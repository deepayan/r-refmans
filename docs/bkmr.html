<!DOCTYPE html><html lang="en"><head><title>Help for package bkmr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bkmr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ComputePostmeanHnew'><p>Compute the posterior mean and variance of <code>h</code> at a new predictor values</p></a></li>
<li><a href='#ExtractEsts'><p>Extract summary statistics</p></a></li>
<li><a href='#ExtractPIPs'><p>Extract posterior inclusion probabilities (PIPs) from BKMR model fit</p></a></li>
<li><a href='#ExtractSamps'><p>Extract samples</p></a></li>
<li><a href='#InvestigatePrior'><p>Investigate prior</p></a></li>
<li><a href='#kmbayes'><p>Fit Bayesian kernel machine regression</p></a></li>
<li><a href='#OverallRiskSummaries'><p>Calculate overall risk summaries</p></a></li>
<li><a href='#PlotPriorFits'><p>Plot of exposure-response function from univariate KMR fit</p></a></li>
<li><a href='#PredictorResponseBivar'><p>Predict the exposure-response function at a new grid of points</p></a></li>
<li><a href='#PredictorResponseBivarLevels'><p>Plot cross-sections of the bivariate predictor-response function</p></a></li>
<li><a href='#PredictorResponseBivarPair'><p>Plot bivariate predictor-response function on a new grid of points</p></a></li>
<li><a href='#PredictorResponseUnivar'><p>Plot univariate predictor-response function on a new grid of points</p></a></li>
<li><a href='#print.bkmrfit'><p>Print basic summary of BKMR model fit</p></a></li>
<li><a href='#SamplePred'><p>Obtain posterior samples of predictions at new points</p></a></li>
<li><a href='#SimData'><p>Simulate dataset</p></a></li>
<li><a href='#SingVarIntSummaries'><p>Single Variable Interaction Summaries</p></a></li>
<li><a href='#SingVarRiskSummaries'><p>Single Variable Risk Summaries</p></a></li>
<li><a href='#summary.bkmrfit'><p>Summarizing BKMR model fits</p></a></li>
<li><a href='#TracePlot'><p>Trace plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian Kernel Machine Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of a statistical approach 
  for estimating the joint health effects of multiple 
  concurrent exposures, as described in Bobb et al (2015) 
  &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxu058">doi:10.1093/biostatistics/kxu058</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jenfb/bkmr">https://github.com/jenfb/bkmr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jenfb/bkmr/issues">https://github.com/jenfb/bkmr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, magrittr, nlme, fields, truncnorm, tidyr, MASS,
tmvtnorm, tibble</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-25 03:14:48 UTC; jenniferbobb</td>
</tr>
<tr>
<td>Author:</td>
<td>Jennifer F. Bobb [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jennifer F. Bobb &lt;jenniferfederbobb@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-28 07:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='ComputePostmeanHnew'>Compute the posterior mean and variance of <code>h</code> at a new predictor values</h2><span id='topic+ComputePostmeanHnew'></span>

<h3>Description</h3>

<p>Compute the posterior mean and variance of <code>h</code> at a new predictor values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputePostmeanHnew(
  fit,
  y = NULL,
  Z = NULL,
  X = NULL,
  Znew = NULL,
  sel = NULL,
  method = "approx"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ComputePostmeanHnew_+3A_fit">fit</code></td>
<td>
<p>An object containing the results returned by a the <code>kmbayes</code> function</p>
</td></tr>
<tr><td><code id="ComputePostmeanHnew_+3A_y">y</code></td>
<td>
<p>a vector of outcome data of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="ComputePostmeanHnew_+3A_z">Z</code></td>
<td>
<p>an <code>n</code>-by-<code>M</code> matrix of predictor variables to be included in the <code>h</code> function. Each row represents an observation and each column represents an predictor.</p>
</td></tr>
<tr><td><code id="ComputePostmeanHnew_+3A_x">X</code></td>
<td>
<p>an <code>n</code>-by-<code>K</code> matrix of covariate data where each row represents an observation and each column represents a covariate. Should not contain an intercept column.</p>
</td></tr>
<tr><td><code id="ComputePostmeanHnew_+3A_znew">Znew</code></td>
<td>
<p>matrix of new predictor values at which to predict new <code>h</code>, where each row represents a new observation. If set to NULL then will default to using the observed exposures Z.</p>
</td></tr>
<tr><td><code id="ComputePostmeanHnew_+3A_sel">sel</code></td>
<td>
<p>selects which iterations of the MCMC sampler to use for inference; see details</p>
</td></tr>
<tr><td><code id="ComputePostmeanHnew_+3A_method">method</code></td>
<td>
<p>method for obtaining posterior summaries at a vector of new points. Options are &quot;approx&quot; and &quot;exact&quot;; defaults to &quot;approx&quot;, which is faster particularly for large datasets; see details</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If <code>method == "approx"</code>, the argument <code>sel</code> defaults to the second half of the MCMC iterations.
</p>
</li>
<li><p> If <code>method == "exact"</code>, the argument <code>sel</code> defaults to keeping every 10 iterations after dropping the first 50% of samples, or if this results in fewer than 100 iterations, than 100 iterations are kept
</p>
</li></ul>

<p>For guided examples and additional information, go to <a href="https://jenfb.github.io/bkmr/overview.html">https://jenfb.github.io/bkmr/overview.html</a>
</p>


<h3>Value</h3>

<p>a list of length two containing the posterior mean vector and posterior variance matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)

med_vals &lt;- apply(Z, 2, median)
Znew &lt;- matrix(med_vals, nrow = 1)
h_true &lt;- dat$HFun(Znew)
h_est1 &lt;- ComputePostmeanHnew(fitkm, Znew = Znew, method = "approx")
h_est2 &lt;- ComputePostmeanHnew(fitkm, Znew = Znew, method = "exact")
</code></pre>

<hr>
<h2 id='ExtractEsts'>Extract summary statistics</h2><span id='topic+ExtractEsts'></span>

<h3>Description</h3>

<p>Obtain summary statistics of each parameter from the BKMR fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractEsts(fit, q = c(0.025, 0.25, 0.5, 0.75, 0.975), sel = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExtractEsts_+3A_fit">fit</code></td>
<td>
<p>An object containing the results returned by a the <code>kmbayes</code> function</p>
</td></tr>
<tr><td><code id="ExtractEsts_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="ExtractEsts_+3A_sel">sel</code></td>
<td>
<p>logical expression indicating samples to keep; defaults to keeping the second half of all samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list where each component is a data frame containing the summary statistics of the posterior distribution of one of the parameters (or vector of parameters) being estimated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)

ests &lt;- ExtractEsts(fitkm)
names(ests)
ests$beta
</code></pre>

<hr>
<h2 id='ExtractPIPs'>Extract posterior inclusion probabilities (PIPs) from BKMR model fit</h2><span id='topic+ExtractPIPs'></span>

<h3>Description</h3>

<p>Extract posterior inclusion probabilities (PIPs) from Bayesian Kernel Machine Regression (BKMR) model fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractPIPs(fit, sel = NULL, z.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExtractPIPs_+3A_fit">fit</code></td>
<td>
<p>An object containing the results returned by a the <code>kmbayes</code> function</p>
</td></tr>
<tr><td><code id="ExtractPIPs_+3A_sel">sel</code></td>
<td>
<p>logical expression indicating samples to keep; defaults to keeping the second half of all samples</p>
</td></tr>
<tr><td><code id="ExtractPIPs_+3A_z.names">z.names</code></td>
<td>
<p>optional argument providing the names of the variables included in the <code>h</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For guided examples, go to <a href="https://jenfb.github.io/bkmr/overview.html">https://jenfb.github.io/bkmr/overview.html</a>
</p>


<h3>Value</h3>

<p>a data frame with the variable-specific PIPs for BKMR fit with component-wise variable selection, and with the group-specific and conditional (within-group) PIPs for BKMR fit with hierarchical variable selection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)

ExtractPIPs(fitkm)
</code></pre>

<hr>
<h2 id='ExtractSamps'>Extract samples</h2><span id='topic+ExtractSamps'></span>

<h3>Description</h3>

<p>Extract samples of each parameter from the BKMR fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractSamps(fit, sel = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExtractSamps_+3A_fit">fit</code></td>
<td>
<p>An object containing the results returned by a the <code>kmbayes</code> function</p>
</td></tr>
<tr><td><code id="ExtractSamps_+3A_sel">sel</code></td>
<td>
<p>logical expression indicating samples to keep; defaults to keeping the second half of all samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list where each component contains the posterior samples of one of the parameters (or vector of parameters) being estimated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)

samps &lt;- ExtractSamps(fitkm)
</code></pre>

<hr>
<h2 id='InvestigatePrior'>Investigate prior</h2><span id='topic+InvestigatePrior'></span>

<h3>Description</h3>

<p>Investigate the impact of the <code>r[m]</code> parameters on the smoothness of the exposure-response function <code>h(z[m])</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InvestigatePrior(
  y,
  Z,
  X,
  ngrid = 50,
  q.seq = c(2, 1, 1/2, 1/4, 1/8, 1/16),
  r.seq = NULL,
  Drange = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InvestigatePrior_+3A_y">y</code></td>
<td>
<p>a vector of outcome data of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="InvestigatePrior_+3A_z">Z</code></td>
<td>
<p>an <code>n</code>-by-<code>M</code> matrix of predictor variables to be included in the <code>h</code> function. Each row represents an observation and each column represents an predictor.</p>
</td></tr>
<tr><td><code id="InvestigatePrior_+3A_x">X</code></td>
<td>
<p>an <code>n</code>-by-<code>K</code> matrix of covariate data where each row represents an observation and each column represents a covariate. Should not contain an intercept column.</p>
</td></tr>
<tr><td><code id="InvestigatePrior_+3A_ngrid">ngrid</code></td>
<td>
<p>Number of grid points over which to plot the exposure-response function</p>
</td></tr>
<tr><td><code id="InvestigatePrior_+3A_q.seq">q.seq</code></td>
<td>
<p>Sequence of values corresponding to different degrees of smoothness in the estimated exposure-response function. A value of q corresponds to fractions of the range of the data over which there is a decay in the correlation <code>cor(h[i],h[j])</code> between two subjects by 50<code>%</code>.</p>
</td></tr>
<tr><td><code id="InvestigatePrior_+3A_r.seq">r.seq</code></td>
<td>
<p>sequence of values at which to fix <code>r</code> for estimating the exposure-response function</p>
</td></tr>
<tr><td><code id="InvestigatePrior_+3A_drange">Drange</code></td>
<td>
<p>the range of the <code>z_m</code> data over which to apply the values of <code>q.seq</code>. If not specified, will be calculated as the maximum of the ranges of <code>z_1</code> through <code>z_M</code>.</p>
</td></tr>
<tr><td><code id="InvestigatePrior_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE: flag indicating whether to print to the screen which exposure variable and q value has been completed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For guided examples, go to <a href="https://jenfb.github.io/bkmr/overview.html">https://jenfb.github.io/bkmr/overview.html</a>
</p>


<h3>Value</h3>

<p>a list containing the predicted values, residuals, and estimated predictor-response function for each degree of smoothness being considered
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

priorfits &lt;- InvestigatePrior(y = y, Z = Z, X = X, q.seq = c(2, 1/2, 1/4, 1/16))
PlotPriorFits(y = y, Z = Z, X = X, fits = priorfits)
</code></pre>

<hr>
<h2 id='kmbayes'>Fit Bayesian kernel machine regression</h2><span id='topic+kmbayes'></span>

<h3>Description</h3>

<p>Fits the Bayesian kernel machine regression (BKMR) model using Markov chain Monte Carlo (MCMC) methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmbayes(
  y,
  Z,
  X = NULL,
  iter = 1000,
  family = "gaussian",
  id = NULL,
  verbose = TRUE,
  Znew = NULL,
  starting.values = NULL,
  control.params = NULL,
  varsel = FALSE,
  groups = NULL,
  knots = NULL,
  ztest = NULL,
  rmethod = "varying",
  est.h = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmbayes_+3A_y">y</code></td>
<td>
<p>a vector of outcome data of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_z">Z</code></td>
<td>
<p>an <code>n</code>-by-<code>M</code> matrix of predictor variables to be included in the <code>h</code> function. Each row represents an observation and each column represents an predictor.</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_x">X</code></td>
<td>
<p>an <code>n</code>-by-<code>K</code> matrix of covariate data where each row represents an observation and each column represents a covariate. Should not contain an intercept column.</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_iter">iter</code></td>
<td>
<p>number of iterations to run the sampler</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be used in the model. Currently implemented for <code>gaussian</code> and <code>binomial</code> families.</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_id">id</code></td>
<td>
<p>optional vector (of length <code>n</code>) of grouping factors for fitting a model with a random intercept. If NULL then no random intercept will be included.</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE: flag indicating whether to print intermediate diagnostic information during the model fitting.</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_znew">Znew</code></td>
<td>
<p>optional matrix of new predictor values at which to predict <code>h</code>, where each row represents a new observation. This will slow down the model fitting, and can be done as a post-processing step using <code><a href="#topic+SamplePred">SamplePred</a></code></p>
</td></tr>
<tr><td><code id="kmbayes_+3A_starting.values">starting.values</code></td>
<td>
<p>list of starting values for each parameter. If not specified default values will be chosen.</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_control.params">control.params</code></td>
<td>
<p>list of parameters specifying the prior distributions and tuning parameters for the MCMC algorithm. If not specified default values will be chosen.</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_varsel">varsel</code></td>
<td>
<p>TRUE or FALSE: indicator for whether to conduct variable selection on the Z variables in <code>h</code></p>
</td></tr>
<tr><td><code id="kmbayes_+3A_groups">groups</code></td>
<td>
<p>optional vector (of length <code>M</code>) of group indicators for fitting hierarchical variable selection if varsel=TRUE. If varsel=TRUE without group specification, component-wise variable selections will be performed.</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_knots">knots</code></td>
<td>
<p>optional matrix of knot locations for implementing the Gaussian predictive process of Banerjee et al. (2008). Currently only implemented for models without a random intercept.</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_ztest">ztest</code></td>
<td>
<p>optional vector indicating on which variables in Z to conduct variable selection (the remaining variables will be forced into the model).</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_rmethod">rmethod</code></td>
<td>
<p>for those predictors being forced into the <code>h</code> function, the method for sampling the <code>r[m]</code> values. Takes the value of 'varying' to allow separate <code>r[m]</code> for each predictor; 'equal' to force the same <code>r[m]</code> for each predictor; or 'fixed' to fix the <code>r[m]</code> to their starting values</p>
</td></tr>
<tr><td><code id="kmbayes_+3A_est.h">est.h</code></td>
<td>
<p>TRUE or FALSE: indicator for whether to sample from the posterior distribution of the subject-specific effects h_i within the main sampler. This will slow down the model fitting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;bkmrfit&quot; (containing the posterior samples from the model fit), which has the associated methods:
</p>

<ul>
<li> <p><code><a href="base.html#topic+print">print</a></code> (i.e., <code><a href="#topic+print.bkmrfit">print.bkmrfit</a></code>) 
</p>
</li>
<li> <p><code><a href="base.html#topic+summary">summary</a></code> (i.e., <code><a href="#topic+summary.bkmrfit">summary.bkmrfit</a></code>)
</p>
</li></ul>



<h3>References</h3>

<p>Bobb, JF, Valeri L, Claus Henn B, Christiani DC, Wright RO, Mazumdar M, Godleski JJ, Coull BA (2015). Bayesian Kernel Machine Regression for Estimating the Health Effects of Multi-Pollutant Mixtures. Biostatistics 16, no. 3: 493-508.
</p>
<p>Banerjee S, Gelfand AE, Finley AO, Sang H (2008). Gaussian predictive process models for large spatial data sets. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 70(4), 825-848.
</p>


<h3>See Also</h3>

<p>For guided examples, go to <a href="https://jenfb.github.io/bkmr/overview.html">https://jenfb.github.io/bkmr/overview.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)
</code></pre>

<hr>
<h2 id='OverallRiskSummaries'>Calculate overall risk summaries</h2><span id='topic+OverallRiskSummaries'></span>

<h3>Description</h3>

<p>Compare estimated <code>h</code> function when all predictors are at a particular quantile to when all are at a second fixed quantile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OverallRiskSummaries(
  fit,
  y = NULL,
  Z = NULL,
  X = NULL,
  qs = seq(0.25, 0.75, by = 0.05),
  q.fixed = 0.5,
  method = "approx",
  sel = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OverallRiskSummaries_+3A_fit">fit</code></td>
<td>
<p>An object containing the results returned by a the <code>kmbayes</code> function</p>
</td></tr>
<tr><td><code id="OverallRiskSummaries_+3A_y">y</code></td>
<td>
<p>a vector of outcome data of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="OverallRiskSummaries_+3A_z">Z</code></td>
<td>
<p>an <code>n</code>-by-<code>M</code> matrix of predictor variables to be included in the <code>h</code> function. Each row represents an observation and each column represents an predictor.</p>
</td></tr>
<tr><td><code id="OverallRiskSummaries_+3A_x">X</code></td>
<td>
<p>an <code>n</code>-by-<code>K</code> matrix of covariate data where each row represents an observation and each column represents a covariate. Should not contain an intercept column.</p>
</td></tr>
<tr><td><code id="OverallRiskSummaries_+3A_qs">qs</code></td>
<td>
<p>vector of quantiles at which to calculate the overall risk summary</p>
</td></tr>
<tr><td><code id="OverallRiskSummaries_+3A_q.fixed">q.fixed</code></td>
<td>
<p>a second quantile at which to compare the estimated <code>h</code> function</p>
</td></tr>
<tr><td><code id="OverallRiskSummaries_+3A_method">method</code></td>
<td>
<p>method for obtaining posterior summaries at a vector of new points. Options are &quot;approx&quot; and &quot;exact&quot;; defaults to &quot;approx&quot;, which is faster particularly for large datasets; see details</p>
</td></tr>
<tr><td><code id="OverallRiskSummaries_+3A_sel">sel</code></td>
<td>
<p>selects which iterations of the MCMC sampler to use for inference; see details</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If <code>method == "approx"</code>, the argument <code>sel</code> defaults to the second half of the MCMC iterations.
</p>
</li>
<li><p> If <code>method == "exact"</code>, the argument <code>sel</code> defaults to keeping every 10 iterations after dropping the first 50% of samples, or if this results in fewer than 100 iterations, than 100 iterations are kept
</p>
</li></ul>

<p>For guided examples and additional information, go to <a href="https://jenfb.github.io/bkmr/overview.html">https://jenfb.github.io/bkmr/overview.html</a>
</p>


<h3>Value</h3>

<p>a data frame containing the (posterior mean) estimate and posterior standard deviation of the overall risk measures
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)

risks.overall &lt;- OverallRiskSummaries(fit = fitkm, qs = seq(0.25, 0.75, by = 0.05), 
q.fixed = 0.5, method = "exact")
</code></pre>

<hr>
<h2 id='PlotPriorFits'>Plot of exposure-response function from univariate KMR fit</h2><span id='topic+PlotPriorFits'></span>

<h3>Description</h3>

<p>Plot the estimated <code>h(z[m])</code> estimated from frequentist KMR for <code>r[m]</code> fixed to specific values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPriorFits(
  y,
  X,
  Z,
  fits,
  which.z = NULL,
  which.q = NULL,
  plot.resid = TRUE,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotPriorFits_+3A_y">y</code></td>
<td>
<p>a vector of outcome data of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="PlotPriorFits_+3A_x">X</code></td>
<td>
<p>an <code>n</code>-by-<code>K</code> matrix of covariate data where each row represents an observation and each column represents a covariate. Should not contain an intercept column.</p>
</td></tr>
<tr><td><code id="PlotPriorFits_+3A_z">Z</code></td>
<td>
<p>an <code>n</code>-by-<code>M</code> matrix of predictor variables to be included in the <code>h</code> function. Each row represents an observation and each column represents an predictor.</p>
</td></tr>
<tr><td><code id="PlotPriorFits_+3A_fits">fits</code></td>
<td>
<p>output from <code><a href="#topic+InvestigatePrior">InvestigatePrior</a></code></p>
</td></tr>
<tr><td><code id="PlotPriorFits_+3A_which.z">which.z</code></td>
<td>
<p>which predictors (columns in <code>Z</code>) to plot</p>
</td></tr>
<tr><td><code id="PlotPriorFits_+3A_which.q">which.q</code></td>
<td>
<p>which q.values to plot; defaults to all possible</p>
</td></tr>
<tr><td><code id="PlotPriorFits_+3A_plot.resid">plot.resid</code></td>
<td>
<p>whether to plot the data points</p>
</td></tr>
<tr><td><code id="PlotPriorFits_+3A_ylim">ylim</code></td>
<td>
<p>plotting limits for the y-axis</p>
</td></tr>
<tr><td><code id="PlotPriorFits_+3A_...">...</code></td>
<td>
<p>other plotting arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, generates plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

priorfits &lt;- InvestigatePrior(y = y, Z = Z, X = X, q.seq = c(2, 1/2, 1/4, 1/16))
PlotPriorFits(y = y, Z = Z, X = X, fits = priorfits)
</code></pre>

<hr>
<h2 id='PredictorResponseBivar'>Predict the exposure-response function at a new grid of points</h2><span id='topic+PredictorResponseBivar'></span>

<h3>Description</h3>

<p>Predict the exposure-response function at a new grid of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredictorResponseBivar(
  fit,
  y = NULL,
  Z = NULL,
  X = NULL,
  z.pairs = NULL,
  method = "approx",
  ngrid = 50,
  q.fixed = 0.5,
  sel = NULL,
  min.plot.dist = 0.5,
  center = TRUE,
  z.names = colnames(Z),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PredictorResponseBivar_+3A_fit">fit</code></td>
<td>
<p>An object containing the results returned by a the <code>kmbayes</code> function</p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_y">y</code></td>
<td>
<p>a vector of outcome data of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_z">Z</code></td>
<td>
<p>an <code>n</code>-by-<code>M</code> matrix of predictor variables to be included in the <code>h</code> function. Each row represents an observation and each column represents an predictor.</p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_x">X</code></td>
<td>
<p>an <code>n</code>-by-<code>K</code> matrix of covariate data where each row represents an observation and each column represents a covariate. Should not contain an intercept column.</p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_z.pairs">z.pairs</code></td>
<td>
<p>data frame showing which pairs of predictors to plot</p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_method">method</code></td>
<td>
<p>method for obtaining posterior summaries at a vector of new points. Options are &quot;approx&quot; and &quot;exact&quot;; defaults to &quot;approx&quot;, which is faster particularly for large datasets; see details</p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_ngrid">ngrid</code></td>
<td>
<p>number of grid points in each dimension</p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_q.fixed">q.fixed</code></td>
<td>
<p>vector of quantiles at which to fix the remaining predictors in <code>Z</code></p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_sel">sel</code></td>
<td>
<p>logical expression indicating samples to keep; defaults to keeping the second half of all samples</p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_min.plot.dist">min.plot.dist</code></td>
<td>
<p>specifies a minimum distance that a new grid point needs to be from an observed data point in order to compute the prediction; points further than this will not be computed</p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_center">center</code></td>
<td>
<p>flag for whether to scale the exposure-response function to have mean zero</p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_z.names">z.names</code></td>
<td>
<p>optional vector of names for the columns of <code>z</code></p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE: flag of whether to print intermediate output to the screen</p>
</td></tr>
<tr><td><code id="PredictorResponseBivar_+3A_...">...</code></td>
<td>
<p>other arguments to pass on to the prediction function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For guided examples, go to <a href="https://jenfb.github.io/bkmr/overview.html">https://jenfb.github.io/bkmr/overview.html</a>
</p>


<h3>Value</h3>

<p>a long data frame with the name of the first predictor, the name of the second predictor, the value of the first predictor, the value of the second predictor, the posterior mean estimate, and the posterior standard deviation of the estimated exposure response function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)

## Obtain predicted value on new grid of points for each pair of predictors
## Using only a 10-by-10 point grid to make example run quickly
pred.resp.bivar &lt;- PredictorResponseBivar(fit = fitkm, min.plot.dist = 1, ngrid = 10)

</code></pre>

<hr>
<h2 id='PredictorResponseBivarLevels'>Plot cross-sections of the bivariate predictor-response function</h2><span id='topic+PredictorResponseBivarLevels'></span>

<h3>Description</h3>

<p>Function to plot the <code>h</code> function of a particular variable at different levels (quantiles) of a second variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredictorResponseBivarLevels(
  pred.resp.df,
  Z = NULL,
  qs = c(0.25, 0.5, 0.75),
  both_pairs = TRUE,
  z.names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PredictorResponseBivarLevels_+3A_pred.resp.df">pred.resp.df</code></td>
<td>
<p>object obtained from running the function <code><a href="#topic+PredictorResponseBivar">PredictorResponseBivar</a></code></p>
</td></tr>
<tr><td><code id="PredictorResponseBivarLevels_+3A_z">Z</code></td>
<td>
<p>an <code>n</code>-by-<code>M</code> matrix of predictor variables to be included in the <code>h</code> function. Each row represents an observation and each column represents an predictor.</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarLevels_+3A_qs">qs</code></td>
<td>
<p>vector of quantiles at which to fix the second variable</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarLevels_+3A_both_pairs">both_pairs</code></td>
<td>
<p>flag indicating whether, if <code>h(z1)</code> is being plotted for z2 fixed at different levels, that they should be plotted in the reverse order as well (for <code>h(z2)</code> at different levels of z1)</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarLevels_+3A_z.names">z.names</code></td>
<td>
<p>optional vector of names for the columns of <code>z</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For guided examples, go to <a href="https://jenfb.github.io/bkmr/overview.html">https://jenfb.github.io/bkmr/overview.html</a>
</p>


<h3>Value</h3>

<p>a long data frame with the name of the first predictor, the name of the second predictor, the value of the first predictor, the quantile at which the second predictor is fixed, the posterior mean estimate, and the posterior standard deviation of the estimated exposure response function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)

## Obtain predicted value on new grid of points for each pair of predictors
## Using only a 10-by-10 point grid to make example run quickly
pred.resp.bivar &lt;- PredictorResponseBivar(fit = fitkm, min.plot.dist = 1, ngrid = 10)
pred.resp.bivar.levels &lt;- PredictorResponseBivarLevels(pred.resp.df = pred.resp.bivar, 
Z = Z, qs = c(0.1, 0.5, 0.9))
</code></pre>

<hr>
<h2 id='PredictorResponseBivarPair'>Plot bivariate predictor-response function on a new grid of points</h2><span id='topic+PredictorResponseBivarPair'></span>

<h3>Description</h3>

<p>Plot bivariate predictor-response function on a new grid of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredictorResponseBivarPair(
  fit,
  y = NULL,
  Z = NULL,
  X = NULL,
  whichz1 = 1,
  whichz2 = 2,
  whichz3 = NULL,
  method = "approx",
  prob = 0.5,
  q.fixed = 0.5,
  sel = NULL,
  ngrid = 50,
  min.plot.dist = 0.5,
  center = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PredictorResponseBivarPair_+3A_fit">fit</code></td>
<td>
<p>An object containing the results returned by a the <code>kmbayes</code> function</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_y">y</code></td>
<td>
<p>a vector of outcome data of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_z">Z</code></td>
<td>
<p>an <code>n</code>-by-<code>M</code> matrix of predictor variables to be included in the <code>h</code> function. Each row represents an observation and each column represents an predictor.</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_x">X</code></td>
<td>
<p>an <code>n</code>-by-<code>K</code> matrix of covariate data where each row represents an observation and each column represents a covariate. Should not contain an intercept column.</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_whichz1">whichz1</code></td>
<td>
<p>vector identifying the first predictor that (column of <code>Z</code>) should be plotted</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_whichz2">whichz2</code></td>
<td>
<p>vector identifying the second predictor that (column of <code>Z</code>) should be plotted</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_whichz3">whichz3</code></td>
<td>
<p>vector identifying the third predictor that will be set to a pre-specified fixed quantile (determined by <code>prob</code>)</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_method">method</code></td>
<td>
<p>method for obtaining posterior summaries at a vector of new points. Options are &quot;approx&quot; and &quot;exact&quot;; defaults to &quot;approx&quot;, which is faster particularly for large datasets; see details</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_prob">prob</code></td>
<td>
<p>pre-specified quantile to set the third predictor (determined by <code>whichz3</code>); defaults to 0.5 (50th percentile)</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_q.fixed">q.fixed</code></td>
<td>
<p>vector of quantiles at which to fix the remaining predictors in <code>Z</code></p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_sel">sel</code></td>
<td>
<p>logical expression indicating samples to keep; defaults to keeping the second half of all samples</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_ngrid">ngrid</code></td>
<td>
<p>number of grid points to cover the range of each predictor (column in <code>Z</code>)</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_min.plot.dist">min.plot.dist</code></td>
<td>
<p>specifies a minimum distance that a new grid point needs to be from an observed data point in order to compute the prediction; points further than this will not be computed</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_center">center</code></td>
<td>
<p>flag for whether to scale the exposure-response function to have mean zero</p>
</td></tr>
<tr><td><code id="PredictorResponseBivarPair_+3A_...">...</code></td>
<td>
<p>other arguments to pass on to the prediction function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with value of the first predictor, the value of the second predictor, the posterior mean estimate, and the posterior standard deviation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)

## Obtain predicted value on new grid of points
## Using only a 10-by-10 point grid to make example run quickly
pred.resp.bivar12 &lt;- PredictorResponseBivarPair(fit = fitkm, min.plot.dist = 1, ngrid = 10)
</code></pre>

<hr>
<h2 id='PredictorResponseUnivar'>Plot univariate predictor-response function on a new grid of points</h2><span id='topic+PredictorResponseUnivar'></span>

<h3>Description</h3>

<p>Plot univariate predictor-response function on a new grid of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredictorResponseUnivar(
  fit,
  y = NULL,
  Z = NULL,
  X = NULL,
  which.z = 1:ncol(Z),
  method = "approx",
  ngrid = 50,
  q.fixed = 0.5,
  sel = NULL,
  min.plot.dist = Inf,
  center = TRUE,
  z.names = colnames(Z),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PredictorResponseUnivar_+3A_fit">fit</code></td>
<td>
<p>An object containing the results returned by a the <code>kmbayes</code> function</p>
</td></tr>
<tr><td><code id="PredictorResponseUnivar_+3A_y">y</code></td>
<td>
<p>a vector of outcome data of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="PredictorResponseUnivar_+3A_z">Z</code></td>
<td>
<p>an <code>n</code>-by-<code>M</code> matrix of predictor variables to be included in the <code>h</code> function. Each row represents an observation and each column represents an predictor.</p>
</td></tr>
<tr><td><code id="PredictorResponseUnivar_+3A_x">X</code></td>
<td>
<p>an <code>n</code>-by-<code>K</code> matrix of covariate data where each row represents an observation and each column represents a covariate. Should not contain an intercept column.</p>
</td></tr>
<tr><td><code id="PredictorResponseUnivar_+3A_which.z">which.z</code></td>
<td>
<p>vector identifying which predictors (columns of <code>Z</code>) should be plotted</p>
</td></tr>
<tr><td><code id="PredictorResponseUnivar_+3A_method">method</code></td>
<td>
<p>method for obtaining posterior summaries at a vector of new points. Options are &quot;approx&quot; and &quot;exact&quot;; defaults to &quot;approx&quot;, which is faster particularly for large datasets; see details</p>
</td></tr>
<tr><td><code id="PredictorResponseUnivar_+3A_ngrid">ngrid</code></td>
<td>
<p>number of grid points to cover the range of each predictor (column in <code>Z</code>)</p>
</td></tr>
<tr><td><code id="PredictorResponseUnivar_+3A_q.fixed">q.fixed</code></td>
<td>
<p>vector of quantiles at which to fix the remaining predictors in <code>Z</code></p>
</td></tr>
<tr><td><code id="PredictorResponseUnivar_+3A_sel">sel</code></td>
<td>
<p>logical expression indicating samples to keep; defaults to keeping the second half of all samples</p>
</td></tr>
<tr><td><code id="PredictorResponseUnivar_+3A_min.plot.dist">min.plot.dist</code></td>
<td>
<p>specifies a minimum distance that a new grid point needs to be from an observed data point in order to compute the prediction; points further than this will not be computed</p>
</td></tr>
<tr><td><code id="PredictorResponseUnivar_+3A_center">center</code></td>
<td>
<p>flag for whether to scale the exposure-response function to have mean zero</p>
</td></tr>
<tr><td><code id="PredictorResponseUnivar_+3A_z.names">z.names</code></td>
<td>
<p>optional vector of names for the columns of <code>z</code></p>
</td></tr>
<tr><td><code id="PredictorResponseUnivar_+3A_...">...</code></td>
<td>
<p>other arguments to pass on to the prediction function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For guided examples, go to <a href="https://jenfb.github.io/bkmr/overview.html">https://jenfb.github.io/bkmr/overview.html</a>
</p>


<h3>Value</h3>

<p>a long data frame with the predictor name, predictor value, posterior mean estimate, and posterior standard deviation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)
pred.resp.univar &lt;- PredictorResponseUnivar(fit = fitkm)
</code></pre>

<hr>
<h2 id='print.bkmrfit'>Print basic summary of BKMR model fit</h2><span id='topic+print.bkmrfit'></span>

<h3>Description</h3>

<p><code>print</code> method for class &quot;bkmrfit&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bkmrfit'
print(x, digits = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bkmrfit_+3A_x">x</code></td>
<td>
<p>an object of class &quot;bkmrfit&quot;</p>
</td></tr>
<tr><td><code id="print.bkmrfit_+3A_digits">digits</code></td>
<td>
<p>the number of digits to show when printing</p>
</td></tr>
<tr><td><code id="print.bkmrfit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, prints basic summary of fit to console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)
fitkm
</code></pre>

<hr>
<h2 id='SamplePred'>Obtain posterior samples of predictions at new points</h2><span id='topic+SamplePred'></span>

<h3>Description</h3>

<p>Obtains posterior samples of <code>E(Y) = h(Znew) + beta*Xnew</code> or of <code>g^{-1}[E(y)]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SamplePred(
  fit,
  Znew = NULL,
  Xnew = NULL,
  Z = NULL,
  X = NULL,
  y = NULL,
  sel = NULL,
  type = c("link", "response"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SamplePred_+3A_fit">fit</code></td>
<td>
<p>An object containing the results returned by a the <code>kmbayes</code> function</p>
</td></tr>
<tr><td><code id="SamplePred_+3A_znew">Znew</code></td>
<td>
<p>optional matrix of new predictor values at which to predict new <code>h</code>, where each row represents a new observation. If not specified, defaults to using observed Z values</p>
</td></tr>
<tr><td><code id="SamplePred_+3A_xnew">Xnew</code></td>
<td>
<p>optional matrix of new covariate values at which to obtain predictions. If not specified, defaults to using observed X values</p>
</td></tr>
<tr><td><code id="SamplePred_+3A_z">Z</code></td>
<td>
<p>an <code>n</code>-by-<code>M</code> matrix of predictor variables to be included in the <code>h</code> function. Each row represents an observation and each column represents an predictor.</p>
</td></tr>
<tr><td><code id="SamplePred_+3A_x">X</code></td>
<td>
<p>an <code>n</code>-by-<code>K</code> matrix of covariate data where each row represents an observation and each column represents a covariate. Should not contain an intercept column.</p>
</td></tr>
<tr><td><code id="SamplePred_+3A_y">y</code></td>
<td>
<p>a vector of outcome data of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="SamplePred_+3A_sel">sel</code></td>
<td>
<p>A vector selecting which iterations of the BKMR fit should be retained for inference. If not specified, will default to keeping every 10 iterations after dropping the first 50% of samples, or if this results in fewer than 100 iterations, than 100 iterations are kept</p>
</td></tr>
<tr><td><code id="SamplePred_+3A_type">type</code></td>
<td>
<p>whether to make predictions on the scale of the link or of the response; only relevant for the binomial outcome family</p>
</td></tr>
<tr><td><code id="SamplePred_+3A_...">...</code></td>
<td>
<p>other arguments; not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For guided examples, go to <a href="https://jenfb.github.io/bkmr/overview.html">https://jenfb.github.io/bkmr/overview.html</a>
</p>


<h3>Value</h3>

<p>a matrix with the posterior samples at the new points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)

med_vals &lt;- apply(Z, 2, median)
Znew &lt;- matrix(med_vals, nrow = 1)
h_true &lt;- dat$HFun(Znew)
set.seed(111)
samps3 &lt;- SamplePred(fitkm, Znew = Znew, Xnew = cbind(0))
head(samps3)
</code></pre>

<hr>
<h2 id='SimData'>Simulate dataset</h2><span id='topic+SimData'></span>

<h3>Description</h3>

<p>Simulate predictor, covariate, and continuous outcome data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimData(
  n = 100,
  M = 5,
  sigsq.true = 0.5,
  beta.true = 2,
  hfun = 3,
  Zgen = "norm",
  ind = 1:2,
  family = "gaussian"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimData_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="SimData_+3A_m">M</code></td>
<td>
<p>Number of predictor variables to generate</p>
</td></tr>
<tr><td><code id="SimData_+3A_sigsq.true">sigsq.true</code></td>
<td>
<p>Variance of normally distributed residual error</p>
</td></tr>
<tr><td><code id="SimData_+3A_beta.true">beta.true</code></td>
<td>
<p>Coefficient on the covariate</p>
</td></tr>
<tr><td><code id="SimData_+3A_hfun">hfun</code></td>
<td>
<p>An integer from 1 to 3 identifying which predictor-response function to generate</p>
</td></tr>
<tr><td><code id="SimData_+3A_zgen">Zgen</code></td>
<td>
<p>Method for generating the matrix Z of exposure variables, taking one of the values c(&quot;unif&quot;, &quot;norm&quot;, &quot;corr&quot;, &quot;realistic&quot;)</p>
</td></tr>
<tr><td><code id="SimData_+3A_ind">ind</code></td>
<td>
<p>select which predictor(s) will be included in the <code>h</code> function; how many predictors that can be included will depend on which <code>h</code> function is being used.</p>
</td></tr>
<tr><td><code id="SimData_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be used in the model. Currently implemented for <code>gaussian</code> and <code>binomial</code> families.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>hfun = 1</code>: A nonlinear function of the first predictor 
</p>
</li>
<li> <p><code>hfun = 2</code>: A linear function of the first two predictors and their product term
</p>
</li>
<li> <p><code>hfun = 3</code>: A nonlinear and nonadditive function of the first two predictor variables
</p>
</li></ul>



<h3>Value</h3>

<p>a list containing the parameter values and generated variables of the simulated datasets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5)
dat &lt;- SimData()
</code></pre>

<hr>
<h2 id='SingVarIntSummaries'>Single Variable Interaction Summaries</h2><span id='topic+SingVarIntSummaries'></span>

<h3>Description</h3>

<p>Compare the single-predictor health risks when all of the other predictors in Z are fixed to their a specific quantile to when all of the other predictors in Z are fixed to their a second specific quantile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingVarIntSummaries(
  fit,
  y = NULL,
  Z = NULL,
  X = NULL,
  which.z = 1:ncol(Z),
  qs.diff = c(0.25, 0.75),
  qs.fixed = c(0.25, 0.75),
  method = "approx",
  sel = NULL,
  z.names = colnames(Z),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SingVarIntSummaries_+3A_fit">fit</code></td>
<td>
<p>An object containing the results returned by a the <code>kmbayes</code> function</p>
</td></tr>
<tr><td><code id="SingVarIntSummaries_+3A_y">y</code></td>
<td>
<p>a vector of outcome data of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="SingVarIntSummaries_+3A_z">Z</code></td>
<td>
<p>an <code>n</code>-by-<code>M</code> matrix of predictor variables to be included in the <code>h</code> function. Each row represents an observation and each column represents an predictor.</p>
</td></tr>
<tr><td><code id="SingVarIntSummaries_+3A_x">X</code></td>
<td>
<p>an <code>n</code>-by-<code>K</code> matrix of covariate data where each row represents an observation and each column represents a covariate. Should not contain an intercept column.</p>
</td></tr>
<tr><td><code id="SingVarIntSummaries_+3A_which.z">which.z</code></td>
<td>
<p>vector indicating which variables (columns of <code>Z</code>) for which the summary should be computed</p>
</td></tr>
<tr><td><code id="SingVarIntSummaries_+3A_qs.diff">qs.diff</code></td>
<td>
<p>vector indicating the two quantiles at which to compute the single-predictor risk summary</p>
</td></tr>
<tr><td><code id="SingVarIntSummaries_+3A_qs.fixed">qs.fixed</code></td>
<td>
<p>vector indicating the two quantiles at which to fix all of the remaining exposures in <code>Z</code></p>
</td></tr>
<tr><td><code id="SingVarIntSummaries_+3A_method">method</code></td>
<td>
<p>method for obtaining posterior summaries at a vector of new points. Options are &quot;approx&quot; and &quot;exact&quot;; defaults to &quot;approx&quot;, which is faster particularly for large datasets; see details</p>
</td></tr>
<tr><td><code id="SingVarIntSummaries_+3A_sel">sel</code></td>
<td>
<p>logical expression indicating samples to keep; defaults to keeping the second half of all samples</p>
</td></tr>
<tr><td><code id="SingVarIntSummaries_+3A_z.names">z.names</code></td>
<td>
<p>optional vector of names for the columns of <code>z</code></p>
</td></tr>
<tr><td><code id="SingVarIntSummaries_+3A_...">...</code></td>
<td>
<p>other arguments to pass on to the prediction function</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If <code>method == "approx"</code>, the argument <code>sel</code> defaults to the second half of the MCMC iterations.
</p>
</li>
<li><p> If <code>method == "exact"</code>, the argument <code>sel</code> defaults to keeping every 10 iterations after dropping the first 50% of samples, or if this results in fewer than 100 iterations, than 100 iterations are kept
</p>
</li></ul>

<p>For guided examples and additional information, go to <a href="https://jenfb.github.io/bkmr/overview.html">https://jenfb.github.io/bkmr/overview.html</a>
</p>


<h3>Value</h3>

<p>a data frame containing the (posterior mean) estimate and posterior standard deviation of the single-predictor risk measures
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)

risks.int &lt;- SingVarIntSummaries(fit = fitkm, method = "exact")
</code></pre>

<hr>
<h2 id='SingVarRiskSummaries'>Single Variable Risk Summaries</h2><span id='topic+SingVarRiskSummaries'></span>

<h3>Description</h3>

<p>Compute summaries of the risks associated with a change in a single variable in <code>Z</code> from a single level (quantile) to a second level (quantile), for the other variables in <code>Z</code> fixed to a specific level (quantile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingVarRiskSummaries(
  fit,
  y = NULL,
  Z = NULL,
  X = NULL,
  which.z = 1:ncol(Z),
  qs.diff = c(0.25, 0.75),
  q.fixed = c(0.25, 0.5, 0.75),
  method = "approx",
  sel = NULL,
  z.names = colnames(Z),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SingVarRiskSummaries_+3A_fit">fit</code></td>
<td>
<p>An object containing the results returned by a the <code>kmbayes</code> function</p>
</td></tr>
<tr><td><code id="SingVarRiskSummaries_+3A_y">y</code></td>
<td>
<p>a vector of outcome data of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="SingVarRiskSummaries_+3A_z">Z</code></td>
<td>
<p>an <code>n</code>-by-<code>M</code> matrix of predictor variables to be included in the <code>h</code> function. Each row represents an observation and each column represents an predictor.</p>
</td></tr>
<tr><td><code id="SingVarRiskSummaries_+3A_x">X</code></td>
<td>
<p>an <code>n</code>-by-<code>K</code> matrix of covariate data where each row represents an observation and each column represents a covariate. Should not contain an intercept column.</p>
</td></tr>
<tr><td><code id="SingVarRiskSummaries_+3A_which.z">which.z</code></td>
<td>
<p>vector indicating which variables (columns of <code>Z</code>) for which the summary should be computed</p>
</td></tr>
<tr><td><code id="SingVarRiskSummaries_+3A_qs.diff">qs.diff</code></td>
<td>
<p>vector indicating the two quantiles <code>q_1</code> and <code>q_2</code> at which to compute <code>h(z_{q2}) - h(z_{q1})</code></p>
</td></tr>
<tr><td><code id="SingVarRiskSummaries_+3A_q.fixed">q.fixed</code></td>
<td>
<p>vector of quantiles at which to fix the remaining predictors in <code>Z</code></p>
</td></tr>
<tr><td><code id="SingVarRiskSummaries_+3A_method">method</code></td>
<td>
<p>method for obtaining posterior summaries at a vector of new points. Options are &quot;approx&quot; and &quot;exact&quot;; defaults to &quot;approx&quot;, which is faster particularly for large datasets; see details</p>
</td></tr>
<tr><td><code id="SingVarRiskSummaries_+3A_sel">sel</code></td>
<td>
<p>logical expression indicating samples to keep; defaults to keeping the second half of all samples</p>
</td></tr>
<tr><td><code id="SingVarRiskSummaries_+3A_z.names">z.names</code></td>
<td>
<p>optional vector of names for the columns of <code>z</code></p>
</td></tr>
<tr><td><code id="SingVarRiskSummaries_+3A_...">...</code></td>
<td>
<p>other arguments to pass on to the prediction function</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If <code>method == "approx"</code>, the argument <code>sel</code> defaults to the second half of the MCMC iterations.
</p>
</li>
<li><p> If <code>method == "exact"</code>, the argument <code>sel</code> defaults to keeping every 10 iterations after dropping the first 50% of samples, or if this results in fewer than 100 iterations, than 100 iterations are kept
</p>
</li></ul>

<p>For guided examples and additional information, go to <a href="https://jenfb.github.io/bkmr/overview.html">https://jenfb.github.io/bkmr/overview.html</a>
</p>


<h3>Value</h3>

<p>a data frame containing the (posterior mean) estimate and posterior standard deviation of the single-predictor risk measures
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)

risks.singvar &lt;- SingVarRiskSummaries(fit = fitkm, method = "exact")
</code></pre>

<hr>
<h2 id='summary.bkmrfit'>Summarizing BKMR model fits</h2><span id='topic+summary.bkmrfit'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;bkmrfit&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bkmrfit'
summary(
  object,
  q = c(0.025, 0.975),
  digits = 5,
  show_ests = TRUE,
  show_MH = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bkmrfit_+3A_object">object</code></td>
<td>
<p>an object of class &quot;bkmrfit&quot;</p>
</td></tr>
<tr><td><code id="summary.bkmrfit_+3A_q">q</code></td>
<td>
<p>quantiles of posterior distribution to show</p>
</td></tr>
<tr><td><code id="summary.bkmrfit_+3A_digits">digits</code></td>
<td>
<p>the number of digits to show when printing</p>
</td></tr>
<tr><td><code id="summary.bkmrfit_+3A_show_ests">show_ests</code></td>
<td>
<p>logical; if <code>TRUE</code>, prints summary statistics of posterior distribution</p>
</td></tr>
<tr><td><code id="summary.bkmrfit_+3A_show_mh">show_MH</code></td>
<td>
<p>logical; if <code>TRUE</code>, prints acceptance rates from the Metropolis-Hastings algorithm</p>
</td></tr>
<tr><td><code id="summary.bkmrfit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, prints more detailed summary of fit to console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)
summary(fitkm)
</code></pre>

<hr>
<h2 id='TracePlot'>Trace plot</h2><span id='topic+TracePlot'></span>

<h3>Description</h3>

<p>Trace plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TracePlot(
  fit,
  par,
  comp = 1,
  sel = NULL,
  main = "",
  xlab = "iteration",
  ylab = "parameter value",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TracePlot_+3A_fit">fit</code></td>
<td>
<p>An object containing the results returned by a the <code>kmbayes</code> function</p>
</td></tr>
<tr><td><code id="TracePlot_+3A_par">par</code></td>
<td>
<p>which parameter to plot</p>
</td></tr>
<tr><td><code id="TracePlot_+3A_comp">comp</code></td>
<td>
<p>which component of the parameter vector to plot</p>
</td></tr>
<tr><td><code id="TracePlot_+3A_sel">sel</code></td>
<td>
<p>logical expression indicating samples to keep; defaults to keeping the second half of all samples</p>
</td></tr>
<tr><td><code id="TracePlot_+3A_main">main</code></td>
<td>
<p>title</p>
</td></tr>
<tr><td><code id="TracePlot_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="TracePlot_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="TracePlot_+3A_...">...</code></td>
<td>
<p>other arguments to pass onto the plotting function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For guided examples, go to <a href="https://jenfb.github.io/bkmr/overview.html">https://jenfb.github.io/bkmr/overview.html</a>
</p>


<h3>Value</h3>

<p>No return value, generates plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First generate dataset
set.seed(111)
dat &lt;- SimData(n = 50, M = 4)
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

## Fit model with component-wise variable selection
## Using only 100 iterations to make example run quickly
## Typically should use a large number of iterations for inference
set.seed(111)
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 100, verbose = FALSE, varsel = TRUE)

TracePlot(fit = fitkm, par = "beta")
TracePlot(fit = fitkm, par = "sigsq.eps")
TracePlot(fit = fitkm, par = "r", comp = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
