<!DOCTYPE html><html><head><title>Help for package ggparty</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggparty}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autoplot.party'><p>autoplot methods for party objects</p></a></li>
<li><a href='#geom_edge'><p>Draw edges</p></a></li>
<li><a href='#geom_edge_label'><p>Draw edge labels</p></a></li>
<li><a href='#geom_node_label'><p>Draw (multi-line) labels at nodes</p></a></li>
<li><a href='#geom_node_plot'><p>Draw plots at nodes</p></a></li>
<li><a href='#get_predictions'><p>Create data.frame with predictions for each node</p></a></li>
<li><a href='#ggparty'><p>Create a new ggparty plot</p></a></li>
<li><a href='#makeContent.nodeplotgrob'><p>apparantly needs to be exported</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>'ggplot' Visualizations for the 'partykit' Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Copyright:</td>
<td>file inst/COPYRIGHTS</td>
</tr>
<tr>
<td>Description:</td>
<td>Extends 'ggplot2' functionality to the 'partykit' package. 'ggparty' provides the necessary tools to create clearly structured and highly customizable visualizations for tree-objects of the class 'party'.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Borkovec &lt;martin.borkovec@skyforge.at&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), ggplot2, partykit</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, gtable, utils, checkmate, methods, survival, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, mlbench, AER, coin, vdiffr, knitr, rmarkdown,
pander, MASS, TH.data</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/martin-borkovec/ggparty">https://github.com/martin-borkovec/ggparty</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/martin-borkovec/ggparty/issues">https://github.com/martin-borkovec/ggparty/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-07-15 15:14:50 UTC; Martin</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Borkovec [aut, cre],
  Niyaz Madin [aut],
  Hadley Wickham [ctb],
  Winston Chang [ctb],
  Lionel Henry [ctb],
  Thomas Lin Pedersen [ctb],
  Kohske Takahashi [ctb],
  Claus Wilke [ctb],
  Kara Woo [ctb],
  Hiroaki Yutani [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-07-18 10:54:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='autoplot.party'>autoplot methods for party objects</h2><span id='topic+autoplot.party'></span><span id='topic+autoplot.constparty'></span><span id='topic+autoplot.modelparty'></span><span id='topic+autoplot.lmtree'></span>

<h3>Description</h3>

<p>autoplot methods for party objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'party'
autoplot(object, ...)

## S3 method for class 'constparty'
autoplot(object, ...)

## S3 method for class 'modelparty'
autoplot(object, plot_var = NULL, ...)

## S3 method for class 'lmtree'
autoplot(object, plot_var = NULL, show_fit = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.party_+3A_object">object</code></td>
<td>
<p>object of class party.</p>
</td></tr>
<tr><td><code id="autoplot.party_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="autoplot.party_+3A_plot_var">plot_var</code></td>
<td>
<p>Which covariate to plot against response. Defaults to second
column in <code>data</code> of tree.</p>
</td></tr>
<tr><td><code id="autoplot.party_+3A_show_fit">show_fit</code></td>
<td>
<p>If TRUE <code>fitted_values</code> are drawn.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggparty)

data("WeatherPlay", package = "partykit")
sp_o &lt;- partysplit(1L, index = 1:3)
sp_h &lt;- partysplit(3L, breaks = 75)
sp_w &lt;- partysplit(4L, index = 1:2)
pn &lt;- partynode(1L, split = sp_o, kids = list(
  partynode(2L, split = sp_h, kids = list(
    partynode(3L, info = "yes"),
    partynode(4L, info = "no"))),
  partynode(5L, info = "yes"),
  partynode(6L, split = sp_w, kids = list(
    partynode(7L, info = "yes"),
    partynode(8L, info = "no")))))
py &lt;- party(pn, WeatherPlay)

autoplot(py)
</code></pre>

<hr>
<h2 id='geom_edge'>Draw edges</h2><span id='topic+geom_edge'></span>

<h3>Description</h3>

<p>Draws edges between children and parent nodes. Wrapper for <code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge(mapping = NULL, nudge_x = 0, nudge_y = 0, ids = NULL,
  show.legend = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_+3A_mapping">mapping</code></td>
<td>
<p>Mapping of <code>x</code>, <code>y</code>, <code>xend</code> and <code>yend</code> defaults to <code>ids</code>' and
their parent's coordinates. Other mappings can be added here as <code>aes()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_+3A_nudge_x">nudge_x</code>, <code id="geom_edge_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Nudge labels.</p>
</td></tr>
<tr><td><code id="geom_edge_+3A_ids">ids</code></td>
<td>
<p>Choose which edges to draw by their children's ids.</p>
</td></tr>
<tr><td><code id="geom_edge_+3A_show.legend">show.legend</code></td>
<td>
<p><code>logical</code> See <code><a href="ggplot2.html#topic+layer">layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="ggplot2.html#topic+geom_segment">geom_segment()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ggparty">ggparty()</a></code>, <code><a href="#topic+geom_edge">geom_edge()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggparty)
data("WeatherPlay", package = "partykit")
sp_o &lt;- partysplit(1L, index = 1:3)
sp_h &lt;- partysplit(3L, breaks = 75)
sp_w &lt;- partysplit(4L, index = 1:2)
pn &lt;- partynode(1L, split = sp_o, kids = list(
  partynode(2L, split = sp_h, kids = list(
    partynode(3L, info = "yes"),
    partynode(4L, info = "no"))),
  partynode(5L, info = "yes"),
  partynode(6L, split = sp_w, kids = list(
    partynode(7L, info = "yes"),
    partynode(8L, info = "no")))))
py &lt;- party(pn, WeatherPlay)

ggparty(py) +
  geom_edge() +
  geom_edge_label() +
  geom_node_label(aes(label = splitvar),
                  ids = "inner") +
  geom_node_label(aes(label = info),
                  ids = "terminal")
</code></pre>

<hr>
<h2 id='geom_edge_label'>Draw edge labels</h2><span id='topic+geom_edge_label'></span>

<h3>Description</h3>

<p>Label edges with corresponding split breaks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edge_label(mapping = NULL, nudge_x = 0, nudge_y = 0,
  ids = NULL, shift = 0.5, label.size = 0,
  splitlevels = seq_len(100), max_length = NULL, parse_all = FALSE,
  parse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edge_label_+3A_mapping">mapping</code></td>
<td>
<p>Mapping of <code>label</code> label defaults to <strong>breaks_label</strong>. Other
mappings can be added here as <code>aes()</code>.</p>
</td></tr>
<tr><td><code id="geom_edge_label_+3A_nudge_x">nudge_x</code>, <code id="geom_edge_label_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Nudge label.</p>
</td></tr>
<tr><td><code id="geom_edge_label_+3A_ids">ids</code></td>
<td>
<p>Choose which splitbreaks to label by their children's ids.</p>
</td></tr>
<tr><td><code id="geom_edge_label_+3A_shift">shift</code></td>
<td>
<p>Value in (0,1). Moves label along corresponding edge.</p>
</td></tr>
<tr><td><code id="geom_edge_label_+3A_label.size">label.size</code></td>
<td>
<p>See <code><a href="ggplot2.html#topic+geom_label">geom_label()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edge_label_+3A_splitlevels">splitlevels</code></td>
<td>
<p>Which levels of split to plot. This may be useful in the
presence of many factor levels for one split break.</p>
</td></tr>
<tr><td><code id="geom_edge_label_+3A_max_length">max_length</code></td>
<td>
<p>If provided <strong>breaks_label</strong> levels will be truncated to the specified length.</p>
</td></tr>
<tr><td><code id="geom_edge_label_+3A_parse_all">parse_all</code></td>
<td>
<p>Defaults to <code>FALSE</code>, in which case everything but the inequality
signs of <strong>breaks_label</strong> are deparsed. If <code>TRUE</code> complete <strong>breaks_label</strong> are parsed.</p>
</td></tr>
<tr><td><code id="geom_edge_label_+3A_parse">parse</code></td>
<td>
<p>Needs to be true in order to parse inequality signs of <strong>breaks_label</strong>.</p>
</td></tr>
<tr><td><code id="geom_edge_label_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="ggplot2.html#topic+geom_label">geom_label()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ggparty">ggparty()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggparty)
data("WeatherPlay", package = "partykit")
sp_o &lt;- partysplit(1L, index = 1:3)
sp_h &lt;- partysplit(3L, breaks = 75)
sp_w &lt;- partysplit(4L, index = 1:2)
pn &lt;- partynode(1L, split = sp_o, kids = list(
  partynode(2L, split = sp_h, kids = list(
    partynode(3L, info = "yes"),
    partynode(4L, info = "no"))),
  partynode(5L, info = "yes"),
  partynode(6L, split = sp_w, kids = list(
    partynode(7L, info = "yes"),
    partynode(8L, info = "no")))))
py &lt;- party(pn, WeatherPlay)

ggparty(py) +
  geom_edge() +
  geom_edge_label() +
  geom_node_label(aes(label = splitvar),
                  ids = "inner") +
  geom_node_label(aes(label = info),
                  ids = "terminal")
</code></pre>

<hr>
<h2 id='geom_node_label'>Draw (multi-line) labels at nodes</h2><span id='topic+geom_node_label'></span><span id='topic+geom_node_info'></span><span id='topic+geom_node_splitvar'></span>

<h3>Description</h3>

<p><code>geom_node_splitvar()</code> and <code>geom_node_info()</code> are simplified versions of
<code>geom_node_label()</code> with the respective defaults to either label the split variables
for all inner nodes or the info for all terminal nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_node_label(mapping = NULL, data = NULL, line_list = NULL,
  line_gpar = NULL, ids = NULL, position = "identity", ...,
  parse = FALSE, nudge_x = 0, nudge_y = 0,
  label.padding = unit(0.25, "lines"), label.r = unit(0.15, "lines"),
  label.size = 0.25, label.col = NULL, label.fill = NULL,
  na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)

geom_node_info(mapping = NULL, nudge_x = 0, nudge_y = 0,
  ids = NULL, label.padding = unit(0.5, "lines"), ...)

geom_node_splitvar(mapping = NULL, nudge_x = 0, nudge_y = 0,
  label.padding = unit(0.5, "lines"), ids = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_node_label_+3A_mapping">mapping</code></td>
<td>
<p><code>x</code> and <code>y</code> are mapped per default to the node's coordinates. If
you don't want to set line specific graphical parameters, you can also map
<code>label</code> here. Otherwise set <code>labels</code> in <code>line_list</code>.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_line_list">line_list</code></td>
<td>
<p>Use this only if you want a multi-line label with the
possibility to override the aesthetics mapping for each line specifically
with fixed graphical parameters. In this case, don't map anything to
<code>label</code> in the <code>aes()</code> supplied to <code>mapping</code>
, but instead pass here a list of <code>aes()</code> with the <strong>only</strong> mapped variable
in each
being <code>label</code>.
Other aesthetic mappings still can be passed to <code>mapping</code> and will apply to
all lines and the border, unless overwritten by <code>line_gpar</code>.
The order of the list represents the order of the plotted lines.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_line_gpar">line_gpar</code></td>
<td>
<p>List of lists containing line-specific graphical parameters.
Only use in
conjunction with <code>line_list</code>. Has to contain the same number of lists as are
<code>aes()</code> in <code>line_list</code>. First list applies to first line, and so on.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_ids">ids</code></td>
<td>
<p>Select for which nodes to draw a label. Can be <code>"inner"</code>, <code>"terminal"</code>,
<code>"all"</code> or <code>numeric</code> vector of ids.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_...">...</code></td>
<td>
<p>Additional arguments to layer.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions. Can also
be specified per line via <code>line_gpar</code>.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_nudge_x">nudge_x</code>, <code id="geom_node_label_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Adjust position of label.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_label.padding">label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_label.r">label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_label.size">label.size</code></td>
<td>
<p>Size of label border, in mm.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_label.col">label.col</code></td>
<td>
<p>Border colour.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_label.fill">label.fill</code></td>
<td>
<p>Background colour.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_node_label_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>geom_node_label()</code> is a modified version of <code><a href="ggplot2.html#topic+geom_label">ggplot2::geom_label()</a></code>. This
modification allows for labels with multiple lines and line specific graphical
parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggparty">ggparty()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggparty)
data("WeatherPlay", package = "partykit")
sp_o &lt;- partysplit(1L, index = 1:3)
sp_h &lt;- partysplit(3L, breaks = 75)
sp_w &lt;- partysplit(4L, index = 1:2)
pn &lt;- partynode(1L, split = sp_o, kids = list(
  partynode(2L, split = sp_h, kids = list(
    partynode(3L, info = "yes"),
    partynode(4L, info = "no"))),
  partynode(5L, info = "yes"),
  partynode(6L, split = sp_w, kids = list(
    partynode(7L, info = "yes"),
    partynode(8L, info = "no")))))
py &lt;- party(pn, WeatherPlay)

ggparty(py) +
  geom_edge() +
  geom_edge_label() +
  geom_node_label(aes(label = splitvar),
                  ids = "inner") +
  geom_node_label(aes(label = info),
                  ids = "terminal")

######################################

data("TeachingRatings", package = "AER")
tr &lt;- subset(TeachingRatings, credits == "more")

tr_tree &lt;- lmtree(eval ~ beauty | minority + age + gender + division + native +
                   tenure, data = tr, weights = students, caseweights = FALSE)

data("TeachingRatings", package = "AER")
tr &lt;- subset(TeachingRatings, credits == "more")

tr_tree &lt;- lmtree(eval ~ beauty | minority + age + gender + division + native +
                    tenure, data = tr, weights = students, caseweights = FALSE)

ggparty(tr_tree,
        terminal_space = 0.5,
        add_vars = list(p.value = "$node$info$p.value")) +
  geom_edge(size = 1.5) +
  geom_edge_label(colour = "grey", size = 6) +
  geom_node_plot(gglist = list(geom_point(aes(x = beauty,
                                              y = eval,
                                              col = tenure,
                                              shape = minority),
                                          alpha = 0.8),
                               theme_bw(base_size = 15)),
                 scales = "fixed",
                 id = "terminal",
                 shared_axis_labels = TRUE,
                 shared_legend = TRUE,
                 legend_separator = TRUE,
                 predict = "beauty",
                 predict_gpar = list(col = "blue",
                                    size = 1.2)
  ) +
  geom_node_label(aes(col = splitvar),
                  line_list = list(aes(label = paste("Node", id)),
                                   aes(label = splitvar),
                                   aes(label = paste("p =", formatC(p.value,
                                    format = "e", digits = 2)))),
                  line_gpar = list(list(size = 12, col = "black", fontface = "bold"),
                                   list(size = 20),
                                   list(size = 12)),
                  ids = "inner") +
  geom_node_label(aes(label = paste0("Node ", id, ", N = ", nodesize)),
                  fontface = "bold",
                  ids = "terminal",
                  size = 5,
                  nudge_y = 0.01) +
  theme(legend.position = "none")
</code></pre>

<hr>
<h2 id='geom_node_plot'>Draw plots at nodes</h2><span id='topic+geom_node_plot'></span>

<h3>Description</h3>

<p>Additional component for a <code><a href="#topic+ggparty">ggparty()</a></code> that allows to create in each node a
ggplot with its data. #'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_node_plot(plot_call = "ggplot", gglist = NULL, width = 1,
  height = 1, size = 1, ids = "terminal", scales = "fixed",
  nudge_x = 0, nudge_y = 0, shared_axis_labels = FALSE,
  shared_legend = TRUE, predict = NULL, predict_gpar = NULL,
  legend_separator = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_node_plot_+3A_plot_call">plot_call</code></td>
<td>
<p>Any function that generates a <code>ggplot2</code> object.</p>
</td></tr>
<tr><td><code id="geom_node_plot_+3A_gglist">gglist</code></td>
<td>
<p>List of additional <code>gg</code> components. Columns of <code>data</code> of nodes can be
mapped. Additionally <code>fitted_values</code> and <code>residuals</code> can be mapped if present in
<code>party</code> of <code>ggparty()</code></p>
</td></tr>
<tr><td><code id="geom_node_plot_+3A_width">width</code></td>
<td>
<p>Expansion factor for viewport's width.</p>
</td></tr>
<tr><td><code id="geom_node_plot_+3A_height">height</code></td>
<td>
<p>Expansion factor for viewport's height.</p>
</td></tr>
<tr><td><code id="geom_node_plot_+3A_size">size</code></td>
<td>
<p>Expansion factor for viewport's size.</p>
</td></tr>
<tr><td><code id="geom_node_plot_+3A_ids">ids</code></td>
<td>
<p>Id's to plot. Numeric, &quot;terminal&quot;, &quot;inner&quot; or &quot;all&quot;. Defaults
to &quot;terminal&quot;.</p>
</td></tr>
<tr><td><code id="geom_node_plot_+3A_scales">scales</code></td>
<td>
<p>See <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap()</a></code></p>
</td></tr>
<tr><td><code id="geom_node_plot_+3A_nudge_x">nudge_x</code>, <code id="geom_node_plot_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Nudges node plot.</p>
</td></tr>
<tr><td><code id="geom_node_plot_+3A_shared_axis_labels">shared_axis_labels</code></td>
<td>
<p>If TRUE only one pair of axes labels is plotted in
the terminal space. Only recommended if <code>ids</code>  &quot;terminal&quot; or &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="geom_node_plot_+3A_shared_legend">shared_legend</code></td>
<td>
<p>If <code>TRUE</code> one shared legend is plotted at the bottom of
the tree.</p>
</td></tr>
<tr><td><code id="geom_node_plot_+3A_predict">predict</code></td>
<td>
<p>Character string specifying variable for which predictions should be plotted.</p>
</td></tr>
<tr><td><code id="geom_node_plot_+3A_predict_gpar">predict_gpar</code></td>
<td>
<p>Named list containing arguments to be passed to the
<code>geom_line()</code> call of predicted values.</p>
</td></tr>
<tr><td><code id="geom_node_plot_+3A_legend_separator">legend_separator</code></td>
<td>
<p>If <code>TRUE</code> line between legend and tree is drawn.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ggparty">ggparty()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggparty)

airq &lt;- subset(airquality, !is.na(Ozone))
airct &lt;- ctree(Ozone ~ ., data = airq)

ggparty(airct, horizontal = TRUE, terminal_space = 0.6) +
  geom_edge() +
  geom_edge_label() +
  geom_node_splitvar() +
  geom_node_plot(gglist = list(
    geom_density(aes(x = Ozone))),
    shared_axis_labels = TRUE)

#############################################################

## Plot with ggparty


## Demand for economics journals data
data("Journals", package = "AER")
Journals &lt;- transform(Journals,
                      age = 2000 - foundingyear,
                      chars = charpp * pages)

## linear regression tree (OLS)
j_tree &lt;- lmtree(log(subs) ~ log(price/citations) | price + citations +
                   age + chars + society, data = Journals, minsize = 10, verbose = TRUE)

pred_df &lt;- get_predictions(j_tree, ids = "terminal", newdata =  function(x) {
  data.frame(
    citations = 1,
    price = exp(seq(from = min(x$`log(price/citations)`),
                    to = max(x$`log(price/citations)`),
                    length.out = 100)))
})

ggparty(j_tree, terminal_space = 0.8) +
  geom_edge() +
  geom_edge_label() +
  geom_node_splitvar() +
  geom_node_plot(gglist =
                   list(aes(x = `log(price/citations)`, y = `log(subs)`),
                        geom_point(),
                        geom_line(data = pred_df,
                                  aes(x = log(price/citations),
                                      y = prediction),
                                  col = "red")))
</code></pre>

<hr>
<h2 id='get_predictions'>Create data.frame with predictions for each node</h2><span id='topic+get_predictions'></span>

<h3>Description</h3>

<p>Create data.frame with predictions for each node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_predictions(party_object, ids, newdata_fun, predict_arg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_predictions_+3A_party_object">party_object</code></td>
<td>
<p>object of class <code>party</code></p>
</td></tr>
<tr><td><code id="get_predictions_+3A_ids">ids</code></td>
<td>
<p>Id's to plot. Numeric, &quot;terminal&quot;, &quot;inner&quot; or &quot;all&quot;. MUST be identical
to <code>ids</code> of <code><a href="#topic+geom_node_plot">geom_node_plot()</a></code> used to plot this data.</p>
</td></tr>
<tr><td><code id="get_predictions_+3A_newdata_fun">newdata_fun</code></td>
<td>
<p>function which takes <code>data</code> of node and returns <code>newdata</code>
for <code>predict()</code></p>
</td></tr>
<tr><td><code id="get_predictions_+3A_predict_arg">predict_arg</code></td>
<td>
<p>list of additional arguments passed to <code><a href="stats.html#topic+predict">predict()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='ggparty'>Create a new ggparty plot</h2><span id='topic+ggparty'></span>

<h3>Description</h3>

<p><code>ggplot2</code> extension for objects of class <code>party</code>. Creates a <code>data.frame</code> from
an object of class <code>party</code> and calls <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggparty(party, horizontal = FALSE, terminal_space, layout = NULL,
  add_vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggparty_+3A_party">party</code></td>
<td>
<p>Object of class <code>party</code>.</p>
</td></tr>
<tr><td><code id="ggparty_+3A_horizontal">horizontal</code></td>
<td>
<p>If <code>TRUE</code> plot will be horizontal.</p>
</td></tr>
<tr><td><code id="ggparty_+3A_terminal_space">terminal_space</code></td>
<td>
<p>Proportion of the plot that should be reserved for
the terminal nodeplots. Defaults to <code>2 / (depth(party) + 2)</code>.</p>
</td></tr>
<tr><td><code id="ggparty_+3A_layout">layout</code></td>
<td>
<p>Optional layout adjustment. Overwrites the coordinates of the
specified nodes. Must be <code>data.frame</code> containing the
columns <code>id</code>, <code>x</code> and <code>y</code>. With <code>x</code> and <code>y</code> values between 0 and 1.</p>
</td></tr>
<tr><td><code id="ggparty_+3A_add_vars">add_vars</code></td>
<td>
<p>Named list containing either string(s) specifying the locations
of elements to be extracted from
each node of <code>party</code>  or function(s) of corresponding row of plot data and node.
In either case returned object  has to be of length 1.
If the data is supposed to be accessible by <code><a href="#topic+geom_node_plot">geom_node_plot()</a></code> the respective
list entry has
to be named with the prefix <code>"nodedata_"</code> and be a function returning a list
of same length as <code>nodesize</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggparty</code> can be called directly with an object of class <code>party</code>, which will
convert it to a suitable <code>data.frame</code> and pass it to a call to <code>ggplot</code> with as
the <code>data</code> argument. As usual, additional components can then be added with
<code>+</code>.
</p>
<p>The nodes will be spaced equally in the unit square. Specifying
<code>terminal_size</code> allows to increase or decrease the area for plots of the
terminal nodes.
</p>
<p>If one of the list entries supplied to <code>add_vars</code> is a function, it has to take
exactly two arguments,
namely <code>data</code> (the corresponding row of the plot_data data frame) and <code>node</code>
(the corresponding node, i.e. <code>party_object[i]</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_edge">geom_edge()</a></code>, <code><a href="#topic+geom_edge_label">geom_edge_label()</a></code>, <code><a href="#topic+geom_node_label">geom_node_label()</a></code>,
<code><a href="#topic+autoplot.party">autoplot.party()</a></code>, <code><a href="#topic+geom_node_plot">geom_node_plot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggparty)
data("WeatherPlay", package = "partykit")
sp_o &lt;- partysplit(1L, index = 1:3)
sp_h &lt;- partysplit(3L, breaks = 75)
sp_w &lt;- partysplit(4L, index = 1:2)
pn &lt;- partynode(1L, split = sp_o, kids = list(
  partynode(2L, split = sp_h, kids = list(
    partynode(3L, info = "yes"),
    partynode(4L, info = "no"))),
  partynode(5L, info = "yes"),
  partynode(6L, split = sp_w, kids = list(
    partynode(7L, info = "yes"),
    partynode(8L, info = "no")))))
py &lt;- party(pn, WeatherPlay)

ggparty(py) +
  geom_edge() +
  geom_edge_label() +
  geom_node_label(aes(label = splitvar),
                  ids = "inner") +
  geom_node_label(aes(label = info),
                  ids = "terminal")
</code></pre>

<hr>
<h2 id='makeContent.nodeplotgrob'>apparantly needs to be exported</h2><span id='topic+makeContent.nodeplotgrob'></span>

<h3>Description</h3>

<p>apparantly needs to be exported
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nodeplotgrob'
makeContent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeContent.nodeplotgrob_+3A_x">x</code></td>
<td>
<p>nodeplotgrob</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
