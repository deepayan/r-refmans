<!DOCTYPE html><html><head><title>Help for package synr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {synr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#synr-package'><p>synr: Explore and Process Synesthesia Consistency Test Data</p></a></li>
<li><a href='#centroid_3d_sq_dist'><p>Calculate sum of squared 3D point distances from centroid</p></a></li>
<li><a href='#create_grapheme'><p>Create a grapheme instance</p></a></li>
<li><a href='#create_participant'><p>Create a Participant instance.</p></a></li>
<li><a href='#create_participantgroup'><p>Create a ParticipantGroup instance using long-format data</p></a></li>
<li><a href='#create_participantgroup_widedata'><p>Create a ParticipantGroup instance</p></a></li>
<li><a href='#filter_graphemes'><p>Filter graphemes of a single participant</p></a></li>
<li><a href='#Grapheme-class'><p>A Reference Class for representing consistency test graphemes</p></a></li>
<li><a href='#Participant-class'><p>A Reference Class for representing consistency test participants</p></a></li>
<li><a href='#ParticipantGroup-class'><p>A Reference Class for representing a group of consistency test participants</p></a></li>
<li><a href='#point_3d_variance'><p>Calculate sample variance of 3D point distance from centroid</p></a></li>
<li><a href='#synr_exampledf_large'><p>Raw consistency test data example, long format</p></a></li>
<li><a href='#synr_exampledf_long_small'><p>Raw consistency test data example, long format (small)</p></a></li>
<li><a href='#synr_exampledf_wide_small'><p>Raw consistency test data example, wide format (small)</p></a></li>
<li><a href='#total_within_cluster_variance'><p>Calculate Total Within Cluster Variance of 3D points</p></a></li>
<li><a href='#validate_get_twcv'><p>Check if color data are valid and get TWCV</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Explore and Process Synesthesia Consistency Test Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Explore synesthesia
  consistency test data, calculate consistency scores, 
  and classify participant data as valid or invalid.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods (&ge; 3.6), data.table (&ge; 1.12), ggplot2 (&ge; 3.3.0),
dbscan (&ge; 1.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), dplyr (&ge; 1.0.0), knitr, rmarkdown,
tidyr, plotly</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://datalowe.github.io/synr/">https://datalowe.github.io/synr/</a>, <a href="https://github.com/datalowe/synr">https://github.com/datalowe/synr</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-13 12:12:52 UTC; lowe</td>
</tr>
<tr>
<td>Author:</td>
<td>Lowe Wilsson [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lowe Wilsson &lt;datalowe@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-13 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='synr-package'>synr: Explore and Process Synesthesia Consistency Test Data</h2><span id='topic+synr'></span><span id='topic+synr-package'></span>

<h3>Description</h3>

<p>synr helps you work with data resulting from grapheme-color consistency tests for synesthesia.
</p>
<p>To learn more about synr, start with the vignettes:
<code style="white-space: pre;">&#8288;browseVignettes(package = "synr")&#8288;</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lowe Wilsson <a href="mailto:datalowe@posteo.de">datalowe@posteo.de</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://datalowe.github.io/synr/">https://datalowe.github.io/synr/</a>
</p>
</li>
<li> <p><a href="https://github.com/datalowe/synr">https://github.com/datalowe/synr</a>
</p>
</li></ul>


<hr>
<h2 id='centroid_3d_sq_dist'>Calculate sum of squared 3D point distances from centroid</h2><span id='topic+centroid_3d_sq_dist'></span>

<h3>Description</h3>

<p>Calculates sum of squared point distances in
3D space betweeen points and their centroid.
</p>
<p style="text-align: center;"><code class="reqn">
\frac{
\sum_{i=1}^n (x_i-x_m)^2 + (y_i-y_m)^2 + (z-z_m)^2
}{
sum_(i=1)^n ((x - x_m)^2 + (y - y_m)^2 + (z - z_m)^2)
}
</code>
</p>

<p>Where <code class="reqn">X/Y/Z</code> represent one axis each, <code class="reqn">a_m</code> represents the mean
of all points' coordinates on an axis, and <code class="reqn">n</code> represents the total
number of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid_3d_sq_dist(point_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroid_3d_sq_dist_+3A_point_matrix">point_matrix</code></td>
<td>
<p>An n-by-3 numerical matrix where each
row corresponds to a single point in 3D space.</p>
</td></tr>
</table>

<hr>
<h2 id='create_grapheme'>Create a grapheme instance</h2><span id='topic+create_grapheme'></span>

<h3>Description</h3>

<p>Takes in a symbol/grapheme and sets of response times/colors,
then creates a Grapheme instance that holds the passed information and returns it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_grapheme(
  symbol,
  response_times = NULL,
  response_colors,
  color_space_spec = "Luv"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_grapheme_+3A_symbol">symbol</code></td>
<td>
<p>A one-element character vector holding a symbol/grapheme.</p>
</td></tr>
<tr><td><code id="create_grapheme_+3A_response_times">response_times</code></td>
<td>
<p>(optional) A numeric vector. Times from presentation to
response, in order.</p>
</td></tr>
<tr><td><code id="create_grapheme_+3A_response_colors">response_colors</code></td>
<td>
<p>A character vector. Response colors, as hex color
codes.</p>
</td></tr>
<tr><td><code id="create_grapheme_+3A_color_space_spec">color_space_spec</code></td>
<td>
<p>A one-element character vector. What color space
is to be used? The following color spaces are supported:
&quot;XYZ&quot;, &quot;sRGB&quot;, &quot;Apple RGB&quot;, &quot;Lab&quot;, and &quot;Luv&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>create_grapheme(symbol="a", response_times=c(2.3, 6.7, 0.4),
response_colors=c("84AE99", "9E3300", "000000"), color_space_spec="Luv")
</code></pre>

<hr>
<h2 id='create_participant'>Create a Participant instance.</h2><span id='topic+create_participant'></span>

<h3>Description</h3>

<p>Takes in a participant id, set of symbols for which graphemes
should be created and participant trial/response data. Returns a Participant
instance with all the input data linked to it. For each grapheme, if there
are data for less trials than the number specified by n_trials_per_grapheme,
NA values are added to affected graphemes' associated vectors of response
times/colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_participant(
  participant_id,
  grapheme_symbols,
  n_trials_per_grapheme,
  trial_symbols,
  response_times = NULL,
  response_colors,
  color_space_spec = "Luv",
  test_date = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_participant_+3A_participant_id">participant_id</code></td>
<td>
<p>A one-element character vector holding a participant id.</p>
</td></tr>
<tr><td><code id="create_participant_+3A_grapheme_symbols">grapheme_symbols</code></td>
<td>
<p>A character vector of symbols/graphemes for which
Grapheme instances should be created and linked to the Participant instance.</p>
</td></tr>
<tr><td><code id="create_participant_+3A_n_trials_per_grapheme">n_trials_per_grapheme</code></td>
<td>
<p>A one-element numeric vector holding the number
of trials per grapheme.</p>
</td></tr>
<tr><td><code id="create_participant_+3A_trial_symbols">trial_symbols</code></td>
<td>
<p>A character vector that holds one symbol/grapheme
for each trial of the participant's consistency test run.</p>
</td></tr>
<tr><td><code id="create_participant_+3A_response_times">response_times</code></td>
<td>
<p>(optional) A numeric vector. Consistency test times from
presentation to response, in order.</p>
</td></tr>
<tr><td><code id="create_participant_+3A_response_colors">response_colors</code></td>
<td>
<p>A character vector. Consistency test response
colors, as hex color codes.</p>
</td></tr>
<tr><td><code id="create_participant_+3A_color_space_spec">color_space_spec</code></td>
<td>
<p>A one-element character vector. What color
space is to be used? The following color spaces are supported:
&quot;XYZ&quot;, &quot;sRGB&quot;, &quot;Apple RGB&quot;, &quot;Lab&quot;, and &quot;Luv&quot;</p>
</td></tr>
<tr><td><code id="create_participant_+3A_test_date">test_date</code></td>
<td>
<p>(optional) A one-element character vector in the format
&quot;YYYY-MM-DD&quot; that indicates on what date the participant
finished the consistency test.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>participant_id &lt;- "1"
target_symbols_vec &lt;- c("A", "D", "7")
symbol_vec &lt;- c("A", "D", "7",
                "D", "A", "7",
                "7", "A", "D")
times_vec &lt;- c(1.1, 0.4, 5,
               0.3, 2.4, 7.3,
               1, 10.2, 8.4)
color_vec &lt;- c("98FF22", "138831", "791322",
               "8952FE", "DC8481", "7D89B0",
               "001100", "887755", "FF0033")
p &lt;- create_participant(participant_id=participant_id,
                        grapheme_symbols=target_symbols_vec,
                        n_trials_per_grapheme=3,
                        trial_symbols=symbol_vec,
                        response_times=times_vec,
                        response_colors=color_vec,
                        color_space_spec="Luv")
</code></pre>

<hr>
<h2 id='create_participantgroup'>Create a ParticipantGroup instance using long-format data</h2><span id='topic+create_participantgroup'></span>

<h3>Description</h3>

<p>Takes in a data frame of raw
<a href="https://stefvanbuuren.name/fimd/sec-longandwide.html">'long format'</a>
consistency test data and returns a
ParticipantGroup instance, to which all the relevant data are linked. See the
example data frame 'synr_exampledf_long_small' and its documentation
('help(synr_exampledf_long_small)') for more information on the format
that this function expects data to be in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_participantgroup(
  raw_df,
  n_trials_per_grapheme = 3,
  id_col_name,
  symbol_col_name,
  color_col_name,
  time_col_name = NULL,
  color_space_spec = "Luv"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_participantgroup_+3A_raw_df">raw_df</code></td>
<td>
<p>A data frame of 'long format' raw consistency test data.</p>
</td></tr>
<tr><td><code id="create_participantgroup_+3A_n_trials_per_grapheme">n_trials_per_grapheme</code></td>
<td>
<p>A one-element numeric vector holding the number
of trials per grapheme that was used in the consistency test the data are from.</p>
</td></tr>
<tr><td><code id="create_participantgroup_+3A_id_col_name">id_col_name</code></td>
<td>
<p>A one-element character vector that holds the
name of the participant id column in raw_df.</p>
</td></tr>
<tr><td><code id="create_participantgroup_+3A_symbol_col_name">symbol_col_name</code></td>
<td>
<p>A one-element character vector that holds the
name of the grapheme/symbol column in raw_df.</p>
</td></tr>
<tr><td><code id="create_participantgroup_+3A_color_col_name">color_col_name</code></td>
<td>
<p>A one-element character vector that holds the
name of the response color (hex codes) column in raw_df.</p>
</td></tr>
<tr><td><code id="create_participantgroup_+3A_time_col_name">time_col_name</code></td>
<td>
<p>(optional) A one-element character vector that holds the
name of the response time (time from stimulus presentation to response) column
in raw_df.</p>
</td></tr>
<tr><td><code id="create_participantgroup_+3A_color_space_spec">color_space_spec</code></td>
<td>
<p>A one-element character vector specifying which color
space to use for calculations with participant data. One of
&quot;XYZ&quot;, &quot;sRGB&quot;, &quot;Apple RGB&quot;, &quot;Lab&quot;, and &quot;Luv&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>pg &lt;- create_participantgroup(
  raw_df=synr_exampledf_long_small,
  n_trials_per_grapheme=2,
  id_col_name="participant_id",
  symbol_col_name="trial_symbol",
  color_col_name="response_color",
  time_col_name="response_time",
  color_space_spec="Luv"
)
cons_means &lt;- pg$get_mean_consistency_scores()
print(cons_means)
</code></pre>

<hr>
<h2 id='create_participantgroup_widedata'>Create a ParticipantGroup instance</h2><span id='topic+create_participantgroup_widedata'></span>

<h3>Description</h3>

<p>Takes in a data frame of raw consistency test data and returns a
ParticipantGroup instance, to which all the relevant data are linked. See the
example data frame synr_exampledf_wide_small and its documentation (help(synr_exampledf_wide_small))
for information on the format that this function expects data to be in.
</p>
<p>Participant id and (optional) test date column names are specified with the
exact column names used in the data frame passed to the function. Symbol
(i. e. grapheme), response color and response time (optional) columns are
specified using regular expressions. You can
<a href="https://r4ds.had.co.nz/strings.html#matching-patterns-with-regular-expressions">read about regular expressions using R here</a>
if you want to, but basically what you want to do is this:
say your columns with response colors are named
&quot;chosen_color_001&quot;, &quot;chosen_color_002&quot; and so on. You then simply set
color_col_regex=&quot;chosen_color&quot; when calling this function. The important thing
is that you specify a part of the column names that is unique for the type of
column you want to indicate. So if your symbol/grapheme columns are named
&quot;grapheme_1&quot;, &quot;grapheme_2&quot; ... and your participant id column is named
&quot;graphparticipant_1&quot; ..., then symbol_col_regex=&quot;graph&quot; wouldn't work,
but symbol_col_regex=&quot;grapheme_&quot; or even symbol_col_regex=&quot;graphe&quot; would.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_participantgroup_widedata(
  raw_df,
  n_trials_per_grapheme = 3,
  participant_col_name,
  symbol_col_regex,
  color_col_regex = "colou*r",
  time_col_regex = NULL,
  testdate_col_name = NULL,
  color_space_spec = "Luv"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_participantgroup_widedata_+3A_raw_df">raw_df</code></td>
<td>
<p>A data frame of raw consistency test data.</p>
</td></tr>
<tr><td><code id="create_participantgroup_widedata_+3A_n_trials_per_grapheme">n_trials_per_grapheme</code></td>
<td>
<p>A one-element numeric vector holding the number
of trials per grapheme that was used in the consistency test the data are from.</p>
</td></tr>
<tr><td><code id="create_participantgroup_widedata_+3A_participant_col_name">participant_col_name</code></td>
<td>
<p>A one-element character vector that holds the
column name used for the column in raw_df that holds participant id's.
(e. g. &quot;participant_id&quot; for the synr::synr_exampledf_wide_small)</p>
</td></tr>
<tr><td><code id="create_participantgroup_widedata_+3A_symbol_col_regex">symbol_col_regex</code></td>
<td>
<p>A one-element character vector with a regular expression
(see above) unique to columns in the passed data frame that hold trial graphemes/symbols.</p>
</td></tr>
<tr><td><code id="create_participantgroup_widedata_+3A_color_col_regex">color_col_regex</code></td>
<td>
<p>A one-element character vector with a regular expression
(see above) unique to columns in the passed data frame that hold response color hex codes.</p>
</td></tr>
<tr><td><code id="create_participantgroup_widedata_+3A_time_col_regex">time_col_regex</code></td>
<td>
<p>(optional) A one-element character vector with a regular expression
(see above) unique to columns in the passed data frame that hold response times (times
from stimulus presentation to response).</p>
</td></tr>
<tr><td><code id="create_participantgroup_widedata_+3A_testdate_col_name">testdate_col_name</code></td>
<td>
<p>(optional) A one-element character vector that holds the
column name used for the column in raw_df that holds test dates (dates when participants
finished the consistency test).</p>
</td></tr>
<tr><td><code id="create_participantgroup_widedata_+3A_color_space_spec">color_space_spec</code></td>
<td>
<p>A one-element character vector. What color
space is to be used for analyses of the data? The following color spaces are supported:
&quot;XYZ&quot;, &quot;sRGB&quot;, &quot;Apple RGB&quot;, &quot;Lab&quot;, and &quot;Luv&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>pg &lt;- create_participantgroup_widedata(raw_df=synr_exampledf_wide_small,
                              n_trials_per_grapheme=2,
                              participant_col_name="participant_id",
                              symbol_col_regex="symbol",
                              color_col_regex="colou*r",
                              time_col_regex="response_time",
                              color_space_spec="Luv"
)
cons_means &lt;- pg$get_mean_consistency_scores()
print(cons_means)
</code></pre>

<hr>
<h2 id='filter_graphemes'>Filter graphemes of a single participant</h2><span id='topic+filter_graphemes'></span>

<h3>Description</h3>

<p>Takes in a list of Grapheme objects and a character vector.
Returns a list of Grapheme objects, consisting of the participant's
graphemes which had a symbol included in the character vector to filter by.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_graphemes(graphemes, symbol_vector = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_graphemes_+3A_graphemes">graphemes</code></td>
<td>
<p>A list of Grapheme objects.</p>
</td></tr>
<tr><td><code id="filter_graphemes_+3A_symbol_vector">symbol_vector</code></td>
<td>
<p>A character vector of symbols to filter the
participant's graphemes by. Alternatively NULL (default), in which case
no filtering will be done and the full grapheme list is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of Grapheme objects.
</p>

<hr>
<h2 id='Grapheme-class'>A Reference Class for representing consistency test graphemes</h2><span id='topic+Grapheme-class'></span><span id='topic+Grapheme'></span>

<h3>Description</h3>

<p>A Reference Class for representing consistency test graphemes
</p>


<h3>Fields</h3>


<dl>
<dt><code>symbol</code></dt><dd><p>A one-element character vector containing the symbol/set of symbols
that describe(s) the grapheme, e. g. '7' or 'Monday'. Set at class new() call or using set_symbol method.</p>
</dd>
<dt><code>response_colors</code></dt><dd><p>A matrix where each row specifies color coordinates for each participant
response. Set using set_colors method.</p>
</dd>
<dt><code>response_times</code></dt><dd><p>A numeric vector of response times. Set using set_times method.</p>
</dd>
<dt><code>color_space</code></dt><dd><p>A one-element character vector which describes the color space
that response colors are coded in. Set when using set_colors method.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>get_abbreviated_symbol()</code></dt><dd><p>Return a short (3 character) representation of
the grapheme's symbol.</p>
</dd>
<dt><code>get_consistency_score(na.rm = FALSE, method = "euclidean")</code></dt><dd><p>Calculate the consistency score based on the
Grapheme instance's response colors. Throws an
error if no responses have been registered yet.
Always returns NA if all grapheme responses are NA.
If na.rm=FALSE, returns NA if any grapheme response
is NA. If na.rm=TRUE, returns the consistency score
for non-NA responses. This function relies on the
base/stats function dist() and so supports only
distance calculation methods implemented by dist()
(use help(dist) to learn more about it).</p>
</dd>
<dt><code>get_mean_color(na.rm = FALSE)</code></dt><dd><p>Average all registered response colors and
return the result (using the color space
set at grapheme initialization) as a 3-element vector.
Example: if color space is RGB, element 1 represents
mean R value, element 2 mean G value, element 3
B value.
</p>
<p>If na.rm=FALSE and any of the response colors is missing,
return a 3-element NA vector. If na.rm=TRUE, return a
3-element NA vector if all response colors are missing,
otherwise return mean of all available colors.</p>
</dd>
<dt><code>get_mean_response_time(na.rm = FALSE)</code></dt><dd><p>Get the mean of the grapheme's associated
response times.</p>
</dd>
<dt><code>get_num_non_na_colors()</code></dt><dd><p>Get the number of response colors that are non-NA, returned as
a one-element numeric vector.</p>
</dd>
<dt><code>get_plot_data_list()</code></dt><dd><p>Get a list of the grapheme's data, bundled up in
a format ready for use in Participant.get_plot_data()
method as a row of plot
data.</p>
</dd>
<dt><code>has_only_non_na_colors()</code></dt><dd><p>Returns TRUE if the grapheme only has responses with valid colors,
FALSE if there are responses with nonvalid colors or there are
no responses at all.</p>
</dd>
<dt><code>set_colors(hex_codes, color_space_spec)</code></dt><dd><p>Set response colors, using passed RGB hex codes. Converts
the hex codes to color coordinates in the specified
color space. Supports the following color spaces:
&quot;XYZ&quot;, &quot;sRGB&quot;, &quot;Apple RGB&quot;, &quot;Lab&quot;, and &quot;Luv&quot;.
For all NA values passed, a row of NA values will be included
in the matrix (preserving order of responses). Returned/set
response colors are in the format of a matrix where each
row represents one response/color, and each
column represents one color coordinate axis (there are always
3 axes used for the currently supported color spaces)</p>
</dd>
<dt><code>set_symbol(symbol_chars)</code></dt><dd><p>Set the grapheme's symbol attribute, using a passed
one-element character vector.</p>
</dd>
<dt><code>set_times(times)</code></dt><dd><p>Add response times, using passed numeric vector.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- synr::Grapheme$new(symbol='a')
a$set_colors(c("#101010", NA), "Luv")
a$set_times(c(5, 10))
a$get_num_non_na_colors()
</code></pre>

<hr>
<h2 id='Participant-class'>A Reference Class for representing consistency test participants</h2><span id='topic+Participant-class'></span><span id='topic+Participant'></span>

<h3>Description</h3>

<p>A Reference Class for representing consistency test participants
</p>


<h3>Fields</h3>


<dl>
<dt><code>id</code></dt><dd><p>A one-element character vector containing the participant's ID.
Set at class new() call.</p>
</dd>
<dt><code>test_date</code></dt><dd><p>A one-element Date vector which specifies the date
on which the participant did the consistency test.</p>
</dd>
<dt><code>graphemes</code></dt><dd><p>A list of <code><a href="#topic+Grapheme">Grapheme</a></code> class instances.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>add_grapheme(grapheme)</code></dt><dd><p>Add a passed grapheme to the participant's list
of graphemes. The grapheme's entry in
the list is named based on the grapheme's
symbol. Note that if you try to add
a grapheme with a symbol that's identical
to one of the graphemes already in the
participant's list of graphemes, the
already existing same-symbol grapheme
is overwritten.</p>
</dd>
<dt><code>add_graphemes(grapheme_list)</code></dt><dd><p>Go through a passed list of Grapheme instances
and add each one using the add_grapheme() method.</p>
</dd>
<dt><code>check_valid_get_twcv(
  min_complete_graphemes = 5,
  dbscan_eps = 20,
  dbscan_min_pts = 4,
  max_var_tight_cluster = 150,
  max_prop_single_tight_cluster = 0.6,
  safe_num_clusters = 3,
  safe_twcv = 250,
  complete_graphemes_only = TRUE,
  symbol_filter = NULL
)</code></dt><dd><p>    Checks if this participant's data are valid based on passed arguments.
This method aims to identify participants who had too few responses or
varied their response colors too little, by marking them as invalid.
Note that there are no absolutely correct values, as what is 'too little
variation' is highly subjective. You might need to tweak parameters to be
in line with your project's criteria, especially if you use another color
space than CIELUV, since the default values are based on what seems
to make sense in a CIELUV context. If you use the results in a
research article, make sure to reference synr and specify what parameter
values you passed to the function.
</p>
<p>This method relies heavily on the DBSCAN algorithm and the package
'dbscan', and involves calculating a synr-specific 'Total Within-Cluster
Variance' (TWCV) score. You can find more information, and
what the parameters here mean, in
the documentation for the function <code>validate_get_twcv</code>.
</p>


<h4>Parameters</h4>


<ul>
<li><p><code>min_complete_graphemes</code> The minimum number of graphemes
with complete (all non-NA color) responses that the participant data
must have for them to not be categorized as invalid based on this
criterion. Defaults to 5.

</p>
</li>
<li><p><code>dbscan_eps</code> Radius of 'epsilon neighborhood' when applying
DBSCAN clustering. Defaults to 20.

</p>
</li>
<li><p><code>dbscan_min_pts</code> Minimum number of points required in the
epsilon neighborhood for core points (including the core point
itself). Defaults to 4.

</p>
</li>
<li><p><code>max_var_tight_cluster</code> Maximum variance for an identified
DBSCAN cluster to be considered 'tight-knit'. Defaults to 150.

</p>
</li>
<li><p><code>max_prop_single_tight_cluster</code> Maximum proportion of
points allowed to be within a single 'tight-knit' cluster (exceeding
this leads to classification as invalid). Defaults to 0.6.

</p>
</li>
<li><p><code>safe_num_clusters</code> Minimum number of identified DBSCAN
clusters (including 'noise' cluster only if it consists of at least
'dbscan_min_pts' points) that guarantees validity if
points are 'non-tight-knit'. Defaults to 3.

</p>
</li>
<li><p><code>safe_twcv</code> Minimum total within-cluster variance (TWCV)
score that guarantees validity if points are 'non-tight-knit'.
Defaults to 250.

</p>
</li>
<li><p><code>complete_graphemes_only</code> A logical vector. If TRUE, 
only data from graphemes that have all non-NA color responses
are used; if FALSE, even data from graphemes with some NA color
responses are used. Defaults to TRUE.

</p>
</li>
<li><p><code>symbol_filter</code> A character vector (or NULL) that specifies
which graphemes' data to use. Defaults to NULL, meaning data from
all of the participant's graphemes will be used.

</p>
</li></ul>




<h4>Returns</h4>

<p>A list with components
</p>

<ul>
<li><p><code>valid</code> TRUE if categorized as valid, otherwise FALSE.
</p>
</li>
<li><p><code>reason_invalid</code> One-element character vector describing
why participant's data were deemed invalid, or empty string if
valid is TRUE.

</p>
</li>
<li><p><code>twcv</code> One-element numeric (or NA if there are no/too few
graphemes with complete responses) vector indicating participant's
calculated TWCV.

</p>
</li>
<li><p><code>num_clusters</code> One-element numeric (or NA if there are no/too few
graphemes with complete responses) vector indicating
the number of identified clusters counting toward the
tally compared with 'safe_num_clusters'.

</p>
</li></ul>


</dd>
<dt><code>get_all_colored_symbols(symbol_filter = NULL)</code></dt><dd><p>Returns a character vector of symbols corresponding to graphemes for
which all responses have an associated non-NA color. If a
character vector is passed to symbol_filter, only
symbols in the passed vector are returned.</p>
</dd>
<dt><code>get_consistency_scores(
  method = "euclidean",
  symbol_filter = NULL,
  na.rm = FALSE
)</code></dt><dd><p>Returns a list of grapheme symbols with associated consistency scores.
If na.rm = TRUE, for each grapheme a consistency score calculation is
forced (except if ALL response colors associated with the grapheme
are NA). That probably isn't what you want, because it leads to things
like a perfect consistency score if all except one response color are
NA. Defaults to na.rm = FALSE.
</p>
<p>If a character vector is passed to
symbol_filter, only consistency scores for graphemes with symbols
in the passed vector are returned.
</p>
<p>Use the method argument to specify what kind of color space
distances should be used when calculating consistency score
(usually 'manhattan' or 'euclidean' - see documentation for
the base R dist function for all options)</p>
</dd>
<dt><code>get_grapheme_mean_colors(symbol_filter = NULL, na.rm = FALSE)</code></dt><dd><p>Returns a list of grapheme symbols with associated mean colors,
using the color space set at participant creation. Colors are represented
by 3-element vectors. 
</p>
<p>Example: if color space is RGB, vector element 1 represents
grapheme mean R value, element 2 mean G value, element 3
B value.
</p>
<p>If na.rm = TRUE, for each grapheme a mean color is calculated even
if one its associated response colors is missing. Defaults to
na.rm = FALSE.
</p>
<p>If a character vector is passed to symbol_filter, only
mean colors for graphemes with symbols
in the passed vector are returned.</p>
</dd>
<dt><code>get_mean_consistency_score(
  symbol_filter = NULL,
  method = "euclidean",
  na.rm = FALSE
)</code></dt><dd><p>Returns the mean consistency score with respect to
Grapheme instances associated with the participant.
</p>
<p>If na.rm = FALSE, calculates the mean consistency score if
all of the participants' graphemes only have response
colors that are non-NA, otherwise returns NA.
If na.rm = TRUE, returns the mean consistency score for
all of the participant's graphemes that only have
non-NA response colors, while ignoring graphemes
that have at least one NA response color value. Note that
NA is returned in either case, if ALL of the participants'
graphemes have at least one NA response color value.
</p>
<p>If a character vector is passed to
symbol_filter, only data from graphemes with symbols
in the passed vector are used when calculating the
mean score.
</p>
<p>Use the method argument to specify what kind of color space
distances should be used when calculating consistency score
(usually 'manhattan' or 'euclidean' - see documentation for
the base R dist function for all options)</p>
</dd>
<dt><code>get_mean_response_time(symbol_filter = NULL, na.rm = FALSE)</code></dt><dd><p>Returns the mean response time, with respect to all
Grapheme instances associated with the participant.
Weights response times based on number of valid responses
that each grapheme has. If na.rm = TRUE, returns mean response
time even if there are missing response times. If na.rm = FALSE,
returns mean response time if there is at least one response time
value for at least one of the participants' graphemes. If a
character vector is passed to symbol_filter, only data from
graphemes with symbols in the passed vector are used when
calculating the mean response time.</p>
</dd>
<dt><code>get_nonna_color_resp_mat(symbol_filter = NULL)</code></dt><dd><p>Returns an n-by-3 matrix of all non-NA color responses' data,
where each column represents a color axis and each row a response
color. If a character vector is passed to symbol_filter,
only data from responses associated with graphemes with corresponding 
symbols are included.</p>
</dd>
<dt><code>get_number_all_colored_graphemes(symbol_filter = NULL)</code></dt><dd><p>Returns the number of graphemes for which all
responses have an associated non-NA color. If a
character vector is passed to symbol_filter, only
graphemes with symbols in the passed vector are counted.</p>
</dd>
<dt><code>get_participant_mean_color(symbol_filter = NULL, na.rm = FALSE)</code></dt><dd><p>Returns average of all of participants' registered
response colors (based on the color space
set at participant initialization) as a 3-element vector.
Example: if color space is RGB, element 1 represents
mean R value, element 2 mean G value, element 3
B value.
</p>
<p>If a character vector is passed to
symbol_filter, only data from graphemes with symbols
in the passed vector are used when calculating the
mean color.
</p>
<p>If na.rm = FALSE, calculates the mean response color if
all of the participants' graphemes only have response
colors that are non-NA, otherwise returns NA.
If na.rm = TRUE, returns the mean response color based on
all non-NA response colors.</p>
</dd>
<dt><code>get_plot(
  cutoff_line = FALSE,
  mean_line = FALSE,
  grapheme_size = 2,
  grapheme_angle = 0,
  grapheme_spacing = 0.25,
  foreground_color = "black",
  background_color = "white",
  symbol_filter = NULL
)</code></dt><dd><p>Returns a ggplot2 plot that describes this participant's
grapheme color responses and per-grapheme consistency scores.
</p>
<p>If cutoff_line = TRUE, the plot will include a blue line that
indicates the value 135.30, which is the synesthesia
cut-off score recommended by Rothen, Seth, Witzel &amp; Ward (2013)
for the L*u*v color space. If mean_line = TRUE, the plot will
include a green line that indicates the participant's mean
consistency score for graphemes with all-valid
response colors (if the participant has any such graphemes). If a vector
is passed to symbol_filter, this green line represents the mean score
for ONLY the symbols included in the filter.
</p>
<p>Pass a value to grapheme_size to adjust the size of graphemes
shown at the bottom of the plot, e. g. increasing the size if
there's a lot of empty space otherwise, or decreasing the size if the
graphemes don't fit. The grapheme_angle
argument allows rotating graphemes. grapheme_spacing is for adjusting
how far grapheme symbols are spaced from each other.
</p>
<p>If a character vector is passed to symbol_filter, only data for graphemes
with symbols in the passed vector are used.
</p>
<p>Graphemes are sorted left-to-right by 1. length and
2. unicode value (this means among other things that digits
come before letters).</p>
</dd>
<dt><code>get_plot_data(symbol_filter = NULL)</code></dt><dd><p>Returns a data frame with the following columns:
</p>
<p>1. grapheme (grapheme names - of type character)
</p>
<p>2. consistency_score (of type numeric)
</p>
<p>3... color_resp&lt;x&gt;, where x is a digit: hold response hex color codes
(number of columns depends on number of response colors
associated with each grapheme).
</p>
<p>The data frame is intended to be used for plotting participant data,
using .get_plot(). The call will end with an error
if not all of the participant's graphemes have the same number
of color responses. This is intended.
</p>
<p>If a character vector is passed to symbol_filter, only data for graphemes
with symbols in the passed vector are used.</p>
</dd>
<dt><code>get_symbols()</code></dt><dd><p>Returns a character vector with all symbols for
graphemes associated with the participant.</p>
</dd>
<dt><code>has_graphemes()</code></dt><dd><p>Returns TRUE if there is at least one
grapheme in the participant's graphemes list,
otherwise returns FALSE</p>
</dd>
<dt><code>save_plot(
  save_dir = NULL,
  file_format = "png",
  dpi = 300,
  cutoff_line = FALSE,
  mean_line = FALSE,
  grapheme_size = 2,
  grapheme_angle = 0,
  foreground_color = "black",
  background_color = "white",
  symbol_filter = NULL,
  ...
)</code></dt><dd><p>Saves a ggplot2 plot that describes this participant's
grapheme color responses and per-grapheme consistency scores,
using the ggsave function.
</p>
<p>If a character vector is passed to symbol_filter, only data for graphemes
with symbols in the passed vector are used.
</p>
<p>If save_dir is not specified, the plot is saved to the current
working directory. Otherwise, the plot is saved to the specified
directory. The file is saved using the specified file_format,
e. g. JPG (see ggplot2::ggsave documentation for list of
supported formats), and the resolution specified with
the dpi argument.
</p>
<p>If cutoff_line = TRUE, the plot will include a blue line that
indicates the value 135.30, which is the synesthesia
cut-off score recommended by Rothen, Seth, Witzel &amp; Ward (2013)
for the L*u*v color space. If mean_line = TRUE, the plot will
include a green line that indicates the participant's mean
consistency score for graphemes with all-valid response colors
(if the participant has any such graphemes). If a vector
is passed to symbol_filter, this green line represents the mean score
for ONLY the symbols included in the filter.
</p>
<p>Pass a value to grapheme_size to adjust the size of graphemes
shown at the bottom of the plot, e. g. increasing the size if
there's empty space otherwise, or decreasing the size if the
graphemes don't fit. Similarly, you can use the grapheme_angle
argument to rotate the graphemes, which might help them fit better.
</p>
<p>Apart from these, all other arguments
that ggsave accepts (e. g. 'scale') also work with this function, since
all arguments are passed on to ggsave.</p>
</dd>
<dt><code>set_date(in_date)</code></dt><dd><p>Takes in a one-element character vector with a date
in the format 'YYYY-MM-DD' and sets the participant's
test_date to the specified date.</p>
</dd>
</dl>

<hr>
<h2 id='ParticipantGroup-class'>A Reference Class for representing a group of consistency test participants</h2><span id='topic+ParticipantGroup-class'></span><span id='topic+ParticipantGroup'></span>

<h3>Description</h3>

<p>A Reference Class for representing a group of consistency test participants
</p>


<h3>Fields</h3>


<dl>
<dt><code>participants</code></dt><dd><p>A list of <code><a href="#topic+Participant">Participant</a></code>
class instances.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>add_participant(participant)</code></dt><dd><p>Add a passed participant to the participantgroup's list
of participants. The participant's entry in
the list is named based on the participant's
id. Note that if you try to add
a participant with an id that's identical
to one of the participants already in the
participantgroup's list of participants, the
already existing same-id participant
is overwritten.</p>
</dd>
<dt><code>add_participants(participant_list)</code></dt><dd><p>Go through a passed list of Participant instances
and add each one using the add_participant() method.</p>
</dd>
<dt><code>check_valid_get_twcv_scores(
  min_complete_graphemes = 5,
  dbscan_eps = 20,
  dbscan_min_pts = 4,
  max_var_tight_cluster = 150,
  max_prop_single_tight_cluster = 0.6,
  safe_num_clusters = 3,
  safe_twcv = 250,
  complete_graphemes_only = TRUE,
  symbol_filter = NULL
)</code></dt><dd><p>    Checks if participants' data are valid based on passed arguments.
This method aims to identify participants who had too few responses or
varied their response colors too little, by marking them as invalid.
Note that there are no absolutely correct values, as what is 'too little
variation' is highly subjective. You might need to tweak parameters to be
in line with your project's criteria, especially if you use another color
space than CIELUV, since the default values are based on what seems
to make sense in a CIELUV context. If you use the results in a
research article, make sure to reference synr and specify what parameter
values you passed to the function.
</p>
<p>This method relies heavily on the DBSCAN algorithm and the package
'dbscan', and involves calculating a synr-specific 'Total Within-Cluster
Variance' (TWCV) score. You can find more information, and
what the parameters here mean, in
the documentation for the function <code>validate_get_twcv</code>. Note
that DBSCAN clustering and related calculations are performed on
a per-participant basis, before they are summarized in the data frame
returned by this method.
</p>


<h4>Parameters</h4>


<ul>
<li><p><code>min_complete_graphemes</code> The minimum number of graphemes
with complete (all non-NA color) responses that a participant's data
must have for them to not be categorized as invalid based on
this criterion. Defaults to 7.

</p>
</li>
<li><p><code>dbscan_eps</code> Radius of 'epsilon neighborhood' when applying
(on a per-participant basis) DBSCAN clustering. Defaults to 30.

</p>
</li>
<li><p><code>dbscan_min_pts</code> Minimum number of points required in the
epsilon neighborhood for core points (including the core point
itself). Defaults to 4.

</p>
</li>
<li><p><code>max_var_tight_cluster</code> Maximum variance for an identified
DBSCAN cluster to be considered 'tight-knit'. Defaults to 150.

</p>
</li>
<li><p><code>max_prop_single_tight_cluster</code> Maximum proportion of
points allowed to be within a single 'tight-knit' cluster (if a
participant's data exceed this limit, they are classified as
invalid). Defaults to 0.6.

</p>
</li>
<li><p><code>safe_num_clusters</code> Minimum number of identified DBSCAN
clusters (including 'noise' cluster only if it consists of at least
'dbscan_min_pts' points) that guarantees validity of
a participant's data if points are 'non-tight-knit'. Defaults to 3.

</p>
</li>
<li><p><code>safe_twcv</code> Minimum total within-cluster variance (TWCV)
score that guarantees a participant's data's validity if points are
'non-tight-knit'. Defaults to 250.

</p>
</li>
<li><p><code>complete_graphemes_only</code> A logical vector. If TRUE, 
only data from graphemes that have all non-NA color responses
are used; if FALSE, even data from graphemes with some NA color
responses are used. Defaults to TRUE.

</p>
</li>
<li><p><code>symbol_filter</code> A character vector (or NULL) that specifies
which graphemes' data to use. Defaults to NULL, meaning data from
all of the participants' graphemes will be used.

</p>
</li></ul>




<h4>Returns</h4>

<p>A data frame with columns
</p>

<ul>
<li><p><code>valid</code> Holds TRUE for participants whose data were
classified as valid, FALSE for participants whose data were
classified as invalid.
</p>
</li>
<li><p><code>reason_invalid</code> Strings which describe for each
participant why their data were deemed invalid. Participants
whose data were classified as valid have empty strings here.

</p>
</li>
<li><p><code>twcv</code> Numeric column which holds participants'
calculated TWCV scores (NA for participants who had no/too
few graphemes with complete responses).

</p>
</li>
<li><p><code>num_clusters</code> One-element numeric (or NA if there are no/too few
graphemes with complete responses) vector indicating
the number of identified clusters counting toward the
tally compared with 'safe_num_clusters'.

</p>
</li></ul>


</dd>
<dt><code>get_ids()</code></dt><dd><p>Returns a character vector with all ids for
participants associated with the participantgroup.</p>
</dd>
<dt><code>get_mean_colors(symbol_filter = NULL, na.rm = FALSE)</code></dt><dd><p>Returns an nx3 data frame of mean colors for
participants in the group, where the columns
represent chosen color space axis 1, 2, and 3, respectively
(e.g. 'R', 'G', 'B' if 'sRGB' was specified upon participantgroup
creation).
</p>
<p>If na.rm=FALSE, for each
participant calculates the mean color if
all of the participants' graphemes only have response
colors that are non-NA, otherwise puts NA values
for that participant's row in matrix. If na.rm=TRUE,
for each participant calculates the mean color
for all of the participant's valid response colors,
while ignoring NA response colors. Note that
for participants whose graphemes ALL have at least one NA
response color value, an NA is put in the row corresponding to
that participant, regardless of what na.rm is set to.
</p>
<p>If a character vector is passed to symbol_filter, only
data from graphemes with symbols in the passed vector
are used when calculating each participant's mean color.</p>
</dd>
<dt><code>get_mean_consistency_scores(
  method = "euclidean",
  symbol_filter = NULL,
  na.rm = FALSE
)</code></dt><dd><p>Returns a vector of mean consistency scores for
participants in the group. If na.rm=FALSE, for each
participant calculates the mean consistency score if
all of the participants' graphemes only have response
colors that are non-NA, otherwise puts an NA value
for that participant in returned vector. If na.rm=TRUE,
for each participant calculates the mean consistency score for
all of the participant's graphemes that only have
non-NA response colors, while ignoring graphemes
that have at least one NA response color value. Note that
for participants whose graphemes ALL have at least one NA
response color value, an NA is put in the returned vector for
that participant, regardless of what na.rm is set to.
</p>
<p>If a character vector is passed to symbol_filter, only
data from graphemes with symbols in the passed vector
are used when calculating each participant's mean score.
</p>
<p>Use the method argument to specify what kind of color space
distances should be used when calculating consistency scores
(usually 'manhattan' or 'euclidean' - see documentation for
the base R dist function for all options)</p>
</dd>
<dt><code>get_mean_response_times(symbol_filter = NULL, na.rm = FALSE)</code></dt><dd><p>Returns the mean response times, with respect to
Grapheme instances associated with each participant.
If na.rm=TRUE, for each participant returns mean response time even
if there are missing response times. If na.rm=FALSE, returns
mean response time if there is at least one response time
value for at least one of the participants' graphemes. If a
character vector is passed to symbol_filter, only data from
graphemes with symbols in the passed vector are used when
calculating each participant's mean response time.</p>
</dd>
<dt><code>get_numbers_all_colored_graphemes(symbol_filter = NULL)</code></dt><dd><p>Returns a vector with numbers representing how many
graphemes with all-valid (non-na) response colors that each
participant has.  If a character vector is passed to symbol_filter,
only data connected to graphemes with symbols in the passed vector
are used.</p>
</dd>
<dt><code>has_participants()</code></dt><dd><p>Returns TRUE if there is at least one
participant in the participantgroup's participants list,
otherwise returns FALSE</p>
</dd>
<dt><code>save_plots(
  save_dir = NULL,
  file_format = "png",
  dpi = 300,
  cutoff_line = FALSE,
  mean_line = FALSE,
  grapheme_size = 2,
  grapheme_angle = 0,
  foreground_color = "black",
  background_color = "white",
  symbol_filter = NULL,
  ...
)</code></dt><dd><p>Goes through all participants and for each one produces and saves
a ggplot2 plot that describes the participant's
grapheme color responses and per-grapheme consistency scores,
using the ggsave function.
</p>
<p>If a character vector is passed to symbol_filter, only data for graphemes
with symbols in the passed vector are used.
</p>
<p>If path is not specified, plots are saved to the current
working directory. Otherwise, plots are saved to the specified
directory. The file is saved using the specified file_format,
e. g. JPG (see ggplot2::ggsave documentation for list of
supported formats), and the resolution specified with
the dpi argument.
</p>
<p>If cutoff_line=TRUE, each plot will include a blue line that
indicates the value 135.30, which is the synesthesia cut-off score
recommended by Rothen, Seth, Witzel &amp; Ward (2013) for the L*u*v
color space. If mean_line=TRUE, the plot will include a green line
that indicates the participant's mean consistency score for
graphemes with all-valid response colors (if the participant
has any such graphemes). If a vector is passed to symbol_filter,
this green line represents the mean score
for ONLY the symbols included in the filter.
</p>
<p>Pass a value to grapheme_size to adjust the size of graphemes
shown at the bottom of the plot, e. g. increasing the size if
there's empty space otherwise, or decreasing the size if the
graphemes don't fit. Similarly, you can use the grapheme_angle
argument to rotate the graphemes, which might help them fit better.
</p>
<p>Apart from the ones above, all other arguments
that ggsave accepts (e. g. 'scale') also work with this function, since
all arguments are passed on to ggsave. </p>
</dd>
</dl>

<hr>
<h2 id='point_3d_variance'>Calculate sample variance of 3D point distance from centroid</h2><span id='topic+point_3d_variance'></span>

<h3>Description</h3>

<p>Calculates sample variance of points' distances in
3D space from their centroid. This function is normally only used
indirectly through 'validate_get_twcv'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point_3d_variance(point_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point_3d_variance_+3A_point_matrix">point_matrix</code></td>
<td>
<p>An n-by-3 numerical matrix where each
row corresponds to a single point in 3D space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-element numeric vector holding calculated variance
</p>


<h3>Details</h3>

<p>The variance here is taken to mean
the sum of variances for each dimension/axis:
</p>
<p style="text-align: center;"><code class="reqn">
\frac{\sum_{i=1}^n (x_i-x_m)^2 + (y_i-y_m)^2 + (z-z_m)^2}{n-1}
</code>
</p>

<p>Where <code class="reqn">X/Y/Z</code> represent one axis each, <code class="reqn">a_m</code> represents the mean
of all points' coordinates on an axis, and <code class="reqn">n</code> represents the total
number of points.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+centroid_3d_sq_dist">centroid_3d_sq_dist</a></code>
</p>

<hr>
<h2 id='synr_exampledf_large'>Raw consistency test data example, long format</h2><span id='topic+synr_exampledf_large'></span>

<h3>Description</h3>

<p>A data frame with an example of raw consistency test data that are
compatible with the synr package's &lsquo;create_participantgroup&rsquo; function.
The color and 'symbol' data are from five actual participants who did
a test that included all letters, digits and weekdays, with 3 trials
per grapheme. The response times are randomly generated. 
Note that response times are optional. If you don't have
them, you can still use synr - see 'help(create_participantgroup_widedata)'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synr_exampledf_large
</code></pre>


<h3>Format</h3>

<p>A data frame with 516 rows and 4 columns:
</p>

<dl>
<dt>participant_id</dt><dd><p>Participant ID</p>
</dd>
<dt>trial_symbol</dt><dd><p>Column of trial symbols/graphemes</p>
</dd>
<dt>response_color</dt><dd><p>Column of trial response colors</p>
</dd>
<dt>response_time</dt><dd><p>Column of trial response times</p>
</dd>
</dl>


<hr>
<h2 id='synr_exampledf_long_small'>Raw consistency test data example, long format (small)</h2><span id='topic+synr_exampledf_long_small'></span>

<h3>Description</h3>

<p>A data frame with an example of raw consistency test data that are
compatible with the synr package's 'create_participantgroup' function,
with completely made updata for three participants from a hypothetical 
test that included three graphemes (&quot;A&quot;, &quot;D&quot;, 7) and two responses
per grapheme. More graphemes and/or
responses per grapheme can be handled by the package (though participant
plots do not function correctly if there are more than three responses
per grapheme). Note that response times are optional. If you don't have
them, you can still use synr - see 'help(create_participantgroup_widedata)'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synr_exampledf_long_small
</code></pre>


<h3>Format</h3>

<p>A data frame with 18 rows and 4 columns:
</p>

<dl>
<dt>participant_id</dt><dd><p>Participant ID</p>
</dd>
<dt>trial_symbol</dt><dd><p>Column of trial symbols/graphemes</p>
</dd>
<dt>response_color</dt><dd><p>Column of trial response colors</p>
</dd>
<dt>response_time</dt><dd><p>Column of trial response times</p>
</dd>
</dl>


<hr>
<h2 id='synr_exampledf_wide_small'>Raw consistency test data example, wide format (small)</h2><span id='topic+synr_exampledf_wide_small'></span>

<h3>Description</h3>

<p>A data frame with an example of raw consistency test data that are
compatible with the synr package's 'create_participantgroup_widedata' function,
with data for three participants from a test that included three
graphemes (&quot;A&quot;, &quot;D&quot;, 7) and two responses
per grapheme. More graphemes and/or
responses per grapheme can be handled by the package (though participant
plots do not function correctly if there are more than three responses
per grapheme)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synr_exampledf_wide_small
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 rows and 8 columns:
</p>

<dl>
<dt>participant_id</dt><dd><p>Participant ID</p>
</dd>
<dt>symbol_1</dt><dd><p>Column with symbol/grapheme connected to first response</p>
</dd>
<dt>response_color_1</dt><dd><p>Column with color of first response</p>
</dd>
<dt>response_time_1</dt><dd><p>(optional) Column with time from
presentation to response, for first response</p>
</dd>
<dt>symbol_2</dt><dd><p>Column with symbol/grapheme connected to second response</p>
</dd>
<dt>response_color_2</dt><dd><p>Column with color of second response</p>
</dd>
<dt>response_time_2</dt><dd><p>(optional) Column with time from
presentation to response, for second response</p>
</dd>
<dt>symbol_3</dt><dd><p>Column with symbol/grapheme connected to third response</p>
</dd>
<dt>response_color_3</dt><dd><p>Column with color of third response</p>
</dd>
<dt>response_time_3</dt><dd><p>(optional) Column with time from
presentation to response, for third response</p>
</dd>
<dt>symbol_4</dt><dd><p>Column with symbol/grapheme connected to fourth response</p>
</dd>
<dt>response_color_4</dt><dd><p>Column with color of fourth response</p>
</dd>
<dt>response_time_4</dt><dd><p>(optional) Column with time from
presentation to response, for fourth response</p>
</dd>
<dt>symbol_5</dt><dd><p>Column with symbol/grapheme connected to fifth response</p>
</dd>
<dt>response_color_5</dt><dd><p>Column with color of fifth response</p>
</dd>
<dt>response_time_5</dt><dd><p>(optional) Column with time from
presentation to response, for fifth response</p>
</dd>
<dt>symbol_6</dt><dd><p>Column with symbol/grapheme connected to sixth response</p>
</dd>
<dt>response_color_6</dt><dd><p>Column with color of sixth response</p>
</dd>
<dt>response_time_6</dt><dd><p>(optional) Column with time from
presentation to response, for sixth response</p>
</dd>
</dl>


<hr>
<h2 id='total_within_cluster_variance'>Calculate Total Within Cluster Variance of 3D points</h2><span id='topic+total_within_cluster_variance'></span>

<h3>Description</h3>

<p>Calculates <em>Total Within Cluster Variance(TWCV)</em> of
3D points. This function is normally only used
indirectly through 'validate_get_twcv'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total_within_cluster_variance(point_matrix, cluster_vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="total_within_cluster_variance_+3A_point_matrix">point_matrix</code></td>
<td>
<p>An n-by-3 numerical matrix where each
row corresponds to a single point in 3D space.</p>
</td></tr>
<tr><td><code id="total_within_cluster_variance_+3A_cluster_vector">cluster_vector</code></td>
<td>
<p>A numerical vector of cluster assignments, of
length n (ie one assignment per point).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-element numeric vector holding calculated variance
</p>


<h3>TWCV</h3>

<p>TWCV is a synr-specific term for a measure that aims to describe spread
of points in 3D space while taking into account that points belong
to distinct clusters.
TWCV is calculated in a multi-step process:
</p>

<ol>
<li><p> Each cluster's centroid is calculated.
</p>
</li>
<li><p> All points' squared distances to their corresponding centroids are
calculated.
</p>
</li>
<li><p> The point-to-centroid squared distances are summed up.
</p>
</li>
<li><p> The sum of squared distances is divided by the total number
of points, minus the number of clusters (to account for decreased
degrees of freedom).
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+centroid_3d_sq_dist">centroid_3d_sq_dist</a></code>
</p>

<hr>
<h2 id='validate_get_twcv'>Check if color data are valid and get TWCV</h2><span id='topic+validate_get_twcv'></span>

<h3>Description</h3>

<p>Checks if passed color data are valid, i. e. are bountiful
and varied enough according to passed validation criteria. This function
is normally only used indirectly through
'Participant$check_valid_get_twcv()' or 'ParticipantGroup$get_valid_twcv()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_get_twcv(
  color_matrix,
  dbscan_eps = 20,
  dbscan_min_pts = 4,
  max_var_tight_cluster = 150,
  max_prop_single_tight_cluster = 0.6,
  safe_num_clusters = 3,
  safe_twcv = 250
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_get_twcv_+3A_color_matrix">color_matrix</code></td>
<td>
<p>An n-by-3 numerical matrix where each
row corresponds to a single point in 3D color space.</p>
</td></tr>
<tr><td><code id="validate_get_twcv_+3A_dbscan_eps">dbscan_eps</code></td>
<td>
<p>One-element numerical vector: radius of
‘epsilon neighborhood’ when applying DBSCAN clustering.</p>
</td></tr>
<tr><td><code id="validate_get_twcv_+3A_dbscan_min_pts">dbscan_min_pts</code></td>
<td>
<p>One-element numerical vector:
Minimum number of points required in the epsilon neighborhood
for core points (including the core point itself).</p>
</td></tr>
<tr><td><code id="validate_get_twcv_+3A_max_var_tight_cluster">max_var_tight_cluster</code></td>
<td>
<p>One-element numerical vector:
maximum variance for a cluster to be considered 'tight-knit'.</p>
</td></tr>
<tr><td><code id="validate_get_twcv_+3A_max_prop_single_tight_cluster">max_prop_single_tight_cluster</code></td>
<td>
<p>One-element numerical vector:
maximum proportion of points allowed to be within a 'tight-knit' cluster
(if this threshold is exceeded, the data are categorized as invalid).</p>
</td></tr>
<tr><td><code id="validate_get_twcv_+3A_safe_num_clusters">safe_num_clusters</code></td>
<td>
<p>One-element numerical vector: minimum number of
clusters that guarantees validity if points are 'non-tight-knit'.</p>
</td></tr>
<tr><td><code id="validate_get_twcv_+3A_safe_twcv">safe_twcv</code></td>
<td>
<p>One-element numerical vector: minimum total
within-cluster variance (TWCV) score that guarantees validity if
points are 'non-tight-knit'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>valid</code></td>
<td>
<p>One-element logical vector</p>
</td></tr>
<tr><td><code>reason_invalid</code></td>
<td>
<p>One-element character vector, empty if valid is TRUE</p>
</td></tr>
<tr><td><code>twcv</code></td>
<td>
<p>One-element numeric (or NA if can't be calculated) vector,
indicating TWCV</p>
</td></tr>
<tr><td><code>num_clusters</code></td>
<td>
<p>One-element numeric (or NA if can't be calculated)
vector, indicating the number of identified clusters counting toward the
tally compared with 'safe_num_clusters'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies heavily on the DBSCAN algorithm and its implementation
in the R package 'dbscan', for clustering color points. For further
information regarding the 'dbscan_eps' and
'dbscan_min_pts' parameters as well as DBSCAN itself, please see
the 'dbscan' documentation. Once clustering is done, passed validation
criteria are applied:
</p>

<ul>
<li><p> If too high a proportion of all color points (cut-off specified with
&lsquo;max_prop_single_tight_cluster') fall within a single &rsquo;tight-knit' cluster
(with a cluster variance less than or equal to 'max_var_tight_cluster'),
then the data are always classified as invalid.
</p>
</li>
<li><p> If the first criterion is cleared, <em>and</em> points form more than
'safe_num_cluster' clusters, data are always classified as valid.
</p>
</li>
<li><p> If the first criterion is cleared, <em>and</em> the Total Within-Cluster
Variance (TWCV) score is greater than or equal to 'safe_twcv', data are
always classified as valid.
</p>
</li></ul>

<p>Note that this means data can be classified as valid by either having
at least 'safe_num_cluster' clusters, <em>or</em> by having points composing
a smaller number of clusters but spaced relatively far apart
<em>within</em> these clusters.
</p>
<p>The DBSCAN 'noise' cluster only counts towards the 'cluster tally' 
(compared with 'safe_num_cluster') if it includes at least 'dbscan_min_pts' points.
Points in the noise cluster are however always included in
other calculations, e. g. total within-cluster variance (TWCV).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+point_3d_variance">point_3d_variance</a></code> for single-cluster variance,
<code><a href="#topic+total_within_cluster_variance">total_within_cluster_variance</a></code> for TWCV.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
