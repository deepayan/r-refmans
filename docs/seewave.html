<!DOCTYPE html><html><head><title>Help for package seewave</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {seewave}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ACI'><p>Acoustic Complexity Index</p></a></li>
<li><a href='#acoustat'><p>Statistics on time and frequency STFT contours</p></a></li>
<li><a href='#addsilw'><p>Add or insert a silence section</p></a></li>
<li><a href='#afilter'><p>Amplitude filter</p></a></li>
<li><a href='#akamatsu'><p>Water tank minimum resonant and cutoff frequencies</p></a></li>
<li><a href='#ama'><p>Amplitude modulation analysis of a time wave</p></a></li>
<li><a href='#AR'><p>Acoustic Richness index</p></a></li>
<li><a href='#attenuation'><p>Generate sound intensity attenuation data</p></a></li>
<li><a href='#audiomoth'><p>Reading and interpreting Audiomoth file name</p></a></li>
<li><a href='#audiomoth.rename'><p>Rename audiomoth files in a readable format</p></a></li>
<li><a href='#autoc'><p>Short-term autocorrelation of a time wave</p></a></li>
<li><a href='#beep'><p>Beep sound</p></a></li>
<li><a href='#bwfilter'><p>Butterworth frequency filter</p></a></li>
<li><a href='#ccoh'><p>Continuous coherence function between two time waves</p></a></li>
<li><a href='#ceps'><p>Cepstrum or real cepstrum</p></a></li>
<li><a href='#cepstro'><p>2D-cepstrogram of a time wave</p></a></li>
<li><a href='#coh'><p>Coherence between two time waves</p></a></li>
<li><a href='#combfilter'><p>Comb filter</p></a></li>
<li><a href='#convSPL'><p>Convert sound pressure level in other units</p></a></li>
<li><a href='#corenv'><p>Cross-correlation between two time wave envelopes</p></a></li>
<li><a href='#corspec'><p>Cross-correlation between two frequency spectra</p></a></li>
<li><a href='#covspectro'><p>Covariance between two spectrograms</p></a></li>
<li><a href='#crest'><p>Crest factor and visualization</p></a></li>
<li><a href='#csh'><p>Continuous spectral entropy</p></a></li>
<li><a href='#cutspec'><p>Cut a frequency spectrum</p></a></li>
<li><a href='#cutw'><p>Cut a section of a time wave</p></a></li>
<li><a href='#dBscale'><p>dB colour scale for a spectrogram display</p></a></li>
<li><a href='#dBweight'><p>dB weightings</p></a></li>
<li><a href='#deletew'><p>Delete a section of a time wave</p></a></li>
<li><a href='#dfreq'><p>Dominant frequency of a time wave</p></a></li>
<li><a href='#diffcumspec'><p>Difference between two cumulative frequency spectra</p></a></li>
<li><a href='#diffenv'><p>Difference between two amplitude envelopes</p></a></li>
<li><a href='#diffspec'><p>Difference between two frequency spectra</p></a></li>
<li><a href='#diffwave'><p>Difference between two time waves</p></a></li>
<li><a href='#discrets'><p>Time series discretisation</p></a></li>
<li><a href='#drawenv'><p>Draw the amplitude envelope of a time wave</p></a></li>
<li><a href='#drawfilter'><p>Draw the amplitude profile of a frequency filter</p></a></li>
<li><a href='#duration'><p>Duration of a time wave</p></a></li>
<li><a href='#dynoscillo'><p>Dynamic oscillogram</p></a></li>
<li><a href='#dynspec'><p>Dynamic sliding spectrum</p></a></li>
<li><a href='#dynspectro'><p>Dynamic sliding spectrogramn</p></a></li>
<li><a href='#echo'><p>Echo generator</p></a></li>
<li><a href='#env'><p>Amplitude envelope of a time wave</p></a></li>
<li><a href='#export'><p>Export sound data</p></a></li>
<li><a href='#fadew'><p>Fade in and fade out of a time wave</p></a></li>
<li><a href='#fbands'><p>Frequency bands plot</p></a></li>
<li><a href='#fdoppler'><p>Doppler effect</p></a></li>
<li><a href='#ffilter'><p>Frequency filter</p></a></li>
<li><a href='#field'><p>Near field and far field limits</p></a></li>
<li><a href='#fir'><p>Finite Impulse Response filter</p></a></li>
<li><a href='#fma'><p>Frequency modulation analysis</p></a></li>
<li><a href='#fpeaks'><p>Frequency peak detection</p></a></li>
<li><a href='#ftwindow'><p>Fourier transform windows</p></a></li>
<li><a href='#fund'><p>Fundamental frequency track</p></a></li>
<li><a href='#gammatone'><p>Gammatone filter</p></a></li>
<li><a href='#ggspectro'><p>2D-spectrogram of a time wave using ggplot2</p></a></li>
<li><a href='#H'><p>Total entropy</p></a></li>
<li><a href='#hilbert'><p>Hilbert transform and analytic signal</p></a></li>
<li><a href='#ifreq'><p>Instantaneous frequency</p></a></li>
<li><a href='#istft'><p>Inverse of the short-term Fourier transform</p></a></li>
<li><a href='#itakura.dist'><p>Itakuro-Saito distance</p></a></li>
<li><a href='#kl.dist'><p>Kullback-Leibler distance</p></a></li>
<li><a href='#ks.dist'><p>Kolmogorov-Smirnov distance</p></a></li>
<li><a href='#lfs'><p>Linear Frequency Shift</p></a></li>
<li><a href='#listen'><p>Play a sound wave</p></a></li>
<li><a href='#localpeaks'><p>Local maximum frequency peak detection</p></a></li>
<li><a href='#logspec.dist'><p>Log-spectral distance</p></a></li>
<li><a href='#lts'><p>Long-term spectrogram</p></a></li>
<li><a href='#M'><p>Median of the amplitude envelope</p></a></li>
<li><a href='#meandB'><p>Mean of dB values</p></a></li>
<li><a href='#meanspec'><p>Mean frequency spectrum of a time wave</p></a></li>
<li><a href='#mel'><p>Hertz / Mel conversion</p></a></li>
<li><a href='#melfilterbank'><p>Mel-filter bank for MFCC computation</p></a></li>
<li><a href='#micsens'><p>Microphone sensitivity and conversion</p></a></li>
<li><a href='#moredB'><p>Addition of dB values</p></a></li>
<li><a href='#mutew'><p>Replace time wave data by 0 values</p></a></li>
<li><a href='#NDSI'><p>Normalized Difference Soundscape Index</p></a></li>
<li><a href='#noisew'><p>Generate noise</p></a></li>
<li><a href='#notefreq'><p>Frequency of a muscical note</p></a></li>
<li><a href='#octaves'><p>Octave values</p></a></li>
<li><a href='#orni'><p>Song of the cicada Cicada orni</p></a></li>
<li><a href='#oscillo'><p>Show a time wave as an oscillogram</p></a></li>
<li><a href='#oscilloEQ'><p>Oscillogram 'equalizer'</p></a></li>
<li><a href='#oscilloST'><p>Show a stereo time wave as oscillograms</p></a></li>
<li><a href='#pastew'><p>Paste a time wave to another one</p></a></li>
<li><a href='#peewit'><p>Song of the bird Vanellus vanellus</p></a></li>
<li><a href='#pellucens'><p>Calling song of the tree cricket Oecanthus pellucens</p></a></li>
<li><a href='#phaseplot'><p>Phase-phase 2D or 3D plot of a time wave</p></a></li>
<li><a href='#phaseplot2'><p>Phase-phase 2D plot of a time wave</p></a></li>
<li><a href='#playlist'><p>Play a list of sound files</p></a></li>
<li><a href='#preemphasis'><p>Pre-emphasis speech filter</p></a></li>
<li><a href='#pulsew'><p>Generate rectangle pulse</p></a></li>
<li><a href='#Q'><p>Resonance quality factor of a frequency spectrum</p></a></li>
<li><a href='#read.audacity'><p>Audacity audio markers import</p></a></li>
<li><a href='#repw'><p>Repeat a time wave</p></a></li>
<li><a href='#resamp'><p>Resample a time wave</p></a></li>
<li><a href='#revw'><p>Time reverse of a time wave</p></a></li>
<li><a href='#rmam'><p>Remove the amplitude modulations of a time wave</p></a></li>
<li><a href='#rmnoise'><p>Remove noise</p></a></li>
<li><a href='#rmoffset'><p>Remove the offset of a time wave</p></a></li>
<li><a href='#rms'>
<p>Root Mean Square</p></a></li>
<li><a href='#roughness'><p>Roughness or total curvature</p></a></li>
<li><a href='#rugo'><p>Rugosity of a time wave</p></a></li>
<li><a href='#savewav'><p>Save a .wav file</p></a></li>
<li><a href='#SAX'><p>Symbolic Aggregate approXimation</p></a></li>
<li><a href='#scd'><p>Soundcape chord diagram</p></a></li>
<li><a href='#sddB'><p>Standard deviation of dB values</p></a></li>
<li><a href='#seedata'><p>A quick look at quantitative data</p></a></li>
<li><a href='#seewave'><p>Sound analysis and synthesis</p></a></li>
<li><a href='#seewave-internal'><p>Internal Seewave Functions</p></a></li>
<li><a href='#setenv'><p>Set the amplitude envelope of a time wave to another one</p></a></li>
<li><a href='#sfm'><p>Spectral Flatness Measure</p></a></li>
<li><a href='#sh'><p>Shannon and Renyi spectral entropy</p></a></li>
<li><a href='#sheep'><p>Sheep bleat</p></a></li>
<li><a href='#simspec'><p>Similarity between two frequency spectra</p></a></li>
<li><a href='#smoothw'><p>A function to tentativily smooth a time wave</p></a></li>
<li><a href='#songmeter'><p>Reading and interpreting SongMeter file name</p></a></li>
<li><a href='#songmeterdiag'><p>Songmeter file diagnostics and diagram</p></a></li>
<li><a href='#soundscapespec'><p>Soundscape frequency spectrum of a time wave</p></a></li>
<li><a href='#sox'><p>Calls SoX</p></a></li>
<li><a href='#spec'><p>Frequency spectrum of a time wave</p></a></li>
<li><a href='#specflux'><p>Spectral flux</p></a></li>
<li><a href='#specprop'><p>Spectral properties</p></a></li>
<li><a href='#spectro'><p>2D-spectrogram of a time wave</p></a></li>
<li><a href='#spectro3D'><p>3D-spectrogram of a time wave</p></a></li>
<li><a href='#squarefilter'><p>Frequency square filter</p></a></li>
<li><a href='#symba'><p>Symbol analysis of a numeric (time) series</p></a></li>
<li><a href='#synth'><p>Synthesis of time wave (additive model)</p></a></li>
<li><a href='#synth2'><p>Synthesis of time wave (tonal model)</p></a></li>
<li><a href='#TFSD'><p>normalized Time and Frequency Second Derivative</p></a></li>
<li><a href='#th'><p>Temporal entropy</p></a></li>
<li><a href='#tico'><p>Song of the bird Zonotrichia capensis</p></a></li>
<li><a href='#timelapse'><p>Time lapse</p></a></li>
<li><a href='#timer'><p>Time measurements of a time wave</p></a></li>
<li><a href='#TKEO'><p>Teager-Kaiser energy tracking operator</p></a></li>
<li><a href='#wasp'><p>WAve length and SPeed of sound</p></a></li>
<li><a href='#wav2dBSPL'><p>Convert wave amplitude to instantaneous sound pressure level (dB SPL)</p></a></li>
<li><a href='#wav2flac'><p>wav-flac file conversion</p></a></li>
<li><a href='#wav2leq'><p>Convert wave amplitude to equivalent continuous sound pressure level (Leq)</p></a></li>
<li><a href='#wf'><p>Waterfall display</p></a></li>
<li><a href='#write.audacity'><p>Audacity audio markers export</p></a></li>
<li><a href='#zapsilw'><p>Zap silence periods of a time wave</p></a></li>
<li><a href='#zc'><p>Instantaneous frequency of a time wave by zero-crossing</p></a></li>
<li><a href='#zcr'><p>Zero-crossing rate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sound Analysis and Synthesis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Jerome Sueur [aut, cre],
  Thierry Aubin [aut],
  Caroline Simonis [aut],
  Laurent Lellouch [ctr],
  Pierre Aumond [ctr],
  Adèle de Baudouin [ctr],
  Ethan C. Brown [ctr],
  Guillaume Corbeau [ctr],
  Marion Depraetere [ctr],
  Camille Desjonquères [ctr],
  François Fabianek [ctr],
  Amandine Gasc [ctr],
  Sylvain Haupert [ctr],
  Eric Kasten [ctr],
  Jonathan Lees [ctr],
  Jean Marchal [ctr],
  Andre Mikulec [ctr],
  Sandrine Pavoine [ctr],
  David Pinaud [ctr],
  Alicia Stotz [ctr],
  Luis J. Villanueva-Rivera [ctr],
  Zev Ross [ctr],
  Carl G. Witthoft [ctr],
  Hristo Zhivomirov [ctr]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jerome Sueur &lt;sueur@mnhn.fr&gt;</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>LIBSNDFILE</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, utils, tuneR, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>audio, circlize, FactoMineR, fftw, ggplot2, rgl, rpanel,
phonTools, signal</td>
</tr>
<tr>
<td>ZipData:</td>
<td>no</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for analysing, manipulating, displaying, editing and synthesizing time waves (particularly sound).  This package processes time analysis (oscillograms and envelopes), spectral content, resonance quality factor, entropy, cross correlation and autocorrelation, zero-crossing, dominant frequency, analytic signal, frequency coherence, 2D and 3D spectrograms and many other analyses. See Sueur et al. (2008) &lt;<a href="https://doi.org/10.1080%2F09524622.2008.9753600">doi:10.1080/09524622.2008.9753600</a>&gt; and Sueur (2018) &lt;<a href="https://doi.org/10.1007%2F978-3-319-77647-7">doi:10.1007/978-3-319-77647-7</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rug.mnhn.fr/seewave/">https://rug.mnhn.fr/seewave/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-19 09:02:03 UTC; root</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-19 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ACI'>Acoustic Complexity Index</h2><span id='topic+ACI'></span>

<h3>Description</h3>

<p>This function computes the Acoustic Complexity Index (ACI)
as described in Pieretti <em>et al</em>. (2011)</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACI(wave, f, channel = 1, wl = 512, ovlp = 0,  wn = "hamming", flim = NULL, nbwindows = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ACI_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="ACI_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="ACI_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="ACI_+3A_wl">wl</code></td>
<td>
<p>window length for the analysis
(even number of points) (by default = 512).</p>
</td></tr>
<tr><td><code id="ACI_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in %).</p>
</td></tr>
<tr><td><code id="ACI_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="ACI_+3A_flim">flim</code></td>
<td>
<p>a numeric vector of length 2 to select a frequency band (in kHz).</p>
</td></tr>
<tr><td><code id="ACI_+3A_nbwindows">nbwindows</code></td>
<td>
<p>a numeric vector of length 1 specifying the number of
windows (by default 1, ie a single window including the complete <code>wave</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes first a short-term Fourier transform and then
the ACI index. <br />
The function returns only the ACI total, ACI tot in Pieretti <em>et
al</em>. (2010). <br />
See the references for details on computation. </p>


<h3>Value</h3>

<p>A vector of length 1 returning the ACI total.</p>


<h3>Note</h3>

<p>Values returned were checked with the results provided by the
add-on Soundscapemeter for the software Wavesurfer.
</p>


<h3>Author(s)</h3>

<p>Laurent Lellouch, improved by Amandine Gasc and Morgane Papin</p>


<h3>References</h3>

<p>Pieretti N, Farina A, Morri FD (2011) A new methodology to infer the
singing activity of an avian community: the Acoustic Complexity Index
(ACI). <em>Ecological Indicators</em>, 11, 868-873.<br />
Farina A, Pieretti N, Piccioli L (2011) The soundscape methodology for long-term bird monitoring: a Mediterranean Europe case-study. <em>Ecological Informatics</em>, 6, 354-363.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectro">spectro</a></code>, <code><a href="#topic+specflux">specflux</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
ACI(tico)
## dividing the sound sample into 4 windows of equal duration
ACI(tico, nbwindows=4)
## selection of a frequency band
ACI(tico, flim=c(2,6))
</code></pre>

<hr>
<h2 id='acoustat'>Statistics on time and frequency STFT contours</h2><span id='topic+acoustat'></span>

<h3>Description</h3>

<p>This function returns statistics based on STFT time and
frequency contours.</p>


<h3>Usage</h3>

<pre><code class='language-R'>acoustat(wave, f, channel = 1, wl = 512, ovlp = 0, wn = "hanning",
tlim = NULL, flim = NULL,
aggregate = sum, fraction = 90,
plot = TRUE, type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acoustat_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="acoustat_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="acoustat_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="acoustat_+3A_wl">wl</code></td>
<td>
<p>window length for the analysis
(even number of points) (by default = 512).</p>
</td></tr>
<tr><td><code id="acoustat_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in %).</p>
</td></tr>
<tr><td><code id="acoustat_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default
<code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="acoustat_+3A_tlim">tlim</code></td>
<td>
<p>modifications of the time limits of the analysis (in s).</p>
</td></tr>
<tr><td><code id="acoustat_+3A_flim">flim</code></td>
<td>
<p>modifications of the frequency limits of the analysis (in kHz).</p>
</td></tr> 
<tr><td><code id="acoustat_+3A_aggregate">aggregate</code></td>
<td>
<p>a character vector of length 1 specifying the function to be applied on the rows (time) and columns (frequency) of the STFT matrix. By default set to <code>sum</code>.</p>
</td></tr>
<tr><td><code id="acoustat_+3A_fraction">fraction</code></td>
<td>
<p>a numeric vector of length 1, specifying a particular
fraction of the contours amplitude to be captured by the initial and
terminal percentile values (in %). See details.</p>
</td></tr>
<tr><td><code id="acoustat_+3A_plot">plot</code></td>
<td>
<p>a logical, if <code>TRUE</code> a two-frame plot is returned
with the time and frequency contours and percentiles displayed.</p>
</td></tr>
<tr><td><code id="acoustat_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn. See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="acoustat_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The principle of <code>acoustat</code> is as follows:
</p>

<ol>
<li><p> Compute the short-term Fourier transform (STFT) with usual
parameters (<code>wl</code> for window length, <code>ovlp</code> for overlap of
successive windows, and <code>wn</code> for the name of window shape).
</p>
</li>
<li><p> This results in a time * frequency matrix.
</p>
</li>
<li><p> Compute an aggregation function (specified with the argument
<code>aggregate</code> set by default to <code>sum</code>) accross rows and
columns of time * frequency matrix.)
</p>
</li>
<li><p> This results in two components: (<em>i</em>) the time contour,
and (<em>ii</em>) the frequency contour.
</p>
</li>
<li><p> Each contour is considered as a probability mass function
(PMF) and transformed into a cumulated distribution function (CDF).
</p>
</li>
<li><p> Measures are extracted from each CDF: median (M), initial
percentile (P1) value, terminal percentile (P2) value, interpercentile range (IPR). P1, P2 and IPR are defined using a fraction parameter
(<code>fraction</code>) that sets the percent of the contour amplitude to be captured by the initial and terminal percentile values. A fraction of 50% would result in the familiar quartiles and interquartile range. An energy fraction of 80% would return the 10th and 90th percentile values, and the width of the range in between.
</p>
</li></ol>



<h3>Value</h3>

<p>The function returns a list with 10 items:
</p>
<table>
<tr><td><code>time.contour</code></td>
<td>
<p>the time contour as a two-column matrix, the
first colum being time (s) and the second colum being the amplitude
probability mass function (no scale).</p>
</td></tr>
<tr><td><code>freq.contour</code></td>
<td>
<p>the frequency contour as a two-column matrix,
the first colum being frequency (kHz) and the second colum being the
amplitude probability mass function (no scale).</p>
</td></tr>
<tr><td><code>time.P1</code></td>
<td>
<p>the time initial percentile</p>
</td></tr>
<tr><td><code>time.M</code></td>
<td>
<p>the time median</p>
</td></tr>
<tr><td><code>time.P2</code></td>
<td>
<p>the time terminal percentile</p>
</td></tr>
<tr><td><code>time.IPR</code></td>
<td>
<p>the time interpercentile range</p>
</td></tr>
<tr><td><code>freq.P1</code></td>
<td>
<p>the frequency initial percentile</p>
</td></tr>
<tr><td><code>freq.M</code></td>
<td>
<p>the frequency median</p>
</td></tr>
<tr><td><code>freq.P2</code></td>
<td>
<p>the frequency terminal percentile</p>
</td></tr>
<tr><td><code>freq.IPR</code></td>
<td>
<p>the frequency interpercentile range</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>acoustat</code> was originally developped in Matlab language by Kurt Fristrup and XXXX Watkins (1992) .<br />
The <abbr><span class="acronym">R</span></abbr> function was kindly checked by Kurt Fristrup.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Fristrup, K. M. and Watkins, W. A. 1992. Characterizing
acoustic features of marine animal sounds.
Woods Hole Oceanographic Institution Technical Report WHOI-92-04.</p>


<h3>See Also</h3>

<p><code><a href="#topic+meanspec">meanspec</a></code>, <code><a href="#topic+specprop">specprop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
note &lt;- cutw(tico, from=0.5, to=0.9, output="Wave")
## default setting
acoustat(note)
## change the percentile fraction
acoustat(note, fraction=50)
## change the STFT parameters
acoustat(note, wl=1024, ovlp=80)
## change the function to compute the aggregate contours
## standard deviation instead of sum   
acoustat(note, aggregate=sd)
## direct time and frequency selection     
acoustat(tico, tlim=c(0.5,0.9), flim=c(3,6))
## some useless graphical changes
acoustat(note, type="o", col="blue") 
</code></pre>

<hr>
<h2 id='addsilw'>Add or insert a silence section</h2><span id='topic+addsilw'></span>

<h3>Description</h3>

<p>Add or insert a silence section to a time wave.</p>


<h3>Usage</h3>

<pre><code class='language-R'>addsilw(wave, f, channel = 1, at = "end", choose = FALSE, d = NULL,
plot = FALSE, output = "matrix", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addsilw_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="addsilw_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="addsilw_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="addsilw_+3A_at">at</code></td>
<td>
<p>position where to add the silence section (in s).
Can be also specified as <code>"start"</code>, <code>"middle"</code> or <code>"end"</code>.</p>
</td></tr>
<tr><td><code id="addsilw_+3A_choose">choose</code></td>
<td>
<p>logical, if <code>TRUE</code> the point where silence will
be added into <code>wave2</code> (=<code>at</code>) can be graphically chosen with a cursor.</p>
</td></tr>
<tr><td><code id="addsilw_+3A_d">d</code></td>
<td>
<p>duration of the silence section to add (in s).</p>
</td></tr>
<tr><td><code id="addsilw_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic plot
of <code>wave</code> with the new silence section (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="addsilw_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="addsilw_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+cutw">cutw</a></code>,<code><a href="#topic+deletew">deletew</a></code>,
<code><a href="#topic+fadew">fadew</a></code>,<code><a href="#topic+pastew">pastew</a></code>, <code><a href="#topic+mutew">mutew</a></code>,<code><a href="#topic+revw">revw</a></code>,
<code><a href="#topic+zapsilw">zapsilw</a></code>
</p>

<hr>
<h2 id='afilter'>Amplitude filter</h2><span id='topic+afilter'></span>

<h3>Description</h3>

<p>This function deletes all signal which amplitude
is below a selected threshold.</p>


<h3>Usage</h3>

<pre><code class='language-R'>afilter(wave, f, channel = 1, threshold = 5, plot = TRUE,
listen = FALSE, output = "matrix", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afilter_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="afilter_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="afilter_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="afilter_+3A_threshold">threshold</code></td>
<td>
<p>amplitude threshold (in %).</p>
</td></tr>
<tr><td><code id="afilter_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the new oscillogram
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="afilter_+3A_listen">listen</code></td>
<td>
<p>if <code>TRUE</code> the new sound is played back.</p>
</td></tr>
<tr><td><code id="afilter_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return,
either <code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="afilter_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>threshold</code> value is in % relative to the maximal value
of <code>wave</code>. Signal inferior to this value is clipped. 
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Note</h3>

<p>This function is used as an argument (<code>threshold</code>) in the 
following functions: <code><a href="#topic+autoc">autoc</a></code>, <code><a href="#topic+csh">csh</a></code>,
<code><a href="#topic+dfreq">dfreq</a></code>, <code><a href="#topic+timer">timer</a></code> and <code><a href="#topic+zc">zc</a></code>.   
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orni)
op&lt;-par(mfrow=c(2,1))
afilter(orni,f=22050)
title(main = "threshold level = 5")
afilter(orni,f=22050,threshold=0.5,colwave="blue")
title(main = "threshold level = 0.5")
par(op)
</code></pre>

<hr>
<h2 id='akamatsu'>Water tank minimum resonant and cutoff frequencies</h2><span id='topic+akamatsu'></span>

<h3>Description</h3>

<p>This function computes the resonant and cutoff frequencies when
recording in a given aquarium according to the criteria explained in Akamatsu et al. (2002)</p>


<h3>Usage</h3>

<pre><code class='language-R'>akamatsu(Lx, Ly, Lz, mode = c(1,1,1),
         c = 148000,  plot = FALSE, xlab = "Frequency (kHz)",
         ylab = "Attenuation distance (cm)", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="akamatsu_+3A_lx">Lx</code></td>
<td>
<p>watertank length (in cm).</p>
</td></tr>
<tr><td><code id="akamatsu_+3A_ly">Ly</code></td>
<td>
<p>watertank width (in cm).</p>
</td></tr>
<tr><td><code id="akamatsu_+3A_lz">Lz</code></td>
<td>
<p>watertank height (in cm).</p>
</td></tr>
<tr><td><code id="akamatsu_+3A_mode">mode</code></td>
<td>
<p>mode, see details.</p>
</td></tr>
<tr><td><code id="akamatsu_+3A_c">c</code></td>
<td>
<p>sound velocity in cm/s (by default 148000 cm/s in water).</p>
</td></tr>
<tr><td><code id="akamatsu_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the attenuation distance in function of frequency.</p>
</td></tr>
<tr><td><code id="akamatsu_+3A_xlab">xlab</code></td>
<td>
<p>title of the x axis if <code>plot</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="akamatsu_+3A_ylab">ylab</code></td>
<td>
<p>title of the y axis if <code>plot</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="akamatsu_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Akamatsu et al. (2002): <br /> <br />
<em>1. Resonant frequency</em> <br /> <br />
The calculated resonant frequencies of a rectangular glass tank with the dimension of Lx , Ly , and Lz (in centimeters) can
be described by the following equation: <br />
</p>
<p style="text-align: center;"><code class="reqn">f^{rectangular}_{lmn} = \frac{c}{2} \times \sqrt{\left(\frac{l}{L_{x}}\right)^2 +
      \left(\frac{m}{L_{y}}\right)^2  + \left(\frac{n}{L_{z}}\right)^2}</code>
</p>

<p>where <em>c</em> is the sound velocity (cm/s) and each <em>l</em>, <em>m</em>, <em>n</em> reprents an
integer, and the combination of these paramameters designates the
'mode number'. The mode (1, 1, 1) represents the resonance wave of minimum
frequency. The mode (2, 1, 1) represents one of the higher order of
resonant component and has additional node of the soundpressure level
at the middle of the X axis, <em>i.e.</em>, Lx/2. <br />
<br />
<br />
<em>2. Cutoff frequency</em> <br /> <br />
The cutoff frequency can be calculated as follows: <br />
</p>
<p style="text-align: center;"><code class="reqn">f^{rectangular}_{cutoff} = \frac{c}{2} \times \sqrt{
      \left(\frac{1}{L_{y}}\right)^2  + \left(\frac{1}{L_{z}}\right)^2}</code>
</p>

<p><br />
<br />
<em>3. Attenuation distance</em> <br /> <br />
The theoretical attenuation distance <em>D</em> can be expressed in function of the
cutoff frequency and the projected frequency following: <br />
</p>
<p style="text-align: center;"><code class="reqn">D^{rectangular}(f) = 2 \times log_{10} \times \frac{c}{4 \pi
  f^{rectangular}_{cutoff}} \times \frac{1}{\sqrt{1-\left(\frac{f}{f^{rectangular}_{cutoff}}\right)^2}}</code>
</p>



<h3>Value</h3>

<p>A list of two items:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>Resonant frequency (in Hz). See <code>Details</code></p>
</td></tr>
<tr><td><code>cut</code></td>
<td>
<p>Cut frequency (in Hz). See <code>Details</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Camille Desjonqueres</p>


<h3>References</h3>

<p>Akamatsu T, Okumura T, Novarini N, Yan HY (2002) Emprical refinements applicable to the recording of fish sounds in small tanks. <em>Journal of the Acoustical Society of America</em>, 112, 3073-3082.</p>


<h3>Examples</h3>

<pre><code class='language-R'>akamatsu(60, 30, 40)
</code></pre>

<hr>
<h2 id='ama'>Amplitude modulation analysis of a time wave</h2><span id='topic+ama'></span>

<h3>Description</h3>

<p>This function computes the Fourier analysis of a time wave envelope. This
allows to detect periodicity, in particular those generated by amplitude
modulations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ama(wave, f, channel = 1, envt = "hil", wl = 512, plot = TRUE, type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ama_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="ama_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="ama_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="ama_+3A_envt">envt</code></td>
<td>
<p>the type of envelope to be used: either &quot;abs&quot; for absolute
amplitude envelope or &quot;hil&quot; for Hilbert amplitude envelope.</p>
</td></tr>
<tr><td><code id="ama_+3A_wl">wl</code></td>
<td>
<p>length of the window for the analysis (even number of points,
by default = 512).</p>
</td></tr>  
<tr><td><code id="ama_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the spectrum of the envelope 
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ama_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="ama_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+meanspec">meanspec</a></code> parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on <code>env</code> and <code>meanspec</code>.<br /> 
The envelope of <code>wave</code> is first computed and the spectrum of this envelope
is then processed. All <code>env</code> and <code>meanspec</code> arguments can be
set up. Be sure to set up <code>wl</code> large enough if you want to detect low amplitude
modulation periodicity.
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, <code>ama</code> returns a numeric
vector corresponding to the computed spectrum.
If <code>peaks</code> is not <code>NULL</code>, <code>ama</code> returns a list with
two elements:
</p>
<table>
<tr><td><code>spec</code></td>
<td>
<p>the spectrum computed</p>
</td></tr>
<tr><td><code>peaks</code></td>
<td>
<p>the peaks values (in kHz).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+env">env</a></code>, <code><a href="#topic+fma">fma</a></code>, <code><a href="#topic+meanspec">meanspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orni)
# detection of the main amplitude modulation in a cicada song:
# one with a 0.258 kHz frequency (due to pulses in the echemes)
# one with a 2.369 kHz frequency (fundamental frequency)
ama(orni,f=22050,wl=1024)
# these amplitude modulations can be identify with a cursor:
ama(orni,f=22050,wl=1024,identify=TRUE)
</code></pre>

<hr>
<h2 id='AR'>Acoustic Richness index</h2><span id='topic+AR'></span>

<h3>Description</h3>

<p>This function computes the Acoustic Richness index based on
M and Ht indices</p>


<h3>Usage</h3>

<pre><code class='language-R'>AR(..., datatype = "objects", envt = "hil",
msmooth = NULL, ksmooth = NULL, ssmooth = NULL,
pattern = "[wav]$|[WAV]$|[mp3]$")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AR_+3A_...">...</code></td>
<td>
<p><code>Wave</code>, <code>WaveMC</code>, <code>audioSample</code> objects if <code>datatype="objects"</code>, or a path as a character string to a directory including <code>.wav</code> and/or <code>.mp3</code> files if <code>datatype="files"</code>.</p>
</td></tr>
<tr><td><code id="AR_+3A_datatype">datatype</code></td>
<td>
<p>A character string to specify if inputs are either <code>R</code> objects (<code>datatype="objects"</code>, default) or files (<code>datatype="files"</code>).</p>
</td></tr>
<tr><td><code id="AR_+3A_envt">envt</code></td>
<td>
<p>the type of envelope to be returned: either <code>"abs"</code> for absolute amplitude envelope or <code>"hil"</code> for Hilbert (default) amplitude envelope. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="AR_+3A_msmooth">msmooth</code></td>
<td>
<p>mean smooth. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="AR_+3A_ksmooth">ksmooth</code></td>
<td>
<p>kernel smooth via kernel. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="AR_+3A_ssmooth">ssmooth</code></td>
<td>
<p>sum smooth. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="AR_+3A_pattern">pattern</code></td>
<td>
<p>an optional regular expression. Only file names which match the regular expression will be returned when <code>datatype="files"</code>. By default <code>.wav</code> or <code>.mp3</code> files. See <code><a href="base.html#topic+dir">dir</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AR is ranked index based on the rank of the M and Ht indices obtained with the functions <code><a href="#topic+M">M</a></code> and <code><a href="#topic+th">th</a></code> respectively following:
</p>
<p style="text-align: center;"><code class="reqn">AR = \frac{rank(M) \times rank(H_{t})}{n^2}</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">0 \leq AR \leq 1</code>
</p>



<h3>Value</h3>

<p>A <code>data.frame</code> with three columns (M, Ht, AR) and n columns, with n the number of objects (respectively files) used as input.</p>


<h3>Note</h3>

<p>As a ranked index, the results returned by AR strongly depends with the set of objects (respectively files) used as   input. Comparaison between different data sets may be spurious. Computing AR on a set of a single object does not make any sense but is allowed.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur and Marion Depraetere</p>


<h3>References</h3>

<p>Depraetere M, Pavoine S, Jiguet F, Gasc A, Duvail S, Sueur J (2012) Monitoring animal diversity using acoustic indices: implementation in a temperate woodland. <em>Ecological Indicators</em>, <b>13</b>, 46-54.</p>


<h3>See Also</h3>

<p><code><a href="#topic+M">M</a></code>, <code><a href="#topic+th">th</a></code>, <code><a href="#topic+env">env</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## input as R objects
data(orni)
data(tico)
AR(orni, tico)
## give names to objects if you wish to have them as row names of the returned data.frame
AR(orni=orni, tico=tico)
## input as files stored in the working directory
## file names will be used as row names of the returned data.frame
## Not run: 
require(tuneR)
AR(getwd(), datatype="files")

## End(Not run)
</code></pre>

<hr>
<h2 id='attenuation'>Generate sound intensity attenuation data</h2><span id='topic+attenuation'></span>

<h3>Description</h3>

<p>This function generates dB data following theoretical spherical
attenuation of sound. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attenuation(lref, dref = 1, dstop, n, plot = TRUE,
xlab = "Distance (m)", ylab = "dB", type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attenuation_+3A_lref">lref</code></td>
<td>
<p>reference intensity or pressure level (in dB).</p>
</td></tr>
<tr><td><code id="attenuation_+3A_dref">dref</code></td>
<td>
<p>reference distance corresponding to <code>lref</code> (in m.)
(by default = 1).</p>
</td></tr>
<tr><td><code id="attenuation_+3A_dstop">dstop</code></td>
<td>
<p>maximal distance of propagation (in m.).</p>
</td></tr>
<tr><td><code id="attenuation_+3A_n">n</code></td>
<td>
<p>number of points generated between <code>dref</code> and <code>dstop</code>.</p>
</td></tr>
<tr><td><code id="attenuation_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots attenuation against distance
of propagation (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="attenuation_+3A_xlab">xlab</code></td>
<td>
<p>title of the x axis.</p>
</td></tr>
<tr><td><code id="attenuation_+3A_ylab">ylab</code></td>
<td>
<p>title of the y axis.</p>
</td></tr>
<tr><td><code id="attenuation_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="attenuation_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code> return a numeric vector with the data generated.
</p>


<h3>Note</h3>

<p>Sound attenuation in a free, unbounded medium behaves in accordance with
the inverse square law. <code>attenuation</code> generates data following this rule
from a reference point where sound intensity level (SIL) or 
sound pressure level (SPL) is known. Such theoretical data can be compared with
experimental data collected in a real environment.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Hartmann, W. M. 1998 <em>Signals, sound and sensation</em>. New York: Springer.</p>


<h3>See Also</h3>

<p><code><a href="#topic+convSPL">convSPL</a></code>, <code><a href="#topic+moredB">moredB</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># theoretical attenuation up to 150 m of a 100 dB/1m sound source
attenuation(lref=100, dref=1, dstop=150, n=200)
</code></pre>

<hr>
<h2 id='audiomoth'>Reading and interpreting Audiomoth file name</h2><span id='topic+audiomoth'></span>

<h3>Description</h3>

<p>This function reads and decomposes the files names
generated by an Audiomoth device,
audio digal recorders produced by the society Open Acoustic Devices.</p>


<h3>Usage</h3>

<pre><code class='language-R'>audiomoth(x, tz = "")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="audiomoth_+3A_x">x</code></td>
<td>
<p>a character vector with <code>.wav</code> file names.</p>
</td></tr>
<tr><td><code id="audiomoth_+3A_tz">tz</code></td>
<td>
<p>a character vector defining a time zone specification. See <code>as.POSIXct</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The digital recorder Audiomoth produced by Open Acoustic
Devices (<a href="https://www.openacousticdevices.info/">https://www.openacousticdevices.info/</a>) generates .wav
files which names contains information about the time of
recording. The information is encoded in hexadecimal
(e.g. &quot;5E9089F0&quot;). The function <code>audiomoth</code> decodes this
information so that time of recording can be retrieved in numeric or
time format.</p>


<h3>Value</h3>

<p>The function returns a <code>data.frame</code> with the following
columns:
</p>
<table>
<tr><td><code>year</code></td>
<td>
<p>year of recording, numeric</p>
</td></tr>
<tr><td><code>month</code></td>
<td>
<p>month of recording, numeric</p>
</td></tr>
<tr><td><code>day</code></td>
<td>
<p>day of recording, numeric</p>
</td></tr>
<tr><td><code>hour</code></td>
<td>
<p>hour of recording, numeric</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>minute of recording, numeric</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>second of recording, numeric</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time in <code>POSIX</code> format</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For the time zone see the 607 time zone names stored in
<code>OlsonNames</code>.<br />
The file names of Audiomoth may change with time. There is no
guarantee that the function will be updated on time.
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>See Open Acoustic Devices website for details regarding
the Audiomoth: <a href="https://www.openacousticdevices.info/">https://www.openacousticdevices.info/</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+audiomoth.rename">audiomoth.rename</a></code>, <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>, <code><a href="base.html#topic+OlsonNames">OlsonNames</a></code>, <code><a href="#topic+songmeter">songmeter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## HEXADECIMAL EXAMPLES (OLD FORMAT)
## recording done on Friday 10 April 2020 16:54:44 UTC
## computer time zone (local time, Europe, Paris for the test)
audiomoth("5E90A4D4.WAV")
## UTC
audiomoth("5E90A4D4.WAV", tz="UTC")
## GMT (= UTC as UTC and GMT are synonyms)    
audiomoth("5E90A4D4.WAV", tz="GMT")
## UTC -2
audiomoth("5E90A4D4.WAV", tz="Etc/GMT-2")
## in Asia, Japan
audiomoth("5E90A4D4.WAV", tz="Japan")
## in South-America, Cayenne
audiomoth("5E90A4D4.WAV", tz="America/Cayenne")  
## several files
filenames &lt;- c("5E914ED0.WAV", "5E915128.WAV",
"5E915380.WAV", "5E9155D8.WAV", "5E915830.WAV",
"5E915A88.WAV", "5E915CE0.WAV", "5E915F38.WAV",
"5E916190.WAV", "5E9163E8.WAV")
audiomoth(filenames)
## YYYYMMDD_HHMMSS.WAV FORMAT (ACTUAL FORMAT)
## single file
audiomoth("20230715_150000.wav")
## several files
filenames &lt;- c("20230715_150000.wav", "20230715_151500.wav",
"20230715_153000.wav", "20230715_154500.wav")
audiomoth(filenames)
</code></pre>

<hr>
<h2 id='audiomoth.rename'>Rename audiomoth files in a readable format</h2><span id='topic+audiomoth.rename'></span>

<h3>Description</h3>

<p>This function renames or copies files created with an
Audiomoth device in a readable format including the data and time of recording.</p>


<h3>Usage</h3>

<pre><code class='language-R'>audiomoth.rename(dir, overwrite = FALSE, tz = "", prefix = "")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="audiomoth.rename_+3A_dir">dir</code></td>
<td>
<p>a character vector, path to directory where the .WAV files are
stored.</p>
</td></tr>
<tr><td><code id="audiomoth.rename_+3A_overwrite">overwrite</code></td>
<td>
<p>a logical, to specify if the files should be renamed
or copied, if <code>TRUE</code> the files are copied, if <code>FALSE</code> the files are renamed.</p>
</td></tr>
<tr><td><code id="audiomoth.rename_+3A_tz">tz</code></td>
<td>
<p>a character vector defining a time zone specification. See <code>as.POSIXct</code></p>
</td></tr>
<tr><td><code id="audiomoth.rename_+3A_prefix">prefix</code></td>
<td>
<p>a charcter vector for a prefix name to be added at the
beginning of the file name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The format of the new file names follows the format of the
SongMeter SM2/SM4 deveices: <code>PREFIX_YYYYMMDD_HHMMSS.wav</code>.</p>


<h3>Value</h3>

<p>1 logical vector indicating which operation succeeded for each of the files attempted.</p>


<h3>Note</h3>

<p>Be careful if you overwrite the files.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+audiomoth">audiomoth</a></code>, <code><a href="#topic+songmeter">songmeter</a></code></p>

<hr>
<h2 id='autoc'>Short-term autocorrelation of a time wave</h2><span id='topic+autoc'></span>

<h3>Description</h3>

<p>This function returns the fundamental frequency of a harmonic time wave. This is
achieved by computing a correlation of the signal with itself
after a time delay. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoc(wave, f, channel = 1, wl = 512, fmin, fmax, threshold = NULL, plot = TRUE,
xlab = "Time (s)", ylab = "Frequency (kHz)", ylim = c(0, f/2000), pb =
FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoc_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="autoc_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="autoc_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="autoc_+3A_wl">wl</code></td>
<td>
<p>length of the window for the analysis (even number of points,
by default = 512).</p>
</td></tr>
<tr><td><code id="autoc_+3A_fmin">fmin</code></td>
<td>
<p>the minimum frequency to detect (in Hz). See details.</p>
</td></tr>
<tr><td><code id="autoc_+3A_fmax">fmax</code></td>
<td>
<p>the maximum frequency to detect (in Hz). See details</p>
</td></tr>
<tr><td><code id="autoc_+3A_threshold">threshold</code></td>
<td>
<p>amplitude threshold for signal detection (in %).</p>
</td></tr>
<tr><td><code id="autoc_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the fundamental frequency 
against time (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="autoc_+3A_xlab">xlab</code></td>
<td>
<p>title of the x-axis.</p>
</td></tr>
<tr><td><code id="autoc_+3A_ylab">ylab</code></td>
<td>
<p>title of the y-axis.</p>
</td></tr>
<tr><td><code id="autoc_+3A_ylim">ylim</code></td>
<td>
<p>the range of y values.</p>
</td></tr>
<tr><td><code id="autoc_+3A_pb">pb</code></td>
<td>
<p>if <code>TRUE</code> returns a text progress bar in the console.</p>
</td></tr>
<tr><td><code id="autoc_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'fmin' and 'fmax' can help by reducing computing time but can
also produce less accurate results.</p>


<h3>Value</h3>

<p>When <code>plot</code> is <code>FALSE</code>, <code>autoc</code> returns a two-column matrix, the first column corresponding to time in seconds (<em>x</em>-axis) and the second column corresponding to 
to fundamental frequency in kHz (<em>y</em>-axis).<br />
NA corresponds to pause sections in <code>wave</code> (see <code>threshold</code>). 
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a> and 
Thierry Aubin <a href="mailto:thierry.aubin@u-psud.fr">thierry.aubin@u-psud.fr</a></p>


<h3>References</h3>

<p>Hopp, S. L., Owren, M. J. and Evans, C. S. (Eds) 1998. <em>Animal acoustic 
communication</em>. Springer, Berlin, Heidelberg.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceps">ceps</a></code>, <code><a href="stats.html#topic+acf">acf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sheep)
# fundamental frequency of a sheep
res &lt;- autoc(sheep, f=8000, threshold=5, fmin=100, fmax=700, plot=FALSE)
spectro(sheep, f=8000, ovlp=75, scale=FALSE)
points(res, pch=20)
legend(0.5, 3.6, "Fundamental frequency", pch=20, bty=0, cex=0.7)
</code></pre>

<hr>
<h2 id='beep'>Beep sound</h2><span id='topic+beep'></span>

<h3>Description</h3>

<p>Generate a simple beep to be used as an alert, for instance
at the end of a loop of when ending up a long script.</p>


<h3>Usage</h3>

<pre><code class='language-R'>beep(d = 0.5, f = 8000, cf = 1000)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beep_+3A_d">d</code></td>
<td>
<p>duration (in s)</p>
</td></tr>
<tr><td><code id="beep_+3A_f">f</code></td>
<td>
<p>sampling frequency (in Hz)</p>
</td></tr>
<tr><td><code id="beep_+3A_cf">cf</code></td>
<td>
<p>carrier frequency (in Hz)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing returned, a pure tone sound is played back. The default
duration is 0.5 s and the default frequency is 1000 Hz</p>


<h3>Note</h3>

<p>The function uses <code><a href="#topic+listen">listen</a></code> of <code>seewave</code> which
calls <code>play</code> of <code>tuneR</code>. You might need to set up your sound
player with <code>setWavPlayer</code> of <code>tuneR</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# default settings
beep()
# change the duration and the frequency
beep(d=1, cf=880)

## End(Not run)
</code></pre>

<hr>
<h2 id='bwfilter'>Butterworth frequency filter</h2><span id='topic+bwfilter'></span>

<h3>Description</h3>

<p>This function is a Butterworth frequency filter that filters
out a selected frequency section of of a time wave (low-pass, high-pass, low-stop, high-stop, bandpass or bandstop frequency filter).</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwfilter(wave, f, channel = 1, n = 1, from = NULL, to = NULL,
bandpass = TRUE, listen = FALSE, output = "matrix")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwfilter_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="bwfilter_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="bwfilter_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="bwfilter_+3A_n">n</code></td>
<td>
<p>Order of the filter. See details.</p>
</td></tr>
<tr><td><code id="bwfilter_+3A_from">from</code></td>
<td>
<p>start frequency (in Hz) where to apply the filter.</p>
</td></tr>
<tr><td><code id="bwfilter_+3A_to">to</code></td>
<td>
<p>end frequency (in Hz) where to apply the filter.</p>
</td></tr>
<tr><td><code id="bwfilter_+3A_bandpass">bandpass</code></td>
<td>
<p>if <code>TRUE</code> a band-pass filter is applied between
<code>from</code> and  <code>to</code>, if not <code>NULL</code> a band-stop filter is applied
between <code>from</code> and  <code>to</code> (by default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="bwfilter_+3A_listen">listen</code></td>
<td>
<p>if <code>TRUE</code> the new sound is played back.</p>
</td></tr>
<tr><td><code id="bwfilter_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of the filter determines the value of the roll-off value, that
is the dB decrease per octave of the transfer function. A filter of order <em>n</em> will have a
transfer function with a roll-off value of - <em>n*6</em> dB.
</p>


<h3>Value</h3>

<p>A new wave is returned. The class
of the returned object is set with the argument <code>output</code>.
</p>


<h3>Note</h3>

<p>This function mainly uses the functions <code>filter()</code> and
<code>filtfilt()</code> from the package <code>signal</code>
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, functions <code>filter()</code> and
<code>filtfilt()</code> from the package <code>signal</code>.
</p>


<h3>References</h3>

<p>Stoddard, P. K. (1998). Application of filters in bioacoustics.
<em>In</em>: Hopp, S. L., Owren, M. J. and Evans, C. S. (Eds), <em>Animal acoustic 
communication</em>. Springer, Berlin, Heidelberg,pp. 105-127.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffilter">ffilter</a></code>, <code><a href="#topic+bwfilter">bwfilter</a></code>, <code><a href="#topic+preemphasis">preemphasis</a></code>, <code><a href="#topic+lfs">lfs</a></code>, <code><a href="#topic+afilter">afilter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(signal)
f &lt;- 8000
a &lt;- noisew(f=f, d=1)
## low-pass
# 1st order filter
res &lt;- bwfilter(a, f=f, n=1, to=1500)
# 8th order filter
res &lt;- bwfilter(a, f=f, n=8, to=1500)
## high-pass
res &lt;- bwfilter(a, f=f, from=2500)
## band-pass
res &lt;- bwfilter(a, f=f, from=1000, to=2000)
## band-stop
res &lt;- bwfilter(a, f=f, from=1000, to=2000,bandpass=FALSE)
</code></pre>

<hr>
<h2 id='ccoh'>Continuous coherence function between two time waves</h2><span id='topic+ccoh'></span>

<h3>Description</h3>

<p>This function returns a two-dimension coherence representation between two time
waves. The function corresponds to a sliding coherence function along the 
two signals. This produces a 2-D density plot.
An amplitude contour plot can be overlaid.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccoh(wave1, wave2, f, channel = c(1,1), wl = 512, ovlp = 0, plot = TRUE,
grid = TRUE, scale = TRUE, cont = FALSE,
collevels = seq(0, 1, 0.01), palette = reverse.heat.colors,
contlevels = seq(0, 1, 0.01), colcont = "black",
colbg="white", colgrid = "black",
colaxis = "black", collab="black",
xlab = "Time (s)", ylab = "Frequency (kHz)",
scalelab = "Coherence",
main = NULL,
scalefontlab = 1, scalecexlab =0.75, axisX = TRUE, axisY = TRUE,
flim = NULL, flimd = NULL,
...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccoh_+3A_wave1">wave1</code></td>
<td>
<p>a first R object</p>
</td></tr>
<tr><td><code id="ccoh_+3A_wave2">wave2</code></td>
<td>
<p>a second R object</p>
</td></tr>
<tr><td><code id="ccoh_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_channel">channel</code></td>
<td>
<p>channel of the R objects, by default left channel (1)
for each object.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_wl">wl</code></td>
<td>
<p>window length for the analysis
(even number of points, by default = 512).</p>
</td></tr>
<tr><td><code id="ccoh_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in %).</p>
</td></tr>
<tr><td><code id="ccoh_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the continuous coherence function
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ccoh_+3A_grid">grid</code></td>
<td>
<p>logical, if <code>TRUE</code> plots a y-axis grid
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ccoh_+3A_scale">scale</code></td>
<td>
<p>logical, if <code>TRUE</code> plots a dB colour scale on the right
side of the plot (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ccoh_+3A_cont">cont</code></td>
<td>
<p>logical, if <code>TRUE</code> overplots contour lines on the plot
(by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="ccoh_+3A_collevels">collevels</code></td>
<td>
<p>a set of levels which are used to partition
the amplitude range of the coherence (should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_palette">palette</code></td>
<td>
<p>a color palette function to be used to assign colors in
the plot, see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_contlevels">contlevels</code></td>
<td>
<p>a set of levels which are used to partition
the amplitude range for contour overplot (in dB).</p>
</td></tr>
<tr><td><code id="ccoh_+3A_colcont">colcont</code></td>
<td>
<p>colour for <code>cont</code> plotting.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_colbg">colbg</code></td>
<td>
<p>background colour.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_colgrid">colgrid</code></td>
<td>
<p>colour for <code>grid</code> plotting.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_colaxis">colaxis</code></td>
<td>
<p>color of the axes.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_collab">collab</code></td>
<td>
<p>color of the labels.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_xlab">xlab</code></td>
<td>
<p>label of the time axis.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_ylab">ylab</code></td>
<td>
<p>label of the frequency axis.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_scalelab">scalelab</code></td>
<td>
<p>label fo the amplitude scale.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_main">main</code></td>
<td>
<p>label of the main title.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_scalefontlab">scalefontlab</code></td>
<td>
<p>font of the amplitude scale label.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_scalecexlab">scalecexlab</code></td>
<td>
<p>cex of the amplitude scale label.</p>
</td></tr>
<tr><td><code id="ccoh_+3A_axisx">axisX</code></td>
<td>
<p>logical, if <code>TRUE</code> plots time X-axis (by default <code>TRUE</code>).</p>
</td></tr>  
<tr><td><code id="ccoh_+3A_axisy">axisY</code></td>
<td>
<p>logical, if <code>TRUE</code> plots frequency Y-axis (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ccoh_+3A_flim">flim</code></td>
<td>
<p>modifications of the frequency Y-axis limits.</p>
</td></tr> 
<tr><td><code id="ccoh_+3A_flimd">flimd</code></td>
<td>
<p>dynamic modifications of the frequency Y-axis limits. New <code>wl</code>
and <code>ovlp</code> arguments are applied to increase time/frequency resolution.</p>
</td></tr>    
<tr><td><code id="ccoh_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+contour">contour</a></code> and <code><a href="#topic+oscillo">oscillo</a></code>
graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coherence is a frequency domain function computed to show the degree
of a relationship between two signals.
The value of the coherence function ranges between zero and one,
where a value of zero indicates there is no causal relationship between the signals.
A value of one indicates the existence of linear frequency response between the
two signals. This can be used, for instance, to compare the input and output
signals of a system.<br />
Any colour palette can be used. In particular, it is possible to use other
palettes coming with <span class="pkg">seewave</span>: <code>temp.colors</code>, <code>reverse.gray.colors.1</code>,
<code>reverse.gray.colors.2</code>, 
<code>spectro.colors</code>, <code>reverse.terrain.colors</code>,
<code>reverse.topo.colors</code>, <code>reverse.cm.colors</code> corresponding
to the reverse of  <code>terrain.colors</code>, <code>topo.colors</code>,
<code>cm.colors</code>.<br />
Use <code><a href="graphics.html#topic+locator">locator</a></code> to identify  points.
</p>


<h3>Value</h3>

<p>This function returns a list of three items:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>a numeric vector corresponding to the time axis.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>a numeric vector corresponding to the frequency axis.</p>
</td></tr>
<tr><td><code>amp</code></td>
<td>
<p>a numeric matrix corresponding to the coherence.
Each column corresponds to a coherence function of length <code>wl</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is based on <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code> and
<code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>. See <code><a href="#topic+spectro">spectro</a></code> for graphical changes.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a> but this function is
mainly based on <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code> by Martyn Plummer, Adrian Trapletti
and B.D. Ripley</p>


<h3>See Also</h3>

<p><code><a href="#topic+coh">coh</a></code>, <code><a href="#topic+spectro">spectro</a></code>, <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>wave1&lt;-synth(d=1,f=4000,cf=500)
wave2&lt;-synth(d=1,f=4000,cf=800)
ccoh(wave1,wave2,f=4000)
</code></pre>

<hr>
<h2 id='ceps'>Cepstrum or real cepstrum</h2><span id='topic+ceps'></span>

<h3>Description</h3>

<p>This function returns the cepstrum of a time wave allowing fundamental
frequency detection.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ceps(wave, f, channel = 1, phase = FALSE, wl = 512, at = NULL, from = NULL, to = NULL,
tidentify = FALSE, fidentify = FALSE, col = "black", cex = 1, plot = TRUE,
qlab = "Quefrency (bottom: s, up: Hz)", alab = "Amplitude",
qlim = NULL, alim = NULL, type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ceps_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="ceps_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="ceps_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="ceps_+3A_phase">phase</code></td>
<td>
<p>if <code>TRUE</code> than the phase is taken into account in
the computation of the cepstrum.</p>
</td></tr>
<tr><td><code id="ceps_+3A_wl">wl</code></td>
<td>
<p>if <code>at</code> is not null, length of the window for the analysis
(even number of points, by defaults = 512).</p>
</td></tr>
<tr><td><code id="ceps_+3A_at">at</code></td>
<td>
<p>position where to compute the cepstrum (in s).</p>
</td></tr>
<tr><td><code id="ceps_+3A_from">from</code></td>
<td>
<p>start position where to compute the cepstrum (in s).</p>
</td></tr>
<tr><td><code id="ceps_+3A_to">to</code></td>
<td>
<p>end position to compute the cepstrum (in s).</p>
</td></tr>
<tr><td><code id="ceps_+3A_tidentify">tidentify</code></td>
<td>
<p>to identify time values on the plot with the help of a cursor.</p>
</td></tr>
<tr><td><code id="ceps_+3A_fidentify">fidentify</code></td>
<td>
<p>to identify frequency values on the plot with the help of a cursor.</p>
</td></tr>
<tr><td><code id="ceps_+3A_col">col</code></td>
<td>
<p>colour of the cepstrum.</p>
</td></tr>
<tr><td><code id="ceps_+3A_cex">cex</code></td>
<td>
<p>pitch size of the cepstrum.</p>
</td></tr>
<tr><td><code id="ceps_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the cepstrum.</p>
</td></tr>
<tr><td><code id="ceps_+3A_qlab">qlab</code></td>
<td>
<p>title of the quefrency axis (in s).</p>
</td></tr>
<tr><td><code id="ceps_+3A_alab">alab</code></td>
<td>
<p>title of the amplitude axis.</p>
</td></tr>
<tr><td><code id="ceps_+3A_qlim">qlim</code></td>
<td>
<p>range of quefrency axis.</p>
</td></tr>
<tr><td><code id="ceps_+3A_alim">alim</code></td>
<td>
<p>range of amplitude axis.</p>
</td></tr>
<tr><td><code id="ceps_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>  
<tr><td><code id="ceps_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cepstrum of a time wave is the inverse Fourier transform of the logarithm
of the Fourier transform. The cepstrum of a wave <em>s</em> is then calculated as follows:<br />
</p>
<p style="text-align: center;"><code class="reqn">C(s) = Re[FFT^{-1}(\log{(|FFT(s)|)]}</code>
</p>
<p><br />
</p>
<p>The independent variable of a cepstral graph is called the quefrency.
The quefrency is a measure of time, though not in the sense of a signal
in the time domain. A correspondence with the frequency domain is obtained
by simply computing the reverse of the temporal x coordinate. For instance if
a peak appears at 0.005 s, this reveals a frequency peak at 200 Hz (=1/0.005).
This explain the two scales plotted when <code>plot</code> is <code>TRUE</code>. <br />
If <code>at</code>, <code>from</code> or <code>to</code> are <code>FALSE</code> then <code>ceps</code> 
computes the cepstrum of the whole signal.<br />
When using <code>tidentify</code> or <code>tidentify</code>, press &lsquo;stop&rsquo;
tools bar button to return values in the console.
</p>


<h3>Value</h3>

<p>When <code>plot</code> is <code>FALSE</code>, <code>ceps</code> returns the cesptral profile as a two-column matrix, the first column corresponding to quefrency (<em>x</em>-axis) and the second
corresponding to amplitude (<em>y</em>-axis).
</p>


<h3>Warning</h3>

<p>The argument <code>peaks</code> is no more available
(version &gt; 1.5.6). See the function <code><a href="#topic+fpeaks">fpeaks</a></code>
for peak(s) detection.</p>


<h3>Note</h3>

<p>Cepstral analysis is mainly used in speech processing.
This analysis allows to extract the fundamental frequency, see the examples.<br />
This function is based on <code><a href="stats.html#topic+fft">fft</a></code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Oppenheim, A.V. and Schafer, R.W. 2004. From frequency
to quefrency: a history of the cepstrum. <em>Signal Processing Magazine IEEE</em>,
21: 95-106.</p>


<h3>See Also</h3>

<p><code><a href="#topic+cepstro">cepstro</a></code>, <code><a href="#topic+fund">fund</a></code>, <code><a href="#topic+autoc">autoc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sheep)
par(mfrow=c(2,1))
# phase not taken into account
ceps(sheep,f=8000,at=0.4,wl=1024)
# phase taken into account
ceps(sheep,f=8000,at=0.4,wl=1024, phase=TRUE)
</code></pre>

<hr>
<h2 id='cepstro'>2D-cepstrogram of a time wave</h2><span id='topic+cepstro'></span>

<h3>Description</h3>

<p>This function returns a two-dimension cepstrographic representation of a time
wave. The function corresponds to a short-term cepstral transform.
An amplitude contour plot can be overlaid.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cepstro(wave, f, channel = 1, wl = 512, ovlp = 0, plot = TRUE, grid = TRUE,
scale = TRUE, cont = FALSE, collevels = seq(0, 1, 0.01),
palette = reverse.heat.colors, contlevels = seq(0, 1, 0.01),
colcont = "black", colbg="white", colgrid = "black",
colaxis = "black", collab = "black",
xlab = "Time (s)", ylab = "Quefrency (ms)",
scalelab = "Amplitude", main = NULL, scalefontlab = 1, scalecexlab = 0.75,
axisX = TRUE, axisY = TRUE, tlim = NULL, qlim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cepstro_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="cepstro_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="cepstro_+3A_wl">wl</code></td>
<td>
<p>if <code>at</code> is not null, length of the window for the analysis
(even number of points, by defaults = 512).</p>
</td></tr>
<tr><td><code id="cepstro_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in %).</p>
</td></tr>
<tr><td><code id="cepstro_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the cepstrogram
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="cepstro_+3A_grid">grid</code></td>
<td>
<p>logical, if <code>TRUE</code> plots a y-axis grid
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="cepstro_+3A_scale">scale</code></td>
<td>
<p>logical, if <code>TRUE</code> plots a dB colour scale on the right
side of the cesptrogram (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="cepstro_+3A_cont">cont</code></td>
<td>
<p>logical, if <code>TRUE</code> overplots contour lines on the cepstrogram
(by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="cepstro_+3A_collevels">collevels</code></td>
<td>
<p>a set of levels which are used to partition
the amplitude range of the cepstrogram (in dB).</p>
</td></tr>
<tr><td><code id="cepstro_+3A_palette">palette</code></td>
<td>
<p>a color palette function to be used to assign colors in
the plot.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_contlevels">contlevels</code></td>
<td>
<p>a set of levels which are used to partition
the amplitude range for contour overplot (in dB).</p>
</td></tr>
<tr><td><code id="cepstro_+3A_colcont">colcont</code></td>
<td>
<p>colour for <code>cont</code> plotting.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_colbg">colbg</code></td>
<td>
<p>background colour.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_colgrid">colgrid</code></td>
<td>
<p>colour for <code>grid</code> plotting.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_colaxis">colaxis</code></td>
<td>
<p>color of the axes.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_collab">collab</code></td>
<td>
<p>color of the labels.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_xlab">xlab</code></td>
<td>
<p>label of the time axis.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_ylab">ylab</code></td>
<td>
<p>label of the quefrency axis.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_main">main</code></td>
<td>
<p>label of the main title.</p>
</td></tr> 
<tr><td><code id="cepstro_+3A_scalelab">scalelab</code></td>
<td>
<p>amplitude scale label.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_scalefontlab">scalefontlab</code></td>
<td>
<p>font of the amplitude scale label.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_scalecexlab">scalecexlab</code></td>
<td>
<p>cex of the amplitude scale label.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_axisx">axisX</code></td>
<td>
<p>if <code>TRUE</code> plots time X-axis (by default <code>TRUE</code>).</p>
</td></tr>  
<tr><td><code id="cepstro_+3A_axisy">axisY</code></td>
<td>
<p>if <code>TRUE</code> plots frequency Y-axis (by default <code>TRUE</code>).</p>
</td></tr>  
<tr><td><code id="cepstro_+3A_tlim">tlim</code></td>
<td>
<p>modifications of the time X-axis limits.</p>
</td></tr>
<tr><td><code id="cepstro_+3A_qlim">qlim</code></td>
<td>
<p>modifications of the quefrency Y-axis limits (in ms).</p>
</td></tr> 
<tr><td><code id="cepstro_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+contour">contour</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is unfortunately not possible to turn the <em>y</em>-axis to a frequency scale.<br />
See <code><a href="#topic+spectro">spectro</a></code> for the use of the graphical arguments. 
</p>


<h3>Value</h3>

<p>This function returns a list of three items:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>a numeric vector corresponding to the time axis.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>a numeric vector corresponding to the quefrency axis.</p>
</td></tr>
<tr><td><code>amp</code></td>
<td>
<p>a numeric matrix corresponding to the the successive
cepstral profiles computed along time.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is based on <code><a href="#topic+ceps">ceps</a></code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a>.</p>


<h3>References</h3>

<p>Oppenheim, A.V. and Schafer, R.W. 2004. From frequency
to quefrency: a history of the cepstrum. <em>Signal Processing Magazine IEEE</em>,
21: 95-106.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceps">ceps</a></code>, <code><a href="#topic+fund">fund</a></code>, <code><a href="#topic+autoc">autoc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sheep)
sheepc &lt;- cutw(sheep, f=8000, from = 0.19, to = 2.3)
cepstro(sheepc,f=8000)
</code></pre>

<hr>
<h2 id='coh'>Coherence between two time waves</h2><span id='topic+coh'></span>

<h3>Description</h3>

<p>This function returns the frequency coherence between two time
waves.</p>


<h3>Usage</h3>

<pre><code class='language-R'>coh(wave1, wave2, f, channel=c(1,1), plot =TRUE, xlab = "Frequency (kHz)",
ylab = "Coherence", xlim = c(0,f/2000), type = "l",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coh_+3A_wave1">wave1</code></td>
<td>
<p>a first R object.</p>
</td></tr>     
<tr><td><code id="coh_+3A_wave2">wave2</code></td>
<td>
<p>a second R object.</p>
</td></tr>     
<tr><td><code id="coh_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="coh_+3A_channel">channel</code></td>
<td>
<p>channel of the R objects, by default left channel (1)
for each object.</p>
</td></tr>
<tr><td><code id="coh_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the continuous coherence function
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="coh_+3A_xlab">xlab</code></td>
<td>
<p>title of the frequency X-axis.</p>
</td></tr>
<tr><td><code id="coh_+3A_ylab">ylab</code></td>
<td>
<p>title of the coherence Y-axis.</p>
</td></tr>
<tr><td><code id="coh_+3A_xlim">xlim</code></td>
<td>
<p>range of frequency X-axis.</p>
</td></tr>
<tr><td><code id="coh_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="coh_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coherence is a frequency domain function computed to show the degree of a relationship
between two signals. The value of the coherence function ranges between zero and one,
where a value of zero indicates there is no causal relationship between the signals.
A value of one indicates the existence of linear frequency response between the
two signals. This can be used, for instance, to compare the input and output
signals of a system.
</p>


<h3>Value</h3>

<p>When <code>plot</code> is <code>FALSE</code>, this <code>coh</code> returns a two-column matrix, the
first column being the frequency axis in kHz (<em>x</em>-axis) and the second column being the coherence (<em>y</em>-axis).</p>


<h3>Note</h3>

<p>This function is based on <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a> but this function
is based on <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>
by Martyn Plummer, Adrian Trapletti and B.D. Ripley.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccoh">ccoh</a></code>, <code><a href="#topic+spectro">spectro</a></code>, <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>wave1&lt;-synth(d=1,f=4000,cf=500)
wave2&lt;-synth(d=1,f=4000,cf=800)
coh(wave1,wave2,f=4000)
</code></pre>

<hr>
<h2 id='combfilter'>Comb filter</h2><span id='topic+combfilter'></span>

<h3>Description</h3>

<p>This function processes a feedforward comb filter and plots a spectrogram of the filtered wave asso-
ciated with the frequency response of the filter.</p>


<h3>Usage</h3>

<pre><code class='language-R'>combfilter(wave, f, channel = 1, alpha, K, units = c("samples", "seconds"),
plot = FALSE, output = "matrix", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combfilter_+3A_wave">wave</code></td>
<td>
<p>an <code>R</code> object</p>
</td></tr>
<tr><td><code id="combfilter_+3A_f">f</code></td>
<td>
<p>sampling frequency (in Hz). Does not need to be specified if
embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="combfilter_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="combfilter_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector of length 1 for the scaling factor. See Details.</p>
</td></tr>
<tr><td><code id="combfilter_+3A_k">K</code></td>
<td>
<p>a numeric vector of lenght 1 for the delay length, in
<code>units</code>. See Details.</p>
</td></tr>
<tr><td><code id="combfilter_+3A_units">units</code></td>
<td>
<p>units in which <code>K</code> is given, the default is
<code>'samples'</code> but can be set to <code>'seconds'</code>.</p>
</td></tr>
<tr><td><code id="combfilter_+3A_plot">plot</code></td>
<td>
<p>a logical, if <code>TRUE</code> plots the spectrogram of the
filtered <code>wave</code> and the frequency response of the comb filter.</p>
</td></tr>
<tr><td><code id="combfilter_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return,
either <code>'matrix'</code>, <code>'Wave'</code>, <code>'Sample'</code>,
<code>'audioSample'</code> or <code>'ts'</code>.</p>
</td></tr>
<tr><td><code id="combfilter_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code><a href="#topic+spectro">spectro</a></code>
except <code>scale</code> and <code>osc</code> that are set by default to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A comb filter consists in adding a delayed version of a signal to itself resulting in constructive and destructive interference. The feedforward version of a comb filter can be written following:
</p>
<p style="text-align: center;"><code class="reqn">y(n) = x(n) + \alpha \times x(n - K)</code>
</p>

<p>where alpha is the scaling factor and K the delay length.
The frequency response of the filter is obtained with:
</p>
<p style="text-align: center;"><code class="reqn">H(f) = \sqrt{(1+\alpha^2)+2 \times \cos(\omega K)}</code>
</p>

<p>The frequency response is periodic. The depth of the cycles is controlled with alpha and the number of cycles with K.
</p>


<h3>Value</h3>

<p>A new wave is returned. The class of the returned object is set with the argument <code>output</code>.</p>


<h3>Note</h3>

<p>Setting K to high values may generate unwanted results. <br />
The feedback form of the combfilter is not implemented yet.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+combfilter">combfilter</a></code>, <code><a href="#topic+fir">fir</a></code>, <code><a href="#topic+squarefilter">squarefilter</a></code>, <code><a href="#topic+drawfilter">drawfilter</a></code>, <code><a href="#topic+ffilter">ffilter</a></code>, <code><a href="#topic+bwfilter">bwfilter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
f &lt;- 44100
## chirp
s1 &lt;- synth(f=f, cf=1, d=2, fm=c(0,0,f/2,0,0), out="Wave")
combfilter(s1, alpha=1, K=50, plot=TRUE)
## harmonic sound
s2 &lt;- synth(f=f, d=2, cf=600, harmonics=rep(1, 35), output="Wave")
combfilter(s2, alpha=1, K=10, plot=TRUE)
## noise, units in seconds
s3 &lt;- noisew(d=2, f=44100, out="Wave")
combfilter(s3, alpha=0.5, K=1e-4, units="seconds", plot=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='convSPL'>Convert sound pressure level in other units</h2><span id='topic+convSPL'></span>

<h3>Description</h3>

<p>This function converts sound pressure level (in dB)
in sound power (Watt), intensity (Watt/m2) and pressure (Pa). By default, these
conversions are applied to air-borne sound.</p>


<h3>Usage</h3>

<pre><code class='language-R'>convSPL(x, d = 1, Iref = 10^-12, pref = 2*10^-5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convSPL_+3A_x">x</code></td>
<td>
<p>a numeric vector or a matrix describind SPL values (in dB).</p>
</td></tr>
<tr><td><code id="convSPL_+3A_d">d</code></td>
<td>
<p>the distance from the sound source where SPL values have been
measured (in meter) (by default = 1m)</p>
</td></tr>
<tr><td><code id="convSPL_+3A_iref">Iref</code></td>
<td>
<p>reference intensity (in Watt/m2) (by default = 10^-12)</p>
</td></tr>
<tr><td><code id="convSPL_+3A_pref">pref</code></td>
<td>
<p>reference pressure (in Pa) (by default = 2*10^-5)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>convSPL</code> returns a list containing three components:
</p>
<table>
<tr><td><code>P</code></td>
<td>
<p>data converted in sound power (in Watt).</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>data converted in sound intensity (in Watt/m2).</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>data converted in sound pressure (in Pa).</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>Iref</code> and <code>pref</code> correspond to a 1 kHz sound in air. 
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Hartmann, W. M. 1998 <em>Signals, sound and sensation</em>. New York: Springer.</p>


<h3>See Also</h3>

<p><code><a href="#topic+moredB">moredB</a></code>, <code><a href="#topic+dBweight">dBweight</a></code>, <code><a href="#topic+attenuation">attenuation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># conversion of two SPL measurements taken at 0.5 m from the source
convSPL(c(80,85),d=0.5) 
</code></pre>

<hr>
<h2 id='corenv'>Cross-correlation between two time wave envelopes</h2><span id='topic+corenv'></span>

<h3>Description</h3>

<p>This function tests the similarity between two time wave envelopes by returning
their maximal correlation and the time shift related to it. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corenv(wave1, wave2, f, channel=c(1,1), envt="hil", msmooth = NULL, ksmooth = NULL,
ssmooth = NULL, plot = TRUE, plotval = TRUE,
method = "spearman", col = "black", colval = "red",
cexval = 1, fontval = 1, xlab = "Time (s)",
ylab = "Coefficient of correlation (r)", type = "l", pb = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corenv_+3A_wave1">wave1</code></td>
<td>
<p>a first R object.</p>
</td></tr>     
<tr><td><code id="corenv_+3A_wave2">wave2</code></td>
<td>
<p>a second R object.</p>
</td></tr>
<tr><td><code id="corenv_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="corenv_+3A_channel">channel</code></td>
<td>
<p>channel of the R objects, by default left channel (1)
for each object.</p>
</td></tr>
<tr><td><code id="corenv_+3A_envt">envt</code></td>
<td>
<p>the type of envelope to be used: either &quot;abs&quot; for absolute
amplitude envelope or &quot;hil&quot; for Hilbert amplitude envelope. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="corenv_+3A_msmooth">msmooth</code></td>
<td>
<p>a vector of length 2 to smooth the amplitude envelope with a 
mean sliding window. The first component is the window length
(in number of points). The second component is the overlap between
successive windows (in %). See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="corenv_+3A_ksmooth">ksmooth</code></td>
<td>
<p>kernel smooth via <code><a href="stats.html#topic+kernel">kernel</a></code>. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="corenv_+3A_ssmooth">ssmooth</code></td>
<td>
<p>sum smooth. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="corenv_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots r values against frequency shift
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="corenv_+3A_plotval">plotval</code></td>
<td>
<p>logical, if <code>TRUE</code> adds to the plot maximum r value
and frequency offset (by default <code>TRUE</code>).</p>
</td></tr>  
<tr><td><code id="corenv_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation coefficient is
to be computed (&quot;pearson&quot;, &quot;spearman&quot;, or &quot;kendall&quot;)
(see <code><a href="stats.html#topic+cor">cor</a></code>).</p>
</td></tr>
<tr><td><code id="corenv_+3A_col">col</code></td>
<td>
<p>colour of r values.</p>
</td></tr>
<tr><td><code id="corenv_+3A_colval">colval</code></td>
<td>
<p>colour of r max and frequency offset values.</p>
</td></tr>
<tr><td><code id="corenv_+3A_cexval">cexval</code></td>
<td>
<p>character size of r max and frequency offset values.</p>
</td></tr>
<tr><td><code id="corenv_+3A_fontval">fontval</code></td>
<td>
<p>font of r max and frequency offset values.</p>
</td></tr>
<tr><td><code id="corenv_+3A_xlab">xlab</code></td>
<td>
<p>title of the frequency axis.</p>
</td></tr>
<tr><td><code id="corenv_+3A_ylab">ylab</code></td>
<td>
<p>title of the r axis.</p>
</td></tr>
<tr><td><code id="corenv_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="corenv_+3A_pb">pb</code></td>
<td>
<p>if <code>TRUE</code> returns a text progress bar in the console.</p>
</td></tr>
<tr><td><code id="corenv_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Successive correlations between the envelopes of <code>wave1</code> and <code>wave2</code>
are computed when regularly sliding forward and backward <code>wave2</code> along
<code>wave1</code>.<br />
The maximal correlation is obtained at a particular shift (time offset). 
This shift may be positive or negative.<br />
The higher <code>smooth</code> is set up,
the faster will be the computation but less precise the results will be.<br /> 
The corresponding p value, obtained with <code><a href="stats.html#topic+cor.test">cor.test</a></code>, is  plotted.
Inverting <code>wave1</code> and <code>wave2</code> may give slight different results.
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, <code>corenv</code> returns a list containing four
components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a two-column matrix, the first colum corresponding to the time
shift (frequency x-axis) and the second column corresponding to the successive
r correlation values between <code>env1</code> and <code>env2</code> (correlation y-axis).</p>
</td></tr>
<tr><td><code>rmax</code></td>
<td>
<p>the maximum correlation value between <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the p value corresponding to <code>rmax</code>.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>the time offset corresponding to <code>rmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+env">env</a></code>,<code><a href="#topic+corspec">corspec</a></code>,<code><a href="#topic+covspectro">covspectro</a></code>,
<code><a href="stats.html#topic+cor">cor</a></code>,<code><a href="stats.html#topic+cor.test">cor.test</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(orni)
# cross-correlation between two echemes of a cicada song
wave1&lt;-cutw(orni,f=22050,from=0.3,to=0.4,plot=FALSE)
wave2&lt;-cutw(orni,f=22050,from=0.58,to=0.68,plot=FALSE)
corenv(wave1,wave2,f=22050)

## End(Not run)
</code></pre>

<hr>
<h2 id='corspec'>Cross-correlation between two frequency spectra</h2><span id='topic+corspec'></span>

<h3>Description</h3>

<p>This function tests the similarity between two frequency spectra by returning
their maximal correlation and the frequency shift related to it. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corspec(spec1, spec2, f = NULL, mel = FALSE, plot = TRUE, plotval = TRUE,
method = "spearman", col = "black", colval = "red",
cexval = 1, fontval = 1, xlab = NULL,
ylab = "Coefficient of correlation (r)", type="l",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corspec_+3A_spec1">spec1</code></td>
<td>
<p>a first data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This
can be either a two-column matrix (col1 = frequency, col2 = amplitude)
or a vector (amplitude).</p>
</td></tr>
<tr><td><code id="corspec_+3A_spec2">spec2</code></td>
<td>
<p>a first data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This
can be either a two-column matrix (col1 = frequency, col2 = amplitude)
or a vector (amplitude).</p>
</td></tr>
<tr><td><code id="corspec_+3A_f">f</code></td>
<td>
<p>sampling frequency of waves used to obtain <code>spec1</code>
and <code>spec2</code> (in Hz). Not necessary if <code>spec1</code> and/or <code>spec2</code>
is a two columns matrix obtained with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code>.</p>
</td></tr>
<tr><td><code id="corspec_+3A_mel">mel</code></td>
<td>
<p>a logical, if <code>TRUE</code> the (htk-)mel scale is used.</p>
</td></tr>
<tr><td><code id="corspec_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots r values against frequency shift (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="corspec_+3A_plotval">plotval</code></td>
<td>
<p>logical, if <code>TRUE</code> adds to the plot maximum r value
and frequency offset (by default <code>TRUE</code>).</p>
</td></tr>  
<tr><td><code id="corspec_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation coefficient is
to be computed (&quot;pearson&quot;, &quot;spearman&quot;, or &quot;kendall&quot;)
(see <code><a href="stats.html#topic+cor">cor</a></code>).</p>
</td></tr>
<tr><td><code id="corspec_+3A_col">col</code></td>
<td>
<p>colour of r values.</p>
</td></tr>
<tr><td><code id="corspec_+3A_colval">colval</code></td>
<td>
<p>colour of r max and frequency offset values.</p>
</td></tr>
<tr><td><code id="corspec_+3A_cexval">cexval</code></td>
<td>
<p>character size of r max and frequency offset values.</p>
</td></tr>
<tr><td><code id="corspec_+3A_fontval">fontval</code></td>
<td>
<p>font of r max and frequency offset values.</p>
</td></tr>
<tr><td><code id="corspec_+3A_xlab">xlab</code></td>
<td>
<p>title of the frequency axis.</p>
</td></tr>
<tr><td><code id="corspec_+3A_ylab">ylab</code></td>
<td>
<p>title of the r axis.</p>
</td></tr>
<tr><td><code id="corspec_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="corspec_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is important not to have data in dB.<br />
Successive correlations between <code>spec1</code> and <code>spec2</code> are computed when regularly
shifting <code>spec2</code> towards lower or higher frequencies.<br />
The maximal correlation is obtained at a particular shift (frequency offset). 
This shift may be positive or negative.<br />
The corresponding p value, obtained with <code><a href="stats.html#topic+cor.test">cor.test</a></code>, is plotted.<br />
Inverting <code>spec1</code> and <code>spec2</code> may give slight different results, see examples.
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, <code>corspec</code> returns a list containing four
components:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a two-column matrix, the first colum corresponding to the frequency
shift (frequency x-axis) and the second column corresponding to the successive
r correlation values between <code>spec1</code> and <code>spec2</code> (correlation y-axis).</p>
</td></tr>
<tr><td><code>rmax</code></td>
<td>
<p>the maximum correlation value between <code>spec1</code> and <code>spec2</code>.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the p value corresponding to <code>rmax</code>.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>the frequency offset corresponding to <code>rmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Sueur, improved by Laurent Lellouch</p>


<h3>References</h3>

<p>Hopp, S. L., Owren, M. J. and Evans, C. S. (Eds) 1998. <em>Animal acoustic 
communication</em>. Springer, Berlin, Heidelberg.</p>


<h3>See Also</h3>

<p><code><a href="#topic+spec">spec</a></code>, <code><a href="#topic+meanspec">meanspec</a></code>, <code><a href="#topic+corspec">corspec</a></code>,
<code><a href="#topic+covspectro">covspectro</a></code>, <code><a href="stats.html#topic+cor">cor</a></code>, <code><a href="stats.html#topic+cor.test">cor.test</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(tico)
## compare the two first notes spectra
a&lt;-spec(tico,f=22050,wl=512,at=0.2,plot=FALSE)
c&lt;-spec(tico,f=22050,wl=512,at=1.1,plot=FALSE)
op&lt;-par(mfrow=c(2,1), mar=c(4.5,4,3,1))
spec(tico,f=22050,at=0.2,col="blue")
par(new=TRUE)
spec(tico,f=22050,at=1.1,col="green")
legend(x=8,y=0.5,c("Note A", "Note C"),lty=1,col=c("blue","green"),bty="o")
par(mar=c(5,4,2,1))
corspec(a,c, ylim=c(-0.25,0.8),xaxs="i",yaxs="i",las=1)
par(op)
## different correlation methods give different results...
op&lt;-par(mfrow=c(3,1))
corspec(a,c,xaxs="i",las=1, ylim=c(-0.25,0.8))
title("spearmann correlation (by default)")
corspec(a,c,xaxs="i",las=1,ylim=c(0,1),method="pearson")
title("pearson correlation")
corspec(a,c,xaxs="i",las=1,ylim=c(-0.23,0.5),method="kendall")
title("kendall correlation")
par(op)
## inverting x and y does not give exactly similar results
op&lt;-par(mfrow=c(2,1),mar=c(2,4,3,1))
corspec(a,c)
corspec(c,a)
par(op)
## mel scale
require(tuneR)
data(orni)
orni.mel &lt;- melfcc(orni, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
orni.mel.mean &lt;- apply(orni.mel$aspectrum, MARGIN=2, FUN=mean)
tico.mel &lt;- melfcc(tico, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
tico.mel.mean &lt;- apply(tico.mel$aspectrum, MARGIN=2, FUN=mean)
corspec(orni.mel.mean, tico.mel.mean, f=22050, mel=TRUE, plot=TRUE)

## End(Not run)</code></pre>

<hr>
<h2 id='covspectro'>Covariance between two spectrograms</h2><span id='topic+covspectro'></span>

<h3>Description</h3>

<p>This function tests the similarity between two spectrograms by returning
their maximal covariance and the time shift related to it. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covspectro(wave1, wave2, f, channel = c(1,1), wl = 512, wn = "hanning", n,
plot = TRUE, plotval = TRUE,
method = "spearman", col = "black", colval = "red", cexval = 1,
fontval = 1, xlab = "Time (s)",
ylab = "Normalised covariance (cov)", type = "l", pb = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covspectro_+3A_wave1">wave1</code></td>
<td>
<p>a first R object.</p>
</td></tr>     
<tr><td><code id="covspectro_+3A_wave2">wave2</code></td>
<td>
<p>a second R object.</p>
</td></tr>
<tr><td><code id="covspectro_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="covspectro_+3A_channel">channel</code></td>
<td>
<p>channel of the R objects, by default left channel (1)
for each object.</p>
</td></tr>
<tr><td><code id="covspectro_+3A_wl">wl</code></td>
<td>
<p>length of the window for the analysis
(even number of points, by default = 512).</p>
</td></tr>
<tr><td><code id="covspectro_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="covspectro_+3A_n">n</code></td>
<td>
<p>number of covariances computed between <code>wave1</code> and <code>wave2</code>
when sliding <code>wave2</code> along <code>wave1</code>.</p>
</td></tr>
<tr><td><code id="covspectro_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots r values against frequency shift
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="covspectro_+3A_plotval">plotval</code></td>
<td>
<p>logical, if <code>TRUE</code> adds to the plot maximum R value
and frequency offset (by default <code>TRUE</code>).</p>
</td></tr>  
<tr><td><code id="covspectro_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation coefficient is
to be computed (&quot;pearson&quot;, &quot;spearman&quot;, or &quot;kendall&quot;)
(see <code><a href="stats.html#topic+cor">cor</a></code>).</p>
</td></tr>
<tr><td><code id="covspectro_+3A_col">col</code></td>
<td>
<p>colour of r values.</p>
</td></tr>
<tr><td><code id="covspectro_+3A_colval">colval</code></td>
<td>
<p>colour of r max and frequency offset values.</p>
</td></tr>
<tr><td><code id="covspectro_+3A_cexval">cexval</code></td>
<td>
<p>character size of r max and frequency offset values.</p>
</td></tr>
<tr><td><code id="covspectro_+3A_fontval">fontval</code></td>
<td>
<p>font of r max and frequency offset values.</p>
</td></tr>
<tr><td><code id="covspectro_+3A_xlab">xlab</code></td>
<td>
<p>title of the frequency axis.</p>
</td></tr>
<tr><td><code id="covspectro_+3A_ylab">ylab</code></td>
<td>
<p>title of the r axis.</p>
</td></tr>
<tr><td><code id="covspectro_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="covspectro_+3A_pb">pb</code></td>
<td>
<p>if <code>TRUE</code> returns a text progress bar in the console.</p>
</td></tr>
<tr><td><code id="covspectro_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Successive covariances between the spectrogram of <code>wave1</code> and
the spectrogram of <code>wave2</code> are computed when regularly sliding
forward and backward <code>wave2</code> along <code>wave1</code>.<br />
The maximal covariance is obtained at a particular shift (time offset). 
This shift may be positive or negative.<br /> 
<code>n</code> sets in how many steps <code>wave2</code> will be slided along <code>wave1</code>.
Time process can be then decreased by setting low <code>n</code> value.<br />
Inverting <code>wave1</code> and <code>wave2</code> may give slight different results.
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, <code>covspectro</code> returns a list containing
three components:
</p>
<table>
<tr><td><code>cov</code></td>
<td>
<p>the successive covariance values between <code>wave1</code> and <code>wave2</code>.</p>
</td></tr>
<tr><td><code>covmax</code></td>
<td>
<p>the maximum covariance between <code>wave1</code> and <code>wave2</code>.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>the time offset corresponding to <code>cov</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Hopp, S. L., Owren, M. J. and Evans, C. S. (Eds) 1998. <em>Animal acoustic 
communication</em>. Springer, Berlin, Heidelberg.</p>


<h3>See Also</h3>

<p><code><a href="#topic+corspec">corspec</a></code>, <code><a href="#topic+corenv">corenv</a></code>, <code><a href="#topic+spectro">spectro</a></code>,
<code><a href="stats.html#topic+cor">cor</a></code>,</p>


<h3>Examples</h3>

<pre><code class='language-R'># covariance between two notes of a birdsong
## Not run: 
data(tico)
note1&lt;-cutw(tico, f=22050, from=0.5, to=0.9)
note2&lt;-cutw(tico, f=22050, from=0.9, to=1.3)
covspectro(note1,note2,f=22050,n=37)

## End(Not run)
</code></pre>

<hr>
<h2 id='crest'>Crest factor and visualization</h2><span id='topic+crest'></span>

<h3>Description</h3>

<p>This function returns the crest factor and localizes the
different crest(s).</p>


<h3>Usage</h3>

<pre><code class='language-R'>crest(wave, f, channel = 1, plot = FALSE, col = 2, cex = 3, symbol = "*", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crest_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="crest_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="crest_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="crest_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> plots the oscillogram of <code>wave</code> and
indicates the location of the crest(s)</p>
</td></tr>
<tr><td><code id="crest_+3A_col">col</code></td>
<td>
<p>color of the symbol indicating the localisation of the crest(s)</p>
</td></tr>
<tr><td><code id="crest_+3A_cex">cex</code></td>
<td>
<p>symbol magnification</p>
</td></tr>
<tr><td><code id="crest_+3A_symbol">symbol</code></td>
<td>
<p>symbol indicating the localisation of the crest(s)</p>
</td></tr>
<tr><td><code id="crest_+3A_...">...</code></td>
<td>
<p>other</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The crest factor of a time series s is calculated according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">C = \frac{max(s)}{rms(s)}</code>
</p>

<p>with rms the root-mean-square (see <code><a href="#topic+rms">rms</a></code>).
</p>


<h3>Value</h3>

<p>The function returns a list of three items
</p>
<table>
<tr><td><code>C</code></td>
<td>
<p>crest factor</p>
</td></tr>
<tr><td><code>val</code></td>
<td>
<p>value of the crest(s)</p>
</td></tr>
<tr><td><code>loc</code></td>
<td>
<p>location of the crest(s)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There might be several crests (maxima) along the time wave but
there is a single crest factor.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Hartmann, W. M. 1998 <em>Signals, sound and sensation</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+rms">rms</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
crest(tico, f=22050)
# see the crest location and change the default graphical parameters
crest(tico, f=22050, plot=TRUE, sym="-")
</code></pre>

<hr>
<h2 id='csh'>Continuous spectral entropy</h2><span id='topic+csh'></span>

<h3>Description</h3>

<p>This function computes the continuous spectral entropy (H) of a time wave.</p>


<h3>Usage</h3>

<pre><code class='language-R'>csh(wave, f, channel = 1, wl = 512, wn = "hanning", ovlp = 0,
fftw = FALSE, threshold = NULL,
plot = TRUE, xlab = "Times (s)", ylab = "Spectral Entropy",
ylim = c(0, 1.1), type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csh_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="csh_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="csh_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="csh_+3A_wl">wl</code></td>
<td>
<p>if <code>at</code> is not null, length of the window for the analysis
(even number of points, by default = 512).</p>
</td></tr>
<tr><td><code id="csh_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="csh_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in %).</p>
</td></tr>
<tr><td><code id="csh_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code>. See Notes of the <code>spectro</code>.</p>
</td></tr>
<tr><td><code id="csh_+3A_threshold">threshold</code></td>
<td>
<p>amplitude threshold for signal detection (in %).</p>
</td></tr>
<tr><td><code id="csh_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the spectral entropy against time
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="csh_+3A_xlab">xlab</code></td>
<td>
<p>title of the x axis.</p>
</td></tr>
<tr><td><code id="csh_+3A_ylab">ylab</code></td>
<td>
<p>title of the y axis.</p>
</td></tr>
<tr><td><code id="csh_+3A_ylim">ylim</code></td>
<td>
<p>the range of y values.</p>
</td></tr>
<tr><td><code id="csh_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="csh_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+sh">sh</a></code> for computing method.</p>


<h3>Value</h3>

<p>When <code>plot</code> is <code>FALSE</code>, <code>csh</code> returns a two-column matrix, the
first column being time in seconds (<em>x</em>-axis) and the second column being the spectral entropy (<em>y</em>-axis) computed along time.<br />
NA corresponds to pause sections in <code>wave</code> (see <code>threshold</code>). 
</p>


<h3>Note</h3>

<p>The spectral entropy of a noisy signal will tend towards 1 whereas
the spectral entropy of a pure tone signal will tend towards 0.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Toh, A. M., Togneri, R. &amp; Nordholm, S. 2005 
Spectral entropy as speech features for speech recognition.
<em>Proceedings of PEECS</em>, pp. 60-65.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sh">sh</a></code>, <code><a href="#topic+th">th</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orni)
csh(orni,f=22050,wl=512,ovlp=50)
# using the threshold argument can lead to some edge effets
# here sh=1 at the end of echemes
csh(orni,f=22050,wl=512,ovlp=50,threshold=5)
</code></pre>

<hr>
<h2 id='cutspec'>Cut a frequency spectrum</h2><span id='topic+cutspec'></span>

<h3>Description</h3>

<p>This function can be used to select (cut)
a specific part of a frequency spectrum.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutspec(spec, f = NULL, flim, mel = FALSE, norm = FALSE, PMF = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutspec_+3A_spec">spec</code></td>
<td>
<p>a vector or a two-column matrix set resulting of a spectral analysis.
This can be the value obtained with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code>.</p>
</td></tr>
<tr><td><code id="cutspec_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>spec</code> (in Hz).</p>
</td></tr>
<tr><td><code id="cutspec_+3A_flim">flim</code></td>
<td>
<p>a vector of length 2 to specify the new frequency range
(in kHz).</p>
</td></tr>
<tr><td><code id="cutspec_+3A_mel">mel</code></td>
<td>
<p>a logical, if <code>TRUE</code> the (htk-)mel scale is used.</p>
</td></tr>
<tr><td><code id="cutspec_+3A_norm">norm</code></td>
<td>
<p>a logical, if <code>TRUE</code> the spectrum returned is normalised between 0 and 1.</p>
</td></tr>
<tr><td><code id="cutspec_+3A_pmf">PMF</code></td>
<td>
<p>a logical, if <code>TRUE</code> the spectrum returned is a probability mass function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new spectrum is returned.
The class of the returned object is the one of the input object (<code>spec</code>)</p>


<h3>Note</h3>

<p>The sampling frequency <code>f</code> is not necessary if <code>spec</code> has been obtained with
either <code>spec</code> or <code>meanspec</code>.<br />
This function can be used before calling analysis function like <code><a href="#topic+sh">sh</a></code> or 
<code><a href="#topic+sfm">sfm</a></code>. See examples.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, improved by Laurent Lellouch</p>


<h3>See Also</h3>

<p><code><a href="#topic+spec">spec</a></code>, <code><a href="#topic+meanspec">meanspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orni)
a &lt;- meanspec(orni,f=22050,plot=FALSE)
b &lt;- cutspec(a,flim=c(4,8))
## quick check with a plot
plot(b,type="l")
## effects on spectral entropy
sfm(a)
sfm(b)
## mel scale
require(tuneR)
mel &lt;- melfcc(orni, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
melspec.mean &lt;- apply(mel$aspectrum, MARGIN=2, FUN=mean)
c &lt;- cutspec(melspec.mean, f=22050, flim=c(4000,8000), mel=TRUE)
</code></pre>

<hr>
<h2 id='cutw'>Cut a section of a time wave</h2><span id='topic+cutw'></span>

<h3>Description</h3>

<p>This function selects and cuts a section of data describing a time wave.
Original and cut sections can be plotted as oscillograms for comparison. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutw(wave, f, channel=1, from = NULL, to = NULL, choose = FALSE,
plot = FALSE, marks = TRUE, output="matrix", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutw_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="cutw_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="cutw_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="cutw_+3A_from">from</code></td>
<td>
<p>start mark (in s).</p>
</td></tr>
<tr><td><code id="cutw_+3A_to">to</code></td>
<td>
<p>end mark (in s).</p>
</td></tr>
<tr><td><code id="cutw_+3A_choose">choose</code></td>
<td>
<p>logical, if <code>TRUE</code> start (=<code>from</code>) and end (=<code>to</code>)
points can be graphically chosen with a cursor on the oscillogram.</p>
</td></tr>
<tr><td><code id="cutw_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic plot of original
and cut sections (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="cutw_+3A_marks">marks</code></td>
<td>
<p>logical, if <code>TRUE</code> shows the start and end mark on the plot
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="cutw_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return,
either <code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="cutw_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>plot</code> is <code>TRUE</code> returns a two-frame plot with both 
original and cut sections.</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+addsilw">addsilw</a></code>,<code><a href="#topic+deletew">deletew</a></code>,
<code><a href="#topic+fadew">fadew</a></code>,<code><a href="#topic+mutew">mutew</a></code>,<code><a href="#topic+pastew">pastew</a></code>,<code><a href="#topic+revw">revw</a></code>,
<code><a href="#topic+zapsilw">zapsilw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># a 0.4 s section in a bird song
data(tico)
a&lt;-cutw(tico,f=22050,from=0.5,to=0.9)
oscillo(a,22050)
# a direct way to see what has been cut
cutw(tico,f=22050,from=0.5,to=0.9,plot=TRUE)
</code></pre>

<hr>
<h2 id='dBscale'>dB colour scale for a spectrogram display</h2><span id='topic+dBscale'></span>

<h3>Description</h3>

<p>This function displays a vertical or horizontal dB colour scale to be used with
<code><a href="#topic+spectro">spectro</a></code> plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dBscale(collevels, palette = spectro.colors, side = 4,
textlab = "Amplitude\n(dB)", cexlab = 0.75,
fontlab = 1, collab = "black", colaxis = "black",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dBscale_+3A_collevels">collevels</code></td>
<td>
<p>a set of levels which are used to partition
the amplitude range of the spectrogram (in dB).</p>
</td></tr>
<tr><td><code id="dBscale_+3A_palette">palette</code></td>
<td>
<p>a color palette function to be used to assign colors in
the plot, see <code>note</code>.</p>
</td></tr>
<tr><td><code id="dBscale_+3A_side">side</code></td>
<td>
<p>side of the axis.</p>
</td></tr>
<tr><td><code id="dBscale_+3A_textlab">textlab</code></td>
<td>
<p>text of the label.</p>
</td></tr>  
<tr><td><code id="dBscale_+3A_cexlab">cexlab</code></td>
<td>
<p>character size of the label.</p>
</td></tr>
<tr><td><code id="dBscale_+3A_fontlab">fontlab</code></td>
<td>
<p>font of the label.</p>
</td></tr>
<tr><td><code id="dBscale_+3A_collab">collab</code></td>
<td>
<p>colour of the label.</p>
</td></tr>
<tr><td><code id="dBscale_+3A_colaxis">colaxis</code></td>
<td>
<p>colour of the axis.</p>
</td></tr>
<tr><td><code id="dBscale_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+axis">axis</a></code> arguments.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function, based on <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> by Ross Ihaka,
is not supposed to be used by itself but as a legend of <code><a href="#topic+spectro">spectro</a></code>.<br />
Any colour palette can be used. In particular, it is possible
to use other palettes coming with
<span class="pkg">seewave</span>: <code>rev.gray.colors.1</code>, <code>rev.gray.colors.2</code>,
<code>rev.heat.colors</code>, <code>rev.terrain.colors</code>, <code>rev.topo.colors</code>, 
<code>rev.cm.colors</code> corresponding to the reverse of <code>heat.colors</code>, 
<code>terrain.colors</code>, <code>topo.colors</code>, <code>cm.colors</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a> and 
Caroline Simonis <a href="mailto:csimonis@mnhn.fr">csimonis@mnhn.fr</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectro">spectro</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pellucens)
# place the scale on the left and not on the right as spectro() does
def.par &lt;- par(no.readonly = TRUE)
layout(matrix(c(1, 2), nc = 2), widths = c(1, 5))
par(mar=c(5,3,4,2))
dBscale(collevels=seq(-30,0,1),side=2)
par(mar=c(5,4,4,2))
spectro(pellucens, f=22050,wl=512,scale=FALSE)
par(def.par)
# place the scale on the top and not on the right as spectro() does
def.par &lt;- par(no.readonly = TRUE)
layout(matrix(c(0,1,2,2), nc = 2, byrow=TRUE),widths=c(1,2),heights=(c(1,5.5)))
par(mar=c(0.5,3,4,2))
dBscale(collevels=seq(-30,0,1), textlab = "",side=3)
mtext("Amplitude (dB)",side=2,line = 1,at=0.6,cex=0.75)
par(mar=c(5,4,0.5,2))
spectro(pellucens, f=22050,wl=512,scale=FALSE)
par(def.par)   
</code></pre>

<hr>
<h2 id='dBweight'>dB weightings</h2><span id='topic+dBweight'></span>

<h3>Description</h3>

<p>This function returns the four most common dB weightings.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dBweight(f, dBref = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dBweight_+3A_f">f</code></td>
<td>
<p>frequency (in Hz).</p>
</td></tr>
<tr><td><code id="dBweight_+3A_dbref">dBref</code></td>
<td>
<p>dB reference level (by default <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the function returns four weightings. When
<code>dBref</code> is not <code>NULL</code> then the function returns the
conversion from a dB reference level to four dB weighting levels.</p>


<h3>Value</h3>

<p><code>dBweight</code> returns a list of five items corresponding to five
dB weightings.
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>dB (A)</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>dB (B)</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>dB (C)</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>dB (D)</p>
</td></tr>
<tr><td><code>ITU</code></td>
<td>
<p>dB ITU-R 468</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The transfer equations used here come from Wipipedia but they were originally coming
from the appendix of an international standard on the design
performance of sound level meters IEC 651:1979 (Neil Glenister, pers. com.).
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a>,  Zev Ross, and Andrey Anikin</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/A-weighting">https://en.wikipedia.org/wiki/A-weighting</a>, <a href="https://en.wikipedia.org/wiki/ITU-R_468_noise_weighting">https://en.wikipedia.org/wiki/ITU-R_468_noise_weighting</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+convSPL">convSPL</a></code>, <code><a href="#topic+moredB">moredB</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># weight for a 50 Hz frequency
dBweight(f=50)
# A weight for the 1/3 Octave centre frequencies.
dBweight(f=c(20,25,31.5,40,50,63,80,100,125,160,200,250,
315,400,500,630,800,1000,1500,
1600,2000,2500,3150,4000,5000,
6300,8000,10000,12500,16000,20000))$A
# correction for a 50 Hz sound emitted at 100 dB
dBweight(f=50, dB=100)
# weighting curves plot
f &lt;- seq(10,20000,by=10)
par(las=1)
plot(f, dBweight(f)$A, type="n", log="x",
xlim=c(10,10^5),ylim=c(-80,20),xlab="",ylab="",xaxt="n",yaxt="n")
abline(v=c(seq(10,100,by=10),seq(100,1000,by=100),
seq(1000,10000,by=1000),seq(10000,100000,by=10000),
c(100,1000,10000,100000)),col="lightgrey",lty=2)
abline(v=c(100,1000,10000,100000),col="grey")
abline(h=seq(-80, 20, 20),col="grey")
par(new=TRUE)
plot(f, dBweight(f)$A, type="l", log="x",
xlab="Frequency (Hz)", ylab="dB",lwd=2, col="blue", xlim=c(10,10^5),ylim=c(-80,20))
title(main="Acoustic weighting curves (10 Hz - 20 kHz)")
lines(x=f, y=dBweight(f)$B, col="green",lwd=2)
lines(x=f, y=dBweight(f)$C, col="red",lwd=2)
lines(x=f, y=dBweight(f)$D, col="black",lwd=2)
legend("bottomright",legend=c("dB(A)","dB(B)","dB(C)","dB(D)"),
lwd=2,col=c("blue","green","red","black"),bty="o",bg="white")
</code></pre>

<hr>
<h2 id='deletew'>Delete a section of a time wave</h2><span id='topic+deletew'></span>

<h3>Description</h3>

<p>This function selects and delete a section of data describing a time wave.
Original section and section after deletion can be plotted as oscillograms for comparison. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deletew(wave, f, channel = 1, from = NULL, to = NULL, choose = FALSE, plot = FALSE,
marks = TRUE, output = "matrix", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deletew_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="deletew_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="deletew_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="deletew_+3A_from">from</code></td>
<td>
<p>start position (in s).</p>
</td></tr>
<tr><td><code id="deletew_+3A_to">to</code></td>
<td>
<p>end position (in s).</p>
</td></tr>
<tr><td><code id="deletew_+3A_choose">choose</code></td>
<td>
<p>logical, if <code>TRUE</code> start (=<code>from</code>) and end (=<code>to</code>)
points can be graphically chosen with a cursor on the oscillogram.</p>
</td></tr>
<tr><td><code id="deletew_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic plot of original
and cut sections (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="deletew_+3A_marks">marks</code></td>
<td>
<p>logical, if <code>TRUE</code> shows the start and end mark on the plot
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="deletew_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
&quot;matrix&quot;, &quot;Wave&quot;, &quot;Sample&quot;, &quot;audioSample&quot; or &quot;ts&quot;.</p>
</td></tr>
<tr><td><code id="deletew_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>plot</code> is <code>TRUE</code> returns a two-frame plot with both 
original and resulting sections.</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+addsilw">addsilw</a></code>,<code><a href="#topic+cutw">cutw</a></code>,
<code><a href="#topic+fadew">fadew</a></code>, <code><a href="#topic+mutew">mutew</a></code>, <code><a href="#topic+pastew">pastew</a></code>,
<code><a href="#topic+revw">revw</a></code>, <code><a href="#topic+zapsilw">zapsilw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># deletion a 0.4 s section in a bird song
data(tico)
a&lt;-deletew(tico,f=22050,from=0.5,to=0.9)
oscillo(a,22050)
# a direct way to see what has been cut
deletew(tico,f=22050,from=0.5,to=0.9,plot=TRUE)
</code></pre>

<hr>
<h2 id='dfreq'>Dominant frequency of a time wave</h2><span id='topic+dfreq'></span>

<h3>Description</h3>

<p>This function gives the dominant frequency (i. e. the frequency of highest amplitude) of a time wave.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfreq(wave, f, channel = 1, wl = 512, wn = "hanning", ovlp = 0, fftw=  FALSE, at =
NULL, tlim = NULL, threshold = NULL, bandpass = NULL, clip = NULL,
plot = TRUE, xlab = "Times (s)", ylab = "Frequency (kHz)",
ylim = c(0, f/2000), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfreq_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="dfreq_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="dfreq_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="dfreq_+3A_wl">wl</code></td>
<td>
<p>length of the window for the analysis
(even number of points, by default = 512).</p>
</td></tr>
<tr><td><code id="dfreq_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="dfreq_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive analysis windows (in % ).</p>
</td></tr>
<tr><td><code id="dfreq_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code>. See Notes of the <code>spectro</code>.</p>
</td></tr>
<tr><td><code id="dfreq_+3A_at">at</code></td>
<td>
<p>time position where the dominant frequency has to be
computed (in s.).</p>
</td></tr>
<tr><td><code id="dfreq_+3A_tlim">tlim</code></td>
<td>
<p>modifications of the time X-axis limits.</p>
</td></tr>
<tr><td><code id="dfreq_+3A_threshold">threshold</code></td>
<td>
<p>amplitude threshold for signal detection (in % ).</p>
</td></tr>
<tr><td><code id="dfreq_+3A_bandpass">bandpass</code></td>
<td>
<p>a numeric vector of length two, giving the lower and
upper limits of a frequency bandpass filter (in Hz).</p>
</td></tr>
<tr><td><code id="dfreq_+3A_clip">clip</code></td>
<td>
<p>a numeric value to select dominant frequency values according to
their amplitude in reference to a maximal value of 1 for
the whole signal (has to be &gt;0 &amp; &lt; 1).</p>
</td></tr>
<tr><td><code id="dfreq_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the dominant frequency against time
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dfreq_+3A_xlab">xlab</code></td>
<td>
<p>title of the x axis.</p>
</td></tr>
<tr><td><code id="dfreq_+3A_ylab">ylab</code></td>
<td>
<p>title of the y axis.</p>
</td></tr>
<tr><td><code id="dfreq_+3A_ylim">ylim</code></td>
<td>
<p>the range of y values.</p>
</td></tr>
<tr><td><code id="dfreq_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>plot</code> is <code>FALSE</code>, <code>dfreq</code> returns a two-column matrix, the first column corresponding to time in seconds (<em>x</em>-axis) and the second column corresponding to 
to dominant frequency in kHz (<em>y</em>-axis).<br />
NA corresponds to pause sections in <code>wave</code> (see <code>threshold</code>). 
</p>


<h3>Note</h3>

<p>This function is based on <code><a href="stats.html#topic+fft">fft</a></code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+spec">spec</a></code>, <code><a href="#topic+meanspec">meanspec</a></code>,<code><a href="#topic+spectro">spectro</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
f &lt;- 22050
# default
dfreq(tico,f)
# using the amplitude threshold and changing the graphical output
dfreq(tico, f, ovlp=50,threshold=5, type="l", col=2)
# using 'at' argument for specific positions along the time axis
dfreq(tico, f, at=c(0.25, 0.75, 1.2, 1.6))
dfreq(tico, f, at=seq(0.5, 1.4, by=0.005), threshold=5)
# a specific number of measures on a single note
dfreq(tico, f, at=seq(0.5, 0.9, len=100), threshold=5, xlim=c(0.5,0.9))
# overlap on spectrogram
# and use of 'clip' argument to better track the dominant frequency
# in noisy conditions
op &lt;- par()
ticon &lt;- tico@left/max(tico@left) + noisew(d=length(tico@left)/f, f)
spectro(ticon, f)
res &lt;- dfreq(ticon, f, clip=0.3, plot=FALSE)
points(res, col=2, pch =13)
par(op)
</code></pre>

<hr>
<h2 id='diffcumspec'>Difference between two cumulative frequency spectra</h2><span id='topic+diffcumspec'></span>

<h3>Description</h3>

<p>This function compares two distributions (e.g. two frequency spectra) by
computing the difference between two cumulative frequency spectra</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffcumspec(spec1, spec2, f = NULL, mel = FALSE, 
plot = FALSE, type = "l", lty = c(1, 2), col = c(2, 4, 8),
flab = NULL, alab = "Cumulated amplitude",
flim = NULL, alim = NULL,
title = TRUE, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffcumspec_+3A_spec1">spec1</code></td>
<td>
<p>any distribution, especially a spectrum obtained with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This can be either a two-column matrix (col1 = frequency, col2 = amplitude) or a vector (amplitude).</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_spec2">spec2</code></td>
<td>
<p>any distribution, especially a spectrum obtained with
<code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This can be
either a two-column matrix (col1 = frequency, col2 = amplitude) or a
vector (amplitude).</p>
</td></tr> 
<tr><td><code id="diffcumspec_+3A_f">f</code></td>
<td>
<p>sampling frequency of waves used to obtain <code>spec1</code>
and <code>spec2</code> (in Hz). Not necessary if <code>spec1</code> and/or <code>spec2</code>
is a two columns matrix obtained with <code><a href="#topic+spec">spec</a></code>
or <code><a href="#topic+meanspec">meanspec</a></code>.</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_mel">mel</code></td>
<td>
<p>a logical, if <code>TRUE</code> the (htk-)mel scale is used.</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots both cumulative spectra and
their distance.</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_col">col</code></td>
<td>
<p>a vector of length 3 for the colour of <code>spec1</code>,
<code>spec2</code>, and the difference between each of them.</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_lty">lty</code></td>
<td>
<p>a vector of length 2 for the line type of <code>spec1</code> and
<code>spec2</code> if <code>type</code>=&quot;l&quot;.</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_flab">flab</code></td>
<td>
<p>title of the frequency axis.</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_alab">alab</code></td>
<td>
<p>title of the amplitude axis.</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_flim">flim</code></td>
<td>
<p>the range of frequency values.</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_alim">alim</code></td>
<td>
<p>range of amplitude axis.</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_title">title</code></td>
<td>
<p>logical, if <code>TRUE</code>, adds a title with D and F values.</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_legend">legend</code></td>
<td>
<p>logical, if <code>TRUE</code> adds a legend to the plot.</p>
</td></tr>
<tr><td><code id="diffcumspec_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both spectra are transformed into cumulative distribution functions
(CDF). <br />
Spectral difference is then computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">D_{cf}(x, y) = \frac{\sum_{i=1}^{n}|X_{i} - Y_{i}|}{n}, with
  with X and Y the spectrum CDFs, and D \in [0,1].</code>
</p>



<h3>Value</h3>

<p>A numeric vector of length 1 returning the difference between the
two spectra. No unit.</p>


<h3>Note</h3>

<p>This metric is sensitive not only to the spectral overlap between
but also to the mean frequential distance between the
different frequency peaks.</p>


<h3>Author(s)</h3>

<p>Laurent Lellouch, Jerome Sueur</p>


<h3>References</h3>

<p>Lellouch L, Pavoine S, Jiguet F, Glotin H, Sueur J (2014) Monitoring temporal change of bird communities with dissimilarity acoustic indices. <em>Methods in Ecology and Evolution</em>, in press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kl.dist">kl.dist</a></code>, <code><a href="#topic+ks.dist">ks.dist</a></code>, <code><a href="#topic+simspec">simspec</a></code>,
<code><a href="#topic+diffspec">diffspec</a></code>, <code><a href="#topic+logspec.dist">logspec.dist</a></code>, <code><a href="#topic+itakura.dist">itakura.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Hz scale
data(tico)
data(orni)
orni.hz &lt;- meanspec(orni, plot=FALSE)
tico.hz &lt;- meanspec(tico, plot=FALSE)
diffcumspec(orni.hz, tico.hz, plot=TRUE)
## mel scale
require(tuneR)
orni.mel &lt;- melfcc(orni, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
orni.mel.mean &lt;- apply(orni.mel$aspectrum, MARGIN=2, FUN=mean)
tico.mel &lt;- melfcc(tico, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
tico.mel.mean &lt;- apply(tico.mel$aspectrum, MARGIN=2, FUN=mean)
diffcumspec(orni.mel.mean, tico.mel.mean, f=22050, mel=TRUE, plot=TRUE)
</code></pre>

<hr>
<h2 id='diffenv'>Difference between two amplitude envelopes</h2><span id='topic+diffenv'></span>

<h3>Description</h3>

<p>This function estimates the surface difference between
two amplitude envelopes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffenv(wave1, wave2, f, channel = c(1,1), envt = "hil", msmooth = NULL, ksmooth = NULL,
plot = FALSE, lty1 = 1, lty2 = 2, col1 = 2, col2 = 4, cold = 8,
xlab = "Time (s)", ylab = "Amplitude", ylim = NULL, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffenv_+3A_wave1">wave1</code></td>
<td>
<p>a first R object.</p>
</td></tr>     
<tr><td><code id="diffenv_+3A_wave2">wave2</code></td>
<td>
<p>a second R object.</p>
</td></tr>
<tr><td><code id="diffenv_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="diffenv_+3A_channel">channel</code></td>
<td>
<p>channel of the R objects, by default left channel (1)
for each object.</p>
</td></tr>  
<tr><td><code id="diffenv_+3A_envt">envt</code></td>
<td>
<p>the type of envelope to be used: either &quot;abs&quot; for absolute
amplitude envelope or &quot;hil&quot; for Hilbert amplitude envelope. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="diffenv_+3A_msmooth">msmooth</code></td>
<td>
<p>a vector of length 2 to smooth the amplitude envelope with a 
mean sliding window. The first component is the window length
(in number of points). The second component is the overlap between
successive windows (in %). See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="diffenv_+3A_ksmooth">ksmooth</code></td>
<td>
<p>kernel smooth via <code><a href="stats.html#topic+kernel">kernel</a></code>. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="diffenv_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots both envelopes and their surface
difference (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="diffenv_+3A_lty1">lty1</code></td>
<td>
<p>line type of the first envelope (envelope of <code>wave1</code>).</p>
</td></tr>
<tr><td><code id="diffenv_+3A_lty2">lty2</code></td>
<td>
<p>line type of the second envelope (envelope of <code>wave2</code>).</p>
</td></tr>
<tr><td><code id="diffenv_+3A_col1">col1</code></td>
<td>
<p>colour of the first envelope (envelope of <code>wave1</code>).</p>
</td></tr>
<tr><td><code id="diffenv_+3A_col2">col2</code></td>
<td>
<p>colour of the second envelope (envelope of <code>wave2</code>).</p>
</td></tr>
<tr><td><code id="diffenv_+3A_cold">cold</code></td>
<td>
<p>colour of the surface difference.</p>
</td></tr>
<tr><td><code id="diffenv_+3A_xlab">xlab</code></td>
<td>
<p>title of the time axis.</p>
</td></tr>
<tr><td><code id="diffenv_+3A_ylab">ylab</code></td>
<td>
<p>title of the amplitude axis.</p>
</td></tr>
<tr><td><code id="diffenv_+3A_ylim">ylim</code></td>
<td>
<p>range of amplitude axis.</p>
</td></tr>
<tr><td><code id="diffenv_+3A_legend">legend</code></td>
<td>
<p>logical, if <code>TRUE</code> adds a legend to the plot.</p>
</td></tr>
<tr><td><code id="diffenv_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>D is a Manhattan distance (l1 norm). <br />
Envelopes of both waves are first transformed as probability mass functions (PMF).<br />
Envelope difference is then computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">D = \frac{\sum{|env1-env2|}}{2}, with D \in [0,1].</code>
</p>



<h3>Value</h3>

<p>The difference is returned. This value is without unit.
When <code>plot</code> is <code>TRUE</code>, both envelopes and their difference surface are
plotted on the same graph.
</p>


<h3>Note</h3>

<p>This method can be used as a relative distance estimation
between different envelopes.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a>.</p>


<h3>References</h3>

<p>Sueur, J., Pavoine, S., Hamerlynck, O. &amp; Duvail, S. (2008) -
Rapid acoustic survey for biodiversity appraisal. <em>PLoS ONE</em>,
3(12): e4065.</p>


<h3>See Also</h3>

<p><code><a href="#topic+env">env</a></code>, <code><a href="#topic+corenv">corenv</a></code>, <code><a href="#topic+diffspec">diffspec</a></code>,
<code><a href="#topic+diffwave">diffwave</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico) ; tico &lt;- tico@left
data(orni) ; orni &lt;- orni@left
# selection in tico of two waves with similar duration
tico2&lt;-tico[1:length(orni)]
diffenv(tico2,orni,f=22050,plot=TRUE)
# smoothing the envelope gives a better graph but slightly changes the result
diffenv(tico2,orni,f=22050,msmooth=c(20,0),plot=TRUE)
</code></pre>

<hr>
<h2 id='diffspec'>Difference between two frequency spectra</h2><span id='topic+diffspec'></span>

<h3>Description</h3>

<p>This function estimates the surface difference between
two frequency spectra.</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffspec(spec1, spec2, f = NULL, mel = FALSE,
plot = FALSE, type="l", 
lty=c(1, 2), col =c(2, 4, 8),
flab = NULL, alab = "Amplitude",
flim = NULL, alim = NULL, title = TRUE, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffspec_+3A_spec1">spec1</code></td>
<td>
<p>a first data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This
can be either a two-column matrix (col1 = frequency, col2 = amplitude)
or a vector (amplitude).</p>
</td></tr>
<tr><td><code id="diffspec_+3A_spec2">spec2</code></td>
<td>
<p>a first data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This
can be either a two-column matrix (col1 = frequency, col2 = amplitude)
or a vector (amplitude).</p>
</td></tr>
<tr><td><code id="diffspec_+3A_f">f</code></td>
<td>
<p>sampling frequency of waves used to obtain <code>spec1</code>
and <code>spec2</code> (in Hz). Not necessary if <code>spec1</code> and/or <code>spec2</code>
is a two-column matrix obtained with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code>.</p>
</td></tr>
<tr><td><code id="diffspec_+3A_mel">mel</code></td>
<td>
<p>a logical, if <code>TRUE</code> the (htk-)mel scale is used.</p>
</td></tr>
<tr><td><code id="diffspec_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots both spectra and their surface
difference (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="diffspec_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="diffspec_+3A_lty">lty</code></td>
<td>
<p>a vector of length 2 for the line type of <code>spec1</code> and
<code>spec2</code> if <code>type</code>=&quot;l&quot;.</p>
</td></tr>
<tr><td><code id="diffspec_+3A_col">col</code></td>
<td>
<p>a vector of length 3 for the colour of <code>spec1</code>,
<code>spec2</code>, and the surface difference between each of them.</p>
</td></tr>
<tr><td><code id="diffspec_+3A_flab">flab</code></td>
<td>
<p>title of the frequency axis.</p>
</td></tr>
<tr><td><code id="diffspec_+3A_alab">alab</code></td>
<td>
<p>title of the amplitude axis.</p>
</td></tr>
<tr><td><code id="diffspec_+3A_flim">flim</code></td>
<td>
<p>the range of frequency values.</p>
</td></tr>
<tr><td><code id="diffspec_+3A_alim">alim</code></td>
<td>
<p>range of amplitude axis.</p>
</td></tr>
<tr><td><code id="diffspec_+3A_title">title</code></td>
<td>
<p>logical, if <code>TRUE</code>, adds a title with D value.</p>
</td></tr>
<tr><td><code id="diffspec_+3A_legend">legend</code></td>
<td>
<p>logical, if <code>TRUE</code> adds a legend to the plot.</p>
</td></tr>
<tr><td><code id="diffspec_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>D is a Manhattan distance (l1 norm). <br />
Both spectra are first transformed as probability mass functions (PMF).<br />
Spectral difference is then computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">D = \frac{\sum{|spec1-spec2|}}{2}, with D \in [0,1].</code>
</p>
<p>, with 0 &lt; D &lt; 1.
</p>


<h3>Value</h3>

<p>The difference is returned. This value is without unit.
When <code>plot</code> is <code>TRUE</code>, both spectra and their difference surface are
plotted on the same graph.
</p>


<h3>Note</h3>

<p>This method can be used as a relative distance estimation
between different spectra.<br />
The dB value obtained can be very different from the one visually estimated
when looking at the graph (<code>plot=TRUE</code>).</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, Sandrine Pavoine and Laurent Lellouch</p>


<h3>References</h3>

<p>Sueur, J., Pavoine, S., Hamerlynck, O. and Duvail, S. (2008).
Rapid acoustic survey for biodiversity appraisal. <em>PLoS One</em>,
3(12): e4065.</p>


<h3>See Also</h3>

<p><code><a href="#topic+spec">spec</a></code>, <code><a href="#topic+meanspec">meanspec</a></code>, <code><a href="#topic+corspec">corspec</a></code>,
<code><a href="#topic+simspec">simspec</a></code>, <code><a href="#topic+diffcumspec">diffcumspec</a></code>, <code><a href="#topic+diffenv">diffenv</a></code>,  <code><a href="#topic+kl.dist">kl.dist</a></code>,
<code><a href="#topic+ks.dist">ks.dist</a></code>, <code><a href="#topic+logspec.dist">logspec.dist</a></code>, <code><a href="#topic+itakura.dist">itakura.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- noisew(f=8000,d=1)
b &lt;- synth(f=8000,d=1,cf=2000)
c &lt;- synth(f=8000,d=1,cf=1000)
d &lt;- noisew(f=8000,d=1)
speca &lt;- spec(a,f=8000,wl=512,at=0.5,plot=FALSE)
specb &lt;- spec(b,f=8000,wl=512,at=0.5,plot=FALSE)
specc &lt;- spec(c,f=8000,wl=512,at=0.5,plot=FALSE)
specd &lt;- spec(d,f=8000,wl=512,at=0.5,plot=FALSE)
diffspec(speca,speca,f=8000)
#[1] 0 =&gt; similar spectra of course !
diffspec(speca,specb)
diffspec(speca,specc,plot=TRUE)
diffspec(specb,specc,plot=TRUE)
diffspec(speca,specd,plot=TRUE)
## mel scale
require(tuneR)
data(orni)
data(tico)
orni.mel &lt;- melfcc(orni, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
orni.mel.mean &lt;- apply(orni.mel$aspectrum, MARGIN=2, FUN=mean)
tico.mel &lt;- melfcc(tico, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
tico.mel.mean &lt;- apply(tico.mel$aspectrum, MARGIN=2, FUN=mean)
diffspec(orni.mel.mean, tico.mel.mean, f=22050, mel=TRUE, plot=TRUE)
</code></pre>

<hr>
<h2 id='diffwave'>Difference between two time waves</h2><span id='topic+diffwave'></span>

<h3>Description</h3>

<p>This function estimates the difference between two waves by computing
the product between envelope surface difference and frequency surface difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffwave(wave1, wave2, f, channel = c(1,1), wl = 512, envt = "hil",
msmooth = NULL, ksmooth = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffwave_+3A_wave1">wave1</code></td>
<td>
<p>a first R object.</p>
</td></tr>     
<tr><td><code id="diffwave_+3A_wave2">wave2</code></td>
<td>
<p>a second R object.</p>
</td></tr>
<tr><td><code id="diffwave_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="diffwave_+3A_channel">channel</code></td>
<td>
<p>channel of the R objects, by default left channel (1)
for each object.</p>
</td></tr>
<tr><td><code id="diffwave_+3A_wl">wl</code></td>
<td>
<p>window length for spectral analysis (even number of points).</p>
</td></tr>  
<tr><td><code id="diffwave_+3A_envt">envt</code></td>
<td>
<p>the type of envelope to be used: either &quot;abs&quot; for absolute
amplitude envelope or &quot;hil&quot; for Hilbert amplitude envelope. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="diffwave_+3A_msmooth">msmooth</code></td>
<td>
<p>a vector of length 2 to smooth the amplitude envelope with a 
mean sliding window. The first component is the window length
(in number of points). The second component is the overlap between
successive windows (in %). See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="diffwave_+3A_ksmooth">ksmooth</code></td>
<td>
<p>kernel smooth via <code><a href="stats.html#topic+kernel">kernel</a></code>. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>D is a Manhattan distance (l1 norm). <br />
This function computes the product between the values obtained with
<code><a href="#topic+diffspec">diffspec</a></code> and <code><a href="#topic+diffenv">diffenv</a></code> functions. <br />
This then gives a global (time and frequency) estimation of dissimilarity.<br />
The frequency mean spectrum and the amplitude envelope needed for computing
respectively <code><a href="#topic+diffspec">diffspec</a></code> and <code><a href="#topic+diffenv">diffenv</a></code> are automatically generated.
They can be controlled through <code>wl</code>, <code>msmooth</code> and <code>ksmooth</code> arguments respectively.<br />
See examples below and examples in <code><a href="#topic+diffspec">diffspec</a></code> and <code><a href="#topic+diffenv">diffenv</a></code>
for implications on the results.</p>


<h3>Value</h3>

<p>A single value varying between 0 and 1 is returned.
The value has no unit.</p>


<h3>Note</h3>

<p>This method can be used as a relative distance estimation
between different waves.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Sueur, J., Pavoine, S., Hamerlynck, O. &amp; Duvail, S. (2008) -
Rapid acoustic survey for biodiversity appraisal. <em>PLoS ONE</em>, 3(12): e4065.</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffspec">diffspec</a></code>, <code><a href="#topic+diffenv">diffenv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico) ; tico &lt;- tico@left
data(orni) ; orni &lt;- orni@left
# selection in tico to have two waves of similar duration (length)
tico &lt;- tico[1:length(orni)]
diffwave(tico,orni,f=22050)
# changing the frequency parameter (wl)
diffwave(tico,orni,f=22050,wl=1024)
# changing the temporal parameter (msmooth)
diffwave(tico,orni,f=22050,msmooth=c(20,0))
</code></pre>

<hr>
<h2 id='discrets'>Time series discretisation</h2><span id='topic+discrets'></span>

<h3>Description</h3>

<p>This function transforms a numeric (time) series into a sequence of symbols</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrets(x, symb = 5, collapse = TRUE, plateau=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrets_+3A_x">x</code></td>
<td>
<p>a <code>vector</code>, a <code>matrix</code> (first column),
an object of class <code>ts</code>, <code>Sample</code> (left channel),
or <code><a href="tuneR.html#topic+Wave">Wave</a></code> (left channel).</p>
</td></tr>
<tr><td><code id="discrets_+3A_symb">symb</code></td>
<td>
<p>the number of symbols used for the discretisation,
can be set to 3 or 5 only.</p>
</td></tr>
<tr><td><code id="discrets_+3A_collapse">collapse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the symbols are pasted in a
character string of length 1.</p>
</td></tr>
<tr><td><code id="discrets_+3A_plateau">plateau</code></td>
<td>
<p>a numeric vector of length 1 taking the values <code>1</code> or <code>2</code>
only. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function partitions the numeric (time) series into a sequence of finite number of symbols.
These symbols result of the comparaison of each series value with its temporal neighbours.<br />
They are two discretisations available:<br />
when <code>symb</code> is set to 3, each value will be replaced by either:<br />
- <em>I</em> if the series is <em>I</em>ncreasing,<br />
- <em>D</em> if the series is <em>D</em>ecreasing,<br />
- <em>F</em> if the series remains <em>F</em>lat,<br />
when <code>symb</code> is set to 5, each value will be replaced by either:<br />
- <em>I</em> if the series is <em>I</em>ncreasing,<br />
- <em>D</em> if the series is <em>D</em>ecreasing,<br />
- <em>F</em> if the series remains <em>F</em>lat,<br />
- <em>P</em> if the series shows a <em>P</em>eak,<br />
- <em>T</em> if the series shows  a <em>T</em>rough.<br />
<br />
The argument <code>plateau</code> can be used to control the way a plateau
is encoded. A plateau is an elevated flat region that can be either
considered a 'flat peak' encoded as <em>PF...FP</em> (<code>plateau
  = 1</code>) or as an increase, a flat region and a decrease encoded as
<em>IF...FD</em> (<code>plateau = 1</code>. The default value (<code>plateau
  = 1</code>) refers to Cazelles <em>et al</em>. (2004).
</p>


<h3>Value</h3>

<p>A character string of length 1 if <code>collapse</code> is <code>TRUE</code>.
Otherwise, a character string of length <em>n-2</em> if <code>symbol=5</code>
(the first and last values cannot be replaced with a symbol)
or <em>n-1</em> if <code>symbol=3</code> (the first value cannot be replaced with a symbol.)
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, improved by Laurent Lellouch</p>


<h3>References</h3>

<p>Cazelles, B. 2004
Symbolic dynamics for identifying similarity between rhythms of ecological time series.
<em>Ecology Letters</em>, <b>7</b>: 755-763.</p>


<h3>See Also</h3>

<p><code><a href="#topic+symba">symba</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># a random variable
discrets(rnorm(30))
discrets(rnorm(30),symb=3)
# a frequency spectrum
data(tico)
spec1&lt;-spec(tico,f=22050,at=0.2,plot=FALSE)
discrets(spec1[,2])
</code></pre>

<hr>
<h2 id='drawenv'>Draw the amplitude envelope of a time wave</h2><span id='topic+drawenv'></span>

<h3>Description</h3>

<p>This function lets the user modifying the amplitude envelope
of a time wave by drawing it with the graphics device </p>


<h3>Usage</h3>

<pre><code class='language-R'>drawenv(wave, f, channel = 1, n = 20, plot = FALSE, listen = FALSE, output = "matrix")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawenv_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="drawenv_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="drawenv_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="drawenv_+3A_n">n</code></td>
<td>
<p>the maximum number of points to draw the new envelope. Valid values start at 1.</p>
</td></tr>
<tr><td><code id="drawenv_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> returns the oscillogram
of the new time wave (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="drawenv_+3A_listen">listen</code></td>
<td>
<p>if <code>TRUE</code> the new sound is played back.</p>
</td></tr>
<tr><td><code id="drawenv_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first plots an oscillogram view of <code>wave</code>.<br />
The user has then to choose points on the positive side of the y-axis (amplitude). 
The junction of these points will draw a new amplitude envelope.<br />
The order of points along the x-axis (time) is not important
but points cannot be cancelled. When this process is finished
the new time wave is returned in the console or as an oscillogram
in a second graphics device if <code>plot</code> is <code>TRUE</code>.
<br />
The function uses <code><a href="graphics.html#topic+locator">locator</a></code>.
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+setenv">setenv</a></code>, <code><a href="#topic+env">env</a></code>, <code><a href="#topic+synth">synth</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
a&lt;-synth(d=1,f=22050,cf=1000)
# drawenv(a,f=22050,plot=TRUE)
# choose points on the oscillogram view to draw a new enveloppe
# stop (ESC on Windows; right mouse button on Linux)
# check the result on the second graphics device opened thanks to plot=TRUE

## End(Not run)
</code></pre>

<hr>
<h2 id='drawfilter'>Draw the amplitude profile of a frequency filter</h2><span id='topic+drawfilter'></span>

<h3>Description</h3>

<p>This function lets the user drawing the amplitude profile of a frequency filter.</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawfilter(f, n = 256, continuous = TRUE, discrete = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawfilter_+3A_f">f</code></td>
<td>
<p>a numeric vector of length 1 for the sampling frequency of
the object to be filtered (in Hz).</p>
</td></tr>
<tr><td><code id="drawfilter_+3A_n">n</code></td>
<td>
<p>a numeric vector of length 1 for the length (i.e. number of points) of the filter. By default = 256 to fit with a FIR with wl = 512.</p>
</td></tr>
<tr><td><code id="drawfilter_+3A_continuous">continuous</code></td>
<td>
<p>a logical (<code>TRUE</code> by default) to draw a continuous filter.</p>
</td></tr>
<tr><td><code id="drawfilter_+3A_discrete">discrete</code></td>
<td>
<p>a logical (<code>TRUE</code> by default) to draw a discrete filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the same frequency of a discrete filter is selected twice then the sum of the amplitudes of the two selections is used.
If both arguments <code>continuous</code> and <code>discrete</code> are set to <code>TRUE</code> and if frequencies selected overlap between the two filters then only the frequencies of the discrete filter are considered.</p>


<h3>Value</h3>

<p>The function returns a two-column matrix, the first column is the frequency in kHz and the second column is the amplitude of the filter.</p>


<h3>Note</h3>

<p>This function can be used to prepare bandpass or bandstop custom filters to be used with <code><a href="#topic+fir">fir</a></code> and <code><a href="#topic+ffilter">ffilter</a></code>. See examples.</p>


<h3>Author(s)</h3>

<p>Laurent Lellouch</p>


<h3>See Also</h3>

<p><code><a href="#topic+fir">fir</a></code>, <code><a href="#topic+squarefilter">squarefilter</a></code>, <code><a href="#topic+combfilter">combfilter</a></code>, <code><a href="#topic+ffilter">ffilter</a></code>, <code><a href="#topic+drawenv">drawenv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
f &lt;- 8000
a &lt;- noisew(f=f, d=1)
## bandpass continuous and discrete
cont.disc &lt;- drawfilter(f=f/2)
a.cont.disc &lt;- fir(a, f=f, custom=cont.disc)
spectro(a.cont.disc, f=f)
## bandpass continuous only
cont &lt;- drawfilter(f=f/2, discrete=FALSE)
a.cont &lt;- fir(a, f=f, custom=cont)
spectro(a.cont, f=f)
## bandstop continuous only
cont.stop &lt;- drawfilter(f=f/2, discrete=FALSE)
a.cont.stop &lt;- fir(a, f=f, custom=cont.stop, bandpass=FALSE)
spectro(a.cont.stop, f=f)
## bandpass discrete only
disc &lt;- drawfilter(f=f/2, continuous=FALSE)
a.disc &lt;- fir(a, f=f, custom=disc, bandpass=FALSE)
spectro(a.disc, f=f)

## End(Not run)
</code></pre>

<hr>
<h2 id='duration'>Duration of a time wave</h2><span id='topic+duration'></span>

<h3>Description</h3>

<p>Returns the duration (in second) of a time wave</p>


<h3>Usage</h3>

<pre><code class='language-R'>duration(wave, f, channel=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duration_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="duration_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="duration_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 1 returning the duration in second.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
duration(tico)
</code></pre>

<hr>
<h2 id='dynoscillo'>Dynamic oscillogram</h2><span id='topic+dynoscillo'></span>

<h3>Description</h3>

<p>This graphical function displays a time wave as an windowed oscillogram.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynoscillo(wave, f, channel = 1, wd = NULL, wl = NULL, wnb = NULL, title = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynoscillo_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="dynoscillo_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="dynoscillo_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="dynoscillo_+3A_wd">wd</code></td>
<td>
<p>a numerical vector, duration of the window (in seconds)</p>
</td></tr>
<tr><td><code id="dynoscillo_+3A_wl">wl</code></td>
<td>
<p>a numerical vector, length of the window (in number of points).</p>
</td></tr>
<tr><td><code id="dynoscillo_+3A_wnb">wnb</code></td>
<td>
<p>a numerical vector, number of windows (no unit).</p>
</td></tr>
<tr><td><code id="dynoscillo_+3A_title">title</code></td>
<td>
<p>a logical, if <code>TRUE</code> displays a title with information regarding window size and number.</p>
</td></tr>
<tr><td><code id="dynoscillo_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>wd</code>, <code>wl</code> and <code>wn</code> have to be used isolated, not in conjunction. They basically do the same, ie they set the duration of the zooming window that is slided along the signal. For instance, for a 5 seconds sound with a sampling rate (<code>f</code>) at 44.1 kHz, <code>wl = 4096</code> is equivalent to <code>wd = 4096 / 44100 = 0.093 s</code> and equivalent to <code>wnb = 5*4096 / 44100 = 53</code>.</p>


<h3>Note</h3>

<p>This function requires the package <code>rpanel</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+oscilloST">oscilloST</a></code>, <code><a href="#topic+dynspec">dynspec</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(rpanel)
data(tico)
dynoscillo(tico, wn=4)
## End(Not run)
</code></pre>

<hr>
<h2 id='dynspec'>Dynamic sliding spectrum</h2><span id='topic+dynspec'></span>

<h3>Description</h3>

<p>This function plots dynamically a sliding spectrum along a time wave. 
This basically corresponds to a short-term Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynspec(wave, f, channel = 1, wl = 512, wn = "hanning", zp = 0,
ovlp = 0, fftw = FALSE, norm = FALSE, dB = NULL,  dBref = NULL, plot = TRUE,
title = TRUE, osc = FALSE, 
tlab = "Time (s)", flab = "Frequency (kHz)",
alab = "Amplitude", alim = NULL, flim = c(0, f/2000),
type = "l", from = NULL, to = NULL, envt = NULL,
msmooth = NULL, ksmooth = NULL, colspec = "black",
coltitle = "black", colbg = "white", colline = "black",
colaxis = "black", collab = "black", cexlab = 1,
fontlab = 1, colwave = "black",
coly0 = "lightgrey", colcursor = "red", bty = "l")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynspec_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="dynspec_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="dynspec_+3A_wl">wl</code></td>
<td>
<p>if <code>at</code> is not null, length of the window for the analysis
(even number of points, by defaults = 512).</p>
</td></tr>
<tr><td><code id="dynspec_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="dynspec_+3A_zp">zp</code></td>
<td>
<p>zero-padding (even number of points), see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in % ).</p>
</td></tr>
<tr><td><code id="dynspec_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code>. See Notes of the <code>spectro</code>.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_norm">norm</code></td>
<td>
<p>logical, if <code>TRUE</code> compute a normalised sliding spectrum.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_db">dB</code></td>
<td>
<p>a character string specifying the type dB to return: &quot;max0&quot; for a
maximum dB value at 0, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, and &quot;ITU&quot; for common dB weights.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_dbref">dBref</code></td>
<td>
<p>a dB reference value when <code>dB</code> is not <code>NULL</code>. <code>NULL</code> by default
but should be set to 2*10e-5 for a 20 microPa reference (SPL).</p>
</td></tr>
<tr><td><code id="dynspec_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots in an ew graphics device the successive
spectra sliding along the time wave (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dynspec_+3A_title">title</code></td>
<td>
<p>logical, if <code>TRUE</code> adds a title with the time position of the current
spectrum along the time wave.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_osc">osc</code></td>
<td>
<p>logical, if <code>TRUE</code> plots an oscillogram beneath
the sliding spectrum with a cursor showing the position of the 
current spectrum (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="dynspec_+3A_tlab">tlab</code></td>
<td>
<p>title of the time axis.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_flab">flab</code></td>
<td>
<p>title of the frequency axis.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_alab">alab</code></td>
<td>
<p>title of the amplitude axis.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_flim">flim</code></td>
<td>
<p>range of frequency axis.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_alim">alim</code></td>
<td>
<p>range of amplitude axis.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_type">type</code></td>
<td>
<p>type of plot that should be drawn for the sliding spectrum.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="dynspec_+3A_from">from</code></td>
<td>
<p>start mark where  to compute the sliding spectrum (in s).</p>
</td></tr>
<tr><td><code id="dynspec_+3A_to">to</code></td>
<td>
<p>end mark where to compute the sliding spectrum (in s).</p>
</td></tr>
<tr><td><code id="dynspec_+3A_envt">envt</code></td>
<td>
<p>the type of envelope to be plooted:
either &quot;abs&quot; for absolute amplitude envelope or &quot;hil&quot; for Hilbert amplitude envelope.
See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_msmooth">msmooth</code></td>
<td>
<p>when <code>env</code> is not <code>NULL</code>,
a vector of length 2 to smooth the amplitude envelope with a 
mean sliding window. The first component is the window length
(in number of points). The second component is the overlap between
successive windows (in %). See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_ksmooth">ksmooth</code></td>
<td>
<p>when <code>env</code> is not <code>NULL</code>,
kernel smooth via <code><a href="stats.html#topic+kernel">kernel</a></code>. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_colspec">colspec</code></td>
<td>
<p>colour of the sliding spectrum.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_coltitle">coltitle</code></td>
<td>
<p>if <code>title</code> is <code>TRUE</code>, colour of the title.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_colbg">colbg</code></td>
<td>
<p>background colour.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_colline">colline</code></td>
<td>
<p>colour of axes line.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_colaxis">colaxis</code></td>
<td>
<p>colour of the axes.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_collab">collab</code></td>
<td>
<p>colour of axes title.</p>
</td></tr>  
<tr><td><code id="dynspec_+3A_cexlab">cexlab</code></td>
<td>
<p>character size for axes title.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_fontlab">fontlab</code></td>
<td>
<p>font for axes title.</p>
</td></tr>
<tr><td><code id="dynspec_+3A_colwave">colwave</code></td>
<td>
<p>colour of the oscillogram or of the envelope (only when <code>osc</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dynspec_+3A_coly0">coly0</code></td>
<td>
<p>colour of the y=0 line (only when <code>osc</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dynspec_+3A_colcursor">colcursor</code></td>
<td>
<p>colour of oscillogram cursor (only when <code>osc</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dynspec_+3A_bty">bty</code></td>
<td>
<p>the type of box to be drawn around the oscillogram (only
when <code>osc</code> is <code>TRUE</code>).</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Use the slider panel to move along the time wave.<br />
Use the argument <code>norm</code> if you wish to have each spectrum normalised, <em>i.e.</em>
with values between 0 and 1 or maximised to 0 dB when <code>dB</code> is <code>TRUE</code>.<br />
The function requires the package <span class="pkg">rpanel</span> that is based on the package <span class="pkg">tcltk</span>.
</p>


<h3>Value</h3>

<p>This function returns a list of three items:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>a numeric vector corresponding to the time axis.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>a numeric vector corresponding to the frequency axis.</p>
</td></tr>
<tr><td><code>amp</code></td>
<td>
<p>a numeric matrix corresponding to the amplitude values.
Each column is a Fourier transform of length <code>wl/2</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is very similar to a spectrogram. See the <code>Details</code> of
<code><a href="#topic+spectro">spectro</a></code> for some information regarding the short term Fourier 
transform.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur and Caroline Simonis</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectro">spectro</a></code>, <code><a href="#topic+spectro3D">spectro3D</a></code>,
<code><a href="#topic+wf">wf</a></code>, <code><a href="#topic+spec">spec</a></code>, <code><a href="#topic+dynspectro">dynspectro</a></code>,
<code><a href="stats.html#topic+fft">fft</a></code>, <code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+env">env</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(sheep)
require(rpanel)
dynspec(sheep,f=8000,wl=1024,ovlp=50,osc=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='dynspectro'>Dynamic sliding spectrogramn</h2><span id='topic+dynspectro'></span>

<h3>Description</h3>

<p>This function plots dynamically a sliding spectrogram along a time wave.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynspectro(wave, f, channel = 1, slidframe = 10,
wl = 512, wn = "hanning", zp = 0, ovlp = 75,
fftw = FALSE, dB = TRUE, plot = TRUE,
title = TRUE, osc = FALSE,
tlab = "Time (s)", flab = "Frequency (kHz)", alab = "Amplitude",
from = NULL, to = NULL,
collevels = NULL, palette = spectro.colors,
envt = NULL, msmooth = NULL, ksmooth = NULL,
coltitle = "black", colbg = "white", colline = "black",
colaxis = "black", collab = "black", cexlab = 1,
fontlab = 1, colwave = "black",
coly0 = "lightgrey", colcursor = "red", bty = "l")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynspectro_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="dynspectro_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="dynspectro_+3A_slidframe">slidframe</code></td>
<td>
<p>size of the sliding frame (in percent of the wave duration).</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_wl">wl</code></td>
<td>
<p>if <code>at</code> is not null, length of the window for the analysis
(even number of points, by defaults = 512).</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_zp">zp</code></td>
<td>
<p>zero-padding (even number of points), see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in % ).</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code>. See Notes of the <code>spectro</code>.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_db">dB</code></td>
<td>
<p>a logical, if <code>TRUE</code> then uses dB values</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots in an ew graphics device the successive
spectrograms sliding along the time wave (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_title">title</code></td>
<td>
<p>logical, if <code>TRUE</code> adds a title with the time position of the current
spectrogram along the time wave.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_osc">osc</code></td>
<td>
<p>logical, if <code>TRUE</code> plots an oscillogram beneath
the sliding spectrogram with a cursor showing the position of the 
current spectrum (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_tlab">tlab</code></td>
<td>
<p>title of the time axis.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_flab">flab</code></td>
<td>
<p>title of the frequency axis.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_alab">alab</code></td>
<td>
<p>title of the amplitude axis.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_from">from</code></td>
<td>
<p>start mark where  to compute the sliding spectrogram (in s).</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_to">to</code></td>
<td>
<p>end mark where to compute the sliding spectrogram (in s).</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_collevels">collevels</code></td>
<td>
<p>a set of levels which are used to partition
the amplitude range of the spectrogram.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_palette">palette</code></td>
<td>
<p>a color palette function to be used to assign colors in
the plot.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_envt">envt</code></td>
<td>
<p>the type of envelope to be plooted:
either &quot;abs&quot; for absolute amplitude envelope or &quot;hil&quot; for Hilbert amplitude envelope.
See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_msmooth">msmooth</code></td>
<td>
<p>when <code>env</code> is not <code>NULL</code>,
a vector of length 2 to smooth the amplitude envelope with a 
mean sliding window. The first component is the window length
(in number of points). The second component is the overlap between
successive windows (in %). See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_ksmooth">ksmooth</code></td>
<td>
<p>when <code>env</code> is not <code>NULL</code>,
kernel smooth via <code><a href="stats.html#topic+kernel">kernel</a></code>. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_coltitle">coltitle</code></td>
<td>
<p>if <code>title</code> is <code>TRUE</code>, colour of the title.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_colbg">colbg</code></td>
<td>
<p>background colour.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_colline">colline</code></td>
<td>
<p>colour of axes line.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_colaxis">colaxis</code></td>
<td>
<p>colour of the axes.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_collab">collab</code></td>
<td>
<p>colour of axes title.</p>
</td></tr>  
<tr><td><code id="dynspectro_+3A_cexlab">cexlab</code></td>
<td>
<p>character size for axes title.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_fontlab">fontlab</code></td>
<td>
<p>font for axes title.</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_colwave">colwave</code></td>
<td>
<p>colour of the oscillogram or of the envelope (only when <code>osc</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_coly0">coly0</code></td>
<td>
<p>colour of the y=0 line (only when <code>osc</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_colcursor">colcursor</code></td>
<td>
<p>colour of oscillogram cursor (only when <code>osc</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dynspectro_+3A_bty">bty</code></td>
<td>
<p>the type of box to be drawn around the oscillogram (only
when <code>osc</code> is <code>TRUE</code>).</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Use the slider panel to move along the time wave. <br />
The function requires the package <span class="pkg">rpanel</span> that is based on the
package <span class="pkg">tcltk</span>.<br />
The function is mainly written for inspecting long sounds.<br />
The function is based on <code><a href="Matrix.html#topic+image">image</a></code> for fast display when
<code><a href="#topic+spectro">spectro</a></code> is based on <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>.
Displaying the amplitude envelope with the argument <code>envt</code> can
slow down significantly the display.
</p>


<h3>Value</h3>

<p>This function returns a list of three items:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>a numeric vector corresponding to the time axis.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>a numeric vector corresponding to the frequency axis.</p>
</td></tr>
<tr><td><code>amp</code></td>
<td>
<p>a numeric matrix corresponding to the amplitude values.
Each column is a Fourier transform of length <code>wl/2</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is very similar to a spectrogram. See the <code>Details</code> of
<code><a href="#topic+spectro">spectro</a></code> for some information regarding the short term Fourier 
transform.</p>


<h3>Author(s)</h3>

<p>David Pinaud and Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectro">spectro</a></code>, <code><a href="#topic+spectro3D">spectro3D</a></code>,
<code><a href="#topic+wf">wf</a></code>, <code><a href="#topic+spec">spec</a></code>, <code><a href="#topic+dynspec">dynspec</a></code>,
<code><a href="stats.html#topic+fft">fft</a></code>, <code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+env">env</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(sheep)
require(rpanel)
dynspectro(sheep, ovlp=95, osc=TRUE)

## End(Not run)</code></pre>

<hr>
<h2 id='echo'>Echo generator</h2><span id='topic+echo'></span>

<h3>Description</h3>

<p>This function generate echoes of a time wave.</p>


<h3>Usage</h3>

<pre><code class='language-R'>echo(wave, f, channel = 1, amp, delay, plot = FALSE,
listen = FALSE, output = "matrix", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="echo_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="echo_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="echo_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="echo_+3A_amp">amp</code></td>
<td>
<p>a vector describing the relative amplitude
of the successive echoes. Each value of the vector should be in [0,1]</p>
</td></tr>
<tr><td><code id="echo_+3A_delay">delay</code></td>
<td>
<p>a vector describing the time delays of the successive echoes
from the beginning of <code>wave</code> (in s.)</p>
</td></tr>
<tr><td><code id="echo_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic plot of the wave
modified (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="echo_+3A_listen">listen</code></td>
<td>
<p>if <code>TRUE</code> the new sound is played back.</p>
</td></tr>
<tr><td><code id="echo_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="echo_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>amp</code> and <code>delay</code> should strictly have the same length corresponding
to the number of desired echoes.</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Note</h3>

<p>This function is based on a convolution (<code><a href="stats.html#topic+convolve">convolve</a></code>) between the
input wave and a pulse echo filter.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Stoddard, P. K. (1998). Application of filters in bioacoustics.
<em>In</em>: Hopp, S. L., Owren, M. J. and Evans, C. S. (Eds), <em>Animal acoustic
communication</em>. Springer, Berlin, Heidelberg,pp. 105-127.</p>


<h3>See Also</h3>

<p><code><a href="#topic+synth">synth</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generation of the input wave
a &lt;- synth(f=11025,d=1,cf=2000,shape="tria",am=c(50,10),fm=c(1000,10,1000,0,0))
# generation of three echoes
# with respectively a relative amplitude of 0.8, 0.4, and 0.2
# and with a delay of 1s, 2s, and 3s  from the beginning of the input wave
aecho &lt;- echo(a,f=11025,amp=c(0.8,0.4,0.2),delay=c(1,2,3))
# another echo with time delays overlapping with the input wave
aecho &lt;- echo(a,f=11025,amp=c(0.4,0.2,0.4),delay=c(0.6,0.8,1.5))
</code></pre>

<hr>
<h2 id='env'>Amplitude envelope of a time wave</h2><span id='topic+env'></span>

<h3>Description</h3>

<p>This function returns the absolute or Hilbert
amplitude envelope of a time wave.</p>


<h3>Usage</h3>

<pre><code class='language-R'>env(wave, f, channel = 1, envt = "hil", 
msmooth = NULL, ksmooth = NULL, ssmooth = NULL,
asmooth = NULL,
fftw = FALSE, norm = FALSE,
plot = TRUE, k = 1, j = 1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="env_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="env_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="env_+3A_envt">envt</code></td>
<td>
<p>the type of envelope to be returned: either &quot;abs&quot; for absolute
amplitude envelope or &quot;hil&quot; for Hilbert amplitude envelope. See Details section.</p>
</td></tr>
<tr><td><code id="env_+3A_msmooth">msmooth</code></td>
<td>
<p>a vector of length 2 to smooth the amplitude envelope with a 
mean sliding window. The first component is the window length
(in number of points). The second component is the overlap between
successive windows (in %). See examples.</p>
</td></tr>
<tr><td><code id="env_+3A_ksmooth">ksmooth</code></td>
<td>
<p>kernel smooth via <code><a href="stats.html#topic+kernel">kernel</a></code>. See examples.</p>
</td></tr>
<tr><td><code id="env_+3A_ssmooth">ssmooth</code></td>
<td>
<p>length of the sliding window used for a sum smooth.</p>
</td></tr>
<tr><td><code id="env_+3A_asmooth">asmooth</code></td>
<td>
<p>length of the sliding window used for an autocorrelation smooth.</p>
</td></tr>
<tr><td><code id="env_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code> for faster computation for the Hilbert amplitude
envelope (<code>envt="hil"</code>) and/or for kernell smoothing
(<code>ksmooth</code>).</p>
</td></tr>
<tr><td><code id="env_+3A_norm">norm</code></td>
<td>
<p>a logical, if <code>TRUE</code> the amplitude of the envelope
is normalised between 0 and 1.</p>
</td></tr>
<tr><td><code id="env_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns a plot
of <code>wave</code> envelope (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="env_+3A_k">k</code></td>
<td>
<p>number of horizontal sections when <code>plot</code> is <code>TRUE</code>
(by default =1).</p>
</td></tr>
<tr><td><code id="env_+3A_j">j</code></td>
<td>
<p>number of vertical sections when <code>plot</code> is <code>TRUE</code>
(by default =1).</p>
</td></tr>
<tr><td><code id="env_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>envt</code> is set as &quot;abs&quot;, the amplitude envelope returned
is the absolute value of <code>wave</code>.<br />
When <code>envt</code> is set as &quot;hil&quot;, the amplitude envelope returned is the modulus
(<code><a href="base.html#topic+Mod">Mod</a></code>) of the analytical signal of <code>wave</code>
obtained through the Hilbert transform (<code><a href="#topic+hilbert">hilbert</a></code>).
</p>


<h3>Value</h3>

<p>Data are returned as one-column matrix when <code>plot</code> is <code>FALSE</code>.</p>


<h3>Note</h3>

<p>Be aware that smoothing with either <code>msmooth</code> or <code>ksmooth</code>
changes the original number of points describing <code>wave</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur. Implementation of 'fftw' argument by Jean Marchal
and Francois Fabianek. Implementation of 'asmooth' by Thibaut Marin-Cudraz.</p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>,<code><a href="#topic+hilbert">hilbert</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
# Hilbert amplitude envelope
env(tico)
# absolute amplitude envelope
env(tico, envt="abs")
# smoothing with a 10 points and 50% overlaping mean sliding window
env(tico, msmooth=c(10,50))
# smoothing kernel
env(tico, ksmooth=kernel("daniell",10))
# sum smooth
env(tico, ssmooth=50)
# autocorrelation smooth
env(tico, asmooth=50)
# overplot of oscillographic and envelope representations
oscillo(tico)
par(new=TRUE)
env(tico, colwave=2)
</code></pre>

<hr>
<h2 id='export'>Export sound data</h2><span id='topic+export'></span>

<h3>Description</h3>

<p>Export sound data as a text file that can be read by a sound player like
'Goldwave'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(wave, f = NULL, channel = 1, filename = NULL, header=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="export_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="export_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="export_+3A_filename">filename</code></td>
<td>
<p>name of the new file. (by default the name of <code>wave</code>).</p>
</td></tr>
<tr><td><code id="export_+3A_header">header</code></td>
<td>
<p>either a logical or a character vector, 
if <code>TRUE</code> add a header to be read by Goldwave,
if <code>FALSE</code> does not add any header,
if a character vector add the character vector as a header.</p>
</td></tr>
<tr><td><code id="export_+3A_...">...</code></td>
<td>
<p>other <code><a href="utils.html#topic+write.table">write.table</a></code> parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a new text file with a header describing the main features of the sound
(wave). For instance, for a 2 s sound with a sampling frequency of 8000 Hz,
the header will be: [ASCII 8000Hz, Channels: 1, Samples: 160000, Flags: 0].
This type of file can be read by sound players like
Goldwave (<a href="http://www.goldwave.com/">http://www.goldwave.com/</a>).
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-synth(f=8000,d=2,cf=2000,plot=FALSE)
export(a,f=8000)
unlink("a.txt")
</code></pre>

<hr>
<h2 id='fadew'>Fade in and fade out of a time wave</h2><span id='topic+fadew'></span>

<h3>Description</h3>

<p>This function applies a &ldquo;fade in&rdquo; and/or a &ldquo;fade out&rdquo; to a time wave following
a linear, exponential or cosinus-like shape.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fadew(wave, f, channel = 1, din = 0, dout = 0, shape = "linear", plot = FALSE,
listen = FALSE, output = "matrix", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fadew_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="fadew_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="fadew_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="fadew_+3A_din">din</code></td>
<td>
<p>fade in duration.</p>
</td></tr>
<tr><td><code id="fadew_+3A_dout">dout</code></td>
<td>
<p>fade out duration.</p>
</td></tr>
<tr><td><code id="fadew_+3A_shape">shape</code></td>
<td>
<p>fade shape, <code>"linear"</code>, <code>"exp"</code> for exponential,
<code>"cos"</code> for cosinus-like, (by default <code>"linear"</code>).</p>
</td></tr>
<tr><td><code id="fadew_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic plot of the wave
modified (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="fadew_+3A_listen">listen</code></td>
<td>
<p>if <code>TRUE</code> the new sound is played back.</p>
</td></tr>
<tr><td><code id="fadew_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="fadew_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+addsilw">addsilw</a></code>, <code><a href="#topic+cutw">cutw</a></code>,
<code><a href="#topic+deletew">deletew</a></code>,<code><a href="#topic+mutew">mutew</a></code>, <code><a href="#topic+pastew">pastew</a></code>, <code><a href="#topic+revw">revw</a></code>,
<code><a href="#topic+zapsilw">zapsilw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-noisew(d=5,f=4000)
op&lt;-par(mfrow=c(3,1))
fadew(a,f=4000,din=1,dout=2,plot=TRUE,title="Linear",cexlab=0.8)
fadew(a,f=4000,din=1,dout=2,shape="exp",plot=TRUE,title="Exponential shape",
    colwave="blue",coltitle="blue",cexlab=0.8)
fadew(a,f=4000,din=1,dout=2,shape="cos",plot=TRUE,title="Cosinus-like shape",
    colwave="red",coltitle="red",cexlab=0.8)
par(op)
</code></pre>

<hr>
<h2 id='fbands'>Frequency bands plot</h2><span id='topic+fbands'></span>

<h3>Description</h3>

<p>This graphical function returns a frequency spectrum as a
bar plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbands(spec, f = NULL, bands = 10, width = FALSE, mel = FALSE, plot = TRUE,
xlab = NULL, ylab = "Relative amplitude", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbands_+3A_spec">spec</code></td>
<td>
<p>a data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code>. Can be in dB.</p>
</td></tr>
<tr><td><code id="fbands_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>spec</code> (in Hz). Not requested if
the first column of <code>spec</code> contains the frequency axis.</p>
</td></tr>
<tr><td><code id="fbands_+3A_bands">bands</code></td>
<td>
<p>a numeric vector. If vector of length 1, then sets the
number of bands dividing in equal parts the spectrum. If of length &gt; 1,
then takes the values as kHz limits of the bands dividing the spectrum. These
bands can be of different size. See details and examples.</p>
</td></tr>
<tr><td><code id="fbands_+3A_width">width</code></td>
<td>
<p>logical, if <code>TRUE</code> and that <code>bands</code> is an
irregular series of values, then the width of the bands will be
proportional to the frequency  limits defined in <code>bands</code>.</p>
</td></tr>
<tr><td><code id="fbands_+3A_mel">mel</code></td>
<td>
<p>a logical, if <code>TRUE</code> the (htk-)mel scale is used.</p>
</td></tr>
<tr><td><code id="fbands_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code>, a plot showing the peaks is
returned.</p>
</td></tr>
<tr><td><code id="fbands_+3A_xlab">xlab</code></td>
<td>
<p>label of the x-axis.</p>
</td></tr>
<tr><td><code id="fbands_+3A_ylab">ylab</code></td>
<td>
<p>label of the y-axis.</p>
</td></tr>
<tr><td><code id="fbands_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function proceeds as follows
</p>

<ul>
<li><p> divides the spectrum in bands. The limits of the bands are set
with the argument <code>bands</code>. There are two options:
</p>

<ul>
<li><p> you set a number of bands with equal size by giving a single
value to <code>bands</code>. For instance, setting <code>bands</code> to a value
of 10 will slice the spectrum in 10 equal parts and return 10 local
peaks.
</p>
</li>
<li><p> you set the limits of the bands. This is achieve by giving a
numeric vector to <code>bands</code>. The limits can follow a regular or
irregular series. For instance attributing the vector c(0,2,4,8) will
generate the following bands [0,2[, [2,4[, [4,8] kHz. Be aware that
the last value should not exceed half the sampling frequency used to
obtain the spectrum <code>spec</code>.
</p>
</li></ul>

</li>
<li><p> uses the function <code><a href="graphics.html#topic+barplot">barplot</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A two-column matrix, the first column corresponding to the
frequency values (x-axis, mean of the bars limits) and
the second column corresponding to height values (y-axis) of the bars.</p>


<h3>Note</h3>

<p>The value below bars is the mean between the corresponding frequency limits.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, improved by Laurent Lellouch</p>


<h3>See Also</h3>

<p><code><a href="#topic+meanspec">meanspec</a></code>, <code><a href="#topic+spec">spec</a></code>, <code><a href="graphics.html#topic+barplot">barplot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sheep)
spec &lt;- meanspec(sheep, f=8000, plot=FALSE)
# default plot
fbands(spec)
# setting a specific number of bands
fbands(spec, bands=6)
#setting specific regular bands limits
fbands(spec, bands=seq(0,4,by=0.25))
# some plot tuning
op &lt;- par(las=1)
fbands(spec, bands=seq(0,4,by=0.1),
       horiz=TRUE, col=heat.colors(41),
       xlab="", ylab="",
       cex.axis=0.75, cex.names = 0.75,
       axes=FALSE)
par(op)
# showing or not the width of the bands
oct &lt;- octaves(440,3)/1000
op &lt;- par(mfrow=c(2,1))
fbands(spec, bands=oct, col="blue")
fbands(spec, bands=oct, width = TRUE, col="red")
par(op)
# kind of horizontal zoom
op &lt;- par(mfrow=c(2,1))
fbands(spec, bands=seq(0,4,by=0.2), col=c(rep(1,10),
   rep("orange",5),rep(1,5)), main="all frequency range")
fbands(spec, bands=seq(2,3,by=0.2),
   col="orange", main="a subset or zoom in")
par(op)
# kind of dynamic frequency bands
specs &lt;- dynspec(sheep, f=8000, plot= FALSE)$amp
out &lt;- apply(specs, f=8000, MARGIN=2,
     FUN = fbands, bands = seq(0,4,by=0.2),
     col = 1, ylim=c(0,max(specs)))
# mel scale
require(tuneR)
mel &lt;- melfcc(sheep, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
melspec.mean &lt;- apply(mel$aspectrum, MARGIN=2, FUN=mean)
melspec.mean &lt;- melspec.mean/max(melspec.mean) # [0,1] scaling 
fbands(melspec.mean, f=8000, bands=8)
</code></pre>

<hr>
<h2 id='fdoppler'>Doppler effect</h2><span id='topic+fdoppler'></span>

<h3>Description</h3>

<p>This function computes the altered frequency of a moving source due to the Doppler effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdoppler(f, c = 340, vs, vo = 0, movs = "toward", movo = "toward")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdoppler_+3A_f">f</code></td>
<td>
<p>original frequency produced by the source (in Hz or kHz)</p>
</td></tr>
<tr><td><code id="fdoppler_+3A_c">c</code></td>
<td>
<p>speed of sound in meters/second.</p>
</td></tr>
<tr><td><code id="fdoppler_+3A_vs">vs</code></td>
<td>
<p>speed of the source in meters/second.</p>
</td></tr>
<tr><td><code id="fdoppler_+3A_vo">vo</code></td>
<td>
<p>speed of the observer in meters/second. The observer is static by default
<em>i.e.</em> <code>vo</code> = 0</p>
</td></tr>
<tr><td><code id="fdoppler_+3A_movs">movs</code></td>
<td>
<p>movement direction of the source in relation with observer position,
either <code>"toward"</code> (by default) or <code>"away"</code>.</p>
</td></tr>
<tr><td><code id="fdoppler_+3A_movo">movo</code></td>
<td>
<p>movement direction of the observer in relation with the source position,
either <code>"toward"</code> (by default, but be aware that
the observer is static by default) or <code>"away"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The altered frequency <em>f'</em> is computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">f{'} = f\times{\frac{c \pm v_{o}}{c \pm v_{s}}}</code>
</p>

<p>with <em>f</em> = original frequency produced by the source (in Hz or kHz),<br />
<em>vs</em> = speed of the source,<br />
<em>vo</em> = speed of the observer.
</p>


<h3>Value</h3>

<p>The altered frequency is returned in a vector.</p>


<h3>Note</h3>

<p>You can use <code><a href="#topic+wasp">wasp</a></code> to have exact values of <code>c</code>.
See examples.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+wasp">wasp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># a 400 Hz source moving toward or away from the observer at 85 m/s
fdoppler(f=400,vs=85)
# [1] 533.3333
fdoppler(f=400,vs=85,movs="away")
# [1] 320
# use wasp() if you wish to have exact sound speed at a specific temperature
fdoppler(f=wasp(f=400,t=25)$c, vs=85)
# [1] 461.8667
# Doppler effect at different source speeds
f&lt;-seq(1,10,by=1); lf&lt;-length(f)
v&lt;-seq(10,300,by=20); lv&lt;-length(v)
res&lt;-matrix(numeric(lf*lv),ncol=lv)
for(i in 1:lv) res[,i]&lt;-fdoppler(f=f,vs=v[i])
op&lt;-par(bg="lightgrey")
matplot(x=f,y=res,type="l",lty=1,las=1,col= spectro.colors(lv),
xlab="Source frequency (kHz)", ylab="Altered frequency (kHz)")
legend("topleft",legend=paste(as.character(v),"m/s"),
lty=1,col= spectro.colors(lv))
title(main="Doppler effect at different source speeds")
par(op)
</code></pre>

<hr>
<h2 id='ffilter'>Frequency filter</h2><span id='topic+ffilter'></span>

<h3>Description</h3>

<p>This function filters out a selected frequency section
of a time wave (low-pass, high-pass, low-stop, high-stop, bandpass
or bandstop frequency filter).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffilter(wave, f, channel = 1, from = NULL, to = NULL, bandpass = TRUE,
custom = NULL, wl = 1024, ovlp = 75, wn = "hanning", fftw = FALSE,
rescale=FALSE, listen=FALSE, output="matrix")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffilter_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="ffilter_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="ffilter_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="ffilter_+3A_from">from</code></td>
<td>
<p>start frequency (in Hz) where to apply the filter.</p>
</td></tr>
<tr><td><code id="ffilter_+3A_to">to</code></td>
<td>
<p>end frequency (in Hz) where to apply the filter.</p>
</td></tr>
<tr><td><code id="ffilter_+3A_bandpass">bandpass</code></td>
<td>
<p>if <code>TRUE</code> a band-pass filter is applied between
<code>from</code> and  <code>to</code>, if <code>FALSE</code> a band-stop filter is applied
between <code>from</code> and  <code>to</code> (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ffilter_+3A_custom">custom</code></td>
<td>
<p>a vector describing the frequency response of a custom filter.
This can be manually generated or obtained with <code><a href="#topic+spec">spec</a></code> and <code><a href="#topic+meanspec">meanspec</a></code>.
The length of the vector should be half the length of <code>wl</code>. See examples.</p>
</td></tr>
<tr><td><code id="ffilter_+3A_wl">wl</code></td>
<td>
<p>window length for the analysis (even number of points).</p>
</td></tr>
<tr><td><code id="ffilter_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between successive FFT windows (in %).</p>
</td></tr>
<tr><td><code id="ffilter_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="ffilter_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code>. See Notes of the <code>spectro</code>.</p>
</td></tr>
<tr><td><code id="ffilter_+3A_rescale">rescale</code></td>
<td>
<p>a logical, if <code>TRUE</code> then the sample values of new
wave (output) are rescaled according to the sample values of
<code>wave</code> (input).</p>
</td></tr>
<tr><td><code id="ffilter_+3A_listen">listen</code></td>
<td>
<p>a logical, if <code>TRUE</code> the new sound is played back.</p>
</td></tr>
<tr><td><code id="ffilter_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A short-term Fourier transform is first applied to the signal
(see <code><a href="#topic+spectro">spectro</a></code>), then the frequency filter is applied and the new
signal is eventually generated using the reverse of the Fourier Transform
(<code><a href="#topic+istft">istft</a></code>).<br />
There is therefore neither temporal modifications nor 
amplitude modifications.
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+afilter">afilter</a></code>,<code><a href="#topic+lfs">lfs</a></code>,<code><a href="#topic+fir">fir</a></code>,
<code><a href="#topic+preemphasis">preemphasis</a></code>, <code><a href="#topic+combfilter">combfilter</a></code>, <code><a href="#topic+bwfilter">bwfilter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-noisew(f=8000,d=1)
# low-pass
b&lt;-ffilter(a,f=8000,to=1500)
spectro(b,f=8000,wl=512)
# high-pass
c&lt;-ffilter(a,f=8000,from=2500)
spectro(c,f=8000,wl=512)
# band-pass
d&lt;-ffilter(a,f=8000,from=1000,to=2000)
spectro(d,f=8000,wl=512)
# band-stop
e&lt;-ffilter(a,f=8000,from=1500,to=2500,bandpass=FALSE)
spectro(e,f=8000,wl=512)
# custom
myfilter1&lt;-rep(c(rep(0,64),rep(1,64)),4)
g&lt;-ffilter(a,f=8000,custom=myfilter1)
spectro(g,f=8000)
</code></pre>

<hr>
<h2 id='field'>Near field and far field limits</h2><span id='topic+field'></span>

<h3>Description</h3>

<p>This function helps in knowing whether you are working in 
the near or far field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>field(f, d)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="field_+3A_f">f</code></td>
<td>
<p>frequency (Hz)</p>
</td></tr>
<tr><td><code id="field_+3A_d">d</code></td>
<td>
<p>distance from the sound source (m)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Areas very close to the sound source are in the near-field where the contribution
of particle velocity to sound energy is greater thant that of sound pressure and where
these components are not in phase. Sound propagation properties are also different
near or far from the source. It is therefore important to know where the microphone
was from the source.<br />
To know this, the product k*d is computed according to:
</p>
<p style="text-align: center;"><code class="reqn">k\times{d} = \frac{f}{c}\times{d}</code>
</p>

<p>with <em>d</em> = distance from the source (m), <em>f</em> = frequency (Hz)
and <em>c</em> = sound celerity (m/s).<br />
If k*d is greatly inferior 1 then the microphone is in the near field.<br />
The decision help returned by the function follows the rule:<br />
far field: </p>
<p style="text-align: center;"><code class="reqn">k\times{d} &gt; 1</code>
</p>
 
<p>between near and far field limits: </p>
<p style="text-align: center;"><code class="reqn">0.1 \leq k\times{d} \leq 1</code>
</p>

<p>near field: </p>
<p style="text-align: center;"><code class="reqn">k\times{d} &lt; 0.1</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>A list of two values is returned:
</p>
<table>
<tr><td><code>kd</code></td>
<td>
<p>the numeric value k*d used to take a decision</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>a character string giving the help decision.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function works for air-borne sound only.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># 1 kHz near field at 1 cm from the source
field(f=1000,d=0.01)
# playing with distance from source and sound frequency
op&lt;-par(bg="lightgrey")
D&lt;-seq(0.01,0.5,by=0.01); nD&lt;-length(D)
F&lt;-seq(100,1000,by=25); nF&lt;-length(F)
a&lt;-matrix(numeric(nD*nF),nrow=nD)
for(i in 1:nF) a[,i]&lt;-field(f=F[i],d=D)$kd
matplot(x=D,y=a,type="l",lty=1,col= spectro.colors(nF),
  xlab="Distance from the source (m)", ylab="k*d")
title("Variation of the product k*d with distance and frequency")
text(x=c(0.4,0.15),y=c(0.02,1), c("Near Field","Far Field"),font=2)
legend(x=0.05,y=1.4,c("100 Hz","1000 Hz"),lty=1,
  col=c(spectro.colors(nF)[1],spectro.colors(nF)[nF]),bg="grey")
abline(h=0.1)
par(op)
</code></pre>

<hr>
<h2 id='fir'>Finite Impulse Response filter</h2><span id='topic+fir'></span>

<h3>Description</h3>

<p>This function is a FIR filter that filters out a selected frequency
section of a time wave (low-pass, high-pass, low-stop, high-stop, bandpass
or bandstop frequency filter).</p>


<h3>Usage</h3>

<pre><code class='language-R'>fir(wave, f, channel = 1, from = NULL, to = NULL, bandpass = TRUE, custom = NULL,
wl = 512, wn = "hanning", rescale=FALSE, listen = FALSE, output = "matrix")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fir_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="fir_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="fir_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="fir_+3A_from">from</code></td>
<td>
<p>start frequency (in Hz) where to apply the filter.</p>
</td></tr>
<tr><td><code id="fir_+3A_to">to</code></td>
<td>
<p>end frequency (in Hz) where to apply the filter.</p>
</td></tr>
<tr><td><code id="fir_+3A_bandpass">bandpass</code></td>
<td>
<p>if <code>TRUE</code> a band-pass filter is applied between
<code>from</code> and  <code>to</code>, if not <code>NULL</code> a band-stop filter is applied
between <code>from</code> and  <code>to</code> (by default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="fir_+3A_custom">custom</code></td>
<td>
<p>a vector describing the frequency response of a custom filter.
This can be manually generated or obtained with <code><a href="#topic+spec">spec</a></code> and <code><a href="#topic+meanspec">meanspec</a></code>.
<code>wl</code> is no more required. See examples.</p>
</td></tr>
<tr><td><code id="fir_+3A_wl">wl</code></td>
<td>
<p>window length of the impulse filter (even number of points).</p>
</td></tr>
<tr><td><code id="fir_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default
<code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="fir_+3A_rescale">rescale</code></td>
<td>
<p>a logical, if <code>TRUE</code> then the sample values of new
wave (output) are rescaled according to the sample values of
<code>wave</code> (input).</p>
</td></tr>
<tr><td><code id="fir_+3A_listen">listen</code></td>
<td>
<p>a logical, if <code>TRUE</code> the new sound is played back.</p>
</td></tr>
<tr><td><code id="fir_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the reverse of the Fourier Transform
(<code><a href="stats.html#topic+fft">fft</a></code>) and on a convolution (<code><a href="stats.html#topic+convolve">convolve</a></code>) between the
wave to be filtered and the impulse filter.
</p>


<h3>Value</h3>

<p>A new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Stoddard, P. K. (1998). Application of filters in bioacoustics.
<em>In</em>: Hopp, S. L., Owren, M. J. and Evans, C. S. (Eds), <em>Animal acoustic 
communication</em>. Springer, Berlin, Heidelberg,pp. 105-127.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffilter">ffilter</a></code>, <code><a href="#topic+bwfilter">bwfilter</a></code>, <code><a href="#topic+preemphasis">preemphasis</a></code>, <code><a href="#topic+lfs">lfs</a></code>, <code><a href="#topic+afilter">afilter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-noisew(f=8000,d=1)
# low-pass
b&lt;-fir(a,f=8000,to=1500)
spectro(b,f=8000)
# high-pass
c&lt;-fir(a,f=8000,from=2500)
spectro(c,f=8000)
# band-pass
d&lt;-fir(a,f=8000,from=1000,to=2000)
spectro(d,f=8000)
# band-stop
e&lt;-fir(a,f=8000,from=1500,to=2500,bandpass=FALSE)
spectro(e,f=8000)
# custom filter manually generated
myfilter1&lt;-rep(c(rep(0,32),rep(1,32)),4)
g&lt;-fir(a,f=8000,custom=myfilter1)
spectro(g,f=8000)
# custom filter generated using spec()
data(tico)
myfilter2&lt;-spec(tico,f=22050,at=0.7,wl=512,plot=FALSE)
b&lt;-noisew(d=1,f=22050)
h&lt;-fir(b,f=22050,custom=myfilter2)
spectro(h,f=22050)
</code></pre>

<hr>
<h2 id='fma'>Frequency modulation analysis</h2><span id='topic+fma'></span>

<h3>Description</h3>

<p>This function computes the Fourier analysis of the instantaneous
frequency of a time wave. This allows to detect periodicity 
in frequency modulation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fma(wave, f, channel = 1, threshold = NULL, plot = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fma_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="fma_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="fma_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="fma_+3A_threshold">threshold</code></td>
<td>
<p>amplitude threshold for signal detection (in % ).</p>
</td></tr>
<tr><td><code id="fma_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the spectrum of the instantaneous frequency 
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="fma_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+spec">spec</a></code> parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on <code>ifreq</code> and <code>spec</code>.<br /> 
The instantaneous frequency of <code>wave</code> is first computed and the spectrum of this
frequency modulation is then processed. All <code>env</code> and <code>spec</code> arguments can be
set up.
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, <code>fma</code> returns a numeric vector
corresponding to the computed spectrum.
If <code>peaks</code> is not <code>NULL</code>, <code>fma</code> returns a list with
two elements:
</p>
<table>
<tr><td><code>spec</code></td>
<td>
<p>the spectrum computed</p>
</td></tr>
<tr><td><code>peaks</code></td>
<td>
<p>the peaks values (in kHz).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ifreq">ifreq</a></code>, <code><a href="#topic+hilbert">hilbert</a></code>, <code><a href="#topic+spec">spec</a></code>, <code><a href="#topic+ama">ama</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># a sound with a 1 kHz sinusoid FM
a&lt;-synth(d=1, f=8000, cf=1500, fm=c(1000,1000,0,0,0), output="Wave")
fma(a)
</code></pre>

<hr>
<h2 id='fpeaks'>Frequency peak detection</h2><span id='topic+fpeaks'></span>

<h3>Description</h3>

<p>This function searches for peaks of a frequency spectrum.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpeaks(spec, f = NULL,
nmax = NULL, amp = NULL, freq = NULL, threshold = NULL,
mel =FALSE,
plot = TRUE, title = TRUE,
xlab = NULL, ylab = "Amplitude",
labels = TRUE, digits = 2,
legend = TRUE, collab = "red", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpeaks_+3A_spec">spec</code></td>
<td>
<p>a data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code>. Can be in dB.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>spec</code> (in Hz). Not requested if
the first column of <code>spec</code> contains the frequency axis.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_nmax">nmax</code></td>
<td>
<p>maximal number of peaks detected. Overrides <code>amp</code> and
<code>freq</code>. See details.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_amp">amp</code></td>
<td>
<p>amplitude slope parameter, a numeric vector of length
2. Refers to the amplitude slopes of the peak. The first value is the
left slope and the second value is the right slope. Only peaks with
higher slopes than threshold values will be kept. See details.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_freq">freq</code></td>
<td>
<p>frequency threshold parameter (in Hz). If the frequency
difference of two successive peaks is less than this threshold, then 
the peak of highest amplitude will be kept only. See details.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_threshold">threshold</code></td>
<td>
<p>amplitude threshold parameter. Only peaks above this
threshold will be considered. See details.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_mel">mel</code></td>
<td>
<p>a logical, if <code>TRUE</code> the (htk-)mel scale is used.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code>, a plot showing the peaks is returned.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_title">title</code></td>
<td>
<p>logical, if <code>TRUE</code> add the number of peaks detected
as a plot title.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_xlab">xlab</code></td>
<td>
<p>label of the x-axis.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_ylab">ylab</code></td>
<td>
<p>label of the y-axis.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_labels">labels</code></td>
<td>
<p>logical, if <code>TRUE</code> peak labels are plotted.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_digits">digits</code></td>
<td>
<p>if <code>labels</code> is <code>TRUE</code>, the number of decimal
places (<code><a href="base.html#topic+round">round</a></code>) for the peak labels.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_legend">legend</code></td>
<td>
<p>logical, if <code>TRUE</code> a legend returning the different
selection parameters (<code>nmax</code>, <code>amp</code>, <code>freq</code>,
<code>threshold</code>, <code>threshold</code>) is added to the plot.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_collab">collab</code></td>
<td>
<p>labels color.</p>
</td></tr>
<tr><td><code id="fpeaks_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here are some details regarding the different selection
parameters:<br />
</p>

<ul>
<li> <p><code>nmax</code>: this parameter is to be used if you wish to get a
specific number of peaks. The peaks selected are those with the
highest slopes. It then does not work in conjunction with the other parameters.
</p>
</li>
<li> <p><code>freq</code>: this parameter allows to remove from the selection
successive peaks with a small frequency difference. Imagine you have two
successive peaks at 1200 Hz and 1210 Hz and at 0.5 
and 0.25 in amplitude. If you set <code>freq</code> to 50 Hz, then only the first
peak will be kept.
</p>
</li>
<li> <p><code>amp</code>: this parameter allows to remove from the selection
peaks with low slopes. You can make the selection on both slopes or on
a single one. Imagine you have an asymetric peak with a 0.01 left slope and a
0.02 right slope. The peak will be discarded for the following
settings: both values higher than 0.02 (<em>e.g.</em> <code>amp =
    c(0.03,0.04)</code>), the first value higher than 0.01 (<em>e.g.</em> <code>amp =
    c(0.02,0.001)</code>), the second value higher than 0.02 (<em>e.g.</em> <code>amp =
    c(0.001,0.03)</code>). If you do not want apply the selection
on one of the slope use 0. For instance, a selection on the left slope
only will be achieved with: <code>amp = c(0.02,0)</code>.
</p>
</li>
<li> <p><code>threshold</code>: this parameter can be used to do a rough
selection on the spectrum. Peaks with an amplitude value (not a slope)
lower than this threshold will be automatically discarded. This can be
useful when you want to remove peaks of a low-amplitude background noise.
</p>
</li></ul>



<h3>Value</h3>

<p>A two-column matrix, the first column corresponding to the
frequency values (x-axis) and the second column corresponding to the
amplitude values (y-axis) of the peaks.</p>


<h3>Note</h3>

<p>You can also use <code>fpeaks</code> with other kind of spectrum, for
instance a cepstral spectrum. See examples.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur and Amandine Gasc</p>


<h3>See Also</h3>

<p><code><a href="#topic+localpeaks">localpeaks</a></code>, <code><a href="#topic+meanspec">meanspec</a></code>, <code><a href="#topic+spec">spec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
spec &lt;- meanspec(tico, f=22050, plot=FALSE)
specdB &lt;- meanspec(tico, f=22050, dB="max0", plot=FALSE)
# all peaks
fpeaks(spec)
# 10 highest peaks
fpeaks(spec, nmax=10)
# highest peak (ie dominant frequency)
fpeaks(spec, nmax=1)
# peaks that are separated by more than 500 Hz
fpeaks(spec, freq=500)
# peaks with a left slope higher than 0.1
fpeaks(spec, amp=c(0.1,0))
# peaks with a right slope higher than 0.1
fpeaks(spec, amp=c(0,0.1))
# peaks with left and right slopes higher than 0.1
fpeaks(spec, amp=c(0.1,0.1))
# peaks above a 0.5 threshold
fpeaks(spec, threshold=0.5)
# peaks of a dB spectrum with peaks showing slopes higher than 3 dB
fpeaks(specdB, amp=c(3,3))
# comparing different parameter settings
meanspec(tico, f=22050)
col &lt;- c("#ff000090","#0000ff75","#00ff00")
cex &lt;- c(2,1.25,1.5)
pch &lt;- c(19,17,4)
title(main="Peak detection \n (spectrum with values between 0 and 1)")
res1 &lt;- fpeaks(spec, plot = FALSE)
res2 &lt;- fpeaks(spec, amp=c(0.02,0.02), plot =FALSE)
res3 &lt;- fpeaks(spec, amp=c(0.02,0.02), freq=200, plot = FALSE)
points(res1, pch=pch[1], col=col[1], cex=cex[1])
points(res2, pch=pch[2], col=col[2], cex=cex[2])
points(res3, pch=pch[3], col=col[3], cex=cex[3])
legend("topright", legend=c("all peaks","amp", "amp &amp; freq"), pch=pch,
pt.cex=cex, col=col, bty="n")
# example with a cepstral spectrum
data(sheep)
res &lt;- ceps(sheep,f=8000,at=0.4,wl=1024,plot=FALSE)
fpeaks(res, nmax=4, xlab="Quefrency (s)")
# melscale
require(tuneR)
mel &lt;- melfcc(sheep, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
melspec.mean &lt;- apply(mel$aspectrum, MARGIN=2, FUN=mean)
melspec.mean &lt;- melspec.mean/max(melspec.mean) # [0,1] scaling 
fpeaks(melspec.mean, nmax=4, f=8000, mel=TRUE)
fpeaks(melspec.mean, freq=4, f=8000, mel=TRUE) # freq in Hz!
fpeaks(melspec.mean, threshold=0.3, f=8000, mel=TRUE)
fpeaks(melspec.mean, amp=c(0.1,0.1), f=8000, mel=TRUE)
</code></pre>

<hr>
<h2 id='ftwindow'>Fourier transform windows</h2><span id='topic+ftwindow'></span>

<h3>Description</h3>

<p>Generates different Fourier Transform windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ftwindow(wl, wn = "hamming",
        correction = c("none", "amplitude", "energy"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ftwindow_+3A_wl">wl</code></td>
<td>
<p>window length</p>
</td></tr>
<tr><td><code id="ftwindow_+3A_wn">wn</code></td>
<td>
<p>window name: <code>bartlett</code>, <code>blackman</code>,
<code>flattop</code>, <code>hamming</code>, <code>hanning</code>, or <code>rectangle</code>
(by default <code>hamming</code>).</p>
</td></tr>
<tr><td><code id="ftwindow_+3A_correction">correction</code></td>
<td>
<p>a character vector of length 1 to apply an
amplitude (&quot;amplitude&quot;) or an energy (&quot;energy&quot;) correction
to the FT window. By default no correction is applied (&quot;none&quot;).</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>A vector of length <code>wl</code>.
</p>


<h3>Note</h3>

<p>Try the example to see windows shape.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Harris, F.J., 1978. On the use of windows for harmonic analysis
with the discrete Fourier Transform. <em>Proceedings of the IEEE</em>, 66(1): 51-83.</p>


<h3>See Also</h3>

<p><code><a href="#topic+covspectro">covspectro</a></code>, <code><a href="#topic+dfreq">dfreq</a></code>, <code><a href="#topic+meanspec">meanspec</a></code>,
<code><a href="#topic+spec">spec</a></code>, <code><a href="#topic+spectro">spectro</a></code>, <code><a href="#topic+spectro3D">spectro3D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-ftwindow(512)
b&lt;-ftwindow(512,wn="bartlett")
c&lt;-ftwindow(512,wn="blackman")
d&lt;-ftwindow(512,wn="flattop")
e&lt;-ftwindow(512,wn="hanning")
f&lt;-ftwindow(512,wn="rectangle")
all&lt;-cbind(a,b,c,d,e,f)
matplot(all,type="l",col=1:6,lty=1:6)
legend(legend=c("hamming","bartlett","blackman","flattop","hanning","rectangle"),
x=380,y=0.95,col=1:6,lty=1:6,cex=0.75)
</code></pre>

<hr>
<h2 id='fund'>Fundamental frequency track</h2><span id='topic+fund'></span>

<h3>Description</h3>

<p>This function estimates the fundamental frequency through a
short-term cepstral transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fund(wave, f, channel = 1, wl = 512, ovlp = 0, fmax = f/2, threshold = NULL,
at = NULL, from = NULL, to = NULL, 
plot = TRUE, xlab = "Time (s)", ylab = "Frequency (kHz)",
ylim = c(0, f/2000), pb = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fund_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="fund_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="fund_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="fund_+3A_wl">wl</code></td>
<td>
<p>if <code>at</code> is not null, length of the window for the analysis
(even number of points, by defaults = 512).</p>
</td></tr>
<tr><td><code id="fund_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in %).</p>
</td></tr>
<tr><td><code id="fund_+3A_fmax">fmax</code></td>
<td>
<p>the maximum frequency to detect (in Hz).</p>
</td></tr>  
<tr><td><code id="fund_+3A_threshold">threshold</code></td>
<td>
<p>amplitude threshold for signal detection (in %).</p>
</td></tr>
<tr><td><code id="fund_+3A_at">at</code></td>
<td>
<p>position where the estimate the fundamental frequency (in s)</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="fund_+3A_from">from</code></td>
<td>
<p>start position where to compute the fundamental frequency (in s).</p>
</td></tr>
<tr><td><code id="fund_+3A_to">to</code></td>
<td>
<p>end position to compute the fundamental frequency (in s).</p>
</td></tr>
<tr><td><code id="fund_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the fundamental frequency
modulations against time (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="fund_+3A_xlab">xlab</code></td>
<td>
<p>title of the time axis (s).</p>
</td></tr>
<tr><td><code id="fund_+3A_ylab">ylab</code></td>
<td>
<p>title of the frequency axis (Hz).</p>
</td></tr>
<tr><td><code id="fund_+3A_ylim">ylim</code></td>
<td>
<p>the range of frequency values.</p>
</td></tr>
<tr><td><code id="fund_+3A_pb">pb</code></td>
<td>
<p>if <code>TRUE</code> returns a text progress bar in the console.</p>
</td></tr>
<tr><td><code id="fund_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>plot</code> is <code>FALSE</code>, <code>fund</code> returns a two-column matrix, the first column corresponding to time in seconds (<em>x</em>-axis) and the second column corresponding to 
to fundamental frequency in kHz (<em>y</em>-axis).<br />
NA corresponds to pause sections in <code>wave</code> (see
<code>threshold</code>). <br />
No plot is produced when using <code>at</code>.
</p>


<h3>Note</h3>

<p>This function is based on <code><a href="#topic+ceps">ceps</a></code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a>.</p>


<h3>References</h3>

<p>Oppenheim, A.V. and Schafer, R.W. 2004. From frequency
to quefrency: a history of the cepstrum. <em>Signal Processing Magazine IEEE</em>,
21: 95-106.</p>


<h3>See Also</h3>

<p><code><a href="#topic+cepstro">cepstro</a></code>, <code><a href="#topic+ceps">ceps</a></code>, <code><a href="#topic+autoc">autoc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sheep)
# estimate the fundamental frequency at a single position
fund(sheep, f=8000, fmax=300, at=1, plot=FALSE)
# track the fundamental frequency along time
fund(sheep,f=8000,fmax=300,type="l")
# with 50% overlap between successive sliding windows, time zoom and 
# amplitude filter (threshold)
fund(sheep,f=8000,fmax=300,type="b",ovlp=50,threshold=5,ylim=c(0,1),cex=0.5)
# overlaid on a spectrogram
spectro(sheep,f=8000,ovlp=75,zp=16,scale=FALSE,palette=reverse.gray.colors.2)
par(new=TRUE)
fund(sheep,f=8000,fmax=300,type="p",pch=24,ann=FALSE,
  xaxs="i",yaxs="i",col="black",bg="red",threshold=6)
</code></pre>

<hr>
<h2 id='gammatone'>Gammatone filter</h2><span id='topic+gammatone'></span>

<h3>Description</h3>

<p>Generate gammatone filter in the time domain (impulse response).</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammatone(f, d, cfreq, n = 4, a = 1, p = 0, output = "matrix")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammatone_+3A_f">f</code></td>
<td>
<p>sampling frequency (in Hz).</p>
</td></tr>
<tr><td><code id="gammatone_+3A_d">d</code></td>
<td>
<p>duration (in s).</p>
</td></tr>
<tr><td><code id="gammatone_+3A_cfreq">cfreq</code></td>
<td>
<p>center frequency (in Hz).</p>
</td></tr>
<tr><td><code id="gammatone_+3A_n">n</code></td>
<td>
<p>filter order (no unit).</p>
</td></tr>
<tr><td><code id="gammatone_+3A_a">a</code></td>
<td>
<p>amplitude (linear scale, no unit).</p>
</td></tr>
<tr><td><code id="gammatone_+3A_p">p</code></td>
<td>
<p>initial phase (in radians).</p>
</td></tr>
<tr><td><code id="gammatone_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gammatone function in the time domain (impulse response) is
obtained with:<br />
</p>
<p style="text-align: center;"><code class="reqn">g(t) = a \times t^{n-1} \times e^{-2\pi \beta t} \times \cos(2 \pi cf t + \phi)</code>
</p>

<p>with <em>a</em> the amplitude, <em>t</em> time, <em>n</em> the filter order, <em>cf</em> the center frequency, <code class="reqn">\phi</code> the initial phase.<br />
The parameter <code class="reqn">\beta</code> is the equivalent rectangular
bandwidth (ERB) bandwidth which varies according to the center
frequency <code class="reqn">cf</code> following:<br />
</p>
<p style="text-align: center;"><code class="reqn">\beta = 24.7 \times (4.37 \times \frac{cf}{1000} + 1)</code>
</p>
 


<h3>Value</h3>

<p>A wave is returned. The class of the returned object is set with the argument <code>output</code>.</p>


<h3>Note</h3>

<p>Use the FFT based function, as <code><a href="#topic+spec">spec</a></code> or
<code><a href="#topic+meanspec">meanspec</a></code>, to get the filter in the frequency domain. See examples.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Holdsworth J, Nimmo-Smith I, Patterson R, Rice P (1988) Implementing a gammatone filter bank. Annex C of the SVOS Final Report: Part A: The Auditory Filterbank, 1, 1-5.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+melfilterbank">melfilterbank</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## gammatone filter in the time domain (impulse response)
f &lt;- 44100
d &lt;- 0.05
res &lt;- gammatone(f=f, d=d, cfreq=440, n=4)
## time display
oscillo(res, f=f)
## frequency display
spec(res, f=f)
## generate and plot a bank of 32 filters from 500 to 10000 Hz
n &lt;- 32
cfreq &lt;- round(seq(500, 10000, length.out=n))
res &lt;- matrix(NA, nrow=f*d/2, ncol=n)
for(i in 1:n){
    res[,i] &lt;- spec(gammatone(f=f, d=d, cfreq=cfreq[i]), f=f, dB="max0", plot=FALSE)[,2]
}
x &lt;- seq(0,f/2,length.out=nrow(res))/1000
plot(x=x, y=res[,1],
     xlim=c(0,14), ylim=c(-60,0),
     type="l", col=2, las=1, 
     xlab="Frequency (kHz)", ylab="Relative amplitude (dB)")
for(i in 2:n) lines(x, res[,i], col=2)
## use the frequency domain to filter a white noise input
## here around the center frequency 2000 Hz
res &lt;- gammatone(f=f, d=d, cfreq=2000, n=4)
gspec &lt;- spec(res, f=f, plot=FALSE)[,2]
nw &lt;- noisew(f=44100, d=1)
nwfilt &lt;- fir(nw, f=44100, wl=length(gspec)*2, custom=gspec) 
spectro(nwfilt, f=f)
</code></pre>

<hr>
<h2 id='ggspectro'>2D-spectrogram of a time wave using ggplot2</h2><span id='topic+ggspectro'></span>

<h3>Description</h3>

<p>This function returns a ggplot object to draw a spectrogram
with the package ggplot2. This is an alternative to <code><a href="#topic+spectro">spectro</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggspectro(wave, f, tlab = "Time (s)",
flab = "Frequency (kHz)", alab = "Amplitude\n(dB)\n", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggspectro_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="ggspectro_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="ggspectro_+3A_tlab">tlab</code></td>
<td>
<p>label of the time axis.</p>
</td></tr>
<tr><td><code id="ggspectro_+3A_flab">flab</code></td>
<td>
<p>label of the frequency axis.</p>
</td></tr>
<tr><td><code id="ggspectro_+3A_alab">alab</code></td>
<td>
<p>label of the amplitude axis.</p>
</td></tr>
<tr><td><code id="ggspectro_+3A_...">...</code></td>
<td>
<p>other non-graphical arguments to be passed to spectro
(<code>wl</code>, <code>ovlp</code> etc).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function return the fist layer (data and aesthetic
mapping) of a ggplot2 plot. <br />
See the example section to understand how to build a spectrogram and consult ggplot2 help to get what you
exactly need.<br />
There is no way to plot the oscillogram as <code><a href="#topic+spectro">spectro</a> does.</code>
</p>


<h3>Value</h3>

<p>A ggpot layer.</p>


<h3>Note</h3>

<p>This function requires <span class="pkg">ggplot2</span> package.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Wickham H (2009) &ndash; <em>ggplot2: elegant graphics for data analysis</em>. UseR! Springer.</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectro">spectro</a></code>, <code><a href="#topic+spectro3D">spectro3D</a></code>, <code><a href="#topic+dynspec">dynspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(ggplot2)
## first layer
v &lt;- ggspectro(tico, ovlp=50)
summary(v)
## using geom_tile ##
v + geom_tile(aes(fill = amplitude)) + stat_contour()
## coordinates flip (interest?)
v + geom_tile(aes(fill = amplitude)) + stat_contour() + coord_flip()
## using stat_contour ##
# default (not nice at all)
v + stat_contour(geom="polygon", aes(fill=..level..))
# set up to 30 color levels with the argument bins
(vv &lt;- v + stat_contour(geom="polygon", aes(fill=..level..), bins=30))
# change the limits of amplitude and NA values as transparent
vv + scale_fill_continuous(name="Amplitude\n(dB)\n", limits=c(-30,0), na.value="transparent")
# Black-and-white theme
(vv + scale_fill_continuous(name="Amplitude\n(dB)\n", limits=c(-30,0),
  na.value="transparent", low="white", high="black") + theme_bw())
# Other colour scale (close to spectro() default output)
v + stat_contour(geom="polygon", aes(fill=..level..), bins=30)
  + scale_fill_gradientn(name="Amplitude\n(dB)\n", limits=c(-30,0),
  na.value="transparent", colours = spectro.colors(30))

## End(Not run)</code></pre>

<hr>
<h2 id='H'>Total entropy</h2><span id='topic+H'></span>

<h3>Description</h3>

<p>This function estimates the total entropy of a time wave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H(wave, f, channel = 1, wl = 512, envt="hil", msmooth = NULL, ksmooth = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="H_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="H_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="H_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="H_+3A_wl">wl</code></td>
<td>
<p>window length for spectral entropy analysis
(even number of points). See <code><a href="#topic+sh">sh</a></code>.</p>
</td></tr>
<tr><td><code id="H_+3A_envt">envt</code></td>
<td>
<p>the type of envelope to be used: either &quot;abs&quot; for absolute
amplitude envelope or &quot;hil&quot; for Hilbert amplitude envelope. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="H_+3A_msmooth">msmooth</code></td>
<td>
<p>a vector of length 2 to smooth the amplitude envelope with a 
mean sliding window. The first component is the window length
(in number of points). The second component is the overlap between
successive windows (in %). See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="H_+3A_ksmooth">ksmooth</code></td>
<td>
<p>kernel smooth via <code><a href="stats.html#topic+kernel">kernel</a></code>. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the product between the values obtained with
<code><a href="#topic+sh">sh</a></code> and <code><a href="#topic+th">th</a></code> functions. <br />
This then gives a global (time and frequency) estimation of signal entropy.<br />
The frequency mean spectrum and the amplitude envelope needed for computing
respectively <code><a href="#topic+sh">sh</a></code> and <code><a href="#topic+th">th</a></code> are automatically generated.
They can be controlled through <code>wl</code> and  <code>smooth</code> arguments respectively.
See examples below and examples in <code><a href="#topic+sh">sh</a></code> and <code><a href="#topic+th">th</a></code>
for implications on the results. 
</p>


<h3>Value</h3>

<p>A single value varying between 0 and 1 is returned. The value has no unit.</p>


<h3>Note</h3>

<p>The entropy of a noisy signal will tend towards 1 whereas
the entropy of a pure tone signal will tend towards 0.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Sueur, J., Pavoine, S., Hamerlynck, O. &amp; Duvail, S. (2008) - Rapid acoustic survey for biodiversity appraisal. <em>PLoS ONE</em>, 3(12): e4065.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sh">sh</a></code>, <code><a href="#topic+th">th</a></code>, <code><a href="#topic+csh">csh</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orni)
H(orni,f=22050)
# changing the spectral parameter (wl)
H(orni,f=22050,wl=1024)
# changing the temporal parameter (msmooth)
H(orni,f=22050,msmooth=c(20,0))
</code></pre>

<hr>
<h2 id='hilbert'>Hilbert transform and analytic signal</h2><span id='topic+hilbert'></span>

<h3>Description</h3>

<p>This function returns the analytic signal of a time wave
through Hilbert transform.</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert(wave, f, channel = 1, fftw = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbert_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="hilbert_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="hilbert_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="hilbert_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code> for faster computation. See Notes of the function <code>spectro</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analytic signal is useful to get the amplitude envelope 
(see argument <code>henv</code> of <code><a href="#topic+oscillo">oscillo</a></code> and the instantaneous
phase or frequency (see <code><a href="#topic+ifreq">ifreq</a></code>) of a time wave.</p>


<h3>Value</h3>

<p><code>hilbert</code> returns the analytic signal as a complex matrix.
The imaginary part of this matrix is the Hilbert transform.</p>


<h3>Note</h3>

<p>To get the Hilbert component only, use <code>Im(Hilbert(wave))</code>.</p>


<h3>Author(s)</h3>

<p>Jonathan Lees <a href="mailto:jonathan.lees@unc.edu">jonathan.lees@unc.edu</a>. Implementation of
'fftw' argument by Jean Marchal and Francois Fabianek.</p>


<h3>References</h3>

<p>Mbu Nyamsi, R. G., Aubin, T. &amp; Bremond, J. C. 1994
On the extraction of some time dependent parameters of an acoustic signal
by means of the analytic signal concept.
Its application to animal sound study. <em>Bioacoustics</em>, 5: 187-203.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifreq">ifreq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-synth(f=8000, d=1, cf=1000)
aa&lt;-hilbert(a, f=8000)
</code></pre>

<hr>
<h2 id='ifreq'>Instantaneous frequency</h2><span id='topic+ifreq'></span>

<h3>Description</h3>

<p>This function returns the instantaneous frequency (and/or phase) of a time wave
through the computation of the analytic signal (Hilbert transform).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifreq(wave, f, channel = 1, phase = FALSE, threshold = NULL,
plot = TRUE, xlab = "Time (s)", ylab = NULL,
ylim = NULL, type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifreq_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="ifreq_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="ifreq_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="ifreq_+3A_phase">phase</code></td>
<td>
<p>if <code>TRUE</code> and  <code>plot</code> is also <code>TRUE</code>
plots the instantaneous phase instead of the instantaneous frequency.</p>
</td></tr>
<tr><td><code id="ifreq_+3A_threshold">threshold</code></td>
<td>
<p>amplitude threshold for signal detection (in % ).</p>
</td></tr>
<tr><td><code id="ifreq_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the instantaneous frequency or phase
against time (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ifreq_+3A_xlab">xlab</code></td>
<td>
<p>title of the x axis.</p>
</td></tr>
<tr><td><code id="ifreq_+3A_ylab">ylab</code></td>
<td>
<p>title of the y axis.</p>
</td></tr>
<tr><td><code id="ifreq_+3A_ylim">ylim</code></td>
<td>
<p>the range of y values.</p>
</td></tr>
<tr><td><code id="ifreq_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>  
<tr><td><code id="ifreq_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The instantaneous phase is the argument of the 
analytic signal obtained throught the Hilbert transform.<br />
The instantaneous phase is then unwrapped and derived against time to
get the instantaneous frequency.<br />
There may be some edge effects at both start and end of the time wave. 
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, <code>ifreq</code>
returns a list of two components:
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p>a two-column matrix, the first column corresponding to time in seconds
(<em>x</em>-axis) and the second column corresponding to instantaneous
frequency in kHz (<em>y</em>-axis).</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a two-column matrix, the first column corresponding to time in seconds
(<em>x</em>-axis) and the second column corresponding to wrapped
instantaneous phase in radians (<em>y</em>-axis).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is based on the analytic signal obtained with the 
Hilbert transform (see <code><a href="#topic+hilbert">hilbert</a></code>).<br />
The function requires the package <span class="pkg">signal</span>.<br />
The matrix describing the instantaneous phase has one more row than the
one describing the instantaneous frequency.
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Mbu Nyamsi, R. G., Aubin, T. &amp; Bremond, J. C. 1994
On the extraction of some time dependent parameters of an acoustic signal
by means of the analytic signal concept.
Its application to animal sound study. <em>Bioacoustics</em>, 5: 187-203.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hilbert">hilbert</a></code>, <code><a href="#topic+zc">zc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a sound with sine and linear frequency modulations
a&lt;-synth(d=1, f=8000, cf=1500, fm=c(200,10,1000,0,0))
# plot on a single graphical device the instantaneous frequency and phase
op&lt;-par(mfrow=c(2,1))
ifreq(a,f=8000,main="Instantaneous frequency")
ifreq(a,f=8000,phase=TRUE,main="Instantaneous phase")
par(op)
</code></pre>

<hr>
<h2 id='istft'>Inverse of the short-term Fourier transform</h2><span id='topic+istft'></span>

<h3>Description</h3>

<p>This function returns a wave object from a complex STFT matrix by computing the inverse of the short-term
Fourier transform (STFT)</p>


<h3>Usage</h3>

<pre><code class='language-R'>istft(stft, f, wl, ovlp=75, wn="hanning", output = "matrix")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="istft_+3A_stft">stft</code></td>
<td>
<p>a complex matrix resulting of a short-term Fourier transform.</p>
</td></tr>
<tr><td><code id="istft_+3A_f">f</code></td>
<td>
<p>sampling frequency of the original <code>wave</code> object (in Hz)</p>
</td></tr>
<tr><td><code id="istft_+3A_wl">wl</code></td>
<td>
<p>FFT window length for the analysis (even number of points).</p>
</td></tr>
<tr><td><code id="istft_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between successive FFT windows (in %, by default
75%, see the Details section).</p>
</td></tr>
<tr><td><code id="istft_+3A_wn">wn</code></td>
<td>
<p>character string specifying the FFT window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="istft_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is based on the inverse of the FFT (see <code><a href="stats.html#topic+fft">fft</a></code>) and on
the overlap add (OLA) method.<br />
The overlap percentage must satisfy the Perfect Reconstruction OLA-constraint. For
the most windows, this constraint is: <br />
</p>
<p style="text-align: center;"><code class="reqn">ovlp = 100 \times (1 - \frac{1}{4 \times n}),</code>
</p>
<p><br />
with <em>n</em> being a positive integer.<br />
A default value is set to 75%. We suggest not to change it.
</p>


<h3>Value</h3>

<p>A new wave is returned. The class of the returned object is set with the argument <code>output</code>.</p>


<h3>Note</h3>

<p>The <code>stft</code> input data must be complex. <br />
This function is used by <code><a href="#topic+ffilter">ffilter</a></code>, <code><a href="#topic+lfs">lfs</a></code> to
respectively filter in frequency and shift in frequency a sound. <br />
The function can be used to reconstruct or modify a sound. See examples.</p>


<h3>Author(s)</h3>

<p>Original Matlab code by Hristo Zhivomirov (Technical University of Varna, Bulgaria),
translated and adapted to R by Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectro">spectro</a></code>, <code><a href="#topic+ffilter">ffilter</a></code>, <code><a href="#topic+lfs">lfs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# STFT and iSTFT parameters
wl &lt;- 1024
ovlp &lt;- 75
# reconstruction of the tico sound from the stft complex data matrix
data(tico)
data &lt;- spectro(tico, wl=wl, ovlp=ovlp, plot=FALSE, norm=FALSE, dB=NULL, complex=TRUE)$amp
res &lt;- istft(data, ovlp=ovlp, wn="hanning", wl=wl, f=22050, out="Wave")
spectro(res)
# a strange frequency filter
n &lt;- noisew(d=1, f=44100)
data &lt;- spectro(n, f=44100, wl=wl, ovlp=ovlp, plot=FALSE, norm=FALSE, dB=NULL, complex=TRUE)$amp
data[64:192, 6:24] &lt;- 0 
nfilt &lt;- istft(data, f=8000, wl=wl, ovlp=ovlp, output="Wave")
spectro(nfilt, wl=wl, ovlp=ovlp)

## End(Not run)
</code></pre>

<hr>
<h2 id='itakura.dist'>Itakuro-Saito distance</h2><span id='topic+itakura.dist'></span>

<h3>Description</h3>

<p>Compare two distributions (e.g. two frequency spectra) by
computing the Itakuro-Saito distance</p>


<h3>Usage</h3>

<pre><code class='language-R'>itakura.dist(spec1, spec2, scale=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itakura.dist_+3A_spec1">spec1</code></td>
<td>
<p>any distribution, especially a spectrum obtained with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This can be either a two-column matrix (col1 = frequency, col2 = amplitude) or a vector (amplitude).</p>
</td></tr>
<tr><td><code id="itakura.dist_+3A_spec2">spec2</code></td>
<td>
<p>any distribution, especially a spectrum obtained with
<code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This can be
either a two-column matrix (col1 = frequency, col2 = amplitude) or a
vector (amplitude).</p>
</td></tr>
<tr><td><code id="itakura.dist_+3A_scale">scale</code></td>
<td>
<p>a logical, if <code>TRUE</code> the distance is scaled by dividing the
distance by the length of <code>spec1</code> (or <code>spec2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Itakura-Saito (I-S) distance is a
non-symmetric measure of the difference between two probability
distributions. It is here adapted for frequency spectra. The distance
is asymmetric, ie computing the I-S distance between spec1 and spec2 is
not the same as computing it between spec2 and spec1. A symmetry can be
obtained by calculating the mean between the two directions.<br />
The distance is obtained following:<br />
</p>
<p style="text-align: center;"><code class="reqn">D_{I-S}(spec1 \Vert spec2) = \sum{\frac{spec1}{spec2} -
  log(\frac{spec1}{spec2}) - 1}</code>
</p>



<h3>Value</h3>

<p>The function returns a list of three items:
</p>
<table>
<tr><td><code>D1</code></td>
<td>
<p>The I-S distance of 'spec2' with respect to 'spec1'
(<em>i.e.</em> D(spec1 || spec2))</p>
</td></tr>
<tr><td><code>D2</code></td>
<td>
<p>The I-S distance of 'spec1' with respect to 'spec2'
(<em>i.e.</em> D(spec2 || spec1))</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>The symmetric distance (<em>i.e.</em> D = 0.5*(D1+D2))</p>
</td></tr>
</table>
<p>If <code>scale = TRUE</code> the distance is divided by the length of <code>spec1</code>
(or <code>spec2</code>).
</p>


<h3>Note</h3>

<p>The function works for both Hz and (htk-)mel scales.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, improved by Laurent Lellouch</p>


<h3>See Also</h3>

<p><code><a href="#topic+kl.dist">kl.dist</a></code>, <code><a href="#topic+ks.dist">ks.dist</a></code>, <code><a href="#topic+logspec.dist">logspec.dist</a></code>, <code><a href="#topic+simspec">simspec</a></code>, <code><a href="#topic+diffspec">diffspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Comparison of two spectra
data(tico)
tico1 &lt;- spec(tico, at=0.65, plot=FALSE)
tico2 &lt;- spec(tico, at=1.1, plot=FALSE)
itakura.dist(tico1, tico2)
itakura.dist(tico1, tico2, scale=TRUE) 
</code></pre>

<hr>
<h2 id='kl.dist'>Kullback-Leibler distance</h2><span id='topic+kl.dist'></span>

<h3>Description</h3>

<p>Compare two distributions (e.g. two frequency spectra) by
computing the Kullback-Leibler distance</p>


<h3>Usage</h3>

<pre><code class='language-R'>kl.dist(spec1, spec2, base = 2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kl.dist_+3A_spec1">spec1</code></td>
<td>
<p>any distribution, especially a spectrum obtained with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This can be either a two-column matrix (col1 = frequency, col2 = amplitude) or a vector (amplitude).</p>
</td></tr>
<tr><td><code id="kl.dist_+3A_spec2">spec2</code></td>
<td>
<p>any distribution, especially a spectrum obtained with
<code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This can be
either a two-column matrix (col1 = frequency, col2 = amplitude) or a
vector (amplitude).</p>
</td></tr> 
<tr><td><code id="kl.dist_+3A_base">base</code></td>
<td>
<p>the logarithm base used to compute the distance. See <code><a href="base.html#topic+log">log</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kullback-Leibler distance or relative entropy is a
non-symmetric measure of the difference between two probability
distributions. It is here adapted for frequency spectra. The distance
is asymmetric, ie computing the K-L distance between spec1 and spec2 is
not the same as computing it between spec2 and spec1. A symmetry can be
obtained by calculating the mean between the two directions.<br />
The distance is obtained following:<br />
</p>
<p style="text-align: center;"><code class="reqn">D_{K-L}(spec1 \Vert spec2) = \sum{spec1 \times log(\frac{spec1}{spec2})}</code>
</p>



<h3>Value</h3>

<p>The function returns a list of three items:
</p>
<table>
<tr><td><code>D1</code></td>
<td>
<p>The K-L distance of 'spec2' with respect to 'spec1'
(<em>i.e.</em> D(spec1 || spec2))</p>
</td></tr>
<tr><td><code>D2</code></td>
<td>
<p>The K-L distance of 'spec1' with respect to 'spec2'
(<em>i.e.</em> D(spec2 || spec1))</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>The symmetric K-L distance (<em>i.e.</em> D = 0.5*(D1+D2))</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The base of the logarithm can be changed using the argument
<code>base</code>. When sets to base 2, the information is measured in units of
bits. When sets to base <em>e</em>, the information is measured in
nats.<br />
The function works for both Hz and (htk-)mel scales.
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, improved by Laurent Lellouch</p>


<h3>References</h3>

<p>Kullback, S., Leibler, R.A. (1951). On information and sufficiency. <em>Annals of Mathematical Statistics</em>, 22: 79-86</p>


<h3>See Also</h3>

<p><code><a href="#topic+ks.dist">ks.dist</a></code>, <code><a href="#topic+logspec.dist">logspec.dist</a></code>, <code><a href="#topic+simspec">simspec</a></code>, <code><a href="#topic+diffspec">diffspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Comparison of two spectra
data(tico)
tico1 &lt;- spec(tico, at=0.65, plot=FALSE)
tico2 &lt;- spec(tico, at=1.1, plot=FALSE)
kl.dist(tico1, tico2)    # log2 (binary logarithm)
kl.dist(tico1, tico2, base=exp(1))  # ln (natural logarithm)
</code></pre>

<hr>
<h2 id='ks.dist'>Kolmogorov-Smirnov distance</h2><span id='topic+ks.dist'></span>

<h3>Description</h3>

<p>This function compares two distributions (e.g. two frequency spectra) by
computing the Kolmogorov-Smirnov distance</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks.dist(spec1, spec2, f = NULL, mel = FALSE,
plot = FALSE, type = "l",
lty = c(1, 2), col = c(2, 4), 
flab = NULL, alab = "Cumulated amplitude",
flim = NULL, alim = NULL,
title = TRUE, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ks.dist_+3A_spec1">spec1</code></td>
<td>
<p>any distribution, especially a spectrum obtained with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This can be either a two-column matrix (col1 = frequency, col2 = amplitude) or a vector (amplitude).</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_spec2">spec2</code></td>
<td>
<p>any distribution, especially a spectrum obtained with
<code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This can be
either a two-column matrix (col1 = frequency, col2 = amplitude) or a
vector (amplitude).</p>
</td></tr> 
<tr><td><code id="ks.dist_+3A_f">f</code></td>
<td>
<p>sampling frequency of waves used to obtain <code>spec1</code>
and <code>spec2</code> (in Hz). Not necessary if <code>spec1</code> and/or <code>spec2</code>
is a two columns matrix obtained with <code><a href="#topic+spec">spec</a></code>
or <code><a href="#topic+meanspec">meanspec</a></code>.</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_mel">mel</code></td>
<td>
<p>a logical, if <code>TRUE</code> the (htk-)mel scale is used.</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots both cumulated spectra and
their maximal distance (<em>i.e.</em> the K-S distance.)</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_lty">lty</code></td>
<td>
<p>a vector of length 2 for the line type of <code>spec1</code> and
<code>spec2</code> if <code>type</code>=&quot;l&quot;.</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_col">col</code></td>
<td>
<p>a vector of length 2 for the colour of <code>spec1</code> and <code>spec2</code>.</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_flab">flab</code></td>
<td>
<p>title of the frequency axis.</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_alab">alab</code></td>
<td>
<p>title of the amplitude axis.</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_flim">flim</code></td>
<td>
<p>the range of frequency values.</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_alim">alim</code></td>
<td>
<p>range of amplitude axis.</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_title">title</code></td>
<td>
<p>logical, if <code>TRUE</code>, adds a title with D and F values.</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_legend">legend</code></td>
<td>
<p>logical, if <code>TRUE</code> adds a legend to the plot.</p>
</td></tr>
<tr><td><code id="ks.dist_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kolmogorov distance is the maximal distance between the
cumulated spectra. The function returns this distance and the
corresponding frequency. This is an adaptation of the statistic
computed by the  non-parametric  Kolmogorov-Smirnov test (see <code><a href="stats.html#topic+ks.test">ks.test</a></code>).</p>


<h3>Value</h3>

<p>The function returns a list of two items
</p>
<table>
<tr><td><code>D</code></td>
<td>
<p>the Kolomogorov-Smirnov distance</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>the frequency (in KHz) where the Kolmogorov-Smirnov distance was found</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There is no p-value associated to the K-S distance.<br />
If no frequency is provided, only the distance D.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, improved by Laurent Lellouch</p>


<h3>See Also</h3>

<p><code><a href="#topic+kl.dist">kl.dist</a></code>, <code><a href="#topic+simspec">simspec</a></code>,
<code><a href="#topic+diffspec">diffspec</a></code>, <code><a href="#topic+logspec.dist">logspec.dist</a></code>, <code><a href="#topic+diffcumspec">diffcumspec</a></code>, <code><a href="#topic+itakura.dist">itakura.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Comparison of two spectra and plot of the cumulated spectra with the K-S distance
data(tico)
tico1 &lt;- spec(tico, at=0.65, plot=FALSE)
tico2 &lt;- spec(tico, at=1.1, plot=FALSE)
ks.dist(tico1, tico2, plot=TRUE)
## mel scale
require(tuneR)
data(orni)
orni.mel &lt;- melfcc(orni, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
orni.mel.mean &lt;- apply(orni.mel$aspectrum, MARGIN=2, FUN=mean)
tico.mel &lt;- melfcc(tico, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
tico.mel.mean &lt;- apply(tico.mel$aspectrum, MARGIN=2, FUN=mean)
ks.dist(orni.mel.mean, tico.mel.mean, f=22050, mel=TRUE, plot=TRUE)
</code></pre>

<hr>
<h2 id='lfs'>Linear Frequency Shift</h2><span id='topic+lfs'></span>

<h3>Description</h3>

<p>This function linearly shifts all the frequency content of a time wave. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfs(wave, f, channel = 1, shift, wl = 1024, ovlp = 75,
wn = "hanning", fftw = FALSE, output = "matrix")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfs_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="lfs_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="lfs_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="lfs_+3A_shift">shift</code></td>
<td>
<p>positive or negative frequency shift to apply (in Hz).</p>
</td></tr>
<tr><td><code id="lfs_+3A_wl">wl</code></td>
<td>
<p>window length for the analysis (even number of points, by
default = 1024).</p>
</td></tr>
<tr><td><code id="lfs_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between successive FFT windows (in %, by default 75%).</p>
</td></tr>
<tr><td><code id="lfs_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default
<code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="lfs_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code>. See Notes of the <code>spectro</code>.</p>
</td></tr>
<tr><td><code id="lfs_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>,
<code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A short-term Fourier transform is first applied to the signal
(see <code><a href="#topic+spectro">spectro</a></code>), then the frequency shift is applied and the new
signal is eventually generated using the reverse of the Fourier Transform
(<code><a href="#topic+istft">istft</a></code>).<br />
There is therefore neither temporal modifications nor 
amplitude modifications.
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a> and 
Thierry Aubin <a href="mailto:thierry.aubin@u-psud.fr">thierry.aubin@u-psud.fr</a></p>


<h3>References</h3>

<p>Hopp, S. L., Owren, M. J. and Evans, C. S. (Eds) 1998. <em>Animal acoustic 
communication</em>. Springer, Berlin, Heidelberg.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffilter">ffilter</a></code>, <code><a href="#topic+spectro">spectro</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orni)
a&lt;-lfs(orni,f=22050,shift=1000)
spectro(a,f=22050)
# to be compared with the original signal
spectro(orni,f=22050)
</code></pre>

<hr>
<h2 id='listen'>Play a sound wave</h2><span id='topic+listen'></span>

<h3>Description</h3>

<p>Play a sound wave</p>


<h3>Usage</h3>

<pre><code class='language-R'>listen(wave, f, channel=1, from = NULL, to = NULL, choose = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listen_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="listen_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="listen_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="listen_+3A_from">from</code></td>
<td>
<p>start of play (in s).</p>
</td></tr>
<tr><td><code id="listen_+3A_to">to</code></td>
<td>
<p>end of play (in s).</p>
</td></tr>
<tr><td><code id="listen_+3A_choose">choose</code></td>
<td>
<p>logical, if <code>TRUE</code> start (=<code>from</code>) and end (=<code>to</code>)
points can be graphically chosen with a cursor on the oscillogram.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is based on <code><a href="tuneR.html#topic+play">play</a></code> but allows to read
one-colum matrix, data.frame, time-series and Sample objects.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a> but the original
<code><a href="tuneR.html#topic+play">play</a></code> function is by Uwe Ligges (package <span class="pkg">tuneR</span>).</p>


<h3>See Also</h3>

<p><code><a href="tuneR.html#topic+play">play</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOT RUN
# data(tico)
# listen(tico,f=22050)
# listen(tico,f=22050,from=0.5,to=1.5)
# listen(noise(d=1,f=8000,Wave=TRUE))
## change f to play the sound a different speed
# data(sheep)
## normal
# listen(sheep,f=8000)
## two times faster
# listen(sheep,f=8000*2)
## two times slower
# listen(sheep,f=8000/2)
</code></pre>

<hr>
<h2 id='localpeaks'>Local maximum frequency peak detection</h2><span id='topic+localpeaks'></span>

<h3>Description</h3>

<p>This functions searches for local peaks of a frequency spectrum</p>


<h3>Usage</h3>

<pre><code class='language-R'>localpeaks(spec, f = NULL, bands = 10, mel = FALSE, plot = TRUE,
xlab = NULL, ylab = "Amplitude", labels = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localpeaks_+3A_spec">spec</code></td>
<td>
<p>a data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code>. Can be in dB.</p>
</td></tr>
<tr><td><code id="localpeaks_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>spec</code> (in Hz). Not requested if
the first column of <code>spec</code> contains the frequency axis.</p>
</td></tr>
<tr><td><code id="localpeaks_+3A_bands">bands</code></td>
<td>
<p>a numeric vector. If vector of length 1, then sets the
number of bands dividing in equal parts the spectrum. If of length &gt; 1,
then takes the values as kHz limits of the bands dividing the spectrum. These
bands can be of different size. See details and examples.</p>
</td></tr>
<tr><td><code id="localpeaks_+3A_mel">mel</code></td>
<td>
<p>a logical, if <code>TRUE</code> the (htk-)mel scale is used.</p>
</td></tr>
<tr><td><code id="localpeaks_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code>, a plot showing the peaks is
returned.</p>
</td></tr>
<tr><td><code id="localpeaks_+3A_xlab">xlab</code></td>
<td>
<p>label of the x-axis.</p>
</td></tr>
<tr><td><code id="localpeaks_+3A_ylab">ylab</code></td>
<td>
<p>label of the y-axis.</p>
</td></tr>
<tr><td><code id="localpeaks_+3A_labels">labels</code></td>
<td>
<p>logical, if <code>TRUE</code> peak labels are plotted.</p>
</td></tr>
<tr><td><code id="localpeaks_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function proceed as follows
</p>

<ul>
<li><p> divides the spectrum in bands. The limits of the bands are set
with the argument <code>bands</code>. There are two options:
</p>

<ul>
<li><p> you set a number of bands with equal size by giving a single
value to <code>bands</code>. For instance, setting <code>bands</code> to a value
of 10 will slice the spectrum in 10 equal parts and return 10 local
peaks.
</p>
</li>
<li><p> you set the limits of the bands. This is achieve by giving a
numeric vector to <code>bands</code>. The limits can follow a regular or
irregular series. For instance attributing the vector c(0,2,4,8) will
generate the following bands [0,2[, [2,4[, [4,8] kHz. Be aware that
the last value should not exceed half the sampling frequency used to
obtain the spectrum <code>spec</code>.
</p>
</li></ul>

</li>
<li><p> uses the function <code><a href="#topic+fpeaks">fpeaks</a></code> with the argument
<code>nmax</code> set to 1.
</p>
</li></ul>



<h3>Value</h3>

<p>A two-column matrix, the first column corresponding to the
frequency values (x-axis) and the second column corresponding to the
amplitude values (y-axis) of the peaks.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+fpeaks">fpeaks</a></code>, <code><a href="#topic+meanspec">meanspec</a></code>, <code><a href="#topic+spec">spec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sheep)
spec &lt;- meanspec(sheep, f=8000)
# a specific number of bands with all the same size
localpeaks(spec, bands=5)
# bands directly specified  with a regular sequence
localpeaks(spec, bands=seq(0,8/2,by=0.5))
# bands directly specified  with an irregular sequence
localpeaks(spec, bands=c(0,0.5,1,1.5,3,4))
# Amaj octave bands, note that there is no peak detection
# in the higher part of the spectrum as sequence stops at 3520 Hz
localpeaks(spec, bands=octaves(440, below=3, above=3)/1000)
# melscale
require(tuneR)
mel &lt;- melfcc(sheep, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
melspec.mean &lt;- apply(mel$aspectrum, MARGIN=2, FUN=mean)
melspec.mean &lt;- melspec.mean/max(melspec.mean) # [0,1] scaling 
localpeaks(melspec.mean, f=8000, bands=8)
</code></pre>

<hr>
<h2 id='logspec.dist'>Log-spectral distance</h2><span id='topic+logspec.dist'></span>

<h3>Description</h3>

<p>Compare two distributions (e.g. two frequency spectra) by
computing the log-spectral distance</p>


<h3>Usage</h3>

<pre><code class='language-R'>logspec.dist(spec1, spec2, scale=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logspec.dist_+3A_spec1">spec1</code></td>
<td>
<p>any distribution, especially a spectrum obtained with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This can be either a two-column matrix (col1 = frequency, col2 = amplitude) or a vector (amplitude).</p>
</td></tr>
<tr><td><code id="logspec.dist_+3A_spec2">spec2</code></td>
<td>
<p>any distribution, especially a spectrum obtained with
<code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This can be
either a two-column matrix (col1 = frequency, col2 = amplitude) or a
vector (amplitude).</p>
</td></tr>
<tr><td><code id="logspec.dist_+3A_scale">scale</code></td>
<td>
<p>a logical, if <code>TRUE</code> the distance is scaled by dividing by
the square-root of the length of <code>spec1</code> (or
<code>spec2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance is computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">D_{LS}(spec1 \Vert spec2) = D_{LS}(spec2 \Vert spec1) = \sqrt{\sum{10
  \times log_{10}(\frac{spec1}{spec2})^{2}}}</code>
</p>
 <p><br />
If <code>scale = TRUE</code> the distance is divided by the length of <code>spec1</code>
(or <code>spec2</code>).
</p>


<h3>Value</h3>

<p>A numeric vector of length 1 returning the D distance.</p>


<h3>Note</h3>

<p>The function works for both Hz and (htk-)mel scales.</p>


<h3>Note</h3>

<p>The distance is symmetric.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, improved by Laurent Lellouch</p>


<h3>See Also</h3>

<p><code><a href="#topic+ks.dist">ks.dist</a></code>, <code><a href="#topic+kl.dist">kl.dist</a></code>,
<code><a href="#topic+itakura.dist">itakura.dist</a></code>, <code><a href="#topic+simspec">simspec</a></code>, <code><a href="#topic+diffspec">diffspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Comparison of two spectra
data(tico)
tico1 &lt;- spec(tico, at=0.65, plot=FALSE)
tico2 &lt;- spec(tico, at=1.1, plot=FALSE)
logspec.dist(tico1, tico2)
logspec.dist(tico1, tico2, scale=TRUE)
</code></pre>

<hr>
<h2 id='lts'>Long-term spectrogram</h2><span id='topic+lts'></span>

<h3>Description</h3>

<p>A spectrogram computed over several survey files obtained
with a Wildlife Acoustics SongMeter recorder</p>


<h3>Usage</h3>

<pre><code class='language-R'>lts(dir, f, wl = 512,
wn = "hanning", ovlp = 0, rmoffset = TRUE, FUN = mean, col = spectro.colors(30),
fftw = FALSE, norm = FALSE, verbose = TRUE,
tlab = "Time", ntann = NULL, flab = "Frequency (kHz)",
recorder = c("songmeter", "audiomoth"), plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lts_+3A_dir">dir</code></td>
<td>
<p>a character vector, the path to the directory where the
.wav files are stored or directly the names of the .wav files to be processed.</p>
</td></tr>
<tr><td><code id="lts_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in the .wav files contained in <code>dir</code>.</p>
</td></tr>  
<tr><td><code id="lts_+3A_wl">wl</code></td>
<td>
<p>window length for the analysis
(even number of points) (by default = 512).</p>
</td></tr>
<tr><td><code id="lts_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default
<code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="lts_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in %).</p>
</td></tr>
<tr><td><code id="lts_+3A_rmoffset">rmoffset</code></td>
<td>
<p>a logical to sepcify whether DC offset should be
removed. By default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lts_+3A_fun">FUN</code></td>
<td>
<p>the function to apply to compute the successive frequency spectra, by
default <code>mean</code> for a mean spectrum but could be other as
<code>median</code> or <code>var</code> for a median spectrum or variance spectrum.</p>
</td></tr>
<tr><td><code id="lts_+3A_col">col</code></td>
<td>
<p>a list of colors or the color palette with a number of colors</p>
</td></tr>
<tr><td><code id="lts_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code>. See Notes.</p>
</td></tr>
<tr><td><code id="lts_+3A_norm">norm</code></td>
<td>
<p>a logical, to specify if each mean
spectrum should be normalised between 0 and 1 (default <code>FALSE</code>)
before to concatenate the image.</p>
</td></tr>
<tr><td><code id="lts_+3A_verbose">verbose</code></td>
<td>
<p>a logical, if <code>TRUE</code> (default) the file number and name
processed are displayed in the console.</p>
</td></tr>
<tr><td><code id="lts_+3A_tlab">tlab</code></td>
<td>
<p>label of the time axis.</p>
</td></tr>
<tr><td><code id="lts_+3A_ntann">ntann</code></td>
<td>
<p>a numeric of length 1, the number of axis annotations (all
annotations by default).</p>
</td></tr>
<tr><td><code id="lts_+3A_flab">flab</code></td>
<td>
<p>label of the frequency axis.</p>
</td></tr>
<tr><td><code id="lts_+3A_recorder">recorder</code></td>
<td>
<p>the type of automatic recorder used, either a Wildlife
SongMeter or a Open Audio deveices Audiomoth.</p>
</td></tr>
<tr><td><code id="lts_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the spectrogram
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="lts_+3A_...">...</code></td>
<td>
<p>other <code><a href="Matrix.html#topic+image">image</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads each .wav file and computes its mean spectrum with
<code><a href="#topic+meanspec">meanspec</a></code>. The successive mean spectra are then
concatenated into a single image with the function
<code><a href="Matrix.html#topic+image">image</a></code>.
The parameters <code>wl</code>, <code>ovlp</code>, and <code>wn</code> are those of the
function <code><a href="#topic+meanspec">meanspec</a></code>.
</p>


<h3>Value</h3>

<p>This function returns a list of three items:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>a numeric vector corresponding to the time axis.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>a numeric vector corresponding to the frequency axis.</p>
</td></tr>
<tr><td><code>amp</code></td>
<td>
<p>a numeric or a complex matrix corresponding to the amplitude values.
Each column is a Fourier transform of length <code>wl/2</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectro">spectro</a></code>, <code><a href="#topic+meanspec">meanspec</a></code>,
<code><a href="Matrix.html#topic+image">image</a></code>,
<code><a href="#topic+spectro3D">spectro3D</a></code>, <code><a href="#topic+ggspectro">ggspectro</a></code>,
<code><a href="#topic+songmeter">songmeter</a></code>, <code><a href="#topic+audiomoth">audiomoth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## if 'dir' contains a set of files recorded with a Wildlife Acoustics
# songmeter recorder then a direct way to obtain
# the spectrogram of all .wav files is
dir &lt;- "pathway-to-directory-containing-wav-files"
lts(dir)
# to normalise each mean spectrum
lts(dir, norm=TRUE)
# to change the STFT parameters used to obtain each mean spectrum
lts(dir, wl=1024, wn="hamming", ovlp=50)
# to change the colors and the number of time labels and to make it quiet
lts(dir, col=cm.colors(20), ntann=10, verbose=FALSE)
## direct use of files names stored in the working directory
files &lt;- c("S4A09154_20190213_150000.wav", "S4A09154_20190213_153000.wav",
"S4A09154_20190213_160000.wav", "S4A09154_20190213_163000.wav",
"S4A09154_20190213_170000.wav", "S4A09154_20190213_173000.wav",
"S4A09154_20190213_180000.wav", "S4A09154_20190213_183000.wav",
"S4A09154_20190213_190000.wav", "S4A09154_20190213_193000.wav")
lts(files)

## End(Not run)
</code></pre>

<hr>
<h2 id='M'>Median of the amplitude envelope</h2><span id='topic+M'></span>

<h3>Description</h3>

<p>This function computes an acoustic index based on the median of the amplitude envelope.</p>


<h3>Usage</h3>

<pre><code class='language-R'>M(wave, f, channel = 1, envt = "hil", plot = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M_+3A_wave">wave</code></td>
<td>
<p>an <code>R</code> object.</p>
</td></tr>
<tr><td><code id="M_+3A_f">f</code></td>
<td>
<p>sampling frequency of wave (in Hz). Does not need to be
specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="M_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="M_+3A_envt">envt</code></td>
<td>
<p>the type of envelope to be used: either <code>"abs"</code> for absolute amplitude envelope or <code>"hil"</code> for Hilbert amplitude envelope. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="M_+3A_plot">plot</code></td>
<td>
<p>logical, if TRUE returns a plot of the amplitude envelope of wave (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="M_+3A_...">...</code></td>
<td>
<p>other env parameters, in particular smoothing parameters. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This amplitude index M is computed according to:
</p>
<p style="text-align: center;"><code class="reqn">M = \bar{A}(t) \times 2^{1-depth}</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">0 \leq M \leq 1</code>
</p>

<p>where A(t) is the amplitude envelope and depth is the signal
digitization depth in number of bits.
</p>


<h3>Value</h3>

<p>A numeric vector of length 1 between 0 and 1, without unit.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur and Marion Depraetere</p>


<h3>References</h3>

<p>Depraetere M, Pavoine S, Jiguet F, Gasc A, Duvail S, Sueur J (2012) Monitoring animal diversity
using acoustic indices: implementation in a temperate woodland. <em>Ecological Indicators</em>, <b>13</b>, 46-54.</p>


<h3>See Also</h3>

<p><code><a href="#topic+env">env</a></code>, <code><a href="#topic+AR">AR</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
M(tico)
# smoothing the amplitude may change slightly the result
M(tico, msmooth=c(500,50), plot=TRUE)
</code></pre>

<hr>
<h2 id='meandB'>Mean of dB values</h2><span id='topic+meandB'></span>

<h3>Description</h3>

<p>This function calculates the mean of dB values</p>


<h3>Usage</h3>

<pre><code class='language-R'>meandB(x, level="IL")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meandB_+3A_x">x</code></td>
<td>
<p>a numeric vector or a numeric matrix.</p>
</td></tr>
<tr><td><code id="meandB_+3A_level">level</code></td>
<td>
<p>intensity level (<code>"IL"</code>) or sound pressure level (<code>"SPL"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean of dB values is not linear. See examples.</p>


<h3>Value</h3>

<p>A numeric vector of length 1 is returned.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur and Zev Ross</p>


<h3>References</h3>

<p>Hartmann, W. M. 1998 <em>Signals, sound and sensation</em>. New York: Springer.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sddB">sddB</a></code>, <code><a href="#topic+moredB">moredB</a></code>, <code><a href="#topic+convSPL">convSPL</a></code>, <code><a href="#topic+dBweight">dBweight</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>meandB(c(89,90,95))
</code></pre>

<hr>
<h2 id='meanspec'>Mean frequency spectrum of a time wave</h2><span id='topic+meanspec'></span>

<h3>Description</h3>

<p>This function returns the mean frequency spectrum (i.e. the mean relative amplitude of the
frequency distribution) of a time wave. Results can be expressed either in absolute 
or dB data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanspec(wave, f, channel = 1, wl = 512, wn = "hanning", ovlp = 0, fftw = FALSE,
norm = TRUE, PSD = FALSE, PMF = FALSE, FUN = mean, correction = "none", dB = NULL,
dBref = NULL, from = NULL, to = NULL, identify = FALSE,
col = "black", cex = 1, plot = 1, flab = "Frequency (kHz)",
alab = "Amplitude", flim = NULL, alim = NULL, type ="l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanspec_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="meanspec_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="meanspec_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="meanspec_+3A_wl">wl</code></td>
<td>
<p>length of the window for the analysis (even number of points, by default = 512).</p>
</td></tr>
<tr><td><code id="meanspec_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="meanspec_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive analysis windows (in %).</p>
</td></tr>
<tr><td><code id="meanspec_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code>. See Notes of <code>spectro</code>.</p>
</td></tr>
<tr><td><code id="meanspec_+3A_norm">norm</code></td>
<td>
<p>if <code>TRUE</code> the mean spectrum is normalised (i. e. scaled) by  its maximum.</p>
</td></tr>
<tr><td><code id="meanspec_+3A_psd">PSD</code></td>
<td>
<p>if <code>TRUE</code> return Power Spectra Density,
<em>i. e.</em> the square of the spectra.</p>
</td></tr>   
<tr><td><code id="meanspec_+3A_pmf">PMF</code></td>
<td>
<p>if <code>TRUE</code> return Probability Mass Function,
<em>i. e.</em> the probability distribution of frequencie.</p>
</td></tr>
<tr><td><code id="meanspec_+3A_fun">FUN</code></td>
<td>
<p>the function to apply on the rows of the STFT matrix, by
default <code>mean</code> for a mean spectrum but could be other as
<code>median</code> or <code>var</code> for a median spectrum or variance spectrum.</p>
</td></tr>
<tr><td><code id="meanspec_+3A_correction">correction</code></td>
<td>
<p>a character vector of length 1 to apply an
amplitude (&quot;amplitude&quot;) or an energy (&quot;energy&quot;) correction
to the FT window. This argument is useful only when one wish to obtain
absolute values that is when <code>norm=FALSE</code> and <code>PMF=FALSE</code>.
By default no correction is applied (&quot;none&quot;).</p>
</td></tr>    
<tr><td><code id="meanspec_+3A_db">dB</code></td>
<td>
<p>a character string specifying the type dB to return: &quot;max0&quot; for a
maximum dB value at 0, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, and &quot;ITU&quot; for common dB weights.</p>
</td></tr>
<tr><td><code id="meanspec_+3A_dbref">dBref</code></td>
<td>
<p>a dB reference value when <code>dB</code> is not <code>NULL</code>. <code>NULL</code> by default
but should be set to 2*10e-5 for a 20 microPa reference (SPL).</p>
</td></tr>
<tr><td><code id="meanspec_+3A_from">from</code></td>
<td>
<p>start mark where to compute the spectrum (in s).</p>
</td></tr>
<tr><td><code id="meanspec_+3A_to">to</code></td>
<td>
<p>end mark where to compute the spectrum (in s).</p>
</td></tr>
<tr><td><code id="meanspec_+3A_identify">identify</code></td>
<td>
<p>to identify frequency and amplitude values on the plot
with the help of a cursor.</p>
</td></tr>
<tr><td><code id="meanspec_+3A_col">col</code></td>
<td>
<p>colour of the spectrum.</p>
</td></tr>
<tr><td><code id="meanspec_+3A_cex">cex</code></td>
<td>
<p>pitch size.</p>
</td></tr>
<tr><td><code id="meanspec_+3A_plot">plot</code></td>
<td>
<p>if <code>1</code> returns frequency on x-axis, if <code>2</code> returns 
frequency on y-axis, (by default <code>1</code>).</p>
</td></tr>
<tr><td><code id="meanspec_+3A_flab">flab</code></td>
<td>
<p>title of the frequency axis.</p>
</td></tr>
<tr><td><code id="meanspec_+3A_alab">alab</code></td>
<td>
<p>title of the amplitude axis.</p>
</td></tr>
<tr><td><code id="meanspec_+3A_flim">flim</code></td>
<td>
<p>range of frequency axis (in kHz).</p>
</td></tr>
<tr><td><code id="meanspec_+3A_alim">alim</code></td>
<td>
<p>range of amplitude axis.</p>
</td></tr>
<tr><td><code id="meanspec_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="meanspec_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples of <code><a href="#topic+spec">spec</a></code>. This function is based on <code><a href="stats.html#topic+fft">fft</a></code>.
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, <code>meanspec</code> returns  a two columns matrix,
the first column corresponding to the frequency axis, the second column
corresponding to the amplitude axis.<br /> 
If <code>identify</code> is <code>TRUE</code>, <code>spec</code> returns a list with
two elements:<br /> 
</p>
<table>
<tr><td><code>freq</code></td>
<td>
<p>the frequency of the points chosen on the spectrum</p>
</td></tr></table>
<p><br /> 
</p>
<table>
<tr><td><code>amp</code></td>
<td>
<p>the relative amplitude of the points chosen on the spectrum</p>
</td></tr></table>
<p><br /> 
</p>


<h3>Warning</h3>

<p>The argument <code>peaks</code> is no more available
(version &gt; 1.5.6). See the function <code><a href="#topic+fpeaks">fpeaks</a></code>
for peak(s) detection.</p>


<h3>Note</h3>

<p>The argument <code>fftw</code> can be used to try to speed up process
time. When set to <code>TRUE</code>, the Fourier transform is computed
through the function <code>FFT</code> of the package <code>fftw</code>. This package is a
wrapper around the fastest Fourier transform of the free C subroutine
library FFTW (<a href="http://www.fftw.org/">http://www.fftw.org/</a>). FFT should be then installed on your OS.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+spec">spec</a></code>,<code><a href="#topic+fpeaks">fpeaks</a></code>,
<code><a href="#topic+localpeaks">localpeaks</a></code>, <code><a href="#topic+dynspec">dynspec</a></code>, 
<code><a href="#topic+corspec">corspec</a></code>, <code><a href="#topic+diffspec">diffspec</a></code>, <code><a href="#topic+simspec">simspec</a></code>, <code><a href="stats.html#topic+fft">fft</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orni)
# compute the mean spectrum of the whole time wave
meanspec(orni,f=22050)
# compute the mean spectrum of a time wave section (from 0.32 s to 0.39 s)
meanspec(orni,f=22050,from=0.32,to=0.39)
# different window lengths
op&lt;-par(mfrow=c(3,1))
meanspec(orni,f=22050,wl=256)
title("wl=256")
meanspec(orni,f=22050,wl=1024)
title("wl=1024")
meanspec(orni,f=22050,wl=4096)
title("wl=4096")
par(op)
# different overlap values (almost no effects here...)
op&lt;-par(mfrow=c(3,1))
meanspec(orni,f=22050)
title("ovlp=0")
meanspec(orni,f=22050,ovlp=50)
title("ovlp=50")
meanspec(orni,f=22050,ovlp=95)
title("ovlp=95")
par(op)
# use of flim to zoom in
op&lt;-par(mfrow=c(2,1))
meanspec(orni,f=22050)
title("zoom in")
meanspec(orni,f=22050,wl=512,flim=c(4,6))
par(op)
# comparaison of spectrum and mean spectrum
op&lt;-par(mfrow=c(2,1))
spec(orni,f=22050)
title("spec()")
meanspec(orni,f=22050)
title("meanspec()")
par(op)
# log scale on frequency axis
meanspec(orni, f=22050, log="x")
# median spectrum
meanspec(orni,f=22050, FUN=median)
# variance spectrum
meanspec(orni,f=22050, FUN=var)
</code></pre>

<hr>
<h2 id='mel'>Hertz / Mel conversion</h2><span id='topic+mel'></span>

<h3>Description</h3>

<p>This function converts Hertz data in Mel data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mel(x, inverse = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mel_+3A_x">x</code></td>
<td>
<p>a value in Hertz (or in Mel if <code>inverse</code> is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="mel_+3A_inverse">inverse</code></td>
<td>
<p>logical, if <code>TRUE</code> converts the Mel data in Hertz data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hertz to mel conversion is computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">m = 1127.01048 \times {\log{(1+(\frac{f}{700}))}}</code>
</p>

<p>with <em>m</em> in Mel and <em>f</em> in Hertz.
</p>
<p>Mel to Hertz conversion (when <code>inverse</code> is <code>TRUE</code>) 
is therefore computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">f = 700 \times{(e^{\frac{m}{1127.01048}}-1)}</code>
</p>

<p>with <em>f</em> in Hertz and <em>m</em> in Mel.
</p>


<h3>Value</h3>

<p>A corresponding <b>R</b> object is returned.</p>


<h3>Note</h3>

<p>The Mel scale is a perceptual scale of pitches judged by listeners
to be equal in distance from one another. The name Mel comes from the word
melody to indicate that the scale is based on pitch comparisons. The reference
point between this scale and normal frequency measurement is defined by
equating a 1000 Hz tone, 40 dB above the listener's threshold,
with a pitch of 1000 mels. 
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Stevens, S. S., Volkman, J. and Newman, E. B. 1937.
A scale for the measurement of psychological magnitude pitch.
<em>Journal of the Acoustical Society of America</em>, 8: 185-190.</p>


<h3>See Also</h3>

<p><code><a href="#topic+melfilterbank">melfilterbank</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-seq(0,10000,by=50)
y&lt;-mel(x)
plot(x,y,type="l",xlab = "f (hertz)", ylab = "f (mel)",
  main = "Mel scale", col="red")
</code></pre>

<hr>
<h2 id='melfilterbank'>Mel-filter bank for MFCC computation</h2><span id='topic+melfilterbank'></span>

<h3>Description</h3>

<p>This functions returns graphically and numerically the
Mel-filters used to compute MFCC.</p>


<h3>Usage</h3>

<pre><code class='language-R'>melfilterbank(f = 44100, wl = 1024,
minfreq = 0, maxfreq = f/2, m = 20,
palette, alpha = 0.5, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melfilterbank_+3A_f">f</code></td>
<td>
<p>sammpling frequency (in Hz).</p>
</td></tr>
<tr><td><code id="melfilterbank_+3A_wl">wl</code></td>
<td>
<p>the Fourier window length (in number of samples).</p>
</td></tr>
<tr><td><code id="melfilterbank_+3A_minfreq">minfreq</code></td>
<td>
<p>the minimum (or lower) frequency of the filter bank (in
Hz).</p>
</td></tr>
<tr><td><code id="melfilterbank_+3A_maxfreq">maxfreq</code></td>
<td>
<p>the maximum (or upper) frequency of the filter bank (in Hz).</p>
</td></tr>
<tr><td><code id="melfilterbank_+3A_m">m</code></td>
<td>
<p>the total number of filters.</p>
</td></tr>
<tr><td><code id="melfilterbank_+3A_palette">palette</code></td>
<td>
<p>an optional colour palette if <code>plot</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="melfilterbank_+3A_alpha">alpha</code></td>
<td>
<p>alpha-transparency when a colour palette is used.</p>
</td></tr>
<tr><td><code id="melfilterbank_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> all filters are displayed in a single plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 items:
</p>
<table>
<tr><td><code>central.freq</code></td>
<td>
<p>the kHz central frequencies of the filters,</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>the kHz frequency scale,</p>
</td></tr>
<tr><td><code>amp</code></td>
<td>
<p>the amplitude of the filters, scaled between 0 and 1.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>These triangular filters are used for computing MFCCs.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Sharan RV &amp; Moir TJ (2016) Applications and advancements in
automatic sound recognition. <em>Neurocomputing</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+mel">mel</a></code>, <code><a href="#topic+gammatone">gammatone</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## default values
melfilterbank(plot=TRUE)
## with color surfaces
melfilterbank(palette=cm.colors, plot=TRUE)
## values changed
res &lt;- melfilterbank(f=16000, wl=512, minfreq=300, plot=TRUE)
## plot the 1st filter only
plot(res$freq, res$amp[,1], type="l", xlab="Frequency (kHz)", ylab="Amplitude")
## plot the last filter only
plot(res$freq, res$amp[,ncol(res$amp)], type="l", xlab="Frequency (kHz)", ylab="Amplitude")
## get the kHz central frequencies of the succesive filters
res$central.freq
</code></pre>

<hr>
<h2 id='micsens'>Microphone sensitivity and conversion</h2><span id='topic+micsens'></span>

<h3>Description</h3>

<p>This function converts microphone sensitivity from mV/Pa to dB. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>micsens(x, sref = 1, inverse = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="micsens_+3A_x">x</code></td>
<td>
<p>a measured sensitivity in mV/Pa (or in dB if <code>inverse</code> is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="micsens_+3A_sref">sref</code></td>
<td>
<p>the sensitivity reference (by default equals to 1 V/Pa)</p>
</td></tr>
<tr><td><code id="micsens_+3A_inverse">inverse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the inverse conversion from dB
to mV/Pa is computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sensitivity <em>S</em> in dB is calculated according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">S_{dB} = 20 \times log_{10}(\frac{s}{s_{ref}})</code>
</p>
<p> with <em>s</em> the measured sensitivity in mv/Pa 
and <em>sref</em> the reference sensitivity (by default 1 mV/Pa).
</p>


<h3>Value</h3>

<p>A numeric value in dB <em>re</em> 1V/Pa with default settings,
in mV/Pa if <code>inverse</code> is set to <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+convSPL">convSPL</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># conversion of a sensitivity of 2 mV/Pa
micsens(2)
# conversion of a sensitivity of -54 dB re 1V/Pa
micsens(-54,inverse=TRUE)
</code></pre>

<hr>
<h2 id='moredB'>Addition of dB values</h2><span id='topic+moredB'></span>

<h3>Description</h3>

<p>This functions calculates the sum of dB values</p>


<h3>Usage</h3>

<pre><code class='language-R'>moredB(x, level="IL")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moredB_+3A_x">x</code></td>
<td>
<p>a numeric vector or numeric matrix.</p>
</td></tr>
<tr><td><code id="moredB_+3A_level">level</code></td>
<td>
<p>intensity level (<code>"IL"</code>) or sound pressure level (<code>"SPL"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The addition of dB values is not linear. See examples.</p>


<h3>Value</h3>

<p>A numeric vector of length 1.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Hartmann, W. M. 1998 <em>Signals, sound and sensation</em>. New York: Springer.</p>


<h3>See Also</h3>

<p><code>meandB</code>, <code>sddB</code>, <code><a href="#topic+convSPL">convSPL</a></code>, <code><a href="#topic+dBweight">dBweight</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># two sources of 60 dB give an intensity level of 63 dB
moredB(c(60,60))
# addition of three sources
moredB(c(89,90,95))
</code></pre>

<hr>
<h2 id='mutew'>Replace time wave data by 0 values</h2><span id='topic+mutew'></span>

<h3>Description</h3>

<p>This functions replaces a time wave or a section of a time wave by 0 values.
For a time wave describing a sound, this corresponds in muting the sound or a section of it. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutew(wave, f, channel = 1, from = NULL, to = NULL, choose = FALSE, plot = TRUE,
output = "matrix", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutew_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="mutew_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="mutew_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="mutew_+3A_from">from</code></td>
<td>
<p>start of the silence section (in s).</p>
</td></tr>
<tr><td><code id="mutew_+3A_to">to</code></td>
<td>
<p>end of the silence section (in s).</p>
</td></tr>
<tr><td><code id="mutew_+3A_choose">choose</code></td>
<td>
<p>logical, if <code>TRUE</code> start (=<code>from</code>) and end (=<code>to</code>)
points can be graphically chosen with a cursor on the oscillogram.</p>
</td></tr>
<tr><td><code id="mutew_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic plot
of <code>wave</code> with the new silence section (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="mutew_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="mutew_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>from</code> and <code>from</code> are <code>NULL</code>,
this results in completely muting <code>wave</code>.  
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+addsilw">addsilw</a></code>, <code><a href="#topic+cutw">cutw</a></code>,
<code><a href="#topic+deletew">deletew</a></code>,<code><a href="#topic+fadew">fadew</a></code>, <code><a href="#topic+pastew">pastew</a></code>,
<code><a href="#topic+revw">revw</a></code>, <code><a href="#topic+zapsilw">zapsilw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
mutew(tico,f=22050,from=0.5,to=0.9)
</code></pre>

<hr>
<h2 id='NDSI'>Normalized Difference Soundscape Index</h2><span id='topic+NDSI'></span>

<h3>Description</h3>

<p>This function computes the Normalized Difference Soundscape
Index as described by Kasten et al. (2012).</p>


<h3>Usage</h3>

<pre><code class='language-R'>NDSI(x, anthropophony = 1, biophony = 2:8, max = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NDSI_+3A_x">x</code></td>
<td>
<p>a two-column numeric matrix computed with <code><a href="#topic+soundscapespec">soundscapespec</a></code>.</p>
</td></tr>
<tr><td><code id="NDSI_+3A_anthropophony">anthropophony</code></td>
<td>
<p>a numeric vector defining the frequency band(s) of
the anthropophony (in kHz).</p>
</td></tr>
<tr><td><code id="NDSI_+3A_biophony">biophony</code></td>
<td>
<p>a numeric vector defining the frequency band(s) of the
biophony (in kHz).</p>
</td></tr>
<tr><td><code id="NDSI_+3A_max">max</code></td>
<td>
<p>a logical, if <code>TRUE</code> then defines the biophony as the
maximum - not the sum - of the 2 and 8 kHz frequency bands</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NDSI aims at estimating the level of anthropogenic disturbance on the soundscape by
computing the ratio of human-generated (anthropophony) to biological
(biophony) acoustic components found in field collected sound
samples. In terms of frequency, the anthropophony is defined as the [1-2[
kHz frequency bin and the biophony as the [2-8[ kHz frequency bins of a
soundscape frequency spectrum (see <code><a href="#topic+soundscapespec">soundscapespec</a></code>). <br />
</p>
<p>NDSI is computed according to:
</p>
<p style="text-align: center;"><code class="reqn">NDSI = \frac{(biophony - anthropophony)}{(biophony + anthropophony)}</code>
</p>

<p><br />
NDSI varies between -1 and +1, where +1 indicates a signal containing
no anthropophony.
</p>


<h3>Value</h3>

<p>A numeric vector of length 1 giving the NDSI value.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Kasten, E.P., Gage, S.H., Fox, J. &amp; Joo, W. (2012). The remote
environmental assessment laboratory's acoustic library: an archive for
studying soundscape ecology. <em>Ecological Informatics</em>, 12, 50-67.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+soundscapespec">soundscapespec</a></code>, <code><a href="#topic+SAX">SAX</a></code>, <code><a href="#topic+NDSI">NDSI</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Note that 'tico' is not a soundscape recording...
data(tico)
spec &lt;- soundscapespec(tico, plot=FALSE)
NDSI(spec)
NDSI(spec, max=TRUE)
</code></pre>

<hr>
<h2 id='noisew'>Generate noise</h2><span id='topic+noisew'></span>

<h3>Description</h3>

<p>This function generates noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noisew(f, d, type="unif", listen = FALSE, output = "matrix")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noisew_+3A_f">f</code></td>
<td>
<p>sampling frequency of the signal to be generated (in Hz)</p>
</td></tr>
<tr><td><code id="noisew_+3A_d">d</code></td>
<td>
<p>duration of the signal to be generated.</p>
</td></tr>
<tr><td><code id="noisew_+3A_type">type</code></td>
<td>
<p>a character string to specify the type of noise, either &quot;unif&quot; or &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="noisew_+3A_listen">listen</code></td>
<td>
<p>if <code>TRUE</code> the new sound is played back.</p>
</td></tr>
<tr><td><code id="noisew_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uniform noise is generated using <code><a href="stats.html#topic+runif">runif</a></code> and gaussian noise is based on <code><a href="stats.html#topic+rnorm">rnorm</a></code> 
</p>


<h3>Value</h3>

<p>A new wave is returned. The class of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+synth">synth</a></code>, <code><a href="HH.html#topic+pulse">pulse</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># add noise to a synthetic signal
a&lt;-noisew(d=1,f=8000)
b&lt;-synth(f=8000,d=1,cf=2000,plot=FALSE)
c&lt;-a+b
spectro(c,f=8000)
</code></pre>

<hr>
<h2 id='notefreq'>Frequency of a muscical note</h2><span id='topic+notefreq'></span>

<h3>Description</h3>

<p>This function computes the frequency of a musical note
(Equal temperament)</p>


<h3>Usage</h3>

<pre><code class='language-R'>notefreq(note, ref = 440, octave = 3)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="notefreq_+3A_note">note</code></td>
<td>
<p>a numerical or a character vector. See <code>Note</code>.</p>
</td></tr>
<tr><td><code id="notefreq_+3A_ref">ref</code></td>
<td>
<p>a numerical vector of length 1 for the reference frequency.</p>
</td></tr>
<tr><td><code id="notefreq_+3A_octave">octave</code></td>
<td>
<p>a numerical vector of length for the octave number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The frequency is computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">f = ref \times 2 ^{octave - 3 + \frac{note-10}{12}}</code>
</p>

<p>with:<br />
<em>ref</em> = reference frequency, <br />
<em>octave</em> = octave number, and <br />
<em>note</em> = rank of the note along the scale.
</p>


<h3>Value</h3>

<p>The frequency in Hz is returned.</p>


<h3>Note</h3>

<p>The note can be given in two ways. The first solution is to give
the rank of the note along the scale (e.g. rank 10 for A) or to give its names in
characters with the following notation: C, D, E, F, G, A, B.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+octaves">octaves</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Some notes frequency (use apply-like functions when dealing with character strings)
sapply(c("C", "A", "Gb"), notefreq)

# C major scale plot
n &lt;- 1:12
freq &lt;- notefreq(n)
names &lt;- c("C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B") 
plot(n, freq, pch=19, cex=1.5,
     xlab = "Note name",
     ylab = "Frequency (Hz)",
     xaxt="n", las=1, main="Third octave")
axis(side=1, at=n, labels=names)
abline(h=freq, col="lightgrey")

# C major scale sound
f &lt;- 2000 # sampling rate
s &lt;- NULL
for (i in 1:length(freq))
  {
    tmp &lt;- synth(d=0.5, f=f, cf=freq[i])
    s &lt;- pastew(s, tmp, at="start", f)
  }
spectro(s, f, ovlp=75)
</code></pre>

<hr>
<h2 id='octaves'>Octave values</h2><span id='topic+octaves'></span>

<h3>Description</h3>

<p>This functions returns the frequency values of the octaves
below and above a specific frequency</p>


<h3>Usage</h3>

<pre><code class='language-R'>octaves(x, below = 3, above = 3)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="octaves_+3A_x">x</code></td>
<td>
<p>a numeric vector, frequency of the note in Hz or kHz.</p>
</td></tr>
<tr><td><code id="octaves_+3A_below">below</code></td>
<td>
<p>the number of octaves below <code>x</code>.</p>
</td></tr>
<tr><td><code id="octaves_+3A_above">above</code></td>
<td>
<p>the number of octaves above <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the octave series in frequency (Hz or kHz
depending on <code>x</code> unit).</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+notefreq">notefreq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>names &lt;- c("C","D","E","F","G","A","B")
values &lt;- c(261.63, 293.66, 329.64, 349.23, 392, 440, 493.88)
res &lt;- sapply(values, FUN=octaves)/1000
op &lt;- par(las=1,mfrow=c(2,1))
par(mar=c(0,4,1,1))
matplot(x=1:7, y=res, t="o", pch=names, xlab="",
    ylab="Frequency (kHz) [linear scale]", col=rainbow(7), xaxt="n")
par(mar=c(4.5,4,0,1))
matplot(x=1:7, y=res, t="o", pch=names, xlab="Octave",
    ylab="Frequency (kHz) [log scale]", col=rainbow(7), ylog=TRUE, log="y")
par(op)
</code></pre>

<hr>
<h2 id='orni'>Song of the cicada Cicada orni</h2><span id='topic+orni'></span>

<h3>Description</h3>

<p>Recording of a calling song section of the Mediterranean cicada 
<em>Cicada orni</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(orni)</code></pre>


<h3>Format</h3>

<p>A Wave object.</p>


<h3>Details</h3>

<p>Duration = 0.719 s. Sampling frequency = 22050 Hz.
</p>


<h3>Source</h3>

<p>Recording by Jerome Sueur.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orni)
oscillo(orni,f=22050)
</code></pre>

<hr>
<h2 id='oscillo'>Show a time wave as an oscillogram</h2><span id='topic+oscillo'></span>

<h3>Description</h3>

<p>This graphical function displays a time wave as an oscillogram in a single or 
multi-frame plot. The envelope of the wave can also be shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscillo(wave, f, channel = 1, from = NULL, to = NULL, fastdisp = FALSE,
scroll = NULL, zoom = FALSE, k=1, j=1, cex,
labels = TRUE,  tlab = "Time (s)", alab = "Amplitude",            
byrow = TRUE, identify = FALSE, nidentify = NULL, 
plot = TRUE, colwave = "black", 
coltitle = "black", cextitle = 1.2, fonttitle = 2,
collab = "black", cexlab = 1, fontlab = 1,
colline = "black",
colaxis = "black", cexaxis = 1, fontaxis = 1,
coly0 = "lightgrey",
tcl = 0.5, title = FALSE, xaxt="s", yaxt="n", type="l", bty = "l")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oscillo_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="oscillo_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="oscillo_+3A_from">from</code></td>
<td>
<p>start of the oscillogram (in s).</p>
</td></tr>
<tr><td><code id="oscillo_+3A_to">to</code></td>
<td>
<p>end of the oscillogram (in s).</p>
</td></tr>
<tr><td><code id="oscillo_+3A_fastdisp">fastdisp</code></td>
<td>
<p>faster graphic display for long <code>wave</code>. The
oscillogram is displayed/saved faster in the graphic device/
graphic file when set to <code>TRUE</code>, with a cost on graphic resolution.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_scroll">scroll</code></td>
<td>
<p>a numeric of length 1 allowing to move along the time wave using a slider panel.
This numeric corresponds to the number of successive windows dividing the time wave.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_zoom">zoom</code></td>
<td>
<p>time zoom in with start and end points chosen on the oscillogram with a cursor.</p>
</td></tr>  
<tr><td><code id="oscillo_+3A_k">k</code></td>
<td>
<p>number of horizontal sections (by default =1).</p>
</td></tr>
<tr><td><code id="oscillo_+3A_j">j</code></td>
<td>
<p>number of vertical sections (by default =1).</p>
</td></tr>
<tr><td><code id="oscillo_+3A_cex">cex</code></td>
<td>
<p>pitch size if <code>type = "p"</code>.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_labels">labels</code></td>
<td>
<p>if <code>TRUE</code> plots time and amplitude labels (by default <code>TRUE</code>).</p>
</td></tr>  
<tr><td><code id="oscillo_+3A_tlab">tlab</code></td>
<td>
<p>label of time axis.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_alab">alab</code></td>
<td>
<p>label of amplitude axis.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_byrow">byrow</code></td>
<td>
<p>logical, if <code>TRUE</code>, the sections are filled by
rows, otherwise the sections are filled by colmuns (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="oscillo_+3A_identify">identify</code></td>
<td>
<p>returns the time and amplitude coordinates of points chosen  with a cursor
on the oscillogram.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_nidentify">nidentify</code></td>
<td>
<p>a numeric vector of length 1, specifies the number of
points to identified on <code>wave</code> if <code>identify</code> is <code>TRUE</code>.</p>
</td></tr>  
<tr><td><code id="oscillo_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic or envelope plot
of <code>wave</code>(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="oscillo_+3A_colwave">colwave</code></td>
<td>
<p>colour of the oscillogram or of the envelope.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_coltitle">coltitle</code></td>
<td>
<p>if <code>title</code> is <code>TRUE</code>, colour of the title.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_cextitle">cextitle</code></td>
<td>
<p>character size for the title.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_fonttitle">fonttitle</code></td>
<td>
<p>font for the title.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_cexlab">cexlab</code></td>
<td>
<p>character size for axes labels.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_fontlab">fontlab</code></td>
<td>
<p>font for axes labels.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_collab">collab</code></td>
<td>
<p>colour of axes labels.</p>
</td></tr>  
<tr><td><code id="oscillo_+3A_colline">colline</code></td>
<td>
<p>colour of axes line.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_colaxis">colaxis</code></td>
<td>
<p>colour of the axis annotation.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_fontaxis">fontaxis</code></td>
<td>
<p>font of axis annotation.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_cexaxis">cexaxis</code></td>
<td>
<p>magnification for axis annotation.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_coly0">coly0</code></td>
<td>
<p>colour of the y=0 line.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_tcl">tcl</code></td>
<td>
<p>length of tick marks.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_title">title</code></td>
<td>
<p><code>TRUE</code> to add a title
with information on <code>wave</code> duration and <code>f</code>,
<code>FALSE</code> to live it blank,
or a character string to add any desired title.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_xaxt">xaxt</code></td>
<td>
<p>equivalent to <code>xaxt</code> of <code><a href="graphics.html#topic+par">par</a></code> (by default =<code>"s"</code>).</p>
</td></tr>    
<tr><td><code id="oscillo_+3A_yaxt">yaxt</code></td>
<td>
<p>equivalent to <code>yaxt</code> of <code><a href="graphics.html#topic+par">par</a></code> (by default
=<code>"n"</code>).</p>
</td></tr>  
<tr><td><code id="oscillo_+3A_type">type</code></td>
<td>
<p>type of plot, by default <code>"l"</code>. Use <code>"n"</code> for no
plot.</p>
</td></tr>
<tr><td><code id="oscillo_+3A_bty">bty</code></td>
<td>
<p>the type of box to be drawn around the oscillogram.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Data are returned as one-column matrix if <code>plot</code> is <code>FALSE</code>.
<code>identify</code> returns a two-column matrix with the time and
amplitude coordinates of points successively chosen on the oscillogram. 
</p>


<h3>Note</h3>

<p><code>zoom</code> is similar to but more visual than <code>from</code> and/or <code>to</code>.
<code>zoom</code> and <code>identify</code> do work with a single-frame window only
(<em>i. e.</em> with <code>k</code> = 1 and <code>j</code> = 1).<br />
Press &lsquo;Stop&rsquo; button of the tools bar after choosing the appropriate
points on the oscillogram.<br />
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a> and 
Caroline Simonis <a href="mailto:csimonis@mnhn.fr">csimonis@mnhn.fr</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dynoscillo">dynoscillo</a></code>, <code><a href="#topic+oscilloST">oscilloST</a></code>,
<code><a href="#topic+oscilloEQ">oscilloEQ</a></code>, <code><a href="#topic+cutw">cutw</a></code>, <code><a href="#topic+pastew">pastew</a></code>,
<code><a href="#topic+timer">timer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
# a simple oscillogram of a bird song
oscillo(tico)
# zoom in
op&lt;-par(mfrow=c(4,1),mar=c(4.5,4,2,2))
oscillo(tico,22050,cexlab=0.75)
oscillo(tico,22050,from=0.5,to=0.9,cexlab=0.75)
oscillo(tico,22050,from=0.65,to=0.75,cexlab=0.75)
oscillo(tico,22050,from=0.68,to=0.70,cexlab=0.75)
par(op)
# the same divided in four lines
oscillo(tico,f=22050,k=4,j=1)
# the same divided in different numbers of lines and columns
oscillo(tico,f=22050,k=4,j=4)
oscillo(tico,f=22050,k=2,j=2,byrow=TRUE)
oscillo(tico,f=22050,k=2,j=2,byrow=FALSE)
# overplot of oscillographic and envelope representations
oscillo(tico,f=22050)
par(new=TRUE)
env(tico,f=22050,colwave=2)
# full colour modifications in a two-frame oscillogram
op&lt;-par(bg="grey")
oscillo(tico,f=22050,k=4,j=1,title=TRUE,colwave="black",
    coltitle="yellow",collab="red",colline="white",
    colaxis="blue",coly0="grey50")
par(op)
# change the title
data(orni)
oscillo(orni,f=22050,title="The song of a famous cicada")
# move along the signal using scroll
## Not run: 
require(rpanel)
oscillo(tico,f=22050,scroll=8)
## End(Not run)
</code></pre>

<hr>
<h2 id='oscilloEQ'>Oscillogram 'equalizer'</h2><span id='topic+oscilloEQ'></span>

<h3>Description</h3>

<p>A multipanel plot of a time wave displaying the oscillogram of a bank
of frequency filters like in an 'equalizer'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscilloEQ(wave, f, channel = 1, flim = NULL, colwave = 1,
xlab = "Time (s)", ylab = "Frequency band (kHz)",
cexlab = 1, collab = 1, fontlab = 1,
savedir = ".", plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oscilloEQ_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="oscilloEQ_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="oscilloEQ_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="oscilloEQ_+3A_flim">flim</code></td>
<td>
<p>a numeric vector giving the ordered limites of the
frequency filters to be applied. By default, 1 kHz frequency filters.
</p>
</td></tr>
<tr><td><code id="oscilloEQ_+3A_colwave">colwave</code></td>
<td>
<p>colour of the oscillogram.</p>
</td></tr>
<tr><td><code id="oscilloEQ_+3A_xlab">xlab</code></td>
<td>
<p>label of the x axis.</p>
</td></tr>
<tr><td><code id="oscilloEQ_+3A_ylab">ylab</code></td>
<td>
<p>label of the y axis.</p>
</td></tr>
<tr><td><code id="oscilloEQ_+3A_cexlab">cexlab</code></td>
<td>
<p>character size for axes labels.</p>
</td></tr>
<tr><td><code id="oscilloEQ_+3A_collab">collab</code></td>
<td>
<p>color for axes labels.</p>
</td></tr>
<tr><td><code id="oscilloEQ_+3A_fontlab">fontlab</code></td>
<td>
<p>font for axes labels.</p>
</td></tr>
<tr><td><code id="oscilloEQ_+3A_savedir">savedir</code></td>
<td>
<p>the path were the <code>.wav</code> files will be stored if
<code>plot</code> is <code>FALSE</code>. By default, the working directory.</p>
</td></tr>
<tr><td><code id="oscilloEQ_+3A_plot">plot</code></td>
<td>
<p>a logical, if <code>TRUE</code> a plot is created, if
<code>FALSE</code> then a series of <code>.wav</code> files are saved. Each file
corresponds to a frequency band.</p>
</td></tr>
<tr><td><code id="oscilloEQ_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function applies a bank of filters as delimited with the argument
<code>flim</code>.
If <code>plot</code> is <code>TRUE</code>, then the function displays the wave on a multiframe plot
so that the time*amplitude dynamics of each frequency filter can
be estimated. The filtered waves are generated using the function <code><a href="#topic+fir">fir</a></code>.
If <code>plot</code> is <code>FALSE</code>, then the corresponding waves are saved
as separated <code>.wav</code> file. Each file corresponds to a frequency
filter. 
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code> then a series of <code>.wav</code> files are saved. Each file
corresponds to a frequency filter.
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+oscilloST">oscilloST</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(peewit)
## default 1 kHz frequency filter
oscilloEQ(peewit)
## change de frequency filter limits
oscilloEQ(peewit, flim=c(0, 4, 8, 10))
oscilloEQ(peewit, flim=seq(2, 10, by=0.5))
## play with colors
oscilloEQ(peewit, colwave=c(1,2))
oscilloEQ(peewit, colwave=heat.colors)
blue.gray  &lt;- colorRampPalette(c("darkblue", "lightgrey"))
oscilloEQ(peewit, colwave=blue.gray)
## save files instead of visualizing them
## Not run: 
oscilloEQ(peewit, plot=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='oscilloST'>Show a stereo time wave as oscillograms</h2><span id='topic+oscilloST'></span>

<h3>Description</h3>

<p>This graphical function displays a stereo (2 channels) time wave as an
oscillogram in a two-frame plot. The envelope of the wave can also be shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscilloST(wave1, wave2 = NULL, f, from = NULL, to = NULL,
fastdisp = FALSE,
identify = FALSE, plot = TRUE, colwave1 = "black",
colwave2 = "blue", coltitle = "black",
collab = "black", cexlab = 1, fontlab = 1, colaxis = "black",
cexaxis = 1, coly01 = "grey47", coly02 = "black", title = FALSE,
bty = "l")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oscilloST_+3A_wave1">wave1</code></td>
<td>
<p>a first R object.</p>
</td></tr>     
<tr><td><code id="oscilloST_+3A_wave2">wave2</code></td>
<td>
<p>a second R object.</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_from">from</code></td>
<td>
<p>start of the oscillogram (in s).</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_to">to</code></td>
<td>
<p>end of the oscillogram (in s).</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_fastdisp">fastdisp</code></td>
<td>
<p>faster graphic display for long <code>wave</code>. The stereo
oscillogram is displayed/saved faster in the graphic device/
graphic file when set to <code>TRUE</code>, with a cost on the graphic resolution.</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_identify">identify</code></td>
<td>
<p>returns the time coordinate of points chosen  with a cursor 
on the bottom oscillogram.</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic or envelope plot
of <code>wave</code>(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_colwave1">colwave1</code></td>
<td>
<p>colour of the oscillogram or of the envelope of <code>wave1</code>.</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_colwave2">colwave2</code></td>
<td>
<p>colour of the oscillogram or of the envelope of <code>wave2</code>.</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_coltitle">coltitle</code></td>
<td>
<p>if <code>title</code> is <code>TRUE</code>, colour of the title.</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_collab">collab</code></td>
<td>
<p>colour of axes title.</p>
</td></tr>  
<tr><td><code id="oscilloST_+3A_cexlab">cexlab</code></td>
<td>
<p>character size for axes title.</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_fontlab">fontlab</code></td>
<td>
<p>font for axes title.</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_colaxis">colaxis</code></td>
<td>
<p>colour of the axes</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_cexaxis">cexaxis</code></td>
<td>
<p>mangification for axes annotation.</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_coly01">coly01</code></td>
<td>
<p>colour of the y=0 line of <code>wave1</code>.</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_coly02">coly02</code></td>
<td>
<p>colour of the y=0 line of <code>wave1</code>.</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_title">title</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the title 
with information on time and <code>f</code> (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="oscilloST_+3A_bty">bty</code></td>
<td>
<p>the type of box to be drawn around the oscillogram.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Data are returned as two-column matrix if <code>plot</code> is <code>FALSE</code>.
<code>identify</code> returns a numeric object with the time coordinate 
of points successively chosen on the bottom oscillogram.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur and Caroline Simonis.</p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+oscilloEQ">oscilloEQ</a></code>, <code><a href="#topic+dynoscillo">dynoscillo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-synth(f=8000,d=1,cf=2000,am=c(50,10),plot=FALSE)
b&lt;-synth(f=8000,d=1,cf=1000,fm=c(0,0,2000,0,0),plot=FALSE)
oscilloST(a,b,f=8000)
</code></pre>

<hr>
<h2 id='pastew'>Paste a time wave to another one</h2><span id='topic+pastew'></span>

<h3>Description</h3>

<p>This function pastes a first time wave to a second one. The time wave to be 
pasted, the time wave to be completed and the resulting time wave can be 
displayed in a three-frame oscillographic plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pastew(wave1, wave2, f, channel = c(1,1), at = "end",
join = FALSE, tjunction = 0,
choose = FALSE, plot = FALSE,
marks = TRUE, output = "matrix", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pastew_+3A_wave1">wave1</code></td>
<td>
<p>a first R object.</p>
</td></tr>
<tr><td><code id="pastew_+3A_wave2">wave2</code></td>
<td>
<p>a second R object.</p>
</td></tr>
<tr><td><code id="pastew_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="pastew_+3A_channel">channel</code></td>
<td>
<p>channel of the R objects, by default left channel (1)
for each object.</p>
</td></tr>
<tr><td><code id="pastew_+3A_at">at</code></td>
<td>
<p><code>wave2</code> position in seconds where <code>wave1</code> will be pasted into.
Can be also specified as <code>"start"</code>, <code>"middle"</code> or
<code>"end"</code>.</p>
</td></tr>
<tr><td><code id="pastew_+3A_join">join</code></td>
<td>
<p>if <code>TRUE</code> the two waves will be pasted and jointed by
removing the last point of wave2. See examples.</p>
</td></tr>
<tr><td><code id="pastew_+3A_tjunction">tjunction</code></td>
<td>
<p>a numeric vector to remove clicks at the junction of ‘wave1’ and ‘wave2’. The value specifies the duration in seconds where the real vales will be replaced by a linear interpolation. This duration should be a few milliseconds.</p>
</td></tr>
<tr><td><code id="pastew_+3A_choose">choose</code></td>
<td>
<p>logical, if <code>TRUE</code> the point where <code>wave1</code> will
be pasted into <code>wave2</code> (=<code>at</code>) can be graphically chosen with a cursor.</p>
</td></tr>
<tr><td><code id="pastew_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic plot of 
<code>wave1</code>, <code>wave2</code> and <code>wave1</code> + <code>wave2</code> (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="pastew_+3A_marks">marks</code></td>
<td>
<p>logical, if <code>TRUE</code> shows where <code>wave1</code> has been
pasted (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="pastew_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="pastew_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>plot</code> is <code>TRUE</code> returns a two-frame plot with three waves:<br /> 
(1) the wave to be pasted (<code>wave1</code>),<br />
(2) the wave to be completed (<code>wave2</code>),<br />
(3) the resulting wave.</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, improved by Laurent Lellouch</p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+addsilw">addsilw</a></code>, <code><a href="#topic+cutw">cutw</a></code>,
<code><a href="#topic+deletew">deletew</a></code>, <code><a href="#topic+fadew">fadew</a></code>, <code><a href="#topic+mutew">mutew</a></code>
, <code><a href="#topic+revw">revw</a></code>, <code><a href="#topic+repw">repw</a></code>, <code><a href="#topic+timelapse">timelapse</a></code>
, <code><a href="#topic+zapsilw">zapsilw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
# double a data set describing a bird song
a&lt;-pastew(tico,tico,f=22050)
oscillo(a,f=22050)
# a direct way to see what has been pasted
pastew(tico,tico,f=22050,plot=TRUE)
# cut a section and then paste it at the beginning
a&lt;-cutw(tico, f=22050, from=0.5, to=0.9)
pastew(a,tico,f=22050,at="start",plot=TRUE)
# or paste it at a specific location
pastew(a,tico,f=22050,at=1.4,plot=TRUE)
# setting the argument 'join' to TRUE might be useful
# to smooth pasting when some phase problem occur
# generate two sine waves
a &lt;- synth(cf=50, f=400, d=0.1)
b &lt;- synth(cf=100, f=400, d=0.1)
# paste it with 'join' turned to FALSE
# there is a click at the junction between the two waves
pastew(a, b, f=400, plot=TRUE)
# that can be removed by setting 'join' to TRUE
pastew(a, b, f=400, join=TRUE, plot=TRUE)
# or by using the argument 'tjunction'
pastew(a, b, f=400, tjunction=0.01, plot=TRUE)
</code></pre>

<hr>
<h2 id='peewit'>Song of the bird Vanellus vanellus</h2><span id='topic+peewit'></span>

<h3>Description</h3>

<p>Recording of a song emitted by a peewit (lapwing) male
<em>Vanellus vanellus</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(peewit)</code></pre>


<h3>Format</h3>

<p>A Wave object.</p>


<h3>Details</h3>

<p>Duration = 0.706 s. Sampling frequency = 22050 hz.
</p>


<h3>Source</h3>

<p>Recording by Thierry Aubin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(peewit)
oscillo(peewit,f=22050)
</code></pre>

<hr>
<h2 id='pellucens'>Calling song of the tree cricket Oecanthus pellucens</h2><span id='topic+pellucens'></span>

<h3>Description</h3>

<p>Recording of a calling song section emitted by the European tree cricket <em>Oecanthus pellucens</em>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pellucens)</code></pre>


<h3>Format</h3>

<p>A Wave object.</p>


<h3>Details</h3>

<p>Duration = 3.309 s. Sampling frequency = 11025 hz.
</p>


<h3>Source</h3>

<p>Recording by Jerome Sueur.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pellucens)
oscillo(pellucens,f=11025)
</code></pre>

<hr>
<h2 id='phaseplot'>Phase-phase 2D or 3D plot of a time wave</h2><span id='topic+phaseplot'></span>

<h3>Description</h3>

<p>This function returns a 2D or 3D representation of a time
wave according to its first, second and possibly third derivatives.</p>


<h3>Usage</h3>

<pre><code class='language-R'>phaseplot(wave, f, channel = 1, dim = 3, plot = TRUE, type = "l",
xlab = "1st derivative",
ylab = "2nd derivative",
zlab = "3rd derivative", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phaseplot_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="phaseplot_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="phaseplot_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="phaseplot_+3A_dim">dim</code></td>
<td>
<p>a vector of lenght 1, the number of dimensions of the
plot. Can be either 2 or 3.</p>
</td></tr>
<tr><td><code id="phaseplot_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots phase-phase plot (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="phaseplot_+3A_type">type</code></td>
<td>
<p>type of plot that should be drawn. See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="phaseplot_+3A_xlab">xlab</code></td>
<td>
<p>title of the x axis.</p>
</td></tr>
<tr><td><code id="phaseplot_+3A_ylab">ylab</code></td>
<td>
<p>title of the y axis.</p>
</td></tr>
<tr><td><code id="phaseplot_+3A_zlab">zlab</code></td>
<td>
<p>title of the z axis.</p>
</td></tr>
<tr><td><code id="phaseplot_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> or <code>plot3d</code> graphical
parameters of the package <span class="pkg">rgl</span>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code> then a 2 or 3 column matrix is
returned. The position of the column is related to the order of the
derivative (<em>i</em>. <em>e</em>. first colum = first derivative.</p>


<h3>Note</h3>

<p>Phase-phase plot can be used to test non-linearity.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>For use of such plots see:
Rice AN, Land BR, Bass AH (2011) - Nonlinear acoustic complexity in a
fish 'two-voice' system. <em>Proceedings of the Royal Society B</em>, in press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phaseplot2">phaseplot2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(rgl)
data(tico)
phaseplot(tico)

## End(Not run)
s &lt;- synth(d=0.05, f=44100, cf=440, out="Wave")
n &lt;- noisew(d=0.05, f=44100, out="Wave")
par(mfrow=c(2,1))
phaseplot(s, dim=2)
phaseplot(n, dim=2)
</code></pre>

<hr>
<h2 id='phaseplot2'>Phase-phase 2D plot of a time wave</h2><span id='topic+phaseplot2'></span>

<h3>Description</h3>

<p>This functions returns a 2D representation of a time wave
against a delayed version of itself.</p>


<h3>Usage</h3>

<pre><code class='language-R'>phaseplot2(wave, f, channel = 1, tau = 1, type = "l",
xlab = "x(t)",
ylab = paste("x(t+", tau, ")", sep = ""), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phaseplot2_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="phaseplot2_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="phaseplot2_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="phaseplot2_+3A_tau">tau</code></td>
<td>
<p>the time delay to apply in number of samples.</p>
</td></tr>
<tr><td><code id="phaseplot2_+3A_type">type</code></td>
<td>
<p>type of plot that should be drawn. See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="phaseplot2_+3A_xlab">xlab</code></td>
<td>
<p>title of the x axis.</p>
</td></tr>
<tr><td><code id="phaseplot2_+3A_ylab">ylab</code></td>
<td>
<p>title of the y axis.</p>
</td></tr>
<tr><td><code id="phaseplot2_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The principle consists in displaying in a single x-y graph the
original time wave with a delayed version of itself. The delay is
controlled with the argument <code>tau</code> that needs to be specified in
number of samples. The conversion of <code>tau</code> in second is obtained by calculating
<code>tau/f</code>, with <code>f</code> the sampling frequency.</p>


<h3>Value</h3>

<p>Nothing is returned except an x-y plot.</p>


<h3>Note</h3>

<p>Phase-phase plot can be used to test non-linearity.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Kantz H, Schreiber T (2003) <em>Non linear time series analysis</em>. Cambridge University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+phaseplot">phaseplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- synth(d=0.05, f=44100, cf=440, out="Wave")
n &lt;- noisew(d=0.05, f=44100, out="Wave")
par(mfrow=c(2,1))
phaseplot2(s)
phaseplot2(n)
</code></pre>

<hr>
<h2 id='playlist'>Play a list of sound files</h2><span id='topic+playlist'></span>

<h3>Description</h3>

<p>This function works as a playlist, ie it plays back a
list of sound files.</p>


<h3>Usage</h3>

<pre><code class='language-R'>playlist(directory, sample = FALSE, loop = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="playlist_+3A_directory">directory</code></td>
<td>
<p>a character vector indicating the path to the
directory where sound files to played are saved.</p>
</td></tr>
<tr><td><code id="playlist_+3A_sample">sample</code></td>
<td>
<p>a logical, if <code>TRUE</code> the order of sounds files to
be played back is shuffled.</p>
</td></tr>
<tr><td><code id="playlist_+3A_loop">loop</code></td>
<td>
<p>a numeric vector of length 1, number of loops.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The success of using this function depends on the wave player in
use. This works particularly well with SoX under Linux. The type of
files (.mp3, .wav, .ogg etc) depends on the wave player as well)</p>


<h3>Value</h3>

<p>None. Listen and enjoy!</p>


<h3>Note</h3>

<p>The function is mainly based on <code><a href="tuneR.html#topic+play">play</a></code></p>


<h3>Author(s)</h3>

<p>Jérôme Sueur</p>


<h3>See Also</h3>

<p><code><a href="tuneR.html#topic+play">play</a></code>, <code><a href="#topic+listen">listen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
playlist("MyMusic", sample = TRUE, loop=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='preemphasis'>Pre-emphasis speech filter</h2><span id='topic+preemphasis'></span>

<h3>Description</h3>

<p>A pre-emphasis frequency filter for speech</p>


<h3>Usage</h3>

<pre><code class='language-R'>preemphasis(wave, f, channel = 1, alpha = 0.9,
plot = FALSE, output = "matrix", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preemphasis_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="preemphasis_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="preemphasis_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="preemphasis_+3A_alpha">alpha</code></td>
<td>
<p>time constant, see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="preemphasis_+3A_plot">plot</code></td>
<td>
<p>a logical, if <code>TRUE</code> plots the spectrogram of the
filtered <code>wave</code> and the frequency response of the comb filter.</p>
</td></tr>
<tr><td><code id="preemphasis_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return,
either <code>'matrix'</code>, <code>'Wave'</code>, <code>'Sample'</code>,
<code>'audioSample'</code> or <code>'ts'</code>.</p>
</td></tr>
<tr><td><code id="preemphasis_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code><a href="#topic+spectro">spectro</a></code>
except <code>scale</code> and <code>osc</code> that are set by default to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function applies a pre-emphasis filter usually applied in
speech analysis. The filter is a kind of high-pass frequency filter
that amplifies the high-frequency content of the sample. The filter is
defined with:
</p>
<p style="text-align: center;"><code class="reqn">y(n) = x(n) - \alpha \times x(n - 1)</code>
</p>

<p>where alpha is a time constant usually set between 0.9 and 1.
</p>
<p>The frequency response of the filter is obtained with:
</p>
<p style="text-align: center;"><code class="reqn">H(f)=1+a^{2}-2 \times \alpha \times \cos(2 \times \pi \times
  f/f_{s})</code>
</p>



<h3>Value</h3>

<p>A new wave is returned. The class of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+bwfilter">bwfilter</a></code>, <code><a href="#topic+combfilter">combfilter</a></code>, <code><a href="#topic+ffilter">ffilter</a></code>, <code><a href="#topic+fir">fir</a></code>,<code><a href="#topic+lfs">lfs</a></code>, <code><a href="#topic+afilter">afilter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sheep)
fc &lt;- 150
f &lt;- sheep@samp.rate
alpha &lt;- exp(-2*pi*fc/f)
res &lt;- preemphasis(sheep, alpha=alpha, output="Wave")
</code></pre>

<hr>
<h2 id='pulsew'>Generate rectangle pulse</h2><span id='topic+pulsew'></span>

<h3>Description</h3>

<p>This function generates a rectangle pulse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pulsew(dbefore, dpulse, dafter, f, plot = FALSE, output = "matrix", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pulsew_+3A_dbefore">dbefore</code></td>
<td>
<p>duration of the silent period before the pulse</p>
</td></tr>
<tr><td><code id="pulsew_+3A_dpulse">dpulse</code></td>
<td>
<p>duration of the pulse to generate</p>
</td></tr>
<tr><td><code id="pulsew_+3A_dafter">dafter</code></td>
<td>
<p>duration of silent period after the pulse</p>
</td></tr>
<tr><td><code id="pulsew_+3A_f">f</code></td>
<td>
<p>sampling frequency of the signal to be generated (in Hz)</p>
</td></tr>
<tr><td><code id="pulsew_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic plot of the 
pulse generated (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="pulsew_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="pulsew_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+synth">synth</a></code>, <code><a href="#topic+noisew">noisew</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pulsew(dbefore=0.5,dpulse=0.1,dafter=0.3,f=8000,plot=TRUE)
</code></pre>

<hr>
<h2 id='Q'>Resonance quality factor of a frequency spectrum</h2><span id='topic+Q'></span>

<h3>Description</h3>

<p>This function estimates the frequency pureness of a time wave by returning the resonant
quality factor Q at a specific dB level.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q(spec, f = NULL, level = -3, mel = FALSE, plot = TRUE, colval = "red",
cexval = 1, fontval = 1, flab = NULL,
alab = "Relative amplitude (dB)", type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q_+3A_spec">spec</code></td>
<td>
<p>a data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code>, or <code><a href="#topic+meanspec">meanspec</a></code> (in dB).
This can be either a two-column matrix (col1 = frequency, col2 = amplitude)
or a vector (amplitude).</p>
</td></tr>
<tr><td><code id="Q_+3A_f">f</code></td>
<td>
<p>sampling frequency of the wave used to obtain <code>spec</code>
(in Hz). Not necessary if <code>spec</code> is a two columns matrix obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code>.</p>
</td></tr>
<tr><td><code id="Q_+3A_level">level</code></td>
<td>
<p>frequency bandwidth set by an amplitude value relative
to <code>spectrum</code> (in dB).</p>
</td></tr>
<tr><td><code id="Q_+3A_mel">mel</code></td>
<td>
<p>a logical, if <code>TRUE</code> the (htk-)mel scale is used.</p>
</td></tr>
<tr><td><code id="Q_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns the spectrum 
with Q plotted (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="Q_+3A_colval">colval</code></td>
<td>
<p>colour of plotting Q.</p>
</td></tr>
<tr><td><code id="Q_+3A_cexval">cexval</code></td>
<td>
<p>character size of plotting Q.</p>
</td></tr>
<tr><td><code id="Q_+3A_fontval">fontval</code></td>
<td>
<p>font of plotting Q.</p>
</td></tr>
<tr><td><code id="Q_+3A_flab">flab</code></td>
<td>
<p>title of the frequency axis.</p>
</td></tr>
<tr><td><code id="Q_+3A_alab">alab</code></td>
<td>
<p>title of the amplitude axis.</p>
</td></tr>
<tr><td><code id="Q_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="Q_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A high Q value indicates a highly resonant system.</p>


<h3>Value</h3>

<p>A list is returned with the following four items:
</p>
<table>
<tr><td><code>Q</code></td>
<td>
<p>a numeric vector of length 1 returning the Q factor (no units)</p>
</td></tr>
<tr><td><code>dfreq</code></td>
<td>
<p>a numeric vector of length 1 the dominant frequency (kHz)</p>
</td></tr>
<tr><td><code>fmin</code></td>
<td>
<p>a numeric vector of length 1 returning the minimum
frequency of the -dB level bandwidth (kHz)</p>
</td></tr> 
<tr><td><code>fmax</code></td>
<td>
<p>a numeric vector of length 1 returning the minimum
frequency of the -dB level bandwidth (kHz)</p>
</td></tr>
<tr><td><code>bwd</code></td>
<td>
<p>a numeric vector of length 1 returning the bandwidth,
i. e. <code>fmax-fmin</code> (kHz)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is based on an linear interpolation of the spectrum
so that the result should be considered as an estimation, not an exact measure.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, improved by Laurent Lellouch</p>


<h3>See Also</h3>

<p><code><a href="#topic+spec">spec</a></code>, <code><a href="#topic+meanspec">meanspec</a></code>, <code><a href="#topic+corspec">corspec</a></code>,
<code><a href="stats.html#topic+fft">fft</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># bird song
data(tico)
t&lt;-spec(tico,f=22050,at=1.1,plot=FALSE,dB="max0")
op&lt;-par(mfrow=c(2,1),las=1)
Q(t,type="l")
Q(t,type="l",xlim=c(3.8,4.2),ylim=c(-60,0))
title("zoom in")
par(op)
# cricket, changing the dB level
data(pellucens)
p&lt;-spec(pellucens,f=11025,at=0.5,plot=FALSE,dB="max0")
op&lt;-par(mfrow=c(3,1))
Q(p,type="l",xlim=c(1.8,2.6),ylim=c(-70,0))
title("level = - 3 (default value)",col.main="red")
Q(p,type="l",level=-6,
    xlim=c(1.8,2.6),ylim=c(-70,0),colval="blue")
title("level = - 6",col.main="blue")
Q(p,type="l",level=-9,
    xlim=c(1.8,2.6),ylim=c(-70,0),colval="green")
title("level = - 9",col.main="green")
par(op)
</code></pre>

<hr>
<h2 id='read.audacity'>Audacity audio markers import</h2><span id='topic+read.audacity'></span>

<h3>Description</h3>

<p>Read audio markers as exported by Audacity.</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.audacity(file, format)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.audacity_+3A_file">file</code></td>
<td>
<p>A .txt file produced by Audacity when exporting time or
time x frequency markers.</p>
</td></tr>
<tr><td><code id="read.audacity_+3A_format">format</code></td>
<td>
<p>The format of the file name that will appear in the
value, that is in the first column of the data frame returned. if
<code>"dir"</code> then the full path to the file is returned, if
<code>"base"</code> only the base name of the file is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Audacity opens the possibility to annotate sound files with a
marker channel. These markers can be exported as .txt files. The
function <code>read.audacity</code> import such .txt files whether they
contain time markers or time x frequency markers. 
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>. The size of the <code>data.frame</code> differs
whether the .txt file contains time markers or time x frequency
markers.<br />
For time markers, the <code>data.frame</code> contains 4 columns:
</p>

<ol>
<li><p><code>file</code> returning the name of the input file either with
the full path or with the base name only (see argument <code>format</code>),
</p>
</li>
<li><p><code>label</code> the text label,
</p>
</li>
<li><p><code>t1</code> the start time in seconds,
</p>
</li>
<li><p><code>t2</code>the end time in seconds.
</p>
</li></ol>
 
<p>For time x frequency markers, the <code>data.frame</code> contains 6
columns:
</p>

<ol>
<li><p><code>file</code> returning the name of the input file either with
the full path or with the base name only (see argument <code>format</code>),
</p>
</li>
<li><p><code>label</code> the text label,
</p>
</li>
<li><p><code>t1</code> the start time in seconds,
</p>
</li>
<li><p><code>t2</code> the end time in seconds,
</p>
</li>
<li><p><code>f1</code> the lower frequency in Hz,
</p>
</li>
<li><p><code>f2</code> the upper frequency in Hz.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Audacity is a free software
distributed under the terms of the GNU General Public License.<br />
Web site: <a href="https://www.audacityteam.org/">https://www.audacityteam.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.audacity">write.audacity</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## If 'markers.txt' is an export of Audacity markers
x &lt;- read.audacity("markers.txt")

## End(Not run)
</code></pre>

<hr>
<h2 id='repw'>Repeat a time wave</h2><span id='topic+repw'></span>

<h3>Description</h3>

<p>This function repeats a time wave</p>


<h3>Usage</h3>

<pre><code class='language-R'>repw(wave, f, channel = 1, times = 2, join = FALSE, plot = FALSE, output= "matrix", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repw_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="repw_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="repw_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="repw_+3A_times">times</code></td>
<td>
<p>a numeric of length 1 describing the number
of times the wave has to be repeated.</p>
</td></tr>
<tr><td><code id="repw_+3A_join">join</code></td>
<td>
<p>if <code>TRUE</code> the last point of <code>wave</code> will be
removed for smoothing junction between repetitions. See examples. </p>
</td></tr>
<tr><td><code id="repw_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the repeated time wave.</p>
</td></tr>
<tr><td><code id="repw_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="repw_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+addsilw">addsilw</a></code>, <code><a href="#topic+cutw">cutw</a></code>,
<code><a href="#topic+deletew">deletew</a></code>, <code><a href="#topic+fadew">fadew</a></code>, <code><a href="#topic+mutew">mutew</a></code>,
<code><a href="#topic+pastew">pastew</a></code>, <code><a href="#topic+revw">revw</a></code>, <code><a href="#topic+zapsilw">zapsilw</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
repw(tico,f=22050,plot=TRUE)
# use 'join' for smooth pasting
par(mfrow=c(2,1))
a &lt;- synth(cf=50, f=400, d=0.1)
repw(a, f=400, plot=TRUE)
title(main="join is FALSE")
points(x=0.1, y=0, cex=2, col=2)
repw(a, f=400, join=TRUE, plot=TRUE)
title(main="join is TRUE")
points(x=0.1, y=0, cex=2, col=2)
</code></pre>

<hr>
<h2 id='resamp'>Resample a time wave</h2><span id='topic+resamp'></span>

<h3>Description</h3>

<p>This function resamples (down- or over-samples) a time wave. This
corresponds to a sampling frequency change.</p>


<h3>Usage</h3>

<pre><code class='language-R'>resamp(wave, f, g, channel = 1, output="matrix")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resamp_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="resamp_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="resamp_+3A_g">g</code></td>
<td>
<p>new sampling frequency of <code>wave</code> (in Hz).</p>
</td></tr>
<tr><td><code id="resamp_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="resamp_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Note</h3>

<p>Resampling might change frequency properties of the time wave.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(peewit)
# downsampling
a&lt;-resamp(peewit,f=22050,g=11025)
# oversampling
b&lt;-resamp(peewit,f=22050,g=44100)
</code></pre>

<hr>
<h2 id='revw'>Time reverse of a time wave</h2><span id='topic+revw'></span>

<h3>Description</h3>

<p>Reverse the wave along the time axis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>revw(wave, f, channel = 1, env = TRUE, ifreq = TRUE,
plot = FALSE, output = "matrix", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revw_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="revw_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="revw_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="revw_+3A_env">env</code></td>
<td>
<p>logical, if <code>TRUE</code> the amplitude envelope is reversed.</p>
</td></tr>
<tr><td><code id="revw_+3A_ifreq">ifreq</code></td>
<td>
<p>logical, if <code>TRUE</code> the instantaneous frequency is reversed.</p>
</td></tr>
<tr><td><code id="revw_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic plot of
the reversed wave (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="revw_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="revw_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>plot</code> is <code>TRUE</code> returns an oscillogram of the reversed
wave. The amplitude and the instantaneous frequency can be independently reversed
thanks to the arguments <code>env</code> and <code>ifreq</code>. See the examples.</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Beeman, K. 1998. Digital signal analysis, editing and synthesis <em>in</em> 
Hopp, S. L., Owren, M. J. and Evans, C. S. (Eds) 1998. <em>Animal acoustic 
communication</em>, pp. 59-103. Springer, Berlin, Heidelberg.</p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+addsilw">addsilw</a></code>, <code><a href="#topic+deletew">deletew</a></code>,
<code><a href="#topic+fadew">fadew</a></code>, <code><a href="#topic+pastew">pastew</a></code>, <code><a href="#topic+mutew">mutew</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
# simple reverse
revw(tico,f=22050,plot=TRUE)
# envelope reverse only
revw(tico,f=22050,ifreq=FALSE, plot=TRUE)
# instantaneous frequency reverse only
revw(tico,f=22050,env=FALSE, plot=TRUE)
</code></pre>

<hr>
<h2 id='rmam'>Remove the amplitude modulations of a time wave</h2><span id='topic+rmam'></span>

<h3>Description</h3>

<p>This functions removes the amplitude modulation of a time wave
through the Hilbert amplitude envelope.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmam(wave, f, channel = 1, plot = FALSE, listen = FALSE, output = "matrix", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmam_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="rmam_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="rmam_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="rmam_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic plot
of the nwe time wave (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="rmam_+3A_listen">listen</code></td>
<td>
<p>if <code>TRUE</code> the new sound is played back.</p>
</td></tr>
<tr><td><code id="rmam_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="rmam_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The new time wave is obtained by dividing the original time wave by
its Hilbert amplitude envelope.</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Mbu Nyamsi, R. G., Aubin, T. &amp; Bremond, J. C. 1994
On the extraction of some time dependent parameters of an acoustic signal
by means of the analytic signal concept.
Its application to animal sound study. <em>Bioacoustics</em>, 5: 187-203.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hilbert">hilbert</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a new sound with amplitude modulation
a&lt;-synth(f=8000, d=1, cf=1500, am=c(50,10))
# remove the amplitude modulation and plot the result
rmam(a,f=8000,plot=TRUE)
</code></pre>

<hr>
<h2 id='rmnoise'>Remove noise</h2><span id='topic+rmnoise'></span>

<h3>Description</h3>

<p>This function removes background noise by smoothing 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmnoise(wave, f, channel = 1, output = "matrix", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmnoise_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="rmnoise_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="rmnoise_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="rmnoise_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="rmnoise_+3A_...">...</code></td>
<td>
<p>other <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>. You can
use the arguments of the later to modify the smoothing.
</p>


<h3>Value</h3>

<p>A new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Note</h3>

<p>Low frequency noise might not be removed out properly.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+afilter">afilter</a></code>,  <code><a href="#topic+noisew">noisew</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># synthesis of a 440 Hz sound with background noise
n &lt;- noisew(d=1,f=8000)
s &lt;- synth(d=1,f=8000,cf=440)
ns &lt;- n+s
# remove noise (but low frequency content still there)
a &lt;- rmnoise(ns,f=8000)
</code></pre>

<hr>
<h2 id='rmoffset'>Remove the offset of a time wave</h2><span id='topic+rmoffset'></span>

<h3>Description</h3>

<p>This function removes the offset of a time wave.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmoffset(wave, f, channel = 1, FUN = mean, plot = FALSE, output = "matrix", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmoffset_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="rmoffset_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="rmoffset_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="rmoffset_+3A_fun">FUN</code></td>
<td>
<p>a function used to apply the offset correction. See Details.</p>
</td></tr>
<tr><td><code id="rmoffset_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns an oscillographic plot of the wave
after removing the offset (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="rmoffset_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="rmoffset_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The offset is removed by substracting the wave by its mean
(argument <code>FUN</code>). But other function can be used. For instance, it
can be more approriate to use the median to remove the
offtset and transients. See Examples. <br />
If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+oscillo">oscillo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
# artifically generates an offset
tico2&lt;-tico+0.1
# see the wave with an offset
oscillo(tico2, f=22050)
# remove the offset with the mean (by default)
rmoffset(tico2, f=22050, plot=TRUE)
# remove the offset with the median
rmoffset(tico2, f=22050, FUN=median, plot=TRUE)
</code></pre>

<hr>
<h2 id='rms'>
Root Mean Square
</h2><span id='topic+rms'></span>

<h3>Description</h3>

<p>This function computes the root mean square or quadratic mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rms_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="rms_+3A_...">...</code></td>
<td>
<p>further arguments passed to mean</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Root Mean Square or quadratic mean is computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">RMS = \sqrt{\frac{1}{n} \times \sum_{i=1}^{N} x{_i}{^2}}</code>
</p>



<h3>Value</h3>

<p>A numeric vector of length 1</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simple rms
rms(1:10)
# rms of a normalized envelope
data(sheep)
env &lt;- env(sheep, f=8000)
rms(env)
</code></pre>

<hr>
<h2 id='roughness'>Roughness or total curvature</h2><span id='topic+roughness'></span>

<h3>Description</h3>

<p>This function computes the roughness or total curvature of
a curve, i.e. of a time wave or of a spectrum</p>


<h3>Usage</h3>

<pre><code class='language-R'>roughness(x, std = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roughness_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="roughness_+3A_std">std</code></td>
<td>
<p>a logical, if set to <code>TRUE</code> then <code>x</code> is standardized by its maximum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Roughness or total curvature is the integrated squared second
derivative :<br />
</p>
<p style="text-align: center;"><code class="reqn">roughness = \int [D^2x(t)]^2 \, \mathrm{d} t</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>A vector of length 1.</p>


<h3>Note</h3>

<p>The value has not unit.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Ramsay JO, Silverman BW (2005) <em>Functional data analysis</em>. Springer, Berlin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rugo">rugo</a></code>, <code><a href="#topic+rms">rms</a></code>, <code><a href="#topic+sh">sh</a></code>, <code><a href="#topic+th">th</a></code>, <code><a href="#topic+H">H</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
spec &lt;- meanspec(tico, plot=FALSE)[,2]
roughness(spec) 
</code></pre>

<hr>
<h2 id='rugo'>Rugosity of a time wave</h2><span id='topic+rugo'></span>

<h3>Description</h3>

<p>This function computes the rugosity of a time wave or time series</p>


<h3>Usage</h3>

<pre><code class='language-R'>rugo(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rugo_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="rugo_+3A_...">...</code></td>
<td>
<p>other <code><a href="base.html#topic+mean">mean</a></code> parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula has been slightly modified from Mezquida &amp; Martinez (2009:
826) to fit with the classical definition of the root-mean-square
(see <code><a href="#topic+rms">rms</a></code>).<br />
The rugosity is then computed as following:
</p>
<p style="text-align: center;"><code class="reqn">rugo = \sqrt{\sum_{i=1}^{n-1} \frac{(x_{i+1}-x_{i})^2}{n}}</code>
</p>

<p>for a vector <code>x</code> of length <em>n</em>.
</p>


<h3>Value</h3>

<p>A vector of length 1.</p>


<h3>Note</h3>

<p>The rugosity of a noisy signal will tend to be higher than that of
a pure tone signal, all other things being equal.<br />
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Mezquida DA, Martinez JL (2009) -
Platform for bee-hives monitoring based on sound analysis.
A perpetual warehouse for swarm's daily activity.
<em>Spanish Journal of Agricultural Research</em> <b>7</b>, 824-828.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roughness">roughness</a></code>, <code><a href="#topic+rms">rms</a></code>, <code><a href="#topic+sh">sh</a></code>, <code><a href="#topic+th">th</a></code>, <code><a href="#topic+H">H</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico) ; tico &lt;-tico@left
# rugosity of the original recording normalised
rugo(tico/max(tico))
# synthesis of white noise with the same duration as tico
noise &lt;- noisew(d=length(tico)/22050, f=22050)
# tico is normalised to get similar amplitude with the noise
tico.norm &lt;- tico/max(tico)
# addition of noise to tico
tico.noisy &lt;- tico.norm + 0.5*noise
# new rugosity (higher) on normalised signal
rugo(tico.noisy/max(tico.noisy))
</code></pre>

<hr>
<h2 id='savewav'>Save a .wav file</h2><span id='topic+savewav'></span>

<h3>Description</h3>

<p>Save sound data as .wav file</p>


<h3>Usage</h3>

<pre><code class='language-R'>savewav(wave, f, channel = 1, filename = NULL, rescale = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="savewav_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="savewav_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="savewav_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="savewav_+3A_filename">filename</code></td>
<td>
<p>name of the new file. (by default the name of
<code>wave</code>).</p>
</td></tr>
<tr><td><code id="savewav_+3A_rescale">rescale</code></td>
<td>
<p>a numeric vector of length 2 giving the lower (negative
value) and upper (positive value) amplitude limits of the .wav file to
be exported.</p>
</td></tr>
<tr><td><code id="savewav_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code><a href="tuneR.html#topic+writeWave">writeWave</a></code></p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>This function uses three functions from the package <span class="pkg">tuneR</span>:
<code><a href="tuneR.html#topic+Wave">Wave</a></code>, <code><a href="tuneR.html#topic+normalize">normalize</a></code> and <code><a href="tuneR.html#topic+writeWave">writeWave</a></code>.
</p>


<h3>Note</h3>

<p>The  file automatically owerwrites an existing file
with the same name.<br />
The amplitude (volume) of the .wav file is normalized by defaults but can be changed with the argument
<code>rescale</code>. See examples</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a>, Ethan C. Brown for the
argument 'rescale'</p>


<h3>See Also</h3>

<p><code><a href="#topic+export">export</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(tuneR)
a&lt;-synth(f=8000,d=2,cf=2000,plot=FALSE)
# the name of the file is automatically the name of the object
# here: "a.wav"
savewav(a,f=22050)
unlink("a.wav")
# if you wish to change the name, use the 'file' argument
savewav(a,f=22050,file="b.wav")
unlink("b.wav")
# if you wish to change the amplitude of the file, use the argument 'rescale'
# this will turn down the volume of a 16 bit sound
# which amplitude was originally ranging between -2^15 and +2^15
savewav(a, f=22050, file="c.wav", rescale=c(-1500,1500))
unlink("c.wav")
</code></pre>

<hr>
<h2 id='SAX'>Symbolic Aggregate approXimation</h2><span id='topic+SAX'></span>

<h3>Description</h3>

<p>This function converts a numeric times seris into a series
of letters with a specific length and alphabet.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SAX(x, alphabet_size, PAA_number,
breakpoints = "gaussian", collapse = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SAX_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="SAX_+3A_alphabet_size">alphabet_size</code></td>
<td>
<p>a numeric vector of length 1 setting the size of
the alphabet.</p>
</td></tr>
<tr><td><code id="SAX_+3A_paa_number">PAA_number</code></td>
<td>
<p>a numeric vector of length 1 setting the number of
elements (subsequences) of the Piecewise Aggregate Approximation (PAA).</p>
</td></tr>
<tr><td><code id="SAX_+3A_breakpoints">breakpoints</code></td>
<td>
<p>either a character vector (&quot;gaussian&quot;, &quot;quantiles&quot;)
or a numeric vector specifying the sorted values of the breakpoints
along the distribution of <code>x</code>. See details and examples.</p>
</td></tr>
<tr><td><code id="SAX_+3A_collapse">collapse</code></td>
<td>
<p>a character vector of length 1, specifying the way to
collapse the output letters, see <code><a href="base.html#topic+paste">paste</a></code>. By default letters are
returned separated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SAX method has been developed to reduce the dimensionality of a numerical series into a short chain of characters. SAX follows a two-step process: (1) Piecewise Aggregate Approximation (PAA) and (2) conversion a PAA sequence into a series of letters. <br />
</p>
<p>PAA consists in a Z-normalisation, a segmentation of the series of
length <em>n</em> into <em>w</em> segments, and the computation of each segment average. <br />
</p>
<p>The conversion of the PAA into a series of letters is achieved by attributing with
equiprobability each value of the PAA to a letter in reference to a
Gaussian distribution. This process therefore assumes that the
distribution of the numeric series <code>x</code> follows a Gaussian
distribution. To relax the constraints of normality we here added the possibility to directly work
on the quantiles of the original data distribution or to specify particular breakpoints along the
distribution of <code>x</code>. See the examples.
</p>


<h3>Value</h3>

<p>A character vector of length (when <code>collapse</code> is
<code>NULL</code>) or number of character (when <code>collapse</code> is
not <code>NULL</code>) corresponding to <code>PAA_number</code> argument. </p>


<h3>Note</h3>

<p>SAX has been used recently to search similar times series in a
soundcape data base (Kasten et al., 2012).</p>


<h3>Author(s)</h3>

<p>Laurent Lellouch. An improvement added by Pavel Senin.</p>


<h3>References</h3>

<p>Kasten, E.P., Gage, S.H., Fox, J. &amp; Joo, W. (2012). The remote environmental assessment laboratory's acoustic library: an archive for studying soundscape ecology. <em>Ecological Informatics</em>, 12, 50 - 67.<br />
</p>
<p>Lin, J., Keogh, E., Lonardi, S., Chiu, B., June (2003). A symbolic representation of time series
with implications for streaming algorithms. Proceedings of the 8th ACM SIGMOD Workshop on Research Issues in Data Mining and Knowledge Discovery. San Diego, California, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrets">discrets</a></code>, <code><a href="#topic+symba">symba</a></code>, <code><a href="#topic+soundscapespec">soundscapespec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
spec &lt;- soundscapespec(tico, plot=FALSE)[,2]
SAX(spec, alphabet = 5, PAA = 10)

# change breakpoints
SAX(spec,  alphabet = 5, PAA = 10, breakpoints="quantiles")
SAX(spec,  alphabet = 5, PAA = 10, breakpoints=c(0, 0.5, 0.75, 1))
SAX(spec,  alphabet = 5, PAA = 10, breakpoints=c(0, 0.33, 0.66, 1))

# different output formats
SAX(spec,  alphabet = 5, PAA = 10, collapse="")
SAX(spec,  alphabet = 5, PAA = 10, collapse="-")
</code></pre>

<hr>
<h2 id='scd'>Soundcape chord diagram</h2><span id='topic+scd'></span>

<h3>Description</h3>

<p>Computes and displays a chord diagram of a set of audio
files or of a set segments extracted from a single audio file.</p>


<h3>Usage</h3>

<pre><code class='language-R'>scd(input, f,  sl, wl = 512, wn = "hanning", ovlp = 0, flim = NULL,
rmoffset = TRUE, threshold = NULL, HCA = TRUE,
grid.col = terrain.colors, names, plot = TRUE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scd_+3A_input">input</code></td>
<td>
<p>a character vector, either (i) the path to the directory where
.wav files are stored, (ii) directly the names of the .wav files to be
processed, or (iii) a single .wav file to be segmented by the
duration set with the argument <code>sl</code>.</p>
</td></tr>
<tr><td><code id="scd_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in the .wav files contained in <code>input</code>.</p>
</td></tr>  
<tr><td><code id="scd_+3A_sl">sl</code></td>
<td>
<p>segment length in duration if <code>input</code> is a single file.</p>
</td></tr>
<tr><td><code id="scd_+3A_wl">wl</code></td>
<td>
<p>window length for the analysis spectral
(even number of points) (by default = 512).</p>
</td></tr>
<tr><td><code id="scd_+3A_wn">wn</code></td>
<td>
<p>window name for the spectral analysis, see
<code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="scd_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in %) for the
spectral analysis.</p>
</td></tr>
<tr><td><code id="scd_+3A_flim">flim</code></td>
<td>
<p>a numeric vector of length 2 to select a frequency band
(in kHz).</p>
</td></tr>
<tr><td><code id="scd_+3A_rmoffset">rmoffset</code></td>
<td>
<p>a logical to sepcify whether DC offset should be
removed. By default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scd_+3A_threshold">threshold</code></td>
<td>
<p>a numeric value in ]0,1[ to be applied to the
similarity distance. All similairty distances below this threshold
will not depicted.</p>
</td></tr>
<tr><td><code id="scd_+3A_hca">HCA</code></td>
<td>
<p>logical, if <code>TRUE</code> the sectors are colored according
to clusters automatically obtained with a hierarchical cluster analysis (HCA).</p>
</td></tr>
<tr><td><code id="scd_+3A_grid.col">grid.col</code></td>
<td>
<p>name of color palette to color the sectors and
the links). By default <code>terrain.colors</code>.</p>
</td></tr>
<tr><td><code id="scd_+3A_names">names</code></td>
<td>
<p>names of the sectors, if empty then the names of the .wav
files or the time stamps of the segments.</p>
</td></tr>
<tr><td><code id="scd_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the chord diagram.</p>
</td></tr>
<tr><td><code id="scd_+3A_verbose">verbose</code></td>
<td>
<p>logical, if <code>TRUE</code> prints the computation progress
of the mean spectra.</p>
</td></tr>
<tr><td><code id="scd_+3A_...">...</code></td>
<td>
<p>other <code>chordDiagram</code> parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The soundscape chord diagram (SCD) aims at representing similarities
between audio files or audio segments extracted from a single audio file. The
mean frequency spectrum of each file/segment is computed using a
STFT. These frequency spectra are then (1) pairwised compared using a
similarity distance (see function <code><a href="#topic+diffcumspec">diffcumspec</a></code>, and (2)
automatically clustered with a hierarchical cluster analysis (HCA) (see function
<code>HCPC</code> of <code>FactoMiner</code>). The
resulting similarity matrix is then given as an input to the function
<code>chordDiagram</code>. The width of the sectors and the links are
based on the spectral similarity matrix. The color of the sectors and the links
follow the HCA classification.
</p>


<h3>Value</h3>

<p>THe function returns a list of two items:
</p>
<table>
<tr><td><code>m</code></td>
<td>
<p>spectral similarity matrix</p>
</td></tr>
<tr><td><code>resHCA</code></td>
<td>
<p>the classification result of the HCA, if <code>HCA</code> is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function call the function <code>HCPC</code> of the package
<code>FactoMineR</code> and the function <code>chordDiagram</code> of the
package <code>circlize</code>.
</p>


<h3>Author(s)</h3>

<p>Adèle de Baudouin, Jérôme Sueur</p>


<h3>References</h3>

<p>de Baudouin, A, Couprie P, Michaud F, Haupert S, Sueur J &ndash;
Similarity visualization of nature and music soundscapes, in prep.</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffcumspec">diffcumspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## 1 ##
# if 'dir' contains a set of files recorded with a Wildlife Acoustics
# songmeter recorder or an Audiomoth  then a direct way to obtain
# the soundscape chord diagram (SCD)  of all .wav files is
dir &lt;- "pathway-to-directory-containing-wav-files"
scd(dir)
# to change the STFT parameters used to obtain each mean spectrum
lts(dir, wl=1024, wn="hamming", ovlp=50)
# to select only high similarities, here above 0.6
scd(dir, threshold=0.6)
# to change the colors
scd(dir, grid.col=colorRampPalette(c("darkblue", "yellow", "grey")))
# to name manually the sectors
scd(dir, names=as.character(0:23))
# to name automatically the sectors from the name of songmeter files
# here according to hour of recording 
scd(dir, names=as.character(songmeter(files)$hour))  

## 2 ##
# to directly use files names stored in the working directory
files &lt;- c("S4A09154_20190213_150000.wav", "S4A09154_20190213_153000.wav",
"S4A09154_20190213_160000.wav", "S4A09154_20190213_163000.wav",
"S4A09154_20190213_170000.wav", "S4A09154_20190213_173000.wav",
"S4A09154_20190213_180000.wav", "S4A09154_20190213_183000.wav",
"S4A09154_20190213_190000.wav", "S4A09154_20190213_193000.wav")
scd(files)

## 3 ##
# to  use of single files which is segmented in successive time segments
# lasting each 60 s
file &lt;- "a-very-nice-soundscape.wav")
scd(file, sl = 60)

## End(Not run)

</code></pre>

<hr>
<h2 id='sddB'>Standard deviation of dB values</h2><span id='topic+sddB'></span>

<h3>Description</h3>

<p>This function estimates the standard deviation of dB values</p>


<h3>Usage</h3>

<pre><code class='language-R'>sddB(x, level = "IL")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sddB_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="sddB_+3A_level">level</code></td>
<td>
<p>intensity level (<code>"IL"</code>) or sound pressure level (<code>"SPL"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard deviation of dB values is not linear. The function
is an estimation not an exact computation which is not possible.</p>


<h3>Value</h3>

<p>A numeric vector of length 1.</p>


<h3>Author(s)</h3>

<p>Jérôme Sueur</p>


<h3>References</h3>

<p>Wikipedia, <a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty">https://en.wikipedia.org/wiki/Propagation_of_uncertainty</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+meandB">meandB</a></code>, <code><a href="#topic+moredB">moredB</a></code>,
<code><a href="#topic+convSPL">convSPL</a></code>, <code><a href="#topic+dBweight">dBweight</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>sddB(c(89,90,95))
sddB(c(89,90,95), level="SPL")
</code></pre>

<hr>
<h2 id='seedata'>A quick look at quantitative data</h2><span id='topic+seedata'></span>

<h3>Description</h3>

<p>See quantitative data at a glance</p>


<h3>Usage</h3>

<pre><code class='language-R'>seedata(data, na.rm = FALSE, col = "grey")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seedata_+3A_data">data</code></td>
<td>
<p>a numeric vector describing quantitative data.</p>
</td></tr>
<tr><td><code id="seedata_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, if <code>TRUE</code> removes <code>NA</code>.</p>
</td></tr>
<tr><td><code id="seedata_+3A_col">col</code></td>
<td>
<p>main color.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The red curves depict the corresponding Normal law (same mean and sd as <code>data</code>).</p>


<h3>Value</h3>

<p>A multi-plot graphic is returned.</p>


<h3>Author(s)</h3>

<p>Caroline Simonis <a href="mailto:csimonis@mnhn.fr">csimonis@mnhn.fr</a> and Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>seedata(rnorm(1000))</code></pre>

<hr>
<h2 id='seewave'>Sound analysis and synthesis</h2><span id='topic+seewave-package'></span><span id='topic+seewave'></span>

<h3>Description</h3>

<p>seewave provides functions for analysing, manipulating, displaying, editing and synthesizing time waves (particularly sound). This package processes in particular time analysis (oscillograms and envelopes), spectral content, resonance quality factor, entropy, cross correlation and autocorrelation, zero-crossing, frequency coherence, dominant frequency, analytic signal, 2D and 3D spectrograms.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> seewave</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 2.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2023-10-15</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL version 2 or newer</td>
</tr>
<tr>
 <td style="text-align: left;">
    Contributors : </td><td style="text-align: left;"> Pierre Aumond, Ethan C. Brown,</td>
</tr>
<tr>
 <td style="text-align: left;">
                   </td><td style="text-align: left;"> Adèle de Baudouin, </td>
</tr>
<tr>
 <td style="text-align: left;">
                   </td><td style="text-align: left;"> Guillaume Corbeau, Camille Desjonqueres, </td>
</tr>
<tr>
 <td style="text-align: left;">
                   </td><td style="text-align: left;"> Marion Depraetere, Francois Fabianek, </td>
</tr>
<tr>
 <td style="text-align: left;">
                   </td><td style="text-align: left;"> Amandine Gasc, Sylvain Haupert, </td>
</tr>
<tr>
 <td style="text-align: left;">
		   </td><td style="text-align: left;"> Eric Kasten, Laurent Lellouch,</td>
</tr>
<tr>
 <td style="text-align: left;">
		   </td><td style="text-align: left;"> Stefanie LaZerte, Jonathan Lees, </td>
</tr>
<tr>
 <td style="text-align: left;">
		   </td><td style="text-align: left;"> Jean Marchal, Thibaut Marin-Cudraz, </td>
</tr>
<tr>
 <td style="text-align: left;">
		   </td><td style="text-align: left;"> Andre Mikulec, Sandrine Pavoine, </td>
</tr>
<tr>
 <td style="text-align: left;">
		   </td><td style="text-align: left;"> David Pinaud, Luis J. Villanueva-Rivera </td>
</tr>
<tr>
 <td style="text-align: left;">
		   </td><td style="text-align: left;"> Zev Ross, Carl G. Witthoft, </td>
</tr>
<tr>
 <td style="text-align: left;">
		   </td><td style="text-align: left;"> Hristo Zhivomirov </td>
</tr>
<tr>
 <td style="text-align: left;">
    Acknowledgments: </td><td style="text-align: left;"> Marianna Anichini, Andrey Anikin, Michel Baylac,</td>
</tr>
<tr>
 <td style="text-align: left;">
		     </td><td style="text-align: left;"> Charlotte Cure, Denis Dupeyron,</td>
</tr>
<tr>
 <td style="text-align: left;">
                     </td><td style="text-align: left;"> Kurt Fristrup, Arnold Fertin, </td>
</tr>
<tr>
 <td style="text-align: left;">
		     </td><td style="text-align: left;"> Sylvain Haupert, Kurt Hornik, </td>
</tr>
<tr>
 <td style="text-align: left;">
		     </td><td style="text-align: left;"> Yannick Jadoul, Emiliano A. Laca,  </td>
</tr>
<tr>
 <td style="text-align: left;">
		     </td><td style="text-align: left;"> Uwe Ligges, Duncan Murdoch, Morgane Papin, </td>
</tr>
<tr>
 <td style="text-align: left;">
		     </td><td style="text-align: left;"> Emmanuel Paradis, Daniel Ridley-Ellis, </td>
</tr>
<tr>
 <td style="text-align: left;">
		     </td><td style="text-align: left;"> Brian Ripley, Jesse Ross, </td>
</tr>
<tr>
 <td style="text-align: left;">
		     </td><td style="text-align: left;"> Zev Ross, Pavel Senin, David Savage, </td>
</tr>
<tr>
 <td style="text-align: left;">
		     </td><td style="text-align: left;"> Arvind Sowmyan, Simon Urbanek </td>
</tr>
<tr>
 <td style="text-align: left;">
		     </td><td style="text-align: left;"> Maria A. Wis, George Zhang </td>
</tr>
<tr>
 <td style="text-align: left;">
    Webpage: </td><td style="text-align: left;"> <a href="https://rug.mnhn.fr/seewave/">https://rug.mnhn.fr/seewave/</a></td>
</tr>
<tr>
 <td style="text-align: left;">
    Discussion group : </td><td style="text-align: left;"> <a href="https://groups.google.com/g/seewave">https://groups.google.com/g/seewave</a></td>
</tr>
<tr>
 <td style="text-align: left;">
    Source reference: </td><td style="text-align: left;"> Sueur J, Aubin T, Simonis C (2008) - seewave: a free
    modular tool for sound analysis and synthesis.</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> Bioacoustics, 18: 213-226.</td>
</tr>
<tr>
 <td style="text-align: left;">
    Book: </td><td style="text-align: left;"> Sueur J (2018) - Sound analysis and synthesis with R. Springer.
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Jerome Sueur &lt;sueur@mnhn.fr&gt;<br /> 
Thierry Aubin<br />
Caroline Simonis<br />
Maintainer: Jerome Sueur &lt;sueur@mnhn.fr&gt;<br />
</p>

<hr>
<h2 id='seewave-internal'>Internal Seewave Functions</h2><span id='topic+aux'></span><span id='topic+bartlett.w'></span><span id='topic+blackman.w'></span><span id='topic+cunwrap'></span><span id='topic+filled.contour.modif2'></span><span id='topic+flattop.w'></span><span id='topic+gaussian.w'></span><span id='topic+hamming.w'></span><span id='topic+hanning.w'></span><span id='topic+inputw'></span><span id='topic+outputw'></span><span id='topic+pressure2dBSPL'></span><span id='topic+pressure2leq'></span><span id='topic+rectangle.w'></span><span id='topic+rescale'></span><span id='topic+reverse.cm.colors'></span><span id='topic+reverse.gray.colors.1'></span><span id='topic+reverse.gray.colors.2'></span><span id='topic+reverse.heat.colors'></span><span id='topic+reverse.terrain.colors'></span><span id='topic+reverse.topo.colors'></span><span id='topic+sumsmooth'></span><span id='topic+soscillo'></span><span id='topic+sspectro'></span><span id='topic+spectro.colors'></span><span id='topic+stdft'></span><span id='topic+stft'></span><span id='topic+synth0'></span><span id='topic+temp.colors'></span><span id='topic+unwrap'></span><span id='topic+volt2pressure'></span><span id='topic+wav2pressure'></span><span id='topic+wav2volt'></span>

<h3>Description</h3>

<p>Internal seewave functions.
</p>


<h3>Note</h3>

<p>These functions are not to be called by the user.
</p>

<hr>
<h2 id='setenv'>Set the amplitude envelope of a time wave to another one</h2><span id='topic+setenv'></span>

<h3>Description</h3>

<p>This function sets the amplitude envelope of a time wave
to another one</p>


<h3>Usage</h3>

<pre><code class='language-R'>setenv(wave1, wave2, f, channel = c(1,1), envt="hil", msmooth = NULL, ksmooth = NULL,
plot = FALSE, listen = FALSE, output = "matrix", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setenv_+3A_wave1">wave1</code></td>
<td>
<p>a first R object.</p>
</td></tr>     
<tr><td><code id="setenv_+3A_wave2">wave2</code></td>
<td>
<p>a second R object.</p>
</td></tr>
<tr><td><code id="setenv_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="setenv_+3A_channel">channel</code></td>
<td>
<p>channel of the R objects, by default left channel (1)
for each object.</p>
</td></tr>  
<tr><td><code id="setenv_+3A_envt">envt</code></td>
<td>
<p>the type of envelope to be used for <code>wave2</code>: either &quot;abs&quot; for absolute
amplitude envelope or &quot;hil&quot; for Hilbert amplitude envelope. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="setenv_+3A_msmooth">msmooth</code></td>
<td>
<p>a vector of length 2 to smooth the amplitude envelope of <code>wave2</code> 
with a mean sliding window. The first component is the window length
(in number of points). The second component is the overlap between
successive windows (in %). See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="setenv_+3A_ksmooth">ksmooth</code></td>
<td>
<p>kernel smooth via <code><a href="stats.html#topic+kernel">kernel</a></code> to apply
to the amplitude envelope of<code>wave2</code>. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="setenv_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> returns the oscillogram
of the new time wave (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="setenv_+3A_listen">listen</code></td>
<td>
<p>if <code>TRUE</code> the new sound is played back.</p>
</td></tr>
<tr><td><code id="setenv_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="setenv_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>wave1</code> and <code>wave2</code> can have different duration (length)<br />
Smoothing the envelope with <code>smooth</code> or <code>ksmooth</code> can significantly
change the value returned.</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+drawenv">drawenv</a></code>, <code><a href="#topic+env">env</a></code>, <code><a href="#topic+synth">synth</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
a&lt;-synth(d=1,f=22050,cf=1000)
# apply 'tico' ammplitude envelope to 'a' that has a square amplitude envelope
setenv(a,tico,f=22050,plot=TRUE)
# the same but with smoothing the envelope
setenv(a,tico,f=22050,ksmooth=kernel("daniell",50),plot=TRUE)
</code></pre>

<hr>
<h2 id='sfm'>Spectral Flatness Measure</h2><span id='topic+sfm'></span>

<h3>Description</h3>

<p>This function estimates the flatness of a frequency spectrum.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfm(spec)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfm_+3A_spec">spec</code></td>
<td>
<p>a data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB).</p>
</td></tr></table>


<h3>Details</h3>

<p>SFM is calculated as the ratio between the geometric mean and the
arithmetic mean :<br />
</p>
<p style="text-align: center;"><code class="reqn">F = N\times{\frac{\sqrt[N]{\prod_{i=1}^N{y_i}}}{\sum_{i=1}^N{y_i}}}</code>
</p>

<p>with:<br />
<em>y</em> = relative amplitude of the <em>i</em> frequency,<br />
and <em>N</em> = number of frequencies.
</p>


<h3>Value</h3>

<p>A single value varying between 0 and 1 is returned.
The value has no unit.</p>


<h3>Note</h3>

<p>The SFM of a noisy signal will tend towards 1 whereas
the SFM of a pure tone signal will tend towards 0.<br />
See <code><a href="#topic+sh">sh</a></code> for another measure of signal noisiness/pureness.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sh">sh</a></code>, <code><a href="#topic+csh">csh</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-synth(f=8000,d=1,cf=2000,plot=FALSE)
speca&lt;-spec(a,f=8000,at=0.5,plot=FALSE)
sfm(speca)
# [1] 0
b&lt;-noisew(d=1,f=8000)
specb&lt;-spec(b,f=8000,at=0.5,plot=FALSE)
sfm(specb)
# [1] 0.8233202
</code></pre>

<hr>
<h2 id='sh'>Shannon and Renyi spectral entropy</h2><span id='topic+sh'></span>

<h3>Description</h3>

<p>This function computes the Shannon or Renyi entropy of a frequency
spectrum</p>


<h3>Usage</h3>

<pre><code class='language-R'>sh(spec, alpha = "shannon")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sh_+3A_spec">spec</code></td>
<td>
<p>a data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB).</p>
</td></tr>
<tr><td><code id="sh_+3A_alpha">alpha</code></td>
<td>
<p>a character string, by default <code>"shannon"</code> to compute Shannon
entropy, <code>"simpson"</code> to compute Simpson entropy otherwise a
numeric vector of length 1 with a value superior to 0 but
different to 1 to compute Renyi entropy. See the examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>. Shannon spectral entropy is calculated according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">S = -\frac{\sum_{i = 1}^{N} y_i log_2(y_i)}{log_2(N)}</code>
</p>

<p>. Simpson or Gini-Simpson spectral entropy (or index) is computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">GS = 1 - \sum_{i=1}^{N} y_{i}^2</code>
</p>

<p>. Renyi spectral entropy of order alpha is calucalted according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">R = \frac{1}{1-\alpha} \times log_2(\sum_{i = 1}^{N} y_{i}^{\alpha})</code>
</p>

<p>with </p>
<p style="text-align: center;"><code class="reqn">\alpha \geq 0</code>
</p>

<p style="text-align: center;"><code class="reqn">\alpha \neq 1</code>
</p>

<p><em>y</em> = relative amplitude of the <em>i</em> frequency,<br />
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i = 1}^{N} y_i = 1</code>
</p>
<p><br /> 
and <em>N</em> = number of frequencies.<br />
</p>


<h3>Value</h3>

<p>A numeric vector of length 1 is returned.
The value has no unit.</p>


<h3>Note</h3>

<p>The Shannon entropy scaled between 0 and 1 is also known as Pielou's evenness index</p>


<h3>Note</h3>

<p>The Shannon spectral entropy of a noisy signal will tend towards 1 whereas
the Shannon spectral entropy of a pure tone signal will tend towards
0. See Han <em>et al</em>. for details regarding the Renyi entropy.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur and Laurent Lellouch</p>


<h3>References</h3>

<p>Han, NC, Muniandy SV, Dayou J (2011) Acoustic classification of
Australian anurans based on hybrid spectral-entropy approach.  <em>Applied
Acoustics</em>. <br />
</p>
<p>Nunes RR, Almeida de MP, Sleigh JW (2004) -
Spectral entropy: a new method for anesthetic adequacy.
<em>Revista Brasileira de Anestesiologia</em>, <b>54</b>, 413-422.<br />
</p>
<p>Renyi A (1961) - On measures of information and entropy. Proceedings
of the 4th Berkeley Symposium on Mathematics, Statistics and
Probability 1960. pp. 547-561.<br />
</p>
<p>Simpson EH (1949) - Measurement of diversity. <em>Nature</em>, <b>163</b>, 688.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csh">csh</a></code>,<code><a href="#topic+th">th</a></code>, <code><a href="#topic+H">H</a></code>, <code><a href="#topic+sfm">sfm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-synth(f=8000,d=1,cf=2000,plot=FALSE)
speca&lt;-spec(a,f=8000,at=0.5,plot=FALSE)
## Shannon spectral entropy
sh(speca)
# [1] 0.2336412
b&lt;-noisew(d=1,f=8000)
specb&lt;-spec(b,f=8000,at=0.5,plot=FALSE)
sh(specb)
# close to 1
## Renyi spectral entropy
sh(speca, alpha=2)
sh(speca, alpha=3)
</code></pre>

<hr>
<h2 id='sheep'>Sheep bleat</h2><span id='topic+sheep'></span>

<h3>Description</h3>

<p>Recording of a sheep bleat.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sheep)</code></pre>


<h3>Format</h3>

<p>A Wave object.</p>


<h3>Details</h3>

<p>Duration = 2.47 s. Sampling frequency = 8000 hz.
</p>


<h3>Source</h3>

<p>Recording by Frederic Sebe.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sheep)
oscillo(sheep,f=8000)
</code></pre>

<hr>
<h2 id='simspec'>Similarity between two frequency spectra</h2><span id='topic+simspec'></span>

<h3>Description</h3>

<p>This function estimates the similarity between
two frequency spectra.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simspec(spec1, spec2, f = NULL, mel = FALSE,
norm = FALSE, PMF = FALSE,
plot = FALSE, type = "l",
lty =c(1, 2, 3), col = c(2, 4, 1),
flab = NULL, alab = "Amplitude (percentage)",
flim = NULL, alim = NULL,
title = TRUE, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simspec_+3A_spec1">spec1</code></td>
<td>
<p>a first data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This
can be either a two-column matrix (col1 = frequency, col2 = amplitude)
or a vector (amplitude).</p>
</td></tr>
<tr><td><code id="simspec_+3A_spec2">spec2</code></td>
<td>
<p>a first data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB). This
can be either a two-column matrix (col1 = frequency, col2 = amplitude)
or a vector (amplitude).</p>
</td></tr>
<tr><td><code id="simspec_+3A_f">f</code></td>
<td>
<p>sampling frequency of waves used to obtain <code>spec1</code>
and <code>spec2</code> (in Hz). Not necessary if <code>spec1</code> and/or <code>spec2</code>
is a two columns matrix obtained with <code><a href="#topic+spec">spec</a></code>
or <code><a href="#topic+meanspec">meanspec</a></code>.</p>
</td></tr>
<tr><td><code id="simspec_+3A_mel">mel</code></td>
<td>
<p>a logical, if <code>TRUE</code> the (htk-)mel scale is used.</p>
</td></tr>  
<tr><td><code id="simspec_+3A_norm">norm</code></td>
<td>
<p>a logical, if <code>TRUE</code> <code>spec1</code> and <code>spec2</code>
are normalised (scaled) between 0 and 1.</p>
</td></tr>
<tr><td><code id="simspec_+3A_pmf">PMF</code></td>
<td>
<p>a logical, if <code>TRUE</code> <code>spec1</code> and <code>spec2</code> are
transformed into probability mass functions.</p>
</td></tr>
<tr><td><code id="simspec_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots both spectra and similarity function 
(by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="simspec_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="simspec_+3A_lty">lty</code></td>
<td>
<p>a vector of length 3 for the line type of <code>spec1</code>,
<code>spec2</code> and  of the similarity function if <code>type</code>=&quot;l&quot;.</p>
</td></tr>
<tr><td><code id="simspec_+3A_col">col</code></td>
<td>
<p>a vector of length 3 for the colour of <code>spec1</code>,
<code>spec2</code>, and the similarity function.</p>
</td></tr>
<tr><td><code id="simspec_+3A_flab">flab</code></td>
<td>
<p>title of the frequency axis.</p>
</td></tr>
<tr><td><code id="simspec_+3A_alab">alab</code></td>
<td>
<p>title of the amplitude axis.</p>
</td></tr>
<tr><td><code id="simspec_+3A_flim">flim</code></td>
<td>
<p>the range of frequency values.</p>
</td></tr>
<tr><td><code id="simspec_+3A_alim">alim</code></td>
<td>
<p>range of amplitude axis.</p>
</td></tr>
<tr><td><code id="simspec_+3A_title">title</code></td>
<td>
<p>logical, if <code>TRUE</code>, adds a title with S value.</p>
</td></tr>
<tr><td><code id="simspec_+3A_legend">legend</code></td>
<td>
<p>logical, if <code>TRUE</code> adds a legend to the plot.</p>
</td></tr>
<tr><td><code id="simspec_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spectra similarity is assessed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">S = \frac{100/N} \times{\sum_{i=1}^N{\frac{\min{spec1(i),spec2(i)}}
        {\max{spec1(i),spec2(i)}}}}</code>
</p>

<p>with <em>S</em> in %.
</p>


<h3>Value</h3>

<p>The similarity index is returned. This value is in %.<br />
When <code>plot</code> is <code>TRUE</code>, both spectra and the similarity function are
plotted on the same graph. The similarity index is the mean of this function.
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, improved by Laurent Lellouch</p>


<h3>References</h3>

<p>Deecke, V. B. and Janik, V. M. 2006. Automated categorization of
bioacoustic signals: avoiding perceptual pitfalls. <em>Journal of the Acoustical
Society of America</em>, 119: 645-653.</p>


<h3>See Also</h3>

<p><code><a href="#topic+spec">spec</a></code>, <code><a href="#topic+meanspec">meanspec</a></code>, <code><a href="#topic+corspec">corspec</a></code>,
<code><a href="#topic+diffspec">diffspec</a></code>, <code><a href="#topic+diffenv">diffenv</a></code>,  <code><a href="#topic+kl.dist">kl.dist</a></code>,
<code><a href="#topic+ks.dist">ks.dist</a></code>, <code><a href="#topic+logspec.dist">logspec.dist</a></code>, <code><a href="#topic+itakura.dist">itakura.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-noisew(f=8000,d=1)
b&lt;-synth(f=8000,d=1,cf=2000)
c&lt;-synth(f=8000,d=1,cf=1000)
d&lt;-noisew(f=8000,d=1)
speca&lt;-spec(a,f=8000,at=0.5,plot=FALSE)
specb&lt;-spec(b,f=8000,at=0.5,plot=FALSE)
specc&lt;-spec(c,f=8000,at=0.5,plot=FALSE)
specd&lt;-spec(d,f=8000,at=0.5,plot=FALSE)
simspec(speca,speca)
simspec(speca,specb)
simspec(speca,specc,plot=TRUE)
simspec(specb,specc,plot=TRUE)
#[1] 12.05652
simspec(speca,specd,plot=TRUE)
## mel scale
require(tuneR)
data(orni)
data(tico)
orni.mel &lt;- melfcc(orni, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
orni.mel.mean &lt;- apply(orni.mel$aspectrum, MARGIN=2, FUN=mean)
tico.mel &lt;- melfcc(tico, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
tico.mel.mean &lt;- apply(tico.mel$aspectrum, MARGIN=2, FUN=mean)
simspec(orni.mel.mean, tico.mel.mean, f=22050, mel=TRUE, plot=TRUE)
</code></pre>

<hr>
<h2 id='smoothw'>A function to tentativily smooth a time wave</h2><span id='topic+smoothw'></span>

<h3>Description</h3>

<p>This function tries to smooth with a sum sliding window a time wave, and then to remove residual noise.</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothw(wave, f, channel = 1, wl, padding=TRUE, output = "matrix")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothw_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="smoothw_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="smoothw_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="smoothw_+3A_wl">wl</code></td>
<td>
<p>window length in number of points (samples).</p>
</td></tr>
<tr><td><code id="smoothw_+3A_padding">padding</code></td>
<td>
<p>a logical, if <code>TRUE</code> add 0 values at the start and
end of the file to match <code>wave</code> length (duration).</p>
</td></tr>
<tr><td><code id="smoothw_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return,
either <code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A window slides along the signal and sums up the sample
amplitude values. Zero values are added at the end of the wave to keep
wave length (duration).</p>


<h3>Value</h3>

<p>A new wave is returned. The class of the returned object is set
with the argument <code>output</code>. If <code>padding</code> is <code>TRUE</code>, the
new wave starts and ends up with <code>0</code> values to match the size of <code>wave</code>.</p>


<h3>Warning </h3>

<p>This function should be used with care as this kind of filter may change the frequency content of the sound. See the examples section for an illustration.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+fir">fir</a></code>, <code><a href="stats.html#topic+filter">filter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># An example to show that smoothw() may change
# the frequency content of your sound
data(orni)
orni2 &lt;- smoothw(orni, wl=2, out="Wave")
orni10 &lt;- smoothw(orni, wl=10, out="Wave")
orni50 &lt;- smoothw(orni, wl=50, out="Wave")
orni100 &lt;- smoothw(orni, wl=100, out="Wave")
meanspec(orni)
lines(meanspec(orni2, plot=FALSE), col=2)
lines(meanspec(orni10, plot=FALSE), col=3)
lines(meanspec(orni50, plot=FALSE), col=4)
lines(meanspec(orni100, plot=FALSE), col=5)
legend("topright", col=1:5, lty=1, legend=c("original","wl=2","wl=10","wl=50","wl=100"))
</code></pre>

<hr>
<h2 id='songmeter'>Reading and interpreting SongMeter file name</h2><span id='topic+songmeter'></span>

<h3>Description</h3>

<p>This function reads and decomposes the files names
generated by a SongMeter device,
audio digal recorders produced by the society Wildlife Acoustics.</p>


<h3>Usage</h3>

<pre><code class='language-R'>songmeter(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="songmeter_+3A_x">x</code></td>
<td>
<p>a character vector with file names, either <code>.wac</code> or
<code>.wav</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The digital recorder SongMeter (either SM2, SM3, or SM4 device model)
produced by the society 'Wildlife Acoustics'
(<a href="https://www.wildlifeacoustics.com/">https://www.wildlifeacoustics.com/</a>) generates '.wav' files
which names include useful information. Here are the
character format of the files:<br />
</p>

<ul>
<li><p><b>SM2 or SM4</b>: <code>PREFIX_YYYYMMDD_HHMMSS.wav</code>
</p>
</li>
<li><p><b>SM3</b>:
</p>

<ul>
<li><p><em>without geolocalisation</em> <code>PREFIX_XXX_YYYYMMDD_HHMMSS.wav</code>
</p>
</li>
<li><p><em>with geolocalisation</em> <code>PREFIX_XXX_YYYYMMDD$HHMMSS.wav</code>
</p>
</li></ul>


</li></ul>

<p>with:
</p>

<ul>
<li><p><code>PREFIX</code>: prefix set when programming the SongMeter
</p>
</li>
<li><p><code>XXX</code>: microphone information
</p>
</li>
<li><p><code>YYYY</code>: year
</p>
</li>
<li><p><code>MM</code>: month
</p>
</li>
<li><p><code>DD</code>: day
</p>
</li>
<li><p><code>HH</code>: hour
</p>
</li>
<li><p><code>MM</code>: month
</p>
</li>
<li><p><code>SS</code>: minute
</p>
</li></ul>

<p>This information is read and decomposed by the function
songmeter().<br />
Please note that the function does not read the content of audio file
but the name of the file.
</p>


<h3>Value</h3>

<p>The function returns a <code>data.frame</code> with the following
columns:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>device model, either &quot;SM2/SM4&quot; or &quot;SM3&quot;</p>
</td></tr>
<tr><td><code>prefix</code></td>
<td>
<p>prefix of the file, specifying for instance to
recording site</p>
</td></tr>
<tr><td><code>mic</code></td>
<td>
<p>microphone information specifying if the recording is mono left channel (&quot;monoL&quot;),
mono right (&quot;monoR&quot;) or stereo (&quot;stereo&quot;). This works for SM3
only, NA for SM2</p>
</td></tr>
<tr><td><code>year</code></td>
<td>
<p>year of recording, numeric</p>
</td></tr>
<tr><td><code>month</code></td>
<td>
<p>month of recording, numeric</p>
</td></tr>
<tr><td><code>day</code></td>
<td>
<p>day of recording, numeric</p>
</td></tr>
<tr><td><code>hour</code></td>
<td>
<p>hour of recording, numeric</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>minute of recording, numeric</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>second of recording, numeric</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time in <code>POSIX</code> format</p>
</td></tr>
<tr><td><code>geo</code></td>
<td>
<p>logical, <code>TRUE</code> if the device was GPS synchronized</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The file names of Songmeters may change with time. There is no
guarantee that the function will be updated on time.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>See Wildlife Acoustics website for details regarding the
SongMeters 2, 3 and 4: <a href="https://www.wildlifeacoustics.com/">https://www.wildlifeacoustics.com/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+songmeterdiag">songmeterdiag</a></code>, <code><a href="#topic+audiomoth">audiomoth</a></code>, <code><a href="base.html#topic+strptime">strptime</a></code> for the POSIX time format.</p>


<h3>Examples</h3>

<pre><code class='language-R'>file1 &lt;- "MNHN_20141225_234500.wav"      # SM2 file
file2 &lt;- "CNRS_0+1_20130824_153000.wav"  # SM3 file without geolocalisation
file3 &lt;- "PARIS_-0-_20150410$195550.wav" # SM3 file with geolocalisation
file4 &lt;- "MNHN_20141225_234500.txt"      # not a .wav or a .wac file
file5 &lt;- "myfile.wav"                    # not a Wildlife Acoustics filename
files &lt;- c(file1, file2, file3, file4, file5)
songmeter(files)
</code></pre>

<hr>
<h2 id='songmeterdiag'>Songmeter file diagnostics and diagram</h2><span id='topic+songmeterdiag'></span>

<h3>Description</h3>

<p>This function looks for files generated by a SongMeter device (audio
digal recorders produced by the society Wildlife Acoustics) and checks
for possible missing or small files according to a predefined recording schedule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>songmeterdiag(dir, start, end, frequency,
pch.exi = 1, pch.mis = 19,
col.exi = 1, col.mis = 2,
cex.exi = NULL, cex.mis = 0.5,
limits = FALSE, output="file", plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="songmeterdiag_+3A_dir">dir</code></td>
<td>
<p>a character vector, path to directory(ies) where the .wav files are
stored. Typically a &quot;Data&quot; folder as generated by SongMeter devices.</p>
</td></tr>
<tr><td><code id="songmeterdiag_+3A_start">start</code></td>
<td>
<p>a character vector, start date/time of the recording schedule as programmed on the
SongMeter device, must be in the format &quot;year-month-day hour:minute:second&quot;.</p>
</td></tr>
<tr><td><code id="songmeterdiag_+3A_end">end</code></td>
<td>
<p>a character vector, end date/time of the recording schedule as programmed on the
SongMeter device, must be in the format &quot;year-month-day hour:minute:second&quot;.</p>
</td></tr>
<tr><td><code id="songmeterdiag_+3A_frequency">frequency</code></td>
<td>
<p>a numeric vector, frequency of the recording schedule expressed in minute.</p>
</td></tr>
<tr><td><code id="songmeterdiag_+3A_pch.exi">pch.exi</code></td>
<td>
<p>symbol for plotting the existing file(s).</p>
</td></tr>
<tr><td><code id="songmeterdiag_+3A_pch.mis">pch.mis</code></td>
<td>
<p>symbol for plotting the missing file(s)</p>
</td></tr>
<tr><td><code id="songmeterdiag_+3A_col.exi">col.exi</code></td>
<td>
<p>colour of the symbol for plotting the existing file(s).</p>
</td></tr>
<tr><td><code id="songmeterdiag_+3A_col.mis">col.mis</code></td>
<td>
<p>colour of the symbol for plotting the missing file(s).</p>
</td></tr>
<tr><td><code id="songmeterdiag_+3A_cex.exi">cex.exi</code></td>
<td>
<p>size of the symbol for plotting the existing file(s),
by default <code>NULL</code> so that the size of the symbol corresponds to
the size of the .wav file in Mb divided by the average size of all
.wav files found in the directory. If not NA then symbol size
as in <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="songmeterdiag_+3A_cex.mis">cex.mis</code></td>
<td>
<p>size of the symbol for plotting the missing file(s).</p>
</td></tr>
<tr><td><code id="songmeterdiag_+3A_limits">limits</code></td>
<td>
<p>a logical, if <code>TRUE</code> adds to the plot the limits
(start and end date/time) of the recording schedule as programmed on
the SongMeter device.</p>
</td></tr>
<tr><td><code id="songmeterdiag_+3A_output">output</code></td>
<td>
<p>a character vector of length 1, either &quot;file&quot; or &quot;time&quot;
to get the file name or the time slot in POSIXct format respectively.</p>
</td></tr>
<tr><td><code id="songmeterdiag_+3A_plot">plot</code></td>
<td>
<p>a logical, if <code>TRUE</code> plots a time plot indicating the
existing and missing files (by default <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works for a single or several directories so that the
operation of several SongMeters can be compared visually. This
function should be helpful to check quickly how the devices worked.
</p>


<h3>Value</h3>

<p>A character vector with the names of the missing files.</p>


<h3>Note</h3>

<p>The file names of Songmeters may change with time. There is no
guarantee that the function will be perfectly updated.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur and Sylvain Haupert</p>


<h3>References</h3>

<p>See Wildlife Acoustics website for details regarding the
SongMeters 2, 3 and 4: <a href="https://www.wildlifeacoustics.com/">https://www.wildlifeacoustics.com/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+songmeter">songmeter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##################
# simulated data
##################
# a recording schedule programmed on four SongMeters SM4
# named "S4A03895", "S4A03998", "S4A03536", and "S4A04430"
# starting the 1st of January 2019 at 00:00:00
# and stopping the 31st January 2019 at 23:30:00
# with a recording frequency of 30 minutes
# all directories stored in a single directory named "project" 
# recorder names
recorders &lt;- c("S4A03895", "S4A03998", "S4A03536", "S4A04430")
n &lt;- length(recorders)
# schedule as programmed on the devices
format &lt;- "
start &lt;- strptime("20190101_000000", format) 
end &lt;- strptime("20190131_233000", format)
schedule &lt;- seq(from=start, to=end, by=30*60)
schedule &lt;- paste(format(schedule, "
# directories and files
dir.create("project")
for(i in 1:n) {
dir.create(paste("project", recorders[i], sep="/"))
}
for(i in 1:n) {
file.create(paste("project", recorders[i],
paste(recorders[i], each=schedule, sep="_"), sep="/"))
}
# removing some files to simulate missing files
dirs &lt;- paste("project", recorders, sep="/")
file.remove(paste(dirs[1], dir(dirs[1])[200:500], sep="/"))

######################
# use of the function
######################
# directories where the .wav files are stored (as above)
dirs &lt;- paste("project", recorders, sep="/")
# function call with a plot, cex.exi is here specify because we deal
# with ghost files (the .wav file are not truly created)
res &lt;- songmeterdiag(dirs,
                     start="2019-01-01 00:00:00", end="2019-01-31 23:30:00", frequency=30,
                     cex.exi=1,  plot=TRUE)
# clear out
unlink("project", recursive=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='soundscapespec'>Soundscape frequency spectrum of a time wave</h2><span id='topic+soundscapespec'></span>

<h3>Description</h3>

<p>This function returns a kHz binned spectrum as described by Kasten et
al. (2012) for the description of a soundscape.</p>


<h3>Usage</h3>

<pre><code class='language-R'>soundscapespec(wave, f, channel = 1, wl = 1024, wn = "hamming", ovlp = 50,
plot = TRUE, xlab = "Frequency (kHz)", ylim = c(0, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soundscapespec_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="soundscapespec_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="soundscapespec_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="soundscapespec_+3A_wl">wl</code></td>
<td>
<p>length of the window for the analysis (even number of points, by default = 1024).</p>
</td></tr>
<tr><td><code id="soundscapespec_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hamming"</code>).</p>
</td></tr>
<tr><td><code id="soundscapespec_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive analysis windows (in %),
by default = 50%.</p>
</td></tr>
<tr><td><code id="soundscapespec_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> returns a barplot.</p>
</td></tr>
<tr><td><code id="soundscapespec_+3A_xlab">xlab</code></td>
<td>
<p>title of the barplot x axis.</p>
</td></tr>
<tr><td><code id="soundscapespec_+3A_ylim">ylim</code></td>
<td>
<p>range of the barplot y axis.</p>
</td></tr>
<tr><td><code id="soundscapespec_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+barplot">barplot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The soundscape frequency spectrum is based on the computation of a spectrogram power
spectral density using Welch'smethod (Welch &amp; June, 1967). Parameters used in
Kasten et al. (2012) were a Hamming window of 1024 samples with 50% of overlap and are used here as default values.</p>


<h3>Value</h3>

<p>A two-column numeric matrix, the first column returning the
frequency (kHz) bands and the second column returning the power
value within each frequency band.<br />
A barplot is returned when <code>plot</code> is <code>TRUE</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur and Eric Kasten</p>


<h3>References</h3>

<p>Kasten, E.P., Gage, S.H., Fox, J. &amp; Joo, W. (2012). The remote
environmental assessment laboratory's acoustic library: an archive for
studying soundscape ecology. <em>Ecological Informatics</em>, 12, 50-67.<br />
Welch, P.D., June (1967). The use of the fast Fourier transform for the estimation
of power spectra: a method based on time-averaging over short, modified
periodograms. <em>IEEE Transactions on Audio and Electroacoustics</em>, 15: 70-73.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spec">spec</a></code>, <code><a href="#topic+meanspec">meanspec</a></code>, <code><a href="#topic+SAX">SAX</a></code>, <code><a href="#topic+NDSI">NDSI</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Note that 'tico' is not a soundscape recording...
data(tico)
soundscapespec(tico, plot=TRUE, col="darkgreen")
</code></pre>

<hr>
<h2 id='sox'>Calls SoX</h2><span id='topic+sox'></span>

<h3>Description</h3>

<p>This function calls SoX, the Swiss Army knife of sound processing programs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sox(command, exename = NULL, path2exe = NULL, option = NULL,
shQuote_type = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sox_+3A_command">command</code></td>
<td>
<p>the SoX command to invoke.</p>
</td></tr>
<tr><td><code id="sox_+3A_exename">exename</code></td>
<td>
<p>a character string specifying the name of the SoX binary file. If <code>NULL</code>, the default name &quot;sox&quot; will be used for Linux OS.</p>
</td></tr>
<tr><td><code id="sox_+3A_path2exe">path2exe</code></td>
<td>
<p>a character string giving the path to the SoX binary
file</p>
</td></tr>
</table>
<p>g  </p>
<table>
<tr><td><code id="sox_+3A_option">option</code></td>
<td>
<p>option to be passed to the SoX command</p>
</td></tr>
<tr><td><code id="sox_+3A_shquote_type">shQuote_type</code></td>
<td>
<p>type of shell quotes (&quot;cmd&quot; or &quot;cmd2&quot;, for Windows
OS; &quot;sh&quot; or &quot;csh&quot; Unix OS)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the documentation of SoX for proper use.</p>


<h3>Note</h3>

<p>Sox must be installed to use this function but not to install the
package <code>seewave</code>. As mentioned on the SoX webpage, the primary development
platform is Linux. Using SoX with Windows from <span class="rlang"><b>R</b></span> might not be
straightforward. In particular, it is advisable to pay attention to file path and exe name.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, Stefanie LaZerte, Andre Mikulec</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/SoX">https://en.wikipedia.org/wiki/SoX</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##########
## data ##
##########
## Generate a simple sound file at 440 Hz
s &lt;- synth(cf=440, f=8000, d=1, fm=c(0,0,1000,0,0), output="Wave")
savewav(s, file="mysound.wav")
##############
## Linux OS ##
##############
## Play the file
sox("mysound.wav", exename="play")
## Slow down  the  audio  tempo  (but  not  its  pitch)
sox("mysound.wav myslowsound.wav tempo 0.5")
## Cut the file
sox("myslowsound.wav myslowcutsound.wav trim 0.25 0.75")
################
## Windows OS ##
################
## path with simple slash
path &lt;- "C:/Program Files (x86)/sox-14-4-2"
## or path with double backslash
## path &lt;- "C:\Program Files (x86)\sox-14-4-2"
sox("mysound.wav", path2exe=path, option="-t waveaudio")
## with the option directly passed to the command 
sox("mysound.wav -t waveaudio", path2exe=path)
## Slow down  the  audio  tempo  (but  not  its  pitch)
sox("mysound.wav myslowsound.wav tempo 0.5", path2exe=path)
## Cut the file
sox("myslowsound.wav myslowcutsound.wav trim 0.25 0.75", path2exe=path)
###########
## clean ##
###########
file.remove("mysound.wav", "myslowsound.wav", "myslowcutsound.wav")

## End(Not run)
</code></pre>

<hr>
<h2 id='spec'>Frequency spectrum of a time wave</h2><span id='topic+spec'></span>

<h3>Description</h3>

<p>This function returns the frequency spectrum (<em>i.e.</em> the relative amplitude of the
frequency content) of a time wave. Results can be obtained either as absolute 
or dB data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec(wave, f, channel = 1, wl = 512, wn = "hanning", fftw = FALSE, norm = TRUE,
scaled = FALSE, PSD = FALSE, PMF = FALSE, correction="none", dB = NULL, dBref = NULL,
at = NULL, from = NULL, to = NULL,
identify = FALSE, col = "black", cex = 1,
plot = 1, flab = "Frequency (kHz)",
alab = "Amplitude", flim = NULL,
alim = NULL, type="l",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="spec_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="spec_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="spec_+3A_wl">wl</code></td>
<td>
<p>if <code>at</code> is not null, length of the window for the analysis
(by default = 512).</p>
</td></tr>
<tr><td><code id="spec_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default
<code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="spec_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code> for faster computation. See Notes of the function <code><a href="#topic+spectro">spectro</a></code>.</p>
</td></tr>
<tr><td><code id="spec_+3A_norm">norm</code></td>
<td>
<p>if <code>TRUE</code> the spectrum is normalised by
its maximum.</p>
</td></tr>
<tr><td><code id="spec_+3A_scaled">scaled</code></td>
<td>
<p>if <code>TRUE</code> the spectrum is scaled by the length of
the FFT.</p>
</td></tr>
<tr><td><code id="spec_+3A_psd">PSD</code></td>
<td>
<p>if <code>TRUE</code> return Power Spectrum Density,
<em>i. e.</em> the square of the spectrum.</p>
</td></tr>  
<tr><td><code id="spec_+3A_pmf">PMF</code></td>
<td>
<p>if <code>TRUE</code> return Probability Mass Function,
<em>i. e.</em> the probability distribution of frequencies.</p>
</td></tr>
<tr><td><code id="spec_+3A_correction">correction</code></td>
<td>
<p>a character vector of length 1 to apply an
amplitude (&quot;amplitude&quot;) or an energy (&quot;energy&quot;) correction
to the FT window. This argument is useful only when one wish to obtain
absolute values that is when <code>norm=FALSE</code>, <code>scaled=FALSE</code>,
and <code>PMF=FALSE</code>. By default no correction is applied (&quot;none&quot;).</p>
</td></tr>  
<tr><td><code id="spec_+3A_db">dB</code></td>
<td>
<p>a character string specifying the type dB to return: &quot;max0&quot; for a
maximum dB value at 0, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, and &quot;ITU&quot; for common dB weights.</p>
</td></tr>
<tr><td><code id="spec_+3A_dbref">dBref</code></td>
<td>
<p>a dB reference value when <code>dB</code> is not <code>NULL</code>. <code>NULL</code> by default
but should be set to 2*10e-5 for a 20 microPa reference (SPL).</p>
</td></tr>
<tr><td><code id="spec_+3A_at">at</code></td>
<td>
<p>position where to compute the spectrum (in s).</p>
</td></tr>
<tr><td><code id="spec_+3A_from">from</code></td>
<td>
<p>start mark where  to compute the spectrum (in s).</p>
</td></tr>
<tr><td><code id="spec_+3A_to">to</code></td>
<td>
<p>end mark where to compute the spectrum (in s).</p>
</td></tr>
<tr><td><code id="spec_+3A_identify">identify</code></td>
<td>
<p>to identify frequency and amplitude values on the plot
with the help of a cursor.</p>
</td></tr>
<tr><td><code id="spec_+3A_col">col</code></td>
<td>
<p>colour of the spectrum.</p>
</td></tr>
<tr><td><code id="spec_+3A_cex">cex</code></td>
<td>
<p>pitch size of the spectrum.</p>
</td></tr>
<tr><td><code id="spec_+3A_plot">plot</code></td>
<td>
<p>if <code>1</code> returns frequency on x-axis, if <code>2</code> returns 
frequency on y-axis, (by default <code>1</code>).</p>
</td></tr>
<tr><td><code id="spec_+3A_flab">flab</code></td>
<td>
<p>title of the frequency axis.</p>
</td></tr>
<tr><td><code id="spec_+3A_alab">alab</code></td>
<td>
<p>title of the amplitude axis.</p>
</td></tr>
<tr><td><code id="spec_+3A_flim">flim</code></td>
<td>
<p>range of frequency axis.</p>
</td></tr>
<tr><td><code id="spec_+3A_alim">alim</code></td>
<td>
<p>range of amplitude axis.</p>
</td></tr>
<tr><td><code id="spec_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="spec_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>at</code>, <code>from</code> or <code>to</code> are <code>FALSE</code> then <code>spec</code> 
computes the spectrum of the whole signal.</p>


<h3>Value</h3>

<p>This function returns  a two-column matrix,
the first column corresponding to the frequency axis, the second column
corresponding to the amplitude axis.<br /> 
If <code>identify</code> is <code>TRUE</code>, <code>spec</code> returns a list with
two elements:<br /> 
</p>
<table>
<tr><td><code>freq</code></td>
<td>
<p>the frequency of the points chosen on the spectrum</p>
</td></tr></table>
<p><br /> 
</p>
<table>
<tr><td><code>amp</code></td>
<td>
<p>the relative amplitude of the points chosen on the spectrum</p>
</td></tr></table>
<p><br /> 
</p>


<h3>Warning</h3>

<p>The argument <code>peaks</code> is no more available
(version &gt; 1.5.6). See the function <code><a href="#topic+fpeaks">fpeaks</a></code>
for peak(s) detection.</p>


<h3>Note</h3>

<p>This function is based on <code><a href="stats.html#topic+fft">fft</a></code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+meanspec">meanspec</a></code>, <code><a href="#topic+fpeaks">fpeaks</a></code>,
<code><a href="#topic+localpeaks">localpeaks</a></code>, <code><a href="#topic+dynspec">dynspec</a></code>, 
<code><a href="#topic+corspec">corspec</a></code>, <code><a href="stats.html#topic+fft">fft</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
# spectrum of the whole signal, in absolute or dB amplitude,
# horizontaly or vertically
op&lt;-par(mfrow=c(2,2))
spec(tico,f=22050)
spec(tico,f=22050,col="red",plot=2)
spec(tico,f=22050,dB="max0",col="blue")
spec(tico,f=22050,dB="max0",col="green",plot=2)
par(op)
# an indirect way to compare spectra 
a&lt;-spec(tico,f=22050,wl=512,at=0.2,plot=FALSE)
b&lt;-spec(tico,f=22050,wl=512,at=0.7,plot=FALSE)
c&lt;-spec(tico,f=22050,wl=512,at=1.1,plot=FALSE)
d&lt;-spec(tico,f=22050,wl=512,at=1.6,plot=FALSE)
all&lt;-cbind(a[,2],b[,2],c[,2],d[,2])
matplot(x=a[,1],y=all,yaxt="n",
    xlab="Frequency (kHz)",ylab="Amplitude",xaxs="i",type="l")
legend(8,0.8,c("Note A","Note B", "Note C", "Note D"),bty="o",
    lty=c(1:4),col=c(1:4))
# spectrum from a particular position to another one
op&lt;-par(mfrow=c(2,1))
oscillo(tico,f=22050)
abline(v=c(0.5,0.9),col="red",lty=2)
spec(tico,f=22050,wl=512,from=0.5,to=0.9,col="red")
title("Spectrum of the note B")
par(op)
# spectrum and spectrogram
data(orni)
orni1&lt;-cutw(orni,f=22050,from=0.32,to=0.39)
layout(matrix(c(1,2),nc=2),widths=c(3,1))
par(mar=c(5,4,3,0.5))
spectro(orni1,f=22050,wl=128,zp=8,ovlp=85,scale=FALSE)
par(mar=c(5,1,3,0.5))
spec(orni1,f=22050,col="red",plot=2,flab="",yaxt="n")
</code></pre>

<hr>
<h2 id='specflux'>Spectral flux</h2><span id='topic+specflux'></span>

<h3>Description</h3>

<p>Compute spectral flux</p>


<h3>Usage</h3>

<pre><code class='language-R'>specflux(wave, f, channel = 1,
         wl = 512, ovlp = 0, wn = "rectangle", flim = NULL,
         norm = FALSE,  p = 2,
         plot = TRUE, xlab = "Times (s)", ylab = "Flux", type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specflux_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="specflux_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="specflux_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="specflux_+3A_wl">wl</code></td>
<td>
<p>window length for the analysis
(even number of points) (by default = 512).</p>
</td></tr>
<tr><td><code id="specflux_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in %).</p>
</td></tr>
<tr><td><code id="specflux_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"rectangle"</code>).</p>
</td></tr>
<tr><td><code id="specflux_+3A_flim">flim</code></td>
<td>
<p>a numeric vector of length 2 to select a frequency band
(in kHz).</p>
</td></tr>
<tr><td><code id="specflux_+3A_norm">norm</code></td>
<td>
<p>if is <code>TRUE</code> then the normalised spectra are
used. The spectra are normalised by their sum.</p>
</td></tr> 
<tr><td><code id="specflux_+3A_p">p</code></td>
<td>
<p>the norm type, by default = 2.</p>
</td></tr>
<tr><td><code id="specflux_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the spectral flux is displayed
against time (s) (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="specflux_+3A_xlab">xlab</code></td>
<td>
<p>title of the x axis.</p>
</td></tr>
<tr><td><code id="specflux_+3A_ylab">ylab</code></td>
<td>
<p>title of the y axis.</p>
</td></tr>
<tr><td><code id="specflux_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="specflux_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spectral flux (<code class="reqn">F</code>) is the sum of the time (<code class="reqn">t</code>) derivative of
the columns &ndash; that is the successive spectra &ndash;
(<code class="reqn">s</code>) of the normalized short-term Fourier transform (<code class="reqn">z</code>).<br />
F is then computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">F = (\sum |s(t+1) - s(t)|^{p})^{\frac{1}{p}}</code>
</p>
  


<h3>Value</h3>

<p>When <code>plot</code> is <code>FALSE</code>, <code>specflux</code> returns a two-column matrix, the
first column being time in seconds (<em>x</em>-axis) and the second column being the spectral flux (<em>y</em>-axis) computed along time.</p>


<h3>Note</h3>

<p>The sum of the successive spectral flux values could be used as an
ecoacoustic index, quite close to the acoustic complexity index
(<code><a href="#topic+ACI">ACI</a></code>). See examples.</p>


<h3>Author(s)</h3>

<p>Jérôme Sueur</p>


<h3>References</h3>

<p>Scheirer E, Slaney M (1997). Construction and evaluation of a robust multifeature speech/music discriminator.
<em>IEEE International Conference on Acoustics, Speech, and Signal Processing</em>, 2, 1221-1224.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectro">spectro</a></code>, <code><a href="#topic+ACI">ACI</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## default use
data(tico)
specflux(tico)
## norm 1
specflux(tico, p = 1)
## frequency limit between 2 and 4 kHz
specflux(tico, flim = c(2,4))
## index computation
sum(specflux(tico, plot=FALSE)[,2])
</code></pre>

<hr>
<h2 id='specprop'>Spectral properties</h2><span id='topic+specprop'></span>

<h3>Description</h3>

<p>This function returns a list of statistical properties of a frequency spectrum.</p>


<h3>Usage</h3>

<pre><code class='language-R'>specprop(spec, f=NULL,
str = FALSE, flim=NULL, mel=FALSE,
plot = FALSE, type = "l", xlab=NULL, ylab = NULL,
col.mode = 2, col.quartiles = 4, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specprop_+3A_spec">spec</code></td>
<td>
<p>a data set resulting of a spectral analysis obtained
with <code><a href="#topic+spec">spec</a></code> or <code><a href="#topic+meanspec">meanspec</a></code> (not in dB).</p>
</td></tr>
<tr><td><code id="specprop_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>spec</code> (in Hz).</p>
</td></tr>
<tr><td><code id="specprop_+3A_str">str</code></td>
<td>
<p>logical, if <code>TRUE</code> returns the results in a structured table.</p>
</td></tr>
<tr><td><code id="specprop_+3A_flim">flim</code></td>
<td>
<p>a vector of length 2 to specifgy the frequency limits of the analysis (in kHz)</p>
</td></tr>
<tr><td><code id="specprop_+3A_mel">mel</code></td>
<td>
<p>a logical, if <code>TRUE</code> the (htk-)mel scale is used.</p>
</td></tr>
<tr><td><code id="specprop_+3A_plot">plot</code></td>
<td>
<p>if <code>1</code> returns the spectrum , if <code>2</code> returns 
the cumulative spectrum, both of them with the first quartile, the third quartile,
the median and the mode plotted (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="specprop_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="specprop_+3A_xlab">xlab</code></td>
<td>
<p>label of the x axis.</p>
</td></tr>
<tr><td><code id="specprop_+3A_ylab">ylab</code></td>
<td>
<p>label of the y axis.</p>
</td></tr>
<tr><td><code id="specprop_+3A_col.mode">col.mode</code></td>
<td>
<p>colour of the mode segments (by default blue).</p>
</td></tr>
<tr><td><code id="specprop_+3A_col.quartiles">col.quartiles</code></td>
<td>
<p>colour of the quartiles segments (by default red).</p>
</td></tr>
<tr><td><code id="specprop_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spectrum is converted in a probability mass function (PMF).<br />
If a selected value has to be selected with $,
the argument <code>str</code> has to be set to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>A list of 15 values is returned
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>mean frequency (see <code><a href="base.html#topic+mean">mean</a></code>)</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>standard deviation of the mean (see <code><a href="stats.html#topic+sd">sd</a></code>)</p>
</td></tr>
<tr><td><code>sem</code></td>
<td>
<p>standard error of the mean</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>median frequency (see <code><a href="stats.html#topic+median">median</a></code>)</p>
</td></tr>
<tr><td><code>mode</code></td>
<td>
<p>mode frequency, <em>i.e.</em> the dominant frequency</p>
</td></tr>
<tr><td><code>Q25</code></td>
<td>
<p>first quartile (see <code><a href="stats.html#topic+quantile">quantile</a></code>)</p>
</td></tr>
<tr><td><code>Q75</code></td>
<td>
<p>third quartile (see <code><a href="stats.html#topic+quantile">quantile</a></code>)</p>
</td></tr>
<tr><td><code>IQR</code></td>
<td>
<p>interquartile range (see <code><a href="stats.html#topic+IQR">IQR</a></code>)</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>centroid, see <code>note</code></p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p>skewness, a measure of asymmetry, see <code>note</code></p>
</td></tr>
<tr><td><code>kurtosis</code></td>
<td>
<p>kurtosis, a measure of peakedness, see <code>note</code></p>
</td></tr>
<tr><td><code>sfm</code></td>
<td>
<p>spectral flatness measure (see <code><a href="#topic+sfm">sfm</a></code>)</p>
</td></tr>
<tr><td><code>sh</code></td>
<td>
<p>spectral entropy (see <code><a href="#topic+sh">sh</a></code>)</p>
</td></tr>
<tr><td><code>prec</code></td>
<td>
<p>frequency precision of the spectrum</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Centroid is computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">C = \sum_{i = 1}^{N} x_i\times{y_i}</code>
</p>
<p><br />
with:<br />
<em>x</em> = frequencies,
<em>y</em> = relative amplitude of the <em>i</em> frequency,<br />
<em>N</em> = number of frequencies.<br /><br />
Skewness is computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">S = \frac{\sum_{i = 1}^{N}(x_i-\bar{x})^{3}}{N-1}\times{\frac{1}{\sigma^{3}}}</code>
</p>
<p>.<br />
S &lt; 0 when the spectrum is skewed to left,<br />
S = 0 when the spectrum is symetric,<br />
S &gt; 0 when the spectrum is skewed to right.<br />
Spectrum asymmetry increases with |S|.<br /><br /> 
Kurtosis is computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">K = \frac{\sum_{i = 1}^{N}(x_i-\bar{x})^{4}}{N-1}\times{\frac{1}{\sigma^{4}}}</code>
</p>
<p>.<br />
K &lt; 3 when the spectrum is platikurtic, <em>i.e.</em> it has fewer items at the
center and at the tails than the normal curve but has more items in the shoulders,<br />
K = 3 when the spectrum shows a normal shape,<br />
K &gt; 3 when the spectrum is leptokurtic, <em>i.e.</em> it has more items near
the center and at the tails, with fewer items in the shoulders
relative to normal distribution with the same mean and variance.
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur and Caroline Simonis, and a patch by Jesse Ross
(Dec. 2012)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orni)
a&lt;-meanspec(orni,f=22050,plot=FALSE)
specprop(a,f=22050)
# to get a single measure of the list
specprop(a,f=22050)$mode
# to get the results structured
specprop(a,f=22050,str=TRUE)
# to limit the analysis between 4 and 6 kHz
specprop(a,f=22050,flim=c(4,6),str=TRUE)
# plots
specprop(a,f=22050,plot=1)
specprop(a,f=22050,plot=2)
# (htk-)mel scale
require(tuneR)
mel &lt;- melfcc(orni, nbands = 256, dcttype = "t3", fbtype = "htkmel", spec_out=TRUE)
melspec.mean &lt;- apply(mel$aspectrum, MARGIN=2, FUN=mean)
specprop(melspec.mean, f=22050, mel=TRUE)
# be aware that flim is always given in kHz even if mel=TRUE
specprop(melspec.mean, f=22050, flim=c(4,6), mel=TRUE, plot=TRUE)
</code></pre>

<hr>
<h2 id='spectro'>2D-spectrogram of a time wave</h2><span id='topic+spectro'></span>

<h3>Description</h3>

<p>This function returns a two-dimension spectrographic representation of a time
wave. The function corresponds to short-term Fourier transform.
An amplitude contour plot can be overlaid.</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectro(wave, f, channel = 1, wl = 512, wn = "hanning", zp = 0,
ovlp = 0, noisereduction = NULL, fastdisp = FALSE,
complex = FALSE, norm = TRUE, correction="none",
fftw = FALSE, dB = "max0", dBref = NULL, plot = TRUE,
flog = FALSE, grid = TRUE, osc = FALSE, scale = TRUE, cont = FALSE,
collevels = NULL, palette = spectro.colors,
contlevels = NULL, colcont = "black",
colbg = "white", colgrid = "black",
colaxis = "black", collab="black",
cexlab = 1, cexaxis = 1, 
tlab = "Time (s)",
flab = "Frequency (kHz)",
alab = "Amplitude",
scalelab = "Amplitude\n(dB)",
main = NULL,
scalefontlab = 1, scalecexlab =0.75,
axisX = TRUE, axisY = TRUE, tlim = NULL, trel = TRUE,
flim = NULL, flimd = NULL,
widths = c(6,1), heights = c(3,1),
oma = rep(0,4),
listen=FALSE,
...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectro_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="spectro_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>  
<tr><td><code id="spectro_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="spectro_+3A_wl">wl</code></td>
<td>
<p>window length for the analysis
(even number of points) (by default = 512).</p>
</td></tr>
<tr><td><code id="spectro_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default
<code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="spectro_+3A_zp">zp</code></td>
<td>
<p>zero-padding (even number of points), see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="spectro_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in %).</p>
</td></tr>
<tr><td><code id="spectro_+3A_noisereduction">noisereduction</code></td>
<td>
<p>a numeric vector of length 1, if <code>1</code> a
noise reduction is applied along the rows of the spectrogram, if
<code>2</code> a noise reduction applied along the columns. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="spectro_+3A_fastdisp">fastdisp</code></td>
<td>
<p>faster graphic display for long <code>wave</code>. The
spectrogram/oscillogram is displayed/saved faster in the graphic device/
graphic file when set to <code>TRUE</code>, with a cost on graphical resolution.</p>
</td></tr>
<tr><td><code id="spectro_+3A_complex">complex</code></td>
<td>
<p>if <code>TRUE</code> the STFT will be returned as complex
numbers.</p>
</td></tr>  
<tr><td><code id="spectro_+3A_norm">norm</code></td>
<td>
<p>if <code>TRUE</code> the STFT is normalised (i. e. scaled) by its maximum.</p>
</td></tr>
<tr><td><code id="spectro_+3A_correction">correction</code></td>
<td>
<p>a character vector of length 1 to apply an
amplitude (&quot;amplitude&quot;) or an energy (&quot;energy&quot;) correction
to each FT window. This argument is useful only when one wish to obtain
absolute values that is when <code>norm=FALSE</code>.
By default no correction is applied (&quot;none&quot;).</p>
</td></tr>  
<tr><td><code id="spectro_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code>. See Notes.</p>
</td></tr>
<tr><td><code id="spectro_+3A_db">dB</code></td>
<td>
<p>a character string specifying the type dB to return: &quot;max0&quot;
(default) for a maximum dB value at 0, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, and &quot;ITU&quot; for
common dB weights. If set to <code>NULL</code>, then a linear scale is used.</p>
</td></tr>
<tr><td><code id="spectro_+3A_dbref">dBref</code></td>
<td>
<p>a dB reference value. <code>NULL</code> by default
but should be set to 2*10e-5 for a 20 microPa reference.</p>
</td></tr>
<tr><td><code id="spectro_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the spectrogram
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="spectro_+3A_flog">flog</code></td>
<td>
<p>a logical to plot the frequency on a logarithmic scale.</p>
</td></tr>
<tr><td><code id="spectro_+3A_grid">grid</code></td>
<td>
<p>logical, if <code>TRUE</code> plots a y-axis grid
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="spectro_+3A_osc">osc</code></td>
<td>
<p>logical, if <code>TRUE</code> plots an oscillogram beneath
the spectrogram (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="spectro_+3A_scale">scale</code></td>
<td>
<p>logical, if <code>TRUE</code> plots a dB colour scale on the right
side of the spectrogram (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="spectro_+3A_cont">cont</code></td>
<td>
<p>logical, if <code>TRUE</code> overplots contour lines on the spectrogram
(by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="spectro_+3A_collevels">collevels</code></td>
<td>
<p>a set of levels which are used to partition
the amplitude range of the spectrogram (in dB).</p>
</td></tr>
<tr><td><code id="spectro_+3A_palette">palette</code></td>
<td>
<p>a color palette function to be used to assign colors in
the plot, see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="spectro_+3A_contlevels">contlevels</code></td>
<td>
<p>a set of levels which are used to partition
the amplitude range for contour overplot (in dB).</p>
</td></tr>
<tr><td><code id="spectro_+3A_colcont">colcont</code></td>
<td>
<p>colour for <code>cont</code> plotting.</p>
</td></tr>
<tr><td><code id="spectro_+3A_colbg">colbg</code></td>
<td>
<p>background colour.</p>
</td></tr>
<tr><td><code id="spectro_+3A_colgrid">colgrid</code></td>
<td>
<p>colour for <code>grid</code> plotting.</p>
</td></tr>
<tr><td><code id="spectro_+3A_colaxis">colaxis</code></td>
<td>
<p>color of the axes.</p>
</td></tr>
<tr><td><code id="spectro_+3A_collab">collab</code></td>
<td>
<p>color of the labels.</p>
</td></tr>
<tr><td><code id="spectro_+3A_cexlab">cexlab</code></td>
<td>
<p>size of the labels.</p>
</td></tr>
<tr><td><code id="spectro_+3A_cexaxis">cexaxis</code></td>
<td>
<p>size of the axes.</p>
</td></tr>
<tr><td><code id="spectro_+3A_tlab">tlab</code></td>
<td>
<p>label of the time axis.</p>
</td></tr>
<tr><td><code id="spectro_+3A_flab">flab</code></td>
<td>
<p>label of the frequency axis.</p>
</td></tr>
<tr><td><code id="spectro_+3A_alab">alab</code></td>
<td>
<p>label of the amplitude axis.</p>
</td></tr>
<tr><td><code id="spectro_+3A_scalelab">scalelab</code></td>
<td>
<p>amplitude scale label.</p>
</td></tr>
<tr><td><code id="spectro_+3A_main">main</code></td>
<td>
<p>label of the main title.</p>
</td></tr>
<tr><td><code id="spectro_+3A_scalefontlab">scalefontlab</code></td>
<td>
<p>font of the amplitude scale label.</p>
</td></tr>
<tr><td><code id="spectro_+3A_scalecexlab">scalecexlab</code></td>
<td>
<p>cex of the amplitude scale label.</p>
</td></tr>
<tr><td><code id="spectro_+3A_axisx">axisX</code></td>
<td>
<p>logical, if <code>TRUE</code> plots time X-axis (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="spectro_+3A_axisy">axisY</code></td>
<td>
<p>logical, if <code>TRUE</code> plots frequency Y-axis (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="spectro_+3A_tlim">tlim</code></td>
<td>
<p>modifications of the time X-axis limits.</p>
</td></tr>
<tr><td><code id="spectro_+3A_trel">trel</code></td>
<td>
<p>time X-axis with a relative scale when <code>tlim</code> is not null,
<em>i.e.</em> relative to <code>wave</code>.</p>
</td></tr> 
<tr><td><code id="spectro_+3A_flim">flim</code></td>
<td>
<p>modifications of the frequency Y-axis limits (in kHz).</p>
</td></tr> 
<tr><td><code id="spectro_+3A_flimd">flimd</code></td>
<td>
<p>dynamic modifications of the frequency Y-axis limits. New <code>wl</code>
and <code>ovlp</code> arguments are applied to increase time/frequency resolution.</p>
</td></tr>
<tr><td><code id="spectro_+3A_widths">widths</code></td>
<td>
<p>a vector of length 2 to control the relative widths of columns on
the device when <code>scale</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spectro_+3A_heights">heights</code></td>
<td>
<p>a vector of length 2 to control the relative heights of rows on
the device when <code>osc</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spectro_+3A_oma">oma</code></td>
<td>
<p>a vector of length 4 to control the size of outer margins
when either <code>scale</code> or <code>osc</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spectro_+3A_listen">listen</code></td>
<td>
<p>if <code>TRUE</code> the sound is played back (by default
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="spectro_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+contour">contour</a></code> and <code><a href="#topic+oscillo">oscillo</a></code>
graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following Heisenberg uncertainty principle, the short-term Fourier transform
cannot be precised in both time and frequency. The temporal and frequency
precisions of the function are actually dependent of the <code>wl</code> value.
Choosing a high <code>wl</code> value will increase the frequency resolution but
reduce the temporal one, and <em>vice versa</em>. The frequency precision is
obtained by calculating the ratio <code>f</code>/<code>wl</code>,
and the temporal precision is obtained by calculating the reverse ratio
<code>wl</code>/<code>f</code>. This problem can be reduced in some way with <code>zp</code> that
adds 0 values on both sides of the analysis window. This increases frequency
resolution without altering time resolution.<br />
Any colour palette can be used. In particular, it is possible to use other
palettes coming with <span class="pkg">seewave</span>: <code>temp.colors</code>, 
<code>reverse.gray.colors.1</code>,
<code>reverse.gray.colors.2</code>, <code>reverse.heat.colors</code>,
<code>reverse.terrain.colors</code>,
<code>reverse.topo.colors</code>,
<code>reverse.cm.colors</code> corresponding to the reverse of <code>heat.colors</code>, 
<code>terrain.colors</code>, <code>topo.colors</code>, <code>cm.colors</code>.<br />
Use <code><a href="graphics.html#topic+locator">locator</a></code> to identify  points.
The noise reduction using the argument <code>noisereduction</code> is an
image filter, not a signal filter. The principle consists in
subtracting each spectrogram row or column by its median. Noise reduction alters
energy conservation, it should then be used for visual display only. 
</p>


<h3>Value</h3>

<p>This function returns a list of three items:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>a numeric vector corresponding to the time axis.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>a numeric vector corresponding to the frequency axis.</p>
</td></tr>
<tr><td><code>amp</code></td>
<td>
<p>a numeric or a complex matrix corresponding to the amplitude values.
Each column is a Fourier transform of length <code>wl/2</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The argument <code>fftw</code> can be used to try to speed up process
time. When set to <code>TRUE</code>, the Fourier transform is computed
through the function <code>FFT</code> of the package <code>fftw</code>. This pacakge is a
wrapper around the fastest Fourier transform of the free C subroutine
library FFTW (<a href="http://www.fftw.org/">http://www.fftw.org/</a>). FFT should be then installed on your OS.</p>


<h3>Note</h3>

<p>This function is based on <code><a href="stats.html#topic+fft">fft</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code> and
<code><a href="graphics.html#topic+filled.contour">filled.contour</a></code></p>


<h3>Author(s)</h3>

<p>Jerome Sueur and Caroline Simonis.</p>


<h3>References</h3>

<p>Hopp, S. L., Owren, M. J. and Evans, C. S. (Eds) 1998. <em>Animal acoustic 
communication</em>. Springer, Berlin, Heidelberg.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggspectro">ggspectro</a></code>, <code><a href="#topic+spectro3D">spectro3D</a></code>,
<code><a href="#topic+lts">lts</a></code>, <code><a href="#topic+dynspec">dynspec</a></code>, <code><a href="#topic+wf">wf</a></code>, 
<code><a href="#topic+oscillo">oscillo</a></code>, <code><a href="#topic+dBscale">dBscale</a></code>, <code><a href="stats.html#topic+fft">fft</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(tico)
data(pellucens)
# simple plots
spectro(tico,f=22050)
spectro(tico,f=22050,osc=TRUE)
spectro(tico,f=22050,scale=FALSE)
spectro(tico,f=22050,osc=TRUE,scale=FALSE)
# change the dB scale by setting a different dB reference value (20microPa)
spectro(tico,f=22050, dBref=2*10e-5)
# unnormalised spectrogram with a linear amplitude scale
spectro(tico, dB=NULL, norm=FALSE, scale=FALSE)
# manipulating wl
op&lt;-par(mfrow=c(2,2))
spectro(tico,f=22050,wl=256,scale=FALSE)
title("wl = 256")
spectro(tico,f=22050,wl=512,scale=FALSE)
title("wl = 512")
spectro(tico,f=22050,wl=1024,scale=FALSE)
title("wl = 1024")
spectro(tico,f=22050,wl=4096,scale=FALSE)
title("wl = 4096")
par(op)
# vertical zoom using flim
spectro(tico,f=22050, flim=c(2,6))
spectro(tico,f=22050, flimd=c(2,6))
# a full plot
pellu2&lt;-cutw(pellucens,f=22050,from=1,plot=FALSE)
spectro(pellu2,f=22050,ovlp=85,zp=16,osc=TRUE,
    cont=TRUE,contlevels=seq(-30,0,20),colcont="red",
    lwd=1.5,lty=2,palette=reverse.terrain.colors)
# black and white spectrogram 
spectro(pellu2,f=22050,ovlp=85,zp=16,
    palette=reverse.gray.colors.1)
# colour modifications
data(sheep)
spectro(sheep,f=8000,palette=temp.colors,collevels=seq(-115,0,1))
spectro(pellu2,f=22050,ovlp=85,zp=16,
palette=reverse.cm.colors,osc=TRUE,colwave="orchid1") 
spectro(pellu2,f=22050,ovlp=85,zp=16,osc=TRUE,palette=reverse.heat.colors,
colbg="black",colgrid="white", colwave="white",colaxis="white",collab="white")

## End(Not run)
</code></pre>

<hr>
<h2 id='spectro3D'>3D-spectrogram of a time wave</h2><span id='topic+spectro3D'></span>

<h3>Description</h3>

<p>This function returns a three-dimension spectrographic representation of a
time wave. The function corresponds to short-term Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectro3D(wave, f, channel = 1, wl = 512, wn = "hanning", zp = 0,
ovlp = 0, noisereduction = FALSE, norm = TRUE, correction = "none", fftw = FALSE,
dB = "max0", dBref = NULL, plot = TRUE,
magt = 10, magf = 10, maga = 2,
palette = reverse.terrain.colors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectro3D_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="spectro3D_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="spectro3D_+3A_wl">wl</code></td>
<td>
<p>length of the window for the analysis
(even number of points).</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_zp">zp</code></td>
<td>
<p>zero-padding (even number of points), see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in % ).</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_noisereduction">noisereduction</code></td>
<td>
<p>a logical, if <code>TRUE</code> a noise reduction is applied.</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_norm">norm</code></td>
<td>
<p>if <code>TRUE</code> the STFT is normalised (i. e. scaled) by its maximum.</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_correction">correction</code></td>
<td>
<p>a character vector of length 1 to apply an
amplitude (&quot;amplitude&quot;) or an energy (&quot;energy&quot;) correction
to the FT window. This argument is useful only when one wish to obtain
absolute values that is when <code>norm=FALSE</code>, <code>scaled=FALSE</code>,
and <code>PMF=FALSE</code>. By default no correction is applied (&quot;none&quot;).</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code>. See Notes of the <code>spectro</code>.</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_db">dB</code></td>
<td>
<p>a character string specifying the type dB to return:
&quot;max0&quot; for a maximum dB value at 0, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, and &quot;ITU&quot; for common dB weights.</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_dbref">dBref</code></td>
<td>
<p>a dB reference value when <code>dB</code> is <code>TRUE</code>. <code>NULL</code> by default
but should be set to 2*10e-5 for a 20 microPa reference.</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the spectrogram
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_magt">magt</code></td>
<td>
<p>magnification of the time axis.</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_magf">magf</code></td>
<td>
<p>magnification of the frequency axis.</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_maga">maga</code></td>
<td>
<p>magnification of the amplitude axis.</p>
</td></tr>
<tr><td><code id="spectro3D_+3A_palette">palette</code></td>
<td>
<p>a color palette function to be used to assign colors in
the plot, see <code>Details</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following Heisenberg uncertainty principle, the short-term Fourier transform
cannot be precised in both time and frequency. The temporal and frequency
precisions of the function are actually dependent of the <code>wl</code> value.
Choosing a high <code>wl</code> value will increase the frequency resolution but
reduce the temporal one, and <em>vice versa</em>. The frequency precision is
obtained by calculating the ratio <code>f</code>/<code>wl</code>,
and the temporal precision is obtained by calculating the reverse ratio
<code>wl</code>/<code>f</code>. This problem can be reduced in some way with <code>zp</code> that
adds 0 values on both sides of the analysis window. This increases frequency
resolution without altering time resolution.<br />
Any colour palette can be used. In particular, it is possible to use other palettes coming with
<span class="pkg">seewave</span>: <code>reverse.gray.colors.1</code>, <code>reverse.gray.colors.2</code>,
<code>spectro.colors</code>, <code>temp.colors</code>, <code>reverse.heat.colors</code>, 
<code>reverse.cm.colors</code>, <code>reverse.topo.colors</code>, corresponding to the reverse
of <code>heat.colors</code>,<code>topo.colors</code>,
<code>cm.colors</code>.<br />
Use <code>magt</code>, <code>magf</code> and <code>maga</code> to resize the plot.   
</p>


<h3>Value</h3>

<p>This function returns a list of three items:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>a numeric vector corresponding to the time axis.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>a numeric vector corresponding to the frequency axis.</p>
</td></tr>
<tr><td><code>amp</code></td>
<td>
<p>a numeric matrix corresponding to the amplitude
values. Each column is a Fourier transform of length <code>wl</code>/2.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires <span class="pkg">rgl</span> and is based on <code><a href="stats.html#topic+fft">fft</a></code>.
See examples of <code><a href="#topic+spectro">spectro</a></code> for analysis arguments
(<code>wl</code>,<code>zp</code>, <code>ovlp</code>).</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a> and 
Caroline Simonis <a href="mailto:csimonis@mnhn.fr">csimonis@mnhn.fr</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectro">spectro</a></code>, <code><a href="#topic+ggspectro">ggspectro</a></code>, <code><a href="#topic+lts">lts</a></code>, <code><a href="#topic+dynspec">dynspec</a></code>,
<code><a href="#topic+wf">wf</a></code>, <code><a href="stats.html#topic+fft">fft</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(rgl)
data(tico)
spectro3D(tico,f=22050,wl=512,ovlp=75,zp=16,maga=4,palette=reverse.terrain.colors)
# linear amplitude scale without a normisation of the STFT matrix
# time and frequency scales need to be dramatically amplified
spectro3D(tico, norm=FALSE, dB=NULL, magt=100000, magf=100000)

## End(Not run)</code></pre>

<hr>
<h2 id='squarefilter'>Frequency square filter</h2><span id='topic+squarefilter'></span>

<h3>Description</h3>

<p>This function prepares the amplitude profile of a square frequency filter.</p>


<h3>Usage</h3>

<pre><code class='language-R'>squarefilter(f, from = NULL, to = NULL, bandpass = TRUE, wl = 1024)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="squarefilter_+3A_f">f</code></td>
<td>
<p>a numeric vector of length 1 for the sampling frequency of the object to be filtered (in Hz).</p>
</td></tr>
<tr><td><code id="squarefilter_+3A_from">from</code></td>
<td>
<p>a numeric vector for the start frequencies (in Hz) where to apply the filter.</p>
</td></tr>
<tr><td><code id="squarefilter_+3A_to">to</code></td>
<td>
<p>a numeric vector of the end frequencies (in Hz) where to apply the filter.</p>
</td></tr>
<tr><td><code id="squarefilter_+3A_bandpass">bandpass</code></td>
<td>
<p>if <code>TRUE</code> a band-pass filter is prepared between
start and end frequencies (arguments <code>from</code> and <code>to</code>), if <code>FALSE</code> a bandstop filter is prepared.</p>
</td></tr>
<tr><td><code id="squarefilter_+3A_wl">wl</code></td>
<td>
<p>window length of the impulse filter (even number of points).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a two-column matrix, the first column is the frequency in kHz and the second column is the amplitude of the filter (frequency response of the filter).</p>


<h3>Note</h3>

<p>This function can be used to prepare bandpass or bandstop filters to be used with <code><a href="#topic+fir">fir</a></code> and <code><a href="#topic+ffilter">ffilter</a></code>. See examples.</p>


<h3>Author(s)</h3>

<p>Laurent Lellouch</p>


<h3>See Also</h3>

<p><code><a href="#topic+fir">fir</a></code>, <code><a href="#topic+drawfilter">drawfilter</a></code>, <code><a href="#topic+ffilter">ffilter</a></code>, <code><a href="#topic+combfilter">combfilter</a></code>, <code><a href="#topic+bwfilter">bwfilter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- 44100
a &lt;- noisew(f = f, d = 1)
p &lt;- squarefilter(f, from = c(100, 1000, 4000), to = c(500, 3000, 8000))
plot(p, type="l")
h &lt;- fir(a, f = f, custom = p, wl = 1024, output = 'Wave')
spectro(h)
</code></pre>

<hr>
<h2 id='symba'>Symbol analysis of a numeric (time) series</h2><span id='topic+symba'></span>

<h3>Description</h3>

<p>This function analyses one or two sequences of symbols from numeric (time) series.</p>


<h3>Usage</h3>

<pre><code class='language-R'>symba(x, y = NULL, symb = 5, collapse = TRUE, entropy = "abs",
plot = FALSE, type = "l", lty1 = 1, lty2 = 2, col1 = 2, col2 = 4,
cex1 = 0.75, cex2= 0.75, xlab = "index", ylab = "Amplitude", legend=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symba_+3A_x">x</code></td>
<td>
<p>a first R object.</p>
</td></tr>
<tr><td><code id="symba_+3A_y">y</code></td>
<td>
<p>a second R object</p>
</td></tr>
<tr><td><code id="symba_+3A_symb">symb</code></td>
<td>
<p>the number of symbols used for the discretisation, can be set to 3 or 5 only.</p>
</td></tr>
<tr><td><code id="symba_+3A_collapse">collapse</code></td>
<td>
<p>logical, if <code>TRUE</code>, the symbols are pasted in a character string of length 1.</p>
</td></tr>
<tr><td><code id="symba_+3A_entropy">entropy</code></td>
<td>
<p>either &quot;abs&quot; for an absolute value or &quot;rel&quot; for a relative value, i. e. between 0 and 1.</p>
</td></tr>
<tr><td><code id="symba_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the series <code>x</code> (and <code>y</code>) and the respective symbols.</p>
</td></tr>
<tr><td><code id="symba_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="symba_+3A_lty1">lty1</code></td>
<td>
<p>line type of the object <code>x</code> if <code>type</code>=&quot;l&quot;.</p>
</td></tr>
<tr><td><code id="symba_+3A_lty2">lty2</code></td>
<td>
<p>line type of the object <code>y</code> if <code>type</code>=&quot;l&quot;.</p>
</td></tr>
<tr><td><code id="symba_+3A_col1">col1</code></td>
<td>
<p>colour of the object <code>x</code>.</p>
</td></tr>
<tr><td><code id="symba_+3A_col2">col2</code></td>
<td>
<p>colour of the object <code>y</code>.</p>
</td></tr>
<tr><td><code id="symba_+3A_cex1">cex1</code></td>
<td>
<p>character size of <code>x</code> symbols.</p>
</td></tr>
<tr><td><code id="symba_+3A_cex2">cex2</code></td>
<td>
<p>character size of <code>y</code> symbols.</p>
</td></tr>
<tr><td><code id="symba_+3A_xlab">xlab</code></td>
<td>
<p>title of the x axis.</p>
</td></tr>
<tr><td><code id="symba_+3A_ylab">ylab</code></td>
<td>
<p>title of the y axis.</p>
</td></tr>
<tr><td><code id="symba_+3A_legend">legend</code></td>
<td>
<p>logical, if <code>TRUE</code> and if <code>y</code> is not <code>NULL</code> adds a legend to the plot.</p>
</td></tr>
<tr><td><code id="symba_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analysis consists in transforming the series into a sequence of symbols (see the function
<code><a href="#topic+discrets">discrets</a></code>) and in computing the absolute frequency of each symbol within the sequence.<br />
The entropy (<em>H</em>) is then calculated using the symbol frequencies.
Using the argument <code>entropy</code>, the entropy can be expressed along an absolute scale or as a relative
value varying between 0 and 1.<br />
If two numeric (time) series are provided (<code>x</code> and <code>y</code>) the absolute symbol
frequencies and entropy of each series is returned. Besides the mutual information (<em>I</em>)
is estimated according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">I = H_{x} + H_{y} - H{xy}</code>
</p>

<p>with <em>Hx</em> the entropy of <code>x</code> symbol series,
<em>Hy</em> the entropy of <code>y</code> symbol series, and <em>Hxy</em>$ the joint entropy
of <code>x</code> and <code>y</code> symbol series.
</p>


<h3>Value</h3>

<p>If <code>y</code> is <code>NULL</code> a list of three items is returned (s1, freq1, h1).<br />
If <code>y</code> is not <code>NULL</code>, a list of 6 items is returned (s1, freq1, h1, s2, freq2, h2, I):
</p>
<table>
<tr><td><code>s1</code></td>
<td>
<p>the sequence of symbols of <code>x</code>,</p>
</td></tr>
<tr><td><code>freq1</code></td>
<td>
<p>the relative frequency of each <code>x</code> symbol,</p>
</td></tr>
<tr><td><code>h1</code></td>
<td>
<p>the entropy of <code>x</code> symbol sequence,</p>
</td></tr>
<tr><td><code>s2</code></td>
<td>
<p>the sequence of symbols of <code>y</code>,</p>
</td></tr>
<tr><td><code>freq2</code></td>
<td>
<p>the relative frequency of each <code>y</code> symbol,</p>
</td></tr>
<tr><td><code>h2</code></td>
<td>
<p>the entropy of <code>y</code> symbol sequence,</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>the mutual information between <code>x</code> and <code>y</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It might be useful to round the values of the input series (see examples).<br />
The mutual information (<em>I</em>) should increase with the similarity
between the series to compare (<code>x</code> and <code>y</code>).
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p>Cazelles, B. 2004
Symbolic dynamics for identifying similarity between rhythms of ecological time series.
<em>Ecology Letters</em>, 7: 755-763.</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrets">discrets</a></code>, <code><a href="#topic+SAX">SAX</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># analysis of a frequency spectrum
data(tico)
spec1&lt;-spec(tico,f=22050,at=0.2,plot=FALSE)
symba(spec1[,2],plot=TRUE)
# it might be better to round the values
symba(round(spec1[,2],2),plot=TRUE)
# in that case the symbol entropy is close to the spectral entropy
symba(round(spec1[,2],2),entrop="rel")$h1
sh(spec1)
# to compare two frequency spectra
spec2&lt;-spec(tico,f=22050,wl=512,at=1.1,plot=FALSE)
symba(round(spec1[,2],2),round(spec2[,2],2),plot=TRUE)
</code></pre>

<hr>
<h2 id='synth'>Synthesis of time wave (additive model)</h2><span id='topic+synth'></span>

<h3>Description</h3>

<p>This functions synthesizes pure or harmonic tone sound with amplitude modulation (am)
and/or frequency modulation (fm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synth(f, d, cf, a = 1, signal = "sine", shape = NULL, p = 0,
am = c(0, 0, 0), fm = c(0, 0, 0, 0, 0), harmonics = 1, 
plot = FALSE, listen = FALSE, output = "matrix",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synth_+3A_f">f</code></td>
<td>
<p>sampling frequency (in Hz).</p>
</td></tr>
<tr><td><code id="synth_+3A_d">d</code></td>
<td>
<p>duration (in s).</p>
</td></tr>
<tr><td><code id="synth_+3A_cf">cf</code></td>
<td>
<p>carrier frequency (in Hz).</p>
</td></tr>
<tr><td><code id="synth_+3A_a">a</code></td>
<td>
<p>amplitude (linear scale, relative when adding different waves).</p>
</td></tr>
<tr><td><code id="synth_+3A_signal">signal</code></td>
<td>
<p>a character vector specifying the shape of the signal,
see <code>details</code>.</p>
</td></tr>
<tr><td><code id="synth_+3A_shape">shape</code></td>
<td>
<p>modification of the whole amplitude shape of the wave,
see <code>details</code>.</p>
</td></tr>
<tr><td><code id="synth_+3A_p">p</code></td>
<td>
<p>initial phase (in radians).</p>
</td></tr>
<tr><td><code id="synth_+3A_am">am</code></td>
<td>
<p>a numeric vector of length 3 describing amplitude modulation parameters,
see <code>details</code>.</p>
</td></tr>
<tr><td><code id="synth_+3A_fm">fm</code></td>
<td>
<p>a numeric vector of length 5 describing frequency modulation parameters,
see <code>details</code>.</p>
</td></tr>
<tr><td><code id="synth_+3A_harmonics">harmonics</code></td>
<td>
<p>a numeric specifying the number and the relative
amplitude of harmonics, see <code>details</code>.</p>
</td></tr>
<tr><td><code id="synth_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> returns the spectrogram
of the synthezised sound (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="synth_+3A_listen">listen</code></td>
<td>
<p>if <code>TRUE</code> the new sound is played back.</p>
</td></tr>
<tr><td><code id="synth_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="synth_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+spectro">spectro</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><code>signal</code> is a character vector of length 1 that specifies
the function used to synthesize the
signal. There are three options:
</p>

<ol>
<li><p>&quot;sine&quot;: for a sinus function,
</p>
</li>
<li><p>&quot;tria&quot;: for a triangle function,
</p>
</li>
<li><p>&quot;square&quot;: for a square function,
</p>
</li>
<li><p>&quot;saw&quot;: for a square function.
</p>
</li></ol>


</li>
<li><p><code>shape</code> is a character vector of length 1 that allows
to modify the whole amplitude shape of the wave. There
are four options:
</p>

<ol>
<li><p>&quot;incr&quot;: linear increase
</p>
</li>
<li><p>&quot;decr&quot;: linear decrease 
</p>
</li>
<li><p>&quot;sine&quot;: sinusoid-like shape
</p>
</li>
<li><p>&quot;tria&quot;: triangular shape
</p>
</li></ol>


</li>
<li><p><code>am</code> is a numeric vector of length 3 including:
</p>

<ol>
<li><p>the amplitude modulation depth (in %)
</p>
</li>
<li><p>the frequency of the amplitude modulation (in Hz),
</p>
</li>
<li><p>the phase of the amplitude modulation (in radian).
</p>
</li></ol>


</li>
<li><p><code>fm</code> is a numeric vector of length 5 including:
</p>

<ol>
<li><p>the maximum excursion of a sinusoidal frequency modulation (in
Hz),
</p>
</li>
<li><p>the frequency of a sinusoidal frequency modulation (in Hz),
</p>
</li>
<li><p>the maximum excursion of a linear frequency modulation (in
Hz).
</p>
</li>
<li><p>the phase of the frequency modulation (in radian).
</p>
</li>
<li><p>the maximum excursion of an exponential frequency modulation (in
Hz).
</p>
</li></ol>


</li>
<li><p><code>harmonics</code> is a numeric vector that controls the number and the
relative amplitude of harmonics synthesized. <br />
By default <code>harmonics = 1</code> meaning that a pure tone made of a single
harmonic (fundamental) will be produced.<br />
To produce harmonics, the length of <code>harmonics</code> has to be
greater than 1. The length of <code>harmonics</code> will set the number of
harmonics, including the first one (fundamental). The value of
each element of <code>harmonics</code> specify the relative ampltiude of
each harmonic. The first value must equal to <code>1</code>. <br />
Here are some examples:
</p>

<ul>
<li><p><code>harmonics = c(1, 0.5, 0.25)</code> will produce a sound
with three harmonics (fundamental + 2 harmonics), the second
harmonic having an amplitude half the fundamental ampltiude and the second
harmonic an amplitude a quarter of the fundamental amplitude.
</p>
</li>
<li><p><code>harmonics = c(1, 0, 0.25)</code> will produce a sound with
two harmonics (fundamental + 1 harmonic) the second harmonic
having a null relative amplitude.
</p>
</li>
<li><p><code>harmonics = rep(1,4)</code> will produce a sound with four
harmonics (fundamental + 3 harmonics) of equal amplitude.
</p>
</li></ul>


</li></ul>



<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur and Laurent Lellouch.</p>


<h3>References</h3>

<p>Hartmann, W. M. 1998 <em>Signals, sound and sensation</em>. New York: Springer.</p>


<h3>See Also</h3>

<p><code><a href="#topic+synth2">synth2</a></code>, <code><a href="#topic+noisew">noisew</a></code>, <code><a href="HH.html#topic+pulse">pulse</a></code>, <code><a href="#topic+echo">echo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## You can use plot=TRUE and spectro() options
## to directly 'see' the new-built sounds
f &lt;- 8000 # sampling frequency
d &lt;- 1    # duration (1 s)
cf &lt;- 440 # carrier frequecy (440 Hz, i.e. flat A tone)
# pure sinusoidal tone
s &lt;- synth(f=f,d=d,cf=cf)
# pure triangular tone
s &lt;- synth(f=f,d=d,cf=cf, signal="tria")
# pure tone with triangle overall shape
s &lt;- synth(f=f,d=d,cf=cf,shape="tria")
# pure tones with am
s &lt;- synth(f=f,d=d,cf=cf,am=c(50,10))
# pure tones with am
# and phase shift of pi radian (180 degrees)
s &lt;- synth(f=f,d=d,cf=cf,am=c(50,10,pi))
# pure tone with +1000 Hz linear fm 
s &lt;- synth(f=f,d=d,cf=cf,fm=c(0,0,1000,0,0))
# pure tone with sinusoidal fm
# (maximum excursion of 250 Hz, frequency of 10 Hz)
s &lt;- synth(f=f,d=d,cf=cf,fm=c(250,10,0,0,0))
# pure tone with sinusoidal fm
# (maximum excursion of 250 Hz, frequency of 10 Hz,
# phase shift of pi radian (180 degrees))
s &lt;- synth(f=f,d=d,cf=cf,fm=c(250,10,0, pi,0))
# pure tone with sinusoidal am
# (maximum excursion of 250 Hz, frequency of 10 Hz)
# and linear fm (maximum excursion of 500 Hz)
s &lt;- synth(f=f,d=d,cf=cf,fm=c(250,10,500,0,0))
# the same with am
s &lt;- synth(f=f,d=d,cf=cf,am=c(50,10), fm=c(250,10,250,0,0))
# the same with am and a triangular overall shape 
s &lt;- synth(f=f,d=d,cf=cf,shape="tria",am=c(50,10), fm=c(250,10,250,0,0))
# an harmonic sound
s &lt;- synth(f=f,d=d,cf=cf, harmonics=c(1, 0.5, 0.25))
# a clarinet-like sound
clarinet &lt;- c(1, 0, 0.5, 0, 0.14, 0, 0.5, 0, 0.12, 0, 0.17)
s &lt;- synth(f=f, d=d, cf = 235.5, harmonics=clarinet)
# inharmonic FM sound built 'manually'
fm &lt;- c(250,5,0,0,0)
F1&lt;-synth(f=f,d=d,cf=cf,fm=fm)
F2&lt;-synth(f=f,d=d,a=0.8,cf=cf*2,fm=fm)
F3&lt;-synth(f=f,d=d,a=0.6,cf=cf*3.5,fm=fm)
F4&lt;-synth(f=f,d=d,a=0.4,cf=cf*6,fm=fm)
final1&lt;-F1+F2+F3+F4
spectro(final1,f=f,wl=512,ovlp=75,scale=FALSE)
</code></pre>

<hr>
<h2 id='synth2'>Synthesis of time wave (tonal model)</h2><span id='topic+synth2'></span>

<h3>Description</h3>

<p>This functions synthesizes pure tone sound based on an amplitude
envelope and an instantaneous frequency contour. The function can also be
used to modify a reference sound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synth2(env = NULL, ifreq, f, plot = FALSE, listen = FALSE, output = "matrix", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synth2_+3A_env">env</code></td>
<td>
<p>a numeric vector describing the amplitude envelope
(i.e. the amplitude modulation). By default <code>NULL</code>, generating a
squared enveloppe.</p>
</td></tr>
<tr><td><code id="synth2_+3A_ifreq">ifreq</code></td>
<td>
<p>a numeric vector describing the instantaneous frequency
(in Hz).</p>
</td></tr>
<tr><td><code id="synth2_+3A_f">f</code></td>
<td>
<p>a numeric vector for the sampling frequency (in Hz)</p>
</td></tr>
<tr><td><code id="synth2_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> returns the spectrogram
of the synthezised sound (by default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="synth2_+3A_listen">listen</code></td>
<td>
<p>if <code>TRUE</code> the new sound is played back.</p>
</td></tr>
<tr><td><code id="synth2_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="synth2_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+spectro">spectro</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>env</code> and <code>ifreq</code> must have exactly the same
length.<br />
The amplitude envelope can be obtained with the Hilbert envelope
(function <code><a href="#topic+env">env</a></code>) and the instantaneous frequency can be
obtained with the Hilbert transform (function
<code><a href="#topic+ifreq">ifreq</a></code>). This opens a great variety of signal
modidications as shown in the example section.
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Author(s)</h3>

<p>Jérôme Sueur and Laurent Lellouch</p>


<h3>References</h3>

<p>Beeman, K. 1998 Digital signal analysis, editing and synthesis, in
<em>Animal acoustic communication</em> edited by Hopp SL, Owren MJ, Evans CS,
Springer, 59-103.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+synth2">synth2</a></code>,  <code><a href="#topic+noisew">noisew</a></code>, <code><a href="HH.html#topic+pulse">pulse</a></code>, <code><a href="#topic+echo">echo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## You can use plot=TRUE and spectro() options
## to directly 'see' the new-built sounds
## MODIFICATION OF A REFERENCE SIGNAL
data(tico)
env.tico &lt;- env(tico, f=22050, plot=FALSE)
ifreq.tico &lt;- ifreq(tico, f=22050, plot=FALSE)$f[,2]
# recover the original signal
s &lt;- synth2(env=env.tico, ifreq=ifreq.tico*1000, f=22050)
# original signal with instantaneous frequency reversed
s &lt;- synth2(env=env.tico, ifreq=rev(ifreq.tico)*1000, f=22050)
# original signal with a +1000 Hz linear frequency shift
s &lt;- synth2(env=env.tico, ifreq=ifreq.tico*1000+1000, f=22050)
# original signal with instantaneous frequency multiplied by 2
s &lt;- synth2(env=env.tico, ifreq=ifreq.tico*1000*2, f=22050)
# original signal with a linear  instantaneous frequency at 2000 Hz
s &lt;- synth2(env=env.tico, ifreq=rep(2000, times=length(tico@left)), f=22050)

## DE NOVO SYNTHESIS
# instantaneous frequency increasing by step of 500 Hz
s &lt;- synth2(ifreq=rep(c(500,1000,1500,2000,2500,3000,3500,4000), each=2000), f=16000)
# square function of the instantaenous frequency
s &lt;- synth2(ifreq=500+seq(-50,50, length.out=8000)^2, f=8000)
# linear increase of the amplitude envelope
s &lt;- synth2(env=seq(0,1,length=8000), ifreq=rep(2000,8000), f=8000)
# square-root increase of the amplitude envelope
s &lt;- synth2(env=sqrt(seq(0,1,length=8000)), ifreq=rep(2000,8000), f=8000)
# square-root increase and decrease of the amplitude envelope
s &lt;- synth2(env=c(sqrt(seq(0,1,length=4000)), sqrt(seq(1,0,length=4000))),
    ifreq=rep(2000,8000), f=8000)
# amplitude envelope and instantaneous frequency following a normal density shape
norm &lt;- rep(dnorm(-4000:3999, sd=1000), 2)
s &lt;- synth2(env=norm, ifreq=500+(norm/max(norm))*1000, f=8000)
</code></pre>

<hr>
<h2 id='TFSD'>normalized Time and Frequency Second Derivative</h2><span id='topic+TFSD'></span>

<h3>Description</h3>

<p>This function computes the normalized Time and Frequency Second Derivative as described by Aumond et al. (2017).</p>


<h3>Usage</h3>

<pre><code class='language-R'>TFSD(wave, f, channel = 1, ovlp = 0,  wn = "hamming", flim = c(2,6), nbwindows = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TFSD_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="TFSD_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="TFSD_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="TFSD_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in %).</p>
</td></tr>
<tr><td><code id="TFSD_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="TFSD_+3A_flim">flim</code></td>
<td>
<p>a numeric vector of length 2 to select a frequency band
(in kHz). Cannot be NULL.</p>
</td></tr>
<tr><td><code id="TFSD_+3A_nbwindows">nbwindows</code></td>
<td>
<p>a numeric vector of length 1 specifying the number of
windows (by default 1, ie a single window including the complete <code>wave</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The TFSD aims at estimating the time of presence of avian or human vocalizations within a sound environment. It calculates the variation in time and frequency of a signal around frequencies of interest, normalized by the spectral time variation of a signal as a whole.<br />
</p>
<p>Warning, this index was initially developed to work from a third octave spectrogram with a time sampling of 125 ms.<br />
</p>
<p>TFSD is computed according to formulation in reference.<br />
</p>
<p>The higher the TFSD varies between 0 and 1, the greater the temporal presence of avian or human vocalizations.  With the default configuration, a TFSD &gt; 0.3 indicates a very important presence time of the vocalizations in the signal. The TFSD is always greater than 0.
</p>


<h3>Value</h3>

<p>A numeric vector of length nbwindows giving the TFSD values.</p>


<h3>Author(s)</h3>

<p>Pierre Aumond, Guillaume Corbeau</p>


<h3>References</h3>

<p>Aumond, P., Can, A., De Coensel, B., Botteldooren, D., Ribeiro, C., &amp; Lavandier, C. (2017). Modeling soundscape pleasantness using perceptual assessments and acoustic measurements along paths in urban context. <em>Acta Acustica united with Acustica</em>, 12, 50-67.<br />
<br />
Gontier, F., Lavandier, C., Aumond, P., Lagrange, M., &amp; Petiot, J. F. (2019). Estimation of the perceived time of presence of sources in urban acoustic environments using deep learning techniques. <em>Acta Acustica united with Acustica</em>, 105(6), 1053-1066.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ACI">ACI</a></code>, <code><a href="#topic+NDSI">NDSI</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Note that 'tico' is not a soundscape recording...
data(tico)
TFSD(tico)
## dividing the sound sample into 4 windows of equal duration
TFSD(tico, nbwindows=4)
## selection of a frequency band
TFSD(tico, flim=c(2,6))
</code></pre>

<hr>
<h2 id='th'>Temporal entropy</h2><span id='topic+th'></span>

<h3>Description</h3>

<p>Compute the entropy of a temporal envelope.</p>


<h3>Usage</h3>

<pre><code class='language-R'>th(env, breaks)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="th_+3A_env">env</code></td>
<td>
<p>a data set resulting of an envelope obtained
using <code><a href="#topic+env">env</a></code></p>
</td></tr>
<tr><td><code id="th_+3A_breaks">breaks</code></td>
<td>
<p>'breaks' argument of <code><a href="graphics.html#topic+hist">hist</a></code> to compute the
entropy on the distribution obtained with an histogram.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Temporal entropy is calculated according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">S = -\frac{\sum_{i = 1}^{N} y_i log_2(y_i)}{log_2(N)}</code>
</p>

<p>with:<br />
<em>y</em> = relative amplitude of the <em>i</em> envelope point,<br />
and
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i = 1}^{N} y_i = 1</code>
</p>
<p><br /> 
and <em>N</em> = number of envelope points.
</p>


<h3>Value</h3>

<p>A single value varying between 0 and 1 is returned.
The value has no unit.</p>


<h3>Note</h3>

<p>The temporal entropy of a noisy signal with many amplitude modulations
will tend towards 1 whereas the temporal entropy of quiet signal
will tend towards 0. <br />
Note, however, that a sustained sound with an almost
flat envelope will also show a very high temporal entropy except if
you compute the entropy on the distribution obtained with the histogram. See examples.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur, George Zhan for the idea and implementation of the
argument <code>breaks</code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sh">sh</a></code>, <code><a href="#topic+csh">csh</a></code>, <code><a href="#topic+H">H</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Temporal entropy of a cicada song
data(orni)
envorni&lt;-env(orni,f=22050,plot=FALSE)
th(envorni)
# Smoothing the envelope might slightly change the result.
envorniS&lt;-env(orni,f=22050,smooth=c(50,0),plot=FALSE)
th(envorniS)
# If we mute a part of the cicada song, the temporal entropy decreases
orni2&lt;-mutew(orni,f=22050,from=0.3,to=0.55,plot=FALSE)
envorni2&lt;-env(orni2,f=22050,plot=FALSE)
th(envorni2)
# The temporal entropy of noise tends towards 1
a&lt;-noisew(d=1,f=8000)
enva&lt;-env(a,f=8000,plot=FALSE)
th(enva)
# But be aware that the temporal entropy
# of a sustained sound also tends towards 1
b&lt;-synth(f=8000,d=1,cf=2000,plot=FALSE)
envb&lt;-env(b,f=8000,plot=FALSE)
th(envb)
# except if you use the distribution of the histogram
th(envb, breaks="Sturges")
</code></pre>

<hr>
<h2 id='tico'>Song of the bird Zonotrichia capensis</h2><span id='topic+tico'></span>

<h3>Description</h3>

<p>Recording of a song emitted by a male of the neotropical sparrow
<em>Zonotrichia capensis</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tico)</code></pre>


<h3>Format</h3>

<p>A Wave object.</p>


<h3>Details</h3>

<p>Duration = 1.795 s. Sampling frequency = 22050 hz.</p>


<h3>Source</h3>

<p>Recording by Thierry Aubin.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
oscillo(tico,f=22050)
</code></pre>

<hr>
<h2 id='timelapse'>Time lapse</h2><span id='topic+timelapse'></span>

<h3>Description</h3>

<p>Append successive input sounds into a single output sound</p>


<h3>Usage</h3>

<pre><code class='language-R'>timelapse(dir, from = 1, to = Inf,
units = c("samples", "seconds", "minutes", "hours"), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timelapse_+3A_dir">dir</code></td>
<td>
<p>a character vector, the path to the directory where the
.wav files are stored or directly the names of the .wav files to be appended.</p>
</td></tr>
<tr><td><code id="timelapse_+3A_from">from</code></td>
<td>
<p>where to start reading the input files, in <code>units</code>. See
<code>readWave</code> of the package <code>tuneR</code>.</p>
</td></tr>
<tr><td><code id="timelapse_+3A_to">to</code></td>
<td>
<p>where to stop reading, in <code>units</code>. See
<code>readWave</code> of the package <code>tuneR</code>.</p>
</td></tr>
<tr><td><code id="timelapse_+3A_units">units</code></td>
<td>
<p>time units in which <code>from</code> and <code>to</code> is given, the default is
<code>"samples"</code>, but can be set to time intervals such as <code>"seconds"</code>. See
<code>readWave</code> of the package <code>tuneR</code>.</p>
</td></tr>
<tr><td><code id="timelapse_+3A_verbose">verbose</code></td>
<td>
<p>a logical, if <code>TRUE</code> (default) the file number and name
processed are displayed in the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes the <code>.wav</code> files which names are provided in the
argument <code>dir</code> and append (paste) them successively so that a single object
is obtained. This can be used to produce sound time lapse based on a series
of ordered files as those produced by an automatic recorder
(e.g. SongMeter of the society 'Wildlife Acoustics').<br />
Only a section of each file can be extracted by using the arguments
<code>from</code> and <code>to</code>. 
The function is based on <code>readWave</code> and <code>bind</code> of the package <code>tuneR</code>.
</p>


<h3>Value</h3>

<p>A <code>Wave</code> object, a class defined in the package <code>tuneR</code>.</p>


<h3>Note</h3>

<p>The characteristics (sampling rate, number of bits, stereo/mono)
of the output object are those of the .wav file.<br />
The files should be alphabatically ordered according to time to
ensure a proper time lapse.<br />
You should use either <code>savewav</code> or <code>writeWave</code> to save the results as a <code>.wav</code> file. 
</p>


<h3>Author(s)</h3>

<p>Jérôme Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+pastew">pastew</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## if 'dir' contains a set of files recorded with a Wildlife Acoustics
# songmeter recorder then a direct way to obtain
# the spectrogram of all .wav files is
dir &lt;- "pathway-to-directory-containing-wav-files"
res &lt;- timelapse(dir)
# to extract a selection of each file (here a section starting
# at 10 s and ending at 12 s)
res &lt;- timelapse(dir, from=10, to=12, unit="seconds")

## End(Not run)
</code></pre>

<hr>
<h2 id='timer'>Time measurements of a time wave</h2><span id='topic+timer'></span>

<h3>Description</h3>

<p>This function computes and shows the duration of signal periods, 
pause periods and their ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timer(wave, f, channel = 1, threshold = 5, dmin = NULL, envt="abs",
power = 1, msmooth = NULL, ksmooth = NULL,
ssmooth = NULL, asmooth=NULL, tlim = NULL, plot = TRUE, plotthreshold = TRUE,
col = "black", colval = "red", 
xlab = "Time (s)", ylab = "Amplitude", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timer_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="timer_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="timer_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="timer_+3A_threshold">threshold</code></td>
<td>
<p>amplitude threshold for signal detection (in %), or
alternatively a function to be applied on the waveform scaled between
0 and 1. See examples.</p>
</td></tr>
<tr><td><code id="timer_+3A_dmin">dmin</code></td>
<td>
<p>time threshold (minimum duration) for signal detection (in s).</p>
</td></tr>  
<tr><td><code id="timer_+3A_envt">envt</code></td>
<td>
<p>the type of envelope to be used: either &quot;abs&quot; for absolute
amplitude envelope or &quot;hil&quot; for Hilbert amplitude envelope. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="timer_+3A_power">power</code></td>
<td>
<p>a power factor applied to the amplitude
envelope. Increasing <code>power</code> will reduce low amplitude
modulations and increase high amplide modulations. This can be used
to reduce background noise (by default equals to 1, <em>i.e.</em> no change.</p>
</td></tr>
<tr><td><code id="timer_+3A_msmooth">msmooth</code></td>
<td>
<p>a vector of length 2 to smooth the amplitude envelope with a 
mean sliding window. The first component is the window length
(in number of points). The second component is the overlap between
successive windows (in %).  See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="timer_+3A_ksmooth">ksmooth</code></td>
<td>
<p>kernel smooth for the amplitude enveloppe via <code><a href="stats.html#topic+kernel">kernel</a></code>. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="timer_+3A_ssmooth">ssmooth</code></td>
<td>
<p>sum smooth for the amplitude enveloppe. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="timer_+3A_asmooth">asmooth</code></td>
<td>
<p>autocorrelation smooth for the amplitude enveloppe. See <code><a href="#topic+env">env</a></code>.</p>
</td></tr>
<tr><td><code id="timer_+3A_tlim">tlim</code></td>
<td>
<p>modifications of the time X-axis limits.</p>
</td></tr>
<tr><td><code id="timer_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the envelope and the measurements 
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="timer_+3A_plotthreshold">plotthreshold</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the threshold
as an horizontal line on the graph (by default <code>TRUE</code>).</p>
</td></tr>  
<tr><td><code id="timer_+3A_col">col</code></td>
<td>
<p>colour of the envelope.</p>
</td></tr>
<tr><td><code id="timer_+3A_colval">colval</code></td>
<td>
<p>colour of plotted measurements.</p>
</td></tr>
<tr><td><code id="timer_+3A_xlab">xlab</code></td>
<td>
<p>title of the x-axis.</p>
</td></tr>
<tr><td><code id="timer_+3A_ylab">ylab</code></td>
<td>
<p>title of the y-axis.</p>
</td></tr>
<tr><td><code id="timer_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing seven items:
</p>
<table>
<tr><td><code>s</code></td>
<td>
<p>duration of signal period(s) in seconds</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>duration of pause period(s) in seconds</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>ratio between the signal and silence periods(s)</p>
</td></tr>
<tr><td><code>positions</code></td>
<td>
<p>a list containing four elements:</p>
</td></tr>
<tr><td><code>s.start</code></td>
<td>
<p>start position(s) of signal period(s)</p>
</td></tr>
<tr><td><code>s.end</code></td>
<td>
<p>end position(s) of signal period(s)</p>
</td></tr>
<tr><td><code>first</code></td>
<td>
<p>whether the first event detected is a pause or a signal</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Setting to high values to <code>msmooth</code> or
<code>ssmooth</code> might return inaccurate results. Double check your
results if so.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+env">env</a></code>, <code><a href="#topic+cutw">cutw</a></code>, <code><a href="#topic+pastew">pastew</a></code>.</p>

<hr>
<h2 id='TKEO'>Teager-Kaiser energy tracking operator</h2><span id='topic+TKEO'></span><span id='topic+tkeo'></span>

<h3>Description</h3>

<p>This function computes the Teager-Kaiser energy operator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>TKEO(wave, f, channel = 1, m = 1, M = 1, plot = TRUE,
xlab = "Time (s)", ylab = "Energy",
type = "l", bty = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TKEO_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="TKEO_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="TKEO_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="TKEO_+3A_m">m</code></td>
<td>
<p>a numeric vector of length 1 for the exponent parameter. See details.</p>
</td></tr>
<tr><td><code id="TKEO_+3A_m">M</code></td>
<td>
<p>a numeric vector of length 1 for the lag parameter. See details.</p>
</td></tr>
<tr><td><code id="TKEO_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> returns a plot of the TK energy
along time (by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="TKEO_+3A_xlab">xlab</code></td>
<td>
<p>Label of time x-axis.</p>
</td></tr>
<tr><td><code id="TKEO_+3A_ylab">ylab</code></td>
<td>
<p>Label of energy y-axis.</p>
</td></tr>
<tr><td><code id="TKEO_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="TKEO_+3A_bty">bty</code></td>
<td>
<p>the type of box to be drawn around the energy plot.</p>
</td></tr> 
<tr><td><code id="TKEO_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discrete version of the Teager-Kaiser operator is computed
according to: <br />
</p>
<p style="text-align: center;"><code class="reqn">y_{n} = x_{n}^{2/m} - (x_{n-M} \times x_{n+M})^{1/m}</code>
</p>
<p>, <br />
with <em>m</em> the exponent parameter and <em>M</em> the lag parameter
which both  are usually equal to 1 for a conventional operator. <br />
The Teaser-Kaiser operator can be used to track amplitude modulations (AM) and/or frequency modulations (FM).<br />
See examples.
</p>


<h3>Value</h3>

<p>This function returns a two-column matrix, the first column is
time and the second column includes the successive energy values. <br />
m/2 NA values are added at the start and end of the vector.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Kvedalen, E. (2003). <em>Signal processing using the Teager Energy
Operator and other nonlinear operators</em>. University of Oslo,
Department of Informatics, PhD Thesis, x + 100 p.</p>


<h3>See Also</h3>

<p><code><a href="#topic+env">env</a></code>, <code><a href="#topic+ifreq">ifreq</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>op &lt;- par(mfrow=c(2,1))

## sinusoid AM 
s1 &lt;- synth(f=8000, d=0.1, cf=200, am=c(100,10), output="Wave") 
oscillo(s1)
TKEO(s1)
## linear AM decrease
s2 &lt;- synth(f=8000, d=0.1, cf=200, shape="decr", output="Wave") 
oscillo(s2)
TKEO(s2)
## sinusoid FM
s3 &lt;- synth(f=8000, d=0.1, cf=200, fm=c(150,50,0,0,0), output="Wave") 
oscillo(s3)
TKEO(s3)
## linear FM increase
s4 &lt;- synth(f=8000, d=0.1, cf=200, fm=c(0,0,600,0,0), output="Wave") 
oscillo(s4)
TKEO(s4)
## AM and FM
s5 &lt;- synth(f=8000, d=0.1, cf=200, am=c(100,10), fm=c(150,50,0,0,0), output="Wave")
oscillo(s5)
TKEO(s5)
par(op)
</code></pre>

<hr>
<h2 id='wasp'>WAve length and SPeed of sound</h2><span id='topic+wasp'></span>

<h3>Description</h3>

<p>This function returns the wavelength and the speed of sound
of a given frequency in air, fresh-water or sea-water.</p>


<h3>Usage</h3>

<pre><code class='language-R'>wasp(f, t = 20, c = NULL, s = NULL, d = NULL, medium = "air")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wasp_+3A_f">f</code></td>
<td>
<p>frequency (Hz).</p>
</td></tr>
<tr><td><code id="wasp_+3A_t">t</code></td>
<td>
<p>temperature (degree Celsius).</p>
</td></tr>
<tr><td><code id="wasp_+3A_c">c</code></td>
<td>
<p>celerity (m/s) if a wavelength is to be found at a particular speed of sound.</p>
</td></tr>
<tr><td><code id="wasp_+3A_s">s</code></td>
<td>
<p>salinity (parts per thousand) when <code>medium</code> is <code>"sea"</code>.</p>
</td></tr>
<tr><td><code id="wasp_+3A_d">d</code></td>
<td>
<p>depth (m) when <code>medium</code> is <code>"sea"</code>.</p>
</td></tr>
<tr><td><code id="wasp_+3A_medium">medium</code></td>
<td>
<p>medium for sound propagation,
either &quot;air&quot;, &quot;fresh&quot; for fresh, or pure, water, &quot;sea&quot; for sea water.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Speed of sound in air is computed according to:<br />
</p>
<p style="text-align: center;"><code class="reqn">c = 331.4 + 0.6\times{t}</code>
</p>

<p>Speed of sound in fresh-water is computed according to Marczak equation:<br />
</p>
<p style="text-align: center;"><code class="reqn">c = 1.402385.10^{3} + 5.038813\times{t} - 5.799136.10^{-2}\times{t^{2}}</code>
</p>

<p style="text-align: center;"><code class="reqn">+ 3.287156.10^{-4}\times{t^{3}} - 1.398845.10^{-6}\times{t^{4}}</code>
</p>

<p style="text-align: center;"><code class="reqn">+ 2.787860.10^{-9}\times{t^{5}}</code>
</p>

<p>with <em>t</em> = temperature in degrees Celsius;
range of validity: 0-95 degrees Celcius at atmospheric pressure.<br />
</p>
<p>Speed of sound in sea-water is computed according to Mackenzie equation:<br />
</p>
<p style="text-align: center;"><code class="reqn">c = 1448.96 + 4.591\times{t}- 5.304.10^{-2}\times{t^{2}}</code>
</p>
      
<p style="text-align: center;"><code class="reqn">+ 2.374.10^{-4}\times{t^{3}} + 1.34\times{(s-35)} + 1.63.10^{-2}\times{d}</code>
</p>
  
<p style="text-align: center;"><code class="reqn">+ 1.675.10^{-7}\times{d^{2}} - 1.025.10^{-2}\times{t}\times{(s-35)}</code>
</p>
      
<p style="text-align: center;"><code class="reqn">- 7.139.10^{-13}\times{t}\times{d^3}</code>
</p>

<p>with <em>t</em> = temperature in degrees Celsius;
<em>s</em> = salinity in parts per thousand;
<em>d</em> = depth in meters;
range of validity: temperature 2 to 30 degrees Celcius, salinity 25 to 40 parts per thousand, depth 0 to 8000 m.<br />
</p>
<p>Wavelength is obtained following:<br />
</p>
<p style="text-align: center;"><code class="reqn">\lambda = \frac{c}{f}</code>
</p>

<p>with <em>c</em> = speed of sound in meters/second;
<em>f</em> = frequency in Hertz. 
</p>


<h3>Value</h3>

<p>A list of two values is returned:
</p>
<table>
<tr><td><code>l</code></td>
<td>
<p>wavelength in meters</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>speed of sound in meters/second.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>References</h3>

<p><a href="http://resource.npl.co.uk">http://resource.npl.co.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># wavelength (m) of a 2000 Hz air-borne sound at 20 degrees Celsius
wasp(f=2000)$l
# [1] 0.1717

# sound speed in sea at 0 and -500 m
# for a respective temperature of 22 degrees Celcius and 11 degrees Celcius
wasp(f=1000,s=30,d=c(0,500),t=c(22,11),medium="sea")$c
# [1] 1521.246 1495.414

# wavelength (m) of a 1000 Hz sound in a medium unspecified where c = 1497 m/s
wasp(f=1000,c=1497)$l
# [1] 1.497

# variation of wavelength according to frequency and air temperature
op&lt;-par(bg="lightgrey")
a&lt;-seq(1000,20000,by=100) ; na&lt;-length(a)
b&lt;-seq(-20,40,by=10) ; nb&lt;-length(b)
res&lt;-matrix(numeric(na*nb),nrow=na)
for(i in 1:nb) res[,i]&lt;-wasp(a,t=b[i])$l
matplot(x=a,y=res,type="l",lty=1,col= spectro.colors(nb),
  xlab="Frequency (Hz)",ylab="Wavelength (m)")
title("Wavelength of air-borne sound at different temperatures (deg. C)")
legend(x=15000,y=0.3,c("-20","-10","0","10","20","30","40"),
  lty=1,col= spectro.colors(nb),bg="grey")
par(op)
</code></pre>

<hr>
<h2 id='wav2dBSPL'>Convert wave amplitude to instantaneous sound pressure level (dB SPL)</h2><span id='topic+wav2dBSPL'></span>

<h3>Description</h3>

<p>This function applies an absolute dB SPL scale to the amplitude
of a time wave based on the properties of the recording chain, if
known.</p>


<h3>Usage</h3>

<pre><code class='language-R'>wav2dBSPL(wave, f, channel = 1, gain, sensitivity = -35, Vadc = 2, pref = 2 * 10^-5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wav2dBSPL_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="wav2dBSPL_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="wav2dBSPL_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="wav2dBSPL_+3A_gain">gain</code></td>
<td>
<p>total gain applied to the sound (preamplifer +
amplifier), in dB.</p>
</td></tr>
<tr><td><code id="wav2dBSPL_+3A_sensitivity">sensitivity</code></td>
<td>
<p>sensitivity of the microphone, in dB/V (by default - 35 dB/V).</p>
</td></tr>
<tr><td><code id="wav2dBSPL_+3A_vadc">Vadc</code></td>
<td>
<p>maximal voltage (peak to peak) converted by the analog to
digital convertor ADC, in V (by default 2 V).</p>
</td></tr>
<tr><td><code id="wav2dBSPL_+3A_pref">pref</code></td>
<td>
<p>sound pressure reference in the medium, in Pa (by default =
2*10^-5 Pa in air).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same legnth as <code>wave</code> containing the sound waveform in dB SPL (Sound Pressure level in dB)</p>


<h3>Note</h3>

<p>This function can be used to turn a recorder, as a Songmeter or an
Audiomoth, in a kind of soundlevel meter.</p>


<h3>Author(s)</h3>

<p>Sylvain Haupert</p>


<h3>See Also</h3>

<p><code><a href="#topic+wav2leq">wav2leq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## note that the original gain, sensitivity and Vadc of tico
## are unknown, this is therefore a kind of 'unreal' example
data(tico)
res &lt;- wav2dBSPL(tico, gain=18)
plot(x=seq(0,duration(tico),length=length(tico@left)), y=res, type="l", xlab="Time (s)",
ylab="dB SPL", las=1)
## dB SPL approximation for the complete sound
meandB(res)
</code></pre>

<hr>
<h2 id='wav2flac'>wav-flac file conversion</h2><span id='topic+wav2flac'></span>

<h3>Description</h3>

<p>This function converts .wav files into .flac files and reversely</p>


<h3>Usage</h3>

<pre><code class='language-R'>wav2flac(file, reverse = FALSE, overwrite = FALSE,
exename = NULL, path2exe = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wav2flac_+3A_file">file</code></td>
<td>
<p>the .wav or .flac file to convert.</p>
</td></tr>
<tr><td><code id="wav2flac_+3A_reverse">reverse</code></td>
<td>
<p>logical, if <code>TRUE</code> converts a .flac file into a .wav file.</p>
</td></tr>
<tr><td><code id="wav2flac_+3A_overwrite">overwrite</code></td>
<td>
<p>logical, if <code>TRUE</code> overwrites the file to convert.</p>
</td></tr>
<tr><td><code id="wav2flac_+3A_exename">exename</code></td>
<td>
<p>a character string specifying the name of the FLAC binary file. If <code>NULL</code>, the dedault name &quot;flac&quot; will be used for Linux OS and &quot;flac.exe&quot; for Windows OS.</p>
</td></tr>
<tr><td><code id="wav2flac_+3A_path2exe">path2exe</code></td>
<td>
<p>a character string giving the path to the FLAC binary file. If <code>NULL</code>, the dedault path &quot;c:/Program Files/FLAC/&quot; will be used for Windows OS.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs FLAC. FLAC has then to be installed first, if not the function will not work.</p>


<h3>Value</h3>

<p>A new file is created.</p>


<h3>Note</h3>

<p>FLAC must be installed to use this function but not to install the
package <code>seewave</code>. Free Lossless Audio Codec (FLAC) is a file format by Josh Coalson for lossless audio data compression. FLAC reduces bandwidth and storage requirements without sacrificing the integrity of the audio source. Audio sources encoded to FLAC are typically reduced in size 40 to 50 percent.</p>


<h3>Author(s)</h3>

<p>Luis J. Villanueva-Rivera</p>


<h3>See Also</h3>

<p><code><a href="#topic+savewav">savewav</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# synthesis of a 1kHz sound
a&lt;-synth(d=10,f=8000,cf=1000)
# save it as a .wav file in the default working directory
savewav(a,f=8000)
# compress it to FLAC format and overwrite on the file a.wav
wav2flac("a.wav", overwrite=TRUE)
# back to .wav format
wav2flac("a.flac", reverse=TRUE)
# remove the files
unlink(c("a.wav","a.flac"))

## End(Not run)
</code></pre>

<hr>
<h2 id='wav2leq'>Convert wave amplitude to equivalent continuous sound pressure level (Leq)</h2><span id='topic+wav2leq'></span>

<h3>Description</h3>

<p>This function computes the Leq value  of a time wave based
on the properties of the recording chain, if known.</p>


<h3>Usage</h3>

<pre><code class='language-R'>wav2leq(wave, f, channel = 1, gain, dt = 1, sensitivity = -35, Vadc = 2, pref = 2 * 10^-5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wav2leq_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="wav2leq_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="wav2leq_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="wav2leq_+3A_gain">gain</code></td>
<td>
<p>total gain applied to the sound (preamplifer +
amplifier), in dB.</p>
</td></tr>
<tr><td><code id="wav2leq_+3A_dt">dt</code></td>
<td>
<p>integration time step, in s (by default 1 s).</p>
</td></tr>
<tr><td><code id="wav2leq_+3A_sensitivity">sensitivity</code></td>
<td>
<p>sensitivity of the microphone, in dB/V (by default - 35 dB/V).</p>
</td></tr>
<tr><td><code id="wav2leq_+3A_vadc">Vadc</code></td>
<td>
<p>maximal voltage (peak to peak) converted by the analog to
digital convertor ADC, in V (by default 2 V).</p>
</td></tr>
<tr><td><code id="wav2leq_+3A_pref">pref</code></td>
<td>
<p>sound pressure reference in the medium, in Pa (by default =
2*10^-5 Pa in air).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 1 returning the Leq value, in dB.</p>


<h3>Note</h3>

<p>This function can be used to turn a recorder, as a Songmeter or an
Audiomoth, in a kind of soundlevel meter.</p>


<h3>Author(s)</h3>

<p>Sylvain Haupert</p>


<h3>See Also</h3>

<p><code><a href="#topic+wav2dBSPL">wav2dBSPL</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
## with a 1 s time of integration (that is for the first time window)
wav2leq(tico, gain=18)
## with a 0.5 s time of integration (that is for 3 successive time windows)
wav2leq(tico, dt=0.5, gain=18)
## for the complete sound
wav2leq(tico, dt=duration(tico), gain=18)
## which is equivalent to
meandB(wav2dBSPL(tico, gain=18))
</code></pre>

<hr>
<h2 id='wf'>Waterfall display</h2><span id='topic+wf'></span>

<h3>Description</h3>

<p>This function returns a waterfall display of
a short-term Fourier transform or of any matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>wf(wave, f, channel = 1, wl = 512, zp = 0, ovlp = 0, fftw= FALSE, dB = "max0",
dBref = NULL, wn = "hanning", x = NULL,
hoff = 1, voff = 1, col = heat.colors,
xlab = "Frequency (kHz)", ylab = "Amplitude (dB)",
xaxis = TRUE, yaxis = TRUE,
density = NULL, border = NULL, lines = FALSE, lwd=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wf_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="wf_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="wf_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>
<tr><td><code id="wf_+3A_wl">wl</code></td>
<td>
<p>window length for the analysis
(even number of points). (by default = 512)</p>
</td></tr>
<tr><td><code id="wf_+3A_zp">zp</code></td>
<td>
<p>zero-padding (even number of points), see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="wf_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive windows (in %).</p>
</td></tr>
<tr><td><code id="wf_+3A_fftw">fftw</code></td>
<td>
<p>if <code>TRUE</code> calls the function <code>FFT</code> of the
library <code>fftw</code>. See Notes of the <code>spectro</code>.</p>
</td></tr>
<tr><td><code id="wf_+3A_db">dB</code></td>
<td>
<p>a character string specifying the type dB to return: &quot;max0&quot; for a
maximum dB value at 0, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, and &quot;ITU&quot; for common dB weights.</p>
</td></tr>
<tr><td><code id="wf_+3A_dbref">dBref</code></td>
<td>
<p>a dB reference value when <code>dB</code> is <code>TRUE</code>. <code>NULL</code> by default
but should be set to 2*10e-5 for a 20 microPa reference.</p>
</td></tr>
<tr><td><code id="wf_+3A_wn">wn</code></td>
<td>
<p>window name, see <code><a href="#topic+ftwindow">ftwindow</a></code> (by default <code>"hanning"</code>).</p>
</td></tr>
<tr><td><code id="wf_+3A_x">x</code></td>
<td>
<p>a matrix if <code>wave</code> is not provided.</p>
</td></tr>
<tr><td><code id="wf_+3A_hoff">hoff</code></td>
<td>
<p>horizontal 'offset' which shifts actual x-values slightly
per row for visibility. Fractional parts will be removed.</p>
</td></tr>
<tr><td><code id="wf_+3A_voff">voff</code></td>
<td>
<p>vertical 'offset' which separates traces.</p>
</td></tr>
<tr><td><code id="wf_+3A_col">col</code></td>
<td>
<p>a color or a color palette function to be used to assign colors in
the plot</p>
</td></tr>
<tr><td><code id="wf_+3A_xlab">xlab</code></td>
<td>
<p>title of the frequency x-axis.</p>
</td></tr>
<tr><td><code id="wf_+3A_ylab">ylab</code></td>
<td>
<p>title of the amplitude y-axis.</p>
</td></tr>
<tr><td><code id="wf_+3A_xaxis">xaxis</code></td>
<td>
<p>a logical, if <code>TRUE</code> adds the frequency x-axis
according to <code>f</code>.</p>
</td></tr>
<tr><td><code id="wf_+3A_yaxis">yaxis</code></td>
<td>
<p>a logical, if <code>TRUE</code> adds the amplitude y-axis
according.</p>
</td></tr>
<tr><td><code id="wf_+3A_density">density</code></td>
<td>
<p>argument of <code><a href="graphics.html#topic+polygon">polygon</a></code>:
the density of shading lines, in lines per inch.  The default
value of 'NULL' means that no shading lines are drawn. A zero
value of 'density' means no shading nor filling whereas
negative values (and 'NA') suppress shading (and so allow
color filling).</p>
</td></tr>
<tr><td><code id="wf_+3A_border">border</code></td>
<td>
<p>argument of <code><a href="graphics.html#topic+polygon">polygon</a></code>:
the color to draw the border.  The default, 'NULL', means to
use 'par(&quot;fg&quot;)'.  Use 'border = NA' to omit borders.</p>
</td></tr>
<tr><td><code id="wf_+3A_lines">lines</code></td>
<td>
<p>a logical, if <code>TRUE</code> plots lines instead of surfaces
(polygons).</p>
</td></tr>
<tr><td><code id="wf_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="wf_+3A_...">...</code></td>
<td>
<p>other graphical arguments to passed to <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data input can be either a time wave (<code>wave</code>) or a matrix
(<code>x</code>). In that case, if <code>xaxis</code> is set to <code>TRUE</code> the
x-axis will follow the row index. To change it, turn <code>xaxis</code> to
<code>FALSE</code> and use <code><a href="graphics.html#topic+axis">axis</a></code> afterwards. See examples.</p>


<h3>Note</h3>

<p>The function is well adapted to display short-term Fourier
transform. However, any matrix can be called using the argument
<code>x</code> instead of <code>wave</code>.</p>


<h3>Author(s)</h3>

<p>Carl G. Witthoft and Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+spectro">spectro</a></code>, <code><a href="#topic+spectro3D">spectro3D</a></code>, <code><a href="#topic+dynspec">dynspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
wf(tico,f=22050)
# changing the display parameters
jet.colors &lt;- colorRampPalette(c("blue", "green"))
wf(tico,f=22050, hoff=0, voff=2, col=jet.colors, border = NA)
# matrix input instead of a time wave and transparent lines display
m &lt;- numeric()
for(i in seq(-pi,pi,len=40)) {m &lt;- cbind(m,10*(sin(seq(0,2*pi,len=100)+i)))}
wf(x=m, lines=TRUE, col="#0000FF50",xlab="Time", ylab="Amplitude",
main="waterfall display")
</code></pre>

<hr>
<h2 id='write.audacity'>Audacity audio markers export</h2><span id='topic+write.audacity'></span>

<h3>Description</h3>

<p>Write audio markers to be imported by Audacity.</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.audacity(x, filename)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.audacity_+3A_x">x</code></td>
<td>
<p>a data frame with the three or five colums, see details.</p>
</td></tr>
<tr><td><code id="write.audacity_+3A_filename">filename</code></td>
<td>
<p>name of the <code>.txt</code> file. (by default the name of
<code>x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>x</code> object should be a data frame with two or
three columns depending on whether the markers include frequency
limits or not : <br />
</p>

<ul>
<li><p>time limits only:
</p>

<ol>
<li><p>text label of each marker,
</p>
</li>
<li><p>time marker of the beginning of each marker,
</p>
</li>
<li><p>time marker of the end of each marker.
</p>
</li></ol>


</li>
<li><p>time and frequency limits:
</p>

<ol>
<li><p>text label of each marker,
</p>
</li>
<li><p>time marker of the beginning of each marker,
</p>
</li>
<li><p>time marker of the end of each marker,
</p>
</li>
<li><p>lower frequency limit of each marker,
</p>
</li>
<li><p>higher frequency limit of each marker.
</p>
</li></ol>


</li></ul>



<h3>Value</h3>

<p>A <code>.txt</code> file is generated to be imported as a markers in Audacity.</p>


<h3>Note</h3>

<p>Naming the columns of <code>x</code> is not necessary.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p>Audacity is a free software
distributed under the terms of the GNU General Public License.<br />
Web site: <a href="https://www.audacityteam.org/">https://www.audacityteam.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.audacity">read.audacity</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## 3 markers, time only
t1 &lt;- c(9.2, 16.2, 24.4)
t2 &lt;- c(11.7, 18.7, 26.9)
label &lt;- c("a", "b", "c")
df &lt;- data.frame(label, t1, t2)
write.audacity(df, filename="test-time.txt")
## 3 markers, time and frequency
t1 &lt;- c(9.4, 15.2, 24.9)
t2 &lt;- c(10.54, 16.6, 26.1)
f1 &lt;- c(1703.4, 3406.8, 1608.8)
f2 &lt;- c(7476.2, 8517.2, 5110.3)
label &lt;- c("a", "b", "c")
dff &lt;- data.frame(label, t1, t2, f1, f2)
write.audacity(dff, filename="test-time-frequency.txt")
## delete files
unlink(c("test-time.txt", "test-time-frequency.txt"))
</code></pre>

<hr>
<h2 id='zapsilw'>Zap silence periods of a time wave</h2><span id='topic+zapsilw'></span>

<h3>Description</h3>

<p>This function simply deletes the silence periods of a time wave. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zapsilw(wave, f, channel = 1, threshold = 5, plot = TRUE, output = "matrix", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zapsilw_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="zapsilw_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="zapsilw_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="zapsilw_+3A_threshold">threshold</code></td>
<td>
<p>amplitude threshold (in %) between silence and signal.</p>
</td></tr>
<tr><td><code id="zapsilw_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the orginal and the new oscillograms
(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="zapsilw_+3A_output">output</code></td>
<td>
<p>character string, the class of the object to return, either
<code>"matrix"</code>, <code>"Wave"</code>, <code>"Sample"</code>, <code>"audioSample"</code> or <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="zapsilw_+3A_...">...</code></td>
<td>
<p>other <code><a href="#topic+oscillo">oscillo</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, a new wave is returned. The class
of the returned object is set with the argument <code>output</code>.</p>


<h3>Note</h3>

<p>Use the argument <code>threshold</code> to set the level of silence. See
the <code>examples</code>.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>See Also</h3>

<p><code><a href="#topic+afilter">afilter</a></code>, <code><a href="#topic+oscillo">oscillo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orni)
zapsilw(orni,f=22050,colwave="red")
# setting the threshold value
zapsilw(orni,f=22050,threshold=1)
</code></pre>

<hr>
<h2 id='zc'>Instantaneous frequency of a time wave by zero-crossing</h2><span id='topic+zc'></span>

<h3>Description</h3>

<p>This function measures the period of a full oscillating cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zc(wave, f, channel = 1,  plot = TRUE, interpol = 1, threshold = NULL,
xlab = "Time (s)", ylab = "Frequency (kHz)", ylim = c(0, f/2000),
warning = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zc_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="zc_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="zc_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="zc_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> plots the dominant frequency along
the time wave(by default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="zc_+3A_interpol">interpol</code></td>
<td>
<p>a numeric vector of length 1, interpolation factor.</p>
</td></tr>
<tr><td><code id="zc_+3A_threshold">threshold</code></td>
<td>
<p>amplitude threshold for signal detection (in % ).</p>
</td></tr>
<tr><td><code id="zc_+3A_xlab">xlab</code></td>
<td>
<p>title of the x axis.</p>
</td></tr>
<tr><td><code id="zc_+3A_ylab">ylab</code></td>
<td>
<p>title of the y axis.</p>
</td></tr>
<tr><td><code id="zc_+3A_ylim">ylim</code></td>
<td>
<p>the range of y values.</p>
</td></tr>
<tr><td><code id="zc_+3A_warning">warning</code></td>
<td>
<p>a logial to specify if warning message should be
displayed or not when <code>interpol</code> is &gt; 100.</p>
</td></tr>
<tr><td><code id="zc_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>plot</code> is <code>FALSE</code>, <code>zc</code> returns a vector of numeric data with
the instantaneous frequency. 
</p>


<h3>Value</h3>

<p>If <code>plot</code> is <code>FALSE</code>, <code>zc</code> returns a two-column matrix, the first column corresponding to time in seconds (<em>x</em>-axis) and the second column corresponding
to the instantaneous frequency of the time wave in kHz (<em>y</em>-axis). <br />
&lsquo;NA&rsquo;s correspond either to pause periods (e. g. detected applying
<code>threshold</code>) or sections of the time wave not crossing the zero line. To remove &lsquo;NA&rsquo;s with <code><a href="stats.html#topic+na.omit">na.omit</a></code> allows to get only instantaneous frequency values but
discards information about pause sections.</p>


<h3>Note</h3>

<p><code>interpol</code> adds points to the time wave by linear interpolation
(through <code><a href="stats.html#topic+approx">approx</a></code>). This increases measurement precision but as well
time process. Type argument of <code>plot</code> cannot be set to &ldquo;l&rdquo;.</p>


<h3>Author(s)</h3>

<p>Jerome Sueur <a href="mailto:sueur@mnhn.fr">sueur@mnhn.fr</a>,
Caroline Simonis and Thierry Aubin</p>


<h3>References</h3>

<p>Hopp, S. L., Owren, M. J. and Evans, C. S. (Eds) 1998.
<em>Animal acoustic communication.</em> Springer, Berlin, Heidelberg.</p>


<h3>See Also</h3>

<p><code><a href="#topic+zc">zc</a></code>, <code><a href="#topic+ifreq">ifreq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pellucens)
pellu1 &lt;- cutw(pellucens,f=22050,from=0,to=1,plot=FALSE)
# without interpolation
zc(pellu1,f=22050,threshold=5,pch=20)
# with interpolation
zc(pellu1,f=22050,threshold=5,interpol=20,pch=20)
# a way to plot with a line and to filter low frequencies
pellu2 &lt;- zc(pellu1,f=22050,threshold=5,interpol=20,plot=FALSE)
pellu3 &lt;- na.omit(pellu2[,2])
pellu4 &lt;- pellu3[pellu3&gt;3]
plot(x=seq(0,nrow(pellu1)/22050,length.out=length(pellu4)),
    y=pellu4,type="l",xlab="Time(s)",ylab="Frequency(kHz)")
</code></pre>

<hr>
<h2 id='zcr'>Zero-crossing rate</h2><span id='topic+zcr'></span>

<h3>Description</h3>

<p>This functions computes the zero-crossing rate of a time
function, i. e. the average number the sign of a time wave changes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>zcr(wave, f, channel = 1, wl = 512, ovlp = 0, plot = TRUE, type = "o", xlab =
"Time (s)", ylab = "Zero crossing rate", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zcr_+3A_wave">wave</code></td>
<td>
<p>an R object.</p>
</td></tr>     
<tr><td><code id="zcr_+3A_f">f</code></td>
<td>
<p>sampling frequency of <code>wave</code> (in Hz). Does not need to
be specified if embedded in <code>wave</code>.</p>
</td></tr>
<tr><td><code id="zcr_+3A_channel">channel</code></td>
<td>
<p>channel of the R object, by default left channel (1).</p>
</td></tr>  
<tr><td><code id="zcr_+3A_wl">wl</code></td>
<td>
<p>length of the window for the analysis (even number of
points, by default = 512). If <code>NULL</code> the zero-crossing rate is
computed of the complete signal.</p>
</td></tr>
<tr><td><code id="zcr_+3A_ovlp">ovlp</code></td>
<td>
<p>overlap between two successive analysis windows (in %) if
<code>wl</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="zcr_+3A_plot">plot</code></td>
<td>
<p>a logical, if <code>TRUE</code> plots a the zero-crossing rate
results along time.</p>
</td></tr>
<tr><td><code id="zcr_+3A_type">type</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, type of plot that should be drawn.
See <code><a href="graphics.html#topic+plot">plot</a></code> for details (by default &quot;l&quot; for lines).</p>
</td></tr>
<tr><td><code id="zcr_+3A_xlab">xlab</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, label of the x axis.</p>
</td></tr>
<tr><td><code id="zcr_+3A_ylab">ylab</code></td>
<td>
<p>if <code>plot</code> is <code>TRUE</code>, label of the y axis.</p>
</td></tr>
<tr><td><code id="zcr_+3A_...">...</code></td>
<td>
<p>other <code><a href="graphics.html#topic+plot">plot</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero-crossing rate is computed according to: <br />
</p>
<p style="text-align: center;"><code class="reqn">zcr = \frac{1}{2 \times N} \sum_{t=0}^{N-1} |sgn[x(t+1)] -sgn[x(t)]|</code>
</p>

<p>with:<br />
<em>N</em> the length of the signal <em>x</em> <br />
and where:
</p>
<p style="text-align: center;"><code class="reqn">sgn[x(t)] = 1</code>
</p>

<p>if </p>
<p style="text-align: center;"><code class="reqn">x(t) \geq 0</code>
</p>

<p>and </p>
<p style="text-align: center;"><code class="reqn">sgn[x(t)] = -1</code>
</p>

<p>if </p>
<p style="text-align: center;"><code class="reqn">x(t) &lt; 0</code>
</p>



<h3>Value</h3>

<p>The are two possibilities:
</p>

<ol>
<li><p> a numeric vector of length 1 if <code>wl</code> is <code>NULL</code>,
</p>
</li>
<li><p> a numeric two-column matrix is returned with the first columnn being
time (s) and the second colum being the zero-crossing rate (no scale) if <code>wl</code> is not <code>NULL</code>. 
</p>
</li></ol>



<h3>Note</h3>

<p>The are two possibilities:
</p>

<ol>
<li><p> if <code>wl</code> is <code>NULL</code> then the zero-crossing rate is
computed for the complete signal.
</p>
</li>
<li><p> if <code>wl</code> is not <code>NULL</code> the the zero-crossing rate is
computed for for a window sliding along the time wave.</p>
</li></ol>

<p>The ZCR is supposed to help in detection of voiced/unvoiced sound sections.
</p>


<h3>Author(s)</h3>

<p>Jerome Sueur</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Zero-crossing_rate">https://en.wikipedia.org/wiki/Zero-crossing_rate</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+zc">zc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tico)
## a single value for the complete signal, no plot
zcr(tico, wl=NULL)
## a series of values computed for a sliding window of 512 samples, plot
zcr(tico)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
