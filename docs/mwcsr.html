<!DOCTYPE html><html><head><title>Help for package mwcsr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mwcsr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#annealing_solver'><p>Construct an annealing solver</p></a></li>
<li><a href='#bionet_example'><p>Example MWCS instance obtained from BioNet package tutorial</p></a></li>
<li><a href='#gam_example'><p>GAM instance for MWCS problem</p></a></li>
<li><a href='#gatom_example'><p>Example of graph from which an SGMWCS instance can be obtained</p></a></li>
<li><a href='#get_instance_type'><p>Check the type and the validity of an MWCS instance</p></a></li>
<li><a href='#get_weight'><p>Calculate weight of the solution. MWCS, GMWCS and SGMWCS instances are supported</p></a></li>
<li><a href='#gmwcs_example'><p>Example GMWCS instance</p></a></li>
<li><a href='#gmwcs_small_instance'><p>Small example of GMWCS instance for demonstration purposes.</p></a></li>
<li><a href='#mwcs_example'><p>Example MWCS instance</p></a></li>
<li><a href='#mwcs_small_instance'><p>Small example of MWCS instance for demonstration purposes.</p></a></li>
<li><a href='#normalize_sgmwcs_instance'><p>Helper function to convert an <code>igraph</code> object into a proper SGMWCS instance</p></a></li>
<li><a href='#parameters'><p>The method returns all parameters supported by specific solver</p></a></li>
<li><a href='#rmwcs_solver'><p>Generate a rmwcs solver</p></a></li>
<li><a href='#rnc_solver'><p>Construct relax-and-cut SGMWCS solver</p></a></li>
<li><a href='#scipjack_solver'><p>Construct a SCIP-jack solver</p></a></li>
<li><a href='#set_parameters'><p>Sets values of specific parameters</p></a></li>
<li><a href='#sgmwcs_example'><p>Example SGMWCS instance</p></a></li>
<li><a href='#sgmwcs_small_instance'><p>Small example of SGMWCS instance for demonstration purposes.</p></a></li>
<li><a href='#solve_mwcsp'><p>Solves a MWCS instance.</p></a></li>
<li><a href='#timelimit&lt;-'><p>Sets time limitation for a solver</p></a></li>
<li><a href='#virgo_solver'><p>Construct a virgo solver</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Solvers for Maximum Weight Connected Subgraph Problem and Its
Variants</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms for solving various Maximum
    Weight Connected Subgraph Problems, including variants with
    budget constraints, cardinality constraints, weighted edges and signals.
    The package represents an R interface to high-efficient solvers based on
    relax-and-cut approach (√Ålvarez-Miranda E., Sinnl M. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.cor.2017.05.015">doi:10.1016/j.cor.2017.05.015</a>&gt;)
    mixed-integer programming (Loboda A., Artyomov M., and Sergushichev A. (2016) &lt;<a href="https://doi.org/10.1007%2F978-3-319-43681-4_17">doi:10.1007/978-3-319-43681-4_17</a>&gt;)
    and simulated annealing.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, igraph, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, mathjaxr, testthat, BioNet, roxygen2, DLBCL</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java (&gt;=8)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ctlab/mwcsr">https://github.com/ctlab/mwcsr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ctlab/mwcsr/issues">https://github.com/ctlab/mwcsr/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-02 09:20:48 UTC; aloboda</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Loboda [aut, cre],
  Nikolay Poperechnyi [aut],
  Eduardo Alvarez-Miranda [aut],
  Markus Sinnl [aut],
  Alexey Sergushichev [aut],
  Paul Hosler Jr. [cph] (Bundled JOpt Simple package),
  www.hamcrest.org [cph] (Bundled hamcrest package),
  Barak Naveh and Contributors [cph] (Bundled JGraphT package),
  The Apache Software Foundation [cph] (Bundled Apache Commons Math
    package)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Loboda &lt;aleks.loboda@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-02 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='annealing_solver'>Construct an annealing solver</h2><span id='topic+annealing_solver'></span>

<h3>Description</h3>

<p>Simulated annealing is a heuristic method of solving optimization problems.
Typically, it allows to find some good solution in a short time. This
implementation doesn't compute any upper bound on solution, so there is no
guarantee of optimality of solution provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annealing_solver(
  schedule = c("fast", "boltzmann"),
  initial_temperature = 1,
  final_temperature = 1e-06,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annealing_solver_+3A_schedule">schedule</code></td>
<td>
<p>boltzmann annealing or fast annealing</p>
</td></tr>
<tr><td><code id="annealing_solver_+3A_initial_temperature">initial_temperature</code></td>
<td>
<p>initial value for the temperature</p>
</td></tr>
<tr><td><code id="annealing_solver_+3A_final_temperature">final_temperature</code></td>
<td>
<p>final value for the temperature</p>
</td></tr>
<tr><td><code id="annealing_solver_+3A_verbose">verbose</code></td>
<td>
<p>whether be verbose or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Algorithm maintains connected subgraph staring with empty subgraph.
Each iteration one random action is considered. It may be a removal of a
vertex or an edge which does not separate graph or addition of an extra vertex or
an edge neighboring existing graph. If the subgraph is empty all vertices
are considered as candidates to form a subgaph. After candidate is chosen two
subgraph scores are considered: for a new subgraph and for an old one. Simulated
annealing operates with a notion of temperature. The candidate action is
accepted with probability: p(S'|S) = exp(-E / T), where E is weight difference
between subgraphs and T is current temperature.
</p>
<p>Temperature is calculated in each iteration. in <code>mwcsr</code> there are two
temperature schedules supported. So called Boltmann annealing uses the formula:
T(k) = T0 / (ln(1 + k)), while in case of fast annealing this one is used:
T(k) = T0 / k, where k is iteration number.
</p>
<p>To tune the algorithm it is useful to realize how typical changes in the goal
function for single actions are distributed. Calculating the acceptance probabilities
at initial temperature and final temperatures may help to choose schedule and
temperatures.
</p>


<h3>Value</h3>

<p>An object of class <code>mwcs_solver</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+rnc_solver">rnc_solver</a> will probably be a better choice with minimal tuning necessary
</p>

<hr>
<h2 id='bionet_example'>Example MWCS instance obtained from BioNet package tutorial</h2><span id='topic+bionet_example'></span>

<h3>Description</h3>

<p>Example MWCS instance obtained from BioNet package tutorial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bionet_example
</code></pre>


<h3>Format</h3>

<p>An object of class <code>igraph</code> of length 2559.
</p>

<hr>
<h2 id='gam_example'>GAM instance for MWCS problem</h2><span id='topic+gam_example'></span>

<h3>Description</h3>

<p>A dataset containing some real-world instances appeared in network
enrichment analysis tool
<a href="https://artyomovlab.wustl.edu/shiny/gam/">Shiny GAM</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam_example
</code></pre>


<h3>Format</h3>

<p>A vector of named vertex-weighted igraph instances
</p>


<h3>Source</h3>

<p><a href="http://dimacs11.zib.de/instances/MWCS-GAM.zip">http://dimacs11.zib.de/instances/MWCS-GAM.zip</a>
</p>

<hr>
<h2 id='gatom_example'>Example of graph from which an SGMWCS instance can be obtained</h2><span id='topic+gatom_example'></span>

<h3>Description</h3>

<p>The graph is based on <code>gatom</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gatom_example
</code></pre>


<h3>Format</h3>

<p>An object of class <code>igraph</code> of length 194.
</p>

<hr>
<h2 id='get_instance_type'>Check the type and the validity of an MWCS instance</h2><span id='topic+get_instance_type'></span>

<h3>Description</h3>

<p>Check the type and the validity of an MWCS instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_instance_type(instance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_instance_type_+3A_instance">instance</code></td>
<td>
<p><code>igraph</code> object, containing an instance to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with members <code>type</code> containing the type of the instance,
<code>valid</code> &ndash; boolean flag indicating whether the instance is valid or not,
<code>errors</code> &ndash; a character vector containing the error messages
</p>
<p>A list with two fields: the type of the instance with which it will
be treated by solve_mwcsp function and boolean showing validness of the instance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mwcs_example)
get_instance_type(mwcs_example)
</code></pre>

<hr>
<h2 id='get_weight'>Calculate weight of the solution. MWCS, GMWCS and SGMWCS instances are supported</h2><span id='topic+get_weight'></span>

<h3>Description</h3>

<p>Calculate weight of the solution. MWCS, GMWCS and SGMWCS instances are supported
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_weight(solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_weight_+3A_solution">solution</code></td>
<td>
<p>Either <code>mwcsp_solution</code> or 'igraph&ldquo; object representing the solution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Weight of the subgraph
</p>

<hr>
<h2 id='gmwcs_example'>Example GMWCS instance</h2><span id='topic+gmwcs_example'></span>

<h3>Description</h3>

<p>Instance is based on <code>gatom</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmwcs_example
</code></pre>


<h3>Format</h3>

<p>An object of class <code>igraph</code> of length 194.
</p>

<hr>
<h2 id='gmwcs_small_instance'>Small example of GMWCS instance for demonstration purposes.</h2><span id='topic+gmwcs_small_instance'></span>

<h3>Description</h3>

<p>Small example of GMWCS instance for demonstration purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmwcs_small_instance
</code></pre>


<h3>Format</h3>

<p>An object of class <code>igraph</code> of length 5.
</p>

<hr>
<h2 id='mwcs_example'>Example MWCS instance</h2><span id='topic+mwcs_example'></span>

<h3>Description</h3>

<p>Instance is based on <code>gatom</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mwcs_example
</code></pre>


<h3>Format</h3>

<p>An object of class <code>igraph</code> of length 194.
</p>

<hr>
<h2 id='mwcs_small_instance'>Small example of MWCS instance for demonstration purposes.</h2><span id='topic+mwcs_small_instance'></span>

<h3>Description</h3>

<p>Small example of MWCS instance for demonstration purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mwcs_small_instance
</code></pre>


<h3>Format</h3>

<p>An object of class <code>igraph</code> of length 5.
</p>

<hr>
<h2 id='normalize_sgmwcs_instance'>Helper function to convert an <code>igraph</code> object into a proper SGMWCS instance</h2><span id='topic+normalize_sgmwcs_instance'></span>

<h3>Description</h3>

<p>This function generates new <code>igraph</code> object with additional <code>signals</code> field added.
The way the instance is constructed is defined by the function parameters.
Nodes and edges are grouped separately, grouping columns are defined
by <code>nodes.group.by</code> and <code>edges.group.by</code> arguments. <code>group.only.positive</code> param specifies
whether to group only positive-weighted (specified by <code>nodes/edges.weight.column</code>) nodes and edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_sgmwcs_instance(
  g,
  nodes.weight.column = "weight",
  edges.weight.column = "weight",
  nodes.group.by = "signal",
  edges.group.by = "signal",
  group.only.positive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_sgmwcs_instance_+3A_g">g</code></td>
<td>
<p>Graph to convert</p>
</td></tr>
<tr><td><code id="normalize_sgmwcs_instance_+3A_nodes.weight.column">nodes.weight.column</code></td>
<td>
<p>Nodes column name (e.g. weight, score, w) for scoring</p>
</td></tr>
<tr><td><code id="normalize_sgmwcs_instance_+3A_edges.weight.column">edges.weight.column</code></td>
<td>
<p>Edges column name for scoring</p>
</td></tr>
<tr><td><code id="normalize_sgmwcs_instance_+3A_nodes.group.by">nodes.group.by</code></td>
<td>
<p>Nodes grouping column (e.g. signal, group, class)</p>
</td></tr>
<tr><td><code id="normalize_sgmwcs_instance_+3A_edges.group.by">edges.group.by</code></td>
<td>
<p>Edges grouping column</p>
</td></tr>
<tr><td><code id="normalize_sgmwcs_instance_+3A_group.only.positive">group.only.positive</code></td>
<td>
<p>Whether to group only positive-scored nodes/edges#'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>igraph</code> object with proper attributes set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("gatom_example")
normalize_sgmwcs_instance(gatom_example)

</code></pre>

<hr>
<h2 id='parameters'>The method returns all parameters supported by specific solver</h2><span id='topic+parameters'></span>

<h3>Description</h3>

<p>The method returns all parameters supported by specific solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameters(solver)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameters_+3A_solver">solver</code></td>
<td>
<p>a solver object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table containing parameter names and possible values for each parameter.
</p>

<hr>
<h2 id='rmwcs_solver'>Generate a rmwcs solver</h2><span id='topic+rmwcs_solver'></span>

<h3>Description</h3>

<p>The method is based on relax-and-cut approach and allows to solve
Maximum Weight Subgraph Probleam and its budget and cardinality variants.
By constructing lagrangian
relaxation of MWCS problem necessary graph connectivity constraints are introduced
in the objective function giving upper bound on the weight of the optimal
solution. On the other side, primal heuristic uses individul contribution
of the variables to lagrangian relaxation to find possible solution of the initial
problem. The relaxation is then optimized by using iterative subgradient method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmwcs_solver(
  timelimit = 1800L,
  max_iterations = 1000L,
  beta_iterations = 5L,
  separation = "strong",
  start_constraints = TRUE,
  pegging = TRUE,
  max_age = 10,
  sep_iterations = 10L,
  sep_iter_freeze = 50L,
  heur_iterations = 10L,
  subgradient = "classic",
  beta = 2,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmwcs_solver_+3A_timelimit">timelimit</code></td>
<td>
<p>Timelimit in seconds</p>
</td></tr>
<tr><td><code id="rmwcs_solver_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="rmwcs_solver_+3A_beta_iterations">beta_iterations</code></td>
<td>
<p>Number of nonimproving iterations until beta is halved</p>
</td></tr>
<tr><td><code id="rmwcs_solver_+3A_separation">separation</code></td>
<td>
<p>Separation: &quot;strong&quot; or &quot;fast&quot;</p>
</td></tr>
<tr><td><code id="rmwcs_solver_+3A_start_constraints">start_constraints</code></td>
<td>
<p>Whether to add flow-conservation/degree constraints at start</p>
</td></tr>
<tr><td><code id="rmwcs_solver_+3A_pegging">pegging</code></td>
<td>
<p>variable fixing</p>
</td></tr>
<tr><td><code id="rmwcs_solver_+3A_max_age">max_age</code></td>
<td>
<p>number of iterations in aging procedure for non-violated  cuts</p>
</td></tr>
<tr><td><code id="rmwcs_solver_+3A_sep_iterations">sep_iterations</code></td>
<td>
<p>Frequency of separating cuts (in iterations)</p>
</td></tr>
<tr><td><code id="rmwcs_solver_+3A_sep_iter_freeze">sep_iter_freeze</code></td>
<td>
<p>Number of iterations when a newly separated cut is anaffected by subgradient algorithm.</p>
</td></tr>
<tr><td><code id="rmwcs_solver_+3A_heur_iterations">heur_iterations</code></td>
<td>
<p>Frequency of calling heuristic method (in iterations)</p>
</td></tr>
<tr><td><code id="rmwcs_solver_+3A_subgradient">subgradient</code></td>
<td>
<p>Subgradient: &quot;classic&quot;, &quot;average&quot;, &quot;cft&quot;</p>
</td></tr>
<tr><td><code id="rmwcs_solver_+3A_beta">beta</code></td>
<td>
<p>Initial step size of subgradient algorithm</p>
</td></tr>
<tr><td><code id="rmwcs_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should the solving progress and stats be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One iteration of algorithm includes solving lagrangian relaxation and updating
lagrange multipliers. It may also contain cuts (or connectivity constraints) separation process, run of
heuristic method, variable fixing routine. The initial step size for
subgradient method can be passed as <code>beta</code> argument. If there is no improvement in
upper bound in consequtive <code>beta_iterations</code> iterations the step size is
halved. There are three possible strategies for updating multipliers. See the references
section for the article where differences are discussed.
</p>
<p>Some initial cuts are added at the start of the algorithm if <code>start_constraints</code>
is set to <code>TRUE</code>. Other constraints are separated on the fly and are
unaffected in the next <code>sep_iter_freeze</code> iterations of the subgradient mehod.
Then the corresponding lagrange mutipliers are updated from iteration to iteration.
Aging procedure for cuts is incorporated in the algorithm meaning constraint multipliers
are updated for non-violated cuts for up to <code>max_age</code> iterations from
the point where a cut was violated last time. There are two separation methods
implemented: fast and strong, where tha latter is supposed to minimize number of
variables used in generated constraint while in the former case there is no need to explore
whole graph to construct a constraint.
</p>
<p>A variant of MST approximation of PCSTP is used as Primal Heuristic.
See references for more details.
</p>
<p>The frequences
of running separation process and heuristic are specified in
<code>sep_iterations</code> and <code>heur_iterations</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>mwcs_solver</code>.
</p>


<h3>References</h3>

<p>√Ålvarez-Miranda E., Sinnl M. (2017)
&quot;A Relax-and-Cut framework for large-scale maximum weight connected subgraph problems&quot;
<a href="https://doi.org/10.1016/j.cor.2017.05.015">doi:10.1016/j.cor.2017.05.015</a>
</p>

<hr>
<h2 id='rnc_solver'>Construct relax-and-cut SGMWCS solver</h2><span id='topic+rnc_solver'></span>

<h3>Description</h3>

<p>The solver is based on the same approach as rmwcs solver. Modifications to
the original scheme are introduced to tackle problems arising with introduction
of edge weights and signals. It is recommended to use rmwcs solver to solve MWCS
problems, while due to differences in primal heuristic it may be a good pratice
to run both solvers on the same problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnc_solver(
  max_iterations = 1000L,
  beta_iterations = 50L,
  heur_iterations = 10L,
  sep_iterations = 10L,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnc_solver_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="rnc_solver_+3A_beta_iterations">beta_iterations</code></td>
<td>
<p>Number of nonimproving iterations until beta is halved</p>
</td></tr>
<tr><td><code id="rnc_solver_+3A_heur_iterations">heur_iterations</code></td>
<td>
<p>Frequency of calling heuristic method (in iterations)</p>
</td></tr>
<tr><td><code id="rnc_solver_+3A_sep_iterations">sep_iterations</code></td>
<td>
<p>Frequency of separating cuts (in iterations)</p>
</td></tr>
<tr><td><code id="rnc_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should the solving progress and stats be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mwcs_solver</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+rmwcs_solver">rmwcs_solver</a>
</p>

<hr>
<h2 id='scipjack_solver'>Construct a SCIP-jack solver</h2><span id='topic+scipjack_solver'></span>

<h3>Description</h3>

<p>This solver requires STP extension of <a href="https://scipopt.org/#scipoptsuite">SCIP-jack</a> solver.
To use this class you first need to download and build <code>SCIP-jack</code> and
<code>SCIPSTP</code> application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scipjack_solver(scipstp_bin, config_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scipjack_solver_+3A_scipstp_bin">scipstp_bin</code></td>
<td>
<p>path to <code style="white-space: pre;">&#8288;scipstp binary&#8288;</code>.</p>
</td></tr>
<tr><td><code id="scipjack_solver_+3A_config_file">config_file</code></td>
<td>
<p>scipstp-formatted file. Parameters list is accessible
at  <a href="https://www.scipopt.org/doc-6.0.2/html/PARAMETERS.php">Official SCIP website</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can access solver directly using <code>run_scip</code> function. See example.
</p>


<h3>References</h3>

<p>Rehfeldt D., Koch T. (2019)
&quot;Combining NP-Hard Reduction Techniques and Strong Heuristics in an Exact Algorithm for the Maximum-Weight Connected Subgraph Problem.&quot;
<a href="https://doi.org/10.1137/17M1145963">doi:10.1137/17M1145963</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("bionet_example")
scip &lt;- scipjack_solver(scipstp_bin='/path/to/scipoptsuite/build/bin/applications/scipstp')
sol &lt;- solve_mwcsp(scip, bionet_example)

## End(Not run)
</code></pre>

<hr>
<h2 id='set_parameters'>Sets values of specific parameters</h2><span id='topic+set_parameters'></span>

<h3>Description</h3>

<p>Sets values of specific parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_parameters(solver, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_parameters_+3A_solver">solver</code></td>
<td>
<p>a solver</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_...">...</code></td>
<td>
<p>listed parameter names and values assigned to them</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The solver with parameters changed.
</p>

<hr>
<h2 id='sgmwcs_example'>Example SGMWCS instance</h2><span id='topic+sgmwcs_example'></span>

<h3>Description</h3>

<p>Instance is based on <code>gatom</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgmwcs_example
</code></pre>


<h3>Format</h3>

<p>An object of class <code>igraph</code> of length 194.
</p>

<hr>
<h2 id='sgmwcs_small_instance'>Small example of SGMWCS instance for demonstration purposes.</h2><span id='topic+sgmwcs_small_instance'></span>

<h3>Description</h3>

<p>Small example of SGMWCS instance for demonstration purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgmwcs_small_instance
</code></pre>


<h3>Format</h3>

<p>An object of class <code>igraph</code> of length 6.
</p>

<hr>
<h2 id='solve_mwcsp'>Solves a MWCS instance.</h2><span id='topic+solve_mwcsp'></span><span id='topic+solve_mwcsp.virgo_solver'></span><span id='topic+solve_mwcsp.rmwcs_solver'></span><span id='topic+solve_mwcsp.rnc_solver'></span><span id='topic+solve_mwcsp.simulated_annealing_solver'></span><span id='topic+solve_mwcsp.scipjack_solver'></span>

<h3>Description</h3>

<p>Generic function for solving MWCS instances using solvers collected in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_mwcsp(solver, instance, ...)

## S3 method for class 'virgo_solver'
solve_mwcsp(solver, instance, ...)

## S3 method for class 'rmwcs_solver'
solve_mwcsp(solver, instance, max_cardinality = NULL, budget = NULL, ...)

## S3 method for class 'rnc_solver'
solve_mwcsp(solver, instance, ...)

## S3 method for class 'simulated_annealing_solver'
solve_mwcsp(solver, instance, warm_start, ...)

## S3 method for class 'scipjack_solver'
solve_mwcsp(solver, instance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_mwcsp_+3A_solver">solver</code></td>
<td>
<p>a solver object returned by rmwcs_solver, annealing_solver, rnc_solver or virgo_solver.</p>
</td></tr>
<tr><td><code id="solve_mwcsp_+3A_instance">instance</code></td>
<td>
<p>an MWCS instance, an igraph object with problem-related vertex, edge and graph attributes. See details.</p>
</td></tr>
<tr><td><code id="solve_mwcsp_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
<tr><td><code id="solve_mwcsp_+3A_max_cardinality">max_cardinality</code></td>
<td>
<p>integer maximum number of vertices in solution.</p>
</td></tr>
<tr><td><code id="solve_mwcsp_+3A_budget">budget</code></td>
<td>
<p>numeric maximum budget of solution.</p>
</td></tr>
<tr><td><code id="solve_mwcsp_+3A_warm_start">warm_start</code></td>
<td>
<p>warm start solution, an object of the class mwcsp_solution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MWCS instance here is represented as an undirected graph, an <code>igraph</code> object.
The package supports four types of instances: Simple MWCS, Generalized MWCS,
Budget MWCS, signal MWCS problems. All the necessary weights and costs are
passed by setting vertex and edge attributes. See <a href="#topic+get_instance_type">get_instance_type</a> to check
if the <code>igraph</code> object is a correct MWCS instance. For Simple MWCS problem
numeric vertex attribute <code>weight</code> must be set. For generalized version <code>weight</code>s
can be provided for edges. For budget version of the problem in addition to
vertex weights it is required that <code>igraph</code> object would have <code>budget_cost</code> vertex
attribute with positive numeric values.
</p>
<p>Signal MWCS instance is quite different. There is no <code>weight</code> attribute for
neither vertices nor edges. Instead, vertex and edge attribute <code>signal</code> should
be provided with signal names. A numeric vector containing weights for the signals
should be assigned to graph attribute <code>signals</code>.
</p>
<p>See vignette for description of the supported problems. See <code>igraph</code> package
documentation for more details about getting/setting necesasry attributes.
</p>


<h3>Value</h3>

<p>An object of class <code>mwcsp_solution</code> consisting of resulting subgraph,
its weight and other information about solution provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)

# for a MWCS instance

data(mwcs_example)
head(V(mwcs_example)$weight)

# for a GMWCS instance
data(gmwcs_example)
head(E(gmwcs_example)$weight)

# for a SGMWCS instance
data(sgmwcs_example)
head(V(sgmwcs_example)$signal)
head(E(sgmwcs_example)$signal)

head(sgmwcs_example$signals)

</code></pre>

<hr>
<h2 id='timelimit+26lt+3B-'>Sets time limitation for a solver</h2><span id='topic+timelimit+3C-'></span>

<h3>Description</h3>

<p>Sets time limitation for a solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timelimit(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timelimit+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a variable name.</p>
</td></tr>
<tr><td><code id="timelimit+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a value to be assigned to x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The solver with new timelimit set.
</p>

<hr>
<h2 id='virgo_solver'>Construct a virgo solver</h2><span id='topic+virgo_solver'></span>

<h3>Description</h3>

<p>This solver uses reformulation of MWCS problem in terms of mixed integer
programming. The later problem can be efficiently solved with
commercial optimization software. Exact version of solver uses CPLEX and requires
it to be installed. CPLEX 12.7.1 or higher is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>virgo_solver(
  cplex_dir,
  threads = parallel::detectCores(),
  timelimit = NULL,
  penalty = 0,
  memory = "2G",
  log = 0,
  cplex_bin = NULL,
  cplex_jar = NULL,
  mst = FALSE,
  dryrun = FALSE,
  jvmargs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="virgo_solver_+3A_cplex_dir">cplex_dir</code></td>
<td>
<p>a path to dir containing cplex_bin and cplex_jar,
setting this to NULL sets <code style="white-space: pre;">&#8288;mst`` param to &#8288;</code>TRUE'</p>
</td></tr>
<tr><td><code id="virgo_solver_+3A_threads">threads</code></td>
<td>
<p>number of threads for simultaneous computation</p>
</td></tr>
<tr><td><code id="virgo_solver_+3A_timelimit">timelimit</code></td>
<td>
<p>maximum number of seconds to solve the problem</p>
</td></tr>
<tr><td><code id="virgo_solver_+3A_penalty">penalty</code></td>
<td>
<p>additional edge penalty for graph edges</p>
</td></tr>
<tr><td><code id="virgo_solver_+3A_memory">memory</code></td>
<td>
<p>maximum amount of memory(-Xmx flag)</p>
</td></tr>
<tr><td><code id="virgo_solver_+3A_log">log</code></td>
<td>
<p>verbosity level</p>
</td></tr>
<tr><td><code id="virgo_solver_+3A_cplex_bin">cplex_bin</code></td>
<td>
<p>a path to cplex binary dir</p>
</td></tr>
<tr><td><code id="virgo_solver_+3A_cplex_jar">cplex_jar</code></td>
<td>
<p>a path to cplex jar file</p>
</td></tr>
<tr><td><code id="virgo_solver_+3A_mst">mst</code></td>
<td>
<p>whether to use approximate MST solver, no CPLEX files required with this parameter
is set to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="virgo_solver_+3A_dryrun">dryrun</code></td>
<td>
<p>if set to <code>TRUE</code> only prints the solver command, without actually running it</p>
</td></tr>
<tr><td><code id="virgo_solver_+3A_jvmargs">jvmargs</code></td>
<td>
<p>character vector with additional arguments for Java Virtual Machine</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The solver currently does not support repeated negative signals, i.e. every
negative signal should be present only once among all edges and vertices.
</p>
<p>You can access solver directly using <code>run_main</code> function. See example.
</p>


<h3>Value</h3>

<p>An object of class <code>mwcs_solver</code>.
</p>


<h3>References</h3>

<p>Loboda A., Artyomov M., and Sergushichev A. (2016)
&quot;Solving generalized maximum-weight connected subgraph problem for network enrichment analysis&quot;
<a href="https://doi.org/10.1007/978-3-319-43681-4_17">doi:10.1007/978-3-319-43681-4_17</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sgmwcs_small_instance")
approx_vs &lt;- virgo_solver(mst=TRUE, threads = 1)
approx_vs$run_main("-h")
sol &lt;- solve_mwcsp(approx_vs, sgmwcs_small_instance)
## Not run: 
vs &lt;- virgo_solver(cplex_dir='/path/to/cplex')
sol &lt;- solve_mwcsp(approx_vs, sgmwcs_example)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
