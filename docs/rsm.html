<!DOCTYPE html><html><head><title>Help for package rsm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rsm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rsm-package'>
<p>Response-surface analysis</p></a></li>
<li><a href='#bbd'><p>Generate a Box-Behnken design</p></a></li>
<li><a href='#ccd'><p>Generate central-composite designs and associated building blocks</p></a></li>
<li><a href='#ccd.pick'><p>Find a good central-composite design</p></a></li>
<li><a href='#ChemReact'><p>Chemical Reaction Data</p></a></li>
<li><a href='#codata'><p>Automobile emissions data</p></a></li>
<li><a href='#coded.data'><p>Functions for coded data</p></a></li>
<li><a href='#contour.lm'><p>Surface plot(s) of a fitted linear model</p></a></li>
<li><a href='#djoin'><p>Join designs together into a blocked design</p></a></li>
<li><a href='#FO'><p>Response-surface model components</p></a></li>
<li><a href='#heli'><p>Paper Helicopter Data</p></a></li>
<li><a href='#model.data'><p>Reconstruct data from a linear model</p></a></li>
<li><a href='#rsm'><p>Response-surface regression</p></a></li>
<li><a href='#steepest'><p>Steepest-ascent methods for response surfaces</p></a></li>
<li><a href='#varfcn'>
<p>Display the scaled variance function for a design</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.10.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Response-Surface Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to generate response-surface designs, 
    fit first- and second-order response-surface models, 
    make surface plots, obtain the path of steepest ascent, 
    and do canonical analysis. A good reference on these methods 
    is Chapter 10 of Wu, C-F J and Hamada, M (2009) 
    "Experiments: Planning, Analysis, and Parameter Design Optimization"
    ISBN 978-0-471-69946-0. An early version of the package is
    documented in Journal of Statistical Software &lt;<a href="https://doi.org/10.18637%2Fjss.v032.i07">doi:10.18637/jss.v032.i07</a>&gt;.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>emmeans (&gt; 1.3.5.1), Vdgraph, conf.design, DoE.base, FrF2</td>
</tr>
<tr>
<td>Imports:</td>
<td>estimability</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-19 23:53:32 UTC; rlenth</td>
</tr>
<tr>
<td>Author:</td>
<td>Russell Lenth [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Russell Lenth &lt;russell-lenth@uiowa.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-20 04:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rsm-package'>
Response-surface analysis
</h2><span id='topic+rsm-package'></span>

<h3>Description</h3>

<p>The <code>rsm</code> package provides functions useful for designing and analyzing
experiments that are done sequentially in hopes of optimizing a response surface.
</p>
<p>The function <code><a href="#topic+ccd">ccd</a></code> can generate (and randomize) a central-composite 
design; it allows the user to specify an aliasing or fractional blocking structure.
The function <code><a href="#topic+bbd">bbd</a></code> generates and randomizes a Box-Behnken design.  
The function <code><a href="#topic+ccd.pick">ccd.pick</a></code> is useful for identifying good parameter choices
in central-composite designs. Functions <code>cube</code>, <code>star</code>, <code>foldover</code>, <code>dupe</code>, and <code>djoin</code> are also provided to build-up designs from individual blocks. The function <code>varfcn</code> allows the experimenter to examine the predictive capabilities of a design before collecting data.
</p>
<p>The function <code><a href="#topic+rsm">rsm</a></code> is an enhancement of <code><a href="stats.html#topic+lm">lm</a></code> that provides 
for additional analyses peculiar to response surfaces.  It requires a model formula 
that contains a call to <code><a href="#topic+FO">FO</a></code> or <code><a href="#topic+SO">SO</a></code> to specify a first- or 
second-order model.  Once the model is fitted, the <code><a href="#topic+steepest">steepest</a></code> 
function may be used to obtain the direction of steepest ascent (or descent).  
<code><a href="#topic+canonical.path">canonical.path</a></code> is an alternative to <code>steepest</code> for second-order 
response surfaces.
</p>
<p>In RSM methods, appropriate coding of data is
important not only for numerical stability, but for proper scaling
of results; the function <code><a href="#topic+coded.data">coded.data</a></code> and its relatives facilitate
this coding requirement.  
</p>
<p>Finally, a few more functions are provided that may be useful beyond response-surface applications.  
<code><a href="#topic+contour.lm">contour.lm</a></code>, <code><a href="#topic+persp.lm">persp.lm</a></code>, and <code><a href="#topic+image.lm">image.lm</a></code> aids in visualizing a response surface, 
or of any other <code>lm</code> object where a surface is fitted.  <code><a href="#topic+model.data">model.data</a></code>
recovers the data used in a <code>lm</code> call, but unlike <code>model.frame</code>, no
polynomials, factors, etc. are expanded.
</p>
<p>For more information and examples, use &lsquo;<span class="samp">&#8288;vignette("rsm")&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;vignette("rs-illus")&#8288;</span>&rsquo;.  
Additionally, &lsquo;<span class="samp">&#8288;vignette("rsm-plots")&#8288;</span>&rsquo; provides some illustrations 
of the graphics functions.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth
</p>
<p>Maintainer: Russell V. Lenth &lt;russell-lenth@uiowa.edu&gt;
</p>


<h3>References</h3>

<p>Box, GEP, Hunter, JS, and Hunter, WG (2005) 
<em>Statistics for Experimenters</em> (2nd ed.), Wiley-Interscience.
</p>
<p>Lenth RV (2009) &ldquo;Response-Surface Methods in R, Using rsm&rdquo;, 
<em>Journal of Statistical Software</em>, 32(7), 1&ndash;17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>
<p>Myers, RH, Montgomery, DC, and Anderson-Cook, CM (2009), 
<em>Response Surface Methodology</em> (3rd ed.), Wiley.
</p>

<hr>
<h2 id='bbd'>Generate a Box-Behnken design</h2><span id='topic+bbd'></span>

<h3>Description</h3>

<p>This function can generate a Box-Behnken design in 3 to 7 factors, and optionally will block it orthogonally if there are 4 or 5 factors.  It can also randomize the design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbd(k, n0 = 4, block = (k == 4 | k == 5), randomize = TRUE, coding)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbd_+3A_k">k</code></td>
<td>
<p>A formula, or an integer giving the number of variables.  If the formula has a left-hand side, the variables named there are appended to the design and initialized to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="bbd_+3A_n0">n0</code></td>
<td>
<p>Number of center points in each block.</p>
</td></tr>
<tr><td><code id="bbd_+3A_block">block</code></td>
<td>
<p>Logical value specifying whether or not to block the design; or a character string (taken as <code>TRUE</code>) giving the desired name for the blocking factor.
Only BBDs with 4 or 5 factors can be blocked.  A 4-factor BBD has three orthogonal blocks, and a 5-factor BBD has two.</p>
</td></tr>
<tr><td><code id="bbd_+3A_randomize">randomize</code></td>
<td>
<p>Logical value determining whether or not to randomize the design.  If <code>block</code> is <code>TRUE</code>, each block is randomized separately.</p>
</td></tr>
<tr><td><code id="bbd_+3A_coding">coding</code></td>
<td>
<p>Optional list of formulas.  If this is provided, it overrides the default coding formulas.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Box-Behnken designs (BBDs) are useful designs for fitting second-order response-surface models.  They use only three levels of each factor (compared with 5 for central-composite designs) and sometimes fewer runs are required than a CCD.
This function uses an internal table of BBDs; it only works for 3 to 7 factors.
</p>
<p>If <code>k</code> is specified as a formula, the names in the formula determine the names of the factors in the generated design.  Otherwise, the names will be <code>x1, x2, ...</code>. If <code>coding</code> is not specified, default codings are created in the form &lsquo;<span class="samp">&#8288;x ~ x.as.is&#8288;</span>&rsquo;.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+coded.data">coded.data</a></code> object with the generated design and the additional valiables <code>run.order</code> and <code>std.order</code>.  The blocking variable, if present, will be a <code><a href="base.html#topic+factor">factor</a></code>; all other variables will be numeric.
</p>


<h3>Note</h3>

<p>To avoid aliasing the pure-quadratic terms, you must use a positive value of <code>n0</code>.
</p>
<p>The non-exported function <code>rsm:::.bbd.1.41</code> is provided in case it is needed by other packages for compatibility with old versions of <span class="pkg">rsm</span> (version 1.41 or earlier). Given the same seed, it will also reproduce the randomization as a previously generated design from an old version.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>References</h3>

<p>Lenth RV (2009) &ldquo;Response-Surface Methods in R, Using rsm&rdquo;, 
<em>Journal of Statistical Software</em>, 32(7), 1&ndash;17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>
<p>Myers, RH, Montgomery, DC, and Anderson-Cook, CM (2009) 
<em>Response Surface Methodology</em> (3rd ed.), Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccd">ccd</a></code>, <code><a href="#topic+coded.data">coded.data</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rsm)

### Simple 3-factor case, not randomized so structure is evident
bbd(3, randomize=FALSE)

### 5-factor BBD, divided between two plants
bbd(y1 + y2 ~ A + B + C + D + E,  n0 = 5,  block = "Plant")
</code></pre>

<hr>
<h2 id='ccd'>Generate central-composite designs and associated building blocks</h2><span id='topic+cube'></span><span id='topic+star'></span><span id='topic+dupe'></span><span id='topic+foldover'></span><span id='topic+ccd'></span>

<h3>Description</h3>

<p>These functions generate central-composite designs, or building blocks thereof.
They allow for flexible choices of replications, aliasing of predictors and fractional blocks, and choices of axis or &lsquo;star&rsquo; points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cube(basis, generators, n0 = 4, reps = 1, coding, randomize = TRUE, 
    blockgen, bid = 1, inscribed = FALSE)
star(basis, n0 = 4, alpha = "orthogonal", reps = 1, randomize = TRUE)
dupe(design, randomize = TRUE, coding)
foldover(basis, variables, bid, randomize = TRUE)
ccd(basis, generators, blocks = "Block", n0 = 4, alpha = "orthogonal", 
    wbreps = 1, bbreps = 1, randomize = TRUE, inscribed = FALSE, 
    coding, oneblock = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccd_+3A_basis">basis</code></td>
<td>
<p>In <code>cube</code> and <code>ccd</code>, a formula, or an integer giving the number of variables.  If the formula has a left-hand side, the variables named there are appended to the design and initialized to <code>NA</code>. 
In <code>star</code>, <code>dupe</code>, and <code>foldover</code>, <code>basis</code> is a <code>coded.data</code> object to use as a reference.</p>
</td></tr>
<tr><td><code id="ccd_+3A_generators">generators</code></td>
<td>
<p>Optional formula or list of formulas to generate aliased variables</p>
</td></tr>
<tr><td><code id="ccd_+3A_n0">n0</code></td>
<td>
<p>Integer giving the number of center points. In <code>ccd</code>, this can be a vector of     
two numbers for the numbers of center points in the cube blocks and the star blocks, 
respectively.</p>
</td></tr>
<tr><td><code id="ccd_+3A_reps">reps</code></td>
<td>
<p>Integer number of replications of the cube or the star. (This does <em>not</em> create replicate blocks; use <code><a href="#topic+djoin">djoin</a></code> to do that.)</p>
</td></tr>
<tr><td><code id="ccd_+3A_coding">coding</code></td>
<td>
<p>List of coding formulas for the design variables (those in <code>basis</code> and <code>generators</code>).  In <code>dupe</code>, <code>coding</code> may be used to change the coding formulas, e.g. in a situation where we want to use the same design as before but center it elsewhere.</p>
</td></tr>
<tr><td><code id="ccd_+3A_randomize">randomize</code></td>
<td>
<p>Logical value determining whether or not to randomize the design.  In <code>ccd</code>, each block is randomized separately.</p>
</td></tr>
<tr><td><code id="ccd_+3A_blockgen">blockgen</code></td>
<td>
<p>A formula, string, or list thereof. Each element is evaluated, and the distinct combinations define fractional blocks for the design. Unlike <code>ccd</code>, <code>cube</code> returns only one of these blocks.</p>
</td></tr>
<tr><td><code id="ccd_+3A_bid">bid</code></td>
<td>
<p>(For block ID.) An integer index (from 1 to number of blocks) of the fractional block to return. The indexes are defined by the standard ordering of the block generators; e.g. if <code>blockgen</code> is of length 2, the <code>bid</code> values of (1, 2, 3, 4) correspond to generated levels of <code>(--, +-, -+, ++)</code> respectively.</p>
</td></tr>
<tr><td><code id="ccd_+3A_inscribed">inscribed</code></td>
<td>
<p>Logical value; if <code>FALSE</code>, the cube points are at +/- 1 in each variable.  If <code>TRUE</code>, the entire desgn is scaled down so that the axis points are at +/- 1 and the cube points are at interior positions.  In <code>cube</code> only, <code>inscribed</code> may be given a numeric value: use the value of <code>alpha</code> anticipated when axis points are added; or use &lsquo;<span class="samp">&#8288;inscribed = TRUE&#8288;</span>&rsquo; to scale in anticipation of &lsquo;<span class="samp">&#8288;alpha = "spherical"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="ccd_+3A_alpha">alpha</code></td>
<td>
<p>If numeric, the position of the &lsquo;star&rsquo; points.  May also be a character string that matches or partially matches one of these:
</p>

<dl>
<dt><code>"orthogonal"</code></dt><dd><p>the star points are positioned to block the design orthogonally</p>
</dd>
<dt><code>"rotatable"</code></dt><dd><p>the star points are chosen to make the design rotatable</p>
</dd>
<dt><code>"spherical"</code></dt><dd><p>the star points are the same distance as the corners of the design cube (alpha is the square root of the number of design factors)</p>
</dd>
<dt><code>"faces"</code></dt><dd><p>the star points are face-centered (same as &lsquo;<span class="samp">&#8288;alpha = 1&#8288;</span>&rsquo;)</p>
</dd>
</dl>

<p>The user may specify a vector value of <code>alpha</code> if it is desired to vary them on different axes. The values are rotated cyclically as needed.
</p>
</td></tr>
<tr><td><code id="ccd_+3A_design">design</code></td>
<td>
<p>A <code>coded.data</code> object to be duplicated.</p>
</td></tr>
<tr><td><code id="ccd_+3A_blocks">blocks</code></td>
<td>
<p>A string or a formula.  If a character string, it is the name of the blocking factor; if a formula, the left-hand side is used as the name of the blocking factor. The formula(s) on the right-hand side are used to generate separate fractional blocks.</p>
</td></tr>
<tr><td><code id="ccd_+3A_variables">variables</code></td>
<td>
<p>Character vector of names of variables to fold over.</p>
</td></tr>  
<tr><td><code id="ccd_+3A_wbreps">wbreps</code></td>
<td>
<p>Number(s) of within-block replications.  If this is a vector of length 2, then separate numbers are used for the &lsquo;cube&rsquo; and the &lsquo;star&rsquo; blocks respectively.</p>
</td></tr>
<tr><td><code id="ccd_+3A_bbreps">bbreps</code></td>
<td>
<p>Number(s) of between-block replications (i.e., number of repeats of each block).  If this is a vector of length 2, then separate numbers are used for the &lsquo;cube&rsquo; and the &lsquo;star&rsquo; blocks respectively.</p>
</td></tr>
<tr><td><code id="ccd_+3A_oneblock">oneblock</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the blocking factor is removed and the whole design is randomized as a single block. Note that the default number of center points may be larger than you anticipated because they are combined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Central-composite designs (CCDs) are popular designs for use in response-surface exploration.  They are blocked designs consisting of at least one &lsquo;cube&rsquo; block (two-level factorial or fractional factorial, plus center points), and at least one &lsquo;star&rsquo; block (points along each axis at positions <code>-alpha</code> and <code>+alpha</code>), plus center points.  Everything is put on a coded scale, where the cube portion of the design has values of -1 and 1 for each variable, and the center points are 0.
</p>
<p>The <code>ccd</code> function creates an entire CCD design; however, in practice, we often start with just the cube portion and build from there. Therefore, the functions <code>cube</code>, <code>star</code>, <code>dupe</code>, and <code>foldover</code> are provided, and one may use <code><a href="#topic+djoin">djoin</a></code> to combine them.
</p>
<p>In <code>cube</code> and <code>ccd</code>, the <code>basis</code> argument determines a basic design used to create cube blocks.  
For example, &lsquo;<span class="samp">&#8288;cube(basis = ~ A + B + C)&#8288;</span>&rsquo; would generate a basic design of 8 factorial points plus center points. 
Use <code>generators</code> if you want additional variables in a fractional design; for example, &lsquo;<span class="samp">&#8288;generators = c(D ~ -A*B, E ~ B*C)&#8288;</span>&rsquo; added to the above would generate a 5-factor design with defining relation <code>I = -ABD = BCE = -ACDE</code>.  For convenience, <code>basis</code> may be an integer instead of a formula, in which case default variable names of <code>x1, x2, ...</code> are used; for example, &lsquo;<span class="samp">&#8288;cube(3, ~ -x1*x2*x3)&#8288;</span>&rsquo; generates a 1/2 fraction design with added center points.
</p>
<p>If you want the cube points divided into fractional blocks, give the formula(s) in the <code>blockgen</code> argument of <code>cube</code>, or the <code>blocks</code> argument of <code>ccd</code>.  For instance, suppose we call &lsquo;<span class="samp">&#8288;cube(basis = A+B+C+D+E&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;generators = F~-A*C*D)&#8288;</span>&rsquo;.
This design has 32 runs; but adding the argument &lsquo;<span class="samp">&#8288;blockgen = c("A*B*C","C*D*E")&#8288;</span>&rsquo; will
create a fractional block of 32/4 = 8 runs. (<code>cube</code> is flexible; we could have used a
formula instead, either &lsquo;<span class="samp">&#8288;blockgen = ~ c(A*B*C, C*D*E)&#8288;</span>&rsquo; or 
&lsquo;<span class="samp">&#8288;blockgen = c(~A*B*C, ~C*D*E)&#8288;</span>&rsquo;.) Center points are added to each block as specified. 
In a call to <code>ccd</code> with the same <code>basis</code> and <code>generators</code>, adding 
&lsquo;<span class="samp">&#8288;blocks = Day ~ c(A*B*C, C*D*E)&#8288;</span>&rsquo; would do the same thing, only all 4 blocks will be
included, and a factor named <code>Day</code> distinguishes the blocks.
</p>
<p>The functions <code>star</code>, <code>dupe</code>, and <code>foldover</code> provide for creating new design blocks based on an existing design.  They also provide for delayed evaluation: if the <code>basis</code> argument is missing, these functions simply return the call, <code><a href="#topic+djoin">djoin</a></code> will fill-in &lsquo;<span class="samp">&#8288;basis = design1&#8288;</span>&rsquo; and evaluate it. 
</p>
<p><code>dupe</code> simply makes a copy of the design, and re-randomizes it. Therefore it is also a convenient way to re-randomize a design. If <code>coding</code> is provided, the coding formulas are replaced as well &ndash; for example, to re-center the design.
</p>
<p>Use <code>star</code> to generate star (axis) points, which consist of center points plus points at <code>+/- alpha</code> on each coordinate axis.  You may specify the <code>alpha</code> you want, or a character argument to specify a certain criterion be met.  For example, using delayed evaluation, &lsquo;<span class="samp">&#8288;ccd1 = djoin(cube1, star(alpha="sph"))&#8288;</span>&rsquo; will return a CCD with <code>cube1</code> as the cube block, and with axis points at the same distance as the corners of the cube. Conditions for the criteria on <code>alpha</code> are described in detail in references such as Myers <em>et al.</em> (2009). 
</p>
<p>In <code>star</code>, determinations of orthogonality and rotatability are based on computed design moments of <code>basis</code>, rather than any assumptions about the structure of the design being augmented. Thus, it may be possible to augment an unusual design to obtain a rotatable design. Also, if an orthogonal star block is requested, the value of <code>alpha</code> may vary from axis to axis if that is required to satisfy the condition.
</p>
<p><code>foldover</code> reverses the levels of one or more  design variables (i.e., those that are coded). By default, it reverses them all. However, if the <code>bid</code> argument is supplied, it instead returns the <code>bid</code>th fractional block that <code>cube</code> would have generated. That is, &lsquo;<span class="samp">&#8288;foldover(des, bid=3)&#8288;</span>&rsquo; is equivalent to &lsquo;<span class="samp">&#8288;cube(&lt;arguments that created des&gt;, bid=3)&#8288;</span>&rsquo; &ndash; only it does so much more efficiently by folding on the appropriate factors.
</p>
<p>In cases where there are constraints on the region of operability, you may want to specify <code>inscribed = TRUE</code>.  This will scale-down the design so that no coded value exceeds 1. If using a building-block approach starting with a first-order design from <code>cube</code>, call <code>cube</code>  with <code>inscribed</code> set to the anticipated value of <code>alpha</code>, or use &lsquo;<span class="samp">&#8288;inscribed = TRUE&#8288;</span>&rsquo;, and then use &lsquo;<span class="samp">&#8288;alpha = "spherical"&#8288;</span>&rsquo; in the subsequent call to <code>star</code>.
</p>
<p><code>ccd</code> generates an entire CCD. In practice, the building-block approach with <code>cube</code>, <code>star</code>, etc. is usually preferable, but <code>ccd</code> exists for convenience and backward compatibility with pre-2.00 versions of <span class="pkg">rsm</span>. Many of the arguments are the same as those in <code>cube</code>; however, <code>n0</code>, <code>wbreps</code>, <code>bbreps</code> may be single values or vectors; if vectors, the first element is for the cube portions and the second element is for the star portions. In <code>ccd</code>, specifying <code>wbreps</code> is equivalent to specifying <code>reps</code> in a call to <code>cube</code> or <code>star</code>. <code>bbreps</code> refers to replicate blocks in the experiment, so that &lsquo;<span class="samp">&#8288;bbreps = c(2,3)&#8288;</span>&rsquo; specifies that we join two cube blocks and three blocks of star points.
</p>
<p>If <code>coding</code> is not specified in a new design, default identity codings are created, e.g. &lsquo;<span class="samp">&#8288;x1 ~ x1.as.is&#8288;</span>&rsquo;.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+coded.data">coded.data</a></code> object with the generated design, with additional variables <code>run.order</code> and <code>std.order</code>. If a multi-block design, the generated blocking variable will be a <code><a href="base.html#topic+factor">factor</a></code>; all other variables will be numeric. The designs are sorted by blocks and <code>run.order</code> within blocks; and (unlike pre-1.41 versions of <span class="pkg">rsm</span>) the <code>row.names</code> will be integers corresponding to this ordering. The user may sort by block and <code>std.order</code> within block to display the designs in their pre-randomized order.
</p>


<h3>Note</h3>

<p>Poor choices of <code>generators</code> and/or <code>blocks</code> can alias or partially alias some effects needed to estimate a second-order response surface.  It is a good idea to run <code><a href="#topic+varfcn">varfcn</a></code> before collecting data to examine the prediction capabilities of the design and to ensure that the desired model can be fitted.
</p>
<p>The function <code><a href="#topic+ccd.pick">ccd.pick</a></code> is available to help determine good choices for arguments to <code>cube</code>, <code>star</code>, and <code>ccd</code>.
</p>
<p>An alternative to a CCD when you want to go straight to second-order modeling is a Box-Behnken design, generated by <code><a href="#topic+bbd">bbd</a></code>.  These designs are not as various or flexible as CCDs, but they can require fewer runs.
</p>
<p>The non-exported function <code>rsm:::.ccd.1.41</code> is provided in case it is needed by other packages for compatibility with old versions of <span class="pkg">rsm</span> (version 1.41 or earlier). Given the same seed, it will also reproduce the randomization as a previously generated design from an old version.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>References</h3>

<p>Lenth RV (2009) &ldquo;Response-Surface Methods in R, Using rsm&rdquo;, 
<em>Journal of Statistical Software</em>, 32(7), 1&ndash;17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>
<p>Myers, RH, Montgomery, DC, and Anderson-Cook, CM (2009) 
<em>Response Surface Methodology</em> (3rd ed.), Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccd.pick">ccd.pick</a></code>, <code><a href="#topic+coded.data">coded.data</a></code>, <code><a href="#topic+varfcn">varfcn</a></code>, <code><a href="#topic+bbd">bbd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rsm)

### Generate a standard 3-variable first-order design with 8 corner points and 4 center points
( FOdes &lt;- cube (3, n0 = 4, coding = list (
                x1 ~ (Temp - 150)/10, x2 ~ (Pres - 50)/5, x3 ~ Feedrate - 4)) )
                                    
### Add an orthodonal star block with 12 runs to create a second-order CCD
( SOdes &lt;- djoin(FOdes, star(n0=6)) )

### Same as above, except make the whole CCD at once; and make it rotatable
### and inscribed so that no coded value exceeds 1
SOdes2 &lt;- ccd (3, n0 = c(4,6), alpha = "rotatable", inscribed = TRUE, coding = list (
                x1 ~ (Temp - 150)/10, x2 ~ (Pres - 50)/5, x3 ~ Feedrate - 4))

### Make two replicate blocks of FOdes (2nd one randomized differently)
djoin(FOdes, dupe(FOdes))

### Fractional blocking illustration (with no center points)
# Basic design (bid = 1 ---&gt; block generators b1 = -1, b2 = -1)
block1 &lt;- cube (~ x1 + x2 + x3 + x4,  generators = x5 ~ x1 * x2 * x3 * x4,
                n0 = 0, blockgen = ~ c(x1 * x2, x1 * x3), bid = 1)
block1                

# The foldover (on all variables) of block1, in the same order
foldover(block1, randomize=FALSE)

# The 4th fractional block:
( block4 &lt;- foldover(block1, bid = 4) )

</code></pre>

<hr>
<h2 id='ccd.pick'>Find a good central-composite design</h2><span id='topic+ccd.pick'></span>

<h3>Description</h3>

<p>This function looks at all combinations of specified design parameters
for central-composite designs, calculates other quantities such as
the <code>alpha</code> values for rotatability and orthogonal blocking, imposes 
specified restrictions, and outputs the best combinations in a specified order.
This serves as an aid in identifying good designs.  The design itself can 
then be generated using <code><a href="#topic+ccd">ccd</a></code>, or in pieces using <code><a href="#topic+cube">cube</a></code>, <code><a href="#topic+star">star</a></code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccd.pick(k, n.c = 2^k, n0.c = 1:10, blks.c = 1, n0.s = 1:10, bbr.c = 1, 
         wbr.s = 1, bbr.s = 1, best = 10, sortby = c("agreement", "N"), 
         restrict)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccd.pick_+3A_k">k</code></td>
<td>
<p>Number of factors in the design</p>
</td></tr>
<tr><td><code id="ccd.pick_+3A_n.c">n.c</code></td>
<td>
<p>Number(s) of factorial points in each cube block</p>
</td></tr>
<tr><td><code id="ccd.pick_+3A_n0.c">n0.c</code></td>
<td>
<p>Numbers(s) of center points in each cube block</p>
</td></tr>
<tr><td><code id="ccd.pick_+3A_blks.c">blks.c</code></td>
<td>
<p>Number(s) of cube blocks that together comprise one rep of the cube portion</p>
</td></tr>
<tr><td><code id="ccd.pick_+3A_n0.s">n0.s</code></td>
<td>
<p>Numbers(s) of center points in each star (axis-point) block</p>
</td></tr>
<tr><td><code id="ccd.pick_+3A_bbr.c">bbr.c</code></td>
<td>
<p>Number(s) of copies of each cube block</p>
</td></tr>
<tr><td><code id="ccd.pick_+3A_wbr.s">wbr.s</code></td>
<td>
<p>Number(s) of replications of each star poit within a block</p>
</td></tr>
<tr><td><code id="ccd.pick_+3A_bbr.s">bbr.s</code></td>
<td>
<p>Number(s) of copies of each star block</p>
</td></tr>
<tr><td><code id="ccd.pick_+3A_best">best</code></td>
<td>
<p>How many designs to list.  Use <code>best=NULL</code> to list them all</p>
</td></tr>
<tr><td><code id="ccd.pick_+3A_sortby">sortby</code></td>
<td>
<p>String(s) containing numeric expressions that are each evaluated and used as sorting key(s).
Specify <code>sortby=NULL</code> if no sorting is desired.</p>
</td></tr>
<tr><td><code id="ccd.pick_+3A_restrict">restrict</code></td>
<td>
<p>Optional string(s) containing Boolean expressions that are each evaluated.  Only combinations where all
expressions are <code>TRUE</code> are retained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A grid is created with all combinations of <code>n.c</code>, <code>n0.c</code>, ..., <code>bbr.s</code>.
Then for each row of the grid, several additional variables 
are computed:
</p>

<dl>
<dt><code>n.s</code></dt><dd><p>The total number of axis points in each star block</p>
</dd>
<dt><code>N</code></dt><dd><p>The total number of observations in the design</p>
</dd>
<dt><code>alpha.rot</code></dt><dd><p>The position of axis points that make the design rotatable.
Rotatability is achieved when design moment [iiii] = 3[iijj] for i and j unequal.</p>
</dd>
<dt><code>alpha.orth</code></dt><dd><p>The position of axis points that make the blocks mutually orthogonal.
This is achieved when design moments [ii] within each block are proprtional
to the number of observations within the block.</p>
</dd>
<dt><code>agreement</code></dt><dd><p>The absolute value of the log of the ratio of 
<code>alpha.rot</code> and <code>alpha.orth</code>.  This measures agreement between 
the two <code>alpha</code>s.</p>
</dd>
</dl>

<p>If <code>restrict</code> is provided, only the cases where the expressions are all <code>TRUE</code> are kept.  
(Regardless of <code>restrict</code>, rows are eliminated where there are 
insufficient degrees of freedom to estimate all needed effects for a 
second-order model.)
The rows are 
sorted according to the expressions in <code>sortby</code>; the default is to sort
by <code>agreement</code> and <code>N</code>, which is suitable for finding designs
that are both rotatable and orthogonally blocked.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing <code>best</code> or fewer rows, and variables
<code>n.c</code>, <code>n0.c</code>, <code>blks.c</code>, <code>n.s</code>, <code>n0.s</code>, <code>bbr.c</code>, 
<code>wbr.s</code>, <code>bbr.s</code>,  <code>N</code>, <code>alpha.rot</code>, and <code>alpha.orth</code>,
as described above.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>References</h3>

<p>Lenth RV (2009) &ldquo;Response-Surface Methods in R, Using rsm&rdquo;, 
<em>Journal of Statistical Software</em>, 32(7), 1&ndash;17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>
<p>Myers, RH, Montgomery, DC, and Anderson-Cook, CM (2009)
<em>Response Surface Methodology</em> (3rd ed.), Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccd">ccd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rsm)

### List CCDs in 3 factors with between 10 and 14 runs per block
ccd.pick(3, n0.c=2:6, n0.s=2:8)
# (Generate the design that is listed first:) 
# ccd(3, n0=c(6,4))

### Find designs in 5 factors containing 1, 2, or 4 cube blocks
### of 8 or 16 runs, 1 or 2 reps of each axis point,
### and no more than 70 runs altogether
ccd.pick(5, n.c=c(8,16), blks.c=c(1,2,4), wbr.s=1:2, restrict="N&lt;=70")
</code></pre>

<hr>
<h2 id='ChemReact'>Chemical Reaction Data</h2><span id='topic+ChemReact'></span><span id='topic+ChemReact1'></span><span id='topic+ChemReact2'></span>

<h3>Description</h3>

<p>These data are from a central composite design with 2 factors in 2 blocks.
The design variables are in actual, not coded, form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChemReact
ChemReact1
ChemReact2
</code></pre>


<h3>Format</h3>

<p>A data frame with 14 observations on the following 4 variables.
</p>

<dl>
<dt><code>Time</code></dt><dd><p>a numeric vector; design variable with settings of 80, 85, and 90.</p>
</dd>
<dt><code>Temp</code></dt><dd><p>a numeric vector; design variable with settings of 170, 175, and 180.</p>
</dd>
<dt><code>Block</code></dt><dd><p>a factor with levels <code>B1</code> <code>B2</code>.
Block <code>B1</code> is a first-order design with 3 center points.  
Block <code>B2</code> consists of axis points and 3 more center points.</p>
</dd>
<dt><code>Yield</code></dt><dd><p>a numeric vector; response variable: yield of the chemical process.</p>
</dd>
</dl>

<p><code>ChemReact1</code> and <code>ChemReact2</code> are the separate blocks.   
Each has 7 runs and three variables (<code>Block</code> is excluded from these).
</p>


<h3>Source</h3>

<p>Table 7.6 of Myers, RH, Montgomery, DC, and Anderson-Cook, CM (2009), 
<em>Response Surface Methodology</em> (3rd ed.), Wiley.
</p>

<hr>
<h2 id='codata'>Automobile emissions data</h2><span id='topic+codata'></span>

<h3>Description</h3>

<p>This is a  replicated 3^2 experiment reported in Box, Hunter, and Hunter (2005), Table 10.17. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codata</code></pre>


<h3>Format</h3>

<p>A data frame with 18 observations on the following 3 variables.
</p>

<dl>
<dt><code>x1</code></dt><dd><p>a numeric vector, coded design variable for ethanol concentration</p>
</dd>
<dt><code>x2</code></dt><dd><p>a numeric vector, coded design variable for air-to-fuel ratio</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector, the response (CO concentration, in micrograms per cubic meter)</p>
</dd>
</dl>



<h3>Details</h3>

<p>This example, when fitted with a second-order response surface, is an example of a rising ridge. The dataset is duscussed again one chapter later in the source text; Figure 11.17 of BH^2 suggests the coding formulas used in the example below.
</p>


<h3>Source</h3>

<p>Box, GEP, Hunter, JS, and Hunter, WG (2005) <em>Statistics for Experimenters</em> (2nd ed), Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a coded dataset based on info in BH^2 Fig 11.17
CO &lt;- as.coded.data(codata,  x1 ~ (Ethanol - 0.2)/0.1,  x2 ~ A.F.ratio - 15)
names(CO)[3] &lt;- "CO.conc"
</code></pre>

<hr>
<h2 id='coded.data'>Functions for coded data</h2><span id='topic+coded.data'></span><span id='topic+as.coded.data'></span><span id='topic+decode.data'></span><span id='topic+recode.data'></span><span id='topic+is.coded.data'></span><span id='topic+val2code'></span><span id='topic+code2val'></span><span id='topic+print.coded.data'></span><span id='topic++5B.coded.data'></span><span id='topic+codings'></span><span id='topic+codings.coded.data'></span><span id='topic+codings+3C-'></span><span id='topic+names+3C-.coded.data'></span><span id='topic+truenames'></span><span id='topic+truenames.coded.data'></span><span id='topic+truenames+3C-'></span><span id='topic+truenames+3C-.coded.data'></span>

<h3>Description</h3>

<p>These functions facilitate the use of coded data in response-surface analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coded.data(data, ..., formulas = list(...), block = "block")
as.coded.data(data, ..., formulas = list(...), block = "block")
decode.data(data)
recode.data(data, ..., formulas = list(...))

val2code(X, codings)
code2val(X, codings)

## S3 method for class 'coded.data'
print(x, ..., decode = TRUE)

### --- Methods for managing coded data ---
is.coded.data(x)

## S3 method for class 'coded.data'
x[...]

codings(object)
## S3 method for class 'coded.data'
codings(object)
codings(object) &lt;- value

## S3 replacement method for class 'coded.data'
names(x) &lt;- value

## Generic method for true variable names (i.e. decoded names)
truenames(x)
## S3 method for class 'coded.data'
truenames(x)
## Generic replacement method for truenames
truenames(x) &lt;- value
## S3 replacement method for class 'coded.data'
truenames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coded.data_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code></p>
</td></tr>
<tr><td><code id="coded.data_+3A_formulas">formulas</code></td>
<td>
<p>List of coding formulas; see details</p>
</td></tr>
<tr><td><code id="coded.data_+3A_block">block</code></td>
<td>
<p>Name(s) of blocking variable(s). It is <code>pmatch</code>ed (case insensitively) with names in <code>data</code> to identify blocking factorss</p>
</td></tr>
<tr><td><code id="coded.data_+3A_x">X</code></td>
<td>
<p>A vector, matrix, or data.frame to be coded or decoded.</p>
</td></tr>
<tr><td><code id="coded.data_+3A_codings">codings</code></td>
<td>
<p>A list of formulas; see Details</p>
</td></tr>
<tr><td><code id="coded.data_+3A_decode">decode</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the decoded values are displayed; if <code>FALSE</code>, the codings are displayed.</p>
</td></tr>
<tr><td><code id="coded.data_+3A_object">object</code></td>
<td>
<p>A <code>coded.data</code> object</p>
</td></tr>
<tr><td><code id="coded.data_+3A_x">x</code></td>
<td>
<p>A <code>coded.data</code> object</p>
</td></tr>
<tr><td><code id="coded.data_+3A_value">value</code></td>
<td>
<p>Replacement value for <code>&lt;-</code> methods</p>
</td></tr>
<tr><td><code id="coded.data_+3A_...">...</code></td>
<td>
<p>In <code>coded.data</code>, <code>as.coded.data</code>, and <code>recode.data</code>, <code>...</code> allows specifying formulas as arguments rather than as a list. In other functions, <code>...</code> is passed to the parent methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically, coding formulas are of the form <code>x ~ (var - center) / halfwd</code> 
where <code>x</code> and <code>var</code> are variable names, and <code>center</code> and 
<code>halfwd</code> are numbers.  
The left-hand side gives the name of the coded variable, and the right-hand side 
should be a linear expression in the uncoded variable (linearity is <em>not</em> explicitly 
checked, but nonlinear expressions will not decode correctly.) If <code>coded.data</code> is called without formulas, automatic codings are created (along with a warning message). Automatic codings are based on transforming all non-block variables having five or fewer unique values to the interval [-1,1]. If no formulas are provided in <code>as.coded.data</code>, default coding formulas like those for <code><a href="#topic+cube">cube</a></code> are created all numeric variables with mean zero &ndash; again with a warning message.
</p>
<p>An S3 <code>print</code> method is provided for the <code>coded.data</code> class; 
it displays the data.frame in either coded or 
decoded form, along with the coding formulas. Some users may prefer <code>print.data.frame</code> 
or <code>as.data.frame</code> in lieu of <code>print</code> with &lsquo;<span class="samp">&#8288;decode=FALSE&#8288;</span>&rsquo;; they produce the 
same output without displaying the coding formulas.
</p>
<p>Use <code>coded.data</code> to convert a <code>data.frame</code> in which the variables
are on their original scales.  The variables named in the formulas are 
coded and replaced with their coded versions (and also renamed).
</p>
<p>In contrast, <code>as.coded.data</code> does not modify any of the data; it assumes the variables
are already coded, and the coding information is simply added. In addition, if <code>data</code> is 
already a <code>coded.data</code> object from a pre-1.41 version of <span class="pkg">rsm</span>, 
it is converted to 
be compatible with new capabilities such as <code><a href="#topic+djoin">djoin</a></code> (no <code>formulas</code> argument 
is needed in this case). Any blocking factors should be specified in the <code>blocks</code> 
argument.
</p>
<p><code>decode.data</code> converts a dataset of class <code>coded.data</code> and 
returns a <code>data.frame</code> containing the original variables.
</p>
<p><code>recode.data</code> is used to convert a <code>coded.data</code> object to new codings. 
Important: this <em>changes</em> the coded values to match the new coding formulas. If you want to keep the coded values the same, but change the levels they represent, use &lsquo;<span class="samp">&#8288;codings(object) &lt;- \dots&#8288;</span>&rsquo; or <code><a href="#topic+dupe">dupe</a></code>.
</p>
<p><code>code2val</code> converts coded values to the original scale using the codings provided, 
and returns an object of the same class as <code>X</code>.  
<code>val2code</code> converts the other direction.  When using these functions, it is 
essential that the names (or column names in the case of matrices) match those of the 
corresponding coded or uncoded variables.
</p>
<p><code>codings</code> is a generic function for accessing codings.  It
returns the list of coding formulas from a <code>coded.data</code> object.  One may use an 
expression like &lsquo;<span class="samp">&#8288;codings(object) &lt;- list(\dots)&#8288;</span>&rsquo; to change the codings (without changing 
the coded values themselves).   See also <code><a href="#topic+codings.rsm">codings.rsm</a></code>.
</p>
<p><code>is.coded.data(x)</code> returns <code>TRUE</code> if <code>x</code> inherits from <code>coded.data</code>, and <code>FALSE otherwise.</code>
</p>
<p>The extraction function <code>x[...]</code> and the naming functions <code>names&lt;-</code>, 
<code>truenames</code>, and <code>truenames&lt;-</code> are provided to preserve the integrity of 
codings. For example, if <code>x[, 1:3]</code> excludes any coded columns, their coding formulas 
are also excluded. If all coded columns are excluded, the return value is unclassed 
from <code>coded.data</code>. When variable names are changed using <code>names(x) &lt;- ...</code>, the coding 
formulas are updated accordingly. The <code>truenames</code> function returns the names of the 
variables in the decoded dataset. We can change the decoded names using 
<code>truenames(x) &lt;- ...</code>, and the coding formulas are updated. Note that <code>truenames</code>
and <code>truenames&lt;-</code> work the same as <code>names</code> and <code>names&lt;-</code> for 
unencoded variables in the object.
</p>
<p>Another convenient way to copy and change the coding formulas a coded dataset (and optionally re-randomize it) is to use the <code><a href="#topic+dupe">dupe</a></code> function with a <code>coding</code> argument.
</p>
<p>When a design is created in another package, some of the variables may be <code>factor</code>s, in which case they are converted using <code>as.numeric</code> (values of 1, 2, ...). These levels may be regarded as a yet different coding of the variables, and so it may take two steps to get it in the desired form: one to convert the supplied levels to the desired range (often -1 to 1), and the other to replace the coding formulas to correspond to the real values of the variables to be used. See the examples.
</p>


<h3>Value</h3>

<p><code>coded.data</code>, <code>as.coded.data</code>, and <code>recode.data</code> return an object of class  
<code>coded.data</code>,  which inherits from <code><a href="base.html#topic+data.frame">data.frame</a></code>. A <code>coded.data</code> 
object is stored in coded form, and its <code>names</code> attribute contains the coded names, 
where they apply. Thus, when fitting models in <code><a href="#topic+rsm">rsm</a></code> or <code><a href="stats.html#topic+lm">lm</a></code> with 
coded data as the <code>data</code> argument, the model formula should be given in terms of the 
coded variables.
</p>


<h3>Note</h3>

<p>Starting with <span class="pkg">rsm</span> version 2.00, the <code>coded.data</code> class involves additional attributes to serve broader needs in design-generation. Because of this, old <code>coded.data</code> objects may need to be updated using <code>as.coded.data</code> if they are to be used with the newer functions such as <code><a href="#topic+djoin">djoin</a></code>.</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>References</h3>

<p>Lenth RV (2009). &ldquo;Response-Surface Methods in R, Using rsm&rdquo;, 
<em>Journal of Statistical Software</em>, 32(7), 1&ndash;17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code>, <code><a href="#topic+djoin">djoin</a></code>, <code><a href="#topic+dupe">dupe</a></code>, <code><a href="#topic+rsm">rsm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rsm)

### Existing dataset with variables on actual scale
CR &lt;- coded.data (ChemReact, x1 ~ (Time - 85)/5, x2 ~ (Temp - 175)/5)
CR                            # same as print(CR, decode = TRUE)
print(CR, decode = FALSE)     # similar to as.data.frame(CR)
code2val (c(x1=.5, x2=-1), codings = codings(CR))

### Existing dataset, already in coded form
CO &lt;- as.coded.data(codata, x1 ~ (Ethanol - 0.2)/0.1, x2 ~ A.F.ratio - 15)
truenames(CO)
names(CO)

# revert x2 to an uncoded variable
codings(CO)[2] &lt;- NULL
truenames(CO)

### Import a design that is coded in a different way

if (require(conf.design)) { # ----- This example requires conf.design -----

# First, generate a 3^3 in blocks and import it via coded.data
    des3 &lt;- coded.data(conf.design(p=3, G=c(1,1,2)))
    # NOTE: This returns a warning message but does the right thing --
    # It generates these names and coding formulas automatically:
    #   x1 ~ (T1 - 2)/1
    #   x2 ~ (T2 - 2)/1
    #   x3 ~ (T3 - 2)/1
# Now randomize and change the codings and variable names for the real situation:
    mydes &lt;- dupe(des3, coding = c(x1 ~ (Dose - 20)/5,  x2 ~ (Conc - 40)/10,  
                                x3 ~ (Time - 60)/15))
                                
} # ----- end of example requiring package conf.design -----

</code></pre>

<hr>
<h2 id='contour.lm'>Surface plot(s) of a fitted linear model</h2><span id='topic+contour.lm'></span><span id='topic+image.lm'></span><span id='topic+persp.lm'></span>

<h3>Description</h3>

<p><code>contour</code>, <code>image</code>, and <code>persp</code> methods that display the fitted surface for an <code>lm</code> object 
involving two or more numerical predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
contour(x, form, at, bounds, zlim, xlabs, hook, 
    plot.it = TRUE, atpos = 1, decode = TRUE, image = FALSE, 
    img.col = terrain.colors(50), ...)

## S3 method for class 'lm'
image(x, form, at, bounds, zlim, xlabs, hook, 
    atpos = 1, decode = TRUE, ...)

## S3 method for class 'lm'
persp(x, form, at, bounds, zlim, zlab, xlabs, 
    col = "white", contours = NULL, hook, atpos = 3, decode = TRUE, 
    theta = -25, phi = 20, r = 4, border = NULL, box = TRUE, 
    ticktype = "detailed", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour.lm_+3A_x">x</code></td>
<td>
<p>A <code>lm</code> object.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_form">form</code></td>
<td>
<p>A formula, or a list of formulas.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_at">at</code></td>
<td>
<p>Optional <em>named</em> list of fixed values to use for surface slices.
For example, if the predictor variables are <code>x1</code>, <code>x2</code>, and <code>x3</code>, the contour plot of <code>x2</code> versus <code>x1</code> would be
based on the fitted surface sliced at the <code>x3</code> value specified in <code>at</code>; the contour plot of <code>x3</code> versus <code>x1</code> would be sliced at the <code>at</code> value for <code>x2</code>; etc.
If not provided, <code>at</code> defaults to the mean value of each numeric variable.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_bounds">bounds</code></td>
<td>
<p>Optional <em>named</em> list of bounds or grid values to use for
the variables having the same names.  See details.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_zlim">zlim</code></td>
<td>
<p><code>zlim</code> setting passed to parent methods <code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="Matrix.html#topic+image">image</a></code>, or <code><a href="graphics.html#topic+persp">persp</a></code>. The same <code>zlim</code> is used in all plots when several are produced.
If not provided, the range of values across all plotted surfaces is used.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_zlab">zlab</code></td>
<td>
<p>Optional label for the vertical axis.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_xlabs">xlabs</code></td>
<td>
<p>Alternate labels for predictor axes (see Details).</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_hook">hook</code></td>
<td>
<p>Optional list that can contain functions <code>pre.plot</code> and <code>post.plot</code>.  
May be used to add annotations or to re-route the graphs to separate files (see Details).</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_atpos">atpos</code></td>
<td>
<p>Determines where <code>at</code> values are displayed.  A value of 1 (or 2) displays it as part of the <em>x</em> (or <em>y</em>) axis label.
A value of 3 displays it as a subtitle below the plot.  A value of 0 suppresses it.
Any other nonzero value will cause the label to be generated but not displayed; it can be accessed via a <code>hook</code> function.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_decode">decode</code></td>
<td>
<p>This has an effect only if <code>x</code> is an <code><a href="#topic+rsm">rsm</a></code> object or other model object that supports <code><a href="#topic+coded.data">coded.data</a></code>. In such cases, if <code>decode</code> is <code>TRUE</code>, the coordinate axes are transformed to their decoded values.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_image">image</code></td>
<td>
<p>Set to <code>TRUE</code> if you want an image plot overlaid by contours.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_img.col">img.col</code></td>
<td>
<p>Color map to use when <code>image=TRUE</code>.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_plot.it">plot.it</code></td>
<td>
<p>If <code>TRUE</code>, no plot is produced, just the return value.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_col">col</code></td>
<td>
<p>Color or colors used for facets in the perspective plot (see details).</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_contours">contours</code></td>
<td>
<p>If non-<code>NULL</code>, specifications for added contour lines in perspective plot.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_theta">theta</code>, <code id="contour.lm_+3A_phi">phi</code></td>
<td>
<p>Viewing angles passed to <code><a href="graphics.html#topic+persp">persp</a></code> (different defaults).</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_r">r</code></td>
<td>
<p>Viewing distance passed to <code><a href="graphics.html#topic+persp">persp</a></code> (different default).</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_border">border</code>, <code id="contour.lm_+3A_box">box</code></td>
<td>
<p>Options passed to <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_ticktype">ticktype</code></td>
<td>
<p>Option passed to <code><a href="graphics.html#topic+persp">persp</a></code> (different default).</p>
</td></tr>
<tr><td><code id="contour.lm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="Matrix.html#topic+image">image</a></code>, or <code><a href="graphics.html#topic+persp">persp</a></code>. Note, however, that a <code>ylab</code> is ignored, with a message to Use <code>xlabs</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>form</code> may be a single formula or a list of formulas.  A simple formula like
<code>x2 ~ x1</code> will produce a contour plot of the fitted regression surface
for combinations of <code>x2</code> (vertical axis) and <code>x1</code> (horizontal axis).
A list of several such simple formulas will produce a contour plot for each formula.
A two-sided formula produces contour plots for each left-hand variable versus each
right-hand variable (except when they are the same); for example, 
<code>x1+x3 ~ x2+x3</code> is equivalent to 
<code>list(x1~x2, x3~x2, x1~x3)</code>.  
A one-sided formula produces contour plots for each pair of variables.  For example,
<code>~ x1+x2+x3</code> is equivalent to 
<code>list(x2~x1, x3~x1, x3~x2)</code>. 
</p>
<p>For any variables not in the <code>bounds</code> argument, a grid of 26 equally-spaced 
values in the observed range of that variable is used.  If you specify a vector of 
length 2, it is interpreted as the desired range for that variable and a grid of 26
equally-spaced points is generated.  If it is a vector of length 3, the first two elements are used
as the range, and the third as the number of grid points.
If it is a vector of length 4 or more, those
values are used directly as the grid values.
</p>
<p>The results are based on the predicted values of the linear model over the specified grid. If there are <code>factor</code>s among the predictors, the predictions are made over all levels (or combinations of levels) of those factors, and then averaged together. (However, the user may include factors in <code>at</code> to restrict this behavior.)
</p>
<p>By default, the predictor axes are labeled using the variable names in <code>form</code>,
unless <code>x</code> is an <code><a href="#topic+rsm">rsm</a></code> or other object that supports <code><a href="#topic+coded.data">coded.data</a></code>, in which case either the decoded variable names or the variable-coding formulas are used to generate axis labels, depending on whether <code>decode</code> is <code>TRUE</code> or <code>FALSE</code>.
These axis labels are replaced by the entries in <code>xlabs</code> if provided.  One must be careful using this
to make sure that the names are mapped correctly.  The entries in <code>xlabs</code>
should match the respective unique variable names in <code>form</code>, <em>after sorting them in 
(case-insensitive) alphabetical order</em> (not necessarily in order of appearance).  Note that if <code>form</code> is changed, it may also
be necessary to change <code>xlabs</code>.
</p>
<p>Please note that with models fitted to coded data, coded values should be used in <code>at</code> or <code>bounds</code>, regardless of whether <code>decode</code> is <code>TRUE</code> or <code>FALSE</code>. However, any elements that are added afterward via <code><a href="graphics.html#topic+points">points</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>, etc., must be specified in terms of whatever coordinate system is present in the plots.
</p>
<p>In <code>persp</code>, contour lines may be added via the <code>contours</code> argument.  It may be a boolean or character value, or a <code>list</code>.
If boolean and <code>TRUE</code>, default black contour lines are added to the bottom surface of the box.  Character values of <code>"top"</code>, <code>"bottom"</code>
add black contour lines to the specified surface of the box.  <code>contours = "colors"</code> puts contour lines on the bottom using the same colors as those 
at the same height on the surface.  Other character values of <code>contours</code> are taken to be the desired color of the contour lines, plotted at the bottom.
If <code>contours</code> is a named <code>list</code>, its elements (all are optional) are used as follows:
</p>

<dl>
<dt><code>z</code></dt><dd><p>Height where the contour lines are plotted.  May be <code>"bottom"</code> (default), <code>"top"</code>, or a numeric value.</p>
</dd>
<dt><code>col</code></dt><dd><p>Color of the lines.  If not specified, they will be black.  
May be integer color values, color names, or <code>"colors"</code> to match the surface colors.</p>
</dd>
<dt><code>lwd</code></dt><dd><p>Line width; default is 1.</p>
</dd>
</dl>

<p>Since these functions often produce several plots, the <code>hook</code> argument is provided if special setups or annotations are needed for each plot.  It
should be a list that defines one or both of the functions <code>pre.plot</code> and <code>post.plot</code>.  Both of these functions have one argument, the character 
vector <code>labs</code> for that plot (see Value documentation).
</p>
<p>Additional examples and discussion of these plotting functions is available via <code>vignette("rsm-plots")</code>.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing information that is plotted.  
Each list item is itself a <code>list</code> with the following components:
</p>
<table>
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>The values used for the x and y axes</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>The matrix of fitted response values</p>
</td></tr>
<tr><td><code>labs</code></td>
<td>
<p>Character vector of length 5: Elements 1 and 2 are the x and y axis labels, 
elements 3 and 4 are their original variable names,
and element 5 is the slice label (empty if <code>atpos</code> is 0)</p>
</td></tr>
<tr><td><code>zlim</code></td>
<td>
<p>The computed or provided <code>zlim</code> values</p>
</td></tr>
<tr><td><code>transf</code></td>
<td>
<p>(<code>persp</code> only) The 3D transformation for <code><a href="grDevices.html#topic+trans3d">trans3d</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>References</h3>

<p>Lenth RV (2009) &ldquo;Response-Surface Methods in R, Using rsm&rdquo;, 
<em>Journal of Statistical Software</em>, 32(7), 1&ndash;17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+contour">contour</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### Basic example with a linear model:
mpg.lm &lt;- lm(mpg ~ poly(hp, disp, degree = 3), data = mtcars)
contour(mpg.lm, hp ~ disp, image = TRUE)

### Extended example with an rsm model...
heli.rsm &lt;- rsm (ave ~ block + SO(x1, x2, x3, x4), data = heli)

# Plain contour plots
par (mfrow = c(2,3))
contour (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm))

# Same but with image overlay, slices at origin and block 2,
# and no slice labeling
contour (heli.rsm, ~x1+x2+x3+x4, at = list(block="2"), 
    atpos = 0, image = TRUE)

# Default perspective views
persp (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm))

# Same plots, souped-up with facet coloring and axis labeling
persp (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm),
    contours = "col", col = rainbow(40), zlab = "Flight time",
  xlabs = c("Wing area", "Wing length", "Body width", "Body length"))
  
## Not run: 
### Hints for creating graphics files for use in publications...

# Save perspective plots in one PDF file (will be six pages long)
pdf(file = "heli-plots.pdf")
persp (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm))
dev.off()

# Save perspective plots in six separate PNG files
png.hook = list(
    pre.plot = function(lab) 
        png(file = paste(lab[3], lab[4], ".png", sep = "")),
    post.plot = function(lab)
        dev.off())
persp (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm), hook = png.hook)

## End(Not run) 
</code></pre>

<hr>
<h2 id='djoin'>Join designs together into a blocked design</h2><span id='topic+djoin'></span><span id='topic+stdorder'></span>

<h3>Description</h3>

<p>This implements the <span class="pkg">rsm</span> package's building-block provisions for handling
sequences of experiments. We often want to join two or more designs into one blocked design for purposes of analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>djoin(design1, design2, ..., blkname = "Block", blocklev)
stdorder(design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="djoin_+3A_design1">design1</code></td>
<td>
<p>A <code>coded.data</code> object (must have been created by <span class="pkg">rsm</span> 2.00 or higher).</p>
</td></tr>
<tr><td><code id="djoin_+3A_design2">design2</code></td>
<td>
<p>A <code>data.frame</code> (or <code>coded.data</code>) to be appended; 
or a call to a function that will create a design</p>
</td></tr>
<tr><td><code id="djoin_+3A_...">...</code></td>
<td>
<p>Additional designs to be appended</p>
</td></tr>
<tr><td><code id="djoin_+3A_blkname">blkname</code></td>
<td>
<p>Name to give to the blocking variable that distinguishes the designs that are joined</p>
</td></tr>
<tr><td><code id="djoin_+3A_blocklev">blocklev</code></td>
<td>
<p>Label to use in the blocking variable for the added design</p>
</td></tr>
<tr><td><code id="djoin_+3A_design">design</code></td>
<td>
<p>A <code>coded.data</code> object to be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>djoin</code> may be used to augment a design with all manner of other designs, including regular designs generated by <code><a href="#topic+cube">cube</a></code> and its relatives, <code>data.frames</code>, and other <code>coded.data</code> objects. The underlying paradigm is that each design joined is a separate block, and the order in which they are joined could matter. 
</p>
<p>It tries to do this in a smart way: The first design, <code>design1</code>, is required to be a <code><a href="#topic+coded.data">coded.data</a></code> object. If <code>design2</code> is a <code><a href="base.html#topic+data.frame">data.frame</a></code>, and variables with the coded names are not present, it is automatically coded according to <code>design1</code>'s coding formulas. If <code>design2</code> is a <code>coded.data</code> object, and its coding formulas differ from those of <code>design1</code>, then <code>design1</code> is recoded with <code>design2</code>'s codings before the designs are joined. In both cases, any variables in <code>design2</code> not matched in <code>design1</code> are excluded, and any <code>design1</code> variables absent in <code>design2</code> are added with values of <code>NA</code>.
</p>


<h3>Value</h3>

<p><code>djoin</code> returns a <code><a href="#topic+coded.data">coded.data</a></code> object with the combined designs, and coding formulas from the last <code>coded.data</code> object added. The generated blocking variable will be a <code><a href="base.html#topic+factor">factor</a></code>. The designs are sorted by blocks and <code>run.order</code> within blocks; and its <code>row.names</code> will be integers corresponding to this ordering. 
</p>
<p>The function <code>stdorder</code> sorts such data by block and <code>std.order</code> within block to display the designs in their pre-randomized order.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>See Also</h3>

<p><code><a href="#topic+cube">cube</a></code>, <code><a href="#topic+coded.data">coded.data</a></code>, <code><a href="#topic+bbd">bbd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Some existing data
CR1 &lt;- coded.data(ChemReact1, x1 ~ (Time - 85)/5, x2 ~ (Temp - 175)/5)
# add the second part of the experiment; it gets coded automagically
djoin(CR1, ChemReact2)

# A new experiment in a different part of the design space
newdes &lt;- cube(Yield ~ x1 + x2,  n0 = 3, 
    coding = c(x1 ~ (Time - 70)/10, x2 ~ (Temp - 180)/5))
# Time passes ... we do the experiment and plug-in the observed Yield values
newdes$Yield &lt;- rnorm(7, 75, 3) # these are our pretend results
combined &lt;- djoin(CR1, newdes)
# Observe that the combined dataset is recoded to the new formulas
print(combined, decode = FALSE)

# List the new design in standard order
stdorder(newdes)
</code></pre>

<hr>
<h2 id='FO'>Response-surface model components</h2><span id='topic+FO'></span><span id='topic+TWI'></span><span id='topic+PQ'></span><span id='topic+SO'></span><span id='topic+PE'></span>

<h3>Description</h3>

<p>Use of one of these functions in a model is how you specify the portion of the model
that is to be regarded as a response-surface component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FO (...)
TWI (..., formula)
PQ (...)
SO (...)
PE (...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FO_+3A_...">...</code></td>
<td>
<p>The numerical predictors for the response surface, 
separated by commas.</p>
</td></tr>
<tr><td><code id="FO_+3A_formula">formula</code></td>
<td>
<p>Alternative way to specify two-way interactions. Use <code>formula</code> or <code>...</code>, never both.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>FO()</code> in the model formula in <code><a href="#topic+rsm">rsm</a></code>
to specify a first-order response surface (i.e., a linear function) 
in its arguments.  Use <code>TWI()</code> to generate two-way interactions, and <code>PQ()</code> to generate
pure quadratic terms (squares of the <code>FO()</code> terms).  A call to
<code>SO()</code> creates all terms in <code>FO()</code>, <code>TWI()</code>, and <code>PQ()</code> (in that order) for those
variables.  However, specifying <code>SO()</code> in a model formula in <code>rsm</code> will be replaced 
by the explicit sum of model terms, so that the <code>anova</code> table shows separate sums of squares.
Other variables (such as blocks or factors) may be included in the model
but should never be included in the arguments to <code>FO</code> or <code>SO</code>.
</p>
<p><code>PE</code> is used for fitting pure-error models.  It should not be used in
response-surface models.  This function exists primarily for use
by <code><a href="#topic+loftest">loftest</a></code>, but could be useful in other linear-model
contexts for fitting a model that interpolates the means at each distinct
combination of argument values.
</p>
<p>The <code>formula</code> argument in <code>TWI</code> can simplify specifying models where only certain interactions are included. For example, &lsquo;<span class="samp">&#8288;TWI(formula = ~x1:(x2+x3))&#8288;</span>&rsquo; is equivalent to &lsquo;<span class="samp">&#8288;TWI(x1,x2) + TWI(x1,x3)&#8288;</span>&rsquo;. The formula is expanded using <code><a href="stats.html#topic+terms">terms</a></code>, and then only the second-order terms are retained. If this results in only one term, an error condition is raised. This is necessary to prevent <code><a href="#topic+rsm">rsm</a></code> from getting confused in identifying second-order terms.
</p>


<h3>Value</h3>

<p>The functions <code>FO</code>, <code>TWI</code>, <code>PQ</code>, and <code>SO</code> return a matrix whose
columns are the required predictors.
</p>
<p><code>PE</code> returns a <code>factor</code> whose levels are all the distinct combinations of
arguments provided to the function.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>References</h3>

<p>Lenth RV (2009) &ldquo;Response-Surface Methods in R, Using rsm&rdquo;, 
<em>Journal of Statistical Software</em>, 32(7), 1&ndash;17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsm">rsm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### See 'rsm' help for examples of FO, TWI, etc
  
  library(rsm)
  ### Test LOF for a regression model
  ChemReact.lm &lt;- lm(Yield ~ Time*Temp, data = ChemReact1)
  PureError.lm &lt;- update (ChemReact.lm, . ~ PE(Time,Temp))
  anova (ChemReact.lm, PureError.lm)
</code></pre>

<hr>
<h2 id='heli'>Paper Helicopter Data</h2><span id='topic+heli'></span>

<h3>Description</h3>

<p>A central composite design with 4 factors in 2 blocks.  These data
comprise a <code><a href="#topic+coded.data">coded.data</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heli</code></pre>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 7 variables.
Each observation reflects the results of 10 replicated flights under the 
same experimental conditions.
</p>

<dl>
<dt><code>block</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code>.
Block 1 consists of 18 observations (a full factorial plus two center points).
Block 2 consists of 12 observations &ndash; 8 axis points and 4 center points.</p>
</dd>
<dt><code>x1</code></dt><dd><p>a numeric vector.  Coded wing area, <code>x1 ~ (A - 12.4)/.6</code></p>
</dd>
<dt><code>x2</code></dt><dd><p>a numeric vector.  Coded length ratio, <code>x2 ~ (R - 2.52)/.26</code></p>
</dd>
<dt><code>x3</code></dt><dd><p>a numeric vector.  Coded body width, <code>x3 ~ (W - 1.25)/.25</code></p>
</dd>
<dt><code>x4</code></dt><dd><p>a numeric vector.  Coded body length, <code>x4 ~ (L - 2)/.5</code></p>
</dd>
<dt><code>ave</code></dt><dd><p>a numeric vector.  Average flight time, in csec.</p>
</dd>
<dt><code>logSD</code></dt><dd><p>a numeric vector.  100*log(SD of times).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Table 12.5 of Box, GEP, Hunter, JS, and Hunter, WG (2005)
<em>Statistics for Experimenters</em> (2nd ed.), Wiley.
</p>

<hr>
<h2 id='model.data'>Reconstruct data from a linear model</h2><span id='topic+model.data'></span>

<h3>Description</h3>

<p>Create a data frame with just the variables in the formula in 
a <code>lm</code> object.  
This is comparable to <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> or <code><a href="stats.html#topic+model.frame">model.frame</a></code> except that factors,
polynomials, transformations, etc. are not expanded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.data(lmobj, lhs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.data_+3A_lmobj">lmobj</code></td>
<td>
<p>An object returned by <code><a href="stats.html#topic+lm">lm</a></code> or one of its relatives.</p>
</td></tr>
<tr><td><code id="model.data_+3A_lhs">lhs</code></td>
<td>
<p>Boolean indicator of whether or not to include the variable(s) 
on the left-hand side of the model formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an easy-to-use substitute for <code><a href="stats.html#topic+get_all_vars">get_all_vars</a></code>.
The <code>formula</code>, <code>data</code>, and <code>subset</code> arguments, if present in
<code>lmobj</code>'s call, affect the result appropriately.
</p>


<h3>Value</h3>

<p>A data frame containing each of the variables referenced in the model formula.
</p>


<h3>Author(s)</h3>

<p> Russell V. Lenth </p>


<h3>References</h3>

<p>Lenth RV (2009) &ldquo;Response-Surface Methods in R, Using rsm&rdquo;, 
<em>Journal of Statistical Software</em>, 32(7), 1&ndash;17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rsm)
trees.lm &lt;- lm(log(Volume) ~ poly(log(Girth),3), data = trees, subset = 1:20)
model.frame(trees.lm)
model.data(trees.lm)
</code></pre>

<hr>
<h2 id='rsm'>Response-surface regression</h2><span id='topic+rsm'></span><span id='topic+summary.rsm'></span><span id='topic+print.summary.rsm'></span><span id='topic+loftest'></span><span id='topic+codings.rsm'></span><span id='topic+canonical'></span><span id='topic+xs'></span><span id='topic+recover_data.rsm'></span><span id='topic+emm_basis.rsm'></span>

<h3>Description</h3>

<p>Fit a linear model with a response-surface component,
and produce appropriate analyses and summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsm (formula, data, ...)

## S3 method for class 'rsm'
summary(object, adjust = rev(p.adjust.methods), ...)
## S3 method for class 'summary.rsm'
print(x, ...)

## S3 method for class 'rsm'
codings(object)

loftest (object)

canonical (object, threshold = 0.1*max.eigen)
xs (object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsm_+3A_formula">formula</code></td>
<td>
<p>Formula to pass to <code><a href="stats.html#topic+lm">lm</a></code>. 
The model must include at least one <code>FO()</code>, <code>SO()</code>, <code>TWI()</code>, or <code>PQ()</code> term to
define the response-surface portion of the model.
</p>
</td></tr>
<tr><td><code id="rsm_+3A_data">data</code></td>
<td>
<p><code>data</code> argument to pass to <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="rsm_+3A_...">...</code></td>
<td>
<p>In <code>rsm</code>, arguments that are passed to <code><a href="stats.html#topic+lm">lm</a></code>, 
<code><a href="stats.html#topic+summary.lm">summary.lm</a></code>, or <code>canonical</code>, as appropriate.
In <code>summary</code>, and <code>print</code>, additional arguments 
are passed to their generic methods.</p>
</td></tr>
<tr><td><code id="rsm_+3A_object">object</code></td>
<td>
<p>An object of class <code>rsm</code></p>
</td></tr>
<tr><td><code id="rsm_+3A_adjust">adjust</code></td>
<td>
<p>Adjustment to apply to the P values in the coefficient matrix, chosen from among the available <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> methods in the <span class="pkg">stats</span> package. The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="rsm_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for canonical analysis &ndash; see &quot;Canonical analysis&quot; below.</p>
</td></tr>
<tr><td><code id="rsm_+3A_x">x</code></td>
<td>
<p>An object produced by <code>summary</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>rsm</code>, the model formula must contain at least an <code>FO</code> term; optionally, you can add
one or more <code>TWI()</code> terms and/or a <code>PQ()</code> term. All variables that appear
in <code>TWI</code> or <code>PQ</code> <em>must</em> be included in <code>FO</code>.
For convenience, specifying <code>SO()</code> is the same as including <code>FO()</code>, <code>TWI()</code>, and <code>PQ()</code>,
and is the safe, preferred way of specifying a full second-order model.
</p>
<p>The variables in <code>FO</code> comprise the variables to consider in response-surface methods. They need not all appear in <code>TWI</code> and <code>PQ</code> terms; and more than one <code>TWI</code> term is allowed. For example, the following two model formulas are equivalent:
</p>
<pre>
resp ~ Oper + FO(x1,x2,x3,x4) + TWI(x1,x2,x3) + TWI(x2,x3,x4) + PQ(x1,x3,x4)
resp ~ Oper + FO(x1,x2,x3,x4) + TWI(formula = ~x1*x2*x3 + x2*x3*x4) + PQ(x1,x3,x4)
</pre>
<p>The first version, however, creates duplicate <code>x2:x3</code> terms &ndash; which <code>rsm</code> can handle but there may be warning messages if it is subsequently used for predictions or plotted in <code><a href="#topic+contour.lm">contour.lm</a></code>.
</p>
<p>In <code>summary.rsm</code>, any <code>...</code> arguments are passed to <code>summary.lm</code>, except for <code>threshold</code>, which is passed to <code>canonical</code>.
</p>


<h3>Value</h3>

<p><code>rsm</code> returns an <code>rsm</code> object, which is a <code><a href="stats.html#topic+lm">lm</a></code> object with 
additional members as follows:
</p>
<table>
<tr><td><code>order</code></td>
<td>
<p>The order of the model: 1 for first-order, 1.5 for first-order plus interactions, 
or 2 for a model that contains square terms.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The first-order response-surface coefficients.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The matrix of second-order response-surface coefficients, if present.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>Labels for the response-surface terms.  These make the summary much more readable.</p>
</td></tr>
<tr><td><code>coding</code></td>
<td>
<p>Coding formulas, if provided in the <code>codings</code> argument or
if the <code>data</code> argument passed to <code><a href="stats.html#topic+lm">lm</a></code> is a <code><a href="#topic+coded.data">coded.data</a></code> object.</p>
</td></tr>
</table>


<h3>Summary and print methods</h3>

<p>The <code>print</code> method for <code>rsm</code> objects just shows the call and the regression
coefficints.
</p>
<p>The <code>summary</code>method for <code>rsm</code> objects returns an object of class
<code><a href="#topic+summary.rsm">summary.rsm</a></code>, which is an extension of the <code>summary.lm</code>
class with these additional list elements:
</p>

<dl>
<dt>sa</dt><dd><p>Unit-length vector of the path of steepest ascent
(first-order models only).</p>
</dd>
<dt>canonical</dt><dd><p>Canonical analysis (second-order models only) from <code>canonical</code></p>
</dd>
<dt>lof</dt><dd><p>ANOVA table including lack-of-fit test.</p>
</dd>
<dt>coding</dt><dd><p>Coding formulas in parent <code>rsm</code> object.</p>
</dd>
</dl>
<p>Its <code>print</code> method shows the regression summary,
followed by an ANOVA and lack-of-fit test.  
For first-order models, it shows the direction of 
steepest ascent (see <code><a href="#topic+steepest">steepest</a></code>), and for second-order models, it shows the canonical analysis of the
response surface.  
</p>


<h3>Canonical analysis and stationary point</h3>

<p><code>canonical</code> returns a list with elements <code>xs</code>, the stationary point, and <code>eigen</code>, the eigenanalysis of the matrix <b>B</b> of second-order coefficients. Any eigenvalues less than <code>threshold</code> are taken to be zero, and a message is displayed.
If this happens, the stationary point is determined using only the surviving eigenvectors,
and stationary ridges or valleys are assumed to exist in their 
corresponding canonical directions. The default threshold is one tenth
of the maximum eigenvalue, internally named <code>max.eigen</code>.
Setting a small <code>threshold</code> may move the stationary point much farther from the origin.
</p>
<p>When uncoded data are used, the canonical analysis and stationary point are not
very meaningful and those results should probably be ignored.
See &lsquo;<span class="samp">&#8288;vignette("rsm")&#8288;</span>&rsquo; for more details.
</p>
<p>The function <code>xs</code> returns just the stationary point.
</p>


<h3>Other functions</h3>

<p><code>loftest</code> returns an <code><a href="stats.html#topic+anova">anova</a></code> object that tests the fitted model against a model 
that interpolates the means of the response-surface-variable combinations.
</p>
<p><code>codings</code> returns a <code>list</code> of coding formulas if the model was fitted to 
<code><a href="#topic+coded.data">coded.data</a></code>, or <code>NULL</code> otherwise.
</p>


<h3><span class="pkg">emmeans</span> support</h3>

<p>Support is provided for the <span class="pkg">emmeans</span> package: its <code><a href="emmeans.html#topic+emmeans">emmeans</a></code> and related functions work with special provisions for models fitted to coded data. The optional <code>mode</code> argument can have values of <code>"asis"</code> (the default), <code>"coded"</code>, or <code>"decoded"</code>. The first two are equivalent and simply return LS means based on the original model formula and the variables therein (raw or coded), without any conversion. When coded data were used and the user specifies <code>mode = "decoded"</code>, the user must specify results in terms of the decoded variables rather than the coded ones. See the illustration in the Examples section.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>References</h3>

<p>Lenth RV (2009) &ldquo;Response-Surface Methods in R, Using rsm&rdquo;, 
<em>Journal of Statistical Software</em>, 32(7), 1&ndash;17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FO">FO</a></code>, <code><a href="#topic+SO">SO</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="methods.html#topic+lm-class">summary</a></code>, <code><a href="#topic+coded.data">coded.data</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rsm)
CR &lt;- coded.data (ChemReact, x1~(Time-85)/5, x2~(Temp-175)/5)

### 1st-order model, using only the first block
CR.rs1 &lt;- rsm (Yield ~ FO(x1,x2), data=CR, subset=1:7) 
summary(CR.rs1)

### 2nd-order model, using both blocks
CR.rs2 &lt;- rsm (Yield ~ Block + SO(x1,x2), data=CR) 
summary(CR.rs2)

### Example of a rising-ridge situation from Montgomery et al, Table 6.2
RRex &lt;- ccd(Response ~ A + B, n0 = c(0, 3), alpha = "face", 
            randomize = FALSE, oneblock = TRUE)
RRex$Response &lt;- c(52.3, 5.3, 46.7, 44.2, 58.5, 33.5, 32.8, 49.2, 49.3, 50.2, 51.6)
RRex.rsm &lt;- rsm(Response ~ SO(A,B), data = RRex)
canonical(RRex.rsm)  # rising ridge is detected
canonical(RRex.rsm, threshold = 0)  # xs is far outside of the experimental region

## Not run: 
# Illustration of emmeans support
emmeans::emmeans(CR.rs2, ~ x1 * x2, mode = "coded", 
        at = list(x1 = c(-1, 0, 1), x2 = c(-2, 2)))
        
# The following will yield the same results, but based on the decoded data
emmeans::emmeans(CR.rs2, ~ Time * Temp, mode = "decoded", 
        at = list(Time = c(80, 85, 90), Temp = c(165, 185)))

## End(Not run)
</code></pre>

<hr>
<h2 id='steepest'>Steepest-ascent methods for response surfaces</h2><span id='topic+steepest'></span><span id='topic+canonical.path'></span>

<h3>Description</h3>

<p>These functions provide the path of steepest ascent (or descent)
for a fitted response surface produced by <code><a href="#topic+rsm">rsm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steepest (object, dist = seq(0, 5, by = .5), descent = FALSE)
canonical.path(object, which = ifelse(descent, length(object$b), 1),
               dist = seq(-5, 5, by = 0.5), descent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steepest_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+rsm">rsm</a></code> object to be analyzed.</p>
</td></tr>
<tr><td><code id="steepest_+3A_dist">dist</code></td>
<td>
<p>Vector of desired distances along the path of steepest ascent or descent.
In <code>steepest</code>, these must all be non-negative; in <code>canonical.path</code>,
you may want both positive and negative values, which specify opposite directions from the stationary point.</p>
</td></tr>
<tr><td><code id="steepest_+3A_descent">descent</code></td>
<td>
<p>Set this to <code>TRUE</code> to obtain the path of steepest descent, or
<code>FALSE</code> to obtain the path of steepest ascent.  This value is ignored in
<code>canonical.path</code> if <code>which</code> is specified.</p>
</td></tr>
<tr><td><code id="steepest_+3A_which">which</code></td>
<td>
<p>Which canonical direction (eigenvector) to use.</p>
</td></tr>
<tr><td><code id="steepest_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="#topic+canonical">canonical</a></code>. 
Currently this includes only <code>threshold</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>steepest</code> returns the linear path of steepest ascent for first-order models, or a path obtained by ridge analysis (see Draper 1963) for second-order models.  In either case, the path begins at the origin.
</p>
<p><code>canonical.path</code> applies only to second-order models (at least a <code>TWI</code> term present).  It determines a linear path along one of the canonical variables, originating at the stationary point (not the origin).  We need to specify which canonical variable to use.
The eigenvalues obtained in the canaonical analysis are always in decreasing order, so the first canonical direction will be the path of steepest ascent (or slowest descent, if all eigenvalues are negative) from the stationary point, and the last one will be the path of steepest descent (or slowest ascent, if all eigenvalues are positive).  These are the defaults for <code>which</code> when <code>descent=FALSE</code> and <code>descent=TRUE</code> respectively. 
</p>
<p>All eigenvalues less (in absolute value than) <code>threshold</code> are taken to be zero. Increasing this threshold may bring the stationary point, and hence the canonical path, much closer to the design center, and thus less extrapolation.
</p>
<p>With either function, the path in uncoded units depends on how the data are coded.  Accordingly, it is important to code the predictor variables appropriately before fitting the response-surface model.  See <code><a href="#topic+coded.data">coded.data</a></code> and its relatives for more information.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of points along the path of steepest ascent (or descent).
For <code>steepest</code>, this path originates from the center of the experiment; for <code>canonical.path</code>, 
it starts at the stationary point.
If coding information is available, the data frame also includes the uncoded values of the variables.
</p>
<p>For first-order response surfaces, only <code>steepest</code> may be used; the path is linear in that case.  
For second-order surfaces, <code>steepest</code> uses ridge analysis, and the path may be curved.  
</p>


<h3>Note</h3>

<p>Take careful note of the fitted values along the outputted path (labeled <code>yhat</code>).  For example, if the stationary point is a maximum 
(all eigenvalues negative), the fitted values from <code>steepest</code> will increase as far as the stationary point, then they will decrease as we proceed along what is now the path of slowest descent.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>References</h3>

<p>Draper, NR (1963), &ldquo;Ridge analysis of response surfaces&rdquo;,
<em>Technometrics</em>, 5, 469&ndash;479.
</p>
<p>Lenth RV (2009). &ldquo;Response-Surface Methods in R, Using rsm&rdquo;, 
<em>Journal of Statistical Software</em>, 32(7), 1&ndash;17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsm">rsm</a></code>, <code><a href="#topic+coded.data">coded.data</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rsm)
heli.rsm = rsm (ave ~ block + SO(x1, x2, x3, x4), data = heli) 

steepest(heli.rsm)

canonical.path(heli.rsm)
</code></pre>

<hr>
<h2 id='varfcn'>
Display the scaled variance function for a design
</h2><span id='topic+varfcn'></span>

<h3>Description</h3>

<p>This function computes the scaled variance function for a design, based on a 
specified model. Options include plotting separate curves for each of several 
directions from the center, or a contour plot for two of the design factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varfcn(design, formula, dist = seq(0, 2, by = 0.1), vectors, contour = FALSE, 
       plot = TRUE, main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varfcn_+3A_design">design</code></td>
<td>
<p>A <code>data.frame</code> or <code>coded.data</code> object</p>
</td></tr>
<tr><td><code id="varfcn_+3A_formula">formula</code></td>
<td>
<p>The model formula for which to compute the variance function</p>
</td></tr>
<tr><td><code id="varfcn_+3A_dist">dist</code></td>
<td>
<p>Vector of distances from the origin at which to compute the scaled variance</p>
</td></tr>
<tr><td><code id="varfcn_+3A_vectors">vectors</code></td>
<td>
<p>A <code>data.frame</code> of design variables. Each nonzero row specifies a direction in which to calculate the scaled variance.</p>
</td></tr>
<tr><td><code id="varfcn_+3A_contour">contour</code></td>
<td>
<p>A logical variable. If <code>TRUE</code>, a contour plot is produced; if <code>FALSE</code>, curves are plotted for each direction in <code>vectors</code>.</p>
</td></tr>
<tr><td><code id="varfcn_+3A_plot">plot</code></td>
<td>
<p>A logical variable. If <code>TRUE</code>, a plot is produced.</p>
</td></tr>
<tr><td><code id="varfcn_+3A_main">main</code></td>
<td>
<p>Title for the plot. The default is constructed based on the name of <code>design</code> and <code>formula</code>.</p>
</td></tr>
<tr><td><code id="varfcn_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> or <code><a href="graphics.html#topic+contour">contour</a></code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scaled prediction variance at a particular design point is the variance of the predicted value, multiplied by the sample size <em>N</em>, and divided by the error variance. (See, for example, Montgomery <em>et al.</em>, Section 8.2.1). It depends on the design point, but for a symmetric design, it depends only on the distance from the origin and the direction. This function provides a simple way to examine the variance function directly. (There are other more sophisticated methods available that integrate-out the direction, for example <code><a href="Vdgraph.html#topic+Vdgraph">Vdgraph</a></code> in the <code>Vdgraph</code> package.) 
</p>
<p>If <code>vectors</code> is not specified and <code>contour==FALSE</code>, the function generates default directions along one axis, and on a diagonal through a corner in each dimension. For example, with four design variables, the default directions are (1,0,0,0), (1,1,0,0), (1,1,1,0), and (1,1,1,1). The graph produced shows how the scaled variance changes along each of these vectors, for the distances provided. In a rotatable design, these curves will all be the same. 
</p>
<p>When <code>countour==TRUE</code>, only the ordering of columns in <code>vectors</code> matters. A grid is constructed over the distance range for the first two variables in <code>vectors</code>. The design points are also plotted for reference, with different symbol sizes depending on replications. When there are more than two response-surface predictors, the contour plot may be misleading, as it does not display what happens as one simultaneously varies three or more variables.
</p>


<h3>Value</h3>

<p>The function invisibly returns a <code>data.frame</code> containing the data that was (or would have been) plotted.</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>References</h3>

<p>Myers, RH Montgomery DC, and Anderson-Cook CM (2009)
<em>Response Surface Methodology</em> (3rd ed.), Wiley.</p>


<h3>See Also</h3>

<p><code><a href="Vdgraph.html#topic+Vdgraph">Vdgraph</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  des = ccd(~ x1 + x2 + x3, alpha = 1.5, block = Phase ~ x1*x2*x3, randomize=FALSE)
  varfcn(des, ~ Phase + SO(x1, x2, x3))
  varfcn(des, ~ Phase + SO(x1, x2, x3), contour=TRUE)
  
  # 10 random directions
  dirs = data.frame(x3=rnorm(10), x2=rnorm(10), x1=rnorm(10))
  varfcn(des, ~ Phase + SO(x1, x2, x3), vectors = dirs)

  # exclude some points to make it more interesting
  lost = c(1,2,3,5,8,13,21)
  varfcn(des[-lost, ], ~ Phase + SO(x1, x2, x3), contour=TRUE)
  
  # different plot due to order of columns
  varfcn(des[-lost, ], ~ Phase + SO(x1, x2, x3), vectors = dirs, contour=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
