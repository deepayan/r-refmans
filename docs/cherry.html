<!DOCTYPE html><html><head><title>Help for package cherry</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cherry}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Adjusted'><p>Adjusted p-values for the number of true hypotheses.</p></a></li>
<li><a href='#Closed+20Testing'><p>Closed Testing for Exploratory Research</p></a></li>
<li><a href='#Closure+20class'><p>Class &quot;closure&quot; for storing the result of the closed testing procedure</p></a></li>
<li><a href='#Construct+20the+20DAG+20from+20a+20given+20collection+20of+20sets.'><p>Constructing a DAG.</p></a></li>
<li><a href='#DAG+20class'><p>Class &quot;DAG&quot; for storing the result of the DAG multiple testing method</p></a></li>
<li><a href='#DAG+20Testing'><p>Testing of hypotheses, forming a DAG.</p></a></li>
<li><a href='#DAGpick'><p>Confidence limits for the number of false hypotheses in a given family of sets.</p></a></li>
<li><a href='#DAGstructure+20class'><p>Class &quot;DAGstructure&quot; for storing the result of the construct method that constructs the DAG.</p></a></li>
<li><a href='#hommelFast'><p>Calculates adjusted p-values of Hommel's method efficiently.</p></a></li>
<li><a href='#NAEP'><p>National Assessment of Educational Progress (NAEP) p-values</p></a></li>
<li><a href='#Pick'><p>Confidence limits for the number of true hypotheses.</p></a></li>
<li><a href='#Plot+20region+20objects'><p>Visualizing of the region hypotheses that could be rejected.</p></a></li>
<li><a href='#Region+20class'><p>Class &quot;region&quot; for storing the result of the region procedure</p></a></li>
<li><a href='#Region+20Testing'><p>Testing of all possible region hypotheses</p></a></li>
<li><a href='#regionpick'><p>Confidence limits for the number of false hypotheses in a given region.</p></a></li>
<li><a href='#Select+20with+20shortcuts'><p>Confidence limits for the number of true hypotheses, with shortcuts.</p></a></li>
<li><a href='#structured+20Holm'><p>Testing of hypotheses, forming a DAG, by using a variant of Holm's method.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.6-14</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Testing Methods for Exploratory Research</td>
</tr>
<tr>
<td>Author:</td>
<td>Jelle Goeman, Aldo Solari, Rosa Meijer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jelle Goeman &lt;j.j.goeman@lumc.nl&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>bitops, lpSolve, hommel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, multtest</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an alternative approach to multiple testing
        by calculating a simultaneous upper confidence bounds for the
        number of true null hypotheses among any subset of the hypotheses of interest, 
        using the methods of Goeman and Solari (2011) &lt;<a href="https://doi.org/10.1214%2F11-STS356">doi:10.1214/11-STS356</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Collate:</td>
<td>closed.R shortcuts.R Meinshausen.R regionmethod.R DAGmethod.R
DAGstructure.R structuredHolm.R</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-07 07:56:33 UTC; jelle</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-07 15:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='Adjusted'>Adjusted p-values for the number of true hypotheses.</h2><span id='topic+adjusted'></span>

<h3>Description</h3>

<p>Calculates adjusted p-values for the number of true hypotheses on the basis of the closed testing procedure.</p>


<h3>Usage</h3>

<pre><code class='language-R'> adjusted (closure, reject, n=0) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Adjusted_+3A_closure">closure</code></td>
<td>
<p>An object of class <code><a href="#topic+closure">closure</a></code>, typically created through a call to <code><a href="#topic+closed">closed</a></code> .</p>
</td></tr>
<tr><td><code id="Adjusted_+3A_reject">reject</code></td>
<td>
<p>A character vector identifying the hypotheses to be rejected. Must be a subvector of <code>hypotheses(closure)</code>.</p>
</td></tr>
<tr><td><code id="Adjusted_+3A_n">n</code></td>
<td>
<p>The maximum number of false null hypotheses allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>pick</code> calculates adjusted p-values for intersection hypotheses of interest.</p>


<h3>Value</h3>

<p>The function returns a p-value (numeric).</p>


<h3>Author(s)</h3>

<p>Jelle Goeman: <a href="mailto:j.j.goeman@lumc.nl">j.j.goeman@lumc.nl</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Example: the birthwt data set from the MASS library
  # We want to find variables associated with low birth weight
  library(MASS)
  fullfit &lt;- glm(low~age+lwt+race+smoke+ptl+ht+ui+ftv, family=binomial, data=birthwt)
  hypotheses &lt;- c("age", "lwt", "race", "smoke", "ptl", "ht", "ui", "ftv")

  # Define the local test to be used in the closed testing procedure
  mytest &lt;- function(hyps) {
    others &lt;- setdiff(hypotheses, hyps)
    form &lt;- formula(paste(c("low~",  paste(c("1", others), collapse="+"))))
    anov &lt;- anova(glm(form, data=birthwt, family=binomial), fullfit, test="Chisq")
    res &lt;- anov$"Pr("[2]                    # for R &gt;= 2.14.0
    if (is.null(res)) res &lt;- anov$"P("[2]   # earlier versions
    res
  }

  # Perform the closed testing with ajdusted p-values
  cl &lt;- closed(mytest, hypotheses, alpha=NA)

  # What is the adjusted p-value of the intersection of the following hypotheses?
  adjusted(cl, c("ht", "lwt", "smoke", "ui"))

  # From what confidence level would we conclude 
  # that more than 2 of the following hypotheses would be false?
  adjusted(cl, c("ht", "lwt", "smoke", "ui"), n=2)
</code></pre>

<hr>
<h2 id='Closed+20Testing'>Closed Testing for Exploratory Research</h2><span id='topic+closed'></span>

<h3>Description</h3>

<p>Performs the closed testing procedure for user-specified local test.</p>


<h3>Usage</h3>

<pre><code class='language-R'> closed (test, hypotheses, alpha = 0.05, adjust=FALSE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Closed+2B20Testing_+3A_test">test</code></td>
<td>
<p>A function that performs the local test. The function should accept a subvector of the <code>hypotheses</code> argument as input, and return a p-value.</p>
</td></tr>
<tr><td><code id="Closed+2B20Testing_+3A_hypotheses">hypotheses</code></td>
<td>
<p>Identifiers of the collection of elementary hypotheses.</p>
</td></tr>
<tr><td><code id="Closed+2B20Testing_+3A_alpha">alpha</code></td>
<td>
<p>The significance level of the test procedure. If set to <code>NA</code>, the function calculates adjusted p-values for each hypothesis in the closure.</p>
</td></tr>
<tr><td><code id="Closed+2B20Testing_+3A_adjust">adjust</code></td>
<td>
<p>Whether adjusted p-values should be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>closed</code> performs the closed testing procedure on the collection <code>hypotheses</code>, testing all their intersection hypotheses and controlling the familywise error rate.</p>


<h3>Value</h3>

<p>The function <code>closed</code> returns an object of class <code><a href="#topic+closure">closure</a></code>.</p>


<h3>Note</h3>

<p>The number of intersection hypotheses is exponential in the number of elementary hypotheses. The number of elementary hypotheses is therefore limited to <code>log2(.Machine$integer.max+1)</code> (typically 31) for computational reasons.
</p>
<p>It is possible to set both <code>adjust</code> to <code>TRUE</code> and specify <code>alpha</code>. In that case, adjusted p-values are calculated up to a value <code>alpha</code>; all higher p-values are set to 1.</p>


<h3>Author(s)</h3>

<p>Jelle Goeman: <a href="mailto:j.j.goeman@lumc.nl">j.j.goeman@lumc.nl</a></p>


<h3>References</h3>

<p>Goeman and Solari (2011) Statistical Science 26 (4) 584-597.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Example: the birthwt data set from the MASS library
  # We want to find variables associated with low birth weight
  library(MASS)
  fullfit &lt;- glm(low~age+lwt+race+smoke+ptl+ht+ui+ftv, family=binomial, data=birthwt)
  hypotheses &lt;- c("age", "lwt", "race", "smoke", "ptl", "ht", "ui", "ftv")

  # Define the local test to be used in the closed testing procedure
  mytest &lt;- function(hyps) {
    others &lt;- setdiff(hypotheses, hyps)
    form &lt;- formula(paste(c("low~",  paste(c("1", others), collapse="+"))))
    anov &lt;- anova(glm(form, data=birthwt, family=binomial), fullfit, test="Chisq")
    res &lt;- anov$"Pr("[2]                    # for R &gt;= 2.14.0
    if (is.null(res)) res &lt;- anov$"P("[2]   # earlier versions
    res
  }

  # perform the closed testing
  cl &lt;- closed(mytest, hypotheses)
  cl

  # how many variables among a chosen set are associated with the response?
  pick(cl, c("ht", "lwt", "smoke", "ui"))
  
  # adjusted p-values and a confidence distribution
  cl &lt;- closed(mytest, hypotheses, alpha=NA)
  pick(cl, c("ht", "lwt", "smoke", "ui"))
</code></pre>

<hr>
<h2 id='Closure+20class'>Class &quot;closure&quot; for storing the result of the closed testing procedure</h2><span id='topic+closure'></span><span id='topic+closure-class'></span><span id='topic+show+2Cclosure-method'></span><span id='topic+summary+2Cclosure-method'></span><span id='topic+defining'></span><span id='topic+defining+2Cclosure-method'></span><span id='topic+shortlist'></span><span id='topic+shortlist+2Cclosure-method'></span><span id='topic+hypotheses'></span><span id='topic+hypotheses+2Cclosure-method'></span><span id='topic+alpha+2Cclosure-method'></span><span id='topic+alpha+3C-+2Cclosure-method'></span><span id='topic+alpha+3C-'></span><span id='topic+alpha'></span>

<h3>Description</h3>

<p>The class closure is the output of a call to <code><a href="#topic+closed">closed</a></code>. It stores the information needed to calculate confidence sets for the number of true and/or false hypotheses among a selected set.</p>


<h3>Slots</h3>

<p>These slots are not meant to be directly accessed by the user.
</p>

<dl>
<dt><code>adjusted</code>:</dt><dd><p>Object of class &quot;numeric&quot;. Sores the adjusted p-values.</p>
</dd>
<dt><code>defining</code>:</dt><dd><p>Object of class &quot;integer&quot;. Stores the identifiers of the intersection hypotheses that are the defining rejections of the closed testing procedure. The identifiers should be read as binary booleans, i.e. 19 = 10011 (binary) is the intersection of the first, second and fifth elementary hypothesis.</p>
</dd>
<dt><code>hypotheses</code>:</dt><dd><p>Object of class &quot;character&quot;. Holds the names of the elementary hypotheses.</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>Object of class &quot;numeric&quot;. The type I error level chosen.</p>
</dd>
<dt><code>max.alpha</code>:</dt><dd><p>Object of class &quot;numeric&quot;. The largest value for which adjusted p-values have been calculated.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p>(closure): Prints a brief description of the test results, including the upper bound of the number of true hypotheses and the corresponding lower bound to the number of false hypotheses among the full set.</p>
</dd>
<dt>summary</dt><dd><p>(closure): Prints the test results (as <code>show</code>) plus the defining rejections.</p>
</dd>
<dt>defining</dt><dd><p>(closure): Extracts the defining rejections as a list.</p>
</dd>
<dt>shortlist</dt><dd><p>(closure): Extracts the shortlist as a list.</p>
</dd>
<dt>hypotheses</dt><dd><p>(closure): Extracts the hypotheses slot.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jelle Goeman: <a href="mailto:j.j.goeman@lumc.nl">j.j.goeman@lumc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+closed">closed</a></code>, <code><a href="#topic+pick">pick</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Example: the birthwt data set from the MASS library
  # We want to find variables associated with low birth weight
  library(MASS)
  fullfit &lt;- glm(low~age+lwt+race+smoke+ptl+ht+ui+ftv, family=binomial, data=birthwt)
  hypotheses &lt;- c("age", "lwt", "race", "smoke", "ptl", "ht", "ui", "ftv")

  # Define the local test to be used in the closed testing procedure
  mytest &lt;- function(hyps) {
    others &lt;- setdiff(hypotheses, hyps)
    form &lt;- formula(paste(c("low~",  paste(c("1", others), collapse="+"))))
    anov &lt;- anova(glm(form, data=birthwt, family=binomial), fullfit, test="Chisq")
    res &lt;- anov$"Pr("[2]                    # for R &gt;= 2.14.0
    if (is.null(res)) res &lt;- anov$"P("[2]   # earlier versions
    res
  }

  # perform the closed testing procedure
  cl &lt;- closed(mytest, hypotheses)
  summary(cl)
  defining(cl)
  shortlist(cl)
  hypotheses(cl)

  # how many variables among a chosen set are associated with the response?
  pick(cl, c("ht", "lwt", "smoke", "ui"))
</code></pre>

<hr>
<h2 id='Construct+20the+20DAG+20from+20a+20given+20collection+20of+20sets.'>Constructing a DAG.</h2><span id='topic+construct'></span>

<h3>Description</h3>

<p>Constructs a DAG from a given collection of sets. Filters duplicates, and checks whether the eventual DAG structure has twoway logical relationships.</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct (sets)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Construct+2B20the+2B20DAG+2B20from+2B20a+2B20given+2B20collection+2B20of+2B20sets._+3A_sets">sets</code></td>
<td>
<p>A list of sets/hypotheses for which you want to construct a DAG according to the underlying subset relations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>construct</code> returns an object of class <code><a href="#topic+DAGstructure">DAGstructure</a></code>.</p>


<h3>Author(s)</h3>

<p>Rosa Meijer: <a href="mailto:r.j.meijer@lumc.nl">r.j.meijer@lumc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DAGstructure">DAGstructure</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  #Generate data, where the response Y is associated with two (out of 4) covariates
  set.seed(1)
  n=100
  p=4
  X &lt;- matrix(rnorm(n*p),n,p)
  beta &lt;- c(0,0.5,0.5,0)
  Y &lt;- X %*% beta + rnorm(n)
  
  # Let us assume we have the following sets that we want to test: 
  sets &lt;- list(c(1,2,3,4), c(1,2), c(2,3,4), c(2,3), 1, 2, 3, 4)
  names(sets) &lt;- c(1234, 12, 234, 23, 1, 2, 3, 4)
  
  # Start by making the corresponding graph structure
  struct &lt;- construct(sets)
  
  # Check whether the DAG has toway logical relations: 
  istwoway(struct)

</code></pre>

<hr>
<h2 id='DAG+20class'>Class &quot;DAG&quot; for storing the result of the DAG multiple testing method</h2><span id='topic+DAG'></span><span id='topic+DAG-class'></span><span id='topic+show+2CDAG-method'></span><span id='topic+summary+2CDAG-method'></span><span id='topic+implications+2CDAG-method'></span><span id='topic+alpha+2CDAG-method'></span><span id='topic+pvalue+2CDAG-method'></span>

<h3>Description</h3>

<p>The class DAG is the output of a call to <code><a href="#topic+DAGmethod">DAGmethod</a></code>. It stores which hypotheses have been rejected and can be used to calculate confidence sets for the number of true and/or false hypotheses among a selected set of hypotheses.</p>


<h3>Slots</h3>

<p>These slots are not meant to be directly accessed by the user.
</p>

<dl>
<dt><code>sets</code>:</dt><dd><p>Object of class &quot;list&quot;. Stores unique original sets that are to be tested.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class &quot;character&quot;. Stores whether the any-parent, all-parents or structuredHolm method has been used.</p>
</dd>
<dt><code>isadjusted</code>:</dt><dd><p>Object of class &quot;logical&quot;. Stores whether adjusted p-values are calculated.</p>
</dd>
<dt><code>allpvalues</code>:</dt><dd><p>Object of class &quot;numeric&quot;. Stores (adjusted) p-values for all hypotheses. Has value NA if adjusted p-value is larger than alpha.</p>
</dd>
<dt><code>implications</code>:</dt><dd><p>Object of class &quot;logical&quot;. Stores whether hypotheses are implications at chosen alpha-level</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>Object of class &quot;numeric&quot;. The type I error level chosen.</p>
</dd>
<dt><code>rejected</code>:</dt><dd><p>Object of class &quot;logical&quot;. Stores for each hypothesis wether this hypothesis has been rejected</p>
</dd>
<dt><code>leaf_based_sets</code>:</dt><dd><p>Object of class &quot;list&quot;. Stores sets expressed in the indices of their corresponding leaf nodes (which are sets itself).</p>
</dd>
<dt><code>twoway</code>:</dt><dd><p>Object of class &quot;logical&quot;. Is TRUE if the final DAG structure has twoway logical relationships.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p>(DAG): Prints how many hypotheses there are in total and how many of them were rejected.</p>
</dd>
<dt>summary</dt><dd><p>(DAG): Prints the test results (as <code>show</code>).</p>
</dd>
<dt>alpha</dt><dd><p>(DAG): Retrieves the maximal alpha_value from the DAG object.</p>
</dd>
<dt>implications</dt><dd><p>(DAG): Retrieves the implications from a given DAG object.</p>
</dd>
<dt>pvalue</dt><dd><p>(DAG,indicator): Retrieves pvalues for all possible hypotheses (as specified by indicator) from the DAG object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Rosa Meijer: <a href="mailto:r.j.meijer@lumc.nl">r.j.meijer@lumc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DAGmethod">DAGmethod</a></code>, <code><a href="#topic+DAGpick">DAGpick</a></code>, <code><a href="#topic+structuredHolm">structuredHolm</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #Generate data, where the response Y is associated with two (out of 4) covariates
  set.seed(1)
  n=100
  p=4
  X &lt;- matrix(rnorm(n*p),n,p)
  beta &lt;- c(0,0.5,0.5,0)
  Y &lt;- X %*% beta + rnorm(n)

  # Let us assume we have the following sets that we want to test: 
  sets &lt;- list(c(1,2,3,4), c(1,2), c(2,3,4), c(2,3), 1, 2, 3, 4)
  names(sets) &lt;- c(1234, 12, 234, 23, 1, 2, 3, 4)

  # Start by making the corresponding graph structure
  struct &lt;- construct(sets)
  
  # Check whether the DAG has toway logical relations: 
  istwoway(struct)
  
  # Define the local test to be used in the closed testing procedure. 
  # This test expects a set as input.
  mytest &lt;- function(set)
  { 
    X &lt;- X[,set,drop=FALSE]
    lm.out &lt;- lm(Y ~ X)
    x &lt;- summary(lm.out)
    return(pf(x$fstatistic[1],x$fstatistic[2],x$fstatistic[3],lower.tail=FALSE))  
  }

  # Perform the DAG procedure (default is all-parents method).
  DAG &lt;- DAGmethod(struct, mytest, isadjusted=TRUE)
  summary(DAG)
  
  # What are the smallest sets that are found to be significant? If the sets have names, 
  # as in our example, the implications function will return the names 
  # of the implying sets, together with their (adjusted) p-value. 
  # If no names are provided, indices will be used instead of the names. 
  implications(DAG)
  
  # What is the adjusted p-value of the null-hypothesis corresponding to the fourth set, 
  # which is set c(2,3)? 
  # To look up the pvalue, the function uses the index or name of the set 
  # in the list of sets stored in the DAGstructure. 
  # (Note that, if there were duplicate sets in the original list, this index can be different from 
  # the one in the original list given to \code{construct})
  pvalue(DAG,4)
  pvalue(DAG, "23") #as above, but while using names
  
  # How many of the elementary hypotheses (the last 4 sets) have to be false 
  # with probability 1-alpha? 
  # Sets (don't have to be elementary hypotheses in general) must be specified 
  # by their index or name. 
  DAGpick(DAG, 5:8)
  DAGpick(DAG, c("1","2","3","4")) #as above, but while using names


</code></pre>

<hr>
<h2 id='DAG+20Testing'>Testing of hypotheses, forming a DAG.</h2><span id='topic+DAGmethod'></span>

<h3>Description</h3>

<p>Tests all hypotheses in a given DAG while controlling the FWER, using a user-specified local test.</p>


<h3>Usage</h3>

<pre><code class='language-R'> DAGmethod (DAGstructure, test, alpha_max = 0.05, method = "all", isadjusted = FALSE, 
        optimization = "none", degree = "group", pvalues = NULL, verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DAG+2B20Testing_+3A_dagstructure">DAGstructure</code></td>
<td>
<p>DAGstructure object, as returned by the function <code>construct</code>.</p>
</td></tr>
<tr><td><code id="DAG+2B20Testing_+3A_test">test</code></td>
<td>
<p>A function that performs the local test. The function should have a set as input and return a p-value.</p>
</td></tr>
<tr><td><code id="DAG+2B20Testing_+3A_alpha_max">alpha_max</code></td>
<td>
<p>The significance level of the test procedure.</p>
</td></tr>
<tr><td><code id="DAG+2B20Testing_+3A_method">method</code></td>
<td>
<p>Type of DAG procedure that is chosen. &quot;all&quot; gives the all-parents procedure, &quot;any&quot; the any-parent procedure.</p>
</td></tr>
<tr><td><code id="DAG+2B20Testing_+3A_isadjusted">isadjusted</code></td>
<td>
<p>If set to TRUE, adjusted p-values will be calculated. Otherwise, the p-values of all rejected hypotheses will equal alpha_max.</p>
</td></tr>
<tr><td><code id="DAG+2B20Testing_+3A_optimization">optimization</code></td>
<td>
<p>Can be, in ascending order of accuracy and computational costs: &quot;none&quot;, &quot;LP&quot; (linear programming) or &quot;ILP&quot; (integer linear programming).</p>
</td></tr>
<tr><td><code id="DAG+2B20Testing_+3A_degree">degree</code></td>
<td>
<p>Can be &quot;group&quot; or &quot;individual&quot;. If &quot;group&quot; is chosen, optimization is done on a group level, otherwise on an individual level (more accurate, but more time-consuming).</p>
</td></tr>
<tr><td><code id="DAG+2B20Testing_+3A_pvalues">pvalues</code></td>
<td>
<p>Optional (in case of stored p-values): a vector in which the raw p-values of the exact sets as found in the DAGstructure argument are stored (in the same order). If the test function is provided, this argument is not necessary.</p>
</td></tr>
<tr><td><code id="DAG+2B20Testing_+3A_verbose">verbose</code></td>
<td>
<p>If set to TRUE, while running the method, a counter will indicate how many hypotheses are already rejected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>DAGmethod</code> tests all possible hypotheses within a given DAG structure, while controlling the familywise error rate.</p>


<h3>Value</h3>

<p>The function <code>DAGmethod</code> returns an object of class <code><a href="#topic+DAG">DAG</a></code>.</p>


<h3>Author(s)</h3>

<p>Rosa Meijer: <a href="mailto:r.j.meijer@lumc.nl">r.j.meijer@lumc.nl</a></p>


<h3>References</h3>

<p>Meijer and Goeman (2015) Biometrical Journal 57 (1) 123-143.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DAG">DAG</a></code>, <code><a href="#topic+DAGstructure">DAGstructure</a></code>, <code><a href="#topic+construct">construct</a></code>, <code><a href="#topic+DAGpick">DAGpick</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  #Generate data, where the response Y is associated with two (out of 4) covariates
  set.seed(1)
  n=100
  p=4
  X &lt;- matrix(rnorm(n*p),n,p)
  beta &lt;- c(0,0.5,0.5,0)
  Y &lt;- X %*% beta + rnorm(n)

  # Let us assume we have the following sets that we want to test: 
  sets &lt;- list(c(1,2,3,4), c(1,2), c(2,3,4), c(2,3), 1, 2, 3, 4)
  names(sets) &lt;- c(1234, 12, 234, 23, 1, 2, 3, 4)

  # Start by making the corresponding graph structure
  struct &lt;- construct(sets)
  
  # Check whether the DAG has toway logical relations: 
  istwoway(struct)
  
  # Define the local test to be used in the closed testing procedure. 
  # This test expects a set as input. 
  mytest &lt;- function(set)
  { 
    X &lt;- X[,set,drop=FALSE]
    lm.out &lt;- lm(Y ~ X)
    x &lt;- summary(lm.out)
    return(pf(x$fstatistic[1],x$fstatistic[2],x$fstatistic[3],lower.tail=FALSE))  
  }

  # Perform the DAG procedure (default is all-parents method).
  DAG &lt;- DAGmethod(struct, mytest, isadjusted=TRUE)
  summary(DAG)
  
  # What are the smallest sets that are found to be significant? 
  implications(DAG)
  
  # What is the adjusted p-value of the null-hypothesis corresponding to the fourth set, 
  # which is set c(2,3)? 
  # To look up the pvalue, the function uses the index or name of the set 
  # in the list of sets stored in the DAGstructure. 
  # (Note that, if there were duplicate sets in the original list, this index can be different from 
  # the one in the original list given to \code{construct})
  pvalue(DAG,4)
  pvalue(DAG, "23") #as above, but while using names
  
  # How many of the elementary hypotheses (the last 4 sets) have to be false 
  # with probability 1-alpha? 
  # Sets (don't have to be elementary hypotheses in general) must be specified 
  # by their index or name. 
  DAGpick(DAG, 5:8)
  DAGpick(DAG, c("1","2","3","4")) #as above, but while using names
  
</code></pre>

<hr>
<h2 id='DAGpick'>Confidence limits for the number of false hypotheses in a given family of sets.</h2><span id='topic+DAGpick'></span>

<h3>Description</h3>

<p>Calculates confidence limits for the number of false hypotheses on the basis of the DAG procedure within a family of sets.</p>


<h3>Usage</h3>

<pre><code class='language-R'> DAGpick (DAG, indicators, optimization = "ILP")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DAGpick_+3A_dag">DAG</code></td>
<td>
<p>DAG object, as returned by the function <code>DAGmethod</code>.</p>
</td></tr>
<tr><td><code id="DAGpick_+3A_indicators">indicators</code></td>
<td>
<p>The names or indices of the sets (as specified in the DAGstructure object) for which you want to know the confidence limits. Note that, if there were duplicate sets in the original list, the index can be different from the one in the original list given to <code>construct</code>.</p>
</td></tr>
<tr><td><code id="DAGpick_+3A_optimization">optimization</code></td>
<td>
<p>Can be, in ascending order of accuracy and computational costs: &quot;LP&quot; (linear programming) or &quot;ILP&quot; (integer linear programming).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>DAGpick</code> returns the lower bound of a 1-alpha confidence set for the number of false sets. For the moment, the function can only be used on DAG objects that correspond to a DAG with two-way logical relationships.</p>


<h3>Author(s)</h3>

<p>Rosa Meijer: <a href="mailto:r.j.meijer@lumc.nl">r.j.meijer@lumc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DAGmethod">DAGmethod</a></code>, <code><a href="#topic+DAG">DAG</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #Generate data, where the response Y is associated with two (out of 4) covariates
  set.seed(1)
  n=100
  p=4
  X &lt;- matrix(rnorm(n*p),n,p)
  beta &lt;- c(0,0.5,0.5,0)
  Y &lt;- X %*% beta + rnorm(n)
    
  # Let us assume we have the following sets that we want to test: 
  sets &lt;- list(c(1,2,3,4), c(1,2), c(2,3,4), c(2,3), 1, 2, 3, 4)
  names(sets) &lt;- c(1234, 12, 234, 23, 1, 2, 3, 4)
    
  # Start by making the corresponding graph structure
  struct &lt;- construct(sets)

  # Define the local test to be used in the closed testing procedure. 
  # This test expects a set as input. 
  mytest &lt;- function(set)
  { 
    X &lt;- X[,set,drop=FALSE]
    lm.out &lt;- lm(Y ~ X)
    x &lt;- summary(lm.out)
    return(pf(x$fstatistic[1],x$fstatistic[2],x$fstatistic[3],lower.tail=FALSE))  
  }
    
  # Perform the DAG procedure (default is all-parents method).
  DAG &lt;- DAGmethod(struct, mytest, isadjusted=TRUE)
  summary(DAG)
    
  # How many of the elementary hypotheses (the last 4 sets) have to be false 
  # with probability 1-alpha? 
  # Sets (don't have to be elementary hypotheses in general) must be specified 
  # by their index or name. 
  DAGpick(DAG, 5:8)
  DAGpick(DAG, c("1","2","3","4")) #as above, but while using names

</code></pre>

<hr>
<h2 id='DAGstructure+20class'>Class &quot;DAGstructure&quot; for storing the result of the construct method that constructs the DAG.</h2><span id='topic+DAGstructure'></span><span id='topic+DAGstructure-class'></span><span id='topic+istwoway'></span><span id='topic+istwoway+2CDAGstructure-method'></span>

<h3>Description</h3>

<p>The class DAGstructure is the output of a call to <code><a href="#topic+construct">construct</a></code>. It stores the DAG structure that is induced by the given sets.</p>


<h3>Slots</h3>

<p>These slots are not meant to be directly accessed by the user.
</p>

<dl>
<dt><code>parents</code>:</dt><dd><p>Object of class &quot;list&quot;. Stores the parents of each set, indicated by indices.</p>
</dd>
<dt><code>children</code>:</dt><dd><p>Object of class &quot;list&quot;. Stores the children of each set, indicated by indices.</p>
</dd>
<dt><code>sets</code>:</dt><dd><p>Object of class &quot;list&quot;. Stores the sets that are used for the DAG construction.</p>
</dd>
<dt><code>twoway</code>:</dt><dd><p>Object of class &quot;logical&quot;. Is TRUE if the final DAG structure has twoway logical relationships.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>istwoway</dt><dd><p>(DAGstructure): Indicates whether given DAGstructure has twoway relationships.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Rosa Meijer: <a href="mailto:r.j.meijer@lumc.nl">r.j.meijer@lumc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DAGmethod">DAGmethod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Let us assume we have the following sets that we want to test: 
  sets &lt;- list(c(1,2,3,4), c(1,2), c(2,3,4), c(2,3), 1, 2, 3, 4)
  # The sets need to have names in order to be able to look up their p-values later
  names(sets) &lt;- c(1234, 12, 234, 23, 1, 2, 3, 4)
  
  # Start by making the corresponding graph structure
  struct &lt;- construct(sets)
  
  # Check whether the DAG has toway logical relations: 
  istwoway(struct)
  
</code></pre>

<hr>
<h2 id='hommelFast'>Calculates adjusted p-values of Hommel's method efficiently.</h2><span id='topic+hommelFast'></span>

<h3>Description</h3>

<p>Calculates adjusted p-values of Hommel's method efficiently.</p>


<h3>Usage</h3>

<pre><code class='language-R'> hommelFast (pvalues, simes = TRUE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hommelFast_+3A_pvalues">pvalues</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="hommelFast_+3A_simes">simes</code></td>
<td>
<p>If <code>TRUE</code>, a Simes' test is used, if <code>FALSE</code> Hommel's test is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="hommel.html#topic+hommel">hommel</a></code> object.</p>


<h3>Author(s)</h3>

<p>Rosa Meijer: <a href="mailto:r.j.meijer@lumc.nl">r.j.meijer@lumc.nl</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  #Generate a vector of pvalues
  set.seed(1)
  n &lt;- 1000
  pvalues &lt;- c(runif(0.50*n,0,0.001), runif(0.50*n,0,1))
  
  #Create an hommel object in which the adjusted p-values are stored, based on a Simes'test
  #(or Hommel's test, by choosing simes = FALSE):
  hom &lt;- hommelFast(pvalues, simes = TRUE)
  
  #Retrieve the first 10 adjusted p-values by using the \code{p.adjust} method 
  # from the hommel package. Note that they are not sorted
  hommel::p.adjust(hom)[1:10]

</code></pre>

<hr>
<h2 id='NAEP'>National Assessment of Educational Progress (NAEP) p-values</h2><span id='topic+NAEP'></span>

<h3>Description</h3>

<p>P-values for the null hypothesis of no change in the average eighth-grade mathematics achievement scores for the 34 states that participated in both the 1990 and the 1992 National Assessment of Educational Progress (NAEP) Trial State Assessment.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NAEP)</code></pre>


<h3>Format</h3>

<p>A named numeric vector of p-values, uncorrected for multiple testing.</p>


<h3>References</h3>

<p>Benjamini Y. and Hochberg, Y. 2000. On the adaptive control of the false discovery rate in multiple testing with independent statistics. Journal of Educational and Behavioral Statistics 25 (1) 60-83.
</p>
<p>Williams, V.S.L., Jones, L.V. and Tukey, J.W. 1999. Controlling error in multiple
comparisons, with examples from state-to-state differences in educational achievement. Journal of Educational and Behavioral Statistics 24 (1) 42-69.</p>

<hr>
<h2 id='Pick'>Confidence limits for the number of true hypotheses.</h2><span id='topic+pick'></span>

<h3>Description</h3>

<p>Calculates confidence limits for the number of true hypotheses on the basis of the closed testing procedure.</p>


<h3>Usage</h3>

<pre><code class='language-R'> pick (closure, reject, alpha, silent=FALSE, plot=FALSE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pick_+3A_closure">closure</code></td>
<td>
<p>An object of class <code><a href="#topic+closure">closure</a></code>, typically created through a call to <code><a href="#topic+closed">closed</a></code> .</p>
</td></tr>
<tr><td><code id="Pick_+3A_reject">reject</code></td>
<td>
<p>A character vector identifying the hypotheses to be rejected. Must be a subvector of <code>hypotheses(closure)</code>.</p>
</td></tr>
<tr><td><code id="Pick_+3A_alpha">alpha</code></td>
<td>
<p>For closure objects with adjusted p-values, specifies the value of alpha for which confidence limits are to be calculated (optional).</p>
</td></tr>
<tr><td><code id="Pick_+3A_silent">silent</code></td>
<td>
<p>If <code>FALSE</code>, prints the result to the screen.</p>
</td></tr>
<tr><td><code id="Pick_+3A_plot">plot</code></td>
<td>
<p>Whether a a confidence distribution should be plotted. Only available for closure objects with adjusted p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>pick</code> calculates a confidence interval for the number of true hypotheses among a selected set of hypotheses.</p>


<h3>Value</h3>

<p>The function returns the upper confidence limit for the number of true hypotheses among the set <code>reject</code>. The lower confidence limit is always equal to 0. If <code><a href="#topic+closed">closed</a></code> was called with <code>alpha=NA</code>, a confidence distribution is plotted and returned.</p>


<h3>Author(s)</h3>

<p>Jelle Goeman: <a href="mailto:j.j.goeman@lumc.nl">j.j.goeman@lumc.nl</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Example: the birthwt data set from the MASS library
  # We want to find variables associated with low birth weight
  library(MASS)
  fullfit &lt;- glm(low~age+lwt+race+smoke+ptl+ht+ui+ftv, family=binomial, data=birthwt)
  hypotheses &lt;- c("age", "lwt", "race", "smoke", "ptl", "ht", "ui", "ftv")

  # Define the local test to be used in the closed testing procedure
  mytest &lt;- function(hyps) {
    others &lt;- setdiff(hypotheses, hyps)
    form &lt;- formula(paste(c("low~",  paste(c("1", others), collapse="+"))))
    anov &lt;- anova(glm(form, data=birthwt, family=binomial), fullfit, test="Chisq")
    res &lt;- anov$"Pr("[2]                    # for R &gt;= 2.14.0
    if (is.null(res)) res &lt;- anov$"P("[2]   # earlier versions
    res
  }

  # perform the closed testing
  cl &lt;- closed(mytest, hypotheses)
  summary(cl)

  # how many variables among a chosen set are associated with the response?
  pick(cl, c("ht", "lwt", "smoke", "ui"))
</code></pre>

<hr>
<h2 id='Plot+20region+20objects'>Visualizing of the region hypotheses that could be rejected.</h2><span id='topic+regionplot'></span><span id='topic+regionplot2'></span>

<h3>Description</h3>

<p>Visualizes region objects as created through a call to <code><a href="#topic+regionmethod">regionmethod</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  regionplot (region, alpha, color="red")
  
  regionplot2 (region, alpha, color_rej="red", color_unrej="grey") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot+2B20region+2B20objects_+3A_region">region</code></td>
<td>
<p>An object of class <code><a href="#topic+region">region</a></code>, typically created through a call to <code><a href="#topic+regionmethod">regionmethod</a></code>.</p>
</td></tr>
<tr><td><code id="Plot+2B20region+2B20objects_+3A_alpha">alpha</code></td>
<td>
<p>For region objects with adjusted p-values, specifies the value of alpha for which rejections should be plotted (optional).</p>
</td></tr>
<tr><td><code id="Plot+2B20region+2B20objects_+3A_color">color</code></td>
<td>
<p>Color that is used to indicate rejected region hypotheses.</p>
</td></tr>
<tr><td><code id="Plot+2B20region+2B20objects_+3A_color_rej">color_rej</code></td>
<td>
<p>Color that is used to indicate rejected region hypotheses.</p>
</td></tr>
<tr><td><code id="Plot+2B20region+2B20objects_+3A_color_unrej">color_unrej</code></td>
<td>
<p>Color that is used to indicate unrejected region hypotheses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both plot functions create a graph that visualizes all possible region hypotheses. Each region hypothesis is a node in the graph, and from each region hypothesis two edged connect the hypothesis with its child hypotheses. The <code>regionplot2</code> function visualized the graph with its nodes and edges. This function is especially useful for <code><a href="#topic+region">region</a></code> objects with a limited number of elementary hypotheses. The <code>regionplot</code> function does not display the nodes and edges separately, but draws a polygon that follows the original graph structure. 
</p>


<h3>Author(s)</h3>

<p>Rosa Meijer: <a href="mailto:r.j.meijer@lumc.nl">r.j.meijer@lumc.nl</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate data, where the response Y is associated with certain groups of covariates
#namely cov 3-6, 9-12, 15-18
set.seed(1)
n=100
p=20
X &lt;- matrix(rnorm(n*p),n,p)
beta &lt;- c(rep(0,2),rep(1,4),rep(0,2),rep(1,4),rep(0,2),rep(1,4),rep(0,2))
Y &lt;- X %*% beta + rnorm(n)

# Define the local test to be used in the closed testing procedure
mytest &lt;- function(left,right)
{
  X &lt;- X[,(left:right),drop=FALSE]
  lm.out &lt;- lm(Y ~ X)
  x &lt;- summary(lm.out)
  return(pf(x$fstatistic[1],x$fstatistic[2],x$fstatistic[3],lower.tail=FALSE))  
}

# perform the region procedure
reg &lt;- regionmethod(rep(1,p), mytest, isadjusted=TRUE)
summary(reg)

#what are the smallest regions that are found to be significant? 
implications(reg)

#how many covariates within the full region of length 20 are at least associated with the response?
regionpick(reg, list(c(1,p)), alpha=0.05)

#visualize the results by either plotting a polygon corresponding to the underlying graph
regionplot(reg)

#or by plotting the graph itself
regionplot2(reg)


</code></pre>

<hr>
<h2 id='Region+20class'>Class &quot;region&quot; for storing the result of the region procedure</h2><span id='topic+region'></span><span id='topic+region-class'></span><span id='topic+show+2Cregion-method'></span><span id='topic+summary+2Cregion-method'></span><span id='topic+implications'></span><span id='topic+implications+2Cregion-method'></span><span id='topic+alpha+2Cregion-method'></span><span id='topic+pvalue'></span><span id='topic+pvalue+2Cregion-method'></span>

<h3>Description</h3>

<p>The class region is the output of a call to <code><a href="#topic+regionmethod">regionmethod</a></code>. It stores which region hypotheses have been rejected and can be used to calculate confidence sets for the number of true and/or false hypotheses among a selected region.</p>


<h3>Slots</h3>

<p>These slots are not meant to be directly accessed by the user.
</p>

<dl>
<dt><code>weights</code>:</dt><dd><p>Object of class &quot;numeric&quot;. Stores the weights of elementary hypotheses.</p>
</dd>
<dt><code>isadjusted</code>:</dt><dd><p>Object of class &quot;logical&quot;. Stores whether adjusted p-values are calculated.</p>
</dd>
<dt><code>allpvalues</code>:</dt><dd><p>Object of class &quot;matrix&quot;. Stores (adjusted) p-values for all possible region hypotheses. Has value NA if adjusted p-value is larger than alpha. Corresponds to a 0x0 matrix if <code>all_pvalues</code> is set to FALSE (by default).</p>
</dd>
<dt><code>implications</code>:</dt><dd><p>Object of class &quot;matrix&quot;. Stores implications includinge (adjusted) p-values at chosen alpha-level</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>Object of class &quot;numeric&quot;. The type I error level chosen.</p>
</dd>
<dt><code>totalrejected</code>:</dt><dd><p>Object of class &quot;numeric&quot;. Stores the total number of rejected region hypotheses.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p>(region): Prints how many region hypotheses were tested and how many of them were rejected.</p>
</dd>
<dt>summary</dt><dd><p>(region): Prints the test results (as <code>show</code>).</p>
</dd>
<dt>alpha</dt><dd><p>(region): Retrieves the maximal alpha_value from the region object.</p>
</dd>
<dt>implications</dt><dd><p>(region,alpha): Retrieves the implications from a given region object. By default, the alpha-level is set to <code>alpha_max</code>, but the alpha level can be varied, if the supporting information is present in the region object.</p>
</dd>
<dt>pvalue</dt><dd><p>(region,left,right): Retrieves pvalues for all possible region hypotheses (indicated with left and right bound) from the region object. Only able to return the value if the allpvalues matrix is stored in the region object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Rosa Meijer: <a href="mailto:r.j.meijer@lumc.nl">r.j.meijer@lumc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+regionmethod">regionmethod</a></code>, <code><a href="#topic+regionpick">regionpick</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data, where the response Y is associated with certain groups of covariates
#namely cov 3-6, 9-12, 15-18
set.seed(1)
n=100
p=20
X &lt;- matrix(rnorm(n*p),n,p)
beta &lt;- c(rep(0,2),rep(1,4),rep(0,2),rep(1,4),rep(0,2),rep(1,4),rep(0,2))
Y &lt;- X %*% beta + rnorm(n)

# Define the local test to be used in the closed testing procedure
mytest &lt;- function(left,right)
{
  X &lt;- X[,(left:right),drop=FALSE]
  lm.out &lt;- lm(Y ~ X)
  x &lt;- summary(lm.out)
  return(pf(x$fstatistic[1],x$fstatistic[2],x$fstatistic[3],lower.tail=FALSE))  
}

# perform the region procedure
reg &lt;- regionmethod(rep(1,p), mytest, isadjusted=TRUE, all_pvalues=TRUE)
summary(reg)

#what are the smallest regions that are found to be significant? 
implications(reg)

#what are the smallest regions that are found to be significant at an alpha-level of 0.03? 
implications(reg, alpha=0.03)

#what is the adjusted p-value of the overall null-hypothesis 
#(corresponding to the region ranging from 1 to 20)?
pvalue(reg,1,20)

#how many covariates within the full region of length 20 are at least associated with the response?
regionpick(reg, list(c(1,p)), alpha=0.05)

#visualize the results by either plotting a polygon corresponding to the underlying graph
regionplot(reg)

#or by plotting the graph itself
regionplot2(reg)
</code></pre>

<hr>
<h2 id='Region+20Testing'>Testing of all possible region hypotheses</h2><span id='topic+regionmethod'></span>

<h3>Description</h3>

<p>Tests all possible region hypotheses in a given region while controlling the FWER, using a user-specified local test.</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
regionmethod (weights, test, alpha_max = 0.05, all_pvalues = FALSE, 
              isadjusted = FALSE, verbose = FALSE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Region+2B20Testing_+3A_weights">weights</code></td>
<td>
<p>a vector that indicates the weight each elementary hypotheses should receive in the multiple testing procedure. The length of the vector should equal the number of elementary hypotheses. All values should be strictly positive.</p>
</td></tr>
<tr><td><code id="Region+2B20Testing_+3A_test">test</code></td>
<td>
<p>A function that performs the local test. The function should have the left and rightbound of the region as input (as two separate numbers), and return a p-value.</p>
</td></tr>
<tr><td><code id="Region+2B20Testing_+3A_alpha_max">alpha_max</code></td>
<td>
<p>The significance level of the test procedure.</p>
</td></tr>
<tr><td><code id="Region+2B20Testing_+3A_all_pvalues">all_pvalues</code></td>
<td>
<p>If set to TRUE, the procedure will return a matrix with the p-values of all tested region hypotheses. If set to FALSE, only the p-values of the implications will be returned.</p>
</td></tr>
<tr><td><code id="Region+2B20Testing_+3A_isadjusted">isadjusted</code></td>
<td>
<p>If set to TRUE, adjusted p-values will be calculated. Otherwise, the p-values of all rejected hypotheses will equal alpha_max.</p>
</td></tr>
<tr><td><code id="Region+2B20Testing_+3A_verbose">verbose</code></td>
<td>
<p>If set to TRUE, while running the method, a counter will indicate how many region hypotheses are already rejected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>regionmethod</code> tests all possible region hypotheses within one main interval, while controlling the familywise error rate.</p>


<h3>Value</h3>

<p>The function <code>regionmethod</code> returns an object of class <code><a href="#topic+region">region</a></code>.</p>


<h3>Note</h3>

<p>The number of region hypotheses is quadratic in the number of elementary hypotheses. The number of elementary hypotheses should for computational reasons not be too large. For values in between 1000 and 10.000 the region procedure can still be used, but one might consider calculating the individual raw p-values beforehand.
</p>
<p>If both <code>isadjusted</code> and <code>all_pvalues</code> are set to TRUE, afterwards implications can be obtained for all alpha-values smaller or equal to <code>alpha_max</code>.</p>


<h3>Author(s)</h3>

<p>Rosa Meijer: <a href="mailto:r.j.meijer@lumc.nl">r.j.meijer@lumc.nl</a></p>


<h3>References</h3>

<p>Meijer, Krebs and Goeman (2015) Statistical Applications in Genetics and Molecular Biology 14 (1) 1-19.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
#generate data, where the response Y is associated with certain groups of covariates
#namely cov 3-6, 9-12, 15-18
set.seed(1)
n=100
p=20
X &lt;- matrix(rnorm(n*p),n,p)
beta &lt;- c(rep(0,2),rep(1,4),rep(0,2),rep(1,4),rep(0,2),rep(1,4),rep(0,2))
Y &lt;- X %*% beta + rnorm(n)

# Define the local test to be used in the closed testing procedure
mytest &lt;- function(left,right)
{
  X &lt;- X[,(left:right),drop=FALSE]
  lm.out &lt;- lm(Y ~ X)
  x &lt;- summary(lm.out)
  return(pf(x$fstatistic[1],x$fstatistic[2],x$fstatistic[3],lower.tail=FALSE))  
}

# perform the region procedure
reg &lt;- regionmethod(rep(1,p), mytest, isadjusted=TRUE)
summary(reg)

#what are the smallest regions that are found to be significant? 
implications(reg)

#at least how many covariates within the full region of length 20 
#are associated with the response?
regionpick(reg, list(c(1,p)), alpha=0.05)

#visualize the results by either plotting a polygon corresponding to the underlying graph
regionplot(reg)

#or by plotting the graph itself
regionplot2(reg)

</code></pre>

<hr>
<h2 id='regionpick'>Confidence limits for the number of false hypotheses in a given region.</h2><span id='topic+regionpick'></span>

<h3>Description</h3>

<p>Calculates confidence limits for the number of false hypotheses on the basis of the region procedure within one or more regions.</p>


<h3>Usage</h3>

<pre><code class='language-R'> regionpick (region, intervals, alpha, silent = FALSE, ignore_weights = TRUE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regionpick_+3A_region">region</code></td>
<td>
<p>An object of class <code><a href="#topic+region">region</a></code>, typically created through a call to <code><a href="#topic+regionmethod">regionmethod</a></code>.</p>
</td></tr>
<tr><td><code id="regionpick_+3A_intervals">intervals</code></td>
<td>
<p>A list containing one or more regions, specified by a left and rightbound.</p>
</td></tr>
<tr><td><code id="regionpick_+3A_alpha">alpha</code></td>
<td>
<p>For region objects with adjusted p-values, specifies the value of alpha for which confidence limits are to be calculated (optional).</p>
</td></tr>
<tr><td><code id="regionpick_+3A_silent">silent</code></td>
<td>
<p>If <code>FALSE</code>, prints the result to the screen.</p>
</td></tr>
<tr><td><code id="regionpick_+3A_ignore_weights">ignore_weights</code></td>
<td>
<p>If set to TRUE, a confidence interval for the number of false elementary hypotheses will be computed. If set to FALSE, a confidence interval for the combined weight of false elemenatary hypotheses will be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>regionpick</code> calculates a confidence interval for the number (or weight) of false hypotheses among a selected set of elementary hypotheses.</p>


<h3>Value</h3>

<p>The function returns the lower confidence limit for the number of false hypotheses (i.e. true findings) among the set of elementary hypotheses as specified by <code>intervals</code>. The upper confidence limit is always equal to the size of the set.</p>


<h3>Author(s)</h3>

<p>Rosa Meijer: <a href="mailto:r.j.meijer@lumc.nl">r.j.meijer@lumc.nl</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate data, where the response Y is associated with certain groups of covariates
#namely cov 3-6, 9-12, 15-18
set.seed(1)
n=100
p=20
X &lt;- matrix(rnorm(n*p),n,p)
beta &lt;- c(rep(0,2),rep(1,4),rep(0,2),rep(1,4),rep(0,2),rep(1,4),rep(0,2))
Y &lt;- X %*% beta + rnorm(n)

# Define the local test to be used in the closed testing procedure
mytest &lt;- function(left,right)
{
  X &lt;- X[,(left:right),drop=FALSE]
  lm.out &lt;- lm(Y ~ X)
  x &lt;- summary(lm.out)
  return(pf(x$fstatistic[1],x$fstatistic[2],x$fstatistic[3],lower.tail=FALSE))  
}

# perform the region procedure
reg &lt;- regionmethod(rep(1,p), mytest, isadjusted=TRUE)
summary(reg)

#what are the smallest regions that are found to be significant? 
implications(reg)

#how many covariates within the full region of length 20 are at least associated with the response?
regionpick(reg, list(c(1,p)), alpha=0.05)

#how many covariates within the two subregions, (1,5) and (16,20) 
#are at least associated with the response?
regionpick(reg, list(c(1,5),c(16,20)))

</code></pre>

<hr>
<h2 id='Select+20with+20shortcuts'>Confidence limits for the number of true hypotheses, with shortcuts.</h2><span id='topic+pickFisher'></span><span id='topic+pickSimes'></span><span id='topic+pickMeinshausen'></span><span id='topic+curveFisher'></span><span id='topic+curveSimes'></span><span id='topic+curveMeinshausen'></span>

<h3>Description</h3>

<p>Calculates confidence limits for the number of true hypotheses on the basis of the closed testing procedure using specific local tests that allow shortcuts.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pickFisher (p, select = seq_along(p), alpha=0.05, silent=FALSE)

curveFisher (p, select = seq_along(p), order, alpha=0.05, plot = TRUE)

pickSimes (hommel, select, alpha=0.05, silent=FALSE)

curveSimes (hommel, select, order, alpha=0.05, plot = TRUE)

pickMeinshausen (p, PM, select = seq_along(p), alpha=0.05, silent=FALSE)

curveMeinshausen (p, PM, select = seq_along(p), order, alpha=0.05, plot = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Select+2B20with+2B20shortcuts_+3A_p">p</code></td>
<td>
<p>The vector of p-values for all tested hypotheses.</p>
</td></tr>
<tr><td><code id="Select+2B20with+2B20shortcuts_+3A_hommel">hommel</code></td>
<td>
<p>The hommel object, obtained from the hommelFast function.</p>
</td></tr>
<tr><td><code id="Select+2B20with+2B20shortcuts_+3A_pm">PM</code></td>
<td>
<p>A matrix of permutation p-values. Rows are hypotheses; columns are permutations.</p>
</td></tr>
<tr><td><code id="Select+2B20with+2B20shortcuts_+3A_select">select</code></td>
<td>
<p>The indexing vector of the p-values of the hypotheses to be selected. May be any type of appropriate indexing vector (integers, logical, or character).</p>
</td></tr>
<tr><td><code id="Select+2B20with+2B20shortcuts_+3A_order">order</code></td>
<td>
<p>The indexing vector specifying the order in which p-values of the hypotheses are to be rejected. May be integer or character.</p>
</td></tr>
<tr><td><code id="Select+2B20with+2B20shortcuts_+3A_alpha">alpha</code></td>
<td>
<p>The significance level of the test procedure.</p>
</td></tr>
<tr><td><code id="Select+2B20with+2B20shortcuts_+3A_silent">silent</code></td>
<td>
<p>If <code>FALSE</code>, prints verbose result to the screen.</p>
</td></tr>
<tr><td><code id="Select+2B20with+2B20shortcuts_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code>, plots the curve of correct rejections versus total rejections.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results of the <code>pickFisher</code>, <code>pickSimes</code> and <code>pickMeinshausen</code> functions are identical to applying <code><a href="#topic+closed">closed</a></code> and <code><a href="#topic+pick">pick</a></code>, for specific choices of the local test, but are computationally more efficient. <code>pickFisher</code> uses local tests based on Fisher combinations. This local test is only valid if p-values of true hypotheses are independent. <code>pickSimes</code> uses a local test based on Simes' inequality. It is valid if p-values of true hypotheses are independent but also under some forms of positive correlations. The Hommel variant of the Simes local test is valid under any dependence structure of the p-values. <code>pickMeinshausen</code> is a permutation-based variant of <code>pickSimes</code>. See the reference below.
</p>
<p>In the curve functions, the user may specify either <code>select</code> or <code>order</code>. Specifying <code>order</code> fixes the precise order in which hypotheses are selected, whereas specifying <code>select</code> only specifies which hypotheses are candidates for selection, leaving the order to be chosen by the function to maximize the number of correct rejections.</p>


<h3>Value</h3>

<p>For <code>pickFisher</code>, <code>pickSimes</code> and <code>pickMeinshausen</code>, the function returns the lower confidence limit for the number of false hypotheses (correct rejection) among the set <code>reject</code>. The upper confidence limit is always equal to the number of rejections made. <code>curveFisher</code> and <code>curveSimes</code> return the same confidence limit, but for selecting only the first 1,2,3,... hypotheses from the selected set.</p>


<h3>Author(s)</h3>

<p>Jelle Goeman: <a href="mailto:j.j.goeman@lumc.nl">j.j.goeman@lumc.nl</a>; Aldo Solari</p>


<h3>References</h3>

<p>Goeman and Solari (2011) Statistical Science 26 (4) 584-597.
</p>
<p>Meinshausen (2006) Scandinavian Journal of Statistics 33 (2), 227-237.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Fisher's method
  data(NAEP)
  pickFisher(NAEP, c("NH", "NC", "IA"))
  pickFisher(NAEP, 1:7)
  curveFisher(NAEP)
  curveFisher(NAEP, order=7:1)


  # Simes method
  hom &lt;- hommelFast(NAEP)
  pickSimes(hom, c("NH", "NC", "IA"))
  pickSimes(hom, 1:7)
  curveSimes(hom)
  curveSimes(hom, select=1:7)
  
  # Meinshausen's method
  # This example uses data from the multtest package on bioconductor
  if(require("multtest")) {
    data(golub)
    smallglb &lt;- golub[1:500,]
    TM&lt;-sapply(1:nrow(smallglb), function(i) {
      mt.sample.teststat(smallglb[i,], golub.cl,test="t.equalvar",B=500)
    })
    PM&lt;-2*(1-pt(abs(TM),df=length(golub.cl)-2)) # permutation matrix
    
    # p-values
    p&lt;-apply(smallglb,1, function(z) t.test(z[golub.cl==0],z[golub.cl==1],var.equal=TRUE)$p.value) 
    
    pickMeinshausen(p, PM, select=1:100)
    pickMeinshausen(p, PM, select=sort.list(p)[1:100])
    curveMeinshausen(p,PM, select=1:200)
    curveMeinshausen(p,PM, order=1:200)
    
  }
</code></pre>

<hr>
<h2 id='structured+20Holm'>Testing of hypotheses, forming a DAG, by using a variant of Holm's method.</h2><span id='topic+structuredHolm'></span>

<h3>Description</h3>

<p>Tests all hypotheses in a given DAG while controlling the FWER, using a user-specified local test.</p>


<h3>Usage</h3>

<pre><code class='language-R'> structuredHolm (DAGstructure, test, alpha_max = 0.05, isadjusted = FALSE, 
optimization = "none", pvalues = NULL, verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="structured+2B20Holm_+3A_dagstructure">DAGstructure</code></td>
<td>
<p>DAGstructure object, as returned by the function <code>construct</code>.</p>
</td></tr>
<tr><td><code id="structured+2B20Holm_+3A_test">test</code></td>
<td>
<p>A function that performs the local test. The function should have a set as input and return a p-value.</p>
</td></tr>
<tr><td><code id="structured+2B20Holm_+3A_alpha_max">alpha_max</code></td>
<td>
<p>The significance level of the test procedure.</p>
</td></tr>
<tr><td><code id="structured+2B20Holm_+3A_isadjusted">isadjusted</code></td>
<td>
<p>If set to TRUE, adjusted p-values will be calculated. Otherwise, the p-values of all rejected hypotheses will equal alpha_max.</p>
</td></tr>
<tr><td><code id="structured+2B20Holm_+3A_optimization">optimization</code></td>
<td>
<p>Can be, in ascending order of accuracy and computational costs: &quot;none&quot;, &quot;LP&quot; (linear programming) or &quot;ILP&quot; (integer linear programming).</p>
</td></tr>
<tr><td><code id="structured+2B20Holm_+3A_pvalues">pvalues</code></td>
<td>
<p>Optional (in case of stored p-values): a vector in which the raw p-values of the exact sets as found in the DAGstructure argument are stored (in the same order). If the test function is provided, this argument is not necessary.</p>
</td></tr>
<tr><td><code id="structured+2B20Holm_+3A_verbose">verbose</code></td>
<td>
<p>If set to TRUE, while running the method, a counter will indicate how many hypotheses are already rejected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>structuredHolm</code> tests all possible hypotheses within a given DAG structure, while controlling the familywise error rate.</p>


<h3>Value</h3>

<p>The function <code>structuredHolm</code> returns an object of class <code><a href="#topic+DAG">DAG</a></code>.</p>


<h3>Author(s)</h3>

<p>Rosa Meijer: <a href="mailto:r.j.meijer@lumc.nl">r.j.meijer@lumc.nl</a></p>


<h3>References</h3>

<p>Meijer and Goeman (2015) Briefings in Bioinformatics, submitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DAG">DAG</a></code>, <code><a href="#topic+DAGstructure">DAGstructure</a></code>, <code><a href="#topic+construct">construct</a></code>, <code><a href="#topic+DAGpick">DAGpick</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  #Generate data, where the response Y is associated with two (out of 4) covariates
  set.seed(1)
  n=100
  p=4
  X &lt;- matrix(rnorm(n*p),n,p)
  beta &lt;- c(0,0.5,0.5,0)
  Y &lt;- X %*% beta + rnorm(n)

  # Let us assume we have the following sets that we want to test: 
  sets &lt;- list(c(1,2,3,4), c(1,2), c(2,3,4), c(2,3), 1, 2, 3, 4)
  names(sets) &lt;- c(1234, 12, 234, 23, 1, 2, 3, 4)

  # Start by making the corresponding graph structure
  struct &lt;- construct(sets)
  
  # Check whether the DAG has toway logical relations: 
  istwoway(struct)
  
  # Define the local test to be used in the closed testing procedure. 
  # This test expects a set as input. 
  mytest &lt;- function(set)
  { 
    X &lt;- X[,set,drop=FALSE]
    lm.out &lt;- lm(Y ~ X)
    x &lt;- summary(lm.out)
    return(pf(x$fstatistic[1],x$fstatistic[2],x$fstatistic[3],lower.tail=FALSE))  
  }

  # Perform the structuredHolm procedure.
  DAG &lt;- structuredHolm(struct, mytest, isadjusted=TRUE)
  summary(DAG)
  
  # What are the smallest sets that are found to be significant? 
  implications(DAG)
  
  # What is the adjusted p-value of the null-hypothesis corresponding to the fourth set, 
  # which is set c(2,3)? 
  # To look up the pvalue, the function uses the index or name of the set 
  # in the list of sets stored in the DAGstructure. 
  # (Note that, if there were duplicate sets in the original list, this index can be different from 
  # the one in the original list given to \code{construct})
  pvalue(DAG,4)
  pvalue(DAG, "23") #as above, but while using names
  
  # How many of the elementary hypotheses (the last 4 sets) have to be false 
  # with probability 1-alpha? 
  # Sets (don't have to be elementary hypotheses in general) must be specified 
  # by their index or name. 
  DAGpick(DAG, 5:8)
  DAGpick(DAG, c("1","2","3","4")) #as above, but while using names
  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
