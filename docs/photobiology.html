<!DOCTYPE html><html><head><title>Help for package photobiology</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {photobiology}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#^.generic_spct'><p>Arithmetic Operators</p></a></li>
<li><a href='#A.illuminant.spct'><p>CIE A illuminant data</p></a></li>
<li><a href='#A2T'><p>Convert absorbance into transmittance</p></a></li>
<li><a href='#absorbance'><p>Absorbance</p></a></li>
<li><a href='#absorbance_spct'><p>Calculate absorbance from spectral absorbance.</p></a></li>
<li><a href='#absorptance'><p>Absorptance</p></a></li>
<li><a href='#absorptance_spct'><p>Calculate absorptance from spectral absorptance.</p></a></li>
<li><a href='#adaptive_smoothing'><p>Custom smoothing</p></a></li>
<li><a href='#add_attr2tb'><p>Copy attributes from members of a generic_mspct</p></a></li>
<li><a href='#Afr2T'><p>Convert transmittance into absorptance.</p></a></li>
<li><a href='#any2T'><p>Convert filter quantities.</p></a></li>
<li><a href='#as_energy'><p>Convert spectral photon irradiance into spectral energy irradiance</p></a></li>
<li><a href='#as_quantum'><p>Convert spectral energy irradiance into spectral photon irradiance</p></a></li>
<li><a href='#as_quantum_mol'><p>Convert spectral energy irradiance into spectral photon irradiance</p></a></li>
<li><a href='#as_tod'><p>Convert datetime to time-of-day</p></a></li>
<li><a href='#as.calibration_mspct'><p>Coerce to a collection-of-spectra</p></a></li>
<li><a href='#as.calibration_spct'><p>Coerce to a spectrum</p></a></li>
<li><a href='#as.chroma_mspct'><p>Coerce to a collection-of-spectra</p></a></li>
<li><a href='#as.chroma_spct'><p>Coerce to a spectrum</p></a></li>
<li><a href='#as.cps_mspct'><p>Coerce to a collection-of-spectra</p></a></li>
<li><a href='#as.cps_spct'><p>Coerce to a spectrum</p></a></li>
<li><a href='#as.filter_mspct'><p>Coerce to a collection-of-spectra</p></a></li>
<li><a href='#as.filter_spct'><p>Coerce or convert into a filter spectrum</p></a></li>
<li><a href='#as.generic_mspct'><p>Coerce to a collection-of-spectra</p></a></li>
<li><a href='#as.generic_spct'><p>Coerce to a spectrum</p></a></li>
<li><a href='#as.matrix-mspct'><p>Coerce a collection of spectra into a matrix</p></a></li>
<li><a href='#as.object_mspct'><p>Coerce to a collection-of-spectra</p></a></li>
<li><a href='#as.object_spct'><p>Coerce to a spectrum</p></a></li>
<li><a href='#as.raw_mspct'><p>Coerce to a collection-of-spectra</p></a></li>
<li><a href='#as.raw_spct'><p>Coerce to a spectrum</p></a></li>
<li><a href='#as.reflector_mspct'><p>Coerce to a collection-of-spectra</p></a></li>
<li><a href='#as.reflector_spct'><p>Coerce to a spectrum</p></a></li>
<li><a href='#as.response_mspct'><p>Coerce to a collection-of-spectra</p></a></li>
<li><a href='#as.response_spct'><p>Coerce to a spectrum</p></a></li>
<li><a href='#as.solar_date'><p>Convert a solar_time object into solar_date object</p></a></li>
<li><a href='#as.solute_mspct'><p>Coerce to a collection-of-spectra</p></a></li>
<li><a href='#as.solute_spct'><p>Coerce to a solute spectrum</p></a></li>
<li><a href='#as.source_mspct'><p>Coerce to a collection-of-spectra</p></a></li>
<li><a href='#as.source_spct'><p>Coerce to a spectrum</p></a></li>
<li><a href='#auto_hinges'><p>Guess whether insertion of hinges is needed or not</p></a></li>
<li><a href='#average_spct'><p>Average spectral data.</p></a></li>
<li><a href='#beesxyzCMF.spct'><p>Honeybee xyz chromaticity colour matching function data</p></a></li>
<li><a href='#black_body.spct'><p>Theoretical optical bodies</p></a></li>
<li><a href='#c'><p>Combine collections of spectra</p></a></li>
<li><a href='#calc_multipliers'><p>Spectral weights</p></a></li>
<li><a href='#calc_source_output'><p>Scaled and/or interpolated light-source spectral output</p></a></li>
<li><a href='#calendar_change'><p>Solar astronomy using Meeus' algorithm</p></a></li>
<li><a href='#ccd.spct'><p>Spectral response of a back-thinned CCD image sensor.</p></a></li>
<li><a href='#check_and_rename_vars'><p>check and rename variables</p></a></li>
<li><a href='#check_spct'><p>Check validity of spectral objects</p></a></li>
<li><a href='#check_spectrum'><p>Sanity check a spectrum</p></a></li>
<li><a href='#check_w.length'><p>Sanity check of wavelengths (internal function).</p></a></li>
<li><a href='#checkMspctVersion'><p>Check that the &quot;mspct.version&quot; attribute is set</p></a></li>
<li><a href='#checkSpctVersion'><p>Check that the &quot;spct.version&quot; attribute is set</p></a></li>
<li><a href='#checkTimeUnit'><p>Check the &quot;time.unit&quot; attribute of an existing source_spct object</p></a></li>
<li><a href='#ciev10.spct'><p>Linear energy CIE 2008 luminous efficiency function 10 deg data</p></a></li>
<li><a href='#ciev2.spct'><p>Linear energy CIE 2008 luminous efficiency function 2 deg data</p></a></li>
<li><a href='#ciexyzCC10.spct'><p>CIE xyz chromaticity coordinates (CC) 10 deg data</p></a></li>
<li><a href='#ciexyzCC2.spct'><p>CIE xyz chromaticity coordinates 2 deg data</p></a></li>
<li><a href='#ciexyzCMF10.spct'><p>Linear energy CIE xyz colour matching function (CMF) 10 deg data</p></a></li>
<li><a href='#ciexyzCMF2.spct'><p>Linear energy CIE xyz colour matching function (CMF) 2 deg data</p></a></li>
<li><a href='#class_spct'><p>Query which is the class of a spectrum</p></a></li>
<li><a href='#clean'><p>Clean (=replace) off-range values in a spectrum</p></a></li>
<li><a href='#clean_spct'><p>Clean a spectrum</p></a></li>
<li><a href='#clear_photobio.cache'><p>Clear the spectral weights cache</p></a></li>
<li><a href='#clear.spct'><p>Theoretical spectrum of clear and apaque materials</p></a></li>
<li><a href='#clip_wl'><p>Clip head and/or tail of a spectrum</p></a></li>
<li><a href='#collect2mspct'><p>Form a new collection</p></a></li>
<li><a href='#color_of'><p>Color of an object</p></a></li>
<li><a href='#compare_spct'><p>Coarse-grained comparison of two spectra</p></a></li>
<li><a href='#cone_fundamentals10.spct'><p>Ten-degree cone fundaamentals</p></a></li>
<li><a href='#convertTfrType'><p>Convert the &quot;Tfr.type&quot; attribute</p></a></li>
<li><a href='#convertThickness'><p>Convert the &quot;thickness&quot; attribute of an existing filter_spct object.</p></a></li>
<li><a href='#convertTimeUnit'><p>Convert the &quot;time.unit&quot; attribute of an existing source_spct object</p></a></li>
<li><a href='#convolve_each'><p>Convolve function for collections of spectra</p></a></li>
<li><a href='#copy_attributes'><p>Copy attributes</p></a></li>
<li><a href='#cps2irrad'><p>Conversion from counts per second to physical quantities</p></a></li>
<li><a href='#D2_spectrum'><p>Calculate deuterium lamp output spectrum from fitted constants</p></a></li>
<li><a href='#D2.UV653'><p>Data for typical calibration lamps</p></a></li>
<li><a href='#D65.illuminant.spct'><p>CIE D65 illuminant data</p></a></li>
<li><a href='#day_night'><p>Times for sun positions</p></a></li>
<li><a href='#defunct'><p>Defunct functions and methods</p></a></li>
<li><a href='#despike'><p>Remove spikes from spectrum</p></a></li>
<li><a href='#diffraction_single_slit'><p>Diffraction</p></a></li>
<li><a href='#dim.generic_mspct'><p>Dimensions of an Object</p></a></li>
<li><a href='#div_spectra'><p>Divide two spectra, even if the wavelengths values differ</p></a></li>
<li><a href='#div-.generic_spct'><p>Arithmetic Operators</p></a></li>
<li><a href='#drop_user_cols'><p>Drop user columns</p></a></li>
<li><a href='#e_fluence'><p>Energy fluence</p></a></li>
<li><a href='#e_fraction'><p>Energy:energy fraction</p></a></li>
<li><a href='#e_irrad'><p>Energy irradiance</p></a></li>
<li><a href='#e_ratio'><p>Energy:energy ratio</p></a></li>
<li><a href='#e_response'><p>Energy-based photo-response</p></a></li>
<li><a href='#e2q'><p>Convert energy-based quantities into photon-based quantities.</p></a></li>
<li><a href='#e2qmol_multipliers'><p>Calculate energy to quantum (mol) multipliers</p></a></li>
<li><a href='#e2quantum_multipliers'><p>Calculate energy to quantum multipliers</p></a></li>
<li><a href='#enable_check_spct'><p>Enable or disable checks</p></a></li>
<li><a href='#energy_as_default'><p>Set spectral-data options</p></a></li>
<li><a href='#energy_irradiance'><p>Calculate (energy) irradiance from spectral irradiance</p></a></li>
<li><a href='#energy_ratio'><p>Energy:energy ratio</p></a></li>
<li><a href='#eq_ratio'><p>Energy:photon ratio</p></a></li>
<li><a href='#ET_ref'><p>Evapotranspiration</p></a></li>
<li><a href='#Extract'><p>Extract or replace parts of a spectrum</p></a></li>
<li><a href='#Extract_mspct'><p>Extract or replace members of a collection of spectra</p></a></li>
<li><a href='#f_dispatcher_spct'><p>Math function dispatcher for spectra</p></a></li>
<li><a href='#FEL_spectrum'><p>Incandescent &quot;FEL&quot; lamp emission spectrum</p></a></li>
<li><a href='#filter_cps.mspct'><p>Counts per second from a measurement of a plastic film</p></a></li>
<li><a href='#find_peaks'><p>Find peaks in a spectrum</p></a></li>
<li><a href='#find_spikes'><p>Find spikes</p></a></li>
<li><a href='#find_wls'><p>Find wavelength values in a spectrum</p></a></li>
<li><a href='#findMultipleWl'><p>Find repeated w.length values</p></a></li>
<li><a href='#fit_peaks'><p>Refine position and value of extremes by fitting</p></a></li>
<li><a href='#fluence'><p>Fluence</p></a></li>
<li><a href='#format.solar_time'><p>Encode in a Common Format</p></a></li>
<li><a href='#format.tod_time'><p>Encode in a Common Format</p></a></li>
<li><a href='#formatted_range'><p>Compute range and format it</p></a></li>
<li><a href='#fscale'><p>Rescale a spectrum using a summary function</p></a></li>
<li><a href='#fscale_spct'><p>fscale a spectrum</p></a></li>
<li><a href='#fshift'><p>Shift the scale of a spectrum using a summary function</p></a></li>
<li><a href='#fshift_spct'><p>fshift a spectrum</p></a></li>
<li><a href='#generic_mspct'><p>Collection-of-spectra constructor</p></a></li>
<li><a href='#get_attributes'><p>Get the metadata attributes</p></a></li>
<li><a href='#get_peaks'><p>Get peaks and valleys in a spectrum</p></a></li>
<li><a href='#getFilterProperties'><p>Get the &quot;filter.properties&quot; attribute</p></a></li>
<li><a href='#getHowMeasured'><p>Get the &quot;how.measured&quot; attribute</p></a></li>
<li><a href='#getIdFactor'><p>Get the &quot;idfactor&quot; attribute</p></a></li>
<li><a href='#getInstrDesc'><p>Get the &quot;instr.desc&quot; attribute</p></a></li>
<li><a href='#getInstrSettings'><p>Get the &quot;instr.settings&quot; attribute</p></a></li>
<li><a href='#getKType'><p>Get the &quot;K.type&quot; attribute</p></a></li>
<li><a href='#getMspctVersion'><p>Get the &quot;mspct.version&quot; attribute</p></a></li>
<li><a href='#getMultipleWl'><p>Get the &quot;multiple.wl&quot; attribute</p></a></li>
<li><a href='#getNormalized'><p>Query the &quot;normalized&quot; and &quot;normalization&quot; attributes</p></a></li>
<li><a href='#getScaled'><p>Get the &quot;scaled&quot; attribute</p></a></li>
<li><a href='#getSoluteProperties'><p>Get the &quot;solute.properties&quot; attribute</p></a></li>
<li><a href='#getSpctVersion'><p>Get the &quot;spct.version&quot; attribute</p></a></li>
<li><a href='#getTimeUnit'><p>Get the &quot;time.unit&quot; attribute of an existing source_spct object</p></a></li>
<li><a href='#getWhatMeasured'><p>Get the &quot;what.measured&quot; attribute</p></a></li>
<li><a href='#getWhenMeasured'><p>Get the &quot;when.measured&quot; attribute</p></a></li>
<li><a href='#getWhereMeasured'><p>Get the &quot;where.measured&quot; attribute</p></a></li>
<li><a href='#green_leaf.spct'><p>Green birch leaf reflectance.</p></a></li>
<li><a href='#head_tail'><p>Return the First and Last Parts of an Object</p></a></li>
<li><a href='#illuminance'><p>Irradiance</p></a></li>
<li><a href='#insert_hinges'><p>Insert wavelength values into spectral data.</p></a></li>
<li><a href='#insert_spct_hinges'><p>Insert new wavelength values into a spectrum</p></a></li>
<li><a href='#integrate_spct'><p>Integrate spectral data.</p></a></li>
<li><a href='#integrate_xy'><p>Gives irradiance from spectral irradiance.</p></a></li>
<li><a href='#interpolate_spct'><p>Map a spectrum to new wavelength values.</p></a></li>
<li><a href='#interpolate_spectrum'><p>Calculate spectral values at a different set of wavelengths</p></a></li>
<li><a href='#interpolate_wl'><p>Map spectra to new wavelength values.</p></a></li>
<li><a href='#irrad'><p>Irradiance</p></a></li>
<li><a href='#irrad_extraterrestrial'><p>Extraterrestrial irradiance</p></a></li>
<li><a href='#irradiance'><p>Photon or energy irradiance from spectral energy or photon irradiance.</p></a></li>
<li><a href='#is_absorbance_based'><p>Query if a spectrum contains absorbance or transmittance data</p></a></li>
<li><a href='#is_effective'><p>Is an R object &quot;effective&quot;</p></a></li>
<li><a href='#is_mole_based'><p>Query if a spectrum contains mole or mass based data</p></a></li>
<li><a href='#is_normalized'><p>Query whether a generic spectrum has been normalized.</p></a></li>
<li><a href='#is_photon_based'><p>Query if a spectrum contains photon- or energy-based data.</p></a></li>
<li><a href='#is_scaled'><p>Query whether a generic spectrum has been scaled</p></a></li>
<li><a href='#is_tagged'><p>Query if a spectrum is tagged</p></a></li>
<li><a href='#is.generic_mspct'><p>Query class of spectrum objects</p></a></li>
<li><a href='#is.generic_spct'><p>Query class of spectrum objects</p></a></li>
<li><a href='#is.old_spct'><p>Query if an object has old class names</p></a></li>
<li><a href='#is.solar_time'><p>Query class</p></a></li>
<li><a href='#is.summary_generic_spct'><p>Query class of spectrum summary objects</p></a></li>
<li><a href='#is.waveband'><p>Query if it is a waveband</p></a></li>
<li><a href='#isValidInstrDesc'><p>Check the &quot;instr.desc&quot; attribute</p></a></li>
<li><a href='#isValidInstrSettings'><p>Check the &quot;instr.settings&quot; attribute</p></a></li>
<li><a href='#join_mspct'><p>Join all spectra in a collection</p></a></li>
<li><a href='#l_insert_hinges'><p>Insert wavelength values into spectral data.</p></a></li>
<li><a href='#labels'><p>Find labels from &quot;waveband&quot; object</p></a></li>
<li><a href='#Ler_leaf.spct'><p>Green Arabidopsis leaf reflectance and transmittance.</p></a></li>
<li><a href='#log'><p>Logarithms and Exponentials</p></a></li>
<li><a href='#make_wl_consistent'><p>Make wavelengths consistent</p></a></li>
<li><a href='#MathFun'><p>Miscellaneous Mathematical Functions</p></a></li>
<li><a href='#merge_attributes'><p>Merge and copy attributes</p></a></li>
<li><a href='#merge2object_spct'><p>Merge into object_spct</p></a></li>
<li><a href='#minus-.generic_spct'><p>Arithmetic Operators</p></a></li>
<li><a href='#mod-.generic_spct'><p>Arithmetic Operators</p></a></li>
<li><a href='#msmsply'><p>Multi-spct transform methods</p></a></li>
<li><a href='#mspct_classes'><p>Names of multi-spectra classes</p></a></li>
<li><a href='#na.omit'><p>Handle Missing Values in Objects</p></a></li>
<li><a href='#net_irradiance'><p>Net radiation flux</p></a></li>
<li><a href='#normalization'><p>Normalization of an R object</p></a></li>
<li><a href='#normalize'><p>Normalize spectral data</p></a></li>
<li><a href='#normalize_range_arg'><p>Normalize a range argument into a true numeric range</p></a></li>
<li><a href='#normalized_diff_ind'><p>Calculate a normalized difference.</p></a></li>
<li><a href='#oper_spectra'><p>Binary operation on two spectra, even if the wavelengths values differ</p></a></li>
<li><a href='#peaks'><p>Peaks or local maxima</p></a></li>
<li><a href='#phenylalanine.spct'><p>Molar spectral attenuation coefficient of phenylalanine</p></a></li>
<li><a href='#photobiology-package'><p>photobiology: Photobiological Calculations</p></a></li>
<li><a href='#photodiode.spct'><p>Spectral response of a GaAsP photodiode</p></a></li>
<li><a href='#photon_irradiance'><p>Photon irradiance</p></a></li>
<li><a href='#photon_ratio'><p>Photo:photon ratio</p></a></li>
<li><a href='#photons_energy_ratio'><p>Photon:energy ratio</p></a></li>
<li><a href='#plus-.generic_spct'><p>Arithmetic Operators</p></a></li>
<li><a href='#print'><p>Print spectral collection summary</p></a></li>
<li><a href='#print.solar_time'><p>Print solar time and solar date objects</p></a></li>
<li><a href='#print.summary_generic_spct'><p>Print spectral summary</p></a></li>
<li><a href='#print.tod_time'><p>Print time-of-day objects</p></a></li>
<li><a href='#print.waveband'><p>Print a &quot;waveband&quot; object</p></a></li>
<li><a href='#prod_spectra'><p>Multiply two spectra, even if the wavelengths values differ</p></a></li>
<li><a href='#pull_sample'><p>Random sample of spectra</p></a></li>
<li><a href='#q_fluence'><p>Photon fluence</p></a></li>
<li><a href='#q_fraction'><p>Photon:photon fraction</p></a></li>
<li><a href='#q_irrad'><p>Photon irradiance</p></a></li>
<li><a href='#q_ratio'><p>Photon:photon ratio</p></a></li>
<li><a href='#q_response'><p>Photon-based photo-response</p></a></li>
<li><a href='#q2e'><p>Convert photon-based quantities into energy-based quantities</p></a></li>
<li><a href='#qe_ratio'><p>Photon:energy ratio</p></a></li>
<li><a href='#r4p_pkgs'><p>Packages in R for Photobiology suite</p></a></li>
<li><a href='#rbindspct'><p>Row-bind spectra</p></a></li>
<li><a href='#reflectance'><p>Reflectance</p></a></li>
<li><a href='#reflectance_spct'><p>Calculate reflectance from spectral reflectance</p></a></li>
<li><a href='#relative_AM'><p>Relative Air Mass (AM)</p></a></li>
<li><a href='#replace_bad_pixs'><p>Replace bad pixels in a spectrum</p></a></li>
<li><a href='#resp_spct'><p>Calculate response from spectral response</p></a></li>
<li><a href='#response'><p>Integrated response</p></a></li>
<li><a href='#Rfr_fraction'><p>reflectance:reflectance fraction</p></a></li>
<li><a href='#Rfr_from_n'><p>Reflectance at a planar boundary</p></a></li>
<li><a href='#Rfr_normdiff'><p>reflectance:reflectance normalised difference</p></a></li>
<li><a href='#Rfr_ratio'><p>reflectance:reflectance ratio</p></a></li>
<li><a href='#rgb_spct'><p>RGB color values</p></a></li>
<li><a href='#rmDerivedMspct'><p>Remove &quot;generic_mspct&quot; and derived class attributes.</p></a></li>
<li><a href='#rmDerivedSpct'><p>Remove &quot;generic_spct&quot; and derived class attributes.</p></a></li>
<li><a href='#round'><p>Rounding of Numbers</p></a></li>
<li><a href='#rowwise'><p>rowwise functions for collections of spectra</p></a></li>
<li><a href='#s_e_irrad2rgb'><p>Spectral irradiance to rgb color conversion</p></a></li>
<li><a href='#s_mean'><p>Mean from collection of spectra</p></a></li>
<li><a href='#s_mean_se'><p>Mean and standard error from collection of spectra</p></a></li>
<li><a href='#s_mean_se_band'><p>Mean plus and minus standard error from collection of spectra</p></a></li>
<li><a href='#s_median'><p>Median of a collection of spectra</p></a></li>
<li><a href='#s_prod'><p>Product from collection of spectra</p></a></li>
<li><a href='#s_range'><p>Range of a collection of spectra</p></a></li>
<li><a href='#s_sd'><p>Standard Deviation of a collection of spectra</p></a></li>
<li><a href='#s_se'><p>Standard Error of a collection of spectra</p></a></li>
<li><a href='#s_sum'><p>Sum from collection of spectra</p></a></li>
<li><a href='#s_var'><p>Variance of a collection of spectra</p></a></li>
<li><a href='#se'><p>Standard error of the mean</p></a></li>
<li><a href='#se.m'><p>Standard error of the mean</p></a></li>
<li><a href='#se.p'><p>Standard error of the mean</p></a></li>
<li><a href='#select_spct_attributes'><p>Merge user supplied attribute names with default ones</p></a></li>
<li><a href='#setBSWFUsed'><p>The &quot;bswf.used&quot; attribute</p></a></li>
<li><a href='#setFilterProperties'><p>Set the &quot;filter.properties&quot; attribute</p></a></li>
<li><a href='#setGenericSpct'><p>Convert an R object into a spectrum object.</p></a></li>
<li><a href='#setHowMeasured'><p>Set the &quot;how.measured&quot; attribute</p></a></li>
<li><a href='#setIdFactor'><p>Set the &quot;idfactor&quot; attribute</p></a></li>
<li><a href='#setInstrDesc'><p>Set the &quot;instr.desc&quot; attribute</p></a></li>
<li><a href='#setInstrSettings'><p>Set the &quot;instr.settings&quot; attribute</p></a></li>
<li><a href='#setKType'><p>Set the &quot;K.type&quot; attribute</p></a></li>
<li><a href='#setMultipleWl'><p>Set the &quot;multiple.wl&quot; attribute</p></a></li>
<li><a href='#setNormalized'><p>Set the &quot;normalized&quot; and &quot;normalization&quot; attributes</p></a></li>
<li><a href='#setResponseType'><p>Set the &quot;response.type&quot; attribute</p></a></li>
<li><a href='#setRfrType'><p>The &quot;Rfr.type&quot; attribute</p></a></li>
<li><a href='#setScaled'><p>Set the &quot;scaled&quot; attribute</p></a></li>
<li><a href='#setSoluteProperties'><p>Set the &quot;solute.properties&quot; attribute</p></a></li>
<li><a href='#setTfrType'><p>The &quot;Tfr.type&quot; attribute</p></a></li>
<li><a href='#setTimeUnit'><p>Set the &quot;time.unit&quot; attribute of an existing source_spct object</p></a></li>
<li><a href='#setWhatMeasured'><p>Set the &quot;what.measured&quot; attribute</p></a></li>
<li><a href='#setWhenMeasured'><p>Set the &quot;when.measured&quot; attribute</p></a></li>
<li><a href='#setWhereMeasured'><p>Set the &quot;where.measured&quot; attribute</p></a></li>
<li><a href='#shared_member_class'><p>Classes common to all collection members.</p></a></li>
<li><a href='#sign'><p>Sign</p></a></li>
<li><a href='#sinc'><p>sinc</p></a></li>
<li><a href='#slash-.generic_spct'><p>Arithmetic Operators</p></a></li>
<li><a href='#smooth_spct'><p>Smooth a spectrum</p></a></li>
<li><a href='#solar_time'><p>Local solar time</p></a></li>
<li><a href='#source_spct'><p>Spectral-object constructors</p></a></li>
<li><a href='#spct_attr2tb'><p>Copy attributes into a tibble</p></a></li>
<li><a href='#spct_classes'><p>Function returning a vector containing the names of spectra classes.</p></a></li>
<li><a href='#spct_metadata'><p>Access metadata</p></a></li>
<li><a href='#spct_wide2long'><p>Convert spectrum from wide to long form</p></a></li>
<li><a href='#spikes'><p>Spikes</p></a></li>
<li><a href='#split_bands'><p>List-of-wavebands constructor</p></a></li>
<li><a href='#split_energy_irradiance'><p>Energy irradiance for split spectrum regions</p></a></li>
<li><a href='#split_irradiance'><p>Energy or photon irradiance for split spectrum regions</p></a></li>
<li><a href='#split_photon_irradiance'><p>Photon irradiance for split spectrum regions</p></a></li>
<li><a href='#split2mspct'><p>Convert a 'wide' or untidy data frame into a collection of spectra</p></a></li>
<li><a href='#spread'><p>Expanse</p></a></li>
<li><a href='#Subset'><p>Subsetting spectra</p></a></li>
<li><a href='#subset_attributes'><p>Subset the metadata attributes</p></a></li>
<li><a href='#subset2mspct'><p>Convert 'long' or tidy spectral data into a collection of spectra</p></a></li>
<li><a href='#subt_spectra'><p>Subtract two spectra</p></a></li>
<li><a href='#sum_spectra'><p>Add two spectra</p></a></li>
<li><a href='#summary'><p>Summary of a collection of spectra</p></a></li>
<li><a href='#summary_spct_classes'><p>Function that returns a vector containing the names of spectral summary</p>
classes.</a></li>
<li><a href='#sun_angles'><p>Solar angles</p></a></li>
<li><a href='#sun_daily.spct'><p>Daily solar spectral irradiance (simulated)</p></a></li>
<li><a href='#sun_evening.spct'><p>Time series of solar spectral irradiance (measured)</p></a></li>
<li><a href='#sun.spct'><p>Solar spectral irradiance (simulated)</p></a></li>
<li><a href='#T2A'><p>Convert transmittance into absorbance.</p></a></li>
<li><a href='#T2Afr'><p>Convert transmittance into absorptance.</p></a></li>
<li><a href='#tag'><p>Tag a spectrum</p></a></li>
<li><a href='#Tfr_fraction'><p>transmittance:transmittance fraction</p></a></li>
<li><a href='#Tfr_normdiff'><p>transmittance:transmittance normalised difference</p></a></li>
<li><a href='#Tfr_ratio'><p>transmittance:transmittance ratio</p></a></li>
<li><a href='#thin_wl'><p>Thin the density of wavelength values</p></a></li>
<li><a href='#times-.generic_spct'><p>Arithmetic Operators</p></a></li>
<li><a href='#transmittance'><p>Transmittance</p></a></li>
<li><a href='#transmittance_spct'><p>Calculate transmittance from spectral transmittance.</p></a></li>
<li><a href='#Trig'><p>Trigonometric Functions</p></a></li>
<li><a href='#trim_spct'><p>Trim (or expand) head and/or tail of a spectrum</p></a></li>
<li><a href='#trim_tails'><p>Trim (or expand) head and/or tail</p></a></li>
<li><a href='#trim_waveband'><p>Trim (or expand) head and/or tail</p></a></li>
<li><a href='#trim_wl'><p>Trim head and/or tail of a spectrum</p></a></li>
<li><a href='#trimInstrDesc'><p>Trim the &quot;instr.desc&quot; attribute</p></a></li>
<li><a href='#trimInstrSettings'><p>Trim the &quot;instr.settings&quot; attribute</p></a></li>
<li><a href='#twilight2angle'><p>twilight argument check and conversion</p></a></li>
<li><a href='#two_filters.spct'><p>Transmittance spectrum of plastic films</p></a></li>
<li><a href='#two_irrads'><p>Compute two irrads for ratio, fraction or normalised difference</p></a></li>
<li><a href='#two_reflectances'><p>Compute two reflectances for ratio, fraction or normalised difference</p></a></li>
<li><a href='#two_transmittances'><p>Compute two transmittances for ratio, fraction or normalised difference</p></a></li>
<li><a href='#tz_time_diff'><p>Time difference between two time zones</p></a></li>
<li><a href='#uncollect2spct'><p>Extract all members from a collection</p></a></li>
<li><a href='#untag'><p>Remove tags</p></a></li>
<li><a href='#upgrade_spct'><p>Upgrade one spectral object</p></a></li>
<li><a href='#upgrade_spectra'><p>Upgrade one or more spectral objects</p></a></li>
<li><a href='#using_Tfr'><p>Use photobiology options</p></a></li>
<li><a href='#v_insert_hinges'><p>Insert spectral data values at new wavelength values.</p></a></li>
<li><a href='#v_replace_hinges'><p>Overwrite spectral data values at existing wavelength values.</p></a></li>
<li><a href='#validate_geocode'><p>Validate a geocode</p></a></li>
<li><a href='#valleys'><p>Valleys or local minima</p></a></li>
<li><a href='#verbose_as_default'><p>Set error reporting options</p></a></li>
<li><a href='#w_length_range2rgb'><p>Wavelength range to rgb color conversion</p></a></li>
<li><a href='#w_length2rgb'><p>Wavelength to rgb color conversion</p></a></li>
<li><a href='#water_vp_sat'><p>Water vapour pressure</p></a></li>
<li><a href='#water.spct'><p>Molar spectral attenuation coefficient of water</p></a></li>
<li><a href='#waveband'><p>Waveband constructor method</p></a></li>
<li><a href='#waveband_ratio'><p>Photon or energy ratio</p></a></li>
<li><a href='#wb_trim_as_default'><p>Set computation options</p></a></li>
<li><a href='#wb2rect_spct'><p>Create tagged spectrum from wavebands</p></a></li>
<li><a href='#wb2spct'><p>Create spectrum from wavebands</p></a></li>
<li><a href='#wb2tagged_spct'><p>Create tagged spectrum from wavebands</p></a></li>
<li><a href='#white_led.source_spct'><p>White led bulb spectrum</p></a></li>
<li><a href='#wl_max'><p>Wavelength maximum</p></a></li>
<li><a href='#wl_midpoint'><p>Midpoint</p></a></li>
<li><a href='#wl_min'><p>Wavelength minimum</p></a></li>
<li><a href='#wl_range'><p>Wavelength range</p></a></li>
<li><a href='#wl_stepsize'><p>Stepsize</p></a></li>
<li><a href='#wl2wavenumber'><p>Wavelength conversions</p></a></li>
<li><a href='#wls_at_target'><p>Find wavelengths values corresponding to a target spectral value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Photobiological Calculations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-25</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pedro J. Aphalo &lt;pedro.aphalo@helsinki.fi&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Definitions of classes, methods, operators and functions for use 
    in photobiology and radiation meteorology and climatology. Calculation of
    effective (weighted) and not-weighted irradiances/doses, fluence rates,
    transmittance, reflectance, absorptance, absorbance and diverse ratios and 
    other derived quantities from spectral data. Local maxima and minima: peaks,
    valleys and spikes. Conversion between energy-and photon-based units. 
    Wavelength interpolation. Astronomical calculations related solar angles and 
    day length. Colours and vision. This package is part of the 'r4photobiology' 
    suite, Aphalo, P. J. (2015) &lt;<a href="https://doi.org/10.19232%2Fuv4pb.2015.1.14">doi:10.19232/uv4pb.2015.1.14</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grDevices, polynom (&ge; 1.4-1), tibble (&ge; 3.1.6),
stringr (&ge; 1.4.0), lubridate (&ge; 1.9.0), plyr (&ge; 1.8.7),
dplyr (&ge; 1.0.9), tidyr (&ge; 1.2.0), splus2R (&ge; 1.3-3), zoo (&ge;
1.8-8), rlang (&ge; 1.0.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.41), rmarkdown (&ge; 2.18), testthat (&ge; 3.1.4),
roxygen2 (&ge; 7.2.0), lutz (&ge; 0.3.1), covr</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.r4photobiology.info/photobiology/">https://docs.r4photobiology.info/photobiology/</a>,
<a href="https://github.com/aphalo/photobiology">https://github.com/aphalo/photobiology</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/aphalo/photobiology/issues">https://github.com/aphalo/photobiology/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-26 00:44:39 UTC; aphalo</td>
</tr>
<tr>
<td>Author:</td>
<td>Pedro J. Aphalo <a href="https://orcid.org/0000-0003-3385-972X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Titta K. Kotilainen
    <a href="https://orcid.org/0000-0002-2822-9734"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Glenn Davis [ctb],
  Agnese Fazio [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-26 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5E.generic_spct'>Arithmetic Operators</h2><span id='topic++5E.generic_spct'></span>

<h3>Description</h3>

<p>Power operator for spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
e1 ^ e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5E.generic_spct_+3A_e1">e1</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
<tr><td><code id="+2B5E.generic_spct_+3A_e2">e2</code></td>
<td>
<p>a numeric vector. possibly of length one.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other math operators and functions: 
<code><a href="#topic+MathFun">MathFun</a></code>,
<code><a href="#topic+convolve_each">convolve_each</a>()</code>,
<code><a href="#topic+div-.generic_spct">div-.generic_spct</a></code>,
<code><a href="#topic+log">log</a>()</code>,
<code><a href="#topic+minus-.generic_spct">minus-.generic_spct</a></code>,
<code><a href="#topic+mod-.generic_spct">mod-.generic_spct</a></code>,
<code><a href="#topic+plus-.generic_spct">plus-.generic_spct</a></code>,
<code><a href="#topic+round">round</a>()</code>,
<code><a href="#topic+sign">sign</a>()</code>,
<code><a href="#topic+slash-.generic_spct">slash-.generic_spct</a></code>,
<code><a href="#topic+times-.generic_spct">times-.generic_spct</a></code>
</p>

<hr>
<h2 id='A.illuminant.spct'>CIE A illuminant data</h2><span id='topic+A.illuminant.spct'></span>

<h3>Description</h3>

<p>A dataset containing wavelengths at a 5 nm interval (300 nm to
830 nm) and the corresponding spectral energy irradiance normalized to 1 at
560 nm. Spectrum approximates typical, domestic, tungsten-filament lighting
and 'corresponds' to a black body a 2856 K. CIE standard illuminant A is
intended to represent typical, domestic, tungsten-filament lighting.
Original data from <a href="http://files.cie.co.at/204.xls">http://files.cie.co.at/204.xls</a> downloaded on
2014-07-25 The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A.illuminant.spct
</code></pre>


<h3>Format</h3>

<p>A source spectrum with 96 rows and 2 variables
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm) </p>
</li>
<li><p> s.e.irrad (rel. units) </p>
</li></ul>



<h3>Author(s)</h3>

<p>CIE
</p>


<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A.illuminant.spct

</code></pre>

<hr>
<h2 id='A2T'>Convert absorbance into transmittance</h2><span id='topic+A2T'></span><span id='topic+A2T.default'></span><span id='topic+A2T.numeric'></span><span id='topic+A2T.filter_spct'></span><span id='topic+A2T.filter_mspct'></span>

<h3>Description</h3>

<p>Function that converts absorbance (a.u.) into transmittance (fraction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A2T(x, action, byref, ...)

## Default S3 method:
A2T(x, action = NULL, byref = FALSE, ...)

## S3 method for class 'numeric'
A2T(x, action = NULL, byref = FALSE, ...)

## S3 method for class 'filter_spct'
A2T(x, action = "add", byref = FALSE, ...)

## S3 method for class 'filter_mspct'
A2T(x, action = "add", byref = FALSE, ..., .parallel = FALSE, .paropts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="A2T_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="A2T_+3A_action">action</code></td>
<td>
<p>a character string</p>
</td></tr>
<tr><td><code id="A2T_+3A_byref">byref</code></td>
<td>
<p>logical indicating if new object will be created by reference or
by copy of <code>x</code></p>
</td></tr>
<tr><td><code id="A2T_+3A_...">...</code></td>
<td>
<p>not used in current version</p>
</td></tr>
<tr><td><code id="A2T_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="A2T_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> with a column <code>Tfr</code> added and <code>A</code> and
<code>Afr</code> possibly deleted except for <code>w.length</code>. If <code>action =
  "replace"</code>, in all cases, the additional columns are removed, even if no
column needs to be added.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>A2T(default)</code>: Default method for generic function
</p>
</li>
<li> <p><code>A2T(numeric)</code>: method for numeric vectors
</p>
</li>
<li> <p><code>A2T(filter_spct)</code>: Method for filter spectra
</p>
</li>
<li> <p><code>A2T(filter_mspct)</code>: Method for collections of filter spectra
</p>
</li></ul>


<h3>See Also</h3>

<p>Other quantity conversion functions: 
<code><a href="#topic+Afr2T">Afr2T</a>()</code>,
<code><a href="#topic+T2A">T2A</a>()</code>,
<code><a href="#topic+T2Afr">T2Afr</a>()</code>,
<code><a href="#topic+any2T">any2T</a>()</code>,
<code><a href="#topic+as_quantum">as_quantum</a>()</code>,
<code><a href="#topic+e2q">e2q</a>()</code>,
<code><a href="#topic+e2qmol_multipliers">e2qmol_multipliers</a>()</code>,
<code><a href="#topic+e2quantum_multipliers">e2quantum_multipliers</a>()</code>,
<code><a href="#topic+q2e">q2e</a>()</code>
</p>

<hr>
<h2 id='absorbance'>Absorbance</h2><span id='topic+absorbance'></span><span id='topic+absorbance.default'></span><span id='topic+absorbance.filter_spct'></span><span id='topic+absorbance.object_spct'></span><span id='topic+absorbance.filter_mspct'></span><span id='topic+absorbance.object_mspct'></span>

<h3>Description</h3>

<p>Function to calculate the mean, total, or other summary of absorbance for
spectral data stored in a <code>filter_spct</code> or in an <code>object_spct</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absorbance(spct, w.band, quantity, wb.trim, use.hinges, ...)

## Default S3 method:
absorbance(spct, w.band, quantity, wb.trim, use.hinges, ...)

## S3 method for class 'filter_spct'
absorbance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...
)

## S3 method for class 'object_spct'
absorbance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...
)

## S3 method for class 'filter_mspct'
absorbance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'object_mspct'
absorbance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absorbance_+3A_spct">spct</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="absorbance_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects or a numeric vector of
length two. The waveband(s) determine the region(s) of the spectrum that
are summarized. If a numeric range is supplied a waveband object is
constructed on the fly from it.</p>
</td></tr>
<tr><td><code id="absorbance_+3A_quantity">quantity</code></td>
<td>
<p>character string One of <code>"average"</code> or <code>"mean"</code>,
<code>"total"</code>, <code>"contribution"</code>, <code>"contribution.pc"</code>,
<code>"relative"</code> or <code>"relative.pc"</code>.</p>
</td></tr>
<tr><td><code id="absorbance_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if <code>TRUE</code> wavebands crossing spectral data
boundaries are trimmed, if <code>FALSE</code>, they are discarded.</p>
</td></tr>
<tr><td><code id="absorbance_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="absorbance_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="absorbance_+3A_naming">naming</code></td>
<td>
<p>character one of <code>"long"</code>, <code>"default"</code>,
<code>"short"</code> or <code>"none"</code>. Used to select the type of names to assign
to returned value.</p>
</td></tr>
<tr><td><code id="absorbance_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="absorbance_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="absorbance_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="absorbance_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector in the case of methods for individual
spectra, with one value for each <code>waveband</code> passed to parameter
<code>w.band</code>. A <code>data.frame</code> in the case of collections of spectra,
containing one column for each <code>waveband</code> object, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>absorbance(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>absorbance(filter_spct)</code>: Specialization for filter spectra
</p>
</li>
<li> <p><code>absorbance(object_spct)</code>: Specialization for object spectra
</p>
</li>
<li> <p><code>absorbance(filter_mspct)</code>: Calculates absorbance from a <code>filter_mspct</code>
</p>
</li>
<li> <p><code>absorbance(object_mspct)</code>: Calculates absorbance from a <code>object_mspct</code>
</p>
</li></ul>


<h3>Note</h3>

<p>The <code>use.hinges</code> parameter controls speed optimization. The
defaults should be suitable in most cases. Only the range of wavelengths in
the wavebands is used and all BSWFs are ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>absorbance(polyester.spct, new_waveband(400,700))
absorbance(yellow_gel.spct, new_waveband(400,700))
absorbance(yellow_gel.spct, split_bands(c(400,700), length.out = 3))
absorbance(yellow_gel.spct, split_bands(c(400,700), length.out = 3),
        quantity = "average")
absorbance(yellow_gel.spct, split_bands(c(400,700), length.out = 3),
        quantity = "total")
absorbance(yellow_gel.spct, split_bands(c(400,700), length.out = 3),
        quantity = "relative")
absorbance(yellow_gel.spct, split_bands(c(400,700), length.out = 3),
        quantity = "relative.pc")
absorbance(yellow_gel.spct, split_bands(c(400,700), length.out = 3),
        quantity = "contribution")
absorbance(yellow_gel.spct, split_bands(c(400,700), length.out = 3),
        quantity = "contribution.pc")

</code></pre>

<hr>
<h2 id='absorbance_spct'>Calculate absorbance from spectral absorbance.</h2><span id='topic+absorbance_spct'></span>

<h3>Description</h3>

<p>This function returns the mean absorbance for a given
waveband of a absorbance spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absorbance_spct(spct, w.band, quantity, wb.trim, use.hinges, naming, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absorbance_spct_+3A_spct">spct</code></td>
<td>
<p>filter_spct</p>
</td></tr>
<tr><td><code id="absorbance_spct_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects or a numeric vector of
length two. The waveband(s) determine the region(s) of the spectrum that
are summarized. If a numeric range is supplied a waveband object is
constructed on the fly from it.</p>
</td></tr>
<tr><td><code id="absorbance_spct_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;average&quot; or &quot;mean&quot;, &quot;total&quot;,
&quot;contribution&quot;, &quot;contribution.pc&quot;, &quot;relative&quot; or &quot;relative.pc&quot;</p>
</td></tr>
<tr><td><code id="absorbance_spct_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical Flag, if TRUE wavebands crossing spectral data
boundaries are trimmed and otherwise ignored.</p>
</td></tr>
<tr><td><code id="absorbance_spct_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to use hinges to reduce
interpolation errors</p>
</td></tr>
<tr><td><code id="absorbance_spct_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="absorbance_spct_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
</table>

<hr>
<h2 id='absorptance'>Absorptance</h2><span id='topic+absorptance'></span><span id='topic+absorptance.default'></span><span id='topic+absorptance.filter_spct'></span><span id='topic+absorptance.object_spct'></span><span id='topic+absorptance.filter_mspct'></span><span id='topic+absorptance.object_mspct'></span>

<h3>Description</h3>

<p>Function to calculate the mean, total, or other summary of absorptance for
spectral data stored in a <code>filter_spct</code> or in an <code>object_spct</code>.
Absorptance is a different quantity than absorbance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absorptance(spct, w.band, quantity, wb.trim, use.hinges, ...)

## Default S3 method:
absorptance(spct, w.band, quantity, wb.trim, use.hinges, ...)

## S3 method for class 'filter_spct'
absorptance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...
)

## S3 method for class 'object_spct'
absorptance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...
)

## S3 method for class 'filter_mspct'
absorptance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx"
)

## S3 method for class 'object_mspct'
absorptance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absorptance_+3A_spct">spct</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="absorptance_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects or a numeric vector of
length two. The waveband(s) determine the region(s) of the spectrum that
are summarized. If a numeric range is supplied a waveband object is
constructed on the fly from it.</p>
</td></tr>
<tr><td><code id="absorptance_+3A_quantity">quantity</code></td>
<td>
<p>character string One of <code>"average"</code> or <code>"mean"</code>,
<code>"total"</code>, <code>"contribution"</code>, <code>"contribution.pc"</code>,
<code>"relative"</code> or <code>"relative.pc"</code>.</p>
</td></tr>
<tr><td><code id="absorptance_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if <code>TRUE</code> wavebands crossing spectral data
boundaries are trimmed, if <code>FALSE</code>, they are discarded.</p>
</td></tr>
<tr><td><code id="absorptance_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="absorptance_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="absorptance_+3A_naming">naming</code></td>
<td>
<p>character one of <code>"long"</code>, <code>"default"</code>,
<code>"short"</code> or <code>"none"</code>. Used to select the type of names to assign
to returned value.</p>
</td></tr>
<tr><td><code id="absorptance_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="absorptance_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="absorptance_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="absorptance_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector in the case of methods for individual
spectra, with one value for each <code>waveband</code> passed to parameter
<code>w.band</code>. A <code>data.frame</code> in the case of collections of spectra,
containing one column for each <code>waveband</code> object, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>absorptance(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>absorptance(filter_spct)</code>: Specialization for filter spectra
</p>
</li>
<li> <p><code>absorptance(object_spct)</code>: Specialization for object spectra
</p>
</li>
<li> <p><code>absorptance(filter_mspct)</code>: Calculates absorptance from a <code>filter_mspct</code>
</p>
</li>
<li> <p><code>absorptance(object_mspct)</code>: Calculates absorptance from a <code>object_mspct</code>
</p>
</li></ul>


<h3>Note</h3>

<p>The <code>use.hinges</code> parameter controls speed optimization. The
defaults should be suitable in most cases. Only the range of wavelengths
in the wavebands is used and all BSWFs are ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>absorptance(black_body.spct, new_waveband(400,500))
absorptance(white_body.spct, new_waveband(300,400))
absorptance(black_body.spct, split_bands(c(400,700), length.out = 3))
absorptance(black_body.spct, split_bands(c(400,700), length.out = 3),
        quantity = "average")
absorptance(black_body.spct, split_bands(c(400,700), length.out = 3),
        quantity = "total")
absorptance(black_body.spct, split_bands(c(400,700), length.out = 3),
        quantity = "relative")
absorptance(black_body.spct, split_bands(c(400,700), length.out = 3),
        quantity = "relative.pc")
absorptance(black_body.spct, split_bands(c(400,700), length.out = 3),
        quantity = "contribution")
absorptance(black_body.spct, split_bands(c(400,700), length.out = 3),
        quantity = "contribution.pc")

</code></pre>

<hr>
<h2 id='absorptance_spct'>Calculate absorptance from spectral absorptance.</h2><span id='topic+absorptance_spct'></span>

<h3>Description</h3>

<p>This function returns the summary absorptance for a given waveband of a
<code>object_spct</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absorptance_spct(spct, w.band, quantity, wb.trim, use.hinges, naming, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absorptance_spct_+3A_spct">spct</code></td>
<td>
<p>object_spct</p>
</td></tr>
<tr><td><code id="absorptance_spct_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects or a numeric vector of
length two. The waveband(s) determine the region(s) of the spectrum that
are summarized. If a numeric range is supplied a waveband object is
constructed on the fly from it.</p>
</td></tr>
<tr><td><code id="absorptance_spct_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;average&quot; or &quot;mean&quot;, &quot;contribution&quot;,
&quot;contribution.pc&quot;, &quot;relative&quot; or &quot;relative.pc&quot;</p>
</td></tr>
<tr><td><code id="absorptance_spct_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="absorptance_spct_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical indicating whether to use hinges to reduce
interpolation errors</p>
</td></tr>
<tr><td><code id="absorptance_spct_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="absorptance_spct_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
</table>

<hr>
<h2 id='adaptive_smoothing'>Custom smoothing</h2><span id='topic+adaptive_smoothing'></span>

<h3>Description</h3>

<p>Generic implementation of the custom smoothing method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptive_smoothing(
  x,
  y,
  zero.limit.cnst = max(y) * 1e-04,
  smooth.limit = 0.001,
  smooth.threshold = max(y) * 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptive_smoothing_+3A_x">x</code>, <code id="adaptive_smoothing_+3A_y">y</code></td>
<td>
<p>numeric vectors of equal length.</p>
</td></tr>
<tr><td><code id="adaptive_smoothing_+3A_smooth.limit">smooth.limit</code></td>
<td>
<p>numeric mad/median value above which no smoothing is
applied.</p>
</td></tr>
<tr><td><code id="adaptive_smoothing_+3A_smooth.threshold">smooth.threshold</code></td>
<td>
<p>numeric y value above which no smoothing is applied.</p>
</td></tr>
<tr><td><code id="adaptive_smoothing_+3A_zero.limit">zero.limit</code></td>
<td>
<p>numeric vector of length one or of the same leangth as
<code>x</code> and <code>y</code>. Smaller values in y are forced to zero.</p>
</td></tr>
</table>

<hr>
<h2 id='add_attr2tb'>Copy attributes from members of a generic_mspct</h2><span id='topic+add_attr2tb'></span><span id='topic+when_measured2tb'></span><span id='topic+geocode2tb'></span><span id='topic+lonlat2tb'></span><span id='topic+lon2tb'></span><span id='topic+lat2tb'></span><span id='topic+address2tb'></span><span id='topic+what_measured2tb'></span><span id='topic+how_measured2tb'></span><span id='topic+normalized2tb'></span><span id='topic+scaled2tb'></span><span id='topic+instr_desc2tb'></span><span id='topic+instr_settings2tb'></span><span id='topic+BSWF_used2tb'></span><span id='topic+filter_properties2tb'></span><span id='topic+Tfr_type2tb'></span><span id='topic+Rfr_type2tb'></span><span id='topic+time_unit2tb'></span><span id='topic+comment2tb'></span>

<h3>Description</h3>

<p>Copy metadata attributes from members of a generic_mspct object into a tibble
or data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_attr2tb(
  tb = NULL,
  mspct,
  col.names = NULL,
  idx = "spct.idx",
  unnest = FALSE
)

when_measured2tb(mspct, tb = NULL, col.names = "when.measured", idx = NULL)

geocode2tb(mspct, tb = NULL, col.names = "geocode", idx = "spct.idx")

lonlat2tb(mspct, tb = NULL, col.names = c("lon", "lat"), idx = "spct.idx")

lon2tb(mspct, tb = NULL, col.names = "lon", idx = "spct.idx")

lat2tb(mspct, tb = NULL, col.names = "lat", idx = "spct.idx")

address2tb(mspct, tb = NULL, col.names = "address", idx = "spct.idx")

what_measured2tb(
  mspct,
  tb = NULL,
  col.names = "what.measured",
  idx = "spct.idx"
)

how_measured2tb(mspct, tb = NULL, col.names = "how.measured", idx = "spct.idx")

normalized2tb(mspct, tb = NULL, col.names = "normalized", idx = "spct.idx")

scaled2tb(mspct, tb = NULL, col.names = "scaled", idx = "spct.idx")

instr_desc2tb(mspct, tb = NULL, col.names = "instr.desc", idx = "spct.idx")

instr_settings2tb(
  mspct,
  tb = NULL,
  col.names = "instr.settings",
  idx = "spct.idx"
)

BSWF_used2tb(mspct, tb = NULL, col.names = "BSWF.used", idx = "spct.idx")

filter_properties2tb(
  mspct,
  tb = NULL,
  col.names = "filter.properties",
  idx = "spct.idx"
)

Tfr_type2tb(mspct, tb = NULL, col.names = "Tfr.type", idx = "spct.idx")

Rfr_type2tb(mspct, tb = NULL, col.names = "Rfr.type", idx = "spct.idx")

time_unit2tb(mspct, tb = NULL, col.names = "time.unit", idx = "spct.idx")

comment2tb(mspct, tb = NULL, col.names = "comment", idx = "spct.idx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_attr2tb_+3A_tb">tb</code></td>
<td>
<p>tibble or data.frame to which to add the data (optional).</p>
</td></tr>
<tr><td><code id="add_attr2tb_+3A_mspct">mspct</code></td>
<td>
<p>generic_mspct Any collection of spectra.</p>
</td></tr>
<tr><td><code id="add_attr2tb_+3A_col.names">col.names</code></td>
<td>
<p>named character vector Name(s) of metadata attributes
to copy, while if named, the names provide the name for the column.</p>
</td></tr>
<tr><td><code id="add_attr2tb_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="add_attr2tb_+3A_unnest">unnest</code></td>
<td>
<p>logical Flag controlling if metadata attributes that are lists
of values should be returned in a list column or in separate columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The attributes are copied to a column in a tibble or data frame. If
the <code>tb</code> formal parameter receives <code>NULL</code> as argument, a new
<code>tibble</code> will be created. If an existing <code>data.frame</code> or
<code>tibble</code> is passed as argument, new columns are added to it. However,
the number of rows in the argument passed to <code>tb</code> must match the
number of spectra in the argument passed to <code>mspct</code>. Only in the case
of method <code>add_attr2tb()</code> if the argument
to <code>col.names</code> is a named vector, the names of members are used as names for the columns
created. This permits setting any valid name for the new columns. If the
vector passed to <code>col.names</code> has no names the names of the attributes
are used for the new columns. If the fields of the attributes are unnested
their names are used as names for the columns.
</p>
<p>Valid accepted as argument to <code>col.names</code> are <code>NULL</code>,
<code>"lon"</code>, <code>"lat"</code>, <code>"address"</code>, <code>"geocode"</code>,
<code>"where.measured"</code>, <code>"when.measured"</code>, <code>"what.measured"</code>,
<code>"how.measured"</code>, <code>"comment"</code>, <code>"normalised"</code>,
<code>"normalized"</code>, <code>"scaled"</code>, <code>"bswf.used"</code>,
<code>"instr.desc"</code>, <code>"instr.settings"</code>, <code>"filter.properties"</code>,
<code>"Tfr.type"</code>, <code>"Rfr.type"</code>, <code>"time.unit"</code>.
</p>


<h3>Value</h3>

<p>A tibble With the metadata attributes in separate new variables.
</p>


<h3>Note</h3>

<p>The order of the first two arguments
is reversed in <code>add_attr2tb()</code> compared to the other functions. This
is to allow its use in 'pipes', while the functions for single attributes
are expected to be used mostly to create new tibbles.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

my.mspct &lt;- source_mspct(list(sun1 = sun.spct, sun2 = sun.spct * 2))
q_irrad(my.mspct) %&gt;%
  add_attr2tb(my.mspct, c(lat = "latitude",
                          lon = "longitude",
                          when.measured = "time"))

when_measured2tb(my.mspct)

</code></pre>

<hr>
<h2 id='Afr2T'>Convert transmittance into absorptance.</h2><span id='topic+Afr2T'></span><span id='topic+Afr2T.default'></span><span id='topic+Afr2T.numeric'></span><span id='topic+Afr2T.filter_spct'></span><span id='topic+Afr2T.object_spct'></span><span id='topic+Afr2T.filter_mspct'></span><span id='topic+Afr2T.object_mspct'></span>

<h3>Description</h3>

<p>Function that converts transmittance (fraction) into absorptance (fraction).
If reflectance (fraction) is available, it allows conversions between
internal and total absorptance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Afr2T(x, action, byref, clean, ...)

## Default S3 method:
Afr2T(x, action = NULL, byref = FALSE, clean = FALSE, ...)

## S3 method for class 'numeric'
Afr2T(x, action = NULL, byref = FALSE, clean = FALSE, Rfr = NA_real_, ...)

## S3 method for class 'filter_spct'
Afr2T(x, action = "add", byref = FALSE, clean = FALSE, ...)

## S3 method for class 'object_spct'
Afr2T(x, action = "add", byref = FALSE, clean = FALSE, ...)

## S3 method for class 'filter_mspct'
Afr2T(
  x,
  action = "add",
  byref = FALSE,
  clean = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'object_mspct'
Afr2T(
  x,
  action = "add",
  byref = FALSE,
  clean = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Afr2T_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="Afr2T_+3A_action">action</code></td>
<td>
<p>character Allowed values &quot;replace&quot; and &quot;add&quot;</p>
</td></tr>
<tr><td><code id="Afr2T_+3A_byref">byref</code></td>
<td>
<p>logical indicating if new object will be created by reference or by copy of x</p>
</td></tr>
<tr><td><code id="Afr2T_+3A_clean">clean</code></td>
<td>
<p>logical replace off-boundary values before conversion</p>
</td></tr>
<tr><td><code id="Afr2T_+3A_...">...</code></td>
<td>
<p>not used in current version</p>
</td></tr>
<tr><td><code id="Afr2T_+3A_rfr">Rfr</code></td>
<td>
<p>numeric vector. Spectral reflectance o reflectance factor.
Set to zero if <code>x</code> is internal reflectance,</p>
</td></tr>
<tr><td><code id="Afr2T_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="Afr2T_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> with a column <code>Tfr</code> added and other columns
possibly deleted except for <code>w.length</code>. If <code>action = "replace"</code>,
in all cases, the additional columns are removed, even if no column needs
to be added.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>Afr2T(default)</code>: Default method for generic function
</p>
</li>
<li> <p><code>Afr2T(numeric)</code>: Default method for generic function
</p>
</li>
<li> <p><code>Afr2T(filter_spct)</code>: Method for filter spectra
</p>
</li>
<li> <p><code>Afr2T(object_spct)</code>: Method for object spectra
</p>
</li>
<li> <p><code>Afr2T(filter_mspct)</code>: Method for collections of filter spectra
</p>
</li>
<li> <p><code>Afr2T(object_mspct)</code>: Method for collections of object spectra
</p>
</li></ul>


<h3>See Also</h3>

<p>Other quantity conversion functions: 
<code><a href="#topic+A2T">A2T</a>()</code>,
<code><a href="#topic+T2A">T2A</a>()</code>,
<code><a href="#topic+T2Afr">T2Afr</a>()</code>,
<code><a href="#topic+any2T">any2T</a>()</code>,
<code><a href="#topic+as_quantum">as_quantum</a>()</code>,
<code><a href="#topic+e2q">e2q</a>()</code>,
<code><a href="#topic+e2qmol_multipliers">e2qmol_multipliers</a>()</code>,
<code><a href="#topic+e2quantum_multipliers">e2quantum_multipliers</a>()</code>,
<code><a href="#topic+q2e">q2e</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T2Afr(Ler_leaf.spct)

</code></pre>

<hr>
<h2 id='any2T'>Convert filter quantities.</h2><span id='topic+any2T'></span><span id='topic+any2A'></span><span id='topic+any2Afr'></span>

<h3>Description</h3>

<p>Functions that convert or add related physical quantities to
<code>filter_spct</code> or  <code>object_spct</code> objects. transmittance (fraction)
into absorptance (fraction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>any2T(x, action = "add", clean = FALSE)

any2A(x, action = "add", clean = FALSE)

any2Afr(x, action = "add", clean = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="any2T_+3A_x">x</code></td>
<td>
<p>an filter_spct or a filter_mspct object.</p>
</td></tr>
<tr><td><code id="any2T_+3A_action">action</code></td>
<td>
<p>character Allowed values &quot;replace&quot; and &quot;add&quot;.</p>
</td></tr>
<tr><td><code id="any2T_+3A_clean">clean</code></td>
<td>
<p>logical replace off-boundary values before conversion</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are dispatchers for <code><a href="#topic+A2T">A2T</a></code>,
<code><a href="#topic+Afr2T">Afr2T</a></code>, <code><a href="#topic+T2A">T2A</a></code>, and <code><a href="#topic+T2Afr">T2Afr</a></code>. The
dispatch is based on the names of the variables stored in <code>x</code>. They
do not support in-place modification of <code>x</code>.
</p>


<h3>Value</h3>

<p>A copy of <code>x</code> with the columns for the different quantities
added or replaced. If <code>action = "replace"</code>, in all cases, the
additional columns are removed, even if no column needs to be added.
</p>


<h3>See Also</h3>

<p>Other quantity conversion functions: 
<code><a href="#topic+A2T">A2T</a>()</code>,
<code><a href="#topic+Afr2T">Afr2T</a>()</code>,
<code><a href="#topic+T2A">T2A</a>()</code>,
<code><a href="#topic+T2Afr">T2Afr</a>()</code>,
<code><a href="#topic+as_quantum">as_quantum</a>()</code>,
<code><a href="#topic+e2q">e2q</a>()</code>,
<code><a href="#topic+e2qmol_multipliers">e2qmol_multipliers</a>()</code>,
<code><a href="#topic+e2quantum_multipliers">e2quantum_multipliers</a>()</code>,
<code><a href="#topic+q2e">q2e</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>any2Afr(Ler_leaf.spct)
any2T(Ler_leaf.spct)
any2T(polyester.spct)

</code></pre>

<hr>
<h2 id='as_energy'>Convert spectral photon irradiance into spectral energy irradiance</h2><span id='topic+as_energy'></span>

<h3>Description</h3>

<p>Convert a spectral photon irradiance [<code class="reqn">mol\,s^{-1}\,m^{-2}\,nm^{-1}</code>] into a spectral energy irradiance [<code class="reqn">W\,m^{-2}\,nm^{-1}</code>].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_energy(w.length, s.qmol.irrad)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_energy_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths [<code class="reqn">nm</code>]).</p>
</td></tr>
<tr><td><code id="as_energy_+3A_s.qmol.irrad">s.qmol.irrad</code></td>
<td>
<p>numeric vector of spectral photon irradiance values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of spectral (energy) irradiances.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.spct, as_energy(w.length, s.q.irrad))

</code></pre>

<hr>
<h2 id='as_quantum'>Convert spectral energy irradiance into spectral photon irradiance</h2><span id='topic+as_quantum'></span>

<h3>Description</h3>

<p>Convert spectral energy irradiance [W m-2 nm-1] into spectral photon
irradiance expressed as number of photons [s-1 m-2 nm-1]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_quantum(w.length, s.e.irrad)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_quantum_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths (nm).</p>
</td></tr>
<tr><td><code id="as_quantum_+3A_s.e.irrad">s.e.irrad</code></td>
<td>
<p>numeric vector of spectral (energy) irradiance values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of spectral photon irradiances.
</p>


<h3>See Also</h3>

<p>Other quantity conversion functions: 
<code><a href="#topic+A2T">A2T</a>()</code>,
<code><a href="#topic+Afr2T">Afr2T</a>()</code>,
<code><a href="#topic+T2A">T2A</a>()</code>,
<code><a href="#topic+T2Afr">T2Afr</a>()</code>,
<code><a href="#topic+any2T">any2T</a>()</code>,
<code><a href="#topic+e2q">e2q</a>()</code>,
<code><a href="#topic+e2qmol_multipliers">e2qmol_multipliers</a>()</code>,
<code><a href="#topic+e2quantum_multipliers">e2quantum_multipliers</a>()</code>,
<code><a href="#topic+q2e">q2e</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data, as_quantum(w.length, s.e.irrad))

</code></pre>

<hr>
<h2 id='as_quantum_mol'>Convert spectral energy irradiance into spectral photon irradiance</h2><span id='topic+as_quantum_mol'></span>

<h3>Description</h3>

<p>Convert spectral energy irradiance [<code class="reqn">W\,m^{-2}\,nm^{-1}</code>]
into a spectral photon irradiance expressed in number of molds of photons
[<code class="reqn">mol\,s^{-1}\,m^{-2}\,nm^{-1}</code>].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_quantum_mol(w.length, s.e.irrad)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_quantum_mol_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths (nm).</p>
</td></tr>
<tr><td><code id="as_quantum_mol_+3A_s.e.irrad">s.e.irrad</code></td>
<td>
<p>numeric vector of spectral (energy) irradiance values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of spectral photon irradiances.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data, as_quantum_mol(w.length, s.e.irrad))

</code></pre>

<hr>
<h2 id='as_tod'>Convert datetime to time-of-day</h2><span id='topic+as_tod'></span>

<h3>Description</h3>

<p>Convert a datetime into a time of day expressed in hours, minutes or seconds
from midnight in local time for a time zone. This conversion is useful when
time-series data for different days needs to be compared or plotted based on
the local time-of-day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tod(x, unit.out = "hours", tz = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tod_+3A_x">x</code></td>
<td>
<p>a datetime object accepted by lubridate functions</p>
</td></tr>
<tr><td><code id="as_tod_+3A_unit.out">unit.out</code></td>
<td>
<p>character string, One of &quot;tod_time&quot;, &quot;hours&quot;, &quot;minutes&quot;, or &quot;seconds&quot;.</p>
</td></tr>
<tr><td><code id="as_tod_+3A_tz">tz</code></td>
<td>
<p>character string indicating time zone to be used in output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>x</code>. If
<code>unit.out = "tod_time"</code> an object of class <code>"tod_time"</code> which
the same as for <code>unit.out = "hours"</code> but with the class attribute
set, which dispatches to special <code>format()</code> nad <code>print()</code>
methods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+solar_time">solar_time</a></code>
</p>
<p>Other Time of day functions: 
<code><a href="#topic+format.tod_time">format.tod_time</a>()</code>,
<code><a href="#topic+print.tod_time">print.tod_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
my_instants &lt;- ymd_hms("2020-05-17 12:05:03") + days(c(0, 30))
my_instants
as_tod(my_instants)
as_tod(my_instants, unit.out = "tod_time")

</code></pre>

<hr>
<h2 id='as.calibration_mspct'>Coerce to a collection-of-spectra</h2><span id='topic+as.calibration_mspct'></span><span id='topic+as.calibration_mspct.default'></span><span id='topic+as.calibration_mspct.data.frame'></span><span id='topic+as.calibration_mspct.calibration_spct'></span><span id='topic+as.calibration_mspct.list'></span><span id='topic+as.calibration_mspct.matrix'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type
of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.calibration_mspct(x, ...)

## Default S3 method:
as.calibration_mspct(x, ...)

## S3 method for class 'data.frame'
as.calibration_mspct(x, ...)

## S3 method for class 'calibration_spct'
as.calibration_mspct(x, ...)

## S3 method for class 'list'
as.calibration_mspct(x, ..., ncol = 1, byrow = FALSE)

## S3 method for class 'matrix'
as.calibration_mspct(
  x,
  w.length,
  spct.data.var = "irrad.mult",
  multiplier = 1,
  byrow = NULL,
  spct.names = "spct_",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.calibration_mspct_+3A_x">x</code></td>
<td>
<p>a list of spectral objects or a list of objects such as data frames
that can be converted into spectral objects.</p>
</td></tr>
<tr><td><code id="as.calibration_mspct_+3A_...">...</code></td>
<td>
<p>passed to individual spectrum object constructor</p>
</td></tr>
<tr><td><code id="as.calibration_mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="as.calibration_mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
<tr><td><code id="as.calibration_mspct_+3A_w.length">w.length</code></td>
<td>
<p>numeric A vector of wavelengthvalues sorted in strictly
ascending order (nm).</p>
</td></tr>
<tr><td><code id="as.calibration_mspct_+3A_spct.data.var">spct.data.var</code></td>
<td>
<p>character The name of the variable that will contain the
spectral data. This indicates what physical quantity is stored in the
matrix and the units of expression used.</p>
</td></tr>
<tr><td><code id="as.calibration_mspct_+3A_multiplier">multiplier</code></td>
<td>
<p>numeric A multiplier to be applied to the values in
<code>x</code> to do unit or scale conversion.</p>
</td></tr>
<tr><td><code id="as.calibration_mspct_+3A_spct.names">spct.names</code></td>
<td>
<p>character Vector of names to be assigned to collection
members, either of length 1, or with length equal to the number of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>calibration_mspctt</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.calibration_mspct(default)</code>: 
</p>
</li>
<li> <p><code>as.calibration_mspct(data.frame)</code>: 
</p>
</li>
<li> <p><code>as.calibration_mspct(calibration_spct)</code>: 
</p>
</li>
<li> <p><code>as.calibration_mspct(list)</code>: 
</p>
</li>
<li> <p><code>as.calibration_mspct(matrix)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>When <code>x</code> is a square matrix an explicit argument is needed for
<code>byrow</code> to indicate how data in <code>x</code> should be read. In every case
the length of the <code>w.length</code> vector must match one of the dimensions
of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.chroma_mspct">as.chroma_mspct</a>()</code>,
<code><a href="#topic+as.cps_mspct">as.cps_mspct</a>()</code>,
<code><a href="#topic+as.filter_mspct">as.filter_mspct</a>()</code>,
<code><a href="#topic+as.generic_mspct">as.generic_mspct</a>()</code>,
<code><a href="#topic+as.object_mspct">as.object_mspct</a>()</code>,
<code><a href="#topic+as.raw_mspct">as.raw_mspct</a>()</code>,
<code><a href="#topic+as.reflector_mspct">as.reflector_mspct</a>()</code>,
<code><a href="#topic+as.response_mspct">as.response_mspct</a>()</code>,
<code><a href="#topic+as.solute_mspct">as.solute_mspct</a>()</code>,
<code><a href="#topic+as.source_mspct">as.source_mspct</a>()</code>,
<code><a href="#topic+split2mspct">split2mspct</a>()</code>,
<code><a href="#topic+subset2mspct">subset2mspct</a>()</code>
</p>

<hr>
<h2 id='as.calibration_spct'>Coerce to a spectrum</h2><span id='topic+as.calibration_spct'></span><span id='topic+as.calibration_spct.default'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.calibration_spct(x, ...)

## Default S3 method:
as.calibration_spct(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.calibration_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="as.calibration_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to &quot;set&quot; functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>calibration_spct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.calibration_spct(default)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setGenericSpct">setGenericSpct</a></code>
</p>
<p>Other constructors of spectral objects: 
<code><a href="#topic+as.chroma_spct">as.chroma_spct</a>()</code>,
<code><a href="#topic+as.cps_spct">as.cps_spct</a>()</code>,
<code><a href="#topic+as.filter_spct">as.filter_spct</a>()</code>,
<code><a href="#topic+as.generic_spct">as.generic_spct</a>()</code>,
<code><a href="#topic+as.object_spct">as.object_spct</a>()</code>,
<code><a href="#topic+as.raw_spct">as.raw_spct</a>()</code>,
<code><a href="#topic+as.reflector_spct">as.reflector_spct</a>()</code>,
<code><a href="#topic+as.response_spct">as.response_spct</a>()</code>,
<code><a href="#topic+as.solute_spct">as.solute_spct</a>()</code>,
<code><a href="#topic+as.source_spct">as.source_spct</a>()</code>,
<code><a href="#topic+source_spct">source_spct</a>()</code>
</p>

<hr>
<h2 id='as.chroma_mspct'>Coerce to a collection-of-spectra</h2><span id='topic+as.chroma_mspct'></span><span id='topic+as.chroma_mspct.default'></span><span id='topic+as.chroma_mspct.data.frame'></span><span id='topic+as.chroma_mspct.chroma_spct'></span><span id='topic+as.chroma_mspct.list'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type
of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.chroma_mspct(x, ...)

## Default S3 method:
as.chroma_mspct(x, ...)

## S3 method for class 'data.frame'
as.chroma_mspct(x, ...)

## S3 method for class 'chroma_spct'
as.chroma_mspct(x, ...)

## S3 method for class 'list'
as.chroma_mspct(x, ..., ncol = 1, byrow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.chroma_mspct_+3A_x">x</code></td>
<td>
<p>a list of spectral objects or a list of objects such as data frames
that can be converted into spectral objects.</p>
</td></tr>
<tr><td><code id="as.chroma_mspct_+3A_...">...</code></td>
<td>
<p>passed to individual spectrum object constructor</p>
</td></tr>
<tr><td><code id="as.chroma_mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="as.chroma_mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>chroma_mspct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.chroma_mspct(default)</code>: 
</p>
</li>
<li> <p><code>as.chroma_mspct(data.frame)</code>: 
</p>
</li>
<li> <p><code>as.chroma_mspct(chroma_spct)</code>: 
</p>
</li>
<li> <p><code>as.chroma_mspct(list)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.calibration_mspct">as.calibration_mspct</a>()</code>,
<code><a href="#topic+as.cps_mspct">as.cps_mspct</a>()</code>,
<code><a href="#topic+as.filter_mspct">as.filter_mspct</a>()</code>,
<code><a href="#topic+as.generic_mspct">as.generic_mspct</a>()</code>,
<code><a href="#topic+as.object_mspct">as.object_mspct</a>()</code>,
<code><a href="#topic+as.raw_mspct">as.raw_mspct</a>()</code>,
<code><a href="#topic+as.reflector_mspct">as.reflector_mspct</a>()</code>,
<code><a href="#topic+as.response_mspct">as.response_mspct</a>()</code>,
<code><a href="#topic+as.solute_mspct">as.solute_mspct</a>()</code>,
<code><a href="#topic+as.source_mspct">as.source_mspct</a>()</code>,
<code><a href="#topic+split2mspct">split2mspct</a>()</code>,
<code><a href="#topic+subset2mspct">subset2mspct</a>()</code>
</p>

<hr>
<h2 id='as.chroma_spct'>Coerce to a spectrum</h2><span id='topic+as.chroma_spct'></span><span id='topic+as.chroma_spct.default'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.chroma_spct(x, ...)

## Default S3 method:
as.chroma_spct(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.chroma_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="as.chroma_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to &quot;set&quot; functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>chroma_spct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.chroma_spct(default)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setGenericSpct">setGenericSpct</a></code>
</p>
<p>Other constructors of spectral objects: 
<code><a href="#topic+as.calibration_spct">as.calibration_spct</a>()</code>,
<code><a href="#topic+as.cps_spct">as.cps_spct</a>()</code>,
<code><a href="#topic+as.filter_spct">as.filter_spct</a>()</code>,
<code><a href="#topic+as.generic_spct">as.generic_spct</a>()</code>,
<code><a href="#topic+as.object_spct">as.object_spct</a>()</code>,
<code><a href="#topic+as.raw_spct">as.raw_spct</a>()</code>,
<code><a href="#topic+as.reflector_spct">as.reflector_spct</a>()</code>,
<code><a href="#topic+as.response_spct">as.response_spct</a>()</code>,
<code><a href="#topic+as.solute_spct">as.solute_spct</a>()</code>,
<code><a href="#topic+as.source_spct">as.source_spct</a>()</code>,
<code><a href="#topic+source_spct">source_spct</a>()</code>
</p>

<hr>
<h2 id='as.cps_mspct'>Coerce to a collection-of-spectra</h2><span id='topic+as.cps_mspct'></span><span id='topic+as.cps_mspct.default'></span><span id='topic+as.cps_mspct.data.frame'></span><span id='topic+as.cps_mspct.cps_spct'></span><span id='topic+as.cps_mspct.list'></span><span id='topic+as.cps_mspct.matrix'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type
of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.cps_mspct(x, ...)

## Default S3 method:
as.cps_mspct(x, ...)

## S3 method for class 'data.frame'
as.cps_mspct(x, ...)

## S3 method for class 'cps_spct'
as.cps_mspct(x, ...)

## S3 method for class 'list'
as.cps_mspct(x, ..., ncol = 1, byrow = FALSE)

## S3 method for class 'matrix'
as.cps_mspct(
  x,
  w.length,
  spct.data.var = "cps",
  multiplier = 1,
  byrow = NULL,
  spct.names = "spct_",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.cps_mspct_+3A_x">x</code></td>
<td>
<p>a list of spectral objects or a list of objects such as data frames
that can be converted into spectral objects.</p>
</td></tr>
<tr><td><code id="as.cps_mspct_+3A_...">...</code></td>
<td>
<p>passed to individual spectrum object constructor</p>
</td></tr>
<tr><td><code id="as.cps_mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="as.cps_mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
<tr><td><code id="as.cps_mspct_+3A_w.length">w.length</code></td>
<td>
<p>numeric A vector of wavelengthvalues sorted in strictly
ascending order (nm).</p>
</td></tr>
<tr><td><code id="as.cps_mspct_+3A_spct.data.var">spct.data.var</code></td>
<td>
<p>character The name of the variable that will contain the
spectral data. This indicates what physical quantity is stored in the
matrix and the units of expression used.</p>
</td></tr>
<tr><td><code id="as.cps_mspct_+3A_multiplier">multiplier</code></td>
<td>
<p>numeric A multiplier to be applied to the values in
<code>x</code> to do unit or scale conversion.</p>
</td></tr>
<tr><td><code id="as.cps_mspct_+3A_spct.names">spct.names</code></td>
<td>
<p>character Vector of names to be assigned to collection
members, either of length 1, or with length equal to the number of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>cps_mspct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.cps_mspct(default)</code>: 
</p>
</li>
<li> <p><code>as.cps_mspct(data.frame)</code>: 
</p>
</li>
<li> <p><code>as.cps_mspct(cps_spct)</code>: 
</p>
</li>
<li> <p><code>as.cps_mspct(list)</code>: 
</p>
</li>
<li> <p><code>as.cps_mspct(matrix)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>When <code>x</code> is a square matrix an explicit argument is needed for
<code>byrow</code> to indicate how data in <code>x</code> should be read. In every case
the length of the <code>w.length</code> vector must match one of the dimensions
of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.calibration_mspct">as.calibration_mspct</a>()</code>,
<code><a href="#topic+as.chroma_mspct">as.chroma_mspct</a>()</code>,
<code><a href="#topic+as.filter_mspct">as.filter_mspct</a>()</code>,
<code><a href="#topic+as.generic_mspct">as.generic_mspct</a>()</code>,
<code><a href="#topic+as.object_mspct">as.object_mspct</a>()</code>,
<code><a href="#topic+as.raw_mspct">as.raw_mspct</a>()</code>,
<code><a href="#topic+as.reflector_mspct">as.reflector_mspct</a>()</code>,
<code><a href="#topic+as.response_mspct">as.response_mspct</a>()</code>,
<code><a href="#topic+as.solute_mspct">as.solute_mspct</a>()</code>,
<code><a href="#topic+as.source_mspct">as.source_mspct</a>()</code>,
<code><a href="#topic+split2mspct">split2mspct</a>()</code>,
<code><a href="#topic+subset2mspct">subset2mspct</a>()</code>
</p>

<hr>
<h2 id='as.cps_spct'>Coerce to a spectrum</h2><span id='topic+as.cps_spct'></span><span id='topic+as.cps_spct.default'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.cps_spct(x, ...)

## Default S3 method:
as.cps_spct(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.cps_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="as.cps_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to &quot;set&quot; functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>cps_spct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.cps_spct(default)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setGenericSpct">setGenericSpct</a></code>
</p>
<p>Other constructors of spectral objects: 
<code><a href="#topic+as.calibration_spct">as.calibration_spct</a>()</code>,
<code><a href="#topic+as.chroma_spct">as.chroma_spct</a>()</code>,
<code><a href="#topic+as.filter_spct">as.filter_spct</a>()</code>,
<code><a href="#topic+as.generic_spct">as.generic_spct</a>()</code>,
<code><a href="#topic+as.object_spct">as.object_spct</a>()</code>,
<code><a href="#topic+as.raw_spct">as.raw_spct</a>()</code>,
<code><a href="#topic+as.reflector_spct">as.reflector_spct</a>()</code>,
<code><a href="#topic+as.response_spct">as.response_spct</a>()</code>,
<code><a href="#topic+as.solute_spct">as.solute_spct</a>()</code>,
<code><a href="#topic+as.source_spct">as.source_spct</a>()</code>,
<code><a href="#topic+source_spct">source_spct</a>()</code>
</p>

<hr>
<h2 id='as.filter_mspct'>Coerce to a collection-of-spectra</h2><span id='topic+as.filter_mspct'></span><span id='topic+as.filter_mspct.default'></span><span id='topic+as.filter_mspct.data.frame'></span><span id='topic+as.filter_mspct.filter_spct'></span><span id='topic+as.filter_mspct.list'></span><span id='topic+as.filter_mspct.matrix'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type
of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.filter_mspct(x, ...)

## Default S3 method:
as.filter_mspct(x, ...)

## S3 method for class 'data.frame'
as.filter_mspct(x, Tfr.type = c("total", "internal"), strict.range = TRUE, ...)

## S3 method for class 'filter_spct'
as.filter_mspct(x, ...)

## S3 method for class 'list'
as.filter_mspct(
  x,
  Tfr.type = c("total", "internal"),
  strict.range = TRUE,
  ...,
  ncol = 1,
  byrow = FALSE
)

## S3 method for class 'matrix'
as.filter_mspct(
  x,
  w.length,
  spct.data.var = "Tfr",
  multiplier = 1,
  byrow = NULL,
  spct.names = "spct_",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.filter_mspct_+3A_x">x</code></td>
<td>
<p>a list of spectral objects or a list of objects such as data frames
that can be converted into spectral objects.</p>
</td></tr>
<tr><td><code id="as.filter_mspct_+3A_...">...</code></td>
<td>
<p>passed to individual spectrum object constructor</p>
</td></tr>
<tr><td><code id="as.filter_mspct_+3A_tfr.type">Tfr.type</code></td>
<td>
<p>a character string, either &quot;total&quot; or &quot;internal&quot;</p>
</td></tr>
<tr><td><code id="as.filter_mspct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical Flag indicating how off-range values are handled</p>
</td></tr>
<tr><td><code id="as.filter_mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="as.filter_mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
<tr><td><code id="as.filter_mspct_+3A_w.length">w.length</code></td>
<td>
<p>numeric A vector of wavelengthvalues sorted in strictly
ascending order (nm).</p>
</td></tr>
<tr><td><code id="as.filter_mspct_+3A_spct.data.var">spct.data.var</code></td>
<td>
<p>character The name of the variable that will contain the
spectral data. This indicates what physical quantity is stored in the
matrix and the units of expression used.</p>
</td></tr>
<tr><td><code id="as.filter_mspct_+3A_multiplier">multiplier</code></td>
<td>
<p>numeric A multiplier to be applied to the values in
<code>x</code> to do unit or scale conversion.</p>
</td></tr>
<tr><td><code id="as.filter_mspct_+3A_spct.names">spct.names</code></td>
<td>
<p>character Vector of names to be assigned to collection
members, either of length 1, or with length equal to the number of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>filter_mspct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.filter_mspct(default)</code>: 
</p>
</li>
<li> <p><code>as.filter_mspct(data.frame)</code>: 
</p>
</li>
<li> <p><code>as.filter_mspct(filter_spct)</code>: 
</p>
</li>
<li> <p><code>as.filter_mspct(list)</code>: 
</p>
</li>
<li> <p><code>as.filter_mspct(matrix)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>When <code>x</code> is a square matrix an explicit argument is needed for
<code>byrow</code> to indicate how data in <code>x</code> should be read. In every case
the length of the <code>w.length</code> vector must match one of the dimensions
of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.calibration_mspct">as.calibration_mspct</a>()</code>,
<code><a href="#topic+as.chroma_mspct">as.chroma_mspct</a>()</code>,
<code><a href="#topic+as.cps_mspct">as.cps_mspct</a>()</code>,
<code><a href="#topic+as.generic_mspct">as.generic_mspct</a>()</code>,
<code><a href="#topic+as.object_mspct">as.object_mspct</a>()</code>,
<code><a href="#topic+as.raw_mspct">as.raw_mspct</a>()</code>,
<code><a href="#topic+as.reflector_mspct">as.reflector_mspct</a>()</code>,
<code><a href="#topic+as.response_mspct">as.response_mspct</a>()</code>,
<code><a href="#topic+as.solute_mspct">as.solute_mspct</a>()</code>,
<code><a href="#topic+as.source_mspct">as.source_mspct</a>()</code>,
<code><a href="#topic+split2mspct">split2mspct</a>()</code>,
<code><a href="#topic+subset2mspct">subset2mspct</a>()</code>
</p>

<hr>
<h2 id='as.filter_spct'>Coerce or convert into a filter spectrum</h2><span id='topic+as.filter_spct'></span><span id='topic+as.filter_spct.default'></span><span id='topic+as.filter_spct.solute_spct'></span>

<h3>Description</h3>

<p>Return a possibly modified copy of an R object with its class set to a filter
spectrum. In the case of conversion from a <code>solute_spct</code> object, compute
the spectral quantity based on additional input from user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.filter_spct(x, ...)

## Default S3 method:
as.filter_spct(
  x,
  Tfr.type = c("total", "internal"),
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  ...
)

## S3 method for class 'solute_spct'
as.filter_spct(
  x,
  Tfr.type = "internal",
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  Rfr.constant = NA_real_,
  comment = NULL,
  molar.concentration = NULL,
  mass.concentration = NULL,
  path.length = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.filter_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="as.filter_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to &quot;set&quot; functions.</p>
</td></tr>
<tr><td><code id="as.filter_spct_+3A_tfr.type">Tfr.type</code></td>
<td>
<p>a character string, either <code>"total"</code> or
<code>"internal"</code>.</p>
</td></tr>
<tr><td><code id="as.filter_spct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical Flag indicating whether off-range values result
in an error instead of a warning.</p>
</td></tr>
<tr><td><code id="as.filter_spct_+3A_rfr.constant">Rfr.constant</code></td>
<td>
<p>numeric The value of the reflection factor (/1) to be
set.</p>
</td></tr>
<tr><td><code id="as.filter_spct_+3A_comment">comment</code></td>
<td>
<p>character A string to be added as a comment attribute to the
object created. If not supplied, the comment will be copied from <code>x</code>.</p>
</td></tr>
<tr><td><code id="as.filter_spct_+3A_molar.concentration">molar.concentration</code>, <code id="as.filter_spct_+3A_mass.concentration">mass.concentration</code></td>
<td>
<p>numeric Concentration to be
used to compute transmittance of the solute in solution
[<code class="reqn">mol\,m^{-3} = mmol\,dm^{-3}</code> or
<code class="reqn">kg\,m^{-3} = g\,dm^{-3}</code>, respectively].</p>
</td></tr>
<tr><td><code id="as.filter_spct_+3A_path.length">path.length</code></td>
<td>
<p>numeric The length of the light path (<code class="reqn">m</code>) used to
compute transmittance of the solute in a solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>filter_spct</code>. object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.filter_spct(default)</code>: 
</p>
</li>
<li> <p><code>as.filter_spct(solute_spct)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setGenericSpct">setGenericSpct</a></code>
</p>
<p>Other constructors of spectral objects: 
<code><a href="#topic+as.calibration_spct">as.calibration_spct</a>()</code>,
<code><a href="#topic+as.chroma_spct">as.chroma_spct</a>()</code>,
<code><a href="#topic+as.cps_spct">as.cps_spct</a>()</code>,
<code><a href="#topic+as.generic_spct">as.generic_spct</a>()</code>,
<code><a href="#topic+as.object_spct">as.object_spct</a>()</code>,
<code><a href="#topic+as.raw_spct">as.raw_spct</a>()</code>,
<code><a href="#topic+as.reflector_spct">as.reflector_spct</a>()</code>,
<code><a href="#topic+as.response_spct">as.response_spct</a>()</code>,
<code><a href="#topic+as.solute_spct">as.solute_spct</a>()</code>,
<code><a href="#topic+as.source_spct">as.source_spct</a>()</code>,
<code><a href="#topic+source_spct">source_spct</a>()</code>
</p>

<hr>
<h2 id='as.generic_mspct'>Coerce to a collection-of-spectra</h2><span id='topic+as.generic_mspct'></span><span id='topic+as.generic_mspct.default'></span><span id='topic+as.generic_mspct.data.frame'></span><span id='topic+as.generic_mspct.generic_spct'></span><span id='topic+as.generic_mspct.list'></span><span id='topic+as.generic_mspct.matrix'></span><span id='topic+mat2mspct'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type
of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.generic_mspct(x, ...)

## Default S3 method:
as.generic_mspct(x, ...)

## S3 method for class 'data.frame'
as.generic_mspct(x, force.spct.class = FALSE, ...)

## S3 method for class 'generic_spct'
as.generic_mspct(x, force.spct.class = FALSE, ...)

## S3 method for class 'list'
as.generic_mspct(x, force.spct.class = FALSE, ..., ncol = 1, byrow = FALSE)

## S3 method for class 'matrix'
as.generic_mspct(
  x,
  w.length,
  member.class,
  spct.data.var,
  multiplier = 1,
  byrow = NULL,
  spct.names = "spct_",
  ...
)

mat2mspct(
  x,
  w.length,
  member.class,
  spct.data.var,
  multiplier = 1,
  byrow = NULL,
  spct.names = "spct_",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.generic_mspct_+3A_x">x</code></td>
<td>
<p>a list of spectral objects or a list of objects such as data frames
that can be converted into spectral objects.</p>
</td></tr>
<tr><td><code id="as.generic_mspct_+3A_...">...</code></td>
<td>
<p>passed to individual spectrum object constructor</p>
</td></tr>
<tr><td><code id="as.generic_mspct_+3A_force.spct.class">force.spct.class</code></td>
<td>
<p>logical indicating whether to change the class of
members to <code>generic_spct</code> or retain the existing class.</p>
</td></tr>
<tr><td><code id="as.generic_mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="as.generic_mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
<tr><td><code id="as.generic_mspct_+3A_w.length">w.length</code></td>
<td>
<p>numeric A vector of wavelengthvalues sorted in strictly
ascending order (nm).</p>
</td></tr>
<tr><td><code id="as.generic_mspct_+3A_member.class">member.class</code></td>
<td>
<p>character The name of the class of the individual spectra
to be constructed.</p>
</td></tr>
<tr><td><code id="as.generic_mspct_+3A_spct.data.var">spct.data.var</code></td>
<td>
<p>character The name of the variable that will contain the
spectral data. This indicates what physical quantity is stored in the
matrix and the units of expression used.</p>
</td></tr>
<tr><td><code id="as.generic_mspct_+3A_multiplier">multiplier</code></td>
<td>
<p>numeric A multiplier to be applied to the values in
<code>x</code> to do unit or scale conversion.</p>
</td></tr>
<tr><td><code id="as.generic_mspct_+3A_spct.names">spct.names</code></td>
<td>
<p>character Vector of names to be assigned to collection
members, either of length 1, or with length equal to the number of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>generic_mspct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.generic_mspct(default)</code>: 
</p>
</li>
<li> <p><code>as.generic_mspct(data.frame)</code>: 
</p>
</li>
<li> <p><code>as.generic_mspct(generic_spct)</code>: 
</p>
</li>
<li> <p><code>as.generic_mspct(list)</code>: 
</p>
</li>
<li> <p><code>as.generic_mspct(matrix)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Members of <code>generic_mspct</code> objects can be heterogeneous: they can
belong to any class derived from <code>generic_spct</code> and class is not
enforced. When <code>x</code> is a list of data frames <code>force.spct.class =
  TRUE</code> needs to be supplied. When <code>x</code> is a square matrix an explicit
argument is needed for <code>byrow</code> to indicate how data in <code>x</code> should
be read. In every case the length of the <code>w.length</code> vector must match
one of the dimensions of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.calibration_mspct">as.calibration_mspct</a>()</code>,
<code><a href="#topic+as.chroma_mspct">as.chroma_mspct</a>()</code>,
<code><a href="#topic+as.cps_mspct">as.cps_mspct</a>()</code>,
<code><a href="#topic+as.filter_mspct">as.filter_mspct</a>()</code>,
<code><a href="#topic+as.object_mspct">as.object_mspct</a>()</code>,
<code><a href="#topic+as.raw_mspct">as.raw_mspct</a>()</code>,
<code><a href="#topic+as.reflector_mspct">as.reflector_mspct</a>()</code>,
<code><a href="#topic+as.response_mspct">as.response_mspct</a>()</code>,
<code><a href="#topic+as.solute_mspct">as.solute_mspct</a>()</code>,
<code><a href="#topic+as.source_mspct">as.source_mspct</a>()</code>,
<code><a href="#topic+split2mspct">split2mspct</a>()</code>,
<code><a href="#topic+subset2mspct">subset2mspct</a>()</code>
</p>

<hr>
<h2 id='as.generic_spct'>Coerce to a spectrum</h2><span id='topic+as.generic_spct'></span><span id='topic+as.generic_spct.default'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.generic_spct(x, ...)

## Default S3 method:
as.generic_spct(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.generic_spct_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="as.generic_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to &quot;set&quot; functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>generic_spct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.generic_spct(default)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setGenericSpct">setGenericSpct</a></code>
</p>
<p>Other constructors of spectral objects: 
<code><a href="#topic+as.calibration_spct">as.calibration_spct</a>()</code>,
<code><a href="#topic+as.chroma_spct">as.chroma_spct</a>()</code>,
<code><a href="#topic+as.cps_spct">as.cps_spct</a>()</code>,
<code><a href="#topic+as.filter_spct">as.filter_spct</a>()</code>,
<code><a href="#topic+as.object_spct">as.object_spct</a>()</code>,
<code><a href="#topic+as.raw_spct">as.raw_spct</a>()</code>,
<code><a href="#topic+as.reflector_spct">as.reflector_spct</a>()</code>,
<code><a href="#topic+as.response_spct">as.response_spct</a>()</code>,
<code><a href="#topic+as.solute_spct">as.solute_spct</a>()</code>,
<code><a href="#topic+as.source_spct">as.source_spct</a>()</code>,
<code><a href="#topic+source_spct">source_spct</a>()</code>
</p>

<hr>
<h2 id='as.matrix-mspct'>Coerce a collection of spectra into a matrix</h2><span id='topic+as.matrix-mspct'></span><span id='topic+as.matrix.generic_mspct'></span><span id='topic+mspct2mat'></span>

<h3>Description</h3>

<p>Convert an object of class <code>generic_mspct</code> or a derived class into an R
matrix with wavelengths saved as an attribute and spectral data in rows or
columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_mspct'
as.matrix(x, spct.data.var, byrow = attr(x, "mspct.byrow"), ...)

mspct2mat(x, spct.data.var, byrow = attr(x, "mspct.byrow"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix-mspct_+3A_x">x</code></td>
<td>
<p>generic_mspct object.</p>
</td></tr>
<tr><td><code id="as.matrix-mspct_+3A_spct.data.var">spct.data.var</code></td>
<td>
<p>character The name of the variable containing the
spectral data.</p>
</td></tr>
<tr><td><code id="as.matrix-mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical. If FALSE (the default) the matrix is filled with the
spectra stored by columns, otherwise the matrix is filled by rows.</p>
</td></tr>
<tr><td><code id="as.matrix-mspct_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Warning!</h3>

<p>This conversion preserves the spectral data but discards
almost all the metadata contained in the spectral objects. In other words a
matrix created with this function cannot be used to recreate the original
object unless the same metadata is explicitly supplied when converting the
matrix into new collection of spectra.
</p>


<h3>Note</h3>

<p>Only collections of spectra containing spectra with exactly the same
<code>w.length</code> values can by converted. If needed, the spectra can be
re-expressed before attempting the conversion to a matrix.
</p>

<hr>
<h2 id='as.object_mspct'>Coerce to a collection-of-spectra</h2><span id='topic+as.object_mspct'></span><span id='topic+as.object_mspct.default'></span><span id='topic+as.object_mspct.data.frame'></span><span id='topic+as.object_mspct.object_spct'></span><span id='topic+as.object_mspct.list'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type
of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.object_mspct(x, ...)

## Default S3 method:
as.object_mspct(x, ...)

## S3 method for class 'data.frame'
as.object_mspct(
  x,
  Tfr.type = c("total", "internal"),
  Rfr.type = c("total", "specular"),
  strict.range = TRUE,
  ...
)

## S3 method for class 'object_spct'
as.object_mspct(x, ...)

## S3 method for class 'list'
as.object_mspct(
  x,
  Tfr.type = c("total", "internal"),
  Rfr.type = c("total", "specular"),
  strict.range = TRUE,
  ...,
  ncol = 1,
  byrow = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.object_mspct_+3A_x">x</code></td>
<td>
<p>a list of spectral objects or a list of objects such as data frames
that can be converted into spectral objects.</p>
</td></tr>
<tr><td><code id="as.object_mspct_+3A_...">...</code></td>
<td>
<p>passed to individual spectrum object constructor</p>
</td></tr>
<tr><td><code id="as.object_mspct_+3A_tfr.type">Tfr.type</code></td>
<td>
<p>a character string, either &quot;total&quot; or &quot;internal&quot;</p>
</td></tr>
<tr><td><code id="as.object_mspct_+3A_rfr.type">Rfr.type</code></td>
<td>
<p>a character string, either &quot;total&quot; or &quot;specular&quot;</p>
</td></tr>
<tr><td><code id="as.object_mspct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical Flag indicating how off-range values are handled</p>
</td></tr>
<tr><td><code id="as.object_mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="as.object_mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>object_mspct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.object_mspct(default)</code>: 
</p>
</li>
<li> <p><code>as.object_mspct(data.frame)</code>: 
</p>
</li>
<li> <p><code>as.object_mspct(object_spct)</code>: 
</p>
</li>
<li> <p><code>as.object_mspct(list)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.calibration_mspct">as.calibration_mspct</a>()</code>,
<code><a href="#topic+as.chroma_mspct">as.chroma_mspct</a>()</code>,
<code><a href="#topic+as.cps_mspct">as.cps_mspct</a>()</code>,
<code><a href="#topic+as.filter_mspct">as.filter_mspct</a>()</code>,
<code><a href="#topic+as.generic_mspct">as.generic_mspct</a>()</code>,
<code><a href="#topic+as.raw_mspct">as.raw_mspct</a>()</code>,
<code><a href="#topic+as.reflector_mspct">as.reflector_mspct</a>()</code>,
<code><a href="#topic+as.response_mspct">as.response_mspct</a>()</code>,
<code><a href="#topic+as.solute_mspct">as.solute_mspct</a>()</code>,
<code><a href="#topic+as.source_mspct">as.source_mspct</a>()</code>,
<code><a href="#topic+split2mspct">split2mspct</a>()</code>,
<code><a href="#topic+subset2mspct">subset2mspct</a>()</code>
</p>

<hr>
<h2 id='as.object_spct'>Coerce to a spectrum</h2><span id='topic+as.object_spct'></span><span id='topic+as.object_spct.default'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.object_spct(x, ...)

## Default S3 method:
as.object_spct(
  x,
  Tfr.type = c("total", "internal"),
  Rfr.type = c("total", "specular"),
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.object_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="as.object_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to &quot;set&quot; functions.</p>
</td></tr>
<tr><td><code id="as.object_spct_+3A_tfr.type">Tfr.type</code></td>
<td>
<p>a character string, either <code>"total"</code> or
<code>"internal"</code>.</p>
</td></tr>
<tr><td><code id="as.object_spct_+3A_rfr.type">Rfr.type</code></td>
<td>
<p>a character string, either <code>"total"</code> or
<code>"specular"</code>.</p>
</td></tr>
<tr><td><code id="as.object_spct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical Flag indicating whether off-range values result
in an error instead of a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>object_spct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.object_spct(default)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setGenericSpct">setGenericSpct</a></code>
</p>
<p>Other constructors of spectral objects: 
<code><a href="#topic+as.calibration_spct">as.calibration_spct</a>()</code>,
<code><a href="#topic+as.chroma_spct">as.chroma_spct</a>()</code>,
<code><a href="#topic+as.cps_spct">as.cps_spct</a>()</code>,
<code><a href="#topic+as.filter_spct">as.filter_spct</a>()</code>,
<code><a href="#topic+as.generic_spct">as.generic_spct</a>()</code>,
<code><a href="#topic+as.raw_spct">as.raw_spct</a>()</code>,
<code><a href="#topic+as.reflector_spct">as.reflector_spct</a>()</code>,
<code><a href="#topic+as.response_spct">as.response_spct</a>()</code>,
<code><a href="#topic+as.solute_spct">as.solute_spct</a>()</code>,
<code><a href="#topic+as.source_spct">as.source_spct</a>()</code>,
<code><a href="#topic+source_spct">source_spct</a>()</code>
</p>

<hr>
<h2 id='as.raw_mspct'>Coerce to a collection-of-spectra</h2><span id='topic+as.raw_mspct'></span><span id='topic+as.raw_mspct.default'></span><span id='topic+as.raw_mspct.data.frame'></span><span id='topic+as.raw_mspct.raw_spct'></span><span id='topic+as.raw_mspct.list'></span><span id='topic+as.raw_mspct.matrix'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type
of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.raw_mspct(x, ...)

## Default S3 method:
as.raw_mspct(x, ...)

## S3 method for class 'data.frame'
as.raw_mspct(x, ...)

## S3 method for class 'raw_spct'
as.raw_mspct(x, ...)

## S3 method for class 'list'
as.raw_mspct(x, ..., ncol = 1, byrow = FALSE)

## S3 method for class 'matrix'
as.raw_mspct(
  x,
  w.length,
  spct.data.var = "counts",
  multiplier = 1,
  byrow = NULL,
  spct.names = "spct_",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.raw_mspct_+3A_x">x</code></td>
<td>
<p>a list of spectral objects or a list of objects such as data frames
that can be converted into spectral objects.</p>
</td></tr>
<tr><td><code id="as.raw_mspct_+3A_...">...</code></td>
<td>
<p>passed to individual spectrum object constructor</p>
</td></tr>
<tr><td><code id="as.raw_mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="as.raw_mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
<tr><td><code id="as.raw_mspct_+3A_w.length">w.length</code></td>
<td>
<p>numeric A vector of wavelengthvalues sorted in strictly
ascending order (nm).</p>
</td></tr>
<tr><td><code id="as.raw_mspct_+3A_spct.data.var">spct.data.var</code></td>
<td>
<p>character The name of the variable that will contain the
spectral data. This indicates what physical quantity is stored in the
matrix and the units of expression used.</p>
</td></tr>
<tr><td><code id="as.raw_mspct_+3A_multiplier">multiplier</code></td>
<td>
<p>numeric A multiplier to be applied to the values in
<code>x</code> to do unit or scale conversion.</p>
</td></tr>
<tr><td><code id="as.raw_mspct_+3A_spct.names">spct.names</code></td>
<td>
<p>character Vector of names to be assigned to collection
members, either of length 1, or with length equal to the number of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>raw_mspct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.raw_mspct(default)</code>: 
</p>
</li>
<li> <p><code>as.raw_mspct(data.frame)</code>: 
</p>
</li>
<li> <p><code>as.raw_mspct(raw_spct)</code>: 
</p>
</li>
<li> <p><code>as.raw_mspct(list)</code>: 
</p>
</li>
<li> <p><code>as.raw_mspct(matrix)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>When <code>x</code> is a square matrix an explicit argument is needed for
<code>byrow</code> to indicate how data in <code>x</code> should be read. In every case
the length of the <code>w.length</code> vector must match one of the dimensions
of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.calibration_mspct">as.calibration_mspct</a>()</code>,
<code><a href="#topic+as.chroma_mspct">as.chroma_mspct</a>()</code>,
<code><a href="#topic+as.cps_mspct">as.cps_mspct</a>()</code>,
<code><a href="#topic+as.filter_mspct">as.filter_mspct</a>()</code>,
<code><a href="#topic+as.generic_mspct">as.generic_mspct</a>()</code>,
<code><a href="#topic+as.object_mspct">as.object_mspct</a>()</code>,
<code><a href="#topic+as.reflector_mspct">as.reflector_mspct</a>()</code>,
<code><a href="#topic+as.response_mspct">as.response_mspct</a>()</code>,
<code><a href="#topic+as.solute_mspct">as.solute_mspct</a>()</code>,
<code><a href="#topic+as.source_mspct">as.source_mspct</a>()</code>,
<code><a href="#topic+split2mspct">split2mspct</a>()</code>,
<code><a href="#topic+subset2mspct">subset2mspct</a>()</code>
</p>

<hr>
<h2 id='as.raw_spct'>Coerce to a spectrum</h2><span id='topic+as.raw_spct'></span><span id='topic+as.raw_spct.default'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.raw_spct(x, ...)

## Default S3 method:
as.raw_spct(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.raw_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="as.raw_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to &quot;set&quot; functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>raw_spct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.raw_spct(default)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setGenericSpct">setGenericSpct</a></code>
</p>
<p>Other constructors of spectral objects: 
<code><a href="#topic+as.calibration_spct">as.calibration_spct</a>()</code>,
<code><a href="#topic+as.chroma_spct">as.chroma_spct</a>()</code>,
<code><a href="#topic+as.cps_spct">as.cps_spct</a>()</code>,
<code><a href="#topic+as.filter_spct">as.filter_spct</a>()</code>,
<code><a href="#topic+as.generic_spct">as.generic_spct</a>()</code>,
<code><a href="#topic+as.object_spct">as.object_spct</a>()</code>,
<code><a href="#topic+as.reflector_spct">as.reflector_spct</a>()</code>,
<code><a href="#topic+as.response_spct">as.response_spct</a>()</code>,
<code><a href="#topic+as.solute_spct">as.solute_spct</a>()</code>,
<code><a href="#topic+as.source_spct">as.source_spct</a>()</code>,
<code><a href="#topic+source_spct">source_spct</a>()</code>
</p>

<hr>
<h2 id='as.reflector_mspct'>Coerce to a collection-of-spectra</h2><span id='topic+as.reflector_mspct'></span><span id='topic+as.reflector_mspct.default'></span><span id='topic+as.reflector_mspct.data.frame'></span><span id='topic+as.reflector_mspct.reflector_spct'></span><span id='topic+as.reflector_mspct.list'></span><span id='topic+as.reflector_mspct.matrix'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type
of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.reflector_mspct(x, ...)

## Default S3 method:
as.reflector_mspct(x, ...)

## S3 method for class 'data.frame'
as.reflector_mspct(
  x,
  Rfr.type = c("total", "specular"),
  strict.range = TRUE,
  ...
)

## S3 method for class 'reflector_spct'
as.reflector_mspct(x, ...)

## S3 method for class 'list'
as.reflector_mspct(
  x,
  Rfr.type = c("total", "specular"),
  strict.range = TRUE,
  ...,
  ncol = 1,
  byrow = FALSE
)

## S3 method for class 'matrix'
as.reflector_mspct(
  x,
  w.length,
  spct.data.var = "Rfr",
  multiplier = 1,
  byrow = NULL,
  spct.names = "spct_",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.reflector_mspct_+3A_x">x</code></td>
<td>
<p>a list of spectral objects or a list of objects such as data frames
that can be converted into spectral objects.</p>
</td></tr>
<tr><td><code id="as.reflector_mspct_+3A_...">...</code></td>
<td>
<p>passed to individual spectrum object constructor</p>
</td></tr>
<tr><td><code id="as.reflector_mspct_+3A_rfr.type">Rfr.type</code></td>
<td>
<p>a character string, either &quot;total&quot; or &quot;specular&quot;</p>
</td></tr>
<tr><td><code id="as.reflector_mspct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical Flag indicating how off-range values are handled</p>
</td></tr>
<tr><td><code id="as.reflector_mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="as.reflector_mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
<tr><td><code id="as.reflector_mspct_+3A_w.length">w.length</code></td>
<td>
<p>numeric A vector of wavelengthvalues sorted in strictly
ascending order (nm).</p>
</td></tr>
<tr><td><code id="as.reflector_mspct_+3A_spct.data.var">spct.data.var</code></td>
<td>
<p>character The name of the variable that will contain the
spectral data. This indicates what physical quantity is stored in the
matrix and the units of expression used.</p>
</td></tr>
<tr><td><code id="as.reflector_mspct_+3A_multiplier">multiplier</code></td>
<td>
<p>numeric A multiplier to be applied to the values in
<code>x</code> to do unit or scale conversion.</p>
</td></tr>
<tr><td><code id="as.reflector_mspct_+3A_spct.names">spct.names</code></td>
<td>
<p>character Vector of names to be assigned to collection
members, either of length 1, or with length equal to the number of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>reflector_mspct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.reflector_mspct(default)</code>: 
</p>
</li>
<li> <p><code>as.reflector_mspct(data.frame)</code>: 
</p>
</li>
<li> <p><code>as.reflector_mspct(reflector_spct)</code>: 
</p>
</li>
<li> <p><code>as.reflector_mspct(list)</code>: 
</p>
</li>
<li> <p><code>as.reflector_mspct(matrix)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>When <code>x</code> is a square matrix an explicit argument is needed for
<code>byrow</code> to indicate how data in <code>x</code> should be read. In every case
the length of the <code>w.length</code> vector must match one of the dimensions
of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.calibration_mspct">as.calibration_mspct</a>()</code>,
<code><a href="#topic+as.chroma_mspct">as.chroma_mspct</a>()</code>,
<code><a href="#topic+as.cps_mspct">as.cps_mspct</a>()</code>,
<code><a href="#topic+as.filter_mspct">as.filter_mspct</a>()</code>,
<code><a href="#topic+as.generic_mspct">as.generic_mspct</a>()</code>,
<code><a href="#topic+as.object_mspct">as.object_mspct</a>()</code>,
<code><a href="#topic+as.raw_mspct">as.raw_mspct</a>()</code>,
<code><a href="#topic+as.response_mspct">as.response_mspct</a>()</code>,
<code><a href="#topic+as.solute_mspct">as.solute_mspct</a>()</code>,
<code><a href="#topic+as.source_mspct">as.source_mspct</a>()</code>,
<code><a href="#topic+split2mspct">split2mspct</a>()</code>,
<code><a href="#topic+subset2mspct">subset2mspct</a>()</code>
</p>

<hr>
<h2 id='as.reflector_spct'>Coerce to a spectrum</h2><span id='topic+as.reflector_spct'></span><span id='topic+as.reflector_spct.default'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.reflector_spct(x, ...)

## Default S3 method:
as.reflector_spct(
  x,
  Rfr.type = c("total", "specular"),
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.reflector_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="as.reflector_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to &quot;set&quot; functions.</p>
</td></tr>
<tr><td><code id="as.reflector_spct_+3A_rfr.type">Rfr.type</code></td>
<td>
<p>a character string, either <code>"total"</code> or
<code>"specular"</code>.</p>
</td></tr>
<tr><td><code id="as.reflector_spct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical Flag indicating whether off-range values result
in an error instead of a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>reflector_spct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.reflector_spct(default)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setGenericSpct">setGenericSpct</a></code>
</p>
<p>Other constructors of spectral objects: 
<code><a href="#topic+as.calibration_spct">as.calibration_spct</a>()</code>,
<code><a href="#topic+as.chroma_spct">as.chroma_spct</a>()</code>,
<code><a href="#topic+as.cps_spct">as.cps_spct</a>()</code>,
<code><a href="#topic+as.filter_spct">as.filter_spct</a>()</code>,
<code><a href="#topic+as.generic_spct">as.generic_spct</a>()</code>,
<code><a href="#topic+as.object_spct">as.object_spct</a>()</code>,
<code><a href="#topic+as.raw_spct">as.raw_spct</a>()</code>,
<code><a href="#topic+as.response_spct">as.response_spct</a>()</code>,
<code><a href="#topic+as.solute_spct">as.solute_spct</a>()</code>,
<code><a href="#topic+as.source_spct">as.source_spct</a>()</code>,
<code><a href="#topic+source_spct">source_spct</a>()</code>
</p>

<hr>
<h2 id='as.response_mspct'>Coerce to a collection-of-spectra</h2><span id='topic+as.response_mspct'></span><span id='topic+as.response_mspct.default'></span><span id='topic+as.response_mspct.data.frame'></span><span id='topic+as.response_mspct.response_spct'></span><span id='topic+as.response_mspct.list'></span><span id='topic+as.response_mspct.matrix'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type
of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.response_mspct(x, ...)

## Default S3 method:
as.response_mspct(x, ...)

## S3 method for class 'data.frame'
as.response_mspct(x, time.unit = "second", ...)

## S3 method for class 'response_spct'
as.response_mspct(x, ...)

## S3 method for class 'list'
as.response_mspct(x, time.unit = "second", ..., ncol = 1, byrow = FALSE)

## S3 method for class 'matrix'
as.response_mspct(
  x,
  w.length,
  spct.data.var = "s.e.response",
  multiplier = 1,
  byrow = NULL,
  spct.names = "spct_",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.response_mspct_+3A_x">x</code></td>
<td>
<p>a list of spectral objects or a list of objects such as data frames
that can be converted into spectral objects.</p>
</td></tr>
<tr><td><code id="as.response_mspct_+3A_...">...</code></td>
<td>
<p>passed to individual spectrum object constructor</p>
</td></tr>
<tr><td><code id="as.response_mspct_+3A_time.unit">time.unit</code></td>
<td>
<p>character A string, &quot;second&quot;, &quot;day&quot; or &quot;exposure&quot;</p>
</td></tr>
<tr><td><code id="as.response_mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="as.response_mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
<tr><td><code id="as.response_mspct_+3A_w.length">w.length</code></td>
<td>
<p>numeric A vector of wavelengthvalues sorted in strictly
ascending order (nm).</p>
</td></tr>
<tr><td><code id="as.response_mspct_+3A_spct.data.var">spct.data.var</code></td>
<td>
<p>character The name of the variable that will contain the
spectral data. This indicates what physical quantity is stored in the
matrix and the units of expression used.</p>
</td></tr>
<tr><td><code id="as.response_mspct_+3A_multiplier">multiplier</code></td>
<td>
<p>numeric A multiplier to be applied to the values in
<code>x</code> to do unit or scale conversion.</p>
</td></tr>
<tr><td><code id="as.response_mspct_+3A_spct.names">spct.names</code></td>
<td>
<p>character Vector of names to be assigned to collection
members, either of length 1, or with length equal to the number of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>response_mspct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.response_mspct(default)</code>: 
</p>
</li>
<li> <p><code>as.response_mspct(data.frame)</code>: 
</p>
</li>
<li> <p><code>as.response_mspct(response_spct)</code>: 
</p>
</li>
<li> <p><code>as.response_mspct(list)</code>: 
</p>
</li>
<li> <p><code>as.response_mspct(matrix)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>When <code>x</code> is a square matrix an explicit argument is needed for
<code>byrow</code> to indicate how data in <code>x</code> should be read. In every case
the length of the <code>w.length</code> vector must match one of the dimensions
of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.calibration_mspct">as.calibration_mspct</a>()</code>,
<code><a href="#topic+as.chroma_mspct">as.chroma_mspct</a>()</code>,
<code><a href="#topic+as.cps_mspct">as.cps_mspct</a>()</code>,
<code><a href="#topic+as.filter_mspct">as.filter_mspct</a>()</code>,
<code><a href="#topic+as.generic_mspct">as.generic_mspct</a>()</code>,
<code><a href="#topic+as.object_mspct">as.object_mspct</a>()</code>,
<code><a href="#topic+as.raw_mspct">as.raw_mspct</a>()</code>,
<code><a href="#topic+as.reflector_mspct">as.reflector_mspct</a>()</code>,
<code><a href="#topic+as.solute_mspct">as.solute_mspct</a>()</code>,
<code><a href="#topic+as.source_mspct">as.source_mspct</a>()</code>,
<code><a href="#topic+split2mspct">split2mspct</a>()</code>,
<code><a href="#topic+subset2mspct">subset2mspct</a>()</code>
</p>

<hr>
<h2 id='as.response_spct'>Coerce to a spectrum</h2><span id='topic+as.response_spct'></span><span id='topic+as.response_spct.default'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.response_spct(x, ...)

## Default S3 method:
as.response_spct(x, time.unit = "second", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.response_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="as.response_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to &quot;set&quot; functions.</p>
</td></tr>
<tr><td><code id="as.response_spct_+3A_time.unit">time.unit</code></td>
<td>
<p>character string indicating the time unit used for spectral
irradiance or exposure (<code>"second"</code>, <code>"day"</code> or <code>"exposure"</code>)
or an object of class duration as defined in package lubridate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>response_spct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.response_spct(default)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setGenericSpct">setGenericSpct</a></code>
</p>
<p>Other constructors of spectral objects: 
<code><a href="#topic+as.calibration_spct">as.calibration_spct</a>()</code>,
<code><a href="#topic+as.chroma_spct">as.chroma_spct</a>()</code>,
<code><a href="#topic+as.cps_spct">as.cps_spct</a>()</code>,
<code><a href="#topic+as.filter_spct">as.filter_spct</a>()</code>,
<code><a href="#topic+as.generic_spct">as.generic_spct</a>()</code>,
<code><a href="#topic+as.object_spct">as.object_spct</a>()</code>,
<code><a href="#topic+as.raw_spct">as.raw_spct</a>()</code>,
<code><a href="#topic+as.reflector_spct">as.reflector_spct</a>()</code>,
<code><a href="#topic+as.solute_spct">as.solute_spct</a>()</code>,
<code><a href="#topic+as.source_spct">as.source_spct</a>()</code>,
<code><a href="#topic+source_spct">source_spct</a>()</code>
</p>

<hr>
<h2 id='as.solar_date'>Convert a solar_time object into solar_date object</h2><span id='topic+as.solar_date'></span>

<h3>Description</h3>

<p>Convert a solar_time object into solar_date object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.solar_date(x, time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.solar_date_+3A_x">x</code></td>
<td>
<p>solar_time object.</p>
</td></tr>
<tr><td><code id="as.solar_date_+3A_time">time</code></td>
<td>
<p>an R date time object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For method <code>as.solar_date()</code> a date-time object with the class attr
set to &quot;solar.time&quot;. This is needed only for unambiguous formatting and
printing.
</p>


<h3>See Also</h3>

<p>Other Local solar time functions: 
<code><a href="#topic+is.solar_time">is.solar_time</a>()</code>,
<code><a href="#topic+print.solar_time">print.solar_time</a>()</code>,
<code><a href="#topic+solar_time">solar_time</a>()</code>
</p>

<hr>
<h2 id='as.solute_mspct'>Coerce to a collection-of-spectra</h2><span id='topic+as.solute_mspct'></span><span id='topic+as.solute_mspct.default'></span><span id='topic+as.solute_mspct.data.frame'></span><span id='topic+as.solute_mspct.solute_spct'></span><span id='topic+as.solute_mspct.list'></span><span id='topic+as.solute_mspct.matrix'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type
of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.solute_mspct(x, ...)

## Default S3 method:
as.solute_mspct(x, ...)

## S3 method for class 'data.frame'
as.solute_mspct(
  x,
  K.type = c("attenuation", "absorption", "scattering"),
  strict.range = TRUE,
  ...
)

## S3 method for class 'solute_spct'
as.solute_mspct(x, ...)

## S3 method for class 'list'
as.solute_mspct(
  x,
  K.type = c("attenuation", "absorption", "scattering"),
  strict.range = TRUE,
  ...,
  ncol = 1,
  byrow = FALSE
)

## S3 method for class 'matrix'
as.solute_mspct(
  x,
  w.length,
  spct.data.var = "K.mole",
  multiplier = 1,
  byrow = NULL,
  spct.names = "spct_",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.solute_mspct_+3A_x">x</code></td>
<td>
<p>a list of spectral objects or a list of objects such as data frames
that can be converted into spectral objects.</p>
</td></tr>
<tr><td><code id="as.solute_mspct_+3A_...">...</code></td>
<td>
<p>passed to individual spectrum object constructor</p>
</td></tr>
<tr><td><code id="as.solute_mspct_+3A_k.type">K.type</code></td>
<td>
<p>a character string, either &quot;attenuation&quot;, &quot;absorption&quot; or
&quot;scattering&quot;</p>
</td></tr>
<tr><td><code id="as.solute_mspct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical Flag indicating how off-range values are handled</p>
</td></tr>
<tr><td><code id="as.solute_mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="as.solute_mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
<tr><td><code id="as.solute_mspct_+3A_w.length">w.length</code></td>
<td>
<p>numeric A vector of wavelength values sorted in strictly
ascending order (nm).</p>
</td></tr>
<tr><td><code id="as.solute_mspct_+3A_spct.data.var">spct.data.var</code></td>
<td>
<p>character The name of the variable that will contain the
spectral data. This indicates what physical quantity is stored in the
matrix and the units of expression used.</p>
</td></tr>
<tr><td><code id="as.solute_mspct_+3A_multiplier">multiplier</code></td>
<td>
<p>numeric A multiplier to be applied to the values in
<code>x</code> to do unit or scale conversion.</p>
</td></tr>
<tr><td><code id="as.solute_mspct_+3A_spct.names">spct.names</code></td>
<td>
<p>character Vector of names to be assigned to collection
members, either of length 1, or with length equal to the number of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>filter_mspct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.solute_mspct(default)</code>: 
</p>
</li>
<li> <p><code>as.solute_mspct(data.frame)</code>: 
</p>
</li>
<li> <p><code>as.solute_mspct(solute_spct)</code>: 
</p>
</li>
<li> <p><code>as.solute_mspct(list)</code>: 
</p>
</li>
<li> <p><code>as.solute_mspct(matrix)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>When <code>x</code> is a square matrix an explicit argument is needed for
<code>byrow</code> to indicate how data in <code>x</code> should be read. In every case
the length of the <code>w.length</code> vector must match one of the dimensions
of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.calibration_mspct">as.calibration_mspct</a>()</code>,
<code><a href="#topic+as.chroma_mspct">as.chroma_mspct</a>()</code>,
<code><a href="#topic+as.cps_mspct">as.cps_mspct</a>()</code>,
<code><a href="#topic+as.filter_mspct">as.filter_mspct</a>()</code>,
<code><a href="#topic+as.generic_mspct">as.generic_mspct</a>()</code>,
<code><a href="#topic+as.object_mspct">as.object_mspct</a>()</code>,
<code><a href="#topic+as.raw_mspct">as.raw_mspct</a>()</code>,
<code><a href="#topic+as.reflector_mspct">as.reflector_mspct</a>()</code>,
<code><a href="#topic+as.response_mspct">as.response_mspct</a>()</code>,
<code><a href="#topic+as.source_mspct">as.source_mspct</a>()</code>,
<code><a href="#topic+split2mspct">split2mspct</a>()</code>,
<code><a href="#topic+subset2mspct">subset2mspct</a>()</code>
</p>

<hr>
<h2 id='as.solute_spct'>Coerce to a solute spectrum</h2><span id='topic+as.solute_spct'></span><span id='topic+as.solute_spct.default'></span><span id='topic+as.solute_spct.filter_spct'></span>

<h3>Description</h3>

<p>Return a possibly modified copy of an R object with its class set to
<code>solute_spct</code> (a solute spectrum). In the case of conversion from a
<code>filter_spct</code> object, compute spectral molar attenuation  based on
additional input from user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.solute_spct(x, ...)

## Default S3 method:
as.solute_spct(
  x,
  K.type = c("attenuation", "absorption", "scattering"),
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  ...
)

## S3 method for class 'filter_spct'
as.solute_spct(
  x,
  K.type = c("attenuation", "absorption", "scattering"),
  name = NA_character_,
  mass = NA_character_,
  formula = NULL,
  structure = grDevices::as.raster(matrix()),
  ID = NA_character_,
  solvent.name = NA_character_,
  solvent.ID = NA_character_,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  comment = NULL,
  molar.concentration = NULL,
  mass.concentration = NULL,
  path.length = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.solute_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="as.solute_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to &quot;set&quot; functions.</p>
</td></tr>
<tr><td><code id="as.solute_spct_+3A_k.type">K.type</code></td>
<td>
<p>a character string, one of <code>"attenuation"</code>,
<code>"absorption"</code> or <code>"scattering"</code>.</p>
</td></tr>
<tr><td><code id="as.solute_spct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical Flag indicating whether off-range values result
in an error instead of a warning.</p>
</td></tr>
<tr><td><code id="as.solute_spct_+3A_name">name</code>, <code id="as.solute_spct_+3A_solvent.name">solvent.name</code></td>
<td>
<p>character The names of the substance and of the
solvent. A named character vector, with member names such as &quot;IUPAC&quot; for
the authority.</p>
</td></tr>
<tr><td><code id="as.solute_spct_+3A_mass">mass</code></td>
<td>
<p>numeric The mass in Dalton (Da = g/mol).</p>
</td></tr>
<tr><td><code id="as.solute_spct_+3A_formula">formula</code></td>
<td>
<p>character The molecular formula.</p>
</td></tr>
<tr><td><code id="as.solute_spct_+3A_structure">structure</code></td>
<td>
<p>raster A bitmap of the structure.</p>
</td></tr>
<tr><td><code id="as.solute_spct_+3A_id">ID</code>, <code id="as.solute_spct_+3A_solvent.id">solvent.ID</code></td>
<td>
<p>character The IDs of the substance and of the solvent. A
named character vector, with member names such as &quot;ChemSpider&quot; or &quot;PubChen&quot;
for the authority.</p>
</td></tr>
<tr><td><code id="as.solute_spct_+3A_comment">comment</code></td>
<td>
<p>character A string to be added as a comment attribute to the
object created. If not supplied, the comment will be copied from <code>x</code>.</p>
</td></tr>
<tr><td><code id="as.solute_spct_+3A_molar.concentration">molar.concentration</code>, <code id="as.solute_spct_+3A_mass.concentration">mass.concentration</code></td>
<td>
<p>numeric Concentration to be
used to compute transmittance of the solute in solution [<code class="reqn">mol\,m^{-3} =
mmol\,dm^{-3}</code> or <code class="reqn">kg\,m^{-3} = g\,dm^{-3}</code>, respectively].</p>
</td></tr>
<tr><td><code id="as.solute_spct_+3A_path.length">path.length</code></td>
<td>
<p>numeric The length of the light path (<code class="reqn">m</code>) used to
compute transmittance of the solute in a solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>solute_spct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.solute_spct(default)</code>: 
</p>
</li>
<li> <p><code>as.solute_spct(filter_spct)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setSoluteSpct">setSoluteSpct</a></code>
</p>
<p>Other constructors of spectral objects: 
<code><a href="#topic+as.calibration_spct">as.calibration_spct</a>()</code>,
<code><a href="#topic+as.chroma_spct">as.chroma_spct</a>()</code>,
<code><a href="#topic+as.cps_spct">as.cps_spct</a>()</code>,
<code><a href="#topic+as.filter_spct">as.filter_spct</a>()</code>,
<code><a href="#topic+as.generic_spct">as.generic_spct</a>()</code>,
<code><a href="#topic+as.object_spct">as.object_spct</a>()</code>,
<code><a href="#topic+as.raw_spct">as.raw_spct</a>()</code>,
<code><a href="#topic+as.reflector_spct">as.reflector_spct</a>()</code>,
<code><a href="#topic+as.response_spct">as.response_spct</a>()</code>,
<code><a href="#topic+as.source_spct">as.source_spct</a>()</code>,
<code><a href="#topic+source_spct">source_spct</a>()</code>
</p>

<hr>
<h2 id='as.source_mspct'>Coerce to a collection-of-spectra</h2><span id='topic+as.source_mspct'></span><span id='topic+as.source_mspct.default'></span><span id='topic+as.source_mspct.data.frame'></span><span id='topic+as.source_mspct.source_spct'></span><span id='topic+as.source_mspct.list'></span><span id='topic+as.source_mspct.matrix'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type
of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.source_mspct(x, ...)

## Default S3 method:
as.source_mspct(x, ...)

## S3 method for class 'data.frame'
as.source_mspct(
  x,
  time.unit = c("second", "day", "exposure"),
  bswf.used = c("none", "unknown"),
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  ...
)

## S3 method for class 'source_spct'
as.source_mspct(x, ...)

## S3 method for class 'list'
as.source_mspct(
  x,
  time.unit = c("second", "day", "exposure"),
  bswf.used = c("none", "unknown"),
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  ...,
  ncol = 1,
  byrow = FALSE
)

## S3 method for class 'matrix'
as.source_mspct(
  x,
  w.length,
  spct.data.var = "s.e.irrad",
  multiplier = 1,
  byrow = NULL,
  spct.names = "spct_",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.source_mspct_+3A_x">x</code></td>
<td>
<p>a list of spectral objects or a list of objects such as data frames
that can be converted into spectral objects.</p>
</td></tr>
<tr><td><code id="as.source_mspct_+3A_...">...</code></td>
<td>
<p>passed to individual spectrum object constructor</p>
</td></tr>
<tr><td><code id="as.source_mspct_+3A_time.unit">time.unit</code></td>
<td>
<p>character A string, &quot;second&quot;, &quot;day&quot; or &quot;exposure&quot;</p>
</td></tr>
<tr><td><code id="as.source_mspct_+3A_bswf.used">bswf.used</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="as.source_mspct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical Flag indicating how off-range values are handled</p>
</td></tr>
<tr><td><code id="as.source_mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="as.source_mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
<tr><td><code id="as.source_mspct_+3A_w.length">w.length</code></td>
<td>
<p>numeric A vector of wavelengthvalues sorted in strictly
ascending order (nm).</p>
</td></tr>
<tr><td><code id="as.source_mspct_+3A_spct.data.var">spct.data.var</code></td>
<td>
<p>character The name of the variable that will contain the
spectral data. This indicates what physical quantity is stored in the
matrix and the units of expression used.</p>
</td></tr>
<tr><td><code id="as.source_mspct_+3A_multiplier">multiplier</code></td>
<td>
<p>numeric A multiplier to be applied to the values in
<code>x</code> to do unit or scale conversion.</p>
</td></tr>
<tr><td><code id="as.source_mspct_+3A_spct.names">spct.names</code></td>
<td>
<p>character Vector of names to be assigned to collection
members, either of length 1, or with length equal to the number of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>source_mspct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.source_mspct(default)</code>: 
</p>
</li>
<li> <p><code>as.source_mspct(data.frame)</code>: 
</p>
</li>
<li> <p><code>as.source_mspct(source_spct)</code>: 
</p>
</li>
<li> <p><code>as.source_mspct(list)</code>: 
</p>
</li>
<li> <p><code>as.source_mspct(matrix)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>When <code>x</code> is a square matrix an explicit argument is needed for
<code>byrow</code> to indicate how data in <code>x</code> should be read. In every case
the length of the <code>w.length</code> vector must match one of the dimensions
of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.calibration_mspct">as.calibration_mspct</a>()</code>,
<code><a href="#topic+as.chroma_mspct">as.chroma_mspct</a>()</code>,
<code><a href="#topic+as.cps_mspct">as.cps_mspct</a>()</code>,
<code><a href="#topic+as.filter_mspct">as.filter_mspct</a>()</code>,
<code><a href="#topic+as.generic_mspct">as.generic_mspct</a>()</code>,
<code><a href="#topic+as.object_mspct">as.object_mspct</a>()</code>,
<code><a href="#topic+as.raw_mspct">as.raw_mspct</a>()</code>,
<code><a href="#topic+as.reflector_mspct">as.reflector_mspct</a>()</code>,
<code><a href="#topic+as.response_mspct">as.response_mspct</a>()</code>,
<code><a href="#topic+as.solute_mspct">as.solute_mspct</a>()</code>,
<code><a href="#topic+split2mspct">split2mspct</a>()</code>,
<code><a href="#topic+subset2mspct">subset2mspct</a>()</code>
</p>

<hr>
<h2 id='as.source_spct'>Coerce to a spectrum</h2><span id='topic+as.source_spct'></span><span id='topic+as.source_spct.default'></span>

<h3>Description</h3>

<p>Return a copy of an R object with its class set to a given type of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.source_spct(x, ...)

## Default S3 method:
as.source_spct(
  x,
  time.unit = c("second", "day", "exposure"),
  bswf.used = c("none", "unknown"),
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.source_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="as.source_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to &quot;set&quot; functions.</p>
</td></tr>
<tr><td><code id="as.source_spct_+3A_time.unit">time.unit</code></td>
<td>
<p>character string indicating the time unit used for spectral
irradiance or exposure (<code>"second"</code>, <code>"day"</code> or <code>"exposure"</code>)
or an object of class duration as defined in package lubridate.</p>
</td></tr>
<tr><td><code id="as.source_spct_+3A_bswf.used">bswf.used</code></td>
<td>
<p>character A string indicating the BSWF used, if any, for
spectral effective irradiance or exposure (<code>"none"</code> or the name of the
BSWF).</p>
</td></tr>
<tr><td><code id="as.source_spct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical Flag indicating whether off-range values result
in an error instead of a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> converted into a <code>source_spct</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.source_spct(default)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+setGenericSpct">setGenericSpct</a></code>
</p>
<p>Other constructors of spectral objects: 
<code><a href="#topic+as.calibration_spct">as.calibration_spct</a>()</code>,
<code><a href="#topic+as.chroma_spct">as.chroma_spct</a>()</code>,
<code><a href="#topic+as.cps_spct">as.cps_spct</a>()</code>,
<code><a href="#topic+as.filter_spct">as.filter_spct</a>()</code>,
<code><a href="#topic+as.generic_spct">as.generic_spct</a>()</code>,
<code><a href="#topic+as.object_spct">as.object_spct</a>()</code>,
<code><a href="#topic+as.raw_spct">as.raw_spct</a>()</code>,
<code><a href="#topic+as.reflector_spct">as.reflector_spct</a>()</code>,
<code><a href="#topic+as.response_spct">as.response_spct</a>()</code>,
<code><a href="#topic+as.solute_spct">as.solute_spct</a>()</code>,
<code><a href="#topic+source_spct">source_spct</a>()</code>
</p>

<hr>
<h2 id='auto_hinges'>Guess whether insertion of hinges is needed or not</h2><span id='topic+auto_hinges'></span>

<h3>Description</h3>

<p>Assess from wavelength vector whether insertion of hinges before further
calculations is needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_hinges(w.length, step.limit = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_hinges_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths (nm).</p>
</td></tr>
<tr><td><code id="auto_hinges_+3A_step.limit">step.limit</code></td>
<td>
<p>numeric value (nm) for step, so that larger wavelength
steps trigger insertion of hinges before computations on spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value, TRUE if insertion of hinges is deemed necessary.
</p>

<hr>
<h2 id='average_spct'>Average spectral data.</h2><span id='topic+average_spct'></span>

<h3>Description</h3>

<p>This function gives the result of integrating spectral data over
wavelengths and dividing the result by the spread or span of the
wavelengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_spct(spct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_spct_+3A_spct">spct</code></td>
<td>
<p>generic_spct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One or more numeric values with no change in scale factor: e.g. [W
m-2 nm-1] -&gt; [W m-2 nm-1]. Each value in the returned vector corresponds to a
variable in the spectral object, except for wavelength.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
average_spct(sun.spct)

</code></pre>

<hr>
<h2 id='beesxyzCMF.spct'>Honeybee xyz chromaticity colour matching function data</h2><span id='topic+beesxyzCMF.spct'></span>

<h3>Description</h3>

<p>A dataset containing wavelengths at a 5 nm interval (300 nm to
700 nm) and the corresponding x, y, and z chromaticity coordinates.
Original data from XXX.
</p>
<p>A chroma_spct object with variables as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beesxyzCMF.spct
</code></pre>


<h3>Format</h3>

<p>A data frame with 81 rows and 4 variables
</p>


<h3>Details</h3>


<ul>
<li><p> w.length (nm)
</p>
</li>
<li><p> x
</p>
</li>
<li><p> y
</p>
</li>
<li><p> z </p>
</li></ul>



<h3>See Also</h3>

<p>Other Visual response data examples: 
<code><a href="#topic+ciev10.spct">ciev10.spct</a></code>,
<code><a href="#topic+ciev2.spct">ciev2.spct</a></code>,
<code><a href="#topic+ciexyzCC10.spct">ciexyzCC10.spct</a></code>,
<code><a href="#topic+ciexyzCC2.spct">ciexyzCC2.spct</a></code>,
<code><a href="#topic+ciexyzCMF10.spct">ciexyzCMF10.spct</a></code>,
<code><a href="#topic+ciexyzCMF2.spct">ciexyzCMF2.spct</a></code>,
<code><a href="#topic+cone_fundamentals10.spct">cone_fundamentals10.spct</a></code>
</p>

<hr>
<h2 id='black_body.spct'>Theoretical optical bodies</h2><span id='topic+black_body.spct'></span><span id='topic+white_body.spct'></span><span id='topic+clear_body.spct'></span>

<h3>Description</h3>

<p>Datasets for a hypothetical objects with transmittance 0/1
(0%), reflectance 0/1 (0%), with transmittance 0/1
(0%), reflectance 1/1 (100%), and with with transmittance 1/1
(100%), reflectance 0/1 (0%).
</p>


<h3>Format</h3>

<p>A <code>object_spct</code> object with 4 rows and 3 variables
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm) </p>
</li>
<li><p> Tfr (0..1) </p>
</li>
<li><p> Rfr (0..1) </p>
</li></ul>



<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>

<hr>
<h2 id='c'>Combine collections of spectra</h2><span id='topic+c'></span><span id='topic+c.generic_mspct'></span>

<h3>Description</h3>

<p>Combine two or more generic_mspct objects into a single object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_mspct'
c(..., recursive = FALSE, ncol = 1, byrow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_+3A_...">...</code></td>
<td>
<p>one or more generic_mspct objects to combine.</p>
</td></tr>
<tr><td><code id="c_+3A_recursive">recursive</code></td>
<td>
<p>logical ignored as nesting of collections of spectra is
not supported.</p>
</td></tr>
<tr><td><code id="c_+3A_ncol">ncol</code></td>
<td>
<p>numeric Virtual number of columns</p>
</td></tr>
<tr><td><code id="c_+3A_byrow">byrow</code></td>
<td>
<p>logical When object has two dimensions, how to map member
objects to columns and rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A collection of spectra object belonging to the most derived class
shared among the combined objects.
</p>

<hr>
<h2 id='calc_multipliers'>Spectral weights</h2><span id='topic+calc_multipliers'></span>

<h3>Description</h3>

<p>Calculate multipliers for selecting a range of wavelengths and optionally
applying a biological spectral weighting function (BSWF) and wavelength
normalization. This function returns numeric multipliers that can be used to
select a waveband and apply a weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_multipliers(
  w.length,
  w.band,
  unit.out = "energy",
  unit.in = "energy",
  use.cached.mult = FALSE,
  fill = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_multipliers_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths (nm).</p>
</td></tr>
<tr><td><code id="calc_multipliers_+3A_w.band">w.band</code></td>
<td>
<p>waveband object.</p>
</td></tr>
<tr><td><code id="calc_multipliers_+3A_unit.out">unit.out</code></td>
<td>
<p>character A string: &quot;photon&quot; or &quot;energy&quot;, default is &quot;energy&quot;.</p>
</td></tr>
<tr><td><code id="calc_multipliers_+3A_unit.in">unit.in</code></td>
<td>
<p>character A string: &quot;photon&quot; or &quot;energy&quot;, default is &quot;energy&quot;.</p>
</td></tr>
<tr><td><code id="calc_multipliers_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag indicating whether multiplier values
should be cached between calls.</p>
</td></tr>
<tr><td><code id="calc_multipliers_+3A_fill">fill</code></td>
<td>
<p>numeric If <code>fill = NA</code> then values returned for wavelengths outside
the range of the waveband are set to <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of multipliers of the same length as <code>w.length</code>.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data, calc_multipliers(w.length, new_waveband(400,700),"photon"))
with(sun.data, calc_multipliers(w.length, new_waveband(400,700),"photon"), use.cached.mult = TRUE)

</code></pre>

<hr>
<h2 id='calc_source_output'>Scaled and/or interpolated light-source spectral output</h2><span id='topic+calc_source_output'></span>

<h3>Description</h3>

<p>Values calculated by interpolation from user-supplied spectral emission data
or by name for light source data included in the packages photobiologySun,
photobiologyLamps, or photobiologyLEDs, optionally re-scaling the spectral
data values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_source_output(
  w.length.out,
  w.length.in,
  s.irrad.in,
  unit.in = "energy",
  scaled = NULL,
  fill = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_source_output_+3A_w.length.out">w.length.out</code></td>
<td>
<p>numeric vector of wavelengths (nm) for output.</p>
</td></tr>
<tr><td><code id="calc_source_output_+3A_w.length.in">w.length.in</code></td>
<td>
<p>numeric vector of wavelengths (nm) for input.</p>
</td></tr>
<tr><td><code id="calc_source_output_+3A_s.irrad.in">s.irrad.in</code></td>
<td>
<p>numeric vector of spectral transmittance value (fractions
or percent).</p>
</td></tr>
<tr><td><code id="calc_source_output_+3A_unit.in">unit.in</code></td>
<td>
<p>a character string &quot;energy&quot; or &quot;photon&quot;.</p>
</td></tr>
<tr><td><code id="calc_source_output_+3A_scaled">scaled</code></td>
<td>
<p>NULL, &quot;peak&quot;, &quot;area&quot;; div ignored if !is.null(scaled).</p>
</td></tr>
<tr><td><code id="calc_source_output_+3A_fill">fill</code></td>
<td>
<p>if NA, no extrapolation is done, and NA is returned for
wavelengths outside the range of the input. If NULL then the tails are
deleted. If 0 then the tails are set to zero.</p>
</td></tr>
<tr><td><code id="calc_source_output_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>spline</code> if called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a source_spct with three numeric vectors with wavelength values
(w.length), scaled and interpolated spectral energy irradiance (s.e.irrad),
scaled and interpolated spectral photon irradiance values (s.q.irrad).
</p>


<h3>Note</h3>

<p>This is a convenience function that adds no new functionality but makes
it a little easier to plot lamp spectral emission data consistently. It
automates interpolation, extrapolation/trimming and scaling.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
with(sun.data,
     calc_source_output(290:1100,
                        w.length.in = w.length,
                        s.irrad.in = s.e.irrad)
    )

</code></pre>

<hr>
<h2 id='calendar_change'>Solar astronomy using Meeus' algorithm</h2><span id='topic+calendar_change'></span><span id='topic+julian_day'></span><span id='topic+julian_day_fast'></span><span id='topic+julian_century'></span><span id='topic+geom_mean_lon_sun'></span><span id='topic+geom_mean_anom_sun'></span><span id='topic+eccent_earth_orbit'></span><span id='topic+sun_eq_of_ctr'></span><span id='topic+sun_rad_vector'></span><span id='topic+sun_app_lon'></span><span id='topic+mean_obliq_eclip'></span><span id='topic+obliq_corr'></span><span id='topic+sun_rt_ascen'></span><span id='topic+sun_decline'></span><span id='topic+var_y'></span><span id='topic+eq_of_time'></span><span id='topic+ha_sunrise'></span><span id='topic+solar_noon'></span><span id='topic+sunrise'></span><span id='topic+sunset'></span><span id='topic+sunlight_duration'></span><span id='topic+solar_datetime'></span><span id='topic+solar_tod'></span><span id='topic+hour_angle'></span><span id='topic+zenith_angle'></span><span id='topic+elevation_angle'></span><span id='topic+atm_refraction_approx'></span><span id='topic+azimuth_angle'></span>

<h3>Description</h3>

<p>The exact julian day computation is adapted from ode::julianDay() and tested
againts test cases in Redas and Andreas (2008, table A4.1) for validity up
to year 4712 BC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calendar_change

julian_day(time)

julian_day_fast(time)

julian_century(time)

geom_mean_lon_sun(x)

geom_mean_anom_sun(x)

eccent_earth_orbit(x)

sun_eq_of_ctr(x, anom)

sun_rad_vector(eccent, anom)

sun_app_lon(x, lon)

mean_obliq_eclip(x)

obliq_corr(x, eclip)

sun_rt_ascen(app.lon, obliq.corr)

sun_decline(app.lon, obliq.corr)

var_y(obliq.corr)

eq_of_time(mean.lon, eccent.earth, anom.mean, var.y)

ha_sunrise(lat, decline, nag = 0)

solar_noon(lon, eq.of.time)

sunrise(noon, ha.sunrise)

sunset(noon, ha.sunrise)

sunlight_duration(ha.sunrise, unit.out = "hours")

solar_datetime(time, lat, lon, eq.of.time)

solar_tod(time, lat, lon, eq.of.time)

hour_angle(solar.time)

zenith_angle(lat, hour.angle, decline)

elevation_angle(lat, hour.angle, decline)

atm_refraction_approx(elevation.angle)

azimuth_angle(lat, hour.angle, zenith.angle, decline)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calendar_change_+3A_time">time</code></td>
<td>
<p>dateTime</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_x">x</code></td>
<td>
<p>numeric Julian century</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_anom">anom</code></td>
<td>
<p>numeric Solar anomaly in degrees</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_eccent">eccent</code></td>
<td>
<p>numeric Eccentricity of Earth orbit</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_eclip">eclip</code></td>
<td>
<p>numeric Ecliptic</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_app.lon">app.lon</code>, <code id="calendar_change_+3A_obliq.corr">obliq.corr</code>, <code id="calendar_change_+3A_mean.lon">mean.lon</code>, <code id="calendar_change_+3A_nag">nag</code>, <code id="calendar_change_+3A_decline">decline</code></td>
<td>
<p>numeric Angles in degrees</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_lat">lat</code>, <code id="calendar_change_+3A_lon">lon</code></td>
<td>
<p>numeric Geographic coordinates in degrees</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_eq.of.time">eq.of.time</code>, <code id="calendar_change_+3A_ha.sunrise">ha.sunrise</code>, <code id="calendar_change_+3A_noon">noon</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_zenith.angle">zenith.angle</code>, <code id="calendar_change_+3A_elevation.angle">elevation.angle</code>, <code id="calendar_change_+3A_hour.angle">hour.angle</code></td>
<td>
<p>numeric Angles in degrees</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>POSIXct</code> (inherits from <code>POSIXt</code>) of length 1.
</p>


<h3>Details</h3>

<p>Low level functions based on NOAA's Excel worksheet
</p>


<h3>Value</h3>

<p>datetime
</p>
<p>numeric
</p>

<hr>
<h2 id='ccd.spct'>Spectral response of a back-thinned CCD image sensor.</h2><span id='topic+ccd.spct'></span>

<h3>Description</h3>

<p>A dataset containing wavelengths at a 1 nm interval and
spectral response as quantum efficiency for CCD sensor type
S11071/S10420 from Hamamatsu (measured without a quartz window). These
vectors are frequently used as sensors in high-UV-sensitivity vector
spectrometers. Data digitized from manufacturer's data sheet.
The original data is expressed as percent quantum efficiency with a value
of 77% at the peak. The data have been re-expressed as fractions of one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccd.spct
</code></pre>


<h3>Format</h3>

<p>A <code>response_spct</code> object with 186 rows and 2 variables
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm). </p>
</li>
<li><p> s.q.response
(fractional quantum efficiency)  </p>
</li></ul>



<h3>References</h3>

<p>Hamamatsu (2014) Datasheet: CCD Image Sensors S11071/S10420-01 Series.
Hamamatsu Photonics KK, Hamamatsu, City.
http://www.hamamatsu.com/jp/en/S11071-1004.html.
Visited 2017-12-15.
</p>


<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ccd.spct

</code></pre>

<hr>
<h2 id='check_and_rename_vars'>check and rename variables</h2><span id='topic+check_and_rename_vars'></span>

<h3>Description</h3>

<p>check and rename variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_and_rename_vars(
  x,
  target.var,
  alternative.vars,
  multiplier,
  required = FALSE,
  fill = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_and_rename_vars_+3A_x">x</code></td>
<td>
<p>data frame or equivalent R object.</p>
</td></tr>
<tr><td><code id="check_and_rename_vars_+3A_target.var">target.var</code></td>
<td>
<p>character vector of length one, with the name of the
target variable.</p>
</td></tr>
<tr><td><code id="check_and_rename_vars_+3A_alternative.vars">alternative.vars</code></td>
<td>
<p>character vector of any length, with the names of the
of alternative variables that could replace the target.</p>
</td></tr>
<tr><td><code id="check_and_rename_vars_+3A_multiplier">multiplier</code></td>
<td>
<p>numeric vector with the multipliers to apply to the
alternative variables.</p>
</td></tr>
<tr><td><code id="check_and_rename_vars_+3A_required">required</code></td>
<td>
<p>logical Indicating whether an error should be triggered if
no variable is found.</p>
</td></tr>
<tr><td><code id="check_and_rename_vars_+3A_fill">fill</code></td>
<td>
<p>if <code>required = TRUE</code> and <code>fill</code> different from
<code>NULL</code> the value is used to fill the target variable if it and
all alternative variables are missing.</p>
</td></tr>
</table>

<hr>
<h2 id='check_spct'>Check validity of spectral objects</h2><span id='topic+check_spct'></span><span id='topic+check_spct.default'></span><span id='topic+check_spct.generic_spct'></span><span id='topic+check_spct.calibration_spct'></span><span id='topic+check_spct.raw_spct'></span><span id='topic+check_spct.cps_spct'></span><span id='topic+check_spct.filter_spct'></span><span id='topic+check_spct.solute_spct'></span><span id='topic+check_spct.reflector_spct'></span><span id='topic+check_spct.object_spct'></span><span id='topic+check_spct.response_spct'></span><span id='topic+check_spct.source_spct'></span><span id='topic+check_spct.chroma_spct'></span>

<h3>Description</h3>

<p>Check that an R object contains the expected data members.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_spct(x, byref, strict.range, force = FALSE, ...)

## Default S3 method:
check_spct(x, byref = FALSE, strict.range = NA, force = FALSE, ...)

## S3 method for class 'generic_spct'
check_spct(
  x,
  byref = TRUE,
  strict.range = NA,
  force = FALSE,
  multiple.wl = getMultipleWl(x),
  ...
)

## S3 method for class 'calibration_spct'
check_spct(
  x,
  byref = TRUE,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  force = FALSE,
  multiple.wl = getMultipleWl(x),
  ...
)

## S3 method for class 'raw_spct'
check_spct(
  x,
  byref = TRUE,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  force = FALSE,
  multiple.wl = getMultipleWl(x),
  ...
)

## S3 method for class 'cps_spct'
check_spct(
  x,
  byref = TRUE,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  force = FALSE,
  multiple.wl = getMultipleWl(x),
  ...
)

## S3 method for class 'filter_spct'
check_spct(
  x,
  byref = TRUE,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  force = FALSE,
  multiple.wl = getMultipleWl(x),
  ...
)

## S3 method for class 'solute_spct'
check_spct(
  x,
  byref = TRUE,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  force = FALSE,
  multiple.wl = getMultipleWl(x),
  ...
)

## S3 method for class 'reflector_spct'
check_spct(
  x,
  byref = TRUE,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  force = FALSE,
  multiple.wl = getMultipleWl(x),
  ...
)

## S3 method for class 'object_spct'
check_spct(
  x,
  byref = TRUE,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  force = FALSE,
  multiple.wl = getMultipleWl(x),
  ...
)

## S3 method for class 'response_spct'
check_spct(
  x,
  byref = TRUE,
  strict.range = NA,
  force = FALSE,
  multiple.wl = getMultipleWl(x),
  ...
)

## S3 method for class 'source_spct'
check_spct(
  x,
  byref = TRUE,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  force = FALSE,
  multiple.wl = getMultipleWl(x),
  ...
)

## S3 method for class 'chroma_spct'
check_spct(
  x,
  byref = TRUE,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  force = FALSE,
  multiple.wl = getMultipleWl(x),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_spct_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
<tr><td><code id="check_spct_+3A_byref">byref</code></td>
<td>
<p>logical indicating if new object will be created by reference or
by copy of <code>x</code></p>
</td></tr>
<tr><td><code id="check_spct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical indicating whether off-range values result in an
error instead of a warning, <code>NA</code> disables the test.</p>
</td></tr>
<tr><td><code id="check_spct_+3A_force">force</code></td>
<td>
<p>logical If <code>TRUE</code> check is done even if checks are
disabled.</p>
</td></tr>
<tr><td><code id="check_spct_+3A_...">...</code></td>
<td>
<p>additional param possible in derived methods</p>
</td></tr>
<tr><td><code id="check_spct_+3A_multiple.wl">multiple.wl</code></td>
<td>
<p>numeric Maximum number of repeated w.length entries with
same value.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>check_spct(default)</code>: Default for generic function.
</p>
</li>
<li> <p><code>check_spct(generic_spct)</code>: Specialization for generic_spct.
</p>
</li>
<li> <p><code>check_spct(calibration_spct)</code>: Specialization for calibration_spct.
</p>
</li>
<li> <p><code>check_spct(raw_spct)</code>: Specialization for raw_spct.
</p>
</li>
<li> <p><code>check_spct(cps_spct)</code>: Specialization for cps_spct.
</p>
</li>
<li> <p><code>check_spct(filter_spct)</code>: Specialization for filter_spct.
</p>
</li>
<li> <p><code>check_spct(solute_spct)</code>: Specialization for solute_spct.
</p>
</li>
<li> <p><code>check_spct(reflector_spct)</code>: Specialization for reflector_spct.
</p>
</li>
<li> <p><code>check_spct(object_spct)</code>: Specialization for object_spct.
</p>
</li>
<li> <p><code>check_spct(response_spct)</code>: Specialization for response_spct.
</p>
</li>
<li> <p><code>check_spct(source_spct)</code>: Specialization for source_spct.
</p>
</li>
<li> <p><code>check_spct(chroma_spct)</code>: Specialization for chroma_spct.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other data validity check functions: 
<code><a href="#topic+check_spectrum">check_spectrum</a>()</code>,
<code><a href="#topic+check_w.length">check_w.length</a>()</code>,
<code><a href="#topic+enable_check_spct">enable_check_spct</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_spct(sun.spct)

check_spct(sun.spct)
# try(check_spct(-sun.spct))
# try(check_spct((sun.spct[1, "w.length"] &lt;- 1000)))

</code></pre>

<hr>
<h2 id='check_spectrum'>Sanity check a spectrum</h2><span id='topic+check_spectrum'></span>

<h3>Description</h3>

<p>Checks spectral irradiance data in <code>numeric</code> vectors for
compliance with assumptions used in calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_spectrum(w.length, s.irrad)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_spectrum_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths [<code class="reqn">nm</code>].</p>
</td></tr>
<tr><td><code id="check_spectrum_+3A_s.irrad">s.irrad</code></td>
<td>
<p>numeric Corresponding vector of spectral (energy) irradiances
[<code class="reqn">W\,m^{-2}\,nm^{-1}</code>].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>logical</code> value indicating whether test was passed or
not
</p>


<h3>See Also</h3>

<p>Other data validity check functions: 
<code><a href="#topic+check_spct">check_spct</a>()</code>,
<code><a href="#topic+check_w.length">check_w.length</a>()</code>,
<code><a href="#topic+enable_check_spct">enable_check_spct</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data, check_spectrum(w.length, s.e.irrad))

</code></pre>

<hr>
<h2 id='check_w.length'>Sanity check of wavelengths (internal function).</h2><span id='topic+check_w.length'></span>

<h3>Description</h3>

<p>This function checks a w.length vector for compliance with assumptions used in calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_w.length(w.length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_w.length_+3A_w.length">w.length</code></td>
<td>
<p>numeric array of wavelength (nm)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single logical value indicating whether test was passed or not
</p>


<h3>See Also</h3>

<p>Other data validity check functions: 
<code><a href="#topic+check_spct">check_spct</a>()</code>,
<code><a href="#topic+check_spectrum">check_spectrum</a>()</code>,
<code><a href="#topic+enable_check_spct">enable_check_spct</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
with(sun.data, photobiology:::check_w.length(w.length))

</code></pre>

<hr>
<h2 id='checkMspctVersion'>Check that the &quot;mspct.version&quot; attribute is set</h2><span id='topic+checkMspctVersion'></span>

<h3>Description</h3>

<p>Function to check the &quot;mspct.version&quot; attribute of an existing generic_spct
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkMspctVersion(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkMspctVersion_+3A_x">x</code></td>
<td>
<p>a generic_mspct object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value
</p>


<h3>Note</h3>

<p>if x is not a <code>generic_mspct</code> object, <code>NA</code> is returned,
and if it the attribute is missing, zero is returned with a warning.
</p>

<hr>
<h2 id='checkSpctVersion'>Check that the &quot;spct.version&quot; attribute is set</h2><span id='topic+checkSpctVersion'></span>

<h3>Description</h3>

<p>Function to check the &quot;spct.version&quot; attribute of an existing generic_spct
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSpctVersion(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkSpctVersion_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value
</p>


<h3>Note</h3>

<p>if x is not a <code>generic_spct</code> object, <code>NA</code> is returned,
and if it the attribute is missing, zero is returned with a warning.
</p>

<hr>
<h2 id='checkTimeUnit'>Check the &quot;time.unit&quot; attribute of an existing source_spct object</h2><span id='topic+checkTimeUnit'></span>

<h3>Description</h3>

<p>Function to read the &quot;time.unit&quot; attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkTimeUnit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkTimeUnit_+3A_x">x</code></td>
<td>
<p>a source_spct object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x possibly with the <code>time.unit</code> attribute modified
</p>


<h3>Note</h3>

<p>if x is not a <code>source_spct</code> or a <code>response_spct</code> object, NA
is returned
</p>


<h3>See Also</h3>

<p>Other time attribute functions: 
<code><a href="#topic+convertThickness">convertThickness</a>()</code>,
<code><a href="#topic+convertTimeUnit">convertTimeUnit</a>()</code>,
<code><a href="#topic+getTimeUnit">getTimeUnit</a>()</code>,
<code><a href="#topic+setTimeUnit">setTimeUnit</a>()</code>
</p>

<hr>
<h2 id='ciev10.spct'>Linear energy CIE 2008 luminous efficiency function 10 deg data</h2><span id='topic+ciev10.spct'></span>

<h3>Description</h3>

<p>A dataset containing wavelengths at a 1 nm interval (390 nm to
830 nm) and the corresponding response values for a 10 degrees target.
Original data from <a href="http://www.cvrl.org/">http://www.cvrl.org/</a> downloaded on 2014-04-29 The
variables are as follows:
</p>

<ul>
<li><p> w.length (nm)
</p>
</li>
<li><p> s.e.response</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ciev10.spct
</code></pre>


<h3>Format</h3>

<p>A chroma_spct object with 441 rows and 4 variables
</p>


<h3>Author(s)</h3>

<p>CIE
</p>


<h3>See Also</h3>

<p>Other Visual response data examples: 
<code><a href="#topic+beesxyzCMF.spct">beesxyzCMF.spct</a></code>,
<code><a href="#topic+ciev2.spct">ciev2.spct</a></code>,
<code><a href="#topic+ciexyzCC10.spct">ciexyzCC10.spct</a></code>,
<code><a href="#topic+ciexyzCC2.spct">ciexyzCC2.spct</a></code>,
<code><a href="#topic+ciexyzCMF10.spct">ciexyzCMF10.spct</a></code>,
<code><a href="#topic+ciexyzCMF2.spct">ciexyzCMF2.spct</a></code>,
<code><a href="#topic+cone_fundamentals10.spct">cone_fundamentals10.spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ciev10.spct

</code></pre>

<hr>
<h2 id='ciev2.spct'>Linear energy CIE 2008 luminous efficiency function 2 deg data</h2><span id='topic+ciev2.spct'></span>

<h3>Description</h3>

<p>A dataset containing wavelengths at a 1 nm interval (390 nm to
830 nm) and the corresponding response values for a 2 degrees target.
Original data from <a href="http://www.cvrl.org/">http://www.cvrl.org/</a> downloaded on 2014-04-29 The
variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciev2.spct
</code></pre>


<h3>Format</h3>

<p>A chroma_spct object with 441 rows and 4 variables
</p>


<h3>Details</h3>


<ul>
<li><p> w.length (nm)
</p>
</li>
<li><p> s.e.response</p>
</li></ul>



<h3>Author(s)</h3>

<p>CIE
</p>


<h3>See Also</h3>

<p>Other Visual response data examples: 
<code><a href="#topic+beesxyzCMF.spct">beesxyzCMF.spct</a></code>,
<code><a href="#topic+ciev10.spct">ciev10.spct</a></code>,
<code><a href="#topic+ciexyzCC10.spct">ciexyzCC10.spct</a></code>,
<code><a href="#topic+ciexyzCC2.spct">ciexyzCC2.spct</a></code>,
<code><a href="#topic+ciexyzCMF10.spct">ciexyzCMF10.spct</a></code>,
<code><a href="#topic+ciexyzCMF2.spct">ciexyzCMF2.spct</a></code>,
<code><a href="#topic+cone_fundamentals10.spct">cone_fundamentals10.spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ciev2.spct

</code></pre>

<hr>
<h2 id='ciexyzCC10.spct'>CIE xyz chromaticity coordinates (CC) 10 deg data</h2><span id='topic+ciexyzCC10.spct'></span>

<h3>Description</h3>

<p>A dataset containing wavelengths at a 1 nm interval (390 nm to
830 nm) and the corresponding x, y, and z chromaticity coordinates. Derived
from proposed CIE 2006 standard. Original data from
<a href="http://www.cvrl.org/">http://www.cvrl.org/</a> downloaded on 2014-04-29 The variables are as
follows:
</p>

<ul>
<li><p> w.length (nm)
</p>
</li>
<li><p> x
</p>
</li>
<li><p> y
</p>
</li>
<li><p> z </p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ciexyzCC10.spct
</code></pre>


<h3>Format</h3>

<p>A chroma_spct object with 441 rows and 4 variables
</p>


<h3>Author(s)</h3>

<p>CIE
</p>


<h3>See Also</h3>

<p>Other Visual response data examples: 
<code><a href="#topic+beesxyzCMF.spct">beesxyzCMF.spct</a></code>,
<code><a href="#topic+ciev10.spct">ciev10.spct</a></code>,
<code><a href="#topic+ciev2.spct">ciev2.spct</a></code>,
<code><a href="#topic+ciexyzCC2.spct">ciexyzCC2.spct</a></code>,
<code><a href="#topic+ciexyzCMF10.spct">ciexyzCMF10.spct</a></code>,
<code><a href="#topic+ciexyzCMF2.spct">ciexyzCMF2.spct</a></code>,
<code><a href="#topic+cone_fundamentals10.spct">cone_fundamentals10.spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ciexyzCC10.spct

</code></pre>

<hr>
<h2 id='ciexyzCC2.spct'>CIE xyz chromaticity coordinates 2 deg data</h2><span id='topic+ciexyzCC2.spct'></span>

<h3>Description</h3>

<p>A dataset containing wavelengths at a 1 nm interval (390 nm to
830 nm) and the corresponding x, y, and z chromaticity coordinates.
According to proposed CIE 2006 standard. Original data from
<a href="http://www.cvrl.org/">http://www.cvrl.org/</a> downloaded on 2014-04-28 The variables are as
follows:
</p>

<ul>
<li><p> w.length (nm)
</p>
</li>
<li><p> x
</p>
</li>
<li><p> y
</p>
</li>
<li><p> z </p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ciexyzCC2.spct
</code></pre>


<h3>Format</h3>

<p>A chroma_spct object with 441 rows and 4 variables
</p>


<h3>Author(s)</h3>

<p>CIE
</p>


<h3>See Also</h3>

<p>Other Visual response data examples: 
<code><a href="#topic+beesxyzCMF.spct">beesxyzCMF.spct</a></code>,
<code><a href="#topic+ciev10.spct">ciev10.spct</a></code>,
<code><a href="#topic+ciev2.spct">ciev2.spct</a></code>,
<code><a href="#topic+ciexyzCC10.spct">ciexyzCC10.spct</a></code>,
<code><a href="#topic+ciexyzCMF10.spct">ciexyzCMF10.spct</a></code>,
<code><a href="#topic+ciexyzCMF2.spct">ciexyzCMF2.spct</a></code>,
<code><a href="#topic+cone_fundamentals10.spct">cone_fundamentals10.spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ciexyzCC2.spct

</code></pre>

<hr>
<h2 id='ciexyzCMF10.spct'>Linear energy CIE xyz colour matching function (CMF) 10 deg data</h2><span id='topic+ciexyzCMF10.spct'></span>

<h3>Description</h3>

<p>A dataset containing wavelengths at a 1 nm interval (390 nm to
830 nm) and the corresponding x, y, and z 10 degrees CMF values. Derived
from proposed CIE 2006 standard. Original data from
<a href="http://www.cvrl.org/">http://www.cvrl.org/</a> downloaded on 2014-04-29 The variables are as
follows:
</p>

<ul>
<li><p> w.length (nm)
</p>
</li>
<li><p> x
</p>
</li>
<li><p> y
</p>
</li>
<li><p> z </p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ciexyzCMF10.spct
</code></pre>


<h3>Format</h3>

<p>A chroma_spct object with 441 rows and 4 variables
</p>


<h3>Author(s)</h3>

<p>CIE
</p>


<h3>See Also</h3>

<p>Other Visual response data examples: 
<code><a href="#topic+beesxyzCMF.spct">beesxyzCMF.spct</a></code>,
<code><a href="#topic+ciev10.spct">ciev10.spct</a></code>,
<code><a href="#topic+ciev2.spct">ciev2.spct</a></code>,
<code><a href="#topic+ciexyzCC10.spct">ciexyzCC10.spct</a></code>,
<code><a href="#topic+ciexyzCC2.spct">ciexyzCC2.spct</a></code>,
<code><a href="#topic+ciexyzCMF2.spct">ciexyzCMF2.spct</a></code>,
<code><a href="#topic+cone_fundamentals10.spct">cone_fundamentals10.spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ciexyzCMF10.spct

</code></pre>

<hr>
<h2 id='ciexyzCMF2.spct'>Linear energy CIE xyz colour matching function (CMF) 2 deg data</h2><span id='topic+ciexyzCMF2.spct'></span>

<h3>Description</h3>

<p>A dataset containing wavelengths at a 1 nm interval (390 nm to
830 nm) and the corresponding x, y, and z 2 degrees CMF values. Derived
from proposed CIE 2006 standard. Original data from
<a href="http://www.cvrl.org/">http://www.cvrl.org/</a> downloaded on 2014-04-29 The variables are as
follows:
</p>

<ul>
<li><p> w.length (nm)
</p>
</li>
<li><p> x
</p>
</li>
<li><p> y
</p>
</li>
<li><p> z </p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ciexyzCMF2.spct
</code></pre>


<h3>Format</h3>

<p>A chroma_spct object with 441 rows and 4 variables
</p>


<h3>Author(s)</h3>

<p>CIE
</p>


<h3>See Also</h3>

<p>Other Visual response data examples: 
<code><a href="#topic+beesxyzCMF.spct">beesxyzCMF.spct</a></code>,
<code><a href="#topic+ciev10.spct">ciev10.spct</a></code>,
<code><a href="#topic+ciev2.spct">ciev2.spct</a></code>,
<code><a href="#topic+ciexyzCC10.spct">ciexyzCC10.spct</a></code>,
<code><a href="#topic+ciexyzCC2.spct">ciexyzCC2.spct</a></code>,
<code><a href="#topic+ciexyzCMF10.spct">ciexyzCMF10.spct</a></code>,
<code><a href="#topic+cone_fundamentals10.spct">cone_fundamentals10.spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ciexyzCMF2.spct

</code></pre>

<hr>
<h2 id='class_spct'>Query which is the class of a spectrum</h2><span id='topic+class_spct'></span>

<h3>Description</h3>

<p>Extract class information from a generic spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>class_spct(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="class_spct_+3A_x">x</code></td>
<td>
<p>any R object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value returned is equivalent to the set intersection of the
value returned by <code>class(x)</code> and the value returned by
<code><a href="#topic+spct_classes">spct_classes</a></code>, but preserving the order of the members of
the character vector.
</p>


<h3>Value</h3>

<p>A character vector containing all matching xxxx.spct S3 classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>class_spct(sun.spct)
class(sun.spct)

</code></pre>

<hr>
<h2 id='clean'>Clean (=replace) off-range values in a spectrum</h2><span id='topic+clean'></span><span id='topic+clean.default'></span><span id='topic+clean.source_spct'></span><span id='topic+clean.filter_spct'></span><span id='topic+clean.reflector_spct'></span><span id='topic+clean.solute_spct'></span><span id='topic+clean.object_spct'></span><span id='topic+clean.response_spct'></span><span id='topic+clean.cps_spct'></span><span id='topic+clean.raw_spct'></span><span id='topic+clean.generic_spct'></span><span id='topic+clean.source_mspct'></span><span id='topic+clean.filter_mspct'></span><span id='topic+clean.reflector_mspct'></span><span id='topic+clean.object_mspct'></span><span id='topic+clean.solute_mspct'></span><span id='topic+clean.response_mspct'></span><span id='topic+clean.cps_mspct'></span><span id='topic+clean.raw_mspct'></span><span id='topic+clean.generic_mspct'></span>

<h3>Description</h3>

<p>These functions implement the equivalent of replace() but for spectral
objects instead of vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean(x, range, range.s.data, fill, ...)

## Default S3 method:
clean(x, range, range.s.data, fill, ...)

## S3 method for class 'source_spct'
clean(
  x,
  range = x,
  range.s.data = c(0, NA),
  fill = range.s.data,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'filter_spct'
clean(
  x,
  range = x,
  range.s.data = NULL,
  fill = range.s.data,
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  ...
)

## S3 method for class 'reflector_spct'
clean(x, range = x, range.s.data = c(0, 1), fill = range.s.data, ...)

## S3 method for class 'solute_spct'
clean(x, range = x, range.s.data = c(0, NA), fill = range.s.data, ...)

## S3 method for class 'object_spct'
clean(
  x,
  range = x,
  range.s.data = c(0, 1),
  fill = range.s.data,
  min.Afr = NULL,
  ...
)

## S3 method for class 'response_spct'
clean(
  x,
  range = x,
  range.s.data = c(0, NA),
  fill = range.s.data,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'cps_spct'
clean(x, range = x, range.s.data = c(0, NA), fill = range.s.data, ...)

## S3 method for class 'raw_spct'
clean(
  x,
  range = x,
  range.s.data = c(NA_real_, NA_real_),
  fill = range.s.data,
  ...
)

## S3 method for class 'generic_spct'
clean(
  x,
  range = x,
  range.s.data = c(NA_real_, NA_real_),
  fill = range.s.data,
  col.names,
  ...
)

## S3 method for class 'source_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, NA),
  fill = range.s.data,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'filter_mspct'
clean(
  x,
  range = NULL,
  range.s.data = NULL,
  fill = range.s.data,
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'reflector_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, 1),
  fill = range.s.data,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'object_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, 1),
  fill = range.s.data,
  min.Afr = NULL,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'solute_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, NA),
  fill = range.s.data,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'response_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, NA),
  fill = range.s.data,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'cps_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, NA),
  fill = range.s.data,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'raw_mspct'
clean(
  x,
  range = NULL,
  range.s.data = c(0, NA),
  fill = range.s.data,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'generic_mspct'
clean(
  x,
  range = x,
  range.s.data = c(NA_real_, NA_real_),
  fill = range.s.data,
  col.names,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="clean_+3A_range">range</code></td>
<td>
<p>numeric vector of wavelengths</p>
</td></tr>
<tr><td><code id="clean_+3A_range.s.data">range.s.data</code></td>
<td>
<p>numeric vector of length two giving the allowable
range for the spectral data.</p>
</td></tr>
<tr><td><code id="clean_+3A_fill">fill</code></td>
<td>
<p>numeric vector of length 1 or 2, giving the replacement
values to use at each extreme of the range.</p>
</td></tr>
<tr><td><code id="clean_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="clean_+3A_unit.out">unit.out</code></td>
<td>
<p>character string with allowed values &quot;energy&quot;, and &quot;photon&quot;,
or its alias &quot;quantum&quot;</p>
</td></tr>
<tr><td><code id="clean_+3A_qty.out">qty.out</code></td>
<td>
<p>character string with allowed values &quot;energy&quot;, and &quot;photon&quot;,
or its alias &quot;quantum&quot;</p>
</td></tr>
<tr><td><code id="clean_+3A_min.afr">min.Afr</code></td>
<td>
<p>numeric Gives the minimum value accepted for the computed
absorptance. The default <code>NULL</code> sets a valid value (Afr &gt;= 0) with
a warning. If an integer value is passed to <code>digits</code> values are
adjusted silently.</p>
</td></tr>
<tr><td><code id="clean_+3A_col.names">col.names</code></td>
<td>
<p>character The name of the variable to clean</p>
</td></tr>
<tr><td><code id="clean_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="clean_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code>, possibly with some of the spectral data values
replaced by the value passed to <code>fill</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>clean(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>clean(source_spct)</code>: Replace off-range values in a source spectrum
</p>
</li>
<li> <p><code>clean(filter_spct)</code>: Replace off-range values in a filter spectrum
</p>
</li>
<li> <p><code>clean(reflector_spct)</code>: Replace off-range values in a reflector spectrum
</p>
</li>
<li> <p><code>clean(solute_spct)</code>: Replace off-range values in a solute spectrum
</p>
</li>
<li> <p><code>clean(object_spct)</code>: Replace off-range values in an object spectrum
</p>
</li>
<li> <p><code>clean(response_spct)</code>: Replace off-range values in a response spectrum
</p>
</li>
<li> <p><code>clean(cps_spct)</code>: Replace off-range values in a counts per second spectrum
</p>
</li>
<li> <p><code>clean(raw_spct)</code>: Replace off-range values in a raw counts spectrum
</p>
</li>
<li> <p><code>clean(generic_spct)</code>: Replace off-range values in a generic spectrum
</p>
</li>
<li> <p><code>clean(source_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(object_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(solute_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(response_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(raw_mspct)</code>: 
</p>
</li>
<li> <p><code>clean(generic_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>In the case of <code>object_spct</code> objects, cleaning is done first
on the Rfr and Tfr columns and subsequently Afr estimated and if needed
half of deviation of Afr from the expected minimum value subtracted from
each of Rfr and Tfr.
</p>

<hr>
<h2 id='clean_spct'>Clean a spectrum</h2><span id='topic+clean_spct'></span>

<h3>Description</h3>

<p>These functions implement the equivalent of replace() but for spectral
objects instead of vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_spct(x, range, range.s.data, fill, col.names, col.pattern = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_spct_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="clean_spct_+3A_range">range</code></td>
<td>
<p>numeric vector of wavelengths</p>
</td></tr>
<tr><td><code id="clean_spct_+3A_range.s.data">range.s.data</code></td>
<td>
<p>numeric vector of length two giving the allowable
range for the spectral data.</p>
</td></tr>
<tr><td><code id="clean_spct_+3A_fill">fill</code></td>
<td>
<p>numeric vector of length 1 or 2, giving the replacement
values to use at each extreme of the range.</p>
</td></tr>
<tr><td><code id="clean_spct_+3A_col.names">col.names</code></td>
<td>
<p>character The name of the variable to clean.</p>
</td></tr>
<tr><td><code id="clean_spct_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>

<hr>
<h2 id='clear_photobio.cache'>Clear the spectral weights cache</h2><span id='topic+clear_photobio.cache'></span>

<h3>Description</h3>

<p>Clear the cache objects stored in environment .photobio.cache
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_photobio.cache(pattern = "*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clear_photobio.cache_+3A_pattern">pattern</code></td>
<td>
<p>character string passed to ls() for selecting within the
environment .photobio.cache the objects to be deleted</p>
</td></tr>
</table>

<hr>
<h2 id='clear.spct'>Theoretical spectrum of clear and apaque materials</h2><span id='topic+clear.spct'></span><span id='topic+opaque.spct'></span>

<h3>Description</h3>

<p>Dataset for hypothetical objects with transmittance 1/1
(100%) and transmittance 0/1 (0%)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear.spct

opaque.spct
</code></pre>


<h3>Format</h3>

<p>A <code>filter_spct</code> object with 4 rows and 2 variables
</p>
<p>An object of class <code>filter_spct</code> (inherits from <code>generic_spct</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 4 rows and 2 columns.
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm). </p>
</li>
<li><p> Tfr
(0..1)  </p>
</li></ul>



<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clear.spct
opaque.spct

</code></pre>

<hr>
<h2 id='clip_wl'>Clip head and/or tail of a spectrum</h2><span id='topic+clip_wl'></span><span id='topic+clip_wl.default'></span><span id='topic+clip_wl.generic_spct'></span><span id='topic+clip_wl.generic_mspct'></span><span id='topic+clip_wl.waveband'></span><span id='topic+clip_wl.list'></span>

<h3>Description</h3>

<p>Clip head and tail of a spectrum based on wavelength limits, no
interpolation used at range boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clip_wl(x, range, ...)

## Default S3 method:
clip_wl(x, range, ...)

## S3 method for class 'generic_spct'
clip_wl(x, range = NULL, ...)

## S3 method for class 'generic_mspct'
clip_wl(x, range = NULL, ...)

## S3 method for class 'waveband'
clip_wl(x, range = NULL, ...)

## S3 method for class 'list'
clip_wl(x, range = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clip_wl_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="clip_wl_+3A_range">range</code></td>
<td>
<p>a numeric vector of length two, or any other object for which
function <code>range()</code> will return range of wavelengths expressed in
nanometres.</p>
</td></tr>
<tr><td><code id="clip_wl_+3A_...">...</code></td>
<td>
<p>ignored (possibly used by derived methods).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a spectrum object or a collection of spectral objects of the same
class as <code>x</code> with wavelength heads and tails clipped.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>clip_wl(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>clip_wl(generic_spct)</code>: Clip an object of class &quot;generic_spct&quot; or derived.
</p>
</li>
<li> <p><code>clip_wl(generic_mspct)</code>: Clip an object of class &quot;generic_mspct&quot; or derived.
</p>
</li>
<li> <p><code>clip_wl(waveband)</code>: Clip an object of class &quot;waveband&quot;.
</p>
</li>
<li> <p><code>clip_wl(list)</code>: Clip a list (of objects of class &quot;waveband&quot;).
</p>
</li></ul>


<h3>Note</h3>

<p>The condition tested is <code>wl &gt;= range[1] &amp; wl &lt; (range[2] + 1e-13)</code>.
</p>


<h3>See Also</h3>

<p>Other trim functions: 
<code><a href="#topic+trim_spct">trim_spct</a>()</code>,
<code><a href="#topic+trim_waveband">trim_waveband</a>()</code>,
<code><a href="#topic+trim_wl">trim_wl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clip_wl(sun.spct, range = c(400, 500))
clip_wl(sun.spct, range = c(NA, 500))
clip_wl(sun.spct, range = c(400, NA))

</code></pre>

<hr>
<h2 id='collect2mspct'>Form a new collection</h2><span id='topic+collect2mspct'></span>

<h3>Description</h3>

<p>Form a collection of spectra from separate objects in the parent
frame of the call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect2mspct(
  .list = NULL,
  pattern = "*\\.spct$",
  collection.class = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect2mspct_+3A_.list">.list</code></td>
<td>
<p>list of R objects</p>
</td></tr>
<tr><td><code id="collect2mspct_+3A_pattern">pattern</code></td>
<td>
<p>character an optional regular expression, ignored if
<code>.list</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="collect2mspct_+3A_collection.class">collection.class</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="collect2mspct_+3A_...">...</code></td>
<td>
<p>additional named arguments passed down to the collection
constructor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function that simplifies the creation of
collections from existing objects of class <code>generic_spct</code> or a derived
class. A list of objects con be passed as argument, or a search pattern. If
a list is passed, no search is done. If <code>collection.class</code> is
<code>NULL</code>, then all objects of class <code>generic_spct</code> or of a class
derived from it are added to the collection. If objects of only one derived
class are to be collected this class or that of the matching collection
should be passed as argument to <code>collection.class</code>. Objects of other R
classes are silently discarded, which simplifies the specification of
search patterns. By default, i.e., if <code>collection.class</code> is
<code>NULL</code>, if all the objects collected belong to the same class then the
corresponding collection class will be returned, otherwise a
<code>generic_mspct</code> object with heterogeneous members will be returned. To
force the return of a <code>generic_mspct</code> even when the collected spectra
all belong to the same class, pass <code>generic_mspct</code> as argument to
<code>collection.class</code>. If the argument to <code>collection.class</code> is a
vector containing two of more class names, only the matching spectra will
be collected, and a <code>generic_mspct</code> will be returned. The returned
object is created with the constructor for the class, and validated.
</p>


<h3>Value</h3>

<p>By default a collection of spectra.
</p>


<h3>See Also</h3>

<p>Other experimental utility functions: 
<code><a href="#topic+drop_user_cols">drop_user_cols</a>()</code>,
<code><a href="#topic+thin_wl">thin_wl</a>()</code>,
<code><a href="#topic+uncollect2spct">uncollect2spct</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>collect2mspct() # returns empty generic_mspct object

sun1.spct &lt;- sun.spct
sun2.spct &lt;- sun.spct
kk.spct &lt;- 10:30 # ignored
collect2mspct()
collect2mspct(collection.class = "generic_mspct")

pet1.spct &lt;- polyester.spct
collect2mspct()
collect2mspct(collection.class = "source_mspct")
collect2mspct(collection.class = "filter_mspct")
collect2mspct(collection.class = "response_mspct")

</code></pre>

<hr>
<h2 id='color_of'>Color of an object</h2><span id='topic+color_of'></span><span id='topic+color_of.default'></span><span id='topic+color_of.numeric'></span><span id='topic+color_of.list'></span><span id='topic+color_of.waveband'></span><span id='topic+color_of.source_spct'></span><span id='topic+color_of.source_mspct'></span><span id='topic+colour_of'></span><span id='topic+color'></span><span id='topic+fast_color_of_wl'></span><span id='topic+fast_color_of_wb'></span>

<h3>Description</h3>

<p>Equivalent RGB color of an object such as a spectrum, wavelength or waveband.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_of(x, ...)

## Default S3 method:
color_of(x, ...)

## S3 method for class 'numeric'
color_of(x, type = "CMF", chroma.type = type, ...)

## S3 method for class 'list'
color_of(x, short.names = TRUE, type = "CMF", chroma.type = type, ...)

## S3 method for class 'waveband'
color_of(x, short.names = TRUE, type = "CMF", chroma.type = type, ...)

## S3 method for class 'source_spct'
color_of(x, type = "CMF", chroma.type = type, ...)

## S3 method for class 'source_mspct'
color_of(x, ..., idx = "spct.idx")

colour_of(x, ...)

color(x, ...)

fast_color_of_wl(x, type = "CMF", ...)

fast_color_of_wb(x, type = "CMF", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color_of_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="color_of_+3A_...">...</code></td>
<td>
<p>ignored (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="color_of_+3A_type">type</code>, <code id="color_of_+3A_chroma.type">chroma.type</code></td>
<td>
<p>character telling whether &quot;CMF&quot;, &quot;CC&quot;, or &quot;both&quot; should be returned
for human vision, or an object of class <code>chroma_spct</code> for any other
trichromic visual system.</p>
</td></tr>
<tr><td><code id="color_of_+3A_short.names">short.names</code></td>
<td>
<p>logical indicating whether to use short or long names for
wavebands</p>
</td></tr>
<tr><td><code id="color_of_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A color definition in hexadecimal format as a <code>character</code> string
of 7 characters, &quot;#&quot; followed by the red, blue, and green values in
hexadecimal (scaled to 0 ... 255). In the case of the specialization for
<code>list</code>, a list of such definitions is returned. In the case of a
collection of spectra, a <code>data.frame</code> with one column with such
definitions and by default an additional column with names of the spectra
as index. In case of missing input the returned value is <code>NA</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>color_of(default)</code>: Default method (returns always &quot;black&quot;).
</p>
</li>
<li> <p><code>color_of(numeric)</code>: Method that returns Color definitions corresponding to
numeric values representing a wavelengths in nm.
</p>
</li>
<li> <p><code>color_of(list)</code>: Method that returns Color of elements in a list.
</p>
</li>
<li> <p><code>color_of(waveband)</code>: Color at midpoint of a <code><a href="#topic+waveband">waveband</a></code> object.
</p>
</li>
<li> <p><code>color_of(source_spct)</code>: 
</p>
</li>
<li> <p><code>color_of(source_mspct)</code>: 
</p>
</li></ul>


<h3>Deprecated</h3>

<p>Use of color() is deprecated as this wrapper function
may be removed in future versions of the package because of name clashes.
Use color_of() instead.
</p>


<h3>Note</h3>

<p>When <code>x</code> is a list but not a waveband, if a method  <code>color_of</code>
is not available for the class of each element of the list, then
<code>color_of.default</code> will be called.
</p>
<p>Function <code>fast_color_of_wl()</code> should be used only when high
performance is needed. It speeds up performance by rounding the wavelength
values in the numeric vector passed as argument to <code>x</code> and then
retrieves the corresponding pre-computed color definitions if <code>type</code>
is either <code>"CMF"</code> or <code>"CC"</code>. In other cases it falls-back to
calling <code>color_of.numeric()</code>. Returned color definitions always have
default names irrespective of names of <code>x</code>, which is different from
the behavior of <code>color_of()</code> methods.
</p>
<p>Function <code>fast_color_of_wb()</code> accepts waveband objects and lists of
waveband objects. If all wavebands are narrow, it issues a vectotized
call to <code>fast_color_of_wl()</code> with a vector of waveband midpoint
wavelengths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wavelengths &lt;- c(300, 420, 500, 600, NA) # nanometres
color_of(wavelengths)
color_of(waveband(c(300,400)))
color_of(list(blue = waveband(c(400,480)), red = waveband(c(600,700))))
color_of(numeric())
color_of(NA_real_)

color_of(sun.spct)

</code></pre>

<hr>
<h2 id='compare_spct'>Coarse-grained comparison of two spectra</h2><span id='topic+compare_spct'></span>

<h3>Description</h3>

<p>Compare two spectra using a specified summary function pre-applied to
wavelength intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_spct(
  x,
  w.band = 10,
  .summary.fun = NULL,
  ...,
  .comparison.fun = `/`,
  returned.value = "spectrum",
  use.hinges = FALSE,
  short.names = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_spct_+3A_x">x</code></td>
<td>
<p>A collection of two spectral objects of the same type.</p>
</td></tr>
<tr><td><code id="compare_spct_+3A_w.band">w.band</code></td>
<td>
<p>waveband object or a numeric stepsize in nanometres.</p>
</td></tr>
<tr><td><code id="compare_spct_+3A_.summary.fun">.summary.fun</code></td>
<td>
<p>function. The summary function to use. It must be a
method accepting object <code>x</code> as first argument.</p>
</td></tr>
<tr><td><code id="compare_spct_+3A_...">...</code></td>
<td>
<p>additional named arguments passed down to <code>.summary.fun</code>.</p>
</td></tr>
<tr><td><code id="compare_spct_+3A_.comparison.fun">.comparison.fun</code></td>
<td>
<p>function. The comparison function to use.</p>
</td></tr>
<tr><td><code id="compare_spct_+3A_returned.value">returned.value</code></td>
<td>
<p>character One of &quot;data.frame&quot;, &quot;spectrum&quot;,
&quot;tagged.spectrum&quot;.</p>
</td></tr>
<tr><td><code id="compare_spct_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
returned spectrum when tagging it.</p>
</td></tr>
<tr><td><code id="compare_spct_+3A_short.names">short.names</code></td>
<td>
<p>logical Flag indicating whether to use short or long names
for wavebands when tagging.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summaries are computed for each of the wavebands in <code>w.band</code> by
applying function <code>.summary.fun</code> separately to each spectrum, after
trimming them to the overlapping wavelength region. Next the matching
summaries are compared by means of <code>.comparison.fun</code>. Both the
summaries and the result of the comparison are returned. Columns containing
summary values are named by concatenating the name each member spectrum
with the name of the argument passed to <code>.summary.fun</code>.
</p>
<p>Tagging is useful for plotting using wavelength based colours, or when
names for wavebands are used as annotations. When tagging is requested, the
spectrum is passed to method <code><a href="#topic+tag">tag</a></code> with <code>use.hinges</code> and
<code>short.names</code> as additional arguments.
</p>


<h3>Value</h3>

<p>A <code>generic_spct</code>, tagged or not with the wavebdans, or a
<code>data.frame</code> object containing the summary values per waveband for
each spectrum and the result of applying the comparison function to these
summaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
compare_spct(source_mspct(list(sun1 = sun.spct, sun2 = sun.spct * 2)))
compare_spct(source_mspct(list(sun1 = sun.spct, sun2 = sun.spct * 2)),
             w.band = NULL)
compare_spct(source_mspct(list(sun1 = sun.spct, sun2 = sun.spct * 2)),
             w.band = list(waveband(c(640, 650)), waveband(c(720, 740))))

compare_spct(filter_mspct(list(pet = polyester.spct,
                               yllw = yellow_gel.spct)),
             w.band = 50,
             .comparison.fun = `&lt;`)

head(
  compare_spct(source_mspct(list(sun1 = sun.spct, sun2 = sun.spct * 2)),
               returned.value = "data.frame")
)
compare_spct(source_mspct(list(sun1 = sun.spct, sun2 = sun.spct * 2)),
             returned.value = "tagged.spectrum")
compare_spct(source_mspct(list(sun1 = sun.spct, sun2 = sun.spct * 2)),
             returned.value = "tagged.spectrum",
             use.hinges = TRUE)

</code></pre>

<hr>
<h2 id='cone_fundamentals10.spct'>Ten-degree cone fundaamentals</h2><span id='topic+cone_fundamentals10.spct'></span><span id='topic+cone_fundamentals10.mspct'></span>

<h3>Description</h3>

<p>A dataset containing wavelengths at a 1 nm interval (390 nm to
830 nm) and the corresponding response values for a 2 degrees target.
Original data from <a href="http://www.cvrl.org/">http://www.cvrl.org/</a> downloaded on 2014-04-29 The
variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cone_fundamentals10.spct

cone_fundamentals10.mspct
</code></pre>


<h3>Format</h3>

<p>A chroma_spct object with 440 rows and 4 variables
</p>
<p>An object of class <code>response_mspct</code> (inherits from <code>generic_mspct</code>, <code>list</code>) with 3 rows and 1 columns.
</p>


<h3>Details</h3>


<ul>
<li><p> w.length (nm)
</p>
</li>
<li><p> x
</p>
</li>
<li><p> y
</p>
</li>
<li><p> z </p>
</li></ul>



<h3>Value</h3>

<p>A <code>chroma_spct</code> object.
</p>
<p>A <code>response_mspct</code> object containing the same data in three
<code>response_spct</code> objects, one for each of x, y and z.
</p>


<h3>Note</h3>

<p>The missing data for z in the NIR have been filled with zeros.
</p>


<h3>Author(s)</h3>

<p>CIE
</p>


<h3>See Also</h3>

<p>Other Visual response data examples: 
<code><a href="#topic+beesxyzCMF.spct">beesxyzCMF.spct</a></code>,
<code><a href="#topic+ciev10.spct">ciev10.spct</a></code>,
<code><a href="#topic+ciev2.spct">ciev2.spct</a></code>,
<code><a href="#topic+ciexyzCC10.spct">ciexyzCC10.spct</a></code>,
<code><a href="#topic+ciexyzCC2.spct">ciexyzCC2.spct</a></code>,
<code><a href="#topic+ciexyzCMF10.spct">ciexyzCMF10.spct</a></code>,
<code><a href="#topic+ciexyzCMF2.spct">ciexyzCMF2.spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cone_fundamentals10.spct

</code></pre>

<hr>
<h2 id='convertTfrType'>Convert the &quot;Tfr.type&quot; attribute</h2><span id='topic+convertTfrType'></span>

<h3>Description</h3>

<p>Function to set the <code>"Tfr.type"</code> attribute and simultaneously convert
the spectral data to correspond to the new type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertTfrType(x, Tfr.type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertTfrType_+3A_x">x</code></td>
<td>
<p>a <code>filter_spct</code>, <code>object_spct</code>, <code>filter_mspct</code> or <code>object_mspct</code> object.</p>
</td></tr>
<tr><td><code id="convertTfrType_+3A_tfr.type">Tfr.type</code></td>
<td>
<p>character One of <code>"internal"</code> or <code>"total"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal transmittance, <code class="reqn">\tau</code>, uses as reference the light
entering the object while total transmittance, <code class="reqn">T</code>, takes the incident
light as reference. The
conversion is possible only if total reflectance, <code class="reqn">\rho</code>, is known. Either as spectral
data in an <code>object_spct</code> object, a <code>filter_spct</code> object that is
&quot;under-the-hood&quot; an <code>object_spct</code>, or if a fixed reflectance factor
applicable to all wavelengths is stored in the <code>filter.properties</code>
attribute of the <code>filter_spct</code> object.
</p>
<p>Conversions are computed as:
</p>
<p style="text-align: center;"><code class="reqn">\tau = \frac{T - \rho}{1 - \rho}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">T = \tau * (1 - \rho) + \rho</code>
</p>

<p>For the conversion to take place the object passed as argument to <code>x</code>,
must contain a column with transmittance data, named <code>Tfr</code>. Any
necessary conversion from absorbance <code>A</code> or from <code>Afr</code> into
transmittance, must be done before calling <code>convertTfrType()</code>.
</p>


<h3>Value</h3>

<p><code>x</code> if possible, with the value of the <code>"Tfr.type"</code> attribute
modified and the values stored in the <code>Tfr</code> variable converted to the
new quantity.
</p>


<h3>Note</h3>

<p>if <code>x</code> is not a <code>filter_spct</code> object, <code>x</code> is returned
unchanged. If <code>x</code> does not have the <code>"filter.properties"</code>
attribute set if it is missing data, <code>x</code> is returned with
<code>Tfr</code> set to <code>NA</code> values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setTfrType">setTfrType</a></code>, <code><a href="#topic+filter_spct">filter_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getTfrType(polyester.spct)
filter_properties(polyester.spct)
convertTfrType(polyester.spct, Tfr.type = "internal")

</code></pre>

<hr>
<h2 id='convertThickness'>Convert the &quot;thickness&quot; attribute of an existing filter_spct object.</h2><span id='topic+convertThickness'></span>

<h3>Description</h3>

<p>Function to set the &quot;thickness&quot; attribute and simultaneously converting the
spectral data to correspond to the new thickness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertThickness(x, thickness = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertThickness_+3A_x">x</code></td>
<td>
<p>a filter_spct, object_spct, filter_mspct or object_mspct object.</p>
</td></tr>
<tr><td><code id="convertThickness_+3A_thickness">thickness</code></td>
<td>
<p>numeric [<code class="reqn">m</code>].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For spectral transmittance at a different thickness to be exactly
computed, it needs to be based on internal transmittance. This function
will apply <code>converTfrType()</code> to <code>x</code> if needed, but to succeed
metadata should be available. Please, see <code><a href="#topic+convertTfrType">convertTfrType</a></code>.
</p>


<h3>Value</h3>

<p><code>x</code> possibly with the <code>"thickness"</code> field of the
<code>"filter.properties"</code> attribute modified and <code>Tfr</code> or <code>A</code>
computed for the requested thickness.
</p>


<h3>Note</h3>

<p>if <code>x</code> is not a <code>filter_spct</code>, <code>object_spct</code>,
<code>filter_mspct</code> or <code>object_mspct</code> object or a collection of such
objects, <code>x</code> is returned unchanged. If <code>x</code> does not have the
<code>"filter.properties"</code> attribute set or has it with missing member
data, <code>x</code> is returned with <code>Tfr</code> set to <code>NA</code> values.
</p>


<h3>See Also</h3>

<p>Other time attribute functions: 
<code><a href="#topic+checkTimeUnit">checkTimeUnit</a>()</code>,
<code><a href="#topic+convertTimeUnit">convertTimeUnit</a>()</code>,
<code><a href="#topic+getTimeUnit">getTimeUnit</a>()</code>,
<code><a href="#topic+setTimeUnit">setTimeUnit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.spct &lt;- polyester.spct
filter_properties(my.spct)
convertThickness(my.spct, thickness = 250e-6)

</code></pre>

<hr>
<h2 id='convertTimeUnit'>Convert the &quot;time.unit&quot; attribute of an existing source_spct object</h2><span id='topic+convertTimeUnit'></span>

<h3>Description</h3>

<p>Function to set the &quot;time.unit&quot; attribute and simultaneously rescaling the
spectral data to be expressed using the new time unit as basis of expression.
The change is done by reference ('in place').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertTimeUnit(x, time.unit = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertTimeUnit_+3A_x">x</code></td>
<td>
<p>source_spct or response_spct object</p>
</td></tr>
<tr><td><code id="convertTimeUnit_+3A_time.unit">time.unit</code></td>
<td>
<p>a character string, either &quot;second&quot;, &quot;hour&quot;, &quot;day&quot;,
&quot;exposure&quot; or &quot;none&quot;, or a lubridate::duration</p>
</td></tr>
<tr><td><code id="convertTimeUnit_+3A_...">...</code></td>
<td>
<p>(currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x possibly with the <code>time.unit</code> attribute modified
</p>


<h3>Note</h3>

<p>if x is not a <code>source_spct</code> or a <code>response_spct</code> object, or
time.unit is NULL x is returned unchanged, if the existing or new time.unit
cannot be converted to a duration, then the returned spectrum will contain
NAs.
</p>


<h3>See Also</h3>

<p>Other time attribute functions: 
<code><a href="#topic+checkTimeUnit">checkTimeUnit</a>()</code>,
<code><a href="#topic+convertThickness">convertThickness</a>()</code>,
<code><a href="#topic+getTimeUnit">getTimeUnit</a>()</code>,
<code><a href="#topic+setTimeUnit">setTimeUnit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.spct &lt;- sun.spct
my.spct
convertTimeUnit(my.spct, "day")
my.spct

</code></pre>

<hr>
<h2 id='convolve_each'>Convolve function for collections of spectra</h2><span id='topic+convolve_each'></span>

<h3>Description</h3>

<p>Convolve function for collections of spectra which applies an operation on
all the individual members of the collection(s) of spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convolve_each(e1, e2, oper = `*`, sep = "_", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convolve_each_+3A_e1">e1</code></td>
<td>
<p>an object of class <code>generic_mspct</code> or <code>generic_scpt</code> or
<code>numeric</code></p>
</td></tr>
<tr><td><code id="convolve_each_+3A_e2">e2</code></td>
<td>
<p>an object of class <code>generic_mspct</code> or <code>generic_scpt</code> or
<code>numeric</code></p>
</td></tr>
<tr><td><code id="convolve_each_+3A_oper">oper</code></td>
<td>
<p>function, usually but not necessarily an operator with two
arguments.</p>
</td></tr>
<tr><td><code id="convolve_each_+3A_sep">sep</code></td>
<td>
<p>character Used when pasting the names of members of <code>e1</code> and
<code>e2</code> to form the names of members of the returned collection of
spectra.</p>
</td></tr>
<tr><td><code id="convolve_each_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>oper</code> if present.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>At least one of e1 and e2 must be a <code>generic_mspct</code> object or
derived.
</p>


<h3>See Also</h3>

<p>Other math operators and functions: 
<code><a href="#topic+MathFun">MathFun</a></code>,
<code><a href="#topic++5E.generic_spct">^.generic_spct</a>()</code>,
<code><a href="#topic+div-.generic_spct">div-.generic_spct</a></code>,
<code><a href="#topic+log">log</a>()</code>,
<code><a href="#topic+minus-.generic_spct">minus-.generic_spct</a></code>,
<code><a href="#topic+mod-.generic_spct">mod-.generic_spct</a></code>,
<code><a href="#topic+plus-.generic_spct">plus-.generic_spct</a></code>,
<code><a href="#topic+round">round</a>()</code>,
<code><a href="#topic+sign">sign</a>()</code>,
<code><a href="#topic+slash-.generic_spct">slash-.generic_spct</a></code>,
<code><a href="#topic+times-.generic_spct">times-.generic_spct</a></code>
</p>

<hr>
<h2 id='copy_attributes'>Copy attributes</h2><span id='topic+copy_attributes'></span><span id='topic+copy_attributes.default'></span><span id='topic+copy_attributes.generic_spct'></span><span id='topic+copy_attributes.generic_mspct'></span><span id='topic+copy_attributes.waveband'></span>

<h3>Description</h3>

<p>Copy attributes from <code>x</code> to <code>y</code>. Methods defined for spectral
and waveband objects of classes from package 'photobiology'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_attributes(x, y, which, ...)

## Default S3 method:
copy_attributes(x, y, which = NULL, ...)

## S3 method for class 'generic_spct'
copy_attributes(x, y, which = NULL, which.not = NULL, copy.class = FALSE, ...)

## S3 method for class 'generic_mspct'
copy_attributes(x, y, which = NULL, which.not = NULL, copy.class = FALSE, ...)

## S3 method for class 'waveband'
copy_attributes(x, y, which = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_attributes_+3A_x">x</code>, <code id="copy_attributes_+3A_y">y</code></td>
<td>
<p>R objects</p>
</td></tr>
<tr><td><code id="copy_attributes_+3A_which">which</code></td>
<td>
<p>character Names of attributes to copy, if NULL all those
relevant according to the class of <code>x</code> is used as defaul,</p>
</td></tr>
<tr><td><code id="copy_attributes_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="copy_attributes_+3A_which.not">which.not</code></td>
<td>
<p>character Names of attributes not to be copied. The
names passed here are removed from the list for <code>which</code>, which
is most useful when we want to modify the default.</p>
</td></tr>
<tr><td><code id="copy_attributes_+3A_copy.class">copy.class</code></td>
<td>
<p>logical If TRUE class attributes are also copied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>y</code> with additional attributes set.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>copy_attributes(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>copy_attributes(generic_spct)</code>: 
</p>
</li>
<li> <p><code>copy_attributes(generic_mspct)</code>: 
</p>
</li>
<li> <p><code>copy_attributes(waveband)</code>: 
</p>
</li></ul>

<hr>
<h2 id='cps2irrad'>Conversion from counts per second to physical quantities</h2><span id='topic+cps2irrad'></span><span id='topic+cps2Rfr'></span><span id='topic+cps2Tfr'></span>

<h3>Description</h3>

<p>Conversion of spectral data expressed as cps into irradiance, transmittance
or reflectance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cps2irrad(x.sample, pre.fun = NULL, missing.pixs = numeric(0), ...)

cps2Rfr(x.sample, x.white, x.black = NULL, dyn.range = NULL)

cps2Tfr(x.sample, x.clear, x.opaque = NULL, dyn.range = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cps2irrad_+3A_x.sample">x.sample</code>, <code id="cps2irrad_+3A_x.clear">x.clear</code>, <code id="cps2irrad_+3A_x.opaque">x.opaque</code>, <code id="cps2irrad_+3A_x.white">x.white</code>, <code id="cps2irrad_+3A_x.black">x.black</code></td>
<td>
<p>cps_spct objects.</p>
</td></tr>
<tr><td><code id="cps2irrad_+3A_pre.fun">pre.fun</code></td>
<td>
<p>function A function applied to x.sample before conversion.</p>
</td></tr>
<tr><td><code id="cps2irrad_+3A_missing.pixs">missing.pixs</code></td>
<td>
<p>integer Index to positions in the detector
array or scan missing in <code>x.sample</code> but present in the embedded
calibration data. (Use only for emergency recovery of incomplete data!!)</p>
</td></tr>
<tr><td><code id="cps2irrad_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>pre.fun</code>.</p>
</td></tr>
<tr><td><code id="cps2irrad_+3A_dyn.range">dyn.range</code></td>
<td>
<p>numeric The effective dynamic range of the instrument,
if <code>NULL</code> it is automatically set based on integration time
bracketing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A source_spct, filter_spct or reflector_spct object containing the
spectral values expressed in physical units.
</p>


<h3>Note</h3>

<p>In contrast to other classes defined in package 'photobiology', class
&quot;cps_spct&quot; can have more than one column of cps counts in cases where the
intention is to merge these values as part of the processing at the time
the calibration is applied. However, being these functions the final step
in the conversion to physical units, they accept as input only objects
with a single &quot;cps&quot; column, as merging is expected to have been already
done.
</p>

<hr>
<h2 id='D2_spectrum'>Calculate deuterium lamp output spectrum from fitted constants</h2><span id='topic+D2_spectrum'></span>

<h3>Description</h3>

<p>Calculate values by means of a nth degree polynomial from
user-supplied constants (for example from a lamp calibration certificate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D2_spectrum(w.length, k = photobiology::D2.UV653, fill = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D2_spectrum_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths (nm) for output</p>
</td></tr>
<tr><td><code id="D2_spectrum_+3A_k">k</code></td>
<td>
<p>a polynom:polynomial object with n constants for the polynomial</p>
</td></tr>
<tr><td><code id="D2_spectrum_+3A_fill">fill</code></td>
<td>
<p>if NA, no extrapolation is done, and NA is returned for
wavelengths outside the range 190 nm to 450 nm. If NULL then the tails are
deleted. If 0 then the tails are set to zero, etc. NA is default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with four numeric vectors with wavelength values
(w.length), energy and photon irradiance (s.e.irrad, s.q.irrad) depending
on the argument passed to unit.out (s.irrad).
</p>


<h3>Note</h3>

<p>This is function is valid for wavelengths in the range 180 nm to 495
nm, for wavelengths outside this range NAs are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D2_spectrum(200)
D2_spectrum(170:220)

</code></pre>

<hr>
<h2 id='D2.UV653'>Data for typical calibration lamps</h2><span id='topic+D2.UV653'></span><span id='topic+D2.UV586'></span><span id='topic+D2.UV654'></span><span id='topic+FEL.BN.9101.165'></span>

<h3>Description</h3>

<p>A dataset containing fitted constants to be used as input for
functions <code><a href="#topic+D2_spectrum">D2_spectrum</a></code> and <code><a href="#topic+FEL_spectrum">FEL_spectrum</a></code> for
computing example spectral curves based on fitted polynomials.
</p>


<h3>Format</h3>

<p>A <code>polynom::polynomial</code> object with 6 constants.
</p>


<h3>Details</h3>

<p>An object of class <code>polynom::polynomial</code>.
</p>


<h3>Author(s)</h3>

<p>Lasse Ylianttila (data)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D2.UV653
as.character(D2.UV653)

</code></pre>

<hr>
<h2 id='D65.illuminant.spct'>CIE D65 illuminant data</h2><span id='topic+D65.illuminant.spct'></span>

<h3>Description</h3>

<p>A dataset containing wavelengths at a 5 nm interval (300 nm to
830 nm) and the corresponding spectral energy irradiance normalized to 1 at
560 nm. Spectrum approximates the midday solar spectrum at middle latitude
as 'corresponds' to the white point of a black body a 6504 K. Original data
from <a href="http://files.cie.co.at/204.xls">http://files.cie.co.at/204.xls</a> downloaded on 2014-07-25 The
variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D65.illuminant.spct
</code></pre>


<h3>Format</h3>

<p>A source spectrum with 107 rows and 2 variables
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm) </p>
</li>
<li><p> s.e.irrad (rel. units) </p>
</li></ul>



<h3>Author(s)</h3>

<p>CIE
</p>


<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D65.illuminant.spct

</code></pre>

<hr>
<h2 id='day_night'>Times for sun positions</h2><span id='topic+day_night'></span><span id='topic+day_night_fast'></span><span id='topic+is_daytime'></span><span id='topic+noon_time'></span><span id='topic+sunrise_time'></span><span id='topic+sunset_time'></span><span id='topic+day_length'></span><span id='topic+night_length'></span>

<h3>Description</h3>

<p>Functions for calculating the timing of solar positions, given geographical
coordinates and dates. They can be also used to find the time for an
arbitrary solar elevation between 90 and -90 degrees by supplying &quot;twilight&quot;
angle(s) as argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>day_night(
  date = lubridate::now(tzone = "UTC"),
  tz = ifelse(lubridate::is.Date(date), "UTC", lubridate::tz(date)),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "none",
  unit.out = "hours"
)

day_night_fast(date, tz, geocode, twilight, unit.out)

is_daytime(
  date = lubridate::now(tzone = "UTC"),
  tz = ifelse(lubridate::is.Date(date), "UTC", lubridate::tz(date)),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "none",
  unit.out = "hours"
)

noon_time(
  date = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(date),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "none",
  unit.out = "datetime"
)

sunrise_time(
  date = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(date),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "sunlight",
  unit.out = "datetime"
)

sunset_time(
  date = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(date),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "sunlight",
  unit.out = "datetime"
)

day_length(
  date = lubridate::now(tzone = "UTC"),
  tz = "UTC",
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "sunlight",
  unit.out = "hours"
)

night_length(
  date = lubridate::now(tzone = "UTC"),
  tz = "UTC",
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "sunlight",
  unit.out = "hours"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="day_night_+3A_date">date</code></td>
<td>
<p>&quot;vector&quot; of <code>POSIXct</code> times or<code>Date</code> objects, any valid
TZ is allowed, default is current date at Greenwich matching the default
for <code>geocode</code>.</p>
</td></tr>
<tr><td><code id="day_night_+3A_tz">tz</code></td>
<td>
<p>character vector indicating time zone to be used in output and to
interpret <code>Date</code> values passed as argument to <code>date</code>.</p>
</td></tr>
<tr><td><code id="day_night_+3A_geocode">geocode</code></td>
<td>
<p>data frame with one or more rows and variables lon and lat as
numeric values (degrees). If present, address will be copied to the output.</p>
</td></tr>
<tr><td><code id="day_night_+3A_twilight">twilight</code></td>
<td>
<p>character string, one of &quot;none&quot;, &quot;rim&quot;, &quot;refraction&quot;,
&quot;sunlight&quot;, &quot;civil&quot;, &quot;nautical&quot;, &quot;astronomical&quot;, or a <code>numeric</code> vector
of length one, or two, giving solar elevation angle(s) in degrees (negative
if below the horizon).</p>
</td></tr>
<tr><td><code id="day_night_+3A_unit.out">unit.out</code></td>
<td>
<p>character string, One of &quot;datetime&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;,
or &quot;second&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Twilight names are interpreted as follows. &quot;none&quot;: solar elevation =
0 degrees. &quot;rim&quot;: upper rim of solar disk at the horizon or solar elevation
= -0.53 / 2. &quot;refraction&quot;: solar elevation = 0 degrees + refraction
correction. &quot;sunlight&quot;: upper rim of solar disk corrected for refraction,
which is close to the value used by the online NOAA Solar Calculator.
&quot;civil&quot;: -6 degrees, &quot;naval&quot;: -12 degrees, and &quot;astronomical&quot;: -18 degrees.
Unit names for output are as follows: &quot;day&quot;, &quot;hours&quot;, &quot;minutes&quot; and
&quot;seconds&quot; times for sunrise and sunset are returned as times-of-day since
midnight expressed in the chosen unit. &quot;date&quot; or &quot;datetime&quot; return the same
times as datetime objects with TZ set (this is much slower than &quot;hours&quot;).
Day length and night length are returned as numeric values expressed in
hours when &lsquo;&quot;datetime&quot;&rsquo; is passed as argument to <code>unit.out</code>. If
twilight is a numeric vector of length two, the element with index 1 is
used for sunrise and that with index 2 for sunset.
</p>
<p><code>is_daytime()</code> supports twilight specifications by name, a test
like <code>sun_elevation() &gt; 0</code> may be used directly for a numeric angle.
</p>


<h3>Value</h3>

<p>A tibble with variables day, tz, twilight.rise, twilight.set,
longitude, latitude, address, sunrise, noon, sunset, daylength,
nightlength or the corresponding individual vectors.
</p>
<p><code>is_daytime()</code> returns a logical vector, with <code>TRUE</code> for
day time and <code>FALSE</code> for night time.
</p>
<p><code>noon_time</code>, <code>sunrise_time</code> and <code>sunset_time</code> return a
vector of POSIXct times
</p>
<p><code>day_length</code> and <code>night_length</code> return numeric a vector
giving the length in hours
</p>


<h3>Warning</h3>

<p>Be aware that R's <code>Date</code> class does not save time zone
metadata. This can lead to ambiguities in the current implementation
based on time instants. The argument passed to <code>date</code> should be
of class <code>POSIXct</code>, in other words an instant in time, from which
the correct date will be computed based on the <code>tz</code> argument.
</p>
<p>The time zone in which times passed to <code>date</code> as argument are
expressed does not need to be the local one or match the geocode, however,
the returned values will be in the same time zone as the input.
</p>


<h3>Note</h3>

<p>Function <code>day_night()</code> is an implementation of Meeus equations as
used in NOAAs on-line web calculator, which are very precise and valid for
a very broad range of dates. For sunrise and sunset the times are affected
by refraction in the atmosphere, which does in turn depend on weather
conditions. The effect of refraction on the apparent position of the sun is
only an estimate based on &quot;typical&quot; conditions. The more tangential to the
horizon is the path of the sun, the larger the effect of refraction is on
the times of visual occlusion of the sun behind the horizon&mdash;i.e. the
largest timing errors occur at high latitudes. The computation is not
defined for latitudes 90 and -90 degrees, i.e. at the poles.
</p>
<p>There exists a different R implementation of the same algorithms called
&quot;AstroCalcPureR&quot; available as function <code>astrocalc4r</code> in package
'fishmethods'. Although the equations used are almost all the same, the
function signatures and which values are returned differ. In particular,
the implementation in 'photobiology' splits the calculation into two
separate functions, one returning angles at given instants in time, and a
separate one returning the timing of events for given dates. In
'fishmethods' (= 1.11-0) there is a bug in function astrocalc4r() that
affects sunrise and sunset times. The times returned by the functions in
package 'photobiology' have been validated against the NOAA base
implementation.
</p>
<p>In the current implementation functions <code>sunrise_time</code>,
<code>noon_time</code>, <code>sunset_time</code>, <code>day_length</code>,
<code>night_length</code> and <code>is_daytime</code> are all wrappers
on <code>day_night</code>, so if more than one quantity is needed it is
preferable to directly call <code>day_night</code> and extract the different
components from the returned list.
</p>
<p><code>night_length</code> returns the length of night-time conditions in one
day (00:00:00 to 23:59:59), rather than the length of the night between two
consecutive days.
</p>


<h3>References</h3>

<p>The primary source for the algorithm used is the book:
Meeus, J. (1998) Astronomical Algorithms, 2 ed., Willmann-Bell, Richmond,
VA, USA. ISBN 978-0943396613.
</p>
<p>A different implementation is available at
<a href="https://github.com/NEFSC/READ-PDB-AstroCalc4R/">https://github.com/NEFSC/READ-PDB-AstroCalc4R/</a> and in R paclage
'fishmethods'. In 'fishmethods' (= 1.11-0) there is a bug in function
astrocalc4r() that affects sunrise and sunset times.
</p>
<p>An interactive web page using the same algorithms is available at
<a href="https://gml.noaa.gov/grad/solcalc/">https://gml.noaa.gov/grad/solcalc/</a>. There are small
differences in the returned times compared to our function that seem to be
related to the estimation of atmospheric refraction (about 0.1 degrees).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sun_angles">sun_angles</a></code>.
</p>
<p>Other astronomy related functions: 
<code><a href="#topic+format.solar_time">format.solar_time</a>()</code>,
<code><a href="#topic+sun_angles">sun_angles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

my.geocode &lt;- data.frame(lon = 24.93838,
                         lat = 60.16986,
                         address = "Helsinki, Finland")

day_night(ymd("2015-05-30", tz = "EET"),
          geocode = my.geocode)
day_night(ymd("2015-05-30", tz = "EET") + days(1:10),
          geocode = my.geocode,
          twilight = "civil")
sunrise_time(ymd("2015-05-30", tz = "EET"),
             geocode = my.geocode)
noon_time(ymd("2015-05-30", tz = "EET"),
          geocode = my.geocode)
sunset_time(ymd("2015-05-30", tz = "EET"),
            geocode = my.geocode)
day_length(ymd("2015-05-30", tz = "EET"),
           geocode = my.geocode)
day_length(ymd("2015-05-30", tz = "EET"),
           geocode = my.geocode,
           unit.out = "day")
is_daytime(ymd("2015-05-30", tz = "EET") + hours(c(0, 6, 12, 18, 24)),
           geocode = my.geocode)
is_daytime(ymd_hms("2015-05-30 03:00:00", tz = "EET"),
           geocode = my.geocode)
is_daytime(ymd_hms("2015-05-30 00:00:00", tz = "UTC"),
           geocode = my.geocode)
is_daytime(ymd_hms("2015-05-30 03:00:00", tz = "EET"),
           geocode = my.geocode,
           twilight = "civil")
is_daytime(ymd_hms("2015-05-30 00:00:00", tz = "UTC"),
           geocode = my.geocode,
           twilight = "civil")

</code></pre>

<hr>
<h2 id='defunct'>Defunct functions and methods</h2><span id='topic+defunct'></span><span id='topic+f_mspct'></span><span id='topic+mutate_mspct'></span><span id='topic+calc_filter_multipliers'></span><span id='topic+T2T'></span><span id='topic+getAfrType'></span><span id='topic+setAfrType'></span><span id='topic+sample_spct'></span><span id='topic+sample_mspct'></span>

<h3>Description</h3>

<p>Functions listed here have been removed or deleted, and temporarily replaced
by stubs that report this when they are called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_mspct(...)

mutate_mspct(...)

calc_filter_multipliers(...)

T2T(...)

getAfrType(...)

setAfrType(...)

sample_spct(...)

sample_mspct(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defunct_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Function <code>f_mspct()</code> has been renamed <code>msdply()</code>.
</p>
<p>Function <code>mutate_mspct()</code> has been renamed <code>msmsply()</code>.
</p>
<p>Function <code>calc_filter_multipliers()</code> has been removed.
</p>
<p>Function <code>calc_filter_multipliers()</code> has been removed.
</p>
<p>Method <code>getAfrType()</code> has been removed.
</p>
<p>Method <code>setAfrType()</code> has been removed.
</p>
<p>Function <code>sample_spct()</code> has been removed.
</p>
<p>Function <code>sample_mspct()</code> has been removed.
</p>

<hr>
<h2 id='despike'>Remove spikes from spectrum</h2><span id='topic+despike'></span><span id='topic+despike.default'></span><span id='topic+despike.numeric'></span><span id='topic+despike.data.frame'></span><span id='topic+despike.generic_spct'></span><span id='topic+despike.source_spct'></span><span id='topic+despike.response_spct'></span><span id='topic+despike.filter_spct'></span><span id='topic+despike.reflector_spct'></span><span id='topic+despike.solute_spct'></span><span id='topic+despike.cps_spct'></span><span id='topic+despike.raw_spct'></span><span id='topic+despike.generic_mspct'></span><span id='topic+despike.source_mspct'></span><span id='topic+despike.response_mspct'></span><span id='topic+despike.filter_mspct'></span><span id='topic+despike.reflector_mspct'></span><span id='topic+despike.solute_mspct'></span><span id='topic+despike.cps_mspct'></span><span id='topic+despike.raw_mspct'></span>

<h3>Description</h3>

<p>Function that returns an R object with observations corresponding to spikes
replaced by values computed from neighboring pixels. Spikes are values in
spectra that are unusually high compared to neighbors. They are usually
individual values or very short runs of similar &quot;unusual&quot; values. Spikes
caused by cosmic radiation are a frequent problem in Raman spectra. Another
source of spikes are &quot;hot pixels&quot; in CCD and diode array detectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>despike(x, z.threshold, max.spike.width, window.width, method, na.rm, ...)

## Default S3 method:
despike(
  x,
  z.threshold = NA,
  max.spike.width = NA,
  window.width = NA,
  method = "run.mean",
  na.rm = FALSE,
  ...
)

## S3 method for class 'numeric'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...
)

## S3 method for class 'data.frame'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...,
  y.var.name = NULL,
  var.name = y.var.name
)

## S3 method for class 'generic_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  y.var.name = NULL,
  var.name = y.var.name,
  ...
)

## S3 method for class 'source_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'response_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'filter_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  filter.qty = getOption("photobiology.filter.qty", default = "transmittance"),
  ...
)

## S3 method for class 'reflector_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...
)

## S3 method for class 'solute_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...
)

## S3 method for class 'cps_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...
)

## S3 method for class 'raw_spct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...
)

## S3 method for class 'generic_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...,
  y.var.name = NULL,
  var.name = y.var.name,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'source_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'response_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'filter_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  filter.qty = getOption("photobiology.filter.qty", default = "transmittance"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'reflector_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'solute_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'cps_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'raw_mspct'
despike(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  window.width = 11,
  method = "run.mean",
  na.rm = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="despike_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="despike_+3A_z.threshold">z.threshold</code></td>
<td>
<p>numeric Modified Z values larger than <code>z.threshold</code>
are considered to correspond to spikes.</p>
</td></tr>
<tr><td><code id="despike_+3A_max.spike.width">max.spike.width</code></td>
<td>
<p>integer Wider regions with high Z values are not detected as
spikes.</p>
</td></tr>
<tr><td><code id="despike_+3A_window.width">window.width</code></td>
<td>
<p>integer. The full width of the window used for the
running mean used as replacement.</p>
</td></tr>
<tr><td><code id="despike_+3A_method">method</code></td>
<td>
<p>character The name of the method: <code>"run.mean"</code> is running
mean as described in Whitaker and Hayes (2018); <code>"adj.mean"</code> is mean
of adjacent neighbors (isolated bad pixels only).</p>
</td></tr>
<tr><td><code id="despike_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be treated
as spikes and replaced.</p>
</td></tr>
<tr><td><code id="despike_+3A_...">...</code></td>
<td>
<p>Arguments passed by name to <code>find_spikes()</code>.</p>
</td></tr>
<tr><td><code id="despike_+3A_var.name">var.name</code>, <code id="despike_+3A_y.var.name">y.var.name</code></td>
<td>
<p>character Names of columns where to look
for spikes to remove.</p>
</td></tr>
<tr><td><code id="despike_+3A_unit.out">unit.out</code></td>
<td>
<p>character One of &quot;energy&quot; or &quot;photon&quot;</p>
</td></tr>
<tr><td><code id="despike_+3A_filter.qty">filter.qty</code></td>
<td>
<p>character One of &quot;transmittance&quot; or &quot;absorbance&quot;</p>
</td></tr>
<tr><td><code id="despike_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="despike_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spikes are detected based on a modified Z score calculated from the
differenced spectrum. The Z threshold used should be adjusted to the
characteristics of the input and desired sensitivity. The lower the
threshold the more stringent the test becomes, resulting in most cases in
more spikes being detected. A modified version of the algorithm is used if
a value different from <code>NULL</code> is passed as argument to
<code>max.spike.width</code>. In such a case, an additional step filters out
broader spikes (or falsely detected steep slopes) from the returned values.
</p>
<p>Simple interpolation replaces values of isolated bad pixels by the mean of
their two closest neighbors. The running mean approach allows the
replacement of short runs of bad pixels by the running mean of neighboring
pixels within a window of user-specified width. The first approach works
well for spectra from array spectrometers to correct for hot and dead
pixels in an instrument. The second approach is most suitable for Raman
spectra in which spikes triggered by radiation are wider than a single
pixel but usually not more than five pixels wide.
</p>
<p>When the argument passed to <code>x</code> contains multiple spectra, the spikes
are searched for and replaced in each spectrum independently of other
spectra.
</p>


<h3>Value</h3>

<p>A copy of the object passed as argument to <code>x</code> with values
detected as spikes replaced by a local average of adjacent neighbors
outside the spike.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>despike(default)</code>: Default returning always NA.
</p>
</li>
<li> <p><code>despike(numeric)</code>: Default function usable on numeric vectors.
</p>
</li>
<li> <p><code>despike(data.frame)</code>: Method for &quot;data.frame&quot; objects.
</p>
</li>
<li> <p><code>despike(generic_spct)</code>: Method for &quot;generic_spct&quot; objects.
</p>
</li>
<li> <p><code>despike(source_spct)</code>: Method for &quot;source_spct&quot; objects.
</p>
</li>
<li> <p><code>despike(response_spct)</code>: Method for &quot;response_spct&quot; objects.
</p>
</li>
<li> <p><code>despike(filter_spct)</code>: Method for &quot;filter_spct&quot; objects.
</p>
</li>
<li> <p><code>despike(reflector_spct)</code>: Method for &quot;reflector_spct&quot; objects.
</p>
</li>
<li> <p><code>despike(solute_spct)</code>: Method for &quot;solute_spct&quot; objects.
</p>
</li>
<li> <p><code>despike(cps_spct)</code>: Method for &quot;cps_spct&quot; objects.
</p>
</li>
<li> <p><code>despike(raw_spct)</code>: Method for &quot;raw_spct&quot; objects.
</p>
</li>
<li> <p><code>despike(generic_mspct)</code>: Method for &quot;generic_mspct&quot; objects.
</p>
</li>
<li> <p><code>despike(source_mspct)</code>: Method for &quot;source_mspct&quot; objects.
</p>
</li>
<li> <p><code>despike(response_mspct)</code>: Method for &quot;cps_mspct&quot; objects.
</p>
</li>
<li> <p><code>despike(filter_mspct)</code>: Method for &quot;filter_mspct&quot; objects.
</p>
</li>
<li> <p><code>despike(reflector_mspct)</code>: Method for &quot;reflector_mspct&quot; objects.
</p>
</li>
<li> <p><code>despike(solute_mspct)</code>: Method for &quot;solute_mspct&quot; objects.
</p>
</li>
<li> <p><code>despike(cps_mspct)</code>: Method for &quot;cps_mspct&quot; objects.
</p>
</li>
<li> <p><code>despike(raw_mspct)</code>: Method for &quot;raw_mspct&quot; objects.
</p>
</li></ul>


<h3>Note</h3>

<p>Current algorithm misidentifies steep smooth slopes as spikes, so
manual inspection is needed together with adjustment by trial and error
of a suitable argument value for <code>z.threshold</code>.
</p>


<h3>See Also</h3>

<p>See the documentation for <code><a href="#topic+find_spikes">find_spikes</a></code> and
<code><a href="#topic+replace_bad_pixs">replace_bad_pixs</a></code> for details of the algorithm and
implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
white_led.raw_spct[120:125, ]

# find and replace spike at 245.93 nm
despike(white_led.raw_spct,
        z.threshold = 10,
        window.width = 25)[120:125, ]

</code></pre>

<hr>
<h2 id='diffraction_single_slit'>Diffraction</h2><span id='topic+diffraction_single_slit'></span><span id='topic+diffraction_double_slit'></span>

<h3>Description</h3>

<p>Diffraction of optical radiation passing through a single slit can
be computed with function <code>diffraction_single_slit()</code>, which
implements Fraunhofer's equation. Diffraction plus interference for a
pair of slits can be computed with <code>diffraction_double_slit()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffraction_single_slit(w.length, slit.width, angle)

diffraction_double_slit(w.length, slit.width, slit.distance, angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffraction_single_slit_+3A_w.length">w.length</code></td>
<td>
<p>numeric Wavelength (nm).</p>
</td></tr>
<tr><td><code id="diffraction_single_slit_+3A_slit.width">slit.width</code></td>
<td>
<p>numeric Width of the slit (m).</p>
</td></tr>
<tr><td><code id="diffraction_single_slit_+3A_angle">angle</code></td>
<td>
<p>numeric vector Angle (radians).</p>
</td></tr>
<tr><td><code id="diffraction_single_slit_+3A_slit.distance">slit.distance</code></td>
<td>
<p>numeric Distance between the centres of the two slits
(m).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>angle</code>, containing
relative intensities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diffraction_single_slit(w.length = 550,
                             slit.width = 1e-5,
                             angle = 0)

# use odd number for length.out so that 0 is in the sequence
angles &lt;- pi * seq(from = -1/2, to = 1/2, length.out = 501)

plot(angles,
     diffraction_single_slit(w.length = 550, # 550 nm
                             slit.width = 6e-6, # 6 um
                             angle = angles),
     type = "l",
     ylab = "Relative irradiance (/1)",
     xlab = "Angle (radian)")

plot(angles,
     diffraction_double_slit(w.length = 550, # 550 nm
                             slit.width = 6e-6, # 6 um
                             slit.distance = 18e-6, # 18 um
                             angle = angles),
     type = "l",
     ylab = "Relative irradiance (/1)",
     xlab = "Angle (radian)")

</code></pre>

<hr>
<h2 id='dim.generic_mspct'>Dimensions of an Object</h2><span id='topic+dim.generic_mspct'></span><span id='topic+dim+3C-.generic_mspct'></span>

<h3>Description</h3>

<p>Retrieve or set the dimension of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_mspct'
dim(x)

## S3 replacement method for class 'generic_mspct'
dim(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim.generic_mspct_+3A_x">x</code></td>
<td>
<p>A <code>generic_mspct</code> object or of a derived class.</p>
</td></tr>
<tr><td><code id="dim.generic_mspct_+3A_value">value</code></td>
<td>
<p>Either NULL or a numeric vector, which is coerced to integer (by
truncation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either NULL or a numeric vector, which is coerced to integer (by
truncation).
</p>

<hr>
<h2 id='div_spectra'>Divide two spectra, even if the wavelengths values differ</h2><span id='topic+div_spectra'></span>

<h3>Description</h3>

<p>The wavelength vectors of the two spectra are merged, and the missing
spectral values are calculated by interpolation. After this, the two spectral
values at each wavelength are operated upon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>div_spectra(
  w.length1,
  w.length2 = NULL,
  s.irrad1,
  s.irrad2,
  trim = "union",
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="div_spectra_+3A_w.length1">w.length1</code></td>
<td>
<p>numeric vector of wavelength (nm) of denominator.</p>
</td></tr>
<tr><td><code id="div_spectra_+3A_w.length2">w.length2</code></td>
<td>
<p>numeric vector of wavelength (nm) of divisor.</p>
</td></tr>
<tr><td><code id="div_spectra_+3A_s.irrad1">s.irrad1</code></td>
<td>
<p>a numeric vector of spectral values of denominator.</p>
</td></tr>
<tr><td><code id="div_spectra_+3A_s.irrad2">s.irrad2</code></td>
<td>
<p>a numeric vector of spectral values of divisor.</p>
</td></tr>
<tr><td><code id="div_spectra_+3A_trim">trim</code></td>
<td>
<p>a character string with value &quot;union&quot; or &quot;intersection&quot;.</p>
</td></tr>
<tr><td><code id="div_spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value, if TRUE, not the default, NAs in the input are
replaced with zeros.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If trim==&quot;union&quot; spectral values are calculated for the whole range
of wavelengths covered by at least one of the input spectra, and missing
values are set in each input spectrum to zero before addition. If
trim==&quot;intersection&quot; then the range of wavelengths covered by both input
spectra is returned, and the non-overlapping regions discarded. If
w.length2==NULL, it is assumed that both spectra are measured at the same
wavelengths, and a simple addition is used, ensuring fast calculation.
</p>


<h3>Value</h3>

<p>a dataframe with two numeric variables.
</p>
<table>
<tr><td><code>w.length</code></td>
<td>
<p>A numeric vector with the wavelengths (nm) obtained
by &quot;fusing&quot; w.length1 and
w.length2. w.length contains all the unique vales, sorted in ascending
order.</p>
</td></tr>
<tr><td><code>s.irrad</code></td>
<td>
<p>A numeric vector with the ratio between the two spectral
values at each wavelength.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(sun.data)
one.data &lt;- with(sun.data, div_spectra(w.length, w.length, s.e.irrad, s.e.irrad))
head(one.data)
tail(one.data)

</code></pre>

<hr>
<h2 id='div-.generic_spct'>Arithmetic Operators</h2><span id='topic+div-.generic_spct'></span><span id='topic++25+2F+25.generic_spct'></span>

<h3>Description</h3>

<p>Integer-division operator for generic spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
e1 %/% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="div-.generic_spct_+3A_e1">e1</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
<tr><td><code id="div-.generic_spct_+3A_e2">e2</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other math operators and functions: 
<code><a href="#topic+MathFun">MathFun</a></code>,
<code><a href="#topic++5E.generic_spct">^.generic_spct</a>()</code>,
<code><a href="#topic+convolve_each">convolve_each</a>()</code>,
<code><a href="#topic+log">log</a>()</code>,
<code><a href="#topic+minus-.generic_spct">minus-.generic_spct</a></code>,
<code><a href="#topic+mod-.generic_spct">mod-.generic_spct</a></code>,
<code><a href="#topic+plus-.generic_spct">plus-.generic_spct</a></code>,
<code><a href="#topic+round">round</a>()</code>,
<code><a href="#topic+sign">sign</a>()</code>,
<code><a href="#topic+slash-.generic_spct">slash-.generic_spct</a></code>,
<code><a href="#topic+times-.generic_spct">times-.generic_spct</a></code>
</p>

<hr>
<h2 id='drop_user_cols'>Drop user columns</h2><span id='topic+drop_user_cols'></span><span id='topic+drop_user_cols.default'></span><span id='topic+drop_user_cols.generic_spct'></span><span id='topic+drop_user_cols.source_spct'></span><span id='topic+drop_user_cols.response_spct'></span><span id='topic+drop_user_cols.object_spct'></span><span id='topic+drop_user_cols.filter_spct'></span><span id='topic+drop_user_cols.reflector_spct'></span><span id='topic+drop_user_cols.solute_spct'></span><span id='topic+drop_user_cols.chroma_spct'></span><span id='topic+drop_user_cols.calibration_spct'></span><span id='topic+drop_user_cols.cps_spct'></span><span id='topic+drop_user_cols.raw_spct'></span><span id='topic+drop_user_cols.generic_mspct'></span>

<h3>Description</h3>

<p>Remove from spectral object additional columns that are user defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_user_cols(x, keep.also, ...)

## Default S3 method:
drop_user_cols(x, keep.also = NULL, ...)

## S3 method for class 'generic_spct'
drop_user_cols(x, keep.also, ...)

## S3 method for class 'source_spct'
drop_user_cols(x, keep.also = NULL, ...)

## S3 method for class 'response_spct'
drop_user_cols(x, keep.also = NULL, ...)

## S3 method for class 'object_spct'
drop_user_cols(x, keep.also = NULL, ...)

## S3 method for class 'filter_spct'
drop_user_cols(x, keep.also = NULL, ...)

## S3 method for class 'reflector_spct'
drop_user_cols(x, keep.also = NULL, ...)

## S3 method for class 'solute_spct'
drop_user_cols(x, keep.also = NULL, ...)

## S3 method for class 'chroma_spct'
drop_user_cols(x, keep.also = NULL, ...)

## S3 method for class 'calibration_spct'
drop_user_cols(x, keep.also = NULL, ...)

## S3 method for class 'cps_spct'
drop_user_cols(x, keep.also = NULL, ...)

## S3 method for class 'raw_spct'
drop_user_cols(x, keep.also = NULL, ...)

## S3 method for class 'generic_mspct'
drop_user_cols(x, keep.also = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_user_cols_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
<tr><td><code id="drop_user_cols_+3A_keep.also">keep.also</code></td>
<td>
<p>character Additionlal columns to preserve.</p>
</td></tr>
<tr><td><code id="drop_user_cols_+3A_...">...</code></td>
<td>
<p>needed to allow derivation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> possibly with some columns removed.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>drop_user_cols(default)</code>: 
</p>
</li>
<li> <p><code>drop_user_cols(generic_spct)</code>: 
</p>
</li>
<li> <p><code>drop_user_cols(source_spct)</code>: 
</p>
</li>
<li> <p><code>drop_user_cols(response_spct)</code>: 
</p>
</li>
<li> <p><code>drop_user_cols(object_spct)</code>: 
</p>
</li>
<li> <p><code>drop_user_cols(filter_spct)</code>: 
</p>
</li>
<li> <p><code>drop_user_cols(reflector_spct)</code>: 
</p>
</li>
<li> <p><code>drop_user_cols(solute_spct)</code>: 
</p>
</li>
<li> <p><code>drop_user_cols(chroma_spct)</code>: 
</p>
</li>
<li> <p><code>drop_user_cols(calibration_spct)</code>: 
</p>
</li>
<li> <p><code>drop_user_cols(cps_spct)</code>: 
</p>
</li>
<li> <p><code>drop_user_cols(raw_spct)</code>: 
</p>
</li>
<li> <p><code>drop_user_cols(generic_mspct)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p>Other experimental utility functions: 
<code><a href="#topic+collect2mspct">collect2mspct</a>()</code>,
<code><a href="#topic+thin_wl">thin_wl</a>()</code>,
<code><a href="#topic+uncollect2spct">uncollect2spct</a>()</code>
</p>

<hr>
<h2 id='e_fluence'>Energy fluence</h2><span id='topic+e_fluence'></span><span id='topic+e_fluence.default'></span><span id='topic+e_fluence.source_spct'></span><span id='topic+e_fluence.source_mspct'></span>

<h3>Description</h3>

<p>Energy fluence for one or more wavebands of a light source spectrum and a
duration of the exposure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e_fluence(
  spct,
  w.band,
  exposure.time,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## Default S3 method:
e_fluence(
  spct,
  w.band,
  exposure.time,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## S3 method for class 'source_spct'
e_fluence(
  spct,
  w.band = NULL,
  exposure.time,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = FALSE,
  naming = "default",
  ...
)

## S3 method for class 'source_mspct'
e_fluence(
  spct,
  w.band = NULL,
  exposure.time,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = FALSE,
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_fluence_+3A_spct">spct</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_w.band">w.band</code></td>
<td>
<p>a list of <code>waveband</code> objects or a <code>waveband</code> object</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_exposure.time">exposure.time</code></td>
<td>
<p>lubridate::duration object.</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_allow.scaled">allow.scaled</code></td>
<td>
<p>logical indicating whether scaled or normalized spectra
as argument to spct are flagged as an error</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="e_fluence_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One numeric value for each waveband with no change in scale factor,
with name attribute set to the name of each waveband unless a named list is
supplied in which case the names of the list elements are used. The
exposure.time is copied to the output as an attribute. Units are as
follows: (J) joules per exposure.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>e_fluence(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>e_fluence(source_spct)</code>: Calculate energy fluence from a <code>source_spct</code>
object and the duration of the exposure.
</p>
</li>
<li> <p><code>e_fluence(source_mspct)</code>: Calculates energy fluence from a <code>source_mspct</code>
object.
</p>
</li></ul>


<h3>Note</h3>

<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult=TRUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>See Also</h3>

<p>Other irradiance functions: 
<code><a href="#topic+e_irrad">e_irrad</a>()</code>,
<code><a href="#topic+fluence">fluence</a>()</code>,
<code><a href="#topic+irrad">irrad</a>()</code>,
<code><a href="#topic+q_fluence">q_fluence</a>()</code>,
<code><a href="#topic+q_irrad">q_irrad</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
e_fluence(sun.spct, w.band = waveband(c(400,700)),
          exposure.time = lubridate::duration(3, "minutes") )

</code></pre>

<hr>
<h2 id='e_fraction'>Energy:energy fraction</h2><span id='topic+e_fraction'></span><span id='topic+e_fraction.default'></span><span id='topic+e_fraction.source_spct'></span><span id='topic+e_fraction.source_mspct'></span>

<h3>Description</h3>

<p>This function returns the energy fraction for a given pair of wavebands of a
light source spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e_fraction(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## Default S3 method:
e_fraction(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## S3 method for class 'source_spct'
e_fraction(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "total",
  naming = "short",
  name.tag = NULL,
  ...
)

## S3 method for class 'source_mspct'
e_fraction(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "total",
  naming = "short",
  name.tag = ifelse(naming != "none", "[e:e]", ""),
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_fraction_+3A_spct">spct</code></td>
<td>
<p>source_spct</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_w.band.num">w.band.num</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the numerator(s) and denominator(s) of the fraction(s).</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_w.band.denom">w.band.denom</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the denominator(s) of the fraction(s).</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag telling whether multiplier values should be
cached between calls.</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_quantity">quantity</code></td>
<td>
<p>character One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_name.tag">name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach.</p>
</td></tr>
<tr><td><code id="e_fraction_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default <code>quantity = "total"</code> the fraction is based on
two <strong>energy irradiances</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{E(s, wb_\mathrm{num})}{E(s, wb_\mathrm{denom}) + E(s, wb_\mathrm{num})}</code>
</p>

<p>If the argument is set to <code>quantity = "mean"</code> or
<code>quantity = "average"</code> the ratio is based on
two <strong>mean spectral energy irradiances</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\overline{Q_\lambda}(s, wb_\mathrm{num})}{\overline{Q_\lambda}(s, wb_\mathrm{denom}) + \overline{Q_\lambda}(s, wb_\mathrm{num})}</code>
</p>

<p>Only if the wavelength expanse of the two wavebands is the same, these two
ratios are numerically identical.
</p>


<h3>Value</h3>

<p>In the case of methods for individual spectra, a <code>numeric</code>
vector with name attribute set. The name is based on the name of the
wavebands unless a named list of wavebands is supplied in which case the
names of the list elements are used. &quot;[e:e]&quot; is appended if <code>quantity
  = "total"</code> and &quot;[e(wl):e(wl)]&quot; if <code>quantity = "mean"</code> or
<code>quantity = "average"</code>.
</p>
<p>A <code>data.frame</code> is returned in the case of collections of spectra,
containing one column for each fraction definition, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>Fraction definitions are &quot;assembled&quot; from the arguments passed to
<code>w.band.num</code> and <code>w.band.denom</code>. If both arguments are lists of
waveband definitions, with an equal number of members, then the wavebands
are paired to obtain as many fractions as the number of wavebands in each
list. Recycling for wavebands takes place when the number of denominator
and numerator wavebands differ.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>e_fraction(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>e_fraction(source_spct)</code>: Method for <code>source_spct</code> objects
</p>
</li>
<li> <p><code>e_fraction(source_mspct)</code>: Calculates energy:energy fraction from a <code>source_mspct</code>
object.
</p>
</li></ul>


<h3>Note</h3>

<p>Recycling for wavebands takes place when the number of denominator and
denominator wavebands differ. The last two parameters control speed
optimizations. The defaults should be suitable in most cases. If you will
use repeatedly the same SWFs on many spectra measured at exactly the same
wavelengths you may obtain some speed up by setting
<code>use.cached.mult=TRUE</code>. However, be aware that you are responsible for
ensuring that the wavelengths are the same in each call, as the only test
done is for the length of the <code>w.length</code> vector.
</p>


<h3>See Also</h3>

<p>Other photon and energy ratio functions: 
<code><a href="#topic+e_ratio">e_ratio</a>()</code>,
<code><a href="#topic+eq_ratio">eq_ratio</a>()</code>,
<code><a href="#topic+q_fraction">q_fraction</a>()</code>,
<code><a href="#topic+q_ratio">q_ratio</a>()</code>,
<code><a href="#topic+qe_ratio">qe_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e_fraction(sun.spct, new_waveband(400,700), new_waveband(400,500))

</code></pre>

<hr>
<h2 id='e_irrad'>Energy irradiance</h2><span id='topic+e_irrad'></span><span id='topic+e_irrad.default'></span><span id='topic+e_irrad.source_spct'></span><span id='topic+e_irrad.source_mspct'></span>

<h3>Description</h3>

<p>Energy irradiance for one or more wavebands of a light source spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e_irrad(
  spct,
  w.band,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## Default S3 method:
e_irrad(
  spct,
  w.band,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## S3 method for class 'source_spct'
e_irrad(
  spct,
  w.band = NULL,
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = !quantity %in% c("average", "mean", "total"),
  naming = "default",
  return.tb = FALSE,
  ...
)

## S3 method for class 'source_mspct'
e_irrad(
  spct,
  w.band = NULL,
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = !quantity %in% c("average", "mean", "total"),
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_irrad_+3A_spct">spct</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_w.band">w.band</code></td>
<td>
<p>a list of <code>waveband</code> objects or a <code>waveband</code> object.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;,
&quot;contribution&quot;, &quot;contribution.pc&quot;, &quot;relative&quot; or &quot;relative.pc&quot;.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_time.unit">time.unit</code></td>
<td>
<p>character or lubridate::duration object.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_allow.scaled">allow.scaled</code></td>
<td>
<p>logical indicating whether scaled or normalized spectra
as argument to spct are flagged as an error.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_return.tb">return.tb</code></td>
<td>
<p>logical Flag forcing a tibble to be always returned, even
for a single spectrum as argumnet to <code>spct</code>. The default is
<code>FALSE</code> for backwards compatibility.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="e_irrad_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector in the case of a <code>_spct</code> object
containing a single spectrum and <code>return.tb = FALSE</code>. The vector has
one member one value for each <code>waveband</code> passed to parameter
<code>w.band</code>. In all other cases a <code>tibble</code>, containing one column
for each <code>waveband</code> object, an index column with the names of the
spectra, and optionally additional columns with metadata values retrieved
from the attributes of the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used. The time.unit
attribute is copied from the spectrum object to the output. Units are as
follows: If units are absolute and time.unit is second, [W m-2 nm-1] -&gt; [W
m-2] If time.unit is day, [J d-1 m-2 nm-1] -&gt; [J m-2]; if units are
relative, fraction of one or percent.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>e_irrad(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>e_irrad(source_spct)</code>: Calculates energy irradiance from a <code>source_spct</code>
object.
</p>
</li>
<li> <p><code>e_irrad(source_mspct)</code>: Calculates energy irradiance from a
<code>source_mspct</code> object.
</p>
</li></ul>


<h3>Note</h3>

<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult=TRUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>See Also</h3>

<p>Other irradiance functions: 
<code><a href="#topic+e_fluence">e_fluence</a>()</code>,
<code><a href="#topic+fluence">fluence</a>()</code>,
<code><a href="#topic+irrad">irrad</a>()</code>,
<code><a href="#topic+q_fluence">q_fluence</a>()</code>,
<code><a href="#topic+q_irrad">q_irrad</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e_irrad(sun.spct, waveband(c(400,700)))
e_irrad(sun.spct, split_bands(c(400,700), length.out = 3))
e_irrad(sun.spct, split_bands(c(400,700), length.out = 3),
        quantity = "total")
e_irrad(sun.spct, split_bands(c(400,700), length.out = 3),
        quantity = "average")
e_irrad(sun.spct, split_bands(c(400,700), length.out = 3),
        quantity = "relative")
e_irrad(sun.spct, split_bands(c(400,700), length.out = 3),
        quantity = "relative.pc")
e_irrad(sun.spct, split_bands(c(400,700), length.out = 3),
        quantity = "contribution")
e_irrad(sun.spct, split_bands(c(400,700), length.out = 3),
        quantity = "contribution.pc")

</code></pre>

<hr>
<h2 id='e_ratio'>Energy:energy ratio</h2><span id='topic+e_ratio'></span><span id='topic+e_ratio.default'></span><span id='topic+e_ratio.source_spct'></span><span id='topic+e_ratio.source_mspct'></span>

<h3>Description</h3>

<p>This function returns the photon ratio for a given pair of wavebands of a
light source spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e_ratio(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## Default S3 method:
e_ratio(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## S3 method for class 'source_spct'
e_ratio(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "total",
  naming = "short",
  name.tag = NULL,
  ...
)

## S3 method for class 'source_mspct'
e_ratio(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "total",
  naming = "short",
  name.tag = ifelse(naming != "none", "[e:e]", ""),
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_ratio_+3A_spct">spct</code></td>
<td>
<p>source_spct</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_w.band.num">w.band.num</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the numerator(s) of the ratio(s).</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_w.band.denom">w.band.denom</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the denominator(s) of the ratio(s).</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag telling whether multiplier values should be
cached between calls.</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_quantity">quantity</code></td>
<td>
<p>character One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_name.tag">name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach.</p>
</td></tr>
<tr><td><code id="e_ratio_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default <code>quantity = "total"</code> the ratio is based on
two energy irradiances, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{I(s, wb_\mathrm{num})}{I(s, wb_\mathrm{denom})}</code>
</p>

<p>If the argument is set to <code>quantity = "mean"</code> or
<code>quantity = "average"</code> the ratio is based on
two mean spectral photon irradiances, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\overline{I_\lambda}(s, wb_\mathrm{num})}{\overline{I_\lambda}(s, wb_\mathrm{denom})}</code>
</p>

<p>Only if the wavelength expanse of the two wavebands is the same, these two
ratios are numerically identical.
</p>
<p>Fraction definitions are &quot;assembled&quot; from the arguments passed to
<code>w.band.num</code> and <code>w.band.denom</code>. If both arguments are lists of
waveband definitions, with an equal number of members, then the wavebands
are paired to obtain as many fractions as the number of wavebands in each
list. Recycling for wavebands takes place when the number of denominator
and numerator wavebands differ.
</p>
<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult=TRUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>Value</h3>

<p>In the case of methods for individual spectra, a <code>numeric</code>
vector with name attribute set. The name is based on the name of the
wavebands unless a named list of wavebands is supplied in which case the
names of the list elements are used. &quot;[e:e]&quot; is appended if <code>quantity
  = "total"</code> and &quot;[e(wl):e(wl)]&quot; if <code>quantity = "mean"</code> or
<code>quantity = "average"</code>.
</p>
<p>A <code>data.frame</code> is returned in the case of collections of spectra,
containing one column for each fraction definition, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>e_ratio(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>e_ratio(source_spct)</code>: Method for <code>source_spct</code> objects
</p>
</li>
<li> <p><code>e_ratio(source_mspct)</code>: Calculates energy:energy ratio from a <code>source_mspct</code>
object.
</p>
</li></ul>


<h3>Performance</h3>

<p>As this method accepts spectra as its input, it
computes irradiances before computing the ratios. If you need to compute
both ratios and irradiances from several hundreds or thousands of spectra,
computing the ratios from previously computed irradiances avoids their
repeated computation. A less dramatic, but still important, increase in
performance is available when computing in the same function call ratios
that share the same denominator.
</p>


<h3>See Also</h3>

<p>Other photon and energy ratio functions: 
<code><a href="#topic+e_fraction">e_fraction</a>()</code>,
<code><a href="#topic+eq_ratio">eq_ratio</a>()</code>,
<code><a href="#topic+q_fraction">q_fraction</a>()</code>,
<code><a href="#topic+q_ratio">q_ratio</a>()</code>,
<code><a href="#topic+qe_ratio">qe_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e_ratio(sun.spct,
        waveband(c(400,500), wb.name = "Blue"),
        waveband(c(400,700), wb.name = "White"))

</code></pre>

<hr>
<h2 id='e_response'>Energy-based photo-response</h2><span id='topic+e_response'></span><span id='topic+e_response.default'></span><span id='topic+e_response.response_spct'></span><span id='topic+e_response.response_mspct'></span>

<h3>Description</h3>

<p>This function returns the mean, total, or contribution of response for each
waveband and a response spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e_response(
  spct,
  w.band,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.hinges,
  ...
)

## Default S3 method:
e_response(
  spct,
  w.band,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.hinges,
  ...
)

## S3 method for class 'response_spct'
e_response(
  spct,
  w.band = NULL,
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = getOption("photobiology.use.hinges", default = NULL),
  naming = "default",
  ...
)

## S3 method for class 'response_mspct'
e_response(
  spct,
  w.band = NULL,
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = getOption("photobiology.use.hinges", default = NULL),
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_response_+3A_spct">spct</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="e_response_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects or a numeric vector of
length two. The waveband(s) determine the region(s) of the spectrum that
are summarized. If a numeric range is supplied a waveband object is
constructed on the fly from it.</p>
</td></tr>
<tr><td><code id="e_response_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;,
&quot;contribution&quot;, &quot;contribution.pc&quot;, &quot;relative&quot; or &quot;relative.pc&quot;.</p>
</td></tr>
<tr><td><code id="e_response_+3A_time.unit">time.unit</code></td>
<td>
<p>character or lubridate::duration object.</p>
</td></tr>
<tr><td><code id="e_response_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="e_response_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded.</p>
</td></tr>
<tr><td><code id="e_response_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="e_response_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="e_response_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="e_response_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="e_response_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="e_response_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="e_response_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector in the case of methods for individual
spectra, with one value for each <code>waveband</code> passed to parameter
<code>w.band</code>. A <code>data.frame</code> in the case of collections of spectra,
containing one column for each <code>waveband</code> object, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>e_response(default)</code>: Default method for generic function
</p>
</li>
<li> <p><code>e_response(response_spct)</code>: Method for response spectra.
</p>
</li>
<li> <p><code>e_response(response_mspct)</code>: Calculates energy response from a
<code>response_mspct</code>
</p>
</li></ul>


<h3>Note</h3>

<p>The parameter <code>use.hinges</code> controls speed optimization. The
defaults should be suitable in most cases. Only the range of wavelengths
in the wavebands is used and all BSWFs are ignored.
</p>


<h3>See Also</h3>

<p>Other response functions: 
<code><a href="#topic+q_response">q_response</a>()</code>,
<code><a href="#topic+response">response</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e_response(ccd.spct, new_waveband(200,300))
e_response(photodiode.spct)

</code></pre>

<hr>
<h2 id='e2q'>Convert energy-based quantities into photon-based quantities.</h2><span id='topic+e2q'></span><span id='topic+e2q.default'></span><span id='topic+e2q.source_spct'></span><span id='topic+e2q.response_spct'></span><span id='topic+e2q.source_mspct'></span><span id='topic+e2q.response_mspct'></span>

<h3>Description</h3>

<p>Conversion methods for spectral energy irradiance into spectral photon
irradiance and for spectral energy response into spectral photon
response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e2q(x, action, byref, ...)

## Default S3 method:
e2q(x, action = "add", byref = FALSE, ...)

## S3 method for class 'source_spct'
e2q(x, action = "add", byref = FALSE, ...)

## S3 method for class 'response_spct'
e2q(x, action = "add", byref = FALSE, ...)

## S3 method for class 'source_mspct'
e2q(x, action = "add", byref = FALSE, ..., .parallel = FALSE, .paropts = NULL)

## S3 method for class 'response_mspct'
e2q(x, action = "add", byref = FALSE, ..., .parallel = FALSE, .paropts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e2q_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="e2q_+3A_action">action</code></td>
<td>
<p>a character string, one of &quot;add&quot;, &quot;replace&quot;, &quot;add.raw&quot; or
&quot;replace.raw&quot;.</p>
</td></tr>
<tr><td><code id="e2q_+3A_byref">byref</code></td>
<td>
<p>logical indicating if a new object will be created by reference
or a new object returned.</p>
</td></tr>
<tr><td><code id="e2q_+3A_...">...</code></td>
<td>
<p>not used in current version.</p>
</td></tr>
<tr><td><code id="e2q_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="e2q_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The converted spectral values are added to or replace the existing
spectral values depending on the argument passed to parameter
<code>action</code>. Addition is currently not supported for normalized spectra.
If the spectrum has been normalized with a recent version of package
'photobiology' the spectrum will be renormalized after conversion using the
same arguments as previously. <code>"add.raw"</code> and <code>"replace.raw"</code>
prevent the re-normalization, are included for completeness and as a way
of restoring previous behaviour.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>e2q(default)</code>: Default method
</p>
</li>
<li> <p><code>e2q(source_spct)</code>: Method for spectral irradiance
</p>
</li>
<li> <p><code>e2q(response_spct)</code>: Method for spectral responsiveness
</p>
</li>
<li> <p><code>e2q(source_mspct)</code>: Method for collections of (light) source spectra
</p>
</li>
<li> <p><code>e2q(response_mspct)</code>: Method for collections of response spectra
</p>
</li></ul>


<h3>See Also</h3>

<p>Other quantity conversion functions: 
<code><a href="#topic+A2T">A2T</a>()</code>,
<code><a href="#topic+Afr2T">Afr2T</a>()</code>,
<code><a href="#topic+T2A">T2A</a>()</code>,
<code><a href="#topic+T2Afr">T2Afr</a>()</code>,
<code><a href="#topic+any2T">any2T</a>()</code>,
<code><a href="#topic+as_quantum">as_quantum</a>()</code>,
<code><a href="#topic+e2qmol_multipliers">e2qmol_multipliers</a>()</code>,
<code><a href="#topic+e2quantum_multipliers">e2quantum_multipliers</a>()</code>,
<code><a href="#topic+q2e">q2e</a>()</code>
</p>

<hr>
<h2 id='e2qmol_multipliers'>Calculate energy to quantum (mol) multipliers</h2><span id='topic+e2qmol_multipliers'></span>

<h3>Description</h3>

<p>Multipliers as a function of wavelength, for converting from energy to
photon (quantum) molar units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e2qmol_multipliers(w.length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e2qmol_multipliers_+3A_w.length">w.length</code></td>
<td>
<p>numeric Vector of wavelengths (nm)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of multipliers
</p>


<h3>See Also</h3>

<p>Other quantity conversion functions: 
<code><a href="#topic+A2T">A2T</a>()</code>,
<code><a href="#topic+Afr2T">Afr2T</a>()</code>,
<code><a href="#topic+T2A">T2A</a>()</code>,
<code><a href="#topic+T2Afr">T2Afr</a>()</code>,
<code><a href="#topic+any2T">any2T</a>()</code>,
<code><a href="#topic+as_quantum">as_quantum</a>()</code>,
<code><a href="#topic+e2q">e2q</a>()</code>,
<code><a href="#topic+e2quantum_multipliers">e2quantum_multipliers</a>()</code>,
<code><a href="#topic+q2e">q2e</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data, e2qmol_multipliers(w.length))

</code></pre>

<hr>
<h2 id='e2quantum_multipliers'>Calculate energy to quantum multipliers</h2><span id='topic+e2quantum_multipliers'></span>

<h3>Description</h3>

<p>Gives multipliers as a function of wavelength, for converting from energy to
photon (quantum) units (number of photons as default, or moles of photons).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e2quantum_multipliers(w.length, molar = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e2quantum_multipliers_+3A_w.length">w.length</code></td>
<td>
<p>numeric Vector of wavelengths (nm)</p>
</td></tr>
<tr><td><code id="e2quantum_multipliers_+3A_molar">molar</code></td>
<td>
<p>logical Flag indicating whether output should be in moles or
numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of multipliers
</p>


<h3>See Also</h3>

<p>Other quantity conversion functions: 
<code><a href="#topic+A2T">A2T</a>()</code>,
<code><a href="#topic+Afr2T">Afr2T</a>()</code>,
<code><a href="#topic+T2A">T2A</a>()</code>,
<code><a href="#topic+T2Afr">T2Afr</a>()</code>,
<code><a href="#topic+any2T">any2T</a>()</code>,
<code><a href="#topic+as_quantum">as_quantum</a>()</code>,
<code><a href="#topic+e2q">e2q</a>()</code>,
<code><a href="#topic+e2qmol_multipliers">e2qmol_multipliers</a>()</code>,
<code><a href="#topic+q2e">q2e</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data, e2quantum_multipliers(w.length))
with(sun.data, e2quantum_multipliers(w.length, molar = TRUE))

</code></pre>

<hr>
<h2 id='enable_check_spct'>Enable or disable checks</h2><span id='topic+enable_check_spct'></span><span id='topic+disable_check_spct'></span><span id='topic+set_check_spct'></span>

<h3>Description</h3>

<p>Choose between protection against errors or faster performance by enabling
(the default) or disabling data-consistency and sanity checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enable_check_spct()

disable_check_spct()

set_check_spct(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enable_check_spct_+3A_x">x</code></td>
<td>
<p>logical Flag to enable (TRUE), disable (FALSE) or unset (NULL)
option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The previous value of the option, which can be passed as argument
to function <code>set_check_spct()</code> to restore the previous state of the
option.
</p>


<h3>See Also</h3>

<p>Other data validity check functions: 
<code><a href="#topic+check_spct">check_spct</a>()</code>,
<code><a href="#topic+check_spectrum">check_spectrum</a>()</code>,
<code><a href="#topic+check_w.length">check_w.length</a>()</code>
</p>

<hr>
<h2 id='energy_as_default'>Set spectral-data options</h2><span id='topic+energy_as_default'></span><span id='topic+photon_as_default'></span><span id='topic+quantum_as_default'></span><span id='topic+Tfr_as_default'></span><span id='topic+Afr_as_default'></span><span id='topic+A_as_default'></span><span id='topic+unset_radiation_unit_default'></span><span id='topic+unset_filter_qty_default'></span><span id='topic+unset_user_defaults'></span>

<h3>Description</h3>

<p>Set spectral-data related options easily.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>energy_as_default()

photon_as_default()

quantum_as_default()

Tfr_as_default()

Afr_as_default()

A_as_default()

unset_radiation_unit_default()

unset_filter_qty_default()

unset_user_defaults()
</code></pre>


<h3>Value</h3>

<p>Previous value of the modified option.
</p>

<hr>
<h2 id='energy_irradiance'>Calculate (energy) irradiance from spectral irradiance</h2><span id='topic+energy_irradiance'></span>

<h3>Description</h3>

<p>Energy irradiance for a waveband from a radiation spectrum, optionally
applying a &quot;biological spectral weighting function&quot; or BSWF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>energy_irradiance(
  w.length,
  s.irrad,
  w.band = NULL,
  unit.in = "energy",
  check.spectrum = TRUE,
  use.cached.mult = FALSE,
  use.hinges = getOption("photobiology.use.hinges", default = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="energy_irradiance_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelength [<code class="reqn">nm</code>].</p>
</td></tr>
<tr><td><code id="energy_irradiance_+3A_s.irrad">s.irrad</code></td>
<td>
<p>numeric vector of spectral irradiances in
[<code class="reqn">W\,m^{-2}\,nm^{-1}</code>] or
[<code class="reqn">mol\,s^{-1}\,sm^{-2}\,nm^{-1}</code>] as indicated by the
argument pased to <code>unit.in</code>.</p>
</td></tr>
<tr><td><code id="energy_irradiance_+3A_w.band">w.band</code></td>
<td>
<p>waveband.</p>
</td></tr>
<tr><td><code id="energy_irradiance_+3A_unit.in">unit.in</code></td>
<td>
<p>character Allowed values <code>"energy"</code>, and <code>"photon"</code>,
or its alias <code>"quantum"</code>.</p>
</td></tr>
<tr><td><code id="energy_irradiance_+3A_check.spectrum">check.spectrum</code></td>
<td>
<p>logical Flag indicating whether to sanity check input
data, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="energy_irradiance_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag indicating whether multiplier values
should be cached between calls.</p>
</td></tr>
<tr><td><code id="energy_irradiance_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value with no change in scale factor:
[<code class="reqn">W\,m^{-2}</code>].
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data, energy_irradiance(w.length, s.e.irrad))
with(sun.data, energy_irradiance(w.length, s.e.irrad, new_waveband(400,700)))

</code></pre>

<hr>
<h2 id='energy_ratio'>Energy:energy ratio</h2><span id='topic+energy_ratio'></span>

<h3>Description</h3>

<p>Energy irradiance ratio between two wavebands for a radiation spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>energy_ratio(
  w.length,
  s.irrad,
  w.band.num = NULL,
  w.band.denom = NULL,
  unit.in = "energy",
  check.spectrum = TRUE,
  use.cached.mult = FALSE,
  use.hinges = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="energy_ratio_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths [<code class="reqn">nm</code>].</p>
</td></tr>
<tr><td><code id="energy_ratio_+3A_s.irrad">s.irrad</code></td>
<td>
<p>numeric vector of spectral irradiances in
[<code class="reqn">W\,m^{-2}\,nm^{-1}</code>] or
[<code class="reqn">mol\,s^{-1}\,sm^{-2}\,nm^{-1}</code>] as indicated by the
argument pased to <code>unit.in</code>.</p>
</td></tr>
<tr><td><code id="energy_ratio_+3A_w.band.num">w.band.num</code></td>
<td>
<p>waveband object used to compute the numerator of the ratio.</p>
</td></tr>
<tr><td><code id="energy_ratio_+3A_w.band.denom">w.band.denom</code></td>
<td>
<p>waveband object used to compute the denominator of the
ratio.</p>
</td></tr>
<tr><td><code id="energy_ratio_+3A_unit.in">unit.in</code></td>
<td>
<p>character Allowed values <code>"energy"</code>, and <code>"photon"</code>,
or its alias <code>"quantum"</code>.</p>
</td></tr>
<tr><td><code id="energy_ratio_+3A_check.spectrum">check.spectrum</code></td>
<td>
<p>logical Flag indicating whether to sanity check input
data, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="energy_ratio_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag indicating whether multiplier values
should be cached between calls.</p>
</td></tr>
<tr><td><code id="energy_ratio_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value giving the unitless energy ratio.
</p>


<h3>Note</h3>

<p>The default for both <code>w.band</code> parameters is a waveband covering
the whole range of <code>w.length</code>.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data,
     energy_ratio(w.length, s.e.irrad, new_waveband(400,500), new_waveband(400,700)))

</code></pre>

<hr>
<h2 id='eq_ratio'>Energy:photon ratio</h2><span id='topic+eq_ratio'></span><span id='topic+eq_ratio.default'></span><span id='topic+eq_ratio.source_spct'></span><span id='topic+eq_ratio.source_mspct'></span>

<h3>Description</h3>

<p>This function returns the energy to mole of photons ratio for each waveband
and a light source spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eq_ratio(spct, w.band, scale.factor, wb.trim, use.cached.mult, use.hinges, ...)

## Default S3 method:
eq_ratio(spct, w.band, scale.factor, wb.trim, use.cached.mult, use.hinges, ...)

## S3 method for class 'source_spct'
eq_ratio(
  spct,
  w.band = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  naming = "short",
  name.tag = ifelse(naming != "none", "[e:q]", ""),
  ...
)

## S3 method for class 'source_mspct'
eq_ratio(
  spct,
  w.band = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  naming = "short",
  name.tag = ifelse(naming != "none", "[e:q]", ""),
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eq_ratio_+3A_spct">spct</code></td>
<td>
<p>source_spct.</p>
</td></tr>
<tr><td><code id="eq_ratio_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects.</p>
</td></tr>
<tr><td><code id="eq_ratio_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="eq_ratio_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded.</p>
</td></tr>
<tr><td><code id="eq_ratio_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag telling whether multiplier values should
be cached between calls.</p>
</td></tr>
<tr><td><code id="eq_ratio_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="eq_ratio_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="eq_ratio_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="eq_ratio_+3A_name.tag">name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td></tr>
<tr><td><code id="eq_ratio_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="eq_ratio_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="eq_ratio_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="eq_ratio_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ratio is based on one photon irradiance and one energy
irradiance, both computed for the same waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{I(s, wb)}{Q(s, wb)}</code>
</p>

<p>The last two parameters control speed optimizations. The defaults should be
suitable in most cases. If you will use repeatedly the same SWFs on many
spectra measured at exactly the same wavelengths you may obtain some speed
up by setting <code>use.cached.mult=TRUE</code>. However, be aware that you are
responsible for ensuring that the wavelengths are the same in each call, as
the only test done is for the length of the <code>w.length</code> vector.#'
@return Computed values are ratios between energy irradiance and photon
irradiance for a given waveband. A named <code>numeric</code> vector in the case
of methods for individual spectra, with one value for each <code>waveband</code>
passed to parameter <code>w.band</code>. A <code>data.frame</code> in the case of
collections of spectra, containing one column for each <code>waveband</code>
object, an index column with the names of the spectra, and optionally
additional columns with metadata values retrieved from the attributes of
the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used, with &quot;[e:q]&quot;
prepended. Units [J mol-1].
</p>


<h3>Value</h3>

<p>Computed values are ratios between energy irradiance and photon
irradiance for a given waveband. A named <code>numeric</code> vector in the case
of methods for individual spectra, with one value for each <code>waveband</code>
passed to parameter <code>w.band</code>. A <code>data.frame</code> in the case of
multiple spectra, containing one column with ratios for each <code>waveband</code>
object, an index column with the names of the spectra, and optionally
additional columns with metadata values retrieved from the attributes of
the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they are expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used, with &quot;[e:q]&quot; prepended.
Units [mol J-1].
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>eq_ratio(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>eq_ratio(source_spct)</code>: Method for <code>source_spct</code> objects
</p>
</li>
<li> <p><code>eq_ratio(source_mspct)</code>: Calculates energy:photon from a <code>source_mspct</code>
object.
</p>
</li></ul>


<h3>Performance</h3>

<p>As this method accepts spectra as its input, it
computes irradiances before computing the ratios. If you need to compute
both ratios and irradiances from several hundreds or thousands of spectra,
computing the ratios from previously computed irradiances avoids their
repeated computation. A less dramatic, but still important, increase in
performance is available when computing in the same function call ratios
that share the same denominator.
</p>


<h3>See Also</h3>

<p>Other photon and energy ratio functions: 
<code><a href="#topic+e_fraction">e_fraction</a>()</code>,
<code><a href="#topic+e_ratio">e_ratio</a>()</code>,
<code><a href="#topic+q_fraction">q_fraction</a>()</code>,
<code><a href="#topic+q_ratio">q_ratio</a>()</code>,
<code><a href="#topic+qe_ratio">qe_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eq_ratio(sun.spct,
         waveband(c(400,700), wb.name = "White")) # J mol-1
eq_ratio(sun.spct,
         waveband(c(400,700), wb.name = "White"),
         scale.factor = 1e-6) # J umol-1

</code></pre>

<hr>
<h2 id='ET_ref'>Evapotranspiration</h2><span id='topic+ET_ref'></span><span id='topic+ET_ref_day'></span>

<h3>Description</h3>

<p>Compute an estimate of reference (= potential) evapotranspiration from
meteorologial data. Evapotranspiration from vegetation includes
transpiraction by plants plus evaporation from the soil or other wet
surfaces. <code class="reqn">ET_0</code> is the reference value assuming no limitation to
transpiration due to soil water, similar to potential evapotranspiration
(PET). An actual evapotranpiration value <code class="reqn">ET</code> can be estimated only if
additional information on the plants and soil is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ET_ref(
  temperature,
  water.vp,
  wind.speed,
  net.irradiance,
  nighttime = FALSE,
  atmospheric.pressure = 10.13,
  soil.heat.flux = 0,
  method = "FAO.PM",
  check.range = TRUE
)

ET_ref_day(
  temperature,
  water.vp,
  wind.speed,
  net.radiation,
  atmospheric.pressure = 10.13,
  soil.heat.flux = 0,
  method = "FAO.PM",
  check.range = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ET_ref_+3A_temperature">temperature</code></td>
<td>
<p>numeric vector of air temperatures (C) at 2 m height.</p>
</td></tr>
<tr><td><code id="ET_ref_+3A_water.vp">water.vp</code></td>
<td>
<p>numeric vector of water vapour pressure in air (Pa).</p>
</td></tr>
<tr><td><code id="ET_ref_+3A_wind.speed">wind.speed</code></td>
<td>
<p>numeric Wind speed (m/s) at 2 m height.</p>
</td></tr>
<tr><td><code id="ET_ref_+3A_net.irradiance">net.irradiance</code></td>
<td>
<p>numeric Long wave and short wave balance (W/m2).</p>
</td></tr>
<tr><td><code id="ET_ref_+3A_nighttime">nighttime</code></td>
<td>
<p>logical Used only for methods that distinguish between
daytime- and nighttime canopy conductances.</p>
</td></tr>
<tr><td><code id="ET_ref_+3A_atmospheric.pressure">atmospheric.pressure</code></td>
<td>
<p>numeric Atmospheric pressure (Pa).</p>
</td></tr>
<tr><td><code id="ET_ref_+3A_soil.heat.flux">soil.heat.flux</code></td>
<td>
<p>numeric Soil heat flux (W/m2), positive if soil
temperature is increasing.</p>
</td></tr>
<tr><td><code id="ET_ref_+3A_method">method</code></td>
<td>
<p>character The name of an estimation method.</p>
</td></tr>
<tr><td><code id="ET_ref_+3A_check.range">check.range</code></td>
<td>
<p>logical Flag indicating whether to check or not that
arguments for temperature are within range of method. Passed to
function calls to <code>water_vp_sat()</code> and <code>water_vp_sat_slope()</code>.</p>
</td></tr>
<tr><td><code id="ET_ref_+3A_net.radiation">net.radiation</code></td>
<td>
<p>numeric Long wave and short wave balance (J/m2/day).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently three methods, based on the Penmann-Monteith equation
formulated as recommended by FAO56 (Allen et al., 1998) as well as modified
in 2005 for tall and short vegetation according to ASCE-EWRI are
implemented in function <code>ET_ref()</code>. The computations rely on data
measured according WHO standards at 2 m above ground level to estimate
reference evapotranspiration (<code class="reqn">ET_0</code>). The formulations are those for
ET expressed in mm/h, but modified to use as input flux rates in W/m2 and
pressures expressed in Pa.
</p>


<h3>Value</h3>

<p>A numeric vector of reference evapotranspiration estimates expressed
in mm/h for <code>ET_ref()</code> and <code>ET_PM()</code> and in mm/d for
<code>ET_ref_day()</code>.
</p>


<h3>References</h3>

<p>Allen R G, Pereira L S, Raes D, Smith M. 1998. Crop evapotranspiration:
Guidelines for computing crop water requirements. Rome: FAO.
Allen R G, Pruitt W O, Wright J L, Howell T A, Ventura F, Snyder R,
Itenfisu D, Steduto P, Berengena J, Yrisarry J, et al. 2006. A
recommendation on standardized surface resistance for hourly calculation
of reference ETo by the FAO56 Penman-Monteith method. Agricultural Water
Management 81.
</p>


<h3>See Also</h3>

<p>Other Evapotranspiration and energy balance related functions.: 
<code><a href="#topic+net_irradiance">net_irradiance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># instantaneous
ET_ref(temperature = 20,
       water.vp = water_RH2vp(relative.humidity = 70,
                              temperature = 20),
       wind.speed = 0,
       net.irradiance = 10)

ET_ref(temperature = c(5, 20, 35),
       water.vp = water_RH2vp(70, c(5, 20, 35)),
       wind.speed = 0,
       net.irradiance = 10)

# Hot and dry air
ET_ref(temperature = 35,
       water.vp = water_RH2vp(10, 35),
       wind.speed = 5,
       net.irradiance = 400)

ET_ref(temperature = 35,
       water.vp = water_RH2vp(10, 35),
       wind.speed = 5,
       net.irradiance = 400,
       method = "FAO.PM")

ET_ref(temperature = 35,
       water.vp = water_RH2vp(10, 35),
       wind.speed = 5,
       net.irradiance = 400,
       method = "ASCE.PM.short")

ET_ref(temperature = 35,
       water.vp = water_RH2vp(10, 35),
       wind.speed = 5,
       net.irradiance = 400,
       method = "ASCE.PM.tall")

# Low temperature and high humidity
ET_ref(temperature = 5,
       water.vp = water_RH2vp(95, 5),
       wind.speed = 0.5,
       net.irradiance = -10,
       nighttime = TRUE,
       method = "ASCE.PM.short")

ET_ref_day(temperature = 35,
           water.vp = water_RH2vp(10, 35),
           wind.speed = 5,
           net.radiation = 35e6) # 35 MJ / d / m2

</code></pre>

<hr>
<h2 id='Extract'>Extract or replace parts of a spectrum</h2><span id='topic+Extract'></span><span id='topic++5B.generic_spct'></span><span id='topic++5B.raw_spct'></span><span id='topic++5B.cps_spct'></span><span id='topic++5B.source_spct'></span><span id='topic++5B.response_spct'></span><span id='topic++5B.filter_spct'></span><span id='topic++5B.reflector_spct'></span><span id='topic++5B.solute_spct'></span><span id='topic++5B.object_spct'></span><span id='topic++5B.chroma_spct'></span><span id='topic++5B+3C-.generic_spct'></span><span id='topic++24+3C-.generic_spct'></span>

<h3>Description</h3>

<p>Just like extraction and replacement with indexes in base R, but preserving
the special attributes used in spectral classes and checking for validity of
remaining spectral data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
x[i, j, drop = NULL]

## S3 method for class 'raw_spct'
x[i, j, drop = NULL]

## S3 method for class 'cps_spct'
x[i, j, drop = NULL]

## S3 method for class 'source_spct'
x[i, j, drop = NULL]

## S3 method for class 'response_spct'
x[i, j, drop = NULL]

## S3 method for class 'filter_spct'
x[i, j, drop = NULL]

## S3 method for class 'reflector_spct'
x[i, j, drop = NULL]

## S3 method for class 'solute_spct'
x[i, j, drop = NULL]

## S3 method for class 'object_spct'
x[i, j, drop = NULL]

## S3 method for class 'chroma_spct'
x[i, j, drop = NULL]

## S3 replacement method for class 'generic_spct'
x[i, j] &lt;- value

## S3 replacement method for class 'generic_spct'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract_+3A_x">x</code></td>
<td>
<p>spectral object from which to extract element(s) or in which to replace element(s)</p>
</td></tr>
<tr><td><code id="Extract_+3A_i">i</code></td>
<td>
<p>index for rows,</p>
</td></tr>
<tr><td><code id="Extract_+3A_j">j</code></td>
<td>
<p>index for columns, specifying elements to extract or replace. Indices are
numeric or character vectors or empty (missing) or NULL. Please, see
<code><a href="base.html#topic+Extract">Extract</a></code> for more details.</p>
</td></tr>
<tr><td><code id="Extract_+3A_drop">drop</code></td>
<td>
<p>logical. If TRUE the result is coerced to the lowest possible
dimension. The default is FALSE unless the result is a single column.</p>
</td></tr>
<tr><td><code id="Extract_+3A_value">value</code></td>
<td>
<p>A suitable replacement value: it will be repeated a whole number
of times if necessary and it may be coerced: see the Coercion section. If
NULL, deletes the column if a single column is selected.</p>
</td></tr>
<tr><td><code id="Extract_+3A_name">name</code></td>
<td>
<p>A literal character string or a name (possibly backtick quoted).
For extraction, this is normally (see under 'Environments') partially
matched to the names of the object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods are just wrappers on the method for data.frame objects
which copy the additional attributes used by these classes, and validate
the extracted object as a spectral object. When drop is TRUE and the
returned object has only one column, then a vector is returned. If the
extracted columns are more than one but do not include <code>w.length</code>, a
data frame is returned instead of a spectral object.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> but containing only the
subset of rows and columns that are selected. See details for special
cases.
</p>


<h3>Note</h3>

<p>If any argument is passed to <code>j</code>, even <code>TRUE</code>, some metadata
attributes are removed from the returned object. This is how the
extraction operator works with <code>data.frames</code> in R. For the time
being we retain this behaviour for spectra, but it may change in the
future.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code> and <code><a href="#topic+trim_spct">trim_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sun.spct[sun.spct[["w.length"]] &gt; 400, ]
subset(sun.spct, w.length &gt; 400)

tmp.spct &lt;- sun.spct
tmp.spct[tmp.spct[["s.e.irrad"]] &lt; 1e-5 , "s.e.irrad"] &lt;- 0
e2q(tmp.spct[ , c("w.length", "s.e.irrad")]) # restore data consistency!

</code></pre>

<hr>
<h2 id='Extract_mspct'>Extract or replace members of a collection of spectra</h2><span id='topic+Extract_mspct'></span><span id='topic++5B.generic_mspct'></span><span id='topic++5B+3C-.generic_mspct'></span><span id='topic++24+3C-.generic_mspct'></span><span id='topic++5B+5B+3C-.generic_mspct'></span>

<h3>Description</h3>

<p>Just like extraction and replacement with indexes for base R lists, but
preserving the special attributes used in spectral classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_mspct'
x[i, drop = NULL]

## S3 replacement method for class 'generic_mspct'
x[i] &lt;- value

## S3 replacement method for class 'generic_mspct'
x$name &lt;- value

## S3 replacement method for class 'generic_mspct'
x[[name]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract_mspct_+3A_x">x</code></td>
<td>
<p>Collection of spectra object from which to extract member(s) or in
which to replace member(s)</p>
</td></tr>
<tr><td><code id="Extract_mspct_+3A_i">i</code></td>
<td>
<p>Index specifying elements to extract or replace. Indices are numeric
or character vectors. Please, see <code><a href="base.html#topic+Extract">Extract</a></code> for
more details.</p>
</td></tr>
<tr><td><code id="Extract_mspct_+3A_drop">drop</code></td>
<td>
<p>If TRUE the result is coerced to the lowest possible dimension
(see the examples). This only works for extracting elements, not for the
replacement.</p>
</td></tr>
<tr><td><code id="Extract_mspct_+3A_value">value</code></td>
<td>
<p>A suitable replacement value: it will be repeated a whole number
of times if necessary and it may be coerced: see the Coercion section. If
NULL, deletes the column if a single column is selected.</p>
</td></tr>
<tr><td><code id="Extract_mspct_+3A_name">name</code></td>
<td>
<p>A literal character string or a name (possibly backtick quoted).
For extraction, this is normally (see under 'Environments') partially
matched to the names of the object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is a wrapper on base R's extract method for lists that
sets additional attributes used by these classes.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> but containing only the
subset of members that are selected.
</p>

<hr>
<h2 id='f_dispatcher_spct'>Math function dispatcher for spectra</h2><span id='topic+f_dispatcher_spct'></span>

<h3>Description</h3>

<p>Function that dispatches the function supplied as argument using different variables depending
on the class of the spectrum argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_dispatcher_spct(x, .fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_dispatcher_spct_+3A_x">x</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
<tr><td><code id="f_dispatcher_spct_+3A_.fun">.fun</code></td>
<td>
<p>an R function with signature function(x, ...)</p>
</td></tr>
<tr><td><code id="f_dispatcher_spct_+3A_...">...</code></td>
<td>
<p>additional arguments passed to f</p>
</td></tr>
</table>

<hr>
<h2 id='FEL_spectrum'>Incandescent &quot;FEL&quot; lamp emission spectrum</h2><span id='topic+FEL_spectrum'></span>

<h3>Description</h3>

<p>Calculate values by means of a nth degree polynomial from
user-supplied constants (for example from a lamp calibration certificate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FEL_spectrum(w.length, k = photobiology::FEL.BN.9101.165, fill = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FEL_spectrum_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths (nm) for output</p>
</td></tr>
<tr><td><code id="FEL_spectrum_+3A_k">k</code></td>
<td>
<p>a numeric vector with n constants for the function</p>
</td></tr>
<tr><td><code id="FEL_spectrum_+3A_fill">fill</code></td>
<td>
<p>if NA, no extrapolation is done, and NA is returned for
wavelengths outside the range 250 nm to 900 nm. If NULL then the tails are
deleted. If 0 then the tails are set to zero, etc. NA is default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with four numeric vectors with wavelength values
(w.length), energy and photon irradiance (s.e.irrad, s.q.irrad) depending
on the argument passed to unit.out (s.irrad).
</p>


<h3>Note</h3>

<p>This is function is valid for wavelengths in the range 250 nm to 900
nm, for wavelengths outside this range NAs are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FEL_spectrum(400)
FEL_spectrum(250:900)
</code></pre>

<hr>
<h2 id='filter_cps.mspct'>Counts per second from a measurement of a plastic film</h2><span id='topic+filter_cps.mspct'></span>

<h3>Description</h3>

<p>A dataset containing the wavelengths at a varying interval and
counts per second data. Two spectra are included a reference measurement
of the light source plus a measurement of a plastic film.
</p>


<h3>Format</h3>

<p>A <code>filter_cps.mspct</code> object with 611 rows and 2 variables
</p>


<h3>Details</h3>

<p>A collection of two spectra as a <code>cps_mspct</code> object, each
each spectrum being a <code>cps_spct</code> object with two columns:
</p>
 <ul>
<li><p> w.length (nm). </p>
</li>
<li><p> cps (counts/s)  </p>
</li></ul>



<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>

<hr>
<h2 id='find_peaks'>Find peaks in a spectrum</h2><span id='topic+find_peaks'></span>

<h3>Description</h3>

<p>This function finds all peaks (local maxima) in a spectrum, using a user
provided size threshold relative to the tallest peak (global maximum) bellow
which found peaks are ignored&mdash;i.e., not included in the returned value. This
is a wrapper built on top of function <code>peaks()</code> from package 'splus2R'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_peaks(x, ignore_threshold = 0, span = 3, strict = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_peaks_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_ignore_threshold">ignore_threshold</code></td>
<td>
<p>numeric Value between 0.0 and 1.0 indicating the
relative size compared to tallest peak threshold below which peaks will be
ignored. Negative values set a threshold so that the tallest peaks are
ignored, instead of the shortest.</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_span">span</code></td>
<td>
<p>integer A peak is defined as an element in a sequence which is
greater than all other elements within a window of width <code>span</code>
centered at that element. Use <code>NULL</code> for the global peak.</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_strict">strict</code></td>
<td>
<p>logical If <code>TRUE</code>, an element must be strictly greater
than all other values in its window to be considered a peak.</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be stripped
before searching for peaks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as <code>x</code>. Values that are
<code>TRUE</code> correspond to local peaks in the data.
</p>


<h3>Note</h3>

<p>This function is a wrapper built on function
<code><a href="splus2R.html#topic+peaks">peaks</a></code> from <span class="pkg">splus2R</span> and handles non-finite
(including <code>NA</code>) values differently than <code>splus2R::peaks</code>,
instead of giving an error they are replaced with the smallest finite value
in <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="splus2R.html#topic+peaks">peaks</a></code>
</p>
<p>Other peaks and valleys functions: 
<code><a href="#topic+find_spikes">find_spikes</a>()</code>,
<code><a href="#topic+get_peaks">get_peaks</a>()</code>,
<code><a href="#topic+peaks">peaks</a>()</code>,
<code><a href="#topic+replace_bad_pixs">replace_bad_pixs</a>()</code>,
<code><a href="#topic+spikes">spikes</a>()</code>,
<code><a href="#topic+valleys">valleys</a>()</code>,
<code><a href="#topic+wls_at_target">wls_at_target</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data, w.length[find_peaks(s.e.irrad)])

</code></pre>

<hr>
<h2 id='find_spikes'>Find spikes</h2><span id='topic+find_spikes'></span>

<h3>Description</h3>

<p>This function finds spikes in a numeric vector using the algorithm of
Whitaker and Hayes (2018). Spikes are values in spectra that are unusually
high or low compared to neighbors. They are usually individual values or very
short runs of similar &quot;unusual&quot; values. Spikes caused by cosmic radiation are
a frequent problem in Raman spectra. Another source of spikes are &quot;hot
pixels&quot; in CCD and diode arrays. Other kinds of accidental &quot;outlayers&quot; will
be also detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_spikes(
  x,
  x.is.delta = FALSE,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_spikes_+3A_x">x</code></td>
<td>
<p>numeric vector containing spectral data.</p>
</td></tr>
<tr><td><code id="find_spikes_+3A_x.is.delta">x.is.delta</code></td>
<td>
<p>logical Flag indicating if x contains already differences.</p>
</td></tr>
<tr><td><code id="find_spikes_+3A_z.threshold">z.threshold</code></td>
<td>
<p>numeric Modified Z values larger than <code>z.threshold</code>
are considered to be spikes.</p>
</td></tr>
<tr><td><code id="find_spikes_+3A_max.spike.width">max.spike.width</code></td>
<td>
<p>integer Wider regions with high Z values are not detected as
spikes.</p>
</td></tr>
<tr><td><code id="find_spikes_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be stripped
before searching for spikes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spikes are detected based on a modified Z score calculated from the
differenced spectrum. The Z threshold used should be adjusted to the
characteristics of the input and desired sensitivity. The lower the
threshold the more stringent the test becomes, resulting in most cases in
more spikes being detected. A modified version of the algorithm is used if
a value different from <code>NULL</code> is passed as argument to
<code>max.spike.width</code>. In such a case, an additional step filters out
broader spikes (or falsely detected steep slopes) from the returned values.
</p>


<h3>Value</h3>

<p>A logical vector of the same length as <code>x</code>. Values that are TRUE
correspond to local spikes in the data.
</p>


<h3>References</h3>

<p>Whitaker, D. A.; Hayes, K. (2018) A simple algorithm for despiking Raman
spectra. Chemometrics and Intelligent Laboratory Systems, 179, 82-84.
</p>


<h3>See Also</h3>

<p>Other peaks and valleys functions: 
<code><a href="#topic+find_peaks">find_peaks</a>()</code>,
<code><a href="#topic+get_peaks">get_peaks</a>()</code>,
<code><a href="#topic+peaks">peaks</a>()</code>,
<code><a href="#topic+replace_bad_pixs">replace_bad_pixs</a>()</code>,
<code><a href="#topic+spikes">spikes</a>()</code>,
<code><a href="#topic+valleys">valleys</a>()</code>,
<code><a href="#topic+wls_at_target">wls_at_target</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
with(white_led.raw_spct,
     which(find_spikes(counts_3, z.threshold = 30)))

</code></pre>

<hr>
<h2 id='find_wls'>Find wavelength values in a spectrum</h2><span id='topic+find_wls'></span>

<h3>Description</h3>

<p>Find wavelength values corresponding to a target y value in any spectrum. The
name of the column of the spectral data to be used to match the target needs
to be passed as argument unless the spectrum contains a single numerical
variable in addition to &quot;w.length&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_wls(
  x,
  target = NULL,
  col.name.x = NULL,
  col.name = NULL,
  .fun = `&lt;=`,
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_wls_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="find_wls_+3A_target">target</code></td>
<td>
<p>numeric or character. A numeric value indicates the spectral
quantity value for which wavelengths are to be searched. A character
representing a number is converted to a number. A character value
representing a number followed by a function name, will be also accepted
and decoded, such that <code>"0.1max"</code> is interpreted as targetting one
tenthof the maximum value in a column. The character strings &quot;half.maximum&quot;
and &quot;HM&quot; are synonyms for &quot;0.5max&quot; while &quot;half.range&quot; and &quot;HR&quot; are synonyms
for &quot;0.5range&quot;. These synonyms are converted to the cannonical form before
saving them to the returned value.</p>
</td></tr>
<tr><td><code id="find_wls_+3A_col.name.x">col.name.x</code></td>
<td>
<p>character The name of the column in which to the
independent variable is stored. Defaults to &quot;w.length&quot; for objects of class
<code>"generic_spct"</code> or derived.</p>
</td></tr>
<tr><td><code id="find_wls_+3A_col.name">col.name</code></td>
<td>
<p>character The name of the column in which to search for the
target value.</p>
</td></tr>
<tr><td><code id="find_wls_+3A_.fun">.fun</code></td>
<td>
<p>function A binary comparison function or operator.</p>
</td></tr>
<tr><td><code id="find_wls_+3A_interpolate">interpolate</code></td>
<td>
<p>logical Indicating whether the nearest wavelength value in
<code>x</code> should be returned or a value calculated by linear interpolation
between wavelength values stradling the target.</p>
</td></tr>
<tr><td><code id="find_wls_+3A_idfactor">idfactor</code></td>
<td>
<p>logical or character Generates an index column of factor
type. If <code>idfactor = TRUE</code> then the column is auto named target.idx.
Alternatively the column name can be directly passed as argument to
<code>idfactor</code> as a character string.</p>
</td></tr>
<tr><td><code id="find_wls_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be stripped
before searching for the target.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spectrum object of the same class as <code>x</code> with fewer rows,
possibly even no rows. If <code>FALSE</code> is passed to <code>interpolate</code> a
subset of <code>x</code> is returned, otherwise a new object of the same class
containing interpolated wavelenths for the <code>target</code> value is returned.
</p>


<h3>Note</h3>

<p>This function is used internally by method <code>wls_at_target()</code>, and
these methods should be preferred in user code and scripts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_wls(white_led.source_spct)
find_wls(white_led.source_spct, target = "0.5max")
find_wls(white_led.source_spct, target = 0.4)
find_wls(white_led.source_spct, target = 0.4, interpolate = TRUE)
find_wls(white_led.source_spct, target = c(0.3, 0.4))
find_wls(white_led.source_spct, target = c(0.3, 0.4), idfactor = "target")
find_wls(white_led.source_spct, target = c(0.3, 0.4), idfactor = TRUE)
find_wls(white_led.source_spct, target = "0.5max")
find_wls(white_led.source_spct, target = "0.05max")
find_wls(white_led.source_spct, target = "0.5range")

led.df &lt;- as.data.frame(white_led.source_spct)
find_wls(led.df)
find_wls(led.df, col.name = "s.e.irrad", col.name.x = "w.length")
find_wls(led.df, col.name = "s.e.irrad", col.name.x = "w.length",
         target = 0.4)
find_wls(led.df, col.name = "s.e.irrad", col.name.x = "w.length",
         target = c(0.3, 0.4))
find_wls(led.df, col.name = "s.e.irrad", col.name.x = "w.length",
         target = 0.4, idfactor = "target")

</code></pre>

<hr>
<h2 id='findMultipleWl'>Find repeated w.length values</h2><span id='topic+findMultipleWl'></span>

<h3>Description</h3>

<p>Find repeated w.length values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findMultipleWl(x, same.wls = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findMultipleWl_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="findMultipleWl_+3A_same.wls">same.wls</code></td>
<td>
<p>logical If TRUE all spectra spected to share same w.length
values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer Number of spectra, guessed from the number of copies of each
individual w.length value.
</p>

<hr>
<h2 id='fit_peaks'>Refine position and value of extremes by fitting</h2><span id='topic+fit_peaks'></span><span id='topic+fit_valleys'></span>

<h3>Description</h3>

<p>Functions implementing fitting of peaks in a class-agnostic way. The fitting
refines the location of peaks and value of peaks based on the location of
maxima and minima supplied. This function is to be used together with
<code>find_peaks()</code> or <code>find_valleys()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_peaks(
  x,
  peaks.idx,
  span,
  x.col.name = NULL,
  y.col.name,
  method,
  max.span = 5L,
  maximum = TRUE,
  keep.cols = NULL
)

fit_valleys(
  x,
  valleys.idx,
  span,
  x.col.name = NULL,
  y.col.name,
  method,
  max.span = 5L,
  maximum = FALSE,
  keep.cols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_peaks_+3A_x">x</code></td>
<td>
<p>generic_spct or data.frame object.</p>
</td></tr>
<tr><td><code id="fit_peaks_+3A_peaks.idx">peaks.idx</code>, <code id="fit_peaks_+3A_valleys.idx">valleys.idx</code></td>
<td>
<p>logical or integer Indexes into <code>x</code>
selecting global or local extremes.</p>
</td></tr>
<tr><td><code id="fit_peaks_+3A_span">span</code></td>
<td>
<p>odd integer The span used when refining the location of maxima or
minima of <code>x</code>.</p>
</td></tr>
<tr><td><code id="fit_peaks_+3A_x.col.name">x.col.name</code>, <code id="fit_peaks_+3A_y.col.name">y.col.name</code></td>
<td>
<p>character Name of the column of <code>x</code> on
which to operate.</p>
</td></tr>
<tr><td><code id="fit_peaks_+3A_method">method</code></td>
<td>
<p>character The method to use for the fit.</p>
</td></tr>
<tr><td><code id="fit_peaks_+3A_max.span">max.span</code></td>
<td>
<p>odd integer The maximum number of data points used when
when refining the location of maxima and minima.</p>
</td></tr>
<tr><td><code id="fit_peaks_+3A_maximum">maximum</code></td>
<td>
<p>logical A flag indicating whether to search for maxima or
minima.</p>
</td></tr>
<tr><td><code id="fit_peaks_+3A_keep.cols">keep.cols</code></td>
<td>
<p>logical Keep unrecognized columns in data frames</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R object of the same class as <code>x</code> containing the fitted
values for the peaks, and optionally the values for at <code>peaks.idx</code> or
<code>valleys.idx</code> for other retained columns.
</p>


<h3>Note</h3>

<p>These functions are not meant for everyday use. Use option
<code>refine.wl = TRUE</code> of methods <code>peaks()</code> and <code>valleys()</code> instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
peaks &lt;- find_peaks(sun.spct[["s.e.irrad"]], span = 31)
fit_peaks(sun.spct, peaks, span = 31,
          y.col.name = "s.e.irrad", method = "spline")

</code></pre>

<hr>
<h2 id='fluence'>Fluence</h2><span id='topic+fluence'></span><span id='topic+fluence.default'></span><span id='topic+fluence.source_spct'></span><span id='topic+fluence.source_mspct'></span>

<h3>Description</h3>

<p>Energy or photon fluence for one or more wavebands of a light source spectrum
and a duration of exposure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluence(
  spct,
  w.band,
  unit.out,
  exposure.time,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## Default S3 method:
fluence(
  spct,
  w.band,
  unit.out,
  exposure.time,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## S3 method for class 'source_spct'
fluence(
  spct,
  w.band = NULL,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  exposure.time,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = FALSE,
  naming = "default",
  ...
)

## S3 method for class 'source_mspct'
fluence(
  spct,
  w.band = NULL,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  exposure.time,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = FALSE,
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluence_+3A_spct">spct</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="fluence_+3A_w.band">w.band</code></td>
<td>
<p>a list of <code>waveband</code> objects or a <code>waveband</code> object.</p>
</td></tr>
<tr><td><code id="fluence_+3A_unit.out">unit.out</code></td>
<td>
<p>character string with allowed values &quot;energy&quot;, and &quot;photon&quot;,
or its alias &quot;quantum&quot;.</p>
</td></tr>
<tr><td><code id="fluence_+3A_exposure.time">exposure.time</code></td>
<td>
<p>lubridate::duration object.</p>
</td></tr>
<tr><td><code id="fluence_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="fluence_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded.</p>
</td></tr>
<tr><td><code id="fluence_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls.</p>
</td></tr>
<tr><td><code id="fluence_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="fluence_+3A_allow.scaled">allow.scaled</code></td>
<td>
<p>logical indicating whether scaled or normalized spectra
as argument to spct are flagged as an error.</p>
</td></tr>
<tr><td><code id="fluence_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="fluence_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="fluence_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="fluence_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="fluence_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="fluence_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One numeric value for each waveband with no change in scale factor,
with name attribute set to the name of each waveband unless a named list is
supplied in which case the names of the list elements are used. The
time.unit attribute is copied from the spectrum object to the output. Units
are as follows: If time.unit is second, [W m-2 nm-1] -&gt; [mol s-1 m-2] If
time.unit is day, [J d-1 m-2 nm-1] -&gt; [mol d-1 m-2]
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fluence(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>fluence(source_spct)</code>: Calculate photon fluence from a <code>source_spct</code>
object and the duration of the exposure
</p>
</li>
<li> <p><code>fluence(source_mspct)</code>: Calculates fluence from a <code>source_mspct</code>
object.
</p>
</li></ul>


<h3>Note</h3>

<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult=TRUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>See Also</h3>

<p>Other irradiance functions: 
<code><a href="#topic+e_fluence">e_fluence</a>()</code>,
<code><a href="#topic+e_irrad">e_irrad</a>()</code>,
<code><a href="#topic+irrad">irrad</a>()</code>,
<code><a href="#topic+q_fluence">q_fluence</a>()</code>,
<code><a href="#topic+q_irrad">q_irrad</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
fluence(sun.spct,
        w.band = waveband(c(400,700)),
        exposure.time = lubridate::duration(3, "minutes") )

</code></pre>

<hr>
<h2 id='format.solar_time'>Encode in a Common Format</h2><span id='topic+format.solar_time'></span>

<h3>Description</h3>

<p>Format a <code>solar_time</code> object for pretty printing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'solar_time'
format(x, ..., sep = ":")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.solar_time_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="format.solar_time_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="format.solar_time_+3A_sep">sep</code></td>
<td>
<p>character used as separator</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other astronomy related functions: 
<code><a href="#topic+day_night">day_night</a>()</code>,
<code><a href="#topic+sun_angles">sun_angles</a>()</code>
</p>

<hr>
<h2 id='format.tod_time'>Encode in a Common Format</h2><span id='topic+format.tod_time'></span>

<h3>Description</h3>

<p>Format a <code>tod_time</code> object for pretty printing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tod_time'
format(x, ..., sep = ":")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.tod_time_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="format.tod_time_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="format.tod_time_+3A_sep">sep</code></td>
<td>
<p>character used as separator</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Time of day functions: 
<code><a href="#topic+as_tod">as_tod</a>()</code>,
<code><a href="#topic+print.tod_time">print.tod_time</a>()</code>
</p>

<hr>
<h2 id='formatted_range'>Compute range and format it</h2><span id='topic+formatted_range'></span>

<h3>Description</h3>

<p>Compute the range of an R object, and format it as string suitable for
printing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatted_range(x, na.rm = TRUE, digits = 3, nsmall = 2, collapse = "..")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatted_range_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="formatted_range_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be
omitted.</p>
</td></tr>
<tr><td><code id="formatted_range_+3A_digits">digits</code>, <code id="formatted_range_+3A_nsmall">nsmall</code></td>
<td>
<p>numeric, passed to same name parameters of
<code>format()</code>.</p>
</td></tr>
<tr><td><code id="formatted_range_+3A_collapse">collapse</code></td>
<td>
<p>character, passed to same name parameter of <code>paste()</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+range">range</a></code>, <code><a href="base.html#topic+format">format</a></code> and
<code><a href="base.html#topic+paste">paste</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>formatted_range(c(1, 3.5, -0.01))

</code></pre>

<hr>
<h2 id='fscale'>Rescale a spectrum using a summary function</h2><span id='topic+fscale'></span><span id='topic+fscale.default'></span><span id='topic+fscale.source_spct'></span><span id='topic+fscale.response_spct'></span><span id='topic+fscale.filter_spct'></span><span id='topic+fscale.reflector_spct'></span><span id='topic+fscale.solute_spct'></span><span id='topic+fscale.raw_spct'></span><span id='topic+fscale.cps_spct'></span><span id='topic+fscale.generic_spct'></span><span id='topic+fscale.source_mspct'></span><span id='topic+fscale.response_mspct'></span><span id='topic+fscale.filter_mspct'></span><span id='topic+fscale.reflector_mspct'></span><span id='topic+fscale.solute_mspct'></span><span id='topic+fscale.raw_mspct'></span><span id='topic+fscale.cps_mspct'></span><span id='topic+fscale.generic_mspct'></span>

<h3>Description</h3>

<p>These methods return a spectral object of the same class as the one
supplied as argument but with the spectral data rescaled based on a summary
function <code>f</code> applied over a specific <code>range</code> of wavelengths and a
<code>target</code> value for the summary value. When the object contains
multiple spectra, the rescaling is applied separately to each spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fscale(x, ...)

## Default S3 method:
fscale(x, ...)

## S3 method for class 'source_spct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  set.scaled = target == 1,
  ...
)

## S3 method for class 'response_spct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  set.scaled = target == 1,
  ...
)

## S3 method for class 'filter_spct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  set.scaled = target == 1,
  ...
)

## S3 method for class 'reflector_spct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  qty.out = NULL,
  set.scaled = target == 1,
  ...
)

## S3 method for class 'solute_spct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  qty.out = NULL,
  set.scaled = target == 1,
  ...
)

## S3 method for class 'raw_spct'
fscale(x, range = NULL, f = "mean", target = 1, set.scaled = target == 1, ...)

## S3 method for class 'cps_spct'
fscale(x, range = NULL, f = "mean", target = 1, set.scaled = target == 1, ...)

## S3 method for class 'generic_spct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  set.scaled = target == 1,
  col.names,
  ...
)

## S3 method for class 'source_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'response_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'filter_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'reflector_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  qty.out = NULL,
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'solute_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'raw_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'cps_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  set.scaled = target == 1,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'generic_mspct'
fscale(
  x,
  range = NULL,
  f = "mean",
  target = 1,
  set.scaled = target == 1,
  col.names,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fscale_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
<tr><td><code id="fscale_+3A_...">...</code></td>
<td>
<p>additional named arguments passed down to <code>f</code>.</p>
</td></tr>
<tr><td><code id="fscale_+3A_range">range</code></td>
<td>
<p>numeric. An R object on which <code>range()</code> returns a numeric
vector of length 2 with the limits of a range of wavelengths in nm, with
min and max wavelengths (nm)</p>
</td></tr>
<tr><td><code id="fscale_+3A_f">f</code></td>
<td>
<p>character string. &quot;mean&quot; or &quot;total&quot; for scaling so that this summary
value becomes 1 for the returned object, or the name of a function taking
<code>x</code> as first argument and returning a numeric value.</p>
</td></tr>
<tr><td><code id="fscale_+3A_target">target</code></td>
<td>
<p>numeric A constant used as target value for scaling.</p>
</td></tr>
<tr><td><code id="fscale_+3A_unit.out">unit.out</code></td>
<td>
<p>character. Allowed values &quot;energy&quot;, and &quot;photon&quot;, or its alias
&quot;quantum&quot;.</p>
</td></tr>
<tr><td><code id="fscale_+3A_set.scaled">set.scaled</code></td>
<td>
<p>logical or NULL Flag indicating if the data is to be marked
as &quot;scaled&quot; or not.</p>
</td></tr>
<tr><td><code id="fscale_+3A_qty.out">qty.out</code></td>
<td>
<p>character. Allowed values &quot;transmittance&quot;, and &quot;absorbance&quot;.</p>
</td></tr>
<tr><td><code id="fscale_+3A_col.names">col.names</code></td>
<td>
<p>character vector containing the names of columns or
variables to which to apply the scaling.</p>
</td></tr>
<tr><td><code id="fscale_+3A_.parallel">.parallel</code></td>
<td>
<p>logical if TRUE, apply function in parallel, using parallel
backend provided by foreach.</p>
</td></tr>
<tr><td><code id="fscale_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After scaling, applying the function passed as argument to <code>f</code>
to the scaled spectrum will return the value passed as argument to
<code>target</code>. <strong>The default for <code>set.scaled</code> depends
dynamically on the passed to <code>target</code>.</strong> Sometimes we rescale a
spectrum to a &quot;theoretical&quot; value for the summary, while in other cases we
rescale the spectrum to a real-world target value of e.g. a reference
energy irradiance. In the first case we say that the data are expressed in
relative units, while in the second case we retain actual physical units.
To indicate this, this package uses an attribute, which will by default be
set assuming the first of these two situations when <code>target == 1</code> and
not set assuming the second situation. These defaults can be
overriden with an explicit <code>logical</code> argument passed to
<code>set.scaled</code>. When present, normalization metadata is filled with
<code>NA</code> values, and the spectrum tagged as not normalized.
</p>


<h3>Value</h3>

<p>A copy of the object passed as argument to <code>x</code> with the original
spectral data values replaced with rescaled values, and the <code>"scaled"</code>
attribute set to a list describing the scaling applied.
</p>
<p>a new object of the same class as <code>x</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fscale(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>fscale(source_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(response_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(filter_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(reflector_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(solute_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(raw_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(cps_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(generic_spct)</code>: 
</p>
</li>
<li> <p><code>fscale(source_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(response_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(solute_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(raw_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>fscale(generic_mspct)</code>: 
</p>
</li></ul>


<h3>Important changes</h3>

<p>Metadata describing the rescaling operation are
stored in an attribute only if <code>set.scaled = TRUE</code> is passed to the call.
The exact format and data stored in the attribute <code>"scaled"</code> has changed
during the development of the package. Spectra re-scaled with earlier
versions will lack some information. To obtain the metadata in a consistent
format irrespective of this variation use accessor <code>getScaling()</code>, which
fills missing fields with <code>NA</code>.
</p>


<h3>Note</h3>

<p>Method <code>fscale</code> is not implemented for <code>solute_spct</code> objects
as the spectral data stored in them are a description of an intensive
property of a substance. To represent solutions of specific concentrations
of solutes, <code>filter_spct</code> objects can be used.
</p>


<h3>See Also</h3>

<p>Other rescaling functions: 
<code><a href="#topic+fshift">fshift</a>()</code>,
<code><a href="#topic+getNormalized">getNormalized</a>()</code>,
<code><a href="#topic+getScaled">getScaled</a>()</code>,
<code><a href="#topic+is_normalized">is_normalized</a>()</code>,
<code><a href="#topic+is_scaled">is_scaled</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+setNormalized">setNormalized</a>()</code>,
<code><a href="#topic+setScaled">setScaled</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fscale(sun.spct)
fscale(sun.spct, f = "mean") # same as default
fscale(sun.spct, f = "mean", na.rm = TRUE)
fscale(sun.spct, range = c(400, 700)) # default is whole spectrum
fscale(sun.spct, f = e_irrad, range = c(400, 700))
s400.spct &lt;- fscale(sun.spct,
                    f = e_irrad,
                    range = c(400, 700),
                    target = 400) # a target in W m-2
s400.spct
e_irrad(s400.spct, c(400, 700))

</code></pre>

<hr>
<h2 id='fscale_spct'>fscale a spectrum</h2><span id='topic+fscale_spct'></span>

<h3>Description</h3>

<p>This function returns a spectral object of the same class as the one
supplied as argument but with the spectral data re-scaled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fscale_spct(spct, range, col.names, f, target, set.scaled, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fscale_spct_+3A_spct">spct</code></td>
<td>
<p>generic_spct The spectrum to be normalized</p>
</td></tr>
<tr><td><code id="fscale_spct_+3A_range">range</code></td>
<td>
<p>an R object on which range() returns a vector of length 2, with
min and max wavelengths (nm)</p>
</td></tr>
<tr><td><code id="fscale_spct_+3A_col.names">col.names</code></td>
<td>
<p>character The name of the variable to fscale</p>
</td></tr>
<tr><td><code id="fscale_spct_+3A_f">f</code></td>
<td>
<p>function A summary function to be applied to <code>spct</code></p>
</td></tr>
<tr><td><code id="fscale_spct_+3A_set.scaled">set.scaled</code></td>
<td>
<p>logical Flag indicating if the data is to be marked
as &quot;scaled&quot; or not.</p>
</td></tr>
<tr><td><code id="fscale_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to f()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new object of the same class as <code>spct</code>.
</p>

<hr>
<h2 id='fshift'>Shift the scale of a spectrum using a summary function</h2><span id='topic+fshift'></span><span id='topic+fshift.default'></span><span id='topic+fshift.source_spct'></span><span id='topic+fshift.response_spct'></span><span id='topic+fshift.filter_spct'></span><span id='topic+fshift.reflector_spct'></span><span id='topic+fshift.source_mspct'></span><span id='topic+fshift.raw_spct'></span><span id='topic+fshift.cps_spct'></span><span id='topic+fshift.generic_spct'></span><span id='topic+fshift.response_mspct'></span><span id='topic+fshift.filter_mspct'></span><span id='topic+fshift.reflector_mspct'></span><span id='topic+fshift.raw_mspct'></span><span id='topic+fshift.cps_mspct'></span><span id='topic+fshift.generic_mspct'></span>

<h3>Description</h3>

<p>The <code>fshift()</code> methods return a spectral object of the same class as the
one supplied as argument but with the spectral data on a zero-shifted scale.
A range of wavelengths is taken as a zero reference and the summary
calculated with <code>f</code> for this waveband is substracted. This results in a
zero shift (= additive correction) to the values in the returned object.
Metadata attributes are retained unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fshift(x, ...)

## Default S3 method:
fshift(x, ...)

## S3 method for class 'source_spct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'response_spct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'filter_spct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  ...
)

## S3 method for class 'reflector_spct'
fshift(x, range = c(wl_min(x), wl_min(x) + 10), f = "min", qty.out = NULL, ...)

## S3 method for class 'source_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'raw_spct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  qty.out = NULL,
  ...
)

## S3 method for class 'cps_spct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  qty.out = NULL,
  ...
)

## S3 method for class 'generic_spct'
fshift(x, range = c(wl_min(x), wl_min(x) + 10), f = "mean", col.names, ...)

## S3 method for class 'response_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'filter_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'reflector_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  qty.out = NULL,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'raw_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'cps_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'generic_mspct'
fshift(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  col.names,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fshift_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
<tr><td><code id="fshift_+3A_...">...</code></td>
<td>
<p>additional named arguments passed down to <code>f</code>.</p>
</td></tr>
<tr><td><code id="fshift_+3A_range">range</code></td>
<td>
<p>An R object on which <code>range()</code> returns a numeric vector of
length 2 with the limits of a range of wavelengths in nm, with min and max
wavelengths (nm)</p>
</td></tr>
<tr><td><code id="fshift_+3A_f">f</code></td>
<td>
<p>character string &quot;mean&quot;, &quot;min&quot; or &quot;max&quot; for scaling so that this
summary value becomes the origin of the spectral data scale in the returned
object, or the name of a function taking <code>x</code> as first argument and
returning a numeric value.</p>
</td></tr>
<tr><td><code id="fshift_+3A_unit.out">unit.out</code></td>
<td>
<p>character Allowed values &quot;energy&quot;, and &quot;photon&quot;, or its alias
&quot;quantum&quot;</p>
</td></tr>
<tr><td><code id="fshift_+3A_qty.out">qty.out</code></td>
<td>
<p>character Allowed values &quot;transmittance&quot;, and &quot;absorbance&quot;</p>
</td></tr>
<tr><td><code id="fshift_+3A_col.names">col.names</code></td>
<td>
<p>character vector containing the names of columns or
variables to which to apply the scale shift.</p>
</td></tr>
<tr><td><code id="fshift_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="fshift_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> with the spectral data values replaced with values
zero-shifted.
</p>
<p>a new object of the same class as <code>x</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fshift(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>fshift(source_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(response_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(filter_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(reflector_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(source_mspct)</code>: 
</p>
</li>
<li> <p><code>fshift(raw_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(cps_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(generic_spct)</code>: 
</p>
</li>
<li> <p><code>fshift(response_mspct)</code>: 
</p>
</li>
<li> <p><code>fshift(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>fshift(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>fshift(raw_mspct)</code>: 
</p>
</li>
<li> <p><code>fshift(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>fshift(generic_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Method <code>fshift</code> is not implemented for <code>solute_spct</code> objects
as the spectral data stored in them are a description of an intensive
property of a substance. To represent solutions of specific concentrations
of solutes, <code>filter_spct</code> objects can be used.
</p>


<h3>See Also</h3>

<p>Other rescaling functions: 
<code><a href="#topic+fscale">fscale</a>()</code>,
<code><a href="#topic+getNormalized">getNormalized</a>()</code>,
<code><a href="#topic+getScaled">getScaled</a>()</code>,
<code><a href="#topic+is_normalized">is_normalized</a>()</code>,
<code><a href="#topic+is_scaled">is_scaled</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+setNormalized">setNormalized</a>()</code>,
<code><a href="#topic+setScaled">setScaled</a>()</code>
</p>

<hr>
<h2 id='fshift_spct'>fshift a spectrum</h2><span id='topic+fshift_spct'></span>

<h3>Description</h3>

<p>This function returns a spectral object of the same class as the one
supplied as argument but with the spectral data expressed on a zero-shifted
scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fshift_spct(spct, range, col.names, f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fshift_spct_+3A_spct">spct</code></td>
<td>
<p>generic_spct The spectrum to be normalized</p>
</td></tr>
<tr><td><code id="fshift_spct_+3A_range">range</code></td>
<td>
<p>an R object on which range() returns a vector of length 2, with
min and max wavelengths (nm)</p>
</td></tr>
<tr><td><code id="fshift_spct_+3A_col.names">col.names</code></td>
<td>
<p>character The name of the variable to shift with respect to
zero.</p>
</td></tr>
<tr><td><code id="fshift_spct_+3A_f">f</code></td>
<td>
<p>function A summary function to be applied to <code>spct</code></p>
</td></tr>
<tr><td><code id="fshift_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to f()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This private function is used internally to implement the
<code>hshift()</code> methods that are exported.
</p>


<h3>Value</h3>

<p>a new object of the same class as <code>spct</code>.
</p>

<hr>
<h2 id='generic_mspct'>Collection-of-spectra constructor</h2><span id='topic+generic_mspct'></span><span id='topic+calibration_mspct'></span><span id='topic+raw_mspct'></span><span id='topic+cps_mspct'></span><span id='topic+source_mspct'></span><span id='topic+filter_mspct'></span><span id='topic+reflector_mspct'></span><span id='topic+object_mspct'></span><span id='topic+solute_mspct'></span><span id='topic+response_mspct'></span><span id='topic+chroma_mspct'></span>

<h3>Description</h3>

<p>Converts a list of spectral objects into a &quot;multi spectrum&quot;
object by setting the class attribute of the list of spectra to the
corresponding multi-spct class, check that components of the list belong to
the expected class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generic_mspct(
  l = NULL,
  class = "generic_spct",
  ncol = 1,
  byrow = FALSE,
  dim = c(length(l)%/%ncol, ncol)
)

calibration_mspct(l = NULL, ncol = 1, byrow = FALSE, ...)

raw_mspct(l = NULL, ncol = 1, byrow = FALSE, ...)

cps_mspct(l = NULL, ncol = 1, byrow = FALSE, ...)

source_mspct(l = NULL, ncol = 1, byrow = FALSE, ...)

filter_mspct(l = NULL, ncol = 1, byrow = FALSE, ...)

reflector_mspct(l = NULL, ncol = 1, byrow = FALSE, ...)

object_mspct(l = NULL, ncol = 1, byrow = FALSE, ...)

solute_mspct(l = NULL, ncol = 1, byrow = FALSE, ...)

response_mspct(l = NULL, ncol = 1, byrow = FALSE, ...)

chroma_mspct(l = NULL, ncol = 1, byrow = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generic_mspct_+3A_l">l</code></td>
<td>
<p>list of generic_spct or derived classes</p>
</td></tr>
<tr><td><code id="generic_mspct_+3A_class">class</code></td>
<td>
<p>character The multi spectrum object class or the expected class
for the elements of l</p>
</td></tr>
<tr><td><code id="generic_mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="generic_mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
<tr><td><code id="generic_mspct_+3A_dim">dim</code></td>
<td>
<p>integer vector of dimensions</p>
</td></tr>
<tr><td><code id="generic_mspct_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>calibration_mspct()</code>: Specialization for collections of <code>calibration_spct</code> objects.
</p>
</li>
<li> <p><code>raw_mspct()</code>: Specialization for collections of <code>raw_spct</code> objects.
</p>
</li>
<li> <p><code>cps_mspct()</code>: Specialization for collections of <code>cps_spct</code> objects.
</p>
</li>
<li> <p><code>source_mspct()</code>: Specialization for collections of <code>source_spct</code> objects.
</p>
</li>
<li> <p><code>filter_mspct()</code>: Specialization for collections of <code>filter_spct</code> objects.
</p>
</li>
<li> <p><code>reflector_mspct()</code>: Specialization for collections of <code>reflector_spct</code> objects.
</p>
</li>
<li> <p><code>object_mspct()</code>: Specialization for collections of <code>object_spct</code> objects.
</p>
</li>
<li> <p><code>solute_mspct()</code>: Specialization for collections of <code>solute_spct</code> objects.
</p>
</li>
<li> <p><code>response_mspct()</code>: Specialization for collections of <code>response_spct</code> objects.
</p>
</li>
<li> <p><code>chroma_mspct()</code>: Specialization for collections of <code>chroma_spct</code> objects.
</p>
</li></ul>


<h3>Note</h3>

<p>Setting class = source_spct or class = source_mspct makes no difference
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filter_mspct(list(polyester.spct, yellow_gel.spct))

</code></pre>

<hr>
<h2 id='get_attributes'>Get the metadata attributes</h2><span id='topic+get_attributes'></span><span id='topic+get_attributes.generic_spct'></span><span id='topic+get_attributes.source_spct'></span><span id='topic+get_attributes.filter_spct'></span><span id='topic+get_attributes.reflector_spct'></span><span id='topic+get_attributes.object_spct'></span><span id='topic+get_attributes.solute_spct'></span><span id='topic+get_attributes.waveband'></span>

<h3>Description</h3>

<p>Method returning attributes of an object of class generic_spct or derived,
or of class waveband. Only attributes defined and/or set by package
'photobiology' for objects of the corresponding class are returned. Parameter
<code>which</code> can be used to subset the list of attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_attributes(x, which, ...)

## S3 method for class 'generic_spct'
get_attributes(x, which = NULL, allowed = all.attributes, ...)

## S3 method for class 'source_spct'
get_attributes(x, which = NULL, ...)

## S3 method for class 'filter_spct'
get_attributes(x, which = NULL, ...)

## S3 method for class 'reflector_spct'
get_attributes(x, which = NULL, ...)

## S3 method for class 'object_spct'
get_attributes(x, which = NULL, ...)

## S3 method for class 'solute_spct'
get_attributes(x, which = NULL, ...)

## S3 method for class 'waveband'
get_attributes(x, which = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_attributes_+3A_x">x</code></td>
<td>
<p>a generic_spct object.</p>
</td></tr>
<tr><td><code id="get_attributes_+3A_which">which</code></td>
<td>
<p>character vector Names of attributes to retrieve.</p>
</td></tr>
<tr><td><code id="get_attributes_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="get_attributes_+3A_allowed">allowed</code></td>
<td>
<p>character vector Names of attributes accepted by <code>which</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectors of character strings passed as argument to <code>which</code> are
parsed so that if the first member string is <code>"-"</code> the remaining
members are removed from the <code>allowed</code>; and if it is <code>"="</code> the
remaining members are used if in <code>allowed</code>. If the first member is
none of these three strings, the behaviour is the same as if the first
string is <code>"="</code>. If <code>which</code> is <code>NULL</code> all the attributes in
<code>allowed</code> are used. The string <code>""</code> means no attributes, and has
precedence over any other values in the character vector. The order of the
names of annotations has no meaning: the vector is interpreted as a set
except for the three possible &quot;operators&quot; at position 1.
</p>


<h3>Value</h3>

<p>Named <code>list</code> of attribute values.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>get_attributes(generic_spct)</code>: generic_spct
</p>
</li>
<li> <p><code>get_attributes(source_spct)</code>: source_spct
</p>
</li>
<li> <p><code>get_attributes(filter_spct)</code>: filter_spct
</p>
</li>
<li> <p><code>get_attributes(reflector_spct)</code>: reflector_spct
</p>
</li>
<li> <p><code>get_attributes(object_spct)</code>: object_spct
</p>
</li>
<li> <p><code>get_attributes(solute_spct)</code>: solute_spct
</p>
</li>
<li> <p><code>get_attributes(waveband)</code>: waveband
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+select_spct_attributes">select_spct_attributes</a></code>
</p>
<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>

<hr>
<h2 id='get_peaks'>Get peaks and valleys in a spectrum</h2><span id='topic+get_peaks'></span><span id='topic+get_valleys'></span>

<h3>Description</h3>

<p>These functions find peaks (local maxima) or valleys (local minima) in a
spectrum, using a user selectable size threshold relative to the tallest peak
(global maximum). This a wrapper built on top of function peaks from package
splus2R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_peaks(
  x,
  y,
  ignore_threshold = 0,
  span = 5,
  strict = TRUE,
  x_unit = "",
  x_digits = 3,
  na.rm = FALSE
)

get_valleys(
  x,
  y,
  ignore_threshold = 0,
  span = 5,
  strict = TRUE,
  x_unit = "",
  x_digits = 3,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_peaks_+3A_x">x</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="get_peaks_+3A_y">y</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="get_peaks_+3A_ignore_threshold">ignore_threshold</code></td>
<td>
<p>numeric Value between 0.0 and 1.0 indicating the
relative size compared to tallest peak threshold below which peaks will be
ignored. Negative values set a threshold so that the tallest peaks are
ignored, instead of the shortest.</p>
</td></tr>
<tr><td><code id="get_peaks_+3A_span">span</code></td>
<td>
<p>integer A peak is defined as an element in a sequence which is
greater than all other elements within a window of width <code>span</code>
centered at that element. Use <code>NULL</code> for the global peak.</p>
</td></tr>
<tr><td><code id="get_peaks_+3A_strict">strict</code></td>
<td>
<p>logical If <code>TRUE</code>, an element must be strictly greater
than all other values in its window to be considered a peak.</p>
</td></tr>
<tr><td><code id="get_peaks_+3A_x_unit">x_unit</code></td>
<td>
<p>character Vector of texts to be pasted at end of labels built
from x value at peaks.</p>
</td></tr>
<tr><td><code id="get_peaks_+3A_x_digits">x_digits</code></td>
<td>
<p>numeric Number of significant digits in wavelength label.</p>
</td></tr>
<tr><td><code id="get_peaks_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be stripped
before searching for peaks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with variables w.length and s.irrad with their values at
the peaks or valleys plus a character variable of labels.
</p>


<h3>See Also</h3>

<p>Other peaks and valleys functions: 
<code><a href="#topic+find_peaks">find_peaks</a>()</code>,
<code><a href="#topic+find_spikes">find_spikes</a>()</code>,
<code><a href="#topic+peaks">peaks</a>()</code>,
<code><a href="#topic+replace_bad_pixs">replace_bad_pixs</a>()</code>,
<code><a href="#topic+spikes">spikes</a>()</code>,
<code><a href="#topic+valleys">valleys</a>()</code>,
<code><a href="#topic+wls_at_target">wls_at_target</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.spct, get_peaks(w.length, s.e.irrad))
with(sun.spct, get_valleys(w.length, s.e.irrad))

</code></pre>

<hr>
<h2 id='getFilterProperties'>Get the &quot;filter.properties&quot; attribute</h2><span id='topic+getFilterProperties'></span><span id='topic+filter_properties'></span><span id='topic+getFilterProperties.default'></span><span id='topic+getFilterProperties.filter_spct'></span><span id='topic+getFilterProperties.summary_filter_spct'></span><span id='topic+getFilterProperties.generic_mspct'></span>

<h3>Description</h3>

<p>Function to read the &quot;filter.properties&quot; attribute of an existing filter_spct
or a filter_mspct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFilterProperties(x, return.null, ...)

filter_properties(x, return.null, ...)

## Default S3 method:
getFilterProperties(x, return.null = FALSE, ...)

## S3 method for class 'filter_spct'
getFilterProperties(x, return.null = FALSE, ...)

## S3 method for class 'summary_filter_spct'
getFilterProperties(x, return.null = FALSE, ...)

## S3 method for class 'generic_mspct'
getFilterProperties(x, return.null = FALSE, ..., idx = "spct.idx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFilterProperties_+3A_x">x</code></td>
<td>
<p>a filter_spct object</p>
</td></tr>
<tr><td><code id="getFilterProperties_+3A_return.null">return.null</code></td>
<td>
<p>logical If true, <code>NULL</code> is returned if the attribute
is not set, otherwise the expected list is returned with all fields set to
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="getFilterProperties_+3A_...">...</code></td>
<td>
<p>Allows use of additional arguments in methods for other classes.</p>
</td></tr>
<tr><td><code id="getFilterProperties_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with fields named <code>"Rfr.constant"</code> [<code class="reqn">/1</code>],
<code>"thickness"</code> [<code class="reqn">m</code>] and <code>"attenuation.mode"</code>. If the
attribute is not set, and <code>return.null</code> is FALSE, a list with fields
set to <code>NA</code> is returned, otherwise, <code>NULL</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getFilterProperties(default)</code>: default
</p>
</li>
<li> <p><code>getFilterProperties(filter_spct)</code>: generic_spct
</p>
</li>
<li> <p><code>getFilterProperties(summary_filter_spct)</code>: summary_generic_spct
</p>
</li>
<li> <p><code>getFilterProperties(generic_mspct)</code>: filter_mspct
</p>
</li></ul>


<h3>Note</h3>

<p>The method for collections of spectra returns the a tibble with a
column of lists.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filter_properties(polyester.spct)

</code></pre>

<hr>
<h2 id='getHowMeasured'>Get the &quot;how.measured&quot; attribute</h2><span id='topic+getHowMeasured'></span><span id='topic+how_measured'></span><span id='topic+getHowMeasured.default'></span><span id='topic+getHowMeasured.generic_spct'></span><span id='topic+getHowMeasured.summary_generic_spct'></span><span id='topic+getHowMeasured.generic_mspct'></span>

<h3>Description</h3>

<p>Function to read the &quot;how.measured&quot; attribute of an existing generic_spct
or a generic_mspct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHowMeasured(x, ...)

how_measured(x, ...)

## Default S3 method:
getHowMeasured(x, ...)

## S3 method for class 'generic_spct'
getHowMeasured(x, ...)

## S3 method for class 'summary_generic_spct'
getHowMeasured(x, ...)

## S3 method for class 'generic_mspct'
getHowMeasured(x, ..., idx = "spct.idx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getHowMeasured_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="getHowMeasured_+3A_...">...</code></td>
<td>
<p>Allows use of additional arguments in methods for other classes.</p>
</td></tr>
<tr><td><code id="getHowMeasured_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector An object containing a description of the data.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getHowMeasured(default)</code>: default
</p>
</li>
<li> <p><code>getHowMeasured(generic_spct)</code>: generic_spct
</p>
</li>
<li> <p><code>getHowMeasured(summary_generic_spct)</code>: summary_generic_spct
</p>
</li>
<li> <p><code>getHowMeasured(generic_mspct)</code>: generic_mspct
</p>
</li></ul>


<h3>Note</h3>

<p>The method for collections of spectra returns the
a tibble with a column of character strings.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>how_measured(sun.spct)

</code></pre>

<hr>
<h2 id='getIdFactor'>Get the &quot;idfactor&quot; attribute</h2><span id='topic+getIdFactor'></span>

<h3>Description</h3>

<p>Function to read the &quot;idfactor&quot; attribute of an existing generic_spct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIdFactor(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIdFactor_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Note</h3>

<p>If x is not a <code>generic_spct</code> or an object of a derived class
<code>NA</code> is returned.
</p>


<h3>See Also</h3>

<p>Other idfactor attribute functions: 
<code><a href="#topic+setIdFactor">setIdFactor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getIdFactor(white_led.cps_spct)

</code></pre>

<hr>
<h2 id='getInstrDesc'>Get the &quot;instr.desc&quot; attribute</h2><span id='topic+getInstrDesc'></span>

<h3>Description</h3>

<p>Function to read the &quot;instr.desc&quot; attribute of an existing generic_spct
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInstrDesc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInstrDesc_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list (depends on instrument type)
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>

<hr>
<h2 id='getInstrSettings'>Get the &quot;instr.settings&quot; attribute</h2><span id='topic+getInstrSettings'></span>

<h3>Description</h3>

<p>Function to read the &quot;instr.settings&quot; attribute of an existing generic_spct
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInstrSettings(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInstrSettings_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>

<hr>
<h2 id='getKType'>Get the &quot;K.type&quot; attribute</h2><span id='topic+getKType'></span>

<h3>Description</h3>

<p>Function to read the &quot;K.type&quot; attribute of an existing solute_spct object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKType(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getKType_+3A_x">x</code></td>
<td>
<p>a solute_spct object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string
</p>


<h3>Note</h3>

<p>If x is not a <code>solute_spct</code> or a <code>summary_solute_spct</code> object,
<code>NA</code> is returned.
</p>


<h3>See Also</h3>

<p>Other K attribute functions: 
<code><a href="#topic+setKType">setKType</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print("missing example")

</code></pre>

<hr>
<h2 id='getMspctVersion'>Get the &quot;mspct.version&quot; attribute</h2><span id='topic+getMspctVersion'></span>

<h3>Description</h3>

<p>Function to read the &quot;mspct.version&quot; attribute of an existing generic_mspct
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMspctVersion(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMspctVersion_+3A_x">x</code></td>
<td>
<p>a generic_mspct object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value
</p>


<h3>Note</h3>

<p>if x is not a <code>generic_mspct</code> object, <code>NA</code> is returned,
and if it the attribute is missing, zero is returned with a warning.
</p>

<hr>
<h2 id='getMultipleWl'>Get the &quot;multiple.wl&quot; attribute</h2><span id='topic+getMultipleWl'></span>

<h3>Description</h3>

<p>Function to read the &quot;multiple.wl&quot; attribute of an existing generic_spct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMultipleWl(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMultipleWl_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>Note</h3>

<p>If x is not a <code>generic_spct</code> or an object of a derived class
<code>NA</code> is returned.
</p>


<h3>See Also</h3>

<p>Other multiple.wl attribute functions: 
<code><a href="#topic+setMultipleWl">setMultipleWl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getMultipleWl(sun.spct)

</code></pre>

<hr>
<h2 id='getNormalized'>Query the &quot;normalized&quot; and &quot;normalization&quot; attributes</h2><span id='topic+getNormalized'></span><span id='topic+getNormalised'></span><span id='topic+getNormalization'></span><span id='topic+getNormalisation'></span>

<h3>Description</h3>

<p>Functions to read the &quot;normalized&quot; and &quot;normalization&quot; attributes of an
existing generic_spct object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNormalized(x, .force.numeric = FALSE)

getNormalised(x, .force.numeric = FALSE)

getNormalization(x)

getNormalisation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNormalized_+3A_x">x</code></td>
<td>
<p>a generic_spct object.</p>
</td></tr>
<tr><td><code id="getNormalized_+3A_.force.numeric">.force.numeric</code></td>
<td>
<p>logical If <code>TRUE</code> always silently return a
numeric value, with <code>FALSE</code> encoded as zero, and character values
as <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spectral data that has been normalized needs to be used diffferently
in computations than data expresed in original units. These two functions
make it possible to query if data stored in an object of class
<code>generic_spct</code> or of a derived class contains data expressed in
physical units or normalized. In the later case, it is possible to also
query how the normalization was done.
</p>


<h3>Value</h3>

<p><code>getNormalized()</code> returns numeric or logical (possibly character
for objects created with earlier versions); for collections of spectra, a
named list, with one member for each spectrum. If <code>x</code> is not a
<code>generic_spct</code> object, <code>NA</code> or a list with fields set to NAs is
returned. Objects created with versions of package 'photobiology' earlier
than 0.10.8 are lacking the detailed normalization metadata.
</p>
<p><code>getNormalization()</code> returns a list with five fields: norm.type,
norm.wl, norm.factors, norm.cols, norm.range. For collections of spectra, a
named list of lists, with one member list for each member of the collection
of spectra. See <code><a href="#topic+setNormalized">setNormalized</a>()</code> for the values stored in the
fields.
</p>


<h3>Note</h3>

<p><code>getNormalised()</code> is a synonym for this <code>getNormalized()</code>
method.
</p>


<h3>See Also</h3>

<p>Other rescaling functions: 
<code><a href="#topic+fscale">fscale</a>()</code>,
<code><a href="#topic+fshift">fshift</a>()</code>,
<code><a href="#topic+getScaled">getScaled</a>()</code>,
<code><a href="#topic+is_normalized">is_normalized</a>()</code>,
<code><a href="#topic+is_scaled">is_scaled</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+setNormalized">setNormalized</a>()</code>,
<code><a href="#topic+setScaled">setScaled</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
getNormalized(sun.spct)
getNormalization(sun.spct)

sun_norm.spct &lt;- normalize(sun.spct)

getNormalized(sun_norm.spct)
getNormalization(sun_norm.spct)

getNormalization(e2q(sun_norm.spct))

gel_norm.spct &lt;- normalize(yellow_gel.spct)

getNormalized(gel_norm.spct)
getNormalization(gel_norm.spct)

getNormalization(T2Afr(gel_norm.spct))
getNormalization(any2A(gel_norm.spct))

</code></pre>

<hr>
<h2 id='getScaled'>Get the &quot;scaled&quot; attribute</h2><span id='topic+getScaled'></span><span id='topic+getScaling'></span>

<h3>Description</h3>

<p>Function to read the &quot;scaled&quot; attribute of an existing generic_spct
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScaled(x, .force.list = FALSE)

getScaling(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getScaled_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="getScaled_+3A_.force.list">.force.list</code></td>
<td>
<p>logical If <code>TRUE</code> always silently return a
list, with <code>FALSE</code> encoded field <code>multiplier = 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Note</h3>

<p>if x is not a <code>filter_spct</code> object, <code>NA</code> is returned
</p>


<h3>See Also</h3>

<p>Other rescaling functions: 
<code><a href="#topic+fscale">fscale</a>()</code>,
<code><a href="#topic+fshift">fshift</a>()</code>,
<code><a href="#topic+getNormalized">getNormalized</a>()</code>,
<code><a href="#topic+is_normalized">is_normalized</a>()</code>,
<code><a href="#topic+is_scaled">is_scaled</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+setNormalized">setNormalized</a>()</code>,
<code><a href="#topic+setScaled">setScaled</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
scaled.spct &lt;- fscale(sun.spct)
getScaled(scaled.spct)

</code></pre>

<hr>
<h2 id='getSoluteProperties'>Get the &quot;solute.properties&quot; attribute</h2><span id='topic+getSoluteProperties'></span><span id='topic+solute_properties'></span><span id='topic+getSoluteProperties.default'></span><span id='topic+getSoluteProperties.solute_spct'></span><span id='topic+getSoluteProperties.summary_solute_spct'></span><span id='topic+getSoluteProperties.solute_mspct'></span>

<h3>Description</h3>

<p>Function to read the <code>"solute.properties"</code> attribute of an existing
<code>solute_spct</code> or a <code>solute_mspct</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSoluteProperties(x, return.null, ...)

solute_properties(x, return.null, ...)

## Default S3 method:
getSoluteProperties(x, return.null = FALSE, ...)

## S3 method for class 'solute_spct'
getSoluteProperties(x, return.null = FALSE, ...)

## S3 method for class 'summary_solute_spct'
getSoluteProperties(x, return.null = FALSE, ...)

## S3 method for class 'solute_mspct'
getSoluteProperties(x, return.null = FALSE, ..., idx = "spct.idx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSoluteProperties_+3A_x">x</code></td>
<td>
<p>solute_spct A spectrum of coefficients of attenuation.</p>
</td></tr>
<tr><td><code id="getSoluteProperties_+3A_return.null">return.null</code></td>
<td>
<p>logical If true, <code>NULL</code> is returned if the attribute
is not set, otherwise the expected list is returned with all fields set to
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="getSoluteProperties_+3A_...">...</code></td>
<td>
<p>Allows use of additional arguments in methods for other classes.</p>
</td></tr>
<tr><td><code id="getSoluteProperties_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> with fields named <code>"mass"</code>, <code>"formula"</code>,
<code>"structure"</code>, <code>"name"</code> and <code>"ID"</code>. If the attribute is not
set, and <code>return.null</code> is <code>FALSE</code>, a list with fields set to
<code>NA</code> is returned, otherwise, <code>NULL</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getSoluteProperties(default)</code>: default
</p>
</li>
<li> <p><code>getSoluteProperties(solute_spct)</code>: solute_spct
</p>
</li>
<li> <p><code>getSoluteProperties(summary_solute_spct)</code>: summary_solute_spct
</p>
</li>
<li> <p><code>getSoluteProperties(solute_mspct)</code>: solute_mspct
</p>
</li></ul>


<h3>Note</h3>

<p>The method for collections of spectra returns the a tibble with a
column of lists.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>solute_properties(water.spct)

</code></pre>

<hr>
<h2 id='getSpctVersion'>Get the &quot;spct.version&quot; attribute</h2><span id='topic+getSpctVersion'></span>

<h3>Description</h3>

<p>Function to read the &quot;spct.version&quot; attribute of an existing generic_spct
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSpctVersion(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSpctVersion_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer value
</p>


<h3>Note</h3>

<p>if x is not a <code>generic_spct</code> object, <code>NA</code> is returned,
and if it the attribute is missing, zero is returned with a warning.
</p>

<hr>
<h2 id='getTimeUnit'>Get the &quot;time.unit&quot; attribute of an existing source_spct object</h2><span id='topic+getTimeUnit'></span>

<h3>Description</h3>

<p>Function to read the &quot;time.unit&quot; attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTimeUnit(x, force.duration = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimeUnit_+3A_x">x</code></td>
<td>
<p>a source_spct object</p>
</td></tr>
<tr><td><code id="getTimeUnit_+3A_force.duration">force.duration</code></td>
<td>
<p>logical If TRUE a lubridate::duration is returned even
if the object attribute is a character string, if no conversion is possible
NA is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string or a lubridate::duration
</p>


<h3>Note</h3>

<p>if x is not a <code>source_spct</code> or a <code>response_spct</code> object, NA
is returned
</p>


<h3>See Also</h3>

<p>Other time attribute functions: 
<code><a href="#topic+checkTimeUnit">checkTimeUnit</a>()</code>,
<code><a href="#topic+convertThickness">convertThickness</a>()</code>,
<code><a href="#topic+convertTimeUnit">convertTimeUnit</a>()</code>,
<code><a href="#topic+setTimeUnit">setTimeUnit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getTimeUnit(sun.spct)

</code></pre>

<hr>
<h2 id='getWhatMeasured'>Get the &quot;what.measured&quot; attribute</h2><span id='topic+getWhatMeasured'></span><span id='topic+what_measured'></span><span id='topic+getWhatMeasured.default'></span><span id='topic+getWhatMeasured.generic_spct'></span><span id='topic+getWhatMeasured.summary_generic_spct'></span><span id='topic+getWhatMeasured.generic_mspct'></span>

<h3>Description</h3>

<p>Function to read the &quot;what.measured&quot; attribute of an existing generic_spct
or a generic_mspct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWhatMeasured(x, ...)

what_measured(x, ...)

## Default S3 method:
getWhatMeasured(x, ...)

## S3 method for class 'generic_spct'
getWhatMeasured(x, ...)

## S3 method for class 'summary_generic_spct'
getWhatMeasured(x, ...)

## S3 method for class 'generic_mspct'
getWhatMeasured(x, ..., idx = "spct.idx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWhatMeasured_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="getWhatMeasured_+3A_...">...</code></td>
<td>
<p>Allows use of additional arguments in methods for other classes.</p>
</td></tr>
<tr><td><code id="getWhatMeasured_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector An object containing a description of the data.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getWhatMeasured(default)</code>: default
</p>
</li>
<li> <p><code>getWhatMeasured(generic_spct)</code>: generic_spct
</p>
</li>
<li> <p><code>getWhatMeasured(summary_generic_spct)</code>: summary_generic_spct
</p>
</li>
<li> <p><code>getWhatMeasured(generic_mspct)</code>: generic_mspct
</p>
</li></ul>


<h3>Note</h3>

<p>The method for collections of spectra returns the
a tibble with a column of character strings.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
what_measured(sun.spct)

</code></pre>

<hr>
<h2 id='getWhenMeasured'>Get the &quot;when.measured&quot; attribute</h2><span id='topic+getWhenMeasured'></span><span id='topic+when_measured'></span><span id='topic+getWhenMeasured.default'></span><span id='topic+getWhenMeasured.generic_spct'></span><span id='topic+getWhenMeasured.summary_generic_spct'></span><span id='topic+getWhenMeasured.generic_mspct'></span>

<h3>Description</h3>

<p>Function to read the &quot;when.measured&quot; attribute of an existing generic_spct
or a generic_mspct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWhenMeasured(x, ...)

when_measured(x, ...)

## Default S3 method:
getWhenMeasured(x, ...)

## S3 method for class 'generic_spct'
getWhenMeasured(x, ...)

## S3 method for class 'summary_generic_spct'
getWhenMeasured(x, ...)

## S3 method for class 'generic_mspct'
getWhenMeasured(x, ..., idx = "spct.idx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWhenMeasured_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="getWhenMeasured_+3A_...">...</code></td>
<td>
<p>Allows use of additional arguments in methods for other classes.</p>
</td></tr>
<tr><td><code id="getWhenMeasured_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>POSIXct An object with date and time.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getWhenMeasured(default)</code>: default
</p>
</li>
<li> <p><code>getWhenMeasured(generic_spct)</code>: generic_spct
</p>
</li>
<li> <p><code>getWhenMeasured(summary_generic_spct)</code>: summary_generic_spct
</p>
</li>
<li> <p><code>getWhenMeasured(generic_mspct)</code>: generic_mspct
</p>
</li></ul>


<h3>Note</h3>

<p>If x is not a <code>generic_spct</code> or an object of a derived class
<code>NA</code> is returned.
</p>
<p>The method for collections of spectra returns the
a tibble with the correct times in TZ = &quot;UTC&quot;.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
when_measured(sun.spct)

</code></pre>

<hr>
<h2 id='getWhereMeasured'>Get the &quot;where.measured&quot; attribute</h2><span id='topic+getWhereMeasured'></span><span id='topic+where_measured'></span><span id='topic+getWhereMeasured.default'></span><span id='topic+getWhereMeasured.generic_spct'></span><span id='topic+getWhereMeasured.summary_generic_spct'></span><span id='topic+getWhereMeasured.generic_mspct'></span>

<h3>Description</h3>

<p>Function to read the &quot;where.measured&quot; attribute of an existing generic_spct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWhereMeasured(x, ...)

where_measured(x, ...)

## Default S3 method:
getWhereMeasured(x, ...)

## S3 method for class 'generic_spct'
getWhereMeasured(x, ...)

## S3 method for class 'summary_generic_spct'
getWhereMeasured(x, ...)

## S3 method for class 'generic_mspct'
getWhereMeasured(x, ..., idx = "spct.idx", .bind.geocodes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWhereMeasured_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="getWhereMeasured_+3A_...">...</code></td>
<td>
<p>Allows use of additional arguments in methods for other classes.</p>
</td></tr>
<tr><td><code id="getWhereMeasured_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="getWhereMeasured_+3A_.bind.geocodes">.bind.geocodes</code></td>
<td>
<p>logical In the case of collections of spectra if
<code>.bind.geocodes = TRUE</code>, the default, the returned value is a single
geocode with one row for each member spectrum. Otherwise the individual
geocode data frames are returned in a list column within a tibble.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with a single row and at least columns &quot;lon&quot; and &quot;lat&quot;,
unless expand is set to <code>FALSE</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getWhereMeasured(default)</code>: default
</p>
</li>
<li> <p><code>getWhereMeasured(generic_spct)</code>: generic_spct
</p>
</li>
<li> <p><code>getWhereMeasured(summary_generic_spct)</code>: summary_generic_spct
</p>
</li>
<li> <p><code>getWhereMeasured(generic_mspct)</code>: generic_mspct
</p>
</li></ul>


<h3>Note</h3>

<p>If x is not a <code>generic_spct</code> or an object of a derived class
<code>NA</code> is returned.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>where_measured(sun.spct)

</code></pre>

<hr>
<h2 id='green_leaf.spct'>Green birch leaf reflectance.</h2><span id='topic+green_leaf.spct'></span>

<h3>Description</h3>

<p>A dataset of spectral reflectance expressed as a fraction of one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>green_leaf.spct
</code></pre>


<h3>Format</h3>

<p>A <code>reflector_spct</code> object with 226 rows and 2 variables
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm) </p>
</li>
<li><p> Rfr (0..1) </p>
</li></ul>



<h3>References</h3>

<p>Aphalo, P. J. &amp; Lehto, T. Effects of light quality on growth and N
accumulation in birch seedlings Tree Physiology, 1997, 17, 125-132
</p>


<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>green_leaf.spct

</code></pre>

<hr>
<h2 id='head_tail'>Return the First and Last Parts of an Object</h2><span id='topic+head_tail'></span><span id='topic+head_tail.default'></span><span id='topic+head_tail.data.frame'></span><span id='topic+head_tail.matrix'></span><span id='topic+head_tail.function'></span><span id='topic+head_tail.table'></span><span id='topic+head_tail.ftable'></span>

<h3>Description</h3>

<p>Returns the first and last &quot;parts&quot; (rows or members) of a spectrum,
dataframe, vector, function, table or ftable. In other words, the combined
output from methods <code>head</code> and <code>tail</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head_tail(x, n, ...)

## Default S3 method:
head_tail(x, n = 3L, ...)

## S3 method for class 'data.frame'
head_tail(x, n = 3L, ...)

## S3 method for class 'matrix'
head_tail(x, n = 3L, ...)

## S3 method for class ''function''
head_tail(x, n = 6L, ...)

## S3 method for class 'table'
head_tail(x, n = 6L, ...)

## S3 method for class 'ftable'
head_tail(x, n = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_tail_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="head_tail_+3A_n">n</code></td>
<td>
<p>integer. If positive, <code>n</code> rows or members in the
returned object are copied from each of &quot;head&quot; and &quot;tail&quot; of <code>x</code>.
If negative, all except <code>n</code> elements of <code>x</code> from each of &quot;head&quot;
and &quot;tail&quot; are returned.</p>
</td></tr>
<tr><td><code id="head_tail_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value returned by <code>head_tail()</code> is equivalent to row
binding the the values returned by <code>head()</code> and <code>tail()</code>,
although not implemented in this way. The same specializations as defined
in package 'utils' for <code>head()</code> and <code>tail()</code> have been
implemented.
</p>


<h3>Value</h3>

<p>An object (usually) like <code>x</code> but smaller, except when
<code>n = 0</code>. For <code>ftable</code> objects <code>x</code>, a transformed
<code>format(x)</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>head_tail(default)</code>: 
</p>
</li>
<li> <p><code>head_tail(data.frame)</code>: 
</p>
</li>
<li> <p><code>head_tail(matrix)</code>: 
</p>
</li>
<li> <p><code>head_tail(`function`)</code>: 
</p>
</li>
<li> <p><code>head_tail(table)</code>: 
</p>
</li>
<li> <p><code>head_tail(ftable)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>For some types of input, like functions, the output may be confusing,
however, we have opted for consistency with existing functions. The code is
in part a revision of that of <code>head()</code> and <code>tail()</code> from package
&lsquo;utils&rsquo;. This method is especially useful when checking spectral
data, as both ends are of interest.
</p>
<p><code>head_tail()</code> methods for function, table and ftable classes, are
wrappers for head() method.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+head">head</a></code>, and compare the examples and the values
returned to the examples below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head_tail(letters)
head_tail(letters, n = -6L)
head_tail(freeny.x, n = 10L)
head_tail(freeny.y)

head_tail(stats::ftable(Titanic))

</code></pre>

<hr>
<h2 id='illuminance'>Irradiance</h2><span id='topic+illuminance'></span><span id='topic+illuminance.default'></span><span id='topic+illuminance.source_spct'></span><span id='topic+illuminance.source_mspct'></span>

<h3>Description</h3>

<p>Computes illuminance (lux), or the luminous flux incident on a surface, from
spectral irradiance stored in a <code>source_spct</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>illuminance(spct, std, scale.factor, allow.scaled, ...)

## Default S3 method:
illuminance(spct, std, scale.factor, allow.scaled, ...)

## S3 method for class 'source_spct'
illuminance(
  spct,
  std = "CIE2deg",
  scale.factor = 1,
  allow.scaled = FALSE,
  naming = "default",
  ...
)

## S3 method for class 'source_mspct'
illuminance(
  spct,
  std = "CIE2deg",
  scale.factor = 1,
  allow.scaled = FALSE,
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="illuminance_+3A_spct">spct</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="illuminance_+3A_std">std</code></td>
<td>
<p>character The luminous efficiency function to use,
<code>"CIE2deg"</code> or <code>"CIE10deg"</code>.</p>
</td></tr>
<tr><td><code id="illuminance_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or the character string
<code>exposure</code>.</p>
</td></tr>
<tr><td><code id="illuminance_+3A_allow.scaled">allow.scaled</code></td>
<td>
<p>logical indicating whether scaled or normalized spectra
as argument to spct are flagged as an error.</p>
</td></tr>
<tr><td><code id="illuminance_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td></tr>
<tr><td><code id="illuminance_+3A_naming">naming</code></td>
<td>
<p>character one of <code>"long"</code>, <code>"default"</code>,
<code>"short"</code> or <code>"none"</code>. Used to select the type of names to assign
to returned value.</p>
</td></tr>
<tr><td><code id="illuminance_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="illuminance_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="illuminance_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach.</p>
</td></tr>
<tr><td><code id="illuminance_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector of length one in the case of methods
for individual spectra. A <code>data.frame</code> in the case of collections of
spectra, containing one column with illuminance, an index column with the
names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>The <code>time.unit</code> attribute is always second. Units are as follows: if
time.unit of the argument passed to <code>spct</code> is second, [W m-2 nm-1] -&gt;
[lx], otherwise average value [lx] for the period unless
<code>exposure = TRUE</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>illuminance(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>illuminance(source_spct)</code>: Calculates illuminance from a <code>source_spct</code>
object.
</p>
</li>
<li> <p><code>illuminance(source_mspct)</code>: Calculates illuminance from a <code>source_mspct</code> object.
</p>
</li></ul>


<h3>Note</h3>

<p>Formal parameter <code>allow.scaled</code> is used internally for calculation
of ratios, as rescaling and normalization do not invalidate the calculation
of ratios within one spectrum.
</p>


<h3>References</h3>

<p>Stockman, A. (2019) Cone fundamentals and CIE standards.
<em>Current Opinion in Behavioral Sciences</em>, 30, 87-93.
<a href="https://doi.org/10.1016/j.cobeha.2019.06.005">doi:10.1016/j.cobeha.2019.06.005</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>illuminance(sun.spct)
illuminance(sun.daily.spct)
illuminance(sun.daily.spct, scale.factor = "exposure")
illuminance(sun.daily.spct, scale.factor = 1e-3)

</code></pre>

<hr>
<h2 id='insert_hinges'>Insert wavelength values into spectral data.</h2><span id='topic+insert_hinges'></span>

<h3>Description</h3>

<p>Inserting wavelengths values immediately before and after a discontinuity in
the SWF, greatly reduces the errors caused by interpolating the weighted
irradiance during integration of the effective spectral irradiance. This is
specially true when data have a large wavelength step size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_hinges(x, y, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_hinges_+3A_x">x</code></td>
<td>
<p>numeric vector (sorted in increasing order)</p>
</td></tr>
<tr><td><code id="insert_hinges_+3A_y">y</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="insert_hinges_+3A_h">h</code></td>
<td>
<p>a numeric vector giving the wavelengths at which the y values
should be inserted by interpolation, no interpolation is indicated by an
empty vector (numeric(0))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with variables <code>x</code> and <code>y</code>. Unless the hinge
values were already present in <code>y</code>, each inserted hinge, expands the
vectors returned in the data frame by one value.
</p>


<h3>Note</h3>

<p>Insertion is a costly operation but I have tried to optimize this
function as much as possible by avoiding loops. Earlier this function was
implemented in C++, but a bug was discovered and I have now rewritten it
using R.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data,
    insert_hinges(w.length, s.e.irrad,
       c(399.99, 400.00, 699.99, 700.00)))

</code></pre>

<hr>
<h2 id='insert_spct_hinges'>Insert new wavelength values into a spectrum</h2><span id='topic+insert_spct_hinges'></span>

<h3>Description</h3>

<p>Insert new wavelength values into a spectrum interpolating the corresponding
spectral data values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_spct_hinges(spct, hinges = NULL, byref = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_spct_hinges_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
<tr><td><code id="insert_spct_hinges_+3A_hinges">hinges</code></td>
<td>
<p>numeric vector of wavelengths (nm) at which the
s.irrad should be inserted by interpolation, no interpolation is indicated
by an empty vector (numeric(0))</p>
</td></tr>
<tr><td><code id="insert_spct_hinges_+3A_byref">byref</code></td>
<td>
<p>logical indicating if new object will be created by reference or
by copy of spct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a generic_spct or a derived type with variables <code>w.length</code> and
other numeric variables.
</p>


<h3>Note</h3>

<p>Inserting wavelengths values &quot;hinges&quot; immediately before and after a
discontinuity in the SWF, greatly reduces the errors caused by
interpolating the weighted irradiance during integration of the effective
spectral irradiance. This is specially true when data has a large
wavelength step size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
insert_spct_hinges(sun.spct, c(399.99,400.00,699.99,700.00))
insert_spct_hinges(sun.spct,
                   c(199.99,200.00,399.50,399.99,400.00,699.99,
                         700.00,799.99,1000.00))
</code></pre>

<hr>
<h2 id='integrate_spct'>Integrate spectral data.</h2><span id='topic+integrate_spct'></span>

<h3>Description</h3>

<p>This function gives the result of integrating spectral data over wavelengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate_spct(spct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrate_spct_+3A_spct">spct</code></td>
<td>
<p>generic_spct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One or more numeric values with no change in scale factor: e.g. [W
m-2 nm-1] -&gt; [W m-2]. Each value in the returned vector corresponds to a
variable in the spectral object, except for wavelength. For non-numeric
variables the returned value is <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
integrate_spct(sun.spct)

</code></pre>

<hr>
<h2 id='integrate_xy'>Gives irradiance from spectral irradiance.</h2><span id='topic+integrate_xy'></span>

<h3>Description</h3>

<p>This function gives the result of integrating spectral irradiance over
wavelengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate_xy(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrate_xy_+3A_x">x</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="integrate_xy_+3A_y">y</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value with no change in scale factor: e.g. [W m-2
nm-1] -&gt; [W m-2]
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data, integrate_xy(w.length, s.e.irrad))

</code></pre>

<hr>
<h2 id='interpolate_spct'>Map a spectrum to new wavelength values.</h2><span id='topic+interpolate_spct'></span><span id='topic+interpolate_mspct'></span>

<h3>Description</h3>

<p>This function gives the result of interpolating spectral data from the original set of
wavelengths to a new one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_spct(spct, w.length.out = NULL, fill = NA, length.out = NULL)

interpolate_mspct(
  mspct,
  w.length.out = NULL,
  fill = NA,
  length.out = NULL,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_spct_+3A_spct">spct</code></td>
<td>
<p>generic_spct</p>
</td></tr>
<tr><td><code id="interpolate_spct_+3A_w.length.out">w.length.out</code></td>
<td>
<p>numeric vector of wavelengths (nm)</p>
</td></tr>
<tr><td><code id="interpolate_spct_+3A_fill">fill</code></td>
<td>
<p>a value to be assigned to out of range wavelengths</p>
</td></tr>
<tr><td><code id="interpolate_spct_+3A_length.out">length.out</code></td>
<td>
<p>numeric value</p>
</td></tr>
<tr><td><code id="interpolate_spct_+3A_mspct">mspct</code></td>
<td>
<p>an object of class &quot;generic_mspct&quot;</p>
</td></tr>
<tr><td><code id="interpolate_spct_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="interpolate_spct_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>length.out</code> it is a numeric value, then gives the number of
rows in the output, if it is <code>NULL</code>, the values in the numeric vector
<code>w.length.out</code> are used. If both are not <code>NULL</code> then the range of
<code>w.length.out</code> and <code>length.out</code> are used to generate a vector of
wavelength. A value of <code>NULL</code> for <code>fill</code> prevents extrapolation.
If both <code>w.length.out</code> and <code>length.out</code> are <code>NULL</code> the input
is returned as is. If <code>w.length.out</code> has length equal to zero, zero
rows from the input are returned.
</p>


<h3>Value</h3>

<p>A new spectral object of the same class as argument <code>spct</code>.
</p>


<h3>Note</h3>

<p>The default <code>fill = NA</code> fills extrapolated values with NA. Giving NULL as
argument for <code>fill</code> deletes wavelengths outside the input data range from the
returned spectrum. A numerical value can be also be provided as fill. This function calls
<code>interpolate_spectrum</code> for each non-wavelength column in the input spectra object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
interpolate_spct(sun.spct, 400:500, NA)
interpolate_spct(sun.spct, 400:500, NULL)
interpolate_spct(sun.spct, seq(200, 1000, by=0.1), 0)
interpolate_spct(sun.spct, c(400,500), length.out=201)

</code></pre>

<hr>
<h2 id='interpolate_spectrum'>Calculate spectral values at a different set of wavelengths</h2><span id='topic+interpolate_spectrum'></span>

<h3>Description</h3>

<p>Interpolate/re-express spectral irradiance (or other spectral quantity)
values at new wavelengths values. This is a low-level function operating
on numeric vectors and called by higher level functions in the package,
such as mathematical operators for classes for spectral data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_spectrum(w.length.in, s.irrad, w.length.out, fill = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_spectrum_+3A_w.length.in">w.length.in</code></td>
<td>
<p>numeric vector of wavelengths (nm).</p>
</td></tr>
<tr><td><code id="interpolate_spectrum_+3A_s.irrad">s.irrad</code></td>
<td>
<p>a numeric vector of spectral values.</p>
</td></tr>
<tr><td><code id="interpolate_spectrum_+3A_w.length.out">w.length.out</code></td>
<td>
<p>numeric vector of wavelengths (nm).</p>
</td></tr>
<tr><td><code id="interpolate_spectrum_+3A_fill">fill</code></td>
<td>
<p>a value to be assigned to out of range wavelengths.</p>
</td></tr>
<tr><td><code id="interpolate_spectrum_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>spline()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of interpolated spectral values.
</p>


<h3>Note</h3>

<p>The current version of interpolate uses <code>spline</code> if fewer than 25
data points are available. Otherwise it uses <code>approx</code>. In the first case
a cubic spline is used, in the second case linear interpolation, which should
be faster.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+splinefun">splinefun</a></code>.
</p>
<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.w.length &lt;- 300:700
with(sun.data, interpolate_spectrum(w.length, s.e.irrad, my.w.length))

</code></pre>

<hr>
<h2 id='interpolate_wl'>Map spectra to new wavelength values.</h2><span id='topic+interpolate_wl'></span><span id='topic+interpolate_wl.default'></span><span id='topic+interpolate_wl.generic_spct'></span><span id='topic+interpolate_wl.generic_mspct'></span>

<h3>Description</h3>

<p>This function returns the result of interpolating spectral data from the original set of
wavelengths to a new one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_wl(x, w.length.out, fill, length.out, ...)

## Default S3 method:
interpolate_wl(x, w.length.out, fill, length.out, ...)

## S3 method for class 'generic_spct'
interpolate_wl(x, w.length.out = NULL, fill = NA, length.out = NULL, ...)

## S3 method for class 'generic_mspct'
interpolate_wl(
  x,
  w.length.out = NULL,
  fill = NA,
  length.out = NULL,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_wl_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="interpolate_wl_+3A_w.length.out">w.length.out</code></td>
<td>
<p>numeric vector of wavelengths (nm)</p>
</td></tr>
<tr><td><code id="interpolate_wl_+3A_fill">fill</code></td>
<td>
<p>a value to be assigned to out of range wavelengths</p>
</td></tr>
<tr><td><code id="interpolate_wl_+3A_length.out">length.out</code></td>
<td>
<p>numeric value</p>
</td></tr>
<tr><td><code id="interpolate_wl_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="interpolate_wl_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="interpolate_wl_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>length.out</code> it is a numeric value, then gives the number of rows in the
output, if it is <code>NULL</code>, the values in the numeric vector <code>w.length.out</code> are used.
If both are not <code>NULL</code> then the range of <code>w.length.out</code> and <code>length.out</code> are
used to generate a vector of wavelength. A value of <code>NULL</code> for <code>fill</code> prevents
extrapolation.
</p>


<h3>Value</h3>

<p>A new spectral object of the same class as argument <code>spct</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>interpolate_wl(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>interpolate_wl(generic_spct)</code>: Interpolate wavelength in an object of class
&quot;generic_spct&quot; or derived.
</p>
</li>
<li> <p><code>interpolate_wl(generic_mspct)</code>: Interpolate wavelength in an object of class
&quot;generic_mspct&quot; or derived.
</p>
</li></ul>


<h3>Note</h3>

<p>The default <code>fill = NA</code> fills extrapolated values with NA. Giving NULL as
argument for <code>fill</code> deletes wavelengths outside the input data range from the
returned spectrum. A numerical value can be also be provided as fill. This function calls
<code>interpolate_spectrum</code> for each non-wavelength column in the input spectra object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>interpolate_wl(sun.spct, 400:500, NA)
interpolate_wl(sun.spct, 400:500, NULL)
interpolate_wl(sun.spct, seq(200, 1000, by=0.1), 0)
interpolate_wl(sun.spct, c(400,500), length.out=201)

</code></pre>

<hr>
<h2 id='irrad'>Irradiance</h2><span id='topic+irrad'></span><span id='topic+irrad.default'></span><span id='topic+irrad.source_spct'></span><span id='topic+irrad.source_mspct'></span>

<h3>Description</h3>

<p>This function returns the irradiance for a given waveband of a light source
spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irrad(
  spct,
  w.band,
  unit.out,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## Default S3 method:
irrad(
  spct,
  w.band,
  unit.out,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## S3 method for class 'source_spct'
irrad(
  spct,
  w.band = NULL,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = !quantity %in% c("average", "mean", "total"),
  naming = "default",
  return.tb = FALSE,
  ...
)

## S3 method for class 'source_mspct'
irrad(
  spct,
  w.band = NULL,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = !quantity %in% c("average", "mean", "total"),
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irrad_+3A_spct">spct</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="irrad_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects The waveband(s) determine
the region(s) of the spectrum that are summarized.</p>
</td></tr>
<tr><td><code id="irrad_+3A_unit.out">unit.out</code></td>
<td>
<p>character Allowed values <code>"energy"</code>, and
<code>"photon"</code>, or its alias <code>"quantum"</code>.</p>
</td></tr>
<tr><td><code id="irrad_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;,
&quot;contribution&quot;, &quot;contribution.pc&quot;, &quot;relative&quot; or &quot;relative.pc&quot;.</p>
</td></tr>
<tr><td><code id="irrad_+3A_time.unit">time.unit</code></td>
<td>
<p>character or lubridate::duration object.</p>
</td></tr>
<tr><td><code id="irrad_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="irrad_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if <code>TRUE</code> wavebands crossing spectral data
boundaries are trimmed, if <code>FALSE</code>, they are discarded.</p>
</td></tr>
<tr><td><code id="irrad_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls.</p>
</td></tr>
<tr><td><code id="irrad_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands. If NULL, default is chosen based on data.</p>
</td></tr>
<tr><td><code id="irrad_+3A_allow.scaled">allow.scaled</code></td>
<td>
<p>logical indicating whether scaled or normalized spectra
as argument to spct are flagged as an error.</p>
</td></tr>
<tr><td><code id="irrad_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td></tr>
<tr><td><code id="irrad_+3A_naming">naming</code></td>
<td>
<p>character one of <code>"long"</code>, <code>"default"</code>,
<code>"short"</code> or <code>"none"</code>. Used to select the type of names to assign
to returned value.</p>
</td></tr>
<tr><td><code id="irrad_+3A_return.tb">return.tb</code></td>
<td>
<p>logical Flag forcing a tibble to be always returned, even
for a single spectrum as argumnet to <code>spct</code>. The default is
<code>FALSE</code> for backwards compatibility.</p>
</td></tr>
<tr><td><code id="irrad_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="irrad_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="irrad_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach.</p>
</td></tr>
<tr><td><code id="irrad_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector in the case of a <code>_spct</code> object
containing a single spectrum and <code>return.tb = FALSE</code>. The vector has
one member one value for each <code>waveband</code> passed to parameter
<code>w.band</code>. In all other cases a <code>tibble</code>, containing one column
for each <code>waveband</code> object, an index column with the names of the
spectra, and optionally additional columns with metadata values retrieved
from the attributes of the member spectra.
</p>
<p>If <code>naming = "long"</code> the names generated reflect both quantity and
waveband, if <code>naming = "short"</code>, names are based only on the wavebands,
and if <code>naming = "none"</code> the returned vector has no names.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used. The <code>time.unit</code>
attribute is copied from the spectrum object to the output. Units are as
follows: If time.unit is second, [W m-2 nm-1] -&gt; [mol s-1 m-2] or [W m-2
nm-1] -&gt; [W m-2] If time.unit is day, [J d-1 m-2 nm-1] -&gt; [mol d-1 m-2] or
[J d-1 m-2 nm-1] -&gt; [J m-2]
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>irrad(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>irrad(source_spct)</code>: Calculates irradiance from a <code>source_spct</code>
object.
</p>
</li>
<li> <p><code>irrad(source_mspct)</code>: Calculates irradiance from a <code>source_mspct</code> object.
</p>
</li></ul>


<h3>Note</h3>

<p>Formal parameter <code>allow.scaled</code> is used internally for calculation
of ratios, as rescaling and normalization do not invalidate the calculation
of ratios.
</p>
<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult=TRUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>See Also</h3>

<p>Other irradiance functions: 
<code><a href="#topic+e_fluence">e_fluence</a>()</code>,
<code><a href="#topic+e_irrad">e_irrad</a>()</code>,
<code><a href="#topic+fluence">fluence</a>()</code>,
<code><a href="#topic+q_fluence">q_fluence</a>()</code>,
<code><a href="#topic+q_irrad">q_irrad</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>irrad(sun.spct, waveband(c(400,700)))
irrad(sun.spct, waveband(c(400,700)), "energy")
irrad(sun.spct, waveband(c(400,700)), "photon")
irrad(sun.spct, split_bands(c(400,700), length.out = 3))
irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "total")
irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "average")
irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "relative")
irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "relative.pc")
irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "contribution")
irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "contribution.pc")

</code></pre>

<hr>
<h2 id='irrad_extraterrestrial'>Extraterrestrial irradiance</h2><span id='topic+irrad_extraterrestrial'></span>

<h3>Description</h3>

<p>Estimate of down-welling solar (short wave) irradiance at the top of the
atmosphere above a location on Earth, computed based on angles, Sun-Earth
distance and the solar constant. Astronomical computations are done with
function <code>sun_angles()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irrad_extraterrestrial(
  time = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  solar.constant = "NASA"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irrad_extraterrestrial_+3A_time">time</code></td>
<td>
<p>A &quot;vector&quot; of POSIXct Time, with any valid time zone (TZ) is
allowed, default is current time.</p>
</td></tr>
<tr><td><code id="irrad_extraterrestrial_+3A_tz">tz</code></td>
<td>
<p>character string indicating time zone to be used in output.</p>
</td></tr>
<tr><td><code id="irrad_extraterrestrial_+3A_geocode">geocode</code></td>
<td>
<p>data frame with variables lon and lat as numeric values
(degrees), nrow &gt; 1, allowed.</p>
</td></tr>
<tr><td><code id="irrad_extraterrestrial_+3A_solar.constant">solar.constant</code></td>
<td>
<p>numeric or character If character, &quot;WMO&quot; or &quot;NASA&quot;, if
numeric, an irradiance value in the same units as the value to be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of extraterrestrial irradiance (in W / m2 if solar
constant is a character value).
</p>


<h3>See Also</h3>

<p>Function <code><a href="#topic+sun_angles">sun_angles</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

irrad_extraterrestrial(ymd_hm("2021-06-21 12:00", tz = "UTC"))

irrad_extraterrestrial(ymd_hm("2021-12-21 20:00", tz = "UTC"))

irrad_extraterrestrial(ymd_hm("2021-06-21 00:00", tz = "UTC") + hours(1:23))

</code></pre>

<hr>
<h2 id='irradiance'>Photon or energy irradiance from spectral energy or photon irradiance.</h2><span id='topic+irradiance'></span>

<h3>Description</h3>

<p>Energy or photon irradiance for one or more wavebands of a radiation
spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irradiance(
  w.length,
  s.irrad,
  w.band = NULL,
  unit.out = NULL,
  unit.in = "energy",
  check.spectrum = TRUE,
  use.cached.mult = FALSE,
  use.hinges = getOption("photobiology.use.hinges", default = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irradiance_+3A_w.length">w.length</code></td>
<td>
<p>numeric Vector of wavelength [<code class="reqn">nm</code>].</p>
</td></tr>
<tr><td><code id="irradiance_+3A_s.irrad">s.irrad</code></td>
<td>
<p>numeric vector of spectral (energy) irradiances
[<code class="reqn">W\,m^{-2}\,nm^{-1}</code>].</p>
</td></tr>
<tr><td><code id="irradiance_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects The waveband(s) determine
the region(s) of the spectrum that are summarized.</p>
</td></tr>
<tr><td><code id="irradiance_+3A_unit.out">unit.out</code>, <code id="irradiance_+3A_unit.in">unit.in</code></td>
<td>
<p>character Allowed values <code>"energy"</code>, and
<code>"photon"</code>, or its alias <code>"quantum"</code>.</p>
</td></tr>
<tr><td><code id="irradiance_+3A_check.spectrum">check.spectrum</code></td>
<td>
<p>logical Flag indicating whether to sanity check input
data, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="irradiance_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag indicating whether multiplier values
should be cached between calls.</p>
</td></tr>
<tr><td><code id="irradiance_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value or a vector of numeric values with no change
in scale factor: [<code class="reqn">mol\,s^{-1}\,sm^{-2}\,nm^{-1}</code>]
yields [<code class="reqn">mol\,s^{-1}\,sm^{-2}</code>]
</p>


<h3>Note</h3>

<p>The last three parameters control speed optimizations. The defaults
should be suitable in most cases. If you set <code>check.spectrum=FALSE</code>
then you should call <code>check_spectrum()</code> at least once for your
spectrum before using any of the other functions. If you will use
repeatedly the same SWFs on many spectra measured at exactly the same
wavelengths you may obtain some speed up by setting
<code>use.cached.mult=TRUE</code>. However, be aware that you are responsible for
ensuring that the wavelengths are the same in each call, as the only test
done is for the length of the <code>w.length</code> vector. The is no reason for
setting <code>use.cpp.code=FALSE</code> other than for testing the improvement in
speed, or in cases where there is no suitable C++ compiler for building the
package.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
with(sun.data, irradiance(w.length, s.e.irrad, new_waveband(400,700), "photon"))
</code></pre>

<hr>
<h2 id='is_absorbance_based'>Query if a spectrum contains absorbance or transmittance data</h2><span id='topic+is_absorbance_based'></span><span id='topic+is_absorptance_based'></span><span id='topic+is_transmittance_based'></span>

<h3>Description</h3>

<p>Functions to query if an filter spectrum contains spectral absorbance data or
spectral transmittance data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_absorbance_based(x)

is_absorptance_based(x)

is_transmittance_based(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_absorbance_based_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_absorbance_based</code> returns a logical value, <code>TRUE</code> if its argument is a <code>filter_spct</code>
object that contains spectral absorbance data and <code>FALSE</code> otherwise,
but returns <code>NA</code> for any other R object, including those belonging
other <code>generic_spct</code>-derived classes.
</p>
<p><code>is_absorptance_based</code> returns a logical value, if its argument
is a <code>filter_spct</code> object, <code>TRUE</code> if it contains data as spectral
absorptance and <code>FALSE</code> otherwise, but returns <code>NA</code> for any other
R object, including those belonging other <code>generic_spct</code>-derived
classes.
</p>
<p><code>is_transmittance_based</code> returns TRUE if its argument is a
<code>filter_spct</code> object that contains spectral transmittance data and
FALSE if it does not contain such data, but returns NA for any other R
object, including those belonging other <code>generic_spct</code>-derived
classes.
</p>


<h3>See Also</h3>

<p>Other query units functions: 
<code><a href="#topic+is_mole_based">is_mole_based</a>()</code>,
<code><a href="#topic+is_photon_based">is_photon_based</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_absorbance_based(polyester.spct)
my.spct &lt;- T2A(polyester.spct)
is.filter_spct(my.spct)
is_absorbance_based(my.spct)

is_absorptance_based(polyester.spct)

is_transmittance_based(polyester.spct)

</code></pre>

<hr>
<h2 id='is_effective'>Is an R object &quot;effective&quot;</h2><span id='topic+is_effective'></span><span id='topic+is_effective.default'></span><span id='topic+is_effective.waveband'></span><span id='topic+is_effective.generic_spct'></span><span id='topic+is_effective.source_spct'></span><span id='topic+is_effective.summary_generic_spct'></span><span id='topic+is_effective.summary_source_spct'></span>

<h3>Description</h3>

<p>A generic function for querying if a biological spectral weighting function
(BSWF) has been applied to an object or is included in its definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_effective(x)

## Default S3 method:
is_effective(x)

## S3 method for class 'waveband'
is_effective(x)

## S3 method for class 'generic_spct'
is_effective(x)

## S3 method for class 'source_spct'
is_effective(x)

## S3 method for class 'summary_generic_spct'
is_effective(x)

## S3 method for class 'summary_source_spct'
is_effective(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_effective_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>is_effective(default)</code>: Default method.
</p>
</li>
<li> <p><code>is_effective(waveband)</code>: Is a <code>waveband</code> object defining a method for
calculating effective irradiance.
</p>
</li>
<li> <p><code>is_effective(generic_spct)</code>: Does a <code>source_spct</code> object contain effective
spectral irradiance values.
</p>
</li>
<li> <p><code>is_effective(source_spct)</code>: Does a <code>source_spct</code> object contain effective
spectral irradiance values.
</p>
</li>
<li> <p><code>is_effective(summary_generic_spct)</code>: Method for &quot;summary_generic_spct&quot;.
</p>
</li>
<li> <p><code>is_effective(summary_source_spct)</code>: Method for &quot;summary_source_spct&quot;.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other waveband attributes: 
<code><a href="#topic+labels">labels</a>()</code>,
<code><a href="#topic+normalization">normalization</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_effective(summary(sun.spct))

</code></pre>

<hr>
<h2 id='is_mole_based'>Query if a spectrum contains mole or mass based data</h2><span id='topic+is_mole_based'></span><span id='topic+is_mass_based'></span>

<h3>Description</h3>

<p>Functions to check if an solute attenuation spectrum contains coefficients
on expressed on mole of mass base.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mole_based(x)

is_mass_based(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_mole_based_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_mole_based</code> returns TRUE if its argument is a
<code>solute_spct</code> object that contains spectral <code>K.mole</code> data and
<code>FALSE</code> if it contains <code>K.mass</code> data, but returns NA for any
other R object, including those belonging other <code>generic_spct</code>-derived
classes. <code>is_mass_based</code> returns the complement of
<code>is_mole_based</code>.
</p>


<h3>See Also</h3>

<p>Other query units functions: 
<code><a href="#topic+is_absorbance_based">is_absorbance_based</a>()</code>,
<code><a href="#topic+is_photon_based">is_photon_based</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print("missing example")

</code></pre>

<hr>
<h2 id='is_normalized'>Query whether a generic spectrum has been normalized.</h2><span id='topic+is_normalized'></span><span id='topic+is_normalised'></span>

<h3>Description</h3>

<p>This function tests a <code>generic_spct</code> object for an attribute that
signals whether the spectral data has been normalized or not after the object
was created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_normalized(x)

is_normalised(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_normalized_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> value indicating if <code>x</code> is normalized or not,
for collections of spectra, a named list with <code>logicals</code> as members.
If <code>x</code> is not a <code>generic_spct</code> or <code>generic_mspct</code> object the
value returned is <code>NA</code>.
</p>


<h3>Note</h3>

<p><code>is_normalised()</code> is a synonym for this <code>is_normalized()</code>
method.
</p>


<h3>See Also</h3>

<p>Other rescaling functions: 
<code><a href="#topic+fscale">fscale</a>()</code>,
<code><a href="#topic+fshift">fshift</a>()</code>,
<code><a href="#topic+getNormalized">getNormalized</a>()</code>,
<code><a href="#topic+getScaled">getScaled</a>()</code>,
<code><a href="#topic+is_scaled">is_scaled</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+setNormalized">setNormalized</a>()</code>,
<code><a href="#topic+setScaled">setScaled</a>()</code>
</p>

<hr>
<h2 id='is_photon_based'>Query if a spectrum contains photon- or energy-based data.</h2><span id='topic+is_photon_based'></span><span id='topic+is_energy_based'></span>

<h3>Description</h3>

<p>Functions to query if <code>source_spct</code> and <code>response_spct</code> objects
contain photon-based or energy-based data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_photon_based(x)

is_energy_based(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_photon_based_+3A_x">x</code></td>
<td>
<p>any R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_photon_based</code> returns a logical value, <code>TRUE</code> if its argument is a <code>source_spct</code>
or a <code>response_spct</code> object that contains photon base data and
<code>FALSE</code> otherwise, but returns <code>NA</code> for any other R object,
including those belonging other <code>generic_spct</code>-derived classes.
</p>
<p><code>is_energy_based</code> returns a logical value, <code>TRUE</code> if its argument is a <code>source_spct</code>
or a <code>response_spct</code> object that contains energy base data and
<code>FALSE</code> otherwise, but returns <code>NA</code> for any other R object,
including those belonging other <code>generic_spct</code>-derived classes
</p>


<h3>See Also</h3>

<p>Other query units functions: 
<code><a href="#topic+is_absorbance_based">is_absorbance_based</a>()</code>,
<code><a href="#topic+is_mole_based">is_mole_based</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colnames(sun.spct)
is_photon_based(sun.spct)
my.spct &lt;- sun.spct[ , c("w.length", "s.e.irrad")]
is.source_spct(my.spct)
is_photon_based(my.spct)

colnames(sun.spct)
is_energy_based(sun.spct)
my.spct &lt;- sun.spct[ , c("w.length", "s.q.irrad")]
is.source_spct(my.spct)
is_energy_based(my.spct)

</code></pre>

<hr>
<h2 id='is_scaled'>Query whether a generic spectrum has been scaled</h2><span id='topic+is_scaled'></span>

<h3>Description</h3>

<p>This function tests a <code>generic_spct</code> object for an attribute that
signals whether the spectral data has been rescaled or not after the object
was created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_scaled(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_scaled_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> value. If <code>x</code> is not scaled or <code>x</code> is
not a <code>generic_spct</code> object the value returned is <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p>Other rescaling functions: 
<code><a href="#topic+fscale">fscale</a>()</code>,
<code><a href="#topic+fshift">fshift</a>()</code>,
<code><a href="#topic+getNormalized">getNormalized</a>()</code>,
<code><a href="#topic+getScaled">getScaled</a>()</code>,
<code><a href="#topic+is_normalized">is_normalized</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+setNormalized">setNormalized</a>()</code>,
<code><a href="#topic+setScaled">setScaled</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
scaled.spct &lt;- fscale(sun.spct)
is_scaled(sun.spct)
is_scaled(scaled.spct)

</code></pre>

<hr>
<h2 id='is_tagged'>Query if a spectrum is tagged</h2><span id='topic+is_tagged'></span>

<h3>Description</h3>

<p>Functions to check if an spct object contains tags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_tagged(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_tagged_+3A_x">x</code></td>
<td>
<p>any R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_tagged</code> returns a logical value, <code>TRUE</code> if its argument is a a spectrum that contains
tags and <code>FALSE</code> if it is an untagged spectrum, but returns <code>NA</code>
for any other R object.
</p>


<h3>See Also</h3>

<p>Other tagging and related functions: 
<code><a href="#topic+tag">tag</a>()</code>,
<code><a href="#topic+untag">untag</a>()</code>,
<code><a href="#topic+wb2rect_spct">wb2rect_spct</a>()</code>,
<code><a href="#topic+wb2spct">wb2spct</a>()</code>,
<code><a href="#topic+wb2tagged_spct">wb2tagged_spct</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_tagged(sun.spct)

</code></pre>

<hr>
<h2 id='is.generic_mspct'>Query class of spectrum objects</h2><span id='topic+is.generic_mspct'></span><span id='topic+is.calibration_mspct'></span><span id='topic+is.raw_mspct'></span><span id='topic+is.cps_mspct'></span><span id='topic+is.source_mspct'></span><span id='topic+is.response_mspct'></span><span id='topic+is.filter_mspct'></span><span id='topic+is.reflector_mspct'></span><span id='topic+is.object_mspct'></span><span id='topic+is.solute_mspct'></span><span id='topic+is.chroma_mspct'></span><span id='topic+is.any_mspct'></span>

<h3>Description</h3>

<p>Functions to check if an object is of a given type of spectrum, or coerce it if
possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.generic_mspct(x)

is.calibration_mspct(x)

is.raw_mspct(x)

is.cps_mspct(x)

is.source_mspct(x)

is.response_mspct(x)

is.filter_mspct(x)

is.reflector_mspct(x)

is.object_mspct(x)

is.solute_mspct(x)

is.chroma_mspct(x)

is.any_mspct(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.generic_mspct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions return <code>TRUE</code> if its argument is a of the queried type
of spectrum and <code>FALSE</code> otherwise.
</p>


<h3>Note</h3>

<p>Derived types also return TRUE for a query for a base type such as
<code>generic_mspct</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.mspct &lt;- filter_mspct(list(polyester.spct, yellow_gel.spct))
is.any_mspct(my.mspct)
is.filter_mspct(my.mspct)
is.source_mspct(my.mspct)

</code></pre>

<hr>
<h2 id='is.generic_spct'>Query class of spectrum objects</h2><span id='topic+is.generic_spct'></span><span id='topic+is.raw_spct'></span><span id='topic+is.calibration_spct'></span><span id='topic+is.cps_spct'></span><span id='topic+is.source_spct'></span><span id='topic+is.response_spct'></span><span id='topic+is.filter_spct'></span><span id='topic+is.reflector_spct'></span><span id='topic+is.object_spct'></span><span id='topic+is.solute_spct'></span><span id='topic+is.chroma_spct'></span><span id='topic+is.any_spct'></span>

<h3>Description</h3>

<p>Functions to query whether an object is of a given type of spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.generic_spct(x)

is.raw_spct(x)

is.calibration_spct(x)

is.cps_spct(x)

is.source_spct(x)

is.response_spct(x)

is.filter_spct(x)

is.reflector_spct(x)

is.object_spct(x)

is.solute_spct(x)

is.chroma_spct(x)

is.any_spct(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.generic_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value, <code>TRUE</code> if the argument passed to <code>x</code> is an
object of the queried type of spectrum and <code>FALSE</code> otherwise.
</p>


<h3>Note</h3>

<p>Derived types also return <code>TRUE</code> for a query for a base type such
as <code>generic_spct</code>, following R's practice.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.source_spct(sun.spct)
is.filter_spct(sun.spct)
is.generic_spct(sun.spct)
is.generic_spct(sun.spct)

is.source_spct(sun.spct)
is.filter_spct(sun.spct)
is.generic_spct(sun.spct)
is.generic_spct(sun.spct)

</code></pre>

<hr>
<h2 id='is.old_spct'>Query if an object has old class names</h2><span id='topic+is.old_spct'></span>

<h3>Description</h3>

<p>Query if an object has old class names Query if an object has old class names
as used in photobiology (&gt;= 0.6.0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.old_spct(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.old_spct_+3A_object">object</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>See Also</h3>

<p>Other upgrade from earlier versions: 
<code><a href="#topic+upgrade_spct">upgrade_spct</a>()</code>,
<code><a href="#topic+upgrade_spectra">upgrade_spectra</a>()</code>
</p>

<hr>
<h2 id='is.solar_time'>Query class</h2><span id='topic+is.solar_time'></span><span id='topic+is.solar_date'></span>

<h3>Description</h3>

<p>Query class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.solar_time(x)

is.solar_date(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.solar_time_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Local solar time functions: 
<code><a href="#topic+as.solar_date">as.solar_date</a>()</code>,
<code><a href="#topic+print.solar_time">print.solar_time</a>()</code>,
<code><a href="#topic+solar_time">solar_time</a>()</code>
</p>

<hr>
<h2 id='is.summary_generic_spct'>Query class of spectrum summary objects</h2><span id='topic+is.summary_generic_spct'></span><span id='topic+is.summary_raw_spct'></span><span id='topic+is.summary_cps_spct'></span><span id='topic+is.summary_source_spct'></span><span id='topic+is.summary_response_spct'></span><span id='topic+is.summary_filter_spct'></span><span id='topic+is.summary_reflector_spct'></span><span id='topic+is.summary_object_spct'></span><span id='topic+is.summary_solute_spct'></span><span id='topic+is.summary_chroma_spct'></span><span id='topic+is.any_summary_spct'></span>

<h3>Description</h3>

<p>Functions to check if an object is of a given type of spectrum, or coerce it if
possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.summary_generic_spct(x)

is.summary_raw_spct(x)

is.summary_cps_spct(x)

is.summary_source_spct(x)

is.summary_response_spct(x)

is.summary_filter_spct(x)

is.summary_reflector_spct(x)

is.summary_object_spct(x)

is.summary_solute_spct(x)

is.summary_chroma_spct(x)

is.any_summary_spct(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.summary_generic_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions return <code>TRUE</code> if its argument is a of the queried type
of spectrum and <code>FALSE</code> otherwise.
</p>


<h3>Note</h3>

<p>Derived types also return TRUE for a query for a base type such as
<code>generic_spct</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sm &lt;- summary(sun.spct)
is.summary_source_spct(sm)

</code></pre>

<hr>
<h2 id='is.waveband'>Query if it is a waveband</h2><span id='topic+is.waveband'></span>

<h3>Description</h3>

<p>Functions to check if an object is waveband.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.waveband(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.waveband_+3A_x">x</code></td>
<td>
<p>any R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>is.waveband returns TRUE if its argument is a waveband and FALSE
otherwise.
</p>

<hr>
<h2 id='isValidInstrDesc'>Check the &quot;instr.desc&quot; attribute</h2><span id='topic+isValidInstrDesc'></span>

<h3>Description</h3>

<p>Function to validate the &quot;instr.settings&quot; attribute of an existing generic_spct
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isValidInstrDesc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isValidInstrDesc_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical TRUE if at least instrument name and serial number is found.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>

<hr>
<h2 id='isValidInstrSettings'>Check the &quot;instr.settings&quot; attribute</h2><span id='topic+isValidInstrSettings'></span>

<h3>Description</h3>

<p>Function to validate the &quot;instr.settings&quot; attribute of an existing generic_spct
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isValidInstrSettings(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isValidInstrSettings_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical TRUE if at least integration time data is found.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>

<hr>
<h2 id='join_mspct'>Join all spectra in a collection</h2><span id='topic+join_mspct'></span><span id='topic+join_mspct.default'></span><span id='topic+join_mspct.generic_mspct'></span><span id='topic+join_mspct.source_mspct'></span><span id='topic+join_mspct.response_mspct'></span><span id='topic+join_mspct.filter_mspct'></span><span id='topic+join_mspct.reflector_mspct'></span><span id='topic+join_mspct.object_mspct'></span><span id='topic+join_mspct.solute_mspct'></span>

<h3>Description</h3>

<p>Join all the spectra contained in a homogeneous collection, returning a data
frame with spectral-data columns named according to the names of the spectra
in the collection. By default a full join is done within the overlapping range
of wavelengths, after interpolating the spectra to a shared set of wavelength
values, and discarding data for wavelength not shared. Alternatively, filling
the spectral data for wavelengths outside the overlapping range with with
<code>NA</code> when data is not available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_mspct(x, type, ...)

## Default S3 method:
join_mspct(x, type = "full", ...)

## S3 method for class 'generic_mspct'
join_mspct(x, type = "full", col.name, validate.names = TRUE, ...)

## S3 method for class 'source_mspct'
join_mspct(x, type = "full", unit.out = "energy", validate.names = TRUE, ...)

## S3 method for class 'response_mspct'
join_mspct(x, type = "full", unit.out = "energy", validate.names = TRUE, ...)

## S3 method for class 'filter_mspct'
join_mspct(
  x,
  type = "full",
  qty.out = "transmittance",
  validate.names = TRUE,
  ...
)

## S3 method for class 'reflector_mspct'
join_mspct(x, type = "full", validate.names = TRUE, ...)

## S3 method for class 'object_mspct'
join_mspct(x, type = "full", qty.out, validate.names = TRUE, ...)

## S3 method for class 'solute_mspct'
join_mspct(x, type = "full", validate.names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_mspct_+3A_x">x</code></td>
<td>
<p>generic_mspct object, or an object of a class derived from
<code>generic_mspct</code>.</p>
</td></tr>
<tr><td><code id="join_mspct_+3A_type">type</code></td>
<td>
<p>character Type of join: <code>"inner"</code> (default) or
<code>"full"</code>. See details for more information.</p>
</td></tr>
<tr><td><code id="join_mspct_+3A_...">...</code></td>
<td>
<p>ignored (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="join_mspct_+3A_col.name">col.name</code></td>
<td>
<p>character, name of the column in the spectra to be preserved,
in addition to &quot;w.length&quot;.</p>
</td></tr>
<tr><td><code id="join_mspct_+3A_validate.names">validate.names</code></td>
<td>
<p>logical A flag to enable (default) or disable
validation of column names with <code><a href="base.html#topic+make.names">make.names</a></code>.</p>
</td></tr>
<tr><td><code id="join_mspct_+3A_unit.out">unit.out</code></td>
<td>
<p>character Allowed values <code>"energy"</code>, and <code>"photon"</code>, or its alias
<code>"quantum"</code>.</p>
</td></tr>
<tr><td><code id="join_mspct_+3A_qty.out">qty.out</code></td>
<td>
<p>character Allowed values <code>"transmittance"</code>,
<code>"absorptance"</code>, and <code>"absorbance"</code> and in the method for
<code>object_spct</code>, also <code>"reflectance"</code> (.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the spectra joined by, possibly
interpolated, wavelength, with rows sorted by wavelength (variable
<code>w.length</code>) and data columns named according to the names of members
in <code>x</code>, by default made unique and valid.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>join_mspct(default)</code>: 
</p>
</li>
<li> <p><code>join_mspct(generic_mspct)</code>: 
</p>
</li>
<li> <p><code>join_mspct(source_mspct)</code>: 
</p>
</li>
<li> <p><code>join_mspct(response_mspct)</code>: 
</p>
</li>
<li> <p><code>join_mspct(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>join_mspct(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>join_mspct(object_mspct)</code>: 
</p>
</li>
<li> <p><code>join_mspct(solute_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Currently only <code>generic_spct</code>, <code>source_mspct</code>,
<code>response_mspct</code>, <code>filter_mspct</code>, <code>reflector_mspct</code>,
<code>object_mspct</code> and <code>solute_mspct</code> classes have this method
implemented.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.mspct &lt;- solute_mspct(list(water = water.spct, pha = phenylalanine.spct))
join_mspct(my.mspct, type = "inner")
join_mspct(my.mspct, type = "full")

</code></pre>

<hr>
<h2 id='l_insert_hinges'>Insert wavelength values into spectral data.</h2><span id='topic+l_insert_hinges'></span>

<h3>Description</h3>

<p>Inserting wavelengths values immediately before and after a discontinuity in
the SWF, greatly reduces the errors caused by interpolating the weighted
irradiance during integration of the effective spectral irradiance. This is
specially true when data have a large wavelength step size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_insert_hinges(x, y, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_insert_hinges_+3A_x">x</code></td>
<td>
<p>numeric vector (sorted in increasing order)</p>
</td></tr>
<tr><td><code id="l_insert_hinges_+3A_y">y</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="l_insert_hinges_+3A_h">h</code></td>
<td>
<p>a numeric vector giving the wavelengths at which the y values
should be inserted by interpolation, no interpolation is indicated by an
empty vector (numeric(0))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with variables <code>x</code> and <code>y</code>. Unless the hinge values
were already present in <code>y</code>, each inserted hinge, expands the vectors
by two values.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>

<hr>
<h2 id='labels'>Find labels from &quot;waveband&quot; object</h2><span id='topic+labels'></span><span id='topic+labels.waveband'></span><span id='topic+labels.generic_spct'></span>

<h3>Description</h3>

<p>A method specialization that extracts the name and label of objects of class
<code>waveband</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'waveband'
labels(object, ...)

## S3 method for class 'generic_spct'
labels(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels_+3A_object">object</code></td>
<td>
<p>an object of class &quot;waveband&quot;</p>
</td></tr>
<tr><td><code id="labels_+3A_...">...</code></td>
<td>
<p>not used in current version</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>labels(generic_spct)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p>Other waveband attributes: 
<code><a href="#topic+is_effective">is_effective</a>()</code>,
<code><a href="#topic+normalization">normalization</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>labels(sun.spct)

</code></pre>

<hr>
<h2 id='Ler_leaf.spct'>Green Arabidopsis leaf reflectance and transmittance.</h2><span id='topic+Ler_leaf.spct'></span><span id='topic+Ler_leaf_rflt.spct'></span><span id='topic+Ler_leaf_trns.spct'></span><span id='topic+Ler_leaf_trns_i.spct'></span>

<h3>Description</h3>

<p>A dataset of total spectral reflectance and total spectral
transmittance expressed as fractions of one from the upper surface of a
leaf of an Arabidopsis thaliana 'Ler' rosette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ler_leaf.spct

Ler_leaf_rflt.spct

Ler_leaf_trns.spct

Ler_leaf_trns_i.spct
</code></pre>


<h3>Format</h3>

<p>Datasets stored as <code>object_spct</code>, <code>reflector_spct</code> and
<code>filter_spct</code> objects, containing transmittance and reflectance
data.
</p>
<p>An object of class <code>reflector_spct</code> (inherits from <code>generic_spct</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 1750 rows and 2 columns.
</p>
<p>An object of class <code>filter_spct</code> (inherits from <code>generic_spct</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 1753 rows and 2 columns.
</p>
<p>An object of class <code>filter_spct</code> (inherits from <code>generic_spct</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 2401 rows and 3 columns.
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm) </p>
</li>
<li><p> Rfr (0..1) </p>
</li>
<li><p> Tfr (0..1)</p>
</li></ul>



<h3>Note</h3>

<p>Measured with a Jaz spectrometer from Ocean Optics (USA) configured
with a PX Xenon lamp module and Spectroclip double integrating spheres.
</p>


<h3>Author(s)</h3>

<p>Aphalo, P. J. &amp; Wang, F (unpublished data)
</p>


<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Ler_leaf.spct
Ler_leaf_rflt.spct

</code></pre>

<hr>
<h2 id='log'>Logarithms and Exponentials</h2><span id='topic+log'></span><span id='topic+log.generic_spct'></span><span id='topic+log2.generic_spct'></span><span id='topic+log10.generic_spct'></span><span id='topic+exp.generic_spct'></span>

<h3>Description</h3>

<p>Logarithms and Exponentials for Spectra. The functions are applied to the
spectral data, not the wavelengths. The quantity in the spectrum to which the
function is applied depends on the class of <code>x</code> and the current value of
output options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
log(x, base = exp(1))

## S3 method for class 'generic_spct'
log2(x)

## S3 method for class 'generic_spct'
log10(x)

## S3 method for class 'generic_spct'
exp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_+3A_x">x</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
<tr><td><code id="log_+3A_base">base</code></td>
<td>
<p>a positive number: the base with respect to which logarithms are
computed. Defaults to e=exp(1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>.
</p>


<h3>Note</h3>

<p>In most cases a logarithm of an spectral quantity will yield off-range
values. For this reason unless <code>x</code> is an object of base class
<code>generic_spct</code>, checks will not be passed, resulting in warnings or
errors.
</p>


<h3>See Also</h3>

<p>Other math operators and functions: 
<code><a href="#topic+MathFun">MathFun</a></code>,
<code><a href="#topic++5E.generic_spct">^.generic_spct</a>()</code>,
<code><a href="#topic+convolve_each">convolve_each</a>()</code>,
<code><a href="#topic+div-.generic_spct">div-.generic_spct</a></code>,
<code><a href="#topic+minus-.generic_spct">minus-.generic_spct</a></code>,
<code><a href="#topic+mod-.generic_spct">mod-.generic_spct</a></code>,
<code><a href="#topic+plus-.generic_spct">plus-.generic_spct</a></code>,
<code><a href="#topic+round">round</a>()</code>,
<code><a href="#topic+sign">sign</a>()</code>,
<code><a href="#topic+slash-.generic_spct">slash-.generic_spct</a></code>,
<code><a href="#topic+times-.generic_spct">times-.generic_spct</a></code>
</p>

<hr>
<h2 id='make_wl_consistent'>Make wavelengths consistent</h2><span id='topic+make_wl_consistent'></span>

<h3>Description</h3>

<p>Ensure wavelengths in all spectra in a <code>mspct</code> object are consistent,
filling head and tail of spectral quantities when needed with NAs, and using
interpolation if needed. If individual <code>spct</code> objects contain multiple
spectra in long form these are split into multiple <code>spct</code> objects, each
containing data for one spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_wl_consistent(x, w.length.out = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_wl_consistent_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="make_wl_consistent_+3A_w.length.out">w.length.out</code></td>
<td>
<p>numeric vector of wavelengths (nanometres)</p>
</td></tr>
</table>

<hr>
<h2 id='MathFun'>Miscellaneous Mathematical Functions</h2><span id='topic+MathFun'></span><span id='topic+sqrt.generic_spct'></span><span id='topic+abs.generic_spct'></span>

<h3>Description</h3>

<p><code>abs(x)</code> computes the absolute value of <code>x</code>, <code>sqrt(x)</code>
computes the (principal) square root of <code>x</code>. The functions are applied
to the spectral data, not the wavelengths. The quantity in the spectrum to
which the function is applied depends on the class of <code>x</code> and the current
value of output options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
sqrt(x)

## S3 method for class 'generic_spct'
abs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MathFun_+3A_x">x</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other math operators and functions: 
<code><a href="#topic++5E.generic_spct">^.generic_spct</a>()</code>,
<code><a href="#topic+convolve_each">convolve_each</a>()</code>,
<code><a href="#topic+div-.generic_spct">div-.generic_spct</a></code>,
<code><a href="#topic+log">log</a>()</code>,
<code><a href="#topic+minus-.generic_spct">minus-.generic_spct</a></code>,
<code><a href="#topic+mod-.generic_spct">mod-.generic_spct</a></code>,
<code><a href="#topic+plus-.generic_spct">plus-.generic_spct</a></code>,
<code><a href="#topic+round">round</a>()</code>,
<code><a href="#topic+sign">sign</a>()</code>,
<code><a href="#topic+slash-.generic_spct">slash-.generic_spct</a></code>,
<code><a href="#topic+times-.generic_spct">times-.generic_spct</a></code>
</p>

<hr>
<h2 id='merge_attributes'>Merge and copy attributes</h2><span id='topic+merge_attributes'></span><span id='topic+merge_attributes.default'></span><span id='topic+merge_attributes.generic_spct'></span>

<h3>Description</h3>

<p>Merge attributes from <code>x</code> and <code>y</code> and copy them to <code>z</code>.
Methods defined for spectral objects of classes from package 'photobiology'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_attributes(x, y, z, which, which.not, ...)

## Default S3 method:
merge_attributes(x, y, z, which = NULL, which.not = NULL, ...)

## S3 method for class 'generic_spct'
merge_attributes(
  x,
  y,
  z,
  which = NULL,
  which.not = NULL,
  copy.class = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_attributes_+3A_x">x</code>, <code id="merge_attributes_+3A_y">y</code>, <code id="merge_attributes_+3A_z">z</code></td>
<td>
<p>R objects. Objects <code>x</code> and <code>y</code> must be of the same class,
<code>z</code> must be an object with a structure valid for this same class.</p>
</td></tr>
<tr><td><code id="merge_attributes_+3A_which">which</code></td>
<td>
<p>character Names of attributes to copy, if NULL all those
relevant according to the class of <code>x</code> are used as default,</p>
</td></tr>
<tr><td><code id="merge_attributes_+3A_which.not">which.not</code></td>
<td>
<p>character Names of attributes not to be copied. The
names passed here are removed from the list for <code>which</code>, which
is most useful when we want to modify the default.</p>
</td></tr>
<tr><td><code id="merge_attributes_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="merge_attributes_+3A_copy.class">copy.class</code></td>
<td>
<p>logical If TRUE class attributes are also copied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>z</code> with additional attributes set.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>merge_attributes(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>merge_attributes(generic_spct)</code>: 
</p>
</li></ul>

<hr>
<h2 id='merge2object_spct'>Merge into object_spct</h2><span id='topic+merge2object_spct'></span>

<h3>Description</h3>

<p>Merge a <code>filter_spct</code> with a <code>reflector_spct</code> returning an
<code>object_spct</code> object, even if wavelength values are mismatched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge2object_spct(
  x,
  y,
  by = "w.length",
  ...,
  w.length.out = x[["w.length"]],
  Tfr.type.out = "total"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge2object_spct_+3A_x">x</code>, <code id="merge2object_spct_+3A_y">y</code></td>
<td>
<p>a <code>filter_spct</code> object and a <code>reflector_spct</code> object.</p>
</td></tr>
<tr><td><code id="merge2object_spct_+3A_by">by</code></td>
<td>
<p>a vector of shared column names in <code>x</code> and <code>y</code> to merge
on; <code>by</code> defaults to <code>w.length</code>.</p>
</td></tr>
<tr><td><code id="merge2object_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>dplyr::inner_join()</code>.</p>
</td></tr>
<tr><td><code id="merge2object_spct_+3A_w.length.out">w.length.out</code></td>
<td>
<p>numeric vector of wavelengths to be used for the returned
object (<code class="reqn">nm</code>).</p>
</td></tr>
<tr><td><code id="merge2object_spct_+3A_tfr.type.out">Tfr.type.out</code></td>
<td>
<p>character string indicating whether transmittance values
in the returned object should be expressed as <code>"total"</code> or
<code>"internal"</code>. This applies only to the case when an <code>object_spct</code>
is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>object_spct</code> is returned as the result of merging a
<code>filter_spct</code> and a <code>reflector_spct</code> object.
</p>


<h3>Note</h3>

<p>If a numeric vector is supplied as argument for <code>w.length.out</code>,
the two spectra are interpolated to the new wavelength values before
merging. The default argument for <code>w.length.out</code> is
<code>x[["w.length"]]</code>.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+join">join</a></code>
</p>

<hr>
<h2 id='minus-.generic_spct'>Arithmetic Operators</h2><span id='topic+minus-.generic_spct'></span><span id='topic+-.generic_spct'></span>

<h3>Description</h3>

<p>Subtraction operator for generic spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
e1 - e2 = NULL
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minus-.generic_spct_+3A_e1">e1</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
<tr><td><code id="minus-.generic_spct_+3A_e2">e2</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other math operators and functions: 
<code><a href="#topic+MathFun">MathFun</a></code>,
<code><a href="#topic++5E.generic_spct">^.generic_spct</a>()</code>,
<code><a href="#topic+convolve_each">convolve_each</a>()</code>,
<code><a href="#topic+div-.generic_spct">div-.generic_spct</a></code>,
<code><a href="#topic+log">log</a>()</code>,
<code><a href="#topic+mod-.generic_spct">mod-.generic_spct</a></code>,
<code><a href="#topic+plus-.generic_spct">plus-.generic_spct</a></code>,
<code><a href="#topic+round">round</a>()</code>,
<code><a href="#topic+sign">sign</a>()</code>,
<code><a href="#topic+slash-.generic_spct">slash-.generic_spct</a></code>,
<code><a href="#topic+times-.generic_spct">times-.generic_spct</a></code>
</p>

<hr>
<h2 id='mod-.generic_spct'>Arithmetic Operators</h2><span id='topic+mod-.generic_spct'></span><span id='topic++25+25.generic_spct'></span>

<h3>Description</h3>

<p>Reminder operator for generic spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
e1 %% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mod-.generic_spct_+3A_e1">e1</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
<tr><td><code id="mod-.generic_spct_+3A_e2">e2</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other math operators and functions: 
<code><a href="#topic+MathFun">MathFun</a></code>,
<code><a href="#topic++5E.generic_spct">^.generic_spct</a>()</code>,
<code><a href="#topic+convolve_each">convolve_each</a>()</code>,
<code><a href="#topic+div-.generic_spct">div-.generic_spct</a></code>,
<code><a href="#topic+log">log</a>()</code>,
<code><a href="#topic+minus-.generic_spct">minus-.generic_spct</a></code>,
<code><a href="#topic+plus-.generic_spct">plus-.generic_spct</a></code>,
<code><a href="#topic+round">round</a>()</code>,
<code><a href="#topic+sign">sign</a>()</code>,
<code><a href="#topic+slash-.generic_spct">slash-.generic_spct</a></code>,
<code><a href="#topic+times-.generic_spct">times-.generic_spct</a></code>
</p>

<hr>
<h2 id='msmsply'>Multi-spct transform methods</h2><span id='topic+msmsply'></span><span id='topic+msdply'></span><span id='topic+mslply'></span><span id='topic+msaply'></span>

<h3>Description</h3>

<p>Apply a function or operator to a collection of spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msmsply(mspct, .fun, ..., .parallel = FALSE, .paropts = NULL)

msdply(
  mspct,
  .fun,
  ...,
  idx = NULL,
  col.names = NULL,
  .parallel = FALSE,
  .paropts = NULL
)

mslply(mspct, .fun, ..., .parallel = FALSE, .paropts = NULL)

msaply(mspct, .fun, ..., .drop = TRUE, .parallel = FALSE, .paropts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msmsply_+3A_mspct">mspct</code></td>
<td>
<p>an object of class generic_mspct or a derived class</p>
</td></tr>
<tr><td><code id="msmsply_+3A_.fun">.fun</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="msmsply_+3A_...">...</code></td>
<td>
<p>other arguments passed to .fun</p>
</td></tr>
<tr><td><code id="msmsply_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="msmsply_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
<tr><td><code id="msmsply_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="msmsply_+3A_col.names">col.names</code></td>
<td>
<p>character Names to be used for data columns.</p>
</td></tr>
<tr><td><code id="msmsply_+3A_.drop">.drop</code></td>
<td>
<p>should extra dimensions of length 1 in the output be dropped,
simplifying the output. Defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a collection of spectra in the case of <code>msmsply</code>, belonging to a
different class than <code>mspct</code> if <code>.fun</code> modifies the class of the
member spectra.
</p>
<p>a data frame in the case of <code>msdply</code>
</p>
<p>a list in the case of <code>mslply</code>
</p>
<p>an vector in the case of <code>msaply</code>
</p>

<hr>
<h2 id='mspct_classes'>Names of multi-spectra classes</h2><span id='topic+mspct_classes'></span>

<h3>Description</h3>

<p>Function that returns a vector containing the names of multi-spectra classes
using for collections of spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mspct_classes()
</code></pre>


<h3>Value</h3>

<p>A <code>character</code> vector of class names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mspct_classes()

</code></pre>

<hr>
<h2 id='na.omit'>Handle Missing Values in Objects</h2><span id='topic+na.omit'></span><span id='topic+na.omit.generic_spct'></span><span id='topic+na.omit.source_spct'></span><span id='topic+na.omit.response_spct'></span><span id='topic+na.omit.filter_spct'></span><span id='topic+na.omit.reflector_spct'></span><span id='topic+na.omit.object_spct'></span><span id='topic+na.omit.solute_spct'></span><span id='topic+na.omit.cps_spct'></span><span id='topic+na.omit.raw_spct'></span><span id='topic+na.omit.chroma_spct'></span><span id='topic+na.omit.generic_mspct'></span><span id='topic+na.exclude.generic_spct'></span><span id='topic+na.exclude.source_spct'></span><span id='topic+na.exclude.response_spct'></span><span id='topic+na.exclude.filter_spct'></span><span id='topic+na.exclude.reflector_spct'></span><span id='topic+na.exclude.object_spct'></span><span id='topic+na.exclude.solute_spct'></span><span id='topic+na.exclude.cps_spct'></span><span id='topic+na.exclude.raw_spct'></span><span id='topic+na.exclude.chroma_spct'></span><span id='topic+na.exclude.generic_mspct'></span>

<h3>Description</h3>

<p>These methods are useful for dealing with NAs in e.g., <code>source_spct</code>,
<code>response_spct</code>, <code>filter_spct</code> and <code>reflector_spct</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
na.omit(object, na.action = "omit", fill = NULL, target.colnames, ...)

## S3 method for class 'source_spct'
na.omit(object, na.action = "omit", fill = NULL, ...)

## S3 method for class 'response_spct'
na.omit(object, na.action = "omit", fill = NULL, ...)

## S3 method for class 'filter_spct'
na.omit(object, na.action = "omit", fill = NULL, ...)

## S3 method for class 'reflector_spct'
na.omit(object, na.action = "omit", fill = NULL, ...)

## S3 method for class 'object_spct'
na.omit(object, na.action = "omit", fill = NULL, ...)

## S3 method for class 'solute_spct'
na.omit(object, na.action = "omit", fill = NULL, ...)

## S3 method for class 'cps_spct'
na.omit(object, na.action = "omit", fill = NULL, ...)

## S3 method for class 'raw_spct'
na.omit(object, na.action = "omit", fill = NULL, ...)

## S3 method for class 'chroma_spct'
na.omit(object, na.action = "omit", fill = NULL, ...)

## S3 method for class 'generic_mspct'
na.omit(object, na.action = "omit", fill = NULL, ...)

## S3 method for class 'generic_spct'
na.exclude(object, na.action = "exclude", fill = NULL, target.colnames, ...)

## S3 method for class 'source_spct'
na.exclude(object, na.action = "exclude", fill = NULL, ...)

## S3 method for class 'response_spct'
na.exclude(object, na.action = "exclude", fill = NULL, ...)

## S3 method for class 'filter_spct'
na.exclude(object, na.action = "exclude", fill = NULL, ...)

## S3 method for class 'reflector_spct'
na.exclude(object, na.action = "exclude", fill = NULL, ...)

## S3 method for class 'object_spct'
na.exclude(object, na.action = "exclude", fill = NULL, ...)

## S3 method for class 'solute_spct'
na.exclude(object, na.action = "exclude", fill = NULL, ...)

## S3 method for class 'cps_spct'
na.exclude(object, na.action = "exclude", fill = NULL, ...)

## S3 method for class 'raw_spct'
na.exclude(object, na.action = "exclude", fill = NULL, ...)

## S3 method for class 'chroma_spct'
na.exclude(object, na.action = "exclude", fill = NULL, ...)

## S3 method for class 'generic_mspct'
na.exclude(object, na.action = "exclude", fill = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.omit_+3A_object">object</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="na.omit_+3A_na.action">na.action</code></td>
<td>
<p>character One of &quot;omit&quot;, &quot;exclude&quot; or &quot;replace&quot;.</p>
</td></tr>
<tr><td><code id="na.omit_+3A_fill">fill</code></td>
<td>
<p>numeric Value used to replace NAs unless NULL, in which case
interpolation is attempted.</p>
</td></tr>
<tr><td><code id="na.omit_+3A_target.colnames">target.colnames</code></td>
<td>
<p>character Vector of names for the target columns
to operate upon, if present in <code>object</code>.</p>
</td></tr>
<tr><td><code id="na.omit_+3A_...">...</code></td>
<td>
<p>further arguments other special methods could require</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>na.omit</code> removes cases, the row numbers of the cases form
the <code>"na.action"</code> attribute of the result, of class <code>"omit"</code>.
</p>
<p><code>na.exclude</code> differs from <code>na.omit</code> only in the class of the
&quot;na.action&quot; attribute of the result, which is <code>"exclude"</code>.
</p>


<h3>Note</h3>

<p><code>na.fail</code> and <code>na.pass</code> do not require a specialisation
for spectral objects. R's definitions work as expected with no need to
override them. We do not define a method <code>na.replace</code>, just pass
<code>"replace"</code> as argument. The current implementation replaces by
interpolation only individual NAs which are flanked on both sides by
valid data. Runs of multiple NAs con only replaced by a constant value
passed through parameter <code>fill</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+na.fail">na.fail</a></code> and <code><a href="stats.html#topic+na.action">na.action</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_sun.spct &lt;- sun.spct
my_sun.spct[3, "s.e.irrad"] &lt;- NA
my_sun.spct[5, "s.q.irrad"] &lt;- NA

head(my_sun.spct)

# rows omitted
zo &lt;- na.omit(my_sun.spct)
head(zo)
na.action(zo)

# rows excluded
ze &lt;- na.exclude(my_sun.spct)
head(ze)
na.action(ze)

# data in both rows replaced
zr &lt;- na.omit(my_sun.spct, na.action = "replace")
head(zr)
na.action(zr)

</code></pre>

<hr>
<h2 id='net_irradiance'>Net radiation flux</h2><span id='topic+net_irradiance'></span>

<h3>Description</h3>

<p>Estimate net radiation balance expressed as a flux in W/m2. If
<code>lw.down.irradiance</code> is passed a value in W / m2 the difference is
computed directly and if not an approximate value is estimated, using
<code>R_rel = 0.75</code> which corresponds to clear sky, i.e., uncorrected for
cloudiness. This is the approach to estimation is that recommended by FAO for
hourly estimates while here we use it for instantaneous or mean flux rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_irradiance(
  temperature,
  sw.down.irradiance,
  lw.down.irradiance = NULL,
  sw.albedo = 0.23,
  lw.emissivity = 0.98,
  water.vp = 0,
  R_rel = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net_irradiance_+3A_temperature">temperature</code></td>
<td>
<p>numeric vector of air temperatures (C) at 2 m height.</p>
</td></tr>
<tr><td><code id="net_irradiance_+3A_sw.down.irradiance">sw.down.irradiance</code>, <code id="net_irradiance_+3A_lw.down.irradiance">lw.down.irradiance</code></td>
<td>
<p>numeric Down-welling short wave
and long wave radiation radiation (W/m2).</p>
</td></tr>
<tr><td><code id="net_irradiance_+3A_sw.albedo">sw.albedo</code></td>
<td>
<p>numeric Albedo as a fraction of one (/1).</p>
</td></tr>
<tr><td><code id="net_irradiance_+3A_lw.emissivity">lw.emissivity</code></td>
<td>
<p>numeric Emissivity of the surface (ground or vegetation)
for long wave radiation.</p>
</td></tr>
<tr><td><code id="net_irradiance_+3A_water.vp">water.vp</code></td>
<td>
<p>numeric vector of water vapour pressure in air (Pa), ignored
if <code>lw.down.irradiance</code> is available.</p>
</td></tr>
<tr><td><code id="net_irradiance_+3A_r_rel">R_rel</code></td>
<td>
<p>numeric The ratio of actual and clear sky short wave irradiance
(/1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of evapotranspiration estimates expressed as
W / m-2.
</p>


<h3>See Also</h3>

<p>Other Evapotranspiration and energy balance related functions.: 
<code><a href="#topic+ET_ref">ET_ref</a>()</code>
</p>

<hr>
<h2 id='normalization'>Normalization of an R object</h2><span id='topic+normalization'></span><span id='topic+normalization.default'></span><span id='topic+normalization.waveband'></span>

<h3>Description</h3>

<p>Normalization wavelength [<code class="reqn">nm</code>] of an R object, retrieved from the object's
attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalization(x)

## Default S3 method:
normalization(x)

## S3 method for class 'waveband'
normalization(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalization_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value of wavelength [<code class="reqn">nm</code>].
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>normalization(default)</code>: Default methods.
</p>
</li>
<li> <p><code>normalization(waveband)</code>: Normalization of a <code><a href="#topic+waveband">waveband</a></code> object.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other waveband attributes: 
<code><a href="#topic+is_effective">is_effective</a>()</code>,
<code><a href="#topic+labels">labels</a>()</code>
</p>

<hr>
<h2 id='normalize'>Normalize spectral data</h2><span id='topic+normalize'></span><span id='topic+normalise'></span><span id='topic+normalize.default'></span><span id='topic+normalize.source_spct'></span><span id='topic+normalize.response_spct'></span><span id='topic+normalize.filter_spct'></span><span id='topic+normalize.reflector_spct'></span><span id='topic+normalize.solute_spct'></span><span id='topic+normalize.raw_spct'></span><span id='topic+normalize.cps_spct'></span><span id='topic+normalize.generic_spct'></span><span id='topic+normalize.source_mspct'></span><span id='topic+normalize.response_mspct'></span><span id='topic+normalize.filter_mspct'></span><span id='topic+normalize.reflector_mspct'></span><span id='topic+normalize.raw_mspct'></span><span id='topic+normalize.cps_mspct'></span>

<h3>Description</h3>

<p>This method returns a spectral object of the same class as the one supplied
as argument but with the spectral data normalized to 1.0 at a specific
wavelength.  When the object contains multiple spectra, the normalisation is
applied to each spectrum individually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(x, ...)

normalise(x, ...)

## Default S3 method:
normalize(x, ...)

## S3 method for class 'source_spct'
normalize(
  x,
  ...,
  range = NULL,
  norm = "max",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  keep.scaling = FALSE,
  na.rm = FALSE
)

## S3 method for class 'response_spct'
normalize(
  x,
  ...,
  range = NULL,
  norm = "max",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  keep.scaling = FALSE,
  na.rm = FALSE
)

## S3 method for class 'filter_spct'
normalize(
  x,
  ...,
  range = NULL,
  norm = "max",
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  keep.scaling = FALSE,
  na.rm = FALSE
)

## S3 method for class 'reflector_spct'
normalize(
  x,
  ...,
  range = NULL,
  norm = "max",
  qty.out = NULL,
  keep.scaling = FALSE,
  na.rm = FALSE
)

## S3 method for class 'solute_spct'
normalize(
  x,
  ...,
  range = NULL,
  norm = "max",
  keep.scaling = FALSE,
  na.rm = FALSE
)

## S3 method for class 'raw_spct'
normalize(
  x,
  ...,
  range = NULL,
  norm = "max",
  keep.scaling = FALSE,
  na.rm = FALSE
)

## S3 method for class 'cps_spct'
normalize(
  x,
  ...,
  range = NULL,
  norm = "max",
  keep.scaling = FALSE,
  na.rm = FALSE
)

## S3 method for class 'generic_spct'
normalize(
  x,
  ...,
  range = NULL,
  norm = "max",
  col.names,
  keep.scaling = FALSE,
  na.rm = FALSE
)

## S3 method for class 'source_mspct'
normalize(
  x,
  ...,
  range = NULL,
  norm = "max",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  keep.scaling = FALSE,
  na.rm = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'response_mspct'
normalize(
  x,
  ...,
  range = NULL,
  norm = "max",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  keep.scaling = FALSE,
  na.rm = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'filter_mspct'
normalize(
  x,
  ...,
  range = NULL,
  norm = "max",
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  keep.scaling = FALSE,
  na.rm = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'reflector_mspct'
normalize(
  x,
  ...,
  range = x,
  norm = "max",
  qty.out = NULL,
  keep.scaling = FALSE,
  na.rm = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'raw_mspct'
normalize(
  x,
  ...,
  range = x,
  norm = "max",
  keep.scaling = FALSE,
  na.rm = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'cps_mspct'
normalize(
  x,
  ...,
  range = x,
  norm = "max",
  keep.scaling = FALSE,
  na.rm = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
<tr><td><code id="normalize_+3A_...">...</code></td>
<td>
<p>not used in current version</p>
</td></tr>
<tr><td><code id="normalize_+3A_range">range</code></td>
<td>
<p>An R object on which <code>range()</code> returns a numeric vector of
length 2 with the limits of a range of wavelengths in nm, with min and max
wavelengths (nm) used to set boundaries for search for normalization.</p>
</td></tr>
<tr><td><code id="normalize_+3A_norm">norm</code></td>
<td>
<p>numeric Normalization wavelength (nm) or character string &quot;max&quot;,
or &quot;min&quot; for normalization at the corresponding wavelength, &quot;update&quot; to
update the normalization after modifying units of expression, quantity
or range but respecting the previously used criterion, or &quot;skip&quot; to force
return of <code>x</code> unchanged.</p>
</td></tr>
<tr><td><code id="normalize_+3A_unit.out">unit.out</code></td>
<td>
<p>character Allowed values &quot;energy&quot;, and &quot;photon&quot;,
or its alias &quot;quantum&quot;</p>
</td></tr>
<tr><td><code id="normalize_+3A_keep.scaling">keep.scaling</code></td>
<td>
<p>logical or numeric Flag to indicate if any existing
scaling should be preserved or not. The default, <code>FALSE</code>, preserves
the behaviour of versions (&lt;= 0.10.9). If numeric, the spectrum is scaled
to this value before normalization and marked as not scaled.</p>
</td></tr>
<tr><td><code id="normalize_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be stripped
before calculating the summary (e.g. &quot;max&quot;) used for normalization.</p>
</td></tr>
<tr><td><code id="normalize_+3A_qty.out">qty.out</code></td>
<td>
<p>character string  Allowed values are &quot;transmittance&quot;, and
&quot;absorbance&quot; indicating on which quantity to apply the normalization.</p>
</td></tr>
<tr><td><code id="normalize_+3A_col.names">col.names</code></td>
<td>
<p>character vector containing the names of columns or
variables to which to apply the normalization.</p>
</td></tr>
<tr><td><code id="normalize_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="normalize_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default normalization is done based on the maximum of the
spectral data. It is possible to also do the normalization based on a
user-supplied wavelength expressed in nanometres or the minimum. An
existing normalization can be updated for a different unit of expression or
after a conversion to a related spectral quantity.
</p>
<p>By default the function is applied to the whole spectrum, but by passing a
range of wavelengths as input, the search, e.g., for the maximum, can be
limited to a range of wavelengths of interest instead of the whole
spectrum.
</p>
<p>In 'photobiology' (&gt;= 0.10.8) detailed information about the normalization
is stored in an attribute. In 'photobiology' (&gt;= 0.10.10)
applying a new normalization to an already normalized spectrum recomputes
the multiplier factors stored in the attributes whenever possible. This
ensures that the returned object is identical, except for possible
accumulated loss of precision due to floating-point arithmetic,
independently of the previous application of a different normalization.
</p>


<h3>Value</h3>

<p>A copy of the object passed as argument to <code>x</code> with the values
of the spectral quantity rescaled to 1 at the normalization wavelength. If
the normalization wavelength is not already present in <code>x</code>, it is
added by interpolation&mdash;i.e. the returned value may be one row longer than
<code>x</code>. Attributes <code>normalized</code> and <code>normalization</code> are set to
keep a log of the computations applied.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>normalize(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>normalize(source_spct)</code>: Normalize a <code>source_spct</code> object.
</p>
</li>
<li> <p><code>normalize(response_spct)</code>: Normalize a response spectrum.
</p>
</li>
<li> <p><code>normalize(filter_spct)</code>: Normalize a filter spectrum.
</p>
</li>
<li> <p><code>normalize(reflector_spct)</code>: Normalize a reflector spectrum.
</p>
</li>
<li> <p><code>normalize(solute_spct)</code>: Normalize a solute spectrum.
</p>
</li>
<li> <p><code>normalize(raw_spct)</code>: Normalize a raw spectrum.
</p>
</li>
<li> <p><code>normalize(cps_spct)</code>: Normalize a cps spectrum.
</p>
</li>
<li> <p><code>normalize(generic_spct)</code>: Normalize a raw spectrum.
</p>
</li>
<li> <p><code>normalize(source_mspct)</code>: Normalize the members of a source_mspct object.
</p>
</li>
<li> <p><code>normalize(response_mspct)</code>: Normalize the members of a response_mspct object.
</p>
</li>
<li> <p><code>normalize(filter_mspct)</code>: Normalize the members of a filter_mspct object.
</p>
</li>
<li> <p><code>normalize(reflector_mspct)</code>: Normalize the members of a reflector_mspct object.
</p>
</li>
<li> <p><code>normalize(raw_mspct)</code>: Normalize the members of a raw_mspct object.
</p>
</li>
<li> <p><code>normalize(cps_mspct)</code>: Normalize the members of a cps_mspct object.
</p>
</li></ul>


<h3>Note</h3>

<p>When the spectrum passed as argument to <code>x</code> had been previously
scaled, in 'photobiology' (&lt;= 0.10.9) the scaling attribute was always
removed and no normalization factors returned. In 'photobiology'
(&gt;= 0.10.10) scaling information can be preserved by passing
<code>keep.scaling = TRUE</code>.
</p>
<p>By default if <code>x</code> contains one or more <code>NA</code> values and the
normalization is based on a summary quantity, the returned spectrum will
contain only <code>NA</code> values. If <code>na.rm == TRUE</code> then the summary
quantity will be calculated after striping <code>NA</code> values, and only the
values that were <code>NA</code> in <code>x</code> will be <code>NA</code> values in the
returned spectrum.
</p>
<p>When a numeric value is passed as argument to keep.scaling, the scaling
uses <code>f = "total"</code> or <code>f = "mean"</code> depending on the class of
<code>x</code>. Prescaling is only occasionally needed.
</p>
<p>Method <code>normalize</code> is implemented for <code>solute_spct</code> objects but
as the spectral data stored in them are a description of an intensive
property of a substance, normalization is unlikely to useful. To represent
solutions of specific concentrations of solutes, <code>filter_spct</code> objects
should be used instead.
</p>
<p><code>normalise()</code> is a synonym for this <code>normalize()</code> method.
</p>


<h3>See Also</h3>

<p>Other rescaling functions: 
<code><a href="#topic+fscale">fscale</a>()</code>,
<code><a href="#topic+fshift">fshift</a>()</code>,
<code><a href="#topic+getNormalized">getNormalized</a>()</code>,
<code><a href="#topic+getScaled">getScaled</a>()</code>,
<code><a href="#topic+is_normalized">is_normalized</a>()</code>,
<code><a href="#topic+is_scaled">is_scaled</a>()</code>,
<code><a href="#topic+setNormalized">setNormalized</a>()</code>,
<code><a href="#topic+setScaled">setScaled</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
normalize(sun.spct)
normalise(sun.spct) # equivalent

normalize(sun.spct, norm = "max")
normalize(sun.spct, norm = 400)

</code></pre>

<hr>
<h2 id='normalize_range_arg'>Normalize a range argument into a true numeric range</h2><span id='topic+normalize_range_arg'></span>

<h3>Description</h3>

<p>Several functions in this package and the suite accept a range argument
with a flexible syntax. To ensure that all functions and methods behave
in the same way this code has been factored out into a separate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_range_arg(arg.range, wl.range, trim = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_range_arg_+3A_arg.range">arg.range</code></td>
<td>
<p>a numeric vector of length two, or any other object for
which function range() will return a range of wavelengths (nm).</p>
</td></tr>
<tr><td><code id="normalize_range_arg_+3A_wl.range">wl.range</code></td>
<td>
<p>a numeric vector of length two, or any other object for which
function range() will return a range of wavelengths (nm), missing values
are not allowed.</p>
</td></tr>
<tr><td><code id="normalize_range_arg_+3A_trim">trim</code></td>
<td>
<p>logical If TRUE the range returned is bound within
<code>wl.range</code> while if FALSE it can be broader.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>arg.range</code> argument can contain NAs which are replaced by
the value at the same position in <code>wl.range</code>. In addition
a NULL argument for <code>range</code> is converted into <code>wl.range</code>.
The <code>wl.range</code> is also the limit to which the returned value
is trimmed if <code>trim == TRUE</code>. The idea is that the value supplied as
<code>wl.range</code> is the wavelength range of the data.
</p>


<h3>Value</h3>

<p>a numeric vector of length two, guaranteed not to have missing
values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalize_range_arg(c(NA, 500), range(sun.spct))
normalize_range_arg(c(300, NA), range(sun.spct))
normalize_range_arg(c(100, 5000), range(sun.spct), FALSE)
normalize_range_arg(c(NA, NA), range(sun.spct))
normalize_range_arg(c(NA, NA), sun.spct)

</code></pre>

<hr>
<h2 id='normalized_diff_ind'>Calculate a normalized difference.</h2><span id='topic+normalized_diff_ind'></span><span id='topic+normalised_diff_ind'></span><span id='topic+NDxI'></span><span id='topic+normalized_diff_ind.default'></span><span id='topic+normalized_diff_ind.generic_spct'></span><span id='topic+normalized_diff_ind.generic_mspct'></span>

<h3>Description</h3>

<p>This method returns a normalized difference index value for an arbitrary
pair of wavebands. There are many such indexes in use, such as NDVI
(normalized difference vegetation index), NDWI (normalized difference water
index), NDMI (normalized difference moisture index), etc., the only
difference among then is in the wavebands used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalized_diff_ind(spct, w.band.plus, w.band.minus, f, ...)

normalised_diff_ind(spct, w.band.plus, w.band.minus, f, ...)

NDxI(spct, w.band.plus, w.band.minus, f, ...)

## Default S3 method:
normalized_diff_ind(spct, w.band.plus, w.band.minus, f, ...)

## S3 method for class 'generic_spct'
normalized_diff_ind(spct, w.band.plus, w.band.minus, f, ...)

## S3 method for class 'generic_mspct'
normalized_diff_ind(spct, w.band.plus, w.band.minus, f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalized_diff_ind_+3A_spct">spct</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="normalized_diff_ind_+3A_w.band.plus">w.band.plus</code>, <code id="normalized_diff_ind_+3A_w.band.minus">w.band.minus</code></td>
<td>
<p>waveband objects The wavebands determine the
regions of the spectrum used in the calculations.</p>
</td></tr>
<tr><td><code id="normalized_diff_ind_+3A_f">f</code></td>
<td>
<p>function used for integration taking spct as first argument and a
list of wavebands as second argument.</p>
</td></tr>
<tr><td><code id="normalized_diff_ind_+3A_...">...</code></td>
<td>
<p>additional arguments passed to f</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>f</code> is most frequently <code><a href="#topic+reflectance">reflectance</a></code>, but also
<code><a href="#topic+transmittance">transmittance</a></code>, or even <code><a href="#topic+absorbance">absorbance</a></code>,
<code><a href="#topic+response">response</a></code>, <code><a href="#topic+irradiance">irradiance</a></code> or a user-defined function
can be used if there is a good reason for it. In every case <code>spct</code>
should be of the class expected by <code>f</code>. When using two wavebands of
different widths do consider passing to <code>f</code> a suitable <code>quantity</code>
argument, for example to compare averages rather than integrals. Wavebands
can describe weighting functions if desired.
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{NDxI} = \frac{f(s, wb_\mathrm{plus}) - f(s, wb_\mathrm{minus})}{f(s, wb_\mathrm{plus}) + f(s, wb_\mathrm{minus})}</code>
</p>



<h3>Value</h3>

<p>A named numeric value for the index, or a tibble depending on whether
a spectrum or a collection of spectra is passed as first argument. If
the wavelength range of <code>spct</code> does not fully overlap with both
wavebands <code>NA</code> is silently returned.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>normalized_diff_ind(default)</code>: default
</p>
</li>
<li> <p><code>normalized_diff_ind(generic_spct)</code>: 
</p>
</li>
<li> <p><code>normalized_diff_ind(generic_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Some NDxI indexes are directly based on satellite instrument data, such
as those in the Landsat satellites. To simulate such indexes using spectral
reflectande as input, constructors of <code>waveband</code> definitions from package
'photobiologyWavebands' can be useful.
</p>
<p><code>normalised_diff_ind()</code> is a synonym for <code>normalized_diff_ind()</code>.
</p>
<p><code>NDxI()</code> is a shorthand for <code>normalized_diff_ind()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rfr_normdiff">Rfr_normdiff</a></code>
</p>

<hr>
<h2 id='oper_spectra'>Binary operation on two spectra, even if the wavelengths values differ</h2><span id='topic+oper_spectra'></span>

<h3>Description</h3>

<p>The wavelength vectors of the two spectra are merged, and the missing
spectral values are calculated by interpolation. After this, the two spectral
values at each wavelength are added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oper_spectra(
  w.length1,
  w.length2 = NULL,
  s.irrad1,
  s.irrad2,
  trim = "union",
  na.rm = FALSE,
  bin.oper = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oper_spectra_+3A_w.length1">w.length1</code></td>
<td>
<p>numeric vector of wavelength (nm)</p>
</td></tr>
<tr><td><code id="oper_spectra_+3A_w.length2">w.length2</code></td>
<td>
<p>numeric vector of wavelength (nm)</p>
</td></tr>
<tr><td><code id="oper_spectra_+3A_s.irrad1">s.irrad1</code></td>
<td>
<p>a numeric vector of spectral values</p>
</td></tr>
<tr><td><code id="oper_spectra_+3A_s.irrad2">s.irrad2</code></td>
<td>
<p>a numeric vector of spectral values</p>
</td></tr>
<tr><td><code id="oper_spectra_+3A_trim">trim</code></td>
<td>
<p>a character string with value &quot;union&quot; or &quot;intersection&quot;</p>
</td></tr>
<tr><td><code id="oper_spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value, if TRUE, not the default, NAs in the input are
replaced with zeros</p>
</td></tr>
<tr><td><code id="oper_spectra_+3A_bin.oper">bin.oper</code></td>
<td>
<p>a function defining a binary operator (for the usual math
operators enclose argument in backticks)</p>
</td></tr>
<tr><td><code id="oper_spectra_+3A_...">...</code></td>
<td>
<p>additional arguments (by name) passed to bin.oper</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If trim==&quot;union&quot; spectral values are calculated for the whole range
of wavelengths covered by at least one of the input spectra, and missing
values are set in each input spectrum to zero before addition. If
trim==&quot;intersection&quot; then the range of wavelengths covered by both input
spectra is returned, and the non-overlapping regions discarded. If
w.length2==NULL, it is assumed that both spectra are measured at the same
wavelengths, and a simple addition is used, ensuring fast calculation.
</p>


<h3>Value</h3>

<p>a dataframe with two numeric variables </p>
<table>
<tr><td><code>w.length</code></td>
<td>
<p>A numeric
vector with the wavelengths (nm) obtained by &quot;fusing&quot; w.length1 and
w.length2. w.length contains all the unique vales, sorted in ascending
order.</p>
</td></tr> <tr><td><code>s.irrad</code></td>
<td>
<p>A numeric vector with the sum of the two spectral
values at each wavelength.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(sun.data)
result.data &lt;-
    with(sun.data,
         oper_spectra(w.length, w.length, s.e.irrad, s.e.irrad, bin.oper=`+`))
head(result.data)
tail(result.data)
my_fun &lt;- function(e1, e2, k) {return((e1 + e2) / k)}
result.data &lt;-
    with(sun.data,
        oper_spectra(w.length, w.length, s.e.irrad, s.e.irrad, bin.oper=my_fun, k=2))
head(result.data)
tail(result.data)

</code></pre>

<hr>
<h2 id='peaks'>Peaks or local maxima</h2><span id='topic+peaks'></span><span id='topic+peaks.default'></span><span id='topic+peaks.numeric'></span><span id='topic+peaks.data.frame'></span><span id='topic+peaks.generic_spct'></span><span id='topic+peaks.source_spct'></span><span id='topic+peaks.response_spct'></span><span id='topic+peaks.filter_spct'></span><span id='topic+peaks.reflector_spct'></span><span id='topic+peaks.solute_spct'></span><span id='topic+peaks.cps_spct'></span><span id='topic+peaks.raw_spct'></span><span id='topic+peaks.generic_mspct'></span><span id='topic+peaks.source_mspct'></span><span id='topic+peaks.response_mspct'></span><span id='topic+peaks.filter_mspct'></span><span id='topic+peaks.reflector_mspct'></span><span id='topic+peaks.solute_mspct'></span><span id='topic+peaks.cps_mspct'></span><span id='topic+peaks.raw_mspct'></span>

<h3>Description</h3>

<p>Function that returns a subset of an R object with observations corresponding
to local maxima.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peaks(x, span, ignore_threshold, strict, na.rm, ...)

## Default S3 method:
peaks(x, span = NA, ignore_threshold = NA, strict = NA, na.rm = FALSE, ...)

## S3 method for class 'numeric'
peaks(x, span = 5, ignore_threshold = NA, strict = TRUE, na.rm = FALSE, ...)

## S3 method for class 'data.frame'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  x.var.name = NULL,
  y.var.name = NULL,
  var.name = y.var.name,
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'generic_spct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  var.name = NULL,
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'source_spct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'response_spct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'filter_spct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  filter.qty = getOption("photobiology.filter.qty", default = "transmittance"),
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'reflector_spct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'solute_spct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'cps_spct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  var.name = "cps",
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'raw_spct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  var.name = "counts",
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'generic_mspct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  var.name = NULL,
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'source_mspct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'response_mspct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'filter_mspct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  filter.qty = getOption("photobiology.filter.qty", default = "transmittance"),
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'reflector_mspct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'solute_mspct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'cps_mspct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  var.name = "cps",
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'raw_mspct'
peaks(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  var.name = "counts",
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peaks_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="peaks_+3A_span">span</code></td>
<td>
<p>integer A peak is defined as an element in a sequence which is
greater than all other elements within a window of width <code>span</code>
centered at that element. Use <code>NULL</code> for the global peak.</p>
</td></tr>
<tr><td><code id="peaks_+3A_ignore_threshold">ignore_threshold</code></td>
<td>
<p>numeric Value between 0.0 and 1.0 indicating the
relative size compared to tallest peak threshold below which peaks will be
ignored. Negative values set a threshold so that the tallest peaks are
ignored, instead of the shortest.</p>
</td></tr>
<tr><td><code id="peaks_+3A_strict">strict</code></td>
<td>
<p>logical If <code>TRUE</code>, an element must be strictly greater
than all other values in its window to be considered a peak.</p>
</td></tr>
<tr><td><code id="peaks_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be stripped
before searching for peaks.</p>
</td></tr>
<tr><td><code id="peaks_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="peaks_+3A_var.name">var.name</code>, <code id="peaks_+3A_x.var.name">x.var.name</code>, <code id="peaks_+3A_y.var.name">y.var.name</code></td>
<td>
<p>character Name of column where to look
for peaks.</p>
</td></tr>
<tr><td><code id="peaks_+3A_refine.wl">refine.wl</code></td>
<td>
<p>logical Flag indicating if peak location should be refined by
fitting a function.</p>
</td></tr>
<tr><td><code id="peaks_+3A_method">method</code></td>
<td>
<p>character String with the name of a method. Currently only
spline interpolation is implemented.</p>
</td></tr>
<tr><td><code id="peaks_+3A_unit.out">unit.out</code></td>
<td>
<p>character One of &quot;energy&quot; or &quot;photon&quot;</p>
</td></tr>
<tr><td><code id="peaks_+3A_filter.qty">filter.qty</code></td>
<td>
<p>character One of &quot;transmittance&quot; or &quot;absorbance&quot;</p>
</td></tr>
<tr><td><code id="peaks_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="peaks_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of <code>x</code> with rows corresponding to local maxima.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>peaks(default)</code>: Default returning always NA.
</p>
</li>
<li> <p><code>peaks(numeric)</code>: Default function usable on numeric vectors.
</p>
</li>
<li> <p><code>peaks(data.frame)</code>: Method for &quot;data.frame&quot; objects.
</p>
</li>
<li> <p><code>peaks(generic_spct)</code>: Method for &quot;generic_spct&quot; objects.
</p>
</li>
<li> <p><code>peaks(source_spct)</code>: Method for &quot;source_spct&quot; objects.
</p>
</li>
<li> <p><code>peaks(response_spct)</code>: Method for &quot;response_spct&quot; objects.
</p>
</li>
<li> <p><code>peaks(filter_spct)</code>: Method for &quot;filter_spct&quot; objects.
</p>
</li>
<li> <p><code>peaks(reflector_spct)</code>: Method for &quot;reflector_spct&quot; objects.
</p>
</li>
<li> <p><code>peaks(solute_spct)</code>: Method for &quot;solute_spct&quot; objects.
</p>
</li>
<li> <p><code>peaks(cps_spct)</code>: Method for &quot;cps_spct&quot; objects.
</p>
</li>
<li> <p><code>peaks(raw_spct)</code>: Method for &quot;raw_spct&quot; objects.
</p>
</li>
<li> <p><code>peaks(generic_mspct)</code>: Method for &quot;generic_mspct&quot; objects.
</p>
</li>
<li> <p><code>peaks(source_mspct)</code>: Method for &quot;source_mspct&quot; objects.
</p>
</li>
<li> <p><code>peaks(response_mspct)</code>: Method for &quot;cps_mspct&quot; objects.
</p>
</li>
<li> <p><code>peaks(filter_mspct)</code>: Method for &quot;filter_mspct&quot; objects.
</p>
</li>
<li> <p><code>peaks(reflector_mspct)</code>: Method for &quot;reflector_mspct&quot; objects.
</p>
</li>
<li> <p><code>peaks(solute_mspct)</code>: Method for &quot;solute_mspct&quot; objects.
</p>
</li>
<li> <p><code>peaks(cps_mspct)</code>: Method for &quot;cps_mspct&quot; objects.
</p>
</li>
<li> <p><code>peaks(raw_mspct)</code>: Method for &quot;raw_mspct&quot; objects.
</p>
</li></ul>


<h3>Note</h3>

<p>Thresholds for ignoring peaks are applied after peaks are searched for,
and negative threshold values can in some cases result in no peaks being
returned.
</p>


<h3>See Also</h3>

<p>Other peaks and valleys functions: 
<code><a href="#topic+find_peaks">find_peaks</a>()</code>,
<code><a href="#topic+find_spikes">find_spikes</a>()</code>,
<code><a href="#topic+get_peaks">get_peaks</a>()</code>,
<code><a href="#topic+replace_bad_pixs">replace_bad_pixs</a>()</code>,
<code><a href="#topic+spikes">spikes</a>()</code>,
<code><a href="#topic+valleys">valleys</a>()</code>,
<code><a href="#topic+wls_at_target">wls_at_target</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>peaks(sun.spct, span = 51)
peaks(sun.spct, span = NULL)
peaks(sun.spct, span = 51, refine.wl = TRUE)

peaks(sun.spct)

</code></pre>

<hr>
<h2 id='phenylalanine.spct'>Molar spectral attenuation coefficient of phenylalanine</h2><span id='topic+phenylalanine.spct'></span>

<h3>Description</h3>

<p>A dataset containing the wavelengths at a 0.25 nm interval and the
corresponding attenuation coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenylalanine.spct
</code></pre>


<h3>Format</h3>

<p>A <code>solute_spct</code> object with 1993 rows and 2 variables
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm), range 222 to 720 nm. </p>
</li>
<li><p> K.mole
(cm-1/M)</p>
</li></ul>



<h3>Author(s)</h3>

<p>Du et ql. (original data); Scott Prahl (included data).
</p>


<h3>References</h3>

<p><a href="https://omlc.org/spectra/PhotochemCAD/html/073.html">https://omlc.org/spectra/PhotochemCAD/html/073.html</a>
</p>
<p>H. Du, R. A. Fuh, J. Li, A. Corkan, J. S. Lindsey, &quot;PhotochemCAD: A
computer-aided design and research tool in photochemistry,&quot; Photochem.
Photobiol., 68, 141-142, 1998.
</p>
<p>J. M. Dixon, M. Taniguchi and J. S. Lindsey &quot;PhotochemCAD 2. A refined
program with accompanying spectral databases for photochemical calculations&quot;,
Photochem. Photobiol., 81, 212-213, 2005.
</p>


<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(phenylalanine.spct)
summary(phenylalanine.spct)
solute_properties(phenylalanine.spct)
cat(comment(phenylalanine.spct))

</code></pre>

<hr>
<h2 id='photobiology-package'>photobiology: Photobiological Calculations</h2><span id='topic+photobiology'></span><span id='topic+photobiology-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Definitions of classes, methods, operators and functions for use in photobiology and radiation meteorology and climatology. Calculation of effective (weighted) and not-weighted irradiances/doses, fluence rates, transmittance, reflectance, absorptance, absorbance and diverse ratios and other derived quantities from spectral data. Local maxima and minima: peaks, valleys and spikes. Conversion between energy-and photon-based units. Wavelength interpolation. Astronomical calculations related solar angles and day length. Colours and vision. This package is part of the 'r4photobiology' suite, Aphalo, P. J. (2015) <a href="https://doi.org/10.19232/uv4pb.2015.1.14">doi:10.19232/uv4pb.2015.1.14</a>.
</p>


<h3>Details</h3>

<p>Package &lsquo;photobiology&rsquo; is at the core of a suite of R packages
supporting computations and plotting relevant to photobiology (described at
<a href="https://www.r4photobiology.info/">https://www.r4photobiology.info/</a>). Package 'photobiology' has its
main focus in the characterization of the light environment, the
description of optical properties of objects and substances and description
of light responses of organisms and devices used to measure light. The
facilities for spectral data storage and manipulations are widely useful in
photobiology, chemistry, geophysics, radiation climatology and remote
sensing. Astronomical computations for the sun are also implemented. The
design of object classes for spectral data supports reproducibility by
facilitating the consistent use of units and physical quantities and
consistent embedding of metadata. Data are expressed throughout using SI
base units, except for wavelengths which are consistently expressed in
nanometres [<code class="reqn">nm</code>]. Please see the vignette <em>0: The R for
Photobiology Suite</em> for a description of the suite.
</p>


<h3>Acknowledgements</h3>

<p>This work was funded by the Academy of Finland
(decision 252548). COST Action FA9604 &lsquo;UV4Growth&rsquo; facilitated discussions
and exchanges of ideas that lead to the development of this package. The
contributions of Andy McLeod, Lars Olof Bjrn, Nigel Paul, Lasse Ylianttila,
T. Matthew Robson and Titta Kotilainen were specially significant.
Tutorials by Hadley Wickham and comments on my presentation at UseR!2015
allowed me to significantly improve the coding and functionality.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pedro J. Aphalo <a href="mailto:pedro.aphalo@helsinki.fi">pedro.aphalo@helsinki.fi</a> (<a href="https://orcid.org/0000-0003-3385-972X">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Titta K. Kotilainen (<a href="https://orcid.org/0000-0002-2822-9734">ORCID</a>) [contributor]
</p>
</li>
<li><p> Glenn Davis <a href="mailto:gdavis@gluonics.com">gdavis@gluonics.com</a> [contributor]
</p>
</li>
<li><p> Agnese Fazio <a href="mailto:agnese.fazio@uni-jena.de">agnese.fazio@uni-jena.de</a> [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Aphalo, P. J., Albert, A., Bjrn, L. O., McLeod, A. R., Robson, T. M.,
Rosenqvist, E. (Eds.). (2012). <em>Beyond the Visible: A handbook of best
practice in plant UV photobiology</em> (1st ed., p. xx + 174). Helsinki:
University of Helsinki, Department of Biosciences, Division of Plant Biology.
ISBN 978-952-10-8363-1 (PDF), 978-952-10-8362-4 (paperback). Open access PDF
download available at <a href="https://doi.org/10.31885/9789521083631">doi:10.31885/9789521083631</a>.
</p>
<p>Aphalo, Pedro J. (2015) The r4photobiology suite. <em>UV4Plants Bulletin</em>, 2015:1,
21-29. <a href="https://doi.org/10.19232/uv4pb.2015.1.14">doi:10.19232/uv4pb.2015.1.14</a>.
</p>
<p>Maia, R., Eliason, C. M., Bitton, P. P., Doucet, S. M., Shawkey, M. D. (2013)
pavo: an R package for the analysis, visualization and organization of
spectral data. <em>Methods in Ecology and Evolution</em>, 4(10):906-913.
<a href="https://doi.org/10.1111/2041-210X.12069">doi:10.1111/2041-210X.12069</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://docs.r4photobiology.info/photobiology/">https://docs.r4photobiology.info/photobiology/</a>
</p>
</li>
<li> <p><a href="https://github.com/aphalo/photobiology">https://github.com/aphalo/photobiology</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/aphalo/photobiology/issues">https://github.com/aphalo/photobiology/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># irradiance of the whole spectrum
irrad(sun.spct)
# photon irradiance 400 nm to 700 nm
q_irrad(sun.spct, waveband(c(400,700)))
# energy irradiance 400 nm to 700 nm
e_irrad(sun.spct, waveband(c(400,700)))
# simulating the effect of a filter on solar irradiance
e_irrad(sun.spct * yellow_gel.spct, waveband(c(400,500)))
e_irrad(sun.spct * yellow_gel.spct, waveband(c(500,700)))
# daylength
sunrise_time(lubridate::today(tzone = "EET"), tz = "EET",
             geocode = data.frame(lat = 60, lon = 25),
             unit.out = "hour")
day_length(lubridate::today(tzone = "EET"), tz = "EET",
           geocode = data.frame(lat = 60, lon = 25),
           unit.out = "hour")
# colour as seen by humans
color_of(sun.spct)
color_of(sun.spct * yellow_gel.spct)
# filter transmittance
transmittance(yellow_gel.spct)
transmittance(yellow_gel.spct, waveband(c(400,500)))
transmittance(yellow_gel.spct, waveband(c(500,700)))
</code></pre>

<hr>
<h2 id='photodiode.spct'>Spectral response of a GaAsP photodiode</h2><span id='topic+photodiode.spct'></span>

<h3>Description</h3>

<p>A dataset containing wavelengths at a 1 nm interval and
spectral response as <code class="reqn">A / (W / nm)</code> for GaAsP photodiode type
G6262 from Hamamatsu. Data digitized from manufacturer's data sheet.
The value at the peak is 0.19 <code class="reqn">A / W</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>photodiode.spct
</code></pre>


<h3>Format</h3>

<p>A <code>response_spct</code> object with 94 rows and 2 variables
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm). </p>
</li>
<li><p> s.e.response
(A/W)  </p>
</li></ul>



<h3>References</h3>

<p>Hamamatsu (2011) Datasheet: GaAsP Photodiodes G5645 G5842 G6262. Hamamatsu
Photonics KK, Hamamatsu, City.
http://www.hamamatsu.com/jp/en/G6262.html.
Visited 2017-12-15.
</p>


<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>photodiode.spct

</code></pre>

<hr>
<h2 id='photon_irradiance'>Photon irradiance</h2><span id='topic+photon_irradiance'></span>

<h3>Description</h3>

<p>This function returns the photon irradiance for a given waveband of a
radiation spectrum, optionally applies a BSWF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>photon_irradiance(
  w.length,
  s.irrad,
  w.band = NULL,
  unit.in = "energy",
  check.spectrum = TRUE,
  use.cached.mult = FALSE,
  use.hinges = getOption("photobiology.use.hinges", default = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="photon_irradiance_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelength [<code class="reqn">nm</code>].</p>
</td></tr>
<tr><td><code id="photon_irradiance_+3A_s.irrad">s.irrad</code></td>
<td>
<p>numeric vector of spectral irradiances in
[<code class="reqn">W\,m^{-2}\,nm^{-1}</code>] or
[<code class="reqn">mol\,s^{-1}\,sm^{-2}\,nm^{-1}</code>] as indicated by the
argument pased to <code>unit.in</code>.</p>
</td></tr>
<tr><td><code id="photon_irradiance_+3A_w.band">w.band</code></td>
<td>
<p>waveband.</p>
</td></tr>
<tr><td><code id="photon_irradiance_+3A_unit.in">unit.in</code></td>
<td>
<p>character Allowed values <code>"energy"</code>, and <code>"photon"</code>,
or its alias <code>"quantum"</code>.</p>
</td></tr>
<tr><td><code id="photon_irradiance_+3A_check.spectrum">check.spectrum</code></td>
<td>
<p>logical Flag telling whether to sanity check input
data, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="photon_irradiance_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag telling whether multiplier values should
be cached between calls.</p>
</td></tr>
<tr><td><code id="photon_irradiance_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value with no change in scale factor:
[<code class="reqn">mol\,s^{-1}\,sm^{-2}</code>].
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data, photon_irradiance(w.length, s.e.irrad))
with(sun.data, photon_irradiance(w.length, s.e.irrad, new_waveband(400,700)))

</code></pre>

<hr>
<h2 id='photon_ratio'>Photo:photon ratio</h2><span id='topic+photon_ratio'></span>

<h3>Description</h3>

<p>This function gives the photon ratio between two given wavebands of a
radiation spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>photon_ratio(
  w.length,
  s.irrad,
  w.band.num = NULL,
  w.band.denom = NULL,
  unit.in = "energy",
  check.spectrum = TRUE,
  use.cached.mult = FALSE,
  use.hinges = getOption("photobiology.use.hinges", default = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="photon_ratio_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelength (nm).</p>
</td></tr>
<tr><td><code id="photon_ratio_+3A_s.irrad">s.irrad</code></td>
<td>
<p>numeric vector of spectral irradiances in
[<code class="reqn">W\,m^{-2}\,nm^{-1}</code>] or
[<code class="reqn">mol\,s^{-1}\,sm^{-2}\,nm^{-1}</code>] as indicated by the
argument pased to <code>unit.in</code>.</p>
</td></tr>
<tr><td><code id="photon_ratio_+3A_w.band.num">w.band.num</code></td>
<td>
<p>waveband object used to compute the numerator of the ratio.</p>
</td></tr>
<tr><td><code id="photon_ratio_+3A_w.band.denom">w.band.denom</code></td>
<td>
<p>waveband object used to compute the denominator of the ratio.</p>
</td></tr>
<tr><td><code id="photon_ratio_+3A_unit.in">unit.in</code></td>
<td>
<p>character Allowed values <code>"energy"</code>, and <code>"photon"</code>,
or its alias <code>"quantum"</code>.</p>
</td></tr>
<tr><td><code id="photon_ratio_+3A_check.spectrum">check.spectrum</code></td>
<td>
<p>logical Flag telling whether to sanity check input data,
default is TRUE.</p>
</td></tr>
<tr><td><code id="photon_ratio_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag telling whether multiplier values should be
cached between calls.</p>
</td></tr>
<tr><td><code id="photon_ratio_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value giving the unitless ratio.
</p>


<h3>Note</h3>

<p>The default for both <code>w.band</code> parameters is a waveband covering
the whole range of <code>w.length</code>.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data,
     photon_ratio(w.length, s.e.irrad, new_waveband(400,500), new_waveband(400,700)))

</code></pre>

<hr>
<h2 id='photons_energy_ratio'>Photon:energy ratio</h2><span id='topic+photons_energy_ratio'></span>

<h3>Description</h3>

<p>This function gives the photons:energy ratio between for one given waveband
of a radiation spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>photons_energy_ratio(
  w.length,
  s.irrad,
  w.band = NULL,
  unit.in = "energy",
  check.spectrum = TRUE,
  use.cached.mult = FALSE,
  use.hinges = getOption("photobiology.use.hinges", default = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="photons_energy_ratio_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelength (nm).</p>
</td></tr>
<tr><td><code id="photons_energy_ratio_+3A_s.irrad">s.irrad</code></td>
<td>
<p>numeric vector of spectral irradiances in
[<code class="reqn">W\,m^{-2}\,nm^{-1}</code>] or
[<code class="reqn">mol\,s^{-1}\,sm^{-2}\,nm^{-1}</code>] as indicated by the
argument pased to <code>unit.in</code>.</p>
</td></tr>
<tr><td><code id="photons_energy_ratio_+3A_w.band">w.band</code></td>
<td>
<p>waveband object.</p>
</td></tr>
<tr><td><code id="photons_energy_ratio_+3A_unit.in">unit.in</code></td>
<td>
<p>character Allowed values <code>"energy"</code>, and <code>"photon"</code>,
or its alias <code>"quantum"</code>.</p>
</td></tr>
<tr><td><code id="photons_energy_ratio_+3A_check.spectrum">check.spectrum</code></td>
<td>
<p>logical Flag telling whether to sanity check input
data, default is TRUE.</p>
</td></tr>
<tr><td><code id="photons_energy_ratio_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag telling whether multiplier values should
be cached between calls.</p>
</td></tr>
<tr><td><code id="photons_energy_ratio_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value giving the ratio moles-photons per Joule.
</p>


<h3>Note</h3>

<p>The default for the <code>w.band</code> parameter is a waveband covering
the whole range of <code>w.length</code>.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># photons:energy ratio
with(sun.data, photons_energy_ratio(w.length, s.e.irrad, new_waveband(400,500)))
# photons:energy ratio for whole spectrum
with(sun.data, photons_energy_ratio(w.length, s.e.irrad))

</code></pre>

<hr>
<h2 id='plus-.generic_spct'>Arithmetic Operators</h2><span id='topic+plus-.generic_spct'></span><span id='topic++2B.generic_spct'></span>

<h3>Description</h3>

<p>Division operator for generic spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
e1 + e2 = NULL
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plus-.generic_spct_+3A_e1">e1</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
<tr><td><code id="plus-.generic_spct_+3A_e2">e2</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other math operators and functions: 
<code><a href="#topic+MathFun">MathFun</a></code>,
<code><a href="#topic++5E.generic_spct">^.generic_spct</a>()</code>,
<code><a href="#topic+convolve_each">convolve_each</a>()</code>,
<code><a href="#topic+div-.generic_spct">div-.generic_spct</a></code>,
<code><a href="#topic+log">log</a>()</code>,
<code><a href="#topic+minus-.generic_spct">minus-.generic_spct</a></code>,
<code><a href="#topic+mod-.generic_spct">mod-.generic_spct</a></code>,
<code><a href="#topic+round">round</a>()</code>,
<code><a href="#topic+sign">sign</a>()</code>,
<code><a href="#topic+slash-.generic_spct">slash-.generic_spct</a></code>,
<code><a href="#topic+times-.generic_spct">times-.generic_spct</a></code>
</p>

<hr>
<h2 id='print'>Print spectral collection summary</h2><span id='topic+print'></span><span id='topic+print.summary_generic_mspct'></span><span id='topic+print.generic_spct'></span><span id='topic+print.generic_mspct'></span>

<h3>Description</h3>

<p>A function to nicely print objects of classes &quot;summary...mspct&quot;.
</p>
<p>Print method for objects of spectral classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_generic_mspct'
print(x, width = NULL, ..., n = NULL)

## S3 method for class 'generic_spct'
print(x, ..., n = NULL, width = NULL)

## S3 method for class 'generic_mspct'
print(x, ..., n = NULL, width = NULL, n.members = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>An object of one of the summary classes for spectra</p>
</td></tr>
<tr><td><code id="print_+3A_width">width</code></td>
<td>
<p>Width of text output to generate. This defaults to NULL, which
means use getOption(&quot;width&quot;) and only display the columns that fit on one
screen. You can also set option(dplyr.width = Inf) to override this default
and always print all columns.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>not used in current version</p>
</td></tr>
<tr><td><code id="print_+3A_n">n</code></td>
<td>
<p>Number of rows to show. If NULL, the default, will print all rows if
less than option dplyr.print_max. Otherwise, will print dplyr.print_min</p>
</td></tr>
<tr><td><code id="print_+3A_n.members">n.members</code></td>
<td>
<p>numeric Number of members of the collection to print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>print(generic_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>This is simply a wrapper on the print method for tibbles, with
additional information in the header. Curently, <code>width</code> applies only
to the table of data.
</p>


<h3>See Also</h3>

<p><code><a href="tibble.html#topic+formatting">formatting</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(summary(sun.spct))


print(sun.spct)
print(sun.spct, n = 5)

</code></pre>

<hr>
<h2 id='print.solar_time'>Print solar time and solar date objects</h2><span id='topic+print.solar_time'></span><span id='topic+print.solar_date'></span>

<h3>Description</h3>

<p>Print solar time and solar date objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'solar_time'
print(x, ...)

## S3 method for class 'solar_date'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.solar_time_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="print.solar_time_+3A_...">...</code></td>
<td>
<p>passed to <code>format</code> method</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Default is to print the underlying POSIXct as a solar time.
</p>


<h3>See Also</h3>

<p>Other Local solar time functions: 
<code><a href="#topic+as.solar_date">as.solar_date</a>()</code>,
<code><a href="#topic+is.solar_time">is.solar_time</a>()</code>,
<code><a href="#topic+solar_time">solar_time</a>()</code>
</p>

<hr>
<h2 id='print.summary_generic_spct'>Print spectral summary</h2><span id='topic+print.summary_generic_spct'></span>

<h3>Description</h3>

<p>A function to nicely print objects of classes &quot;summary...spct&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_generic_spct'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary_generic_spct_+3A_x">x</code></td>
<td>
<p>An object of one of the summary classes for spectra</p>
</td></tr>
<tr><td><code id="print.summary_generic_spct_+3A_...">...</code></td>
<td>
<p>not used in current version</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>print(summary(sun.spct))

</code></pre>

<hr>
<h2 id='print.tod_time'>Print time-of-day objects</h2><span id='topic+print.tod_time'></span>

<h3>Description</h3>

<p>Print time-of-day objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tod_time'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tod_time_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="print.tod_time_+3A_...">...</code></td>
<td>
<p>passed to <code>format</code> method</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Default is to print the underlying <code>numeric</code> vector as a solar time.
</p>


<h3>See Also</h3>

<p>Other Time of day functions: 
<code><a href="#topic+as_tod">as_tod</a>()</code>,
<code><a href="#topic+format.tod_time">format.tod_time</a>()</code>
</p>

<hr>
<h2 id='print.waveband'>Print a &quot;waveband&quot; object</h2><span id='topic+print.waveband'></span>

<h3>Description</h3>

<p>A function to more nicely print objects of class &quot;waveband&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'waveband'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.waveband_+3A_x">x</code></td>
<td>
<p>an object of class &quot;waveband&quot;</p>
</td></tr>
<tr><td><code id="print.waveband_+3A_...">...</code></td>
<td>
<p>not used in current version</p>
</td></tr>
</table>

<hr>
<h2 id='prod_spectra'>Multiply two spectra, even if the wavelengths values differ</h2><span id='topic+prod_spectra'></span>

<h3>Description</h3>

<p>The wavelength vectors of the two spectra are merged, and the missing
spectral values are calculated by interpolation. After this, the two spectral
values at each wavelength are added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prod_spectra(
  w.length1,
  w.length2 = NULL,
  s.irrad1,
  s.irrad2,
  trim = "union",
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prod_spectra_+3A_w.length1">w.length1</code></td>
<td>
<p>numeric vector of wavelength (nm).</p>
</td></tr>
<tr><td><code id="prod_spectra_+3A_w.length2">w.length2</code></td>
<td>
<p>numeric vector of wavelength (nm).</p>
</td></tr>
<tr><td><code id="prod_spectra_+3A_s.irrad1">s.irrad1</code></td>
<td>
<p>a numeric vector of spectral values.</p>
</td></tr>
<tr><td><code id="prod_spectra_+3A_s.irrad2">s.irrad2</code></td>
<td>
<p>a numeric vector of spectral values.</p>
</td></tr>
<tr><td><code id="prod_spectra_+3A_trim">trim</code></td>
<td>
<p>a character string with value &quot;union&quot; or &quot;intersection&quot;.</p>
</td></tr>
<tr><td><code id="prod_spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value, if TRUE, not the default, NAs in the input are
replaced with zeros.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If trim==&quot;union&quot; spectral values are calculated for the whole range
of wavelengths covered by at least one of the input spectra, and missing
values are set in each input spectrum to zero before addition. If
trim==&quot;intersection&quot; then the range of wavelengths covered by both input
spectra is returned, and the non-overlapping regions discarded. If
w.length2==NULL, it is assumed that both spectra are measured at the same
wavelengths, and a simple addition is used, ensuring fast calculation.
</p>


<h3>Value</h3>

<p>a dataframe with two numeric variables </p>
<table>
<tr><td><code>w.length</code></td>
<td>
<p>A numeric
vector with the wavelengths (nm) obtained by &quot;fusing&quot; w.length1 and
w.length2. w.length contains all the unique vales, sorted in ascending
order.</p>
</td></tr> <tr><td><code>s.irrad</code></td>
<td>
<p>A numeric vector with the sum of the two spectral
values at each wavelength.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(sun.data)
square.sun.data &lt;-
  with(sun.data, prod_spectra(w.length, w.length, s.e.irrad, s.e.irrad))
head(square.sun.data)
tail(square.sun.data)

</code></pre>

<hr>
<h2 id='pull_sample'>Random sample of spectra</h2><span id='topic+pull_sample'></span><span id='topic+pull_sample.default'></span><span id='topic+pull_sample.list'></span><span id='topic+pull_sample.generic_spct'></span><span id='topic+pull_sample.generic_mspct'></span>

<h3>Description</h3>

<p>A method to extract a random sample of members from a list, a collection of
spectra or a spectrum object containing multiple spectra in long form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_sample(x, size, ...)

## Default S3 method:
pull_sample(x, size, ...)

## S3 method for class 'list'
pull_sample(
  x,
  size = 1,
  replace = FALSE,
  keep.order = TRUE,
  simplify = FALSE,
  ...
)

## S3 method for class 'generic_spct'
pull_sample(x, size = 1, replace = FALSE, keep.order = TRUE, ...)

## S3 method for class 'generic_mspct'
pull_sample(
  x,
  size = 1,
  replace = FALSE,
  recursive = FALSE,
  keep.order = TRUE,
  simplify = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_sample_+3A_x">x</code></td>
<td>
<p>An R object possibly containing multiple spectra or other
components.</p>
</td></tr>
<tr><td><code id="pull_sample_+3A_size">size</code></td>
<td>
<p>integer The number of spectra to extract, if available.</p>
</td></tr>
<tr><td><code id="pull_sample_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
<tr><td><code id="pull_sample_+3A_replace">replace</code></td>
<td>
<p>logical Sample with or without replacement.</p>
</td></tr>
<tr><td><code id="pull_sample_+3A_keep.order">keep.order</code></td>
<td>
<p>logical Return the spectra ordered as in <code>x</code> or in
random order.</p>
</td></tr>
<tr><td><code id="pull_sample_+3A_simplify">simplify</code></td>
<td>
<p>logical If <code>size = 1</code>, and <code>x</code> is a collection
return the spectrum object instead of a collection with it as only member.</p>
</td></tr>
<tr><td><code id="pull_sample_+3A_recursive">recursive</code></td>
<td>
<p>logical If <code>x</code> is a collection, expand or not member
spectra containing multiple spectra in long form into individual members
before sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is an spectrum object, such as a
<code>"filter_spct"</code> object, the returned object is of the same class but
in most cases containing fewer spectra in long form than <code>x</code>.
If <code>x</code> is a collection of spectrum objecta, such as a
<code>"filter_mspct"</code> object, the returned object is of the same class but
in most cases containing fewer member spectra than <code>x</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>pull_sample(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>pull_sample(list)</code>: Specialization for generic_spct
</p>
</li>
<li> <p><code>pull_sample(generic_spct)</code>: Specialization for generic_spct
</p>
</li>
<li> <p><code>pull_sample(generic_mspct)</code>: Specialization for generic_mspct
</p>
</li></ul>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+sample">sample</a></code> for the method used for
the sampling.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a.list &lt;- as.list(letters)
names(a.list) &lt;- LETTERS
set.seed(12345678)
pull_sample(a.list, size = 8)
pull_sample(a.list, size = 8, keep.order = FALSE)
pull_sample(a.list, size = 8, replace = TRUE)
pull_sample(a.list, size = 8, replace = TRUE, keep.order = FALSE)
pull_sample(a.list, size = 1)
pull_sample(a.list, size = 1, simplify = TRUE)

</code></pre>

<hr>
<h2 id='q_fluence'>Photon fluence</h2><span id='topic+q_fluence'></span><span id='topic+q_fluence.default'></span><span id='topic+q_fluence.source_spct'></span><span id='topic+q_fluence.source_mspct'></span>

<h3>Description</h3>

<p>Photon irradiance (i.e. quantum irradiance) for one or more waveband of a
light source spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q_fluence(
  spct,
  w.band,
  exposure.time,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## Default S3 method:
q_fluence(
  spct,
  w.band,
  exposure.time,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## S3 method for class 'source_spct'
q_fluence(
  spct,
  w.band = NULL,
  exposure.time,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = FALSE,
  naming = "default",
  ...
)

## S3 method for class 'source_mspct'
q_fluence(
  spct,
  w.band = NULL,
  exposure.time,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = FALSE,
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q_fluence_+3A_spct">spct</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_w.band">w.band</code></td>
<td>
<p>a list of <code>waveband</code> objects or a <code>waveband</code> object</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_exposure.time">exposure.time</code></td>
<td>
<p>lubridate::duration object.</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded.</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls.</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_allow.scaled">allow.scaled</code></td>
<td>
<p>logical indicating whether scaled or normalized spectra
as argument to spct are flagged as an error.</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored).</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="q_fluence_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One numeric value for each waveband with no change in scale factor,
with name attribute set to the name of each waveband unless a named list is
supplied in which case the names of the list elements are used. The
exposure.time is copied from the spectrum object to the output as an attribute.
Units are as follows: moles of photons per exposure.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>q_fluence(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>q_fluence(source_spct)</code>: Calculate photon fluence from a <code>source_spct</code>
object and the duration of the exposure
</p>
</li>
<li> <p><code>q_fluence(source_mspct)</code>: Calculates photon (quantum) fluence from a
<code>source_mspct</code> object.
</p>
</li></ul>


<h3>Note</h3>

<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult=TRUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>See Also</h3>

<p>Other irradiance functions: 
<code><a href="#topic+e_fluence">e_fluence</a>()</code>,
<code><a href="#topic+e_irrad">e_irrad</a>()</code>,
<code><a href="#topic+fluence">fluence</a>()</code>,
<code><a href="#topic+irrad">irrad</a>()</code>,
<code><a href="#topic+q_irrad">q_irrad</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
q_fluence(sun.spct,
          w.band = waveband(c(400,700)),
          exposure.time = lubridate::duration(3, "minutes") )

</code></pre>

<hr>
<h2 id='q_fraction'>Photon:photon fraction</h2><span id='topic+q_fraction'></span><span id='topic+q_fraction.default'></span><span id='topic+q_fraction.source_spct'></span><span id='topic+q_fraction.source_mspct'></span>

<h3>Description</h3>

<p>This function returns the photon fraction for a given pair of wavebands of a
light source spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q_fraction(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## Default S3 method:
q_fraction(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## S3 method for class 'source_spct'
q_fraction(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "total",
  naming = "short",
  name.tag = NULL,
  ...
)

## S3 method for class 'source_mspct'
q_fraction(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "total",
  naming = "short",
  name.tag = ifelse(naming != "none", "[q:q]", ""),
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q_fraction_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;source_spct&quot;.</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_w.band.num">w.band.num</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the numerator(s) and denominator(s) of the fraction(s).</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_w.band.denom">w.band.denom</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the denominator(s) of the fraction(s).</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_quantity">quantity</code></td>
<td>
<p>character One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_name.tag">name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="q_fraction_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default <code>quantity = "total"</code> the fraction is based on
two <strong>photon irradiances</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{Q(s, wb_\mathrm{num})}{Q(s, wb_\mathrm{denom}) + Q(s, wb_\mathrm{num})}</code>
</p>

<p>If the argument is set to <code>quantity = "mean"</code> or
<code>quantity = "average"</code> the ratio is based on
two <strong>mean spectral photon irradiances</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\overline{Q_\lambda}(s, wb_\mathrm{num})}{\overline{Q_\lambda}(s, wb_\mathrm{denom}) + \overline{Q_\lambda}(s, wb_\mathrm{num})}</code>
</p>

<p>Only if the wavelength expanse of the two wavebands is the same, these two
ratios are numerically identical.
</p>


<h3>Value</h3>

<p>In the case of methods for individual spectra, a <code>numeric</code>
vector with name attribute set. The name is based on the name of the
wavebands unless a named list of wavebands is supplied in which case the
names of the list elements are used. &quot;[q:q]&quot; is appended if <code>quantity
  = "total"</code> and &quot;[q(wl):q(wl)]&quot; if <code>quantity = "mean"</code> or
<code>quantity = "average"</code>.
</p>
<p>A <code>data.frame</code> is returned in the case of collections of spectra,
containing one column for each fraction definition, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>Fraction definitions are &quot;assembled&quot; from the arguments passed to
<code>w.band.num</code> and <code>w.band.denom</code>. If both arguments are lists of
waveband definitions, with an equal number of members, then the wavebands
are paired to obtain as many fractions as the number of wavebands in each
list. Recycling for wavebands takes place when the number of denominator
and numerator wavebands differ.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>q_fraction(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>q_fraction(source_spct)</code>: Method for <code>source_spct</code> objects
</p>
</li>
<li> <p><code>q_fraction(source_mspct)</code>: Calculates photon:photon from a <code>source_mspct</code>
object.
</p>
</li></ul>


<h3>Note</h3>

<p>The last two parameters control speed
optimizations. The defaults should be suitable in most cases. If you will
use repeatedly the same SWFs on many spectra measured at exactly the same
wavelengths you may obtain some speed up by setting
<code>use.cached.mult=TRUE</code>. However, be aware that you are responsible for
ensuring that the wavelengths are the same in each call, as the only test
done is for the length of the <code>w.length</code> vector.
</p>


<h3>See Also</h3>

<p>Other photon and energy ratio functions: 
<code><a href="#topic+e_fraction">e_fraction</a>()</code>,
<code><a href="#topic+e_ratio">e_ratio</a>()</code>,
<code><a href="#topic+eq_ratio">eq_ratio</a>()</code>,
<code><a href="#topic+q_ratio">q_ratio</a>()</code>,
<code><a href="#topic+qe_ratio">qe_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q_fraction(sun.spct, new_waveband(400,500), new_waveband(400,700))

</code></pre>

<hr>
<h2 id='q_irrad'>Photon irradiance</h2><span id='topic+q_irrad'></span><span id='topic+q_irrad.default'></span><span id='topic+q_irrad.source_spct'></span><span id='topic+q_irrad.source_mspct'></span>

<h3>Description</h3>

<p>Photon irradiance (i.e. quantum irradiance) for one or more wavebands of a
light source spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q_irrad(
  spct,
  w.band,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## Default S3 method:
q_irrad(
  spct,
  w.band,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  allow.scaled,
  ...
)

## S3 method for class 'source_spct'
q_irrad(
  spct,
  w.band = NULL,
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = !quantity %in% c("average", "mean", "total"),
  naming = "default",
  return.tb = FALSE,
  ...
)

## S3 method for class 'source_mspct'
q_irrad(
  spct,
  w.band = NULL,
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = getOption("photobiology.use.cached.mult", default = FALSE),
  use.hinges = NULL,
  allow.scaled = !quantity %in% c("average", "mean", "total"),
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q_irrad_+3A_spct">spct</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_w.band">w.band</code></td>
<td>
<p>a list of <code>waveband</code> objects or a <code>waveband</code> object.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;,
&quot;contribution&quot;, &quot;contribution.pc&quot;, &quot;relative&quot; or &quot;relative.pc&quot;.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_time.unit">time.unit</code></td>
<td>
<p>character or lubridate::duration object.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_allow.scaled">allow.scaled</code></td>
<td>
<p>logical indicating whether scaled or normalized spectra
as argument to spct are flagged as an error.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored).</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_return.tb">return.tb</code></td>
<td>
<p>logical Flag forcing a tibble to be always returned, even
for a single spectrum as argumnet to <code>spct</code>. The default is
<code>FALSE</code> for backwards compatibility.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="q_irrad_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector in the case of a <code>_spct</code> object
containing a single spectrum and <code>return.tb = FALSE</code>. The vector has
one member one value for each <code>waveband</code> passed to parameter
<code>w.band</code>. In all other cases a <code>tibble</code>, containing one column
for each <code>waveband</code> object, an index column with the names of the
spectra, and optionally additional columns with metadata values retrieved
from the attributes of the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used. The time.unit
attribute is copied from the spectrum object to the output. Units are as
follows: If time.unit is second, [W m-2 nm-1] -&gt; [mol s-1 m-2] If time.unit
is day, [J d-1 m-2 nm-1] -&gt; [mol d-1 m-2]
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>q_irrad(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>q_irrad(source_spct)</code>: Calculates photon irradiance from a <code>source_spct</code>
object.
</p>
</li>
<li> <p><code>q_irrad(source_mspct)</code>: Calculates photon (quantum) irradiance from a
<code>source_mspct</code> object.
</p>
</li></ul>


<h3>Note</h3>

<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult=TRUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>See Also</h3>

<p>Other irradiance functions: 
<code><a href="#topic+e_fluence">e_fluence</a>()</code>,
<code><a href="#topic+e_irrad">e_irrad</a>()</code>,
<code><a href="#topic+fluence">fluence</a>()</code>,
<code><a href="#topic+irrad">irrad</a>()</code>,
<code><a href="#topic+q_fluence">q_fluence</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q_irrad(sun.spct, waveband(c(400,700)))
q_irrad(sun.spct, split_bands(c(400,700), length.out = 3))
q_irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "total")
q_irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "average")
q_irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "relative")
q_irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "relative.pc")
q_irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "contribution")
q_irrad(sun.spct, split_bands(c(400,700), length.out = 3), quantity = "contribution.pc")

</code></pre>

<hr>
<h2 id='q_ratio'>Photon:photon ratio</h2><span id='topic+q_ratio'></span><span id='topic+q_ratio.default'></span><span id='topic+q_ratio.source_spct'></span><span id='topic+q_ratio.source_mspct'></span>

<h3>Description</h3>

<p>This function returns the photon ratio for a given pair of wavebands of a
light source spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q_ratio(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## Default S3 method:
q_ratio(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## S3 method for class 'source_spct'
q_ratio(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "total",
  naming = "short",
  name.tag = NULL,
  ...
)

## S3 method for class 'source_mspct'
q_ratio(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "total",
  naming = "short",
  name.tag = ifelse(naming != "none", "[q:q]", ""),
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q_ratio_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;source_spct&quot;.</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_w.band.num">w.band.num</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the numerator(s) of the ratio(s).</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_w.band.denom">w.band.denom</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the denominator(s) of the ratio(s).</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_quantity">quantity</code></td>
<td>
<p>character One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_name.tag">name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="q_ratio_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default <code>quantity = "total"</code> the ratio is based on
two photon irradiances, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{Q(s, wb_\mathrm{num})}{Q(s, wb_\mathrm{denom})}</code>
</p>

<p>If the argument is set to <code>quantity = "mean"</code> or
<code>quantity = "average"</code> the ratio is based on
two mean spectral photon irradiances, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\overline{Q_\lambda}(s, wb_\mathrm{num})}{\overline{Q_\lambda}(s, wb_\mathrm{denom})}</code>
</p>

<p>Ratios based on totals and means are numerically identical only if the
wavelength expanse of the two wavebands is the same.
</p>
<p>Fraction definitions are &quot;assembled&quot; from the arguments passed to
<code>w.band.num</code> and <code>w.band.denom</code>. If both arguments are lists of
waveband definitions, with an equal number of members, then the wavebands
are paired to obtain as many fractions as the number of wavebands in each
list. Recycling for wavebands takes place when the number of denominator
and numerator wavebands differ.
</p>
<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult=TRUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>Value</h3>

<p>In the case of methods for individual spectra, a <code>numeric</code>
vector with name attribute set. The name is based on the name of the
wavebands unless a named list of wavebands is supplied in which case the
names of the list elements are used. &quot;[q:q]&quot; is appended if <code>quantity
  = "total"</code> and &quot;[q(wl):q(wl)]&quot; if <code>quantity = "mean"</code> or
<code>quantity = "average"</code>.
</p>
<p>A <code>data.frame</code> is returned in the case of collections of spectra,
containing one column for each fraction definition, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>q_ratio(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>q_ratio(source_spct)</code>: Method for <code>source_spct</code> objects
</p>
</li>
<li> <p><code>q_ratio(source_mspct)</code>: Calculates photon:photon from a <code>source_mspct</code>
object.
</p>
</li></ul>


<h3>Performance</h3>

<p>As this method accepts spectra as its input, it
computes irradiances before computing the ratios. If you need to compute
both ratios and irradiances from several hundreds or thousands of spectra,
computing the ratios from previously computed irradiances avoids their
repeated computation. A less dramatic, but still important, increase in
performance is available when computing in the same function call ratios
that share the same denominator.
</p>


<h3>See Also</h3>

<p>Other photon and energy ratio functions: 
<code><a href="#topic+e_fraction">e_fraction</a>()</code>,
<code><a href="#topic+e_ratio">e_ratio</a>()</code>,
<code><a href="#topic+eq_ratio">eq_ratio</a>()</code>,
<code><a href="#topic+q_fraction">q_fraction</a>()</code>,
<code><a href="#topic+qe_ratio">qe_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q_ratio(sun.spct,
        waveband(c(400,500), wb.name = "Blue"),
        waveband(c(400,700), wb.name = "White"))

</code></pre>

<hr>
<h2 id='q_response'>Photon-based photo-response</h2><span id='topic+q_response'></span><span id='topic+q_response.default'></span><span id='topic+q_response.response_spct'></span><span id='topic+q_response.response_mspct'></span>

<h3>Description</h3>

<p>This function returns the mean response for a given
waveband and a response spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q_response(
  spct,
  w.band,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.hinges,
  ...
)

## Default S3 method:
q_response(
  spct,
  w.band,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.hinges,
  ...
)

## S3 method for class 'response_spct'
q_response(
  spct,
  w.band = NULL,
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = getOption("photobiology.use.hinges", default = NULL),
  naming = "default",
  ...
)

## S3 method for class 'response_mspct'
q_response(
  spct,
  w.band = NULL,
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = getOption("photobiology.use.hinges", default = NULL),
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q_response_+3A_spct">spct</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="q_response_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects or a numeric vector of
length two. The waveband(s) determine the region(s) of the spectrum that
are summarized. If a numeric range is supplied a waveband object is
constructed on the fly from it.</p>
</td></tr>
<tr><td><code id="q_response_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;,
&quot;contribution&quot;, &quot;contribution.pc&quot;, &quot;relative&quot; or &quot;relative.pc&quot;.</p>
</td></tr>
<tr><td><code id="q_response_+3A_time.unit">time.unit</code></td>
<td>
<p>character or lubridate::duration object.</p>
</td></tr>
<tr><td><code id="q_response_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="q_response_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded.</p>
</td></tr>
<tr><td><code id="q_response_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="q_response_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="q_response_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="q_response_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="q_response_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="q_response_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="q_response_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector in the case of methods for individual
spectra, with one value for each <code>waveband</code> passed to parameter
<code>w.band</code>. A <code>data.frame</code> in the case of collections of spectra,
containing one column for each <code>waveband</code> object, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>q_response(default)</code>: Default method for generic function
</p>
</li>
<li> <p><code>q_response(response_spct)</code>: Method for response spectra.
</p>
</li>
<li> <p><code>q_response(response_mspct)</code>: Calculates photon (quantum) response from a
<code>response_mspct</code>
</p>
</li></ul>


<h3>Note</h3>

<p>The parameter <code>use.hinges</code> controls speed optimization. The
defaults should be suitable in most cases. Only the range of wavelengths
in the wavebands is used and all BSWFs are ignored.
</p>


<h3>See Also</h3>

<p>Other response functions: 
<code><a href="#topic+e_response">e_response</a>()</code>,
<code><a href="#topic+response">response</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q_response(ccd.spct, new_waveband(200,300))
q_response(photodiode.spct)

</code></pre>

<hr>
<h2 id='q2e'>Convert photon-based quantities into energy-based quantities</h2><span id='topic+q2e'></span><span id='topic+q2e.default'></span><span id='topic+q2e.source_spct'></span><span id='topic+q2e.response_spct'></span><span id='topic+q2e.source_mspct'></span><span id='topic+q2e.response_mspct'></span>

<h3>Description</h3>

<p>Conversion methods for spectral photon irradiance into spectral energy
irradiance and for spectral photon response into spectral energy
response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q2e(x, action, byref, ...)

## Default S3 method:
q2e(x, action = "add", byref = FALSE, ...)

## S3 method for class 'source_spct'
q2e(x, action = "add", byref = FALSE, ...)

## S3 method for class 'response_spct'
q2e(x, action = "add", byref = FALSE, ...)

## S3 method for class 'source_mspct'
q2e(x, action = "add", byref = FALSE, ..., .parallel = FALSE, .paropts = NULL)

## S3 method for class 'response_mspct'
q2e(x, action = "add", byref = FALSE, ..., .parallel = FALSE, .paropts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q2e_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="q2e_+3A_action">action</code></td>
<td>
<p>a character string, one of &quot;add&quot;, &quot;replace&quot;, &quot;add.raw&quot; or
&quot;replace.raw&quot;.</p>
</td></tr>
<tr><td><code id="q2e_+3A_byref">byref</code></td>
<td>
<p>logical indicating if a new object will be created by reference
or a new object returned.</p>
</td></tr>
<tr><td><code id="q2e_+3A_...">...</code></td>
<td>
<p>not used in current version.</p>
</td></tr>
<tr><td><code id="q2e_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="q2e_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The converted spectral values are added to or replace the existing
spectral values depending on the argument passed to parameter
<code>action</code>. Addition is currently not supported for normalized spectra.
If the spectrum has been normalized with a recent version of package
'photobiology' the spectrum will be renormalized after conversion using the
same arguments as previously. <code>"add.raw"</code> and <code>"replace.raw"</code>
prevent the re-normalization, are included for completeness and as a way of
restoring previous behaviour.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>q2e(default)</code>: Default method
</p>
</li>
<li> <p><code>q2e(source_spct)</code>: Method for spectral irradiance
</p>
</li>
<li> <p><code>q2e(response_spct)</code>: Method for spectral responsiveness
</p>
</li>
<li> <p><code>q2e(source_mspct)</code>: Method for collections of (light) source spectra
</p>
</li>
<li> <p><code>q2e(response_mspct)</code>: Method for collections of response spectra
</p>
</li></ul>


<h3>See Also</h3>

<p>Other quantity conversion functions: 
<code><a href="#topic+A2T">A2T</a>()</code>,
<code><a href="#topic+Afr2T">Afr2T</a>()</code>,
<code><a href="#topic+T2A">T2A</a>()</code>,
<code><a href="#topic+T2Afr">T2Afr</a>()</code>,
<code><a href="#topic+any2T">any2T</a>()</code>,
<code><a href="#topic+as_quantum">as_quantum</a>()</code>,
<code><a href="#topic+e2q">e2q</a>()</code>,
<code><a href="#topic+e2qmol_multipliers">e2qmol_multipliers</a>()</code>,
<code><a href="#topic+e2quantum_multipliers">e2quantum_multipliers</a>()</code>
</p>

<hr>
<h2 id='qe_ratio'>Photon:energy ratio</h2><span id='topic+qe_ratio'></span><span id='topic+qe_ratio.default'></span><span id='topic+qe_ratio.source_spct'></span><span id='topic+qe_ratio.source_mspct'></span>

<h3>Description</h3>

<p>This function returns the photon to energy ratio for each waveband of a light
source spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qe_ratio(spct, w.band, scale.factor, wb.trim, use.cached.mult, use.hinges, ...)

## Default S3 method:
qe_ratio(spct, w.band, scale.factor, wb.trim, use.cached.mult, use.hinges, ...)

## S3 method for class 'source_spct'
qe_ratio(
  spct,
  w.band = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  naming = "short",
  name.tag = ifelse(naming != "none", "[q:e]", ""),
  ...
)

## S3 method for class 'source_mspct'
qe_ratio(
  spct,
  w.band = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  naming = "short",
  name.tag = ifelse(naming != "none", "[q:e]", ""),
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qe_ratio_+3A_spct">spct</code></td>
<td>
<p>source_spct.</p>
</td></tr>
<tr><td><code id="qe_ratio_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects.</p>
</td></tr>
<tr><td><code id="qe_ratio_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="qe_ratio_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded.</p>
</td></tr>
<tr><td><code id="qe_ratio_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag telling whether multiplier values should be
cached between calls.</p>
</td></tr>
<tr><td><code id="qe_ratio_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="qe_ratio_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="qe_ratio_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="qe_ratio_+3A_name.tag">name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td></tr>
<tr><td><code id="qe_ratio_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="qe_ratio_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="qe_ratio_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="qe_ratio_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ratio is based on one photon irrandiance and one energy
irradiance, both computed for the same waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{Q(s, wb)}{I(s, wb)}</code>
</p>

<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult=TRUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>Value</h3>

<p>Computed values are ratios between photon irradiance and energy
irradiance for a given waveband. A named <code>numeric</code> vector in the case
of methods for individual spectra, with one value for each <code>waveband</code>
passed to parameter <code>w.band</code>. A <code>data.frame</code> in the case of
collections of spectra, containing one column for each <code>waveband</code>
object, an index column with the names of the spectra, and optionally
additional columns with metadata values retrieved from the attributes of
the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used, with &quot;[q:e]&quot; prepended.
Units [mol J-1].
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>qe_ratio(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>qe_ratio(source_spct)</code>: Method for <code>source_spct</code> objects
</p>
</li>
<li> <p><code>qe_ratio(source_mspct)</code>: Calculates photon:energy ratio from a
<code>source_mspct</code> object.
</p>
</li></ul>


<h3>Performance</h3>

<p>As this method accepts spectra as its input, it
computes irradiances before computing the ratios. If you need to compute
both ratios and irradiances from several hundreds or thousands of spectra,
computing the ratios from previously computed irradiances avoids their
repeated computation. A less dramatic, but still important, increase in
performance is available when computing in the same function call ratios
that share the same denominator.
</p>


<h3>See Also</h3>

<p>Other photon and energy ratio functions: 
<code><a href="#topic+e_fraction">e_fraction</a>()</code>,
<code><a href="#topic+e_ratio">e_ratio</a>()</code>,
<code><a href="#topic+eq_ratio">eq_ratio</a>()</code>,
<code><a href="#topic+q_fraction">q_fraction</a>()</code>,
<code><a href="#topic+q_ratio">q_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qe_ratio(sun.spct,
         waveband(c(400,700), wb.name = "White")) # mol J-1
qe_ratio(sun.spct,
         waveband(c(400,700), wb.name = "White"),
         scale.factor = 1e6) # umol J-1

</code></pre>

<hr>
<h2 id='r4p_pkgs'>Packages in R for Photobiology suite</h2><span id='topic+r4p_pkgs'></span>

<h3>Description</h3>

<p>A dataset containing the names of all the packages in this
suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r4p_pkgs
</code></pre>


<h3>Format</h3>

<p>A <code>character vector</code>.
</p>


<h3>Details</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r4p_pkgs

</code></pre>

<hr>
<h2 id='rbindspct'>Row-bind spectra</h2><span id='topic+rbindspct'></span>

<h3>Description</h3>

<p>A wrapper on <code>dplyr::rbind_fill</code> that preserves class and other
attributes of spectral objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbindspct(
  l,
  use.names = TRUE,
  fill = TRUE,
  idfactor = TRUE,
  attrs.source = NULL,
  attrs.simplify = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbindspct_+3A_l">l</code></td>
<td>
<p>A <code>source_mspct</code>, <code>filter_mspct</code>, <code>reflector_mspct</code>,
<code>response_mspct</code>, <code>chroma_mspct</code>, <code>cps_mspct</code>,
<code>generic_mspct</code> object or a list containing <code>source_spct</code>,
<code>filter_spct</code>, <code>reflector_spct</code>, <code>response_spct</code>,
<code>chroma_spct</code>, <code>cps_spct</code>, or <code>generic_spct</code> objects.</p>
</td></tr>
<tr><td><code id="rbindspct_+3A_use.names">use.names</code></td>
<td>
<p>logical If <code>TRUE</code> items will be bound by matching
column names. By default <code>TRUE</code> for <code>rbindspct</code>. Columns with
duplicate names are bound in the order of occurrence, similar to base. When
TRUE, at least one item of the input list has to have non-null column
names.</p>
</td></tr>
<tr><td><code id="rbindspct_+3A_fill">fill</code></td>
<td>
<p>logical If <code>TRUE</code> fills missing columns with NAs. By default
<code>TRUE</code>. When <code>TRUE</code>, <code>use.names</code> has also to be <code>TRUE</code>,
and all items of the input list have to have non-null column names.</p>
</td></tr>
<tr><td><code id="rbindspct_+3A_idfactor">idfactor</code></td>
<td>
<p>logical or character Generates an index column of
<code>factor</code> type. Default is (<code>idfactor=TRUE</code>) for both lists and
<code>_mspct</code> objects. If <code>idfactor=TRUE</code> then the column is auto
named <code>spct.idx</code>. Alternatively the column name can be directly
provided to <code>idfactor</code> as a character string.</p>
</td></tr>
<tr><td><code id="rbindspct_+3A_attrs.source">attrs.source</code></td>
<td>
<p>integer Index into the members of the list from which
attributes should be copied. If <code>NULL</code>, all attributes are collected
into named lists, except that unique comments are pasted.</p>
</td></tr>
<tr><td><code id="rbindspct_+3A_attrs.simplify">attrs.simplify</code></td>
<td>
<p>logical Flag indicating that when all values of an
attribute are equal for all members, the named list will be replaced by
a single copy of the value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each item of <code>l</code> should be a spectrum, including <code>NULL</code>
(skipped) or an empty object (0 rows). <code>rbindspc</code> is most useful when
there are a variable number of (potentially many) objects to stack.
<code>rbindspct</code> always returns at least a <code>generic_spct</code> as long as
all elements in l are spectra.
</p>


<h3>Value</h3>

<p>An spectral object of a type common to all bound items containing a
concatenation of all the items passed in. If the argument 'idfactor' is
TRUE, then a factor 'spct.idx' will be added to the returned spectral
object.
</p>


<h3>Note</h3>

<p>Note that any additional 'user added' attributes that might exist on
individual items of the input list will not be preserved in the result.
The attributes used by the <code>photobiology</code> package are preserved, and
if they are not consistent across the bound spectral objects, a warning is
issued.
</p>
<p><code>dplyr::rbind_fill</code> is called internally and the result returned is
the highest class in the inheritance hierarchy which is common to all
elements in the list. If not all members of the list belong to one of the
<code>_spct</code> classes, an error is triggered. The function sets all data in
<code>source_spct</code> and <code>response_spct</code> objects supplied as arguments
into energy-based quantities, and all data in <code>filter_spct</code> objects
into transmittance before the row binding is done. If any member spectrum
is tagged, it is untagged before row binding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># default, adds factor 'spct.idx' with letters as levels
spct &lt;- rbindspct(list(sun.spct, sun.spct))
spct
class(spct)

# adds factor 'spct.idx' with letters as levels
spct &lt;- rbindspct(list(sun.spct, sun.spct), idfactor = TRUE)
head(spct)
class(spct)

# adds factor 'spct.idx' with the names given to the spectra in the list
# supplied as formal argument 'l' as levels
spct &lt;- rbindspct(list(one = sun.spct, two = sun.spct), idfactor = TRUE)
head(spct)
class(spct)

# adds factor 'ID' with the names given to the spectra in the list
# supplied as formal argument 'l' as levels
spct &lt;- rbindspct(list(one = sun.spct, two = sun.spct),
                  idfactor = "ID")
head(spct)
class(spct)

</code></pre>

<hr>
<h2 id='reflectance'>Reflectance</h2><span id='topic+reflectance'></span><span id='topic+reflectance.default'></span><span id='topic+reflectance.reflector_spct'></span><span id='topic+reflectance.object_spct'></span><span id='topic+reflectance.reflector_mspct'></span><span id='topic+reflectance.object_mspct'></span>

<h3>Description</h3>

<p>Function to calculate the mean, total, or other summary of reflectance for
spectral data stored in a <code>reflector_spct</code> or in an <code>object_spct</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reflectance(spct, w.band, quantity, wb.trim, use.hinges, ...)

## Default S3 method:
reflectance(spct, w.band, quantity, wb.trim, use.hinges, ...)

## S3 method for class 'reflector_spct'
reflectance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...
)

## S3 method for class 'object_spct'
reflectance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...
)

## S3 method for class 'reflector_mspct'
reflectance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'object_mspct'
reflectance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reflectance_+3A_spct">spct</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="reflectance_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects or a numeric vector of
length two. The waveband(s) determine the region(s) of the spectrum that
are summarized. If a numeric range is supplied a waveband object is
constructed on the fly from it.</p>
</td></tr>
<tr><td><code id="reflectance_+3A_quantity">quantity</code></td>
<td>
<p>character string One of <code>"average"</code> or <code>"mean"</code>,
<code>"total"</code>, <code>"contribution"</code>, <code>"contribution.pc"</code>,
<code>"relative"</code> or <code>"relative.pc"</code>.</p>
</td></tr>
<tr><td><code id="reflectance_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if <code>TRUE</code> wavebands crossing spectral data
boundaries are trimmed, if <code>FALSE</code>, they are discarded.</p>
</td></tr>
<tr><td><code id="reflectance_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="reflectance_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id="reflectance_+3A_naming">naming</code></td>
<td>
<p>character one of <code>"long"</code>, <code>"default"</code>,
<code>"short"</code> or <code>"none"</code>. Used to select the type of names to assign
to returned value.</p>
</td></tr>
<tr><td><code id="reflectance_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="reflectance_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="reflectance_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="reflectance_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector in the case of methods for individual
spectra, with one value for each <code>waveband</code> passed to parameter
<code>w.band</code>. A <code>data.frame</code> in the case of collections of spectra,
containing one column for each <code>waveband</code> object, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>reflectance(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>reflectance(reflector_spct)</code>: Specialization for reflector_spct
</p>
</li>
<li> <p><code>reflectance(object_spct)</code>: Specialization for object_spct
</p>
</li>
<li> <p><code>reflectance(reflector_mspct)</code>: Calculates reflectance from a <code>reflector_mspct</code>
</p>
</li>
<li> <p><code>reflectance(object_mspct)</code>: Calculates reflectance from a <code>object_mspct</code>
</p>
</li></ul>


<h3>Note</h3>

<p>The <code>use.hinges</code> parameter controls speed optimization. The
defaults should be suitable in most cases. Only the range of wavelengths
in the wavebands is used and all BSWFs are ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reflectance(black_body.spct, waveband(c(400,700)))
reflectance(white_body.spct, waveband(c(400,700)))

</code></pre>

<hr>
<h2 id='reflectance_spct'>Calculate reflectance from spectral reflectance</h2><span id='topic+reflectance_spct'></span>

<h3>Description</h3>

<p>This function returns the mean reflectance for a given waveband and a
reflectance spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reflectance_spct(spct, w.band, quantity, wb.trim, use.hinges, naming, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reflectance_spct_+3A_spct">spct</code></td>
<td>
<p>an object of class generic_spct&quot;</p>
</td></tr>
<tr><td><code id="reflectance_spct_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects or a numeric vector of
length two. The waveband(s) determine the region(s) of the spectrum that
are summarized. If a numeric range is supplied a waveband object is
constructed on the fly from it.</p>
</td></tr>
<tr><td><code id="reflectance_spct_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;,
&quot;contribution&quot;, &quot;contribution.pc&quot;, &quot;relative&quot; or &quot;relative.pc&quot;</p>
</td></tr>
<tr><td><code id="reflectance_spct_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="reflectance_spct_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="reflectance_spct_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="reflectance_spct_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value expressed as a fraction of one
</p>

<hr>
<h2 id='relative_AM'>Relative Air Mass (AM)</h2><span id='topic+relative_AM'></span>

<h3>Description</h3>

<p>Approximate relative air mass (AM) from sun elevation or
sun zenith angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relative_AM(elevation.angle = NULL, zenith.angle = NULL, occluded.value = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relative_AM_+3A_elevation.angle">elevation.angle</code>, <code id="relative_AM_+3A_zenith.angle">zenith.angle</code></td>
<td>
<p>numeric vector Angle in degrees for the
sun position. An argument should be passed to one and only one of
<code>elevation_angle</code> or <code>zenith_angle</code>.</p>
</td></tr>
<tr><td><code id="relative_AM_+3A_occluded.value">occluded.value</code></td>
<td>
<p>numeric Value to return when elevation angle is
negative (sun below the horizon).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of equation (3) in Kasten and Young
(1989). This equation is only an approximation to the tabulated values in
the same paper. Returned values are rounded to three significant digits.
</p>


<h3>Note</h3>

<p>Although relative air mass is not defined when the sun is not visible,
returning a value different from the default <code>NA</code> might be useful in
some cases.
</p>


<h3>References</h3>

<p>F. Kasten, A. T. Young (1989) Revised optical air mass tables and
approximation formula. Applied Optics, 28, 4735-. doi:10.1364/ao.28.004735.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
relative_AM(c(90, 60, 30, 1, -10))
relative_AM(c(90, 60, 30, 1, -10), occluded.value = Inf)
relative_AM(zenith.angle = 0)

</code></pre>

<hr>
<h2 id='replace_bad_pixs'>Replace bad pixels in a spectrum</h2><span id='topic+replace_bad_pixs'></span>

<h3>Description</h3>

<p>This function replaces data for bad pixels by a local estimate, by either
simple interpolation or using the algorithm of Whitaker and Hayes (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_bad_pixs(
  x,
  bad.pix.idx = FALSE,
  window.width = 11,
  method = "run.mean",
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_bad_pixs_+3A_x">x</code></td>
<td>
<p>numeric vector containing spectral data.</p>
</td></tr>
<tr><td><code id="replace_bad_pixs_+3A_bad.pix.idx">bad.pix.idx</code></td>
<td>
<p>logical vector or integer. Index into bad pixels in
<code>x</code>.</p>
</td></tr>
<tr><td><code id="replace_bad_pixs_+3A_window.width">window.width</code></td>
<td>
<p>integer. The full width of the window used for the
running mean.</p>
</td></tr>
<tr><td><code id="replace_bad_pixs_+3A_method">method</code></td>
<td>
<p>character The name of the method: <code>"run.mean"</code> is running
mean as described in Whitaker and Hayes (2018); <code>"adj.mean"</code> is mean
of adjacent neighbors (isolated bad pixels only).</p>
</td></tr>
<tr><td><code id="replace_bad_pixs_+3A_na.rm">na.rm</code></td>
<td>
<p>logical Treat <code>NA</code> values as additional bad pixels and
replace them.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple interpolation replaces values of isolated bad pixels by the mean of
their two closest neighbors. The running mean approach allows the replacement
of short runs of bad pixels by the running mean of neighboring pixels within
a window of user-specified width. The first approach works well for spectra
from array spectrometers to correct for hot and dead pixels in an instrument.
The second approach is most suitable for Raman spectra in which spikes
triggered by radiation are wider than a single pixel but usually not more
than five pixels wide.
</p>


<h3>Value</h3>

<p>A logical vector of the same length as <code>x</code>. Values that are TRUE
correspond to local spikes in the data.
</p>


<h3>Note</h3>

<p>In the current implementation <code>NA</code> values are not removed, and
if they are in the neighborhood of bad pixels, they will result in the
generation of additional <code>NA</code>s during their replacement.
</p>


<h3>References</h3>

<p>Whitaker, D. A.; Hayes, K. (2018) A simple algorithm for despiking Raman
spectra. Chemometrics and Intelligent Laboratory Systems, 179, 82-84.
</p>


<h3>See Also</h3>

<p>Other peaks and valleys functions: 
<code><a href="#topic+find_peaks">find_peaks</a>()</code>,
<code><a href="#topic+find_spikes">find_spikes</a>()</code>,
<code><a href="#topic+get_peaks">get_peaks</a>()</code>,
<code><a href="#topic+peaks">peaks</a>()</code>,
<code><a href="#topic+spikes">spikes</a>()</code>,
<code><a href="#topic+valleys">valleys</a>()</code>,
<code><a href="#topic+wls_at_target">wls_at_target</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># in a vector
replace_bad_pixs(c(1, 1, 45, 1, 1), bad.pix.idx = 3)

# before replacement
white_led.raw_spct$counts_3[120:125]

# replacing bad pixels at index positions 123 and 1994
with(white_led.raw_spct,
     replace_bad_pixs(counts_3, bad.pix.idx = c(123, 1994)))[120:125]

</code></pre>

<hr>
<h2 id='resp_spct'>Calculate response from spectral response</h2><span id='topic+resp_spct'></span>

<h3>Description</h3>

<p>This function returns the mean response for a given waveband and a response
spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resp_spct(
  spct,
  w.band,
  unit.out,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.hinges,
  allow.scaled = !quantity %in% c("average", "mean", "total"),
  naming,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resp_spct_+3A_spct">spct</code></td>
<td>
<p>an object of class response_spct&quot;.</p>
</td></tr>
<tr><td><code id="resp_spct_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects or a numeric vector of
length two. The waveband(s) determine the region(s) of the spectrum that
are summarized. If a numeric range is supplied a waveband object is
constructed on the fly from it.</p>
</td></tr>
<tr><td><code id="resp_spct_+3A_unit.out">unit.out</code></td>
<td>
<p>character with allowed values &quot;energy&quot;, and &quot;photon&quot;, or its
alias &quot;quantum&quot;.</p>
</td></tr>
<tr><td><code id="resp_spct_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;,
&quot;contribution&quot;, &quot;contribution.pc&quot;, &quot;relative&quot; or &quot;relative.pc&quot;.</p>
</td></tr>
<tr><td><code id="resp_spct_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="resp_spct_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded.</p>
</td></tr>
<tr><td><code id="resp_spct_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="resp_spct_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="resp_spct_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value expressed either as a fraction of one or a
percentage, or a vector of the same length as the list of <code>waveband</code>
objects.
</p>


<h3>Note</h3>

<p>The parameter <code>use.hinges</code> controls speed optimization. The
defaults should be suitable in most cases. Only the range of wavelengths
in the wavebands is used and all BSWFs are ignored.
</p>

<hr>
<h2 id='response'>Integrated response</h2><span id='topic+response'></span><span id='topic+response.default'></span><span id='topic+response.response_spct'></span><span id='topic+response.response_mspct'></span>

<h3>Description</h3>

<p>Calculate average photon- or energy-based photo-response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response(
  spct,
  w.band,
  unit.out,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.hinges,
  ...
)

## Default S3 method:
response(
  spct,
  w.band,
  unit.out,
  quantity,
  time.unit,
  scale.factor,
  wb.trim,
  use.hinges,
  ...
)

## S3 method for class 'response_spct'
response(
  spct,
  w.band = NULL,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = getOption("photobiology.use.hinges", default = NULL),
  naming = "default",
  ...
)

## S3 method for class 'response_mspct'
response(
  spct,
  w.band = NULL,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  quantity = "total",
  time.unit = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = getOption("photobiology.use.hinges", default = NULL),
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_+3A_spct">spct</code></td>
<td>
<p>an R object of class &quot;generic_spct&quot;.</p>
</td></tr>
<tr><td><code id="response_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects or a numeric vector of
length two. The waveband(s) determine the region(s) of the spectrum that
are summarized. If a numeric range is supplied a waveband object is
constructed on the fly from it.</p>
</td></tr>
<tr><td><code id="response_+3A_unit.out">unit.out</code></td>
<td>
<p>character Allowed values <code>"energy"</code>, and
<code>"photon"</code>, or its alias <code>"quantum"</code>.</p>
</td></tr>
<tr><td><code id="response_+3A_quantity">quantity</code></td>
<td>
<p>character string One of <code>"average"</code> or <code>"mean"</code>,
<code>"total"</code>, <code>"contribution"</code>, <code>"contribution.pc"</code>,
<code>"relative"</code> or <code>"relative.pc"</code>.</p>
</td></tr>
<tr><td><code id="response_+3A_time.unit">time.unit</code></td>
<td>
<p>character or lubridate::duration object.</p>
</td></tr>
<tr><td><code id="response_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="response_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if <code>TRUE</code> wavebands crossing spectral data
boundaries are trimmed, if <code>FALSE</code>, they are discarded.</p>
</td></tr>
<tr><td><code id="response_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="response_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="response_+3A_naming">naming</code></td>
<td>
<p>character one of <code>"long"</code>, <code>"default"</code>,
<code>"short"</code> or <code>"none"</code>. Used to select the type of names to assign
to returned value.</p>
</td></tr>
<tr><td><code id="response_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="response_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="response_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="response_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector in the case of methods for individual
spectra, with one value for each <code>waveband</code> passed to parameter
<code>w.band</code>. A <code>data.frame</code> in the case of collections of spectra,
containing one column for each <code>waveband</code> object, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>Whether returned values are expressed in energy-based or photon-based units
depends on <code>unit.out</code>. By default values are only integrated, but
depending on the argument passed to parameter <code>quantity</code> they can be
re-expressed as relative fractions or percentages. In the case of vector
output, <code>names</code> attribute is set to the name of the corresponding
waveband unless a named list is supplied in which case the names of the
list members are used.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>response(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>response(response_spct)</code>: Method for response spectra.
</p>
</li>
<li> <p><code>response(response_mspct)</code>: Calculates response from a <code>response_mspct</code>
</p>
</li></ul>


<h3>Note</h3>

<p>The parameter <code>use.hinges</code> controls speed optimization. The
defaults should be suitable in most cases. Only the range of wavelengths
in the wavebands is used and all BSWFs are ignored.
</p>


<h3>See Also</h3>

<p>Other response functions: 
<code><a href="#topic+e_response">e_response</a>()</code>,
<code><a href="#topic+q_response">q_response</a>()</code>
</p>

<hr>
<h2 id='Rfr_fraction'>reflectance:reflectance fraction</h2><span id='topic+Rfr_fraction'></span><span id='topic+Rfr_fraction.default'></span><span id='topic+Rfr_fraction.reflector_spct'></span><span id='topic+Rfr_fraction.reflector_mspct'></span>

<h3>Description</h3>

<p>This function returns the reflectance fraction for a given pair of wavebands of a
reflector spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rfr_fraction(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## Default S3 method:
Rfr_fraction(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## S3 method for class 'reflector_spct'
Rfr_fraction(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...
)

## S3 method for class 'reflector_mspct'
Rfr_fraction(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rfr_fraction_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;reflector_spct&quot;.</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_w.band.num">w.band.num</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the numerator(s) and denominator(s) of the fraction(s).</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_w.band.denom">w.band.denom</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the denominator(s) of the fraction(s).</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_quantity">quantity</code></td>
<td>
<p>character One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_name.tag">name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="Rfr_fraction_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default <code>quantity = "mean"</code> or <code>quantity =
  "average"</code> the ratio is based on two <strong>mean spectral reflectance</strong>,
one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{num})}{\overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{denom}) + \overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{num})}</code>
</p>

<p>If the argument is set to <code>quantity = "total"</code> the fraction is based on
two <strong>integrated reflectance</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\mathrm{Rfr}(s, wb_\mathrm{num})}{\mathrm{Rfr}(s, wb_\mathrm{denom}) + \mathrm{Rfr}(s, wb_\mathrm{num})}</code>
</p>

<p>Only if the wavelength expanse of the two wavebands is the same, these two
ratios are numerically identical.
</p>


<h3>Value</h3>

<p>In the case of methods for individual spectra, a <code>numeric</code>
vector with name attribute set. The name is based on the name of the
wavebands unless a named list of wavebands is supplied in which case the
names of the list elements are used. &quot;[Rfr:Rfr]&quot; is appended if <code>quantity
  = "total"</code> and &quot;[Rfr(wl):Rfr(wl)]&quot; if <code>quantity = "mean"</code> or
<code>quantity = "average"</code>.
</p>
<p>A <code>data.frame</code> is returned in the case of collections of spectra,
containing one column for each fraction definition, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>Fraction definitions are &quot;assembled&quot; from the arguments passed to
<code>w.band.num</code> and <code>w.band.denom</code>. If both arguments are lists of
waveband definitions, with an equal number of members, then the wavebands
are paired to obtain as many fractions as the number of wavebands in each
list. Recycling for wavebands takes place when the number of denominator
and numerator wavebands differ.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>Rfr_fraction(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>Rfr_fraction(reflector_spct)</code>: Method for <code>reflector_spct</code> objects
</p>
</li>
<li> <p><code>Rfr_fraction(reflector_mspct)</code>: Calculates Rfr:Rfr from a <code>reflector_mspct</code>
object.
</p>
</li></ul>


<h3>Note</h3>

<p>The last two parameters control speed
optimizations. The defaults should be suitable in most cases. If you will
use repeatedly the same SWFs on many spectra measured at exactly the same
wavelengths you may obtain some speed up by setting
<code>use.cached.mult=TRUE</code>. However, be aware that you are responsible for
ensuring that the wavelengths are the same in each call, as the only test
done is for the length of the <code>w.length</code> vector.
</p>


<h3>See Also</h3>

<p>Other Reflectance ratio functions: 
<code><a href="#topic+Rfr_normdiff">Rfr_normdiff</a>()</code>,
<code><a href="#topic+Rfr_ratio">Rfr_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rfr_fraction(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"))
Rfr_fraction(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"),
             quantity = "total")
Rfr_fraction(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"),
             quantity = "mean")

</code></pre>

<hr>
<h2 id='Rfr_from_n'>Reflectance at a planar boundary</h2><span id='topic+Rfr_from_n'></span><span id='topic+Rfr_p_from_n'></span><span id='topic+Rfr_s_from_n'></span>

<h3>Description</h3>

<p>The reflectance at the planar boundary between two media, or interface, can
be computed from the relative refractive index. Reflectance depends on
polarization, and the process of reflection can generate polarized light
through selective reflection of <code class="reqn">s</code> and <code class="reqn">p</code> components. A perfectly
flat (i.e., polished) interface creates specular reflection, and this is the
case that these functions describe. These function describe a single
interface, and for example in a glass pane, a light beam will cross two
air-glass interfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rfr_from_n(angle_deg, angle = angle_deg/180 * pi, n = 1.5, p_fraction = 0.5)

Rfr_p_from_n(angle_deg, angle = angle_deg/180 * pi, n = 1.5)

Rfr_s_from_n(angle_deg, angle = angle_deg/180 * pi, n = 1.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rfr_from_n_+3A_angle_deg">angle_deg</code>, <code id="Rfr_from_n_+3A_angle">angle</code></td>
<td>
<p>numeric vector Angle of incidence of the light beam,
in degrees or radians. If both are supplied, radians take precedence.</p>
</td></tr>
<tr><td><code id="Rfr_from_n_+3A_n">n</code></td>
<td>
<p>numeric vector, or generic_spct object Relative refractive index.
The default 1.5 is suitable for crown glass or acrylic interacting with
visible light. <code class="reqn">n</code> depends on wavelength, more or less strongly
depending on the material.</p>
</td></tr>
<tr><td><code id="Rfr_from_n_+3A_p_fraction">p_fraction</code></td>
<td>
<p>numeric in range 0 to 1. Polarization, defaults to 0.5
assuming light that is not polarized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions implement Fresnel's formulae. All parameters accept
vectors as arguments. If both n and angle are vectors with length different
from one, they should both have the same length. Reflectance depends on
polarization, the <code class="reqn">s</code> and <code class="reqn">p</code> components need to be computed
separately and added up. <code>Rfr_from_n()</code> is for non-polarized light,
i.e., with equal contribution of the two components.
</p>


<h3>Value</h3>

<p>If <code>n</code> is a numeric vector the returned value is a vector of
reflectances, while if <code>n</code> is a <code>generic_spct</code> object the
returned value is a <code>reflector_spct</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Rfr_from_n(0:90)
Rfr_from_n(0:90, p_fraction = 1)
Rfr_from_n(0:90, n = 1.333) # water

</code></pre>

<hr>
<h2 id='Rfr_normdiff'>reflectance:reflectance normalised difference</h2><span id='topic+Rfr_normdiff'></span><span id='topic+Rfr_normdiff.default'></span><span id='topic+Rfr_normdiff.reflector_spct'></span><span id='topic+Rfr_normdiff.reflector_mspct'></span>

<h3>Description</h3>

<p>This function returns the reflectance normalized difference index for a given
pair of wavebands of a reflector spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rfr_normdiff(
  spct,
  w.band.plus,
  w.band.minus,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## Default S3 method:
Rfr_normdiff(
  spct,
  w.band.plus,
  w.band.minus,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## S3 method for class 'reflector_spct'
Rfr_normdiff(
  spct,
  w.band.plus = NULL,
  w.band.minus = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...
)

## S3 method for class 'reflector_mspct'
Rfr_normdiff(
  spct,
  w.band.plus = NULL,
  w.band.minus = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rfr_normdiff_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;reflector_spct&quot;.</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_w.band.plus">w.band.plus</code>, <code id="Rfr_normdiff_+3A_w.band.minus">w.band.minus</code></td>
<td>
<p>waveband object(s) or a list(s) of waveband
objects used to compute the additive and subtractive reflectance terms of
the normalized difference index.</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_quantity">quantity</code></td>
<td>
<p>character One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_name.tag">name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="Rfr_normdiff_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default <code>quantity = "mean"</code> or
<code>quantity = "average"</code> the ratio is based on
two <strong>mean spectral photon reflectances</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{plus}) - \overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{minus})}{\overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{plus}) + \overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{minus})}</code>
</p>

<p>If the argument is set to <code>quantity = "total"</code> the fraction is based on
two <strong>photon reflectances</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\mathrm{Rfr}(s, wb_\mathrm{plus}) - \mathrm{Rfr}(s, wb_\mathrm{minus})}{\mathrm{Rfr}(s, wb_\mathrm{plus}) + \mathrm{Rfr}(s, wb_\mathrm{minus})}</code>
</p>

<p>Only if the wavelength expanse of the two wavebands is the same, these two
ratios are numerically identical.
</p>


<h3>Value</h3>

<p>In the case of methods for individual spectra, a <code>numeric</code>
vector with name attribute set. The name is based on the name of the
wavebands unless a named list of wavebands is supplied in which case the
names of the list elements are used. &quot;[Rfr:Rfr]&quot; is appended if <code>quantity
  = "total"</code> and &quot;[Rfr(wl):Rfr(wl)]&quot; if <code>quantity = "mean"</code> or
<code>quantity = "average"</code>.
</p>
<p>A <code>data.frame</code> is returned in the case of collections of spectra,
containing one column for each fraction definition, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>Fraction definitions are &quot;assembled&quot; from the arguments passed to
<code>w.band.num</code> and <code>w.band.denom</code>. If both arguments are lists of
waveband definitions, with an equal number of members, then the wavebands
are paired to obtain as many fractions as the number of wavebands in each
list. Recycling for wavebands takes place when the number of denominator
and numerator wavebands differ.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>Rfr_normdiff(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>Rfr_normdiff(reflector_spct)</code>: Method for <code>reflector_spct</code> objects
</p>
</li>
<li> <p><code>Rfr_normdiff(reflector_mspct)</code>: Calculates Rfr:Rfr from a <code>reflector_mspct</code>
object.
</p>
</li></ul>


<h3>Note</h3>

<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult =T RUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalized_diff_ind">normalized_diff_ind</a></code>, accepts different summary
functions.
</p>
<p>Other Reflectance ratio functions: 
<code><a href="#topic+Rfr_fraction">Rfr_fraction</a>()</code>,
<code><a href="#topic+Rfr_ratio">Rfr_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rfr_normdiff(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"))
Rfr_normdiff(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"),
             quantity = "total")
Rfr_normdiff(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"),
             quantity = "mean")

</code></pre>

<hr>
<h2 id='Rfr_ratio'>reflectance:reflectance ratio</h2><span id='topic+Rfr_ratio'></span><span id='topic+Rfr_ratio.default'></span><span id='topic+Rfr_ratio.reflector_spct'></span><span id='topic+Rfr_ratio.reflector_mspct'></span>

<h3>Description</h3>

<p>This function returns the reflectance ratio for a given pair of wavebands of a
reflector spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rfr_ratio(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## Default S3 method:
Rfr_ratio(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## S3 method for class 'reflector_spct'
Rfr_ratio(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...
)

## S3 method for class 'reflector_mspct'
Rfr_ratio(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rfr_ratio_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;reflector_spct&quot;.</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_w.band.num">w.band.num</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the numerator(s) and denominator(s) of the ratio(s).</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_w.band.denom">w.band.denom</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the denominator(s) of the ratio(s).</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_quantity">quantity</code></td>
<td>
<p>character One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_name.tag">name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="Rfr_ratio_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default <code>quantity = "mean"</code> or
<code>quantity = "average"</code> the ratio is based on
two <strong>mean spectral reflectance</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{num})}{\overline{\mathrm{Rfr}_\lambda}(s, wb_\mathrm{denom}))}</code>
</p>

<p>If the argument is set to <code>quantity = "total"</code> the ratio is based on
two <strong>integrated reflectance</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\mathrm{Rfr}(s, wb_\mathrm{num})}{\mathrm{Rfr}(s, wb_\mathrm{denom})}</code>
</p>

<p>Only if the wavelength expanse of the two wavebands is the same, these two
ratios are numerically identical.
</p>


<h3>Value</h3>

<p>In the case of methods for individual spectra, a <code>numeric</code>
vector with name attribute set. The name is based on the name of the
wavebands unless a named list of wavebands is supplied in which case the
names of the list elements are used. &quot;[Rfr:Rfr]&quot; is appended if <code>quantity
  = "total"</code> and &quot;[Rfr(wl):Rfr(wl)]&quot; if <code>quantity = "mean"</code> or
<code>quantity = "average"</code>.
</p>
<p>A <code>data.frame</code> is returned in the case of collections of spectra,
containing one column for each fraction definition, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>Fraction definitions are &quot;assembled&quot; from the arguments passed to
<code>w.band.num</code> and <code>w.band.denom</code>. If both arguments are lists of
waveband definitions, with an equal number of members, then the wavebands
are paired to obtain as many fractions as the number of wavebands in each
list. Recycling for wavebands takes place when the number of denominator
and numerator wavebands differ.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>Rfr_ratio(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>Rfr_ratio(reflector_spct)</code>: Method for <code>reflector_spct</code> objects
</p>
</li>
<li> <p><code>Rfr_ratio(reflector_mspct)</code>: Calculates Rfr:Rfr from a <code>reflector_mspct</code>
object.
</p>
</li></ul>


<h3>Note</h3>

<p>The last two parameters control speed
optimizations. The defaults should be suitable in most cases. If you will
use repeatedly the same SWFs on many spectra measured at exactly the same
wavelengths you may obtain some speed up by setting
<code>use.cached.mult=TRUE</code>. However, be aware that you are responsible for
ensuring that the wavelengths are the same in each call, as the only test
done is for the length of the <code>w.length</code> vector.
</p>


<h3>See Also</h3>

<p>Other Reflectance ratio functions: 
<code><a href="#topic+Rfr_fraction">Rfr_fraction</a>()</code>,
<code><a href="#topic+Rfr_normdiff">Rfr_normdiff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rfr_ratio(Ler_leaf_rflt.spct,
          waveband(c(400,500), wb.name = "Blue"),
          waveband(c(600,700), wb.name = "Red"))
Rfr_ratio(Ler_leaf_rflt.spct,
          waveband(c(400,500), wb.name = "Blue"),
          waveband(c(600,700), wb.name = "Red"),
          quantity = "total")
Rfr_ratio(Ler_leaf_rflt.spct,
          waveband(c(400,500), wb.name = "Blue"),
          waveband(c(600,700), wb.name = "Red"),
          quantity = "mean")

</code></pre>

<hr>
<h2 id='rgb_spct'>RGB color values</h2><span id='topic+rgb_spct'></span>

<h3>Description</h3>

<p>This function returns the RGB values for a source spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgb_spct(spct, sens = photobiology::ciexyzCMF2.spct, color.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgb_spct_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;source_spct&quot;</p>
</td></tr>
<tr><td><code id="rgb_spct_+3A_sens">sens</code></td>
<td>
<p>a chroma_spct object with variables w.length, x, y, and z, giving
the CC or CMF definition (default is the proposed human CMF according to
CIE 2006.)</p>
</td></tr>
<tr><td><code id="rgb_spct_+3A_color.name">color.name</code></td>
<td>
<p>character string for naming the rgb color definition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A color defined using <code>rgb()</code>. The numeric values of the RGB
components can be obtained
</p>


<h3>See Also</h3>

<p>Other color functions: 
<code><a href="#topic+w_length2rgb">w_length2rgb</a>()</code>,
<code><a href="#topic+w_length_range2rgb">w_length_range2rgb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rgb_spct(sun.spct)

</code></pre>

<hr>
<h2 id='rmDerivedMspct'>Remove &quot;generic_mspct&quot; and derived class attributes.</h2><span id='topic+rmDerivedMspct'></span>

<h3>Description</h3>

<p>Removes from a spectrum object the class attributes &quot;generic_mspct&quot; and any
derived class attribute such as &quot;source_mspct&quot;. <strong>This operation is done
by reference!</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmDerivedMspct(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmDerivedMspct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the removed class attribute values.
This is different to the behaviour of function <code>unlist</code> in base R!
</p>


<h3>Note</h3>

<p>If <code>x</code> is an object of any of the multi spectral classes defined
in this package, this function changes by reference the multi spectrum
object into the underlying list object. Otherwise, it just leaves <code>x</code>
unchanged. The modified <code>x</code> is also returned invisibly.
</p>


<h3>See Also</h3>

<p>Other set and unset 'multi spectral' class functions: 
<code><a href="#topic+shared_member_class">shared_member_class</a>()</code>
</p>

<hr>
<h2 id='rmDerivedSpct'>Remove &quot;generic_spct&quot; and derived class attributes.</h2><span id='topic+rmDerivedSpct'></span>

<h3>Description</h3>

<p>Removes from a spectrum object the class attributes <code>"generic_spct"</code> and
any derived class attribute such as <code>"source_spct"</code>. <strong>This
operation is done by reference!</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmDerivedSpct(x, keep.classes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmDerivedSpct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="rmDerivedSpct_+3A_keep.classes">keep.classes</code></td>
<td>
<p>character vector Names of classes to keep. Can be used
to retain base class <code>"generic_spct"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function alters <code>x</code> itself by reference. If <code>x</code> is
not a <code>generic_spct</code> object, <code>x</code> is not modified. This function
behaves similarly to <code>setdiff()</code> but preserving the original order of
the character vector of the S3 class names.
</p>


<h3>Value</h3>

<p>A character vector containing the removed class attribute values.
This is different to the behaviour of function <code>unlist</code> in base R!
</p>


<h3>Note</h3>

<p>If <code>x</code> is an object of any of the spectral classes defined in this
package, this function changes by reference the spectrum object into the
underlying data.frame object. Otherwise, it just leaves <code>x</code> unchanged.
</p>


<h3>See Also</h3>

<p>Other set and unset spectral class functions: 
<code><a href="#topic+setGenericSpct">setGenericSpct</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.spct &lt;- sun.spct
removed &lt;- rmDerivedSpct(my.spct)
removed
class(sun.spct)
class(my.spct)

</code></pre>

<hr>
<h2 id='round'>Rounding of Numbers</h2><span id='topic+round'></span><span id='topic+round.generic_spct'></span><span id='topic+signif.generic_spct'></span><span id='topic+ceiling.generic_spct'></span><span id='topic+floor.generic_spct'></span><span id='topic+trunc.generic_spct'></span>

<h3>Description</h3>

<p><code>ceiling</code> takes a single numeric argument x and returns a numeric vector
containing the smallest integers not less than the corresponding elements of
x. \
<code>floor</code> takes a single numeric argument x and returns a numeric vector
containing the largest integers not greater than the corresponding elements
of x. \
<code>trunc</code> takes a single numeric argument x and returns a numeric vector
containing the integers formed by truncating the values in x toward 0. \
<code>round</code> rounds the values in its first argument to the specified number of
decimal places (default 0). \
<code>signif</code> rounds the values in its first argument to the specified number of
significant digits. \
The functions are applied to the spectral data, not the wavelengths. The
quantity in the spectrum to which the function is applied depends on the class
of <code>x</code> and the current value of output options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
round(x, digits = 0)

## S3 method for class 'generic_spct'
signif(x, digits = 6)

## S3 method for class 'generic_spct'
ceiling(x)

## S3 method for class 'generic_spct'
floor(x)

## S3 method for class 'generic_spct'
trunc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_+3A_x">x</code></td>
<td>
<p>an object of class &quot;generic_spct&quot; or a derived class.</p>
</td></tr>
<tr><td><code id="round_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places (round) or
significant digits (signif) to be used. Negative values are allowed (see
'Details').</p>
</td></tr>
<tr><td><code id="round_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other math operators and functions: 
<code><a href="#topic+MathFun">MathFun</a></code>,
<code><a href="#topic++5E.generic_spct">^.generic_spct</a>()</code>,
<code><a href="#topic+convolve_each">convolve_each</a>()</code>,
<code><a href="#topic+div-.generic_spct">div-.generic_spct</a></code>,
<code><a href="#topic+log">log</a>()</code>,
<code><a href="#topic+minus-.generic_spct">minus-.generic_spct</a></code>,
<code><a href="#topic+mod-.generic_spct">mod-.generic_spct</a></code>,
<code><a href="#topic+plus-.generic_spct">plus-.generic_spct</a></code>,
<code><a href="#topic+sign">sign</a>()</code>,
<code><a href="#topic+slash-.generic_spct">slash-.generic_spct</a></code>,
<code><a href="#topic+times-.generic_spct">times-.generic_spct</a></code>
</p>

<hr>
<h2 id='rowwise'>rowwise functions for collections of spectra</h2><span id='topic+rowwise'></span><span id='topic+rowwise_filter'></span><span id='topic+rowwise_source'></span><span id='topic+rowwise_response'></span><span id='topic+rowwise_reflector'></span><span id='topic+rowwise_calibration'></span><span id='topic+rowwise_cps'></span><span id='topic+rowwise_raw'></span>

<h3>Description</h3>

<p>Private methods for collections of spectra. Applies a function at each wavelength
across all the spectra in the collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowwise_filter(
  x,
  .fun,
  col.name.tag = "",
  .fun.name = "Summary of",
  w.length.out = NULL,
  ...
)

rowwise_source(
  x,
  .fun,
  col.name.tag = "",
  .fun.name = "Summary of",
  w.length.out = NULL,
  ...
)

rowwise_response(
  x,
  .fun,
  col.name.tag = "",
  .fun.name = "Summary of",
  w.length.out = NULL,
  ...
)

rowwise_reflector(
  x,
  .fun,
  col.name.tag = "",
  .fun.name = "Summary of",
  w.length.out = NULL,
  ...
)

rowwise_calibration(
  x,
  .fun,
  col.name.tag = "",
  .fun.name = "Summary of",
  w.length.out = NULL,
  ...
)

rowwise_cps(
  x,
  .fun,
  col.name.tag = "",
  .fun.name = "Summary of",
  w.length.out = NULL,
  ...
)

rowwise_raw(
  x,
  .fun,
  col.name.tag = "",
  .fun.name = "Summary of",
  w.length.out = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowwise_+3A_x">x</code></td>
<td>
<p>An R object. Currently this package defines methods for collections of
spectral objects.</p>
</td></tr>
<tr><td><code id="rowwise_+3A_.fun">.fun</code></td>
<td>
<p>An R function or a list of functions.</p>
</td></tr>
<tr><td><code id="rowwise_+3A_col.name.tag">col.name.tag</code></td>
<td>
<p>character Vector of extensions to paste to default column
name for the output from each of the functions. If <code>col.name.tag[1] != ""</code>,
this forces the return of an object of class <code>"generic_spct"</code>.</p>
</td></tr>
<tr><td><code id="rowwise_+3A_.fun.name">.fun.name</code></td>
<td>
<p>character string used to set what.measured attribute.</p>
</td></tr>
<tr><td><code id="rowwise_+3A_w.length.out">w.length.out</code></td>
<td>
<p>numeric vector of wavelengths (nanometres).</p>
</td></tr>
<tr><td><code id="rowwise_+3A_...">...</code></td>
<td>
<p>Arguments passed to .fun.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Omission of NAs is done separately at each wavelength. Interpolation is
applied, so spectra in <code>x</code> do not need to share the same set of
wavelengths. When defining
new public functions using these utility functions make sure to return data
that is valid for the class of spectral object returned!!
</p>
<p>Objects of classes <code>raw_spct</code> and <code>cps_spct</code> can contain data
from multiple scans acquired with the same instrument, thus at the same set
of wave lengths.
</p>

<hr>
<h2 id='s_e_irrad2rgb'>Spectral irradiance to rgb color conversion</h2><span id='topic+s_e_irrad2rgb'></span>

<h3>Description</h3>

<p>Calculates rgb values from spectra based on human color matching functions
(CMF) or chromaticity coordinates (CC). A CMF takes into account luminous
sensitivity, while a CC only the color hue. This function, in contrast to
that in package pavo does not normalize the values to equal luminosity, so
using a CMF as input gives the expected result. Another difference is that it
allows the user to choose the chromaticity data to be used. The data used by
default is different, and it corresponds to the whole range of CIE standard,
rather than the reduced range 400 nm to 700 nm. The wavelength limits are not
hard coded, so the function could be used to simulate vision in other
organisms as long as pseudo CMF or CC data are available for the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_e_irrad2rgb(
  w.length,
  s.e.irrad,
  sens = photobiology::ciexyzCMF2.spct,
  color.name = NULL,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_e_irrad2rgb_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths (nm).</p>
</td></tr>
<tr><td><code id="s_e_irrad2rgb_+3A_s.e.irrad">s.e.irrad</code></td>
<td>
<p>numeric vector of spectral irradiance values.</p>
</td></tr>
<tr><td><code id="s_e_irrad2rgb_+3A_sens">sens</code></td>
<td>
<p>a chroma_spct object with variables w.length, x, y, and z, giving
the CC or CMF definition (default is the proposed human CMF according to
CIE 2006.).</p>
</td></tr>
<tr><td><code id="s_e_irrad2rgb_+3A_color.name">color.name</code></td>
<td>
<p>character string for naming the rgb color definition.</p>
</td></tr>
<tr><td><code id="s_e_irrad2rgb_+3A_check">check</code></td>
<td>
<p>logical indicating whether to check or not spectral data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A color defined using <code><a href="grDevices.html#topic+rgb">rgb</a></code>. The numeric
values of the RGB components can be obtained using function
<code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>.
</p>


<h3>Note</h3>

<p>Very heavily modified from Chad Eliason's
<a href="mailto:cme16@zips.uakron.edu">cme16@zips.uakron.edu</a> spec2rgb function in package <code>Pavo</code>.
</p>


<h3>References</h3>

<p>CIE(1932). Commission Internationale de l'Eclairage Proceedings,
1931. Cambridge: Cambridge University Press.
</p>
<p>Color matching functions obtained from Colour and Vision Research
Laboratory online data repository at <a href="http://www.cvrl.org/">http://www.cvrl.org/</a>.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.color &lt;-
    with(sun.data,
         s_e_irrad2rgb(w.length, s.e.irrad, color.name = "sunWhite"))
col2rgb(my.color)

</code></pre>

<hr>
<h2 id='s_mean'>Mean from collection of spectra</h2><span id='topic+s_mean'></span><span id='topic+s_mean.default'></span><span id='topic+s_mean.source_mspct'></span><span id='topic+s_mean.response_mspct'></span><span id='topic+s_mean.filter_mspct'></span><span id='topic+s_mean.reflector_mspct'></span><span id='topic+s_mean.calibration_mspct'></span><span id='topic+s_mean.cps_mspct'></span><span id='topic+s_mean.raw_mspct'></span>

<h3>Description</h3>

<p>A method to compute the mean of values across members of a collections of
spectra. Computes the mean at each wavelength across all the spectra in the
collection returning a spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_mean(x, trim, na.rm, ...)

## Default S3 method:
s_mean(x, trim = 0, na.rm = FALSE, ...)

## S3 method for class 'source_mspct'
s_mean(x, trim = 0, na.rm = FALSE, ...)

## S3 method for class 'response_mspct'
s_mean(x, trim = 0, na.rm = FALSE, ...)

## S3 method for class 'filter_mspct'
s_mean(x, trim = 0, na.rm = FALSE, ...)

## S3 method for class 'reflector_mspct'
s_mean(x, trim = 0, na.rm = FALSE, ...)

## S3 method for class 'calibration_mspct'
s_mean(x, trim = 0, na.rm = FALSE, ...)

## S3 method for class 'cps_mspct'
s_mean(x, trim = 0, na.rm = FALSE, ...)

## S3 method for class 'raw_mspct'
s_mean(x, trim = 0, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_mean_+3A_x">x</code></td>
<td>
<p>An R object Currently this package defines methods for collections of
spectral objects.</p>
</td></tr>
<tr><td><code id="s_mean_+3A_trim">trim</code></td>
<td>
<p>numeric The fraction (0 to 0.5) of observations to be trimmed from
each end of x before the mean is computed. Values of trim outside that
range are taken as the nearest endpoint.</p>
</td></tr>
<tr><td><code id="s_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>logical A value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="s_mean_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a collection spectral of objects, such as a
&quot;filter_mspct&quot; object, the returned object is of same class as the
members of the collection, such as &quot;filter_spct&quot;, containing the mean
spectrum.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>s_mean(default)</code>: 
</p>
</li>
<li> <p><code>s_mean(source_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean(response_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean(calibration_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean(raw_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Trimming of extreme values and omission of NAs is done separately at
each wavelength. Interpolation is not applied, so all spectra in <code>x</code>
must share the same set of wavelengths.
</p>
<p>Objects of classes raw_spct and cps_spct can contain data from multiple
scans. This functions are implemented for these classes only for the case
when all member spectra contain data for a single scan, or spliced into a
single column in the case of cps_spct members.
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+mean">mean</a></code> for the <code>mean()</code> method used for
the computations.
</p>

<hr>
<h2 id='s_mean_se'>Mean and standard error from collection of spectra</h2><span id='topic+s_mean_se'></span><span id='topic+s_mean_se.default'></span><span id='topic+s_mean_se.filter_mspct'></span><span id='topic+s_mean_se.source_mspct'></span><span id='topic+s_mean_se.response_mspct'></span><span id='topic+s_mean_se.reflector_mspct'></span><span id='topic+s_mean_se.calibration_mspct'></span><span id='topic+s_mean_se.cps_mspct'></span><span id='topic+s_mean_se.raw_mspct'></span>

<h3>Description</h3>

<p>A method to compute the mean of values across members of a collections of
spectra. Computes the mean at each wavelength across all the spectra in the
collection returning a spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_mean_se(x, na.rm, mult, ...)

## Default S3 method:
s_mean_se(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'filter_mspct'
s_mean_se(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'source_mspct'
s_mean_se(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'response_mspct'
s_mean_se(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'reflector_mspct'
s_mean_se(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'calibration_mspct'
s_mean_se(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'cps_mspct'
s_mean_se(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'raw_mspct'
s_mean_se(x, na.rm = FALSE, mult = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_mean_se_+3A_x">x</code></td>
<td>
<p>An R object Currently this package defines methods for collections of
spectral objects.</p>
</td></tr>
<tr><td><code id="s_mean_se_+3A_na.rm">na.rm</code></td>
<td>
<p>logical A value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="s_mean_se_+3A_mult">mult</code></td>
<td>
<p>numeric number of multiples of standard error.</p>
</td></tr>
<tr><td><code id="s_mean_se_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a collection spectral of objects, such as a
&quot;filter_mspct&quot; object, the returned object is of same class as the
members of the collection, such as &quot;filter_spct&quot;, containing the mean
spectrum.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>s_mean_se(default)</code>: 
</p>
</li>
<li> <p><code>s_mean_se(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean_se(source_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean_se(response_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean_se(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean_se(calibration_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean_se(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean_se(raw_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Trimming of extreme values and omission of NAs is done separately at
each wavelength. Interpolation is not applied, so all spectra in <code>x</code>
must share the same set of wavelengths.
</p>
<p>Objects of classes raw_spct and cps_spct can contain data from multiple
scans. This functions are implemented for these classes only for the case
when all member spectra contain data for a single scan, or spliced into a
single column in the case of cps_spct members.
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+mean">mean</a></code> for the <code>mean()</code> method used for
the computations.
</p>

<hr>
<h2 id='s_mean_se_band'>Mean plus and minus standard error from collection of spectra</h2><span id='topic+s_mean_se_band'></span><span id='topic+s_mean_se_band.default'></span><span id='topic+s_mean_se_band.filter_mspct'></span><span id='topic+s_mean_se_band.source_mspct'></span><span id='topic+s_mean_se_band.response_mspct'></span><span id='topic+s_mean_se_band.reflector_mspct'></span><span id='topic+s_mean_se_band.calibration_mspct'></span><span id='topic+s_mean_se_band.cps_mspct'></span><span id='topic+s_mean_se_band.raw_mspct'></span>

<h3>Description</h3>

<p>A method to compute the mean of values and se across members of a collections
of spectra. Computes the mean at each wavelength across all the spectra in
the collection returning a spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_mean_se_band(x, na.rm, mult, ...)

## Default S3 method:
s_mean_se_band(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'filter_mspct'
s_mean_se_band(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'source_mspct'
s_mean_se_band(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'response_mspct'
s_mean_se_band(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'reflector_mspct'
s_mean_se_band(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'calibration_mspct'
s_mean_se_band(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'cps_mspct'
s_mean_se_band(x, na.rm = FALSE, mult = 1, ...)

## S3 method for class 'raw_mspct'
s_mean_se_band(x, na.rm = FALSE, mult = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_mean_se_band_+3A_x">x</code></td>
<td>
<p>An R object Currently this package defines methods for collections of
spectral objects.</p>
</td></tr>
<tr><td><code id="s_mean_se_band_+3A_na.rm">na.rm</code></td>
<td>
<p>logical A value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="s_mean_se_band_+3A_mult">mult</code></td>
<td>
<p>numeric number of multiples of standard error.</p>
</td></tr>
<tr><td><code id="s_mean_se_band_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a collection spectral of objects, such as a
&quot;filter_mspct&quot; object, the returned object is of same class as the
members of the collection, such as &quot;filter_spct&quot;, containing the mean
spectrum.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>s_mean_se_band(default)</code>: 
</p>
</li>
<li> <p><code>s_mean_se_band(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean_se_band(source_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean_se_band(response_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean_se_band(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean_se_band(calibration_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean_se_band(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>s_mean_se_band(raw_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Trimming of extreme values and omission of NAs is done separately at
each wavelength. Interpolation is not applied, so all spectra in <code>x</code>
must share the same set of wavelengths.
</p>
<p>Objects of classes raw_spct and cps_spct can contain data from multiple
scans. This functions are implemented for these classes only for the case
when all member spectra contain data for a single scan, or spliced into a
single column in the case of cps_spct members.
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+mean">mean</a></code> for the <code>mean()</code> method used for
the computations.
</p>

<hr>
<h2 id='s_median'>Median of a collection of spectra</h2><span id='topic+s_median'></span><span id='topic+s_median.default'></span><span id='topic+s_median.source_mspct'></span><span id='topic+s_median.response_mspct'></span><span id='topic+s_median.filter_mspct'></span><span id='topic+s_median.reflector_mspct'></span><span id='topic+s_median.calibration_mspct'></span><span id='topic+s_median.cps_mspct'></span><span id='topic+s_median.raw_mspct'></span>

<h3>Description</h3>

<p>A method to compute the median of values across members of a collections of
spectra. Computes the median at each wavelength across all the spectra in the
collection returning a spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_median(x, na.rm, ...)

## Default S3 method:
s_median(x, na.rm = FALSE, ...)

## S3 method for class 'source_mspct'
s_median(x, na.rm = FALSE, ...)

## S3 method for class 'response_mspct'
s_median(x, na.rm = FALSE, ...)

## S3 method for class 'filter_mspct'
s_median(x, na.rm = FALSE, ...)

## S3 method for class 'reflector_mspct'
s_median(x, na.rm = FALSE, ...)

## S3 method for class 'calibration_mspct'
s_median(x, na.rm = FALSE, ...)

## S3 method for class 'cps_mspct'
s_median(x, na.rm = FALSE, ...)

## S3 method for class 'raw_mspct'
s_median(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_median_+3A_x">x</code></td>
<td>
<p>An R object. Currently this package defines methods for collections
of spectral objects.</p>
</td></tr>
<tr><td><code id="s_median_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. A value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="s_median_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a collection spectral of objects, such as a
&quot;filter_mspct&quot; object, the returned object is of same class as the members
of the collection, such as &quot;filter_spct&quot;, containing the median spectrum.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>s_median(default)</code>: 
</p>
</li>
<li> <p><code>s_median(source_mspct)</code>: 
</p>
</li>
<li> <p><code>s_median(response_mspct)</code>: 
</p>
</li>
<li> <p><code>s_median(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>s_median(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>s_median(calibration_mspct)</code>: 
</p>
</li>
<li> <p><code>s_median(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>s_median(raw_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Omission of NAs is done separately at each wavelength. Interpolation is
not applied, so all spectra in <code>x</code> must share the same set of
wavelengths.
</p>
<p>Objects of classes raw_spct and cps_spct can contain data from multiple
scans. This functions are implemented for these classes only for the case
when all member spectra contain data for a single scan, or spliced into a
single column in the case of cps_spct members.
</p>


<h3>See Also</h3>

<p>See <code><a href="stats.html#topic+median">median</a></code> for the <code>median()</code> method used
for the computations.
</p>

<hr>
<h2 id='s_prod'>Product from collection of spectra</h2><span id='topic+s_prod'></span><span id='topic+s_prod.default'></span><span id='topic+s_prod.source_mspct'></span><span id='topic+s_prod.response_mspct'></span><span id='topic+s_prod.filter_mspct'></span><span id='topic+s_prod.reflector_mspct'></span><span id='topic+s_prod.calibration_mspct'></span><span id='topic+s_prod.cps_mspct'></span><span id='topic+s_prod.raw_mspct'></span>

<h3>Description</h3>

<p>A method to compute the product of values across members of a collections of
spectra. Computes the product at each wavelength across all the spectra in the
collection returning a spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_prod(x, na.rm, ...)

## Default S3 method:
s_prod(x, na.rm = FALSE, ...)

## S3 method for class 'source_mspct'
s_prod(x, na.rm = FALSE, ...)

## S3 method for class 'response_mspct'
s_prod(x, na.rm = FALSE, ...)

## S3 method for class 'filter_mspct'
s_prod(x, na.rm = FALSE, ...)

## S3 method for class 'reflector_mspct'
s_prod(x, na.rm = FALSE, ...)

## S3 method for class 'calibration_mspct'
s_prod(x, na.rm = FALSE, ...)

## S3 method for class 'cps_mspct'
s_prod(x, na.rm = FALSE, ...)

## S3 method for class 'raw_mspct'
s_prod(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_prod_+3A_x">x</code></td>
<td>
<p>An R object. Currently this package defines methods for collections of
spectral objects.</p>
</td></tr>
<tr><td><code id="s_prod_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. A value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="s_prod_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a collection spectral of objects, such as a
&quot;filter_mspct&quot; object, the returned object is of same class as the
members of the collection, such as &quot;filter_spct&quot;, containing the product
of the spectra.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>s_prod(default)</code>: 
</p>
</li>
<li> <p><code>s_prod(source_mspct)</code>: 
</p>
</li>
<li> <p><code>s_prod(response_mspct)</code>: 
</p>
</li>
<li> <p><code>s_prod(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>s_prod(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>s_prod(calibration_mspct)</code>: 
</p>
</li>
<li> <p><code>s_prod(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>s_prod(raw_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Omission of NAs is done separately at each wavelength. Interpolation is
not applied, so all spectra in <code>x</code> must share the same set of
wavelengths.
</p>
<p>A product of spectral irradiance or spectral response is no longer a well
defined physical quanttiy, and these product operations return an object of
class generic_spct.
</p>
<p>Objects of classes raw_spct and cps_spct can contain data from multiple
scans. This functions are implemented for these classes only for the case
when all member spectra contain data for a single scan, or spliced into a
single column in the case of cps_spct members.
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+prod">prod</a></code> for the <code>prod()</code> method used for
the computations.
</p>

<hr>
<h2 id='s_range'>Range of a collection of spectra</h2><span id='topic+s_range'></span><span id='topic+s_range.default'></span><span id='topic+s_range.filter_mspct'></span><span id='topic+s_range.source_mspct'></span><span id='topic+s_range.response_mspct'></span><span id='topic+s_range.reflector_mspct'></span><span id='topic+s_range.calibration_mspct'></span><span id='topic+s_range.cps_mspct'></span><span id='topic+s_range.raw_mspct'></span>

<h3>Description</h3>

<p>A method to compute the range of values across members of a collections of
spectra. Computes the max and min at each wavelength across all the spectra
in the collection returning a spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_range(x, na.rm, ...)

## Default S3 method:
s_range(x, na.rm = FALSE, ...)

## S3 method for class 'filter_mspct'
s_range(x, na.rm = FALSE, ...)

## S3 method for class 'source_mspct'
s_range(x, na.rm = FALSE, ...)

## S3 method for class 'response_mspct'
s_range(x, na.rm = FALSE, ...)

## S3 method for class 'reflector_mspct'
s_range(x, na.rm = FALSE, ...)

## S3 method for class 'calibration_mspct'
s_range(x, na.rm = FALSE, ...)

## S3 method for class 'cps_mspct'
s_range(x, na.rm = FALSE, ...)

## S3 method for class 'raw_mspct'
s_range(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_range_+3A_x">x</code></td>
<td>
<p>An R object. Currently this package defines methods for collections of
spectral objects.</p>
</td></tr>
<tr><td><code id="s_range_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. A value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="s_range_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a collection spectral of objects, such as a
&quot;filter_mspct&quot; object, the returned object is of same class as the
members of the collection, such as &quot;filter_spct&quot;, containing the mean
spectrum.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>s_range(default)</code>: 
</p>
</li>
<li> <p><code>s_range(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>s_range(source_mspct)</code>: 
</p>
</li>
<li> <p><code>s_range(response_mspct)</code>: 
</p>
</li>
<li> <p><code>s_range(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>s_range(calibration_mspct)</code>: 
</p>
</li>
<li> <p><code>s_range(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>s_range(raw_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Trimming of extreme values and omission of NAs is done separately at
each wavelength. Interpolation is not applied, so all spectra in <code>x</code>
must share the same set of wavelengths.
</p>
<p>Objects of classes raw_spct and cps_spct can contain data from multiple
scans. This functions are implemented for these classes only for the case
when all member spectra contain data for a single scan, or spliced into a
single column in the case of cps_spct members.
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+Extremes">Extremes</a></code> details on the <code>min()</code> and
<code>max()</code> methods used for the computations.
</p>

<hr>
<h2 id='s_sd'>Standard Deviation of a collection of spectra</h2><span id='topic+s_sd'></span><span id='topic+s_sd.default'></span><span id='topic+s_sd.filter_mspct'></span><span id='topic+s_sd.source_mspct'></span><span id='topic+s_sd.response_mspct'></span><span id='topic+s_sd.reflector_mspct'></span><span id='topic+s_sd.calibration_mspct'></span><span id='topic+s_sd.cps_mspct'></span><span id='topic+s_sd.raw_mspct'></span>

<h3>Description</h3>

<p>A method to compute the standard deviation of values across members of a
collections of spectra. Computes the standard deviation at each wavelength
across all the spectra in the collection returning a spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_sd(x, na.rm, ...)

## Default S3 method:
s_sd(x, na.rm = FALSE, ...)

## S3 method for class 'filter_mspct'
s_sd(x, na.rm = FALSE, ...)

## S3 method for class 'source_mspct'
s_sd(x, na.rm = FALSE, ...)

## S3 method for class 'response_mspct'
s_sd(x, na.rm = FALSE, ...)

## S3 method for class 'reflector_mspct'
s_sd(x, na.rm = FALSE, ...)

## S3 method for class 'calibration_mspct'
s_sd(x, na.rm = FALSE, ...)

## S3 method for class 'cps_mspct'
s_sd(x, na.rm = FALSE, ...)

## S3 method for class 'raw_mspct'
s_sd(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_sd_+3A_x">x</code></td>
<td>
<p>An R object. Currently this package defines methods for collections
of spectral objects.</p>
</td></tr>
<tr><td><code id="s_sd_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. A value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="s_sd_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a collection spectral of objects, such as a
&quot;filter_mspct&quot; object, the returned object is of class &quot;generic_spct&quot;,
containing the standard deviation among the spectra at each wavelength
in a column with name ending in &quot;.sd&quot;.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>s_sd(default)</code>: 
</p>
</li>
<li> <p><code>s_sd(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>s_sd(source_mspct)</code>: 
</p>
</li>
<li> <p><code>s_sd(response_mspct)</code>: 
</p>
</li>
<li> <p><code>s_sd(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>s_sd(calibration_mspct)</code>: 
</p>
</li>
<li> <p><code>s_sd(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>s_sd(raw_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Omission of NAs is done separately at each wavelength. Interpolation is
not applied, so all spectra in <code>x</code> must share the same set of
wavelengths.
</p>
<p>Objects of classes raw_spct and cps_spct can contain data from multiple
scans. This functions are implemented for these classes only for the case
when all member spectra contain data for a single scan, or spliced into a
single column in the case of cps_spct members.
</p>


<h3>See Also</h3>

<p>See <code><a href="stats.html#topic+sd">sd</a></code> for details about <code>sd()</code> methods
for other classes.
</p>

<hr>
<h2 id='s_se'>Standard Error of a collection of spectra</h2><span id='topic+s_se'></span><span id='topic+s_se.default'></span><span id='topic+s_se.source_mspct'></span><span id='topic+s_se.response_mspct'></span><span id='topic+s_se.filter_mspct'></span><span id='topic+s_se.reflector_mspct'></span><span id='topic+s_se.calibration_mspct'></span><span id='topic+s_se.cps_mspct'></span><span id='topic+s_se.raw_mspct'></span>

<h3>Description</h3>

<p>A method to compute the standard error of values across members of a
collections of spectra. Computes the standard error at each wavelength
across all the spectra in the collection returning a spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_se(x, na.rm, ...)

## Default S3 method:
s_se(x, na.rm = FALSE, ...)

## S3 method for class 'source_mspct'
s_se(x, na.rm = FALSE, ...)

## S3 method for class 'response_mspct'
s_se(x, na.rm = FALSE, ...)

## S3 method for class 'filter_mspct'
s_se(x, na.rm = FALSE, ...)

## S3 method for class 'reflector_mspct'
s_se(x, na.rm = FALSE, ...)

## S3 method for class 'calibration_mspct'
s_se(x, na.rm = FALSE, ...)

## S3 method for class 'cps_mspct'
s_se(x, na.rm = FALSE, ...)

## S3 method for class 'raw_mspct'
s_se(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_se_+3A_x">x</code></td>
<td>
<p>An R object. Currently this package defines methods for collections
of spectral objects.</p>
</td></tr>
<tr><td><code id="s_se_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. A value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="s_se_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a collection spectral of objects, such as a
&quot;filter_mspct&quot; object, the returned object is of class &quot;generic_spct&quot;,
containing the standard error among the spectra at each wavelength
in a column with name ending in &quot;.se&quot;.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>s_se(default)</code>: 
</p>
</li>
<li> <p><code>s_se(source_mspct)</code>: 
</p>
</li>
<li> <p><code>s_se(response_mspct)</code>: 
</p>
</li>
<li> <p><code>s_se(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>s_se(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>s_se(calibration_mspct)</code>: 
</p>
</li>
<li> <p><code>s_se(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>s_se(raw_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Omission of NAs is done separately at each wavelength. Interpolation is
not applied, so all spectra in <code>x</code> must share the same set of
wavelengths.
</p>
<p>Objects of classes raw_spct and cps_spct can contain data from multiple
scans. This functions are implemented for these classes only for the case
when all member spectra contain data for a single scan, or spliced into a
single column in the case of cps_spct members.
</p>

<hr>
<h2 id='s_sum'>Sum from collection of spectra</h2><span id='topic+s_sum'></span><span id='topic+s_sum.default'></span><span id='topic+s_sum.filter_mspct'></span><span id='topic+s_sum.source_mspct'></span><span id='topic+s_sum.response_mspct'></span><span id='topic+s_sum.reflector_mspct'></span><span id='topic+s_sum.calibration_mspct'></span><span id='topic+s_sum.cps_mspct'></span><span id='topic+s_sum.raw_mspct'></span>

<h3>Description</h3>

<p>A method to compute the sum of values across members of a collections of
spectra. Computes the sum at each wavelength across all the spectra in the
collection returning a spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_sum(x, na.rm, ...)

## Default S3 method:
s_sum(x, na.rm = FALSE, ...)

## S3 method for class 'filter_mspct'
s_sum(x, na.rm = FALSE, ...)

## S3 method for class 'source_mspct'
s_sum(x, na.rm = FALSE, ...)

## S3 method for class 'response_mspct'
s_sum(x, na.rm = FALSE, ...)

## S3 method for class 'reflector_mspct'
s_sum(x, na.rm = FALSE, ...)

## S3 method for class 'calibration_mspct'
s_sum(x, na.rm = FALSE, ...)

## S3 method for class 'cps_mspct'
s_sum(x, na.rm = FALSE, ...)

## S3 method for class 'raw_mspct'
s_sum(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_sum_+3A_x">x</code></td>
<td>
<p>An R object. Currently this package defines methods for collections of
spectral objects.</p>
</td></tr>
<tr><td><code id="s_sum_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. A value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="s_sum_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a collection spectral of objects, such as a
&quot;filter_mspct&quot; object, the returned object is of same class as the
members of the collection, such as &quot;filter_spct&quot;, containing the sum
of the spectra.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>s_sum(default)</code>: 
</p>
</li>
<li> <p><code>s_sum(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>s_sum(source_mspct)</code>: 
</p>
</li>
<li> <p><code>s_sum(response_mspct)</code>: 
</p>
</li>
<li> <p><code>s_sum(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>s_sum(calibration_mspct)</code>: 
</p>
</li>
<li> <p><code>s_sum(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>s_sum(raw_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Omission of NAs is done separately at each wavelength. Interpolation is
not applied, so all spectra in <code>x</code> must share the same set of
wavelengths.
</p>
<p>A sum of transmitances or reflectances is no longer a well defined physical
quanttiy, and these sum operations return an object of class generic_spct.
</p>
<p>Objects of classes raw_spct and cps_spct can contain data from multiple
scans. This functions are implemented for these classes only for the case
when all member spectra contain data for a single scan, or spliced into a
single column in the case of cps_spct members.
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+sum">sum</a></code> for the <code>sum()</code> method used for
the computations.
</p>

<hr>
<h2 id='s_var'>Variance of a collection of spectra</h2><span id='topic+s_var'></span><span id='topic+s_var.default'></span><span id='topic+s_var.filter_mspct'></span><span id='topic+s_var.source_mspct'></span><span id='topic+s_var.response_mspct'></span><span id='topic+s_var.reflector_mspct'></span><span id='topic+s_var.calibration_mspct'></span><span id='topic+s_var.cps_mspct'></span><span id='topic+s_var.raw_mspct'></span>

<h3>Description</h3>

<p>A method to compute the variance of values across members of a collections of
spectra. Computes the variance at each wavelength across all the spectra in
the collection returning a spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_var(x, na.rm, ...)

## Default S3 method:
s_var(x, na.rm = FALSE, ...)

## S3 method for class 'filter_mspct'
s_var(x, na.rm = FALSE, ...)

## S3 method for class 'source_mspct'
s_var(x, na.rm = FALSE, ...)

## S3 method for class 'response_mspct'
s_var(x, na.rm = FALSE, ...)

## S3 method for class 'reflector_mspct'
s_var(x, na.rm = FALSE, ...)

## S3 method for class 'calibration_mspct'
s_var(x, na.rm = FALSE, ...)

## S3 method for class 'cps_mspct'
s_var(x, na.rm = FALSE, ...)

## S3 method for class 'raw_mspct'
s_var(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_var_+3A_x">x</code></td>
<td>
<p>An R object. Currently this package defines methods for collections
of spectral objects.</p>
</td></tr>
<tr><td><code id="s_var_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. A value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="s_var_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variance method for collections of spectra. Computes the variance at each
wavelength across all the spectra in the collection.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a collection spectral of objects, such as a
&quot;filter_mspct&quot; object, the returned object is of class &quot;generic_spct&quot;,
containing the variance among the spectra at each wavelength
in a column with name ending in &quot;.var&quot;.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>s_var(default)</code>: 
</p>
</li>
<li> <p><code>s_var(filter_mspct)</code>: 
</p>
</li>
<li> <p><code>s_var(source_mspct)</code>: 
</p>
</li>
<li> <p><code>s_var(response_mspct)</code>: 
</p>
</li>
<li> <p><code>s_var(reflector_mspct)</code>: 
</p>
</li>
<li> <p><code>s_var(calibration_mspct)</code>: 
</p>
</li>
<li> <p><code>s_var(cps_mspct)</code>: 
</p>
</li>
<li> <p><code>s_var(raw_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Omission of NAs is done separately at each wavelength. Interpolation is
not applied, so all spectra in <code>x</code> must share the same set of
wavelengths.
</p>
<p>Objects of classes raw_spct and cps_spct can contain data from multiple
scans. This functions are implemented for these classes only for the case
when all member spectra contain data for a single scan, or spliced into a
single column in the case of cps_spct members.
</p>


<h3>See Also</h3>

<p>See <code><a href="stats.html#topic+cor">cor</a></code> for details about <code>var()</code>, which
is used for the computations.
</p>

<hr>
<h2 id='se'>Standard error of the mean</h2><span id='topic+se'></span>

<h3>Description</h3>

<p>Standard error of the mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(x, na.rm = FALSE, mult = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="se_+3A_mult">mult</code></td>
<td>
<p>numeric number of multiples of standard error</p>
</td></tr>
</table>


<h3>Note</h3>

<p>mult can be used to construct confidence intervals
</p>

<hr>
<h2 id='se.m'>Standard error of the mean</h2><span id='topic+se.m'></span>

<h3>Description</h3>

<p>Standard error of the mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se.m(x, na.rm = FALSE, mult = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se.m_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="se.m_+3A_mult">mult</code></td>
<td>
<p>numeric number of multiples of standard error</p>
</td></tr>
</table>


<h3>Note</h3>

<p>mult can be used to construct confidence intervals
</p>

<hr>
<h2 id='se.p'>Standard error of the mean</h2><span id='topic+se.p'></span>

<h3>Description</h3>

<p>Standard error of the mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se.p(x, na.rm = FALSE, mult = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se.p_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="se.p_+3A_mult">mult</code></td>
<td>
<p>numeric number of multiples of standard error</p>
</td></tr>
</table>


<h3>Note</h3>

<p>mult can be used to construct confidence intervals
</p>

<hr>
<h2 id='select_spct_attributes'>Merge user supplied attribute names with default ones</h2><span id='topic+select_spct_attributes'></span><span id='topic+spct_attributes'></span>

<h3>Description</h3>

<p>Allow users to add and subtract from default attributes in addition to
providing a given set of attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_spct_attributes(attributes, attributes.default = spct_attributes())

spct_attributes(.class = "all", attributes = "*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_spct_attributes_+3A_attributes">attributes</code>, <code id="select_spct_attributes_+3A_attributes.default">attributes.default</code></td>
<td>
<p>character vector or a list of character
vectors.</p>
</td></tr>
<tr><td><code id="select_spct_attributes_+3A_.class">.class</code></td>
<td>
<p>character Name of spectral class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectors of character strings passed as argument to <code>attributes</code>
are parsed so that if the first member string is <code>"+"</code>, the remaining
members are added to those in <code>attributes.default</code>; if it is
<code>"-"</code> the remaining members are removed from in
<code>attributes.default</code>; and if it is <code>"="</code> the remaining members
replace those in in <code>attributes.default</code>. If the first member is none
of these three strings, the behaviour is the same as when the first string
is <code>"="</code>. If <code>attributes</code> is <code>NULL</code> all the attributes in
<code>attributes.default</code> are used and if it is <code>""</code> no attribute
names are returned, <code>""</code> has precedence over other member values. The
order of the names of annotations has no meaning: the vector is interpreted
as a set except for the three possible &quot;operators&quot; at position 1.
</p>


<h3>Value</h3>

<p>A character vector of attribute names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_attributes">get_attributes</a></code>
</p>
<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>

<hr>
<h2 id='setBSWFUsed'>The &quot;bswf.used&quot; attribute</h2><span id='topic+setBSWFUsed'></span><span id='topic+getBSWFUsed'></span>

<h3>Description</h3>

<p>Function to set by reference the <code>"time.unit"</code> attribute of an
existing <code>source_spct object</code>, and function to query its value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setBSWFUsed(x, bswf.used = c("none", "unknown"))

getBSWFUsed(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setBSWFUsed_+3A_x">x</code></td>
<td>
<p>a source_spct object.</p>
</td></tr>
<tr><td><code id="setBSWFUsed_+3A_bswf.used">bswf.used</code></td>
<td>
<p>a character string, either <code>"none"</code> or the name of a
BSWF.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Effective spectral irradiance, describes an estimate of the strength of
the radiation towards eliciting a given response, frequently, but not only
a biological response. The biological spectral weighting function, BSWF,
used, can be for example that of the human eye, or an action spectrum,
such as the erythema, or reddening of the human skin, action spectrum.
</p>
<p style="text-align: center;"><code class="reqn">I_{BE}(\lambda) = I(\lambda) \times f_{BE}(\lambda)</code>
</p>

<p>where, <code class="reqn">I_{BE}(\lambda)</code> is the biologically effective spectral
irradiance, <code class="reqn">I(\lambda)</code> is the spectral irradiance
and <code class="reqn">f_{BE}(\lambda)</code> is one of many possible BSWF.
</p>
<p>When the values stored in a <code>source_spct</code> object have been multiplied
by those from a curve describing a certain response or effect, the
attribute <code>"time.unit"</code> is set accordingly to track the transformation
applied to the data. When a spectral response data have been directly measured,
they should be stored in an object of class <code>response_spct</code> as they
are expressed in actual response units, not
of class <code>source_spct</code> expressed in irradiance units, even if weighted.
However, when like in the case of spectral
illuminance, the aim is technical measure of a light source,
class <code>source_spct</code> should be used and the BSWF set in the metadata.
</p>
<p>This attribute is normally set by the function or operator used to apply
the BSWF to spectral irradiance data, or set when the <code>source_spct</code> object
is created.
</p>


<h3>Value</h3>

<p><code>x</code> or the <code>character</code> value stored in <code>x</code>.
</p>


<h3>Note</h3>

<p>Function <code>setBSWFUsed()</code> alters <code>x</code> itself by reference and in addition
returns <code>x</code> invisibly. If <code>x</code> is not a <code>source_spct</code>, <code>x</code> is not modified.
The behaviour of this function is 'unusual' in that the default for
parameter <code>bswf.used</code> is used only if <code>x</code> does not already have
this attribute set. Function <code>getBSWFUsed()</code> returns the value to
which the attribute is set as a <code>character</code> string and otherwise
<code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getBSWFUsed(sun.spct)

</code></pre>

<hr>
<h2 id='setFilterProperties'>Set the &quot;filter.properties&quot; attribute</h2><span id='topic+setFilterProperties'></span><span id='topic+filter_properties+3C-'></span>

<h3>Description</h3>

<p>Function to set by reference the &quot;filter.properties&quot; attribute  of an existing
filter_spct object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFilterProperties(
  x,
  filter.properties = NULL,
  pass.null = FALSE,
  Rfr.constant = NA_real_,
  thickness = NA_real_,
  attenuation.mode = NA_character_
)

filter_properties(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setFilterProperties_+3A_x">x</code></td>
<td>
<p>a filter_spct object</p>
</td></tr>
<tr><td><code id="setFilterProperties_+3A_filter.properties">filter.properties</code>, <code id="setFilterProperties_+3A_value">value</code></td>
<td>
<p>a list with fields named <code>"Rfr.constant"</code>,
<code>"thickness"</code> and <code>"attenuation.mode"</code>.</p>
</td></tr>
<tr><td><code id="setFilterProperties_+3A_pass.null">pass.null</code></td>
<td>
<p>logical If TRUE, the parameters to the next three
parameters will be always ignored, otherwise they will be used to
build an object of class <code>"filter.properties"</code> when the argument
passed to parameter <code>filter.properties</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="setFilterProperties_+3A_rfr.constant">Rfr.constant</code></td>
<td>
<p>numeric The value of the reflection factor [/1].</p>
</td></tr>
<tr><td><code id="setFilterProperties_+3A_thickness">thickness</code></td>
<td>
<p>numeric The thickness of the material [<code class="reqn">m</code>].</p>
</td></tr>
<tr><td><code id="setFilterProperties_+3A_attenuation.mode">attenuation.mode</code></td>
<td>
<p>character One of <code>"reflection"</code>, <code>"absorption"</code>,
<code>"absorption.layer"</code>, <code>"mixed"</code> or <code>"stack"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Storing filter properties allows inter-conversion between internal
and total transmittance, as well as computation of transmittance for
arbitrary thickness of the material. Whether computations are valid depend
on the homogeneity of the material. The parameter <code>pass.null</code> makes
it possible to remove the attribute.
</p>


<h3>Value</h3>

<p><code>x</code>
</p>


<h3>Note</h3>

<p>This function alters <code>x</code> itself by reference and in addition
returns <code>x</code> invisibly. If <code>x</code> is not a <code>filter_spct</code> object,
<code>x</code> is not modified.
</p>
<p>The values of <code>attenuation.mode</code> <code>"reflection"</code> and
<code>"absorption"</code> should be used when one of these processes is clearly
the main one; <code>"mixed"</code> is for cases when they both play a role, i.e.,
when a simple correction using a single value of <code>Rfr</code> across
wavelengths is not possible; <code>"absorption.layer"</code> is for cases when a
thin absorbing layer is deposited on the surface of a transparent support
or enclosed between two sheets of glass or other transparent material. If
in doubt, set this to <code>NA</code> to ensure that computation of spectra for a
different thickness remains disabled.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.spct &lt;- polyester.spct
filter_properties(my.spct)
filter_properties(my.spct) &lt;- NULL
filter_properties(my.spct)
filter_properties(my.spct, return.null = TRUE)
filter_properties(my.spct) &lt;- list(Rfr.constant = 0.01,
                                   thickness = 125e-6,
                                   attenuation.mode = "absorption")
filter_properties(my.spct)

</code></pre>

<hr>
<h2 id='setGenericSpct'>Convert an R object into a spectrum object.</h2><span id='topic+setGenericSpct'></span><span id='topic+setCalibrationSpct'></span><span id='topic+setRawSpct'></span><span id='topic+setCpsSpct'></span><span id='topic+setFilterSpct'></span><span id='topic+setSoluteSpct'></span><span id='topic+setReflectorSpct'></span><span id='topic+setObjectSpct'></span><span id='topic+setResponseSpct'></span><span id='topic+setSourceSpct'></span><span id='topic+setChromaSpct'></span>

<h3>Description</h3>

<p>Sets the class attribute of a data.frame or an object of a derived
class to &quot;generic_spct&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGenericSpct(x, multiple.wl = 1L, idfactor = NULL)

setCalibrationSpct(
  x,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

setRawSpct(
  x,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

setCpsSpct(
  x,
  time.unit = "second",
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

setFilterSpct(
  x,
  Tfr.type = c("total", "internal"),
  Rfr.constant = NA_real_,
  thickness = NA_real_,
  attenuation.mode = NA_character_,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

setSoluteSpct(
  x,
  K.type = c("attenuation", "absorption", "scattering"),
  name = NA_character_,
  mass = NA_character_,
  formula = NA_character_,
  structure = grDevices::as.raster(matrix()),
  ID = NA_character_,
  solvent.name = NA_character_,
  solvent.ID = NA_character_,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

setReflectorSpct(
  x,
  Rfr.type = c("total", "specular"),
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

setObjectSpct(
  x,
  Tfr.type = c("total", "internal"),
  Rfr.type = c("total", "specular"),
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

setResponseSpct(
  x,
  time.unit = "second",
  response.type = "response",
  multiple.wl = 1L,
  idfactor = NULL
)

setSourceSpct(
  x,
  time.unit = "second",
  bswf.used = c("none", "unknown"),
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

setChromaSpct(x, multiple.wl = 1L, idfactor = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setGenericSpct_+3A_x">x</code></td>
<td>
<p>data.frame, list or generic_spct and derived classes</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_multiple.wl">multiple.wl</code></td>
<td>
<p>numeric Maximum number of repeated <code>w.length</code> entries
with same value.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_idfactor">idfactor</code></td>
<td>
<p>character Name of factor distinguishing multiple spectra when
stored longitudinally (required if <code>mulitple.wl</code> &gt; 1).</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical Flag indicating whether off-range values result
in an error instead of a warning.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_time.unit">time.unit</code></td>
<td>
<p>character string indicating the time unit used for spectral
irradiance or exposure (<code>"second"</code>, <code>"day"</code> or <code>"exposure"</code>)
or an object of class duration as defined in package lubridate.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_tfr.type">Tfr.type</code></td>
<td>
<p>character Either &quot;total&quot; or &quot;internal&quot;.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_rfr.constant">Rfr.constant</code></td>
<td>
<p>numeric The value of the reflection factor [<code class="reqn">/1</code>].</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_thickness">thickness</code></td>
<td>
<p>numeric The thickness of the material.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_attenuation.mode">attenuation.mode</code></td>
<td>
<p>character One of <code>"reflection"</code>,
<code>"absorption"</code> or <code>"mixed"</code>.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_k.type">K.type</code></td>
<td>
<p>character A string, either &quot;attenuation&quot;, &quot;absorption&quot; or
&quot;scattering&quot;.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_name">name</code>, <code id="setGenericSpct_+3A_solvent.name">solvent.name</code></td>
<td>
<p>character The names of the substance and of the
solvent. A named character vector, with member names such as &quot;IUPAC&quot; for
the authority.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_mass">mass</code></td>
<td>
<p>numeric The mass in Dalton (Da = g/mol).</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_formula">formula</code></td>
<td>
<p>character The molecular formula.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_structure">structure</code></td>
<td>
<p>raster A bitmap of the structure.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_id">ID</code>, <code id="setGenericSpct_+3A_solvent.id">solvent.ID</code></td>
<td>
<p>character The IDs of the substance and of the solvent. A
named character vector, with member names such as &quot;ChemSpider&quot; or &quot;PubChen&quot;
for the authority.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_rfr.type">Rfr.type</code></td>
<td>
<p>character A string, either &quot;total&quot; or &quot;specular&quot;.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_response.type">response.type</code></td>
<td>
<p>a character string, either <code>"response"</code> or <code>"action"</code>.</p>
</td></tr>
<tr><td><code id="setGenericSpct_+3A_bswf.used">bswf.used</code></td>
<td>
<p>character A string, either <code>"none"</code> or the name of a
BSWF. (Users seldom need to change the default, as this metadata value
is in normal use set by operators or functions that apply a BSWF.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method alters <code>x</code> itself by reference and in addition
returns the modified <code>x</code> invisibly. The wavelength values and data are
checked for validity and out-of-range values trigger warnings. These checks
are done during construction by means of the matching
<code><a href="#topic+check_spct">check_spct</a></code> methods, unless checks have been disabled by
setting the corresponding option (see <code><a href="#topic+enable_check_spct">enable_check_spct</a></code>).
</p>


<h3>Value</h3>

<p>x
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>setCalibrationSpct()</code>: Set class of a an object to &quot;calibration_spct&quot;.
</p>
</li>
<li> <p><code>setRawSpct()</code>: Set class of a an object to &quot;raw_spct&quot;.
</p>
</li>
<li> <p><code>setCpsSpct()</code>: Set class of a an object to &quot;cps_spct&quot;.
</p>
</li>
<li> <p><code>setFilterSpct()</code>: Set class of an object to &quot;filter_spct&quot;.
</p>
</li>
<li> <p><code>setSoluteSpct()</code>: Set class of an object to &quot;solute_spct&quot;.
</p>
</li>
<li> <p><code>setReflectorSpct()</code>: Set class of a an object to &quot;reflector_spct&quot;.
</p>
</li>
<li> <p><code>setObjectSpct()</code>: Set class of an object to &quot;object_spct&quot;.
</p>
</li>
<li> <p><code>setResponseSpct()</code>: Set class of an object to &quot;response_spct&quot;.
</p>
</li>
<li> <p><code>setSourceSpct()</code>: Set class of an object to &quot;source_spct&quot;.
</p>
</li>
<li> <p><code>setChromaSpct()</code>: Set class of an object to &quot;chroma_spct&quot;.
</p>
</li></ul>


<h3>Warning!</h3>

<p>Not entering metadata when creating an object will limit
the available operations!
</p>


<h3>Note</h3>

<p><code>"internal"</code> <strong>transmittance</strong> is defined as the
transmittance of the material body itself, while <code>"total"</code>
transmittance includes the effects of surface reflectance on the amount of
light transmitted. For non-diffusing materials like glass an approximate
<code>Rfr.constant</code> value can be used to inter-convert total and internal
transmittance values. Use <code>NA</code> if the the mode is not known, or not
applicable, e.g., for materials subject to internal scattering. The
validity of computations related to thickness of the material or length of
the light path depends on the availability and accuracy of the metadata.
</p>
<p>Particles in suspension unlike dissolved <strong>solutes</strong> scatter light.
Thus two different processes can attenuate light in liquid media:
absorption and scattering. Coefficients of attenuation are always based on
measurements of internal absorbance or internal transmittance. In practice
this is achieved by using as reference pure solvent in a vessel, such as a
spectrometer cuvette, called <em>blank</em>. The measurement of the blank is
done sequentially, before or after the <em>sample</em> of interest in single
beam spectrophotometers and concurrently in double beam spectrophotometers.
<code>K.type</code> describes the process of attenuation: <code>"attenuation"</code>,
<code>"absorption"</code> or <code>"scattering"</code>, with <code>"attenuation"</code> used
for cases of mixed modes of attenuation. Set <code>K.type = NA</code> if not
available or unknown, or not applicable.
</p>
<p><code>"specular"</code> <strong>reflectance</strong> is defined as that measured by
collecting the light reflected by the surface at the &ldquo;mirror&rdquo; of the
angle of incidence; i.e., using a probe with a narrow angle of aperture.
Usually measured close to normal angle of incidence. <code>"total"</code>
<strong>reflectance</strong> is defined as that measured by collecting all the
light reflected by the surface; i.e., using an integrating sphere. In a
mirror, reflectance is mostly specular, while on the white surface of a
sheet of paper scattering predominates. In the first case the value for
total reflectance is not much more than for specular reflectance, while in
the second case the difference is much larger as the &quot;specular&quot; component
is much smaller.
</p>


<h3>See Also</h3>

<p>Other set and unset spectral class functions: 
<code><a href="#topic+rmDerivedSpct">rmDerivedSpct</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.df &lt;- data.frame(w.length = 300:309, s.e.irrad = rep(100, 10))
is.source_spct(my.df)
setSourceSpct(my.df)
is.source_spct(my.df)

</code></pre>

<hr>
<h2 id='setHowMeasured'>Set the &quot;how.measured&quot; attribute</h2><span id='topic+setHowMeasured'></span><span id='topic+how_measured+3C-'></span>

<h3>Description</h3>

<p>Function to set by reference the &quot;how.measured&quot; attribute  of an existing
generic_spct or derived-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setHowMeasured(x, how.measured)

how_measured(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setHowMeasured_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="setHowMeasured_+3A_how.measured">how.measured</code>, <code id="setHowMeasured_+3A_value">value</code></td>
<td>
<p>a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Note</h3>

<p>This function alters x itself by reference and in addition
returns x invisibly. If x is not a generic_spct object, x is not
modified.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.spct &lt;- sun.spct
how_measured(my.spct)
how_measured(my.spct) &lt;- "simulated with a radiation transfer model"
how_measured(my.spct)

</code></pre>

<hr>
<h2 id='setIdFactor'>Set the &quot;idfactor&quot; attribute</h2><span id='topic+setIdFactor'></span>

<h3>Description</h3>

<p>Function to set by reference the &quot;idfactor&quot; attribute  of an existing
generic_spct or an object of a class derived from generic_spct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setIdFactor(x, idfactor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setIdFactor_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="setIdFactor_+3A_idfactor">idfactor</code></td>
<td>
<p>character The name of a factor identifying multiple
spectra stored longitudinally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Note</h3>

<p>This function alters x itself by reference and in addition
returns x invisibly. If x is not a generic_spct or an object of a class derived from
generic_spct, x is not modified.
</p>


<h3>See Also</h3>

<p>Other idfactor attribute functions: 
<code><a href="#topic+getIdFactor">getIdFactor</a>()</code>
</p>

<hr>
<h2 id='setInstrDesc'>Set the &quot;instr.desc&quot; attribute</h2><span id='topic+setInstrDesc'></span>

<h3>Description</h3>

<p>Function to set by reference the &quot;instr.desc&quot; attribute  of an existing
generic_spct or derived-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setInstrDesc(x, instr.desc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setInstrDesc_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="setInstrDesc_+3A_instr.desc">instr.desc</code></td>
<td>
<p>a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Note</h3>

<p>This function alters x itself by reference and in addition
returns x invisibly. If x is not a generic_spct object, x is not
modified.
</p>
<p>The fields to be passed in the list <code>instr.desc</code> in part vary
depending on the instrument brand and model.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>

<hr>
<h2 id='setInstrSettings'>Set the &quot;instr.settings&quot; attribute</h2><span id='topic+setInstrSettings'></span>

<h3>Description</h3>

<p>Function to set by reference the &quot;what.measured&quot; attribute  of an existing
generic_spct or derived-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setInstrSettings(x, instr.settings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setInstrSettings_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="setInstrSettings_+3A_instr.settings">instr.settings</code></td>
<td>
<p>a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Note</h3>

<p>This function alters x itself by reference and in addition
returns x invisibly. If x is not a generic_spct object, x is not
modified.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>

<hr>
<h2 id='setKType'>Set the &quot;K.type&quot; attribute</h2><span id='topic+setKType'></span>

<h3>Description</h3>

<p>Function to set by reference the &quot;K.type&quot; attribute of an existing
solute_spct object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setKType(x, K.type = c("attenuation", "absorption", "scattering"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setKType_+3A_x">x</code></td>
<td>
<p>a solute_spct or a summary_solute_spct object.</p>
</td></tr>
<tr><td><code id="setKType_+3A_k.type">K.type</code></td>
<td>
<p>character A string, either &quot;attenuation&quot;, &quot;absorption&quot; or
&quot;scattering&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Note</h3>

<p>This function alters x itself by reference and in addition
returns x invisibly. If x is not a solute_spct object, x is not modified
The behaviour of this function is 'unusual' in that the default for
parameter <code>K.type</code> is used only if <code>x</code> does not already have
this attribute set.
</p>


<h3>See Also</h3>

<p>Other K attribute functions: 
<code><a href="#topic+getKType">getKType</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print("missing example")

</code></pre>

<hr>
<h2 id='setMultipleWl'>Set the &quot;multiple.wl&quot; attribute</h2><span id='topic+setMultipleWl'></span>

<h3>Description</h3>

<p>Function to set by reference the &quot;multiple.wl&quot; attribute  of an existing
generic_spct or an object of a class derived from generic_spct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMultipleWl(x, multiple.wl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMultipleWl_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="setMultipleWl_+3A_multiple.wl">multiple.wl</code></td>
<td>
<p>numeric &gt;= 1 If <code>multiple.wl</code> is <code>NULL</code>, the
default, the attribute is not modified if it is already present and valid,
and set to 1 otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Note</h3>

<p>This function alters x itself by reference and in addition
returns x invisibly. If x is not a generic_spct or an object of a class derived from
generic_spct, x is not modified. If <code>multiple.wl</code>
</p>


<h3>See Also</h3>

<p>Other multiple.wl attribute functions: 
<code><a href="#topic+getMultipleWl">getMultipleWl</a>()</code>
</p>

<hr>
<h2 id='setNormalized'>Set the &quot;normalized&quot; and &quot;normalization&quot; attributes</h2><span id='topic+setNormalized'></span><span id='topic+setNormalised'></span>

<h3>Description</h3>

<p>Function to write the &quot;normalized&quot; attribute of an existing generic_spct
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setNormalized(
  x,
  norm = FALSE,
  norm.type = NA_character_,
  norm.factors = NA_real_,
  norm.cols = NA_character_,
  norm.range = rep(NA_real_, 2),
  verbose = getOption("verbose_as_default", default = FALSE)
)

setNormalised(
  x,
  norm = FALSE,
  norm.type = NA_character_,
  norm.factors = NA_real_,
  norm.cols = NA_character_,
  norm.range = rep(NA_real_, 2),
  verbose = getOption("verbose_as_default", default = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setNormalized_+3A_x">x</code></td>
<td>
<p>a generic_spct object.</p>
</td></tr>
<tr><td><code id="setNormalized_+3A_norm">norm</code></td>
<td>
<p>numeric (or logical) Normalization wavelength (nanometres).</p>
</td></tr>
<tr><td><code id="setNormalized_+3A_norm.type">norm.type</code></td>
<td>
<p>character Type of normalization applied.</p>
</td></tr>
<tr><td><code id="setNormalized_+3A_norm.factors">norm.factors</code></td>
<td>
<p>numeric The scaling factor(s) so that dividing the spectral
values by this factor reverts the normalization.</p>
</td></tr>
<tr><td><code id="setNormalized_+3A_norm.cols">norm.cols</code></td>
<td>
<p>character The name(s) of the data columns normalized.</p>
</td></tr>
<tr><td><code id="setNormalized_+3A_norm.range">norm.range</code></td>
<td>
<p>numeric The wavelength range used for normalization (nm).</p>
</td></tr>
<tr><td><code id="setNormalized_+3A_verbose">verbose</code></td>
<td>
<p>logical Flag enabling or silencing informative warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function <strong>is used internally</strong>, although occasionally
users may want to use it to &quot;pretend&quot; that spectral data have not been
normalized. Use <code><a href="#topic+normalize">normalize</a>()</code> methods to apply a normalization
and set the attributes accordingly. Function <code>setNormalized()</code> only
sets the attributes that store the metadata corresponding to an already
applied normalization. Thus a trace of the transformations applied to
spectral data is kept, which currently is used to renormalize the spectra
when the quantity used for expression is changed with a conversion
function. It is also used in other packages like 'ggspectra' when
generating automatically axis labels. If <code>x</code> is not a
<code>generic_spct</code> object, <code>x</code> is not modified.
</p>


<h3>Note</h3>

<p>Passing a <code>logical</code> as argument to <code>norm</code> is deprecated
but accepted silently for backwards compatibility.
</p>
<p><code>setNormalised()</code> is a synonym for this <code>setNormalized()</code>
method.
</p>


<h3>See Also</h3>

<p>Other rescaling functions: 
<code><a href="#topic+fscale">fscale</a>()</code>,
<code><a href="#topic+fshift">fshift</a>()</code>,
<code><a href="#topic+getNormalized">getNormalized</a>()</code>,
<code><a href="#topic+getScaled">getScaled</a>()</code>,
<code><a href="#topic+is_normalized">is_normalized</a>()</code>,
<code><a href="#topic+is_scaled">is_scaled</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+setScaled">setScaled</a>()</code>
</p>

<hr>
<h2 id='setResponseType'>Set the &quot;response.type&quot; attribute</h2><span id='topic+setResponseType'></span><span id='topic+getResponseType'></span>

<h3>Description</h3>

<p>Functions to set by reference the <code>"response.type"</code> attribute of an
existing <code>response_spct</code> object, and to query its value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setResponseType(x, response.type = c("response", "action"))

getResponseType(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setResponseType_+3A_x">x</code></td>
<td>
<p>a response_spct object</p>
</td></tr>
<tr><td><code id="setResponseType_+3A_response.type">response.type</code></td>
<td>
<p>a character string, either &quot;response&quot; or &quot;action&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>response_spct()</code> can contain data for a response
spectrum or an action spectrum. Response spectra are measured using the
same photon (or energy) irradiance at each wavelength. Action spectra are
derived from dose response curves at each wavelength, and responsivity
at each wavelength is expressed as the reciprocal of the photon fluence
required to obtain a fixed level of response. In the case of biological
systems the action and response spectra frequently differ in their shape
and spectral values. This is a property inherent to a data set and not
subject to conversions, thus normally set when a <code>response_spct</code> object
is created and never modified.
</p>


<h3>Value</h3>

<p>x
</p>


<h3>Note</h3>

<p>This function alters x itself by reference and in addition returns x
invisibly. If x is not a response_spct object, x is not modified The
behaviour of this function is 'unusual' in that the default for parameter
<code>response.type</code> is used only if <code>x</code> does not already have this
attribute set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.spct &lt;- ccd.spct
setResponseType(my.spct, "action")
getResponseType(ccd.spct)
getResponseType(sun.spct)

</code></pre>

<hr>
<h2 id='setRfrType'>The &quot;Rfr.type&quot; attribute</h2><span id='topic+setRfrType'></span><span id='topic+getRfrType'></span>

<h3>Description</h3>

<p>Function to set by reference the <code>"Rfr.type"</code> attribute of an
existing <code>reflector_spct</code> or <code>object_spct</code> object, and function to
query its current status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setRfrType(x, Rfr.type = c("total", "specular"))

getRfrType(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setRfrType_+3A_x">x</code></td>
<td>
<p>a <code>reflector_spct</code> or an <code>object_spct</code> object.</p>
</td></tr>
<tr><td><code id="setRfrType_+3A_rfr.type">Rfr.type</code></td>
<td>
<p>character String, either <code>"total"</code> or <code>"specular"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reflectance can be measured by collecting the light reflected out of a
surface in all directions, using an integrating sphere, obtaining a
quantity called total reflectance. If instead, the reflected light is
collected at a narrow angle mirroring the incident angle, only part of the
reflected radiation is collected, corresponding to mirror-like reflection,
called specular. Thus,
</p>
<p style="text-align: center;"><code class="reqn">\rho = \rho_s + \rho_d</code>
</p>

<p>where, <code class="reqn">\rho</code> is total reflectance, and its components, <code class="reqn">\rho_s</code>, specular
reflectance, and <code class="reqn">\rho_d</code>, diffuse or scattered reflectance.
When strong scattering takes place, total reflectance can
be much more than the specular component. In most cases <code class="reqn">\rho_d</code> is
not measured directly.
</p>
<p>The distinction depends on the measuring procedure, and this information is
stored as metadata in an attribute of objects of classes
<code>reflector_spct</code> or an <code>object_spct</code>.
</p>
<p>When converting between internal and total transmittance, or computing
absorptance by difference based on transmittance and reflectance, only total
reflectance can be meaningfully used (if the object does not noticeably
scatter light, it may be possible to assume that specular reflectance
represents most of the total reflectance.) Consequently, checking the stored
value of this attribute is used as a safeguard in these compuations.
</p>
<p>This attribute is normally set when the <code>source_spct</code> object
is created.
</p>


<h3>Value</h3>

<p><code>x</code>, with the modified attribute in the case of <code>setRfrType()</code> or
the <code>character</code> value, <code>"total"</code> or <code>"specular"</code>, stored
in the <code>"Rfr.type"</code> attribute of <code>x</code> in the case
of <code>getRfrType()</code>. If <code>x</code> is not a <code>reflector_spct</code> or
an <code>object_spct</code> object, <code>NA</code> is returned.
</p>


<h3>Note</h3>

<p>Function <code>setRfrType()</code> alters <code>x</code> itself by reference and in
addition returns <code>x</code> invisibly. If <code>x</code> is not a
<code>reflector_spct</code> or an <code>object_spct object</code>, <code>x</code> is not
modified. The behaviour of this function is 'unusual' in that the default
for parameter <code>Rfr.type</code> is used only if <code>x</code> does not already
have this attribute set.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reflector_spct">reflector_spct</a></code> and <code><a href="#topic+object_spct">object_spct</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.spct &lt;- reflector_spct(w.length = 400:409, Rfr = 0.1)
getRfrType(my.spct)
setRfrType(my.spct, "specular")
getRfrType(my.spct)

</code></pre>

<hr>
<h2 id='setScaled'>Set the &quot;scaled&quot; attribute</h2><span id='topic+setScaled'></span><span id='topic+setScaled.default'></span><span id='topic+setScaled.generic_spct'></span><span id='topic+setScaled.summary_generic_spct'></span><span id='topic+setScaled.generic_mspct'></span>

<h3>Description</h3>

<p>Function to write the &quot;scaled&quot; attribute of an existing generic_spct
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setScaled(x, ...)

## Default S3 method:
setScaled(x, ...)

## S3 method for class 'generic_spct'
setScaled(x, ..., scaled = FALSE)

## S3 method for class 'summary_generic_spct'
setScaled(x, ..., scaled = FALSE)

## S3 method for class 'generic_mspct'
setScaled(x, ..., scaled = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setScaled_+3A_x">x</code></td>
<td>
<p>a generic_spct object.</p>
</td></tr>
<tr><td><code id="setScaled_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
<tr><td><code id="setScaled_+3A_scaled">scaled</code></td>
<td>
<p>logical with <code>FALSE</code> meaning that values are expressed in
absolute physical units and <code>TRUE</code> meaning that relative units are
used. If <code>NULL</code> the attribute is not modified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new object of the same class as <code>x</code>.
</p>
<p>a new object of the same class as <code>x</code>.
</p>
<p>a new object of the same class as <code>x</code>.
</p>
<p>a new object of the same class as <code>x</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>setScaled(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>setScaled(generic_spct)</code>: Specialization for generic_spct
</p>
</li>
<li> <p><code>setScaled(summary_generic_spct)</code>: Specialization for summary_generic_spct
</p>
</li>
<li> <p><code>setScaled(generic_mspct)</code>: Specialization for generic_mspct
</p>
</li></ul>


<h3>Note</h3>

<p>if x is not a <code>generic_spct</code> object, x is not modified.
</p>


<h3>See Also</h3>

<p>Other rescaling functions: 
<code><a href="#topic+fscale">fscale</a>()</code>,
<code><a href="#topic+fshift">fshift</a>()</code>,
<code><a href="#topic+getNormalized">getNormalized</a>()</code>,
<code><a href="#topic+getScaled">getScaled</a>()</code>,
<code><a href="#topic+is_normalized">is_normalized</a>()</code>,
<code><a href="#topic+is_scaled">is_scaled</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+setNormalized">setNormalized</a>()</code>
</p>

<hr>
<h2 id='setSoluteProperties'>Set the &quot;solute.properties&quot; attribute</h2><span id='topic+setSoluteProperties'></span><span id='topic+solute_properties+3C-'></span>

<h3>Description</h3>

<p>Function to set by reference the <code>"solute.properties"</code> attribute of an
existing <code>solute_spct</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSoluteProperties(
  x,
  solute.properties = NULL,
  pass.null = FALSE,
  mass = NA_real_,
  formula = NULL,
  structure = grDevices::as.raster(matrix()),
  name = NA_character_,
  ID = NA_character_,
  solvent.name = NA_character_,
  solvent.ID = NA_character_
)

solute_properties(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSoluteProperties_+3A_x">x</code></td>
<td>
<p>solute_spct A spectrum of coefficients of attenuation.</p>
</td></tr>
<tr><td><code id="setSoluteProperties_+3A_solute.properties">solute.properties</code>, <code id="setSoluteProperties_+3A_value">value</code></td>
<td>
<p>a list with fields named <code>"mass"</code>, <code>"formula"</code>,
<code>"structure"</code>, <code>"name"</code> and <code>"ID"</code>.</p>
</td></tr>
<tr><td><code id="setSoluteProperties_+3A_pass.null">pass.null</code></td>
<td>
<p>logical If <code>TRUE</code>, the parameters to the next three
parameters will be always ignored, otherwise they will be used to
build an object of class <code>"solute.properties"</code> when the argument to
<code>solute.properties</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="setSoluteProperties_+3A_mass">mass</code></td>
<td>
<p>numeric The mass in Dalton [<code class="reqn">Da = g\,mol^{-1}</code>].</p>
</td></tr>
<tr><td><code id="setSoluteProperties_+3A_formula">formula</code></td>
<td>
<p>character The molecular formula.</p>
</td></tr>
<tr><td><code id="setSoluteProperties_+3A_structure">structure</code></td>
<td>
<p>raster A bitmap of the structure.</p>
</td></tr>
<tr><td><code id="setSoluteProperties_+3A_name">name</code>, <code id="setSoluteProperties_+3A_solvent.name">solvent.name</code></td>
<td>
<p>character The name of the substance and the name of the solvent. A named character
vector, with member names such as &quot;IUPAC&quot; for the authority.</p>
</td></tr>
<tr><td><code id="setSoluteProperties_+3A_id">ID</code>, <code id="setSoluteProperties_+3A_solvent.id">solvent.ID</code></td>
<td>
<p>character The names of the substance and of the solvent. A named character
vector, with member names such as &quot;ChemSpider&quot; or &quot;PubChen&quot; for the
authority.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Storing solute properties allows inter-conversion between bases of
expression, and ensures the unambiguous identification of the substances to
which the spectral data refer. These properties make it possible to compute
<code>filter_spct</code> objects for solutions of the solute, i.e., absorption
spectra of liquid filters. The parameter <code>pass.null</code> makes it possible
to remove the attribute. The solvent used for the determination of the
attenuation coefficient is important metadata as the solvent can alter
the spectral ansorption properties of the solute.
</p>


<h3>Value</h3>

<p><code>x</code>
</p>


<h3>Note</h3>

<p>This function alters <code>x</code> itself by reference and in addition
returns <code>x</code> invisibly. If <code>x</code> is not a filter_spct object,
<code>x</code> is not modified.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
solute.properties &lt;-
  list(formula = c(text = "H2O", html = "H&lt;sub&gt;2&lt;/sub&gt;", TeX = "$H_2O$"),
       name = c("water", IUPAC = "oxidane"),
       structure = grDevices::as.raster(matrix()),
       mass = 18.015, # Da
       ID = c(ChemSpider = "917", CID = "962"),
       solvent.name = NA_character_,
       solvent.ID = NA_character_)
my.spct &lt;- solute_spct()
solute_properties(my.spct) &lt;- solute.properties
solute_properties(my.spct)
solute_properties(my.spct) &lt;- NULL
solute_properties(my.spct)
solute_properties(my.spct, return.null = TRUE)
solute_properties(my.spct)

</code></pre>

<hr>
<h2 id='setTfrType'>The &quot;Tfr.type&quot; attribute</h2><span id='topic+setTfrType'></span><span id='topic+getTfrType'></span>

<h3>Description</h3>

<p>Function to set by reference the <code>"Tfr.type"</code> attribute of an
existing <code>filter_spct</code> or <code>object_spct</code> object, and function to
query its current status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTfrType(x, Tfr.type = c("total", "internal"))

getTfrType(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setTfrType_+3A_x">x</code></td>
<td>
<p>a <code>filter_spct</code> or an <code>object_spct</code> object.</p>
</td></tr>
<tr><td><code id="setTfrType_+3A_tfr.type">Tfr.type</code></td>
<td>
<p>character string, either <code>"total"</code> or <code>"internal"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transmittance, <code class="reqn">T</code> or <code class="reqn">\tau</code>, has two different definitions that
differ in how reflectance is taken into account: &quot;total&quot; transmittance and
&quot;internal&quot; transmittance. They are both in widespread use, and rather
frequently the interconversion is approximate or even not possible.
</p>
<p style="text-align: center;"><code class="reqn">T = \frac{I_z}{I_0}</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau = \frac{I_z}{I_0 - \rho}</code>
</p>

<p>where <code class="reqn">T</code> is total transmittance and <code class="reqn">\tau</code> is internal transmittance;
<code class="reqn">I_0</code> is the radiant power incident on an object and <code class="reqn">I_z</code> is the
radiant power at depth <code class="reqn">z</code>, in most cases measured below the non-illuminated
side of the object, and <code class="reqn">\rho</code> is the total reflectance at the
illuminated surface.
</p>
<p>The transmittance of an object as a whole depends on the length of the light
path within the object and reflectance on the angle of incidence of the light
on the surface. When the light beam is near-normal to the surface, both
quantities are at their minimum.
</p>
<p>Thus, the interconversion of total spectral transmittance, <code class="reqn">T(\lambda)</code>,
into internal spectral transmittance, <code class="reqn">\tau(\lambda)</code>, is strictly
possible only if the spectral reflectance <code class="reqn">\rho(\lambda)</code> is known. In
practice, the spectral reflectance is approximated by a constant value
that is assumed independent of wavelength.
</p>
<p>Objects of class <code>object_spct</code> contain spectral data for both spectral
transmittance and spectral reflectance or spectral absorptance, making
conversion possible. Objects of class <code>filter_spct</code> do not contain
spectral reflectance data, but may have a known approximate value for a
reflectance constant, but this is frequently not the case.
</p>
<p>The type of transmittance data stored in an object of these classes is
recorded as metadata in attribute <code>Tfr.Type</code>. The functions described
here set and query this attribute. Contrary to directly accessing the
attribute, the query function consistently returns <code>NA</code> both when the
attribute is set to <code>NA</code> and when the attribute has not been set, as can
be the case of objects created with early versions of the package.
</p>
<p>Absorptance, <code class="reqn">\alpha</code>, and absorbance, <code class="reqn">A</code>, are normally given as
<code>"internal"</code>, and this is the assumption in this package. However,
as in some cases strict enforcement would prevent conversions, this is not
strictly enforced. (IUPAC, recommends use of the name <em>attenuance</em>
(formerly <em>extinction</em>) instead of
<em>absorbance</em> when light attenuation involves processes other than pure
absorption, such as scattering and luminescence.)
</p>
<p style="text-align: center;"><code class="reqn">1 = \alpha + \rho + \tau</code>
</p>

<p style="text-align: center;"><code class="reqn">A_{10} = \log_{10} \frac{1}{\alpha} = - \log_{10} \alpha</code>
</p>

<p>When a solvent-only <em>blank</em> is used when measuring the absorbance of a
solution, the absorbance is not only <code>"internal"</code> to the solution
(discounting reflections at the cuvette boundaries) but also discounts the
effect of the solvent itself. When measuring solid samples, like a sheet of
glass, in most cases a blank is not available.
</p>
<p>For semitransparent objects like glass, it is important to take into
account that reflections occur at each interface between substances with
different refractive index.
</p>
<p>This attribute is normally set when the <code>source_spct</code> object
is created. But <code>convertTfrType()</code> updates it when it changes due
to a conversion.
</p>


<h3>Value</h3>

<p><code>x</code>, with the modified attribute in the case of <code>setTfrType()</code> or
the <code>character</code> value, <code>"total"</code> or <code>internal</code>, stored in
the <code>"Tfr.type"</code> attribute of <code>x</code> in the case
of <code>getTfrType()</code>. If <code>x</code> is not a <code>filter_spct</code> or
an <code>object_spct</code> object, <code>NA</code> is returned.
</p>


<h3>Note</h3>

<p>Function <code>setTfrType()</code> alters <code>x</code> itself by reference and in
addition returns <code>x</code> invisibly. If <code>x</code> is not
a <code>filter_spct</code> or an <code>object_spct object</code>, <code>x</code> is not
modified. The behaviour of this function is 'unusual' in that the default
for parameter <code>Tfr.type</code> is used only if <code>x</code> does not already
have this attribute set.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convertTfrType">convertTfrType</a></code>, <code><a href="#topic+filter_spct">filter_spct</a></code>,
and <code><a href="#topic+object_spct">object_spct</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.spct &lt;- polyester.spct
getTfrType(my.spct)
setTfrType(my.spct, "internal")
getTfrType(my.spct)

</code></pre>

<hr>
<h2 id='setTimeUnit'>Set the &quot;time.unit&quot; attribute of an existing source_spct object</h2><span id='topic+setTimeUnit'></span>

<h3>Description</h3>

<p>Function to set by reference the &quot;time.unit&quot; attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTimeUnit(
  x,
  time.unit = c("second", "hour", "day", "exposure", "none"),
  override.ok = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setTimeUnit_+3A_x">x</code></td>
<td>
<p>a source_spct object</p>
</td></tr>
<tr><td><code id="setTimeUnit_+3A_time.unit">time.unit</code></td>
<td>
<p>character string indicating the time unit used for spectral
irradiance or exposure (&quot;second&quot; , &quot;day&quot; or &quot;exposure&quot;) or an object of
class duration as defined in package lubridate.</p>
</td></tr>
<tr><td><code id="setTimeUnit_+3A_override.ok">override.ok</code></td>
<td>
<p>logical Flag that can be used to silence warning when
overwriting an existing attribute value (used internally)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Note</h3>

<p>This function alters x itself by reference and in addition
returns x invisibly. If x is not a source_spct or response_spct object, x is not modified.
The behaviour of this function is 'unusual' in that the default for
parameter <code>time.unit</code> is used only if <code>x</code> does not already have
this attribute set. <code>time.unit = "hour"</code> is currently not fully
supported.
</p>


<h3>See Also</h3>

<p>Other time attribute functions: 
<code><a href="#topic+checkTimeUnit">checkTimeUnit</a>()</code>,
<code><a href="#topic+convertThickness">convertThickness</a>()</code>,
<code><a href="#topic+convertTimeUnit">convertTimeUnit</a>()</code>,
<code><a href="#topic+getTimeUnit">getTimeUnit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.spct &lt;- sun.spct
setTimeUnit(my.spct, time.unit = "second")
setTimeUnit(my.spct, time.unit = lubridate::duration(1, "seconds"))

</code></pre>

<hr>
<h2 id='setWhatMeasured'>Set the &quot;what.measured&quot; attribute</h2><span id='topic+setWhatMeasured'></span><span id='topic+what_measured+3C-'></span>

<h3>Description</h3>

<p>Function to set by reference the &quot;what.measured&quot; attribute  of an existing
generic_spct or derived-class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setWhatMeasured(x, what.measured)

what_measured(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setWhatMeasured_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="setWhatMeasured_+3A_what.measured">what.measured</code>, <code id="setWhatMeasured_+3A_value">value</code></td>
<td>
<p>a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Note</h3>

<p>This function alters x itself by reference and in addition
returns x invisibly. If x is not a generic_spct object, x is not
modified.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.spct &lt;- sun.spct
what_measured(my.spct)
what_measured(my.spct) &lt;- "Sun"
what_measured(my.spct)

</code></pre>

<hr>
<h2 id='setWhenMeasured'>Set the &quot;when.measured&quot; attribute</h2><span id='topic+setWhenMeasured'></span><span id='topic+when_measured+3C-'></span><span id='topic+setWhenMeasured.default'></span><span id='topic+setWhenMeasured.generic_spct'></span><span id='topic+setWhenMeasured.summary_generic_spct'></span><span id='topic+setWhenMeasured.generic_mspct'></span>

<h3>Description</h3>

<p>Function to set by reference the &quot;when&quot; attribute  of an existing
generic_spct or an object of a class derived from generic_spct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setWhenMeasured(x, when.measured, ...)

when_measured(x) &lt;- value

## Default S3 method:
setWhenMeasured(x, when.measured, ...)

## S3 method for class 'generic_spct'
setWhenMeasured(x, when.measured = lubridate::now(tzone = "UTC"), ...)

## S3 method for class 'summary_generic_spct'
setWhenMeasured(x, when.measured = lubridate::now(tzone = "UTC"), ...)

## S3 method for class 'generic_mspct'
setWhenMeasured(x, when.measured = lubridate::now(tzone = "UTC"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setWhenMeasured_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="setWhenMeasured_+3A_when.measured">when.measured</code>, <code id="setWhenMeasured_+3A_value">value</code></td>
<td>
<p>POSIXct to add as attribute, or a list of POSIXct.</p>
</td></tr>
<tr><td><code id="setWhenMeasured_+3A_...">...</code></td>
<td>
<p>Allows use of additional arguments in methods for other classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>setWhenMeasured(default)</code>: default
</p>
</li>
<li> <p><code>setWhenMeasured(generic_spct)</code>: generic_spct
</p>
</li>
<li> <p><code>setWhenMeasured(summary_generic_spct)</code>: summary_generic_spct
</p>
</li>
<li> <p><code>setWhenMeasured(generic_mspct)</code>: generic_mspct
</p>
</li></ul>


<h3>Note</h3>

<p>This method alters x itself by reference and in addition
returns x invisibly. If x is not a generic_spct or an object of a class derived from
generic_spct, x is not modified. If <code>when</code> is not a POSIXct object
or <code>NULL</code> an error is triggered. A <code>POSIXct</code> describes an
instant in time (date plus time-of-day plus time zone).
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.spct &lt;- sun.spct
when_measured(my.spct)
when_measured(my.spct) &lt;- lubridate::ymd_hms("2020-01-01 08:00:00")
when_measured(my.spct)

</code></pre>

<hr>
<h2 id='setWhereMeasured'>Set the &quot;where.measured&quot; attribute</h2><span id='topic+setWhereMeasured'></span><span id='topic+where_measured+3C-'></span><span id='topic+setWhereMeasured.default'></span><span id='topic+setWhereMeasured.generic_spct'></span><span id='topic+setWhereMeasured.summary_generic_spct'></span><span id='topic+setWhereMeasured.generic_mspct'></span>

<h3>Description</h3>

<p>Function to set by reference the &quot;where.measured&quot; attribute  of an existing
generic_spct or an object of a class derived from generic_spct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setWhereMeasured(x, where.measured, lat, lon, address, ...)

where_measured(x) &lt;- value

## Default S3 method:
setWhereMeasured(x, where.measured, lat, lon, address, ...)

## S3 method for class 'generic_spct'
setWhereMeasured(x, where.measured = NA, lat = NA, lon = NA, address = NA, ...)

## S3 method for class 'summary_generic_spct'
setWhereMeasured(x, where.measured = NA, lat = NA, lon = NA, address = NA, ...)

## S3 method for class 'generic_mspct'
setWhereMeasured(x, where.measured = NA, lat = NA, lon = NA, address = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setWhereMeasured_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="setWhereMeasured_+3A_where.measured">where.measured</code>, <code id="setWhereMeasured_+3A_value">value</code></td>
<td>
<p>A one row data.frame such as returned by
function <code>geocode</code> from package 'ggmap' for a location search.</p>
</td></tr>
<tr><td><code id="setWhereMeasured_+3A_lat">lat</code></td>
<td>
<p>numeric Latitude in decimal degrees North</p>
</td></tr>
<tr><td><code id="setWhereMeasured_+3A_lon">lon</code></td>
<td>
<p>numeric Longitude in decimal degrees West</p>
</td></tr>
<tr><td><code id="setWhereMeasured_+3A_address">address</code></td>
<td>
<p>character Human readable address</p>
</td></tr>
<tr><td><code id="setWhereMeasured_+3A_...">...</code></td>
<td>
<p>Allows use of additional arguments in methods for other classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>setWhereMeasured(default)</code>: default
</p>
</li>
<li> <p><code>setWhereMeasured(generic_spct)</code>: generic_spct
</p>
</li>
<li> <p><code>setWhereMeasured(summary_generic_spct)</code>: summary_generic_spct
</p>
</li>
<li> <p><code>setWhereMeasured(generic_mspct)</code>: generic_mspct
</p>
</li></ul>


<h3>Note</h3>

<p>This method alters x itself by reference and in addition
returns x invisibly. If x is not a generic_spct or an object of a class derived from
generic_spct, x is not modified. If <code>where</code> is not a POSIXct object
or <code>NULL</code> an error is triggered. A <code>POSIXct</code> describes an
instant in time (date plus time-of-day plus time zone). As expected
passing <code>NULL</code> as argument for <code>where.measured</code> unsets the
attribute.
</p>
<p>Method for collections of spectra recycles the location information
only if it is of length one.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.spct &lt;- sun.spct
where_measured(my.spct)
where_measured(my.spct) &lt;- data.frame(lon = 0, lat = -60)
where_measured(my.spct)

</code></pre>

<hr>
<h2 id='shared_member_class'>Classes common to all collection members.</h2><span id='topic+shared_member_class'></span>

<h3>Description</h3>

<p>Finds the set intersection among the class attributes of all collection
member as a target set of class names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shared_member_class(l, target.set = spct_classes())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shared_member_class_+3A_l">l</code></td>
<td>
<p>a list or a generic_mspct object or of a derived class.</p>
</td></tr>
<tr><td><code id="shared_member_class_+3A_target.set">target.set</code></td>
<td>
<p>character The target set of classes within which to search
for classes common to all members.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the class attribute values.
</p>


<h3>See Also</h3>

<p>Other set and unset 'multi spectral' class functions: 
<code><a href="#topic+rmDerivedMspct">rmDerivedMspct</a>()</code>
</p>

<hr>
<h2 id='sign'>Sign</h2><span id='topic+sign'></span><span id='topic+sign.generic_spct'></span>

<h3>Description</h3>

<p><code>sign</code> returns a vector with the signs of the corresponding elements of
x (the sign of a real number is 1, 0, or -1 if the number is positive, zero,
or negative, respectively).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
sign(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sign_+3A_x">x</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other math operators and functions: 
<code><a href="#topic+MathFun">MathFun</a></code>,
<code><a href="#topic++5E.generic_spct">^.generic_spct</a>()</code>,
<code><a href="#topic+convolve_each">convolve_each</a>()</code>,
<code><a href="#topic+div-.generic_spct">div-.generic_spct</a></code>,
<code><a href="#topic+log">log</a>()</code>,
<code><a href="#topic+minus-.generic_spct">minus-.generic_spct</a></code>,
<code><a href="#topic+mod-.generic_spct">mod-.generic_spct</a></code>,
<code><a href="#topic+plus-.generic_spct">plus-.generic_spct</a></code>,
<code><a href="#topic+round">round</a>()</code>,
<code><a href="#topic+slash-.generic_spct">slash-.generic_spct</a></code>,
<code><a href="#topic+times-.generic_spct">times-.generic_spct</a></code>
</p>

<hr>
<h2 id='sinc'>sinc</h2><span id='topic+sinc'></span>

<h3>Description</h3>

<p>sinc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinc(x)
</code></pre>

<hr>
<h2 id='slash-.generic_spct'>Arithmetic Operators</h2><span id='topic+slash-.generic_spct'></span><span id='topic++2F.generic_spct'></span>

<h3>Description</h3>

<p>Division operator for generic spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
e1 / e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slash-.generic_spct_+3A_e1">e1</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
<tr><td><code id="slash-.generic_spct_+3A_e2">e2</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other math operators and functions: 
<code><a href="#topic+MathFun">MathFun</a></code>,
<code><a href="#topic++5E.generic_spct">^.generic_spct</a>()</code>,
<code><a href="#topic+convolve_each">convolve_each</a>()</code>,
<code><a href="#topic+div-.generic_spct">div-.generic_spct</a></code>,
<code><a href="#topic+log">log</a>()</code>,
<code><a href="#topic+minus-.generic_spct">minus-.generic_spct</a></code>,
<code><a href="#topic+mod-.generic_spct">mod-.generic_spct</a></code>,
<code><a href="#topic+plus-.generic_spct">plus-.generic_spct</a></code>,
<code><a href="#topic+round">round</a>()</code>,
<code><a href="#topic+sign">sign</a>()</code>,
<code><a href="#topic+times-.generic_spct">times-.generic_spct</a></code>
</p>

<hr>
<h2 id='smooth_spct'>Smooth a spectrum</h2><span id='topic+smooth_spct'></span><span id='topic+smooth_spct.default'></span><span id='topic+smooth_spct.source_spct'></span><span id='topic+smooth_spct.filter_spct'></span><span id='topic+smooth_spct.reflector_spct'></span><span id='topic+smooth_spct.solute_spct'></span><span id='topic+smooth_spct.response_spct'></span><span id='topic+smooth_spct.cps_spct'></span><span id='topic+smooth_spct.generic_mspct'></span>

<h3>Description</h3>

<p>These functions implement one original methods and acts as a wrapper for
other common R smoothing functions. The advantage of using this function for
smoothing spectral objects is that it simplifies the user interface and sets,
when needed, defaults suitable for spectral data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_spct(x, method, strength, wl.range, ...)

## Default S3 method:
smooth_spct(x, method, strength, wl.range, ...)

## S3 method for class 'source_spct'
smooth_spct(
  x,
  method = "custom",
  strength = 1,
  wl.range = NULL,
  na.rm = FALSE,
  ...
)

## S3 method for class 'filter_spct'
smooth_spct(
  x,
  method = "custom",
  strength = 1,
  wl.range = NULL,
  na.rm = FALSE,
  ...
)

## S3 method for class 'reflector_spct'
smooth_spct(
  x,
  method = "custom",
  strength = 1,
  wl.range = NULL,
  na.rm = FALSE,
  ...
)

## S3 method for class 'solute_spct'
smooth_spct(
  x,
  method = "custom",
  strength = 1,
  wl.range = NULL,
  na.rm = FALSE,
  ...
)

## S3 method for class 'response_spct'
smooth_spct(
  x,
  method = "custom",
  strength = 1,
  wl.range = NULL,
  na.rm = FALSE,
  ...
)

## S3 method for class 'cps_spct'
smooth_spct(
  x,
  method = "custom",
  strength = 1,
  wl.range = NULL,
  na.rm = FALSE,
  ...
)

## S3 method for class 'generic_mspct'
smooth_spct(
  x,
  method = "custom",
  strength = 1,
  wl.range = NULL,
  na.rm = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_spct_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="smooth_spct_+3A_method">method</code></td>
<td>
<p>a character string &quot;custom&quot;, &quot;lowess&quot;, &quot;supsmu&quot; or &quot;skip&quot;..</p>
</td></tr>
<tr><td><code id="smooth_spct_+3A_strength">strength</code></td>
<td>
<p>numeric value to adjust the degree of smoothing. Ignored if
method-specific parameters are passed through <code>...</code>.</p>
</td></tr>
<tr><td><code id="smooth_spct_+3A_wl.range">wl.range</code></td>
<td>
<p>any R object on which applying the method <code>range()</code>
yields a vector of two numeric values, describing a range of wavelengths
(nm) within which spectral data is to be smoothed. <code>NA</code> is interpreted
as the min or max value of <code>x[[w.length]]</code>.</p>
</td></tr>
<tr><td><code id="smooth_spct_+3A_...">...</code></td>
<td>
<p>other parameters passed to the underlying smoothing functions.</p>
</td></tr>
<tr><td><code id="smooth_spct_+3A_na.rm">na.rm</code></td>
<td>
<p>logical A flag indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> with spectral data values replaced by smoothed
ones.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>smooth_spct(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>smooth_spct(source_spct)</code>: Smooth a source spectrum
</p>
</li>
<li> <p><code>smooth_spct(filter_spct)</code>: Smooth a filter spectrum
</p>
</li>
<li> <p><code>smooth_spct(reflector_spct)</code>: Smooth a reflector spectrum
</p>
</li>
<li> <p><code>smooth_spct(solute_spct)</code>: Smooth a solute attenuation spectrum
</p>
</li>
<li> <p><code>smooth_spct(response_spct)</code>: Smooth a response spectrum
</p>
</li>
<li> <p><code>smooth_spct(cps_spct)</code>: Smooth a counts per second spectrum
</p>
</li>
<li> <p><code>smooth_spct(generic_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>Method &quot;custom&quot; is our home-brewed method which applies strong
smoothing to low signal regions of the spectral data, and weaker or no
smoothing to the high signal areas. Values very close to zero are set to
zero with a limit which depends on the local variation. This method is an
ad-hock method suitable for smoothing spectral data obtained with
spectrometers. In the cased of methods &quot;lowess&quot; and &quot;supsmu&quot; the current
function behaves like a wrapper of the functions of the same names from
base R. Method &quot;skip&quot; returns <code>x</code> unchanged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.spct &lt;- clip_wl(sun.spct, c(400, 500))
smooth_spct(my.spct)
smooth_spct(my.spct, method = "custom", strength = 1)
smooth_spct(my.spct, method = "custom", strength = 4)
smooth_spct(my.spct, method = "supsmu", strength = 4)

</code></pre>

<hr>
<h2 id='solar_time'>Local solar time</h2><span id='topic+solar_time'></span>

<h3>Description</h3>

<p><code>solar_time()</code> computes the time of day expressed in seconds since the
astronomical midnight using and instant in time and a geocode as input. Solar
time is useful when we want to plot data according to the local solar time
rather than the local time in use at a time zone. How the returned instant in
time is expressed depends on the argument passed to <code>unit.out</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solar_time(
  time = lubridate::now(),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  unit.out = "time"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solar_time_+3A_time">time</code></td>
<td>
<p>POSIXct Time, any valid time zone (TZ) is allowed, default is
current time</p>
</td></tr>
<tr><td><code id="solar_time_+3A_geocode">geocode</code></td>
<td>
<p>data frame with variables lon and lat as numeric values
(degrees).</p>
</td></tr>
<tr><td><code id="solar_time_+3A_unit.out">unit.out</code></td>
<td>
<p>character string, One of &quot;datetime&quot;, &quot;time&quot;, &quot;hour&quot;, &quot;minute&quot;, or
&quot;second&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Solar time is determined by the position of the sun in the sky and
it almost always differs from the time expressed in the local time
coordinates in use. The differences can vary from a few minutes up to a
couple of hours depending on the exact location within the time zone and the
use or not of daylight saving time.
</p>


<h3>Value</h3>

<p>In all cases solar time is expressed as time since local astronomical
midnight and, thus, lacks date information. If <code>unit.out = "time"</code>, a
numeric value in seconds with an additional class attribute
&quot;solar_time&quot;; if <code>unit.out = "datetime"</code>, a &quot;POSIXct&quot; value in seconds
from midnight but with an additional class attribute &quot;solar_date&quot;; if
<code>unit.out = "hour"</code> or <code>unit.out = "minute"</code> or <code>unit.out =
  "second"</code>, a numeric value.
</p>


<h3>Warning!</h3>

<p>Returned values are computed based on the time zone of the
argument for parameter time. In the case of solar time, this timezone does
not affect the result. However, in the case of solar dates the date part
may be off by one day, if the time zone does not match the coordinates of
the geocode value provided as argument.
</p>


<h3>Note</h3>

<p>The algorithm is approximate, it calculates the difference between
local solar noon and noon in the time zone of <code>time</code> and uses this
value for the whole day when converting times into solar time. Days are not
exactly 24 h long. Between successive days the shift is only a few seconds,
and this leads to a small jump at midnight.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_tod">as_tod</a></code>
</p>
<p>Other Local solar time functions: 
<code><a href="#topic+as.solar_date">as.solar_date</a>()</code>,
<code><a href="#topic+is.solar_time">is.solar_time</a>()</code>,
<code><a href="#topic+print.solar_time">print.solar_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BA.geocode &lt;-
  data.frame(lon = -58.38156, lat = -34.60368, address = "Buenos Aires, Argentina")
sol_t &lt;- solar_time(lubridate::dmy_hms("21/06/2016 10:00:00", tz = "UTC"),
                    BA.geocode)
sol_t
class(sol_t)

sol_d &lt;- solar_time(lubridate::dmy_hms("21/06/2016 10:00:00", tz = "UTC"),
                    BA.geocode,
                    unit.out = "datetime")
sol_d
class(sol_d)

</code></pre>

<hr>
<h2 id='source_spct'>Spectral-object constructors</h2><span id='topic+source_spct'></span><span id='topic+calibration_spct'></span><span id='topic+raw_spct'></span><span id='topic+cps_spct'></span><span id='topic+generic_spct'></span><span id='topic+response_spct'></span><span id='topic+filter_spct'></span><span id='topic+reflector_spct'></span><span id='topic+solute_spct'></span><span id='topic+object_spct'></span><span id='topic+chroma_spct'></span>

<h3>Description</h3>

<p>These constructor functions can be used to create spectral objects derived
from <code>generic_spct</code>. They take as arguments numeric vectors for the
wavelengths and spectral data, and numeric, character, and logical values for
metadata attributes to be saved to the objects created and options
controlling the creation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>source_spct(
  w.length = NULL,
  s.e.irrad = NULL,
  s.q.irrad = NULL,
  ...,
  time.unit = c("second", "day", "exposure"),
  bswf.used = c("none", "unknown"),
  comment = NULL,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

calibration_spct(
  w.length = NULL,
  irrad.mult = NA_real_,
  ...,
  comment = NULL,
  instr.desc = NA,
  multiple.wl = 1L,
  idfactor = NULL
)

raw_spct(
  w.length = NULL,
  counts = NA_real_,
  ...,
  comment = NULL,
  instr.desc = NA,
  instr.settings = NA,
  multiple.wl = 1L,
  idfactor = NULL
)

cps_spct(
  w.length = NULL,
  cps = NA_real_,
  ...,
  comment = NULL,
  instr.desc = NA,
  instr.settings = NA,
  multiple.wl = 1L,
  idfactor = NULL
)

generic_spct(
  w.length = NULL,
  ...,
  comment = NULL,
  multiple.wl = 1L,
  idfactor = NULL
)

response_spct(
  w.length = NULL,
  s.e.response = NULL,
  s.q.response = NULL,
  ...,
  time.unit = c("second", "day", "exposure"),
  response.type = c("response", "action"),
  comment = NULL,
  multiple.wl = 1L,
  idfactor = NULL
)

filter_spct(
  w.length = NULL,
  Tfr = NULL,
  Tpc = NULL,
  Afr = NULL,
  A = NULL,
  ...,
  Tfr.type = c("total", "internal"),
  Rfr.constant = NA_real_,
  thickness = NA_real_,
  attenuation.mode = NA,
  comment = NULL,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

reflector_spct(
  w.length = NULL,
  Rfr = NULL,
  Rpc = NULL,
  ...,
  Rfr.type = c("total", "specular"),
  comment = NULL,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

solute_spct(
  w.length = NULL,
  K.mole = NULL,
  K.mass = NULL,
  attenuation.XS = NULL,
  ...,
  log.base = 10,
  K.type = c("attenuation", "absorption", "scattering"),
  name = NA_character_,
  mass = NA_character_,
  formula = NULL,
  structure = grDevices::as.raster(matrix()),
  ID = NA_character_,
  solvent.name = NA_character_,
  solvent.ID = NA_character_,
  comment = NULL,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

object_spct(
  w.length = NULL,
  Rfr = NULL,
  Tfr = NULL,
  Afr = NULL,
  ...,
  Tfr.type = c("total", "internal"),
  Rfr.type = c("total", "specular"),
  comment = NULL,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)

chroma_spct(
  w.length = NULL,
  x,
  y,
  z,
  ...,
  comment = NULL,
  strict.range = getOption("photobiology.strict.range", default = FALSE),
  multiple.wl = 1L,
  idfactor = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="source_spct_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector with wavelengths in nanometres [<code class="reqn">nm</code>].</p>
</td></tr>
<tr><td><code id="source_spct_+3A_s.e.irrad">s.e.irrad</code></td>
<td>
<p>numeric vector with spectral energy irradiance in
[<code class="reqn">W\,m^{-2}\,nm^{-1}</code>] or [<code class="reqn">J\,d^{-1}\,m^{-2}\,nm^{-1}</code>].</p>
</td></tr>
<tr><td><code id="source_spct_+3A_s.q.irrad">s.q.irrad</code></td>
<td>
<p>numeric A vector with spectral photon irradiance in
[<code class="reqn">mol\,s^{-1}\,m^{-2}\,nm^{-1}</code>] or
[<code class="reqn">mol\,d^{-1}\,m^{-2}\,nm^{-1}</code>].</p>
</td></tr>
<tr><td><code id="source_spct_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>tibble()</code> such as vectors or
factors to be added as additional columns.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_time.unit">time.unit</code></td>
<td>
<p>character string indicating the time unit used for spectral
irradiance or exposure (<code>"second"</code>, <code>"day"</code> or <code>"exposure"</code>)
or an object of class duration as defined in package lubridate.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_bswf.used">bswf.used</code></td>
<td>
<p>character A string indicating the BSWF used, if any, for
spectral effective irradiance or exposure (<code>"none"</code> or the name of the
BSWF).</p>
</td></tr>
<tr><td><code id="source_spct_+3A_comment">comment</code></td>
<td>
<p>character A string to be added as a comment attribute to the
object created.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_strict.range">strict.range</code></td>
<td>
<p>logical Flag indicating whether off-range values result
in an error instead of a warning.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_multiple.wl">multiple.wl</code></td>
<td>
<p>numeric Maximum number of repeated <code>w.length</code> entries
with same value. (As with multiple spectra stored in long from).</p>
</td></tr>
<tr><td><code id="source_spct_+3A_idfactor">idfactor</code></td>
<td>
<p>character Name of factor distinguishing multiple spectra when
stored longitudinally (required if <code>multiple.wl</code> &gt; 1).</p>
</td></tr>
<tr><td><code id="source_spct_+3A_irrad.mult">irrad.mult</code></td>
<td>
<p>numeric vector with multipliers for each detector pixel
expressed in units of <code class="reqn">W\,m^{-2}\,nm^{-1}\,n^{-1}\,s</code>,
where <code class="reqn">n\,s^{-1}</code> are detector counts per second.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_instr.desc">instr.desc</code></td>
<td>
<p>a list describing the spectrometer used to acquire the data.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_counts">counts</code></td>
<td>
<p>numeric vector with raw counts expressed per scan.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_instr.settings">instr.settings</code></td>
<td>
<p>a list describing the settings used to acquire the data.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_cps">cps</code></td>
<td>
<p>numeric vector with linearized raw counts expressed per second
[<code class="reqn">n\,s^{-1}</code>]</p>
</td></tr>
<tr><td><code id="source_spct_+3A_s.e.response">s.e.response</code></td>
<td>
<p>numeric vector with a biological, chemical or physical
response expressed per unit spectral energy irradiance
[<code class="reqn">W\,m^{-2}\,nm^{-1}</code> or <code class="reqn">J\,d^{-1}\,m^{-2}\,nm^{-1}</code>].</p>
</td></tr>
<tr><td><code id="source_spct_+3A_s.q.response">s.q.response</code></td>
<td>
<p>numeric vector with a biological, chemical or physical
response expressed per unit spectral photon irradiance in
[<code class="reqn">mol\,s^{-1}\,m^{-2}\,nm^{-1}</code> or <code class="reqn">mol\,d^{-1}\,m^{-2}\,nm^{-1}</code>].</p>
</td></tr>
<tr><td><code id="source_spct_+3A_response.type">response.type</code></td>
<td>
<p>a character string, either <code>"response"</code> or
<code>"action"</code>.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_tfr">Tfr</code></td>
<td>
<p>numeric vector with spectral transmittance as fraction of one
[<code class="reqn">/1</code>].</p>
</td></tr>
<tr><td><code id="source_spct_+3A_tpc">Tpc</code></td>
<td>
<p>numeric vector with spectral transmittance as percent values</p>
</td></tr>
<tr><td><code id="source_spct_+3A_afr">Afr</code></td>
<td>
<p>numeric vector of absorptance as fraction of one [<code class="reqn">/1</code>].</p>
</td></tr>
<tr><td><code id="source_spct_+3A_a">A</code></td>
<td>
<p>numeric vector of absorbance values (<code class="reqn">log_{10}</code>-base
a.u.)</p>
</td></tr>
<tr><td><code id="source_spct_+3A_tfr.type">Tfr.type</code></td>
<td>
<p>character string indicating whether transmittance and
absorptance values are <code>"total"</code> or <code>"internal"</code> values</p>
</td></tr>
<tr><td><code id="source_spct_+3A_rfr.constant">Rfr.constant</code></td>
<td>
<p>numeric The value of the reflection factor [<code class="reqn">/1</code>].</p>
</td></tr>
<tr><td><code id="source_spct_+3A_thickness">thickness</code></td>
<td>
<p>numeric The thickness of the material.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_attenuation.mode">attenuation.mode</code></td>
<td>
<p>character One of <code>"reflection"</code>,
<code>"absorption"</code> or <code>"mixed"</code>.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_rfr">Rfr</code></td>
<td>
<p>numeric vector with spectral reflectance as fraction of one
[<code class="reqn">/1</code>].</p>
</td></tr>
<tr><td><code id="source_spct_+3A_rpc">Rpc</code></td>
<td>
<p>numeric vector with spectral reflectance as percent values.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_rfr.type">Rfr.type</code></td>
<td>
<p>character A string, either <code>"total"</code> or
<code>"specular"</code>.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_k.mole">K.mole</code></td>
<td>
<p>numeric vector with molar attenuation coefficient in SI units
[<code class="reqn">m^2\,mol^-1</code>].</p>
</td></tr>
<tr><td><code id="source_spct_+3A_k.mass">K.mass</code></td>
<td>
<p>numeric vector with mass attenuation coefficient in SI units
[<code class="reqn">m^2\,g^-1</code>].</p>
</td></tr>
<tr><td><code id="source_spct_+3A_attenuation.xs">attenuation.XS</code></td>
<td>
<p>numeric vector with attenuation cross section values
(Converted during object construction into <code>K.mole</code>.)</p>
</td></tr>
<tr><td><code id="source_spct_+3A_log.base">log.base</code></td>
<td>
<p>numeric Normally one of <code>e</code> or <code>10</code>. Data are
stored always on base 10 corresponding to decadal absorbance as used in
chemistry.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_k.type">K.type</code></td>
<td>
<p>character A string, either <code>"attenuation"</code>,
<code>"absorption"</code> or <code>"scattering"</code>.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_name">name</code>, <code id="source_spct_+3A_solvent.name">solvent.name</code></td>
<td>
<p>character The names of the substance and of the
solvent. A named character vector, with member names such as &quot;IUPAC&quot; for
the authority.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_mass">mass</code></td>
<td>
<p>numeric The molar mass in Dalton [Da] (<code class="reqn">Da = g\,mol^{-1}</code>).</p>
</td></tr>
<tr><td><code id="source_spct_+3A_formula">formula</code></td>
<td>
<p>character The molecular formula.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_structure">structure</code></td>
<td>
<p>raster A bitmap of the structure.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_id">ID</code>, <code id="source_spct_+3A_solvent.id">solvent.ID</code></td>
<td>
<p>character The ID of the substance and of the solvent. A
named character vector, with member names such as &quot;ChemSpider&quot; or &quot;PubChem&quot;
for the authority.</p>
</td></tr>
<tr><td><code id="source_spct_+3A_x">x</code>, <code id="source_spct_+3A_y">y</code>, <code id="source_spct_+3A_z">z</code></td>
<td>
<p>numeric colour coordinates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructors can be used to create spectral objects from spectral
quantities expressed on a single base or unit. Some of the functions have
different formal parameters accepting a quantity expressed in different
units, however, an argument can be passed to only one of these formal
parameters in a given call. The constructors <code>object_spct()</code> and
<code>chroma_spct()</code> require arguments to be passed for multiple but
distinct spectral quantities.
</p>


<h3>Value</h3>

<p>A object of class <code>generic_spct</code> or a class derived from it,
depending on the function used. In other words an object of a class with
the same name as the constructor function.
</p>


<h3>Warning for filter_spct!</h3>

<p>Not entering metadata when creating an
object will limit the available operations! While &quot;internal&quot; transmittance
is defined as the transmittance of the material body itself, &quot;total&quot;
transmittance includes the effects of surface reflectance on the amount of
light transmitted. For non-diffusing materials like glass an approximate
<code>Rfr.constant</code> value can be used to convert &quot;total&quot; into &quot;internal&quot;
transmittance values and vice versa. Use <code>NA</code> if not known, or not
applicable, e.g., for materials subject to internal scattering.
</p>


<h3>Warning for solute_spct!</h3>

<p>You should always set the base for logarithms to match that on which the
absorbance data are expressed. Failing to do this will result in bad data
and all further computation will be wrong. Not entering metadata when
creating an object will limit the available operations! Mass should be
indicated in daltons or <code class="reqn">g\,mol^{-1}</code>. The SI unit of molar attenuation
coefficient is the square metre per mole (<code class="reqn">m^2\,mol^{1}</code>),
but in practice, quantities are usually expressed in terms of
<code class="reqn">M^{-1}\,cm^{-1}</code> or <code class="reqn">l\,mol^{-1}\,cm^{-1}</code> (the latter two units are
both equal to 0.1 <code class="reqn">m^2\,mol^{-1}</code> and quantities expressed in them need
to be divided by 10 when passed as arguments to <code>K.mole</code>.).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setFilterProperties">setFilterProperties</a></code>
</p>
<p><code><a href="#topic+setSoluteProperties">setSoluteProperties</a></code>
</p>
<p>Other constructors of spectral objects: 
<code><a href="#topic+as.calibration_spct">as.calibration_spct</a>()</code>,
<code><a href="#topic+as.chroma_spct">as.chroma_spct</a>()</code>,
<code><a href="#topic+as.cps_spct">as.cps_spct</a>()</code>,
<code><a href="#topic+as.filter_spct">as.filter_spct</a>()</code>,
<code><a href="#topic+as.generic_spct">as.generic_spct</a>()</code>,
<code><a href="#topic+as.object_spct">as.object_spct</a>()</code>,
<code><a href="#topic+as.raw_spct">as.raw_spct</a>()</code>,
<code><a href="#topic+as.reflector_spct">as.reflector_spct</a>()</code>,
<code><a href="#topic+as.response_spct">as.response_spct</a>()</code>,
<code><a href="#topic+as.solute_spct">as.solute_spct</a>()</code>,
<code><a href="#topic+as.source_spct">as.source_spct</a>()</code>
</p>

<hr>
<h2 id='spct_attr2tb'>Copy attributes into a tibble</h2><span id='topic+spct_attr2tb'></span>

<h3>Description</h3>

<p>Method returning attributes of an object of class generic_spct or derived,
or of class waveband. Only attributes defined and/or set by package
'photobiology' for objects of the corresponding class are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spct_attr2tb(
  x,
  which = c("-", "names", "row.names", "spct.tags", "spct.version", "comment"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spct_attr2tb_+3A_x">x</code></td>
<td>
<p>a generic_spct object.</p>
</td></tr>
<tr><td><code id="spct_attr2tb_+3A_which">which</code></td>
<td>
<p>character vector Names of attributes to retrieve.</p>
</td></tr>
<tr><td><code id="spct_attr2tb_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the values stored in the attributes whose names were
selected through the argument to <code>which</code> if present in <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>

<hr>
<h2 id='spct_classes'>Function returning a vector containing the names of spectra classes.</h2><span id='topic+spct_classes'></span>

<h3>Description</h3>

<p>Function returning a vector containing the names of spectra classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spct_classes()
</code></pre>


<h3>Value</h3>

<p>A <code>character</code> vector of class names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spct_classes()

</code></pre>

<hr>
<h2 id='spct_metadata'>Access metadata</h2><span id='topic+spct_metadata'></span>

<h3>Description</h3>

<p>Return metadata attributes from a single spectrum or a collection of spectra
as a tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spct_metadata(
  x,
  col.names = NULL,
  idx = "spct.idx",
  na.rm = is.null(col.names),
  unnest = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spct_metadata_+3A_x">x</code></td>
<td>
<p>generic_mspct or generic_spct Any collection of spectra or spectrum.</p>
</td></tr>
<tr><td><code id="spct_metadata_+3A_col.names">col.names</code></td>
<td>
<p>named character vector Name(s) of column(s) to create.</p>
</td></tr>
<tr><td><code id="spct_metadata_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="spct_metadata_+3A_na.rm">na.rm</code></td>
<td>
<p>logical Flag controlling deletion of columns containing only NA
values.</p>
</td></tr>
<tr><td><code id="spct_metadata_+3A_unnest">unnest</code></td>
<td>
<p>logical Flag controlling if metadata attributes that are lists
of values should be returned in a list column or in separate columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attributes are returned as columns in a tibble. If the argument to
<code>col.names</code> is a named vector, with the names of members matching the
names of attributes, then the values are used as names for the columns
created. This permits setting any valid name for the new columns. If the
vector passed to <code>col.names</code> has no names, then the values are
interpreted as the names of the attributes to add, and also used as names
for the new columns.
</p>
<p>Some metadata values are stored in lists or data frames, these can be
returned as a list columns or the individual fields unnested into separate
columns.
</p>


<h3>Value</h3>

<p>A tibble With the metadata attributes and an index column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for more details.
</p>
<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.mspct &lt;- source_mspct(list(sun1 = sun.spct, sun2 = sun.spct * 2))

spct_metadata(my.mspct)

spct_metadata(sun.spct)

spct_metadata(my.mspct, na.rm = TRUE)

spct_metadata(sun.spct, na.rm = TRUE)

spct_metadata(my.mspct, col.names = c(geocode = "geo", "instr.desc"))

spct_metadata(sun.spct, col.names = c(geocode = "geo", "instr.desc"))

spct_metadata(sun.spct, col.names = "where.measured")$where.measured

</code></pre>

<hr>
<h2 id='spct_wide2long'>Convert spectrum from wide to long form</h2><span id='topic+spct_wide2long'></span>

<h3>Description</h3>

<p>Convert spectrum from wide to long form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spct_wide2long(
  spct,
  fixed.cols = "w.length",
  idfactor = "spct.idx",
  rm.spct.class = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spct_wide2long_+3A_spct">spct</code></td>
<td>
<p>An object with spectral data.</p>
</td></tr>
<tr><td><code id="spct_wide2long_+3A_fixed.cols">fixed.cols</code></td>
<td>
<p>character Names of variables that should be copied
unchanged for each spectrum.</p>
</td></tr>
<tr><td><code id="spct_wide2long_+3A_idfactor">idfactor</code></td>
<td>
<p>character The name of the factor to be added to the long-form
object and used to store the original name of the columns as an index
to the different spectra.</p>
</td></tr>
<tr><td><code id="spct_wide2long_+3A_rm.spct.class">rm.spct.class</code></td>
<td>
<p>logical If true the returned object is a data frame.</p>
</td></tr>
<tr><td><code id="spct_wide2long_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only objects of classes raw_spct, cps_spct, and object_spct normally contain
multiple columns of spectral data. These are supported as well as
generic_spct. Is the wide spectra contain multiple spectra in long form,
the original <code>idfactor</code> is preserved.
</p>
<p>Spectra that are already in long form, if passed as argument, are returned
unchanged.
</p>
<p>Because the classes defined for spectra have a well defined format, and
known column names we can define a rather simple function for this
operation.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>spct</code> or a <code>data.frame</code>
with derived classes removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
spct_wide2long(white_led.raw_spct)
spct_wide2long(white_led.cps_spct)
spct_wide2long(Ler_leaf.spct)

</code></pre>

<hr>
<h2 id='spikes'>Spikes</h2><span id='topic+spikes'></span><span id='topic+spikes.default'></span><span id='topic+spikes.numeric'></span><span id='topic+spikes.data.frame'></span><span id='topic+spikes.generic_spct'></span><span id='topic+spikes.source_spct'></span><span id='topic+spikes.response_spct'></span><span id='topic+spikes.filter_spct'></span><span id='topic+spikes.reflector_spct'></span><span id='topic+spikes.solute_spct'></span><span id='topic+spikes.cps_spct'></span><span id='topic+spikes.raw_spct'></span><span id='topic+spikes.generic_mspct'></span><span id='topic+spikes.source_mspct'></span><span id='topic+spikes.response_mspct'></span><span id='topic+spikes.filter_mspct'></span><span id='topic+spikes.reflector_mspct'></span><span id='topic+spikes.solute_mspct'></span><span id='topic+spikes.cps_mspct'></span><span id='topic+spikes.raw_mspct'></span>

<h3>Description</h3>

<p>Function that returns a subset of an R object with observations corresponding
to spikes. Spikes are values in spectra that are unusually high compared to
neighbors. They are usually individual values or very short runs of similar
&quot;unusual&quot; values. Spikes caused by cosmic radiation are a frequent problem in
Raman spectra. Another source of spikes are &quot;hot pixels&quot; in CCD and diode
arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spikes(x, z.threshold, max.spike.width, na.rm, ...)

## Default S3 method:
spikes(x, z.threshold = NA, max.spike.width = 8, na.rm = FALSE, ...)

## S3 method for class 'numeric'
spikes(x, z.threshold = NA, max.spike.width = 8, na.rm = FALSE, ...)

## S3 method for class 'data.frame'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  ...,
  y.var.name = NULL,
  var.name = y.var.name
)

## S3 method for class 'generic_spct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  var.name = NULL,
  ...
)

## S3 method for class 'source_spct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'response_spct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'filter_spct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  filter.qty = getOption("photobiology.filter.qty", default = "transmittance"),
  ...
)

## S3 method for class 'reflector_spct'
spikes(x, z.threshold = 9, max.spike.width = 8, na.rm = FALSE, ...)

## S3 method for class 'solute_spct'
spikes(x, z.threshold = 9, max.spike.width = 8, na.rm = FALSE, ...)

## S3 method for class 'cps_spct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  var.name = "cps",
  ...
)

## S3 method for class 'raw_spct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  var.name = "counts",
  ...
)

## S3 method for class 'generic_mspct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  ...,
  var.name = NULL,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'source_mspct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'response_mspct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'filter_mspct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  filter.qty = getOption("photobiology.filter.qty", default = "transmittance"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'reflector_mspct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'solute_mspct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'cps_mspct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  ...,
  var.name = "cps",
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'raw_mspct'
spikes(
  x,
  z.threshold = 9,
  max.spike.width = 8,
  na.rm = FALSE,
  ...,
  var.name = "counts",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spikes_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="spikes_+3A_z.threshold">z.threshold</code></td>
<td>
<p>numeric Modified Z values larger than <code>z.threshold</code>
are considered to correspond to spikes.</p>
</td></tr>
<tr><td><code id="spikes_+3A_max.spike.width">max.spike.width</code></td>
<td>
<p>integer Wider regions with high Z values are not
detected as spikes.</p>
</td></tr>
<tr><td><code id="spikes_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be stripped
before searching for spikes.</p>
</td></tr>
<tr><td><code id="spikes_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="spikes_+3A_var.name">var.name</code>, <code id="spikes_+3A_y.var.name">y.var.name</code></td>
<td>
<p>character Name of column where to look
for spikes.</p>
</td></tr>
<tr><td><code id="spikes_+3A_unit.out">unit.out</code></td>
<td>
<p>character One of &quot;energy&quot; or &quot;photon&quot;</p>
</td></tr>
<tr><td><code id="spikes_+3A_filter.qty">filter.qty</code></td>
<td>
<p>character One of &quot;transmittance&quot; or &quot;absorbance&quot;</p>
</td></tr>
<tr><td><code id="spikes_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="spikes_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spikes are detected based on a modified Z score calculated from the
differenced spectrum. The Z threshold used should be adjusted to the
characteristics of the input and desired sensitivity. The lower the
threshold the more stringent the test becomes, resulting in most cases in
more spikes being detected. A modified version of the algorithm is used if
a value different from <code>NULL</code> is passed as argument to
<code>max.spike.width</code>. In such a case, an additional step filters out
broader spikes (or falsely detected steep slopes) from the returned values.
</p>
<p>When the argument passed to <code>x</code> contains multiple spectra, the spikes
are searched for in each spectrum independently of other spectra.
</p>


<h3>Value</h3>

<p>A subset of the object passed as argument to <code>x</code> with rows
corresponding to spikes.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>spikes(default)</code>: Default returning always NA.
</p>
</li>
<li> <p><code>spikes(numeric)</code>: Default function usable on numeric vectors.
</p>
</li>
<li> <p><code>spikes(data.frame)</code>: Method for &quot;data.frame&quot; objects.
</p>
</li>
<li> <p><code>spikes(generic_spct)</code>: Method for &quot;generic_spct&quot; objects.
</p>
</li>
<li> <p><code>spikes(source_spct)</code>: Method for &quot;source_spct&quot; objects.
</p>
</li>
<li> <p><code>spikes(response_spct)</code>: Method for &quot;response_spct&quot; objects.
</p>
</li>
<li> <p><code>spikes(filter_spct)</code>: Method for &quot;filter_spct&quot; objects.
</p>
</li>
<li> <p><code>spikes(reflector_spct)</code>: Method for &quot;reflector_spct&quot; objects.
</p>
</li>
<li> <p><code>spikes(solute_spct)</code>: Method for &quot;solute_spct&quot; objects.
</p>
</li>
<li> <p><code>spikes(cps_spct)</code>: Method for &quot;cps_spct&quot; objects.
</p>
</li>
<li> <p><code>spikes(raw_spct)</code>: Method for &quot;raw_spct&quot; objects.
</p>
</li>
<li> <p><code>spikes(generic_mspct)</code>: Method for &quot;generic_mspct&quot; objects.
</p>
</li>
<li> <p><code>spikes(source_mspct)</code>: Method for &quot;source_mspct&quot; objects.
</p>
</li>
<li> <p><code>spikes(response_mspct)</code>: Method for &quot;cps_mspct&quot; objects.
</p>
</li>
<li> <p><code>spikes(filter_mspct)</code>: Method for &quot;filter_mspct&quot; objects.
</p>
</li>
<li> <p><code>spikes(reflector_mspct)</code>: Method for &quot;reflector_mspct&quot; objects.
</p>
</li>
<li> <p><code>spikes(solute_mspct)</code>: Method for &quot;solute_mspct&quot; objects.
</p>
</li>
<li> <p><code>spikes(cps_mspct)</code>: Method for &quot;cps_mspct&quot; objects.
</p>
</li>
<li> <p><code>spikes(raw_mspct)</code>: Method for &quot;raw_mspct&quot; objects.
</p>
</li></ul>


<h3>See Also</h3>

<p>See the documentation for <code><a href="#topic+find_spikes">find_spikes</a></code> for details of
the algorithm and implementation.
</p>
<p>Other peaks and valleys functions: 
<code><a href="#topic+find_peaks">find_peaks</a>()</code>,
<code><a href="#topic+find_spikes">find_spikes</a>()</code>,
<code><a href="#topic+get_peaks">get_peaks</a>()</code>,
<code><a href="#topic+peaks">peaks</a>()</code>,
<code><a href="#topic+replace_bad_pixs">replace_bad_pixs</a>()</code>,
<code><a href="#topic+valleys">valleys</a>()</code>,
<code><a href="#topic+wls_at_target">wls_at_target</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spikes(sun.spct)

</code></pre>

<hr>
<h2 id='split_bands'>List-of-wavebands constructor</h2><span id='topic+split_bands'></span>

<h3>Description</h3>

<p>Build a list of unweighted &quot;waveband&quot; objects that can be used as input when
calculating irradiances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_bands(
  x,
  list.names = NULL,
  short.names = is.null(list.names),
  length.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_bands_+3A_x">x</code></td>
<td>
<p>a numeric vector of wavelengths to split at (nm), or a range of
wavelengths or a generic_spct or a waveband.</p>
</td></tr>
<tr><td><code id="split_bands_+3A_list.names">list.names</code></td>
<td>
<p>character vector with names for the component wavebands in
the returned list (in order of increasing wavelength)</p>
</td></tr>
<tr><td><code id="split_bands_+3A_short.names">short.names</code></td>
<td>
<p>logical indicating whether to use short or long names for
wavebands</p>
</td></tr>
<tr><td><code id="split_bands_+3A_length.out">length.out</code></td>
<td>
<p>numeric giving the number of regions to split the range
into (ignored if w.length is not numeric).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an un-named list of waveband objects
</p>


<h3>Note</h3>

<p><code>list.names</code> is used to assign names to the elements of the list,
while the waveband objects themselves always retain their <code>wb.label</code>
and <code>wb.name</code> as generated during their creation.
</p>


<h3>See Also</h3>

<p>Other waveband constructors: 
<code><a href="#topic+waveband">waveband</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>split_bands(c(400,500,600))
split_bands(list(c(400,500),c(550,650)))
split_bands(list(A=c(400,500),B=c(550,650)))
split_bands(c(400,500,600), short.names=FALSE)
split_bands(c(400,500,600), list.names=c("a","b"))
split_bands(c(400,700), length.out=6)
split_bands(400:700, length.out=3)
split_bands(sun.spct, length.out=10)
split_bands(waveband(c(400,700)), length.out=5)

</code></pre>

<hr>
<h2 id='split_energy_irradiance'>Energy irradiance for split spectrum regions</h2><span id='topic+split_energy_irradiance'></span>

<h3>Description</h3>

<p>This function returns the energy irradiance for a series of contiguous
wavebands from a radiation-source spectrum. The returned values can be either
absolute or relative to their sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_energy_irradiance(
  w.length,
  s.irrad,
  cut.w.length = range(w.length),
  unit.in = "energy",
  scale = "absolute",
  check.spectrum = TRUE,
  use.cached.mult = FALSE,
  use.hinges = getOption("photobiology.use.hinges", default = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_energy_irradiance_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths (nm).</p>
</td></tr>
<tr><td><code id="split_energy_irradiance_+3A_s.irrad">s.irrad</code></td>
<td>
<p>numeric vector of spectral (energy or photon) irradiance values
(W m-2 nm-1) or (mol s-1 m-2 nm-1).</p>
</td></tr>
<tr><td><code id="split_energy_irradiance_+3A_cut.w.length">cut.w.length</code></td>
<td>
<p>numeric vector of wavelengths (nm).</p>
</td></tr>
<tr><td><code id="split_energy_irradiance_+3A_unit.in">unit.in</code></td>
<td>
<p>character string with allowed values &quot;energy&quot;, and &quot;photon&quot;,
or its alias &quot;quantum&quot;.</p>
</td></tr>
<tr><td><code id="split_energy_irradiance_+3A_scale">scale</code></td>
<td>
<p>character string indicating the scale used for the returned
values (&quot;absolute&quot;, &quot;relative&quot;, &quot;percent&quot;).</p>
</td></tr>
<tr><td><code id="split_energy_irradiance_+3A_check.spectrum">check.spectrum</code></td>
<td>
<p>logical indicating whether to sanity check input data,
default is TRUE.</p>
</td></tr>
<tr><td><code id="split_energy_irradiance_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag indicating whether multiplier values
should be cached between calls.</p>
</td></tr>
<tr><td><code id="split_energy_irradiance_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of irradiances with no change in scale factor: [W
m-2 nm-1] -&gt; [W m-2] or [mol s-1 m-2] -&gt; [W m-2] or relative values
(fraction of one) if scale = &quot;relative&quot; or scale = &quot;percent&quot;.
</p>


<h3>Note</h3>

<p>The last three parameters control speed optimizations. The defaults
should be suitable in most cases. If you set <code>check.spectrum=FALSE</code>
then you should call <code><a href="#topic+check_spectrum">check_spectrum</a></code> at least once for your
spectrum before using any of the other functions. If you will use
repeatedly the same SWFs on many spectra measured at exactly the same
wavelengths you may obtain some speed up by setting
<code>use.cached.mult=TRUE</code>. However, be aware that you are responsible for
ensuring that the wavelengths are the same in each call, as the only test
done is for the length of the <code>w.length</code> vector.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data,
     split_energy_irradiance(w.length, s.e.irrad,
                             cut.w.length = c(300, 400, 500, 600, 700)))

</code></pre>

<hr>
<h2 id='split_irradiance'>Energy or photon irradiance for split spectrum regions</h2><span id='topic+split_irradiance'></span>

<h3>Description</h3>

<p>This function returns the energy or photon irradiance for a series of
contiguous wavebands from a radiation spectrum. The returned values can be
either absolute or relative to their sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_irradiance(
  w.length,
  s.irrad,
  cut.w.length = range(w.length),
  unit.out = getOption("photobiology.base.unit", default = "energy"),
  unit.in = "energy",
  scale = "absolute",
  check.spectrum = TRUE,
  use.cached.mult = FALSE,
  use.hinges = getOption("photobiology.use.hinges", default = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_irradiance_+3A_w.length">w.length</code></td>
<td>
<p>numeric Vector of wavelengths [<code class="reqn">nm</code>].</p>
</td></tr>
<tr><td><code id="split_irradiance_+3A_s.irrad">s.irrad</code></td>
<td>
<p>numeric vector of spectral irradiances in
[<code class="reqn">W\,m^{-2}\,nm^{-1}</code>] or
[<code class="reqn">mol\,s^{-1}\,sm^{-2}\,nm^{-1}</code>] as indicated by the
argument pased to <code>unit.in</code>.</p>
</td></tr>
<tr><td><code id="split_irradiance_+3A_cut.w.length">cut.w.length</code></td>
<td>
<p>numeric Vector of wavelengths [<code class="reqn">nm</code>].</p>
</td></tr>
<tr><td><code id="split_irradiance_+3A_unit.out">unit.out</code>, <code id="split_irradiance_+3A_unit.in">unit.in</code></td>
<td>
<p>character Allowed values <code>"energy"</code>, and
<code>"photon"</code>, or its alias <code>"quantum"</code>.</p>
</td></tr>
<tr><td><code id="split_irradiance_+3A_scale">scale</code></td>
<td>
<p>a character A string indicating the scale used for the returned
values (<code>"absolute"</code>, <code>"relative"</code> or <code>"percent"</code>).</p>
</td></tr>
<tr><td><code id="split_irradiance_+3A_check.spectrum">check.spectrum</code></td>
<td>
<p>logical Flag indicating whether to sanity check input data,
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="split_irradiance_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag indicating whether multiplier values should be
cached between calls.</p>
</td></tr>
<tr><td><code id="split_irradiance_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of irradiances with no change in scale factor if
<code>scale == "absolute"</code>, [<code class="reqn">W\,m^{-2}</code>] or
[<code class="reqn">mol\,s^{-1}\,sm^{-2}</code>] depending on the argument passed
to <code>unit.out</code> or relative values (as fraction of one if <code>scale ==
  "relative"</code> or percentages if <code>scale == "percent"</code> of photons or
energy depending on the argument passed to <code>unit.out</code>.
</p>


<h3>Note</h3>

<p>The last three parameters control speed optimizations. The defaults
should be suitable in most cases. If you set <code>check.spectrum=FALSE</code>
then you should call <code><a href="#topic+check_spectrum">check_spectrum</a></code> at least once for your
spectrum before using any of the other functions. If you will use
repeatedly the same SWFs on many spectra measured at exactly the same
wavelengths you may obtain some speed up by setting
<code>use.cached.mult=TRUE</code>. However, be aware that you are responsible for
ensuring that the wavelengths are the same in each call, as the only test
done is for the length of the <code>w.length</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data,
      split_irradiance(w.length, s.e.irrad,
                       cut.w.length = c(300, 400, 500, 600, 700),
                       unit.out = "photon"))
</code></pre>

<hr>
<h2 id='split_photon_irradiance'>Photon irradiance for split spectrum regions</h2><span id='topic+split_photon_irradiance'></span>

<h3>Description</h3>

<p>This function returns the photon irradiance for a series of contiguous
wavebands from a radiation spectrum. The returned values can be either
absolute or relative to their sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_photon_irradiance(
  w.length,
  s.irrad,
  cut.w.length = range(w.length),
  unit.in = "energy",
  scale = "absolute",
  check.spectrum = TRUE,
  use.cached.mult = FALSE,
  use.hinges = getOption("photobiology.use.hinges", default = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_photon_irradiance_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths (nm).</p>
</td></tr>
<tr><td><code id="split_photon_irradiance_+3A_s.irrad">s.irrad</code></td>
<td>
<p>numeric vector of spectral (energy or photon) irradiance values
(W m-2 nm-1).</p>
</td></tr>
<tr><td><code id="split_photon_irradiance_+3A_cut.w.length">cut.w.length</code></td>
<td>
<p>numeric vector of wavelengths (nm).</p>
</td></tr>
<tr><td><code id="split_photon_irradiance_+3A_unit.in">unit.in</code></td>
<td>
<p>character Allowed values &quot;energy&quot;, and &quot;photon&quot;, or its alias
&quot;quantum&quot;.</p>
</td></tr>
<tr><td><code id="split_photon_irradiance_+3A_scale">scale</code></td>
<td>
<p>a character A string indicating the scale used for the returned
values (&quot;absolute&quot;, &quot;relative&quot;, &quot;percent&quot;).</p>
</td></tr>
<tr><td><code id="split_photon_irradiance_+3A_check.spectrum">check.spectrum</code></td>
<td>
<p>logical Flag indicating whether to sanity check input
data, default is TRUE.</p>
</td></tr>
<tr><td><code id="split_photon_irradiance_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag indicating whether multiplier values
should be cached between calls.</p>
</td></tr>
<tr><td><code id="split_photon_irradiance_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of photon irradiances with no change in scale factor:
[W m-2 nm-1] -&gt; [mol s-1 m-2], [mol s-1 m-2 nm-1] -&gt; [mol s-1 m-2] or
relative values (fraction of one based on photon units) if scale
= &quot;relative&quot; or scale = &quot;percent&quot;.
</p>


<h3>Note</h3>

<p>The last three parameters control speed optimizations. The defaults
should be suitable in most cases. If you set <code>check.spectrum=FALSE</code>
then you should call <code><a href="#topic+check_spectrum">check_spectrum</a></code> at least once for your
spectrum before using any of the other functions. If you will use
repeatedly the same SWFs on many spectra measured at exactly the same
wavelengths you may obtain some speed up by setting
<code>use.cached.mult=TRUE</code>. However, be aware that you are responsible for
ensuring that the wavelengths are the same in each call, as the only test
done is for the length of the <code>w.length</code> vector.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(sun.data,
     split_photon_irradiance(w.length, s.e.irrad,
             cut.w.length = c(300, 400, 500, 600, 700)))
with(sun.data,
     split_photon_irradiance(w.length, s.e.irrad))

</code></pre>

<hr>
<h2 id='split2mspct'>Convert a 'wide' or untidy data frame into a collection of spectra</h2><span id='topic+split2mspct'></span><span id='topic+split2source_mspct'></span><span id='topic+split2response_mspct'></span><span id='topic+split2filter_mspct'></span><span id='topic+split2reflector_mspct'></span><span id='topic+split2solute_mspct'></span><span id='topic+split2cps_mspct'></span><span id='topic+split2raw_mspct'></span><span id='topic+split2calibration_mspct'></span>

<h3>Description</h3>

<p>Convert a data frame object into a &quot;multi spectrum&quot; object by
constructing a an object of a multi-spct class, converting numeric columns
other than wavelength into individual spct objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split2mspct(
  x,
  member.class = NULL,
  spct.data.var = NULL,
  w.length.var = "w.length",
  idx.var = NULL,
  ncol = 1,
  byrow = FALSE,
  ...
)

split2source_mspct(
  x,
  spct.data.var = "s.e.irrad",
  w.length.var = "w.length",
  idx.var = NULL,
  ncol = 1,
  byrow = FALSE,
  ...
)

split2response_mspct(
  x,
  spct.data.var = "s.e.response",
  w.length.var = "w.length",
  idx.var = NULL,
  ncol = 1,
  byrow = FALSE,
  ...
)

split2filter_mspct(
  x,
  spct.data.var = "Tfr",
  w.length.var = "w.length",
  idx.var = NULL,
  ncol = 1,
  byrow = FALSE,
  ...
)

split2reflector_mspct(
  x,
  spct.data.var = "Rfr",
  w.length.var = "w.length",
  idx.var = NULL,
  ncol = 1,
  byrow = FALSE,
  ...
)

split2solute_mspct(
  x,
  spct.data.var = "K.mole",
  w.length.var = "w.length",
  idx.var = NULL,
  ncol = 1,
  byrow = FALSE,
  ...
)

split2cps_mspct(
  x,
  spct.data.var = "cps",
  w.length.var = "w.length",
  idx.var = NULL,
  ncol = 1,
  byrow = FALSE,
  ...
)

split2raw_mspct(
  x,
  spct.data.var = "count",
  w.length.var = "w.length",
  idx.var = NULL,
  ncol = 1,
  byrow = FALSE,
  ...
)

split2calibration_mspct(
  x,
  spct.data.var = "irrad.mult",
  w.length.var = "w.length",
  idx.var = NULL,
  ncol = 1,
  byrow = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split2mspct_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="split2mspct_+3A_member.class">member.class</code></td>
<td>
<p>character Class of the collection members</p>
</td></tr>
<tr><td><code id="split2mspct_+3A_spct.data.var">spct.data.var</code></td>
<td>
<p>character Name of the spectral data argument in the
object constructor for <code>member.class</code></p>
</td></tr>
<tr><td><code id="split2mspct_+3A_w.length.var">w.length.var</code></td>
<td>
<p>character Name of column containing wavelength data in
nanometres</p>
</td></tr>
<tr><td><code id="split2mspct_+3A_idx.var">idx.var</code></td>
<td>
<p>character Name of column containing data to be copied
unchanged to each spct object</p>
</td></tr>
<tr><td><code id="split2mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data</p>
</td></tr>
<tr><td><code id="split2mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data</p>
</td></tr>
<tr><td><code id="split2mspct_+3A_...">...</code></td>
<td>
<p>additional named arguments passed to the member constructor
function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.calibration_mspct">as.calibration_mspct</a>()</code>,
<code><a href="#topic+as.chroma_mspct">as.chroma_mspct</a>()</code>,
<code><a href="#topic+as.cps_mspct">as.cps_mspct</a>()</code>,
<code><a href="#topic+as.filter_mspct">as.filter_mspct</a>()</code>,
<code><a href="#topic+as.generic_mspct">as.generic_mspct</a>()</code>,
<code><a href="#topic+as.object_mspct">as.object_mspct</a>()</code>,
<code><a href="#topic+as.raw_mspct">as.raw_mspct</a>()</code>,
<code><a href="#topic+as.reflector_mspct">as.reflector_mspct</a>()</code>,
<code><a href="#topic+as.response_mspct">as.response_mspct</a>()</code>,
<code><a href="#topic+as.solute_mspct">as.solute_mspct</a>()</code>,
<code><a href="#topic+as.source_mspct">as.source_mspct</a>()</code>,
<code><a href="#topic+subset2mspct">subset2mspct</a>()</code>
</p>

<hr>
<h2 id='spread'>Expanse</h2><span id='topic+spread'></span><span id='topic+wl_expanse'></span><span id='topic+expanse'></span><span id='topic+expanse.default'></span><span id='topic+expanse.numeric'></span><span id='topic+expanse.waveband'></span><span id='topic+expanse.generic_spct'></span><span id='topic+expanse.generic_mspct'></span>

<h3>Description</h3>

<p>A method that returns the expanse (<code class="reqn">max(x) - min(x)</code>) for R objects. In
particular the wavelength [<code class="reqn">nm</code>] expanse of the wavelength range of
objects of classes <code>waveband</code> or of class <code>generic_spct</code> or derived
(or the expanse of values in a <code>numeric</code> vector).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread(x, ...)

wl_expanse(x, ...)

expanse(x, ...)

## Default S3 method:
expanse(x, ...)

## S3 method for class 'numeric'
expanse(x, ...)

## S3 method for class 'waveband'
expanse(x, ...)

## S3 method for class 'generic_spct'
expanse(x, ...)

## S3 method for class 'generic_mspct'
expanse(x, ..., idx = "spct.idx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="spread_+3A_...">...</code></td>
<td>
<p>not used in current version</p>
</td></tr>
<tr><td><code id="spread_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value equal to <code>max(x) - min(x)</code>. In the case of
spectral objects wavelength difference [<code class="reqn">nm</code>]. For any other R object,
according to available specialised methods of <code><a href="#topic+min">min</a></code> and
<code><a href="#topic+max">max</a></code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>expanse(default)</code>: Default method for generic function
</p>
</li>
<li> <p><code>expanse(numeric)</code>: Method for &quot;numeric&quot;
</p>
</li>
<li> <p><code>expanse(waveband)</code>: Method for &quot;waveband&quot;
</p>
</li>
<li> <p><code>expanse(generic_spct)</code>: Method for &quot;generic_spct&quot;
</p>
</li>
<li> <p><code>expanse(generic_mspct)</code>: Method for &quot;generic_mspct&quot; objects.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>expanse(10:20)
expanse(sun.spct)
wl_expanse(sun.spct)

expanse(sun.spct)

</code></pre>

<hr>
<h2 id='Subset'>Subsetting spectra</h2><span id='topic+Subset'></span><span id='topic+subset.generic_spct'></span>

<h3>Description</h3>

<p>Return subsets of spectra stored in class <code>generic_spct</code> or derived from
it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
subset(x, subset, select, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Subset_+3A_x">x</code></td>
<td>
<p>object to be subsetted.</p>
</td></tr>
<tr><td><code id="Subset_+3A_subset">subset</code></td>
<td>
<p>logical expression indicating elements or rows to keep: missing
values are taken as false.</p>
</td></tr>
<tr><td><code id="Subset_+3A_select">select</code></td>
<td>
<p>expression, indicating columns to select from a spectrum.</p>
</td></tr>
<tr><td><code id="Subset_+3A_drop">drop</code></td>
<td>
<p>passed on to <code>[</code> indexing operator.</p>
</td></tr>
<tr><td><code id="Subset_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object similar to <code>x</code> containing just the selected rows and
columns. Depending on the columns remaining after subsetting the class of
the object will be simplified to the most derived parent class.
</p>


<h3>Note</h3>

<p>This method is copied from <code>base::subset.data.frame()</code> but ensures
that all metadata stored in attributes of spectral objects are copied to
the returned value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
subset(sun.spct, w.length &gt; 400)

</code></pre>

<hr>
<h2 id='subset_attributes'>Subset the metadata attributes</h2><span id='topic+subset_attributes'></span><span id='topic+subset_attributes.default'></span><span id='topic+subset_attributes.generic_spct'></span>

<h3>Description</h3>

<p>Method returning attributes of an object of class generic_spct or derived,
or of class waveband. Only attributes defined and/or set by package
'photobiology' for objects of the corresponding class are returned. Parameter
<code>which</code> can be used to subset each attribute when a generic_spct object
with multiple spectra in long form is subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_attributes(x, to.keep, ...)

## Default S3 method:
subset_attributes(x, to.keep, ...)

## S3 method for class 'generic_spct'
subset_attributes(
  x,
  to.keep = character(),
  target.attributes = spct_attributes(class(x)[1]),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_attributes_+3A_x">x</code></td>
<td>
<p>a generic_spct object.</p>
</td></tr>
<tr><td><code id="subset_attributes_+3A_to.keep">to.keep</code></td>
<td>
<p>character vector Indices to the spectra for
which attributes are to be extracted and retained.</p>
</td></tr>
<tr><td><code id="subset_attributes_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="subset_attributes_+3A_target.attributes">target.attributes</code></td>
<td>
<p>character vector Names of attributes to be subset using
<code>which</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values in <code>which</code> are passed as argument to the extract
operator only if the value of the attribute is a list of the same length
as the logical vector passed as argument to <code>which</code>.
</p>


<h3>Value</h3>

<p>Named <code>list</code> of attribute values.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>subset_attributes(default)</code>: default
</p>
</li>
<li> <p><code>subset_attributes(generic_spct)</code>: generic_spct
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+select_spct_attributes">select_spct_attributes</a></code>
</p>
<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>

<hr>
<h2 id='subset2mspct'>Convert 'long' or tidy spectral data into a collection of spectra</h2><span id='topic+subset2mspct'></span>

<h3>Description</h3>

<p>Convert a data frame object or spectral object into a collection
of spectra object of the matching class. For data frames converting numeric
columns other than wavelength into individual spct objects. For collection
of spectra objects, subset/expand long-form members into multiple members
of the same collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset2mspct(
  x,
  member.class = NULL,
  idx.var = getIdFactor(x),
  drop.idx = TRUE,
  ncol = 1,
  byrow = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset2mspct_+3A_x">x</code></td>
<td>
<p>a generic_spct object or of a derived class, or a data frame, or a
generic_mspct object or of a derived class.</p>
</td></tr>
<tr><td><code id="subset2mspct_+3A_member.class">member.class</code></td>
<td>
<p>character string.</p>
</td></tr>
<tr><td><code id="subset2mspct_+3A_idx.var">idx.var</code></td>
<td>
<p>character Name of column containing data to be copied
unchanged to each spct object.</p>
</td></tr>
<tr><td><code id="subset2mspct_+3A_drop.idx">drop.idx</code></td>
<td>
<p>logical Flag indicating whether to drop or keep idx.var in
the collection members.</p>
</td></tr>
<tr><td><code id="subset2mspct_+3A_ncol">ncol</code></td>
<td>
<p>integer Number of 'virtual' columns in data.</p>
</td></tr>
<tr><td><code id="subset2mspct_+3A_byrow">byrow</code></td>
<td>
<p>logical If <code>ncol &gt; 1</code> how to read in the data.</p>
</td></tr>
<tr><td><code id="subset2mspct_+3A_...">...</code></td>
<td>
<p>additional named arguments passed to the member constructor
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A collection of spectral objects, each with attributes set if x is a
spectral object in long form with metadata attributes. If this object
was created by row binding with 'photobiology' 0.9.14 or later then
all metadata for each individual spectrum will be preserved, except for
unique comments which are merged.
</p>


<h3>Note</h3>

<p>A non-null value for <code>member.class</code> is mandatory only when
<code>x</code> is a data frame.
</p>


<h3>See Also</h3>

<p>Other Coercion methods for collections of spectra: 
<code><a href="#topic+as.calibration_mspct">as.calibration_mspct</a>()</code>,
<code><a href="#topic+as.chroma_mspct">as.chroma_mspct</a>()</code>,
<code><a href="#topic+as.cps_mspct">as.cps_mspct</a>()</code>,
<code><a href="#topic+as.filter_mspct">as.filter_mspct</a>()</code>,
<code><a href="#topic+as.generic_mspct">as.generic_mspct</a>()</code>,
<code><a href="#topic+as.object_mspct">as.object_mspct</a>()</code>,
<code><a href="#topic+as.raw_mspct">as.raw_mspct</a>()</code>,
<code><a href="#topic+as.reflector_mspct">as.reflector_mspct</a>()</code>,
<code><a href="#topic+as.response_mspct">as.response_mspct</a>()</code>,
<code><a href="#topic+as.solute_mspct">as.solute_mspct</a>()</code>,
<code><a href="#topic+as.source_mspct">as.source_mspct</a>()</code>,
<code><a href="#topic+split2mspct">split2mspct</a>()</code>
</p>

<hr>
<h2 id='subt_spectra'>Subtract two spectra</h2><span id='topic+subt_spectra'></span>

<h3>Description</h3>

<p>The wavelength vectors of the two spectra are merged, and the missing
spectral values are calculated by interpolation. After this, the two spectral
values at each wavelength are added. This is 'parallel' operation between two
spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subt_spectra(
  w.length1,
  w.length2 = NULL,
  s.irrad1,
  s.irrad2,
  trim = "union",
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subt_spectra_+3A_w.length1">w.length1</code></td>
<td>
<p>numeric vector of wavelength (nm).</p>
</td></tr>
<tr><td><code id="subt_spectra_+3A_w.length2">w.length2</code></td>
<td>
<p>numeric vector of wavelength (nm).</p>
</td></tr>
<tr><td><code id="subt_spectra_+3A_s.irrad1">s.irrad1</code></td>
<td>
<p>a numeric vector of spectral values.</p>
</td></tr>
<tr><td><code id="subt_spectra_+3A_s.irrad2">s.irrad2</code></td>
<td>
<p>a numeric vector of spectral values.</p>
</td></tr>
<tr><td><code id="subt_spectra_+3A_trim">trim</code></td>
<td>
<p>a character string with value &quot;union&quot; or &quot;intersection&quot;.</p>
</td></tr>
<tr><td><code id="subt_spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value, if TRUE, not the default, NAs in the input are
replaced with zeros.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If trim==&quot;union&quot; spectral values are calculated for the whole range
of wavelengths covered by at least one of the input spectra, and missing
values are set in each input spectrum to zero before addition. If
trim==&quot;intersection&quot; then the range of wavelengths covered by both input
spectra is returned, and the non-overlapping regions discarded. If
w.length2==NULL, it is assumed that both spectra are measured at the same
wavelengths, and a simple addition is used, ensuring fast calculation.
</p>


<h3>Value</h3>

<p>a data frame with two numeric variables </p>
<table>
<tr><td><code>w.length</code></td>
<td>
<p>A numeric
vector with the wavelengths (nm) obtained by &quot;fusing&quot; w.length1 and
w.length2. w.length contains all the unique vales, sorted in ascending
order.</p>
</td></tr> <tr><td><code>s.irrad</code></td>
<td>
<p>A numeric vector with the sum of the two spectral
values at each wavelength.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(sun.data)
zero.data &lt;- with(sun.data, subt_spectra(w.length, w.length, s.e.irrad, s.e.irrad))
head(zero.data)
tail(zero.data)

</code></pre>

<hr>
<h2 id='sum_spectra'>Add two spectra</h2><span id='topic+sum_spectra'></span>

<h3>Description</h3>

<p>Merge wavelength vectors of two spectra, and compute the missing spectral
values by interpolation within each spectrum. After this, the spectral values
at each wavelength are added. This is a 'parallel' operation between two
spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_spectra(
  w.length1,
  w.length2 = NULL,
  s.irrad1,
  s.irrad2,
  trim = "union",
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_spectra_+3A_w.length1">w.length1</code></td>
<td>
<p>numeric vector of wavelength (nm).</p>
</td></tr>
<tr><td><code id="sum_spectra_+3A_w.length2">w.length2</code></td>
<td>
<p>numeric vector of wavelength (nm).</p>
</td></tr>
<tr><td><code id="sum_spectra_+3A_s.irrad1">s.irrad1</code></td>
<td>
<p>a numeric vector of spectral values.</p>
</td></tr>
<tr><td><code id="sum_spectra_+3A_s.irrad2">s.irrad2</code></td>
<td>
<p>a numeric vector of spectral values.</p>
</td></tr>
<tr><td><code id="sum_spectra_+3A_trim">trim</code></td>
<td>
<p>a character string with value &quot;union&quot; or &quot;intersection&quot;.</p>
</td></tr>
<tr><td><code id="sum_spectra_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value, if TRUE, not the default, NAs in the input are
replaced with zeros.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If trim==&quot;union&quot; spectral values are calculated for the whole range
of wavelengths covered by at least one of the input spectra, and missing
values are set in each input spectrum to zero before addition. If
trim==&quot;intersection&quot; then the range of wavelengths covered by both input
spectra is returned, and the non-overlapping regions discarded. If
<code>w.length2 = NULL</code>, it is assumed that both spectra are measured at the same
wavelengths, and a simple addition is used, ensuring fast calculation.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with two numeric variables </p>
<table>
<tr><td><code>w.length</code></td>
<td>
<p>A numeric
vector with the wavelengths (nm) obtained by &quot;fusing&quot; w.length1 and
w.length2. w.length contains all the unique vales, sorted in ascending
order.</p>
</td></tr> <tr><td><code>s.irrad</code></td>
<td>
<p>A numeric vector with the sum of the two spectral
values at each wavelength.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
head(sun.data)
twice.sun.data &lt;- with(sun.data, sum_spectra(w.length, w.length, s.e.irrad, s.e.irrad))
head(twice.sun.data)
tail(twice.sun.data)

</code></pre>

<hr>
<h2 id='summary'>Summary of a collection of spectra</h2><span id='topic+summary'></span><span id='topic+summary.generic_mspct'></span><span id='topic+summary.generic_spct'></span>

<h3>Description</h3>

<p>Method of generic function summary for objects of spectral collection
classes.
</p>
<p>Methods of generic function summary for objects of spectral classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_mspct'
summary(
  object,
  maxsum = 7,
  digits = max(3, getOption("digits") - 3),
  idx = "spct.idx",
  which.metadata = NULL,
  ...
)

## S3 method for class 'generic_spct'
summary(object, maxsum = 7, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>An object of one of the spectral classes for which a summary is
desired</p>
</td></tr>
<tr><td><code id="summary_+3A_maxsum">maxsum</code></td>
<td>
<p>integer Indicates how many levels should be shown for factors.</p>
</td></tr>
<tr><td><code id="summary_+3A_digits">digits</code></td>
<td>
<p>integer Used for number formatting with <code><a href="base.html#topic+format">format</a>()</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="summary_+3A_which.metadata">which.metadata</code></td>
<td>
<p>character vector Names of attributes to retrieve, or
&quot;none&quot; or &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced, ignored in
current version</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary object matching the class of <code>object</code>.
</p>
<p>A summary object matching the class of <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(sun.spct)

summary(sun.spct)

</code></pre>

<hr>
<h2 id='summary_spct_classes'>Function that returns a vector containing the names of spectral summary
classes.</h2><span id='topic+summary_spct_classes'></span>

<h3>Description</h3>

<p>Function that returns a vector containing the names of spectral summary
classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_spct_classes()
</code></pre>


<h3>Value</h3>

<p>A <code>character</code> vector of class names.
</p>

<hr>
<h2 id='sun_angles'>Solar angles</h2><span id='topic+sun_angles'></span><span id='topic+sun_angles_fast'></span><span id='topic+sun_elevation'></span><span id='topic+sun_zenith_angle'></span><span id='topic+sun_azimuth'></span><span id='topic+distance_to_sun'></span>

<h3>Description</h3>

<p>Function <code>sun_angles()</code> returns the solar angles and Sun to Earth
relative distance for given times and locations using a very precise
algorithm. Convenience functions <code>sun_azimuth()</code>,
<code>sun_elevation()</code>, <code>sun_zenith_angle()</code> and
<code>distance_to_sun()</code> are wrappers on <code>sun_angles()</code> that return
individual vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sun_angles(
  time = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)

sun_angles_fast(time, tz, geocode, use.refraction)

sun_elevation(
  time = lubridate::now(),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)

sun_zenith_angle(
  time = lubridate::now(),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)

sun_azimuth(
  time = lubridate::now(),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)

distance_to_sun(
  time = lubridate::now(),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sun_angles_+3A_time">time</code></td>
<td>
<p>A &quot;vector&quot; of POSIXct Time, with any valid time zone (TZ) is
allowed, default is current time.</p>
</td></tr>
<tr><td><code id="sun_angles_+3A_tz">tz</code></td>
<td>
<p>character string indicating time zone to be used in output.</p>
</td></tr>
<tr><td><code id="sun_angles_+3A_geocode">geocode</code></td>
<td>
<p>data frame with variables lon and lat as numeric values
(degrees), nrow &gt; 1, allowed.</p>
</td></tr>
<tr><td><code id="sun_angles_+3A_use.refraction">use.refraction</code></td>
<td>
<p>logical Flag indicating whether to correct for
fraction in the atmosphere.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an implementation of Meeus equations as used in
NOAAs on-line web calculator, which are precise and valid for a very broad
range of dates (years -1000 to 3000 at least). The apparent solar
elevations near sunrise and sunset are affected by refraction in the
atmosphere, which does in turn depend on weather conditions. The effect of
refraction on the apparent position of the sun is only an estimate based on
&quot;typical&quot; conditions for the atmosphere. The computation is not defined for
latitudes 90 and -90 degrees, i.e. exactly at the poles. The function is
vectorized and in particular passing a vector of times for a single geocode
enhances performance very much as the equation of time, the most time
consuming step, is computed only once.
</p>
<p>For improved performance, if more than one angle is needed it
is preferable to directly call <code>sun_angles</code> instead of the wrapper
functions as this avoids the unnecesary recalculation.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with variables <code>time</code> (in same TZ as input),
<code>TZ</code>, <code>solartime</code>, <code>longitude</code>, <code>latitude</code>,
<code>address</code>, <code>azimuth</code>, <code>elevation</code>, <code>declination</code>,
<code>eq.of.time</code>, <code>hour.angle</code>, and <code>distance</code>. If a data frame
with multiple rows is passed to <code>geocode</code> and a vector of times longer
than one is passed to <code>time</code>, sun position for all combinations of
locations and times are returned by <code>sun_angles</code>. Angles are expressed
in degrees, <code>solartime</code> is a vector of class <code>"solar.time"</code>,
<code>distance</code> is expressed in relative sun units.
</p>


<h3>Important!</h3>

<p>Given an instant in time and a time zone, the date is
computed from these, and may differ by one day to that at the location
pointed by <code>geocode</code> at the same instant in time, unless the argument
passed to <code>tz</code> matches the time zone at this location.
</p>


<h3>Note</h3>

<p>There exists a different R implementation of the same algorithms called
&quot;AstroCalcPureR&quot; available as function <code>astrocalc4r</code> in package
'fishmethods'. Although the equations used are almost all the same, the
function signatures and which values are returned differ. In particular,
the present implementation splits the calculation into two separate
functions, one returning angles at given instants in time, and a separate
one returning the timing of events for given dates.
</p>


<h3>References</h3>

<p>The primary source for the algorithm used is the book:
Meeus, J. (1998) Astronomical Algorithms, 2 ed., Willmann-Bell, Richmond,
VA, USA. ISBN 978-0943396613.
</p>
<p>A different implementation is available at
<a href="https://github.com/NEFSC/READ-PDB-AstroCalc4R/">https://github.com/NEFSC/READ-PDB-AstroCalc4R/</a>.
</p>
<p>An interactive web page using the same algorithms is available at
<a href="https://gml.noaa.gov/grad/solcalc/">https://gml.noaa.gov/grad/solcalc/</a>. There are small
differences in the returned times compared to our function that seem to be
related to the estimation of atmospheric refraction (about 0.1 degrees).
</p>


<h3>See Also</h3>

<p>Other astronomy related functions: 
<code><a href="#topic+day_night">day_night</a>()</code>,
<code><a href="#topic+format.solar_time">format.solar_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
sun_angles()
sun_azimuth()
sun_elevation()
sun_zenith_angle()
sun_angles(ymd_hms("2014-09-23 12:00:00"))
sun_angles(ymd_hms("2014-09-23 12:00:00"),
           geocode = data.frame(lat=60, lon=0))
sun_angles(ymd_hms("2014-09-23 12:00:00") + minutes((0:6) * 10))

</code></pre>

<hr>
<h2 id='sun_daily.spct'>Daily solar spectral irradiance (simulated)</h2><span id='topic+sun_daily.spct'></span><span id='topic+sun_daily.data'></span><span id='topic+sun.daily.spct'></span><span id='topic+sun.daily.data'></span>

<h3>Description</h3>

<p>A dataset containing the wavelengths at a 1 nm interval and the corresponding
spectral (energy) irradiance. Values simulated for 2 June 2012, at Helsinki,
under clear sky conditions. The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sun_daily.spct

sun_daily.data

sun.daily.spct

sun.daily.data
</code></pre>


<h3>Format</h3>

<p>A <code>source_spct</code> object and a <code>data.frame</code>, each with 511
rows and 3 variables
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 511 rows and 3 columns.
</p>
<p>An object of class <code>source_spct</code> (inherits from <code>generic_spct</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 522 rows and 3 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 511 rows and 3 columns.
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm), range 290 to 800 nm. </p>
</li>
<li><p> s.e.irrad (J d-1
m-2 nm-1) </p>
</li>
<li><p> s.q.irrad (mol d-1 m-2 nm-1) </p>
</li></ul>



<h3>Deprecation!</h3>

<p>Objects <code>sun.daily.spct</code> and <code>sun.daily.data</code> have been renamed
into <code>sun_daily.spct</code> and <code>sun_daily.data</code>, for consistency with
other data sets in the package. Please, use the new names for new code.
</p>


<h3>Note</h3>

<p>The simulations are based on libRadTran using hourly mean global
radiation measurements to estimate cloud cover. The simulations were for
each hour and the results integrated for the whole day.
</p>


<h3>Author(s)</h3>

<p>Anders K. Lindfors (data)
</p>


<h3>References</h3>

<p>Lindfors, A.; Heikkil, A.; Kaurola, J.; Koskela, T. &amp; Lakkala,
K. (2009) Reconstruction of Solar Spectral Surface UV Irradiances Using
Radiative Transfer Simulations. Photochemistry and Photobiology, 85:
1233-1239
</p>


<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sun.daily.spct
summary(sun.daily.spct)

</code></pre>

<hr>
<h2 id='sun_evening.spct'>Time series of solar spectral irradiance (measured)</h2><span id='topic+sun_evening.spct'></span><span id='topic+sun_evening.mspct'></span>

<h3>Description</h3>

<p>Two data objects containing containing the same time series of five spectra.
Values measured in Viikki, Helsinki, under nearly clear sky in a summer
evening.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sun_evening.spct

sun_evening.mspct
</code></pre>


<h3>Format</h3>

<p>A <code>source_spct</code> object and a <code>source_mspct</code> object.
</p>
<p>An object of class <code>source_mspct</code> (inherits from <code>generic_mspct</code>, <code>list</code>) with 5 rows and 1 columns.
</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>
 <ul>
<li><p> w.length (nm), range 290 to 1000 nm. </p>
</li>
<li><p> s.e.irrad (J d-1
m-2 nm-1) </p>
</li>
<li><p> s.q.irrad (mol d-1 m-2 nm-1) </p>
</li></ul>



<h3>Author(s)</h3>

<p>Pedro J. Aphalo (data)
</p>


<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(sun_evening.mspct)
colnames(sun_evening.spct)

</code></pre>

<hr>
<h2 id='sun.spct'>Solar spectral irradiance (simulated)</h2><span id='topic+sun.spct'></span><span id='topic+sun.data'></span>

<h3>Description</h3>

<p>A dataset containing the wavelengths at a 1 nm interval and the
corresponding spectral (energy) irradiance and spectral photon irradiance.
Values simulated for 22 June 2010, near midday, at Helsinki, under partly
cloudy conditions. The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sun.spct

sun.data
</code></pre>


<h3>Format</h3>

<p>A <code>source_spct</code> object and a <code>data.frame</code>, each with 511
rows and 3 variables
</p>
<p>An object of class <code>data.frame</code> with 508 rows and 3 columns.
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm), range 293 to 800 nm. </p>
</li>
<li><p> s.e.irrad
(W m-2 nm-1) </p>
</li>
<li><p> s.q.irrad (mol m-2 nm-1) </p>
</li></ul>



<h3>Note</h3>

<p>Package 'photobiologySun' contains data sets for the daylight spectrum
under different conditions in and outside vegetation, stored in objects of
these same classes, ready to be used with package 'photobiology'.
</p>


<h3>Author(s)</h3>

<p>Anders K. Lindfors (data)
</p>


<h3>References</h3>

<p>Lindfors, A.; Heikkil, A.; Kaurola, J.; Koskela, T. &amp; Lakkala,
K. (2009) Reconstruction of Solar Spectral Surface UV Irradiances Using
Radiative Transfer Simulations. Photochemistry and Photobiology, 85:
1233-1239
</p>


<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sun.spct
summary(sun.spct)

</code></pre>

<hr>
<h2 id='T2A'>Convert transmittance into absorbance.</h2><span id='topic+T2A'></span><span id='topic+T2A.default'></span><span id='topic+T2A.numeric'></span><span id='topic+T2A.filter_spct'></span><span id='topic+T2A.filter_mspct'></span>

<h3>Description</h3>

<p>Function that converts transmittance (fraction) into <code class="reqn">\log_{10}</code>-based
absorbance (a.u.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T2A(x, action, byref, clean, ...)

## Default S3 method:
T2A(x, action = NULL, byref = FALSE, ...)

## S3 method for class 'numeric'
T2A(x, action = NULL, byref = FALSE, clean = TRUE, ...)

## S3 method for class 'filter_spct'
T2A(x, action = "add", byref = FALSE, clean = TRUE, strict.A = FALSE, ...)

## S3 method for class 'filter_mspct'
T2A(
  x,
  action = "add",
  byref = FALSE,
  clean = TRUE,
  strict.A = TRUE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T2A_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="T2A_+3A_action">action</code></td>
<td>
<p>character Allowed values <code>"replace"</code> and <code>"add"</code>.</p>
</td></tr>
<tr><td><code id="T2A_+3A_byref">byref</code></td>
<td>
<p>logical indicating if new object will be created by reference
or by copy of <code>x</code>.</p>
</td></tr>
<tr><td><code id="T2A_+3A_clean">clean</code></td>
<td>
<p>logical replace off-boundary values before conversion</p>
</td></tr>
<tr><td><code id="T2A_+3A_...">...</code></td>
<td>
<p>not used in current version</p>
</td></tr>
<tr><td><code id="T2A_+3A_strict.a">strict.A</code></td>
<td>
<p>logical Attempt to compute a true internal absorbance even
if <code>"total"</code> transmittance is stored in <code>x</code>.</p>
</td></tr>
<tr><td><code id="T2A_+3A_.parallel">.parallel</code></td>
<td>
<p>if <code>TRUE</code>, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="T2A_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Absorbance, <code class="reqn">A</code>, is frequently used in chemistry as it is linearly
related to the concentration of a solute dissolved in a solvent.
</p>
<p style="text-align: center;"><code class="reqn">A = -\log_{10} \tau</code>
</p>

<p>where, <code class="reqn">A</code> absorbance and <code class="reqn">\tau</code> is internal transmittance. By
default, if total transmittance, <code class="reqn">T</code>, is stored in <code>x</code>, the
returned value computed as
</p>
<p style="text-align: center;"><code class="reqn">A = -\log_{10} T</code>
</p>

<p>is not strictly absorbance. In this
case and in cases when the measured light attenuation is the result of
scattering, or when part of measured light is re-emitted after absorption
the use of <em>attenuance</em> is the IUPAC-recommended name for this quantity.
</p>
<p>If <code>strict.A = TRUE</code> is passed in the call and total
transmittance, <code class="reqn">T</code>, and total
reflectance, <code class="reqn">\rho</code>, are both available, absorbance is computed as:
</p>
<p style="text-align: center;"><code class="reqn">A = -\log_{10} (T - \rho) / (1 - \rho)</code>
</p>

<p>where <code class="reqn">\rho</code> can be either spectral total reflectance stored in <code>x</code>
as data or a single approximate <code>Rfr.constant</code> value stored as part
of the metadata.
</p>


<h3>Value</h3>

<p>A copy of <code>x</code> with a column <code>A</code> added and other columns
possibly deleted except for <code>w.length</code>. If <code>action = "replace"</code>,
in all cases, the additional columns are removed, even if no column needs
to be added.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>T2A(default)</code>: Default method for generic function
</p>
</li>
<li> <p><code>T2A(numeric)</code>: Method for numeric vectors
</p>
</li>
<li> <p><code>T2A(filter_spct)</code>: Method for filter spectra
</p>
</li>
<li> <p><code>T2A(filter_mspct)</code>: Method for collections of filter spectra
</p>
</li></ul>


<h3>Note</h3>

<p>The default <code>A.strict = FALSE</code> ensures indentical behaviour
as in 'photobiology' (&lt;= 0.11.0).
</p>


<h3>See Also</h3>

<p>Other quantity conversion functions: 
<code><a href="#topic+A2T">A2T</a>()</code>,
<code><a href="#topic+Afr2T">Afr2T</a>()</code>,
<code><a href="#topic+T2Afr">T2Afr</a>()</code>,
<code><a href="#topic+any2T">any2T</a>()</code>,
<code><a href="#topic+as_quantum">as_quantum</a>()</code>,
<code><a href="#topic+e2q">e2q</a>()</code>,
<code><a href="#topic+e2qmol_multipliers">e2qmol_multipliers</a>()</code>,
<code><a href="#topic+e2quantum_multipliers">e2quantum_multipliers</a>()</code>,
<code><a href="#topic+q2e">q2e</a>()</code>
</p>

<hr>
<h2 id='T2Afr'>Convert transmittance into absorptance.</h2><span id='topic+T2Afr'></span><span id='topic+T2Afr.default'></span><span id='topic+T2Afr.numeric'></span><span id='topic+T2Afr.filter_spct'></span><span id='topic+T2Afr.object_spct'></span><span id='topic+T2Afr.filter_mspct'></span><span id='topic+T2Afr.object_mspct'></span>

<h3>Description</h3>

<p>Function that converts transmittance (fraction) into absorptance (fraction).
If reflectance (fraction) is available, it also allows conversions between
internal and total absorptance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T2Afr(x, action, byref, clean, ...)

## Default S3 method:
T2Afr(x, action = NULL, byref = FALSE, clean = FALSE, ...)

## S3 method for class 'numeric'
T2Afr(x, action = NULL, byref = FALSE, clean = FALSE, Rfr = NA_real_, ...)

## S3 method for class 'filter_spct'
T2Afr(x, action = "add", byref = FALSE, clean = FALSE, ...)

## S3 method for class 'object_spct'
T2Afr(x, action = "add", byref = FALSE, clean = FALSE, ...)

## S3 method for class 'filter_mspct'
T2Afr(
  x,
  action = "add",
  byref = FALSE,
  clean = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'object_mspct'
T2Afr(
  x,
  action = "add",
  byref = FALSE,
  clean = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T2Afr_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="T2Afr_+3A_action">action</code></td>
<td>
<p>character Allowed values <code>"replace"</code> and <code>"add"</code>.</p>
</td></tr>
<tr><td><code id="T2Afr_+3A_byref">byref</code></td>
<td>
<p>logical indicating if new object will be created by reference
or by copy of <code>x</code>.</p>
</td></tr>
<tr><td><code id="T2Afr_+3A_clean">clean</code></td>
<td>
<p>logical replace off-boundary values before conversion.</p>
</td></tr>
<tr><td><code id="T2Afr_+3A_...">...</code></td>
<td>
<p>not used in current version.</p>
</td></tr>
<tr><td><code id="T2Afr_+3A_rfr">Rfr</code></td>
<td>
<p>numeric vector. Spectral reflectance o reflectance factor.
Set to zero if <code>x</code> is internal reflectance,</p>
</td></tr>
<tr><td><code id="T2Afr_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="T2Afr_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Absorptance, internal transmittance and total reflectance when expressed as
fractions, add up to one:
</p>
<p style="text-align: center;"><code class="reqn">1 = \alpha + \tau + \rho</code>
</p>

<p>where, <code class="reqn">\alpha</code> is absorptance, <code class="reqn">\tau</code> is internal transmittance and
<code class="reqn">\rho</code> is total reflectance. If any two of these quantities are known,
the third one can be computed from them.
</p>
<p>On the other hand:
</p>
<p style="text-align: center;"><code class="reqn">1 = \alpha\prime + T</code>
</p>

<p>where, <code class="reqn">\alpha\prime = \alpha + \rho</code>, measured together. In this case,
there is not enough information available to compute <code class="reqn">\alpha</code>.
</p>
<p>Thus, method <code>T2Afr()</code> computes
either <code class="reqn">\alpha</code> or <code class="reqn">\alpha\prime</code>,
depending on whether <code class="reqn">\tau</code> or <code class="reqn">T</code> are contained in the argument
passed to <code>x</code>, but neither of them when only <code class="reqn">\tau</code> is known. To
know which quantity has been computed, use <code>getTfrType()</code> to query
whether the computations were based on <code class="reqn">\tau</code> or <code class="reqn">T</code>.
</p>
<p>The R names used are: <code>Tfr</code> for <code class="reqn">\tau</code> and <code class="reqn">T</code> are <code>Tfr</code>,
<code>Afr</code> for <code class="reqn">\alpha</code> and <code class="reqn">\alpha\prime</code>, and <code>Rfr</code> for
<code class="reqn">rho</code>. The distinction between <code class="reqn">\tau</code> and <code class="reqn">T</code> and
between <code class="reqn">\alpha</code> and <code class="reqn">\alpha\prime</code> is made based on metadata
attributes.
</p>


<h3>Value</h3>

<p>A copy of <code>x</code> with a column <code>Afr</code> added and other columns
possibly deleted except for <code>w.length</code>. If <code>action = "replace"</code>,
in all cases, the redundant columns are removed, even when
column <code>Afr</code> was present in the argument passed to <code>x</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>T2Afr(default)</code>: Default method for generic function
</p>
</li>
<li> <p><code>T2Afr(numeric)</code>: Default method for generic function
</p>
</li>
<li> <p><code>T2Afr(filter_spct)</code>: Method for filter spectra
</p>
</li>
<li> <p><code>T2Afr(object_spct)</code>: Method for object spectra
</p>
</li>
<li> <p><code>T2Afr(filter_mspct)</code>: Method for collections of filter spectra
</p>
</li>
<li> <p><code>T2Afr(object_mspct)</code>: Method for collections of object spectra
</p>
</li></ul>


<h3>See Also</h3>

<p>Other quantity conversion functions: 
<code><a href="#topic+A2T">A2T</a>()</code>,
<code><a href="#topic+Afr2T">Afr2T</a>()</code>,
<code><a href="#topic+T2A">T2A</a>()</code>,
<code><a href="#topic+any2T">any2T</a>()</code>,
<code><a href="#topic+as_quantum">as_quantum</a>()</code>,
<code><a href="#topic+e2q">e2q</a>()</code>,
<code><a href="#topic+e2qmol_multipliers">e2qmol_multipliers</a>()</code>,
<code><a href="#topic+e2quantum_multipliers">e2quantum_multipliers</a>()</code>,
<code><a href="#topic+q2e">q2e</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T2Afr(Ler_leaf.spct)

</code></pre>

<hr>
<h2 id='tag'>Tag a spectrum</h2><span id='topic+tag'></span><span id='topic+tag.default'></span><span id='topic+tag.generic_spct'></span><span id='topic+tag.generic_mspct'></span>

<h3>Description</h3>

<p>Spectra are tagged by adding variables and attributes containing color
definitions, labels, and a factor following the wavebands given in
<code>w.band</code>. This methods are most useful for plotting realistic
computed colors from spectral data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tag(x, ...)

## Default S3 method:
tag(x, ...)

## S3 method for class 'generic_spct'
tag(
  x,
  w.band = NULL,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = TRUE,
  short.names = TRUE,
  chroma.type = "CMF",
  byref = FALSE,
  ...
)

## S3 method for class 'generic_mspct'
tag(
  x,
  w.band = NULL,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = TRUE,
  short.names = TRUE,
  chroma.type = "CMF",
  byref = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tag_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="tag_+3A_...">...</code></td>
<td>
<p>ignored (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="tag_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects. The waveband(s) determine
the region(s) of the spectrum that are tagged</p>
</td></tr>
<tr><td><code id="tag_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical Flag telling if wavebands crossing spectral data
boundaries are trimmed or ignored</p>
</td></tr>
<tr><td><code id="tag_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="tag_+3A_short.names">short.names</code></td>
<td>
<p>logical Flag indicating whether to use short or long names
for wavebands</p>
</td></tr>
<tr><td><code id="tag_+3A_chroma.type">chroma.type</code></td>
<td>
<p>character telling whether &quot;CMF&quot;, &quot;CC&quot;, or &quot;both&quot; should be returned
for human vision, or an object of class <code>chroma_spct</code> for any other
trichromic visual system.</p>
</td></tr>
<tr><td><code id="tag_+3A_byref">byref</code></td>
<td>
<p>logical Flag indicating if new object will be created <em>by
reference</em> or <em>by copy</em> of <code>x</code></p>
</td></tr>
<tr><td><code id="tag_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="tag_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code> expanded with additional columns with
color-related information.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tag(default)</code>: Default method for generic
</p>
</li>
<li> <p><code>tag(generic_spct)</code>: Tag one of <code>generic_spct</code>, and derived classes including
<code>source_spct</code>, <code>filter_spct</code>, <code>reflector_spct</code>,
<code>object_spct</code>, and <code>response_spct</code>.
</p>
</li>
<li> <p><code>tag(generic_mspct)</code>: Tag one of <code>generic_mspct</code>, and derived classes including
<code>source_mspct</code>, <code>filter_mspct</code>, <code>reflector_mspct</code>,
<code>object_mspct</code>, and <code>response_mspct</code>.
</p>
</li></ul>


<h3>Note</h3>

<p><code>NULL</code> as <code>w.band</code> argument does not add any new tags,
instead it removes existing tags if present. <code>NA</code>, the default, as
<code>w.band</code> argument removes existing waveband tags if present and
sets the <code>wl.color</code> variable. If a waveband object or a list of
wavebands is supplied as argument then tagging is based on them, and
<code>wl.color</code> is also set.
</p>


<h3>See Also</h3>

<p>Other tagging and related functions: 
<code><a href="#topic+is_tagged">is_tagged</a>()</code>,
<code><a href="#topic+untag">untag</a>()</code>,
<code><a href="#topic+wb2rect_spct">wb2rect_spct</a>()</code>,
<code><a href="#topic+wb2spct">wb2spct</a>()</code>,
<code><a href="#topic+wb2tagged_spct">wb2tagged_spct</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tag(sun.spct)
tag(sun.spct, list(A = waveband(c(300,3005))))

</code></pre>

<hr>
<h2 id='Tfr_fraction'>transmittance:transmittance fraction</h2><span id='topic+Tfr_fraction'></span><span id='topic+Tfr_fraction.default'></span><span id='topic+Tfr_fraction.filter_spct'></span><span id='topic+Tfr_fraction.filter_mspct'></span>

<h3>Description</h3>

<p>This function returns the transmittance fraction for a given pair of wavebands of a
filter spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tfr_fraction(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## Default S3 method:
Tfr_fraction(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## S3 method for class 'filter_spct'
Tfr_fraction(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...
)

## S3 method for class 'filter_mspct'
Tfr_fraction(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tfr_fraction_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;filter_spct&quot;.</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_w.band.num">w.band.num</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the numerator(s) and denominator(s) of the fraction(s).</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_w.band.denom">w.band.denom</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the denominator(s) of the fraction(s).</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_quantity">quantity</code></td>
<td>
<p>character One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_name.tag">name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="Tfr_fraction_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default <code>quantity = "mean"</code> or <code>quantity =
  "average"</code> the ratio is based on two <strong>mean spectral transmittance</strong>,
one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\overline{\mathrm{Tfr}_\lambda}(s, wb_\mathrm{num})}{\overline{\mathrm{Tfr}_\lambda}(s, wb_\mathrm{denom}) + \overline{\mathrm{Tfr}_\lambda}(s, wb_\mathrm{num})}</code>
</p>

<p>If the argument is set to <code>quantity = "total"</code> the fraction is based on
two <strong>integrated transmittance</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\mathrm{Tfr}(s, wb_\mathrm{num})}{\mathrm{Tfr}(s, wb_\mathrm{denom}) + \mathrm{Tfr}(s, wb_\mathrm{num})}</code>
</p>

<p>Only if the wavelength expanse of the two wavebands is the same, these two
ratios are numerically identical.
</p>


<h3>Value</h3>

<p>In the case of methods for individual spectra, a <code>numeric</code>
vector with name attribute set. The name is based on the name of the
wavebands unless a named list of wavebands is supplied in which case the
names of the list elements are used. &quot;[Tfr:Tfr]&quot; is appended if <code>quantity
  = "total"</code> and &quot;[Tfr(wl):Tfr(wl)]&quot; if <code>quantity = "mean"</code> or
<code>quantity = "average"</code>.
</p>
<p>A <code>data.frame</code> is returned in the case of collections of spectra,
containing one column for each fraction definition, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>Fraction definitions are &quot;assembled&quot; from the arguments passed to
<code>w.band.num</code> and <code>w.band.denom</code>. If both arguments are lists of
waveband definitions, with an equal number of members, then the wavebands
are paired to obtain as many fractions as the number of wavebands in each
list. Recycling for wavebands takes place when the number of denominator
and numerator wavebands differ.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>Tfr_fraction(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>Tfr_fraction(filter_spct)</code>: Method for <code>filter_spct</code> objects
</p>
</li>
<li> <p><code>Tfr_fraction(filter_mspct)</code>: Calculates Tfr:Tfr from a <code>filter_mspct</code>
object.
</p>
</li></ul>


<h3>Note</h3>

<p>The last two parameters control speed
optimizations. The defaults should be suitable in most cases. If you will
use repeatedly the same SWFs on many spectra measured at exactly the same
wavelengths you may obtain some speed up by setting
<code>use.cached.mult=TRUE</code>. However, be aware that you are responsible for
ensuring that the wavelengths are the same in each call, as the only test
done is for the length of the <code>w.length</code> vector.
</p>


<h3>See Also</h3>

<p>Other transmittance ratio functions: 
<code><a href="#topic+Tfr_normdiff">Tfr_normdiff</a>()</code>,
<code><a href="#topic+Tfr_ratio">Tfr_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Tfr_fraction(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"))
Tfr_fraction(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"),
             quantity = "total")
Tfr_fraction(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"),
             quantity = "mean")

</code></pre>

<hr>
<h2 id='Tfr_normdiff'>transmittance:transmittance normalised difference</h2><span id='topic+Tfr_normdiff'></span><span id='topic+Tfr_normdiff.default'></span><span id='topic+Tfr_normdiff.filter_spct'></span><span id='topic+Tfr_normdiff.filter_mspct'></span>

<h3>Description</h3>

<p>This function returns the transmittance normalized difference index for a given
pair of wavebands of a filter spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tfr_normdiff(
  spct,
  w.band.plus,
  w.band.minus,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## Default S3 method:
Tfr_normdiff(
  spct,
  w.band.plus,
  w.band.minus,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## S3 method for class 'filter_spct'
Tfr_normdiff(
  spct,
  w.band.plus = NULL,
  w.band.minus = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...
)

## S3 method for class 'filter_mspct'
Tfr_normdiff(
  spct,
  w.band.plus = NULL,
  w.band.minus = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tfr_normdiff_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;filter_spct&quot;.</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_w.band.plus">w.band.plus</code>, <code id="Tfr_normdiff_+3A_w.band.minus">w.band.minus</code></td>
<td>
<p>waveband object(s) or a list(s) of waveband
objects used to compute the additive and subtractive transmittance terms of
the normalized difference index.</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_quantity">quantity</code></td>
<td>
<p>character One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_name.tag">name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="Tfr_normdiff_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default <code>quantity = "mean"</code> or
<code>quantity = "average"</code> the ratio is based on
two <strong>mean spectral photon transmittances</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\overline{\mathrm{Tfr}_\lambda}(s, wb_\mathrm{plus}) - \overline{\mathrm{Tfr}_\lambda}(s, wb_\mathrm{minus})}{\overline{\mathrm{Tfr}_\lambda}(s, wb_\mathrm{plus}) + \overline{\mathrm{Tfr}_\lambda}(s, wb_\mathrm{minus})}</code>
</p>

<p>If the argument is set to <code>quantity = "total"</code> the fraction is based on
two <strong>photon transmittances</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\mathrm{Tfr}(s, wb_\mathrm{plus}) - \mathrm{Tfr}(s, wb_\mathrm{minus})}{\mathrm{Tfr}(s, wb_\mathrm{plus}) + \mathrm{Tfr}(s, wb_\mathrm{minus})}</code>
</p>

<p>Only if the wavelength expanse of the two wavebands is the same, these two
ratios are numerically identical.
</p>


<h3>Value</h3>

<p>In the case of methods for individual spectra, a <code>numeric</code>
vector with name attribute set. The name is based on the name of the
wavebands unless a named list of wavebands is supplied in which case the
names of the list elements are used. &quot;[Tfr:Tfr]&quot; is appended if <code>quantity
  = "total"</code> and &quot;[Tfr(wl):Tfr(wl)]&quot; if <code>quantity = "mean"</code> or
<code>quantity = "average"</code>.
</p>
<p>A <code>data.frame</code> is returned in the case of collections of spectra,
containing one column for each fraction definition, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>Fraction definitions are &quot;assembled&quot; from the arguments passed to
<code>w.band.num</code> and <code>w.band.denom</code>. If both arguments are lists of
waveband definitions, with an equal number of members, then the wavebands
are paired to obtain as many fractions as the number of wavebands in each
list. Recycling for wavebands takes place when the number of denominator
and numerator wavebands differ.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>Tfr_normdiff(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>Tfr_normdiff(filter_spct)</code>: Method for <code>filter_spct</code> objects
</p>
</li>
<li> <p><code>Tfr_normdiff(filter_mspct)</code>: Calculates Tfr:Tfr from a <code>filter_mspct</code>
object.
</p>
</li></ul>


<h3>Note</h3>

<p>The last two parameters control speed optimizations. The defaults
should be suitable in most cases. If you will use repeatedly the same SWFs
on many spectra measured at exactly the same wavelengths you may obtain
some speed up by setting <code>use.cached.mult =T RUE</code>. However, be aware
that you are responsible for ensuring that the wavelengths are the same in
each call, as the only test done is for the length of the <code>w.length</code>
vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalized_diff_ind">normalized_diff_ind</a></code>, accepts different summary
functions.
</p>
<p>Other transmittance ratio functions: 
<code><a href="#topic+Tfr_fraction">Tfr_fraction</a>()</code>,
<code><a href="#topic+Tfr_ratio">Tfr_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Tfr_normdiff(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"))
Tfr_normdiff(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"),
             quantity = "total")
Tfr_normdiff(Ler_leaf_rflt.spct,
             waveband(c(400,500), wb.name = "Blue"),
             waveband(c(600,700), wb.name = "Red"),
             quantity = "mean")

</code></pre>

<hr>
<h2 id='Tfr_ratio'>transmittance:transmittance ratio</h2><span id='topic+Tfr_ratio'></span><span id='topic+Tfr_ratio.default'></span><span id='topic+Tfr_ratio.filter_spct'></span><span id='topic+Tfr_ratio.filter_mspct'></span>

<h3>Description</h3>

<p>This function returns the transmittance ratio for a given pair of wavebands of a
filter spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tfr_ratio(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## Default S3 method:
Tfr_ratio(
  spct,
  w.band.num,
  w.band.denom,
  scale.factor,
  wb.trim,
  use.cached.mult,
  use.hinges,
  ...
)

## S3 method for class 'filter_spct'
Tfr_ratio(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...
)

## S3 method for class 'filter_mspct'
Tfr_ratio(
  spct,
  w.band.num = NULL,
  w.band.denom = NULL,
  scale.factor = 1,
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.cached.mult = FALSE,
  use.hinges = NULL,
  quantity = "mean",
  naming = "short",
  name.tag = NULL,
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tfr_ratio_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;filter_spct&quot;.</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_w.band.num">w.band.num</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the numerator(s) and denominator(s) of the ratio(s).</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_w.band.denom">w.band.denom</code></td>
<td>
<p>waveband object or a list of waveband objects used to
compute the denominator(s) of the ratio(s).</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_scale.factor">scale.factor</code></td>
<td>
<p>numeric vector of length 1, or length equal to that of
<code>w.band</code>. Numeric multiplier applied to returned values.</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_...">...</code></td>
<td>
<p>other arguments (possibly ignored)</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_quantity">quantity</code></td>
<td>
<p>character One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_name.tag">name.tag</code></td>
<td>
<p>character Used to tag the name of the returned values.</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax
for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="Tfr_ratio_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default <code>quantity = "mean"</code> or <code>quantity =
  "average"</code> the ratio is based on two <strong>mean spectral transmittance</strong>,
one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\overline{\mathrm{Tfr}_\lambda}(s, wb_\mathrm{num})}{\overline{\mathrm{Tfr}_\lambda}(s, wb_\mathrm{denom}))}</code>
</p>

<p>If the argument is set to <code>quantity = "total"</code> the ratio is based on
two <strong>integrated transmittance</strong>, one computed for each waveband.
</p>
<p style="text-align: center;"><code class="reqn">\frac{\mathrm{Tfr}(s, wb_\mathrm{num})}{\mathrm{Tfr}(s, wb_\mathrm{denom})}</code>
</p>

<p>Only if the wavelength expanse of the two wavebands is the same, these two
ratios are numerically identical.
</p>


<h3>Value</h3>

<p>In the case of methods for individual spectra, a <code>numeric</code>
vector with name attribute set. The name is based on the name of the
wavebands unless a named list of wavebands is supplied in which case the
names of the list elements are used. &quot;[Tfr:Tfr]&quot; is appended if <code>quantity
  = "total"</code> and &quot;[Tfr(wl):Tfr(wl)]&quot; if <code>quantity = "mean"</code> or
<code>quantity = "average"</code>.
</p>
<p>A <code>data.frame</code> is returned in the case of collections of spectra,
containing one column for each fraction definition, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>Fraction definitions are &quot;assembled&quot; from the arguments passed to
<code>w.band.num</code> and <code>w.band.denom</code>. If both arguments are lists of
waveband definitions, with an equal number of members, then the wavebands
are paired to obtain as many fractions as the number of wavebands in each
list. Recycling for wavebands takes place when the number of denominator
and numerator wavebands differ.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>Tfr_ratio(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>Tfr_ratio(filter_spct)</code>: Method for <code>filter_spct</code> objects
</p>
</li>
<li> <p><code>Tfr_ratio(filter_mspct)</code>: Calculates Tfr:Tfr from a <code>filter_mspct</code>
object.
</p>
</li></ul>


<h3>Note</h3>

<p>The last two parameters control speed
optimizations. The defaults should be suitable in most cases. If you will
use repeatedly the same SWFs on many spectra measured at exactly the same
wavelengths you may obtain some speed up by setting
<code>use.cached.mult=TRUE</code>. However, be aware that you are responsible for
ensuring that the wavelengths are the same in each call, as the only test
done is for the length of the <code>w.length</code> vector.
</p>


<h3>See Also</h3>

<p>Other transmittance ratio functions: 
<code><a href="#topic+Tfr_fraction">Tfr_fraction</a>()</code>,
<code><a href="#topic+Tfr_normdiff">Tfr_normdiff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Tfr_ratio(Ler_leaf_rflt.spct,
          waveband(c(400,500), wb.name = "Blue"),
          waveband(c(600,700), wb.name = "Red"))
Tfr_ratio(Ler_leaf_rflt.spct,
          waveband(c(400,500), wb.name = "Blue"),
          waveband(c(600,700), wb.name = "Red"),
          quantity = "total")
Tfr_ratio(Ler_leaf_rflt.spct,
          waveband(c(400,500), wb.name = "Blue"),
          waveband(c(600,700), wb.name = "Red"),
          quantity = "mean")

</code></pre>

<hr>
<h2 id='thin_wl'>Thin the density of wavelength values</h2><span id='topic+thin_wl'></span><span id='topic+thin_wl.default'></span><span id='topic+thin_wl.generic_spct'></span><span id='topic+thin_wl.source_spct'></span><span id='topic+thin_wl.response_spct'></span><span id='topic+thin_wl.filter_spct'></span><span id='topic+thin_wl.reflector_spct'></span><span id='topic+thin_wl.solute_spct'></span><span id='topic+thin_wl.raw_spct'></span><span id='topic+thin_wl.cps_spct'></span><span id='topic+thin_wl.object_spct'></span><span id='topic+thin_wl.chroma_spct'></span><span id='topic+thin_wl.calibration_spct'></span><span id='topic+thin_wl.generic_mspct'></span><span id='topic+thin_wl.chroma_mspct'></span><span id='topic+thin_wl.calibration_mspct'></span>

<h3>Description</h3>

<p>Increase the wavelength step in stored spectral data in featureless regions
to save storage space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin_wl(x, ...)

## Default S3 method:
thin_wl(x, ...)

## S3 method for class 'generic_spct'
thin_wl(
  x,
  max.wl.step = 10,
  max.slope.delta = 0.001,
  span = 21,
  col.names,
  ...
)

## S3 method for class 'source_spct'
thin_wl(
  x,
  max.wl.step = 10,
  max.slope.delta = 0.001,
  span = 21,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'response_spct'
thin_wl(
  x,
  max.wl.step = 10,
  max.slope.delta = 0.001,
  span = 21,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'filter_spct'
thin_wl(
  x,
  max.wl.step = 10,
  max.slope.delta = 0.001,
  span = 21,
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  ...
)

## S3 method for class 'reflector_spct'
thin_wl(x, max.wl.step = 10, max.slope.delta = 0.001, span = 21, ...)

## S3 method for class 'solute_spct'
thin_wl(x, max.wl.step = 10, max.slope.delta = 0.001, span = 21, ...)

## S3 method for class 'raw_spct'
thin_wl(
  x,
  max.wl.step = 10,
  max.slope.delta = 0.001,
  span = 21,
  col.names,
  ...
)

## S3 method for class 'cps_spct'
thin_wl(
  x,
  max.wl.step = 10,
  max.slope.delta = 0.001,
  span = 21,
  col.names,
  ...
)

## S3 method for class 'object_spct'
thin_wl(
  x,
  max.wl.step = 10,
  max.slope.delta = 0.001,
  span = 21,
  col.names,
  ...
)

## S3 method for class 'chroma_spct'
thin_wl(x, ...)

## S3 method for class 'calibration_spct'
thin_wl(x, ...)

## S3 method for class 'generic_mspct'
thin_wl(x, max.wl.step = 10, max.slope.delta = 0.001, span = 21, ...)

## S3 method for class 'chroma_mspct'
thin_wl(x, ...)

## S3 method for class 'calibration_mspct'
thin_wl(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin_wl_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
<tr><td><code id="thin_wl_+3A_...">...</code></td>
<td>
<p>additional named arguments passed down to <code>f</code>.</p>
</td></tr>
<tr><td><code id="thin_wl_+3A_max.wl.step">max.wl.step</code></td>
<td>
<p>numeric. Largest allowed wavelength difference between
adjacent spectral values in nanometres (nm).</p>
</td></tr>
<tr><td><code id="thin_wl_+3A_max.slope.delta">max.slope.delta</code></td>
<td>
<p>numeric in 0 to 1. Largest allowed change in relative
slope of the spectral quantity per nm between adjacent pairs of values.</p>
</td></tr>
<tr><td><code id="thin_wl_+3A_span">span</code></td>
<td>
<p>integer A peak (or valley) is defined as an element in a sequence
which is greater (or smaller) than all other elements within a window of
width span centred at that element. Use NULL for the global peak.</p>
</td></tr>
<tr><td><code id="thin_wl_+3A_col.names">col.names</code></td>
<td>
<p>character. Name of the column of <code>x</code> containing the
spectral data to check against <code>max.slope.delta</code>. Currently only one
column supported.</p>
</td></tr>
<tr><td><code id="thin_wl_+3A_unit.out">unit.out</code></td>
<td>
<p>character Allowed values &quot;energy&quot;, and &quot;photon&quot;, or its alias
&quot;quantum&quot;.</p>
</td></tr>
<tr><td><code id="thin_wl_+3A_qty.out">qty.out</code></td>
<td>
<p>character Allowed values &quot;transmittance&quot;, and &quot;absorbance&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm used for spectra is &quot;naive&quot; in an effort to keep it
efficient. It works by iteratively attempting to delete every other
observation along wavelengths, based on the criteria for maximum wavelength
step and maximum relative step in the spectral variable between adjacent
data values.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> but with a reduced density of
wavelength values in those regions were slope is shallow and featureless.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>thin_wl(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>thin_wl(generic_spct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(source_spct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(response_spct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(filter_spct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(reflector_spct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(solute_spct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(raw_spct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(cps_spct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(object_spct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(chroma_spct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(calibration_spct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(generic_mspct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(chroma_mspct)</code>: 
</p>
</li>
<li> <p><code>thin_wl(calibration_mspct)</code>: 
</p>
</li></ul>


<h3>Note</h3>

<p>The value of <code>max.slope.delta</code> is expressed as relative change in
the slope of spectral variable per nanometre. This means that values
between 0.0005 and 0.005 tend to work reasonably well. The best value will
depend on the wavelength step of the input and noise in data. A moderate
smoothing before thinning can sometimes help in the case of noisy data.
</p>
<p>The amount of thinning is almost always less than the value of criteria
passed as argument as it is based on existing wavelength values. For
example if we start with a spectrum with a uniform wavelength step of 1 nm,
possible steps in the thinned spectrum are 2, 4, 8, 16, 32, etc. nm. The
algorithm, does work with any step sizes, regular or variable in the input.
Thinning is most effective for spectra with large &quot;featureless&quot; regions as
the algorithm attempts not to discard information, contrary to smoothing or
interpolation.
</p>
<p>Local peaks and valleys are always preserved, using by default a span of 21
to search for them. See <code><a href="#topic+find_peaks">find_peaks</a></code>.
</p>


<h3>See Also</h3>

<p>Other experimental utility functions: 
<code><a href="#topic+collect2mspct">collect2mspct</a>()</code>,
<code><a href="#topic+drop_user_cols">drop_user_cols</a>()</code>,
<code><a href="#topic+uncollect2spct">uncollect2spct</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nrow(yellow_gel.spct)
wl_stepsize(yellow_gel.spct)
thinned.spct &lt;- thin_wl(yellow_gel.spct)
nrow(thinned.spct)
wl_stepsize(thinned.spct)

</code></pre>

<hr>
<h2 id='times-.generic_spct'>Arithmetic Operators</h2><span id='topic+times-.generic_spct'></span><span id='topic++2A.generic_spct'></span>

<h3>Description</h3>

<p>Multiplication operator for spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="times-.generic_spct_+3A_e1">e1</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
<tr><td><code id="times-.generic_spct_+3A_e2">e2</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other math operators and functions: 
<code><a href="#topic+MathFun">MathFun</a></code>,
<code><a href="#topic++5E.generic_spct">^.generic_spct</a>()</code>,
<code><a href="#topic+convolve_each">convolve_each</a>()</code>,
<code><a href="#topic+div-.generic_spct">div-.generic_spct</a></code>,
<code><a href="#topic+log">log</a>()</code>,
<code><a href="#topic+minus-.generic_spct">minus-.generic_spct</a></code>,
<code><a href="#topic+mod-.generic_spct">mod-.generic_spct</a></code>,
<code><a href="#topic+plus-.generic_spct">plus-.generic_spct</a></code>,
<code><a href="#topic+round">round</a>()</code>,
<code><a href="#topic+sign">sign</a>()</code>,
<code><a href="#topic+slash-.generic_spct">slash-.generic_spct</a></code>
</p>

<hr>
<h2 id='transmittance'>Transmittance</h2><span id='topic+transmittance'></span><span id='topic+transmittance.default'></span><span id='topic+transmittance.filter_spct'></span><span id='topic+transmittance.object_spct'></span><span id='topic+transmittance.filter_mspct'></span><span id='topic+transmittance.object_mspct'></span>

<h3>Description</h3>

<p>Summary transmittance for supplied wavebands from filter or object spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transmittance(spct, w.band, quantity, wb.trim, use.hinges, ...)

## Default S3 method:
transmittance(spct, w.band, quantity, wb.trim, use.hinges, ...)

## S3 method for class 'filter_spct'
transmittance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...
)

## S3 method for class 'object_spct'
transmittance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = NULL,
  naming = "default",
  ...
)

## S3 method for class 'filter_mspct'
transmittance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = getOption("photobiology.use.hinges", default = NULL),
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx"
)

## S3 method for class 'object_mspct'
transmittance(
  spct,
  w.band = NULL,
  quantity = "average",
  wb.trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = getOption("photobiology.use.hinges", default = NULL),
  naming = "default",
  ...,
  attr2tb = NULL,
  idx = "spct.idx",
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transmittance_+3A_spct">spct</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="transmittance_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects or a numeric vector of
length two. The waveband(s) determine the region(s) of the spectrum that
are summarized. If a numeric range is supplied a waveband object is
constructed on the fly from it.</p>
</td></tr>
<tr><td><code id="transmittance_+3A_quantity">quantity</code></td>
<td>
<p>character string One of <code>"average"</code> or <code>"mean"</code>,
<code>"total"</code>, <code>"contribution"</code>, <code>"contribution.pc"</code>,
<code>"relative"</code> or <code>"relative.pc"</code>.</p>
</td></tr>
<tr><td><code id="transmittance_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if <code>TRUE</code> wavebands crossing spectral data
boundaries are trimmed, if <code>FALSE</code>, they are discarded.</p>
</td></tr>
<tr><td><code id="transmittance_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="transmittance_+3A_...">...</code></td>
<td>
<p>ignored (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="transmittance_+3A_naming">naming</code></td>
<td>
<p>character one of <code>"long"</code>, <code>"default"</code>,
<code>"short"</code> or <code>"none"</code>. Used to select the type of names to assign
to returned value.</p>
</td></tr>
<tr><td><code id="transmittance_+3A_attr2tb">attr2tb</code></td>
<td>
<p>character vector, see <code><a href="#topic+add_attr2tb">add_attr2tb</a></code> for the syntax for <code>attr2tb</code> passed as is to formal parameter <code>col.names</code>.</p>
</td></tr>
<tr><td><code id="transmittance_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
<tr><td><code id="transmittance_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="transmittance_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>numeric</code> vector in the case of methods for individual
spectra, with one value for each <code>waveband</code> passed to parameter
<code>w.band</code>. A <code>data.frame</code> in the case of collections of spectra,
containing one column for each <code>waveband</code> object, an index column with
the names of the spectra, and optionally additional columns with metadata
values retrieved from the attributes of the member spectra.
</p>
<p>By default values are only integrated, but depending on the argument passed
to parameter <code>quantity</code> they can be re-expressed as relative fractions
or percentages. In the case of vector output, <code>names</code> attribute is set
to the name of the corresponding waveband unless a named list is supplied
in which case the names of the list members are used.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>transmittance(default)</code>: Default method
</p>
</li>
<li> <p><code>transmittance(filter_spct)</code>: Method for filter spectra
</p>
</li>
<li> <p><code>transmittance(object_spct)</code>: Method for object spectra
</p>
</li>
<li> <p><code>transmittance(filter_mspct)</code>: Calculates transmittance from a <code>filter_mspct</code>
</p>
</li>
<li> <p><code>transmittance(object_mspct)</code>: Calculates transmittance from a <code>object_mspct</code>
</p>
</li></ul>


<h3>Note</h3>

<p>The <code>use.hinges</code> parameter controls speed optimization. The
defaults should be suitable in most cases. Only the range of wavelengths
in the wavebands is used and all BSWFs are ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>transmittance(polyester.spct, waveband(c(280, 315)))
transmittance(polyester.spct, waveband(c(315, 400)))
transmittance(polyester.spct, waveband(c(400, 700)))

</code></pre>

<hr>
<h2 id='transmittance_spct'>Calculate transmittance from spectral transmittance.</h2><span id='topic+transmittance_spct'></span>

<h3>Description</h3>

<p>Mean transmittance for one or more wavebands of a filter or object spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transmittance_spct(spct, w.band, quantity, wb.trim, use.hinges, naming, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transmittance_spct_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;.</p>
</td></tr>
<tr><td><code id="transmittance_spct_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects or a numeric vector of
length two. The waveband(s) determine the region(s) of the spectrum that
are summarized. If a numeric range is supplied a waveband object is
constructed on the fly from it.</p>
</td></tr>
<tr><td><code id="transmittance_spct_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;,
&quot;contribution&quot;, &quot;contribution.pc&quot;, &quot;relative&quot; or &quot;relative.pc&quot;.</p>
</td></tr>
<tr><td><code id="transmittance_spct_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical Flag indicating if wavebands crossing spectral data boundaries
are trimmed or ignored.</p>
</td></tr>
<tr><td><code id="transmittance_spct_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="transmittance_spct_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
<tr><td><code id="transmittance_spct_+3A_...">...</code></td>
<td>
<p>other arguments (possibly used by derived methods).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value
</p>


<h3>Note</h3>

<p>The last parameter controls speed optimization. The defaults should be
suitable in most cases. Only the range of wavelengths in the wavebands is
used and all BSWFs are ignored.
</p>

<hr>
<h2 id='Trig'>Trigonometric Functions</h2><span id='topic+Trig'></span><span id='topic+cos.generic_spct'></span><span id='topic+sin.generic_spct'></span><span id='topic+tan.generic_spct'></span><span id='topic+acos.generic_spct'></span><span id='topic+asin.generic_spct'></span><span id='topic+atan.generic_spct'></span>

<h3>Description</h3>

<p>Trigonometric functions for object of <code>generic_spct</code> and derived
classes.  \
The functions are applied to the spectral data, not the wavelengths. The
quantity in the spectrum to which the function is applied depends on the class
of <code>x</code> and the current value of output options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'generic_spct'
cos(x)

## S3 method for class 'generic_spct'
sin(x)

## S3 method for class 'generic_spct'
tan(x)

## S3 method for class 'generic_spct'
acos(x)

## S3 method for class 'generic_spct'
asin(x)

## S3 method for class 'generic_spct'
atan(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Trig_+3A_x">x</code></td>
<td>
<p>an object of class &quot;generic_spct&quot; or a derived class.</p>
</td></tr>
</table>

<hr>
<h2 id='trim_spct'>Trim (or expand) head and/or tail of a spectrum</h2><span id='topic+trim_spct'></span><span id='topic+trim_mspct'></span><span id='topic+trim2overlap'></span><span id='topic+extend2extremes'></span>

<h3>Description</h3>

<p>Trim head and tail of a spectrum based on wavelength limits, interpolating
the values at the boundaries of the range. Trimming is needed for example to
remove short wavelength noise when the measured spectrum extends beyond the
known emission spectrum of the measured light source. Occasionally one may
want also to expand the wavelength range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_spct(
  spct,
  range = NULL,
  low.limit = NULL,
  high.limit = NULL,
  use.hinges = TRUE,
  fill = NULL,
  byref = FALSE,
  verbose = getOption("photobiology.verbose")
)

trim_mspct(
  mspct,
  range = NULL,
  low.limit = NULL,
  high.limit = NULL,
  use.hinges = TRUE,
  fill = NULL,
  byref = FALSE,
  verbose = getOption("photobiology.verbose"),
  .parallel = FALSE,
  .paropts = NULL
)

trim2overlap(
  mspct,
  use.hinges = TRUE,
  verbose = getOption("photobiology.verbose"),
  .parallel = FALSE,
  .paropts = NULL
)

extend2extremes(
  mspct,
  use.hinges = TRUE,
  fill = NA,
  verbose = getOption("photobiology.verbose"),
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_spct_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;generic_spct&quot;.</p>
</td></tr>
<tr><td><code id="trim_spct_+3A_range">range</code></td>
<td>
<p>a numeric vector of length two, or any other object for which
method range() will return a numeric vector of length two.</p>
</td></tr>
<tr><td><code id="trim_spct_+3A_low.limit">low.limit</code></td>
<td>
<p>shortest wavelength to be kept (defaults to shortest
w.length value).</p>
</td></tr>
<tr><td><code id="trim_spct_+3A_high.limit">high.limit</code></td>
<td>
<p>longest wavelength to be kept (defaults to longest w.length
value).</p>
</td></tr>
<tr><td><code id="trim_spct_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="trim_spct_+3A_fill">fill</code></td>
<td>
<p>if fill==NULL then tails are deleted, otherwise tails or s.irrad
are filled with the value of fill.</p>
</td></tr>
<tr><td><code id="trim_spct_+3A_byref">byref</code></td>
<td>
<p>logical indicating if new object will be created by reference or
by copy of spct.</p>
</td></tr>
<tr><td><code id="trim_spct_+3A_verbose">verbose</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="trim_spct_+3A_mspct">mspct</code></td>
<td>
<p>an object of class &quot;generic_mspct&quot;</p>
</td></tr>
<tr><td><code id="trim_spct_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="trim_spct_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a spectrum object or a collection of spectral objects of the same
class as <code>x</code> with wavelength heads and tails clipped or extended.
</p>


<h3>Note</h3>

<p>When expanding a spectrum, if fill==NULL, then expansion is not
performed. Range can be &quot;waveband&quot; object, a numeric vector or a list of
numeric vectors, or any other user-defined or built-in object for which
<code>range()</code> returns a numeric vector of length two, that can be
interpreted as wavelengths expressed in nm.
</p>


<h3>See Also</h3>

<p>Other trim functions: 
<code><a href="#topic+clip_wl">clip_wl</a>()</code>,
<code><a href="#topic+trim_waveband">trim_waveband</a>()</code>,
<code><a href="#topic+trim_wl">trim_wl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trim_spct(sun.spct, low.limit=300)
trim_spct(sun.spct, low.limit=300, fill=NULL)
trim_spct(sun.spct, low.limit=300, fill=NA)
trim_spct(sun.spct, low.limit=300, fill=0.0)
trim_spct(sun.spct, range = c(300, 400))
trim_spct(sun.spct, range = c(300, NA))
trim_spct(sun.spct, range = c(NA, 400))

</code></pre>

<hr>
<h2 id='trim_tails'>Trim (or expand) head and/or tail</h2><span id='topic+trim_tails'></span>

<h3>Description</h3>

<p>Trim tails of a spectrum based on wavelength limits, interpolating the
values at the boundaries.Trimming is needed for example to remove short
wavelength noise when the measured spectrum extends beyond the known emission
spectrum of the measured light source. Occasionally one may want also to
expand the wavelength range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_tails(
  x,
  y,
  low.limit = min(x),
  high.limit = max(x),
  use.hinges = TRUE,
  fill = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_tails_+3A_x">x</code></td>
<td>
<p>numeric vector of wavelengths.</p>
</td></tr>
<tr><td><code id="trim_tails_+3A_y">y</code></td>
<td>
<p>numeric vector of values for a spectral quantity.</p>
</td></tr>
<tr><td><code id="trim_tails_+3A_low.limit">low.limit</code></td>
<td>
<p>smallest x-value to be kept (defaults to smallest x-value in
input).</p>
</td></tr>
<tr><td><code id="trim_tails_+3A_high.limit">high.limit</code></td>
<td>
<p>largest x-value to be kept (defaults to largest x-value in
input).</p>
</td></tr>
<tr><td><code id="trim_tails_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="trim_tails_+3A_fill">fill</code></td>
<td>
<p>if <code>fill == NULL</code> then tails are deleted, otherwise tails of
y are filled with the value of <code>fill</code>.</p>
</td></tr>
<tr><td><code id="trim_tails_+3A_verbose">verbose</code></td>
<td>
<p>logical Use to suppress warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with variables <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p>When expanding a spectrum, if <code>fill == NULL</code>, expansion is
not performed with a warning.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(sun.data)
head(with(sun.data,
     trim_tails(w.length, s.e.irrad, low.limit=300)))
head(with(sun.data,
     trim_tails(w.length, s.e.irrad, low.limit=300, fill=NULL)))

</code></pre>

<hr>
<h2 id='trim_waveband'>Trim (or expand) head and/or tail</h2><span id='topic+trim_waveband'></span>

<h3>Description</h3>

<p>Trimming of waveband boundaries can be needed when the spectral data do not
cover the whole waveband, or wavebands may have to be removed altogether.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_waveband(
  w.band,
  range = NULL,
  low.limit = 0,
  high.limit = Inf,
  trim = getOption("photobiology.waveband.trim", default = TRUE),
  use.hinges = TRUE,
  trunc.labels = getOption("photobiology.brief.trunc.names", default = c("]", "["))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_waveband_+3A_w.band">w.band</code></td>
<td>
<p>an object of class &quot;waveband&quot; or a list of such objects.</p>
</td></tr>
<tr><td><code id="trim_waveband_+3A_range">range</code></td>
<td>
<p>a numeric vector of length two, or any other object for which
function range() will return a numeric vector of two wavelengths (nm).</p>
</td></tr>
<tr><td><code id="trim_waveband_+3A_low.limit">low.limit</code></td>
<td>
<p>shortest wavelength to be kept (defaults to 0 nm).</p>
</td></tr>
<tr><td><code id="trim_waveband_+3A_high.limit">high.limit</code></td>
<td>
<p>longest wavelength to be kept (defaults to Inf nm).</p>
</td></tr>
<tr><td><code id="trim_waveband_+3A_trim">trim</code></td>
<td>
<p>logical (default is TRUE which trims the wavebands at the
boundary, while FALSE discards wavebands that are partly off-boundary).</p>
</td></tr>
<tr><td><code id="trim_waveband_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="trim_waveband_+3A_trunc.labels">trunc.labels</code></td>
<td>
<p>character vector of length one or two. The first string
will be prepended to the waveband name and label on left truncation and the
second appended on right truncation. If the vector is of length one, the
same string will be used in both cases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will accept both individual wavebands or list of
wavebands. When the input is a list, wavebands outside the range of the
range will be removed from the list, and those partly outside the
target range either &quot;trimmed&quot; to this edge truncated if <code>trim =
  TRUE</code> is passed or excluded if <code>trim = FALSE</code>). Waveband objects
contain a name and a label that are used to label the returned values of
calculations that make use of them. When a waveband object is truncated so
that the definition changes, the name and label are also modified so that
the change is visible when they are used. The name and label have a string
prepended or appended, and what strings are used can be set with an R
option.
</p>


<h3>Value</h3>

<p>The returned value is a waveband object or a list of waveband objects
depending on whether a single waveband object or a list of waveband objects
was supplied as argument to formal parameter <code>w.band</code>. If no waveband
is retained, in the first case,  a NULL waveband object is returned, and in
the second case, a list of length zero is returned. If the input is a
named, list, names are preserved in the returned list.
</p>


<h3>Note</h3>

<p>Modification of the name and label stored in the wavebands passed as
input is done so that summaries produced with the modified objects can be
recognized as different from those computed using the original definitions
when the waveband objects are used. When the input is a named list, the
names of the retained members of the list are not modified as these are not
part of the definitions.
</p>


<h3>See Also</h3>

<p>Other trim functions: 
<code><a href="#topic+clip_wl">clip_wl</a>()</code>,
<code><a href="#topic+trim_spct">trim_spct</a>()</code>,
<code><a href="#topic+trim_wl">trim_wl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>VIS &lt;- waveband(c(380, 760)) # manometers

trim_waveband(VIS, c(400,700))
trim_waveband(VIS, low.limit = 400)
trim_waveband(VIS, high.limit = 700)
trim_waveband(VIS, c(400,700), trunc.labels = c("&gt;", "&lt;"))
trim_waveband(VIS, c(400,700), trunc.labels = "!")

</code></pre>

<hr>
<h2 id='trim_wl'>Trim head and/or tail of a spectrum</h2><span id='topic+trim_wl'></span><span id='topic+trim_wl.default'></span><span id='topic+trim_wl.generic_spct'></span><span id='topic+trim_wl.generic_mspct'></span><span id='topic+trim_wl.waveband'></span><span id='topic+trim_wl.list'></span>

<h3>Description</h3>

<p>Trim head and tail of a spectrum based on wavelength limits, with
interpolation at range boundaries used by default. Expansion is also
possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_wl(x, range, use.hinges, fill, ...)

## Default S3 method:
trim_wl(x, range, use.hinges, fill, ...)

## S3 method for class 'generic_spct'
trim_wl(x, range = NULL, use.hinges = TRUE, fill = NULL, ...)

## S3 method for class 'generic_mspct'
trim_wl(
  x,
  range = NULL,
  use.hinges = TRUE,
  fill = NULL,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'waveband'
trim_wl(
  x,
  range = NULL,
  use.hinges = TRUE,
  fill = NULL,
  trim = getOption("photobiology.waveband.trim", default = TRUE),
  ...
)

## S3 method for class 'list'
trim_wl(
  x,
  range = NULL,
  use.hinges = TRUE,
  fill = NULL,
  trim = getOption("photobiology.waveband.trim", default = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_wl_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="trim_wl_+3A_range">range</code></td>
<td>
<p>a numeric vector of length two, or any other object for which
function range() will return two.</p>
</td></tr>
<tr><td><code id="trim_wl_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="trim_wl_+3A_fill">fill</code></td>
<td>
<p>if <code>fill == NULL</code> then tails are deleted, otherwise tails
are filled with the value of fill.</p>
</td></tr>
<tr><td><code id="trim_wl_+3A_...">...</code></td>
<td>
<p>ignored (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="trim_wl_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="trim_wl_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
<tr><td><code id="trim_wl_+3A_trim">trim</code></td>
<td>
<p>logical (default is TRUE which trims the wavebands at the
boundary, while FALSE discards wavebands that are partly off-boundary).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>x</code>, usually trimmed or expanded to a different
length, either shorter or longer. Possibly with some of the original
spectral data values replaced with <code>fill</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>trim_wl(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>trim_wl(generic_spct)</code>: Trim an object of class &quot;generic_spct&quot; or derived.
</p>
</li>
<li> <p><code>trim_wl(generic_mspct)</code>: Trim an object of class &quot;generic_mspct&quot; or derived.
</p>
</li>
<li> <p><code>trim_wl(waveband)</code>: Trim an object of class &quot;waveband&quot;.
</p>
</li>
<li> <p><code>trim_wl(list)</code>: Trim a list (of &quot;waveband&quot; objects).
</p>
</li></ul>


<h3>Note</h3>

<p>By default the <code>w.length</code> values for the first and last rows
in the returned object are the values supplied as <code>range</code>.
</p>
<p>trim_wl when applied to waveband objects always inserts hinges when
trimming.
</p>
<p>trim_wl when applied to waveband objects always inserts hinges when
trimming.
</p>


<h3>See Also</h3>

<p>Other trim functions: 
<code><a href="#topic+clip_wl">clip_wl</a>()</code>,
<code><a href="#topic+trim_spct">trim_spct</a>()</code>,
<code><a href="#topic+trim_waveband">trim_waveband</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trim_wl(sun.spct, range = c(400, 500))
trim_wl(sun.spct, range = c(NA, 500))
trim_wl(sun.spct, range = c(400, NA))

</code></pre>

<hr>
<h2 id='trimInstrDesc'>Trim the &quot;instr.desc&quot; attribute</h2><span id='topic+trimInstrDesc'></span>

<h3>Description</h3>

<p>Function to trim the &quot;instr.desc&quot; attribute of an existing generic_spct
object, discarding all fields except for 'spectrometer.name',
'spectrometer.sn', 'bench.grating', 'bench.slit', and calibration name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimInstrDesc(
  x,
  fields = c("time", "spectrometer.name", "spectrometer.sn", "bench.grating",
    "bench.slit", "entrance.optics")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimInstrDesc_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="trimInstrDesc_+3A_fields">fields</code></td>
<td>
<p>a character vector with the names of the fields to keep,
or if first member is '&quot;-&quot;', the names of fields to delete; &quot;*&quot; as
first member of the vector makes the function a no-op, leaving the spectrum
object unaltered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Note</h3>

<p>This function alters x itself by reference and in addition
returns x invisibly. If x is not a generic_spct object, x is not
modified.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrSettings">trimInstrSettings</a>()</code>
</p>

<hr>
<h2 id='trimInstrSettings'>Trim the &quot;instr.settings&quot; attribute</h2><span id='topic+trimInstrSettings'></span>

<h3>Description</h3>

<p>Function to trim the &quot;instr.settings&quot; attribute of an existing generic_spct
object, by discarding some fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimInstrSettings(x, fields = "*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimInstrSettings_+3A_x">x</code></td>
<td>
<p>a generic_spct object</p>
</td></tr>
<tr><td><code id="trimInstrSettings_+3A_fields">fields</code></td>
<td>
<p>a character vector with the names of the fields to keep,
or if first member is '&quot;-&quot;', the names of fields to delete; &quot;*&quot; as
first member of the vector makes the function a no-op, leaving the spectrum
object unaltered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Note</h3>

<p>This function alters x itself by reference and in addition
returns x invisibly. If x is not a generic_spct object, x is not
modified.
</p>


<h3>See Also</h3>

<p>Other measurement metadata functions: 
<code><a href="#topic+add_attr2tb">add_attr2tb</a>()</code>,
<code><a href="#topic+getFilterProperties">getFilterProperties</a>()</code>,
<code><a href="#topic+getHowMeasured">getHowMeasured</a>()</code>,
<code><a href="#topic+getInstrDesc">getInstrDesc</a>()</code>,
<code><a href="#topic+getInstrSettings">getInstrSettings</a>()</code>,
<code><a href="#topic+getSoluteProperties">getSoluteProperties</a>()</code>,
<code><a href="#topic+getWhatMeasured">getWhatMeasured</a>()</code>,
<code><a href="#topic+getWhenMeasured">getWhenMeasured</a>()</code>,
<code><a href="#topic+getWhereMeasured">getWhereMeasured</a>()</code>,
<code><a href="#topic+get_attributes">get_attributes</a>()</code>,
<code><a href="#topic+isValidInstrDesc">isValidInstrDesc</a>()</code>,
<code><a href="#topic+isValidInstrSettings">isValidInstrSettings</a>()</code>,
<code><a href="#topic+select_spct_attributes">select_spct_attributes</a>()</code>,
<code><a href="#topic+setFilterProperties">setFilterProperties</a>()</code>,
<code><a href="#topic+setHowMeasured">setHowMeasured</a>()</code>,
<code><a href="#topic+setInstrDesc">setInstrDesc</a>()</code>,
<code><a href="#topic+setInstrSettings">setInstrSettings</a>()</code>,
<code><a href="#topic+setSoluteProperties">setSoluteProperties</a>()</code>,
<code><a href="#topic+setWhatMeasured">setWhatMeasured</a>()</code>,
<code><a href="#topic+setWhenMeasured">setWhenMeasured</a>()</code>,
<code><a href="#topic+setWhereMeasured">setWhereMeasured</a>()</code>,
<code><a href="#topic+spct_attr2tb">spct_attr2tb</a>()</code>,
<code><a href="#topic+spct_metadata">spct_metadata</a>()</code>,
<code><a href="#topic+subset_attributes">subset_attributes</a>()</code>,
<code><a href="#topic+trimInstrDesc">trimInstrDesc</a>()</code>
</p>

<hr>
<h2 id='twilight2angle'>twilight argument check and conversion</h2><span id='topic+twilight2angle'></span>

<h3>Description</h3>

<p>twilight argument check and conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twilight2angle(twilight)
</code></pre>


<h3>Value</h3>

<p>numeric Solar elevation angle at sunrise or sunset
</p>

<hr>
<h2 id='two_filters.spct'>Transmittance spectrum of plastic films</h2><span id='topic+two_filters.spct'></span><span id='topic+two_filters.mspct'></span><span id='topic+polyester.spct'></span><span id='topic+yellow_gel.spct'></span>

<h3>Description</h3>

<p>Datasets containing the wavelengths at a 1 nm interval and
fractional total transmittance for a clear polyester film and a yellow
theatrical &quot;gel&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two_filters.spct

two_filters.mspct

polyester.spct

yellow_gel.spct
</code></pre>


<h3>Format</h3>

<p>A <code>filter_spct</code> object with 611 rows and 2 variables.
Individually as <code>filter_spct</code> objects, and together as a collection
stored in a <code>filter_mspct</code> object and in a long-form
<code>filter_spct</code> object.
</p>
<p>An object of class <code>filter_mspct</code> (inherits from <code>generic_mspct</code>, <code>list</code>) with 2 rows and 1 columns.
</p>
<p>An object of class <code>filter_spct</code> (inherits from <code>generic_spct</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 454 rows and 2 columns.
</p>
<p>An object of class <code>filter_spct</code> (inherits from <code>generic_spct</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 425 rows and 2 columns.
</p>


<h3>Details</h3>

 <ul>
<li> <p><code>w.length</code> (nm). </p>
</li>
<li> <p><code>Tfr</code>
(0..1). </p>
</li>
<li> <p><code>spct.idx</code> (names, only in <code>two_filters.spct</code>).</p>
</li></ul>



<h3>Note</h3>

<p>Package 'photobiologyFilters' contains data sets for hundreds of
optical filters and materials in objects of these same classes, ready to be
used with package 'photobiology'.
</p>


<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>polyester.spct
yellow_gel.spct
summary(two_filters.mspct)

</code></pre>

<hr>
<h2 id='two_irrads'>Compute two irrads for ratio, fraction or normalised difference</h2><span id='topic+two_irrads'></span>

<h3>Description</h3>

<p>Internal function that computes the two irradiances needed to compute
various waveband ratios and fractions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two_irrads(
  spct,
  w.band.num,
  w.band.denom,
  unit.out.num,
  unit.out.denom,
  quantity,
  wb.trim,
  use.cached.mult,
  use.hinges,
  naming
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two_irrads_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;source_spct&quot;.</p>
</td></tr>
<tr><td><code id="two_irrads_+3A_w.band.num">w.band.num</code>, <code id="two_irrads_+3A_w.band.denom">w.band.denom</code></td>
<td>
<p>waveband objects or lists of waveband objects
used to compute the numerator(s) and denominator(s) of the ratio(s). The
waveband(s) determine the region(s) of the spectrum that are summarized.</p>
</td></tr>
<tr><td><code id="two_irrads_+3A_unit.out.num">unit.out.num</code>, <code id="two_irrads_+3A_unit.out.denom">unit.out.denom</code></td>
<td>
<p>character Allowed values &quot;energy&quot;, and
&quot;photon&quot;, or its alias &quot;quantum&quot;.</p>
</td></tr>
<tr><td><code id="two_irrads_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="two_irrads_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="two_irrads_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td></tr>
<tr><td><code id="two_irrads_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="two_irrads_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+irrad">irrad</a></code> for details on the irradiance calculations.
</p>

<hr>
<h2 id='two_reflectances'>Compute two reflectances for ratio, fraction or normalised difference</h2><span id='topic+two_reflectances'></span>

<h3>Description</h3>

<p>Internal function that computes the two reflectances needed to compute
various waveband ratios and fractions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two_reflectances(
  spct,
  w.band.1,
  w.band.2,
  quantity,
  wb.trim,
  use.cached.mult,
  use.hinges,
  naming
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two_reflectances_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;reflector_spct&quot; or &quot;object_spct&quot;.</p>
</td></tr>
<tr><td><code id="two_reflectances_+3A_w.band.1">w.band.1</code>, <code id="two_reflectances_+3A_w.band.2">w.band.2</code></td>
<td>
<p>waveband objects or lists of waveband objects
used to compute the numerator(s) and denominator(s) of the ratio(s). The
waveband(s) determine the region(s) of the spectrum that are summarized.</p>
</td></tr>
<tr><td><code id="two_reflectances_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="two_reflectances_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="two_reflectances_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td></tr>
<tr><td><code id="two_reflectances_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="two_reflectances_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+reflectance">reflectance</a></code> for details on the reflectance calculations.
</p>

<hr>
<h2 id='two_transmittances'>Compute two transmittances for ratio, fraction or normalised difference</h2><span id='topic+two_transmittances'></span>

<h3>Description</h3>

<p>Internal function that computes the two transmittances needed to compute
various waveband ratios and fractions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two_transmittances(
  spct,
  w.band.1,
  w.band.2,
  quantity,
  wb.trim,
  use.cached.mult,
  use.hinges,
  naming
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two_transmittances_+3A_spct">spct</code></td>
<td>
<p>an object of class &quot;filter_spct&quot; or &quot;object_spct&quot;.</p>
</td></tr>
<tr><td><code id="two_transmittances_+3A_w.band.1">w.band.1</code>, <code id="two_transmittances_+3A_w.band.2">w.band.2</code></td>
<td>
<p>waveband objects or lists of waveband objects
used to compute the numerator(s) and denominator(s) of the ratio(s). The
waveband(s) determine the region(s) of the spectrum that are summarized.</p>
</td></tr>
<tr><td><code id="two_transmittances_+3A_quantity">quantity</code></td>
<td>
<p>character string One of &quot;total&quot;, &quot;average&quot; or &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="two_transmittances_+3A_wb.trim">wb.trim</code></td>
<td>
<p>logical if TRUE wavebands crossing spectral data boundaries
are trimmed, if FALSE, they are discarded</p>
</td></tr>
<tr><td><code id="two_transmittances_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical indicating whether multiplier values should be
cached between calls</p>
</td></tr>
<tr><td><code id="two_transmittances_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="two_transmittances_+3A_naming">naming</code></td>
<td>
<p>character one of &quot;long&quot;, &quot;default&quot;, &quot;short&quot; or &quot;none&quot;. Used to
select the type of names to assign to returned value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+transmittance">transmittance</a></code> for details on the transmittance calculations.
</p>

<hr>
<h2 id='tz_time_diff'>Time difference between two time zones</h2><span id='topic+tz_time_diff'></span>

<h3>Description</h3>

<p>Returns the difference in local time expressed in hours between two time
zones at a given instant in time. The difference due to daylight saving time
or Summer and Winter time as well as historical changes in time zones are
taken into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tz_time_diff(
  when = lubridate::now(),
  tz.target = lubridate::tz(when),
  tz.reference = "UTC"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tz_time_diff_+3A_when">when</code></td>
<td>
<p>datetime A time instant</p>
</td></tr>
<tr><td><code id="tz_time_diff_+3A_tz.target">tz.target</code>, <code id="tz_time_diff_+3A_tz.reference">tz.reference</code></td>
<td>
<p>character Two time zones using names
recognized by functions from package 'lubridate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> value.
</p>


<h3>Note</h3>

<p>This function is implemented using functions from package 'lubridate'.
For details on the handling of time zones, please, consult the
documentation for <code><a href="base.html#topic+Sys.timezone">Sys.timezone</a></code> about system differences in
time zone names and handling.
</p>

<hr>
<h2 id='uncollect2spct'>Extract all members from a collection</h2><span id='topic+uncollect2spct'></span><span id='topic+uncollect2spct.default'></span><span id='topic+uncollect2spct.generic_mspct'></span>

<h3>Description</h3>

<p>Extract all members from a collection into separate objects in the parent
frame of the call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncollect2spct(x, ...)

## Default S3 method:
uncollect2spct(x, ...)

## S3 method for class 'generic_mspct'
uncollect2spct(
  x,
  name.tag = ".spct",
  ignore.case = FALSE,
  check.names = TRUE,
  check.overwrite = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncollect2spct_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
<tr><td><code id="uncollect2spct_+3A_...">...</code></td>
<td>
<p>additional named arguments passed down to <code>f</code>.</p>
</td></tr>
<tr><td><code id="uncollect2spct_+3A_name.tag">name.tag</code></td>
<td>
<p>character. A string used as tag for the names of the objects.
If of length zero, names of members are used as named of objects. Otherwise
the tag is appended, unless already present in the member name.</p>
</td></tr>
<tr><td><code id="uncollect2spct_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical. If FALSE, the pattern matching used for <code>name.tag</code> is
case sensitive and if TRUE, case is ignored during matching.</p>
</td></tr>
<tr><td><code id="uncollect2spct_+3A_check.names">check.names</code></td>
<td>
<p>logical. If TRUE then the names of the objects created are
checked to ensure that they are syntactically valid variable names and
unique. If necessary they are adjusted (by make.names) so that they are,
and if FALSE names are used as is.</p>
</td></tr>
<tr><td><code id="uncollect2spct_+3A_check.overwrite">check.overwrite</code></td>
<td>
<p>logical. If TRUE trigger an error if an exisitng
object would be overwritten, and if FALSE silently overwrite objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Utility used for its side effects, invisibly returns a character
vector with the names of the objects created.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>uncollect2spct(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>uncollect2spct(generic_mspct)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p>Other experimental utility functions: 
<code><a href="#topic+collect2mspct">collect2mspct</a>()</code>,
<code><a href="#topic+drop_user_cols">drop_user_cols</a>()</code>,
<code><a href="#topic+thin_wl">thin_wl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.mscpt &lt;- source_mspct(list(sun1.spct = sun.spct, sun2.spct = sun.spct))
uncollect2spct(my.mscpt)
ls(pattern = "*.spct")

</code></pre>

<hr>
<h2 id='untag'>Remove tags</h2><span id='topic+untag'></span><span id='topic+untag.default'></span><span id='topic+untag.generic_spct'></span><span id='topic+untag.generic_mspct'></span>

<h3>Description</h3>

<p>Remove tags from an R object if present, otherwise return the object
unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untag(x, ...)

## Default S3 method:
untag(x, ...)

## S3 method for class 'generic_spct'
untag(x, byref = FALSE, ...)

## S3 method for class 'generic_mspct'
untag(x, byref = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="untag_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
<tr><td><code id="untag_+3A_...">...</code></td>
<td>
<p>ignored (possibly used by derived methods).</p>
</td></tr>
<tr><td><code id="untag_+3A_byref">byref</code></td>
<td>
<p>logical indicating if new object will be created by reference or
by copy of x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>x</code> contains tag data they are removed and the &quot;spct.tags&quot;
attribute is set to <code>NA</code>, while if <code>x</code> has no tags, it is not
modified. In either case, the byref argument is respected: in all cases if
<code>byref = FALSE</code> a copy of <code>x</code> is returned.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>untag(default)</code>: Default for generic function
</p>
</li>
<li> <p><code>untag(generic_spct)</code>: Specialization for generic_spct
</p>
</li>
<li> <p><code>untag(generic_mspct)</code>: Specialization for generic_spct
</p>
</li></ul>


<h3>See Also</h3>

<p>Other tagging and related functions: 
<code><a href="#topic+is_tagged">is_tagged</a>()</code>,
<code><a href="#topic+tag">tag</a>()</code>,
<code><a href="#topic+wb2rect_spct">wb2rect_spct</a>()</code>,
<code><a href="#topic+wb2spct">wb2spct</a>()</code>,
<code><a href="#topic+wb2tagged_spct">wb2tagged_spct</a>()</code>
</p>

<hr>
<h2 id='upgrade_spct'>Upgrade one spectral object</h2><span id='topic+upgrade_spct'></span>

<h3>Description</h3>

<p>Update the spectral class names of objects to those used in photobiology (&gt;=
0.6.0) and add 'version' attribute as used in photobiology (&gt;= 0.70).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upgrade_spct(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upgrade_spct_+3A_object">object</code></td>
<td>
<p>generic.spct A single object to upgrade</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object (invisibly).
</p>


<h3>Note</h3>

<p>The object is modified by reference. The class names with ending
&quot;.spct&quot; replaced by their new equivalents ending in &quot;_spct&quot;.
</p>


<h3>See Also</h3>

<p>Other upgrade from earlier versions: 
<code><a href="#topic+is.old_spct">is.old_spct</a>()</code>,
<code><a href="#topic+upgrade_spectra">upgrade_spectra</a>()</code>
</p>

<hr>
<h2 id='upgrade_spectra'>Upgrade one or more spectral objects</h2><span id='topic+upgrade_spectra'></span>

<h3>Description</h3>

<p>Update the spectral class names of objects to those used in photobiology (&gt;=
0.6.0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upgrade_spectra(obj.names = ls(parent.frame()))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upgrade_spectra_+3A_obj.names">obj.names</code></td>
<td>
<p>char Names of objects to upgrade as a vector of character
strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object (invisibly).
</p>


<h3>Note</h3>

<p>The objects are modified by reference. The class names with ending
&quot;.spct&quot; are replaced by their new equivalents ending in &quot;_spct&quot;.
<code>object.names</code> can safely include names of any R object. Names of
objects which do not belong to any the old <code>.spct</code> classes are
ignored. This makes it possible to supply as argument the output from
<code>ls</code>, the default, or its equivalent <code>objects</code>.
</p>


<h3>See Also</h3>

<p>Other upgrade from earlier versions: 
<code><a href="#topic+is.old_spct">is.old_spct</a>()</code>,
<code><a href="#topic+upgrade_spct">upgrade_spct</a>()</code>
</p>

<hr>
<h2 id='using_Tfr'>Use photobiology options</h2><span id='topic+using_Tfr'></span><span id='topic+using_Afr'></span><span id='topic+using_A'></span><span id='topic+using_energy'></span><span id='topic+using_photon'></span><span id='topic+using_quantum'></span>

<h3>Description</h3>

<p>Execute an R expression, possibly compound, using a certain setting for
spectral data related options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>using_Tfr(expr)

using_Afr(expr)

using_A(expr)

using_energy(expr)

using_photon(expr)

using_quantum(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="using_Tfr_+3A_expr">expr</code></td>
<td>
<p>an R expression to execute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned by the execution of <code>expression</code>.
</p>


<h3>References</h3>

<p>Based on <code>withOptions()</code> as offered by Thomas Lumley, and
listed in <a href="https://www.burns-stat.com/the-options-mechanism-in-r/">https://www.burns-stat.com/the-options-mechanism-in-r/</a>,
section Deep End, of &quot;The Options mechanism in R&quot; by Patrick Burns.
</p>

<hr>
<h2 id='v_insert_hinges'>Insert spectral data values at new wavelength values.</h2><span id='topic+v_insert_hinges'></span>

<h3>Description</h3>

<p>Inserting wavelengths values immediately before and after a discontinuity in
the SWF, greatly reduces the errors caused by interpolating the weighted
irradiance during integration of the effective spectral irradiance. This is
specially true when data have a relatively large wavelength step size and/or
when the weighting function used has discontinuities in its value or slope.
This function differs from <code>insert_hinges()</code> in that it returns a vector
of <code>y</code> values instead of a <code>tibble</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v_insert_hinges(x, y, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="v_insert_hinges_+3A_x">x</code></td>
<td>
<p>numeric vector (sorted in increasing order).</p>
</td></tr>
<tr><td><code id="v_insert_hinges_+3A_y">y</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="v_insert_hinges_+3A_h">h</code></td>
<td>
<p>a numeric vector giving the wavelengths at which the y values should
be inserted by interpolation, no interpolation is indicated by an empty
numeric vector (<code>numeric(0)</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the numeric values of <code>y</code>, but longer.
Unless the hinge values were already present in <code>y</code>, each inserted
hinge, expands the vector by two values.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_replace_hinges">v_replace_hinges</a>()</code>
</p>

<hr>
<h2 id='v_replace_hinges'>Overwrite spectral data values at existing wavelength values.</h2><span id='topic+v_replace_hinges'></span>

<h3>Description</h3>

<p>Overwriting spectral data with interpolated values at wavelengths values
containing bad data is needed when cleaning spectral data.
This function differs from <code>insert_hinges()</code> in that it returns a vector
of <code>y</code> values instead of a <code>tibble</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v_replace_hinges(x, y, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="v_replace_hinges_+3A_x">x</code></td>
<td>
<p>numeric vector (sorted in increasing order).</p>
</td></tr>
<tr><td><code id="v_replace_hinges_+3A_y">y</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="v_replace_hinges_+3A_h">h</code></td>
<td>
<p>a numeric vector giving the wavelengths at which the y values should
be replaced by interpolation, no interpolation is indicated by an empty
numeric vector (<code>numeric(0)</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the numeric values of <code>y</code> with values
at the hinges replaced by interpolation of neighbours.
</p>


<h3>See Also</h3>

<p>Other low-level functions operating on numeric vectors.: 
<code><a href="#topic+as_energy">as_energy</a>()</code>,
<code><a href="#topic+as_quantum_mol">as_quantum_mol</a>()</code>,
<code><a href="#topic+calc_multipliers">calc_multipliers</a>()</code>,
<code><a href="#topic+div_spectra">div_spectra</a>()</code>,
<code><a href="#topic+energy_irradiance">energy_irradiance</a>()</code>,
<code><a href="#topic+energy_ratio">energy_ratio</a>()</code>,
<code><a href="#topic+insert_hinges">insert_hinges</a>()</code>,
<code><a href="#topic+integrate_xy">integrate_xy</a>()</code>,
<code><a href="#topic+interpolate_spectrum">interpolate_spectrum</a>()</code>,
<code><a href="#topic+irradiance">irradiance</a>()</code>,
<code><a href="#topic+l_insert_hinges">l_insert_hinges</a>()</code>,
<code><a href="#topic+oper_spectra">oper_spectra</a>()</code>,
<code><a href="#topic+photon_irradiance">photon_irradiance</a>()</code>,
<code><a href="#topic+photon_ratio">photon_ratio</a>()</code>,
<code><a href="#topic+photons_energy_ratio">photons_energy_ratio</a>()</code>,
<code><a href="#topic+prod_spectra">prod_spectra</a>()</code>,
<code><a href="#topic+s_e_irrad2rgb">s_e_irrad2rgb</a>()</code>,
<code><a href="#topic+split_energy_irradiance">split_energy_irradiance</a>()</code>,
<code><a href="#topic+split_photon_irradiance">split_photon_irradiance</a>()</code>,
<code><a href="#topic+subt_spectra">subt_spectra</a>()</code>,
<code><a href="#topic+sum_spectra">sum_spectra</a>()</code>,
<code><a href="#topic+trim_tails">trim_tails</a>()</code>,
<code><a href="#topic+v_insert_hinges">v_insert_hinges</a>()</code>
</p>

<hr>
<h2 id='validate_geocode'>Validate a geocode</h2><span id='topic+validate_geocode'></span><span id='topic+is_valid_geocode'></span><span id='topic+length_geocode'></span><span id='topic+na_geocode'></span>

<h3>Description</h3>

<p>Test validity of a geocode or ensure that a geocode is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_geocode(geocode)

is_valid_geocode(geocode)

length_geocode(geocode)

na_geocode()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_geocode_+3A_geocode">geocode</code></td>
<td>
<p>data.frame with geocode data in columns <code>"lat"</code>,
<code>"lon"</code>, and possibly also <code>"address"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>validate_geocode</code> Converts to tibble, checks data bounds, converts
address to character if it is not already a character vector, or add
character NAs if the address column is missing.
</p>
<p><code>is_valid_geocode</code> Checks if a geocode is valid, returning 0L if not,
and the number of row otherwise.
</p>


<h3>Value</h3>

<p>A valid geocode stored in a tibble.
</p>
<p>FALSE for invalid, TRUE for valid.
</p>
<p>FALSE for invalid, number of rows for valid.
</p>
<p>A geo_code tibble with all fields set to suitable NAs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
validate_geocode(NA)
validate_geocode(data.frame(lon = -25, lat = 66))

is_valid_geocode(NA)
is_valid_geocode(1L)
is_valid_geocode(data.frame(lon = -25, lat = 66))

na_geocode()

</code></pre>

<hr>
<h2 id='valleys'>Valleys or local minima</h2><span id='topic+valleys'></span><span id='topic+valleys.default'></span><span id='topic+valleys.numeric'></span><span id='topic+valleys.data.frame'></span><span id='topic+valleys.generic_spct'></span><span id='topic+valleys.source_spct'></span><span id='topic+valleys.response_spct'></span><span id='topic+valleys.filter_spct'></span><span id='topic+valleys.reflector_spct'></span><span id='topic+valleys.solute_spct'></span><span id='topic+valleys.cps_spct'></span><span id='topic+valleys.raw_spct'></span><span id='topic+valleys.generic_mspct'></span><span id='topic+valleys.source_mspct'></span><span id='topic+valleys.response_mspct'></span><span id='topic+valleys.filter_mspct'></span><span id='topic+valleys.reflector_mspct'></span><span id='topic+valleys.solute_mspct'></span><span id='topic+valleys.cps_mspct'></span><span id='topic+valleys.raw_mspct'></span>

<h3>Description</h3>

<p>Function that returns a subset of an R object with observations corresponding
to local maxima.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valleys(x, span, ignore_threshold, strict, ...)

## Default S3 method:
valleys(x, span = NA, ignore_threshold = NA, strict = NA, na.rm = FALSE, ...)

## Default S3 method:
valleys(x, span = NA, ignore_threshold = NA, strict = NA, na.rm = FALSE, ...)

## S3 method for class 'numeric'
valleys(x, span = 5, ignore_threshold, strict = TRUE, na.rm = FALSE, ...)

## S3 method for class 'data.frame'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  x.var.name = NULL,
  y.var.name = NULL,
  var.name = y.var.name,
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'generic_spct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  var.name = NULL,
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'source_spct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'response_spct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'filter_spct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  filter.qty = getOption("photobiology.filter.qty", default = "transmittance"),
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'reflector_spct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'solute_spct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'cps_spct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  var.name = "cps",
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'raw_spct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  var.name = "counts",
  refine.wl = FALSE,
  method = "spline",
  ...
)

## S3 method for class 'generic_mspct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  var.name = NULL,
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'source_mspct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'response_mspct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'filter_mspct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  filter.qty = getOption("photobiology.filter.qty", default = "transmittance"),
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'reflector_mspct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'solute_mspct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'cps_mspct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  var.name = "cps",
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

## S3 method for class 'raw_mspct'
valleys(
  x,
  span = 5,
  ignore_threshold = 0,
  strict = TRUE,
  na.rm = FALSE,
  var.name = "counts",
  refine.wl = FALSE,
  method = "spline",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valleys_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="valleys_+3A_span">span</code></td>
<td>
<p>integer A valley is defined as an element in a sequence which is smaller
than all other elements within a window of width <code>span</code> centered at that
element. Use <code>NULL</code> for the global peak.</p>
</td></tr>
<tr><td><code id="valleys_+3A_ignore_threshold">ignore_threshold</code></td>
<td>
<p>numeric Value between 0.0 and 1.0 indicating the
relative size compared to tallest peak threshold below which peaks will be
ignored. Negative values set a threshold so that the tallest peaks are
ignored, instead of the shortest.</p>
</td></tr>
<tr><td><code id="valleys_+3A_strict">strict</code></td>
<td>
<p>logical If <code>TRUE</code>, an element must be strictly greater
than all other values in its window to be considered a peak.</p>
</td></tr>
<tr><td><code id="valleys_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="valleys_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be stripped
before searching for peaks.</p>
</td></tr>
<tr><td><code id="valleys_+3A_var.name">var.name</code>, <code id="valleys_+3A_x.var.name">x.var.name</code>, <code id="valleys_+3A_y.var.name">y.var.name</code></td>
<td>
<p>character Name of column where to look
for valleys.</p>
</td></tr>
<tr><td><code id="valleys_+3A_refine.wl">refine.wl</code></td>
<td>
<p>logical Flag indicating if valley location should be refined by
fitting a function.</p>
</td></tr>
<tr><td><code id="valleys_+3A_method">method</code></td>
<td>
<p>character String with the name of a method. Currently only
spline interpolation is implemented.</p>
</td></tr>
<tr><td><code id="valleys_+3A_unit.out">unit.out</code></td>
<td>
<p>character One of &quot;energy&quot; or &quot;photon&quot;</p>
</td></tr>
<tr><td><code id="valleys_+3A_filter.qty">filter.qty</code></td>
<td>
<p>character One of &quot;transmittance&quot; or &quot;absorbance&quot;</p>
</td></tr>
<tr><td><code id="valleys_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="valleys_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of <code>x</code> with rows corresponding to local minima.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>valleys(default)</code>: Default function usable on numeric vectors.
</p>
</li>
<li> <p><code>valleys(default)</code>: Default returning always NA.
</p>
</li>
<li> <p><code>valleys(numeric)</code>: Default function usable on numeric vectors.
</p>
</li>
<li> <p><code>valleys(data.frame)</code>: Method for &quot;data.frame&quot; objects.
</p>
</li>
<li> <p><code>valleys(generic_spct)</code>: Method for &quot;generic_spct&quot; objects.
</p>
</li>
<li> <p><code>valleys(source_spct)</code>: Method for &quot;source_spct&quot; objects.
</p>
</li>
<li> <p><code>valleys(response_spct)</code>: Method for &quot;response_spct&quot; objects.
</p>
</li>
<li> <p><code>valleys(filter_spct)</code>: Method for &quot;filter_spct&quot; objects.
</p>
</li>
<li> <p><code>valleys(reflector_spct)</code>: Method for &quot;reflector_spct&quot;.
</p>
</li>
<li> <p><code>valleys(solute_spct)</code>: Method for &quot;solute_spct&quot; objects.
</p>
</li>
<li> <p><code>valleys(cps_spct)</code>: Method for &quot;cps_spct&quot; objects.
</p>
</li>
<li> <p><code>valleys(raw_spct)</code>: Method for &quot;raw_spct&quot; objects.
</p>
</li>
<li> <p><code>valleys(generic_mspct)</code>: Method for &quot;generic_mspct&quot; objects.
</p>
</li>
<li> <p><code>valleys(source_mspct)</code>: Method for &quot;source_mspct&quot; objects.
</p>
</li>
<li> <p><code>valleys(response_mspct)</code>: Method for &quot;cps_mspct&quot; objects.
</p>
</li>
<li> <p><code>valleys(filter_mspct)</code>: Method for &quot;filter_mspct&quot; objects.
</p>
</li>
<li> <p><code>valleys(reflector_mspct)</code>: Method for &quot;reflector_mspct&quot; objects.
</p>
</li>
<li> <p><code>valleys(solute_mspct)</code>: Method for &quot;solute_mspct&quot; objects.
</p>
</li>
<li> <p><code>valleys(cps_mspct)</code>: Method for &quot;cps_mspct&quot; objects.
</p>
</li>
<li> <p><code>valleys(raw_mspct)</code>: Method for &quot;raw_mspct&quot; objects.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other peaks and valleys functions: 
<code><a href="#topic+find_peaks">find_peaks</a>()</code>,
<code><a href="#topic+find_spikes">find_spikes</a>()</code>,
<code><a href="#topic+get_peaks">get_peaks</a>()</code>,
<code><a href="#topic+peaks">peaks</a>()</code>,
<code><a href="#topic+replace_bad_pixs">replace_bad_pixs</a>()</code>,
<code><a href="#topic+spikes">spikes</a>()</code>,
<code><a href="#topic+wls_at_target">wls_at_target</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>valleys(sun.spct, span = 50)

valleys(sun.spct)

</code></pre>

<hr>
<h2 id='verbose_as_default'>Set error reporting options</h2><span id='topic+verbose_as_default'></span><span id='topic+strict_range_as_default'></span>

<h3>Description</h3>

<p>Set error reporting related options easily.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verbose_as_default(flag = TRUE)

strict_range_as_default(flag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verbose_as_default_+3A_flag">flag</code></td>
<td>
<p>logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Previous value of the modified option.
</p>

<hr>
<h2 id='w_length_range2rgb'>Wavelength range to rgb color conversion</h2><span id='topic+w_length_range2rgb'></span>

<h3>Description</h3>

<p>Calculates rgb values from spectra based on human color matching functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w_length_range2rgb(
  w.length,
  sens = photobiology::ciexyzCMF2.spct,
  color.name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="w_length_range2rgb_+3A_w.length">w.length</code></td>
<td>
<p>numeric vector of wavelengths (nm) of length 2. If longer,
its range is used.</p>
</td></tr>
<tr><td><code id="w_length_range2rgb_+3A_sens">sens</code></td>
<td>
<p>chroma_spct Used as the chromaticity definition.</p>
</td></tr>
<tr><td><code id="w_length_range2rgb_+3A_color.name">color.name</code></td>
<td>
<p>character Used for naming the rgb color definition(s)
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of colors defined using <code>rgb()</code>. The numeric values of
the RGB components can be obtained by calling function
<code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>.
</p>


<h3>See Also</h3>

<p>Other color functions: 
<code><a href="#topic+rgb_spct">rgb_spct</a>()</code>,
<code><a href="#topic+w_length2rgb">w_length2rgb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col2rgb(w_length_range2rgb(c(500,600)))
col2rgb(w_length_range2rgb(550))
col2rgb(w_length_range2rgb(500:600))

</code></pre>

<hr>
<h2 id='w_length2rgb'>Wavelength to rgb color conversion</h2><span id='topic+w_length2rgb'></span>

<h3>Description</h3>

<p>Calculates rgb values from spectra based on human color matching functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w_length2rgb(w.length, sens = photobiology::ciexyzCMF2.spct, color.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="w_length2rgb_+3A_w.length">w.length</code></td>
<td>
<p>numeric Vector of wavelengths [<code class="reqn">nm</code>].</p>
</td></tr>
<tr><td><code id="w_length2rgb_+3A_sens">sens</code></td>
<td>
<p>chroma_spct Used as chromaticity definition.</p>
</td></tr>
<tr><td><code id="w_length2rgb_+3A_color.name">color.name</code></td>
<td>
<p>character Used for naming the rgb color definition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of colors defined using <code>rgb()</code>. The numeric values of
the RGB components can be obtained using function <code>col2rgb()</code>.
</p>


<h3>See Also</h3>

<p>Other color functions: 
<code><a href="#topic+rgb_spct">rgb_spct</a>()</code>,
<code><a href="#topic+w_length_range2rgb">w_length_range2rgb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col2rgb(w_length2rgb(580))
col2rgb(w_length2rgb(c(400, 500, 600, 700)))
col2rgb(w_length2rgb(c(400, 500, 600, 700), color.name=c("a","b","c","d")))
col2rgb(w_length2rgb(c(400, 500, 600, 700), color.name="a"))

</code></pre>

<hr>
<h2 id='water_vp_sat'>Water vapour pressure</h2><span id='topic+water_vp_sat'></span><span id='topic+water_dp'></span><span id='topic+water_fp'></span><span id='topic+water_vp2mvc'></span><span id='topic+water_mvc2vp'></span><span id='topic+water_vp2RH'></span><span id='topic+water_RH2vp'></span><span id='topic+water_vp_sat_slope'></span><span id='topic+psychrometric_constant'></span>

<h3>Description</h3>

<p>Approximate water pressure in air as a function of temperature, and its
inverse the calculation of dewpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>water_vp_sat(
  temperature,
  over.ice = FALSE,
  method = "tetens",
  check.range = TRUE
)

water_dp(water.vp, over.ice = FALSE, method = "tetens", check.range = TRUE)

water_fp(water.vp, over.ice = TRUE, method = "tetens", check.range = TRUE)

water_vp2mvc(water.vp, temperature)

water_mvc2vp(water.mvc, temperature)

water_vp2RH(
  water.vp,
  temperature,
  over.ice = FALSE,
  method = "tetens",
  pc = TRUE,
  check.range = TRUE
)

water_RH2vp(
  relative.humidity,
  temperature,
  over.ice = FALSE,
  method = "tetens",
  pc = TRUE,
  check.range = TRUE
)

water_vp_sat_slope(
  temperature,
  over.ice = FALSE,
  method = "tetens",
  check.range = TRUE,
  temperature.step = 0.1
)

psychrometric_constant(atmospheric.pressure = 101325)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="water_vp_sat_+3A_temperature">temperature</code></td>
<td>
<p>numeric vector of air temperatures (C).</p>
</td></tr>
<tr><td><code id="water_vp_sat_+3A_over.ice">over.ice</code></td>
<td>
<p>logical vector Is the estimate for equilibrium with liquid
water or with ice.</p>
</td></tr>
<tr><td><code id="water_vp_sat_+3A_method">method</code></td>
<td>
<p>character Currently &quot;tetens&quot;, modified &quot;magnus&quot;, &quot;wexler&quot; and
&quot;goff.gratch&quot; equations  are supported.</p>
</td></tr>
<tr><td><code id="water_vp_sat_+3A_check.range">check.range</code></td>
<td>
<p>logical Flag indicating whether to check or not that
arguments for temperature are within the range of validity of the
<code>method</code> used.</p>
</td></tr>
<tr><td><code id="water_vp_sat_+3A_water.vp">water.vp</code></td>
<td>
<p>numeric vector of water vapour pressure in air (Pa).</p>
</td></tr>
<tr><td><code id="water_vp_sat_+3A_water.mvc">water.mvc</code></td>
<td>
<p>numeric vector of water vapour concnetration as mass per
volume (<code class="reqn">g m^{-3}</code>).</p>
</td></tr>
<tr><td><code id="water_vp_sat_+3A_pc">pc</code></td>
<td>
<p>logical flag for result returned as percent or not.</p>
</td></tr>
<tr><td><code id="water_vp_sat_+3A_relative.humidity">relative.humidity</code></td>
<td>
<p>numeric Relative humidity as 
fraction of 1.</p>
</td></tr>
<tr><td><code id="water_vp_sat_+3A_temperature.step">temperature.step</code></td>
<td>
<p>numeric Delta or step used to estimate the slope
as a finite difference (C).</p>
</td></tr>
<tr><td><code id="water_vp_sat_+3A_atmospheric.pressure">atmospheric.pressure</code></td>
<td>
<p>numeric Atmospheric pressure (Pa).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>water_vp_sat()</code> provides implementations of several
well known equations for the estimation of saturation vapor pressure in
air. Functions <code>water_dp()</code> and <code>water_fp()</code> use the inverse of
these equations to compute the dew point or frost point from water vapour
pressure in air. The inverse functions are either analytical solutions or
fitted approximations. None of these functions are solved numerically by
iteration.
</p>
<p>Method <code>"tetens"</code> implements Tetens' (1930) equation for the cases of
equilibrium with a water and an ice surface. Method <code>"magnus"</code>
implements the modified Magnus equations of Alduchov and Eskridge (1996,
eqs. 21 and 23). Method <code>"wexler"</code> implements the equations proposed
by Wexler (1976, 1977), and their inverse according to Hardy (1998). Method
<code>"goff.gratch"</code> implements the equations of Groff and Gratch (1946)
with the minor updates of Groff (1956).
</p>
<p>The equations are approximations, and in spite of their different names,
Tetens' and Magnus' equations have the same form with the only difference
in the values of the parameters. However, the modified Magnus equation is
more accurate as Tetens equation suffers from some bias errors at extreme
low temperatures (&lt; -40 C). In contrast Magnus equations with recently
fitted values for the parameters are usable for temperatures from -80 C to
+50 C over water and -80 C to 0 C over ice. The Groff Gratch equation is
more complex and is frequently used as a reference in comparison as it is
considered reliable over a broad range of temperatures. Wexler's equations
are computationally simpler and fitted to relatively recent data. There is
little difference at temperatures in the range -20 C to +50 C, and
differences become large at extreme temperatures. Temperatures outside the
range where estimations are highly reliable for each equation return
<code>NA</code>, unless extrapolation is enabled by passing <code>FALSE</code> as
argument to parameter <code>check.range</code>.
</p>
<p>The switch between equations for ice or water cannot be based on
air temperature, as it depends on the presence or not of a surface of
liquid water. It must be set by passing an argument to parameter
<code>over.ice</code> which defaults to <code>FALSE</code>.
</p>
<p>Tetens equation is still very frequently used, and is for example the
one recommended by FAO for computing potential evapotranspiration. For this
reason it is used as default here.
</p>


<h3>Value</h3>

<p>A numeric vector of partial pressures in pascal (Pa) for
<code>water_vp_sat()</code> and <code>water_mvc2vp()</code>, a numeric vector of dew point
temperatures (C) for <code>water_dp()</code> and numeric vector of mass per volume
concentrations (<code class="reqn">g m^{-3}</code>) for <code>water_vp2mvc()</code>.  <code>water_vp_sat()</code> and
<code>psychrometric_constant()</code> both return numeric vectors of pressure per
degree of temperature (<code class="reqn">Pa C^{-1}</code>)
</p>


<h3>Note</h3>

<p>The inverse of the Groff Gratch equation has yet to be implemented.
</p>


<h3>References</h3>

<p>Tetens, O., 1930. Uber einige meteorologische Begriffe.
Zeitschrift fur Geophysik, Vol. 6:297.
</p>
<p>Goff, J. A., and S. Gratch (1946) Low-pressure properties of water from
-160 to 212 F, in Transactions of the American Society of Heating and
Ventilating Engineers, pp 95-122, presented at the 52nd annual meeting of
the American Society of Heating and Ventilating Engineers, New York, 1946.
</p>
<p>Wexler, A. (1976) Vapor Pressure Formulation for Water in Range 0 to 100C.
A Revision, Journal of Research ofthe National Bureau of Standards: A.
Physics and Chemistry, September-December 1976, Vol. 80A, Nos.5 and 6,
775-785
</p>
<p>Wexler, A., (1977) Vapor Pressure Formulation for Ice, Journal of Research of the
National Bureau of Standards - A. Physics and Chemistry, Vol. 81A, No. 1, 5-19
</p>
<p>Alduchov, O. A., Eskridge, R. E., 1996. Improved Magnus Form Approximation
of Saturation Vapor Pressure. Journal of Applied Meteorology, 35: 601-609 .
</p>
<p>Hardy, Bob (1998) ITS-90 formulations for vapor pressure, frostpoint
temperature, dewpoint temperature, andenhancement factors in the range -100
TO +100 C. The Proceedings of the Third International Symposium on Humidity
&amp; Moisture, Teddington, London, England, April 1998.
<a href="https://www.decatur.de/javascript/dew/resources/its90formulas.pdf">https://www.decatur.de/javascript/dew/resources/its90formulas.pdf</a>
</p>
<p>Monteith, J., Unsworth, M. (2008) Principles of Environmental Physics.
Academic Press, Amsterdam.
</p>
<p>Allen R G, Pereira L S, Raes D, Smith M. (1998) Crop evapotranspiration:
Guidelines for computing crop water requirements. FAO Irrigation and
drainage paper 56. Rome: FAO.
</p>
<p>[Equations describing the physical properties of moist
air](http://www.conservationphysics.org/atmcalc/atmoclc2.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>water_vp_sat(20) # C -&gt; Pa
water_vp_sat(temperature = c(0, 10, 20, 30, 40)) # C -&gt; Pa
water_vp_sat(temperature = -10) # over water!!
water_vp_sat(temperature = -10, over.ice = TRUE)
water_vp_sat(temperature = 20) / 100 # C -&gt; mbar

water_vp_sat(temperature = 20, method = "magnus") # C -&gt; Pa
water_vp_sat(temperature = 20, method = "tetens") # C -&gt; Pa
water_vp_sat(temperature = 20, method = "wexler") # C -&gt; Pa
water_vp_sat(temperature = 20, method = "goff.gratch") # C -&gt; Pa

water_vp_sat(temperature = -20, over.ice = TRUE, method = "magnus") # C -&gt; Pa
water_vp_sat(temperature = -20, over.ice = TRUE, method = "tetens") # C -&gt; Pa
water_vp_sat(temperature = -20, over.ice = TRUE, method = "wexler") # C -&gt; Pa
water_vp_sat(temperature = -20, over.ice = TRUE, method = "goff.gratch") # C -&gt; Pa

water_dp(water.vp = 1000) # Pa -&gt; C
water_dp(water.vp = 1000, method = "magnus") # Pa -&gt; C
water_dp(water.vp = 1000, method = "wexler") # Pa -&gt; C
water_dp(water.vp = 500, over.ice = TRUE) # Pa -&gt; C
water_dp(water.vp = 500, method = "wexler", over.ice = TRUE) # Pa -&gt; C

water_fp(water.vp = 300) # Pa -&gt; C
water_dp(water.vp = 300, over.ice = TRUE) # Pa -&gt; C

water_vp2RH(water.vp = 1500, temperature = 20) # Pa, C -&gt; RH %
water_vp2RH(water.vp = 1500, temperature = c(20, 30)) # Pa, C -&gt; RH %
water_vp2RH(water.vp = c(600, 1500), temperature = 20) # Pa, C -&gt; RH %

water_vp2mvc(water.vp = 1000, temperature = 20) # Pa -&gt; g m-3

water_mvc2vp(water.mvc = 30, temperature = 40) # g m-3 -&gt; Pa

water_dp(water.vp = water_mvc2vp(water.mvc = 10, temperature = 30)) # g m-3 -&gt; C


water_vp_sat_slope(temperature = 20) # C -&gt; Pa / C


psychrometric_constant(atmospheric.pressure = 81.8e3) # Pa -&gt; Pa / C

</code></pre>

<hr>
<h2 id='water.spct'>Molar spectral attenuation coefficient of water</h2><span id='topic+water.spct'></span>

<h3>Description</h3>

<p>A dataset containing the wavelengths at a 2 nm interval and the
corresponding attenuation coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>water.spct
</code></pre>


<h3>Format</h3>

<p>A <code>solute_spct</code> object with 251 rows and 2 variables
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm), range 300 to 800 nm. </p>
</li>
<li><p> K.mole
(cm-1/M)</p>
</li></ul>



<h3>Author(s)</h3>

<p>Buiteveld et al. (1994) (original data)
</p>


<h3>References</h3>

<p>H. Buiteveld and J. M. H. Hakvoort and M. Donze (1994) &quot;The
optical properties of pure water,&quot; in SPIE Proceedings on Ocean Optics XII,
edited by J. S. Jaffe, 2258, 174&ndash;183.
</p>
<p><a href="https://omlc.org/spectra/water/">https://omlc.org/spectra/water/</a>
</p>


<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+white_led.source_spct">white_led.source_spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(water.spct)
summary(water.spct)
solute_properties(water.spct)
cat(comment(water.spct))

</code></pre>

<hr>
<h2 id='waveband'>Waveband constructor method</h2><span id='topic+waveband'></span><span id='topic+new_waveband'></span>

<h3>Description</h3>

<p>Constructor for &quot;waveband&quot; objects that can be used as input when calculating
irradiances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waveband(
  x = NULL,
  weight = NULL,
  SWF.e.fun = NULL,
  SWF.q.fun = NULL,
  norm = NULL,
  SWF.norm = NULL,
  hinges = NULL,
  wb.name = NULL,
  wb.label = wb.name
)

new_waveband(
  w.low,
  w.high,
  weight = NULL,
  SWF.e.fun = NULL,
  SWF.q.fun = NULL,
  norm = NULL,
  SWF.norm = NULL,
  hinges = NULL,
  wb.name = NULL,
  wb.label = wb.name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waveband_+3A_x">x</code></td>
<td>
<p>any R object on which applying the method <code>range()</code> yields an
vector of two numeric values, describing a range of wavelengths [<code class="reqn">nm</code>].</p>
</td></tr>
<tr><td><code id="waveband_+3A_weight">weight</code></td>
<td>
<p>a character string <code>"SWF"</code> or <code>"BSWF"</code>, use
<code>NULL</code> (the default) to indicate no weighting used when calculating
irradiance.</p>
</td></tr>
<tr><td><code id="waveband_+3A_swf.e.fun">SWF.e.fun</code>, <code id="waveband_+3A_swf.q.fun">SWF.q.fun</code></td>
<td>
<p>a functions giving multipliers for a spectral
weighting function (energy and quantum, respectively) as a function of
wavelength [<code class="reqn">nm</code>].</p>
</td></tr>
<tr><td><code id="waveband_+3A_norm">norm</code></td>
<td>
<p>a single numeric value indicating the wavelength [<code class="reqn">nm</code>] at
which the SWF should be normalized to 1.0; <code>NULL</code> is interpreted as no
normalization.</p>
</td></tr>
<tr><td><code id="waveband_+3A_swf.norm">SWF.norm</code></td>
<td>
<p>a numeric value giving the native normalization wavelength
[<code class="reqn">nm</code>] used by <code>SWF.e.fun</code> and <code>SWF.q.fun</code>.</p>
</td></tr>
<tr><td><code id="waveband_+3A_hinges">hinges</code></td>
<td>
<p>a numeric vector giving the wavelengths at which values in
<code>s.irrad</code> should be inserted by interpolation before integration is
attempted. No interpolation is indicated by an empty vector
(<code>numeric(0)</code>), while interpolation at both boundaries of the band is
indicated by <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="waveband_+3A_wb.name">wb.name</code></td>
<td>
<p>character string giving the name for the waveband defined,
default is <code>NULL</code> for an automatically generated name.</p>
</td></tr>
<tr><td><code id="waveband_+3A_wb.label">wb.label</code></td>
<td>
<p>character string giving the label of the waveband to be used
for labelling computed summaries or plots, default is <code>wb.name</code>. (This
is usually a shorter character string than <code>wb.name</code>.)</p>
</td></tr>
<tr><td><code id="waveband_+3A_w.low">w.low</code>, <code id="waveband_+3A_w.high">w.high</code></td>
<td>
<p>numeric value, wavelengths at the short end and long ends
of the wavelength band [<code class="reqn">nm</code>].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>waveband</code> are used to store the different
bits of information needed to compute summaries from spectral data by
integration over wavelengths. The wavelength ranges, possible spectral
weighting functions (SWF) or biological spectral weighting functions
(BSWF), their normalization wavelengths and names and labels used for
reporting the results are all stored in waveband objects. This facilitates
the use of functions that compute summaries, as well as ensures consistency
in computations and labelling, as all the bits of information are passed
together. Class <code>"waveband"</code> is derived from R class <code>list</code>.
</p>


<h3>Value</h3>

<p>a <code>waveband</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>new_waveband()</code>: A less flexible variant
</p>
</li></ul>


<h3>See Also</h3>

<p>Other waveband constructors: 
<code><a href="#topic+split_bands">split_bands</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>waveband(c(400,700))

new_waveband(400,700)

</code></pre>

<hr>
<h2 id='waveband_ratio'>Photon or energy ratio</h2><span id='topic+waveband_ratio'></span>

<h3>Description</h3>

<p>This function gives the (energy or photon) irradiance ratio between two given
wavebands of a radiation spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waveband_ratio(
  w.length,
  s.irrad,
  w.band.num = NULL,
  w.band.denom = NULL,
  unit.out.num = NULL,
  unit.out.denom = unit.out.num,
  unit.in = "energy",
  check.spectrum = TRUE,
  use.cached.mult = FALSE,
  use.hinges = getOption("photobiology.use.hinges", default = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waveband_ratio_+3A_w.length">w.length</code></td>
<td>
<p>numeric Vector of wavelengths [<code class="reqn">nm</code>].</p>
</td></tr>
<tr><td><code id="waveband_ratio_+3A_s.irrad">s.irrad</code></td>
<td>
<p>numeric vector of spectral irradiances in
[<code class="reqn">W\,m^{-2}\,nm^{-1}</code>] or
[<code class="reqn">mol\,s^{-1}\,sm^{-2}\,nm^{-1}</code>] as indicated by the
argument pased to <code>unit.in</code>.</p>
</td></tr>
<tr><td><code id="waveband_ratio_+3A_w.band.num">w.band.num</code>, <code id="waveband_ratio_+3A_w.band.denom">w.band.denom</code></td>
<td>
<p>waveband objects used to compute the numerator
and denominator of the ratio.</p>
</td></tr>
<tr><td><code id="waveband_ratio_+3A_unit.out.num">unit.out.num</code>, <code id="waveband_ratio_+3A_unit.out.denom">unit.out.denom</code></td>
<td>
<p>character Base of expression used to
compute the numerator and denominator of the ratio. Allowed values
<code>"energy"</code>, and <code>"photon"</code>, or its alias <code>"quantum"</code>.</p>
</td></tr>
<tr><td><code id="waveband_ratio_+3A_unit.in">unit.in</code></td>
<td>
<p>character Allowed values <code>"energy"</code>, and <code>"photon"</code>,
or its alias <code>"quantum"</code>.</p>
</td></tr>
<tr><td><code id="waveband_ratio_+3A_check.spectrum">check.spectrum</code></td>
<td>
<p>logical Flag indicating whether to sanity check input
data, default is TRUE.</p>
</td></tr>
<tr><td><code id="waveband_ratio_+3A_use.cached.mult">use.cached.mult</code></td>
<td>
<p>logical Flag indicating whether multiplier values
should be cached between calls.</p>
</td></tr>
<tr><td><code id="waveband_ratio_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value giving the ratio
</p>


<h3>Note</h3>

<p>The default for both <code>w.band</code> parameters is a waveband covering
the whole range of <code>w.length</code>. From version 0.9.19 onwards use of this
default does not trigger a warning, but instead is used silently.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># photon:photon ratio
with(sun.data,
     waveband_ratio(w.length, s.e.irrad,
                    new_waveband(400,500),
                    new_waveband(400,700), "photon"))
# energy:energy ratio
with(sun.data,
     waveband_ratio(w.length, s.e.irrad,
                    new_waveband(400,500),
                    new_waveband(400,700), "energy"))
# energy:photon ratio
with(sun.data,
     waveband_ratio(w.length, s.e.irrad,
                    new_waveband(400,700),
                    new_waveband(400,700),
                    "energy", "photon"))
# photon:photon ratio waveband : whole spectrum
with(sun.data,
     waveband_ratio(w.length, s.e.irrad,
                    new_waveband(400,500),
                    unit.out.num="photon"))
# photon:photon ratio of whole spectrum should be equal to 1.0
with(sun.data,
     waveband_ratio(w.length, s.e.irrad,
     unit.out.num="photon"))

</code></pre>

<hr>
<h2 id='wb_trim_as_default'>Set computation options</h2><span id='topic+wb_trim_as_default'></span><span id='topic+use_cached_mult_as_default'></span>

<h3>Description</h3>

<p>Set computation related options easily.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wb_trim_as_default(flag = TRUE)

use_cached_mult_as_default(flag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wb_trim_as_default_+3A_flag">flag</code></td>
<td>
<p>logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Previous value of the modified option.
</p>

<hr>
<h2 id='wb2rect_spct'>Create tagged spectrum from wavebands</h2><span id='topic+wb2rect_spct'></span><span id='topic+fast_wb2rect_spct'></span>

<h3>Description</h3>

<p>Create a generic_spct object with wavelengths from the range of wavebands in
a list. The spectrum is suitable for plotting labels, symbols, rectangles or
similar, as the midpoint of each waveband is added to the spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wb2rect_spct(w.band, short.names = TRUE, chroma.type = "CMF")

fast_wb2rect_spct(w.band, chroma.type = "CMF", simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wb2rect_spct_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects The waveband(s) determine
the wavelengths in variable <code>w.length</code> of the returned spectrum</p>
</td></tr>
<tr><td><code id="wb2rect_spct_+3A_short.names">short.names</code></td>
<td>
<p>logical Flag indicating whether to use short or long names
for wavebands</p>
</td></tr>
<tr><td><code id="wb2rect_spct_+3A_chroma.type">chroma.type</code></td>
<td>
<p>character telling whether &quot;CMF&quot;, &quot;CC&quot;, or &quot;both&quot; should be
returned for human vision, or an object of class <code>chroma_spct</code> for any
other trichromic visual system.</p>
</td></tr>
<tr><td><code id="wb2rect_spct_+3A_simplify">simplify</code></td>
<td>
<p>logical Flag indicating whether to merge neighboring
rectangles of equal color. Simplification is done only for narrow
wavebands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>generic.spectrum</code> object, with columns w.length, wl.low,
wl.hi, wl.color, wb.color and wb.name. The w.length values are the
midpoint of the wavebands, wl.low and wl.high give the boundaries of the
wavebands, wl.color the color definition corresponding to the wavelength at
the center of the waveband and wb.color the color of the waveband as a
whole (assuming a flat energy irradiance spectrum). Different spectral data
variables are set to zero and added making the returned value compatible
with classes derived from <code>generic_spct</code>.
</p>


<h3>Note</h3>

<p>Function <code>fast_wb2rect_spct()</code> differs from <code>wb2rect_spct()</code>
in that it computes colors for narrow wavebands based on the midpoint
wavelength and uses vectorization when possible. It always returns color
definitions with short names, which are also used as waveband names for
narrow wavebands and merged wavebands. The purpose of merging of rectangles
is to speed up rendering and to reduce the size of vector graphics output.
This function should be used with care as the color definitions returned
are only approximate and original waveband names can be lost.
</p>


<h3>See Also</h3>

<p>Other tagging and related functions: 
<code><a href="#topic+is_tagged">is_tagged</a>()</code>,
<code><a href="#topic+tag">tag</a>()</code>,
<code><a href="#topic+untag">untag</a>()</code>,
<code><a href="#topic+wb2spct">wb2spct</a>()</code>,
<code><a href="#topic+wb2tagged_spct">wb2tagged_spct</a>()</code>
</p>

<hr>
<h2 id='wb2spct'>Create spectrum from wavebands</h2><span id='topic+wb2spct'></span>

<h3>Description</h3>

<p>Create a generic_spct object with wavelengths from wavebands in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wb2spct(w.band)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wb2spct_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects The waveband(s) determine
the wavelengths in variable <code>w.length</code> of the returned spectrum</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A generic.spectrum object, with columns w.length set to the
<em>union</em> of all  boundaries and hinges defined in the waveband(s).
Different spectral data variables are set to zero and added making the
returned value compatible with classes derived from <code>generic_spct</code>.
</p>


<h3>See Also</h3>

<p>Other tagging and related functions: 
<code><a href="#topic+is_tagged">is_tagged</a>()</code>,
<code><a href="#topic+tag">tag</a>()</code>,
<code><a href="#topic+untag">untag</a>()</code>,
<code><a href="#topic+wb2rect_spct">wb2rect_spct</a>()</code>,
<code><a href="#topic+wb2tagged_spct">wb2tagged_spct</a>()</code>
</p>

<hr>
<h2 id='wb2tagged_spct'>Create tagged spectrum from wavebands</h2><span id='topic+wb2tagged_spct'></span>

<h3>Description</h3>

<p>Create a tagged <code>generic_spct</code> object with wavelengths from the range of
wavebands in a list, and names of the same bands as factor levels, and
corresponding color definitions. The spectrum is not suitable for plotting
labels, symbols, rectangles or similar, as the midpoint of each waveband is
not added to the spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wb2tagged_spct(
  w.band,
  use.hinges = TRUE,
  short.names = TRUE,
  chroma.type = "CMF",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wb2tagged_spct_+3A_w.band">w.band</code></td>
<td>
<p>waveband or list of waveband objects The waveband(s) determine
the region(s) of the spectrum that are tagged and the wavelengths returned
in variable <code>w.length</code>.</p>
</td></tr>
<tr><td><code id="wb2tagged_spct_+3A_use.hinges">use.hinges</code></td>
<td>
<p>logical Flag indicating whether to insert &quot;hinges&quot; into the
spectral data before integration so as to reduce interpolation errors at
the boundaries of the wavebands.</p>
</td></tr>
<tr><td><code id="wb2tagged_spct_+3A_short.names">short.names</code></td>
<td>
<p>logical Flag indicating whether to use short or long names
for wavebands.</p>
</td></tr>
<tr><td><code id="wb2tagged_spct_+3A_chroma.type">chroma.type</code></td>
<td>
<p>character telling whether &quot;CMF&quot;, &quot;CC&quot;, or &quot;both&quot; should be
returned for human vision, or an object of class <code>chroma_spct</code> for any
other trichromic visual system.</p>
</td></tr>
<tr><td><code id="wb2tagged_spct_+3A_...">...</code></td>
<td>
<p>ignored (possibly used by derived methods).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spectrum as returned by <code><a href="#topic+wb2spct">wb2spct</a></code> but additionally
tagged using function <code><a href="#topic+tag">tag</a></code>
</p>


<h3>See Also</h3>

<p>Other tagging and related functions: 
<code><a href="#topic+is_tagged">is_tagged</a>()</code>,
<code><a href="#topic+tag">tag</a>()</code>,
<code><a href="#topic+untag">untag</a>()</code>,
<code><a href="#topic+wb2rect_spct">wb2rect_spct</a>()</code>,
<code><a href="#topic+wb2spct">wb2spct</a>()</code>
</p>

<hr>
<h2 id='white_led.source_spct'>White led bulb spectrum</h2><span id='topic+white_led.source_spct'></span><span id='topic+white_led.cps_spct'></span><span id='topic+white_led.raw_spct'></span>

<h3>Description</h3>

<p>Datasets containing wavelengths and the
corresponding spectral irradiance data for an Osram warm white led lamp,
and the corresponding raw instrument counts and counts per second data
underlying them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>white_led.source_spct

white_led.cps_spct

white_led.raw_spct
</code></pre>


<h3>Format</h3>

<p>A <code>source_spct</code> object with 1421 rows and 2 columns,
a <code>cps_spct</code> object with 2068 rows and 2 columns, and
a <code>raw_spct</code> object with 2068 rows and 4 columns.
</p>
<p>An object of class <code>cps_spct</code> (inherits from <code>generic_spct</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 2068 rows and 2 columns.
</p>
<p>An object of class <code>raw_spct</code> (inherits from <code>generic_spct</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 2068 rows and 4 columns.
</p>


<h3>Details</h3>

 <ul>
<li><p> w.length (nm), range 250 to 900 nm. </p>
</li>
<li><p> s.e.irrad
(W m-2 nm-1)</p>
</li></ul>

<p>or
</p>
 <ul>
<li><p> w.length (nm), range 188 to 1117 nm. </p>
</li>
<li><p> cps </p>
</li></ul>

<p>or
</p>
 <ul>
<li><p> w.length (nm), range 188 to 1117 nm. </p>
</li>
<li><p> counts_1 </p>
</li>
<li><p> counts_2 </p>
</li>
<li><p> counts_3 </p>
</li></ul>



<h3>See Also</h3>

<p>Other Spectral data examples: 
<code><a href="#topic+A.illuminant.spct">A.illuminant.spct</a></code>,
<code><a href="#topic+D65.illuminant.spct">D65.illuminant.spct</a></code>,
<code><a href="#topic+Ler_leaf.spct">Ler_leaf.spct</a></code>,
<code><a href="#topic+black_body.spct">black_body.spct</a></code>,
<code><a href="#topic+ccd.spct">ccd.spct</a></code>,
<code><a href="#topic+clear.spct">clear.spct</a></code>,
<code><a href="#topic+filter_cps.mspct">filter_cps.mspct</a></code>,
<code><a href="#topic+green_leaf.spct">green_leaf.spct</a></code>,
<code><a href="#topic+phenylalanine.spct">phenylalanine.spct</a></code>,
<code><a href="#topic+photodiode.spct">photodiode.spct</a></code>,
<code><a href="#topic+sun.spct">sun.spct</a></code>,
<code><a href="#topic+sun_daily.spct">sun_daily.spct</a></code>,
<code><a href="#topic+sun_evening.spct">sun_evening.spct</a></code>,
<code><a href="#topic+two_filters.spct">two_filters.spct</a></code>,
<code><a href="#topic+water.spct">water.spct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>white_led.source_spct

</code></pre>

<hr>
<h2 id='wl_max'>Wavelength maximum</h2><span id='topic+wl_max'></span><span id='topic+max'></span><span id='topic+max.waveband'></span><span id='topic+max.generic_spct'></span><span id='topic+max.generic_mspct'></span>

<h3>Description</h3>

<p>A method specialization that returns the wavelength maximum [<code class="reqn">nm</code>] from
objects of classes <code>waveband</code> or of class <code>generic_spct</code> or
derived.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wl_max(x, na.rm = FALSE)

## S3 method for class 'waveband'
max(..., na.rm = FALSE)

## S3 method for class 'generic_spct'
max(..., na.rm = FALSE)

## S3 method for class 'generic_mspct'
max(..., na.rm = FALSE, idx = "spct.idx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wl_max_+3A_x">x</code></td>
<td>
<p>generic_spct, generic_mspct or waveband object.</p>
</td></tr>
<tr><td><code id="wl_max_+3A_na.rm">na.rm</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="wl_max_+3A_...">...</code></td>
<td>
<p>numeric, <code>waveband</code> or <code>generic_spct</code> arguments.</p>
</td></tr>
<tr><td><code id="wl_max_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length-one vector for individual objects or numeric vectors
or a data frame for collections of spectra.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>max(generic_spct)</code>: 
</p>
</li>
<li> <p><code>max(generic_mspct)</code>: 
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>max(sun.spct)
wl_max(sun.spct)

</code></pre>

<hr>
<h2 id='wl_midpoint'>Midpoint</h2><span id='topic+wl_midpoint'></span><span id='topic+midpoint'></span><span id='topic+midpoint.default'></span><span id='topic+midpoint.numeric'></span><span id='topic+midpoint.waveband'></span><span id='topic+midpoint.generic_spct'></span><span id='topic+midpoint.generic_mspct'></span>

<h3>Description</h3>

<p>A method that returns the wavelength [<code class="reqn">nm</code>] (or value) at the center of
the wavelength range of objects of classes <code>waveband</code> or of class
<code>generic_spct</code> or derived (or the midpoint from a <code>numeric</code>
vector).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wl_midpoint(x, ...)

midpoint(x, ...)

## Default S3 method:
midpoint(x, ...)

## S3 method for class 'numeric'
midpoint(x, ...)

## S3 method for class 'waveband'
midpoint(x, ...)

## S3 method for class 'generic_spct'
midpoint(x, ...)

## S3 method for class 'generic_mspct'
midpoint(x, ..., idx = "spct.idx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wl_midpoint_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="wl_midpoint_+3A_...">...</code></td>
<td>
<p>not used in current version</p>
</td></tr>
<tr><td><code id="wl_midpoint_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value equal to <code>max(x) - min(x)) / 2</code>. In the case of
spectral objects a wavelength [<code class="reqn">nm</code>]. For any other R object, according
to available definitions of <code><a href="#topic+min">min</a></code> and <code><a href="#topic+max">max</a></code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>midpoint(default)</code>: Default method for generic function
</p>
</li>
<li> <p><code>midpoint(numeric)</code>: Default method for generic function
</p>
</li>
<li> <p><code>midpoint(waveband)</code>: Wavelength at center of a &quot;waveband&quot;.
</p>
</li>
<li> <p><code>midpoint(generic_spct)</code>: Method for &quot;generic_spct&quot;.
</p>
</li>
<li> <p><code>midpoint(generic_mspct)</code>: Method for &quot;generic_mspct&quot; objects.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other wavelength summaries: 
<code><a href="#topic+wl_min">wl_min</a>()</code>,
<code><a href="#topic+wl_range">wl_range</a>()</code>,
<code><a href="#topic+wl_stepsize">wl_stepsize</a>()</code>
</p>
<p>Other wavelength summaries: 
<code><a href="#topic+wl_min">wl_min</a>()</code>,
<code><a href="#topic+wl_range">wl_range</a>()</code>,
<code><a href="#topic+wl_stepsize">wl_stepsize</a>()</code>
</p>
<p>Other wavelength summaries: 
<code><a href="#topic+wl_min">wl_min</a>()</code>,
<code><a href="#topic+wl_range">wl_range</a>()</code>,
<code><a href="#topic+wl_stepsize">wl_stepsize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>midpoint(10:20)
midpoint(sun.spct)
wl_midpoint(sun.spct)

midpoint(sun.spct)

</code></pre>

<hr>
<h2 id='wl_min'>Wavelength minimum</h2><span id='topic+wl_min'></span><span id='topic+min'></span><span id='topic+min.waveband'></span><span id='topic+min.generic_spct'></span><span id='topic+min.generic_mspct'></span>

<h3>Description</h3>

<p>A method specialization that returns the wavelength minimum [<code class="reqn">nm</code>] from
objects of classes <code>waveband</code> or of class <code>generic_spct</code> or
derived.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wl_min(x, na.rm = FALSE)

## S3 method for class 'waveband'
min(..., na.rm = FALSE)

## S3 method for class 'generic_spct'
min(..., na.rm = FALSE)

## S3 method for class 'generic_mspct'
min(..., na.rm = FALSE, idx = "spct.idx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wl_min_+3A_x">x</code></td>
<td>
<p>generic_spct, generic_mspct or waveband object.</p>
</td></tr>
<tr><td><code id="wl_min_+3A_na.rm">na.rm</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="wl_min_+3A_...">...</code></td>
<td>
<p>not used in current version</p>
</td></tr>
<tr><td><code id="wl_min_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length-one vector for individual objects or numeric vectors
or a data frame for collections of spectra.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>min(generic_spct)</code>: 
</p>
</li>
<li> <p><code>min(generic_mspct)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p>Other wavelength summaries: 
<code><a href="#topic+wl_midpoint">wl_midpoint</a>()</code>,
<code><a href="#topic+wl_range">wl_range</a>()</code>,
<code><a href="#topic+wl_stepsize">wl_stepsize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>min(sun.spct)
wl_min(sun.spct)

</code></pre>

<hr>
<h2 id='wl_range'>Wavelength range</h2><span id='topic+wl_range'></span><span id='topic+range'></span><span id='topic+range.waveband'></span><span id='topic+range.generic_spct'></span><span id='topic+range.generic_mspct'></span>

<h3>Description</h3>

<p>A method specialization that returns the wavelength range [<code class="reqn">nm</code>] from
objects of classes <code>waveband</code> or of class <code>generic_spct</code> or
derived.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wl_range(x, na.rm = FALSE)

## S3 method for class 'waveband'
range(..., na.rm = FALSE)

## S3 method for class 'generic_spct'
range(..., na.rm = FALSE)

## S3 method for class 'generic_mspct'
range(..., na.rm = FALSE, idx = "spct.idx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wl_range_+3A_x">x</code></td>
<td>
<p>generic_spct, generic_mspct or waveband object.</p>
</td></tr>
<tr><td><code id="wl_range_+3A_na.rm">na.rm</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="wl_range_+3A_...">...</code></td>
<td>
<p>a single R object</p>
</td></tr>
<tr><td><code id="wl_range_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length-two vector for individual objects or numeric vectors
or a data frame for collections of spectra.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>range(generic_spct)</code>: 
</p>
</li>
<li> <p><code>range(generic_mspct)</code>: 
</p>
</li></ul>


<h3>See Also</h3>

<p>Other wavelength summaries: 
<code><a href="#topic+wl_midpoint">wl_midpoint</a>()</code>,
<code><a href="#topic+wl_min">wl_min</a>()</code>,
<code><a href="#topic+wl_stepsize">wl_stepsize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>range(sun.spct)
wl_range(sun.spct)

range(sun.spct)

</code></pre>

<hr>
<h2 id='wl_stepsize'>Stepsize</h2><span id='topic+wl_stepsize'></span><span id='topic+stepsize'></span><span id='topic+stepsize.default'></span><span id='topic+stepsize.numeric'></span><span id='topic+stepsize.generic_spct'></span><span id='topic+stepsize.generic_mspct'></span>

<h3>Description</h3>

<p>Method returning the range of step sizes in an object; i.e., the Range of
differences between successive sorted values.  In particular the wavelength
step sizes [<code class="reqn">nm</code>] of objects of class <code>generic_spct</code> or derived (or
the step sizes of values in a <code>numeric</code> vector).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wl_stepsize(x, ...)

stepsize(x, ...)

## Default S3 method:
stepsize(x, ...)

## S3 method for class 'numeric'
stepsize(x, ...)

## S3 method for class 'generic_spct'
stepsize(x, ...)

## S3 method for class 'generic_mspct'
stepsize(x, ..., idx = "spct.idx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wl_stepsize_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="wl_stepsize_+3A_...">...</code></td>
<td>
<p>not used in current version</p>
</td></tr>
<tr><td><code id="wl_stepsize_+3A_idx">idx</code></td>
<td>
<p>character Name of the column with the names of the members of the
collection of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 2 with min and maximum stepsize values.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>stepsize(default)</code>: Default function usable on numeric vectors.
</p>
</li>
<li> <p><code>stepsize(numeric)</code>: Method for numeric vectors.
</p>
</li>
<li> <p><code>stepsize(generic_spct)</code>: Method for &quot;generic_spct&quot; objects.
</p>
</li>
<li> <p><code>stepsize(generic_mspct)</code>: Method for &quot;generic_mspct&quot; objects.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other wavelength summaries: 
<code><a href="#topic+wl_midpoint">wl_midpoint</a>()</code>,
<code><a href="#topic+wl_min">wl_min</a>()</code>,
<code><a href="#topic+wl_range">wl_range</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stepsize(sun.spct)
wl_stepsize(sun.spct)

stepsize(sun.spct)

</code></pre>

<hr>
<h2 id='wl2wavenumber'>Wavelength conversions</h2><span id='topic+wl2wavenumber'></span><span id='topic+wavenumber2wl'></span><span id='topic+wl2frequency'></span><span id='topic+frequency2wl'></span><span id='topic+wl2energy'></span><span id='topic+energy2wl'></span>

<h3>Description</h3>

<p>Convert wavelength (nm) into wave number, frequency (Hz) or energy per photon
(J, or eV) and back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wl2wavenumber(w.length, unit.exponent = 0)

wavenumber2wl(wavenumber, unit.exponent = 0)

wl2frequency(w.length, unit.exponent = 0)

frequency2wl(frequency, unit.exponent = 0)

wl2energy(w.length, unit.exponent = 0, unit = "joule")

energy2wl(photon.energy, unit.exponent = 0, unit = "joule")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wl2wavenumber_+3A_w.length">w.length</code></td>
<td>
<p>numeric wavelength (nm)</p>
</td></tr>
<tr><td><code id="wl2wavenumber_+3A_unit.exponent">unit.exponent</code></td>
<td>
<p>integer Exponent of the scale multiplier implicit in
result, e.g., use 3 for kJ.</p>
</td></tr>
<tr><td><code id="wl2wavenumber_+3A_wavenumber">wavenumber</code></td>
<td>
<p>numeric Wave number in waves per metre, possibly
with a scale factor according to <code>unit.exponent</code>.</p>
</td></tr>
<tr><td><code id="wl2wavenumber_+3A_frequency">frequency</code></td>
<td>
<p>numeric Frequency in Hz, possibly
with the scale factor according to <code>unit.exponent</code>.</p>
</td></tr>
<tr><td><code id="wl2wavenumber_+3A_unit">unit</code></td>
<td>
<p>character One of &quot;joule&quot; or &quot;eV&quot;.</p>
</td></tr>
<tr><td><code id="wl2wavenumber_+3A_photon.energy">photon.energy</code></td>
<td>
<p>numeric Energy of one photon in joule or eV, possibly
with a scale factor according to <code>unit.exponent</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions always expect as input and return wavelengths
expressed in nanometres (nm) as all other functions in the R for
photobiology suite of packages. Conversions depend on Plank's constant,
<em>h</em>, the speed of light in vacuum, <em>c</em>, and Avogadro's number,
<code class="reqn">N_A</code>. The values used for these constants have at least nine
significant digits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
wl2wavenumber(600) # wavelength in nm -&gt; wave number
wavenumber2wl(1666666.66) # wave number -&gt; wavelength in nm
wl2frequency(600) # wavelength in nm -&gt; wave frequency (Hz)
frequency2wl(499654096666667) # wave frequency (Hz) -&gt; wavelength in nm
wl2energy(600) # wavelength in nm -&gt; energy of one photon (J)
wl2energy(600, unit = "eV") # wavelength in nm -&gt; energy of one photon (eV)
wl2energy(600,
          unit.exponent = -3,
          unit = "eV")  # wavelength in nm -&gt; energy of one photon (meV)
energy2wl(2066.40330,
          unit.exponent = -3,
          unit = "eV")  # energy of one photon (meV) -&gt; wavelength (nm)

</code></pre>

<hr>
<h2 id='wls_at_target'>Find wavelengths values corresponding to a target spectral value</h2><span id='topic+wls_at_target'></span><span id='topic+wls_at_target.default'></span><span id='topic+wls_at_target.data.frame'></span><span id='topic+wls_at_target.generic_spct'></span><span id='topic+wls_at_target.source_spct'></span><span id='topic+wls_at_target.response_spct'></span><span id='topic+wls_at_target.filter_spct'></span><span id='topic+wls_at_target.reflector_spct'></span><span id='topic+wls_at_target.solute_spct'></span><span id='topic+wls_at_target.cps_spct'></span><span id='topic+wls_at_target.raw_spct'></span><span id='topic+wls_at_target.generic_mspct'></span>

<h3>Description</h3>

<p>Find wavelength values corresponding to a target spectral value in a spectrum.
The name of the column of the spectral data to be used is inferred from the
class of <code>x</code> and the argument passed to <code>unit.out</code> or
<code>filter.qty</code> or their defaults that depend on R options set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wls_at_target(
  x,
  target = NULL,
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...
)

## Default S3 method:
wls_at_target(
  x,
  target = NULL,
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...
)

## S3 method for class 'data.frame'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  x.var.name = NULL,
  y.var.name = NULL,
  ...
)

## S3 method for class 'generic_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  col.name = NULL,
  y.var.name = col.name,
  ...
)

## S3 method for class 'source_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'response_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

## S3 method for class 'filter_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  filter.qty = getOption("photobiology.filter.qty", default = "transmittance"),
  ...
)

## S3 method for class 'reflector_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...
)

## S3 method for class 'solute_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...
)

## S3 method for class 'cps_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...
)

## S3 method for class 'raw_spct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...
)

## S3 method for class 'generic_mspct'
wls_at_target(
  x,
  target = "0.5max",
  interpolate = FALSE,
  idfactor = length(target) &gt; 1,
  na.rm = FALSE,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wls_at_target_+3A_x">x</code></td>
<td>
<p>data.frame or spectrum object.</p>
</td></tr>
<tr><td><code id="wls_at_target_+3A_target">target</code></td>
<td>
<p>numeric or character vector. A numeric value indicates the spectral
quantity value for which wavelengths are to be searched. A character
string representing a number is converted to numeric. A character value
representing a number followed by a function name, will be also accepted
and decoded, such that <code>"0.1max"</code> is interpreted as targeting one
tenth of the maximum value in the column. The character
strings &quot;half.maximum&quot; and &quot;HM&quot; are synonyms for &quot;0.5max&quot; while
&quot;half.range&quot; and &quot;HR&quot; are synonyms for &quot;0.5range&quot;.</p>
</td></tr>
<tr><td><code id="wls_at_target_+3A_interpolate">interpolate</code></td>
<td>
<p>logical Indicating whether the nearest wavelength value
in <code>x</code> should be returned or a value calculated by linear
interpolation between wavelength values straddling the target.</p>
</td></tr>
<tr><td><code id="wls_at_target_+3A_idfactor">idfactor</code></td>
<td>
<p>logical or character Generates an index column of factor
type. If <code>idfactor = TRUE</code> then the column is auto named target.idx.
Alternatively the column name can be directly passed as argument to
<code>idfactor</code> as a character string.</p>
</td></tr>
<tr><td><code id="wls_at_target_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be stripped
before searching for the target.</p>
</td></tr>
<tr><td><code id="wls_at_target_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
<tr><td><code id="wls_at_target_+3A_x.var.name">x.var.name</code>, <code id="wls_at_target_+3A_y.var.name">y.var.name</code>, <code id="wls_at_target_+3A_col.name">col.name</code></td>
<td>
<p>character The name of the columns in
which to search for the target value. Use of <code>col.name</code> is deprecated,
and is a synonym for <code>y.var.name</code>.</p>
</td></tr>
<tr><td><code id="wls_at_target_+3A_unit.out">unit.out</code></td>
<td>
<p>character One of &quot;energy&quot; or &quot;photon&quot;</p>
</td></tr>
<tr><td><code id="wls_at_target_+3A_filter.qty">filter.qty</code></td>
<td>
<p>character One of &quot;transmittance&quot; or &quot;absorbance&quot;</p>
</td></tr>
<tr><td><code id="wls_at_target_+3A_.parallel">.parallel</code></td>
<td>
<p>if TRUE, apply function in parallel, using parallel backend
provided by foreach</p>
</td></tr>
<tr><td><code id="wls_at_target_+3A_.paropts">.paropts</code></td>
<td>
<p>a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame, a spectrum object or a collection of spectra object of
the same class as <code>x</code> with fewer rows, possibly even no rows. If
<code>FALSE</code> is passed to <code>interpolate</code> a subset of <code>x</code> is
returned, otherwise a new object of the same class containing interpolated
wavelengths for the <code>target</code> value is returned. As 'target' accepts
a vector or list as argument, a factor can be added to the output with
the corresponding target value.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>wls_at_target(default)</code>: Default returning always an empty object of the
same class as <code>x</code>.
</p>
</li>
<li> <p><code>wls_at_target(data.frame)</code>: Method for &quot;data.frame&quot; objects.
</p>
</li>
<li> <p><code>wls_at_target(generic_spct)</code>: Method for &quot;generic_spct&quot; objects.
</p>
</li>
<li> <p><code>wls_at_target(source_spct)</code>: Method for &quot;source_spct&quot; objects.
</p>
</li>
<li> <p><code>wls_at_target(response_spct)</code>: Method for &quot;response_spct&quot; objects.
</p>
</li>
<li> <p><code>wls_at_target(filter_spct)</code>: Method for &quot;filter_spct&quot; objects.
</p>
</li>
<li> <p><code>wls_at_target(reflector_spct)</code>: Method for &quot;reflector_spct&quot; objects.
</p>
</li>
<li> <p><code>wls_at_target(solute_spct)</code>: Method for &quot;solute_spct&quot; objects.
</p>
</li>
<li> <p><code>wls_at_target(cps_spct)</code>: Method for &quot;cps_spct&quot; objects.
</p>
</li>
<li> <p><code>wls_at_target(raw_spct)</code>: Method for &quot;raw_spct&quot; objects.
</p>
</li>
<li> <p><code>wls_at_target(generic_mspct)</code>: Method for &quot;generic_mspct&quot; objects.
</p>
</li></ul>


<h3>Note</h3>

<p>When interpolation is used, only column <code>w.length</code> and the column
against which the target value was compared are included in the returned
object, otherwise, all columns in <code>x</code> are returned. We implement
support for <code>data.frame</code> to simplify the coding of 'ggplot2' stats
using this function.
</p>


<h3>See Also</h3>

<p>Other peaks and valleys functions: 
<code><a href="#topic+find_peaks">find_peaks</a>()</code>,
<code><a href="#topic+find_spikes">find_spikes</a>()</code>,
<code><a href="#topic+get_peaks">get_peaks</a>()</code>,
<code><a href="#topic+peaks">peaks</a>()</code>,
<code><a href="#topic+replace_bad_pixs">replace_bad_pixs</a>()</code>,
<code><a href="#topic+spikes">spikes</a>()</code>,
<code><a href="#topic+valleys">valleys</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wls_at_target(sun.spct, target = 0.1)
wls_at_target(sun.spct, target = 2e-6, unit.out = "photon")
wls_at_target(polyester.spct, target = "HM")
wls_at_target(polyester.spct, target = "HM", interpolate = TRUE)
wls_at_target(polyester.spct, target = "HM", idfactor = "target")
wls_at_target(polyester.spct, target = "HM", filter.qty = "absorbance")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
