<!DOCTYPE html><html lang="en"><head><title>Help for package rayvertex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rayvertex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_light'><p>Add light</p></a></li>
<li><a href='#add_lines'><p>Add Line</p></a></li>
<li><a href='#add_plane_uv_mesh'><p>Add Plane UV Mapping to Mesh</p></a></li>
<li><a href='#add_shape'><p>Add Shape</p></a></li>
<li><a href='#add_sphere_uv_mesh'><p>Add Sphere UV Mapping to Mesh</p></a></li>
<li><a href='#arrow_mesh'><p>Arrow 3D Model</p></a></li>
<li><a href='#cat_color'><p>Print out the color</p></a></li>
<li><a href='#center_mesh'><p>Center Mesh</p></a></li>
<li><a href='#change_material'><p>Change Material</p></a></li>
<li><a href='#color_lines'><p>Color Lines</p></a></li>
<li><a href='#cone_mesh'><p>Cone 3D Model</p></a></li>
<li><a href='#construct_mesh'><p>Manually construct a mesh</p></a></li>
<li><a href='#convert_color'><p>Convert Color</p></a></li>
<li><a href='#convert_rgb_to_ansi'><p>Convert RGB to ANSI Color</p></a></li>
<li><a href='#cross_prod'><p>Cross Product</p></a></li>
<li><a href='#cube_mesh'><p>Cube 3D Model</p></a></li>
<li><a href='#cylinder_mesh'><p>Cylinder 3D Model</p></a></li>
<li><a href='#directional_light'><p>Generate Directional Lights</p></a></li>
<li><a href='#displace_mesh'><p>Displace a Mesh</p></a></li>
<li><a href='#displacement_sphere'><p>Construct Displacement Sphere</p></a></li>
<li><a href='#flip_orientation_mesh'><p>Flip Orientation</p></a></li>
<li><a href='#fliplr'><p>Flip Left-Right</p></a></li>
<li><a href='#flipud'><p>Flip Up-Down</p></a></li>
<li><a href='#format_pillar_shp'><p>Format ray_shape for pillar</p></a></li>
<li><a href='#generate_cornell_mesh'><p>Cornell Box 3D Model</p></a></li>
<li><a href='#generate_line'><p>Generate Lines</p></a></li>
<li><a href='#generate_rot_matrix'><p>Generate Rotation Matrix</p></a></li>
<li><a href='#generate_rotation_matrix_from_direction'><p>Generate Rotation Matrix from Direction</p></a></li>
<li><a href='#generate_surface'><p>Generate Surface</p></a></li>
<li><a href='#generate_toon_outline'><p>Add Outline</p></a></li>
<li><a href='#get_file_type'><p>Check Filename</p></a></li>
<li><a href='#get_mesh_bbox'><p>Get Mesh Bounding Box</p></a></li>
<li><a href='#get_mesh_center'><p>Get Mesh Center</p></a></li>
<li><a href='#get_time'><p>Get time</p></a></li>
<li><a href='#init_time'><p>Print time</p></a></li>
<li><a href='#material_list'><p>Material List</p></a></li>
<li><a href='#merge_scene'><p>Merge scene</p></a></li>
<li><a href='#mesh3d_mesh'><p>Mesh3d 3D Model</p></a></li>
<li><a href='#obj_mesh'><p>OBJ Mesh 3D Model</p></a></li>
<li><a href='#pillar_shaft.ray_shape'><p>Pillar shaft for ray_shape</p></a></li>
<li><a href='#pillar_shaft.ray_shape_list'><p>Pillar shaft for ray_shape_list</p></a></li>
<li><a href='#ply_mesh'><p>PLY Mesh 3D Model</p></a></li>
<li><a href='#point_light'><p>Point light</p></a></li>
<li><a href='#print_time'><p>Print time</p></a></li>
<li><a href='#print.ray_shape'><p>Print method for ray_shape</p></a></li>
<li><a href='#print.ray_vertex_data'><p>Print method for ray_vertex_data</p></a></li>
<li><a href='#r_obj'><p>R 3D Model</p></a></li>
<li><a href='#rasterize_lines'><p>Rasterize Lines</p></a></li>
<li><a href='#rasterize_scene'><p>Rasterize Scene</p></a></li>
<li><a href='#ray_mesh'><p>Constructor for ray_mesh</p></a></li>
<li><a href='#ray_shape'><p>Define the ray_shape class</p></a></li>
<li><a href='#ray_shape_list'><p>Define the ray_shape_list class</p></a></li>
<li><a href='#ray_vertex_data'><p>Define the ray_vertex_data class</p></a></li>
<li><a href='#read_obj'><p>Load an OBJ file</p></a></li>
<li><a href='#read_ply'><p>Load an PLY file</p></a></li>
<li><a href='#remove_duplicate_materials'><p>Remove Duplicates</p></a></li>
<li><a href='#rescale'><p>Rescale</p></a></li>
<li><a href='#rotate_lines'><p>Rotate Lines</p></a></li>
<li><a href='#rotate_mesh'><p>Rotate Mesh</p></a></li>
<li><a href='#run_documentation'><p>Run Documentation</p></a></li>
<li><a href='#save_png'><p>Save PNG</p></a></li>
<li><a href='#scale_lines'><p>Scale Lines</p></a></li>
<li><a href='#scale_mesh'><p>Scale Mesh</p></a></li>
<li><a href='#scale_unit_mesh'><p>Scale Mesh to Unit Bounding Box</p></a></li>
<li><a href='#scene_from_list'><p>Scene From List</p></a></li>
<li><a href='#segment_mesh'><p>Segment 3D Model</p></a></li>
<li><a href='#set_material'><p>Set Material</p></a></li>
<li><a href='#smooth_normals_mesh'><p>Calculate Smooth Mesh Normals</p></a></li>
<li><a href='#sphere_mesh'><p>Sphere 3D Model</p></a></li>
<li><a href='#subdivide_mesh'><p>Subdivide Mesh</p></a></li>
<li><a href='#swap_yz'><p>Swap Y/Z Axis</p></a></li>
<li><a href='#text3d_mesh'><p>Text Object</p></a></li>
<li><a href='#torus_mesh'><p>Torus 3D Model</p></a></li>
<li><a href='#translate_lines'><p>Translate Lines</p></a></li>
<li><a href='#translate_mesh'><p>Translate Mesh</p></a></li>
<li><a href='#validate_mesh'><p>Validate Mesh Data</p></a></li>
<li><a href='#validate_scene'><p>Validate Scene</p></a></li>
<li><a href='#vec_ptype_abbr.ray_shape'><p>Abbreviate the ptype of ray_shape</p></a></li>
<li><a href='#vec_ptype_abbr.ray_shape_list'><p>Abbreviate the ptype of ray_shape_list</p></a></li>
<li><a href='#verify_vertex_shader'><p>Verify Vertex Shader</p></a></li>
<li><a href='#write_scene_to_obj'><p>Write the scene to an OBJ file</p></a></li>
<li><a href='#xy_rect_mesh'><p>XY Rectangle 3D Model</p></a></li>
<li><a href='#xz_rect_mesh'><p>XZ Rectangle 3D Model</p></a></li>
<li><a href='#yz_rect_mesh'><p>YZ Rectangle 3D Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>3D Software Rasterizer</td>
</tr>
<tr>
<td>Version:</td>
<td>0.12.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-02</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler Morgan-Wall &lt;tylermw@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Rasterize images using a 3D software renderer. 3D scenes are created either by importing external files, building scenes out of the included objects, or by constructing meshes manually. Supports point and directional lights, anti-aliased lines, shadow mapping, transparent objects, translucent objects, multiple materials types, reflection, refraction, environment maps, multicore rendering, bloom, tone-mapping, and screen-space ambient occlusion.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>file inst/COPYRIGHTS</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.6), grDevices, rayimage (&ge; 0.15.1), png, digest,
pillar (&ge; 1.10.1), vctrs, tibble, withr, cli</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rvcg, magick, raster, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, spacefillr, RcppThread, rayimage</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.rayvertex.com">https://www.rayvertex.com</a>,
<a href="https://github.com/tylermorganwall/rayvertex">https://github.com/tylermorganwall/rayvertex</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tylermorganwall/rayvertex/issues">https://github.com/tylermorganwall/rayvertex/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-01 21:57:38 UTC; tyler</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler Morgan-Wall <a href="https://orcid.org/0000-0002-3131-3814"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph, cre],
  Syoyo Fujita [ctb, cph],
  Vilya Harvey [ctb, cph],
  G-Truc Creation [ctb, cph],
  Sean Barrett [ctb, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-03 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_light'>Add light</h2><span id='topic+add_light'></span>

<h3>Description</h3>

<p>Add light
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_light(lights, light)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_light_+3A_lights">lights</code></td>
<td>
<p>Current light scene.</p>
</td></tr>
<tr><td><code id="add_light_+3A_light">light</code></td>
<td>
<p>New light to add.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the light information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Add a light to scene (manually specify the light automatically added to the Cornell Box
lights = point_light(position=c(555/2,450,555/2),
                    falloff_quad = 0.0, constant = 0.0002, falloff = 0.005)
generate_cornell_mesh(light=FALSE) |&gt;
 rasterize_scene(light_info = lights)
 
#Add directional lights and a point light
lights_d = add_light(lights, directional_light(direction=c(1,1.5,-1), intensity=0.2)) |&gt;
 add_light(directional_light(direction=c(-1,1.5,-1),color="red", intensity=0.2)) |&gt;
 add_light(point_light(position=c(555/2,50,555/2), color="blue", intensity=0.3,
                       falloff_quad = 0.0, constant = 0.0002, falloff = 0.005))
                       
generate_cornell_mesh(light=FALSE) |&gt;
 rasterize_scene(light_info = lights_d)
}
</code></pre>

<hr>
<h2 id='add_lines'>Add Line</h2><span id='topic+add_lines'></span>

<h3>Description</h3>

<p>Add Line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_lines(lines, line)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_lines_+3A_lines">lines</code></td>
<td>
<p>Existing lines or empty (0-row) matrix.</p>
</td></tr>
<tr><td><code id="add_lines_+3A_line">line</code></td>
<td>
<p>Line to add, generated with <code>generate_line()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>New line matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a cube out of lines
cube_outline = generate_line(start = c(-1, -1, -1), end = c(-1, -1, 1)) |&gt;
  add_lines(generate_line(start = c(-1, -1, -1), end = c(-1, 1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, -1), end = c(1, -1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, 1), end = c(-1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, 1), end = c(1, -1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, 1), end = c(-1, 1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, 1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(1, 1, -1), end = c(1, -1, -1))) |&gt;
  add_lines(generate_line(start = c(1, 1, -1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(1, -1, -1), end = c(1, -1, 1))) |&gt;
  add_lines(generate_line(start = c(1, -1, 1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, -1), end = c(1, 1, -1)))
  
rasterize_lines(cube_outline,fov=90,lookfrom=c(0,0,3))
}
</code></pre>

<hr>
<h2 id='add_plane_uv_mesh'>Add Plane UV Mapping to Mesh</h2><span id='topic+add_plane_uv_mesh'></span>

<h3>Description</h3>

<p>Applies a planar UV mapping to a mesh based on a given direction and set of U/V vectors.
If <code>full_mesh_bbox</code> is true, the UV mapping is scaled based on the bounding box
of the entire mesh. If false, each shape's bounding box is used.
One of direction/u/v must be <code>NULL</code> and will be calculated from the others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_plane_uv_mesh(
  mesh,
  direction = c(0, 1, 0),
  u = NULL,
  v = NULL,
  override_existing = FALSE,
  full_mesh_bbox = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_plane_uv_mesh_+3A_mesh">mesh</code></td>
<td>
<p>The mesh to which the UV mapping will be applied.</p>
</td></tr>
<tr><td><code id="add_plane_uv_mesh_+3A_direction">direction</code></td>
<td>
<p>Default <code>c(0, 1, 0)</code>. A vector specifying the direction for
UV mapping. If not specified and <code>u</code>/<code>v</code> are both specified, this will be ignored.</p>
</td></tr>
<tr><td><code id="add_plane_uv_mesh_+3A_u">u</code></td>
<td>
<p>Default <code>NULL</code>. A vector specifying the u direction.</p>
</td></tr>
<tr><td><code id="add_plane_uv_mesh_+3A_v">v</code></td>
<td>
<p>Default <code>NULL</code>. A vector specifying the v direction.</p>
</td></tr>
<tr><td><code id="add_plane_uv_mesh_+3A_override_existing">override_existing</code></td>
<td>
<p>Default <code>FALSE</code>. Specifies whether existing UV
coordinates should be overridden.</p>
</td></tr>
<tr><td><code id="add_plane_uv_mesh_+3A_full_mesh_bbox">full_mesh_bbox</code></td>
<td>
<p>Default <code>TRUE</code>. Specifies whether the full mesh's
bounding box is used for UV mapping.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified mesh with added UV mapping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Let's construct a mesh from the volcano dataset
#Build the vertex matrix
vertex_list = list()
counter = 1
for(i in 1:nrow(volcano)) {
  for(j in 1:ncol(volcano)) {
    vertex_list[[counter]] = matrix(c(j,volcano[i,j]/3,i), ncol=3)
    counter = counter + 1
  }
}
vertices = do.call(rbind,vertex_list)

#Build the index matrix
index_list = list()
counter = 0
for(i in 1:(nrow(volcano)-1)) {
  for(j in 1:(ncol(volcano)-1)) {
    index_list[[counter+1]] = matrix(c(counter,counter+ncol(volcano),counter+1,
                                       counter+ncol(volcano),counter+ncol(volcano)+1,counter + 1),
                                     nrow=2, ncol=3, byrow=TRUE)
    counter = counter + 1
  }
  counter = counter + 1
}
indices = do.call("rbind",index_list)

#Create a checkerboard image
create_checkerboard_texture = function(filename, n = 16) {
  old_par = par(no.readonly = TRUE)
  on.exit(par(old_par))
  plot.new()
  par(mar = c(0, 0, 0, 0))
  checkerboard = matrix(c(1, 0), nrow = n+1, ncol = n)
  png(filename, width = 800, height = 800)
  image(1:(n+1), 1:n, checkerboard, col = c("dodgerblue", "red"),
        axes = FALSE, xlab = "", ylab = "")
  dev.off()
}
checkerboard_file = tempfile(fileext = ".png")
create_checkerboard_texture(checkerboard_file)
rayimage::plot_image(checkerboard_file)
}

if(run_documentation()) {
#Construct the mesh
volc_mesh = construct_mesh(vertices = vertices, indices = indices,
                           material = material_list(type="phong", diffuse="darkred",
                                                    ambient = "darkred", ambient_intensity=0.2))


#Set the direction so that the checkerboard will be mapped to the surface like a carpet
uv = add_plane_uv_mesh(volc_mesh, direction=c(0,200,0), u = c(1,0,0))
uv = set_material(uv, texture_location = checkerboard_file,
                  ambient = "white", ambient_intensity=0.1)
#Rasterize the scene
rasterize_scene(center_mesh(uv), lookfrom=c(200,200,200),fov=0,width=1200,height=1200,
                light_info = directional_light(c(0,1,1)) |&gt;
                  add_light(directional_light(c(1,1,-1))),ortho_dimensions=c(120,120))
}

if(run_documentation()) {
#Set the direction so that the checkerboard will be mapped directly at the camera
uv = add_plane_uv_mesh(volc_mesh, direction=c(200,200,200), v = c(-1,1,-1))
uv = set_material(uv, texture_location = checkerboard_file,
                  ambient = "white", ambient_intensity=0.1)
#Rasterize the scene
rasterize_scene(center_mesh(uv), lookfrom=c(200,200,200),fov=0,width=1200,height=1200,
                light_info = directional_light(c(0,1,1)) |&gt;
                add_light(directional_light(c(1,1,-1))), ortho_dimensions=c(120,120))
}
</code></pre>

<hr>
<h2 id='add_shape'>Add Shape</h2><span id='topic+add_shape'></span>

<h3>Description</h3>

<p>Add shape to the scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_shape(scene, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_shape_+3A_scene">scene</code></td>
<td>
<p>The scene to add the shape.</p>
</td></tr>
<tr><td><code id="add_shape_+3A_shape">shape</code></td>
<td>
<p>The mesh to add to the scene.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scene with shape added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate several spheres in the cornell box
scene = generate_cornell_mesh()
set.seed(1)

for(i in 1:30) {
 col = hsv(runif(1))
 scene = add_shape(scene, sphere_mesh(position=runif(3)*400+155/2,
                                      material=material_list(diffuse=col, type="phong",
                                                             ambient=col,ambient_intensity=0.2), 
                                      radius=30))
}
rasterize_scene(scene, light_info=directional_light(direction=c(0.1,0.6,-1)))
}
</code></pre>

<hr>
<h2 id='add_sphere_uv_mesh'>Add Sphere UV Mapping to Mesh</h2><span id='topic+add_sphere_uv_mesh'></span>

<h3>Description</h3>

<p>Applies a planar UV mapping to a mesh based on a spherical
direction from the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_sphere_uv_mesh(mesh, origin = c(0, 0, 0), override_existing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_sphere_uv_mesh_+3A_mesh">mesh</code></td>
<td>
<p>The mesh to which the UV mapping will be applied.</p>
</td></tr>
<tr><td><code id="add_sphere_uv_mesh_+3A_origin">origin</code></td>
<td>
<p>Default <code>c(0, 0, 0)</code>. A vector specifying the origin to
apply spherical UV coordinates.</p>
</td></tr>
<tr><td><code id="add_sphere_uv_mesh_+3A_override_existing">override_existing</code></td>
<td>
<p>Default <code>FALSE</code>. Specifies whether existing UV
coordinates should be overridden.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified mesh with added UV mapping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Let's construct a mesh from the volcano dataset

}
</code></pre>

<hr>
<h2 id='arrow_mesh'>Arrow 3D Model</h2><span id='topic+arrow_mesh'></span>

<h3>Description</h3>

<p>Arrow 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrow_mesh(
  start = c(0, 0, 0),
  end = c(0, 1, 0),
  radius_top = 0.5,
  radius_tail = 0.25,
  tail_proportion = 0.5,
  direction = NA,
  from_center = TRUE,
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrow_mesh_+3A_start">start</code></td>
<td>
<p>Default <code>c(0, 0, 0)</code>. Base of the arrow, specifying <code>x</code>, <code>y</code>, <code>z</code>.</p>
</td></tr>
<tr><td><code id="arrow_mesh_+3A_end">end</code></td>
<td>
<p>Default <code>c(0, 1, 0)</code>. Tip of the arrow, specifying <code>x</code>, <code>y</code>, <code>z</code>.</p>
</td></tr>
<tr><td><code id="arrow_mesh_+3A_radius_top">radius_top</code></td>
<td>
<p>Default <code>0.5</code>. Radius of the top of the arrow.</p>
</td></tr>
<tr><td><code id="arrow_mesh_+3A_radius_tail">radius_tail</code></td>
<td>
<p>Default <code>0.2</code>.  Radius of the tail of the arrow.</p>
</td></tr>
<tr><td><code id="arrow_mesh_+3A_tail_proportion">tail_proportion</code></td>
<td>
<p>Default <code>0.5</code>. Proportion of the arrow that is the tail.</p>
</td></tr>
<tr><td><code id="arrow_mesh_+3A_direction">direction</code></td>
<td>
<p>Default <code>NA</code>. Alternative to <code>start</code> and <code>end</code>, specify the direction (via
a length-3 vector) of the arrow. Arrow will be centered at <code>start</code>, and the length will be
determined by the magnitude of the direction vector.</p>
</td></tr>
<tr><td><code id="arrow_mesh_+3A_from_center">from_center</code></td>
<td>
<p>Default <code>TRUE</code>. If orientation specified via <code>direction</code>, setting this argument
to <code>FALSE</code> will make <code>start</code> specify the bottom of the cone, instead of the middle.</p>
</td></tr>
<tr><td><code id="arrow_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate an arrow
generate_cornell_mesh() |&gt;
  add_shape(arrow_mesh(start = c(555/2, 20, 555/2), end = c(555/2, 300, 555/2), radius_tail=50,
                       radius_top = 100,
                      material = material_list(diffuse="dodgerblue"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
if(run_documentation()) {
#Generate a blue arrow with a wide tail
generate_cornell_mesh() |&gt;
  add_shape(arrow_mesh(start = c(555/2, 20, 555/2), end = c(555/2, 300, 555/2), radius_tail=100,
                       radius_top = 150,
                      material = material_list(diffuse="dodgerblue"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
  }
if(run_documentation()) {
#Generate a long, thin arrow and change the proportions
generate_cornell_mesh() |&gt;
  add_shape(arrow_mesh(start = c(555/2, 20, 555/2), end = c(555/2, 400, 555/2), radius_top=30,
                       radius_tail = 10, tail_proportion = 0.8,
                      material = material_list(diffuse="dodgerblue"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
if(run_documentation()) {
#Change the start and end points
generate_cornell_mesh() |&gt;
  add_shape(arrow_mesh(start = c(500, 20, 555/2), end = c(50, 500, 555/2), radius_top=30,
                       radius_tail = 10, tail_proportion = 0.8,
                      material = material_list(diffuse="dodgerblue"))) |&gt;
  add_shape(arrow_mesh(start = c(500, 500, 500), end = c(50, 50, 50), radius_top=30,
                       radius_tail = 10, tail_proportion = 0.8,
                      material = material_list(diffuse="red"))) |&gt;
  add_shape(arrow_mesh(start = c(555/2, 50, 500), end = c(555/2, 50, 50), radius_top=30,
                       radius_tail = 10, tail_proportion = 0.8,
                      material = material_list(diffuse="green"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
</code></pre>

<hr>
<h2 id='cat_color'>Print out the color</h2><span id='topic+cat_color'></span>

<h3>Description</h3>

<p>Print out the color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_color(color, var_name, default = NA, intensity = 1, spacer = "")
</code></pre>


<h3>Value</h3>

<p>none
</p>

<hr>
<h2 id='center_mesh'>Center Mesh</h2><span id='topic+center_mesh'></span>

<h3>Description</h3>

<p>Centers the mesh at the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_mesh(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="center_mesh_+3A_mesh">mesh</code></td>
<td>
<p>The mesh object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Centered mesh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Center the Cornell box and the R OBJ at the origin
center_mesh(generate_cornell_mesh()) |&gt;
  add_shape(center_mesh(obj_mesh(r_obj(),scale=100,angle=c(0,180,0)))) |&gt;
  rasterize_scene(lookfrom=c(0,0,-1100),fov=40,lookat=c(0,0,0),
                  light_info = directional_light(c(0.4,0.4,-1)) |&gt;
      add_light(point_light(c(0,450,0),  falloff_quad = 0.0, constant = 0.0002, falloff = 0.005)))
}
</code></pre>

<hr>
<h2 id='change_material'>Change Material</h2><span id='topic+change_material'></span>

<h3>Description</h3>

<p>Change individual material properties, leaving others alone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_material(
  mesh,
  id = NULL,
  sub_id = 1,
  diffuse = NULL,
  ambient = NULL,
  specular = NULL,
  transmittance = NULL,
  emission = NULL,
  shininess = NULL,
  ior = NULL,
  dissolve = NULL,
  illum = NULL,
  texture_location = NULL,
  normal_texture_location = NULL,
  bump_texture_location = NULL,
  specular_texture_location = NULL,
  ambient_texture_location = NULL,
  emissive_texture_location = NULL,
  diffuse_intensity = NULL,
  bump_intensity = NULL,
  specular_intensity = NULL,
  emission_intensity = NULL,
  ambient_intensity = NULL,
  culling = NULL,
  type = NULL,
  translucent = NULL,
  toon_levels = NULL,
  toon_outline_width = NULL,
  toon_outline_color = NULL,
  reflection_intensity = NULL,
  reflection_sharpness = NULL,
  two_sided = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="change_material_+3A_mesh">mesh</code></td>
<td>
<p>Mesh to change.</p>
</td></tr>
<tr><td><code id="change_material_+3A_id">id</code></td>
<td>
<p>Default <code>NULL</code>. Either a number specifying the material to change, or a character vector
matching the material name.</p>
</td></tr>
<tr><td><code id="change_material_+3A_sub_id">sub_id</code></td>
<td>
<p>Default <code>1</code>. A number specifying which material to change (within an id).</p>
</td></tr>
<tr><td><code id="change_material_+3A_diffuse">diffuse</code></td>
<td>
<p>Default <code>NULL</code>. The diffuse color.</p>
</td></tr>
<tr><td><code id="change_material_+3A_ambient">ambient</code></td>
<td>
<p>Default <code>NULL</code>. The ambient color.</p>
</td></tr>
<tr><td><code id="change_material_+3A_specular">specular</code></td>
<td>
<p>Default <code>NULL</code>. The specular color.</p>
</td></tr>
<tr><td><code id="change_material_+3A_transmittance">transmittance</code></td>
<td>
<p>Default <code>NULL</code>. The transmittance</p>
</td></tr>
<tr><td><code id="change_material_+3A_emission">emission</code></td>
<td>
<p>Default <code>NULL</code>. The emissive color.</p>
</td></tr>
<tr><td><code id="change_material_+3A_shininess">shininess</code></td>
<td>
<p>Default <code>NULL</code>. The shininess exponent.</p>
</td></tr>
<tr><td><code id="change_material_+3A_ior">ior</code></td>
<td>
<p>Default <code>NULL</code>. The index of refraction. If this is not equal to <code>1.0</code>, the material will be refractive.</p>
</td></tr>
<tr><td><code id="change_material_+3A_dissolve">dissolve</code></td>
<td>
<p>Default <code>NULL</code>. The transparency.</p>
</td></tr>
<tr><td><code id="change_material_+3A_illum">illum</code></td>
<td>
<p>Default <code>NULL</code>. The illumination.</p>
</td></tr>
<tr><td><code id="change_material_+3A_texture_location">texture_location</code></td>
<td>
<p>Default <code>NULL</code>. The diffuse texture location.</p>
</td></tr>
<tr><td><code id="change_material_+3A_normal_texture_location">normal_texture_location</code></td>
<td>
<p>Default <code>NULL</code>. The normal texture location.</p>
</td></tr>
<tr><td><code id="change_material_+3A_bump_texture_location">bump_texture_location</code></td>
<td>
<p>Default <code>NULL</code>. The bump texture location.</p>
</td></tr>
<tr><td><code id="change_material_+3A_specular_texture_location">specular_texture_location</code></td>
<td>
<p>Default <code>NULL</code>. The specular texture location.</p>
</td></tr>
<tr><td><code id="change_material_+3A_ambient_texture_location">ambient_texture_location</code></td>
<td>
<p>Default <code>NULL</code>. The ambient texture location.</p>
</td></tr>
<tr><td><code id="change_material_+3A_emissive_texture_location">emissive_texture_location</code></td>
<td>
<p>Default <code>NULL</code>. The emissive texture location.</p>
</td></tr>
<tr><td><code id="change_material_+3A_diffuse_intensity">diffuse_intensity</code></td>
<td>
<p>Default <code>NULL</code>. The diffuse intensity.</p>
</td></tr>
<tr><td><code id="change_material_+3A_bump_intensity">bump_intensity</code></td>
<td>
<p>Default <code>NULL</code>. The bump intensity.</p>
</td></tr>
<tr><td><code id="change_material_+3A_specular_intensity">specular_intensity</code></td>
<td>
<p>Default <code>NULL</code>. The specular intensity.</p>
</td></tr>
<tr><td><code id="change_material_+3A_emission_intensity">emission_intensity</code></td>
<td>
<p>Default <code>NULL</code>. The emission intensity.</p>
</td></tr>
<tr><td><code id="change_material_+3A_ambient_intensity">ambient_intensity</code></td>
<td>
<p>Default <code>NULL</code>. The ambient intensity.</p>
</td></tr>
<tr><td><code id="change_material_+3A_culling">culling</code></td>
<td>
<p>Default <code>NULL</code>. The culling type. Options are <code>back</code>, <code>front</code>, and <code>none</code>.</p>
</td></tr>
<tr><td><code id="change_material_+3A_type">type</code></td>
<td>
<p>Default <code>NULL</code>. The shader type. Options include <code>diffuse</code>,<code>phong</code>,<code>vertex</code>, and <code>color</code>.</p>
</td></tr>
<tr><td><code id="change_material_+3A_translucent">translucent</code></td>
<td>
<p>Default <code>NULL</code>. Whether light should transmit through a semi-transparent material.</p>
</td></tr>
<tr><td><code id="change_material_+3A_toon_levels">toon_levels</code></td>
<td>
<p>Default <code>NULL</code>. Number of color breaks in the toon shader.</p>
</td></tr>
<tr><td><code id="change_material_+3A_toon_outline_width">toon_outline_width</code></td>
<td>
<p>Default <code>NULL</code>. Expansion term for model to specify toon outline width. Note: setting this property via this function currently does not generate outlines. Specify it during object creation.</p>
</td></tr>
<tr><td><code id="change_material_+3A_toon_outline_color">toon_outline_color</code></td>
<td>
<p>Default <code>NULL</code>. Toon outline color.Note: setting this property via this function currently does not color outlines. Specify it during object creation.</p>
</td></tr>
<tr><td><code id="change_material_+3A_reflection_intensity">reflection_intensity</code></td>
<td>
<p>Default <code>NULL</code>. Intensity of the reflection of the environment map, if present. This will be ignored if the material is refractive.</p>
</td></tr>
<tr><td><code id="change_material_+3A_reflection_sharpness">reflection_sharpness</code></td>
<td>
<p>Default <code>NULL</code>. Sharpness of the reflection, where lower values have blurrier reflections. Must be greater than zero and less than one.</p>
</td></tr>
<tr><td><code id="change_material_+3A_two_sided">two_sided</code></td>
<td>
<p>Default <code>NULL</code>. Whether diffuse materials should be two sided (normal is taken as the absolute value of the dot product of the light direction and the normal).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shape with new material settings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
p_sphere = sphere_mesh(position=c(555/2,555/2,555/2), 
                      radius=40,material=material_list(diffuse="purple"))
generate_cornell_mesh() |&gt;
 add_shape(translate_mesh(p_sphere,c(0,-100,0))) |&gt;
 add_shape(change_material(translate_mesh(p_sphere,c(200,-100,0)),diffuse="red")) |&gt;
 add_shape(change_material(translate_mesh(p_sphere,c(100,-100,0)),dissolve=0.5)) |&gt;
 add_shape(change_material(translate_mesh(p_sphere,c(-100,-100,0)),type="phong")) |&gt;
 add_shape(change_material(translate_mesh(p_sphere,c(-200,-100,0)),type="phong",shininess=30)) |&gt;
 rasterize_scene(light_info=directional_light(direction=c(0.1,0.6,-1)))
}  

if(run_documentation()) {
#Change several shapes at once
p_sphere |&gt;
 add_shape(change_material(translate_mesh(p_sphere,c(200,0,0)),diffuse="red")) |&gt;
 add_shape(change_material(translate_mesh(p_sphere,c(100,0,0)),dissolve=0.5)) |&gt;
 add_shape(change_material(translate_mesh(p_sphere,c(-100,0,0)),type="phong")) |&gt;
 add_shape(change_material(translate_mesh(p_sphere,c(-200,0,0)),type="phong",shininess=30)) |&gt;
 change_material(diffuse = "red") |&gt; 
 add_shape(generate_cornell_mesh()) |&gt; 
 rasterize_scene(light_info=directional_light(direction=c(0.1,0.6,-1)))
}
</code></pre>

<hr>
<h2 id='color_lines'>Color Lines</h2><span id='topic+color_lines'></span>

<h3>Description</h3>

<p>Color Lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_lines(lines, color = "white")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="color_lines_+3A_lines">lines</code></td>
<td>
<p>The line scene.</p>
</td></tr>
<tr><td><code id="color_lines_+3A_color">color</code></td>
<td>
<p>Default <code>white</code>. The color to convert the lines to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Colored line matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a cube out of lines
cube_outline = generate_line(start = c(-1, -1, -1), end = c(-1, -1, 1)) |&gt;
  add_lines(generate_line(start = c(-1, -1, -1), end = c(-1, 1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, -1), end = c(1, -1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, 1), end = c(-1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, 1), end = c(1, -1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, 1), end = c(-1, 1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, 1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(1, 1, -1), end = c(1, -1, -1))) |&gt;
  add_lines(generate_line(start = c(1, 1, -1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(1, -1, -1), end = c(1, -1, 1))) |&gt;
  add_lines(generate_line(start = c(1, -1, 1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, -1), end = c(1, 1, -1)))
  
cube_outline |&gt;
  color_lines(color="red") |&gt;
  rasterize_lines()
}
</code></pre>

<hr>
<h2 id='cone_mesh'>Cone 3D Model</h2><span id='topic+cone_mesh'></span>

<h3>Description</h3>

<p>Cone 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cone_mesh(
  start = c(0, 0, 0),
  end = c(0, 1, 0),
  radius = 0.5,
  direction = NA,
  from_center = FALSE,
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cone_mesh_+3A_start">start</code></td>
<td>
<p>Default <code>c(0, 0, 0)</code>. Base of the cone, specifying <code>x</code>, <code>y</code>, <code>z</code>.</p>
</td></tr>
<tr><td><code id="cone_mesh_+3A_end">end</code></td>
<td>
<p>Default <code>c(0, 1, 0)</code>. Tip of the cone, specifying <code>x</code>, <code>y</code>, <code>z</code>.</p>
</td></tr>
<tr><td><code id="cone_mesh_+3A_radius">radius</code></td>
<td>
<p>Default <code>1</code>. Radius of the bottom of the cone.</p>
</td></tr>
<tr><td><code id="cone_mesh_+3A_direction">direction</code></td>
<td>
<p>Default <code>NA</code>. Alternative to <code>start</code> and <code>end</code>, specify the direction (via
a length-3 vector) of the cone. Cone will be centered at <code>start</code>, and the length will be
determined by the magnitude of the direction vector.</p>
</td></tr>
<tr><td><code id="cone_mesh_+3A_from_center">from_center</code></td>
<td>
<p>Default <code>TRUE</code>. If orientation specified via <code>direction</code>, setting this argument
to <code>FALSE</code> will make <code>start</code> specify the bottom of the cone, instead of the middle.</p>
</td></tr>
<tr><td><code id="cone_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a cone
generate_cornell_mesh() |&gt;
  add_shape(cone_mesh(start = c(555/2, 20, 555/2), end = c(555/2, 300, 555/2),
                      radius = 100)) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
if(run_documentation()) {
#Generate a blue cone with a wide base
generate_cornell_mesh() |&gt;
  add_shape(cone_mesh(start = c(555/2, 20, 555/2), end = c(555/2, 300, 555/2), radius=200,
                      material = material_list(diffuse="dodgerblue"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
if(run_documentation()) {
#Generate a long, thin cone
generate_cornell_mesh() |&gt;
  add_shape(cone_mesh(start = c(555/2, 20, 555/2), end = c(555/2, 400, 555/2), radius=50,
                      material = material_list(diffuse="dodgerblue"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
</code></pre>

<hr>
<h2 id='construct_mesh'>Manually construct a mesh</h2><span id='topic+construct_mesh'></span>

<h3>Description</h3>

<p>Manually construct a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_mesh(
  vertices,
  indices,
  normals = NULL,
  norm_indices = NULL,
  texcoords = NULL,
  tex_indices = NULL,
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_mesh_+3A_vertices">vertices</code></td>
<td>
<p>Nx3 matrix of vertex coordinates..</p>
</td></tr>
<tr><td><code id="construct_mesh_+3A_indices">indices</code></td>
<td>
<p>Nx3 integer matrix, where each row defines a triangle using the
vertices defined in <code>vertices</code>.</p>
</td></tr>
<tr><td><code id="construct_mesh_+3A_normals">normals</code></td>
<td>
<p>Default <code>NULL</code>.  Nx3 matrix of normals.</p>
</td></tr>
<tr><td><code id="construct_mesh_+3A_norm_indices">norm_indices</code></td>
<td>
<p>Nx3 integer matrix, where each row defines the normal for a vertex using the
normals defined in <code>normals</code> for the corresponding triangle in <code>indices</code>.
Required to be the same number of rows as <code>indices</code>.</p>
</td></tr>
<tr><td><code id="construct_mesh_+3A_texcoords">texcoords</code></td>
<td>
<p>Default <code>NULL</code>. Nx2 matrix of texture coordinates.</p>
</td></tr>
<tr><td><code id="construct_mesh_+3A_tex_indices">tex_indices</code></td>
<td>
<p>Nx3 integer matrix, where each row defines the texture coordinates for a triangle
using the tex coords defined in <code>texcoors</code> for the corresponding triangle in <code>indices</code>.
Required to be the same number of rows as <code>indices</code>.</p>
</td></tr>
<tr><td><code id="construct_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing mesh info.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Let's construct a mesh from the volcano dataset
#Build the vertex matrix
vertex_list = list()
counter = 1
for(i in 1:nrow(volcano)) {
  for(j in 1:ncol(volcano)) {
    vertex_list[[counter]] = matrix(c(j,volcano[i,j],i), ncol=3)
    counter = counter + 1
  }
}
vertices = do.call(rbind,vertex_list)

#Build the index matrix
index_list = list()
counter = 0
for(i in 1:(nrow(volcano)-1)) {
  for(j in 1:(ncol(volcano)-1)) {
    index_list[[counter+1]] = matrix(c(counter,counter+ncol(volcano),counter+1,
                                       counter+ncol(volcano),counter+ncol(volcano)+1,counter + 1), 
                                     nrow=2, ncol=3, byrow=TRUE)
    counter = counter + 1
  }
  counter = counter + 1
}
indices = do.call(rbind,index_list)

#Construct the mesh
volc_mesh = construct_mesh(vertices = vertices, indices = indices,
                           material = material_list(type="phong", diffuse="darkred", 
                                                    ambient = "darkred", ambient_intensity=0.2))

#Rasterize the scene
rasterize_scene(volc_mesh, lookfrom=c(-50,230,100),fov=60,width=1200,height=1200,
                light_info = directional_light(c(0,1,1)) |&gt;
                  add_light(directional_light(c(1,1,-1))))
}
</code></pre>

<hr>
<h2 id='convert_color'>Convert Color</h2><span id='topic+convert_color'></span>

<h3>Description</h3>

<p>Convert Color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_color(color, as_hex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_color_+3A_color">color</code></td>
<td>
<p>The color to convert. Can be either a hexadecimal code, or a numeric rgb
vector listing three intensities between <code>0</code> and <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Color vector
</p>

<hr>
<h2 id='convert_rgb_to_ansi'>Convert RGB to ANSI Color</h2><span id='topic+convert_rgb_to_ansi'></span>

<h3>Description</h3>

<p>Convert RGB to ANSI Color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_rgb_to_ansi(color)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_rgb_to_ansi_+3A_color">color</code></td>
<td>
<p>Length=3 numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ANSI color code as a string.
</p>

<hr>
<h2 id='cross_prod'>Cross Product</h2><span id='topic+cross_prod'></span>

<h3>Description</h3>

<p>Computes the cross product of two 3-dimensional vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_prod(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cross_prod_+3A_x">x</code></td>
<td>
<p>A numeric vector representing the first 3D vector.</p>
</td></tr>
<tr><td><code id="cross_prod_+3A_y">y</code></td>
<td>
<p>A numeric vector representing the second 3D vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the cross product of <code>x</code> and <code>y</code>.
</p>

<hr>
<h2 id='cube_mesh'>Cube 3D Model</h2><span id='topic+cube_mesh'></span>

<h3>Description</h3>

<p>3D obj model of the letter R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cube_mesh(
  position = c(0, 0, 0),
  scale = c(1, 1, 1),
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cube_mesh_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Position of the mesh.</p>
</td></tr>
<tr><td><code id="cube_mesh_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. Scale of the mesh. Can also be a single numeric value scaling all axes uniformly.</p>
</td></tr>
<tr><td><code id="cube_mesh_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Angle to rotate the mesh.</p>
</td></tr>
<tr><td><code id="cube_mesh_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Point around which to rotate the mesh.</p>
</td></tr>
<tr><td><code id="cube_mesh_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. Order to rotate the axes.</p>
</td></tr>
<tr><td><code id="cube_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a cube
generate_cornell_mesh() |&gt;
  add_shape(cube_mesh(position = c(555/2, 100, 555/2), scale = 100)) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
if(run_documentation()) {
#Generate a blue rotated cube 
generate_cornell_mesh() |&gt;
  add_shape(cube_mesh(position = c(555/2, 100, 555/2), scale = 100, angle=c(0,45,0),
                      material = material_list(diffuse="dodgerblue"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
if(run_documentation()) {
#Generate a scaled, blue rotated cube 
generate_cornell_mesh() |&gt;
  add_shape(cube_mesh(position = c(555/2, 100, 555/2), angle=c(0,45,0),
                      scale = c(2,0.5,0.8)*100,
                      material = material_list(diffuse="dodgerblue"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
</code></pre>

<hr>
<h2 id='cylinder_mesh'>Cylinder 3D Model</h2><span id='topic+cylinder_mesh'></span>

<h3>Description</h3>

<p>Cylinder 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cylinder_mesh(
  position = c(0, 0, 0),
  radius = 0.5,
  length = 1,
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cylinder_mesh_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Position of the mesh.</p>
</td></tr>
<tr><td><code id="cylinder_mesh_+3A_radius">radius</code></td>
<td>
<p>Default <code>0.5</code>. Radius of the cylinder.</p>
</td></tr>
<tr><td><code id="cylinder_mesh_+3A_length">length</code></td>
<td>
<p>Default <code>1</code>. Length of the cylinder.</p>
</td></tr>
<tr><td><code id="cylinder_mesh_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Angle to rotate the mesh.</p>
</td></tr>
<tr><td><code id="cylinder_mesh_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Point around which to rotate the mesh.</p>
</td></tr>
<tr><td><code id="cylinder_mesh_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. Order to rotate the axes.</p>
</td></tr>
<tr><td><code id="cylinder_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a cylinder
generate_cornell_mesh() |&gt;
  add_shape(cylinder_mesh(position=c(555/2,150,555/2),
                          radius = 50, length=300, material = material_list(diffuse="purple"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
if(run_documentation()) {
#Generate a wide, thin disk
generate_cornell_mesh() |&gt;
  add_shape(cylinder_mesh(position=c(555/2,20,555/2),
                          radius = 200, length=5, material = material_list(diffuse="purple"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
if(run_documentation()) {
#Generate a narrow cylinder
generate_cornell_mesh() |&gt;
  add_shape(cylinder_mesh(position=c(555/2,555/2,555/2),angle=c(45,-45,0),
                          radius = 10, length=500, material = material_list(diffuse="purple"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
</code></pre>

<hr>
<h2 id='directional_light'>Generate Directional Lights</h2><span id='topic+directional_light'></span>

<h3>Description</h3>

<p>Generate Directional Lights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directional_light(direction = c(0, 1, 0), color = "white", intensity = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="directional_light_+3A_direction">direction</code></td>
<td>
<p>Default <code>c(0,1,0)</code>. Direction of the light.</p>
</td></tr>
<tr><td><code id="directional_light_+3A_color">color</code></td>
<td>
<p>Default <code>white</code>. COlor of the light.</p>
</td></tr>
<tr><td><code id="directional_light_+3A_intensity">intensity</code></td>
<td>
<p>Default <code>1</code>. Intensity of the light.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the light information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Add a light to scene (manually specify the light automatically added to the Cornell Box
lights = point_light(position=c(555/2,450,555/2),
                    falloff_quad = 0.0, constant = 0.0002, falloff = 0.005)
generate_cornell_mesh(light=FALSE) |&gt;
 rasterize_scene(light_info = lights)
 
#Add a directional light
lights_d = add_light(lights, directional_light(direction=c(1,1.5,-1)))

generate_cornell_mesh(light=FALSE) |&gt;
 rasterize_scene(light_info = lights_d)
 
#Change the intensity and color
lights_d = add_light(lights, 
                    directional_light(direction=c(1,1.5,-1),color="orange", intensity=0.5))

generate_cornell_mesh(light=FALSE) |&gt;
 rasterize_scene(light_info = lights_d)
}
</code></pre>

<hr>
<h2 id='displace_mesh'>Displace a Mesh</h2><span id='topic+displace_mesh'></span>

<h3>Description</h3>

<p>Displace a Mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displace_mesh(
  mesh,
  displacement_texture,
  displacement_scale = 1,
  displacement_vector = FALSE,
  id = NA,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="displace_mesh_+3A_mesh">mesh</code></td>
<td>
<p>The mesh.</p>
</td></tr>
<tr><td><code id="displace_mesh_+3A_displacement_texture">displacement_texture</code></td>
<td>
<p>Image or matrix/array that will be used to displace the mesh</p>
</td></tr>
<tr><td><code id="displace_mesh_+3A_displacement_scale">displacement_scale</code></td>
<td>
<p>Default <code>1</code>. Intensity of the displacement effect.
Higher values result in greater displacement.</p>
</td></tr>
<tr><td><code id="displace_mesh_+3A_displacement_vector">displacement_vector</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to use vector displacement.
If <code>TRUE</code>, the displacement texture is interpreted as providing a 3D displacement vector.
Otherwise, the texture is interpreted as providing a scalar displacement.</p>
</td></tr>
<tr><td><code id="displace_mesh_+3A_id">id</code></td>
<td>
<p>Default <code>NA</code> (all shapes). The shape index to have new normals calculated.</p>
</td></tr>
<tr><td><code id="displace_mesh_+3A_verbose">verbose</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to print displacement texture information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>raymesh object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
 #Let's construct a mesh from the volcano dataset
}
</code></pre>

<hr>
<h2 id='displacement_sphere'>Construct Displacement Sphere</h2><span id='topic+displacement_sphere'></span>

<h3>Description</h3>

<p>Construct Displacement Sphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displacement_sphere(
  displacement_texture,
  displacement_scale = 1,
  use_cube = FALSE,
  cube_subdivision_levels = NA,
  displace = TRUE,
  verbose = TRUE,
  position = c(0, 0, 0),
  scale = c(1, 1, 1),
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="displacement_sphere_+3A_displacement_texture">displacement_texture</code></td>
<td>
<p>Image or matrix/array that will be used to displace the sphere.</p>
</td></tr>
<tr><td><code id="displacement_sphere_+3A_displacement_scale">displacement_scale</code></td>
<td>
<p>Default <code>1</code>. Scale of the displacement.</p>
</td></tr>
<tr><td><code id="displacement_sphere_+3A_use_cube">use_cube</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to use a subdivided cube instead of a UV sphere. Use this
if you want to visualize areas near the poles.</p>
</td></tr>
<tr><td><code id="displacement_sphere_+3A_cube_subdivision_levels">cube_subdivision_levels</code></td>
<td>
<p>Default <code>NA</code>. Uses the dimensions of the displacement texture
to automatically calculate the number of subdivision levels.</p>
</td></tr>
<tr><td><code id="displacement_sphere_+3A_displace">displace</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to displace the sphere, or just generate the initial mesh
for later displacement.</p>
</td></tr>
<tr><td><code id="displacement_sphere_+3A_verbose">verbose</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to print displacement texture information.</p>
</td></tr>
<tr><td><code id="displacement_sphere_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Position of the mesh.</p>
</td></tr>
<tr><td><code id="displacement_sphere_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. Scale of the mesh. Can also be a single numeric value scaling all axes uniformly.</p>
</td></tr>
<tr><td><code id="displacement_sphere_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Angle to rotate the mesh.</p>
</td></tr>
<tr><td><code id="displacement_sphere_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Point around which to rotate the mesh.</p>
</td></tr>
<tr><td><code id="displacement_sphere_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. Order to rotate the axes.</p>
</td></tr>
<tr><td><code id="displacement_sphere_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>raymesh object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {

}
</code></pre>

<hr>
<h2 id='flip_orientation_mesh'>Flip Orientation</h2><span id='topic+flip_orientation_mesh'></span>

<h3>Description</h3>

<p>Flip Orientation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip_orientation_mesh(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flip_orientation_mesh_+3A_mesh">mesh</code></td>
<td>
<p>The mesh to swap orientations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mesh with flipped vertex orientation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Flip a mesh 
if(run_documentation()) {
sphere_mesh(position=c(-1,0,0)) |&gt; 
  add_shape(flip_orientation_mesh(sphere_mesh(position=c(1,0,0)))) |&gt; 
  rasterize_scene(debug="normals",fov=30)
}
</code></pre>

<hr>
<h2 id='fliplr'>Flip Left-Right</h2><span id='topic+fliplr'></span>

<h3>Description</h3>

<p>Flip Left-Right
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fliplr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fliplr_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>

<hr>
<h2 id='flipud'>Flip Up-Down</h2><span id='topic+flipud'></span>

<h3>Description</h3>

<p>Flip Up-Down
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipud(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flipud_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>

<hr>
<h2 id='format_pillar_shp'>Format ray_shape for pillar</h2><span id='topic+format_pillar_shp'></span>

<h3>Description</h3>

<p>Format ray_shape for pillar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_pillar_shp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_pillar_shp_+3A_x">x</code></td>
<td>
<p>A ray_shape object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted character vector.
</p>

<hr>
<h2 id='generate_cornell_mesh'>Cornell Box 3D Model</h2><span id='topic+generate_cornell_mesh'></span>

<h3>Description</h3>

<p>Cornell Box 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_cornell_mesh(
  leftcolor = "#1f7326",
  rightcolor = "#a60d0d",
  roomcolor = "#bababa",
  ceiling = TRUE,
  light = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_cornell_mesh_+3A_leftcolor">leftcolor</code></td>
<td>
<p>Default <code style="white-space: pre;">&#8288;#1f7326&#8288;</code> (green).</p>
</td></tr>
<tr><td><code id="generate_cornell_mesh_+3A_rightcolor">rightcolor</code></td>
<td>
<p>Default <code style="white-space: pre;">&#8288;#a60d0d&#8288;</code> (red).</p>
</td></tr>
<tr><td><code id="generate_cornell_mesh_+3A_roomcolor">roomcolor</code></td>
<td>
<p>Default <code style="white-space: pre;">&#8288;#bababa&#8288;</code> (light grey).</p>
</td></tr>
<tr><td><code id="generate_cornell_mesh_+3A_ceiling">ceiling</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to render the ceiling.</p>
</td></tr>
<tr><td><code id="generate_cornell_mesh_+3A_light">light</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to render a point light near the ceiling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate and render the default Cornell box and add an object.
generate_cornell_mesh() |&gt; 
  rasterize_scene()
}
if(run_documentation()) {
#Add an object to the scene
generate_cornell_mesh() |&gt; 
  add_shape(obj_mesh(r_obj(),position=c(555/2,555/2,555/2),scale=300,angle=c(0,180,0))) |&gt; 
  rasterize_scene()
}
if(run_documentation()) {
#Turn off the ceiling so the default directional light reaches inside the box
generate_cornell_mesh(ceiling=FALSE) |&gt; 
  add_shape(obj_mesh(r_obj(),position=c(555/2,555/2,555/2),scale=300,angle=c(0,180,0))) |&gt; 
  rasterize_scene()
}
if(run_documentation()) {
#Adjust the light to the front
generate_cornell_mesh(ceiling=FALSE) |&gt; 
  add_shape(obj_mesh(r_obj(),position=c(555/2,555/2,555/2),scale=300,angle=c(0,180,0))) |&gt; 
  rasterize_scene(light_info = directional_light(direction=c(0,1,-1)))
  }
if(run_documentation()) {
#Change the color palette
generate_cornell_mesh(ceiling=FALSE,leftcolor="purple", rightcolor="yellow") |&gt; 
  add_shape(obj_mesh(r_obj(),position=c(555/2,555/2,555/2),scale=300,angle=c(0,180,0))) |&gt; 
  rasterize_scene(light_info = directional_light(direction=c(0,1,-1)))
}
</code></pre>

<hr>
<h2 id='generate_line'>Generate Lines</h2><span id='topic+generate_line'></span>

<h3>Description</h3>

<p>Generate Lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_line(start = c(0, 0, 0), end = c(0, 1, 0), color = "white")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_line_+3A_start">start</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Start of the line segment.</p>
</td></tr>
<tr><td><code id="generate_line_+3A_end">end</code></td>
<td>
<p>Default <code>c(0,1,0)</code>. End of the line segment..</p>
</td></tr>
<tr><td><code id="generate_line_+3A_color">color</code></td>
<td>
<p>Default <code>white</code>. Color of the line segment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Line matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
# Make a spiral of lines
t = seq(0,8*pi,length.out=361)
line_mat = matrix(nrow=0,ncol=9)

for(i in 1:360) {
  line_mat = add_lines(line_mat,
                      generate_line(start = c(0.5*sin(t[i]), t[i]/(8*pi), 0.5*cos(t[i])),
                                    end  = c(0.5*sin(t[i+1]), t[i+1]/(8*pi), 0.5*cos(t[i+1]))))
}
rasterize_lines(line_mat)
}
if(run_documentation()) {
#Change the line color
line_mat = matrix(nrow=0,ncol=9)
cols = hsv(seq(0,1,length.out=360))
for(i in 1:360) {
  line_mat = add_lines(line_mat,
                      generate_line(start = c(sin(t[i]), 2*t[i]/(8*pi), cos(t[i])),
                                   end  = c(sin(t[i+1]), 2*t[i+1]/(8*pi), cos(t[i+1])),
                                   color = cols[i]))
}
rasterize_lines(line_mat,lookfrom=c(0,10,10),fov=15)
}
if(run_documentation()) {
#Use in a scene with a mesh
obj_mesh(r_obj(simple_r = TRUE),material=material_list(diffuse="dodgerblue")) |&gt;
 rasterize_scene(line_info = line_mat, light_info = directional_light(c(0,1,1)),
                 lookfrom=c(0,5,10),lookat=c(0,0.8,0),fov=15)
}
</code></pre>

<hr>
<h2 id='generate_rot_matrix'>Generate Rotation Matrix</h2><span id='topic+generate_rot_matrix'></span>

<h3>Description</h3>

<p>Generate Rotation Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_rot_matrix(angle, order_rotation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_rot_matrix_+3A_angle">angle</code></td>
<td>
<p>The angle</p>
</td></tr>
<tr><td><code id="generate_rot_matrix_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix
</p>

<hr>
<h2 id='generate_rotation_matrix_from_direction'>Generate Rotation Matrix from Direction</h2><span id='topic+generate_rotation_matrix_from_direction'></span>

<h3>Description</h3>

<p>Internal function to generate a rotation matrix that aligns the
Y-axis with a given direction vector. It uses the Rodrigues' rotation formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_rotation_matrix_from_direction(
  direction = c(0, 1, 0),
  up = c(0, 1, 0)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_rotation_matrix_from_direction_+3A_direction">direction</code></td>
<td>
<p>Default <code>c(0, 1, 0)</code>. A 3D vector representing the direction.
The function normalizes this vector.</p>
</td></tr>
<tr><td><code id="generate_rotation_matrix_from_direction_+3A_up">up</code></td>
<td>
<p>Default <code>c(0, 1, 0)</code>. A 3D vector representing the up direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3x3 rotation matrix.
</p>

<hr>
<h2 id='generate_surface'>Generate Surface</h2><span id='topic+generate_surface'></span>

<h3>Description</h3>

<p>Generate Surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_surface(heightmap, zscale = 1)
</code></pre>

<hr>
<h2 id='generate_toon_outline'>Add Outline</h2><span id='topic+generate_toon_outline'></span>

<h3>Description</h3>

<p>Add Outline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_toon_outline(single_obj, material, scale = 1)
</code></pre>


<h3>Value</h3>

<p>Matrix
</p>

<hr>
<h2 id='get_file_type'>Check Filename</h2><span id='topic+get_file_type'></span>

<h3>Description</h3>

<p>Check Filename
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_file_type(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_file_type_+3A_file">file</code></td>
<td>
<p>Filename to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>

<hr>
<h2 id='get_mesh_bbox'>Get Mesh Bounding Box</h2><span id='topic+get_mesh_bbox'></span>

<h3>Description</h3>

<p>Calculates the bounding box of a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mesh_bbox(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_mesh_bbox_+3A_mesh">mesh</code></td>
<td>
<p>The mesh object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2x3 numeric matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Calculates the center of the mesh
get_mesh_bbox(generate_cornell_mesh())
}
</code></pre>

<hr>
<h2 id='get_mesh_center'>Get Mesh Center</h2><span id='topic+get_mesh_center'></span>

<h3>Description</h3>

<p>Calculates the coordinates of the center of a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mesh_center(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_mesh_center_+3A_mesh">mesh</code></td>
<td>
<p>The mesh object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Length-3 numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Calculates the center of the mesh
get_mesh_center(generate_cornell_mesh())
}
</code></pre>

<hr>
<h2 id='get_time'>Get time</h2><span id='topic+get_time'></span>

<h3>Description</h3>

<p>Get time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_time(init = TRUE)
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='init_time'>Print time</h2><span id='topic+init_time'></span>

<h3>Description</h3>

<p>Print time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_time()
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='material_list'>Material List</h2><span id='topic+material_list'></span>

<h3>Description</h3>

<p>Generate a material properties list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>material_list(
  diffuse = c(0.8, 0.8, 0.8),
  ambient = c(0, 0, 0),
  specular = c(1, 1, 1),
  transmittance = c(0, 0, 0),
  emission = c(0, 0, 0),
  shininess = 50,
  ior = 1,
  dissolve = 1,
  illum = 1,
  texture_location = "",
  normal_texture_location = "",
  bump_texture_location = "",
  specular_texture_location = "",
  ambient_texture_location = "",
  emissive_texture_location = "",
  diffuse_intensity = 1,
  bump_intensity = 1,
  specular_intensity = 1,
  emission_intensity = 1,
  ambient_intensity = 1,
  culling = "back",
  type = "diffuse",
  translucent = TRUE,
  toon_levels = 5,
  toon_outline_width = 0.05,
  toon_outline_color = "black",
  reflection_intensity = 0,
  reflection_sharpness = 1,
  two_sided = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="material_list_+3A_diffuse">diffuse</code></td>
<td>
<p>Default <code>c(0.5,0.5,0.5)</code>. The diffuse color.</p>
</td></tr>
<tr><td><code id="material_list_+3A_ambient">ambient</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The ambient color.</p>
</td></tr>
<tr><td><code id="material_list_+3A_specular">specular</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. The specular color.</p>
</td></tr>
<tr><td><code id="material_list_+3A_transmittance">transmittance</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The transmittance</p>
</td></tr>
<tr><td><code id="material_list_+3A_emission">emission</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The emissive color.</p>
</td></tr>
<tr><td><code id="material_list_+3A_shininess">shininess</code></td>
<td>
<p>Default <code>50.0</code>. The shininess exponent.</p>
</td></tr>
<tr><td><code id="material_list_+3A_ior">ior</code></td>
<td>
<p>Default <code>1.0</code>. The index of refraction. If this is not equal to <code>1.0</code>, the material will be refractive.</p>
</td></tr>
<tr><td><code id="material_list_+3A_dissolve">dissolve</code></td>
<td>
<p>Default <code>1.0</code>. The transparency.</p>
</td></tr>
<tr><td><code id="material_list_+3A_illum">illum</code></td>
<td>
<p>Default <code>1.0</code>. The illumination.</p>
</td></tr>
<tr><td><code id="material_list_+3A_texture_location">texture_location</code></td>
<td>
<p>Default <code>""</code>. The diffuse texture location.</p>
</td></tr>
<tr><td><code id="material_list_+3A_normal_texture_location">normal_texture_location</code></td>
<td>
<p>Default <code>""</code>. The normal texture location.</p>
</td></tr>
<tr><td><code id="material_list_+3A_bump_texture_location">bump_texture_location</code></td>
<td>
<p>Default <code>""</code>. The bump texture location.</p>
</td></tr>
<tr><td><code id="material_list_+3A_specular_texture_location">specular_texture_location</code></td>
<td>
<p>Default <code>""</code>. The specular texture location.</p>
</td></tr>
<tr><td><code id="material_list_+3A_ambient_texture_location">ambient_texture_location</code></td>
<td>
<p>Default <code>""</code>. The ambient texture location.</p>
</td></tr>
<tr><td><code id="material_list_+3A_emissive_texture_location">emissive_texture_location</code></td>
<td>
<p>Default <code>""</code>. The emissive texture location.</p>
</td></tr>
<tr><td><code id="material_list_+3A_diffuse_intensity">diffuse_intensity</code></td>
<td>
<p>Default <code>1</code>. The diffuse intensity.</p>
</td></tr>
<tr><td><code id="material_list_+3A_bump_intensity">bump_intensity</code></td>
<td>
<p>Default <code>1</code>. The bump intensity.</p>
</td></tr>
<tr><td><code id="material_list_+3A_specular_intensity">specular_intensity</code></td>
<td>
<p>Default <code>1</code>. The specular intensity.</p>
</td></tr>
<tr><td><code id="material_list_+3A_emission_intensity">emission_intensity</code></td>
<td>
<p>Default <code>1</code>. The emission intensity.</p>
</td></tr>
<tr><td><code id="material_list_+3A_ambient_intensity">ambient_intensity</code></td>
<td>
<p>Default <code>1</code>. The ambient intensity.</p>
</td></tr>
<tr><td><code id="material_list_+3A_culling">culling</code></td>
<td>
<p>Default <code>"back"</code>. The culling type. Options are <code>back</code>, <code>front</code>, and <code>none</code>.</p>
</td></tr>
<tr><td><code id="material_list_+3A_type">type</code></td>
<td>
<p>Default <code>"diffuse"</code>. The shader type. Options include <code>diffuse</code>,<code>phong</code>,<code>vertex</code>, and <code>color</code>.</p>
</td></tr>
<tr><td><code id="material_list_+3A_translucent">translucent</code></td>
<td>
<p>Default <code>FALSE</code>. Whether light should transmit through a semi-transparent material.</p>
</td></tr>
<tr><td><code id="material_list_+3A_toon_levels">toon_levels</code></td>
<td>
<p>Default <code>5</code>. Number of color breaks in the toon shader.</p>
</td></tr>
<tr><td><code id="material_list_+3A_toon_outline_width">toon_outline_width</code></td>
<td>
<p>Default <code>0.05</code>. Expansion term for model to specify toon outline width.</p>
</td></tr>
<tr><td><code id="material_list_+3A_toon_outline_color">toon_outline_color</code></td>
<td>
<p>Default <code>black</code>. Toon outline color.</p>
</td></tr>
<tr><td><code id="material_list_+3A_reflection_intensity">reflection_intensity</code></td>
<td>
<p>Default <code>0.0</code>. Intensity of the reflection of the environment map, if present. This will be ignored if the material is refractive.</p>
</td></tr>
<tr><td><code id="material_list_+3A_reflection_sharpness">reflection_sharpness</code></td>
<td>
<p>Default <code>1.0</code>. Sharpness of the reflection, where lower values have blurrier reflections. Must be greater than zero and less than one.</p>
</td></tr>
<tr><td><code id="material_list_+3A_two_sided">two_sided</code></td>
<td>
<p>Default <code>FALSE</code>. Whether diffuse materials should be two sided (normal is taken as the absolute value of the dot product of the light direction and the normal).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of material properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
mat_prop = material_list(diffuse="purple", type="phong", shininess = 20,
                        ambient="purple", ambient_intensity=0.3,
                        specular = "red", specular_intensity=2)
                        
p_sphere = sphere_mesh(position=c(555/2,555/2,555/2), 
                      radius=40,material=mat_prop)
                      
rasterize_scene(p_sphere, light_info=directional_light(direction=c(0.1,0.6,-1)))
}
</code></pre>

<hr>
<h2 id='merge_scene'>Merge scene</h2><span id='topic+merge_scene'></span>

<h3>Description</h3>

<p>Merge the shapes to one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_scene(old_scene, flatten_materials = TRUE)
</code></pre>


<h3>Value</h3>

<p>Merged scene
</p>

<hr>
<h2 id='mesh3d_mesh'>Mesh3d 3D Model</h2><span id='topic+mesh3d_mesh'></span>

<h3>Description</h3>

<p>Mesh3d 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh3d_mesh(
  mesh,
  center = FALSE,
  position = c(0, 0, 0),
  scale = c(1, 1, 1),
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  materialspath = NULL,
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh3d_mesh_+3A_mesh">mesh</code></td>
<td>
<p>Mesh3d object.</p>
</td></tr>
<tr><td><code id="mesh3d_mesh_+3A_center">center</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to center the mesh.</p>
</td></tr>
<tr><td><code id="mesh3d_mesh_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Position of the mesh.</p>
</td></tr>
<tr><td><code id="mesh3d_mesh_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. Scale of the mesh. Can also be a single numeric value scaling all axes uniformly.</p>
</td></tr>
<tr><td><code id="mesh3d_mesh_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Angle to rotate the mesh.</p>
</td></tr>
<tr><td><code id="mesh3d_mesh_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Point around which to rotate the mesh.</p>
</td></tr>
<tr><td><code id="mesh3d_mesh_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. Order to rotate the axes.</p>
</td></tr>
<tr><td><code id="mesh3d_mesh_+3A_materialspath">materialspath</code></td>
<td>
<p>Default <code>NULL</code>. Path to the MTL file, if different from the OBJ file.</p>
</td></tr>
<tr><td><code id="mesh3d_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>NULL</code>, read from the MTL file. If not <code>NULL</code>, this accepts the output
from the <code>material_list()</code> function to specify the material.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
  # Read in a mesh3d object and rasterize it
  library(Rvcg)
  data(humface)
  
  mesh3d_mesh(humface,position = c(0,-0.3,0),scale = 1/70,
              material=material_list(diffuse="dodgerblue4", type="phong", shininess=20,
              ambient = "dodgerblue4", ambient_intensity=0.3)) |&gt;
    rasterize_scene(lookat = c(0,0.5,1), light_info = directional_light(c(1,0.5,1)))
 }
 
 if(run_documentation()) {
  # Subdivide the mesh for a smoother appearance
  mesh3d_mesh(humface,position = c(0,-0.3,0),scale = 1/70,
              material=material_list(diffuse="dodgerblue4", type="phong", shininess=20,
              ambient = "dodgerblue4", ambient_intensity=0.3)) |&gt;
    subdivide_mesh() |&gt; 
    rasterize_scene(lookat = c(0,0.5,1), light_info = directional_light(c(1,0.5,1)))
 }
</code></pre>

<hr>
<h2 id='obj_mesh'>OBJ Mesh 3D Model</h2><span id='topic+obj_mesh'></span>

<h3>Description</h3>

<p>OBJ Mesh 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj_mesh(
  filename,
  position = c(0, 0, 0),
  scale = c(1, 1, 1),
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  materialspath = NULL,
  center = FALSE,
  material = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obj_mesh_+3A_filename">filename</code></td>
<td>
<p>OBJ filename.</p>
</td></tr>
<tr><td><code id="obj_mesh_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Position of the mesh.</p>
</td></tr>
<tr><td><code id="obj_mesh_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. Scale of the mesh. Can also be a single numeric value scaling all axes uniformly.</p>
</td></tr>
<tr><td><code id="obj_mesh_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Angle to rotate the mesh.</p>
</td></tr>
<tr><td><code id="obj_mesh_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Point around which to rotate the mesh.</p>
</td></tr>
<tr><td><code id="obj_mesh_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. Order to rotate the axes.</p>
</td></tr>
<tr><td><code id="obj_mesh_+3A_materialspath">materialspath</code></td>
<td>
<p>Default <code>NULL</code>. Path to the MTL file, if different from the OBJ file.</p>
</td></tr>
<tr><td><code id="obj_mesh_+3A_center">center</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to center the mesh.</p>
</td></tr>
<tr><td><code id="obj_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>NULL</code>, read from the MTL file. If not <code>NULL</code>, this accepts the output
from the <code>material_list()</code> function to specify the material.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Read in the provided 3D R mesh
generate_cornell_mesh(ceiling=FALSE) |&gt; 
  add_shape(obj_mesh(r_obj(),position=c(555/2,555/2,555/2),scale=400,angle=c(0,180,0))) |&gt; 
  rasterize_scene(light_info = directional_light(direction=c(0.2,0.5,-1)))
}
</code></pre>

<hr>
<h2 id='pillar_shaft.ray_shape'>Pillar shaft for ray_shape</h2><span id='topic+pillar_shaft.ray_shape'></span>

<h3>Description</h3>

<p>Pillar shaft for ray_shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pillar_shaft.ray_shape(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pillar_shaft.ray_shape_+3A_x">x</code></td>
<td>
<p>A ray_shape object.</p>
</td></tr>
<tr><td><code id="pillar_shaft.ray_shape_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pillar shaft object.
</p>

<hr>
<h2 id='pillar_shaft.ray_shape_list'>Pillar shaft for ray_shape_list</h2><span id='topic+pillar_shaft.ray_shape_list'></span>

<h3>Description</h3>

<p>Pillar shaft for ray_shape_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pillar_shaft.ray_shape_list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pillar_shaft.ray_shape_list_+3A_x">x</code></td>
<td>
<p>A ray_shape_list object.</p>
</td></tr>
<tr><td><code id="pillar_shaft.ray_shape_list_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pillar shaft object.
</p>

<hr>
<h2 id='ply_mesh'>PLY Mesh 3D Model</h2><span id='topic+ply_mesh'></span>

<h3>Description</h3>

<p>PLY Mesh 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ply_mesh(
  filename,
  center = FALSE,
  position = c(0, 0, 0),
  scale = c(1, 1, 1),
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ply_mesh_+3A_filename">filename</code></td>
<td>
<p>PLY filename.</p>
</td></tr>
<tr><td><code id="ply_mesh_+3A_center">center</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to center the mesh.</p>
</td></tr>
<tr><td><code id="ply_mesh_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Position of the mesh.</p>
</td></tr>
<tr><td><code id="ply_mesh_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. Scale of the mesh. Can also be a single numeric value scaling all axes uniformly.</p>
</td></tr>
<tr><td><code id="ply_mesh_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Angle to rotate the mesh.</p>
</td></tr>
<tr><td><code id="ply_mesh_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Point around which to rotate the mesh.</p>
</td></tr>
<tr><td><code id="ply_mesh_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. Order to rotate the axes.</p>
</td></tr>
<tr><td><code id="ply_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See the documentation for `obj_mesh()`--no example PLY models are included with this package,
#but the process of loading a model is the same (but no materials are included in PLY files).
</code></pre>

<hr>
<h2 id='point_light'>Point light</h2><span id='topic+point_light'></span>

<h3>Description</h3>

<p>The falloff of the point light intensity is given by the following equation (referenc:
</p>
<p>Intensity = intensity / (constant + falloff * distance + falloff_quad * (distance * distance));
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point_light(
  position = c(0, 0, 0),
  color = "white",
  intensity = 1,
  constant = 1,
  falloff = 1,
  falloff_quad = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="point_light_+3A_position">position</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="point_light_+3A_color">color</code></td>
<td>
<p>Default <code>400</code>. Width of the rendered image.</p>
</td></tr>
<tr><td><code id="point_light_+3A_intensity">intensity</code></td>
<td>
<p>Default <code>1</code>. Intensity of the point light.</p>
</td></tr>
<tr><td><code id="point_light_+3A_constant">constant</code></td>
<td>
<p>Default <code>1</code>. Constant term. See description for details.</p>
</td></tr>
<tr><td><code id="point_light_+3A_falloff">falloff</code></td>
<td>
<p>Default <code>1</code>. Linear falloff term. See description for details.</p>
</td></tr>
<tr><td><code id="point_light_+3A_falloff_quad">falloff_quad</code></td>
<td>
<p>Default <code>1</code>. Quadratic falloff term. See description for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the light information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Add point lights and vary the intensity
lights_int = point_light(position=c(100,100,400), color="white", intensity=0.125,
                      falloff_quad = 0.0, constant = 0.0002, falloff = 0.005) |&gt;
 add_light(point_light(position=c(100,455,400), color="white", intensity=0.25,
                       falloff_quad = 0.0, constant = 0.0002, falloff = 0.005)) |&gt;
 add_light(point_light(position=c(455,100,400), color="white", intensity=0.5,
                       falloff_quad = 0.0, constant = 0.0002, falloff = 0.005)) |&gt;
 add_light(point_light(position=c(455,455,400), color="white", intensity=1,
                       falloff_quad = 0.0, constant = 0.0002, falloff = 0.005))
                       
generate_cornell_mesh(light=FALSE) |&gt;
 rasterize_scene(light_info = lights_int)
 
#Add point lights and vary the color
lights_c = point_light(position=c(100,100,500), color="red", 
                      falloff_quad = 0.0, constant = 0.0002, falloff = 0.005) |&gt;
 add_light(point_light(position=c(100,455,500), color="blue",
                       falloff_quad = 0.0, constant = 0.0002, falloff = 0.005)) |&gt;
 add_light(point_light(position=c(455,100,500), color="purple", 
                       falloff_quad = 0.0, constant = 0.0002, falloff = 0.005)) |&gt;
 add_light(point_light(position=c(455,455,500), color="yellow", 
                       falloff_quad = 0.0, constant = 0.0002, falloff = 0.005))
                       
generate_cornell_mesh(light=FALSE) |&gt;
 rasterize_scene(light_info = lights_c)
 
#Add point lights and vary the falloff term
lights_fo = point_light(position=c(100,100,500), color="white", 
                      falloff_quad = 0.0, constant = 0.0002, falloff = 0.005) |&gt;
 add_light(point_light(position=c(100,455,500), color="white",
                       falloff_quad = 0.0, constant = 0.0002, falloff = 0.01)) |&gt;
 add_light(point_light(position=c(455,100,500), color="white", 
                       falloff_quad = 0.0, constant = 0.0002, falloff = 0.02)) |&gt;
 add_light(point_light(position=c(455,455,500), color="white", 
                       falloff_quad = 0.0, constant = 0.0002, falloff = 0.04))
                       
generate_cornell_mesh(light=FALSE) |&gt;
 rasterize_scene(light_info = lights_fo)
 
#Add point lights and vary the quadradic falloff term
lights_quad = point_light(position=c(100,100,500), color="white", 
                      falloff_quad = 0.0001, constant = 0.0002, falloff = 0.005) |&gt;
 add_light(point_light(position=c(100,455,500), color="white",
                       falloff_quad = 0.0002, constant = 0.0002, falloff = 0.005)) |&gt;
 add_light(point_light(position=c(455,100,500), color="white", 
                       falloff_quad = 0.0004, constant = 0.0002, falloff = 0.005)) |&gt;
 add_light(point_light(position=c(455,455,500), color="white", 
                       falloff_quad = 0.0008, constant = 0.0002, falloff = 0.005))
                       
generate_cornell_mesh(light=FALSE) |&gt;
 rasterize_scene(light_info = lights_quad)
}
</code></pre>

<hr>
<h2 id='print_time'>Print time</h2><span id='topic+print_time'></span>

<h3>Description</h3>

<p>Print time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_time(verbose = FALSE, message_text = "")
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='print.ray_shape'>Print method for ray_shape</h2><span id='topic+print.ray_shape'></span>

<h3>Description</h3>

<p>Print method for ray_shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ray_shape'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ray_shape_+3A_x">x</code></td>
<td>
<p>A ray_shape object.</p>
</td></tr>
<tr><td><code id="print.ray_shape_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
</table>

<hr>
<h2 id='print.ray_vertex_data'>Print method for ray_vertex_data</h2><span id='topic+print.ray_vertex_data'></span>

<h3>Description</h3>

<p>Print method for ray_vertex_data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ray_vertex_data'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ray_vertex_data_+3A_x">x</code></td>
<td>
<p>A ray_vertex_data object.</p>
</td></tr>
<tr><td><code id="print.ray_vertex_data_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
</table>

<hr>
<h2 id='r_obj'>R 3D Model</h2><span id='topic+r_obj'></span>

<h3>Description</h3>

<p>3D obj model of R logo (created from the R SVG logo with the <code>raybevel</code> package),
to be used with <code>obj_model()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_obj(simple_r = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_obj_+3A_simple_r">simple_r</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, this will return a 3D R (instead of the R logo).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>File location of the 3d_r_logo.obj file (saved with a .txt extension)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load and render the included example R object file.
if(run_documentation()) {
obj_mesh(r_obj()) |&gt; 
  rasterize_scene(lookfrom = c(0, 1, 10),
                  fov=7,light_info = directional_light(c(1,1,1)))
}
</code></pre>

<hr>
<h2 id='rasterize_lines'>Rasterize Lines</h2><span id='topic+rasterize_lines'></span>

<h3>Description</h3>

<p>Render a 3D scene made out of lines using a software rasterizer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterize_lines(
  line_info = NULL,
  filename = NA,
  width = 800,
  height = 800,
  alpha_line = 1,
  parallel = TRUE,
  fov = 20,
  lookfrom = c(0, 0, 10),
  lookat = NULL,
  camera_up = c(0, 1, 0),
  color = "red",
  background = "black",
  debug = "none",
  near_plane = 0.1,
  far_plane = 100,
  block_size = 4,
  ortho_dimensions = c(1, 1),
  bloom = FALSE,
  antialias_lines = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rasterize_lines_+3A_line_info">line_info</code></td>
<td>
<p>The mesh object.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. Filename to save the image. If <code>NULL</code>, the image will be plotted.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_width">width</code></td>
<td>
<p>Default <code>400</code>. Width of the rendered image.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_height">height</code></td>
<td>
<p>Default <code>400</code>. Width of the rendered image.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_alpha_line">alpha_line</code></td>
<td>
<p>Default <code>1</code>. Line transparency.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_parallel">parallel</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to use parallel processing.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_fov">fov</code></td>
<td>
<p>Default <code>20</code>. Width of the rendered image.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_lookfrom">lookfrom</code></td>
<td>
<p>Default <code>c(0,0,10)</code>. Camera location.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_lookat">lookat</code></td>
<td>
<p>Default <code>NULL</code>. Camera focal position, defaults to the center of the model.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_camera_up">camera_up</code></td>
<td>
<p>Default <code>c(0,1,0)</code>. Camera up vector.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_color">color</code></td>
<td>
<p>Default <code>darkred</code>. Color of model if no material file present (or for faces using the default material).</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_background">background</code></td>
<td>
<p>Default <code>white</code>. Background color.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_debug">debug</code></td>
<td>
<p>Default <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_near_plane">near_plane</code></td>
<td>
<p>Default <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_far_plane">far_plane</code></td>
<td>
<p>Default <code>100</code>.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_block_size">block_size</code></td>
<td>
<p>Default <code>4</code>.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_ortho_dimensions">ortho_dimensions</code></td>
<td>
<p>Default <code>c(1,1)</code>. Width and height of the orthographic camera. Will only be used if <code>fov = 0</code>.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_bloom">bloom</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to apply bloom to the image. If <code>TRUE</code>,
this performs a convolution of the HDR image of the scene with a sharp, long-tailed
exponential kernel, which does not visibly affect dimly pixels, but does result in emitters light
slightly bleeding into adjacent pixels.</p>
</td></tr>
<tr><td><code id="rasterize_lines_+3A_antialias_lines">antialias_lines</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to anti-alias lines in the scene.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rasterized image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a cube out of lines
cube_outline = generate_line(start = c(-1, -1, -1), end = c(-1, -1, 1)) |&gt;
  add_lines(generate_line(start = c(-1, -1, -1), end = c(-1, 1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, -1), end = c(1, -1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, 1), end = c(-1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, 1), end = c(1, -1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, 1), end = c(-1, 1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, 1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(1, 1, -1), end = c(1, -1, -1))) |&gt;
  add_lines(generate_line(start = c(1, 1, -1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(1, -1, -1), end = c(1, -1, 1))) |&gt;
  add_lines(generate_line(start = c(1, -1, 1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, -1), end = c(1, 1, -1)))
rasterize_lines(cube_outline,fov=90,lookfrom=c(0,0,3))
}
if(run_documentation()) {
#Scale the cube uniformly
scaled_cube = color_lines(scale_lines(cube_outline,scale=0.5),color="red")
rasterize_lines(add_lines(cube_outline,scaled_cube),fov=90,lookfrom=c(0,0,3))
}
if(run_documentation()) {
#Scale the cube non-uniformly
scaled_cube = color_lines(scale_lines(cube_outline,scale=c(0.8,2,0.4)),color="red")
rasterize_lines(add_lines(cube_outline,scaled_cube),fov=60,lookfrom=c(3,3,3))
}
</code></pre>

<hr>
<h2 id='rasterize_scene'>Rasterize Scene</h2><span id='topic+rasterize_scene'></span>

<h3>Description</h3>

<p>Render a 3D scene with meshes, lights, and lines using a software rasterizer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterize_scene(
  scene,
  filename = NA,
  width = 800,
  height = 800,
  line_info = NULL,
  alpha_line = 1,
  parallel = TRUE,
  plot = is.na(filename),
  fov = 20,
  lookfrom = c(0, 0, 10),
  lookat = NULL,
  camera_up = c(0, 1, 0),
  fsaa = 2,
  light_info = directional_light(),
  color = "red",
  type = "diffuse",
  background = "black",
  tangent_space_normals = TRUE,
  shadow_map = TRUE,
  shadow_map_bias = 0.003,
  shadow_map_intensity = 0,
  shadow_map_dims = NULL,
  ssao = FALSE,
  ssao_intensity = 10,
  ssao_radius = 0.1,
  tonemap = "none",
  debug = "none",
  near_plane = 0.1,
  far_plane = 100,
  shader = "default",
  block_size = 4,
  shape = NULL,
  line_offset = 1e-05,
  ortho_dimensions = c(1, 1),
  bloom = FALSE,
  antialias_lines = TRUE,
  environment_map = "",
  background_sharpness = 1,
  verbose = FALSE,
  vertex_transform = NULL,
  validate_scene = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rasterize_scene_+3A_scene">scene</code></td>
<td>
<p>The scene object.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. Filename to save the image. If <code>NULL</code>, the image will be plotted.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_width">width</code></td>
<td>
<p>Default <code>400</code>. Width of the rendered image.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_height">height</code></td>
<td>
<p>Default <code>400</code>. Width of the rendered image.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_line_info">line_info</code></td>
<td>
<p>Default <code>NULL</code>. Matrix of line segments to add to the scene. Number of rows must be a multiple of 2.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_alpha_line">alpha_line</code></td>
<td>
<p>Default <code>1</code>. Line transparency.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_parallel">parallel</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to use parallel processing.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_plot">plot</code></td>
<td>
<p>Default <code>is.na(filename)</code>. Whether to plot the image.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_fov">fov</code></td>
<td>
<p>Default <code>20</code>. Width of the rendered image.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_lookfrom">lookfrom</code></td>
<td>
<p>Default <code>c(0,0,10)</code>. Camera location.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_lookat">lookat</code></td>
<td>
<p>Default <code>NULL</code>. Camera focal position, defaults to the center of the model.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_camera_up">camera_up</code></td>
<td>
<p>Default <code>c(0,1,0)</code>. Camera up vector.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_fsaa">fsaa</code></td>
<td>
<p>Default <code>2</code>. Full screen anti-aliasing multiplier. Must be positive integer, higher numbers
will improve anti-aliasing quality but will vastly increase memory usage.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_light_info">light_info</code></td>
<td>
<p>Default <code>directional_light()</code>. Description of scene lights, generated with the <code>point_light()</code> and
<code>directional_light()</code> functions.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_color">color</code></td>
<td>
<p>Default <code>darkred</code>. Color of model if no material file present (or for faces using the default material).</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_type">type</code></td>
<td>
<p>Default <code>diffuse</code>. Shader type. Other options: <code>vertex</code> (Gouraud shading), <code>phong</code>, and <code>color</code> (no lighting).</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_background">background</code></td>
<td>
<p>Default <code>white</code>. Background color.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_tangent_space_normals">tangent_space_normals</code></td>
<td>
<p>Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_shadow_map">shadow_map</code></td>
<td>
<p>Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_shadow_map_bias">shadow_map_bias</code></td>
<td>
<p>Default <code>0.005</code>.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_shadow_map_intensity">shadow_map_intensity</code></td>
<td>
<p>Default <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_shadow_map_dims">shadow_map_dims</code></td>
<td>
<p>Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_ssao">ssao</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to add screen-space ambient occlusion (SSAO) to the render.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_ssao_intensity">ssao_intensity</code></td>
<td>
<p>Default <code>10</code>. Intensity of the shadow map.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_ssao_radius">ssao_radius</code></td>
<td>
<p>Default <code>0.1</code>. Radius to use when calculating the SSAO term.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_tonemap">tonemap</code></td>
<td>
<p>Default <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_debug">debug</code></td>
<td>
<p>Default <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_near_plane">near_plane</code></td>
<td>
<p>Default <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_far_plane">far_plane</code></td>
<td>
<p>Default <code>100</code>.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_shader">shader</code></td>
<td>
<p>Default <code>"default"</code>.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_block_size">block_size</code></td>
<td>
<p>Default <code>4</code>.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_shape">shape</code></td>
<td>
<p>Default <code>NULL</code>. The shape to render in the OBJ mesh.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_line_offset">line_offset</code></td>
<td>
<p>Default <code>0.0001</code>. Amount to offset lines towards camera to prevent z-fighting.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_ortho_dimensions">ortho_dimensions</code></td>
<td>
<p>Default <code>c(1,1)</code>. Width and height of the orthographic camera. Will only be used if <code>fov = 0</code>.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_bloom">bloom</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to apply bloom to the image. If <code>TRUE</code>,
this performs a convolution of the HDR image of the scene with a sharp, long-tailed
exponential kernel, which does not visibly affect dimly pixels, but does result in emitters light
slightly bleeding into adjacent pixels.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_antialias_lines">antialias_lines</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to anti-alias lines in the scene.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_environment_map">environment_map</code></td>
<td>
<p>Default <code>""</code>. Image file to use as a texture for all reflective and refractive
materials in the scene, along with the background.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_background_sharpness">background_sharpness</code></td>
<td>
<p>Default <code>1.0</code>. A number greater than zero but less than one indicating the sharpness
of the background image.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_verbose">verbose</code></td>
<td>
<p>Default <code>FALSE</code>. Prints out timing information.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_vertex_transform">vertex_transform</code></td>
<td>
<p>Default <code>NULL</code>. A function that transforms the vertex locations, based on their location.
Function should takes a length-3 numeric vector and returns another length-3 numeric vector as the output.</p>
</td></tr>
<tr><td><code id="rasterize_scene_+3A_validate_scene">validate_scene</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to validate the scene input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rasterized image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Let's load the cube OBJ file included with the package

rasterize_scene(cube_mesh(),lookfrom=c(2,4,10), 
              light_info = directional_light(direction=c(0.5,1,0.7)))
}
if(run_documentation()) {
#Flatten the cube, translate downwards, and set to grey
base_model = cube_mesh() |&gt;
 scale_mesh(scale=c(5,0.2,5)) |&gt;
 translate_mesh(c(0,-0.1,0)) |&gt;
 set_material(diffuse="grey80") 
 
rasterize_scene(base_model, lookfrom=c(2,4,10), 
              light_info = directional_light(direction=c(0.5,1,0.7)))
}
if(run_documentation()) {           
#load the R OBJ file, scale it down, color it blue, and add it to the grey base
r_model = obj_mesh(r_obj(simple_r = TRUE)) |&gt;
 scale_mesh(scale=0.5) |&gt;
 set_material(diffuse="dodgerblue") |&gt;
 add_shape(base_model)
 
rasterize_scene(r_model, lookfrom=c(2,4,10), 
              light_info = directional_light(direction=c(0.5,1,0.7)))
}
if(run_documentation()) {
#Zoom in and reduce the shadow mapping intensity
rasterize_scene(r_model, lookfrom=c(2,4,10), fov=10,shadow_map = TRUE, shadow_map_intensity=0.3,
              light_info = directional_light(direction=c(0.5,1,0.7)))
}
if(run_documentation()) {
#Include the resolution (4x) of the shadow map for less pixellation around the edges
#Also decrease the shadow_map_bias slightly to remove the "peter panning" floating shadow effect
rasterize_scene(r_model, lookfrom=c(2,4,10), fov=10,
              shadow_map_dims=4, 
              light_info = directional_light(direction=c(0.5,1,0.7)))
}
if(run_documentation()) {
#Add some more directional lights and change their color
lights = directional_light(c(0.7,1.1,-0.9),color = "orange",intensity = 1) |&gt;
           add_light(directional_light(c(0.7,1,1),color = "dodgerblue",intensity = 1)) |&gt;
           add_light(directional_light(c(2,4,10),color = "white",intensity = 0.5))
rasterize_scene(r_model, lookfrom=c(2,4,10), fov=10,
              light_info = lights)
}
if(run_documentation()) {
#Add some point lights
lights_p = lights |&gt;
 add_light(point_light(position=c(-1,1,0),color="red", intensity=2)) |&gt;
 add_light(point_light(position=c(1,1,0),color="purple", intensity=2)) 
rasterize_scene(r_model, lookfrom=c(2,4,10), fov=10,
              light_info = lights_p)
}
if(run_documentation()) {
#change the camera position
rasterize_scene(r_model, lookfrom=c(-2,2,-10), fov=10,
              light_info = lights_p)
}
if(run_documentation()) {
              
#Add a spiral of lines around the model by generating a matrix of line segments
t = seq(0,8*pi,length.out=361)
line_mat = matrix(nrow=0,ncol=9)

for(i in 1:360) {
  line_mat = add_lines(line_mat,
                      generate_line(start = c(0.5*sin(t[i]), t[i]/(8*pi), 0.5*cos(t[i])),
                                    end  = c(0.5*sin(t[i+1]), t[i+1]/(8*pi), 0.5*cos(t[i+1]))))
}

rasterize_scene(r_model, lookfrom=c(2,4,10), fov=10, line_info = line_mat,
              light_info = lights)
}
</code></pre>

<hr>
<h2 id='ray_mesh'>Constructor for ray_mesh</h2><span id='topic+ray_mesh'></span>

<h3>Description</h3>

<p>Constructor for ray_mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_mesh(...)
</code></pre>


<h3>Value</h3>

<p>ray
</p>

<hr>
<h2 id='ray_shape'>Define the ray_shape class</h2><span id='topic+ray_shape'></span>

<h3>Description</h3>

<p>Define the ray_shape class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_shape(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ray_shape_+3A_...">...</code></td>
<td>
<p>Objects to be included in the ray_shape.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new ray_shape object.
</p>

<hr>
<h2 id='ray_shape_list'>Define the ray_shape_list class</h2><span id='topic+ray_shape_list'></span>

<h3>Description</h3>

<p>Define the ray_shape_list class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_shape_list(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ray_shape_list_+3A_...">...</code></td>
<td>
<p>Objects to be included in the ray_shape_list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new ray_shape_list object.
</p>

<hr>
<h2 id='ray_vertex_data'>Define the ray_vertex_data class</h2><span id='topic+ray_vertex_data'></span>

<h3>Description</h3>

<p>Define the ray_vertex_data class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_vertex_data(data = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ray_vertex_data_+3A_data">data</code></td>
<td>
<p>A matrix with 2 or 3 columns representing vertex data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new ray_vertex_data object.
</p>

<hr>
<h2 id='read_obj'>Load an OBJ file</h2><span id='topic+read_obj'></span>

<h3>Description</h3>

<p>Loads an OBJ file and return a <code>ray_mesh</code> list structure. No processing is done on
the object other than loading it (unlike <code>obj_model()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_obj(filename, materialspath = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_obj_+3A_filename">filename</code></td>
<td>
<p>Filename of the OBJ file.</p>
</td></tr>
<tr><td><code id="read_obj_+3A_materialspath">materialspath</code></td>
<td>
<p>Directory where the MTL file is located. Defaults to the directory of <code>filename</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ray_mesh</code> list object
#Load an arrow OBJ
sphere = read_obj(system.file(&quot;extdata&quot;, &quot;arrow.txt&quot;, package=&quot;rayvertex&quot;))
</p>

<hr>
<h2 id='read_ply'>Load an PLY file</h2><span id='topic+read_ply'></span>

<h3>Description</h3>

<p>Load an PLY file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ply(filename)
</code></pre>


<h3>Value</h3>

<p>List
</p>

<hr>
<h2 id='remove_duplicate_materials'>Remove Duplicates</h2><span id='topic+remove_duplicate_materials'></span>

<h3>Description</h3>

<p>Remove Duplicates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_duplicate_materials(scene)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_duplicate_materials_+3A_scene">scene</code></td>
<td>
<p>The scene</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scene with shape added.
</p>

<hr>
<h2 id='rescale'>Rescale</h2><span id='topic+rescale'></span>

<h3>Description</h3>

<p>Rescale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale(vals, to = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescale_+3A_vals">vals</code></td>
<td>
<p>Values</p>
</td></tr>
<tr><td><code id="rescale_+3A_to">to</code></td>
<td>
<p>to vales</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Color vector
</p>

<hr>
<h2 id='rotate_lines'>Rotate Lines</h2><span id='topic+rotate_lines'></span>

<h3>Description</h3>

<p>Rotate Lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_lines(
  lines,
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate_lines_+3A_lines">lines</code></td>
<td>
<p>The existing line scene.</p>
</td></tr>
<tr><td><code id="rotate_lines_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The rotation amount for the x/y/z axes, in degrees.</p>
</td></tr>
<tr><td><code id="rotate_lines_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The pivot point of the rotation.</p>
</td></tr>
<tr><td><code id="rotate_lines_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. The order in which to perform the rotations.#'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rotated lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a cube out of lines
cube_outline = generate_line(start = c(-1, -1, -1), end = c(-1, -1, 1)) |&gt;
  add_lines(generate_line(start = c(-1, -1, -1), end = c(-1, 1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, -1), end = c(1, -1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, 1), end = c(-1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, 1), end = c(1, -1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, 1), end = c(-1, 1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, 1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(1, 1, -1), end = c(1, -1, -1))) |&gt;
  add_lines(generate_line(start = c(1, 1, -1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(1, -1, -1), end = c(1, -1, 1))) |&gt;
  add_lines(generate_line(start = c(1, -1, 1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, -1), end = c(1, 1, -1)))
rasterize_lines(cube_outline,lookfrom=c(0,6,10))
}
if(run_documentation()) {
#Rotate the cube 30 degrees around the y-axis
rotated_cube = color_lines(rotate_lines(cube_outline,angle=c(0,30,0)),color="red")
rasterize_lines(add_lines(cube_outline,rotated_cube),lookfrom=c(0,6,10))
}
if(run_documentation()) {
#Rotate the cube 30 degrees around each axis, in this order: x,y,z
rotated_cube = color_lines(rotate_lines(cube_outline,angle=c(30,30,30)),color="red")
rasterize_lines(add_lines(cube_outline,rotated_cube),lookfrom=c(0,6,10))
}
if(run_documentation()) {
#Rotate the cube 30 degrees around each axis, in this order: z,y,x
rotated_cube = color_lines(rotate_lines(cube_outline,angle=c(30,30,30), 
                           order_rotation = c(3,2,1)),color="red")
rasterize_lines(add_lines(cube_outline,rotated_cube),lookfrom=c(0,6,10))
}
</code></pre>

<hr>
<h2 id='rotate_mesh'>Rotate Mesh</h2><span id='topic+rotate_mesh'></span>

<h3>Description</h3>

<p>Rotate Mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_mesh(
  mesh,
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate_mesh_+3A_mesh">mesh</code></td>
<td>
<p>The mesh.</p>
</td></tr>
<tr><td><code id="rotate_mesh_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The rotation amount for the x/y/z axes, in degrees.</p>
</td></tr>
<tr><td><code id="rotate_mesh_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The pivot point of the rotation.</p>
</td></tr>
<tr><td><code id="rotate_mesh_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. The order in which to perform the rotations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rotated Mesh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Rotate a mesh in the Cornell box
robj = obj_mesh(r_obj(), scale=150,angle=c(0,180,0))

generate_cornell_mesh() |&gt;
add_shape(rotate_mesh(translate_mesh(robj,c(400,100,155)),c(0,30,0), 
                      pivot_point=c(400,100,155))) |&gt;
add_shape(rotate_mesh(translate_mesh(robj,c(555/2,200,555/2)),c(-30,60,30), 
                      pivot_point=c(555/2,200,555/2))) |&gt;
add_shape(rotate_mesh(translate_mesh(robj,c(155,300,400)),c(-30,60,30), 
                      pivot_point=c(155,300,400), order_rotation=c(3,2,1))) |&gt;
rasterize_scene(light_info=directional_light(direction=c(0.1,0.6,-1)))
}
</code></pre>

<hr>
<h2 id='run_documentation'>Run Documentation</h2><span id='topic+run_documentation'></span>

<h3>Description</h3>

<p>This function determines if the examples are being run in pkgdown. It is not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_documentation()
</code></pre>


<h3>Value</h3>

<p>Boolean value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See if the documentation should be run.
run_documentation()
</code></pre>

<hr>
<h2 id='save_png'>Save PNG</h2><span id='topic+save_png'></span>

<h3>Description</h3>

<p>Writes the hillshaded map to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_png(hillshade, filename, rotate = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_png_+3A_hillshade">hillshade</code></td>
<td>
<p>Array (or matrix) of hillshade to be written.</p>
</td></tr>
<tr><td><code id="save_png_+3A_filename">filename</code></td>
<td>
<p>String with the filename. If <code>.png</code> is not at the end of the string, it will be appended automatically.</p>
</td></tr>
<tr><td><code id="save_png_+3A_rotate">rotate</code></td>
<td>
<p>Default 0. Rotates the output. Possible values: 0, 90, 180, 270.</p>
</td></tr>
</table>

<hr>
<h2 id='scale_lines'>Scale Lines</h2><span id='topic+scale_lines'></span>

<h3>Description</h3>

<p>Scale Lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_lines(lines, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_lines_+3A_lines">lines</code></td>
<td>
<p>The line scene.</p>
</td></tr>
<tr><td><code id="scale_lines_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. The scale amount, per axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scaled line matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a cube out of lines
cube_outline = generate_line(start = c(-1, -1, -1), end = c(-1, -1, 1)) |&gt;
  add_lines(generate_line(start = c(-1, -1, -1), end = c(-1, 1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, -1), end = c(1, -1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, 1), end = c(-1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, 1), end = c(1, -1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, 1), end = c(-1, 1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, 1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(1, 1, -1), end = c(1, -1, -1))) |&gt;
  add_lines(generate_line(start = c(1, 1, -1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(1, -1, -1), end = c(1, -1, 1))) |&gt;
  add_lines(generate_line(start = c(1, -1, 1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, -1), end = c(1, 1, -1)))
rasterize_lines(cube_outline,fov=90,lookfrom=c(0,0,3))
}
if(run_documentation()) {
#Scale the cube uniformly
scaled_cube = color_lines(scale_lines(cube_outline,scale=0.5),color="red")
rasterize_lines(add_lines(cube_outline,scaled_cube),fov=90,lookfrom=c(0,0,3))
}
if(run_documentation()) {
#Scale the cube non-uniformly
scaled_cube = color_lines(scale_lines(cube_outline,scale=c(0.8,2,0.4)),color="red")
rasterize_lines(add_lines(cube_outline,scaled_cube),fov=60,lookfrom=c(3,3,3))
}
</code></pre>

<hr>
<h2 id='scale_mesh'>Scale Mesh</h2><span id='topic+scale_mesh'></span>

<h3>Description</h3>

<p>Scale Mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_mesh(mesh, scale = 1, center = c(0, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_mesh_+3A_mesh">mesh</code></td>
<td>
<p>The mesh.</p>
</td></tr>
<tr><td><code id="scale_mesh_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. The scale amount, per axis.</p>
</td></tr>
<tr><td><code id="scale_mesh_+3A_center">center</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The center of the scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scaled mesh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Scale a mesh in the Cornell box
robj = obj_mesh(r_obj(), scale=150,angle=c(0,180,0))

generate_cornell_mesh() |&gt;
add_shape(scale_mesh(translate_mesh(robj,c(400,100,155)),0.5, center=c(400,100,155))) |&gt;
add_shape(scale_mesh(translate_mesh(robj,c(555/2,200,555/2)),1.5, center=c(555/2,200,555/2))) |&gt;
add_shape(scale_mesh(translate_mesh(robj,c(55,300,400)),c(0.5,2,0.5), center=c(155,300,400))) |&gt;
rasterize_scene(light_info=directional_light(direction=c(0.1,0.6,-1)))
}
</code></pre>

<hr>
<h2 id='scale_unit_mesh'>Scale Mesh to Unit Bounding Box</h2><span id='topic+scale_unit_mesh'></span>

<h3>Description</h3>

<p>Scale Mesh to Unit Bounding Box
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_unit_mesh(mesh, center_mesh = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_unit_mesh_+3A_mesh">mesh</code></td>
<td>
<p>The mesh.</p>
</td></tr>
<tr><td><code id="scale_unit_mesh_+3A_center_mesh">center_mesh</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to center the mesh at the origin after scaling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scaled mesh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Scale the Cornell box (and contents) down to the unit box.
robj = obj_mesh(r_obj(), scale=150,angle=c(0,180,0))

generate_cornell_mesh() |&gt;
add_shape(scale_mesh(translate_mesh(robj,c(400,100,155)),0.5, center=c(400,100,155))) |&gt;
add_shape(scale_mesh(translate_mesh(robj,c(555/2,200,555/2)),1.5, center=c(555/2,200,555/2))) |&gt;
add_shape(scale_mesh(translate_mesh(robj,c(55,300,400)),c(0.5,2,0.5), center=c(155,300,400))) |&gt;
scale_unit_mesh(center_mesh = TRUE) |&gt; 
rasterize_scene(light_info=directional_light(direction=c(0.1,0.6,-1)), 
                lookfrom = c(0,0,-2), lookat=c(0,0,0))
}
</code></pre>

<hr>
<h2 id='scene_from_list'>Scene From List</h2><span id='topic+scene_from_list'></span>

<h3>Description</h3>

<p>Fast generation of rayvertex scenes from a list of objects (much faster than calling
<code>add_shape()</code> on each object individually to build the scene). This returns a <code>ray_scene</code> object
that cdoes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scene_from_list(scene_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scene_from_list_+3A_scene_list">scene_list</code></td>
<td>
<p>List containing rayvertex mesh objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ray_scene</code> containing mesh info.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
 #Build a scene out of cubes including 87 * 61 = 5307 objects
 scene = list()
 volcol = rainbow(103)
 counter = 1
 for(i in 1:nrow(volcano)) {
   for(j in 1:ncol(volcano)) {
     scene[[counter]] = cube_mesh(position = c(i,(volcano[i,j]-94),j), 
                                  material = material_list(diffuse = volcol[volcano[i,j]-92],
                                                           ambient = volcol[volcano[i,j]-92],
                                                           ambient_intensity = 0.2))
     counter = counter + 1
   }
 }
 #Quickly generate the 
 new_scene = scene_from_list(scene)
 new_scene |&gt; 
   rotate_mesh(c(0,10,0), pivot_point = c(44,0,31)) |&gt; 
   add_shape(xz_rect_mesh(position=c(44,0,31),scale=500,
                          material = material_list(diffuse="lightblue",
                                                   ambient = "lightblue",
                                                   ambient_intensity = 0.2))) |&gt; 
   rasterize_scene(lookfrom=c(500,500,500), lookat = c(44.00, 40.50, 31.00),
                   width=800,height=800, fov=0, ortho_dimensions = c(140,140),
                   light_info = directional_light(c(-0.6,1,0.6)))
}
</code></pre>

<hr>
<h2 id='segment_mesh'>Segment 3D Model</h2><span id='topic+segment_mesh'></span>

<h3>Description</h3>

<p>Segment 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment_mesh(
  start = c(0, -1, 0),
  end = c(0, 1, 0),
  radius = 0.5,
  direction = NA,
  from_center = TRUE,
  square = FALSE,
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segment_mesh_+3A_start">start</code></td>
<td>
<p>Default <code>c(0, 0, 0)</code>. Base of the segment, specifying <code>x</code>, <code>y</code>, <code>z</code>.</p>
</td></tr>
<tr><td><code id="segment_mesh_+3A_end">end</code></td>
<td>
<p>Default <code>c(0, 1, 0)</code>. End of the segment, specifying <code>x</code>, <code>y</code>, <code>z</code>.</p>
</td></tr>
<tr><td><code id="segment_mesh_+3A_radius">radius</code></td>
<td>
<p>Default <code>0.5</code>. Radius of the cylinder.</p>
</td></tr>
<tr><td><code id="segment_mesh_+3A_direction">direction</code></td>
<td>
<p>Default <code>NA</code>. Alternative to <code>start</code> and <code>end</code>, specify the direction (via
a length-3 vector) of the arrow. Arrow will be centered at <code>start</code>, and the length will be
determined by the magnitude of the direction vector.</p>
</td></tr>
<tr><td><code id="segment_mesh_+3A_from_center">from_center</code></td>
<td>
<p>Default <code>TRUE</code>. If orientation specified via <code>direction</code>, setting this argument
to <code>FALSE</code> will make <code>start</code> specify the bottom of the cone, instead of the middle.</p>
</td></tr>
<tr><td><code id="segment_mesh_+3A_square">square</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, will use a square instead of a circle for the cylinder.</p>
</td></tr>
<tr><td><code id="segment_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a segment in the cornell box. 
generate_cornell_mesh() |&gt;
  add_shape(segment_mesh(start = c(100, 100, 100), end = c(455, 455, 455), radius = 50)) |&gt;
  rasterize_scene(light_info = directional_light(c(0,0.5,-1)))
}
if(run_documentation()) {
# Draw a line graph representing a normal distribution, but with metal:
xvals = seq(-3, 3, length.out = 30)
yvals = dnorm(xvals)

scene_list = list()
for(i in 1:(length(xvals) - 1)) {
  scene_list = add_shape(scene_list, 
                         segment_mesh(start = c(555/2 + xvals[i] * 80, yvals[i] * 800, 555/2),
                            end = c(555/2 + xvals[i + 1] * 80, yvals[i + 1] * 800, 555/2),
                            radius = 10,
                            material = material_list(diffuse="purple", type="phong")))
}

generate_cornell_mesh() |&gt; 
  add_shape(scene_list) |&gt;
  rasterize_scene(light_info = directional_light(c(0,0.5,-1)))
}
if(run_documentation()) {
#Draw the outline of a cube:

cube_outline = segment_mesh(start = c(100, 100, 100), end = c(100, 100, 455), radius = 10) |&gt;
  add_shape(segment_mesh(start = c(100, 100, 100), end = c(100, 455, 100), radius = 10)) |&gt;
  add_shape(segment_mesh(start = c(100, 100, 100), end = c(455, 100, 100), radius = 10)) |&gt;
  add_shape(segment_mesh(start = c(100, 100, 455), end = c(100, 455, 455), radius = 10)) |&gt;
  add_shape(segment_mesh(start = c(100, 100, 455), end = c(455, 100, 455), radius = 10)) |&gt;
  add_shape(segment_mesh(start = c(100, 455, 455), end = c(100, 455, 100), radius = 10)) |&gt;
  add_shape(segment_mesh(start = c(100, 455, 455), end = c(455, 455, 455), radius = 10)) |&gt;
  add_shape(segment_mesh(start = c(455, 455, 100), end = c(455, 100, 100), radius = 10)) |&gt;
  add_shape(segment_mesh(start = c(455, 455, 100), end = c(455, 455, 455), radius = 10)) |&gt;
  add_shape(segment_mesh(start = c(455, 100, 100), end = c(455, 100, 455), radius = 10)) |&gt;
  add_shape(segment_mesh(start = c(455, 100, 455), end = c(455, 455, 455), radius = 10)) |&gt;
  add_shape(segment_mesh(start = c(100, 455, 100), end = c(455, 455, 100), radius = 10))

generate_cornell_mesh() |&gt;
  add_shape(set_material(cube_outline,diffuse="dodgerblue",type="phong")) |&gt;
  rasterize_scene(light_info = directional_light(c(0,0.5,-1)))
  }
if(run_documentation()) {
#Shrink and rotate the cube
generate_cornell_mesh() |&gt;
  add_shape(
    scale_mesh(rotate_mesh(set_material(cube_outline,diffuse="dodgerblue",type="phong"),
                angle=c(45,45,45), pivot_point=c(555/2,555/2,555/2)),0.5,
                center=c(555/2,555/2,555/2))) |&gt;
  rasterize_scene(light_info = directional_light(c(0,0.5,-1)))
}
</code></pre>

<hr>
<h2 id='set_material'>Set Material</h2><span id='topic+set_material'></span>

<h3>Description</h3>

<p>Set the material(s) of the mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_material(
  mesh,
  material = NULL,
  id = NULL,
  diffuse = c(0.5, 0.5, 0.5),
  ambient = c(0, 0, 0),
  specular = c(1, 1, 1),
  transmittance = c(0, 0, 0),
  emission = c(0, 0, 0),
  shininess = 50,
  ior = 1,
  dissolve = 1,
  illum = 1,
  texture_location = "",
  normal_texture_location = "",
  bump_texture_location = "",
  specular_texture_location = "",
  ambient_texture_location = "",
  emissive_texture_location = "",
  diffuse_intensity = 1,
  bump_intensity = 1,
  specular_intensity = 1,
  emission_intensity = 1,
  ambient_intensity = 1,
  culling = "back",
  type = "diffuse",
  translucent = TRUE,
  toon_levels = 5,
  toon_outline_width = 0.05,
  toon_outline_color = "black",
  reflection_intensity = 0,
  reflection_sharpness = 0,
  two_sided = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_material_+3A_mesh">mesh</code></td>
<td>
<p>The target mesh.</p>
</td></tr>
<tr><td><code id="set_material_+3A_material">material</code></td>
<td>
<p>Default <code>NULL</code>. You can pass the output of the <code>material_list()</code> function
to specify the material, or use the following individual settings.</p>
</td></tr>
<tr><td><code id="set_material_+3A_id">id</code></td>
<td>
<p>Default <code>1</code>. Either a number specifying the material to change, or a character vector
matching the material name.</p>
</td></tr>
<tr><td><code id="set_material_+3A_diffuse">diffuse</code></td>
<td>
<p>Default <code>c(0.5,0.5,0.5)</code>. The diffuse color.</p>
</td></tr>
<tr><td><code id="set_material_+3A_ambient">ambient</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The ambient color.</p>
</td></tr>
<tr><td><code id="set_material_+3A_specular">specular</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. The specular color.</p>
</td></tr>
<tr><td><code id="set_material_+3A_transmittance">transmittance</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The transmittance.</p>
</td></tr>
<tr><td><code id="set_material_+3A_emission">emission</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The emissive color.</p>
</td></tr>
<tr><td><code id="set_material_+3A_shininess">shininess</code></td>
<td>
<p>Default <code>50.0</code>. The shininess exponent.</p>
</td></tr>
<tr><td><code id="set_material_+3A_ior">ior</code></td>
<td>
<p>Default <code>1.0</code>. The index of refraction. If this is not equal to <code>1.0</code>, the material will be refractive.</p>
</td></tr>
<tr><td><code id="set_material_+3A_dissolve">dissolve</code></td>
<td>
<p>Default <code>1.0</code>. The transparency.</p>
</td></tr>
<tr><td><code id="set_material_+3A_illum">illum</code></td>
<td>
<p>Default <code>1.0</code>. The illumination.</p>
</td></tr>
<tr><td><code id="set_material_+3A_texture_location">texture_location</code></td>
<td>
<p>Default <code>""</code>. The diffuse texture location.</p>
</td></tr>
<tr><td><code id="set_material_+3A_normal_texture_location">normal_texture_location</code></td>
<td>
<p>Default <code>""</code>. The normal texture location.</p>
</td></tr>
<tr><td><code id="set_material_+3A_bump_texture_location">bump_texture_location</code></td>
<td>
<p>Default <code>""</code>. The bump texture location.</p>
</td></tr>
<tr><td><code id="set_material_+3A_specular_texture_location">specular_texture_location</code></td>
<td>
<p>Default <code>""</code>. The specular texture location.</p>
</td></tr>
<tr><td><code id="set_material_+3A_ambient_texture_location">ambient_texture_location</code></td>
<td>
<p>Default <code>""</code>. The ambient texture location.</p>
</td></tr>
<tr><td><code id="set_material_+3A_emissive_texture_location">emissive_texture_location</code></td>
<td>
<p>Default <code>""</code>. The emissive texture location.</p>
</td></tr>
<tr><td><code id="set_material_+3A_diffuse_intensity">diffuse_intensity</code></td>
<td>
<p>Default <code>1</code>. The diffuse intensity.</p>
</td></tr>
<tr><td><code id="set_material_+3A_bump_intensity">bump_intensity</code></td>
<td>
<p>Default <code>1</code>. The bump intensity.</p>
</td></tr>
<tr><td><code id="set_material_+3A_specular_intensity">specular_intensity</code></td>
<td>
<p>Default <code>1</code>. The specular intensity.</p>
</td></tr>
<tr><td><code id="set_material_+3A_emission_intensity">emission_intensity</code></td>
<td>
<p>Default <code>1</code>. The emission intensity.</p>
</td></tr>
<tr><td><code id="set_material_+3A_ambient_intensity">ambient_intensity</code></td>
<td>
<p>Default <code>1</code>. The ambient intensity.</p>
</td></tr>
<tr><td><code id="set_material_+3A_culling">culling</code></td>
<td>
<p>Default <code>"back"</code>. The culling type. Options are <code>back</code>, <code>front</code>, and <code>none</code>.</p>
</td></tr>
<tr><td><code id="set_material_+3A_type">type</code></td>
<td>
<p>Default <code>"diffuse"</code>. The shader type. Options include <code>diffuse</code>,<code>phong</code>,<code>vertex</code>, and <code>color</code>.</p>
</td></tr>
<tr><td><code id="set_material_+3A_translucent">translucent</code></td>
<td>
<p>Default <code>TRUE</code>. Whether light should transmit through a semi-transparent material.</p>
</td></tr>
<tr><td><code id="set_material_+3A_toon_levels">toon_levels</code></td>
<td>
<p>Default <code>5</code>. Number of color breaks in the toon shader.</p>
</td></tr>
<tr><td><code id="set_material_+3A_toon_outline_width">toon_outline_width</code></td>
<td>
<p>Default <code>0.05</code>. Expansion term for model to specify toon outline width. Note: setting this property via this function currently does not generate outlines. Specify it during object creation.</p>
</td></tr>
<tr><td><code id="set_material_+3A_toon_outline_color">toon_outline_color</code></td>
<td>
<p>Default <code>black</code>. Toon outline color. Note: setting this property via this function currently does not color outlines. Specify it during object creation.</p>
</td></tr>
<tr><td><code id="set_material_+3A_reflection_intensity">reflection_intensity</code></td>
<td>
<p>Default <code>0.0</code>. Intensity of the reflection of the environment map, if present. This will be ignored if the material is refractive.</p>
</td></tr>
<tr><td><code id="set_material_+3A_reflection_sharpness">reflection_sharpness</code></td>
<td>
<p>Default <code>1.0</code>. Sharpness of the reflection, where lower values have blurrier reflections. Must be greater than zero and less than one.</p>
</td></tr>
<tr><td><code id="set_material_+3A_two_sided">two_sided</code></td>
<td>
<p>Default <code>NULL</code>. Whether diffuse materials should be two sided (normal is taken as the absolute value of the dot product of the light direction and the normal).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shape with new material
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Set the material of an object
generate_cornell_mesh() |&gt;
 add_shape(set_material(sphere_mesh(position=c(400,555/2,555/2),radius=40), 
                        diffuse="purple", type="phong")) |&gt;
 add_shape(set_material(sphere_mesh(position=c(555/2,220,555/2),radius=40),
                        dissolve=0.2,culling="none",diffuse="red")) |&gt;
 add_shape(set_material(sphere_mesh(position=c(155,300,555/2),radius=60), 
                        material = material_list(diffuse="gold", type="phong", 
                                                 ambient="gold", ambient_intensity=0.4))) |&gt;
 rasterize_scene(light_info=directional_light(direction=c(0.1,0.6,-1)))
 }
</code></pre>

<hr>
<h2 id='smooth_normals_mesh'>Calculate Smooth Mesh Normals</h2><span id='topic+smooth_normals_mesh'></span>

<h3>Description</h3>

<p>Calculate Smooth Mesh Normals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_normals_mesh(mesh, id = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_normals_mesh_+3A_mesh">mesh</code></td>
<td>
<p>The mesh.</p>
</td></tr>
<tr><td><code id="smooth_normals_mesh_+3A_id">id</code></td>
<td>
<p>Default <code>NA</code> (all shapes). The shape index to have new normals calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mesh with new vertex normals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
 #Let's construct a mesh from the volcano dataset
 #Build the vertex matrix
  vertex_list = list()
  counter = 1
  for(i in 1:nrow(volcano)) {
    for(j in 1:ncol(volcano)) {
      vertex_list[[counter]] = matrix(c(j,volcano[i,j],i), ncol=3)
      counter = counter + 1
    }
  }
  vertices = do.call(rbind,vertex_list)
  
  #Build the index matrix
  index_list = list()
  counter = 0
  for(i in 1:(nrow(volcano)-1)) {
    for(j in 1:(ncol(volcano)-1)) {
      index_list[[counter+1]] = matrix(c(counter,counter+ncol(volcano),counter+1,
                                         counter+ncol(volcano),counter+ncol(volcano)+1,counter + 1), 
                                       nrow=2, ncol=3, byrow=TRUE)
      counter = counter + 1
    }
    counter = counter + 1
  }
  indices = do.call(rbind,index_list)
  #Construct the mesh
  volc_mesh = construct_mesh(vertices = vertices, indices = indices,
                             material = material_list(type="diffuse", diffuse="darkred", 
                                                      ambient = "darkred", ambient_intensity=0.2))
  #Rasterize the no-normal scene
  scale_mesh(volc_mesh, scale = c(1,1/3,1)) |&gt; 
    center_mesh() |&gt; 
    rasterize_scene(lookfrom=c(-50,50,100),lookat=c(7,-15,0), fov=40,width=800,height=800,
                    light_info = directional_light(c(0,1,1)) |&gt;
                      add_light(directional_light(c(1,1,-1))))
                      
  #Smooth the mesh
  volc_mesh_smooth = smooth_normals_mesh(volc_mesh)
  
  #Rasterize the scene
  scale_mesh(volc_mesh_smooth, scale = c(1,1/3,1)) |&gt; 
    center_mesh() |&gt; 
    rasterize_scene(lookfrom=c(-50,50,100),lookat=c(7,-15,0), fov=40,width=800,height=800,
                    light_info = directional_light(c(0,1,1)) |&gt;
                      add_light(directional_light(c(1,1,-1))))
}
</code></pre>

<hr>
<h2 id='sphere_mesh'>Sphere 3D Model</h2><span id='topic+sphere_mesh'></span>

<h3>Description</h3>

<p>Sphere 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere_mesh(
  position = c(0, 0, 0),
  scale = c(1, 1, 1),
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  radius = 1,
  low_poly = FALSE,
  normals = TRUE,
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphere_mesh_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Position of the mesh.</p>
</td></tr>
<tr><td><code id="sphere_mesh_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. Scale of the mesh. Can also be a single numeric value scaling all axes uniformly.</p>
</td></tr>
<tr><td><code id="sphere_mesh_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Angle to rotate the mesh.</p>
</td></tr>
<tr><td><code id="sphere_mesh_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Point around which to rotate the mesh.</p>
</td></tr>
<tr><td><code id="sphere_mesh_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. Order to rotate the axes.</p>
</td></tr>
<tr><td><code id="sphere_mesh_+3A_radius">radius</code></td>
<td>
<p>Default <code>1</code>. Radius of the sphere.</p>
</td></tr>
<tr><td><code id="sphere_mesh_+3A_low_poly">low_poly</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, will use a low-poly sphere.</p>
</td></tr>
<tr><td><code id="sphere_mesh_+3A_normals">normals</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to include vertex normals.</p>
</td></tr>
<tr><td><code id="sphere_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a sphere in the Cornell box.
generate_cornell_mesh() |&gt;
  add_shape(sphere_mesh(position = c(555/2, 555/2, 555/2), radius = 100)) |&gt;
  rasterize_scene(light_info = directional_light(c(0,0.5,-1)))
}
if(run_documentation()) {
#Generate a shiny sphere in the Cornell box
generate_cornell_mesh() |&gt;
  add_shape(sphere_mesh(position = c(555/2, 100, 555/2), radius = 100, 
                    material = material_list(diffuse = "gold",type="phong"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
if(run_documentation()) {
#Generate an ellipsoid in the Cornell box
generate_cornell_mesh() |&gt;
  add_shape(sphere_mesh(position = c(555/2, 210, 555/2), radius = 100, 
                        angle=c(0,30,0), scale = c(0.5,2,0.5),
                        material = material_list(diffuse = "dodgerblue",type="phong"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0.5,0.5,-1)))
}
</code></pre>

<hr>
<h2 id='subdivide_mesh'>Subdivide Mesh</h2><span id='topic+subdivide_mesh'></span>

<h3>Description</h3>

<p>Applies Loop subdivision to the scene (or selected meshes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subdivide_mesh(
  scene,
  id = NA,
  subdivision_levels = 2,
  simple = FALSE,
  normals = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subdivide_mesh_+3A_scene">scene</code></td>
<td>
<p>The scene to subdivide.</p>
</td></tr>
<tr><td><code id="subdivide_mesh_+3A_id">id</code></td>
<td>
<p>Default <code>NA</code>, all shapes. The index of which shape to subdivide.</p>
</td></tr>
<tr><td><code id="subdivide_mesh_+3A_subdivision_levels">subdivision_levels</code></td>
<td>
<p>Default <code>1</code>.
Number of Loop subdivisions to be applied to the mesh.</p>
</td></tr>
<tr><td><code id="subdivide_mesh_+3A_simple">simple</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to use simple subdivision, which does
not change the appearance of the mesh but does create a finer mesh.</p>
</td></tr>
<tr><td><code id="subdivide_mesh_+3A_normals">normals</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to calculate subdivided vertex normals.</p>
</td></tr>
<tr><td><code id="subdivide_mesh_+3A_verbose">verbose</code></td>
<td>
<p>Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scene with shape added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Subdivide the included R mesh
obj_mesh(r_obj(),position=c(-0.5,0,0)) |&gt; 
  add_shape(subdivide_mesh(obj_mesh(r_obj(),position=c(0.5,0,0)),
                           subdivision_levels = 2)) |&gt; 
  rasterize_scene(light_info = directional_light(direction=c(0.2,0.5,1)),fov=13)
}
</code></pre>

<hr>
<h2 id='swap_yz'>Swap Y/Z Axis</h2><span id='topic+swap_yz'></span>

<h3>Description</h3>

<p>Swap Y/Z Axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_yz(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swap_yz_+3A_mesh">mesh</code></td>
<td>
<p>A raymesh object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mesh with Y and Z axis exchanged
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Flip a mesh that's originally aligned along the y-axis
if(run_documentation()) {
cyl_mat = material_list(ambient="red", ambient_intensity=0.3, 
                        diffuse="red", diffuse_intensity=0.7)
change_material(cylinder_mesh(length = 3, position=c(0,2,0), material = cyl_mat),
                diffuse="green", ambient="green") |&gt; 
  add_shape(swap_yz(cylinder_mesh(position=c(0,2,0), length=3, material = cyl_mat))) |&gt; 
  rasterize_scene(lookfrom=c(10,10,10), lookat=c(0,0,0), fov=40,
                  light_info = directional_light(c(1,1,-1)),
                  line_info = generate_line(end=c(10,0,0)) |&gt; 
                  add_lines(generate_line(end=c(0,10,0),color="green")) |&gt; 
                  add_lines(generate_line(end=c(0,0,10),color="red")))
}
</code></pre>

<hr>
<h2 id='text3d_mesh'>Text Object</h2><span id='topic+text3d_mesh'></span>

<h3>Description</h3>

<p>Text Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text3d_mesh(
  label,
  position = c(0, 0, 0),
  text_height = 1,
  orientation = "xy",
  font_color = "black",
  font_size = 100,
  font = "sans",
  font_lineheight = 12,
  background_color = "white",
  background_alpha = 0,
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="text3d_mesh_+3A_label">label</code></td>
<td>
<p>Text string.</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Position of the mesh.</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_text_height">text_height</code></td>
<td>
<p>Default <code>1</code>. Height of the text.</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_orientation">orientation</code></td>
<td>
<p>Default <code>xy</code>. Orientation of the plane. Other options are <code>yz</code> and <code>xz</code>.</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_font_color">font_color</code></td>
<td>
<p>Default <code>"black"</code>. The font color.</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_font_size">font_size</code></td>
<td>
<p>Default <code>100</code>. The size of the font. Note that this does not control the size of the text, just the resolution
as rendered in the texture.</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_font">font</code></td>
<td>
<p>Default <code>"sans"</code>. A character string specifying the font family (e.g., <code>"Arial"</code>, <code>"Times"</code>, <code>"Helvetica"</code>).</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_font_lineheight">font_lineheight</code></td>
<td>
<p>Default <code>12</code>. The lineheight for strings with newlines.</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_background_color">background_color</code></td>
<td>
<p>Default <code>"white"</code>. The background color.</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_background_alpha">background_alpha</code></td>
<td>
<p>Default <code>0</code>. The background opacity. <code>1</code> is fully opaque.</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Angle to rotate the mesh.</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Point around which to rotate the mesh.</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. Order to rotate the axes.</p>
</td></tr>
<tr><td><code id="text3d_mesh_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. Scale of the mesh. Can also be a single numeric value scaling all axes uniformly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a label in the Cornell box.
generate_cornell_mesh() |&gt; 
  add_shape(text3d_mesh(label="Cornell Box", position=c(555/2,555/2,555/2),angle=c(0,180,0),
  text_height=120)) |&gt; 
  rasterize_scene(light_info = directional_light(c(0.1,0.4,-1)))
}
if(run_documentation()) {
#Change the orientation
generate_cornell_mesh() |&gt; 
  add_shape(text3d_mesh(label="YZ Plane", position=c(540,555/2,555/2),text_height=180,
                    orientation = "yz",angle=c(0,180,0))) |&gt; 
  add_shape(text3d_mesh(label="XY Plane", position=c(555/2,555/2,540),text_height=180,
                    orientation = "xy", angle=c(0,180,0))) |&gt; 
  add_shape(text3d_mesh(label="XZ Plane", position=c(555/2,15,555/2),text_height=180,
                    orientation = "xz", angle=c(0,180,0))) |&gt; 
  rasterize_scene(light_info = directional_light(c(0.1,0.4,-1)))
  }
if(run_documentation()) {
#Add an label in front of a sphere and change the font
generate_cornell_mesh() |&gt; 
  add_shape(text3d_mesh(label="Cornell Box", position=c(555/2,555/2,555/2),text_height=180,
                        font = "Serif", font_color="orange",
                        angle=c(0,180,0))) |&gt; 
  add_shape(text3d_mesh(label="Sphere", position=c(555/2,130,100),text_height=100,
                        font = "sans",
                        font_color="lightblue",angle=c(0,180,40))) |&gt; 
  add_shape(sphere_mesh(radius=100,position=c(555/2,100,555/2),
                        material=material_list(diffuse="purple",type="phong"))) |&gt;                  
  rasterize_scene(light_info = directional_light(c(0.1,0.4,-1)))
  }
if(run_documentation()) {
#A room full of b's
set.seed(1)
bee_scene = list()
for(i in 1:100) {
bee_scene = add_shape(bee_scene, text3d_mesh("B", position=c(20+runif(3)*525), 
                                             font_color="yellow", text_height = 100,
                                             angle=c(0,180,0)))
}
generate_cornell_mesh() |&gt; 
  add_shape(bee_scene) |&gt;                   
  rasterize_scene(light=directional_light(c(0,1,-1)))
}

if(run_documentation()) {
#A room full of bees
bee_scene = list()
set.seed(1)
for(i in 1:100) {
  bee_scene = add_shape(bee_scene, text3d_mesh("\U1F41D", position=c(20+runif(3)*525), 
                                               font_color="yellow", text_height = 100,
                                               angle=c(0,180,0)))
}
generate_cornell_mesh() |&gt; 
  add_shape(bee_scene) |&gt;                   
  rasterize_scene(light=directional_light(c(0,1,-1)))
}
</code></pre>

<hr>
<h2 id='torus_mesh'>Torus 3D Model</h2><span id='topic+torus_mesh'></span>

<h3>Description</h3>

<p>Torus 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>torus_mesh(
  position = c(0, 0, 0),
  scale = c(1, 1, 1),
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  radius = 0.5,
  ring_radius = 0.2,
  sides = 36,
  rings = 36,
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="torus_mesh_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Position of the mesh.</p>
</td></tr>
<tr><td><code id="torus_mesh_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. Scale of the mesh. Can also be a single numeric value scaling all axes uniformly.</p>
</td></tr>
<tr><td><code id="torus_mesh_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Angle to rotate the mesh.</p>
</td></tr>
<tr><td><code id="torus_mesh_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Point around which to rotate the mesh.</p>
</td></tr>
<tr><td><code id="torus_mesh_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. Order to rotate the axes.</p>
</td></tr>
<tr><td><code id="torus_mesh_+3A_radius">radius</code></td>
<td>
<p>Default <code>0.5</code>. The radius of the torus.</p>
</td></tr>
<tr><td><code id="torus_mesh_+3A_ring_radius">ring_radius</code></td>
<td>
<p>Default <code>0.2</code>. The radius of the ring.</p>
</td></tr>
<tr><td><code id="torus_mesh_+3A_sides">sides</code></td>
<td>
<p>Default <code>36</code>. The number of faces around the ring when triangulating the torus.</p>
</td></tr>
<tr><td><code id="torus_mesh_+3A_rings">rings</code></td>
<td>
<p>Default <code>36</code>. The number of faces around the torus.</p>
</td></tr>
<tr><td><code id="torus_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Plot a group of tori in the cornell box
generate_cornell_mesh(ceiling = FALSE) |&gt; 
 add_shape(torus_mesh(position=c(555/2,555/3,555/2), angle=c(20,0,45),
                      radius=120, ring_radius = 40,
                      material = material_list(diffuse="dodgerblue4",type="phong",
                                               ambient="dodgerblue4",ambient_intensity=0.2))) |&gt;
 add_shape(torus_mesh(position=c(400,400,555/2), angle=c(20,200,45),radius=80, ring_radius = 30,
                      material=material_list(diffuse="orange",type="phong",
                                             ambient="orange",ambient_intensity=0.2))) |&gt;
 add_shape(torus_mesh(position=c(150,450,555/2), angle=c(60,180,0),radius=40, ring_radius = 20,
                      material=material_list(diffuse="red",type="phong"))) |&gt;
 rasterize_scene(light_info = directional_light(c(0,1,-2)))
}
</code></pre>

<hr>
<h2 id='translate_lines'>Translate Lines</h2><span id='topic+translate_lines'></span>

<h3>Description</h3>

<p>Translate Lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_lines(lines, position = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translate_lines_+3A_lines">lines</code></td>
<td>
<p>The line scene.</p>
</td></tr>
<tr><td><code id="translate_lines_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The translation vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Translated line matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a cube out of lines
cube_outline = generate_line(start = c(-1, -1, -1), end = c(-1, -1, 1)) |&gt;
  add_lines(generate_line(start = c(-1, -1, -1), end = c(-1, 1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, -1), end = c(1, -1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, 1), end = c(-1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, -1, 1), end = c(1, -1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, 1), end = c(-1, 1, -1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, 1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(1, 1, -1), end = c(1, -1, -1))) |&gt;
  add_lines(generate_line(start = c(1, 1, -1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(1, -1, -1), end = c(1, -1, 1))) |&gt;
  add_lines(generate_line(start = c(1, -1, 1), end = c(1, 1, 1))) |&gt;
  add_lines(generate_line(start = c(-1, 1, -1), end = c(1, 1, -1))) 
rasterize_lines(cube_outline,fov=40,lookfrom=c(1,2,10),lookat=c(0,0,0))
}
if(run_documentation()) {
#Scale the cube uniformly
translated_cube = color_lines(translate_lines(cube_outline,c(1,1,1)),"red")
translated_cube2 = color_lines(translate_lines(cube_outline,c(-1,-1,-1)),"green")

cube_outline |&gt;
  add_lines(translated_cube) |&gt;
  add_lines(translated_cube2) |&gt;
  rasterize_lines(fov=40,lookfrom=c(1,2,10),lookat=c(0,0,0))
}
</code></pre>

<hr>
<h2 id='translate_mesh'>Translate Mesh</h2><span id='topic+translate_mesh'></span>

<h3>Description</h3>

<p>Translate Mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_mesh(mesh, position = c(0, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translate_mesh_+3A_mesh">mesh</code></td>
<td>
<p>The mesh.</p>
</td></tr>
<tr><td><code id="translate_mesh_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. The translation vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Translated mesh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Translate a mesh in the Cornell box
robj = obj_mesh(r_obj(), scale=150,angle=c(0,180,0))
generate_cornell_mesh() |&gt;
 add_shape(translate_mesh(robj,c(400,100,155))) |&gt;
 add_shape(translate_mesh(robj,c(555/2,200,555/2))) |&gt;
 add_shape(translate_mesh(robj,c(155,300,400))) |&gt;
 rasterize_scene(light_info=directional_light(direction=c(0.1,0.6,-1)))
}
</code></pre>

<hr>
<h2 id='validate_mesh'>Validate Mesh Data</h2><span id='topic+validate_mesh'></span>

<h3>Description</h3>

<p>This function takes a mesh and validates it. The mesh should be a list with
&quot;shapes&quot;, &quot;materials&quot;, &quot;vertices&quot;, &quot;texcoords&quot;, &quot;normals&quot;, and &quot;material_hashes&quot; entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_mesh(mesh, validate_materials = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_mesh_+3A_mesh">mesh</code></td>
<td>
<p>List. A mesh is a list as described above.</p>
</td></tr>
<tr><td><code id="validate_mesh_+3A_validate_materials">validate_materials</code></td>
<td>
<p>Default <code>TRUE</code>. Whether or not to validate &quot;materials&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mesh.
</p>


<h3>Shapes</h3>

<p>Each &quot;shapes&quot; entry should be a list with &quot;mesh&quot;, &quot;name&quot;, and &quot;material&quot; entries.
Each &quot;mesh&quot; entry should have &quot;indices&quot;, &quot;tex_indices&quot;, &quot;norm_indices&quot;, &quot;material_ids&quot;, &quot;has_vertex_tex&quot;, and &quot;has_vertex_normals&quot;.
The indices should not exceed the number of rows in their corresponding vertex/normal/texcoord data. There should be no NA/NaN values in the vertex/normal/texcoord data.
</p>


<h3>Materials (for rayvertex package only)</h3>

<p>Each &quot;materials&quot; entry is expected to be a list with several entries with specific required lengths, as listed below:</p>

<table>
<tr>
 <td style="text-align: center;">
   Attribute </td><td style="text-align: center;"> Length </td><td style="text-align: center;"> Type </td>
</tr>
<tr>
 <td style="text-align: center;">
   diffuse </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   ambient </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   specular </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   transmittance </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   emission </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   shininess </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   ior </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   dissolve </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   illum </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   diffuse_texname </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Character </td>
</tr>
<tr>
 <td style="text-align: center;">
   normal_texname </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Character </td>
</tr>
<tr>
 <td style="text-align: center;">
   bump_texname </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Character </td>
</tr>
<tr>
 <td style="text-align: center;">
   specular_texname </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Character </td>
</tr>
<tr>
 <td style="text-align: center;">
   ambient_texname </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Character </td>
</tr>
<tr>
 <td style="text-align: center;">
   emissive_texname </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Character </td>
</tr>
<tr>
 <td style="text-align: center;">
   diffuse_intensity </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   bump_intensity </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   specular_intensity </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   emission_intensity </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   ambient_intensity </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   culling </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Character </td>
</tr>
<tr>
 <td style="text-align: center;">
   type </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Character </td>
</tr>
<tr>
 <td style="text-align: center;">
   translucent </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Logical </td>
</tr>
<tr>
 <td style="text-align: center;">
   toon_levels </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   toon_outline_width </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   toon_outline_color </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   reflection_intensity </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   reflection_sharpness </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Numeric </td>
</tr>
<tr>
 <td style="text-align: center;">
   two_sided </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> Logical </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>Note: This materials validation only applies to the rayvertex package. Other renderers might choose to use their own information in the material list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># validate a mesh
mesh = validate_mesh(sphere_mesh())
</code></pre>

<hr>
<h2 id='validate_scene'>Validate Scene</h2><span id='topic+validate_scene'></span>

<h3>Description</h3>

<p>Validate Scene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_scene(scene)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_scene_+3A_scene">scene</code></td>
<td>
<p>Make sure that there are no out of bounds issues and all the materials are valid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Color vector
</p>

<hr>
<h2 id='vec_ptype_abbr.ray_shape'>Abbreviate the ptype of ray_shape</h2><span id='topic+vec_ptype_abbr.ray_shape'></span>

<h3>Description</h3>

<p>Abbreviate the ptype of ray_shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_ptype_abbr.ray_shape(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vec_ptype_abbr.ray_shape_+3A_x">x</code></td>
<td>
<p>A ray_shape object.</p>
</td></tr>
<tr><td><code id="vec_ptype_abbr.ray_shape_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the abbreviation &quot;ray_shp&quot;.
</p>

<hr>
<h2 id='vec_ptype_abbr.ray_shape_list'>Abbreviate the ptype of ray_shape_list</h2><span id='topic+vec_ptype_abbr.ray_shape_list'></span>

<h3>Description</h3>

<p>Abbreviate the ptype of ray_shape_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_ptype_abbr.ray_shape_list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vec_ptype_abbr.ray_shape_list_+3A_x">x</code></td>
<td>
<p>A ray_shape_list object.</p>
</td></tr>
<tr><td><code id="vec_ptype_abbr.ray_shape_list_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the abbreviation &quot;ray_shp&quot;.
</p>

<hr>
<h2 id='verify_vertex_shader'>Verify Vertex Shader</h2><span id='topic+verify_vertex_shader'></span>

<h3>Description</h3>

<p>Verify Vertex Shader
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_vertex_shader(vertex_shader)
</code></pre>


<h3>Value</h3>

<p>bool
</p>

<hr>
<h2 id='write_scene_to_obj'>Write the scene to an OBJ file</h2><span id='topic+write_scene_to_obj'></span>

<h3>Description</h3>

<p>Writes the current scene to a Wavefront OBJ file, with or without materials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_scene_to_obj(scene, filename, materials = TRUE, fileext = ".obj")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_scene_to_obj_+3A_scene">scene</code></td>
<td>
<p>A rayvertex scene.</p>
</td></tr>
<tr><td><code id="write_scene_to_obj_+3A_filename">filename</code></td>
<td>
<p>The filename for the OBJ file.</p>
</td></tr>
<tr><td><code id="write_scene_to_obj_+3A_materials">materials</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to write an MTL file to specify the materials for the OBJ.</p>
</td></tr>
<tr><td><code id="write_scene_to_obj_+3A_fileext">fileext</code></td>
<td>
<p>Default <code>".obj"</code>. The file extension to add to the filename.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
tmpfile = tempfile(fileext = ".obj")
write_scene_to_obj(generate_cornell_mesh(), tmpfile)
}
</code></pre>

<hr>
<h2 id='xy_rect_mesh'>XY Rectangle 3D Model</h2><span id='topic+xy_rect_mesh'></span>

<h3>Description</h3>

<p>XY Rectangle 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy_rect_mesh(
  position = c(0, 0, 0),
  scale = c(1, 1, 1),
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xy_rect_mesh_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Position of the mesh.</p>
</td></tr>
<tr><td><code id="xy_rect_mesh_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. Scale of the mesh. Can also be a single numeric value scaling all axes uniformly.</p>
</td></tr>
<tr><td><code id="xy_rect_mesh_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Angle to rotate the mesh.</p>
</td></tr>
<tr><td><code id="xy_rect_mesh_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Point around which to rotate the mesh.</p>
</td></tr>
<tr><td><code id="xy_rect_mesh_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. Order to rotate the axes.</p>
</td></tr>
<tr><td><code id="xy_rect_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
generate_cornell_mesh() |&gt;
  add_shape(xy_rect_mesh(position = c(555/2, 100, 555/2), scale=200,
             material = material_list(diffuse = "purple"),angle=c(0,180,0))) |&gt;
  rasterize_scene(light_info = directional_light(c(0,0.5,-1)))
}
if(run_documentation()) {
#Rotate the plane and scale 
generate_cornell_mesh() |&gt;
  add_shape(xy_rect_mesh(position = c(555/2, 100, 555/2), scale=c(200,100,1), angle=c(0,180,0),
             material = material_list(diffuse = "purple"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0,0.5,-1)))
}
</code></pre>

<hr>
<h2 id='xz_rect_mesh'>XZ Rectangle 3D Model</h2><span id='topic+xz_rect_mesh'></span>

<h3>Description</h3>

<p>XZ Rectangle 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xz_rect_mesh(
  position = c(0, 0, 0),
  scale = c(1, 1, 1),
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xz_rect_mesh_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Position of the mesh.</p>
</td></tr>
<tr><td><code id="xz_rect_mesh_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. Scale of the mesh. Can also be a single numeric value scaling all axes uniformly.</p>
</td></tr>
<tr><td><code id="xz_rect_mesh_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Angle to rotate the mesh.</p>
</td></tr>
<tr><td><code id="xz_rect_mesh_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Point around which to rotate the mesh.</p>
</td></tr>
<tr><td><code id="xz_rect_mesh_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. Order to rotate the axes.</p>
</td></tr>
<tr><td><code id="xz_rect_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
generate_cornell_mesh() |&gt;
  add_shape(xz_rect_mesh(position = c(555/2, 100, 555/2), scale=200,
             material = material_list(diffuse = "purple"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0,0.5,-1)))
}
if(run_documentation()) {
#Rotate the plane and scale 
generate_cornell_mesh() |&gt;
  add_shape(xz_rect_mesh(position = c(555/2, 100, 555/2), scale=c(200,1,100), angle=c(0,30,0),
             material = material_list(diffuse = "purple"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0,0.5,-1)))
}
</code></pre>

<hr>
<h2 id='yz_rect_mesh'>YZ Rectangle 3D Model</h2><span id='topic+yz_rect_mesh'></span>

<h3>Description</h3>

<p>YZ Rectangle 3D Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yz_rect_mesh(
  position = c(0, 0, 0),
  scale = c(1, 1, 1),
  angle = c(0, 0, 0),
  pivot_point = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  material = material_list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yz_rect_mesh_+3A_position">position</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Position of the mesh.</p>
</td></tr>
<tr><td><code id="yz_rect_mesh_+3A_scale">scale</code></td>
<td>
<p>Default <code>c(1,1,1)</code>. Scale of the mesh. Can also be a single numeric value scaling all axes uniformly.</p>
</td></tr>
<tr><td><code id="yz_rect_mesh_+3A_angle">angle</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Angle to rotate the mesh.</p>
</td></tr>
<tr><td><code id="yz_rect_mesh_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default <code>c(0,0,0)</code>. Point around which to rotate the mesh.</p>
</td></tr>
<tr><td><code id="yz_rect_mesh_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default <code>c(1,2,3)</code>. Order to rotate the axes.</p>
</td></tr>
<tr><td><code id="yz_rect_mesh_+3A_material">material</code></td>
<td>
<p>Default <code>material_list()</code> (default values). Specify the material of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
generate_cornell_mesh() |&gt;
  add_shape(yz_rect_mesh(position = c(555/2, 100, 555/2), scale=c(200,1,200), angle=c(0,0,0),
             material = material_list(diffuse = "purple"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0,0.5,-1)))
}
if(run_documentation()) {
#Rotate and scale
generate_cornell_mesh() |&gt;
  add_shape(yz_rect_mesh(position = c(555/2, 100, 555/2), scale=c(300,1,200), angle=c(0,45,0),
             material = material_list(diffuse = "purple"))) |&gt;
  rasterize_scene(light_info = directional_light(c(0,0.5,-1)))
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
