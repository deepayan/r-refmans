<!DOCTYPE html><html><head><title>Help for package bizicount</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bizicount}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bizicount'><p>Bizicount: Maximum likelihood estimation of copula-based bivariate zero-inflated</p>
(and non-inflated) count models</a></li>
<li><a href='#bizicount-class'><p>The bizicount S4 Class</p></a></li>
<li><a href='#bizicount-package'><p>bizicount: Copula-Based Bivariate Zero-Inflated Count Regression</p>
Models</a></li>
<li><a href='#extract.bizicount'><p>Texreg for bizicount objects</p></a></li>
<li><a href='#extract.zicreg'><p>Texreg for zicreg objects</p></a></li>
<li><a href='#make_DHARMa'><p>DHARMa-class objects from bizicount models</p></a></li>
<li><a href='#predict.zicreg'><p>Predictions for univariate zero-inflated count regression models</p></a></li>
<li><a href='#simulate.bizicount'><p>Simulating response values using parameters from fitted bizicount models</p></a></li>
<li><a href='#simulate.zicreg'><p>Simulating response values from fitted univariate zero-inflated count</p>
regression model</a></li>
<li><a href='#terror'><p>Nigeria Terrorism Data</p></a></li>
<li><a href='#zi_test'><p>He's (2019) test for zero-modification</p></a></li>
<li><a href='#zic.reg'><p>Univariate zero-inflated Poisson and negative binomial regression models</p></a></li>
<li><a href='#zicreg-class'><p>The zicreg S4 Class</p></a></li>
<li><a href='#zinb'><p>The zero-inflated negative binomial (ZINB) distribution</p></a></li>
<li><a href='#zip'><p>The zero-inflated Poisson (ZIP) distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bivariate Zero-Inflated Count Models Using Copulas</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Maximum likelihood estimation of copula-based zero-inflated 
    (and non-inflated) Poisson and negative binomial count models. Supports Frank 
    and Gaussian copulas. Allows for mixed margins (e.g., one margin Poisson, the 
    other zero-inflated negative binomial), and several marginal link functions. 
    Built-in methods for publication-quality tables using 'texreg', post-estimation 
    diagnostics using 'DHARMa', and testing for marginal zero-modification
    via &lt;<a href="https://doi.org/10.1177%2F0962280217749991">doi:10.1177/0962280217749991</a>&gt;. For information on copula regression for count data, 
    see Genest and Nešlehová (2007) &lt;<a href="https://doi.org/10.1017%2FS0515036100014963">doi:10.1017/S0515036100014963</a>&gt; as well as 
    Nikoloulopoulos (2013) &lt;<a href="https://doi.org/10.1007%2F978-3-642-35407-6_11">doi:10.1007/978-3-642-35407-6_11</a>&gt;. For information on zero-inflated
    count regression generally, see Lambert (1992) &lt;https:www.jstor.org/stable/1269547?origin=crossref&gt;. The author 
    acknowledges support by NSF DMS-1925119 and DMS-212324.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jmniehaus/bizicount">https://github.com/jmniehaus/bizicount</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jmniehaus/bizicount/issues">https://github.com/jmniehaus/bizicount/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>pbivnorm (&ge; 0.6.0), Formula (&ge; 1.2-4), rlang (&ge; 0.4.7),
MASS (&ge; 7.3-54), numDeriv (&ge; 2016.8-1.1), methods, stats,
utils, DHARMa (&ge; 0.3.4), texreg (&ge; 1.37.5)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-03 00:36:35 UTC; john</td>
</tr>
<tr>
<td>Author:</td>
<td>John Niehaus [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Niehaus &lt;jniehaus2257@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-03 04:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bizicount'>Bizicount: Maximum likelihood estimation of copula-based bivariate zero-inflated
(and non-inflated) count models</h2><span id='topic+bizicount'></span>

<h3>Description</h3>

<p>The main bivariate regression function of the <code><a href="#topic+bizicount-package">bizicount-package</a></code>
Estimates copula-based bivariate zero-inflated (and non-inflated)
count models via maximum likelihood. Supports the Frank and Gaussian
copulas, as well as zero-inflated Poisson and negative binomial margins
(and their non-inflated counterparts). It's class has associated
<code><a href="stats.html#topic+simulate">simulate</a></code> methods for post-estimation diagnostics using
the <code>DHARMa</code> package, as well as an
<code><a href="texreg.html#topic+extract">extract</a></code> method for printing professional tables using
<code><a href="texreg.html#topic+texreg">texreg</a></code>, and a test for zero-modification using <code>zi_test</code>.
See the 'See Also' section for links to these methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bizicount(
  fmla1,
  fmla2,
  data,
  cop = "gaus",
  margins = c("pois", "pois"),
  link.ct = c("log", "log"),
  link.zi = c("logit", "logit"),
  scaling = "none",
  starts = NULL,
  keep = TRUE,
  subset,
  na.action,
  weights,
  frech.min = 1e-07,
  pmf.min = 1e-07,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bizicount_+3A_fmla1">fmla1</code>, <code id="bizicount_+3A_fmla2">fmla2</code></td>
<td>
<p><code><a href="stats.html#topic+formula">formula</a></code>s for the first margin and
second margins, respectively. If non-inflated, of the form <code>y ~ x_1 + x_2 + ... + x_k</code>; if inflated, of the form <code>y ~ x1 + x2 + ... + x_k| z1 + z2 + ... + z_p</code>, where <code>y</code> is the outcome for the first margin, <code>x</code> are
covariates for count parameters, and <code>z</code> are covariates for zero-inflated
parameters in each margin. All covariates can be the same.</p>
</td></tr>
<tr><td><code id="bizicount_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the response variables, covariates, and
offsets for the model. If <code>NULL</code>, these quantities are searched for in the
parent environment.</p>
</td></tr>
<tr><td><code id="bizicount_+3A_cop">cop</code></td>
<td>
<p>Character string specifying the copula to be used. One of
<code>c("gaus", "frank")</code>. Partial matching supported.</p>
</td></tr>
<tr><td><code id="bizicount_+3A_margins">margins</code></td>
<td>
<p>Length 2 character vector specifying the marginal
distributions for each outcome. Each of the two elements must be one of
<code>c("pois", "nbinom", "zip", "zinb")</code>, and must be consistent with its
corresponding formula (i.e., zero-inflated margins with zero-inflated
formulas).</p>
</td></tr>
<tr><td><code id="bizicount_+3A_link.ct">link.ct</code></td>
<td>
<p>Length 2 character string specifying the link function used
for the count portion of each margin. One of <code>c("log", "identity", "sqrt")</code>.</p>
</td></tr>
<tr><td><code id="bizicount_+3A_link.zi">link.zi</code></td>
<td>
<p>Length 2 character string specifying the link function used
for the zero-inflation portion of each margin. One of <code>c("logit", "probit", "cauchit", "log", "cloglog")</code>. Ignored if corresponding <code>margins</code> entry is
not zero-inflated.</p>
</td></tr>
<tr><td><code id="bizicount_+3A_scaling">scaling</code></td>
<td>
<p>Deprecated. It is recommended that users scale their covariates
if they encounter convergence issues, which can be accomplished using the
<code>scale()</code> function on their data before putting it into the <code>bizicount()</code> function.</p>
</td></tr>
<tr><td><code id="bizicount_+3A_starts">starts</code></td>
<td>
<p>Numeric vector of starting values for parameter estimates. See
'Details' section regarding the correct order for the values in this vector.
If <code>NULL</code>, starting values are obtained automatically by a univariate regression fit.</p>
</td></tr>
<tr><td><code id="bizicount_+3A_keep">keep</code></td>
<td>
<p>Logical indicating whether to keep the model matrix in the
returned model object. Defaults to <code>TRUE</code>, but can be set to <code>FALSE</code> to conserve memory.
NOTE: Must be <code>TRUE</code> to use any post-estimation functions in this package,
including <code>zi_test</code>.</p>
</td></tr>
<tr><td><code id="bizicount_+3A_subset">subset</code></td>
<td>
<p>A vector indicating the subset of observations to use in
estimation.</p>
</td></tr>
<tr><td><code id="bizicount_+3A_na.action">na.action</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="bizicount_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector of weights for each observation.</p>
</td></tr>
<tr><td><code id="bizicount_+3A_frech.min">frech.min</code></td>
<td>
<p>Lower boundary for Frechet-Hoeffding bounds on copula CDF.
Used for computational purposes to prevent over/underflow in likelihood
search. Must be in <code class="reqn">[0, 1e-5]</code>, with <code class="reqn">0</code> imposing the original FH
bounds without computational consideration. See 'Details.'</p>
</td></tr>
<tr><td><code id="bizicount_+3A_pmf.min">pmf.min</code></td>
<td>
<p>Lower boundary on copula PMF evaluations. Used for
computational purposes to prevent over/underflow in likelihood search. Must
be in <code class="reqn">[0, 1e-5]</code>, with <code class="reqn">0</code> imposing no bound. See &lsquo;Details.&rsquo;</p>
</td></tr>
<tr><td><code id="bizicount_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to the quasi-newton fitting
function, <code><a href="stats.html#topic+nlm">nlm</a></code>. See 'Details' for some parameters that
may be useful to alter.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>starts</code> &ndash; Starting values should be organized as
follows:
</p>

<ol>
<li><p> count parameters for margin 1
</p>
</li>
<li><p> count parameters for margin 2
</p>
</li>
<li><p> zero-inflated parameters for margin 1 (if applicable),
</p>
</li>
<li><p> zero-inflated parameters for margin 2 (if applicable),
</p>
</li>
<li><p> inverse dispersion parameter for margin 1 (if applicable),
</p>
</li>
<li><p> inverse dispersion parameter for margin 2 (if applicable)
</p>
</li></ol>

<p>Thus, in general count parameters should come first, followed by
zero-inflation parameters, and finally inverse dispersion parameters.
</p>
</li>
<li> <p><code>frech.min</code> &ndash; Changing this argument should almost never be
necessary. Frechet (1951) and Hoeffding (1940) showed that copula CDFs have
bounds of the form <code class="reqn">max\{u + v - 1, 0\} \le C(u, v) \le min\{u, v\}</code>, where
<code class="reqn">u</code> and <code class="reqn">v</code> are uniform realizations derived from the probability
integral transform. Due to numerical underflow, very small values of <code class="reqn">u</code>
and <code class="reqn">v</code> can be rounded to zero. Particularly when evaluating the Gaussian
copula CDF this is problematic, ultimately leading to infinite-valued
likelihood evaluations. Therefore, we impose Frechet-Hoeffding bounds
numerically as <code class="reqn">max\{u + v - 1, frech.min\} \le C(u, v) \le min\{u, v, 1 -
frech.min\}</code>. NOTE: Setting this to 0 imposes the original Frechet bounds
mentioned above.
</p>
</li>
<li> <p><code>pmf.min</code> &ndash; Changing this argument should almost never be
necessary. Observations can have likelihoods that are extremely close to 0.
Numerically, these get rounded to 0 due to underflow. Then, taking logarithms
results in an infinite likelihood. To avoid this, we bound PMF evaluations
from below at <code>pmf.min</code>.
</p>
</li>
<li> <p><code>...</code> &ndash; Sometimes it may be useful to alter <code><a href="stats.html#topic+nlm">nlm</a></code>'s
default parameters. This can be done by simply passing those arguments into
<code>bizicount()</code>. The two that seem to benefit the fitting process the most are
<code>stepmax</code> and <code>steptol</code>. Readers are referred to the documentation on
<code><a href="stats.html#topic+nlm">nlm</a></code> for more details on these parameters. It can be
useful to lower <code>stepmax</code> particularly when the Hessian is not negative
definite at convergence, sometimes to a value between 0 and 1. It can also be
beneficial to increase <code>steptol</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An S3 <code><a href="#topic+bizicount-class">bizicount-class</a></code> object, which is a list containing:
</p>

<ul>
<li> <p><code>coef</code> &ndash; Coefficients of the model
</p>
</li>
<li> <p><code>coef.nid</code> &ndash; Coefficients without margin IDs
</p>
</li>
<li> <p><code>coef.orig</code> &ndash; Coefficients prior to transformations, for Gaussian
dependence and negative binomial dispersion.
</p>
</li>
<li> <p><code>coef.orig.nid</code> &ndash; Coefficients prior to transforms, no margin IDs.
</p>
</li>
<li> <p><code>se</code> &ndash; Asymptotic normal-theory standard errors based on observed Fisher Information
</p>
</li>
<li> <p><code>se.nid</code> &ndash; Standard errors without margin IDs
</p>
</li>
<li> <p><code>z</code> &ndash; z-scores for parameter estimates
</p>
</li>
<li> <p><code>z.nid</code> &ndash; z-scores without margin IDs
</p>
</li>
<li> <p><code>p</code> &ndash; p-values for parameter estimates
</p>
</li>
<li> <p><code>p.nid</code> &ndash; p-values without margin IDs
</p>
</li>
<li> <p><code>coefmats</code> &ndash; A list containing coeficient matrices for each margin
</p>
</li>
<li> <p><code>loglik</code> &ndash; Scalar log-likelihood at convergence
</p>
</li>
<li> <p><code>grad</code> &ndash; Numerical gradient vector at convergence
</p>
</li>
<li> <p><code>n.iter</code> &ndash; Number of quasi-newton fitting iterations.
</p>
</li>
<li> <p><code>covmat</code> &ndash; Covariance matrix of parameter estimates based on observed Fisher Information
</p>
</li>
<li> <p><code>aic</code> &ndash; Model's Akaike information
</p>
</li>
<li> <p><code>bic</code> &ndash; Model's Bayesian information criterion
</p>
</li>
<li> <p><code>nobs</code> &ndash; Number of observations
</p>
</li>
<li> <p><code>margins</code> &ndash; Marginal distributions used in fitting
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;link.zi, link.ct&#8288;</code> &ndash; Names of link functions used in fitting
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;invlink.ct, invlink.zi&#8288;</code> &ndash; Inverse link functions used in fitting (the
actual function, not their names)
</p>
</li>
<li> <p><code>outcomes</code> &ndash; Name of the response vector
</p>
</li>
<li> <p><code>conv</code> &ndash; Integer telling convergence status in nlm. See ?nlm.
</p>
</li>
<li> <p><code>cop</code> &ndash; The copula used in fitting
</p>
</li>
<li> <p><code>starts</code> &ndash; list of starting values used
</p>
</li>
<li> <p><code>call</code> &ndash; The model's call
</p>
</li>
<li> <p><code>model</code> &ndash; List containing model matrices, or <code>NULL</code> if <code>keep = F</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>John Niehaus
</p>


<h3>References</h3>

<p>Genest C, Nešlehová J (2007). “A primer on copulas for count
data.” ASTIN Bulletin: The Journal of the IAA, 37(2), 475–515.
</p>
<p>Inouye DI, Yang E, Allen GI, Ravikumar P (2017). “A review of multivariate
distributions for count data derived from the Poisson distribution.” Wiley
Interdisciplinary Reviews: Computational Statistics, 9(3).
</p>
<p>Joe H (1997). Multivariate models and multivariate dependence concepts. CRC Press.
</p>
<p>Nikoloulopoulos A (2013). “Copula-Based Models for Multivariate Discrete
Response Data.” In P Jaworski, F Durante, WK Härdle (eds.), Copulae in
Mathematical and Quantitative Finance, chapter 11, pp. 231–250. Springer.
</p>
<p>Nelsen RB (2007). An Introduction to Copulas. Springer Science &amp; Business Media.
</p>
<p>Trivedi P, Zimmer D (2017). “A note on identification of bivariate copulas
for discrete countdata.” Econometrics, 5(1), 10.
</p>
<p>Trivedi PK, Zimmer DM (2007). Copula modeling: an introduction for
practitioners. NowPublishers Inc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract.bizicount">extract.bizicount</a></code>, <code><a href="#topic+make_DHARMa">make_DHARMa</a></code>, <code><a href="#topic+zi_test">zi_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### bizicount example

## SETUP
set.seed(123)
n = 300

# define a function to simulate from a gaussian copula
# first margin is zero-inflated negative binomial (zinb)
# second margin is zero-inflated poisson (zip)
# Note: marginal distributions are hard-coded in function, including
# inverse dispersion parameter for zinb.
gen = function(n,
               b1,
               b2,
               g1,
               g2,
               dep) {

     k1 = length(b1)
     k2 = length(b2)

     X1 = cbind(1, matrix(rbinom(n * (k1 - 1), 1, .5), ncol = k1 - 1))
     X2 = cbind(1, matrix(rexp(n * (k2 - 1), 3), ncol = k2 - 1))

     lam1 = exp(X1 %*% b1)
     lam2 = exp(X2 %*% b2)

     Z1 = cbind(1, matrix(runif(n * (k1 - 1), -1, 1), ncol = k1 - 1))
     Z2 = cbind(1, matrix(rnorm(n * (k2 - 1)), ncol = k2 - 1))

     psi1 = plogis(Z1 %*% g1)
     psi2 = plogis(Z2 %*% g2)

     norm_vars = MASS::mvrnorm(
          n,
          mu = c(0, 0),
          Sigma = matrix(c(1, dep, dep, 1), ncol =2)
          )

     U = pnorm(norm_vars)

     y1 =  qzinb(U[, 1],
                 mu = lam1,
                 psi = psi1,
                 size = .3)
     y2 =  qzip(U[, 2],
                lambda = lam2,
                psi = psi2)

     dat = data.frame(
          X1 = X1[, -1],
          X2 = X2[, -1],
          Z1 = Z1[, -1],
          Z2 = Z2[, -1],
          y1,
          y2,
          lam1,
          lam2,
          psi1,
          psi2
     )
     return(dat)
}


# define parameters
b1 = c(1, -2, 3)
b2 = c(-1, 3, 1)
g1 = c(2, -1.5, 2)
g2 = c(-1, -3.75, 1.25)
rho = .5


# generate data
dat = gen(n, b1, b2, g1, g2, rho)
f1 = y1 ~ X1.1 + X1.2 | Z1.1 + Z1.2
f2 = y2 ~ X2.1 + X2.2 | Z2.1 + Z2.2

## END SETUP

# estimate model

mod = bizicount(f1, f2, dat, cop = "g", margins = c("zinb", "zip"), keep = TRUE)

print(mod)
summary(mod)
</code></pre>

<hr>
<h2 id='bizicount-class'>The bizicount S4 Class</h2><span id='topic+bizicount-class'></span>

<h3>Description</h3>

<p>Note that <code>bizicount</code> objects are generally S3, and should use
S3 syntax. This S4 class is defined only for compatability with
<code><a href="texreg.html#topic+texreg">texreg</a></code>. However, the contents of <code>bizicount</code> objects
is the same in both S3 and S4, so the descriptions below apply in both cases.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coef</code></dt><dd><p>Coefficients of the model</p>
</dd>
<dt><code>coef.nid</code></dt><dd><p>Coefficients without margin IDs</p>
</dd>
<dt><code>coef.orig</code></dt><dd><p>Coefficients prior to transformations, for Gaussian
dependence and negative binomial dispersion.</p>
</dd>
<dt><code>coef.orig.nid</code></dt><dd><p>Coefficients prior to transforms, no margin IDs.</p>
</dd>
<dt><code>se</code></dt><dd><p>Asymptotic standard errors based on observed Fisher Information</p>
</dd>
<dt><code>se.nid</code></dt><dd><p>Standard errors without margin IDs</p>
</dd>
<dt><code>z</code></dt><dd><p>z-scores for parameter estimates</p>
</dd>
<dt><code>z.nid</code></dt><dd><p>z-scores without margin IDs</p>
</dd>
<dt><code>p</code></dt><dd><p>p-values for parameter estimates</p>
</dd>
<dt><code>p.nid</code></dt><dd><p>p-values without margin IDs</p>
</dd>
<dt><code>coefmats</code></dt><dd><p>A list containing coefficient matrices for each margin</p>
</dd>
<dt><code>loglik</code></dt><dd><p>Scalar log-likelihood at convergence</p>
</dd>
<dt><code>grad</code></dt><dd><p>Gradient vector at convergence</p>
</dd>
<dt><code>n.iter</code></dt><dd><p>Number of quasi-newton fitting iterations.</p>
</dd>
<dt><code>covmat</code></dt><dd><p>Covariance matrix of parameter estimates based on observed Fisher Information</p>
</dd>
<dt><code>aic</code></dt><dd><p>Model's Akaike information</p>
</dd>
<dt><code>bic</code></dt><dd><p>Model's Bayesian information criterion</p>
</dd>
<dt><code>nobs</code></dt><dd><p>Number of observations</p>
</dd>
<dt><code>margins</code></dt><dd><p>Marginal distributions used in fitting</p>
</dd>
<dt><code>link.zi,link.ct</code></dt><dd><p>Names of link functions used in fitting</p>
</dd>
<dt><code>invlink.ct,invlink.zi</code></dt><dd><p>Inverse link functions used in fitting (the
actual function, not their names)</p>
</dd>
<dt><code>outcomes</code></dt><dd><p>Name of the response vector</p>
</dd>
<dt><code>conv</code></dt><dd><p>Integer telling convergence status.</p>
</dd>
<dt><code>cop</code></dt><dd><p>The copula used in fitting</p>
</dd>
<dt><code>starts</code></dt><dd><p>list of starting values used</p>
</dd>
<dt><code>call</code></dt><dd><p>The model's call</p>
</dd>
<dt><code>model</code></dt><dd><p>List containing model matrices, or <code>NULL</code> if <code>keep = F</code>.</p>
</dd>
</dl>

<hr>
<h2 id='bizicount-package'>bizicount: Copula-Based Bivariate Zero-Inflated Count Regression
Models</h2><span id='topic+bizicount-package'></span>

<h3>Description</h3>

<p>The package provides regression functions for copula-based
bivariate count models, with and without zero-inflation, as well as
regression functions for univariate zero-inflated count models. Generic
methods from the <code><a href="texreg.html#topic+texreg-package">texreg-package</a></code> and
<code><a href="DHARMa.html#topic+DHARMa">DHARMa</a></code> are extended to support this
package, namely for the purposes of producing professional tables and
carrying out post-estimation diagnostics. A generic for He et al. (2019)'s
test for zero-modification is provided, with methods for both <code>bizicount</code>
and <code>glm</code>-class objects.
</p>


<h3>Bivariate Functions</h3>


<ul>
<li> <p><code><a href="#topic+bizicount">bizicount</a></code> &ndash; The primary function of this package.
Carries out copula-based bivariate count regression via maximum likelihood
using numerical optimization. Supports both zero-inflated and non-inflated
distributions.
</p>
</li>
<li> <p><code><a href="#topic+extract.bizicount">extract.bizicount</a></code> &ndash; Method for the texreg package's
<code><a href="texreg.html#topic+extract">extract</a></code> generic. Creates a list of texreg objects, one
for each margin, for use with that package's other functions.
</p>
</li>
<li> <p><code><a href="#topic+make_DHARMa">make_DHARMa</a></code> &ndash; Creates a list of DHARMa objects, one for
each margin, for <code><a href="#topic+bizicount">bizicount</a></code> models. A wrapper around
<code><a href="DHARMa.html#topic+createDHARMa">createDHARMa</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+simulate.bizicount">simulate.bizicount</a></code> &ndash; Method that simulates observations
using the fitted model's parameters, primarily for use with DHARMa.
</p>
</li>
<li> <p><code><a href="#topic+zi_test">zi_test</a></code> &ndash; Method for testing for marginal zero-modification
using the esimated parameters from the model. This test is preferable to the
Vuong, Wald, Score, and LR tests. See He et al. (2019).
</p>
</li></ul>



<h3>Univariate Functions</h3>


<ul>
<li> <p><code><a href="#topic+zic.reg">zic.reg</a></code> &ndash; Univariate zero-inflated count regression
models via maximum likelihood.
</p>
</li>
<li> <p><code><a href="#topic+extract.zicreg">extract.zicreg</a></code> &ndash; Method for the texreg package's
<code><a href="texreg.html#topic+extract">extract</a></code> generic. Creates a texreg object that
interfaces with that package's methods.
</p>
</li>
<li> <p><code><a href="#topic+simulate.zicreg">simulate.zicreg</a></code> &ndash; Method for simulating from the fitted
model. Results are generally used for creating DHARMa objects.
</p>
<p>#' </p>
</li>
<li> <p><code><a href="#topic+zi_test">zi_test</a></code> &ndash; Method for testing for univariate zero-modification
using the esimated parameters from the model. This test is preferable to the
Vuong, Wald, Score, and LR tests. See He et al. (2019).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>John Niehaus
</p>

<hr>
<h2 id='extract.bizicount'>Texreg for bizicount objects</h2><span id='topic+extract.bizicount'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="texreg.html#topic+extract">extract</a></code> generic
to be used with objects that are output from the <code><a href="#topic+bizicount">bizicount</a></code>
function. The results can be used with any of the
<code><a href="texreg.html#topic+texreg-package">texreg-package</a></code> generics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bizicount'
extract(model, CI = NULL, id = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.bizicount_+3A_model">model</code></td>
<td>
<p>A <code><a href="#topic+bizicount-class">bizicount-class</a></code> model object (S3).</p>
</td></tr>
<tr><td><code id="extract.bizicount_+3A_ci">CI</code></td>
<td>
<p>The two-tailed confidence level, if confidence intervals are
desired in the texreg object, otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="extract.bizicount_+3A_id">id</code></td>
<td>
<p>Logical indicating whether to prepend equation identifiers to
coefficient names (<code>ct_</code> for count parameters, <code>zi_</code> for zero-inflated parameters)</p>
</td></tr>
<tr><td><code id="extract.bizicount_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="texreg.html#topic+texreg-class">texreg-class</a></code> object, as produced by
<code><a href="texreg.html#topic+createTexreg">createTexreg</a></code>, which can interface with all of that
package's generics.
</p>


<h3>Note</h3>

<p>Users can typically just call <code><a href="texreg.html#topic+texreg">texreg</a></code> directly on
a <code><a href="#topic+bizicount-class">bizicount-class</a></code> object, instead of first extracting and
then calling texreg.
</p>


<h3>Author(s)</h3>

<p>John Niehaus
</p>


<h3>References</h3>

<p>Leifeld, Philip (2013). texreg: Conversion of Statistical Model
Output in R to LaTeX and HTML Tables. Journal of Statistical Software,
55(8), 1-24. URL http://dx.doi.org/10.18637/jss.v055.i08.
</p>


<h3>See Also</h3>

<p><code><a href="texreg.html#topic+extract">extract</a></code>, <code><a href="texreg.html#topic+createTexreg">createTexreg</a></code>,
<code><a href="#topic+bizicount">bizicount</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## SETUP
set.seed(123)
n = 500

# define a function to simulate from a gaussian copula
# first margin is zero-inflated negative binomial (zinb)
# second margin is zero-inflated poisson (zip)
# Note: marginal distributions are hard-coded in function, including
# inverse dispersion parameter for zinb.
gen = function(n,
               b1,
               b2,
               g1,
               g2,
               dep) {

     k1 = length(b1)
     k2 = length(b2)

     X1 = cbind(1, matrix(rbinom(n * (k1 - 1), 1, .5), ncol = k1 - 1))
     X2 = cbind(1, matrix(rexp(n * (k2 - 1), 3), ncol = k2 - 1))

     lam1 = exp(X1 %*% b1)
     lam2 = exp(X2 %*% b2)

     Z1 = cbind(1, matrix(runif(n * (k1 - 1), -1, 1), ncol = k1 - 1))
     Z2 = cbind(1, matrix(rnorm(n * (k2 - 1)), ncol = k2 - 1))

     psi1 = plogis(Z1 %*% g1)
     psi2 = plogis(Z2 %*% g2)

     norm_vars = MASS::mvrnorm(
          n,
          mu = c(0, 0),
          Sigma = matrix(c(1, dep, dep, 1), ncol =2)
     )

     U = pnorm(norm_vars)

     y1 =  qzinb(U[, 1],
                 mu = lam1,
                 psi = psi1,
                 size = .3)
     y2 =  qzip(U[, 2],
                lambda = lam2,
                psi = psi2)

     dat = data.frame(
          X1 = X1[, -1],
          X2 = X2[, -1],
          Z1 = Z1[, -1],
          Z2 = Z2[, -1],
          y1,
          y2,
          lam1,
          lam2,
          psi1,
          psi2
     )
     return(dat)
}


# define parameters
b1 = c(1, -2, 3)
b2 = c(-1, 3, 1)
g1 = c(2, -1.5, 2)
g2 = c(-1, -3.75, 1.25)
rho = .5


# generate data
dat = gen(n, b1, b2, g1, g2, rho)
f1 = y1 ~ X1.1 + X1.2 | Z1.1 + Z1.2
f2 = y2 ~ X2.1 + X2.2 | Z2.1 + Z2.2

## END SETUP

# estimate model

mod = bizicount(f1, f2, dat, cop = "g", margins = c("zinb", "zip"), keep=TRUE)

# extract texreg objects, one with SEs, one with CIs
tr_obj_se = texreg::extract(mod)
tr_obj_ci = texreg::extract(mod, CI = .95)


# output to latex, single table.
# Note use of c(), because tr_obj_se, tr_obj_ci are lists.
texreg::texreg(c(tr_obj_se, tr_obj_ci))


# output as plaintext, two tables
texreg::screenreg(tr_obj_se)
texreg::screenreg(tr_obj_ci)
</code></pre>

<hr>
<h2 id='extract.zicreg'>Texreg for zicreg objects</h2><span id='topic+extract.zicreg'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="texreg.html#topic+extract">extract</a></code> generic
to be used with objects that are output from the <code><a href="#topic+zic.reg">zic.reg</a></code>
function. The results can then interface with the
<code><a href="texreg.html#topic+texreg-package">texreg-package</a></code>, as shown in examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zicreg'
extract(model, CI = NULL, id = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.zicreg_+3A_model">model</code></td>
<td>
<p>A zicreg model object, returned by <code><a href="#topic+zic.reg">zic.reg</a></code>.</p>
</td></tr>
<tr><td><code id="extract.zicreg_+3A_ci">CI</code></td>
<td>
<p>The two-tailed confidence level, if desired in the resulting
<code><a href="texreg.html#topic+texreg">texreg</a></code> object.</p>
</td></tr>
<tr><td><code id="extract.zicreg_+3A_id">id</code></td>
<td>
<p>Logical indicating whether to prepend equation identifiers to
coefficient names (<code>ct_</code> for count parameters, <code>zi_</code> for zero-inflated parameters)</p>
</td></tr>
<tr><td><code id="extract.zicreg_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="texreg.html#topic+texreg-class">texreg-class</a></code> object, as produced by
<code><a href="texreg.html#topic+createTexreg">createTexreg</a></code>, which can interface with all of that
package's generics. See 'Examples.'
</p>


<h3>Author(s)</h3>

<p>John Niehaus
</p>


<h3>References</h3>

<p>Leifeld, Philip (2013). texreg: Conversion of Statistical Model
Output in R to LaTeX and HTML Tables. Journal of Statistical Software,
55(8), 1-24. URL http://dx.doi.org/10.18637/jss.v055.i08.
</p>


<h3>See Also</h3>

<p><code><a href="texreg.html#topic+extract">extract</a></code>, <code><a href="texreg.html#topic+createTexreg">createTexreg</a></code>,
<code><a href="#topic+zic.reg">zic.reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate some zip data
n=1000
x = cbind(1, rnorm(n))
z = cbind(1, rbeta(n, 4, 8))
b = c(1, 2.2)
g = c(-1, 1.7)
lam = exp(x %*% b)
psi = plogis(z %*% g)


y = bizicount::rzip(n, lambda = lam, psi=psi)
dat = cbind.data.frame(x = x[,-1], z = z[,-1], y = y)

# estimate model

mod = zic.reg(y ~ x | z, data = dat)


### Output to table with texreg

# extract information

tr_obj_se = texreg::extract(mod)
tr_obj_ci = texreg::extract(mod, CI = .95)

# output to latex, single table

texreg::texreg(list(tr_obj_se, tr_obj_ci))

# output to plain text, multiple tables

texreg::screenreg(tr_obj_se)
texreg::screenreg(tr_obj_ci)
</code></pre>

<hr>
<h2 id='make_DHARMa'>DHARMa-class objects from bizicount models</h2><span id='topic+make_DHARMa'></span>

<h3>Description</h3>

<p>A wrapper around the <code><a href="DHARMa.html#topic+DHARMa">DHARMa</a></code> package's
<code><a href="DHARMa.html#topic+createDHARMa">createDHARMa</a></code> function. Creates a list of DHARMa
objects, one for each margin of a <code><a href="#topic+bizicount-class">bizicount-class</a></code> object, using
simulated responses from <code><a href="#topic+simulate.bizicount">simulate.bizicount</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_DHARMa(object, nsim = 250, seed = 123, method = "PIT")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_DHARMa_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+bizicount-class">bizicount-class</a></code> object, as returned by <a href="#topic+bizicount">bizicount</a>.</p>
</td></tr>
<tr><td><code id="make_DHARMa_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated responses from the fitted model to use for diagnostics.</p>
</td></tr>
<tr><td><code id="make_DHARMa_+3A_seed">seed</code></td>
<td>
<p>Random seed for simulating from fitted model.</p>
</td></tr>
<tr><td><code id="make_DHARMa_+3A_method">method</code></td>
<td>
<p>See <code><a href="DHARMa.html#topic+createDHARMa">createDHARMa</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code><a href="DHARMa.html#topic+DHARMa">DHARMa</a></code> objects.
</p>


<h3>Note</h3>

<p>This is merely a wrapper around the <code><a href="DHARMa.html#topic+createDHARMa">createDHARMa</a></code>
function to conveniently get DHARMa objects for each margin of a bizicount
model.
</p>


<h3>Author(s)</h3>

<p>John Niehaus
</p>


<h3>References</h3>

<p>Florian Hartig (2022). DHARMa: Residual Diagnostics for
Hierarchical (Multi-Level / Mixed) Regression Models. R package version
0.4.5. https://CRAN.R-project.org/package=DHARMa
</p>


<h3>See Also</h3>

<p><code><a href="DHARMa.html#topic+DHARMa">DHARMa</a></code>, <code><a href="DHARMa.html#topic+createDHARMa">createDHARMa</a></code>,
<code><a href="#topic+simulate.bizicount">simulate.bizicount</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## SETUP
set.seed(123)
n = 100

# define a function to simulate from a gaussian copula
# first margin is zero-inflated negative binomial (zinb)
# second margin is zero-inflated poisson (zip)
# Note: marginal distributions are hard-coded in function, including
# inverse dispersion parameter for zinb.
gen = function(n, b1, b2, g1, g2, dep) {

     k1 = length(b1)
     k2 = length(b2)

     X1 = cbind(1, matrix(rbinom(n * (k1 - 1), 1, .5), ncol = k1 - 1))
     X2 = cbind(1, matrix(rexp(n * (k2 - 1), 3), ncol = k2 - 1))

     lam1 = exp(X1 %*% b1)
     lam2 = exp(X2 %*% b2)

     Z1 = cbind(1, matrix(runif(n * (k1 - 1), -1, 1), ncol = k1 - 1))
     Z2 = cbind(1, matrix(rnorm(n * (k2 - 1)), ncol = k2 - 1))

     psi1 = plogis(Z1 %*% g1)
     psi2 = plogis(Z2 %*% g2)

     norm_vars = MASS::mvrnorm(
          n,
          mu = c(0, 0),
          Sigma = matrix(c(1, dep, dep, 1), ncol =2)
     )

     U = pnorm(norm_vars)

     y1 =  qzinb(U[, 1],
                 mu = lam1,
                 psi = psi1,
                 size = .3)
     y2 =  qzip(U[, 2],
                lambda = lam2,
                psi = psi2)

     dat = data.frame(
          X1 = X1[, -1],
          X2 = X2[, -1],
          Z1 = Z1[, -1],
          Z2 = Z2[, -1],
          y1,
          y2,
          lam1,
          lam2,
          psi1,
          psi2
     )
     return(dat)
}


# define parameters
b1 = c(1, -2, 3)
b2 = c(-1, 3, 1)
g1 = c(2, -1.5, 2)
g2 = c(-1, -3.75, 1.25)
rho = .5


# generate data
dat = gen(n, b1, b2, g1, g2, rho)
f1 = y1 ~ X1.1 + X1.2 | Z1.1 + Z1.2
f2 = y2 ~ X2.1 + X2.2 | Z2.1 + Z2.2

## END SETUP




# estimate model

mod = bizicount(f1, f2, dat, cop = "g", margins = c("zinb", "zip"), keep=TRUE)


# diagnose model with DHARMa
# see end for simulate.bizicount example.

dharm = make_DHARMa(mod, nsim = 100)

lapply(dharm, DHARMa::testResiduals)
</code></pre>

<hr>
<h2 id='predict.zicreg'>Predictions for univariate zero-inflated count regression models</h2><span id='topic+predict.zicreg'></span>

<h3>Description</h3>

<p>Predicts the mean, probability, count mean, or zero-inflation
probability for new data using parameters from a fitted zero-inflated count
regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zicreg'
predict(object, newdata = NULL, y.new = NULL, type = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.zicreg_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+zic.reg">zic.reg</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.zicreg_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing new values of the same covariates appearing in fitted model.</p>
</td></tr>
<tr><td><code id="predict.zicreg_+3A_y.new">y.new</code></td>
<td>
<p>An optional vector of new response values, used only for <code>type = "prob"</code>.</p>
</td></tr>
<tr><td><code id="predict.zicreg_+3A_type">type</code></td>
<td>
<p>String, one of <code>c("mean", "prob", "psi", "lambda")</code>. <code>"mean"</code>
will predict the conditional mean of the mixture distribution, <code>"prob"</code>
will predict the probability of a new response value, <code>"psi"</code> will predict
the probability of zero-inflation, and <code>"lambda"</code> will predict the mean of
the count portion of the mixture distribution. NOTE: Setting <code>type = "mean"</code> and leaving <code>newdata = NULL</code> is the same as calling
<code>fitted(object)</code>.</p>
</td></tr>
<tr><td><code id="predict.zicreg_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the predictions using the model parameters.
</p>


<h3>Author(s)</h3>

<p>John Niehaus
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate some zip data
n=1000
x = cbind(1, rnorm(n))
z = cbind(1, rbeta(n, 4, 8))
b = c(1, 2.2)
g = c(-1, 1.7)
lam = exp(x %*% b)
psi = plogis(z %*% g)


y = bizicount::rzip(n, lambda = lam, psi=psi)
dat = cbind.data.frame(x = x[,-1], z = z[,-1], y = y)

# estimate model

mod = zic.reg(y ~ x | z, data = dat, keep = TRUE)


### Predict on observed/training data
# predict conditional mean (fitted values)
predict(mod, type = "mean")

# predict probabilty Y = y
probs_pred_obs = predict(mod, type = "prob")

# predict mean of count distribution (lambda)
lambda_pred_obs = predict(mod, type = "lambda")

# mse predicted vs true lambda values
mean((lam - lambda_pred_obs)**2)

# predict zero inflation probability (psi)
psi_pred_obs = predict(mod, type = "psi")

# MSE predicted vs true zero-inflation probabilities
mean((psi-psi_pred_obs)**2)


### Predict on test data
# simulate some test data

x = cbind(1, rnorm(n, mean = -0.5, sd = 1.25))
z = cbind(1, rbeta(n, 6, 12))
y = rzip(n, lambda = exp(x %*% coef(mod)[1:2]), psi = plogis(z %*% coef(mod)[3:4]))
dat_new = cbind.data.frame(x = x[,-1], z = z[,-1], y = y)

# predict conditional mean
mean_new = predict(mod, type = "mean", newdata = dat_new)
mean((y - mean_new)**2)

# predict probability of Y = y
probs_new = predict(mod, type = "prob", newdata = dat_new, y.new = y)

# predict lambda
lambda_new = predict(mod, type = "lambda", newdata = dat_new)

# predict zero inflation probability
psi_new = predict(mod, type = "psi", newdata = dat_new)




</code></pre>

<hr>
<h2 id='simulate.bizicount'>Simulating response values using parameters from fitted bizicount models</h2><span id='topic+simulate.bizicount'></span>

<h3>Description</h3>

<p>Simulates random response values using the fitted conditional
mean function for each margin of a <code><a href="#topic+bizicount-class">bizicount-class</a></code> object.
Primarily for use with the <code><a href="DHARMa.html#topic+DHARMa">DHARMa</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bizicount'
simulate(object, nsim = 250, seed = 123, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.bizicount_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+bizicount-class">bizicount-class</a></code> object, as returned by
<code><a href="#topic+bizicount">bizicount</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.bizicount_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated response values from the fitted model. E.g.,
<code>nsim = 250</code> will simulate each observation 250 times, for <code class="reqn">n \times
  250</code> total observations.</p>
</td></tr>
<tr><td><code id="simulate.bizicount_+3A_seed">seed</code></td>
<td>
<p>Seed used for simulating from fitted model. If <code>NULL</code>, no seed is
set.</p>
</td></tr>
<tr><td><code id="simulate.bizicount_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length 2 list, with each entry containing a numeric <code class="reqn">n X
  nsim</code> matrix for each margin of the bizicount model. Rows index
the observation, and columns index the simulated dataset number.
</p>


<h3>Author(s)</h3>

<p>John Niehaus
</p>


<h3>References</h3>

<p>Florian Hartig (2022). DHARMa: Residual Diagnostics for
Hierarchical (Multi-Level / Mixed) Regression Models. R package version
0.4.5. https://CRAN.R-project.org/package=DHARMa
</p>


<h3>See Also</h3>

<p><code><a href="DHARMa.html#topic+createDHARMa">createDHARMa</a></code>, <code><a href="DHARMa.html#topic+simulateResiduals">simulateResiduals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## SETUP
set.seed(123)
n = 150

# define a function to simulate from a gaussian copula
# first margin is zero-inflated negative binomial (zinb)
# second margin is zero-inflated poisson (zip)
# Note: marginal distributions are hard-coded in function, including
# inverse dispersion parameter for zinb.
gen = function(n,
               b1,
               b2,
               g1,
               g2,
               dep) {

     k1 = length(b1)
     k2 = length(b2)

     X1 = cbind(1, matrix(rbinom(n * (k1 - 1), 1, .5), ncol = k1 - 1))
     X2 = cbind(1, matrix(rexp(n * (k2 - 1), 3), ncol = k2 - 1))

     lam1 = exp(X1 %*% b1)
     lam2 = exp(X2 %*% b2)

     Z1 = cbind(1, matrix(runif(n * (k1 - 1), -1, 1), ncol = k1 - 1))
     Z2 = cbind(1, matrix(rnorm(n * (k2 - 1)), ncol = k2 - 1))

     psi1 = plogis(Z1 %*% g1)
     psi2 = plogis(Z2 %*% g2)

     norm_vars = MASS::mvrnorm(
          n,
          mu = c(0, 0),
          Sigma = matrix(c(1, dep, dep, 1), ncol =2)
     )

     U = pnorm(norm_vars)

     y1 =  qzinb(U[, 1],
                 mu = lam1,
                 psi = psi1,
                 size = .3)
     y2 =  qzip(U[, 2],
                lambda = lam2,
                psi = psi2)

     dat = data.frame(
          X1 = X1[, -1],
          X2 = X2[, -1],
          Z1 = Z1[, -1],
          Z2 = Z2[, -1],
          y1,
          y2,
          lam1,
          lam2,
          psi1,
          psi2
     )
     return(dat)
}


# define parameters
b1 = c(1, -2, 3)
b2 = c(-1, 3, 1)
g1 = c(2, -1.5, 2)
g2 = c(-1, -3.75, 1.25)
rho = .5


# generate data
dat = gen(n, b1, b2, g1, g2, rho)
f1 = y1 ~ X1.1 + X1.2 | Z1.1 + Z1.2
f2 = y2 ~ X2.1 + X2.2 | Z2.1 + Z2.2

## END SETUP




# estimate model
mod = bizicount(f1, f2, dat, cop = "g", margins = c("zinb", "zip"), keep=TRUE)

# simulate from fitted model
sims = simulate(mod, nsim = 150)


# input sims to DHARMa for diagnostics
# margin 1
d1 = DHARMa::createDHARMa(
     simulatedResponse = sims[[1]],
     observedResponse = dat$y1,
     fittedPredictedResponse = fitted(mod)[,1],
     integerResponse = TRUE,
     method = "PIT"
)

# margin 2
d2 = DHARMa::createDHARMa(
     simulatedResponse = sims[[2]],
     observedResponse = dat$y2,
     fittedPredictedResponse = fitted(mod)[,2],
     integerResponse = TRUE,
     method = "PIT"
)

# test each margin
DHARMa::testResiduals(d1)
DHARMa::testResiduals(d2)


</code></pre>

<hr>
<h2 id='simulate.zicreg'>Simulating response values from fitted univariate zero-inflated count
regression model</h2><span id='topic+simulate.zicreg'></span>

<h3>Description</h3>

<p>Simulates responses using the fitted parameters from a
<code><a href="#topic+zicreg-class">zicreg-class</a></code> object, as returned by <code><a href="#topic+zic.reg">zic.reg</a></code>.
Primarily useful for methods found in <code><a href="DHARMa.html#topic+DHARMa">DHARMa</a></code> package. See 'Examples.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zicreg'
simulate(object, nsim = 250, seed = 123, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.zicreg_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+zicreg-class">zicreg-class</a></code> model object, as returned by <code><a href="#topic+zic.reg">zic.reg</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.zicreg_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated datasets to create.</p>
</td></tr>
<tr><td><code id="simulate.zicreg_+3A_seed">seed</code></td>
<td>
<p>Random seed for random number generation in simulations. If
<code>NULL</code>, no seed is set.</p>
</td></tr>
<tr><td><code id="simulate.zicreg_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric <code class="reqn">n x nsim</code> matrix, with rows indexing
observations, and columns indexing the simulation number.
</p>


<h3>Author(s)</h3>

<p>John Niehaus
</p>


<h3>References</h3>

<p>Florian Hartig (2022). DHARMa: Residual Diagnostics for
Hierarchical (Multi-Level / Mixed) Regression Models. R package version
0.4.5. https://CRAN.R-project.org/package=DHARMa
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate some zip data
n=300
x = cbind(1, rnorm(n))
z = cbind(1, rbeta(n, 4, 8))
b = c(1, 2.2)
g = c(-1, 1.7)
lam = exp(x %*% b)
psi = plogis(z %*% g)

y = bizicount::rzip(n, lambda = lam, psi=psi)
dat = cbind.data.frame(x = x[,-1], z = z[,-1], y = y)

# estimate model

mod = zic.reg(y ~ x | z, data = dat, keep = TRUE)

# simulate from fit for use in dharma
sims = simulate(mod)

### Make dharma object

dharm = DHARMa::createDHARMa(
     simulatedResponse = sims,
     observedResponse = y,
     fittedPredictedResponse = fitted(mod),
     integerResponse = TRUE,
     method = "PIT"
)

### Plot the DHARMa object, do other diagnostics
plot(dharm)
DHARMa::testResiduals(dharm)
</code></pre>

<hr>
<h2 id='terror'>Nigeria Terrorism Data</h2><span id='topic+terror'></span>

<h3>Description</h3>

<p>Data on terrorist attacks by Fulani Extremists and Boko Haram in Nigeria,
from the year 2014. Attacks data from Global Terrorism Database, other variables
from UCDP PRIO-Grid data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terror
</code></pre>


<h3>Format</h3>



<h4><code>terror</code></h4>

<p>A data frame with 312 rows and 6 columns:
</p>

<dl>
<dt>att.ful, att.bok</dt><dd><p>Integer number of attacks by Fulani Extremists and Boko Haram in 2014.</p>
</dd>
<dt>xcoord, ycoord</dt><dd><p>Longitude and Latidude of grid-cell centroid where attack occurs.</p>
</dd>
<dt>pop</dt><dd><p>Population in grid cell.</p>
</dd>
<dt>mtns</dt><dd><p>Proportion of terrain in grid cell that is considered mountainous.</p>
</dd>
</dl>



<hr>
<h2 id='zi_test'>He's (2019) test for zero-modification</h2><span id='topic+zi_test'></span>

<h3>Description</h3>

<p>This is an implementation of He et al. (2019)'s test for
zero-modification (discussed further in Tang &amp; Tang (2019)). This is a test of
zero-<em>modification</em> instead of <em>inflation</em>, because the test is capable of detecting
both excessive or lack of zeros, but cannot determine the cause. For example, a mixed
data generating process could be generating structural zeros, implying a
zero-inflated distribution. However, overdispersion via a negative binomial
may also result in excessive zeros. Thus, the test merely determines whether
there are excessive (or lacking) zeros, but does not determine the process
generating this pattern. That in mind, typical tests in the literature are
inappropriate for zero-modified regression models, namely the Vuong, Wald,
score, and likelihood ratio tests. See the references below for more information
on this claim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_test(model, alternative = "inflated")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zi_test_+3A_model">model</code></td>
<td>
<p>A model object of class <code><a href="#topic+bizicount">bizicount</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>.
If a <code>bizicount</code> model, then at least one margin must be specified as <code>"pois"</code>.
If a <code>glm</code> model, then the <code>family</code> must be <code><a href="stats.html#topic+poisson">poisson</a></code>.</p>
</td></tr>
<tr><td><code id="zi_test_+3A_alternative">alternative</code></td>
<td>
<p>The alternative hypothesis. One of <code>c("inflated", "deflated", "both")</code>.
These correspond to an upper tail, lower tail, or two-tailed test, respectively.
Default is <code>"inflated"</code>. Partial matching supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test compares the
observed proportion of zeros in the data to the expected proportion of zeros
under the null hypothesis of a Poisson distribution. This is done using
estimating equations to account for the fact that the expected proportion is
based on an estimated parameter vector, rather than the true parameter vector.
The test statistic is
</p>
<p><code class="reqn">\hat s = 1/n\sum_i (r_i - \hat p_i)</code>
</p>
<p>where <code class="reqn">r_i = 1</code> if <code class="reqn">y_i = 0</code>, otherwise <code class="reqn">r_i = 0</code>, and <code class="reqn">\hat p = dpois(0, exp(X\hat\beta)) = \hat E(r_i)</code>
is the estimated proportion of zeros under the assumption of a Poisson distribution
generated with covariates <code class="reqn">X</code> and parameter vector <code class="reqn">\hat\beta</code>.
</p>
<p>By the central limit theorem, <code class="reqn">\hat s \sim AN(0, \sigma^2_s)</code>. However,
estimating <code class="reqn">\hat \sigma_s</code> by a plug-in estimate using <code class="reqn">\hat\beta</code> is inefficient
due to <code class="reqn">\hat \beta</code> being an random variable with its own variance. Thus,
<code class="reqn">\hat\sigma</code> is estimated via estimating equations in order to account for the
variance in <code class="reqn">\hat \beta</code>.
</p>
<p>See the references below for more discussion and proofs.
</p>


<h3>Author(s)</h3>

<p>John Niehaus
</p>


<h3>References</h3>

<p>He, H., Zhang, H., Ye, P., &amp; Tang, W. (2019). A test of inflated
zeros for Poisson regression models. Statistical methods in medical research,
28(4), 1157-1169.
</p>
<p>Tang, Y., &amp; Tang, W. (2019). Testing modified zeros for Poisson regression
models. Statistical Methods in Medical Research, 28(10-11), 3123-3141.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n = 500
u = rpois(n, 3)
y1 = rzip(n, 12, .2) + u
y2 = rpois(n, 8) + u

# Single parameter test, covariates can be added though.
uni1 = glm(y1 ~ 1, family = poisson())
uni2 = glm(y2 ~ 1, family = poisson())

biv = bizicount(y1~1, y2~1, margins = c("pois", "pois"), keep = TRUE)

zi_test(uni1)
zi_test(uni2)

zi_test(biv)
</code></pre>

<hr>
<h2 id='zic.reg'>Univariate zero-inflated Poisson and negative binomial regression models</h2><span id='topic+zic.reg'></span>

<h3>Description</h3>

<p>This function from the <code><a href="#topic+bizicount">bizicount</a></code> package estimates
univariate zero-inflated Poisson and negative binomial regression models
via maximum likelihood using either the <code><a href="stats.html#topic+nlm">nlm</a></code> or
<code><a href="stats.html#topic+optim">optim</a></code> optimization functions.  It's class has
associated <code><a href="stats.html#topic+simulate">simulate</a></code> methods for post-estimation
diagnostics using the <code>DHARMa</code> package, as well as an
<code><a href="texreg.html#topic+extract">extract</a></code> method for printing professional tables using
<code><a href="texreg.html#topic+texreg">texreg</a></code>. Visit the 'See Also' section for links to these
methods for <code>zicreg</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zic.reg(
  fmla = NULL,
  data,
  dist = "pois",
  link.ct = "log",
  link.zi = "logit",
  optimizer = "nlm",
  starts = NULL,
  subset,
  na.action,
  weights = rep(1, length(y)),
  X = NULL,
  z = NULL,
  y = NULL,
  offset.ct = NULL,
  offset.zi = NULL,
  warn.parent = T,
  keep = F,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zic.reg_+3A_fmla">fmla</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> of the form <code style="white-space: pre;">&#8288;y ~ x_1 + x_2 + ... + x_n + offset(count_var) | z_1  + ... z_n + offset(zi_var)&#8288;</code>, where the <code>x</code>
values are covariates in the count portion of the model, and <code>z</code> are in the
zero-inflation portion. The <code>z</code> and <code>x</code> variables can be the same. If <code>NULL</code>,
design matrices, the response vector, and offsets can be entered directly; see
<code>X</code>, <code>z</code>, <code>y</code>, <code>offset.ct</code>, and <code>offset.zi</code> below.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing all variables
appearing in <code>fmla</code>, including offsets. If not specified, variables are
searched for in parent environment.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_dist">dist</code></td>
<td>
<p>The distribution used for the count portion of the zero-inflated
mixture. One of <code>c("pois", "nbinom")</code>, partial matching supported.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_link.ct">link.ct</code></td>
<td>
<p>String specifying the link function used for the count portion
of the mixture distribution. One of <code>c("log", "identity", "sqrt")</code>.
See <code><a href="stats.html#topic+family">family</a></code>.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_link.zi">link.zi</code></td>
<td>
<p>Character string specifying the link function used for the
zero-inflation portion of the mixture distribution. One of <code>c("logit", "probit", "cauchit", "log", "cloglog")</code>. See <code><a href="stats.html#topic+family">family</a></code>.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_optimizer">optimizer</code></td>
<td>
<p>String specifying the optimizer to be used for fitting, one
of <code>c("nlm", "optim")</code>. If <code>"optim"</code>, defaults to <code>method="BFGS"</code>.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_starts">starts</code></td>
<td>
<p>Optional vector of starting values used for the numerical
optimization procedure. Should have count parameters first (with intercept
first, if applicable), followed by zero-inflated parameters (with intercept
first, if applicable), and the inverse dispersion parameter last (if
applicable).</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_subset">subset</code></td>
<td>
<p>Vector indicating the subset of observations on which to
estimate the model</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen when the data
contain NAs. Default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector of weights for each observation.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_x">X</code>, <code id="zic.reg_+3A_z">z</code></td>
<td>
<p>If <code>fmla = NULL</code>, these are the design matrices of covariates for
the count and zero-inflation portions, respectively. Both require no
missingness. Similar in spirit to <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> in that it
can be faster for larger datasets because it bypasses model matrix
creation.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_y">y</code></td>
<td>
<p>If <code>fmla = NULL</code>, a vector containing the response variable.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_offset.ct">offset.ct</code>, <code id="zic.reg_+3A_offset.zi">offset.zi</code></td>
<td>
<p>If <code>fmla = NULL</code>, vectors containing the
(constant) offset for the count and zero-inflated portions, respectively.
Must be equal in length to <code>y</code>, and row-dim of <code>X</code>, <code>z</code>. If left <code>NULL</code>,
defaults to <code>rep(0, length(y))</code>.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_warn.parent">warn.parent</code></td>
<td>
<p>Logical indicating whether to warn about <code>data</code> not
being supplied.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_keep">keep</code></td>
<td>
<p>Logical indicating whether to keep the model matrices in the
returned model object. Must be <code>TRUE</code> to use <code>DHARMa</code>
and <code><a href="texreg.html#topic+texreg">texreg</a></code> with the model object, e.g., via
<code><a href="#topic+simulate.zicreg">simulate.zicreg</a></code> and <code><a href="#topic+extract.zicreg">extract.zicreg</a></code>, as well as
base generics like <code><a href="stats.html#topic+fitted">fitted</a></code> and
<code><a href="stats.html#topic+predict">predict</a></code>.</p>
</td></tr>
<tr><td><code id="zic.reg_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass on to the chosen optimizer, either
<code><a href="stats.html#topic+nlm">nlm</a></code> or <code><a href="stats.html#topic+optim">optim</a></code>. See 'Examples'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 <code><a href="#topic+zicreg-class">zicreg-class</a></code> object, which is a list containing:
</p>

<ul>
<li>  <p><code>call</code> &ndash; The original function call
</p>
</li>
<li>  <p><code>obj</code> &ndash; The class of the object
</p>
</li>
<li>  <p><code>coef</code> &ndash; Vector of coefficients, with count, then zi, then dispersion.
</p>
</li>
<li>  <p><code>se</code> &ndash; Vector of asymptotic standard errors
</p>
</li>
<li>  <p><code>grad</code> &ndash; Gradient vector at convergence
</p>
</li>
<li>  <p><code>link.ct</code> &ndash; Name of link used for count portion
</p>
</li>
<li>  <p><code>link.zi</code> &ndash; Name of link used for zero-inflated portion
</p>
</li>
<li>  <p><code>dist</code> &ndash; Name of distribution used for count portion
</p>
</li>
<li>  <p><code>optimizer</code> &ndash; Name of optimization package used in fitting
</p>
</li>
<li>  <p><code>coefmat.ct</code> &ndash; Coefficient matrix for count portion
</p>
</li>
<li>  <p><code>coefmat.zi</code> &ndash; Coefficient matrix for zero-inflated portion
</p>
</li>
<li>  <p><code>convergence</code> &ndash; Convergence code from optimization routine.
</p>
</li>
<li>  <p><code>coefmat.all</code> &ndash; Coefficient matrix for both parts of the model
</p>
</li>
<li>  <p><code>theta</code> &ndash; Coefficient matrix for dispersion, if applicable.
</p>
</li>
<li>  <p><code>covmat</code> &ndash; Asymptotic covariance matrix
</p>
</li>
<li>  <p><code>nobs</code> &ndash; Number of observations
</p>
</li>
<li>  <p><code>aic</code> &ndash; Akaike information
</p>
</li>
<li>  <p><code>bic</code> &ndash; Bayes information
</p>
</li>
<li>  <p><code>loglik</code> &ndash; Log-likelihood at convergence
</p>
</li>
<li>  <p><code>model</code> &ndash; List containing model matrices if <code>keep = TRUE</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>John Niehaus
</p>


<h3>References</h3>

<p>Lambert, Diane. &quot;Zero-inflated Poisson regression, with an
application to defects in manufacturing.&quot; Technometrics 34.1 (1992): 1-14.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.zicreg">simulate.zicreg</a></code>, <code><a href="#topic+extract.zicreg">extract.zicreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ZIP example
# Simulate some zip data
n=1000
x = cbind(1, rnorm(n))
z = cbind(1, rbeta(n, 4, 8))
b = c(1, 2.2)
g = c(-1, 1.7)
lam = exp(x %*% b)
psi = plogis(z %*% g)

y = bizicount::rzip(n, lambda = lam, psi=psi)
dat = cbind.data.frame(x = x[,-1], z = z[,-1], y = y)

# estimate zip model using NLM, no data.frame

mod = zic.reg(y ~ x[,-1] | z[,-1])

# same model, with dataframe

mod = zic.reg(y ~ x | z, data = dat)


# estimate zip using NLM, adjust stepmax via ... param

mod = zic.reg(y ~ x[,-1] | z[,-1], stepmax = .5)


# estimate zip using optim

mod = zic.reg(y ~ x[,-1] | z[,-1], optimizer = "optim")


# pass different method, reltol to optim using ... param

mod = zic.reg(y ~ x[,-1] | z[,-1],
        optimizer = "optim",
        method = "Nelder-Mead",
        control = list(reltol = 1e-10)
        )

# No formula, specify design matrices and offsets.
zic.reg(y=y, X=x, z=z)



## ZINB example
# simulate zinb data

disp = .5
y = bizicount::rzinb(n, psi = psi, size = disp, mu=lam)


# zinb model, use keep = TRUE for post-estimation methods

mod = zic.reg(y ~ x[,-1] | z[,-1], dist = "n", keep = TRUE)

print(mod)
summary(mod)

</code></pre>

<hr>
<h2 id='zicreg-class'>The zicreg S4 Class</h2><span id='topic+zicreg-class'></span>

<h3>Description</h3>

<p>Note that <code>zicreg</code> objects are, in general, S3. However,
this S4 class is defined for compatability with <code><a href="texreg.html#topic+texreg">texreg</a></code>.
Interaction with <code>zicreg</code> objects should generally use S3 syntax, but the below
objects have the same name in both the S3 and S4 objects (but are in a list for S3).
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>The original function call</p>
</dd>
<dt><code>obj</code></dt><dd><p>The class of the object</p>
</dd>
<dt><code>coef</code></dt><dd><p>Vector of coefficients, with count, then zi, then dispersion.</p>
</dd>
<dt><code>se</code></dt><dd><p>Vector of asymptotic standard errors</p>
</dd>
<dt><code>grad</code></dt><dd><p>Gradient vector at convergence</p>
</dd>
<dt><code>link.ct</code></dt><dd><p>Name of link used for count portion</p>
</dd>
<dt><code>link.zi</code></dt><dd><p>Name of link used for zero-inflated portion</p>
</dd>
<dt><code>dist</code></dt><dd><p>Name of distribution used for count portion</p>
</dd>
<dt><code>optimizer</code></dt><dd><p>Name of optimization package used in fitting</p>
</dd>
<dt><code>coefmat.ct</code></dt><dd><p>Coefficient matrix for count portion</p>
</dd>
<dt><code>coefmat.zi</code></dt><dd><p>Coefficient matrix for zero-inflated portion</p>
</dd>
<dt><code>convergence</code></dt><dd><p>Convergence code from optimization routine.</p>
</dd>
<dt><code>coefmat.all</code></dt><dd><p>Coefficient matrix for both parts of the model</p>
</dd>
<dt><code>theta</code></dt><dd><p>Coefficient matrix for dispersion, if applicable.</p>
</dd>
<dt><code>covmat</code></dt><dd><p>Asymptotic covariance matrix</p>
</dd>
<dt><code>nobs</code></dt><dd><p>Number of observations</p>
</dd>
<dt><code>aic</code></dt><dd><p>Akaike information</p>
</dd>
<dt><code>bic</code></dt><dd><p>Bayes information</p>
</dd>
<dt><code>loglik</code></dt><dd><p>Log-likelihood at convergence</p>
</dd>
<dt><code>model</code></dt><dd><p>List containing model matrices if <code>keep = TRUE</code></p>
</dd>
</dl>

<hr>
<h2 id='zinb'>The zero-inflated negative binomial (ZINB) distribution</h2><span id='topic+zinb'></span><span id='topic+dzinb'></span><span id='topic+pzinb'></span><span id='topic+qzinb'></span><span id='topic+rzinb'></span>

<h3>Description</h3>

<p>These functions are used to evaluate the zero-inflated negative binomial
distribution's probability mass function (PMF), cumulative distribution
function (CDF), and quantile function (inverse CDF), as well as generate
random realizations from the ZINB distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzinb(
  x,
  size,
  psi,
  mu = NULL,
  prob = NULL,
  lower.tail = TRUE,
  log = FALSE,
  recycle = FALSE
)

pzinb(
  q,
  size,
  psi,
  mu = NULL,
  prob = NULL,
  lower.tail = TRUE,
  log.p = FALSE,
  recycle = FALSE
)

qzinb(
  p,
  size,
  psi,
  mu = NULL,
  prob = NULL,
  lower.tail = TRUE,
  log.p = FALSE,
  recycle = FALSE
)

rzinb(n, size, psi, mu = NULL, prob = NULL, recycle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zinb_+3A_x">x</code>, <code id="zinb_+3A_q">q</code></td>
<td>
<p>Vector of quantiles at which to evaluate the PMF and CDF,
respectively. Should be non-negative integers.</p>
</td></tr>
<tr><td><code id="zinb_+3A_size">size</code></td>
<td>
<p>The inverse dispersion parameter, or number of successful trials,
both for the negative binomial portion of the ZINB mixture distribution.
See <code><a href="stats.html#topic+dnbinom">nbinom</a></code>.</p>
</td></tr>
<tr><td><code id="zinb_+3A_psi">psi</code></td>
<td>
<p>Vector of zero-inflation probabilities.</p>
</td></tr>
<tr><td><code id="zinb_+3A_mu">mu</code></td>
<td>
<p>Vector of means for the count portion of the zero-inflated negative
binomial distribution. Only one of <code>mu</code> or <code>prob</code> should be specified, not
both. Should be non-negative. NOTE: This is <em>not</em> the mean of the ZINB
distribution; it is the mean of the NB component of the mixture
distribution. See <code><a href="stats.html#topic+dnbinom">nbinom</a></code>.</p>
</td></tr>
<tr><td><code id="zinb_+3A_prob">prob</code></td>
<td>
<p>The probability of success on each trial in the negative binomial portion of the mixture distribution. Only one of <code>mu</code> or
<code>prob</code> should be specified, not both. See <code><a href="stats.html#topic+dnbinom">nbinom</a></code>.</p>
</td></tr>
<tr><td><code id="zinb_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical indicating whether probabilities should be
<code class="reqn">Pr(X \le x)</code> or <code class="reqn">Pr(X &gt; x)</code></p>
</td></tr>
<tr><td><code id="zinb_+3A_log">log</code>, <code id="zinb_+3A_log.p">log.p</code></td>
<td>
<p>Logical indicating whether probabilities should be returned
on log scale (for <code>dzip</code> and <code>pzip</code>), or are supplied on log-scale (for <code>qzip</code>).</p>
</td></tr>
<tr><td><code id="zinb_+3A_recycle">recycle</code></td>
<td>
<p>Logical indicating whether to permit arbitrary recycling of
arguments with unequal length. See 'Details' and 'Examples.'</p>
</td></tr>
<tr><td><code id="zinb_+3A_p">p</code></td>
<td>
<p>Vector of probabilities at which to evaluate the quantile function.</p>
</td></tr>
<tr><td><code id="zinb_+3A_n">n</code></td>
<td>
<p>Number of realizations to generate from the distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dzinb</code> returns the mass function evaluated at <code>x</code>,
<code>pzinb</code> returns the CDF evaluated at <code>q</code>, <code>qzinb</code> returns the quantile
function evaluated at <code>p</code>, and <code>rzinb</code> returns random realizations with the
specified parameters.
</p>


<h3>Author(s)</h3>

<p>John Niehaus
</p>


<h3>References</h3>

<p>Lambert, Diane. &quot;Zero-inflated Poisson regression, with an
application to defects in manufacturing.&quot; Technometrics 34.1 (1992): 1-14.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># zero-inflated negative binomial examples

# two unique lengthed arguments, one is length 1 though. No error.

dzinb(4, size=.25, mu= c(1,2,3), psi=c(.2, .1, .15))


# two unique lengthed arguments, one of them is not length 1
# error
## Not run: 

     dzinb(5, size=c(.25, .3), mu= c(1,2,3), psi=c(.2, .1, .15))


## End(Not run)


# two unique lengthed arguments, one of them is not length 1, set
# recycle = T, no error but can give innacurate results.

dzinb(5, size=c(.25, .3), mu= c(1,2,3), psi=c(.2, .1, .15), recycle=TRUE)
</code></pre>

<hr>
<h2 id='zip'>The zero-inflated Poisson (ZIP) distribution</h2><span id='topic+zip'></span><span id='topic+dzip'></span><span id='topic+rzip'></span><span id='topic+pzip'></span><span id='topic+qzip'></span>

<h3>Description</h3>

<p>These functions are used to evaluate the zero-inflated Poisson
distribution's probability mass function (PMF), cumulative distribution
function (CDF), and quantile function (inverse CDF), as well as generate
random realizations from the ZIP distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzip(x, lambda, psi, log = FALSE, recycle = FALSE)

rzip(n, lambda, psi, recycle = FALSE)

pzip(q, lambda, psi, lower.tail = TRUE, log.p = FALSE, recycle = FALSE)

qzip(p, lambda, psi, lower.tail = TRUE, log.p = FALSE, recycle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zip_+3A_x">x</code>, <code id="zip_+3A_q">q</code></td>
<td>
<p>Vector of quantiles at which to evaluate the PMF and CDF,
respectively. Should be non-negative integers.</p>
</td></tr>
<tr><td><code id="zip_+3A_lambda">lambda</code></td>
<td>
<p>Vector of means for the count portion of the zero-inflated
Poisson distribution. Should be non-negative. NOTE: This is <em>not</em> the mean
of the zero-inflated Poisson distribution; it is the mean of the Poisson
component of the mixture distribution. See 'Details.'</p>
</td></tr>
<tr><td><code id="zip_+3A_psi">psi</code></td>
<td>
<p>Vector of zero-inflation probabilities.</p>
</td></tr>
<tr><td><code id="zip_+3A_log">log</code>, <code id="zip_+3A_log.p">log.p</code></td>
<td>
<p>Logical indicating whether probabilities should be returned
on log scale (for <code>dzip</code> and <code>pzip</code>), or are supplied on log-scale (for <code>qzip</code>).</p>
</td></tr>
<tr><td><code id="zip_+3A_recycle">recycle</code></td>
<td>
<p>Logical indicating whether to permit arbitrary recycling of
arguments with unequal length. See 'Details' and 'Examples.'</p>
</td></tr>
<tr><td><code id="zip_+3A_n">n</code></td>
<td>
<p>Number of realizations from the distribution to generate</p>
</td></tr>
<tr><td><code id="zip_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical indicating whether probabilities should be
<code class="reqn">Pr(X \le x)</code> or <code class="reqn">Pr(X &gt; x)</code></p>
</td></tr>
<tr><td><code id="zip_+3A_p">p</code></td>
<td>
<p>Vector of probabilities at which to evaluate the quantile function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero inflated Poisson distribution is a mixture of a Poisson
and a degenerate point-mass at 0. It has the form
</p>
<p style="text-align: center;"><code class="reqn">\psi + (1-\psi)(\lambda^x e^-\lambda)/x!</code>
</p>
<p>, with mean
<code class="reqn">(1-\psi)\lambda</code>. Thus, the parameter <code>lambda</code> above is the mean of
the Poisson distribution that forms part of the zero-inflated
distribution, <em>not</em> the mean of the ZIP distribution.
</p>
<p><code>recycle</code> &ndash; If <code>FALSE</code> (default), all arguments must have identical
length, there can be two unique lengths for the arguments, provided that
one of those lengths is 1. For example, <code>lambda = c(1,2,3)</code> and <code>psi=.5</code>
is acceptable because there are two unique lengths, and one of them is
length 1. However, <code>lambda=c(1,2,3)</code> and <code>psi=c(.5,.2)</code> would fail, as
there are two distinct lengths, none of which is 1. If <code style="white-space: pre;">&#8288;TRUE,&#8288;</code> no
additional checks (beyond those in base R's functions) are made to ensure
that the argument vectors have the same length.
</p>


<h3>Value</h3>

<p><code>dzip</code> returns the mass function evaluated at <code>x</code>,
<code>pzip</code> returns the CDF evaluated at <code>q</code>, <code>qzip</code> returns the quantile
function evaluated at <code>p</code>, and <code>rzip</code> returns random variates with the
specified parameters.
</p>


<h3>Author(s)</h3>

<p>John Niehaus
</p>


<h3>References</h3>

<p>Lambert, Diane. &quot;Zero-inflated Poisson regression, with an
application to defects in manufacturing.&quot; Technometrics 34.1 (1992): 1-14.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unequal lengths, but one of them is length 1, others are same length (3).
# No error.

x = c(1,2,3)
lambda = c(3,4,5)
psi = .1

dzip(x, lambda, psi)


# unequal lengths, at least one of them is not length 1,
# error

## Not run: 

x = c(1,2,3)
lambda = c(3,4)
psi = .1

dzip(x, lambda, psi)


## End(Not run)

# unequal lengths, at least one of them is not length 1.
# but set recycle = T to permit arbitrary recycling.

x = c(1,2,3)
lambda = c(3,4)
psi = .1

dzip(x, lambda, psi, recycle=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
