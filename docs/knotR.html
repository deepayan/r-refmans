<!DOCTYPE html><html><head><title>Help for package knotR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {knotR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as'>
<p>Conversions between various forms of a knot</p></a></li>
<li><a href='#badness'><p>Badness of knots</p></a></li>
<li><a href='#bezier'>
<p>Various functionality for Bezier curves</p></a></li>
<li><a href='#bezier_angle'><p>Intersection of two Bezier curves</p></a></li>
<li><a href='#bezier_find_length'><p>Solve for arclength</p></a></li>
<li><a href='#bezier_integrals'>
<p>Arcwise integrals over Bezier curves</p></a></li>
<li><a href='#crossing'>
<p>Crossing Metrics for knots</p></a></li>
<li><a href='#getstringpoints'>
<p>Returns the coordinates of a knot's path</p></a></li>
<li><a href='#head.inkscape'>
<p>Head and tail methods for inkscape objects</p></a></li>
<li><a href='#knotoptim'><p>Optimization of knot appearance</p></a></li>
<li><a href='#knotplot'>
<p>Plotting of knots</p></a></li>
<li><a href='#knotR-package'>
<p>Knot Diagrams using Bezier Curves</p></a></li>
<li><a href='#knots'><p>Optimized knots</p></a></li>
<li><a href='#overunder'><p>Functionality for specifying overstrands and understrands</p></a></li>
<li><a href='#reader'><p>Reading and writing svg files</p></a></li>
<li><a href='#symmetrize'><p>Symmetry and knots</p></a></li>
<li><a href='#utilities'><p>Various utilities for knots</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Knot Diagrams using Bezier Curves</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-4</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Description:</td>
<td>Makes visually pleasing diagrams of knot projections using optimized Bezier curves.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-22 19:56:20 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as'>
Conversions between various forms of a knot
</h2><span id='topic+as'></span><span id='topic+as.knotvec'></span><span id='topic+as.minobj'></span><span id='topic+as.controlpoints'></span><span id='topic+as.inkscape'></span><span id='topic+as.minsymvec'></span>

<h3>Description</h3>

<p>Conversions between various forms of a knot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.knotvec(x)
as.minobj(x)
as.inkscape(x)
as.controlpoints(x)
as.minsymvec(x,symobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_+3A_x">x</code></td>
<td>
<p>Object to be converted</p>
</td></tr>
<tr><td><code id="as_+3A_symobj">symobj</code></td>
<td>
<p>A symmetry object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>as.foo()</code> functions are meant to be user-friendly; they use
low-level functions like <code>make_knotvec_from_minobj()</code> (all of
which are documented at <code>utilities.Rd</code>), which are a bit messy.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+utilities">utilities</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>as.minobj(k6_2)

x &lt;- reader(system.file("6_3.svg",package="knotR"))  # x is class inkscape

as.minsymvec(x,symmetry_object(k6_3)) # as.minsymvec() needs a symmetry object

as.controlpoints(x)

as.knotvec(x)


</code></pre>

<hr>
<h2 id='badness'>Badness of knots</h2><span id='topic+badness'></span><span id='topic+curvature_switching_badness'></span><span id='topic+curvature_consecutive_segment_switching_badness'></span><span id='topic+midpoint_badness'></span><span id='topic+node_crossing_badness'></span><span id='topic+total_string_length'></span><span id='topic+total_bending_energy'></span><span id='topic+total_crossing_potential_energy'></span><span id='topic+total_crossing_angles'></span><span id='topic+total_crossing_angle_badness'></span><span id='topic+always_left_badness'></span><span id='topic+metrics'></span><span id='topic+non_crossing_strand_close_approach_badness'></span>

<h3>Description</h3>

<p>Various functions that calculate different aspects of
the badness of a knot, generally with low values representing
pleasing visual representations</p>


<h3>Usage</h3>

<pre><code class='language-R'>badness(b, cpb, weights, prob=0, give=FALSE)
curvature_switching_badness(b)
curvature_consecutive_segment_switching_badness(b, ...)
midpoint_badness(b,cpb)
node_crossing_badness(b,cpb)
total_string_length(b)
total_bending_energy(b,power=2)
total_crossing_potential_energy(b,cpb)
total_crossing_angle_badness(b,cpb)
metrics(b,cpb)
always_left_badness(b)
non_crossing_strand_close_approach_badness(b,cpb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="badness_+3A_b">b</code></td>
<td>
<p>A description of a knot, coerced to a <code>controlpoints</code>
object</p>
</td></tr>
<tr><td><code id="badness_+3A_cpb">cpb</code></td>
<td>
<p>Optional argument containing information on crossing
points (it is short for &lsquo;<code>crossing_points(b)</code>&rsquo;).  It is
time-consuming to calculate, so providing a precalculated value
makes the code run faster</p>
</td></tr>
<tr><td><code id="badness_+3A_prob">prob</code></td>
<td>
<p>In function <code>badness()</code>, the probability of plotting
a knotplot.  I used nonzero values  in the early stages of
developing the package: when optimizing a knot it was useful to
keep tabs on the process</p>
</td></tr>
<tr><td><code id="badness_+3A_give">give</code></td>
<td>
<p>In function <code>badness()</code>, Boolean with default
<code>FALSE</code> meaning to return the sum of the badnesses, and
<code>TRUE</code> meaning to return them separately</p>
</td></tr>
<tr><td><code id="badness_+3A_power">power</code></td>
<td>
<p>Function <code>total_bending_energy()</code> returns the arc
integral of <code class="reqn">R^{-p}</code>; defaults to 2</p>
</td></tr>
<tr><td><code id="badness_+3A_weights">weights</code></td>
<td>
<p>A vector of weights specifying the relative importance
of the various badness measures.  See details</p>
</td></tr>
<tr><td><code id="badness_+3A_...">...</code></td>
<td>
<p>In function
<code>curvature_consecutive_segment_switching_badness()</code>, extra
arguments passed to <code>integrate()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Various functions that calculate different aspects of the badness of a
knot, generally with low values representing pleasing visual
representations.  Function <code>badness()</code> returns a weighted sum of
nine individual badnesses.
</p>
<p>The list below details the values returned by <code>metrics()</code>; the
description of each item is the name of corresponding weight assigned by
the <code>weights</code> argument of <code>badness()</code>.
</p>

<dl>
<dt>pot</dt><dd><p>Function <code>total_crossing_potential_energy()</code> gives the
potential energy of the nodes, under an inverse square force law</p>
</dd>
<dt>ang</dt><dd><p>Function <code>total_crossing_angle_badness()</code> returns a high value if
strands cross at angles far from 90 degrees.  It returns the sum, over
all crossings, of <code>bezier_angle()</code></p>
</dd>
<dt>ben</dt><dd><p>Function <code>total_bending_energy()</code> gives the total bending
energy, effectively the arc integral of the reciprocal of the square
of the radius of curvature</p>
</dd>
<dt>len</dt><dd><p>Function <code>total_string_length()</code> returns <code class="reqn">\ell</code>, the
total string length.  The badness is proportional to
<code class="reqn">(\ell-5000)^2</code>.  A length of 5000 corresponds to
knots that look about right on a sheet of A4 paper</p>
</dd>
<dt>mid</dt><dd><p>Function <code>midpoint_badness()</code> penalizes knots with
crossing points far from the midpoint of segments</p>
</dd>
<dt>clo</dt><dd><p>Function <code>node_crossing_badness()</code> penalizes knots with
nodes too close together (compare function
<code>total_crossing_potential_energy()</code>)</p>
</dd>
<dt>swi</dt><dd><p>Function <code>curvature_switching_badness()</code> provides a
penalty for consecutive segments with curvatures that switch sign.
The magnitude of the penalty is zero if both curvatures are of the
same sign, otherwise proportional to the square of the minimum of
the maximum value of the absolute value of the positive and negative
curvatures.  The source code is easier to look at, honest</p>
</dd>
<dt>con</dt><dd><p>Function
<code>curvature_consecutive_segment_switching_badness()</code> penalizes
knots with consecutive segments that switch curvature from positive
to negative</p>
</dd>
<dt>ncn</dt><dd><p>Function <code>always_left_badness()</code> penalizes knots that are
<em>supposed</em> to curve to the left all the time (eg knot
<code class="reqn">8_{18}</code>).  The penalty is proportional to the greatest
rightward curvature over the whole knot</p>
</dd>
</dl>

<p>The <code>weights</code> argument is nominally a vector of length 9 which is
used to assign weights to different aspects of the badness of a knot.
</p>


<h3>Value</h3>

<p>Returns a scalar badness</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossing">crossing</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

# use the k_infinity knot for speed:

system.time(badness(k_infinity))

cc &lt;- crossing_points(k_infinity)

system.time(badness(k_infinity,cc))

metrics(k_infinity,cc)



## default:
badness(k_infinity, weights=c(1,1,1,1,1,1,1,1,1))


## downweight the importance of strands crossing at 90 degrees:
badness(k_infinity, weights=c(1,0.1,1,1,1,1,1,1,1))

</code></pre>

<hr>
<h2 id='bezier'>
Various functionality for Bezier curves
</h2><span id='topic+bezier'></span><span id='topic+bezier_deriv'></span><span id='topic+bezier_deriv2'></span><span id='topic+bezier_length'></span><span id='topic+bezier_radius'></span><span id='topic+bezier_curvature'></span><span id='topic+myseg'></span>

<h3>Description</h3>

<p>Various functionality for Bezier curves including derivatives and radius
of curvature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bezier(P, tee, n=100)
bezier_deriv(P, tee, n=100)
bezier_deriv2(P, tee, n=100)
bezier_radius(P, tee, n=100)
bezier_curvature(P,tee,n=100)
myseg(P, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bezier_+3A_p">P</code></td>
<td>
<p>Control points in the form of a 4 by 2 matrix with rows
corresponding to <code class="reqn">P_0</code> to <code class="reqn">P_3</code></p>
</td></tr>
<tr><td><code id="bezier_+3A_tee">tee</code></td>
<td>
<p>Parametric variable <code class="reqn">t</code></p>
</td></tr>
<tr><td><code id="bezier_+3A_n">n</code></td>
<td>
<p>Integer specifying number of points between 0 and 1 to use.
Default value of 100 looks OK</p>
</td></tr>
<tr><td><code id="bezier_+3A_...">...</code></td>
<td>
<p>Further arguments passed by <code>myseg()</code> to <code>points()</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Function <code>bezier()</code> returns a two column matrix with rows
corresponding to the positions of the specified Bezier curve.
</p>
</li>
<li><p> Functions <code>bezier_deriv()</code> and <code>bezier_deriv2()</code>
give the first and second derivatives respectively.
</p>
</li>
<li><p> Function <code>bezier_radius()</code> gives the radius of curvature.
</p>
</li>
<li><p> Functions <code>bezier_length()</code> and
<code>bezier_bending_energy()</code> use numerical quadrature to give the
arc length and bending energy (<code class="reqn">\int R^{-1}ds</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bezier_angle">bezier_angle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

P &lt;- matrix(c(0, 1, 2, 2, 2, 0, 3, 2),4,2)
xy &lt;- bezier(P,n=100)
dx &lt;- bezier_deriv(P,n=100)

plot(xy,asp=1)
myseg(P)

plot(xy,asp=1,cex=sqrt(rowSums(dx^2))/3.2)

plot(xy,asp=1)
segments(xy[,1],xy[,2],(xy+dx/200)[,1],(xy+dx/200)[,2])


plot(xy, asp=1,cex=bezier_radius(P,n=100)/2)

lapply(as.controlpoints(k8_9),bezier_radius)
lapply(as.controlpoints(k8_9),bezier_arclength)

</code></pre>

<hr>
<h2 id='bezier_angle'>Intersection of two Bezier curves</h2><span id='topic+bezier_angle'></span><span id='topic+bezier_intersect'></span>

<h3>Description</h3>

<p>Description of the intersection of two Bezier curves including position
and angle of the point of intersection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bezier_angle(P1, P2)
bezier_intersect(P1,P2, type='pos', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bezier_angle_+3A_p1">P1</code>, <code id="bezier_angle_+3A_p2">P2</code></td>
<td>
<p>Control points for two Bezier curves as per
<code>bezier()</code></p>
</td></tr>
<tr><td><code id="bezier_angle_+3A_type">type</code></td>
<td>
<p>In function <code>bezier_intersect()</code>, string argument
governing what exactly is to be returned; see details.</p>
</td></tr>
<tr><td><code id="bezier_angle_+3A_...">...</code></td>
<td>
<p>In function <code>bezier_intersect()</code>, further arguments
passed to <code>constOptim()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>bezier_intersect()</code> uses <code>constOptim()</code> to find
the point of closest approach.
</p>
<p>Function <code>bezier_angle()</code> returns the square of the cosine of the
intersection angle (so strands crossing at right angles return zero).
If the strands do not intersect, then return 1.  This is needed
because sometimes, strands which intersect are perturbed by the
optimization routine so that they are disjoint.
</p>
<p>In function <code>bezier_intersect()</code>, argument <code>type</code> may take
the following values:
</p>

<dl>
<dt>pos</dt><dd><p>Position of intersection point</p>
</dd>
<dt>cons</dt><dd><p>Boolean, indicating whether the strands abut; the
&lsquo;intersection&rsquo; point is the end of one curve and the
beginning of the other</p>
</dd>
<dt>bool</dt><dd><p>Boolean, indicating whether or not the strands actually
intersect</p>
</dd>
<dt>para</dt><dd><p>Bezier parameter <code class="reqn">t</code> for the intersection point;
actually return two parameters, one for each curve</p>
</dd>
<dt>opt</dt><dd><p>Details of the optimization output</p>
</dd>
<dt>all</dt><dd><p>Everything</p>
</dd>
</dl>



<h3>Note</h3>

<p>If the curves intersect in more than one point, the behaviour of these
routines is not defined.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+bezier">bezier</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>


P1 &lt;- matrix(c(1, 3, 6, 4, 7, 3, 2, 2),ncol=2)
P2 &lt;- matrix(c(4, 5, 5, 3, 7, 2, 5, 1),ncol=2)

x1 &lt;- bezier(P1,n=100)
x2 &lt;- bezier(P2,n=100)

plot(x1,asp=1,xlim=c(0,8),ylim=c(0,8))
points(x2)

myseg(P1)
myseg(P2)

jj &lt;- bezier_intersect(P1,P2)
points(x=jj[1],y=jj[2],pch=16,cex=3,col='blue')

# looks close to orthogonal, actually 82 degrees:
acos(sqrt(bezier_angle(P1,P2)))*180/pi 


</code></pre>

<hr>
<h2 id='bezier_find_length'>Solve for arclength</h2><span id='topic+bezier_find_length'></span>

<h3>Description</h3>

<p>Finds the value of the Bezier parameter <code class="reqn">t</code> that corresponds to a
given arclength from the start of a Bezier curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bezier_find_length(P, len, from = 0, increasing = TRUE, give = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bezier_find_length_+3A_p">P</code></td>
<td>
<p>Control points in the form of a 4 by 2 matrix with rows
corresponding to <code class="reqn">P_0</code> to <code class="reqn">P_3</code></p>
</td></tr>
<tr><td><code id="bezier_find_length_+3A_from">from</code></td>
<td>
<p>Point from which to start measuring arc length</p>
</td></tr>
<tr><td><code id="bezier_find_length_+3A_len">len</code></td>
<td>
<p>Arc length</p>
</td></tr>
<tr><td><code id="bezier_find_length_+3A_increasing">increasing</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to
measure length towards the end, and<code>FALSE</code> meaning to measure
in the opposite direction</p>
</td></tr>
<tr><td><code id="bezier_find_length_+3A_give">give</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return details from
<code>uniroot()</code> and default <code>FALSE</code> meaning to give just the
position on the curve</p>
</td></tr>
<tr><td><code id="bezier_find_length_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>uniroot()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function just uses <code>uniroot()</code> to find the appropriate value
of <code>tee</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bezier_integral">bezier_integral</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
P &lt;- matrix(c(1, 3, 6, 4, 7, 3, 2, 2),ncol=2)
bezier_find_length(P,5)

</code></pre>

<hr>
<h2 id='bezier_integrals'>
Arcwise integrals over Bezier curves
</h2><span id='topic+bezier_integrals'></span><span id='topic+bezier_integral'></span><span id='topic+bezier_arclength'></span><span id='topic+bezier_bending_energy'></span><span id='topic+bezier_total_curvature'></span>

<h3>Description</h3>

<p>Various integrals over Bezier curves such as total arc length and
bending energy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bezier_arclength(P, t1=0,t2=1,give=FALSE,...)
bezier_bending_energy(P, t1=0,t2=1, give=FALSE, power=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bezier_integrals_+3A_p">P</code></td>
<td>
<p>Control points in the form of a 4 by 2 matrix with rows
corresponding to <code class="reqn">P_0</code> to <code class="reqn">P_3</code></p>
</td></tr>
<tr><td><code id="bezier_integrals_+3A_give">give</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return more
information and default <code>FALSE</code> meaning to return just the
value of the integration as estimated by the numerical routine</p>
</td></tr>
<tr><td><code id="bezier_integrals_+3A_power">power</code></td>
<td>
<p>Function <code>bezier_bending_energy()</code> returns
bending energy is <code class="reqn">\int_S\frac{ds}{R^\mathrm{power}}</code>, where <code class="reqn">R=R(s)</code> is the radius of curvature.
If <code class="reqn">\mathrm{power}=2</code> this corresponds to the Eulerian
bending energy of a flexible beam</p>
</td></tr>
<tr><td><code id="bezier_integrals_+3A_t1">t1</code>, <code id="bezier_integrals_+3A_t2">t2</code></td>
<td>
<p>In function <code>bezier_arclength()</code>, the values of
<code>t</code> to start and end the integration at</p>
</td></tr>
<tr><td><code id="bezier_integrals_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>integrate()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use numerical integration, specifically
<code>integrate()</code>, between two specified points on a Bezier curve.
</p>

<ol>
<li><p> Function <code>bezier_bending_energy()</code> gives the 
and bending energy (<code class="reqn">\int R^{-1}ds</code>).
</p>
</li>
<li><p> Function <code>bezier_arclength()</code> gives the arc length.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bezier_angle">bezier_angle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

P &lt;- matrix(c(0, 1, 2, 2, 2, 0, 3, 2),4,2)

bezier_arclength(P)

</code></pre>

<hr>
<h2 id='crossing'>
Crossing Metrics for knots
</h2><span id='topic+crossing'></span><span id='topic+crossing_points'></span><span id='topic+crossing_matrix'></span><span id='topic+crossing_points'></span><span id='topic+crossing_strands'></span>

<h3>Description</h3>

<p>Various descriptions for the crossing points of a knot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossing_points(b, give_all = TRUE)
crossing_matrix(b)
crossing_strands(b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossing_+3A_b">b</code></td>
<td>
<p>A list of Bezier control parameters, typically given by
<code>getcontrolpoints()</code></p>
</td></tr>
<tr><td><code id="crossing_+3A_give_all">give_all</code></td>
<td>
<p>In function <code>crossing_points()</code>, Boolean,
with <code>TRUE</code> meaning to give details of the strands that cross
and default <code>FALSE</code> meaning to give just the coordinates of the
crossing points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.controlpoints">as.controlpoints</a></code>,<code><a href="#topic+bezier">bezier</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
crossing_points(k7_2,give_all=TRUE)

</code></pre>

<hr>
<h2 id='getstringpoints'>
Returns the coordinates of a knot's path
</h2><span id='topic+getstringpoints'></span>

<h3>Description</h3>

<p>Returns the coordinates of a knot's path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getstringpoints(b, give_strand = FALSE, n = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getstringpoints_+3A_b">b</code></td>
<td>
<p>The knot path (coerced to <code>controlpoints</code> form)</p>
</td></tr>
<tr><td><code id="getstringpoints_+3A_give_strand">give_strand</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to
return a two-column matrix with rows corresponding to coordinates
of the knot path, and <code>TRUE</code> meaning to return a matrix with
an additional column indicating the strand number</p>
</td></tr>
<tr><td><code id="getstringpoints_+3A_n">n</code></td>
<td>
<p>The number of points to use when constructing the Bezier
curve</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a two- or three- column matrix</p>


<h3>Note</h3>

<p>Function <code>knotplot()</code> returns the points of the string too, but
with <code>NA</code> for understrands.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+knotplot">knotplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(getstringpoints(k4_1),asp=1)

a &lt;- getstringpoints(k11a179,TRUE)
plot(a,asp=1,col=rainbow(24)[a[,3]])
 
d &lt;- 1200
plot(rbind(
    sweep(getstringpoints(k7_1),2,c(0,0)),
    sweep(getstringpoints(k7_2),2,c(0,d)),
    sweep(getstringpoints(k7_3),2,c(d,0)),
    sweep(getstringpoints(k7_4),2,c(d,d))
),asp=1,xlab='',ylab='')

</code></pre>

<hr>
<h2 id='head.inkscape'>
Head and tail methods for inkscape objects
</h2><span id='topic+head.inkscape'></span><span id='topic+tail.inkscape'></span>

<h3>Description</h3>

<p>Head and tail methods for inkscape objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inkscape'
head(x, ...)
## S3 method for class 'inkscape'
tail(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head.inkscape_+3A_x">x</code></td>
<td>
<p>Primary argument, an inkscape object</p>
</td></tr>
<tr><td><code id="head.inkscape_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code>head()</code> or <code>tail()</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- reader(system.file("7_1.svg",package="knotR"))
head(a)
tail(a)

head(as.inkscape(k8_2))
</code></pre>

<hr>
<h2 id='knotoptim'>Optimization of knot appearance</h2><span id='topic+knotoptim'></span>

<h3>Description</h3>

<p>Optimization of knot appearance using user-definable objective functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knotoptim(svg, weights=1, symobj=NULL,
  Mver = NULL, xver = NULL, Mhor = NULL, xhor = NULL, Mrot = NULL,
  mcdonalds = FALSE, celtic = FALSE, ou, prob = 0, useNLM=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knotoptim_+3A_svg">svg</code></td>
<td>
<p>Name of an svg file to read</p>
</td></tr>
<tr><td><code id="knotoptim_+3A_mver">Mver</code>, <code id="knotoptim_+3A_xver">xver</code>, <code id="knotoptim_+3A_mhor">Mhor</code>, <code id="knotoptim_+3A_xhor">xhor</code>, <code id="knotoptim_+3A_mrot">Mrot</code>, <code id="knotoptim_+3A_mcdonalds">mcdonalds</code>, <code id="knotoptim_+3A_celtic">celtic</code></td>
<td>
<p>Arguments passed to
<code>symmetry_object()</code>, specifying the symmetry of the knot</p>
</td></tr>
<tr><td><code id="knotoptim_+3A_symobj">symobj</code></td>
<td>
<p>A symmetry object</p>
</td></tr>
<tr><td><code id="knotoptim_+3A_ou">ou</code></td>
<td>
<p>An overunder object</p>
</td></tr>
<tr><td><code id="knotoptim_+3A_prob">prob</code></td>
<td>
<p>The probability of plotting a knotplot; this is slow so
don't make this too big</p>
</td></tr>
<tr><td><code id="knotoptim_+3A_weights">weights</code></td>
<td>
<p>A vector of weights, defaulting to all ones, passed to
<code>badness()</code></p>
</td></tr>
<tr><td><code id="knotoptim_+3A_usenlm">useNLM</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to use
<code>nlm()</code> and <code>FALSE</code> meaning to use <code>optim()</code></p>
</td></tr>
<tr><td><code id="knotoptim_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>nlm()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>knotoptim()</code> is a generic optimization routine that
starts from an svg file and minimizes the knot's <code>badness()</code>.
</p>
<p>The <code>weights</code> argument is documented more fully at
<code>badness.Rd</code>.
</p>


<h3>Value</h3>

<p>Returns a knot object</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+symmetry_object">symmetry_object</a></code>, <code><a href="#topic+badness">badness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:     #takes too long
knotoptim(
      svg = system.file("4_1_first_draft.svg",package="knotR"),
     Mver = rbind(c(2,3),c(9,7),c(10,6),c(1,4),c(5,11)),
     xver = 8,   # node on vertical axis
     ou   = rbind( c(1,5), c(9,2), c(4,8),c(6,11)),
     prob = 0.1,
  iterlim = 100, print.level=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='knotplot'>
Plotting of knots
</h2><span id='topic+knotplot'></span><span id='topic+knotplot_old'></span><span id='topic+knotplot2'></span>

<h3>Description</h3>

<p>Routines to plot projections of knots with a wide range of user-settable options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knotplot(x, ou, gapwidth=1, n=100, lwd=8, add=FALSE, ...)
knotplot_old(x, ou, gap=20, n=100, lwd=8, add=FALSE, ...)
knotplot2(x, rainbow=FALSE, seg=FALSE, text=FALSE, cross=FALSE, ink=FALSE,
                node=FALSE, width=TRUE, all=FALSE, n=100, circ=1000,
                lwd=8, add=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knotplot_+3A_x">x</code></td>
<td>
<p>Description of a knot, coerced to a <code>controlpoints</code>
object and a <code>minobj</code> object</p>
</td></tr>
<tr><td><code id="knotplot_+3A_rainbow">rainbow</code>, <code id="knotplot_+3A_seg">seg</code>, <code id="knotplot_+3A_text">text</code>, <code id="knotplot_+3A_cross">cross</code>, <code id="knotplot_+3A_ink">ink</code>, <code id="knotplot_+3A_node">node</code>, <code id="knotplot_+3A_all">all</code>, <code id="knotplot_+3A_width">width</code>, <code id="knotplot_+3A_circ">circ</code></td>
<td>
<p>Variables
controlling sundry <code>knotplot2()</code> features; see details</p>
</td></tr>
<tr><td><code id="knotplot_+3A_ou">ou</code></td>
<td>
<p>An overunder object, useful if overunder information not
included in argument <code>x</code></p>
</td></tr>
<tr><td><code id="knotplot_+3A_gap">gap</code>, <code id="knotplot_+3A_gapwidth">gapwidth</code></td>
<td>
<p>Variables controlling visual representation of
strand crossings; see details</p>
</td></tr>
<tr><td><code id="knotplot_+3A_n">n</code></td>
<td>
<p>Number of points on each Bezier curve</p>
</td></tr>
<tr><td><code id="knotplot_+3A_lwd">lwd</code></td>
<td>
<p>Width of line to use</p>
</td></tr>
<tr><td><code id="knotplot_+3A_add">add</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to set up a new
plot, and <code>TRUE</code> meaning to just add points and lines to an
existing plot</p>
</td></tr>
<tr><td><code id="knotplot_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code>plot()</code> and <code>points()</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>knotplot()</code> is useful for production-quality plotting
of knots with crossings indicated by the understrand having a gap;
function <code>knotplot2()</code> is more useful for development.  Function
<code>knotplot_old()</code> is included for backward compatibility and is
possibly more robust than <code>knotplot()</code>.
</p>
<p>Function <code>knotplot()</code> works by setting a suitable length of the
understrand to <code>NA</code> which results in it not being plotted.
</p>
<p>For <code>knotplot()</code>:
</p>

<ul>
<li> <p><code>overunderobj</code>; A two-column matrix indicating the sense
of the crossing.  Each row corresponds to a crossing; the first entry
is the segment number of the overstrand, and the second is the
understrand
</p>
</li>
<li> <p><code>gapwidth</code>; the width of the gap, measured in units of
width of the string
</p>
</li></ul>

<p>For <code>knotplot2()</code>:
</p>

<ul>
<li> <p><code>rainbow</code>; use rainbow colouring for the segments
</p>
</li>
<li> <p><code>seg</code>; plot the Bezier nodes and handles.  The positions
of the nodes and handles are obtained from an object of class
<code>controlpoints</code>.
</p>
</li>
<li> <p><code>text</code>; include the segment number on the segment
</p>
</li>
<li> <p><code>cross</code>; label the crossings
</p>
</li>
<li> <p><code>ink</code>; label the nodes with their inkscape numbering
</p>
</li>
<li> <p><code>width</code>; show the bending strain energy
</p>
</li></ul>

<p>The <code>gap</code> argument of <code>knotplot_old()</code> is a the same as the
<code>gapwidth</code> argument of <code>knotplot()</code> but <code>gap</code> is
measured in the same units as the <code>plot()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
knotplot(k5_1)

knotplot2(k6_1,text=TRUE,seg=TRUE,lwd=1)

</code></pre>

<hr>
<h2 id='knotR-package'>
Knot Diagrams using Bezier Curves
</h2><span id='topic+knotR-package'></span><span id='topic+knotR'></span>

<h3>Description</h3>

<p>Makes visually pleasing diagrams of knot projections using optimized Bezier curves.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> knotR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Knot Diagrams using Bezier Curves</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.10)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Makes visually pleasing diagrams of knot projections using optimized Bezier curves.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
as                      Conversions between various forms of a knot
badness                 Badness of knots
bezier                  Various functionality for Bezier curves
bezier_angle            Intersection of two Bezier curves
bezier_find_length      Solve for arclength
bezier_integrals        Arcwise integrals over Bezier curves
crossing                Crossing Metrics for knots
getstringpoints         Returns the coordinates of a knot's path
head.inkscape           Head and tail methods for inkscape objects
knotoptim               Optimization of knot appearance
knotplot                Plotting of knots
knotR-package           Knot Diagrams using Bezier Curves
knots                   Optimized knots
overunder               Functionality for specifying overstrands and
                        understrands
reader                  Reading and writing svg files
symmetrize              Symmetry and knots
utilities               Various utilities for knots
</pre>
<p>The package contains a large number of knots, optimized for visual
appearance in the sense that the knot path is nice and smooth, and
strands cross at close to right angles.  These can be displayed by
typing
</p>
<p><code>knotplot(k9_23)</code>
</p>
<p>at the R prompt.  The package includes all prime knots up to and
including 9 crossings, and a number of other interesting and attractive
knots.
</p>
<p>The package facilitates the creation and optimization of new knots.  The
basic workflow is to create an <code>.svg</code> file in inkscape comprising a
single closed path (that is, the first and last node are the same
point).  Control nodes should all be symmetrical.  Many examples of
correctly formatted <code>.svg</code> files are given in the <code>inst/</code>
directory.
</p>
<p>The best way to reproduce a knot from an image of its projection is to
fire up inkscape, then <em>import</em> the image into inkscape, resize and
rotate as desired, then follow the string with the &lsquo;Bezier curves
and straight lines&rsquo; tool (also called the &lsquo;pen tool&rsquo; by Kirsanov;
the keyboard shortcut is shift-F6).  Use 1-2 nodes per segment, or 3
nodes for longer or more visually prominent segments.
</p>
<p>Keep the lines straight at first.  Close the path by making a final
click on the initial node; now you have a closed polygon, which will
self-intersect at the path crossing points.  To smoothen the path,
select the &lsquo;edit paths by node&rsquo; tool (shift-F2), then convert the
corner nodes of the path to symmetric Bezier nodes (&lsquo;make
selected nodes symmetric&rsquo;).  You can then tweak the path by moving the
control nodes about with the mouse.  Be aware that adding or deleting
nodes changes the adjacent nodes to asymmetrical Bezier control points;
make them symmetric by selecting all nodes (&lsquo;Ctrl-A&rsquo;), then hit
the &lsquo;make selected nodes symmetric&rsquo; button.  Do this frequently
to avoid confusion.
</p>
<p>An <code>.svg</code> file may be imported into R using the 
<code>reader()</code> function, which creates an <code>inkscape</code> object.  This
represents the <em>path</em> of the knot: it does not include over and under
information.  The package assumes that inkscape uses absolute
coordinates (as opposed to relative coordinates); see <code>reader.Rd</code>
for more information.
</p>
<p>The package provides four classes of objects that specify the path of a knot:
<code>inkscape</code>, <code>minobj</code>, <code>controlpoints</code>, and
<code>knotvec</code>.  These four classes have different uses, and objects may
be converted from one form to another by using functions such as
<code>as.minobj()</code>, documented at <code>as.Rd</code> and <code>utilities.Rd</code>.
</p>
<p>A knot requires information on which strands pass over or under which
other strands; full documentation at <code>?overunder</code>.
</p>
<p>Knots sometimes have symmetry constraints such as horizontal or vertical
symmetry, or rotational symmetry.  Symmetry is imposed by using the
<code>symmetrize()</code> function: this takes a knot path (coereced to
<code>minobj</code> form) and a symmetry object.  Symmetry objects are created
with function <code>symmetry_object()</code>, which takes a knot path and a
series of matrices and vectors that specify the symmetry of the knot.
</p>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

a &lt;- reader(system.file("7_6.svg",package="knotR"))
knotplot2(a)  # shows curvature

# Now use text=TRUE to display strand numbers so you can figure out the
# overunder relations:

knotplot2(a,text=TRUE,lwd=1)

ou76 &lt;- matrix(c(
    12,01,
    02,11,
    07,03,
    04,15,
    16,06,
    14,08,
    10,13
    ),byrow=TRUE,ncol=2)

# Now we can do a proper knot plot:

knotplot(a,ou76)


# To symmetrize a knot we use the symmetry functionality of the knot:

a &lt;- reader(system.file("3_1_not_symmetric.svg",package="knotR"))

knotplot2(a,seg=TRUE,text=TRUE,lwd=1,node=TRUE)

# First specify the vertical symmetry:
         
Mver &lt;- matrix(c(
    08,10,
    07,11,
    02,04,
    01,05,
    12,06
    ),ncol=2,byrow=TRUE)

# Then the rotational symmetry:
Mrot &lt;- matrix(c(
    09,05,01,
    10,06,02,
    08,04,12
    ),byrow=TRUE,ncol=3)


# Now the overunder information:
ou31 &lt;- matrix(c(
    03,08,
    11,04,
    07,12
    ),byrow=TRUE,ncol=2)


# create a symmetry object:

sym31 &lt;- symmetry_object(a, Mver=Mver,xver=c(9,3),Mrot=Mrot)   


knotplot(symmetrize(a,sym31),ou31)

# Symmetric-- but ugly as a burglar's bulldog.

# to beautify, either use the knotoptim() function, or do it by hand:


objective &lt;- function(m) {badness(make_minobj_from_minsymvec(m, sym31))}
startval  &lt;- make_minsymvec_from_minobj(as.minobj(a),sym31)

## Not run: 

# Following examples take a long time to run.
# nlm() is the best optimization method, I think.  Limit to 1 iteration:
o &lt;- nlm(f=objective, p=startval, iterlim=1)

# extract the evaluate:
oo &lt;- make_minobj_from_minsymvec(o$estimate, sym31)

# create a knot:
k31_marginally_better &lt;- 
knot(x = oo, overunderobj = ou31, symobj = sym31)

# then plot it:
knotplot(k31_marginally_better)

## End(Not run)
</code></pre>

<hr>
<h2 id='knots'>Optimized knots</h2><span id='topic+knots'></span><span id='topic+k3_1'></span><span id='topic+k3_1a'></span><span id='topic+k4_1'></span><span id='topic+k4_1a'></span><span id='topic+k5_1'></span><span id='topic+k5_2'></span><span id='topic+k6_1'></span><span id='topic+k6_2'></span><span id='topic+k6_3'></span><span id='topic+k7_1'></span><span id='topic+k7_2'></span><span id='topic+k7_3'></span><span id='topic+k7_4'></span><span id='topic+k7_5'></span><span id='topic+k7_6'></span><span id='topic+k7_7'></span><span id='topic+k7_7a'></span><span id='topic+k8_1'></span><span id='topic+k8_2'></span><span id='topic+k8_3'></span><span id='topic+k8_3_90deg_crossing'></span><span id='topic+k8_4'></span><span id='topic+k8_4a'></span><span id='topic+k8_5'></span><span id='topic+k8_6'></span><span id='topic+k8_7'></span><span id='topic+k8_8'></span><span id='topic+k8_9'></span><span id='topic+k8_10'></span><span id='topic+k8_11'></span><span id='topic+k8_12'></span><span id='topic+k8_13'></span><span id='topic+k8_14'></span><span id='topic+k8_15'></span><span id='topic+k8_16'></span><span id='topic+k8_17'></span><span id='topic+k8_18'></span><span id='topic+k8_19'></span><span id='topic+k8_19a'></span><span id='topic+k8_19b'></span><span id='topic+k8_20'></span><span id='topic+k8_21'></span><span id='topic+k9_1'></span><span id='topic+k9_2'></span><span id='topic+k9_3'></span><span id='topic+k9_4'></span><span id='topic+k9_5'></span><span id='topic+k9_6'></span><span id='topic+k9_7'></span><span id='topic+k9_8'></span><span id='topic+k9_9'></span><span id='topic+k9_10'></span><span id='topic+k9_11'></span><span id='topic+k9_12'></span><span id='topic+k9_13'></span><span id='topic+k9_14'></span><span id='topic+k9_15'></span><span id='topic+k9_16'></span><span id='topic+k9_17'></span><span id='topic+k9_18'></span><span id='topic+k9_19'></span><span id='topic+k9_20'></span><span id='topic+k9_21'></span><span id='topic+k9_22'></span><span id='topic+k9_23'></span><span id='topic+k9_23a'></span><span id='topic+k9_24'></span><span id='topic+k9_25'></span><span id='topic+k9_26'></span><span id='topic+k9_27'></span><span id='topic+k9_28'></span><span id='topic+k9_29'></span><span id='topic+k9_30'></span><span id='topic+k9_31'></span><span id='topic+k9_32'></span><span id='topic+k9_33'></span><span id='topic+k9_34'></span><span id='topic+k9_35'></span><span id='topic+k9_36'></span><span id='topic+k9_37'></span><span id='topic+k9_38'></span><span id='topic+k9_39'></span><span id='topic+k9_40'></span><span id='topic+k9_41'></span><span id='topic+k9_42'></span><span id='topic+k9_43'></span><span id='topic+k9_44'></span><span id='topic+k9_45'></span><span id='topic+k9_46'></span><span id='topic+k9_47'></span><span id='topic+k9_48'></span><span id='topic+k9_49'></span><span id='topic+k10_1'></span><span id='topic+k10_47'></span><span id='topic+k10_61'></span><span id='topic+k10_61a'></span><span id='topic+k10_123'></span><span id='topic+k11a179'></span><span id='topic+k11a361'></span><span id='topic+k11a1'></span><span id='topic+k11n157'></span><span id='topic+k11n157_morenodes'></span><span id='topic+k11n22'></span><span id='topic+k12n_0242'></span><span id='topic+k12n_0411'></span><span id='topic+k12a1202'></span><span id='topic+k12n838'></span><span id='topic+celtic3'></span><span id='topic+k_infinity'></span><span id='topic+fourloops'></span><span id='topic+fiveloops'></span><span id='topic+flower'></span><span id='topic+hexknot'></span><span id='topic+hexknot2'></span><span id='topic+hexknot3'></span><span id='topic+longthin'></span><span id='topic+ochiai'></span><span id='topic+ornamental20'></span><span id='topic+perko_A'></span><span id='topic+perko_B'></span><span id='topic+pretzel_2_3_7'></span><span id='topic+pretzel_7_3_7'></span><span id='topic+pretzel_p3_p5_p7_m3_m5'></span><span id='topic+product_knot'></span><span id='topic+reefknot'></span><span id='topic+amphichiral15'></span><span id='topic+satellite'></span><span id='topic+sum_31_41'></span><span id='topic+three_figure_eights'></span><span id='topic+trefoil_of_trefoils'></span><span id='topic+triloop'></span><span id='topic+unknot'></span><span id='topic+D16'></span><span id='topic+T20'></span><span id='topic+k8_11_90deg_crossing'></span><span id='topic+k8_5_90deg_crossing'></span><span id='topic+k8_6_90deg_crossing'></span><span id='topic+pretzel_2_3_7_90deg_crossing'></span><span id='topic+pretzel_7_3_7_90deg_crossing'></span>

<h3>Description</h3>

<p>A variety of knots with optimized forms</p>


<h3>Details</h3>

<p>A selection of knots that have been optimized for visual appearance.
The list makes no claims for completeness; the examples are intended
to show the abilities of the package.
</p>
<p>Knots with names like <code>k7_3</code> use the naming scheme of Rolfsen.
</p>
<p>Knots with names like <code>k11n157</code> follow the nomenclature of the
Hoste-Thistlethwaite table;  &lsquo;a&rsquo;  means &lsquo;alternating&rsquo;
and &lsquo;n&rsquo; means &lsquo;nonalternating&rsquo;.
</p>
<p>Knot <code>k12a_614</code> is drawn from the &ldquo;Table of Knot
Invariants&rdquo; by Livingstone and Cha.
</p>
<p>Knot <code>amphichiral15</code> is the unique amphichiral knot with crossing
number 15, due to Hoste, Thistlethwaite, and Weeks.
</p>
<p>Knots <code>k12n_0411</code> and <code>k11a203</code> show that partial symmetry
may be enforced.
</p>
<p>Knot <code>k8_18</code> is an exceptional knot.
</p>
<p>Knot <code>pretzel_p3_p5_p7_m3_m5</code> is drawn from a knot appearing in
Bryant 2016.  The notation specifies the sense (&lsquo;p&rsquo; for plus
and &lsquo;m&rsquo; for minus) of the twists.
</p>
<p>Knot <code>T20</code> is a &ldquo;remarkable 20-crossing tangle&rdquo;; see
references
</p>
<p>Knots <code>k12a1202</code> and <code>k12n838</code> are named following Lamm.
</p>
<p>As of version 1.0-4, the complete list of knots is:
</p>
<p><code>k10_1</code>, <code>k10_123</code>, <code>k10_47</code>, <code>k10_61</code>,
<code>k12a1202</code>, <code>k12n838</code>, <code>k3_1</code>, <code>k3_1a</code>, <code>k4_1</code>,
<code>k4_1a</code>, <code>k5_1</code>, <code>k5_2</code>, <code>k6_1</code>, <code>k6_2</code>,
<code>k6_3</code>, <code>k7_1</code>, <code>k7_2</code>, <code>k7_3</code>, <code>k7_4</code>,
<code>k7_5</code>, <code>k7_6</code>, <code>k7_7</code>, <code>k7_7a</code>, <code>k8_1</code>,
<code>k8_10</code>, <code>k8_11</code>, <code>k8_12</code>, <code>k8_13</code>, <code>k8_14</code>,
<code>k8_15</code>, <code>k8_16</code>, <code>k8_17</code>, <code>k8_18</code>, <code>k8_19</code>,
<code>k8_19a</code>, <code>k8_19b</code>, <code>k8_2</code>, <code>k8_20</code>, <code>k8_21</code>,
<code>k8_3</code>, <code>k8_3_90deg_crossing</code>,
<code>k8_4</code>, <code>k8_4a</code>, <code>k8_5</code>, <code>k8_6</code>,
<code>k8_7</code>, <code>k8_8</code>, <code>k8_9</code>, <code>k9_1</code>, <code>k9_10</code>,
<code>k9_11</code>, <code>k9_12</code>, <code>k9_13</code>, <code>k9_14</code>, <code>k9_15</code>,
<code>k9_16</code>, <code>k9_17</code>, <code>k9_18</code>, <code>k9_19</code>, <code>k9_2</code>,
<code>k9_20</code>, <code>k9_21</code>, <code>k9_22</code>, <code>k9_23</code>, <code>k9_23a</code>,
<code>k9_24</code>, <code>k9_25</code>, <code>k9_26</code>, <code>k9_27</code>, <code>k9_28</code>,
<code>k9_29</code>, <code>k9_3</code>, <code>k9_30</code>, <code>k9_31</code>, <code>k9_32</code>,
<code>k9_33</code>, <code>k9_34</code>, <code>k9_35</code>, <code>k9_36</code>, <code>k9_37</code>,
<code>k9_38</code>, <code>k9_39</code>, <code>k9_4</code>, <code>k9_40</code>, <code>k9_41</code>,
<code>k9_42</code>, <code>k9_43</code>, <code>k9_44</code>, <code>k9_45</code>, <code>k9_46</code>,
<code>k9_47</code>, <code>k9_48</code>, <code>k9_49</code>, <code>k9_5</code>, <code>k9_6</code>,
<code>k9_7</code>, <code>k9_8</code>, <code>k9_9</code>, <code>D16</code>, <code>T20</code>,
<code>amphichiral15</code>, <code>celtic3</code>, <code>fiveloops</code>, <code>flower</code>,
<code>fourloops</code>, <code>hexknot</code>, <code>hexknot2</code>, <code>hexknot3</code>,
<code>k_infinity</code>, <code>k11a1</code>, <code>k11a179</code>, <code>k11a361</code>,
<code>k11n157</code>, <code>k11n157_morenodes</code>, <code>k11n22</code>,
<code>k12n_0242</code>, <code>k12n_0411</code>, <code>longthin</code>, <code>ochiai</code>,
<code>ornamental20</code>, <code>perko_A</code>, <code>perko_B</code>,
<code>pretzel_2_3_7</code>, <code>pretzel_7_3_7</code>,
<code>pretzel_p3_p5_p7_m3_m5</code>, <code>reefknot</code>, <code>satellite</code>,
<code>sum_31_41</code>, <code>three_figure_eights</code>,
<code>trefoil_of_trefoils</code>, <code>triloop</code>, <code>unknot</code>
</p>


<h3>References</h3>


<ul>
<li><p> K. A. Bryant, 2016. <em>Slice implies mutant-ribbon for odd,
5-stranded pretzel knots</em>, <code>arXiv:1511.07009v2</code>
</p>
</li>
<li><p> S. Eliahou and J. Fromentin 2017. &ldquo;A remarkable 20-crossing
tangle&rdquo;.  Arxiv, <a href="https://arxiv.org/abs/1610.05560v2">https://arxiv.org/abs/1610.05560v2</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>knotplot(k3_1)
## maybe str(k3_1) ; plot(k3_1) ...
</code></pre>

<hr>
<h2 id='overunder'>Functionality for specifying overstrands and understrands</h2><span id='topic+overunder'></span><span id='topic+overunder'></span><span id='topic+overunder+3C-'></span><span id='topic+mirror'></span><span id='topic+is.sensible'></span>

<h3>Description</h3>

<p>Functionality for specifying overstrands and understrands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overunder(x)
overunder(x) &lt;- value
mirror(x)
is.sensible(overunderobj,x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overunder_+3A_x">x</code></td>
<td>
<p>A knot object</p>
</td></tr>
<tr><td><code id="overunder_+3A_value">value</code>, <code id="overunder_+3A_overunderobj">overunderobj</code></td>
<td>
<p>A two-column integer matrix specifying the
senses of the crossings in a knot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>overunder()</code> returns a two-column integer matrix with
rows corresponding to crossing points.  The first element of each row
corresponds to the strand number of the overstrand and the second
element corresponds to the understrand.  
</p>
<p>Function <code>is.sensible()</code> checks to see whether the overunder
matrix is compatible with the knot path.  For example, it checks to
see whether each crossing has exactly one row, and that each row
corresponds to a pair of strands that actually cross.
</p>
<p>Function <code>mirror()</code> takes a knot and returns the knot with the
senses of each crossing reversed; it is as though the knot is
reflected in the plane of the projection.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+knot">knot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
overunder(k4_1)

par(mfcol=c(1,2))
knotplot(k4_1,gap=80)
knotplot(mirror(k4_1),gap=80)

is.sensible(overunder(k6_1),k6_1)
</code></pre>

<hr>
<h2 id='reader'>Reading and writing svg files</h2><span id='topic+reader'></span><span id='topic+write_svg'></span><span id='topic+svg'></span>

<h3>Description</h3>

<p>Various utilities for reading and creating svg files for use with inkscape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reader(filename)
write_svg(k, oldfile, safe=TRUE,
    regex1 ='sodipodi:docname=',
    regex2=' *d *= *" *M.*C.*[zZ] *"')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reader_+3A_filename">filename</code></td>
<td>
<p>Name of a file to be read by <code>reader()</code>; usually
an inkscape <code>.svg</code> file</p>
</td></tr>
<tr><td><code id="reader_+3A_safe">safe</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to save file
&ldquo;<code>foo.svg</code>&rdquo; as &ldquo;<code>foo_smooth.svg</code>&rdquo;
and <code>FALSE</code> meaning to overwrite <code>foo.svg</code>.</p>
</td></tr>    
<tr><td><code id="reader_+3A_k">k</code>, <code id="reader_+3A_oldfile">oldfile</code>, <code id="reader_+3A_regex1">regex1</code>, <code id="reader_+3A_regex2">regex2</code></td>
<td>
<p>Various arguments sent to
<code>write_svg()</code>; see the source code for details.
Argument <code>k</code> is a knot, <code>oldfile</code> an <code>.svg</code> file for
reference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>reader()</code> is the way to get started with a new
knot.  This takes a filename which is an <code>.svg</code> file created with
inkscape.  Instructions for creating a suitable inkscape file are
given in <code>knotR-package.Rd</code>.
</p>


<h3>Note</h3>

<p>Inkscape's default is to use a mixture of absolute and relative
coordinates.  Function <code>reader()</code> assumes that the <code>.svg</code>
file uses only absolute coordinates.
</p>
<p>To ensure that only absolute coordinates are used, open the
&lsquo;SVG output&rsquo; menu in &lsquo;inkscape preferences&rsquo; and uncheck
the &ldquo;Allow relative coordinates&rdquo; option.
</p>
<p>The format of <code>.svg</code> file is described in the W3C recommendation
(2011) for Scalable Vector Graphics (SVG) 1.1, second edition.
</p>
<p>Sometimes, <code>reader()</code> will fail with a valid <code>.svg</code> file if
a node is sufficiently close to the x or y axis to require exponential
notation (this typically happens with complicated rotational
symmetry).  If the file contains text like
</p>
<p><code>...35.3635879230533 -1.323423734554e-15 , 10.3538368384142...</code>
</p>
<p>the second value is zero to numerical precision, but the text form of
the number interferes with the operation of <code>reader()</code>.  To deal
with this we need to edit the file in a text editor and replace the
offending number with an exact zero:
</p>
<p><code>...35.3635879230533 0 , 10.3538368384142...</code>
</p>
<p>(I guess the ideal would be to incorporate some clever regexp
technique into <code>reader()</code> but this turned out to be harder than I
thought).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+utilities">utilities</a></code>,<code><a href="#topic+knotR-package">knotR-package</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
a &lt;- reader("6_3.svg")
b &lt;- getcontrolpoints(a)
knotplot(a)


## End(Not run)
</code></pre>

<hr>
<h2 id='symmetrize'>Symmetry and knots</h2><span id='topic+symmetrize'></span><span id='topic+symmetrise'></span><span id='topic+force_nodes'></span><span id='topic+force_nodes_exactly_horizontal'></span><span id='topic+force_nodes_exactly_vertical'></span><span id='topic+force_nodes_mirror_images_LR'></span><span id='topic+force_nodes_mirror_images_UD'></span><span id='topic+force_nodes_on_V_axis'></span><span id='topic+force_nodes_on_H_axis'></span><span id='topic+force_nodes_rotational'></span><span id='topic+symmetrize'></span><span id='topic+tag_notneeded'></span><span id='topic+make_minsymvec_from_minobj'></span><span id='topic+make_minobj_from_minsymvec'></span><span id='topic+symmetry_object'></span><span id='topic+minsymvec'></span><span id='topic+knot'></span>

<h3>Description</h3>

<p>Various functionality to impose different types of symmetry on knots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force_nodes_mirror_images_LR(x,symobj)
force_nodes_mirror_images_UD(x,symobj)
force_nodes_exactly_horizontal(x,symobj)
force_nodes_exactly_vertical(x,symobj)
force_nodes_on_V_axis(x,xver)
force_nodes_on_H_axis(x,xhor)
force_nodes_rotational(x,symobj)
symmetrize(x,symobj)
tag_notneeded(x, Mver, xver, Mhor, xhor, Mrot,exact_h,exact_v)
make_minsymvec_from_minobj(x,symobj)
minsymvec(vec)
make_minobj_from_minsymvec(minsymvec,symobj)
symmetry_object(x, Mver=NULL, xver=NULL, Mhor=NULL, xhor=NULL,
Mrot=NULL, exact_h=NULL, exact_v=NULL,
mcdonalds=FALSE, celtic=FALSE, reefknot=FALSE,center_crossing=FALSE)
knot(x, overunderobj, symobj, Mver=NULL, xver=NULL, Mhor=NULL,
xhor=NULL, Mrot=NULL, mcdonalds=FALSE, celtic=FALSE,
reefknot=FALSE,center_crossing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetrize_+3A_x">x</code></td>
<td>
<p>Object coerced to class <code>minobj</code></p>
</td></tr>
<tr><td><code id="symmetrize_+3A_mver">Mver</code>, <code id="symmetrize_+3A_mhor">Mhor</code></td>
<td>
<p>Matrices specifying vertical (resp. horizontal) symmetry,
with two columns.  The rows specify pairs of symmetric nodes about a
vertical (resp. horizontal) axis.  Nodes specified by the first column
should be on the left (resp. upper) side; these are fixed.  Used by
functions <code>force_nodes_mirror_images_LR()</code> and
<code>force_nodes_mirror_images_UD()</code> which move the right (resp. lower)
nodes and their associated handles to the positions required for
exact vertical (resp. horizontal) symmetry</p>
</td></tr>
<tr><td><code id="symmetrize_+3A_mrot">Mrot</code></td>
<td>
<p>A matrix specifying rotational symmetry.  Each row
corresponds to a set of nodes in a rotational relationship.  The
number of columns specifies the order of the rotational symmetry.
The first column corresponds to nodes whose position is fixed.
Used by <code>force_nodes_rotational()</code>, which also moves handles
appropriately</p>
</td></tr> 
<tr><td><code id="symmetrize_+3A_xver">xver</code>, <code id="symmetrize_+3A_xhor">xhor</code></td>
<td>
<p>Vector specifying nodes to be on the vertical
(resp. horizontal) axis of symmetry.  The nodes are assumed to flow from
left to right.  Used by functions <code>force_nodes_on_V_axis()</code> and
<code>force_nodes_on_H_axis()</code> respectively, which also move the
handles</p>
</td></tr> 
<tr><td><code id="symmetrize_+3A_exact_h">exact_h</code>, <code id="symmetrize_+3A_exact_v">exact_v</code></td>
<td>
<p>Vector specifying nodes to be exactly
horizontal or exactly vertical.  A node is exactly horizontal
(resp. vertical) if the y (resp. x) coordinate of the node is the same as the
y (resp. x) coordinate of the handle.  Note that the position of an exactly
horizontal or vertical node is not restricted, and may be anywhere.  Used by
functions <code>force_nodes_exactly_horizontal()</code> and
<code>force_nodes_exactly_vertical()</code></p>
</td></tr>
<tr><td><code id="symmetrize_+3A_symobj">symobj</code></td>
<td>
<p>An object representing the symmetry of the knot, usually
created by function <code>symmetry_object()</code></p>
</td></tr>
<tr><td><code id="symmetrize_+3A_mcdonalds">mcdonalds</code></td>
<td>
<p>For vertical symmetry, argument <code>mcdonalds</code> is
Boolean, defaulting to <code>FALSE</code>, with <code>TRUE</code> meaning that
the symmetric pairs of strands approach the vertical line of
symmetry in the same sense (either both moving inward, or both
moving outward).  It is hard to explain (and named for the gesture
one makes when tracing the top two strands a knot with this type of
symmetry).  The only common knot that needs this is <code>7_2</code></p>
</td></tr>
<tr><td><code id="symmetrize_+3A_celtic">celtic</code></td>
<td>
<p>Like <code>mcdonalds</code> but for horizontal symmetry</p>
</td></tr>
<tr><td><code id="symmetrize_+3A_reefknot">reefknot</code></td>
<td>
<p>Like <code>mcdonalds</code> but for the reefknot</p>
</td></tr>
<tr><td><code id="symmetrize_+3A_center_crossing">center_crossing</code></td>
<td>
<p>Implements a peculiar type of rotational
symmetry in which the strands pass through the geometrical center of
the knot projection.  The only common knot needing this is
<code>9_29</code></p>
</td></tr>
<tr><td><code id="symmetrize_+3A_minsymvec">minsymvec</code></td>
<td>
<p>A &ldquo;minimal symmetric vector&rdquo;.  This is a
numeric vector containing just the independent degrees of freedom of
a knot, after symmetry constraints have been imposed.  The idea is
that one may optimize a <code>minsymvec</code> object using <code>nlm()</code>,
and then reconstruct a knot using
<code>make_minobj_from_minsymvec()</code> together with a symmetry object</p>
</td></tr>
<tr><td><code id="symmetrize_+3A_vec">vec</code></td>
<td>
<p>A vector, given to function <code>minsymvec()</code></p>
</td></tr>
<tr><td><code id="symmetrize_+3A_overunderobj">overunderobj</code></td>
<td>
<p>A matrix specifying the overs and the unders; a
two-column matrix with rows corresponding to pairs of strands
intersecting.  The first element of a row identifies the overstrand
and the second element specifies the understrand</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>symmetry_object()</code> creates a symmetry object from
<code>Mver</code> et seq, but if given a <code>knot</code> object, returns the
embedded symmetry object.
</p>
<p>There are seven types of symmetry that may be imposed on a knot.
These are imposed by the following seven <code>force_nodes_foo()</code>
functions:
</p>

<ul>
<li><p> Functions <code>force_nodes_mirror_images_LR()</code> and
<code>force_nodes_mirror_images_UD()</code> symmetrize a knot about a vertical
(resp. horizontal) axis by taking ordered pairs of nodes, specified by
matrix <code>Mver</code> (resp. <code>Mhor</code>) and forcing the second node to be
symmetrically placed with respect to the first.  It does the same
thing to the handles too.
</p>
</li>
<li><p> Functions <code>force_nodes_exactly_horizontal()</code> and
<code>force_nodes_exactly_vertical()</code> force nodes to be exactly
horizontal (resp. vertical) by restricting the
position of their handles.  Nodes so forced do not
need to be on an axis of symmetry; they can be anywhere
</p>
</li>
<li><p> Functions <code>force_nodes_on_V_axis()</code> and
<code>force_nodes_on_H_axis()</code> force nodes specified by <code>xver</code>
(resp. <code>xhor</code>) to be on the vertical (resp. horizontal)
axis, and to have appropriately placed handles 
</p>
</li>
<li><p> Function <code>force_nodes_rotational()</code> imposes the
rotational symmetry specified by <code>Mrot</code>
</p>
</li></ul>

<p>Function <code>symmetrize()</code> imposes the seven kinds of symmetry by
calling each of the <code>force_nodes_foo()</code> functions in turn.
</p>
<p>Function <code>tag_notneeded()</code> is an internal function, not really
intended for the end-user.  It takes a <code>minobj</code> object and marks
a maximal set of dependent entries with a &lsquo;not needed&rsquo; value.
The values of the entries so marked may be determined by a combination
of the imposed symmetry relations and the unmarked values.  The
unmarked entries constitute a <code>minsymvec</code> object (see above).
These are the <em>real</em> degrees of freedom in the symmetrical knot.
Only these unmarked values are modified by the optimization routines
in <code>knotoptim()</code>
</p>


<h3>Note</h3>

<p>You can achieve up-down symmetry (that is, a horizontal line of
symmetry) by making a left-right symmetric knot and rotating by 90
degrees.  D'oh.
</p>


<h3>Author(s)</h3>

<p>Robin K.S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# each row of M = a pair of symmetrical nodes; each element of v is a
# node on the vertical axis

M &lt;- matrix(c(6,4,13,11,7,3,2,8,9,1,14,10),byrow=TRUE,ncol=2) 
v &lt;-  c(5,12) # on vertical axis

sym_7_3 &lt;- symmetry_object(k7_3, M, v)

k &lt;- symmetrize(as.minobj(k7_3), sym_7_3)

knotplot2(k)  #nice and symmetric!


## OK now convert to and from a mimimal vector for a symmetrical knot:

mii &lt;- make_minsymvec_from_minobj(k, sym_7_3)
pii &lt;- make_minobj_from_minsymvec(mii,sym_7_3)
knotplot2(pii)


##   So 'mii' is a minimal vector for a symmetrical knot, and 'pii' is
##   the corresponding minobj object.  Note that you can mess about with
##   mii, but whatever you do the resulting knot is still symmetric:

mii[2] &lt;- 1000
knotplot2(make_minobj_from_minsymvec(mii,sym_7_3))   # still symmetric.

## and, in particular, you can optimize the badness, using nlm():

## Not run: 
fun &lt;- function(m){badness(make_minobj_from_minsymvec(m,sym_7_3))}
o &lt;- nlm(fun,mii,iterlim=4,print.level=2)

knotplot2(make_minobj_from_minsymvec(o$estimate,sym_7_3))

## End(Not run)


</code></pre>

<hr>
<h2 id='utilities'>Various utilities for knots</h2><span id='topic+utilities'></span><span id='topic+controlpoints'></span><span id='topic+inkscape'></span><span id='topic+minobj'></span><span id='topic+knotvec'></span><span id='topic+make_minobj_from_ink'></span><span id='topic+make_minobj_from_vector'></span><span id='topic+make_ink_from_minobj'></span><span id='topic+make_controlpoints_from_ink'></span><span id='topic+make_inkscape_from_controlpoints'></span><span id='topic+make_minobj_from_knot'></span><span id='topic+make_knotvec_from_minobj'></span>

<h3>Description</h3>

<p>Various utilities for knots including reading files and creating objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>controlpoints(x)
inkscape(x)
minobj(x)
knotvec(x)
make_controlpoints_from_ink(a)
make_minobj_from_ink(a)
make_minobj_from_vector(vec)
make_ink_from_minobj(x)
make_inkscape_from_controlpoints(b)
make_minobj_from_knot(k)
make_knotvec_from_minobj(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilities_+3A_x">x</code></td>
<td>
<p>Suitable object for coercion; see details</p>
</td></tr>
<tr><td><code id="utilities_+3A_a">a</code></td>
<td>
<p>An <code>inkscape</code> object: a two column matrix with rows
representing the positions of nodes and control points</p>
</td></tr>
<tr><td><code id="utilities_+3A_b">b</code></td>
<td>
<p>A controlpoints object</p>
</td></tr>
<tr><td><code id="utilities_+3A_k">k</code></td>
<td>
<p>An object of class knot</p>
</td></tr>
<tr><td><code id="utilities_+3A_vec">vec</code></td>
<td>
<p>A vector of reals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>inkscape()</code>, <code>minobj()</code>, and <code>knotvec()</code> are
low-level functions; these are the only places that objects have their
classes assigned directly.  These functions are not user-friendly and
require very specific types of object; they perform some checks but
are not really intended for the user.  Functions <code>as.foo()</code> are
much more user-friendly, and are documented at <code>as.Rd</code>.
</p>
<p>Functions <code>make_foo_from_bar()</code> coerce <code>bar</code> objects into
<code>foo</code> objects.  Functions that involve symmetry are documented at
<code>symmetry.Rd</code>.
</p>
<p>Objects of class <strong><code>inkscape</code></strong> are in the form of a two-column
matrix, with rows corresponding to 2D positions.  The rows correspond
to the <code class="reqn">(x,y)</code> coordinates of points as held in the inkscape file.
</p>
<p>There is quite a lot of redundancy in an inkscape object:
</p>

<ul>
<li><p> The first row of an inkscape object is equal to the last row
(this follows from the fact that the path is closed).
</p>
</li>
<li><p> If <code class="reqn">n=0</code> modulo 3, then
<code>a[n+2,]-a[n+1,]==a[n+1,]-a[n]</code>, corresponding to the fact that
the handles are symmetric in inkscape.  This is visualised best by
<code>knotplot2(k4_1,ink=TRUE,seg=TRUE)</code>
</p>
</li></ul>

<p>Look at functions <code>make_inkscape_from_minobj()</code> and
<code>make_minobj_from_ink()</code> to see this from a symbolic
perspective.  The vignette also gives some details.
</p>
<p>The <strong><code>minobj</code></strong> class is a &lsquo;MINimal OBJect&rsquo;.
Objects of class <strong><code>minobj</code></strong> are a list of two elements:
<code>$node</code> and <code>$handle_A</code>.  Each element has rows
corresponding to 2D positions, the same as <code>inkscape</code> objects.
Element <code>$node</code> shows the positions of the nodes, and element
<code>$handle_A</code> shows the positions of (one of) the handles; the
other handle is symmetrically positioned with respect to its node.
Use <code>knotplot2(k4_1,node=TRUE,seg=TRUE)</code> to see the meaning of
the entries; the nodes are indicated by a square and the handles by
circles.
</p>
<p>NB: objects of class <code>minobj</code> have no <em>redundancy</em> in the
sense that changing any entry of either <code>$node</code> or
<code>$handle_A</code> results in modifying the corresponding inkscape
diagram.  However, doing this to a knot which has imposed symmetry
conditions (ie a nontrivial <code>symobj</code>) may introduce asymmetry
into the inkscape diagram.  For example, one might take a
<code>minobj</code> object whose knot diagram is left-right mirror symmetric
(eg <code>k6_2</code>) and alter one of the handle positions.  Then the
resulting inkscape object will be asymmetric.  There is an example
using <code>k6_2</code> below.
</p>
<p>An object of class <code>controlpoints</code> is a list of matrices of size
4-by-2.  For each matrix, the four rows correspond to the points in 2D
Cartesian space needed to specify a Bezier curve; further details and
examples are given in <code>bezier.Rd</code>.  There is lots of redundancy
in a <code>controlpoints</code> object because the inkscape nodes are
symmetric nodes with diametrically opposed handles.
</p>
<p>The <strong><code>knotvec</code></strong> class is a named vector of independent
reals suitable for use with optimization routines.
</p>
<p>None of the functions here deal with symmetry relations.  This is
documented at <code>symmetry.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as">as</a></code>,<code><a href="#topic+symmetrize">symmetrize</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
 a &lt;- as.minobj(k6_3)
 plot(a$node,asp=1,pch=16)
 segments(x0=a[[1]][,1],y0=a[[1]][,2],x1=a[[2]][,1],y1=a[[2]][,2],
 main="handle direction follows the string path")
 points(getstringpoints(a),type='l',col='gray',lwd=0.4)

 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
