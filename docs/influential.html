<!DOCTYPE html><html lang="en-US"><head><title>Help for package influential</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {influential}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#influential-package'><p>Influential package</p></a></li>
<li><a href='#betweenness'><p>Vertex betweenness centrality</p></a></li>
<li><a href='#cent_network.vis'><p>Centrality-based network visualization</p></a></li>
<li><a href='#centrality.measures'><p>Centrality measures dataset</p></a></li>
<li><a href='#clusterRank'><p>ClusterRank (CR)</p></a></li>
<li><a href='#coexpression.adjacency'><p>Adjacency matrix</p></a></li>
<li><a href='#coexpression.data'><p>Co-expression dataset</p></a></li>
<li><a href='#collective.influence'><p>Collective Influence (CI)</p></a></li>
<li><a href='#comp_manipulate'><p>Computational manipulation of cells</p></a></li>
<li><a href='#cond.prob.analysis'><p>Conditional probability of deviation from means</p></a></li>
<li><a href='#diff_data.assembly'><p>Assembling the differential/regression data</p></a></li>
<li><a href='#double.cent.assess'><p>Assessment of innate features and associations of two network centrality measures (dependent and independent)</p></a></li>
<li><a href='#double.cent.assess.noRegression'><p>Assessment of innate features and associations of two network centrality measures</p></a></li>
<li><a href='#exir'><p>Experimental data-based Integrated Ranking</p></a></li>
<li><a href='#exir.vis'><p>Visualization of ExIR results</p></a></li>
<li><a href='#fcor'><p>Fast correlation and mutual rank analysis</p></a></li>
<li><a href='#h_index'><p>H-index</p></a></li>
<li><a href='#hubness.score'><p>Hubness score</p></a></li>
<li><a href='#ivi'><p>Integrated Value of Influence (IVI)</p></a></li>
<li><a href='#ivi.from.indices'><p>Integrated Value of Influence (IVI)</p></a></li>
<li><a href='#lh_index'><p>local H-index (LH-index)</p></a></li>
<li><a href='#neighborhood.connectivity'><p>Neighborhood connectivity</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#runShinyApp'><p>Run shiny app</p></a></li>
<li><a href='#sif2igraph'><p>SIF to igraph</p></a></li>
<li><a href='#sirir'><p>SIR-based Influence Ranking</p></a></li>
<li><a href='#spreading.score'><p>Spreading score</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Identification and Classification of the Most Influential Nodes</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.9</td>
</tr>
<tr>
<td>Author:</td>
<td>Abbas (Adrian) Salavaty [aut, cre], Mirana Ramialison [ths], Peter D. Currie [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrian Salavaty &lt;abbas.salavaty@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions for the classification and ranking of top candidate features, reconstruction of networks from
    adjacency matrices and data frames, analysis of the topology of the network 
    and calculation of centrality measures, and identification of the most
    influential nodes. Also, a function is provided for running SIRIR model, which 
    is the combination of leave-one-out cross validation technique and the conventional SIR model, on a network to unsupervisedly rank the true influence of vertices. Additionally, some functions have been provided for the assessment 
    of dependence and correlation of two network centrality measures as well as 
    the conditional probability of deviation from their corresponding means in opposite direction.
    Fred Viole and David Nawrocki (2013, ISBN:1490523995).
    Csardi G, Nepusz T (2006). "The igraph software package for complex network research." InterJournal, Complex Systems, 1695.
    Adopted algorithms and sources are referenced in function document.</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, janitor, ranger, coop, foreach, doParallel,
data.table, ggplot2, BiocManager</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Hmisc (&ge; 4.3-0), mgcv (&ge; 1.8-31), nortest (&ge; 1.0-4), NNS
(&ge; 0.4.7.1), readr, parallel, shiny, shinythemes,
shinyWidgets, shinyjs, shinycssloaders, colourpicker, magrittr,
DT, knitr, rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/asalavaty/influential">https://github.com/asalavaty/influential</a>,
<a href="https://asalavaty.github.io/influential/">https://asalavaty.github.io/influential/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/asalavaty/influential/issues">https://github.com/asalavaty/influential/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-09 08:09:32 UTC; adriansalavaty</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-09 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='influential-package'>Influential package</h2><span id='topic+influential'></span><span id='topic+influential-package'></span>

<h3>Description</h3>

<p>The goal of <em><strong><code>influential</code></strong></em> is to help identification of the most influential nodes in a network
as well as the classification and ranking of top candidate features.
This package contains functions for the classification and ranking of features,
reconstruction of networks from adjacency matrices and
data frames, analysis of the topology of the network and calculation of centrality measures
as well as a novel and powerful influential node ranking.
The <strong>Experimental data-based Integrative Ranking (ExIR)</strong> is a sophisticated model
for classification and ranking of the top candidate features based on only the experimental data.
The first integrative method, namely the <strong>Integrated Value of Influence (IVI)</strong>,
that captures all topological dimensions of the network for
the identification of network most influential nodes is also provided as
a function. Also, neighborhood connectivity, H-index, local H-index, and collective
influence (CI), all of which required centrality measures for the calculation of IVI,
are for the first time provided in an R package. Additionally, a function is provided
for running <strong>SIRIR</strong> model, which is the combination of leave-one-out cross validation
technique and the conventional SIR model, on a network to unsupervisedly rank the true
influence of vertices.Furthermore, some functions have been provided for the
assessment of dependence and correlation of two network centrality measures as well
as the conditional probability of deviation from their corresponding
means in opposite directions.
</p>
<p>You may check the latest developmental version of the <em>influential</em> package on its
<a href="https://github.com/asalavaty/influential">GitHub repository</a>
</p>
<p>Also, a web-based <a href="https://influential.erc.monash.edu/">Influential Software Package</a> with a convenient
user-interface (UI) has been developed for the comfort of all users including those without a coding background.
</p>


<h3>Details</h3>


<ul>
<li><p> Package: influential
</p>
</li>
<li><p> Type: Package
</p>
</li>
<li><p> Version: 2.2.9
</p>
</li>
<li><p> Date: 01-12-2023
</p>
</li>
<li><p> License: GPL-3
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Author: Adrian (Abbas) Salavaty
</p>
<p>Advisors: Mirana Ramialison and Peter D. Currie
</p>
<p>Maintainer: Adrian (Abbas) Salavaty <a href="mailto:abbas.salavaty@gmail.com">abbas.salavaty@gmail.com</a>
</p>
<p>You may find more information on my personal website at <a href="https://asalavaty.com/">www.ASalavaty.com</a>
</p>


<h3>References</h3>


<ul>
<li><p> Fred Viole and David Nawrocki (2013, ISBN:1490523995).
</p>
</li>
<li><p> Csardi G, Nepusz T (2006). “The igraph software package for complex network research.”
InterJournal, Complex Systems, 1695. <a href="https://igraph.org/">https://igraph.org/</a>.
</p>
</li></ul>

<p><strong>Note:</strong> Adopted algorithms and sources are referenced in function document.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/asalavaty/influential">https://github.com/asalavaty/influential</a>
</p>
</li>
<li> <p><a href="https://asalavaty.github.io/influential/">https://asalavaty.github.io/influential/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/asalavaty/influential/issues">https://github.com/asalavaty/influential/issues</a>
</p>
</li></ul>


<hr>
<h2 id='betweenness'>Vertex betweenness centrality</h2><span id='topic+betweenness'></span><span id='topic+BC'></span>

<h3>Description</h3>

<p>This function and all of its descriptions have been obtained from the igraph package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betweenness(
  graph,
  v = V(graph),
  directed = TRUE,
  weights = NULL,
  normalized = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betweenness_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze (an igraph graph).</p>
</td></tr>
<tr><td><code id="betweenness_+3A_v">v</code></td>
<td>
<p>The vertices for which the vertex betweenness will be calculated.</p>
</td></tr>
<tr><td><code id="betweenness_+3A_directed">directed</code></td>
<td>
<p>Logical, whether directed paths should be considered while determining the shortest paths.</p>
</td></tr>
<tr><td><code id="betweenness_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted betweenness.
If the graph has a weight edge attribute, then this is used by default. Weights are used to calculate weighted shortest paths, so they are interpreted as distances.</p>
</td></tr>
<tr><td><code id="betweenness_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether to normalize the betweenness scores. If TRUE, then the results are normalized.</p>
</td></tr>
<tr><td><code id="betweenness_+3A_...">...</code></td>
<td>
<p>Additional arguments according to the original <code><a href="igraph.html#topic+betweenness">betweenness</a></code> function in the package igraph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the betweenness score for each vertex in v.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ivi">ivi</a></code>,
<code><a href="#topic+cent_network.vis">cent_network.vis</a></code>,
and <code><a href="igraph.html#topic+betweenness">betweenness</a></code> for a complete description on this function
</p>
<p>Other centrality functions: 
<code><a href="#topic+clusterRank">clusterRank</a>()</code>,
<code><a href="#topic+collective.influence">collective.influence</a>()</code>,
<code><a href="#topic+h_index">h_index</a>()</code>,
<code><a href="#topic+lh_index">lh_index</a>()</code>,
<code><a href="#topic+neighborhood.connectivity">neighborhood.connectivity</a>()</code>,
<code><a href="#topic+sirir">sirir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- coexpression.data
My_graph &lt;- graph_from_data_frame(MyData)
GraphVertices &lt;- V(My_graph)
My_graph_betweenness &lt;- betweenness(My_graph, v = GraphVertices,
                        directed = FALSE, normalized = FALSE)
                        
## End(Not run)
</code></pre>

<hr>
<h2 id='cent_network.vis'>Centrality-based network visualization</h2><span id='topic+cent_network.vis'></span>

<h3>Description</h3>

<p>This function has been developed for the visualization of a network based on
applying a centrality measure to the size and color of network nodes. You are
also able to adjust the directedness and weight of connections. Some of the documentations
of the arguments of this function have been adapted from ggplot2 and igraph packages.
A shiny app has also been developed for the calculation of IVI as well as IVI-based network
visualization, which is accessible using the 'influential::runShinyApp(&quot;IVI&quot;)' command.
You can also access the shiny app online at https://influential.erc.monash.edu/.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cent_network.vis(
  graph,
  cent.metric,
  layout = "kk",
  node.color = "viridis",
  node.size.min = 3,
  node.size.max = 15,
  dist.power = 1,
  node.shape = "circle",
  stroke.size = 1.5,
  stroke.color = "identical",
  stroke.alpha = 0.6,
  show.labels = TRUE,
  label.cex = 0.4,
  label.color = "black",
  directed = FALSE,
  arrow.width = 25,
  arrow.length = 0.07,
  edge.width = 0.5,
  weighted = FALSE,
  edge.width.min = 0.2,
  edge.width.max = 1,
  edge.color = "grey75",
  edge.linetype = "solid",
  legend.position = "right",
  legend.direction = "vertical",
  legend.title = "Centrality\nmeasure",
  boxed.legend = TRUE,
  show.plot.title = TRUE,
  plot.title = "Centrality Measure-based Network",
  title.position = "center",
  show.bottom.border = TRUE,
  show.left.border = TRUE,
  seed = 1234
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cent_network.vis_+3A_graph">graph</code></td>
<td>
<p>A graph (network) of the igraph class.</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_cent.metric">cent.metric</code></td>
<td>
<p>A numeric vector of the desired centrality measure previously
calculated by any means. For example, you may use the function <code><a href="#topic+ivi">ivi</a></code>
for the calculation of the Integrated Value of Influence (IVI) of network nodes. Please note that
if the centrality measure has been calculated by any means other than the <code>influential</code> package, make
sure that the order of the values in the <code>cent.metric</code> vector is consistent with the order of vertices
in the network <code>(V(graph))</code>.</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_layout">layout</code></td>
<td>
<p>The layout to be used for organizing network nodes. Current available layouts include
<code>"kk", "star", "tree", "components", "circle", "automatic", "grid",
"sphere", "random", "dh", "drl", "fr", "gem", "graphopt", "lgl", "mds", and "sugiyama"</code>
(default is set to &quot;kk&quot;). For a complete description of different layouts and their
underlying algorithms please refer to the function <code><a href="igraph.html#topic+layout_">layout_</a></code>.</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_node.color">node.color</code></td>
<td>
<p>A character string indicating the colormap option to use.
Five options are available: &quot;magma&quot; (or &quot;A&quot;), &quot;inferno&quot; (or &quot;B&quot;), &quot;plasma&quot;
(or &quot;C&quot;), &quot;viridis&quot; (or &quot;D&quot;, the default option) and &quot;cividis&quot; (or &quot;E&quot;).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_node.size.min">node.size.min</code></td>
<td>
<p>The size of nodes with the lowest value of the centrality measure (default is set to 3).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_node.size.max">node.size.max</code></td>
<td>
<p>The size of nodes with the highest value of the centrality measure (default is set to 15).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_dist.power">dist.power</code></td>
<td>
<p>The power to be used to visualize more distinction between nodes with high and low
centrality measure values. The higher the power, the smaller the nodes with lower values of the centrality
measure will become. Default is set to 1, meaning the relative sizes of nodes are reflective of their
actual centrality measure values.</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_node.shape">node.shape</code></td>
<td>
<p>The shape of nodes. Current available shapes include <code>"circle",
"square", "diamond", "triangle", and "inverted triangle"</code> (default is set to &quot;circle&quot;). You can also
set different shapes to different groups of nodes by providing a character vector of shapes of nodes with
the same length and order of network vertices. This is useful when plotting a network that include different
type of node (for example, up- and down-regulated features).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_stroke.size">stroke.size</code></td>
<td>
<p>The size of stroke (border) around the nodes (default is set to 1.5).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_stroke.color">stroke.color</code></td>
<td>
<p>The color of stroke (border) around the nodes (default is set to &quot;identical&quot; meaning that the
stroke color of a node will be identical to its corresponding node color). You can also
set different colors to different groups of nodes by providing a character vector of colors of nodes with
the same length and order of network vertices. This is useful when plotting a network that include different
type of node (for example, up- and down-regulated features).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_stroke.alpha">stroke.alpha</code></td>
<td>
<p>The transparency of the stroke (border) around the nodes which should
be a number between 0 and 1 (default is set to 0.6).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_show.labels">show.labels</code></td>
<td>
<p>Logical scalar, whether to show node labels or not (default is set to TRUE).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_label.cex">label.cex</code></td>
<td>
<p>The amount by which node labels should be scaled relative to the node sizes (default is set to 0.4).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_label.color">label.color</code></td>
<td>
<p>The color of node labels (default is set to &quot;black&quot;).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to draw the network as directed or not (default is set to FALSE).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_arrow.width">arrow.width</code></td>
<td>
<p>The width of arrows in the case the network is directed (default is set to 25).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_arrow.length">arrow.length</code></td>
<td>
<p>The length of arrows in inch in the case the network is directed (default is set to 0.07).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_edge.width">edge.width</code></td>
<td>
<p>The constant width of edges if the network is unweighted (default is set to 0.5).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_weighted">weighted</code></td>
<td>
<p>Logical scalar, whether the network is a weighted network or not (default is set to FALSE).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_edge.width.min">edge.width.min</code></td>
<td>
<p>The width of edges with the lowest weight (default is set to 0.2).
This parameter is ignored for unweighted networks.</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_edge.width.max">edge.width.max</code></td>
<td>
<p>The width of edges with the highest weight (default is set to 1).
This parameter is ignored for unweighted networks.</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_edge.color">edge.color</code></td>
<td>
<p>The color of edges (default is set to &quot;grey75&quot;).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_edge.linetype">edge.linetype</code></td>
<td>
<p>The line type of edges. Current available linetypes include
<code>"twodash", "longdash", "dotdash", "dotted", "dashed", and "solid"</code> (default is set to &quot;solid&quot;).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_legend.position">legend.position</code></td>
<td>
<p>The position of legends (&quot;none&quot;, &quot;left&quot;, &quot;right&quot;,
&quot;bottom&quot;, &quot;top&quot;, or two-element numeric vector). The default is set to &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_legend.direction">legend.direction</code></td>
<td>
<p>layout of items in legends (&quot;horizontal&quot; or &quot;vertical&quot;).
The default is set to &quot;vertical&quot;.</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_legend.title">legend.title</code></td>
<td>
<p>The legend title in the string format (default is set to &quot;Centrality measure&quot;).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_boxed.legend">boxed.legend</code></td>
<td>
<p>Logical scalar, whether to draw a box around the legend or not (default is set to TRUE).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_show.plot.title">show.plot.title</code></td>
<td>
<p>Logical scalar, whether to show the plot title or not (default is set to TRUE).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_plot.title">plot.title</code></td>
<td>
<p>The plot title in the string format (default is set to &quot;Centrality Measure-based Network&quot;).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_title.position">title.position</code></td>
<td>
<p>The position of title (&quot;left&quot;, &quot;center&quot;, or &quot;right&quot;). The default is set to &quot;center&quot;.</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_show.bottom.border">show.bottom.border</code></td>
<td>
<p>Logical scalar, whether to draw the bottom border line (default is set to TRUE).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_show.left.border">show.left.border</code></td>
<td>
<p>Logical scalar, whether to draw the left border line (default is set to TRUE).</p>
</td></tr>
<tr><td><code id="cent_network.vis_+3A_seed">seed</code></td>
<td>
<p>A single value, interpreted as an integer to be used for random number generation for preparing
the network layout (default is set to 1234).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the class ggplot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ivi">ivi</a></code>
</p>
<p>Other visualization functions: 
<code><a href="#topic+exir.vis">exir.vis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- coexpression.data
My_graph &lt;- graph_from_data_frame(MyData)
Graph_IVI &lt;- ivi(graph = My_graph, mode = "all")
Graph_IVI_plot &lt;- cent_network.vis(graph = My_graph, cent.metric = Graph_IVI,
                                   legend.title = "IVI",
                                   plot.title = "IVI-based Network")

## End(Not run)
</code></pre>

<hr>
<h2 id='centrality.measures'>Centrality measures dataset</h2><span id='topic+centrality.measures'></span>

<h3>Description</h3>

<p>The centrality measures of a co-expression network of lncRNAs and
mRNAs in lung adenocarcinoma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centrality.measures
</code></pre>


<h3>Format</h3>

<p>A data frame with 794 rows and 6 variables:
</p>

<p>\
</p>
<dl>
<dt>DC</dt><dd><p>Degree Centrality</p>
</dd>
<dt>CR</dt><dd><p>ClusterRank</p>
</dd>
<dt>NC</dt><dd><p>Neighborhood Connectivity</p>
</dd>
<dt>LH_index</dt><dd><p>Local H-index</p>
</dd>
<dt>BC</dt><dd><p>Betweenness Centrality</p>
</dd>
<dt>CI</dt><dd><p>Collective Influence</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p><a href="https://pubmed.ncbi.nlm.nih.gov/31211495/">https://pubmed.ncbi.nlm.nih.gov/31211495/</a>
</p>

<hr>
<h2 id='clusterRank'>ClusterRank (CR)</h2><span id='topic+clusterRank'></span><span id='topic+CR'></span>

<h3>Description</h3>

<p>This function calculates the ClusterRank of input vertices and
works with both directed and undirected networks.
This function and all of its descriptions have been adapted from the centiserve package with
some minor modifications. ClusterRank is a local ranking algorithm which takes into account not only
the number of neighbors and the neighbors’ influences, but also the clustering coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterRank(
  graph,
  vids = V(graph),
  directed = FALSE,
  loops = TRUE,
  ncores = "default",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterRank_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="clusterRank_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="clusterRank_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to directed graph is analyzed. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="clusterRank_+3A_loops">loops</code></td>
<td>
<p>Logical; whether the loop edges are also counted.</p>
</td></tr>
<tr><td><code id="clusterRank_+3A_ncores">ncores</code></td>
<td>
<p>Integer; the number of cores to be used for parallel processing. If ncores == &quot;default&quot; (default), the number of cores 
to be used will be the max(number of available cores) - 1. We recommend leaving ncores argument as is (ncores = &quot;default&quot;).</p>
</td></tr>
<tr><td><code id="clusterRank_+3A_verbose">verbose</code></td>
<td>
<p>Logical; whether the accomplishment of different stages of the algorithm should be printed (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector contaning the ClusterRank centrality scores for the selected vertices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ivi">ivi</a></code>,
<code><a href="#topic+cent_network.vis">cent_network.vis</a></code>
</p>
<p>Other centrality functions: 
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+collective.influence">collective.influence</a>()</code>,
<code><a href="#topic+h_index">h_index</a>()</code>,
<code><a href="#topic+lh_index">lh_index</a>()</code>,
<code><a href="#topic+neighborhood.connectivity">neighborhood.connectivity</a>()</code>,
<code><a href="#topic+sirir">sirir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- coexpression.data
My_graph &lt;- graph_from_data_frame(MyData)
GraphVertices &lt;- V(My_graph)
cr &lt;- clusterRank(graph = My_graph, vids = GraphVertices, 
directed = FALSE, loops = TRUE, ncores = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='coexpression.adjacency'>Adjacency matrix</h2><span id='topic+coexpression.adjacency'></span>

<h3>Description</h3>

<p>The adjacency matrix of a co-expression network of lncRNAs and
mRNAs in lung adenocarcinoma that was generated using igraph functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coexpression.adjacency
</code></pre>


<h3>Format</h3>

<p>A data frame with 794 rows and 794 variables:
</p>

<dl>
<dt>lncRNA</dt><dd><p>lncRNA symbol</p>
</dd>
<dt>lncRNA</dt><dd><p>lncRNA symbol</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p><a href="https://pubmed.ncbi.nlm.nih.gov/31211495/">https://pubmed.ncbi.nlm.nih.gov/31211495/</a>
</p>

<hr>
<h2 id='coexpression.data'>Co-expression dataset</h2><span id='topic+coexpression.data'></span>

<h3>Description</h3>

<p>A co-expression dataset of lncRNAs and mRNAs in lung adenocarcinoma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coexpression.data
</code></pre>


<h3>Format</h3>

<p>A data frame with 2410 rows and 2 variables:
</p>

<dl>
<dt>lncRNA</dt><dd><p>lncRNA symbol</p>
</dd>
<dt>Coexpressed.Gene</dt><dd><p>Co-expressed gene symbol</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p><a href="https://pubmed.ncbi.nlm.nih.gov/31211495/">https://pubmed.ncbi.nlm.nih.gov/31211495/</a>
</p>

<hr>
<h2 id='collective.influence'>Collective Influence (CI)</h2><span id='topic+collective.influence'></span><span id='topic+CI'></span>

<h3>Description</h3>

<p>This function calculates the collective influence of input vertices and
works with both directed and undirected networks. This function and its descriptions are
obtained from https://github.com/ronammar/collective_influence with minor modifications.
Collective Influence as described by Morone &amp; Makse (2015). In simple terms,
it is the product of the reduced degree (degree - 1) of a node and the total (sum of) reduced
degrees of all nodes at a distance d from the node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collective.influence(
  graph,
  vertices = V(graph),
  mode = "all",
  d = 3,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collective.influence_+3A_graph">graph</code></td>
<td>
<p>A graph (network) of the igraph class.</p>
</td></tr>
<tr><td><code id="collective.influence_+3A_vertices">vertices</code></td>
<td>
<p>A vector of desired vertices, which could be obtained by the V function.</p>
</td></tr>
<tr><td><code id="collective.influence_+3A_mode">mode</code></td>
<td>
<p>The mode of collective influence depending on the directedness of the graph.
If the graph is undirected, the mode &quot;all&quot; should be specified.
Otherwise, for the calculation of collective influence based on
incoming connections select &quot;in&quot; and for the outgoing connections select &quot;out&quot;.
Also, if all of the connections are desired, specify the &quot;all&quot; mode. Default mode is set to &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="collective.influence_+3A_d">d</code></td>
<td>
<p>The distance, expressed in number of steps from a given node (default=3). Distance
must be &gt; 0. According to Morone &amp; Makse (https://doi.org/10.1038/nature14604), optimal
results can be reached at d=3,4, but this depends on the size/&quot;radius&quot; of the network.
NOTE: the distance d is not inclusive. This means that nodes at a distance of 3 from
our node-of-interest do not include nodes at distances 1 and 2. Only 3.</p>
</td></tr>
<tr><td><code id="collective.influence_+3A_verbose">verbose</code></td>
<td>
<p>Logical; whether the accomplishment of different stages of the algorithm should be printed (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of collective influence for each vertex of the graph corresponding to
the order of vertices output by V(graph).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ivi">ivi</a></code>,
<code><a href="#topic+cent_network.vis">cent_network.vis</a></code>
</p>
<p>Other centrality functions: 
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+clusterRank">clusterRank</a>()</code>,
<code><a href="#topic+h_index">h_index</a>()</code>,
<code><a href="#topic+lh_index">lh_index</a>()</code>,
<code><a href="#topic+neighborhood.connectivity">neighborhood.connectivity</a>()</code>,
<code><a href="#topic+sirir">sirir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- coexpression.data
My_graph &lt;- graph_from_data_frame(MyData)
GraphVertices &lt;- V(My_graph)
ci &lt;- collective.influence(graph = My_graph, vertices = GraphVertices, mode = "all", d=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='comp_manipulate'>Computational manipulation of cells</h2><span id='topic+comp_manipulate'></span>

<h3>Description</h3>

<p>This function works based on the SIRIR (SIR-based Influence Ranking) model and could be applied on the
output of the ExIR model or any other independent association network. For feature (gene/protein/etc.)
knockout the SIRIR model is used to remove the feature from the network and assess its impact on the
flow of information (signaling) within the network. On the other hand, in case of up-regulation a node similar
to the desired node is added to the network with exactly the same connections (edges) as of the original node.
Next, the SIRIR model is used to evaluate the difference in the flow of information/signaling after adding (up-regulating)
the desired feature/node compared with the original network. In case you are applying this function on the output of
ExIR model, you may note that as the gene/protein knockout would impact on the integrity of the under-investigation network
as well as the networks of other overlapping biological processes/pathways, it is recommended to select those features that
simultaneously have the highest (most significant) ExIR-based rank and lowest knockout rank. In contrast, as the up-regulation
would not affect the integrity of the network, you may select the features with highest (most significant) ExIR-based and
up-regulation-based ranks.
A shiny app has also been developed for Running the ExIR model, visualization of its results as well as computational
simulation of knockout and/or up-regulation of its top candidate outputs, which is accessible using
the 'influential::runShinyApp(&quot;ExIR&quot;)' command.
You can also access the shiny app online at https://influential.erc.monash.edu/.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_manipulate(
  exir_output = NULL,
  graph = NULL,
  ko_vertices = igraph::V(graph),
  upregulate_vertices = igraph::V(graph),
  beta = 0.5,
  gamma = 1,
  no.sim = 100,
  node_verbose = FALSE,
  loop_verbose = TRUE,
  ncores = "default",
  seed = 1234
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_manipulate_+3A_exir_output">exir_output</code></td>
<td>
<p>The output of the ExIR model (optional).</p>
</td></tr>
<tr><td><code id="comp_manipulate_+3A_graph">graph</code></td>
<td>
<p>A graph (network) of the igraph class (not required if the exir_output is inputted).</p>
</td></tr>
<tr><td><code id="comp_manipulate_+3A_ko_vertices">ko_vertices</code></td>
<td>
<p>A vector of desired vertices/features to knockout. Default is set to V(graph) meaning to assess
the knockout of all vertices/features.</p>
</td></tr>
<tr><td><code id="comp_manipulate_+3A_upregulate_vertices">upregulate_vertices</code></td>
<td>
<p>A vector of desired vertices/features to up-regulate. Default is set to V(graph) meaning to assess
the up-regulation of all vertices/features.</p>
</td></tr>
<tr><td><code id="comp_manipulate_+3A_beta">beta</code></td>
<td>
<p>Non-negative scalar corresponding to the SIRIR model. The rate of infection of an individual that is susceptible
and has a single infected neighbor. The infection rate of a susceptible individual with n
infected neighbors is n times beta. Formally this is the rate parameter of an exponential
distribution.</p>
</td></tr>
<tr><td><code id="comp_manipulate_+3A_gamma">gamma</code></td>
<td>
<p>Positive scalar corresponding to the SIRIR model. The rate of recovery of an infected individual.
Formally, this is the rate parameter of an exponential distribution.</p>
</td></tr>
<tr><td><code id="comp_manipulate_+3A_no.sim">no.sim</code></td>
<td>
<p>Integer scalar corresponding to the SIRIR model. The number of simulation runs to perform SIR model on for the
original network as well perturbed networks generated by leave-one-out technique.
You may choose a different no.sim based on the available memory on your system.</p>
</td></tr>
<tr><td><code id="comp_manipulate_+3A_node_verbose">node_verbose</code></td>
<td>
<p>Logical; whether the process of Parallel Socket Cluster creation should be printed (default is FALSE).</p>
</td></tr>
<tr><td><code id="comp_manipulate_+3A_loop_verbose">loop_verbose</code></td>
<td>
<p>Logical; whether the accomplishment of the evaluation of network nodes in each loop should be printed (default is TRUE).</p>
</td></tr>
<tr><td><code id="comp_manipulate_+3A_ncores">ncores</code></td>
<td>
<p>Integer; the number of cores to be used for parallel processing. If ncores == &quot;default&quot; (default), the number of 
cores to be used will be the max(number of available cores) - 1. We recommend leaving ncores argument as is (ncores = &quot;default&quot;).</p>
</td></tr>
<tr><td><code id="comp_manipulate_+3A_seed">seed</code></td>
<td>
<p>A single value, interpreted as an integer to be used for random number generation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input data, a list including one to three data frames of knockout/up-regulation rankings.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exir">exir</a></code>, <code><a href="#topic+sirir">sirir</a></code>,
and <code><a href="igraph.html#topic+sir">sir</a></code> for a complete description on SIR model
</p>
<p>Other integrative ranking functions: 
<code><a href="#topic+exir">exir</a>()</code>,
<code><a href="#topic+hubness.score">hubness.score</a>()</code>,
<code><a href="#topic+ivi.from.indices">ivi.from.indices</a>()</code>,
<code><a href="#topic+ivi">ivi</a>()</code>,
<code><a href="#topic+spreading.score">spreading.score</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1234)
My_graph &lt;- igraph::sample_gnp(n=50, p=0.05)
GraphVertices &lt;- V(My_graph)
Computational_manipulation &lt;- comp_manipulate(graph = My_graph, beta = 0.5,
                                              gamma = 1, no.sim = 10, seed = 1234)
                                              
## End(Not run)
</code></pre>

<hr>
<h2 id='cond.prob.analysis'>Conditional probability of deviation from means</h2><span id='topic+cond.prob.analysis'></span><span id='topic+CPA'></span>

<h3>Description</h3>

<p>This function calculates the conditional probability of deviation of two
centrality measures (or any two other continuous variables) from their corresponding
means in opposite directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond.prob.analysis(data, nodes.colname, Desired.colname, Condition.colname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cond.prob.analysis_+3A_data">data</code></td>
<td>
<p>A data frame containing the values of two continuous variables and the name of
observations (nodes).</p>
</td></tr>
<tr><td><code id="cond.prob.analysis_+3A_nodes.colname">nodes.colname</code></td>
<td>
<p>The character format (quoted) name of the column containing
the name of observations (nodes).</p>
</td></tr>
<tr><td><code id="cond.prob.analysis_+3A_desired.colname">Desired.colname</code></td>
<td>
<p>The character format (quoted) name of the column containing
the values of the desired variable.</p>
</td></tr>
<tr><td><code id="cond.prob.analysis_+3A_condition.colname">Condition.colname</code></td>
<td>
<p>The character format (quoted) name of the column containing
the values of the condition variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two objects including the conditional probability of deviation of two
centrality measures (or any two other continuous variables) from their corresponding
means in opposite directions based on both the entire network and the split-half random
sample of network nodes.
</p>


<h3>See Also</h3>

<p>Other centrality association assessment functions: 
<code><a href="#topic+double.cent.assess.noRegression">double.cent.assess.noRegression</a>()</code>,
<code><a href="#topic+double.cent.assess">double.cent.assess</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- centrality.measures
My.conditional.prob &lt;- cond.prob.analysis(data = MyData,
                                          nodes.colname = rownames(MyData),
                                          Desired.colname = "BC",
                                          Condition.colname = "NC")
                                          
## End(Not run)
</code></pre>

<hr>
<h2 id='diff_data.assembly'>Assembling the differential/regression data</h2><span id='topic+diff_data.assembly'></span><span id='topic+DDA'></span>

<h3>Description</h3>

<p>This function assembles a dataframe required for running the <em><strong><code>ExIR</code></strong></em> model. You may provide
as many differential/regression data as you wish. Also, the datasets should be filtered
beforehand according to your desired thresholds and, consequently, should only include the significant data.
Each dataset provided should be a dataframe with one or two columns.
The first column should always include differential/regression values
and the second one (if provided) the significance values. Please also note that the significance (adjusted P-value)
column is mandatory for differential datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_data.assembly(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_data.assembly_+3A_...">...</code></td>
<td>
<p>Desired datasets/dataframes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe including the collective list of features in rows and all of the
differential/regression data and their statistical significance in columns with the same
order provided by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exir">exir</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
my.Diff_data &lt;- diff_data.assembly(Differential_data1,
                                   Differential_data2,
                                   Regression_data1)

## End(Not run)
</code></pre>

<hr>
<h2 id='double.cent.assess'>Assessment of innate features and associations of two network centrality measures (dependent and independent)</h2><span id='topic+double.cent.assess'></span><span id='topic+DCA'></span>

<h3>Description</h3>

<p>This function assesses innate features and the association of two centrality measures
(or any two other continuous variables) from the aspect of distribution mode, dependence,
linearity, monotonicity, partial-moments based correlation, and conditional probability of
deviating from corresponding means in opposite direction. This function assumes one
variable as dependent and the other as independent for regression analyses. The non-linear nature of
the association of two centrality measures is evaluated based on generalized additive models (GAM).
The monotonicity of the association is evaluated based on comparing the squared coefficient of
Spearman correlation and R-squared of rank regression analysis.
Also, the correlation between two variables is assessed via non-linear non-parametric statistics (NNS).
For the conditional probability assessment, the independent variable is considered as the condition variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>double.cent.assess(
  data,
  nodes.colname,
  dependent.colname,
  independent.colname,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="double.cent.assess_+3A_data">data</code></td>
<td>
<p>A data frame containing the values of two continuous variables and the name of
observations (nodes).</p>
</td></tr>
<tr><td><code id="double.cent.assess_+3A_nodes.colname">nodes.colname</code></td>
<td>
<p>The character format (quoted) name of the column containing
the name of observations (nodes).</p>
</td></tr>
<tr><td><code id="double.cent.assess_+3A_dependent.colname">dependent.colname</code></td>
<td>
<p>The character format (quoted) name of the column containing
the values of the dependent variable.</p>
</td></tr>
<tr><td><code id="double.cent.assess_+3A_independent.colname">independent.colname</code></td>
<td>
<p>The character format (quoted) name of the column containing
the values of the independent variable.</p>
</td></tr>
<tr><td><code id="double.cent.assess_+3A_plot">plot</code></td>
<td>
<p>logical; FALSE (default) Plots quadrant means of NNS correlation analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 11 objects including:
</p>
<p>- Summary of the basic statistics of two centrality measures (or any two other continuous variables).
</p>
<p>- The results of normality assessment of two variable (p-value &gt; 0.05 imply that the variable is normally distributed).
</p>
<p>- Description of the normality assessment of the dependent variable.
</p>
<p>- Description of the normality assessment of the independent variable.
</p>
<p>- Results of the generalized additive modeling (GAM) of the data.
</p>
<p>- The association type based on simultaneous consideration of normality assessment,
GAM Computation with smoothness estimation, Spearman correlation, and ranked regression analysis of splines.
</p>
<p>- The Hoeffding's D Statistic of dependence (ranging from -0.5 to 1).
</p>
<p>- Description of the dependence significance.
</p>
<p>- Correlation between variables based on the NNS method.
</p>
<p>- The last two objects are the conditional probability of deviation of two
centrality measures from their corresponding means in opposite directions based
on both the entire network and the split-half random sample of network nodes.
</p>


<h3>See Also</h3>

<p><code><a href="nortest.html#topic+ad.test">ad.test</a></code> for Anderson-Darling test for normality,
<code><a href="mgcv.html#topic+gam">gam</a></code> for Generalized additive models with integrated smoothness estimation,
<code><a href="stats.html#topic+lm">lm</a></code> for Fitting Linear Models,
<code><a href="Hmisc.html#topic+hoeffd">hoeffd</a></code> for Matrix of Hoeffding's D Statistics, and
<code><a href="NNS.html#topic+NNS.dep">NNS.dep</a></code> for NNS Dependence
</p>
<p>Other centrality association assessment functions: 
<code><a href="#topic+cond.prob.analysis">cond.prob.analysis</a>()</code>,
<code><a href="#topic+double.cent.assess.noRegression">double.cent.assess.noRegression</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- centrality.measures
My.metrics.assessment &lt;- double.cent.assess(data = MyData,
                                            nodes.colname = rownames(MyData),
                                            dependent.colname = "BC",
                                            independent.colname = "NC")

## End(Not run)
</code></pre>

<hr>
<h2 id='double.cent.assess.noRegression'>Assessment of innate features and associations of two network centrality measures</h2><span id='topic+double.cent.assess.noRegression'></span><span id='topic+DCANR'></span>

<h3>Description</h3>

<p>This function assesses innate features and the association of two centrality measures
(or any two other continuous variables) from the aspect of distribution mode, dependence,
linearity, partial-moments based correlation, and conditional probability of
deviating from corresponding means in opposite direction (centrality2 is used as the condition variable).
This function doesn't consider which variable is dependent and which one is
independent and no regression analysis is done.
Also, the correlation between two variables is assessed via non-linear non-parametric statistics (NNS).
For the conditional probability assessment, the centrality2 variable is considered
as the condition variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>double.cent.assess.noRegression(
  data,
  nodes.colname,
  centrality1.colname,
  centrality2.colname
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="double.cent.assess.noRegression_+3A_data">data</code></td>
<td>
<p>A data frame containing the values of two continuous variables and the name of
observations (nodes).</p>
</td></tr>
<tr><td><code id="double.cent.assess.noRegression_+3A_nodes.colname">nodes.colname</code></td>
<td>
<p>The character format (quoted) name of the column containing
the name of observations (nodes).</p>
</td></tr>
<tr><td><code id="double.cent.assess.noRegression_+3A_centrality1.colname">centrality1.colname</code></td>
<td>
<p>The character format (quoted) name of the column containing
the values of the Centrality_1 variable.</p>
</td></tr>
<tr><td><code id="double.cent.assess.noRegression_+3A_centrality2.colname">centrality2.colname</code></td>
<td>
<p>The character format (quoted) name of the column containing
the values of the Centrality_2 variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of nine objects including:
</p>
<p>- Summary of the basic statistics of two centrality measures (or any two other continuous variables).
</p>
<p>- The results of normality assessment of two variable (p-value &gt; 0.05 imply that the variable is normally distributed).
</p>
<p>- Description of the normality assessment of the centrality1 (first variable).
</p>
<p>- Description of the normality assessment of the centrality2 (second variable).
</p>
<p>- The Hoeffding's D Statistic of dependence (ranging from -0.5 to 1).
</p>
<p>- Description of the dependence significance.
</p>
<p>- Correlation between variables based on the NNS method.
</p>
<p>- The last two objects are the conditional probability of deviation of two
centrality measures from their corresponding means in opposite directions based
on both the entire network and the split-half random sample of network nodes.
</p>


<h3>See Also</h3>

<p><code><a href="nortest.html#topic+ad.test">ad.test</a></code> for Anderson-Darling test for normality,
<code><a href="Hmisc.html#topic+hoeffd">hoeffd</a></code> for Matrix of Hoeffding's D Statistics, and
<code><a href="NNS.html#topic+NNS.dep">NNS.dep</a></code> for NNS Dependence
</p>
<p>Other centrality association assessment functions: 
<code><a href="#topic+cond.prob.analysis">cond.prob.analysis</a>()</code>,
<code><a href="#topic+double.cent.assess">double.cent.assess</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- centrality.measures
My.metrics.assessment &lt;- double.cent.assess.noRegression(data = MyData,
                                            nodes.colname = rownames(MyData),
                                            centrality1.colname = "BC",
                                            centrality2.colname = "NC")

## End(Not run)
</code></pre>

<hr>
<h2 id='exir'>Experimental data-based Integrated Ranking</h2><span id='topic+exir'></span><span id='topic+ExIR'></span>

<h3>Description</h3>

<p>This function runs the Experimental data-based Integrated Ranking (ExIR)
model for the classification and ranking of top candidate features. The input
data could come from any type of experiment such as transcriptomics and proteomics.
A shiny app has also been developed for Running the ExIR model, visualization of its results as well as computational
simulation of knockout and/or up-regulation of its top candidate outputs, which is accessible using
the 'influential::runShinyApp(&quot;ExIR&quot;)' command.
You can also access the shiny app online at https://influential.erc.monash.edu/.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exir(
  Desired_list = NULL,
  Diff_data,
  Diff_value,
  Regr_value = NULL,
  Sig_value,
  Exptl_data,
  Condition_colname,
  Normalize = FALSE,
  cor_thresh_method = "mr",
  r = 0.5,
  mr = 20,
  max.connections = 50000,
  alpha = 0.05,
  num_trees = 10000,
  mtry = NULL,
  num_permutations = 100,
  inf_const = 10^10,
  ncores = "default",
  seed = 1234,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exir_+3A_desired_list">Desired_list</code></td>
<td>
<p>(Optional) A character vector of your desired features. This vector could be, for
instance, a list of features obtained from cluster analysis, time-course analysis,
or a list of dysregulated features with a specific sign.</p>
</td></tr>
<tr><td><code id="exir_+3A_diff_data">Diff_data</code></td>
<td>
<p>A dataframe of all significant differential/regression data and their
statistical significance values (p-value/adjusted p-value). Note that the differential data
should be in the log fold-change (log2FC) format.
You may have selected a proportion of the differential data as the significant ones according
to your desired thresholds. A function, named <code><a href="#topic+diff_data.assembly">diff_data.assembly</a></code>, has also been
provided for the convenient assembling of the Diff_data dataframe.</p>
</td></tr>
<tr><td><code id="exir_+3A_diff_value">Diff_value</code></td>
<td>
<p>An integer vector containing the column number(s) of the differential
data in the Diff_data dataframe. The differential data could result from any type of
differential data analysis. One example could be the fold changes (FCs) obtained from differential
expression analyses. The user may provide as many differential data as he/she wish.</p>
</td></tr>
<tr><td><code id="exir_+3A_regr_value">Regr_value</code></td>
<td>
<p>(Optional) An integer vector containing the column number(s) of the regression
data in the Diff_data dataframe. The regression data could result from any type of regression
data analysis or other analyses such as time-course data analyses that are based on regression models.</p>
</td></tr>
<tr><td><code id="exir_+3A_sig_value">Sig_value</code></td>
<td>
<p>An integer vector containing the column number(s) of the significance values (p-value/adjusted p-value) of
both differential and regression data (if provided). Providing significance values for the regression data is optional.</p>
</td></tr>
<tr><td><code id="exir_+3A_exptl_data">Exptl_data</code></td>
<td>
<p>A dataframe containing all of the experimental data including a column for specifying the conditions.
The features/variables of the dataframe should be as the columns and the samples should come in the rows.
The condition column should be of the character class. For example, if the study includes several replicates of
cancer and normal samples, the condition column should include &quot;cancer&quot; and &quot;normal&quot; as the conditions of different samples.
Also, the prior normalization of the experimental data is highly recommended. Otherwise,
the user may set the Normalize argument to TRUE for a simple log2 transformation of the data.
The experimental data could come from a variety sources such as transcriptomics and proteomics assays.</p>
</td></tr>
<tr><td><code id="exir_+3A_condition_colname">Condition_colname</code></td>
<td>
<p>A string or character vector specifying the name of the column &quot;condition&quot; of the Exptl_data dataframe.</p>
</td></tr>
<tr><td><code id="exir_+3A_normalize">Normalize</code></td>
<td>
<p>Logical; whether the experimental data should be normalized or not (default is FALSE). If TRUE, the
experimental data will be log2 transformed.</p>
</td></tr>
<tr><td><code id="exir_+3A_cor_thresh_method">cor_thresh_method</code></td>
<td>
<p>A character string indicating the method for filtering the correlation results, either
&quot;mr&quot; (default; Mutual Rank) or &quot;cor.coefficient&quot;.</p>
</td></tr>
<tr><td><code id="exir_+3A_r">r</code></td>
<td>
<p>The threshold of Spearman correlation coefficient for the selection of correlated features (default is 0.5).</p>
</td></tr>
<tr><td><code id="exir_+3A_mr">mr</code></td>
<td>
<p>An integer determining the threshold of mutual rank for the selection of correlated features (default is 20). Note that
higher mr values considerably increase the computation time.</p>
</td></tr>
<tr><td><code id="exir_+3A_max.connections">max.connections</code></td>
<td>
<p>The maximum number of connections to be included in the association network.
Higher max.connections might increase the computation time, cost, and accuracy of the results (default is 50,000).</p>
</td></tr>
<tr><td><code id="exir_+3A_alpha">alpha</code></td>
<td>
<p>The threshold of the statistical significance (p-value) used throughout the entire model (default is 0.05)</p>
</td></tr>
<tr><td><code id="exir_+3A_num_trees">num_trees</code></td>
<td>
<p>Number of trees to be used for the random forests classification (supervised machine learning). Default is set to 10000.</p>
</td></tr>
<tr><td><code id="exir_+3A_mtry">mtry</code></td>
<td>
<p>Number of features to possibly split at in each node. Default is the (rounded down) square root of the
number of variables. Alternatively, a single argument function returning an integer, given the number of independent variables.</p>
</td></tr>
<tr><td><code id="exir_+3A_num_permutations">num_permutations</code></td>
<td>
<p>Number of permutations to be used for computation of the statistical significance (p-values) of
the importance scores resulted from random forests classification (default is 100).</p>
</td></tr>
<tr><td><code id="exir_+3A_inf_const">inf_const</code></td>
<td>
<p>The constant value to be multiplied by the maximum absolute value of differential (logFC)
values for the substitution with infinite differential values. This results in noticeably high biomarker values for features
with infinite differential values compared with other features. Having said that, the user can still use the
biomarker rank to compare all of the features. This parameter is ignored if no infinite value
is present within Diff_data. However, this is used in the case of sc-seq experiments where some genes are uniquely
expressed in a specific cell-type and consequently get infinite differential values. Note that the sign of differential
value is preserved (default is 10^10).</p>
</td></tr>
<tr><td><code id="exir_+3A_ncores">ncores</code></td>
<td>
<p>Integer; the number of cores to be used for parallel processing. If ncores == &quot;default&quot; (default), the number of 
cores to be used will be the max(number of available cores) - 1. We recommend leaving ncores argument as is (ncores = &quot;default&quot;).</p>
</td></tr>
<tr><td><code id="exir_+3A_seed">seed</code></td>
<td>
<p>The seed to be used for all of the random processes throughout the model (default is 1234).</p>
</td></tr>
<tr><td><code id="exir_+3A_verbose">verbose</code></td>
<td>
<p>Logical; whether the accomplishment of different stages of the model should be printed (default is TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of one graph and one to four tables including:
</p>
<p>- Driver table: Top candidate drivers
</p>
<p>- DE-mediator table: Top candidate differentially expressed/abundant mediators
</p>
<p>- nonDE-mediator table: Top candidate non-differentially expressed/abundant mediators
</p>
<p>- Biomarker table: Top candidate biomarkers
</p>
<p>The number of returned tables depends on the input data and specified arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exir.vis">exir.vis</a></code>,
<code><a href="#topic+diff_data.assembly">diff_data.assembly</a></code>,
<code><a href="coop.html#topic+pcor">pcor</a></code>,
<code><a href="stats.html#topic+prcomp">prcomp</a></code>,
<code><a href="ranger.html#topic+ranger">ranger</a></code>,
<code><a href="ranger.html#topic+importance_pvalues">importance_pvalues</a></code>
</p>
<p>Other integrative ranking functions: 
<code><a href="#topic+comp_manipulate">comp_manipulate</a>()</code>,
<code><a href="#topic+hubness.score">hubness.score</a>()</code>,
<code><a href="#topic+ivi.from.indices">ivi.from.indices</a>()</code>,
<code><a href="#topic+ivi">ivi</a>()</code>,
<code><a href="#topic+spreading.score">spreading.score</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyDesired_list &lt;- Desiredlist
MyDiff_data &lt;- Diffdata
Diff_value &lt;- c(1,3,5)
Regr_value &lt;- 7
Sig_value &lt;- c(2,4,6,8)
MyExptl_data &lt;- Exptldata
Condition_colname &lt;- "condition"
My.exir &lt;- exir(Desired_list = MyDesired_list,
               Diff_data = MyDiff_data, Diff_value = Diff_value,
               Regr_value = Regr_value, Sig_value = Sig_value,
               Exptl_data = MyExptl_data, Condition_colname = Condition_colname)

## End(Not run)
</code></pre>

<hr>
<h2 id='exir.vis'>Visualization of ExIR results</h2><span id='topic+exir.vis'></span>

<h3>Description</h3>

<p>This function has been developed for the visualization of ExIR results. Some of the documentations
of the arguments of this function have been adapted from ggplot2 package.
A shiny app has also been developed for Running the ExIR model, visualization of its results as well as computational
simulation of knockout and/or up-regulation of its top candidate outputs, which is accessible using
the 'influential::runShinyApp(&quot;ExIR&quot;)' command.
You can also access the shiny app online at https://influential.erc.monash.edu/.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exir.vis(
  exir.results,
  synonyms.table = NULL,
  n = 10,
  driver.type = "combined",
  biomarker.type = "combined",
  show.drivers = TRUE,
  show.biomarkers = TRUE,
  show.de.mediators = TRUE,
  show.nonDE.mediators = TRUE,
  basis = "Rank",
  label.position = "top",
  nrow = 1,
  dot.size.min = 2,
  dot.size.max = 5,
  type.color = "viridis",
  stroke.size = 1.5,
  stroke.alpha = 1,
  dot.color.low = "blue",
  dot.color.high = "red",
  legend.position = "bottom",
  legend.direction = "vertical",
  legends.layout = "horizontal",
  boxed.legend = TRUE,
  show.plot.title = TRUE,
  plot.title = "auto",
  title.position = "left",
  plot.title.size = 12,
  show.plot.subtitle = TRUE,
  plot.subtitle = "auto",
  subtitle.position = "left",
  y.axis.title = "Feature",
  show.y.axis.grid = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exir.vis_+3A_exir.results">exir.results</code></td>
<td>
<p>An object of class <code>"ExIR_Result"</code> which is the output of the function <code>"exir"</code>.</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_synonyms.table">synonyms.table</code></td>
<td>
<p>(Optional) A data frame or matrix with two columns including a column for the used feature
names in the input data of the <code>"exir"</code> model and the other column their synonyms. Note, the original feature names should
always come as the first column and the synonyms as the second one. For example, if
the original feature names used for running the <code>"exir"</code> model are Ensembl gene
symbols, you can use their HGNC synonyms in the second column to be used for the visualization of the ExIR results</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_n">n</code></td>
<td>
<p>An integer specifying the number of top candidates to be selected from each category of ExIR results (default is set to 10).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_driver.type">driver.type</code></td>
<td>
<p>A string specifying the type of drivers to be used for the selection of top N candidates. The possible types
include <code>"combined"</code> (meaning both driver types), <code>"accelerator"</code> and <code>"decelerator"</code> (default is set to &quot;combined&quot;).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_biomarker.type">biomarker.type</code></td>
<td>
<p>A string specifying the type of biomarkers to be used for the selection of top N candidates. Possible types
include <code>"combined"</code> (meaning both biomarker types), <code>"up-regulated"</code> and <code>"down-regulated"</code> (default is set to &quot;combined&quot;).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_show.drivers">show.drivers</code></td>
<td>
<p>Logical scalar, whether to show Drivers or not (default is set to TRUE).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_show.biomarkers">show.biomarkers</code></td>
<td>
<p>Logical scalar, whether to show Biomarkers or not (default is set to TRUE).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_show.de.mediators">show.de.mediators</code></td>
<td>
<p>Logical scalar, whether to show DE-mediators or not (default is set to TRUE).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_show.nonde.mediators">show.nonDE.mediators</code></td>
<td>
<p>Logical scalar, whether to show nonDE-mediators or not (default is set to TRUE).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_basis">basis</code></td>
<td>
<p>A string specifying the basis for the selection of top N candidates from each category of the results. Possible options include
<code>"Rank"</code> and <code>"Adjusted p-value"</code> (default is set to &quot;Rank&quot;).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_label.position">label.position</code></td>
<td>
<p>By default, the labels are displayed on the top of the plot. Using label.position it is possible
to place the labels on either of the four sides by setting label.position = c(&quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows of the plot (default is set to 1).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_dot.size.min">dot.size.min</code></td>
<td>
<p>The size of dots with the lowest statistical significance (default is set to 2).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_dot.size.max">dot.size.max</code></td>
<td>
<p>The size of dots with the highest statistical significance (default is set to 5).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_type.color">type.color</code></td>
<td>
<p>A character string or function indicating the color palette to be used for the visualization of
different types of candidates. You may choose one of the Viridis palettes including &quot;magma&quot; (or &quot;A&quot;),
&quot;inferno&quot; (or &quot;B&quot;), &quot;plasma&quot; (or &quot;C&quot;), &quot;viridis&quot; (or &quot;D&quot;, the default option) and &quot;cividis&quot; (or &quot;E&quot;), use a function specifying
your desired palette, or manually specify the vector of colors for different types.</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_stroke.size">stroke.size</code></td>
<td>
<p>The size of stroke (border) around the dots (default is set to 1.5).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_stroke.alpha">stroke.alpha</code></td>
<td>
<p>The transparency of the stroke (border) around the dots which should
be a number between 0 and 1 (default is set to 1).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_dot.color.low">dot.color.low</code></td>
<td>
<p>The color to be used for the visualization of dots (features) with the lowest Z-score values (default is set to &quot;blue&quot;).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_dot.color.high">dot.color.high</code></td>
<td>
<p>The color to be used for the visualization of dots (features) with the highest Z-score values (default is set to &quot;red&quot;).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_legend.position">legend.position</code></td>
<td>
<p>The position of legends (&quot;none&quot;, &quot;left&quot;, &quot;right&quot;,
&quot;bottom&quot;, &quot;top&quot;, or two-element numeric vector). The default is set to &quot;bottom&quot;.</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_legend.direction">legend.direction</code></td>
<td>
<p>Layout of items in legends (&quot;horizontal&quot; or &quot;vertical&quot;).
The default is set to &quot;vertical&quot;.</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_legends.layout">legends.layout</code></td>
<td>
<p>Layout of different legends of the plot (&quot;horizontal&quot; or &quot;vertical&quot;).
The default is set to &quot;horizontal&quot;.</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_boxed.legend">boxed.legend</code></td>
<td>
<p>Logical scalar, whether to draw a box around the legend or not (default is set to TRUE).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_show.plot.title">show.plot.title</code></td>
<td>
<p>Logical scalar, whether to show the plot title or not (default is set to TRUE).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_plot.title">plot.title</code></td>
<td>
<p>The plot title in the string format (default is set to &quot;auto&quot; which automatically generates a title for the plot).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_title.position">title.position</code></td>
<td>
<p>The position of title (&quot;left&quot;, &quot;center&quot;, or &quot;right&quot;). The default is set to &quot;left&quot;.</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_plot.title.size">plot.title.size</code></td>
<td>
<p>The font size of the plot title (default is set to 12).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_show.plot.subtitle">show.plot.subtitle</code></td>
<td>
<p>Logical scalar, whether to show the plot subtitle or not (default is set to TRUE).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_plot.subtitle">plot.subtitle</code></td>
<td>
<p>The plot subtitle in the string format (default is set to &quot;auto&quot; which automatically generates a subtitle for the plot).</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_subtitle.position">subtitle.position</code></td>
<td>
<p>The position of subtitle (&quot;left&quot;, &quot;center&quot;, or &quot;right&quot;). The default is set to &quot;left&quot;.</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_y.axis.title">y.axis.title</code></td>
<td>
<p>The title of the y axis (features title). Default is set to &quot;Features&quot;.</p>
</td></tr>
<tr><td><code id="exir.vis_+3A_show.y.axis.grid">show.y.axis.grid</code></td>
<td>
<p>Logical scalar, whether to draw y axis grid lines (default is set to TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the class ggplot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exir">exir</a></code>
</p>
<p>Other visualization functions: 
<code><a href="#topic+cent_network.vis">cent_network.vis</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyResults &lt;- exir.results
ExIR.plot &lt;- exir.vis(exir.results = MyResults, n = 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='fcor'>Fast correlation and mutual rank analysis</h2><span id='topic+fcor'></span>

<h3>Description</h3>

<p>This function calculates Pearson/Spearman correlations between all pairs of features in a matrix/dataframe much faster than the base R cor function.
It is also possible to simultaneously calculate mutual rank (MR) of correlations as well as their p-values and adjusted p-values.
Additionally, this function can automatically combine and flatten the result matrices. Selecting correlated features using an MR-based threshold
rather than based on their correlation coefficients or an arbitrary p-value is more efficient and accurate in inferring
functional associations in systems, for example in gene regulatory networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcor(
  data,
  use = "everything",
  method = "spearman",
  mutualRank = TRUE,
  mutualRank_mode = "unsigned",
  pvalue = FALSE,
  adjust = "BH",
  flat = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fcor_+3A_data">data</code></td>
<td>
<p>a numeric dataframe/matrix (features on columns and samples on rows).</p>
</td></tr>
<tr><td><code id="fcor_+3A_use">use</code></td>
<td>
<p>The NA handler, as in R's cov() and cor() functions. Options are &quot;everything&quot;, &quot;all.obs&quot;, and &quot;complete.obs&quot;.</p>
</td></tr>
<tr><td><code id="fcor_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be computed. One of &quot;pearson&quot; or &quot;spearman&quot; (default).</p>
</td></tr>
<tr><td><code id="fcor_+3A_mutualrank">mutualRank</code></td>
<td>
<p>logical, whether to calculate mutual ranks of correlations or not.</p>
</td></tr>
<tr><td><code id="fcor_+3A_mutualrank_mode">mutualRank_mode</code></td>
<td>
<p>a character string indicating whether to rank based on &quot;signed&quot; or &quot;unsigned&quot; (default) correlation values. 
In the &quot;unsigned&quot; mode, only the level of a correlation value is important and not its sign (the function ranks the absolutes of correlations). 
Options are &quot;unsigned&quot;, and &quot;signed&quot;.</p>
</td></tr>
<tr><td><code id="fcor_+3A_pvalue">pvalue</code></td>
<td>
<p>logical, whether to calculate p-values of correlations or not.</p>
</td></tr>
<tr><td><code id="fcor_+3A_adjust">adjust</code></td>
<td>
<p>p-value correction method (when pvalue = TRUE), a character string including any of &quot;BH&quot; (default),
&quot;bonferroni&quot;, &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="fcor_+3A_flat">flat</code></td>
<td>
<p>logical, whether to combine and flatten the result matrices or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input data, a dataframe or list including cor (correlation coefficients),
mr (mutual ranks of correlation coefficients), p (p-values of correlation coefficients), and p.adj (adjusted p-values).
</p>


<h3>See Also</h3>

<p><code><a href="coop.html#topic+pcor">pcor</a></code>, <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>,
and <code><a href="#topic+graph_from_data_frame">graph_from_data_frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1234)
data &lt;- datasets::attitude
cor &lt;- fcor(data = data)

## End(Not run)
</code></pre>

<hr>
<h2 id='h_index'>H-index</h2><span id='topic+h_index'></span><span id='topic+h.index'></span>

<h3>Description</h3>

<p>This function calculates the H-index of input vertices and
works with both directed and undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_index(graph, vertices = V(graph), mode = "all", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h_index_+3A_graph">graph</code></td>
<td>
<p>A graph (network) of the igraph class.</p>
</td></tr>
<tr><td><code id="h_index_+3A_vertices">vertices</code></td>
<td>
<p>A vector of desired vertices, which could be obtained by the V function.</p>
</td></tr>
<tr><td><code id="h_index_+3A_mode">mode</code></td>
<td>
<p>The mode of H-index depending on the directedness of the graph.
If the graph is undirected, the mode &quot;all&quot; should be specified.
Otherwise, for the calculation of H-index based on
incoming connections select &quot;in&quot; and for the outgoing connections select &quot;out&quot;.
Also, if all of the connections are desired, specify the &quot;all&quot; mode. Default mode is set to &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="h_index_+3A_verbose">verbose</code></td>
<td>
<p>Logical; whether the accomplishment of different stages of the algorithm should be printed (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector including the H-index of each vertex inputted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ivi">ivi</a></code>,
<code><a href="#topic+cent_network.vis">cent_network.vis</a></code>
</p>
<p>Other centrality functions: 
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+clusterRank">clusterRank</a>()</code>,
<code><a href="#topic+collective.influence">collective.influence</a>()</code>,
<code><a href="#topic+lh_index">lh_index</a>()</code>,
<code><a href="#topic+neighborhood.connectivity">neighborhood.connectivity</a>()</code>,
<code><a href="#topic+sirir">sirir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- coexpression.data
My_graph &lt;- graph_from_data_frame(MyData)
GraphVertices &lt;- V(My_graph)
h.index &lt;- h_index(graph = My_graph, vertices = GraphVertices, mode = "all")

## End(Not run)
</code></pre>

<hr>
<h2 id='hubness.score'>Hubness score</h2><span id='topic+hubness.score'></span>

<h3>Description</h3>

<p>This function calculates the Hubness score of the desired nodes from a graph.
Hubness score reflects the power of each node in its surrounding environment and is
one of the major components of the IVI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hubness.score(
  graph,
  vertices = V(graph),
  directed = FALSE,
  mode = "all",
  loops = TRUE,
  scale = "range",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hubness.score_+3A_graph">graph</code></td>
<td>
<p>A graph (network) of the igraph class.</p>
</td></tr>
<tr><td><code id="hubness.score_+3A_vertices">vertices</code></td>
<td>
<p>A vector of desired vertices, which could be obtained by the V function.</p>
</td></tr>
<tr><td><code id="hubness.score_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to directed graph is analyzed. This argument
is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="hubness.score_+3A_mode">mode</code></td>
<td>
<p>The mode of Hubness score depending on the directedness of the graph.
If the graph is undirected, the mode &quot;all&quot; should be specified.
Otherwise, for the calculation of Hubness score based on
incoming connections select &quot;in&quot; and for the outgoing connections select &quot;out&quot;.
Also, if all of the connections are desired, specify the &quot;all&quot; mode. Default mode is set to &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="hubness.score_+3A_loops">loops</code></td>
<td>
<p>Logical; whether the loop edges are also counted.</p>
</td></tr>
<tr><td><code id="hubness.score_+3A_scale">scale</code></td>
<td>
<p>Character string; the method used for scaling/normalizing the results. Options include 'range' (normalization within a 1-100 range), 
'z-scale' (standardization using the z-score), and 'none' (no data scaling). The default selection is 'range'. Opting for the 'range' method is 
suitable when exploring a single network, allowing you to observe the complete spectrum and distribution of node influences. In this case, there is 
no intention to establish a specific threshold for the outcomes. However, it is possible to identify and present the top hub nodes 
based on their rankings. Conversely, the 'z-scale' option proves advantageous if the aim is to compare node influences across multiple networks or 
if there is a desire to establish a threshold (usually z-score &gt; 1.645) for generating a list of the most hub nodes without manual intervention.</p>
</td></tr>
<tr><td><code id="hubness.score_+3A_verbose">verbose</code></td>
<td>
<p>Logical; whether the accomplishment of different stages of the algorithm should be printed (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the Hubness scores.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cent_network.vis">cent_network.vis</a></code>
</p>
<p>Other integrative ranking functions: 
<code><a href="#topic+comp_manipulate">comp_manipulate</a>()</code>,
<code><a href="#topic+exir">exir</a>()</code>,
<code><a href="#topic+ivi.from.indices">ivi.from.indices</a>()</code>,
<code><a href="#topic+ivi">ivi</a>()</code>,
<code><a href="#topic+spreading.score">spreading.score</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- coexpression.data
My_graph &lt;- graph_from_data_frame(MyData)
GraphVertices &lt;- V(My_graph)
Hubness.score &lt;- hubness.score(graph = My_graph, vertices = GraphVertices,
                               directed = FALSE, mode = "all",
                               loops = TRUE, scale = "range")

## End(Not run)
</code></pre>

<hr>
<h2 id='ivi'>Integrated Value of Influence (IVI)</h2><span id='topic+ivi'></span><span id='topic+IVI'></span>

<h3>Description</h3>

<p>This function calculates the IVI of the desired nodes from a graph.
#' A shiny app has also been developed for the calculation of IVI as well as IVI-based network
visualization, which is accessible using the 'influential::runShinyApp(&quot;IVI&quot;)' command.
You can also access the shiny app online at https://influential.erc.monash.edu/.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivi(
  graph,
  vertices = V(graph),
  weights = NULL,
  directed = FALSE,
  mode = "all",
  loops = TRUE,
  d = 3,
  scale = "range",
  ncores = "default",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ivi_+3A_graph">graph</code></td>
<td>
<p>A graph (network) of the igraph class.</p>
</td></tr>
<tr><td><code id="ivi_+3A_vertices">vertices</code></td>
<td>
<p>A vector of desired vertices, which could be obtained by the V function.</p>
</td></tr>
<tr><td><code id="ivi_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted betweenness centrality
of nodes as a requirement for calculation of IVI. If the graph has a weight edge attribute,
then this is used by default. Weights are used to calculate weighted shortest paths,
so they are interpreted as distances.</p>
</td></tr>
<tr><td><code id="ivi_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to directed graph is analyzed. This argument
is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="ivi_+3A_mode">mode</code></td>
<td>
<p>The mode of IVI depending on the directedness of the graph.
If the graph is undirected, the mode &quot;all&quot; should be specified.
Otherwise, for the calculation of IVI based on
incoming connections select &quot;in&quot; and for the outgoing connections select &quot;out&quot;.
Also, if all of the connections are desired, specify the &quot;all&quot; mode. Default mode is set to &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="ivi_+3A_loops">loops</code></td>
<td>
<p>Logical; whether the loop edges are also counted.</p>
</td></tr>
<tr><td><code id="ivi_+3A_d">d</code></td>
<td>
<p>The distance, expressed in number of steps from a given node (default=3). Distance
must be &gt; 0. According to Morone &amp; Makse (https://doi.org/10.1038/nature14604), optimal
results can be reached at d=3,4, but this depends on the size/&quot;radius&quot; of the network.
NOTE: the distance d is not inclusive. This means that nodes at a distance of 3 from
our node-of-interest do not include nodes at distances 1 and 2. Only 3.</p>
</td></tr>
<tr><td><code id="ivi_+3A_scale">scale</code></td>
<td>
<p>Character string; the method used for scaling/normalizing the results. Options include 'range' (normalization within a 1-100 range), 
'z-scale' (standardization using the z-score), and 'none' (no data scaling). The default selection is 'range'. Opting for the 'range' method is 
suitable when exploring a single network, allowing you to observe the complete spectrum and distribution of node influences. In this case, there is 
no intention to establish a specific threshold for the outcomes. However, it is possible to identify and present the top influential nodes 
based on their rankings. Conversely, the 'z-scale' option proves advantageous if the aim is to compare node influences across multiple networks or 
if there is a desire to establish a threshold (usually z-score &gt; 1.645) for generating a list of the most influential nodes without manual intervention.</p>
</td></tr>
<tr><td><code id="ivi_+3A_ncores">ncores</code></td>
<td>
<p>Integer; the number of cores to be used for parallel processing. If ncores == &quot;default&quot; (default), the number of 
cores to be used will be the max(number of available cores) - 1. We recommend leaving ncores argument as is (ncores = &quot;default&quot;).</p>
</td></tr>
<tr><td><code id="ivi_+3A_verbose">verbose</code></td>
<td>
<p>Logical; whether the accomplishment of different stages of the algorithm should be printed (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the IVI values based on the provided centrality measures.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cent_network.vis">cent_network.vis</a></code>
</p>
<p>Other integrative ranking functions: 
<code><a href="#topic+comp_manipulate">comp_manipulate</a>()</code>,
<code><a href="#topic+exir">exir</a>()</code>,
<code><a href="#topic+hubness.score">hubness.score</a>()</code>,
<code><a href="#topic+ivi.from.indices">ivi.from.indices</a>()</code>,
<code><a href="#topic+spreading.score">spreading.score</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- coexpression.data
My_graph &lt;- graph_from_data_frame(MyData)
GraphVertices &lt;- V(My_graph)
My.vertices.IVI &lt;- ivi(graph = My_graph, vertices = GraphVertices,
                       weights = NULL, directed = FALSE, mode = "all",
                       loops = TRUE, d = 3, scale = "range")

## End(Not run)
</code></pre>

<hr>
<h2 id='ivi.from.indices'>Integrated Value of Influence (IVI)</h2><span id='topic+ivi.from.indices'></span><span id='topic+IVI.FI'></span>

<h3>Description</h3>

<p>This function calculates the IVI of the desired nodes from previously calculated centrality
measures. This function is not dependent to other packages and the required centrality
measures, namely degree centrality, ClusterRank, betweenness centrality, Collective Influence,
local H-index, and neighborhood connectivity could have been calculated by any means beforehand.
A shiny app has also been developed for the calculation of IVI as well as IVI-based network
visualization, which is accessible using the 'influential::runShinyApp(&quot;IVI&quot;)' command.
You can also access the shiny app online at https://influential.erc.monash.edu/.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivi.from.indices(
  DC,
  CR,
  LH_index,
  NC,
  BC,
  CI,
  scale = "range",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ivi.from.indices_+3A_dc">DC</code></td>
<td>
<p>A vector containing the values of degree centrality of the desired vertices.</p>
</td></tr>
<tr><td><code id="ivi.from.indices_+3A_cr">CR</code></td>
<td>
<p>A vector containing the values of ClusterRank of the desired vertices.</p>
</td></tr>
<tr><td><code id="ivi.from.indices_+3A_lh_index">LH_index</code></td>
<td>
<p>A vector containing the values of local H-index of the desired vertices.</p>
</td></tr>
<tr><td><code id="ivi.from.indices_+3A_nc">NC</code></td>
<td>
<p>A vector containing the values of neighborhood connectivity of the desired vertices.</p>
</td></tr>
<tr><td><code id="ivi.from.indices_+3A_bc">BC</code></td>
<td>
<p>A vector containing the values of betweenness centrality of the desired vertices.</p>
</td></tr>
<tr><td><code id="ivi.from.indices_+3A_ci">CI</code></td>
<td>
<p>A vector containing the values of Collective Influence of the desired vertices.</p>
</td></tr>
<tr><td><code id="ivi.from.indices_+3A_scale">scale</code></td>
<td>
<p>Character string; the method used for scaling/normalizing the results. Options include 'range' (normalization within a 1-100 range), 
'z-scale' (standardization using the z-score), and 'none' (no data scaling). The default selection is 'range'. Opting for the 'range' method is 
suitable when exploring a single network, allowing you to observe the complete spectrum and distribution of node influences. In this case, there is 
no intention to establish a specific threshold for the outcomes. However, it is possible to identify and present the top influential nodes 
based on their rankings. Conversely, the 'z-scale' option proves advantageous if the aim is to compare node influences across multiple networks or 
if there is a desire to establish a threshold (usually z-score &gt; 1.645) for generating a list of the most influential nodes without manual intervention.</p>
</td></tr>
<tr><td><code id="ivi.from.indices_+3A_verbose">verbose</code></td>
<td>
<p>Logical; whether the accomplishment of different stages of the algorithm should be printed (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the IVI values based on the provided centrality measures.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cent_network.vis">cent_network.vis</a></code>
</p>
<p>Other integrative ranking functions: 
<code><a href="#topic+comp_manipulate">comp_manipulate</a>()</code>,
<code><a href="#topic+exir">exir</a>()</code>,
<code><a href="#topic+hubness.score">hubness.score</a>()</code>,
<code><a href="#topic+ivi">ivi</a>()</code>,
<code><a href="#topic+spreading.score">spreading.score</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- centrality.measures
My.vertices.IVI &lt;- ivi.from.indices(DC = centrality.measures$DC,
                                    CR = centrality.measures$CR,
                                    NC = centrality.measures$NC,
                                    LH_index = centrality.measures$LH_index,
                                    BC = centrality.measures$BC,
                                    CI = centrality.measures$CI)
                                    
## End(Not run)
</code></pre>

<hr>
<h2 id='lh_index'>local H-index (LH-index)</h2><span id='topic+lh_index'></span><span id='topic+lh.index'></span>

<h3>Description</h3>

<p>This function calculates the local H-index of input vertices and
works with both directed and undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lh_index(
  graph,
  vertices = V(graph),
  mode = "all",
  ncores = "default",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lh_index_+3A_graph">graph</code></td>
<td>
<p>A graph (network) of the igraph class.</p>
</td></tr>
<tr><td><code id="lh_index_+3A_vertices">vertices</code></td>
<td>
<p>A vector of desired vertices, which could be obtained by the V function.</p>
</td></tr>
<tr><td><code id="lh_index_+3A_mode">mode</code></td>
<td>
<p>The mode of local H-index depending on the directedness of the graph.
If the graph is undirected, the mode &quot;all&quot; should be specified.
Otherwise, for the calculation of local H-index based on
incoming connections select &quot;in&quot; and for the outgoing connections select &quot;out&quot;.
Also, if all of the connections are desired, specify the &quot;all&quot; mode. Default mode is set to &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="lh_index_+3A_ncores">ncores</code></td>
<td>
<p>Integer; the number of cores to be used for parallel processing. If ncores == &quot;default&quot; (default), the number of 
cores to be used will be the max(number of available cores) - 1. We recommend leaving ncores argument as is (ncores = &quot;default&quot;).</p>
</td></tr>
<tr><td><code id="lh_index_+3A_verbose">verbose</code></td>
<td>
<p>Logical; whether the accomplishment of different stages of the algorithm should be printed (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector including the local H-index of each vertex inputted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ivi">ivi</a></code>,
<code><a href="#topic+cent_network.vis">cent_network.vis</a></code>
</p>
<p>Other centrality functions: 
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+clusterRank">clusterRank</a>()</code>,
<code><a href="#topic+collective.influence">collective.influence</a>()</code>,
<code><a href="#topic+h_index">h_index</a>()</code>,
<code><a href="#topic+neighborhood.connectivity">neighborhood.connectivity</a>()</code>,
<code><a href="#topic+sirir">sirir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- coexpression.data
My_graph &lt;- graph_from_data_frame(MyData)
GraphVertices &lt;- V(My_graph)
lh.index &lt;- lh_index(graph = My_graph, vertices = GraphVertices, mode = "all", ncores = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='neighborhood.connectivity'>Neighborhood connectivity</h2><span id='topic+neighborhood.connectivity'></span><span id='topic+NC'></span>

<h3>Description</h3>

<p>This function calculates the neighborhood connectivity of input vertices and
works with both directed and undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhood.connectivity(
  graph,
  vertices = V(graph),
  mode = "all",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neighborhood.connectivity_+3A_graph">graph</code></td>
<td>
<p>A graph (network) of the igraph class.</p>
</td></tr>
<tr><td><code id="neighborhood.connectivity_+3A_vertices">vertices</code></td>
<td>
<p>A vector of desired vertices, which could be obtained by the V function.</p>
</td></tr>
<tr><td><code id="neighborhood.connectivity_+3A_mode">mode</code></td>
<td>
<p>The mode of neighborhood connectivity depending on the directedness of the graph.
If the graph is undirected, the mode &quot;all&quot; should be specified.
Otherwise, for the calculation of neighborhood connectivity based on
incoming connections select &quot;in&quot; and for the outgoing connections select &quot;out&quot;.
Also, if all of the connections are desired, specify the &quot;all&quot; mode. Default mode is set to &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="neighborhood.connectivity_+3A_verbose">verbose</code></td>
<td>
<p>Logical; whether the accomplishment of different stages of the algorithm should be printed (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector including the neighborhood connectivity score of each vertex inputted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ivi">ivi</a></code>,
<code><a href="#topic+cent_network.vis">cent_network.vis</a></code>
</p>
<p>Other centrality functions: 
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+clusterRank">clusterRank</a>()</code>,
<code><a href="#topic+collective.influence">collective.influence</a>()</code>,
<code><a href="#topic+h_index">h_index</a>()</code>,
<code><a href="#topic+lh_index">lh_index</a>()</code>,
<code><a href="#topic+sirir">sirir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- coexpression.data
My_graph &lt;- graph_from_data_frame(MyData)
GraphVertices &lt;- V(My_graph)
neighrhood.co &lt;- neighborhood.connectivity(graph = My_graph,
                                           vertices = GraphVertices,
                                           mode = "all")
                                           
## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+graph_from_data_frame'></span><span id='topic+graph_from_adjacency_matrix'></span><span id='topic+graph_from_incidence_matrix'></span><span id='topic+V'></span><span id='topic+degree'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>igraph</dt><dd><p><code><a href="igraph.html#topic+degree">degree</a></code>, <code><a href="igraph.html#topic+graph_from_adjacency_matrix">graph_from_adjacency_matrix</a></code>, <code><a href="igraph.html#topic+graph_from_data_frame">graph_from_data_frame</a></code>, <code><a href="igraph.html#topic+graph_from_incidence_matrix">graph_from_incidence_matrix</a></code>, <code><a href="igraph.html#topic+V">V</a></code></p>
</dd>
</dl>

<hr>
<h2 id='runShinyApp'>Run shiny app</h2><span id='topic+runShinyApp'></span>

<h3>Description</h3>

<p>Run shiny apps included in the influential R package.
Also, a web-based <a href="https://influential.erc.monash.edu/">Influential Software Package</a> with a convenient
user-interface (UI) has been developed for the comfort of all users including those without a coding background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runShinyApp(shinyApp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runShinyApp_+3A_shinyapp">shinyApp</code></td>
<td>
<p>The name of the shiny app you want to run. You can get the exact name of the available
shiny apps via the following command.
<em>list.files(system.file(&quot;ShinyApps&quot;, package = &quot;influential&quot;))</em>. Please also note this function is
case-sensitive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A shiny app.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
runShinyApp(shinyApp = "IVI")

## End(Not run)
</code></pre>

<hr>
<h2 id='sif2igraph'>SIF to igraph</h2><span id='topic+sif2igraph'></span>

<h3>Description</h3>

<p>This function imports and converts a SIF file from your local hard drive, cloud space,
or internet into a graph with an igraph class, which can then be used for the identification
of most influential nodes via the ivi function, for instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sif2igraph(Path, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sif2igraph_+3A_path">Path</code></td>
<td>
<p>A string or character vector indicating the path to the desired SIF file. The SIF file
could be on your local hard drive, cloud space, or on the internet.</p>
</td></tr>
<tr><td><code id="sif2igraph_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether or not to create a directed graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyGraph &lt;- sif2igraph(Path = "/Users/User1/Desktop/mygraph.sif", directed=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='sirir'>SIR-based Influence Ranking</h2><span id='topic+sirir'></span><span id='topic+SIRIR'></span>

<h3>Description</h3>

<p>This function is achieved by the integration susceptible-infected-recovered (SIR) model
with the leave-one-out cross validation technique and ranks network nodes based on their
true universal influence. One of the applications of this function is the assessment of
performance of a novel algorithm in identification of network influential nodes by considering
the SIRIR ranks as the ground truth (gold standard).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sirir(
  graph,
  vertices = V(graph),
  beta = 0.5,
  gamma = 1,
  no.sim = 100,
  ncores = "default",
  seed = 1234,
  loop_verbose = TRUE,
  node_verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sirir_+3A_graph">graph</code></td>
<td>
<p>A graph (network) of the igraph class.</p>
</td></tr>
<tr><td><code id="sirir_+3A_vertices">vertices</code></td>
<td>
<p>A vector of desired vertices, which could be obtained by the V function.</p>
</td></tr>
<tr><td><code id="sirir_+3A_beta">beta</code></td>
<td>
<p>Non-negative scalar. The rate of infection of an individual that is susceptible
and has a single infected neighbor. The infection rate of a susceptible individual with n
infected neighbors is n times beta. Formally this is the rate parameter of an exponential
distribution.</p>
</td></tr>
<tr><td><code id="sirir_+3A_gamma">gamma</code></td>
<td>
<p>Positive scalar. The rate of recovery of an infected individual.
Formally, this is the rate parameter of an exponential distribution.</p>
</td></tr>
<tr><td><code id="sirir_+3A_no.sim">no.sim</code></td>
<td>
<p>Integer scalar, the number of simulation runs to perform SIR model on the
original network as well as perturbed networks generated by leave-one-out technique.
You may choose a different no.sim based on the available memory on your system.</p>
</td></tr>
<tr><td><code id="sirir_+3A_ncores">ncores</code></td>
<td>
<p>Integer; the number of cores to be used for parallel processing. If ncores == &quot;default&quot; (default), the number of 
cores to be used will be the max(number of available cores) - 1. We recommend leaving ncores argument as is (ncores = &quot;default&quot;).</p>
</td></tr>
<tr><td><code id="sirir_+3A_seed">seed</code></td>
<td>
<p>A single value, interpreted as an integer to be used for random number generation.</p>
</td></tr>
<tr><td><code id="sirir_+3A_loop_verbose">loop_verbose</code></td>
<td>
<p>Logical; whether the accomplishment of the evaluation of network nodes in each loop should be printed (default is TRUE).</p>
</td></tr>
<tr><td><code id="sirir_+3A_node_verbose">node_verbose</code></td>
<td>
<p>Logical; whether the process of Parallel Socket Cluster creation should be printed (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-column dataframe; a column containing the difference values of the original and
perturbed networks and a column containing node influence rankings
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cent_network.vis">cent_network.vis</a></code>,
and <code><a href="igraph.html#topic+sir">sir</a></code> for a complete description on SIR model
</p>
<p>Other centrality functions: 
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+clusterRank">clusterRank</a>()</code>,
<code><a href="#topic+collective.influence">collective.influence</a>()</code>,
<code><a href="#topic+h_index">h_index</a>()</code>,
<code><a href="#topic+lh_index">lh_index</a>()</code>,
<code><a href="#topic+neighborhood.connectivity">neighborhood.connectivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1234)
My_graph &lt;- igraph::sample_gnp(n=50, p=0.05)
GraphVertices &lt;- V(My_graph)
Influence.Ranks &lt;- sirir(graph = My_graph, vertices = GraphVertices, 
                         beta = 0.5, gamma = 1, ncores = "default", no.sim = 10, seed = 1234)

## End(Not run)
</code></pre>

<hr>
<h2 id='spreading.score'>Spreading score</h2><span id='topic+spreading.score'></span>

<h3>Description</h3>

<p>This function calculates the Spreading score of the desired nodes from a graph.
Spreading score reflects the spreading potential of each node within a network and is
one of the major components of the IVI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spreading.score(
  graph,
  vertices = V(graph),
  weights = NULL,
  directed = FALSE,
  mode = "all",
  loops = TRUE,
  d = 3,
  scale = "range",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spreading.score_+3A_graph">graph</code></td>
<td>
<p>A graph (network) of the igraph class.</p>
</td></tr>
<tr><td><code id="spreading.score_+3A_vertices">vertices</code></td>
<td>
<p>A vector of desired vertices, which could be obtained by the V function.</p>
</td></tr>
<tr><td><code id="spreading.score_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted betweenness centrality
of nodes as a requirement for calculation of spreading score. If the graph has a weight edge attribute,
then this is used by default. Weights are used to calculate weighted shortest paths,
so they are interpreted as distances.</p>
</td></tr>
<tr><td><code id="spreading.score_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to directed graph is analyzed. This argument
is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="spreading.score_+3A_mode">mode</code></td>
<td>
<p>The mode of Spreading score depending on the directedness of the graph.
If the graph is undirected, the mode &quot;all&quot; should be specified.
Otherwise, for the calculation of Spreading score based on
incoming connections select &quot;in&quot; and for the outgoing connections select &quot;out&quot;.
Also, if all of the connections are desired, specify the &quot;all&quot; mode. Default mode is set to &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="spreading.score_+3A_loops">loops</code></td>
<td>
<p>Logical; whether the loop edges are also counted.</p>
</td></tr>
<tr><td><code id="spreading.score_+3A_d">d</code></td>
<td>
<p>The distance, expressed in number of steps from a given node (default=3). Distance
must be &gt; 0. According to Morone &amp; Makse (https://doi.org/10.1038/nature14604), optimal
results can be reached at d=3,4, but this depends on the size/&quot;radius&quot; of the network.
NOTE: the distance d is not inclusive. This means that nodes at a distance of 3 from
our node-of-interest do not include nodes at distances 1 and 2. Only 3.</p>
</td></tr>
<tr><td><code id="spreading.score_+3A_scale">scale</code></td>
<td>
<p>Character string; the method used for scaling/normalizing the results. Options include 'range' (normalization within a 1-100 range), 
'z-scale' (standardization using the z-score), and 'none' (no data scaling). The default selection is 'range'. Opting for the 'range' method is 
suitable when exploring a single network, allowing you to observe the complete spectrum and distribution of node influences. In this case, there is 
no intention to establish a specific threshold for the outcomes. However, it is possible to identify and present the top spreading nodes 
based on their rankings. Conversely, the 'z-scale' option proves advantageous if the aim is to compare node influences across multiple networks or 
if there is a desire to establish a threshold (usually z-score &gt; 1.645) for generating a list of the most spreading nodes without manual intervention.</p>
</td></tr>
<tr><td><code id="spreading.score_+3A_verbose">verbose</code></td>
<td>
<p>Logical; whether the accomplishment of different stages of the algorithm should be printed (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with Spreading scores.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cent_network.vis">cent_network.vis</a></code>
</p>
<p>Other integrative ranking functions: 
<code><a href="#topic+comp_manipulate">comp_manipulate</a>()</code>,
<code><a href="#topic+exir">exir</a>()</code>,
<code><a href="#topic+hubness.score">hubness.score</a>()</code>,
<code><a href="#topic+ivi.from.indices">ivi.from.indices</a>()</code>,
<code><a href="#topic+ivi">ivi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MyData &lt;- coexpression.data
My_graph &lt;- graph_from_data_frame(MyData)
GraphVertices &lt;- V(My_graph)
Spreading.score &lt;- spreading.score(graph = My_graph, vertices = GraphVertices,
                                   weights = NULL, directed = FALSE, mode = "all",
                                   loops = TRUE, d = 3, scale = "range")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
