<!DOCTYPE html><html lang="en"><head><title>Help for package multifunc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multifunc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#all_biodepth'><p>Biodepth Data</p></a></li>
<li><a href='#cor_dist'><p>cor_dist</p></a></li>
<li><a href='#divNeeded'><p>divNeeded</p></a></li>
<li><a href='#dmean'><p>dmean</p></a></li>
<li><a href='#dmin'><p>dmin</p></a></li>
<li><a href='#duffy_2003'><p>Seagrass Mesocosm Data</p></a></li>
<li><a href='#eff_num_func'><p>eff_num_func</p></a></li>
<li><a href='#eff_num_func_d'><p>eff_num_func_d</p></a></li>
<li><a href='#eff_num_func_d_onerow'><p>eff_num_func_d_onerow</p></a></li>
<li><a href='#eff_num_func_no_d'><p>eff_num_func_no_d</p></a></li>
<li><a href='#filterCoefData'><p>filterCoefData</p></a></li>
<li><a href='#filterOverData'><p>filterOverData</p></a></li>
<li><a href='#getCoefTab'><p>getCoefTab</p></a></li>
<li><a href='#getFuncMaxed'><p>getFuncMaxed</p></a></li>
<li><a href='#getFuncsMaxed'><p>getFuncsMaxed</p></a></li>
<li><a href='#getIndices'><p>getIndices</p></a></li>
<li><a href='#getMF_eff'><p>getMF_eff</p></a></li>
<li><a href='#getOverlap'><p>getOverlap</p></a></li>
<li><a href='#getOverlapSummary'><p>getOverlapSummary</p></a></li>
<li><a href='#getRedundancy'><p>getRedundancy</p></a></li>
<li><a href='#getStdAndMeanFunctions'><p>getStdAndMeanFunctions</p></a></li>
<li><a href='#qw'><p>Quote Words</p></a></li>
<li><a href='#relevantSp'><p>relevantSp</p></a></li>
<li><a href='#sAICfun'><p>sAICfun</p></a></li>
<li><a href='#standardizeUnitScale'><p>standardizeUnitScale</p></a></li>
<li><a href='#standardizeZScore'><p>standardizeZScore</p></a></li>
<li><a href='#stdEffects'><p>stdEffects</p></a></li>
<li><a href='#whichVars'><p>whichVars</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.9.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-23</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Ecological Drivers on Ecosystem Multifunctionality</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for the analysis of how ecological drivers affect the
    multifunctionality of an ecosystem based on methods of Byrnes et al. 
    2016 &lt;<a href="https://doi.org/10.1111%2F2041-210X.12143">doi:10.1111/2041-210X.12143</a>&gt; and Byrnes et al. 
    2022 &lt;<a href="https://doi.org/10.1101%2F2022.03.17.484802">doi:10.1101/2022.03.17.484802</a>&gt;. Most standard
    methods in the literature are implemented (see vignettes) in a tidy
    format.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jebyrnes.github.io/multifunc/">https://jebyrnes.github.io/multifunc/</a>,
<a href="https://github.com/jebyrnes/multifunc">https://github.com/jebyrnes/multifunc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jebyrnes/multifunc/issues">https://github.com/jebyrnes/multifunc/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, dplyr, purrr, broom, MASS, utils, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, forcats, tidyr, gridExtra, knitr, patchwork, car</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-23 16:01:35 UTC; jebyrnes</td>
</tr>
<tr>
<td>Author:</td>
<td>Jarrett Byrnes [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jarrett Byrnes &lt;jarrett.byrnes@umb.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-25 07:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='all_biodepth'>Biodepth Data</h2><span id='topic+all_biodepth'></span>

<h3>Description</h3>

<p>Data from the pan-European Biodepth grassland diversity manipulation
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes
</p>


<h3>References</h3>

<p>Spehn, E. M., A. Hector, J. Joshi, M. Scherer-Lorenzen, B. Schmid,
E. Bazeley-White, C. Beierkuhnlein, M. C. Caldeira,
M. Diemer, P. G. Dimitrakopoulos, J. A. Finn, H. Freitas, P. S. Giller,
J. Good, R. Harris, P. Hogberg, K. Huss-Danell, A. Jumpponen, J. Koricheva,
P. W. Leadley, M. Loreau, A. Minns, C. P. H. Mulder, G. O'Donovan, S. J. Otway,
C. Palmborg, J. S. Pereira, A. B. Pfisterer, A. Prinz, D. J. Read, E. D. Schulze,
A. S. Siamantziouras, A. C. Terry, A. Y. Troumbis, F. I. Woodward, S. Yachi, and J. H. Lawton. 2005.
Ecosystem effects of biodiversity manipulations in European grasslands.
Ecological Monographs 75:37-63.
</p>

<hr>
<h2 id='cor_dist'>cor_dist</h2><span id='topic+cor_dist'></span>

<h3>Description</h3>

<p>Takes a data frame of functions and calculates the correlation-based
distance between functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_dist(adf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_dist_+3A_adf">adf</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> of functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>

<hr>
<h2 id='divNeeded'>divNeeded</h2><span id='topic+divNeeded'></span>

<h3>Description</h3>

<p><code>divNeeded</code> Determines, for every combination of functions, how many species
influence those functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divNeeded(overData, type = "positive")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="divNeeded_+3A_overdata">overData</code></td>
<td>
<p>Matrix of functions and which species affect them from <code>getRedundancy</code>.</p>
</td></tr>
<tr><td><code id="divNeeded_+3A_type">type</code></td>
<td>
<p>Are the kinds of effects we're looking at &quot;positive&quot;, &quot;negative&quot; or &quot;all&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iterates over all possible combinations of functions.  Checks the matrix of which species
have positive, negative, or both influences on those functions.  Tally's total number of species
that have an effect on those functions
</p>


<h3>Value</h3>

<p>Returns a data frame of all combinations and how many species are needed to
influence all of them.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)
species &lt;- relevantSp(germany, 26:ncol(germany))

# re-normalize N.Soil so that everything is on the
# same sign-scale (e.g. the maximum level of a
# function is the "best" function)
germany$N.Soil &lt;- -1 * germany$N.Soil + max(germany$N.Soil, na.rm = TRUE)

res.list &lt;- lapply(vars, function(x) sAICfun(x, species, germany))
names(res.list) &lt;- vars

redund &lt;- getRedundancy(vars, species, germany)

posCurve &lt;- divNeeded(redund, type = "positive")
</code></pre>

<hr>
<h2 id='dmean'>dmean</h2><span id='topic+dmean'></span>

<h3>Description</h3>

<p>Calculates the average distance between functions for one or an entire
assemblage of replicates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmean(adf_raw, D)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dmean_+3A_adf_raw">adf_raw</code></td>
<td>
<p>A data frame frame with functions in columns and rows as replicates</p>
</td></tr>
<tr><td><code id="dmean_+3A_d">D</code></td>
<td>
<p>A distance matrix describing dissimilarity between functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single numeric of weighted average of distance matrix
</p>


<h3>References</h3>

<p>Byrnes, J. E. K., Roger, F. and Bagchi, R. 2022. Understandable 
Multifunctionality Measures Using Hill Numbers. bioRxiv. 
2022.03.17.484802. https://doi.org/10.1101/2022.03.17.484802
</p>
<p>Chao, A., Chiu, C.-H., Vill√©ger, S., Sun, I.-F., Thorn, S., Lin, Y.-C.,
Chiang, J.-M. and Sherwin, W. B. 2019. An attribute-diversity approach to
functional diversity, functional beta diversity, and related (dis)similarity
measures. Ecological Monographs. 89: e01343.
</p>

<hr>
<h2 id='dmin'>dmin</h2><span id='topic+dmin'></span>

<h3>Description</h3>

<p>Calculates the minimum non-zero value of a distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmin(D)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dmin_+3A_d">D</code></td>
<td>
<p>A distance matrix describing dissimilarity between functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric
</p>

<hr>
<h2 id='duffy_2003'>Seagrass Mesocosm Data</h2><span id='topic+duffy_2003'></span>

<h3>Description</h3>

<p>Data from the a seagrass grazer diversity manipulation at the Virginia Institute of Marine Sciences. From Duffy et al. 2003 Ecology Letters.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes
</p>


<h3>References</h3>

<p>Duffy, J. E., J. P. Richardson, and E. A. Canuel. 2003. Grazer diversity effects on ecosystem functioning in seagrass beds. Ecology letters 6:637-645.
</p>

<hr>
<h2 id='eff_num_func'>eff_num_func</h2><span id='topic+eff_num_func'></span>

<h3>Description</h3>

<p>Calculate the effective number of functions for rows in a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff_num_func(dat, vars, q = 1, standardized = FALSE, D = NULL, tau = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eff_num_func_+3A_dat">dat</code></td>
<td>
<p>A data frame with functions in columns and rows as replicates as well as other information.</p>
</td></tr>
<tr><td><code id="eff_num_func_+3A_vars">vars</code></td>
<td>
<p>Column names of function variables</p>
</td></tr>
<tr><td><code id="eff_num_func_+3A_q">q</code></td>
<td>
<p>Order of the diversity measure. Defaults to the
Shannon case where q = 1. For Simpson, q=2.</p>
</td></tr>
<tr><td><code id="eff_num_func_+3A_standardized">standardized</code></td>
<td>
<p>Use standardized number of functions (scaled by total
number of functions, so between 0-1), or just raw effective number of
functions for calculation. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="eff_num_func_+3A_d">D</code></td>
<td>
<p>A distance matrix describing dissimilarity between functions. Defaults
to NULL, and the index is calculated assuming all functions are different. If
it is not null, it must be a symmetric matrix with dimensions matching the
number of functions listed in <code>vars</code>.</p>
</td></tr>
<tr><td><code id="eff_num_func_+3A_tau">tau</code></td>
<td>
<p>A cutoff for degree of dissimilarity under which functions are considered
to be different. If tau is the minimum non-zero value of D, all functions are different.
if tau is the maximum value of D are greater, all functions are considered the same.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a data frame, variable names,  whether we want
an index standardized by number of functions or not, an order of Hill number for our
effective number of functions as well as a dissimilarity matrix (if desired) and value
for a dissimilarity cutoff (defaults to the average dissimilarity). It then calculates
and returns the effective number of functions using the appropriate method. See Chao
et al. 2019 for more.
</p>


<h3>Value</h3>

<p>Returns a vector of effective or standardized effective number of functions
</p>


<h3>References</h3>

<p>Chao, A., Chiu, C.-H., Vill√©ger, S., Sun, I.-F., Thorn, S., Lin, Y.-C.,
Chiang, J.-M. and Sherwin, W. B. 2019. An attribute-diversity approach to
functional diversity, functional beta diversity, and related (dis)similarity
measures. Ecological Monographs. 89: e01343.
</p>
<p>Jost, L. 2006. Entropy and diversity. Oikos 113(2): 363-375.
</p>
<p>Hill, M. 1973. Diversity and evenness: A unifying notation and its
consequences. Ecology 54: 427-432.
</p>

<hr>
<h2 id='eff_num_func_d'>eff_num_func_d</h2><span id='topic+eff_num_func_d'></span>

<h3>Description</h3>

<p>eff_num_func_d
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff_num_func_d(adf_freq, q = 1, D, tau = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eff_num_func_d_+3A_adf_freq">adf_freq</code></td>
<td>
<p>A data frame of functional &quot;frequencies&quot; - i.e. f_i/sum(f_i)</p>
</td></tr>
<tr><td><code id="eff_num_func_d_+3A_q">q</code></td>
<td>
<p>Order of hill number used for index. Defaults to q=1, as in Shannon Diversity</p>
</td></tr>
<tr><td><code id="eff_num_func_d_+3A_d">D</code></td>
<td>
<p>A distance matrix describing dissimilarity between functions.</p>
</td></tr>
<tr><td><code id="eff_num_func_d_+3A_tau">tau</code></td>
<td>
<p>A cutoff for degree of dissimilarity under which functions are considered
to be different. If tau is the minimum non-zero value of D, all functions are different.
if tau is the maximum value of D are greater, all functions are considered the same.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of effective number of functions
</p>


<h3>References</h3>

<p>Chao, A., Chiu, C.-H., Vill√©ger, S., Sun, I.-F., Thorn, S., Lin, Y.-C.,
Chiang, J.-M. and Sherwin, W. B. 2019. An attribute-diversity approach to
functional diversity, functional beta diversity, and related (dis)similarity
measures. Ecological Monographs. 89: e01343.
</p>

<hr>
<h2 id='eff_num_func_d_onerow'>eff_num_func_d_onerow</h2><span id='topic+eff_num_func_d_onerow'></span>

<h3>Description</h3>

<p>eff_num_func_d_onerow
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff_num_func_d_onerow(arow_freq, D, tau, q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eff_num_func_d_onerow_+3A_arow_freq">arow_freq</code></td>
<td>
<p>One replicate sample of different functions (a single numeric vector)</p>
</td></tr>
<tr><td><code id="eff_num_func_d_onerow_+3A_d">D</code></td>
<td>
<p>A distance matrix describing dissimilarity between functions.</p>
</td></tr>
<tr><td><code id="eff_num_func_d_onerow_+3A_tau">tau</code></td>
<td>
<p>A cutoff for degree of dissimilarity under which functions are considered
to be different. If tau is the minimum non-zero value of D, all functions are different.
if tau is the maximum value of D are greater, all functions are considered the same.</p>
</td></tr>
<tr><td><code id="eff_num_func_d_onerow_+3A_q">q</code></td>
<td>
<p>Order of hill number used for index. Defaults to q=1, as in Shannon Diversity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value of effective number of functions
</p>


<h3>References</h3>

<p>Byrnes, J. E. K., Roger, F. and Bagchi, R. 2022. Understandable 
Multifunctionality Measures Using Hill Numbers. bioRxiv. 
2022.03.17.484802. https://doi.org/10.1101/2022.03.17.484802
</p>
<p>Chao, A., Chiu, C.-H., Vill√©ger, S., Sun, I.-F., Thorn, S., Lin, Y.-C.,
Chiang, J.-M. and Sherwin, W. B. 2019. An attribute-diversity approach to
functional diversity, functional beta diversity, and related (dis)similarity
measures. Ecological Monographs. 89: e01343.
</p>

<hr>
<h2 id='eff_num_func_no_d'>eff_num_func_no_d</h2><span id='topic+eff_num_func_no_d'></span>

<h3>Description</h3>

<p>eff_num_func_no_d
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff_num_func_no_d(adf_freq, q = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eff_num_func_no_d_+3A_adf_freq">adf_freq</code></td>
<td>
<p>A data frame of functional &quot;frequencies&quot; - i.e. f_i/sum(f_i)</p>
</td></tr>
<tr><td><code id="eff_num_func_no_d_+3A_q">q</code></td>
<td>
<p>Order of hill number used for index. Defaults to q=1, as in Shannon Diversity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a data frame, with functions standardized against total level of function
in their replicate as columns and replicates as rows. Returns the effective number of functions using the appropriate method. See Chao
et al. 2019 or Jost 2006 for details. Does not adjust for correlation between functions.
</p>


<h3>Value</h3>

<p>Returns a verctor of effective or standardized effective number of functions
</p>


<h3>References</h3>

<p>Chao, A., Chiu, C.-H., Vill√©ger, S., Sun, I.-F., Thorn, S., Lin, Y.-C.,
Chiang, J.-M. and Sherwin, W. B. 2019. An attribute-diversity approach to
functional diversity, functional beta diversity, and related (dis)similarity
measures. Ecological Monographs. 89: e01343.
</p>
<p>Jost, L. 2006. Entropy and diversity. Oikos 113(2): 363-375.
</p>
<p>Hill, M. 1973. Diversity and evenness: A unifying notation and its
consequences. Ecology 54: 427-432.
</p>

<hr>
<h2 id='filterCoefData'>filterCoefData</h2><span id='topic+filterCoefData'></span>

<h3>Description</h3>

<p><code>filterCoefData</code> filters contributions of species
to function by sign.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterCoefData(coefData, type = "positive")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterCoefData_+3A_coefdata">coefData</code></td>
<td>
<p>Matrix of functions and coefficients for which species affect them from <code>getRedundancy</code>.</p>
</td></tr>
<tr><td><code id="filterCoefData_+3A_type">type</code></td>
<td>
<p>Are the kinds of effects we're looking at &quot;positive&quot;, &quot;negative&quot; or &quot;all&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a matrix of functions and coefficients
for species and filters out
only the sign of contributions desired.  Typically used by other functions in the package.
</p>


<h3>Value</h3>

<p>Returns a filtered matrix.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)
species &lt;- relevantSp(germany, 26:ncol(germany))

# re-normalize N.Soil so that everything is on the same
# sign-scale (e.g. the maximum level of a function is
# the "best" function)
germany$N.Soil &lt;- -1 * germany$N.Soil + max(germany$N.Soil, na.rm = TRUE)

res.list &lt;- lapply(vars, function(x) sAICfun(x, species, germany))
names(res.list) &lt;- vars

coefs &lt;- getRedundancy(vars, species, germany, output = "coef")
stdCoefs &lt;- stdEffects(coefs, germany, vars, species)

filterCoefData(stdCoefs)


#########
# filterCoefData takes a matrix of coefficients
# and filters it so that only the positive, negative, or both contributions
# are present
#########
</code></pre>

<hr>
<h2 id='filterOverData'>filterOverData</h2><span id='topic+filterOverData'></span>

<h3>Description</h3>

<p><code>filterOverData</code> filters qualitative effects of species
to function by sign.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterOverData(overData, type = "positive")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterOverData_+3A_overdata">overData</code></td>
<td>
<p>Matrix of functions and which species affect them from <code>getRedundancy</code>.</p>
</td></tr>
<tr><td><code id="filterOverData_+3A_type">type</code></td>
<td>
<p>Are the kinds of effects we're looking at &quot;positive&quot;, &quot;negative&quot; or &quot;all&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a matrix of functions and effects
of species -  1's and -1's, s - and filters out
only the sign of contributions desired.  Typically used by other functions in the package.
</p>


<h3>Value</h3>

<p>Returns a filtered matrix.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)
species &lt;- relevantSp(germany, 26:ncol(germany))

# re-normalize N.Soil so that everything is on the same
# sign-scale (e.g. the maximum level of a function is the
# "best" function)
germany$N.Soil &lt;- -1 * germany$N.Soil + max(germany$N.Soil, na.rm = TRUE)

res.list &lt;- lapply(vars, function(x) sAICfun(x, species, germany))
names(res.list) &lt;- vars

redund &lt;- getRedundancy(vars, species, germany)

filterOverData(redund, type = "positive")


#########
# filterOverData takes a matrix of 1s, 0s, and -1s
# and filters it so that only the positive, negative, or both contributions
# are 1 for later overlap function usage
#########
</code></pre>

<hr>
<h2 id='getCoefTab'>getCoefTab</h2><span id='topic+getCoefTab'></span>

<h3>Description</h3>

<p><code>getCoefTab</code> extract the effect of diversity on number of functions greater than
a threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCoefTab(
  eqn,
  fun = stats::glm,
  data,
  groupVar = "thresholds",
  coefVar = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCoefTab_+3A_eqn">eqn</code></td>
<td>
<p>The model to be fit at each threshold.</p>
</td></tr>
<tr><td><code id="getCoefTab_+3A_fun">fun</code></td>
<td>
<p>The fitting function.  Defaults to <code>glm</code>.</p>
</td></tr>
<tr><td><code id="getCoefTab_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the model to be fit.</p>
</td></tr>
<tr><td><code id="getCoefTab_+3A_groupvar">groupVar</code></td>
<td>
<p>Grouping variable.  Defaults to &quot;thresholds&quot; to fit the model at different
thresholds, but, other types of grouping are possible.</p>
</td></tr>
<tr><td><code id="getCoefTab_+3A_coefvar">coefVar</code></td>
<td>
<p>The name of the variable from the model whose coefficient we'll be extracting.</p>
</td></tr>
<tr><td><code id="getCoefTab_+3A_...">...</code></td>
<td>
<p>Other arguments to be supplied to the fitting function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>getCoefTab Takes a statistical model and plot level data with the number of functions
greater than a threshold at multiple different thresholds and returns the coefficient for the
effect of diversity at each threshold
</p>


<h3>Value</h3>

<p>Returns a data frame of thresholds, coefficients, and their statistical properties.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)

# re-normalize N.Soil so that everything is on the same
# sign-scale (e.g. the maximum level of a function is
# the "best" function)
germany$N.Soil &lt;- -1 * germany$N.Soil + max(germany$N.Soil, na.rm = TRUE)

germanyThresh &lt;- getFuncsMaxed(germany, vars,
  threshmin = 0.05,
  threshmax = 0.99, prepend = c("plot", "Diversity"), maxN = 7
)

germanyLinearSlopes &lt;- getCoefTab(funcMaxed ~ Diversity,
  data = germanyThresh, coefVar = "Diversity", family = quasipoisson(link = "identity")
)


</code></pre>

<hr>
<h2 id='getFuncMaxed'>getFuncMaxed</h2><span id='topic+getFuncMaxed'></span>

<h3>Description</h3>

<p><code>getFuncMaxed</code> the number of functions greater than or equal to a single threshold in one experimental unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFuncMaxed(
  adf,
  vars = NA,
  thresh = 0.7,
  proportion = FALSE,
  prepend = "Diversity",
  maxN = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFuncMaxed_+3A_adf">adf</code></td>
<td>
<p>A data frame with functions.</p>
</td></tr>
<tr><td><code id="getFuncMaxed_+3A_vars">vars</code></td>
<td>
<p>The column names of the functions to be assessed.</p>
</td></tr>
<tr><td><code id="getFuncMaxed_+3A_thresh">thresh</code></td>
<td>
<p>The threshold value to assess.</p>
</td></tr>
<tr><td><code id="getFuncMaxed_+3A_proportion">proportion</code></td>
<td>
<p>Whether the output will be returned as a proportion of all functions.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getFuncMaxed_+3A_prepend">prepend</code></td>
<td>
<p>Additional columns that will be imported from the data for the returned data frame.</p>
</td></tr>
<tr><td><code id="getFuncMaxed_+3A_maxn">maxN</code></td>
<td>
<p>As a 'maximum' value can be subject to outliers, etc., what number of the highest data points
for a function will be used to calculate the value against which thresholds will be judged.  E.g., if maxN=1
then all thresholds are proportions of the largest value measured for a function.  If maxN=8, then it's the
proportion of the mean of the highest 8 measurements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a data frame that has the value of number or proportion of functions
greater than a single threshold.
</p>


<h3>Value</h3>

<p>Returns a data frame of number or fraction of functions greater than or equal to the selected thresholds in each plot.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)

# re-normalize N.Soil so that everything is on the same
# sign-scale (e.g. the maximum level of a function is
# the "best" function)
germany$N.Soil &lt;- -1 * germany$N.Soil + max(germany$N.Soil, na.rm = TRUE)

germanyThresh &lt;- getFuncMaxed(germany, vars, 
                              thresh = 0.5, 
                              prepend = c("plot", "Diversity"), 
                              maxN = 7)


# A function that will return a data frame with the first several columns
# being information the user wants for identification purposes (prepend)
# which defaults to Diversity and the final column the number of columns
# which pass a predefined threshold, defined as some proportion of the maximim
# observed for each column.  vars=the names of the vars being specified
# thresh is the threshold, between 0 and 1, of proportion of the max that needs
# to be passed to be counted.

# changelog
# 2014-03-24 Fixed -1 error in getMaxValue
# 2015-06-24 Fixed column name from prepend error https://github.com/jebyrnes/multifunc/issues/1
# 2022-04-14 Updated to use dplyr
</code></pre>

<hr>
<h2 id='getFuncsMaxed'>getFuncsMaxed</h2><span id='topic+getFuncsMaxed'></span>

<h3>Description</h3>

<p><code>getFuncsMaxed</code> the number of functions greater than or equal to a wide variety of thresholds in each experimental unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFuncsMaxed(
  adf,
  vars = NA,
  threshmin = 0.05,
  threshmax = 0.99,
  threshstep = 0.01,
  proportion = FALSE,
  prepend = "Diversity",
  maxN = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFuncsMaxed_+3A_adf">adf</code></td>
<td>
<p>A data frame with functions.</p>
</td></tr>
<tr><td><code id="getFuncsMaxed_+3A_vars">vars</code></td>
<td>
<p>The column names of the functions to be assessed.</p>
</td></tr>
<tr><td><code id="getFuncsMaxed_+3A_threshmin">threshmin</code></td>
<td>
<p>The lowest threshold value to assess.</p>
</td></tr>
<tr><td><code id="getFuncsMaxed_+3A_threshmax">threshmax</code></td>
<td>
<p>The highest threshold value to assess</p>
</td></tr>
<tr><td><code id="getFuncsMaxed_+3A_threshstep">threshstep</code></td>
<td>
<p>The incremental steps between lowest and highest thresholds to be assessed.  See <code>seq</code>.</p>
</td></tr>
<tr><td><code id="getFuncsMaxed_+3A_proportion">proportion</code></td>
<td>
<p>Whether the output will be returned as a porportion of all functions.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getFuncsMaxed_+3A_prepend">prepend</code></td>
<td>
<p>Additional columns that will be imported from the data for the returned data frame.</p>
</td></tr>
<tr><td><code id="getFuncsMaxed_+3A_maxn">maxN</code></td>
<td>
<p>As a 'maximum' value can be subject to outliers, etc., what number of the highest data points
for a function will be used to calculate the value against which thresholds will be judged.  E.g., if maxN=1
then all thresholds are porportions of the largest value measured for a function.  If maxN=8, then it's the
porportion of the mean of the highest 8 measurements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a data frame that has the value of number or proportion of functions
greater than a threshold for several different thresholds at the plot.
</p>


<h3>Value</h3>

<p>Returns a data frame of number or fraction of functions greater than or equal to the selected thresholds in each plot over all thresholds within the relevant range.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)

# re-normalize N.Soil so that everything is on the same
# sign-scale (e.g. the maximum level of a function is
# the "best" function)
germany$N.Soil &lt;- -1 * germany$N.Soil + 
                  max(germany$N.Soil, na.rm = TRUE)

germanyThresh &lt;- getFuncsMaxed(germany, vars,
  threshmin = 0.50,
  threshmax = 0.60, prepend = c("plot", "Diversity"), maxN = 7
)


</code></pre>

<hr>
<h2 id='getIndices'>getIndices</h2><span id='topic+getIndices'></span>

<h3>Description</h3>

<p><code>getIndices</code> Generates a variety of indices describing multifunctionality based on
the number of functions greater than a threshold for many different threshold and coefficients describing
the relationship between diversity and number of functoins greater than a threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIndices(
  slopedata,
  threshdata,
  eqn,
  fun = stats::glm,
  divvar = "Diversity",
  groupVar = "thresholds",
  showNfunc = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getIndices_+3A_slopedata">slopedata</code></td>
<td>
<p>A data frame with slopes of the relationship between diversity and number of functions greather than or equal to a threshold
from <code>getCoefTab</code>.</p>
</td></tr>
<tr><td><code id="getIndices_+3A_threshdata">threshdata</code></td>
<td>
<p>A data frame with the number of functions greater than a threshold for each plot at each threshold from <code>getFuncsMaxed</code>.</p>
</td></tr>
<tr><td><code id="getIndices_+3A_eqn">eqn</code></td>
<td>
<p>The formula used for fitting the models in slopedata.</p>
</td></tr>
<tr><td><code id="getIndices_+3A_fun">fun</code></td>
<td>
<p>The function used to refit the threshold data at key points to get intercepts, etc., that are needed for the table.</p>
</td></tr>
<tr><td><code id="getIndices_+3A_divvar">divvar</code></td>
<td>
<p>The name of the variable that has the measure of diversity or other driver in the threshdata data frame.</p>
</td></tr>
<tr><td><code id="getIndices_+3A_groupvar">groupVar</code></td>
<td>
<p>The name of a variable by which data is grouped in the threshdata data frame. Typically &quot;thresholds&quot; from <code>getFuncsMaxed</code>.</p>
</td></tr>
<tr><td><code id="getIndices_+3A_shownfunc">showNfunc</code></td>
<td>
<p>Show the functions at Tmin, Tmax, and Tmde. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Byrnes et al. In Review.
</p>


<h3>Value</h3>

<p>A data frame of indices
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)

germanyThresh &lt;- getFuncsMaxed(germany, vars,
  threshmin = 0.05,
  threshmax = 0.99, prepend = c("plot", "Diversity"), maxN = 7
)

germanyLinearSlopes &lt;- getCoefTab(funcMaxed ~ Diversity,
  data = germanyThresh,
  coefVar = "Diversity", family = quasipoisson(link = "identity")
)

getIndices(germanyLinearSlopes, germanyThresh, funcMaxed ~ Diversity)


</code></pre>

<hr>
<h2 id='getMF_eff'>getMF_eff</h2><span id='topic+getMF_eff'></span>

<h3>Description</h3>

<p>A multifunctionality index rooted in Hill numbers.
<code>getMF_eff</code> get multifunctionality index defined by function and effective number of functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMF_eff(
  data,
  vars,
  q = 1,
  standardized = FALSE,
  standardize_function = standardizeUnitScale,
  D = NULL,
  tau = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMF_eff_+3A_data">data</code></td>
<td>
<p>A data frame with functions in columns and rows as replicates as well as other information.</p>
</td></tr>
<tr><td><code id="getMF_eff_+3A_vars">vars</code></td>
<td>
<p>Name of function variables</p>
</td></tr>
<tr><td><code id="getMF_eff_+3A_q">q</code></td>
<td>
<p>Order of the diversity measure. Defaults to the
Shannon case where q = 1. For Simpson, q=2.</p>
</td></tr>
<tr><td><code id="getMF_eff_+3A_standardized">standardized</code></td>
<td>
<p>Use standardized number of functions (scaled by total
number of functions, so between 0-1), or just raw effective number of
functions for calculation. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getMF_eff_+3A_standardize_function">standardize_function</code></td>
<td>
<p>A function to standardize each individual
function to the same scale, such as <code>standardizeUnitScale</code> or
<code>standardizeZScore</code></p>
</td></tr>
<tr><td><code id="getMF_eff_+3A_d">D</code></td>
<td>
<p>A distance matrix describing dissimilarity between functions. Defaults
to NULL, and the index is calculated assuming all functions are different. If
it is not null, it must be a symmetric matrix with dimensions matching the
number of functions listed in <code>vars</code>.</p>
</td></tr>
<tr><td><code id="getMF_eff_+3A_tau">tau</code></td>
<td>
<p>A cutoff for degree of dissimilarity under which functions are considered
to be different. If tau is the minimum non-zero value of D, all functions are different.
if tau is the maximum value of D are greater, all functions are considered the same.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a data frame, variable names, a standardizing function, whether we want
an index standardized by number of functions or not, an order of Hill number for our
effective number of functions as well as a dissimilarity matrix (if desired) and value
for a dissimilarity cutoff (defaults to the average dissimilarity). It then calculates
both the average standardized function in each plot and the effective number of
functions and returns their product as a measure of effective multifunctionality.
</p>


<h3>Value</h3>

<p>Returns a vector of effective or standardized effective multifunctionality.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>References</h3>

<p>Chao, A., Chiu, C.-H., Vill√©ger, S., Sun, I.-F., Thorn, S., Lin, Y.-C.,
Chiang, J.-M. and Sherwin, W. B. 2019. An attribute-diversity approach to
functional diversity, functional beta diversity, and related (dis)similarity
measures. Ecological Monographs. 89: e01343.
</p>
<p>Jost, L. 2006. Entropy and diversity. Oikos 113(2): 363-375.
</p>
<p>Hill, M. 1973. Diversity and evenness: A unifying notation and its
consequences. Ecology 54: 427-432.
</p>

<hr>
<h2 id='getOverlap'>getOverlap</h2><span id='topic+getOverlap'></span>

<h3>Description</h3>

<p><code>getOverlap</code> goes through all m-wise combinations of species
and returns the amount of overlap between species in functions they perform
for each combination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOverlap(
  overData,
  m = 2,
  type = "positive",
  index = "sorensen",
  denom = "set"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getOverlap_+3A_overdata">overData</code></td>
<td>
<p>Matrix of functions and which species affect them from <code>getRedundancy</code>.</p>
</td></tr>
<tr><td><code id="getOverlap_+3A_m">m</code></td>
<td>
<p>Number of functions. Defaults to 2.</p>
</td></tr>
<tr><td><code id="getOverlap_+3A_type">type</code></td>
<td>
<p>Are the kinds of effects we're looking at &quot;positive&quot;, &quot;negative&quot; or &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="getOverlap_+3A_index">index</code></td>
<td>
<p>Type of overlap index to be used. Defaults to &quot;sorenson&quot; but currently incorporates
&quot;mountford&quot; and &quot;jaccard&quot; as well.</p>
</td></tr>
<tr><td><code id="getOverlap_+3A_denom">denom</code></td>
<td>
<p>Should the denominator be &quot;all&quot; species or just the &quot;set&quot; of species with the types
of interactions being considered? Defaults to &quot;set&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>getOverlap takes a matrix of 1s and -1s, and depending on whether we're
interested in positive, negative, or both types of interactions looks for the
m-wise overlap between species and returns the overlap index for each combination
</p>


<h3>Value</h3>

<p>Returns a vector of overlap indices.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)
species &lt;- relevantSp(germany, 26:ncol(germany))

# re-normalize N.Soil so that everything is on the
# same sign-scale (e.g. the maximum level of a function is the "best" function)
germany$N.Soil &lt;- -1 * germany$N.Soil + max(germany$N.Soil, na.rm = TRUE)

res.list &lt;- lapply(vars, function(x) sAICfun(x, species, germany))
names(res.list) &lt;- vars

redund &lt;- getRedundancy(vars, species, germany)

getOverlap(redund, m = 2)
getOverlap(redund, m = 2, index = "jaccard")
getOverlap(redund, m = 2, index = "mountford")

#########
# getOverlap takes a matrix of 1s and -1s, and depending on whether we're
# interested in positive, negative, or both types of interactions looks for the
# m-wise overlap
#########
</code></pre>

<hr>
<h2 id='getOverlapSummary'>getOverlapSummary</h2><span id='topic+getOverlapSummary'></span>

<h3>Description</h3>

<p><code>getOverlapSummary</code> summarizes the number of species necessary for each function
including means, SDs, and other metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOverlapSummary(
  overData,
  m = 2,
  type = "positive",
  index = "sorensen",
  denom = "set"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getOverlapSummary_+3A_overdata">overData</code></td>
<td>
<p>Matrix of functions and which species affect them from <code>getRedundancy</code>.</p>
</td></tr>
<tr><td><code id="getOverlapSummary_+3A_m">m</code></td>
<td>
<p>Number of functions. Defaults to 2.</p>
</td></tr>
<tr><td><code id="getOverlapSummary_+3A_type">type</code></td>
<td>
<p>Are the kinds of effects we're looking at &quot;positive&quot;, &quot;negative&quot; or &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="getOverlapSummary_+3A_index">index</code></td>
<td>
<p>Type of overlap index to be used by <code>getOverlap</code>.</p>
</td></tr>
<tr><td><code id="getOverlapSummary_+3A_denom">denom</code></td>
<td>
<p>Type of denominator to be used by <code>getOverlap</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>getOverlapSummary takes a matrix of 1s and -1s, and depending on whether we're
interested in positive, negative, or both types of interactions looks for the
m-wise overlap between species and then reports summary metrics of mean overlap,
SD, and number of combinations
</p>


<h3>Value</h3>

<p>Returns a data frame of the mean overlap, SD, and number of possible combinations.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)
species &lt;- relevantSp(germany, 26:ncol(germany))

# re-normalize N.Soil so that everything is on the same
# sign-scale (e.g. the maximum level of a function is
# the "best" function)
germany$N.Soil &lt;- -1 * germany$N.Soil + max(germany$N.Soil, na.rm = TRUE)

res.list &lt;- lapply(vars, function(x) sAICfun(x, species, germany))
names(res.list) &lt;- vars

redund &lt;- getRedundancy(vars, species, germany)

getOverlapSummary(redund, m = 2)


#########
# getOverlapSummary takes a matrix of 1s and -1s, and depending on whether we're
# interested in positive, negative, or both types of interactions looks for the
# m-wise overlap and then reports summary metrics of mean overlap, SD, and number of combinations
#########
</code></pre>

<hr>
<h2 id='getRedundancy'>getRedundancy</h2><span id='topic+getRedundancy'></span>

<h3>Description</h3>

<p><code>getRedundancy</code> examines which species have an effect on which function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRedundancy(
  vars,
  species,
  data,
  negVars = NA,
  method = "lm",
  combine = "+",
  output = "effect",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRedundancy_+3A_vars">vars</code></td>
<td>
<p>Vector of column names of functions</p>
</td></tr>
<tr><td><code id="getRedundancy_+3A_species">species</code></td>
<td>
<p>Vector of column names of species</p>
</td></tr>
<tr><td><code id="getRedundancy_+3A_data">data</code></td>
<td>
<p>data frame with species presence/absence of values of functions</p>
</td></tr>
<tr><td><code id="getRedundancy_+3A_negvars">negVars</code></td>
<td>
<p>Vector of names of species for which a negative coefficient is actually a positive effect.</p>
</td></tr>
<tr><td><code id="getRedundancy_+3A_method">method</code></td>
<td>
<p>Fitting function for statistical models.  Defaults to <code>lm</code>.</p>
</td></tr>
<tr><td><code id="getRedundancy_+3A_combine">combine</code></td>
<td>
<p>How are species combined in the model? Defaults to &quot;+&quot; for additive combinations.</p>
</td></tr>
<tr><td><code id="getRedundancy_+3A_output">output</code></td>
<td>
<p>Will the output be sign of effect or &quot;coefficient&quot;.  Defaults to &quot;effect&quot;</p>
</td></tr>
<tr><td><code id="getRedundancy_+3A_...">...</code></td>
<td>
<p>Other arguments to be supplied to fitting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>getRedundancy takes a matrix of 1s,0s, and -1s, and depending on whether we're
interested in positive, negative, or both types of interactions looks for the
m-wise overlap between species and returns the overlap index for each combination. For
species whose effect is not different from 0 at the alpha=0.05 level, a 0 is returned.
</p>


<h3>Value</h3>

<p>Returns a matrix of functions and the effect of species on each. 1s, -1s, and 0s for &quot;effect&quot; or coefficients.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)
species &lt;- relevantSp(germany, 26:ncol(germany))

# re-normalize N.Soil so that everything is on the same
# sign-scale (e.g. the maximum level of a function is
# the "best" function)
germany$N.Soil &lt;- -1 * germany$N.Soil + max(germany$N.Soil, na.rm = TRUE)

res.list &lt;- lapply(vars, function(x) sAICfun(x, species, germany))
names(res.list) &lt;- vars

getRedundancy(vars, species, germany)
getRedundancy(vars, species, germany, output = "coef")



#########
# takes a vector of responses, the species that may cause them
# and returns a table of 1s, -1s, and 0s with regards to the kind of effect
# or a coefficient table, if asked for.  Arugments can take the form of the fitting function
# how variables are combined, and additional arguments to the fitting function
#########
</code></pre>

<hr>
<h2 id='getStdAndMeanFunctions'>getStdAndMeanFunctions</h2><span id='topic+getStdAndMeanFunctions'></span>

<h3>Description</h3>

<p><code>getStdAndMeanFunctions</code> creates an average function multifunctionality index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStdAndMeanFunctions(data, vars, standardizeFunction = standardizeUnitScale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getStdAndMeanFunctions_+3A_data">data</code></td>
<td>
<p>A data frame with functions.</p>
</td></tr>
<tr><td><code id="getStdAndMeanFunctions_+3A_vars">vars</code></td>
<td>
<p>The column names of the functions to be assessed.</p>
</td></tr>
<tr><td><code id="getStdAndMeanFunctions_+3A_standardizefunction">standardizeFunction</code></td>
<td>
<p>A function to standardize each individual
function to the same scale, such as <code>standardizeUnitScale</code> or
<code>standardizeZScore</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>iterates over all functions and
standardizes them between 0 and 1.  Then it creates an averaged
multifunctionality index by averaging over all standardized functions
</p>


<h3>Value</h3>

<p>Returns a data frame with
standardized values for each function and an averaged index.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)

# re-normalize N.Soil so that everything is on the same
# sign-scale (e.g. the maximum level of a function is
# the "best" function)
germany$N.Soil &lt;- -1 * germany$N.Soil + max(germany$N.Soil, na.rm = TRUE)

germany &lt;- cbind(germany, getStdAndMeanFunctions(germany, vars))
</code></pre>

<hr>
<h2 id='qw'>Quote Words</h2><span id='topic+qw'></span>

<h3>Description</h3>

<p><code>qw</code> Takes an unquoted vector and adds quotes to it like the qw function in perl.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qw(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qw_+3A_...">...</code></td>
<td>
<p>Any unquoted strings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for data processing. Honestly, I use qw all the time
in other languages, and wanted a version for R.
</p>


<h3>Value</h3>

<p>A vector
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c("a", "b")

qw(a, b)



# qw - a helper function that we
# will use later to deal with strings
# analagous to qw in PERL
</code></pre>

<hr>
<h2 id='relevantSp'>relevantSp</h2><span id='topic+relevantSp'></span>

<h3>Description</h3>

<p><code>relevantSp</code> Which species are being used in this analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relevantSp(data, colnums = 26:128)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relevantSp_+3A_data">data</code></td>
<td>
<p>A data frame with presence/abscence of different species.</p>
</td></tr>
<tr><td><code id="relevantSp_+3A_colnums">colnums</code></td>
<td>
<p>Column numbers that will be assessed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which columns have values that are greater than zero.
</p>


<h3>Value</h3>

<p>A vector of columns names.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>

<hr>
<h2 id='sAICfun'>sAICfun</h2><span id='topic+sAICfun'></span>

<h3>Description</h3>

<p><code>sAICfun</code> examines which species have an effect on which function using a stepwise AIC approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sAICfun(
  response,
  species,
  data,
  positive.desired = TRUE,
  method = "lm",
  combine = "+",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sAICfun_+3A_response">response</code></td>
<td>
<p>Name of the response column</p>
</td></tr>
<tr><td><code id="sAICfun_+3A_species">species</code></td>
<td>
<p>Vector of column names of species</p>
</td></tr>
<tr><td><code id="sAICfun_+3A_data">data</code></td>
<td>
<p>data frame with species presence/abscence of values of functions</p>
</td></tr>
<tr><td><code id="sAICfun_+3A_positive.desired">positive.desired</code></td>
<td>
<p>Is a positive effect the desired sign.  Defaults to TRUE</p>
</td></tr>
<tr><td><code id="sAICfun_+3A_method">method</code></td>
<td>
<p>Fitting function for statistical models.  Defaults to <code>lm</code>.</p>
</td></tr>
<tr><td><code id="sAICfun_+3A_combine">combine</code></td>
<td>
<p>How are species combined in the model? Defaults to &quot;+&quot; for additive combinations.</p>
</td></tr>
<tr><td><code id="sAICfun_+3A_...">...</code></td>
<td>
<p>Other arguments to be supplied to fitting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sAICfun</code> takes a dataset, response, and function, and then uses a stepAIC approach
to determine the best model.  From that it extracts the species with a positive,
negative, and neutral effect on that function.
</p>


<h3>Value</h3>

<p>Returns list of species with positive
negative or neutral contributions, the
relevant coefficient and effect matrices, and response name
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)
species &lt;- relevantSp(germany, 26:ncol(germany))

# re-normalize N.Soil so that everything is on the same
# sign-scale (e.g. the maximum level of a function is
# the "best" function)
germany$N.Soil &lt;- -1 * germany$N.Soil + max(germany$N.Soil, na.rm = TRUE)

spList &lt;- sAICfun("biomassY3", species, germany)
# " spList
res.list &lt;- lapply(vars, function(x) sAICfun(x, species, germany))
names(res.list) &lt;- vars



#########
# sAICfun takes a dataset, response, and function, and then uses a stepAIC approach
# to determine the best model.  From that it extracts the species with a positive,
# negative, and neutral effect on that function
#########
</code></pre>

<hr>
<h2 id='standardizeUnitScale'>standardizeUnitScale</h2><span id='topic+standardizeUnitScale'></span>

<h3>Description</h3>

<p><code>standardizeUnitScale</code> standardized a variable so its maximum is 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardizeUnitScale(afun, min0 = TRUE, maxValue = max(afun, na.rm = TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardizeUnitScale_+3A_afun">afun</code></td>
<td>
<p>A vector of measurements of a function.</p>
</td></tr>
<tr><td><code id="standardizeUnitScale_+3A_min0">min0</code></td>
<td>
<p>Must a minimum value be greater than or equal to 0?  Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="standardizeUnitScale_+3A_maxvalue">maxValue</code></td>
<td>
<p>The maximum valye by which the vector will be standardized.  Defaults to
the vector's maximum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a vector and then divides it by a maximum value.
</p>


<h3>Value</h3>

<p>Returns a standardized vector.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>

<hr>
<h2 id='standardizeZScore'>standardizeZScore</h2><span id='topic+standardizeZScore'></span>

<h3>Description</h3>

<p><code>standardizeZScore</code> Z-standardizes a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardizeZScore(afun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardizeZScore_+3A_afun">afun</code></td>
<td>
<p>A vector of measurements of a function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Centers a vector and divides it by its standard deviation.
</p>


<h3>Value</h3>

<p>Returns a z-standardized vector.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>

<hr>
<h2 id='stdEffects'>stdEffects</h2><span id='topic+stdEffects'></span>

<h3>Description</h3>

<p><code>stdEffects</code> obtains the standardized effect of each species on each function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdEffects(cmat, adf, vars, species)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stdEffects_+3A_cmat">cmat</code></td>
<td>
<p>Matrix of coefficients of species effects on functions from <code>getRedundancy</code> with output=&quot;coef&quot;.</p>
</td></tr>
<tr><td><code id="stdEffects_+3A_adf">adf</code></td>
<td>
<p>Data frame with plot level data for species and functions.</p>
</td></tr>
<tr><td><code id="stdEffects_+3A_vars">vars</code></td>
<td>
<p>Names of columns with data for functions in adf.</p>
</td></tr>
<tr><td><code id="stdEffects_+3A_species">species</code></td>
<td>
<p>Names of columns with data for species in adf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>stdEffects takes a matrix of coefficients for relationships
between species and functions, the data frame used to generate those coefficients
and the names of species and function, and then it calculates standardized coefficients
using std coef = b *sx/sy
</p>


<h3>Value</h3>

<p>Returns a matrix of standardized coefficients.
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)
species &lt;- relevantSp(germany, 26:ncol(germany))

# re-normalize N.Soil so that everything is on the same
# sign-scale (e.g. the maximum level of a function is
# the "best" function)
germany$N.Soil &lt;- -1 * germany$N.Soil + max(germany$N.Soil, na.rm = TRUE)

res.list &lt;- lapply(vars, function(x) sAICfun(x, species, germany))
names(res.list) &lt;- vars

coefs &lt;- getRedundancy(vars, species, germany, output = "coef")
stdCoefs &lt;- stdEffects(coefs, germany, vars, species)

#########
# A function that uses the coefficient matrix and information from the
# data to calculate standardized effects of species using the method
# std coef = b *sx/sy
#########
</code></pre>

<hr>
<h2 id='whichVars'>whichVars</h2><span id='topic+whichVars'></span>

<h3>Description</h3>

<p><code>whichVars</code> takes a data frame and the names of a set of columns
and returns the names of those columns that do not have an excessive fraction
of NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whichVars(a.df, vars = NA, thresh = 2/3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whichVars_+3A_a.df">a.df</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="whichVars_+3A_vars">vars</code></td>
<td>
<p>The names of the columns that contain data of interest</p>
</td></tr>
<tr><td><code id="whichVars_+3A_thresh">thresh</code></td>
<td>
<p>The fraction of NA values in a column that is acceptable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for data processing.
</p>


<h3>Value</h3>

<p>A vector of column names
</p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(all_biodepth)
allVars &lt;- qw(biomassY3, root3, N.g.m2, light3, N.Soil, wood3, cotton3)

germany &lt;- subset(all_biodepth, all_biodepth$location == "Germany")

vars &lt;- whichVars(germany, allVars)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
