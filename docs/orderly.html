<!DOCTYPE html><html lang="en-GB"><head><title>Help for package orderly</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {orderly}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#orderly_batch'><p>Run a batch of reports.</p></a></li>
<li><a href='#orderly_bundle_pack'><p>Pack and run orderly &quot;bundles&quot;</p></a></li>
<li><a href='#orderly_bundle_pack_remote'><p>Pack and import bundles with remotes</p></a></li>
<li><a href='#orderly_cleanup'><p>Orderly cleanup</p></a></li>
<li><a href='#orderly_commit'><p>Commit a generated report</p></a></li>
<li><a href='#orderly_config'><p>Retrieve orderly config object.</p></a></li>
<li><a href='#orderly_db'><p>Connect to orderly databases</p></a></li>
<li><a href='#orderly_deduplicate'><p>Deduplicate an orderly archive</p></a></li>
<li><a href='#orderly_default_remote_set'><p>Set default remote location</p></a></li>
<li><a href='#orderly_develop_start'><p>Develop an orderly report</p></a></li>
<li><a href='#orderly_example'><p>Set up an orderly example</p></a></li>
<li><a href='#orderly_graph'><p>Print the dependency tree for a given report using orderly log</p></a></li>
<li><a href='#orderly_graph_out_of_date'><p>Given a tree return a list of reports to be re-run (and the order</p>
that they should be re-run)</a></li>
<li><a href='#orderly_info'><p>Return info about a report which has been run</p></a></li>
<li><a href='#orderly_init'><p>Initialise an orderly store</p></a></li>
<li><a href='#orderly_latest'><p>Find most recent report</p></a></li>
<li><a href='#orderly_list'><p>List orderly reports</p></a></li>
<li><a href='#orderly_list_drafts'><p>List draft and archived reports</p></a></li>
<li><a href='#orderly_list_metadata'><p>List reports with only local metadata</p></a></li>
<li><a href='#orderly_log_on'><p>Orderly logging and diagnostic messages</p></a></li>
<li><a href='#orderly_migrate'><p>Migrate an orderly archive</p></a></li>
<li><a href='#orderly_new'><p>Create new report</p></a></li>
<li><a href='#orderly_pull_dependencies'><p>Download dependent reports</p></a></li>
<li><a href='#orderly_rebuild'><p>Rebuild the report database</p></a></li>
<li><a href='#orderly_remote'><p>Get a remote</p></a></li>
<li><a href='#orderly_remote_path'><p>Orderly remote at a different path</p></a></li>
<li><a href='#orderly_remote_status'><p>Get status of remote queue.</p></a></li>
<li><a href='#orderly_run'><p>Run a report</p></a></li>
<li><a href='#orderly_run_info'><p>Information on current orderly run</p></a></li>
<li><a href='#orderly_run_remote'><p>Run a report on a remote server</p></a></li>
<li><a href='#orderly_search'><p>Search for orderly reports matching criteria</p></a></li>
<li><a href='#orderly_test_start'><p>Prepare a directory for orderly to use</p></a></li>
<li><a href='#orderly_use_resource'><p>Add a resource to orderly.yml</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Lightweight Reproducible Reporting</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Order, create and store reports from R.  By defining a
    lightweight interface around the inputs and outputs of an
    analysis, a lot of the repetitive work for reproducible research
    can be automated.  We define a simple format for organising and
    describing work that facilitates collaborative reproducible
    research and acknowledges that all analyses are run multiple
    times over their lifespans.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.vaccineimpact.org/orderly/">https://www.vaccineimpact.org/orderly/</a>,
<a href="https://github.com/vimc/orderly">https://github.com/vimc/orderly</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vimc/orderly/issues">https://github.com/vimc/orderly/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>git</td>
</tr>
<tr>
<td>Imports:</td>
<td>DBI, R6, RSQLite (&ge; 2.2.4), crayon, digest, docopt, fs (&ge;
1.2.7), gert, ids, withr, yaml, zip (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>httr, jsonlite, knitr, markdown, mockery, processx,
rmarkdown, testthat, vaultr (&ge; 1.0.4)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-22 09:21:19 UTC; rfitzjoh</td>
</tr>
<tr>
<td>Author:</td>
<td>Rich FitzJohn [aut, cre],
  Robert Ashton [aut],
  Alex Hill [aut],
  Martin Eden [aut],
  Wes Hinsley [aut],
  Emma Russell [aut],
  James Thompson [aut],
  Imperial College of Science, Technology and Medicine [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rich FitzJohn &lt;rich.fitzjohn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-22 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='orderly_batch'>Run a batch of reports.</h2><span id='topic+orderly_batch'></span>

<h3>Description</h3>

<p>Run one report multiple times with different sets of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_batch(name = NULL, parameters = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_batch_+3A_name">name</code></td>
<td>
<p>Name of the report to run (see
<code><a href="#topic+orderly_list">orderly_list()</a></code>).  A leading <code style="white-space: pre;">&#8288;src/&#8288;</code> will be
removed if provided, allowing easier use of autocomplete.
Alternatively, the default of <code>NULL</code> is useful if you have
already set the working directory to be the source directory.</p>
</td></tr>
<tr><td><code id="orderly_batch_+3A_parameters">parameters</code></td>
<td>
<p>Data frame of parameters passed to report. Each row
represents a parameter set to be passed to one report run.</p>
</td></tr>
<tr><td><code id="orderly_batch_+3A_...">...</code></td>
<td>
<p>Additional args passed to <code><a href="#topic+orderly_run">orderly_run()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of ids of newly created reports
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderly_run">orderly_run()</a></code> for details of report running
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- orderly::orderly_example("demo")
params &lt;- data.frame(nmin = c(0.2, 0.25))
ids &lt;- orderly::orderly_batch("other", params, root = path)
</code></pre>

<hr>
<h2 id='orderly_bundle_pack'>Pack and run orderly &quot;bundles&quot;</h2><span id='topic+orderly_bundle_pack'></span><span id='topic+orderly_bundle_run'></span><span id='topic+orderly_bundle_import'></span><span id='topic+orderly_bundle_list'></span>

<h3>Description</h3>

<p>Pack up and run orderly reports to run elsewhere. By using these
functions you can safely copy all requirements of an orderly
report into a portable archive and run them on another machine
(perhaps a cluster or HPC), then import the completed archive into
your orderly tree. There is considerable overhead to using these
functions (mostly due to transport costs) so they are intended
primarily for very computationally demanding patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_bundle_pack(
  path,
  name,
  parameters = NULL,
  envir = NULL,
  root = NULL,
  locate = TRUE,
  message = NULL,
  instance = NULL,
  remote = NULL,
  tags = NULL
)

orderly_bundle_run(path, workdir = tempfile(), echo = TRUE, envir = NULL)

orderly_bundle_import(path, root = NULL, locate = TRUE)

orderly_bundle_list(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_bundle_pack_+3A_path">path</code></td>
<td>
<p>A path, whose interpretation depends on the function:
</p>
<p><code>orderly_bundle_pack</code>: A directory to save bundles to.  If
it does not exist it will be created for you.
</p>
<p><code>orderly_bundle_run</code>: The path to the packed bundle (a zip
file created by <code>orderly_bundle_pack</code>)
</p>
<p><code>orderly_bundle_import</code>: The path to unpack and import
(a zip file created by <code>orderly_bundle_run</code>)
</p>
<p><code>orderly_bundle_list</code>: The path to a directory that might
contain either incomplete or complete bundles (created by either
<code>orderly_bundle_pack</code> or <code>orderly_bundle_run</code>)</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_+3A_name">name</code></td>
<td>
<p>Name of the report to pack (see
<code><a href="#topic+orderly_list">orderly_list()</a></code>.  A leading <code style="white-space: pre;">&#8288;src/&#8288;</code> will be removed if
provided, allowing easier use of autocomplete.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_+3A_parameters">parameters</code></td>
<td>
<p>Parameters passed to the report. A named list of
parameters declared in the <code>orderly.yml</code>.  Each parameter
must be a scalar character, numeric, integer or logical.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_+3A_envir">envir</code></td>
<td>
<p>The parent of the environment that will be used to
evaluate the report script; by default a new environment will be
made with the global environment as the parent.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_+3A_message">message</code></td>
<td>
<p>An optional character string containing a message
explaining why the report was run</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_+3A_instance">instance</code></td>
<td>
<p>Select instance of the source database to be used,
where multiple instances are configured.  Use a single
<em>unnamed</em> character string to indicate an instance to
match.  If given, then this name must be present in all
databases where instances are listed in
<code>orderly_config.yml</code>, and will be ignored by all database
where instances are not given.  See the &quot;orderly&quot; vignette for
further information.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_+3A_remote">remote</code></td>
<td>
<p>Remote to use to resolve dependencies.  Use this in
order to run a report with the same dependencies as are
available on a remote server, particularly when using <code>id = "latest"</code>.  Note that this is not the same as running
<code><a href="#topic+orderly_pull_dependencies">orderly_pull_dependencies()</a></code>, then <code>orderly_run</code>
with <code>remote = NULL</code>, as the pull/run approach will use the
latest report in <em>your</em> archive but the <code>remote = "remote"</code> approach will use the latest approach in the
<em>remote</em> archive (which might be less recent).</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_+3A_tags">tags</code></td>
<td>
<p>Character vector of tags to add to the report.  Tags
are immutable and cannot be removed once the report is run.
Tags added here will be <em>in addition</em> to any tags listed in
the <code style="white-space: pre;">&#8288;tags:&#8288;</code> field in <code>orderly.yml</code> and must be present
in <code>orderly_config.yml</code>.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_+3A_workdir">workdir</code></td>
<td>
<p>The path in which to run bundles.  If it does not
exist it will be created for you.  The completed bundle will be
saved in this directory as <code style="white-space: pre;">&#8288;&lt;id&gt;.zip&#8288;</code>.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_+3A_echo">echo</code></td>
<td>
<p>Print the result of running the R code to the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>orderly_bundle_pack</code> and
<code>orderly_bundle_run</code>, a list with elements <code>path</code> (the
path to the bundle) and <code>id</code> (its orderly id).  For
<code>orderly_bundle_list</code> a data.frame with key information
about the report in the bundles (id, name, parameters, status,
time).  The function <code>orderly_bundle_import</code> is called for
its side effect only and does not return anything useful.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- orderly::orderly_example("minimal")

# A working directory to export bundles to:
workdir &lt;- tempfile()

# Pack up the "example" report to go:
res &lt;- orderly::orderly_bundle_pack(workdir, "example", root = path)

# The return value is a list with the id and the path to the zip
# file created:
res

# A list of reports bundled in this directory and their status
orderly::orderly_bundle_list(workdir)

# Run the bundle (this would ordinarily be done on another computer)
zip &lt;- orderly::orderly_bundle_run(res$path, workdir)
zip

# The status has now been updated to reflect the status
orderly::orderly_bundle_list(workdir)

# We can import this into the orderly tree
orderly::orderly_bundle_import(zip$path, root = path)

# This has now been included in your orderly archive and the
# workdir can be safely deleted
unlink(workdir, recursive = TRUE)
orderly::orderly_list_archive(path)
</code></pre>

<hr>
<h2 id='orderly_bundle_pack_remote'>Pack and import bundles with remotes</h2><span id='topic+orderly_bundle_pack_remote'></span><span id='topic+orderly_bundle_import_remote'></span>

<h3>Description</h3>

<p>Pack a bundle on a remote. This is like calling
<code><a href="#topic+orderly_bundle_pack">orderly_bundle_pack()</a></code> on the remote and can be used to
extract a long-running report from a server to run (say) on an HPC
system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_bundle_pack_remote(
  name,
  parameters = NULL,
  instance = NULL,
  root = NULL,
  locate = TRUE,
  remote = NULL,
  dest = tempdir()
)

orderly_bundle_import_remote(path, root = NULL, locate = TRUE, remote = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_bundle_pack_remote_+3A_name">name</code></td>
<td>
<p>Name of the report to pack (see
<code><a href="#topic+orderly_list">orderly_list()</a></code>.  A leading <code style="white-space: pre;">&#8288;src/&#8288;</code> will be removed if
provided, allowing easier use of autocomplete.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_remote_+3A_parameters">parameters</code></td>
<td>
<p>Parameters passed to the report. A named list of
parameters declared in the <code>orderly.yml</code>.  Each parameter
must be a scalar character, numeric, integer or logical.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_remote_+3A_instance">instance</code></td>
<td>
<p>Select instance of the source database to be used,
where multiple instances are configured.  Use a single
<em>unnamed</em> character string to indicate an instance to
match.  If given, then this name must be present in all
databases where instances are listed in
<code>orderly_config.yml</code>, and will be ignored by all database
where instances are not given.  See the &quot;orderly&quot; vignette for
further information.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_remote_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_remote_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_remote_+3A_remote">remote</code></td>
<td>
<p>The remote to pack the bundle from, or import into</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_remote_+3A_dest">dest</code></td>
<td>
<p>Optional path to write bundle to (a directory
name). By default we use the temporary directory and return the
full path to the created file.</p>
</td></tr>
<tr><td><code id="orderly_bundle_pack_remote_+3A_path">path</code></td>
<td>
<p>The path to unpack and import
(a zip file created by <code>orderly_bundle_run</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The workflow here will typically be:
</p>

<ol>
<li><p> Use <code>orderly_bundle_pack_remote()</code> to create a local
copy of a bundle, extracted from a remote. Typically this will
be run from the system where the bundle will be run (an HPC
head-node or another powerful computer).
</p>
</li>
<li><p> Run the bundle using <code><a href="#topic+orderly_bundle_run">orderly_bundle_run()</a></code>
</p>
</li>
<li><p> Re-import the completed bundle using
<code>orderly_bundle_import_remote</code> which sends the zip
file to the remote and adds it to the archive.
</p>
</li></ol>

<p>Typically these commands will <em>not</em> be run from the orderly
root. However, the <code>root</code> argument may still be used to find
your remote configuration. Alternatively, if your <code>remote</code>
argument is an orderly remote (e.g.,
<code><a href="#topic+orderly_remote_path">orderly_remote_path()</a></code>, or <code>orderlyweb</code>'s
<code>orderlyweb::orderlyweb_remote</code>) then the <code>root</code> and
<code>locate</code> arguments will be ignored and this command can be
run from anywhere. This is the recommended configuration for
running on a HPC system.
</p>

<hr>
<h2 id='orderly_cleanup'>Orderly cleanup</h2><span id='topic+orderly_cleanup'></span>

<h3>Description</h3>

<p>Clean up orderly draft and data directories.  Deletes all drafts
(possibly just for a set of report names) and then deletes
dangling data sets that are not pointed to by any draft or
committed reports.  Running cleanup does not affect any reports
that have been committed with <code><a href="#topic+orderly_commit">orderly_commit()</a></code> (i.e.,
the contents of the <code style="white-space: pre;">&#8288;archive/&#8288;</code> directory).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_cleanup(
  name = NULL,
  root = NULL,
  locate = TRUE,
  draft = TRUE,
  data = TRUE,
  failed_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_cleanup_+3A_name">name</code></td>
<td>
<p>Optional name; in this case only clean up drafts with this name</p>
</td></tr>
<tr><td><code id="orderly_cleanup_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_cleanup_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_cleanup_+3A_draft">draft</code></td>
<td>
<p>Logical, indicating if drafts should be removed</p>
</td></tr>
<tr><td><code id="orderly_cleanup_+3A_data">data</code></td>
<td>
<p>Logical, indicating if dangling data should be removed
(data not used by any draft or archived report).</p>
</td></tr>
<tr><td><code id="orderly_cleanup_+3A_failed_only">failed_only</code></td>
<td>
<p>Delete only failed reports (those without the
end-of-run metadata).  This will also clean up drafts created by
<code><a href="#topic+orderly_test_start">orderly_test_start()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, this function is called only for its side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In a new example orderly, run two reports and commit only the
# second one:
path &lt;- orderly::orderly_example("minimal")
id1 &lt;- orderly::orderly_run("example", root = path)
id2 &lt;- orderly::orderly_run("example", root = path)
orderly::orderly_commit(id2, root = path)

# We now have one draft and one archive report:
orderly::orderly_list_drafts(root = path)
orderly::orderly_list_archive(root = path)

# To clean up the drafts:
orderly::orderly_cleanup(root = path)

# We now have no draft and one archive reports:
orderly::orderly_list_drafts(root = path)
orderly::orderly_list_archive(root = path)
</code></pre>

<hr>
<h2 id='orderly_commit'>Commit a generated report</h2><span id='topic+orderly_commit'></span>

<h3>Description</h3>

<p>Commit a generated report, moving it from the <code style="white-space: pre;">&#8288;draft/&#8288;</code>
directory to <code style="white-space: pre;">&#8288;archive/&#8288;</code> and updating the orderly index.  Once
committed, reports should not be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_commit(id, name = NULL, root = NULL, locate = TRUE, timeout = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_commit_+3A_id">id</code></td>
<td>
<p>The identifier of the report</p>
</td></tr>
<tr><td><code id="orderly_commit_+3A_name">name</code></td>
<td>
<p>The name of the report - this can be omitted and the
name will be determined from the <code>id</code>.</p>
</td></tr>
<tr><td><code id="orderly_commit_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_commit_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_commit_+3A_timeout">timeout</code></td>
<td>
<p>Time in seconds to wait for db to be available. In
parallel the database may become locked so we can choose to wait
for <code>timeout</code> seconds before throwing an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path to the newly committed report
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In a new example orderly, run a report
path &lt;- orderly::orderly_example("minimal")
id &lt;- orderly::orderly_run("example", root = path)

# To commit it, all we need is the report id
orderly::orderly_commit(id, root = path)

# The report is now committed, and as such could be used as a
# dependency in another report and is not subject to deletion by
# orderly::orderly_cleanup
orderly::orderly_list_archive(root = path)
</code></pre>

<hr>
<h2 id='orderly_config'>Retrieve orderly config object.</h2><span id='topic+orderly_config'></span><span id='topic+orderly_config_'></span>

<h3>Description</h3>

<p>Retrieve orderly config object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_config(root = NULL, locate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_config_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_config_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R6 object representing the orderly config.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>root</code></dt><dd><p>Root dir of the orderly repository</p>
</dd>
<dt><code>raw</code></dt><dd><p>The raw orderly config yaml</p>
</dd>
<dt><code>destination</code></dt><dd><p>DB connection configuration for where
to store orderly output database. Defaults to local SQLite
db <code>orderly.sqlite</code></p>
</dd>
<dt><code>fields</code></dt><dd><p>Configuration of fields in reports, specifying
which are required</p>
</dd>
<dt><code>remote</code></dt><dd><p>Configuration of remote sources i.e. shared
copy of orderly on a remote machine</p>
</dd>
<dt><code>vault</code></dt><dd><p>Vault server connection information</p>
</dd>
<dt><code>global_resources</code></dt><dd><p>Path to dir containing global resources.</p>
</dd>
<dt><code>changelog</code></dt><dd><p>Changelog type configuration</p>
</dd>
<dt><code>tags</code></dt><dd><p>List of available tags for orderly reports.</p>
</dd>
<dt><code>database</code></dt><dd><p>Database configuration specifying driver and
connection args for (possibly multiple) databases</p>
</dd>
<dt><code>archive_version</code></dt><dd><p>Orderly version number of the archive</p>
</dd>
<dt><code>run_options</code></dt><dd><p>List of run options</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>orderly_config_$new()</code></a>
</p>
</li>
<li> <p><a href="#method-server_options"><code>orderly_config_$server_options()</code></a>
</p>
</li>
<li> <p><a href="#method-add_run_option"><code>orderly_config_$add_run_option()</code></a>
</p>
</li>
<li> <p><a href="#method-get_run_option"><code>orderly_config_$get_run_option()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object representing orderly config
</p>


<h5>Usage</h5>

<div class="r"><pre>orderly_config_$new(root, validate = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>root</code></dt><dd><p>Root dir of the orderly repository</p>
</dd>
<dt><code>validate</code></dt><dd><p>If TRUE migrate cfg to handle any
format changes and validate structure if well formed
for each of the cfg fields</p>
</dd>
</dl>

</div>


<hr>
<a id="method-server_options"></a>



<h4>Method <code>server_options()</code></h4>

<p>Get connection options for the current server. This is
the details from the &quot;remote&quot; section for the server
being run on. Server identified via env var
<code>ORDERLY_API_SERVER_IDENTITY</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>orderly_config_$server_options()</pre></div>



<h5>Returns</h5>

<p>Options for current server if can be identified,
otherwise NULL
</p>


<hr>
<a id="method-add_run_option"></a>



<h4>Method <code>add_run_option()</code></h4>

<p>Add a key-value pair run option
</p>


<h5>Usage</h5>

<div class="r"><pre>orderly_config_$add_run_option(name, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of run option</p>
</dd>
<dt><code>value</code></dt><dd><p>Value for run option</p>
</dd>
</dl>

</div>


<hr>
<a id="method-get_run_option"></a>



<h4>Method <code>get_run_option()</code></h4>

<p>Retrieve value of a run option
</p>


<h5>Usage</h5>

<div class="r"><pre>orderly_config_$get_run_option(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of run option</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># The orderly demo, with lots of potential reports:
path &lt;- orderly::orderly_example("demo")

orderly::orderly_config(path)
</code></pre>

<hr>
<h2 id='orderly_db'>Connect to orderly databases</h2><span id='topic+orderly_db'></span>

<h3>Description</h3>

<p>Connect to the orderly databases.  These should be treated as as
<em>read-only</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_db(type, root = NULL, locate = TRUE, validate = TRUE, instance = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_db_+3A_type">type</code></td>
<td>
<p>The type of connection to make (<code>source</code>,
<code>destination</code>, <code>csv</code> or <code>rds</code>).</p>
</td></tr>
<tr><td><code id="orderly_db_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_db_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_db_+3A_validate">validate</code></td>
<td>
<p>Logical, indicating if the database schema should
be validated on open (currently only applicable with <code>type = "destination"</code>).  This is primarily intended for internal use.</p>
</td></tr>
<tr><td><code id="orderly_db_+3A_instance">instance</code></td>
<td>
<p>Used only by <code>type = "source"</code>, and used to
select the instance, where multiple instances are configured.
Use a single <em>unnamed</em> character string to indicate an
instance to match.  If given, then this name must be present in
all databases where instances are listed in
<code>orderly_config.yml</code>, and will be ignored by all database
where instances are not given.  See the &quot;orderly&quot; vignette for
further information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Orderly has several databases:
</p>

<ul>
<li> <p><code>source</code>: All of the databases named in the <code>database</code> section
of the <code>orderly_config.yml</code>
</p>
</li>
<li> <p><code>destination</code>: The orderly index database (typically a SQLite
database stored at the orderly root)
</p>
</li>
<li> <p><code>csv</code>: The cache of database query results, in csv format
</p>
</li>
<li> <p><code>rds</code>: The cache of database query results, in rds format
</p>
</li></ul>



<h3>Value</h3>

<p>A database connection, or list of connections in the case
of <code>source</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an orderly that has a single commited report:
path &lt;- orderly::orderly_example("minimal")
id &lt;- orderly::orderly_run("example", root = path)
orderly::orderly_commit(id, root = path)

# The source database holds the data that might be accessible via
# the 'data' entry in orderly.yml:
db &lt;- orderly::orderly_db("source", root = path)
# This is a list, with one connection per database listed in the
# orderly_config.yml (an empty list if none are specified):
db
DBI::dbListTables(db$source)
head(DBI::dbReadTable(db$source, "data"))
DBI::dbDisconnect(db$source)

# The destination database holds information about the archived
# reports:
db &lt;- orderly::orderly_db("destination", root = path)
DBI::dbListTables(db)

# These tables are documented online:
# https://vimc.github.io/orderly/schema
DBI::dbReadTable(db, "report_version")
</code></pre>

<hr>
<h2 id='orderly_deduplicate'>Deduplicate an orderly archive</h2><span id='topic+orderly_deduplicate'></span>

<h3>Description</h3>

<p>Deduplicate an orderly archive.  Deduplicating an orderly archive
will replace all files that have the same content with &quot;hard
links&quot;.  This requires hard link support in the underlying
operating system, which is available on all unix-like systems
(e.g. MacOS and Linux) and on Windows since Vista.  However, on
windows systems this might require somewhat elevated privileges.
If you use this feature, it is <em>very important</em> that you
treat your orderly archive as read-only (though you should be
anyway) as changing one copy of a linked file changes all the
other instances of it - the files are literally the same file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_deduplicate(root = NULL, locate = TRUE, dry_run = TRUE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_deduplicate_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_deduplicate_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_deduplicate_+3A_dry_run">dry_run</code></td>
<td>
<p>Logical, indicating if the deduplication should be
planned but not run</p>
</td></tr>
<tr><td><code id="orderly_deduplicate_+3A_quiet">quiet</code></td>
<td>
<p>Logical, indicating if the status should not be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will alter your orderly archive.  Ordinarily this is
not something that should be done, so we try to be careful.  In
order for this to work, it is <em>very important</em> to treat your
orderly archive as read-only generally.  If your canonical orderly
archive is behind OrderlyWeb this will almost certainly be the
case already.
</p>
<p>With &quot;hard linking&quot;, two files with the same content can be
updated so that both files point at the same physical bit of data.
This is great, as if the file is large, then only one copy needs
to be stored.  However, this means that if a change is made to one
copy of the file, it is immediately reflected in the other, but
there is nothing to indicate that the files are linked!
</p>
<p>This approach is worth exploring if you have large files that are
outputs of one report and inputs to another, or large inputs
repeatedly used in different reports, or outputs that end up being
the same in multiple reports.  If you run the deduplication with
<code>dry_run = TRUE</code>, an indication of the savings will be
printed.
</p>


<h3>Value</h3>

<p>Invisibly, information about the duplication status of the
archive before deduplication was run.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- orderly::orderly_example("demo")
id1 &lt;- orderly::orderly_run("minimal", root = path)
id2 &lt;- orderly::orderly_run("minimal", root = path)
orderly_commit(id1, root = path)
orderly_commit(id2, root = path)
tryCatch(
  orderly::orderly_deduplicate(path, dry_run = TRUE),
  error = function(e) NULL)
</code></pre>

<hr>
<h2 id='orderly_default_remote_set'>Set default remote location</h2><span id='topic+orderly_default_remote_set'></span><span id='topic+orderly_default_remote_get'></span>

<h3>Description</h3>

<p>Set and get default remote locations.  Default locations are
specific to an orderly repository (based on the path of the
repository) so there is no interaction between different orderly
projects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_default_remote_set(value, root = NULL, locate = TRUE)

orderly_default_remote_get(root = NULL, locate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_default_remote_set_+3A_value">value</code></td>
<td>
<p>A string describing a remote, a remote object, or
<code>NULL</code> to clear</p>
</td></tr>
<tr><td><code id="orderly_default_remote_set_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_default_remote_set_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The default remote (for
<code>orderly_default_remote_get</code>). The function
<code>orderly_default_remote_set</code> is called for its side effects
only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Same setup as in orderly_remote_path, with a remote orderly:
path_remote &lt;- orderly::orderly_example("demo")
id &lt;- orderly::orderly_run("other", list(nmin = 0),
                           root = path_remote, echo = FALSE)
orderly::orderly_commit(id, root = path_remote)
id &lt;- orderly::orderly_run("use_dependency",
                           root = path_remote, echo = FALSE)
orderly::orderly_commit(id, root = path_remote)

# And a local orderly
path_local &lt;- orderly::orderly_example("demo")

# We'll create an object to interact with this remote using
# orderly_remote_path.
remote &lt;- orderly::orderly_remote_path(path_remote)

# There is no remote set by default:
try(orderly::orderly_default_remote_get(root = path_local))

# We can set one:
orderly::orderly_default_remote_set(remote, root = path_local)

# and now we can retrieve it:
orderly::orderly_default_remote_get(root = path_local)

# Note that this has not affected the other orderly:
try(orderly::orderly_default_remote_get(root = path_remote))
</code></pre>

<hr>
<h2 id='orderly_develop_start'>Develop an orderly report</h2><span id='topic+orderly_develop_start'></span><span id='topic+orderly_develop_status'></span><span id='topic+orderly_develop_clean'></span>

<h3>Description</h3>

<p>The functions <code>orderly_develop_start</code>,
<code>orderly_develop_status</code> and <code>orderly_develop_clean</code>
provide a workflow for developing a report in much the same way as
one might write code outside of orderly.
<code>orderly_develop_start</code> will copy all files required (global
resources and dependencies) into the report source directory, as
well as collect all data and parameters - at this point the
directory can be developed in directly.  It will also load all
declared packages, and source all code files listed in the
<code style="white-space: pre;">&#8288;packages:&#8288;</code> and <code style="white-space: pre;">&#8288;sources:&#8288;</code> sections of your
<code>orderly.yml</code>.  <code>orderly_develop_status</code> provides
information about the status of files in the directory, while
<code>orderly_develop_clean</code> deletes all copied files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_develop_start(
  name = NULL,
  parameters = NULL,
  envir = parent.frame(),
  root = NULL,
  locate = TRUE,
  instance = NULL,
  use_draft = FALSE,
  remote = NULL
)

orderly_develop_status(name = NULL, root = NULL, locate = TRUE)

orderly_develop_clean(name = NULL, root = NULL, locate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_develop_start_+3A_name">name</code></td>
<td>
<p>Name of the report to develop (see
<code><a href="#topic+orderly_list">orderly_list()</a></code>).  A leading <code style="white-space: pre;">&#8288;src/&#8288;</code> will be
removed if provided, allowing easier use of autocomplete.
Alternatively, the default of <code>NULL</code> is useful if you have
already set the working directory to be the source directory.</p>
</td></tr>
<tr><td><code id="orderly_develop_start_+3A_parameters">parameters</code></td>
<td>
<p>Parameters passed to the report. A named list of
parameters declared in the <code>orderly.yml</code>.  Each parameter
must be a scalar character, numeric, integer or logical.</p>
</td></tr>
<tr><td><code id="orderly_develop_start_+3A_envir">envir</code></td>
<td>
<p>The parent of the environment that will be used to
evaluate the report script; by default a new environment will be
made with the global environment as the parent.</p>
</td></tr>
<tr><td><code id="orderly_develop_start_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_develop_start_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_develop_start_+3A_instance">instance</code></td>
<td>
<p>Select instance of the source database to be used,
where multiple instances are configured.  Use a single
<em>unnamed</em> character string to indicate an instance to
match.  If given, then this name must be present in all
databases where instances are listed in
<code>orderly_config.yml</code>, and will be ignored by all database
where instances are not given.  See the &quot;orderly&quot; vignette for
further information.</p>
</td></tr>
<tr><td><code id="orderly_develop_start_+3A_use_draft">use_draft</code></td>
<td>
<p>Should draft reports be used for dependencies?
This should be used only in development.  Valid values are
logical (<code>TRUE</code>, <code>FALSE</code>) or use the string
<code>newer</code> to use draft reports where they are newer than
archive reports.  For consistency, <code>always</code> and
<code>never</code> are equivalent to <code>TRUE</code> and <code>FALSE</code>,
respectively.</p>
</td></tr>
<tr><td><code id="orderly_develop_start_+3A_remote">remote</code></td>
<td>
<p>Remote to use to resolve dependencies.  Use this in
order to run a report with the same dependencies as are
available on a remote server, particularly when using <code>id = "latest"</code>.  Note that this is not the same as running
<code><a href="#topic+orderly_pull_dependencies">orderly_pull_dependencies()</a></code>, then <code>orderly_run</code>
with <code>remote = NULL</code>, as the pull/run approach will use the
latest report in <em>your</em> archive but the <code>remote = "remote"</code> approach will use the latest approach in the
<em>remote</em> archive (which might be less recent).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are designed to work within a report's <code>src</code>
directory.  For example, for a report <code>analysis</code> they will
alter or report on the directory <code>src/analysis</code>.  It is
intended that <code>orderly_develop_start</code> can be run repeatedly;
doing this will <em>refresh</em> the contents of the directory if
upstream files have been updated.
</p>
<p>Some degree of care should be used while using these functions.
</p>
<p>Because <code>orderly_develop_start</code> copies files into your source
tree you should be careful to add these files to your
<code>.gitignore</code> files so that they are not included if using
git.  Rerunning <code>orderly_develop_start</code> will copy a fresh
copy of dependencies into your tree, overwriting files that are
there without warning.
</p>
<p>Repeatedly running <code>orderly_develop_start</code> is &quot;safe&quot;, in that
it will re-run through the setup steps, but beware that sourcing
functions is additive and never subtractive.  If you delete (or
rename) a function within a source file, it will not be removed
from your global environment.  Similarly, environment variables
will be loaded each time you call this, but no deletions will
happen.  When in doubt, restart your R session.
</p>
<p>Note that these functions are much more permissive as to the state
of your <code>orderly.yml</code> than <code><a href="#topic+orderly_run">orderly_run()</a></code> - in
particular, they will run, with a message, even if you have not
yet defined a <code style="white-space: pre;">&#8288;script:&#8288;</code> or any <code style="white-space: pre;">&#8288;artefacts:&#8288;</code>.
</p>
<p>The <code>orderly_develop_clean</code> function will delete dependencies
without warning.
</p>


<h3>Value</h3>

<p>A character vector with the full path to the directory,
invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- orderly::orderly_example("demo")

# This report uses a dependency - it requires that the file
# incoming.csv exists.  This file is created from the report 'other'
orderly::orderly_develop_status("use_dependency", root = path)

# Copy the required dependencies over, in this case from a draft report
orderly::orderly_run("other", list(nmin = 0), root = path, echo = FALSE)
orderly::orderly_develop_start("use_dependency", root = path,
                               use_draft = TRUE)

# Files have been copied across into the source directory
orderly::orderly_develop_status("use_dependency", root = path)

# The report can then be developed as needed, interactively.  After
# we're happy things can be cleaned up with
orderly::orderly_develop_clean("use_dependency", root = path)

</code></pre>

<hr>
<h2 id='orderly_example'>Set up an orderly example</h2><span id='topic+orderly_example'></span>

<h3>Description</h3>

<p>Set up one of the orderly examples included with the package.
These are not intended to be starting points for new orderly
repositories, but are used in the package examples and vignettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_example(
  name,
  path = tempfile(),
  run_demo = FALSE,
  quiet = FALSE,
  git = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_example_+3A_name">name</code></td>
<td>
<p>Name of the example</p>
</td></tr>
<tr><td><code id="orderly_example_+3A_path">path</code></td>
<td>
<p>Destination to create the example - if it exists
already it must be an empty directory.  By default, creates a
new temporary directory</p>
</td></tr>
<tr><td><code id="orderly_example_+3A_run_demo">run_demo</code></td>
<td>
<p>Logical, indicating if the example is configured
as a &quot;demo&quot; (i.e., with a set of reports to be run and
committed), should these be run?</p>
</td></tr>
<tr><td><code id="orderly_example_+3A_quiet">quiet</code></td>
<td>
<p>Logical, indicating if informational messages should
be suppressed when running the demo.</p>
</td></tr>
<tr><td><code id="orderly_example_+3A_git">git</code></td>
<td>
<p>Logical, indicating if we should create an basic git
repository along with the demo. This will have the default
orderly .gitignore set up, and a remote which is itself (so that
git pull and git fetch run without error, though they will do
nothing).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the path to the orderly example
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a new copy of the "minimal" example
path &lt;- orderly::orderly_example("minimal")
dir(path)

# Example reports within this repository:
orderly::orderly_list(path)
</code></pre>

<hr>
<h2 id='orderly_graph'>Print the dependency tree for a given report using orderly log</h2><span id='topic+orderly_graph'></span>

<h3>Description</h3>

<p>Investigate the dependency structure in a set of orderly reports.
This function allows the dependency graph to be created for set of
reports that have been run and committed (the archive) or of a set
of reports that could be run (the src) to be discovered and
printed to screen.  <em>This is experimental and somewhat subject to
change and improvement.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_graph(
  name,
  id = "latest",
  root = NULL,
  locate = TRUE,
  direction = "downstream",
  propagate = TRUE,
  max_depth = Inf,
  recursion_limit = 100,
  show_all = FALSE,
  use = "archive"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_graph_+3A_name">name</code></td>
<td>
<p>the name of the report</p>
</td></tr>
<tr><td><code id="orderly_graph_+3A_id">id</code></td>
<td>
<p>the id of the report, if omitted, use the id of the
latest report</p>
</td></tr>
<tr><td><code id="orderly_graph_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_graph_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_graph_+3A_direction">direction</code></td>
<td>
<p>A string indicating if we want to move up or down
the tree permitted values are upstream, downstream</p>
</td></tr>
<tr><td><code id="orderly_graph_+3A_propagate">propagate</code></td>
<td>
<p>A boolean indicating if we want to propagate out
of date through the tree</p>
</td></tr>
<tr><td><code id="orderly_graph_+3A_max_depth">max_depth</code></td>
<td>
<p>A numeric, how far back should the tree go, this
can be useful to truncate a very large tree. (default = Inf)</p>
</td></tr>
<tr><td><code id="orderly_graph_+3A_recursion_limit">recursion_limit</code></td>
<td>
<p>A numeric, limit for depth of tree, if the tree
goes beyond this then an error is thrown. (default = 100)</p>
</td></tr>
<tr><td><code id="orderly_graph_+3A_show_all">show_all</code></td>
<td>
<p>A boolean, should we show all reports in the tree,
not just the latest.</p>
</td></tr>
<tr><td><code id="orderly_graph_+3A_use">use</code></td>
<td>
<p>Character string indicating what we read to infer the
dependency tree.  Current valid values are <code>archive</code> (the
default), which reads from archive reports and <code>src</code> which
reads from the source reports.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>orderly allows a report to rely on the artefacts of one or more
other orderly reports. This allows users to develop a network of
interconnected reports where the output from report becomes the
source of data for another.  There are two natural questions that
can develop around this workflow:
</p>

<ol>
<li><p> We have updated a report; what are the reports that depend on
this so that we can re-run them?
</p>
</li>
<li><p> We have a report that we want to re-run to ensure uses the
latest information. Which other reports are used (directly or
indirectly) by this report?
</p>
</li></ol>

<p>This function displays this information in an easily readable
format.  Allowing users to see the dependency tree and which
reports are out of date and need to be re-run.
</p>


<h3>Value</h3>

<p>An orderly tree object with the root corresponding to the given
report.
</p>


<h3>Remark</h3>

<p>By default the tree is built using data from the local report
database (see <a href="#topic+orderly_commit">orderly_commit</a>,
<a href="#topic+orderly_db">orderly_db</a>). This means that it will not find changes
from a report that has not be run and committed. That is, if a
user changes a report to use or create different artefacts this
will not be picked up by the function until the reports are
re-run and committed to the archive.
</p>
<p>It is possible to generate a tree from the source reports by using
<code>use = "src"</code> - this generates the &quot;theoretical tree&quot;, and has
no concept of being &quot;up to date&quot; or of ids.
</p>


<h3>Warning</h3>

<p><em>This interface is considered experimental and may change without
notice</em>.  Please do not depend on it in scripts as it may break
things.  Consider this a (hopefully) useful way of exploring the
dependencies in your reports <em>interactively</em> - let us know what
is missing and we'll try and build it out.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- orderly::orderly_example("demo")

id &lt;- orderly::orderly_run("other", root = path, parameters=list(nmin=0))
orderly::orderly_commit(id, root = path)
id &lt;- orderly::orderly_run("use_dependency", root = path)
orderly::orderly_commit(id, root = path)
id &lt;- orderly::orderly_run("use_dependency_2", root = path)
orderly::orderly_commit(id, root = path)
orderly::orderly_graph("other", root = path)
orderly::orderly_graph("use_dependency_2", root = path,
                                 direction = "upstream")
</code></pre>

<hr>
<h2 id='orderly_graph_out_of_date'>Given a tree return a list of reports to be re-run (and the order
that they should be re-run)</h2><span id='topic+orderly_graph_out_of_date'></span>

<h3>Description</h3>

<p>Given a tree return a list of reports to be re-run (and the order
that they should be re-run)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_graph_out_of_date(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_graph_out_of_date_+3A_tree">tree</code></td>
<td>
<p>A dependency tree object from orderly_graph_out_of_date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of report names to be re-run. First report to rerun first
</p>

<hr>
<h2 id='orderly_info'>Return info about a report which has been run</h2><span id='topic+orderly_info'></span>

<h3>Description</h3>

<p>This will return info from either successful or failed reports. It will
look for the report with <code>id</code> in archive first and then look in drafts
if it can't be found from archive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_info(id, name, root = NULL, locate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_info_+3A_id">id</code></td>
<td>
<p>The report ID</p>
</td></tr>
<tr><td><code id="orderly_info_+3A_name">name</code></td>
<td>
<p>The name of the report</p>
</td></tr>
<tr><td><code id="orderly_info_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_info_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Info from report run - this is subject to change. Returns a list
which includes report id, name, indication of success, run date and
elapsed time, parameters, git info (if available), path to logfile
(if exists) and details of error if the run failed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- orderly::orderly_example("demo")
id &lt;- orderly::orderly_run("minimal", root = path)
orderly::orderly_info(id, "minimal", root = path)
</code></pre>

<hr>
<h2 id='orderly_init'>Initialise an orderly store</h2><span id='topic+orderly_init'></span>

<h3>Description</h3>

<p>Initialise an orderly store.  This is a helper function that
automates getting started with using orderly for a new project.
It is not required to use - you can create the orderly structure
yourself (all that is compulsory is the <code>orderly_config.yml</code>
file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_init(root, doc = TRUE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_init_+3A_root">root</code></td>
<td>
<p>The root of the store; this must be an empty directory
or the path of a directory to create</p>
</td></tr>
<tr><td><code id="orderly_init_+3A_doc">doc</code></td>
<td>
<p>Logical, indicating if documentation should be added to
the directories.  This also has the (potentially useful) effect
of making these directories noticeable by git.</p>
</td></tr>
<tr><td><code id="orderly_init_+3A_quiet">quiet</code></td>
<td>
<p>Logical, indicating if informational messages should
be suppressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a minimal orderly structure, containing:
</p>

<ul>
<li> <p><code>orderly_config.yml</code>: The orderly configuration. Minimally, this
can be empty, but it must exist.
</p>
</li>
<li> <p><code>src</code>: The path where report sources live. This should be placed
under version control, and contain a number of reports, each in
their own directory with an <code>orderly.yml</code> describing their
inputs and outputs (artefacts).  The <code><a href="#topic+orderly_new">orderly_new()</a></code>
function can be used to accelerate creation of new reports.
</p>
</li>
<li> <p><code>draft</code>: A directory where reports will be run using
<code><a href="#topic+orderly_run">orderly_run()</a></code>.  This directory should be excluded
from version control. <code>orderly</code> will create it as needed if
it does not exist when a report is run.
</p>
</li>
<li> <p><code>archive</code>: A directory where successfully run reports will be
moved to after being committed with <code><a href="#topic+orderly_commit">orderly_commit()</a></code>.
This directory should be excluded from version
control. <code>orderly</code> will create it as needed if it does not
exist when a report is committed.
</p>
</li>
<li> <p><code>data</code>: A directory where data extracted from the database (if
used) will be stored.  This directory should be excluded from
version control. <code>orderly</code> will create it as needed if it
does not exist when a report is run.
</p>
</li></ul>



<h3>Value</h3>

<p>The path to the newly created archive
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderly_new">orderly_new()</a></code> for creating new reports within
a configured orderly repository.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Initialise a new orderly repository in an temporary directory:
path &lt;- orderly::orderly_init(tempfile())

# This has created the directory skeleton that you need to get
# started using orderly:
fs::dir_tree(path)

# As instructed, the next thing to do is to edit the
# orderly_config.yml file to match your needs:
readLines(file.path(path, "orderly_config.yml"))
</code></pre>

<hr>
<h2 id='orderly_latest'>Find most recent report</h2><span id='topic+orderly_latest'></span>

<h3>Description</h3>

<p>Find most recent version of an orderly report.  The most recent
report is always the most recently run report that has been
committed (regardless of the order in which they were committed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_latest(
  name = NULL,
  root = NULL,
  locate = TRUE,
  draft = FALSE,
  must_work = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_latest_+3A_name">name</code></td>
<td>
<p>Name of the report to find; if <code>NULL</code> returns the
most recent report across all names</p>
</td></tr>
<tr><td><code id="orderly_latest_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_latest_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_latest_+3A_draft">draft</code></td>
<td>
<p>Should draft reports be used searched? Valid values
are logical (<code>TRUE</code>, <code>FALSE</code>) or use the string
<code>newer</code> to use draft reports where they are newer than
archive reports. For consistency, <code>always</code> and <code>never</code>
are equivalent to <code>TRUE</code> and <code>FALSE</code>, respectively.</p>
</td></tr>
<tr><td><code id="orderly_latest_+3A_must_work">must_work</code></td>
<td>
<p>Throw an error if no report is found.  If <code>FALSE</code>,
returns <code>NA_character_</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with the id of the most recent report
</p>


<h3>See Also</h3>

<p><a href="#topic+orderly_list">orderly_list</a> and
<a href="#topic+orderly_list_archive">orderly_list_archive</a> for listing report names and
versions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- orderly::orderly_example("minimal")
id1 &lt;- orderly::orderly_run("example", root = path, echo = FALSE)
id2 &lt;- orderly::orderly_run("example", root = path, echo = FALSE)

# With no reports committed there is no latest report:
orderly::orderly_latest("example", root = path, must_work = FALSE)

# Commit the first report and it will be reported as latest:
orderly::orderly_commit(id1, root = path)
orderly::orderly_latest("example", root = path)

# Commit the second report and it will be reported as latest instead:
orderly::orderly_commit(id2, root = path)
orderly::orderly_latest("example", root = path)
</code></pre>

<hr>
<h2 id='orderly_list'>List orderly reports</h2><span id='topic+orderly_list'></span>

<h3>Description</h3>

<p>List the <em>names</em> of reports known to orderly.  These are the
<em>source</em> names, not the results of running reports.  Note
that if a report has been committed from a different branch it
will not appear here, as this is simply the set of reports in the
<code>src</code> directory that can be run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_list(root = NULL, locate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_list_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_list_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of report names
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderly_list_archive">orderly_list_archive()</a></code> and
<code><a href="#topic+orderly_list_drafts">orderly_list_drafts()</a></code>, which list archived
(committed) and draft reports and their versions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The orderly demo, with lots of potential reports:
path &lt;- orderly::orderly_example("demo")

# Reports that _could_ be run:
orderly::orderly_list(path)
</code></pre>

<hr>
<h2 id='orderly_list_drafts'>List draft and archived reports</h2><span id='topic+orderly_list_drafts'></span><span id='topic+orderly_list_archive'></span>

<h3>Description</h3>

<p>List draft and archived reports.  This returns a data.frame with
columns <code>name</code> (see <code><a href="#topic+orderly_list">orderly_list()</a></code>) and <code>id</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_list_drafts(root = NULL, locate = TRUE, include_failed = FALSE)

orderly_list_archive(root = NULL, locate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_list_drafts_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_list_drafts_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_list_drafts_+3A_include_failed">include_failed</code></td>
<td>
<p>Logical, indicating if failed drafts should
be listed (only has an effect for <code>orderly_list_drafts</code> as
no failed run should make it into the archive).  A failed report
is one that lacks an <code>orderly_run.rds</code> file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns <code>name</code> and
<code>id</code>, containing character vectors of report names and
versions, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderly_list">orderly_list()</a></code>, which lists the names of
source reports that can be run, and <code><a href="#topic+orderly_latest">orderly_latest()</a></code>
which returns the id of the most recent report.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The orderly demo, with lots of potential reports:
path &lt;- orderly::orderly_example("demo")

# Reports that _could_ be run:
orderly::orderly_list(path)

# Run a report twice:
id1 &lt;- orderly::orderly_run("minimal", root = path)
id2 &lt;- orderly::orderly_run("minimal", root = path)

# We can see both drafts:
orderly::orderly_list_drafts(path)

# Nothing is in the archive:
orderly::orderly_list_archive(path)

# Commit a report:
orderly::orderly_commit(id2, root = path)

# Only one draft now
orderly::orderly_list_drafts(path)

# And the second report is in the archive:
orderly::orderly_list_archive(path)
</code></pre>

<hr>
<h2 id='orderly_list_metadata'>List reports with only local metadata</h2><span id='topic+orderly_list_metadata'></span>

<h3>Description</h3>

<p>List reports that are present only as metadata; these are the
result of doing <code><a href="#topic+orderly_pull_archive">orderly_pull_archive()</a></code> with
<code>recursive = FALSE</code>, in which case only metadata was
downloaded and not the report contents itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_list_metadata(root = NULL, locate = FALSE, include_archive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_list_metadata_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_list_metadata_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_list_metadata_+3A_include_archive">include_archive</code></td>
<td>
<p>Logical, indicating if we should include
reports that are also included in the archive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame()</a></code> with columns <code>name</code> and
<code>id</code>, as for <code><a href="#topic+orderly_list_archive">orderly_list_archive()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- orderly::orderly_example("minimal")
# No metadata-only reports will be present, unless you have run
# orderly::orderly_pull_archive(..., recursive = FALSE)
orderly::orderly_list_metadata(path)
</code></pre>

<hr>
<h2 id='orderly_log_on'>Orderly logging and diagnostic messages</h2><span id='topic+orderly_log_on'></span><span id='topic+orderly_log_off'></span><span id='topic+orderly_log'></span>

<h3>Description</h3>

<p>Start and stop the orderly log.  When active, some actions will
print diagnostic information to the message stream.  This is set
to be on by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_log_on()

orderly_log_off()

orderly_log(topic, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_log_on_+3A_topic">topic</code></td>
<td>
<p>Up to 9 character text string with the log topic</p>
</td></tr>
<tr><td><code id="orderly_log_on_+3A_value">value</code></td>
<td>
<p>Character string with the log entry</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>orderly_log</code> is designed to be used from
applications that extend orderly, while the functions
<code>orderly_log_on</code> and <code>orderly_log_off</code> can be used by
applications or users to enable and disable log messages.
</p>
<p>The interface here may expand by adding arguments or change
behaviour based on global options. Future versions may support
logging to a file, or adding timestamps, or logging in json
format, etc.
</p>


<h3>Value</h3>

<p><code>orderly_log_on</code> and <code>orderly_log_off</code> invisibly
returns a logical indicating if logging was previously enabled.
This allows patterns like:</p>
<pre>if (!orderly::orderly_log_off()) {
  on.exit(orderly::orderly_log_on())
}
</pre>
<p>to disable logging within a function (the <code>on.exit</code> block
will be run when the function exits).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderly_run">orderly_run()</a></code>, which makes use of these log
messages
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We are going to log things below
logging_was_enabled &lt;- orderly::orderly_log_on()

# About orderly log messages:
# Orderly log messages have the form "[title] message"
orderly::orderly_log_on()
orderly::orderly_log("title", "message")

# If logging is disabled they are not printed:
orderly::orderly_log_off()
orderly::orderly_log("title", "message")

# Restore to previous settings:
if (logging_was_enabled) {
  orderly::orderly_log_on()
}
</code></pre>

<hr>
<h2 id='orderly_migrate'>Migrate an orderly archive</h2><span id='topic+orderly_migrate'></span>

<h3>Description</h3>

<p>Migrate an orderly archive.  This is needed periodically when the
orderly archive version changes.  If you get a message like
<code style="white-space: pre;">&#8288;orderly archive needs migrating from a.b.c =&gt; x.y.z&#8288;</code> then
you need to run this function.  The archive version is at most
equal to the package version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_migrate(
  root = NULL,
  locate = TRUE,
  to = NULL,
  dry_run = FALSE,
  skip_failed = FALSE,
  clean = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_migrate_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_migrate_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_migrate_+3A_to">to</code></td>
<td>
<p>The version to migrate to.  The default is the current
archive version; this is almost always what is wanted.</p>
</td></tr>
<tr><td><code id="orderly_migrate_+3A_dry_run">dry_run</code></td>
<td>
<p>Logical, indicating if we should try running the
migration but not actually applying it.  This is intended
primarily for developing new migrations and will probably not
work if you are multiple archive versions behind.</p>
</td></tr>
<tr><td><code id="orderly_migrate_+3A_skip_failed">skip_failed</code></td>
<td>
<p>Logical, where <code>TRUE</code> we will skip over
entries that failed to be migrated.  This is expected to be
useful on local archives only because it violates the
append-only nature of orderly.  However, if a local archive
contains unusual copies of orderly archives that can't be
migrated this might come in helpful.</p>
</td></tr>
<tr><td><code id="orderly_migrate_+3A_clean">clean</code></td>
<td>
<p>Logical, where <code>TRUE</code> (and where the migration
was successful and <code>dry_run</code> is <code>FALSE</code>) orderly will
clean up all migration backup files.  Use this periodically to
clean up the archive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes we add change information saved out in the orderly run.
This requires patching previously run versions of the orderly
metadata and that's not something we want to do lightly.  This
function uses a relatively safe, and reversible, way of migrating
metadata.  We modify the <code>orderly_run.rds</code> files, but will
create versioned backups as files are changed.
</p>


<h3>Value</h3>

<p>No return value, this function is called only for its side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Without an orderly repository created by a previous version of
# orderly, this function does nothing interesting:
path &lt;- orderly::orderly_example("minimal")
orderly::orderly_migrate(path)
</code></pre>

<hr>
<h2 id='orderly_new'>Create new report</h2><span id='topic+orderly_new'></span>

<h3>Description</h3>

<p>Create new report, starting from a template.  Orderly comes with a
set of templates, but projects can bring their own templates; see
Details below for how these are configured and discovered by
orderly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_new(name, root = NULL, locate = TRUE, quiet = FALSE, template = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_new_+3A_name">name</code></td>
<td>
<p>Name of the new report (will be a directory name).</p>
</td></tr>
<tr><td><code id="orderly_new_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_new_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_new_+3A_quiet">quiet</code></td>
<td>
<p>Logical, indicating if informational messages should
be suppressed.</p>
</td></tr>
<tr><td><code id="orderly_new_+3A_template">template</code></td>
<td>
<p>The name of a template.  If <code>NULL</code> orderly
will search for a template (see Details).  If given it must be
the name of a directory within a directory <code>templates</code> in
your project root.  The special label &quot;orderly&quot; will use
orderly's builtin template.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To create a custom template, create a directory <code>templates</code>
within your orderly root.  Within that directory create
directories containing all the files that you would like a report
to contain.  This <em>must</em> contain a file
<code>orderly.yml</code> but may contain further files (for example, you
might want a default script and Rmd file).
</p>
<p>If <code>template</code> is not given (i.e., is <code>NULL</code>) then we
look for a template called <code>default</code> (i.e., stored at
<code>template/default</code>), then fall back on the system orderly
template.
</p>
<p>We first look for a file <code>orderly/template.yml</code> within the
orderly root.  If that is not found, then a copy from the orderly
package is used.  This can always be used by using <code>template = "system"</code>.
</p>


<h3>Value</h3>

<p>The path of the new source directory, invisibly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderly_init">orderly_init()</a></code> for initialising a new orderly
repository.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- orderly::orderly_example("minimal")

# Create a new report with the name "myreport" in this orderly
# repository:
orderly::orderly_new("myreport", root = path)

# The directory will be initialised with a orderly.yml file
# containing documentation
dir(file.path(path, "src", "myreport"))
readLines(file.path(path, "src", "myreport", "orderly.yml"))
</code></pre>

<hr>
<h2 id='orderly_pull_dependencies'>Download dependent reports</h2><span id='topic+orderly_pull_dependencies'></span><span id='topic+orderly_pull_archive'></span><span id='topic+orderly_push_archive'></span>

<h3>Description</h3>

<p>Download dependent reports from an orderly remote.  This can only
be used if the <code>orderly_config.yml</code> lists a remote.  This
allows for a centralised workflow where a central orderly store
exists and holds the canonical copies of reports, from which
versions can be downloaded into local stores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_pull_dependencies(
  name = NULL,
  root = NULL,
  locate = TRUE,
  remote = NULL,
  parameters = NULL,
  recursive = TRUE
)

orderly_pull_archive(
  name,
  id = "latest",
  root = NULL,
  locate = TRUE,
  remote = NULL,
  parameters = NULL,
  recursive = TRUE
)

orderly_push_archive(
  name,
  id = "latest",
  root = NULL,
  locate = TRUE,
  remote = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_pull_dependencies_+3A_name">name</code></td>
<td>
<p>Name of the report to download dependencies for.
Alternatively, the default of <code>NULL</code> is useful if you have
already set the working directory to be the source directory.</p>
</td></tr>
<tr><td><code id="orderly_pull_dependencies_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_pull_dependencies_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_pull_dependencies_+3A_remote">remote</code></td>
<td>
<p>Description of the location.  Typically this is a
character string indicating a remote specified in the
<code>remotes</code> block of your <code>orderly_config.yml</code>.  It is
also possible to pass in a directly created remote object (e.g.,
using <code><a href="#topic+orderly_remote_path">orderly_remote_path()</a></code>, or one provided by
another package).  If left <code>NULL</code>, then the default remote
for this orderly repository is used - by default that is the
first listed remote.</p>
</td></tr>
<tr><td><code id="orderly_pull_dependencies_+3A_parameters">parameters</code></td>
<td>
<p>Parameters to pass through when doing dependency
resolution.  If you are using a query for <code>id</code> that
involves a parameter (e.g., <code>latest(parameter:x == p)</code>) you
will need to pass in the parameters here.  Similarly, if you are
pulling a report that uses query dependencies that reference
parameters you need to pass them here (the same parameter set
will be passed through to all dependencies).</p>
</td></tr>
<tr><td><code id="orderly_pull_dependencies_+3A_recursive">recursive</code></td>
<td>
<p>Logical, indicating if all dependencies of a
report should also be pulled. Setting this to <code>FALSE</code> only
the direct reports, along with metadata for the dependencies;
this will be potentially much faster, but leaves your archive in
a more fragile state.</p>
</td></tr>
<tr><td><code id="orderly_pull_dependencies_+3A_id">id</code></td>
<td>
<p>The identifier (for <code>orderly_pull_archive</code>).  The default is
to use the latest report.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>orderly_pull_archive</code> function pulls report directly
(without it being a dependent report).
</p>
<p>After setting your username up you can run
<code>orderly_pull_dependencies("reportname")</code> to pull the
<em>dependencies</em> of <code>"reportname"</code> down so that
<code>"reportname"</code> can be run, or you can run
<code>orderly_pull_archive("reportname")</code> to pull a copy of
<code>"reportname"</code> that has been run on the remote server.
</p>
<p>Pulling an archive report from a remote also pulls its
dependencies (recursively), and adds all of these to the local
database.  This may require migrating old orderly archives
(<code><a href="#topic+orderly_migrate">orderly_migrate()</a></code>).  Note that this migration will
likely fail for remote orderly versions older than 0.6.8 because
the migration needs to read data files on disk that are not
included in the downloaded archive in order to collect all the
information required for the database.  In this case, ask the
administrator of the remote orderly archive to migrate their
archive, and then re-pull.
</p>
<p>Pushing an archive is possible only if the remote supports it.
Currently this is supported by <code><a href="#topic+orderly_remote_path">orderly_remote_path()</a></code>
remotes, though not by orderlyweb remotes.  There is no control
over what will <em>accept</em> a push at this point, nor any check
that what you've pushed is &quot;good&quot; except that it exists in your
archive.  As with pulling an archive, pushes are recursive with
respect to dependencies.  The configuration interface here will
likely change a little over time.
</p>


<h3>Value</h3>

<p>No return value, these functions are called only for their
side effects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderly_remote_path">orderly_remote_path()</a></code>, which implements the
remote interface for orderly repositories at a local path.  See
also <a href="https://github.com/vimc/orderly-web">OrderlyWeb</a> for a
system for hosting orderly repositories over an HTTP API.
<code>vignette("remote", package = "orderly")</code> describes the
remote system in more detail.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Suppose we have a "remote" orderly repository at some path.
# This might be read-only for you in practice and available via a
# network filesystem or a dropbox folder synced to your computer.
# We'll populate this with a pair of reports:
path_remote &lt;- orderly::orderly_example("demo")
id &lt;- orderly::orderly_run("other", list(nmin = 0),
                           root = path_remote, echo = FALSE)
orderly::orderly_commit(id, root = path_remote)
id &lt;- orderly::orderly_run("use_dependency",
                           root = path_remote, echo = FALSE)
orderly::orderly_commit(id, root = path_remote)

# We'll create a an object to interact with this remote using
# orderly_remote_path.
remote &lt;- orderly::orderly_remote_path(path_remote)

# We can use this object directly
remote$list_reports()
remote$list_versions("other")

# More typically one will interact with the functions
# orderly_pull_archive and orderly_pull_dependencies.

# Now, suppose that you have your "local" copy of this; it shares
# the same source (ordinarily these would both be under version
# control with git):
path_local &lt;- orderly::orderly_example("demo")

# If we wanted to run the report "use_dependency" we need to have
# a copy of the report "other", on which it depends:
try(orderly::orderly_run("use_dependency", root = path_local))

# We can "pull" dependencies of a report before running
orderly::orderly_pull_dependencies("use_dependency", remote = remote,
                                   root = path_local)

# Now we can run the report because we have a local copy of the
# dependency:
orderly::orderly_run("use_dependency", root = path_local)

# We can also directly pull previously run reports:
orderly::orderly_pull_archive("use_dependency", id, remote = remote,
                              root = path_local)
orderly::orderly_list_archive(root = path_local)
</code></pre>

<hr>
<h2 id='orderly_rebuild'>Rebuild the report database</h2><span id='topic+orderly_rebuild'></span>

<h3>Description</h3>

<p>Rebuild the report database.  This is necessary when the orderly
database schema changes, and you will be prompted to run this
function after upgrading orderly in that case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_rebuild(
  root = NULL,
  locate = TRUE,
  verbose = TRUE,
  if_schema_changed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_rebuild_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_rebuild_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_rebuild_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating if information about the
rebuild should be printed as it runs</p>
</td></tr>
<tr><td><code id="orderly_rebuild_+3A_if_schema_changed">if_schema_changed</code></td>
<td>
<p>Logical, indicating if the rebuild should
take place only if the schema has changed.  This is designed to
be safe to use in (say) deployment scripts because it will be
fast enough to call regularly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The report database (orderly's &quot;destination&quot; database) is
essentially an index over all the metadata associated with
reports.  It is used by orderly itself, and can be used by
applications that extend orderly (e.g.,
<a href="https://github.com/vimc/orderly-web">OrderlyWeb</a>.  All the
data in this database can be rebuilt from files stored with the
committed (archive) orderly reports, using the
<code>orderly_rebuild</code> function.
</p>


<h3>Value</h3>

<p>No return value, this function is called only for its side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- orderly::orderly_example("minimal")
id &lt;- orderly::orderly_run("example", root = path)
orderly::orderly_commit(id, root = path)

con &lt;- orderly::orderly_db("destination", root = path)
DBI::dbReadTable(con, "report_version")
DBI::dbDisconnect(con)

# The database can be removed and will be rebuilt if requested
# (this is only a good idea if you do not extend the database with
# your own fields - only the fields that orderly looks after can
# be recovered!)
file.remove(file.path(path, "orderly.sqlite"))
orderly::orderly_rebuild(path)
file.exists(file.path(path, "orderly.sqlite"))
con &lt;- orderly::orderly_db("destination", root = path)
DBI::dbReadTable(con, "report_version")
DBI::dbDisconnect(con)

# It is safe to rebuild a database repeatedly, though this can be
# slow with larger databases.
orderly::orderly_rebuild(path)
</code></pre>

<hr>
<h2 id='orderly_remote'>Get a remote</h2><span id='topic+orderly_remote'></span>

<h3>Description</h3>

<p>Get a remote, based on the configuration in
<code>orderly_config.yml</code> - different remote drivers have
different methods, and this function gives you access to these
lower-level objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_remote(remote = NULL, root = NULL, locate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_remote_+3A_remote">remote</code></td>
<td>
<p>Description of the location.  Typically this is a
character string indicating a remote specified in the
<code>remotes</code> block of your <code>orderly_config.yml</code>.  It is
also possible to pass in a directly created remote object (e.g.,
using <code><a href="#topic+orderly_remote_path">orderly_remote_path()</a></code>, or one provided by
another package).  If left <code>NULL</code>, then the default remote
for this orderly repository is used - by default that is the
first listed remote.</p>
</td></tr>
<tr><td><code id="orderly_remote_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_remote_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The orderly remote, as described in
<code>orderly_config.yml</code> - if no remotes are configured, or if
the requested remote does not exist, an error will be thrown.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderly_pull_dependencies">orderly_pull_dependencies()</a></code> which provides a
higher-level interface to pulling from a remote (including
adding the downloaded archive into your orderly repository), and
see the documentation underlying the orderly remote driver that
your <code>orderly_config.yml</code> declares for information about
using that remote.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## We need two orderly repositories here - one as a "local" and one as
## a "remote" (see ?orderly_pull_archive)
path_remote &lt;- orderly::orderly_example("demo")
path_local &lt;- orderly::orderly_example("demo")

## Configure our remote:
path_config &lt;- file.path(path_local, "orderly_config.yml")
txt &lt;- readLines(path_config)
writeLines(c(
  txt,
  "remote:",
  "  default:",
  "    driver: orderly::orderly_remote_path",
  "    args:",
  paste("      path:", path_remote)),
  path_config)

## Get our remote:
remote &lt;- orderly::orderly_remote(root = path_local)

## Can use the remote's methods to interact directly - actual methods
## depend on the remote driver being used.
remote$list_reports()
</code></pre>

<hr>
<h2 id='orderly_remote_path'>Orderly remote at a different path</h2><span id='topic+orderly_remote_path'></span>

<h3>Description</h3>

<p>Create a &quot;handle&quot; for interacting with orderly repositories that
are hosted at a different path.  This might be useful in cases
where you have access to an orderly repository via a network mount
or a synchronised folder (e.g., Dropbox, Box, etc).  More
generally, <code>orderly_remote_path</code> implements an interface
used by orderly to abstract over different ways that orderly
repositories might be hosted remotely, including over HTTP APIs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_remote_path(path, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_remote_path_+3A_path">path</code></td>
<td>
<p>Path to the orderly store</p>
</td></tr>
<tr><td><code id="orderly_remote_path_+3A_name">name</code></td>
<td>
<p>Name of the remote</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>orderly_remote_path</code> object, with methods that
orderly will use in order to control this remote
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderly_pull_dependencies">orderly_pull_dependencies()</a></code> and
<code><a href="#topic+orderly_pull_archive">orderly_pull_archive()</a></code>, which are the primary ways
these remote objects are used.  See also
<a href="https://github.com/vimc/orderly-web">OrderlyWeb</a> for a
system for hosting orderly repositories over an HTTP API.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Suppose we have a "remote" orderly repository at some path.
# This might be read-only for you in practice and available via a
# network filesystem or a dropbox folder synced to your computer.
# We'll populate this with a pair of reports:
path_remote &lt;- orderly::orderly_example("demo")
id &lt;- orderly::orderly_run("other", list(nmin = 0),
                           root = path_remote, echo = FALSE)
orderly::orderly_commit(id, root = path_remote)
id &lt;- orderly::orderly_run("use_dependency",
                           root = path_remote, echo = FALSE)
orderly::orderly_commit(id, root = path_remote)

# We'll create a an object to interact with this remote using
# orderly_remote_path.
remote &lt;- orderly::orderly_remote_path(path_remote)

# We can use this object directly
remote$list_reports()
remote$list_versions("other")

# More typically one will interact with the functions
# orderly_pull_archive and orderly_pull_dependencies.

# Now, suppose that you have your "local" copy of this; it shares
# the same source (ordinarily these would both be under version
# control with git):
path_local &lt;- orderly::orderly_example("demo")

# If we wanted to run the report "use_dependency" we need to have
# a copy of the report "other", on which it depends:
try(orderly::orderly_run("use_dependency", root = path_local))

# We can "pull" dependencies of a report before running
orderly::orderly_pull_dependencies("use_dependency", remote = remote,
                                   root = path_local)

# Now we can run the report because we have a local copy of the
# dependency:
orderly::orderly_run("use_dependency", root = path_local)

# We can also directly pull previously run reports:
orderly::orderly_pull_archive("use_dependency", id, remote = remote,
                              root = path_local)
orderly::orderly_list_archive(root = path_local)
</code></pre>

<hr>
<h2 id='orderly_remote_status'>Get status of remote queue.</h2><span id='topic+orderly_remote_status'></span>

<h3>Description</h3>

<p>Get the status of the remote queue as a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_remote_status(root = NULL, locate = TRUE, remote = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_remote_status_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_remote_status_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_remote_status_+3A_remote">remote</code></td>
<td>
<p>Description of the location.  Typically this is a
character string indicating a remote specified in the
<code>remotes</code> block of your <code>orderly_config.yml</code>.  It is
also possible to pass in a directly created remote object (e.g.,
using <code><a href="#topic+orderly_remote_path">orderly_remote_path()</a></code>, or one provided by
another package).  If left <code>NULL</code>, then the default remote
for this orderly repository is used - by default that is the
first listed remote.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing details of running and queued reports on the
remote queue. Including report name, status and version (where known)
</p>

<hr>
<h2 id='orderly_run'>Run a report</h2><span id='topic+orderly_run'></span>

<h3>Description</h3>

<p>Run a report.  This will create a new directory in
<code style="white-space: pre;">&#8288;drafts/&lt;reportname&gt;&#8288;</code>, copy your declared resources there,
extract data from databases (if you are using them), run your
script and check that all expected artefacts were created.  Once
successfully run you can use <code><a href="#topic+orderly_commit">orderly_commit()</a></code> to move
it to the <code>archive</code> directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_run(
  name = NULL,
  parameters = NULL,
  envir = NULL,
  root = NULL,
  locate = TRUE,
  echo = TRUE,
  message = NULL,
  instance = NULL,
  use_draft = FALSE,
  remote = NULL,
  tags = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_run_+3A_name">name</code></td>
<td>
<p>Name of the report to run (see
<code><a href="#topic+orderly_list">orderly_list()</a></code>).  A leading <code style="white-space: pre;">&#8288;src/&#8288;</code> will be
removed if provided, allowing easier use of autocomplete.
Alternatively, the default of <code>NULL</code> is useful if you have
already set the working directory to be the source directory.</p>
</td></tr>
<tr><td><code id="orderly_run_+3A_parameters">parameters</code></td>
<td>
<p>Parameters passed to the report. A named list of
parameters declared in the <code>orderly.yml</code>.  Each parameter
must be a scalar character, numeric, integer or logical.</p>
</td></tr>
<tr><td><code id="orderly_run_+3A_envir">envir</code></td>
<td>
<p>The parent of the environment that will be used to
evaluate the report script; by default a new environment will be
made with the global environment as the parent.</p>
</td></tr>
<tr><td><code id="orderly_run_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_run_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_run_+3A_echo">echo</code></td>
<td>
<p>Print the result of running the R code to the console</p>
</td></tr>
<tr><td><code id="orderly_run_+3A_message">message</code></td>
<td>
<p>An optional character string containing a message
explaining why the report was run</p>
</td></tr>
<tr><td><code id="orderly_run_+3A_instance">instance</code></td>
<td>
<p>Select instance of the source database to be used,
where multiple instances are configured.  Use a single
<em>unnamed</em> character string to indicate an instance to
match.  If given, then this name must be present in all
databases where instances are listed in
<code>orderly_config.yml</code>, and will be ignored by all database
where instances are not given.  See the &quot;orderly&quot; vignette for
further information.</p>
</td></tr>
<tr><td><code id="orderly_run_+3A_use_draft">use_draft</code></td>
<td>
<p>Should draft reports be used for dependencies?
This should be used only in development.  Valid values are
logical (<code>TRUE</code>, <code>FALSE</code>) or use the string
<code>newer</code> to use draft reports where they are newer than
archive reports.  For consistency, <code>always</code> and
<code>never</code> are equivalent to <code>TRUE</code> and <code>FALSE</code>,
respectively.</p>
</td></tr>
<tr><td><code id="orderly_run_+3A_remote">remote</code></td>
<td>
<p>Remote to use to resolve dependencies.  Use this in
order to run a report with the same dependencies as are
available on a remote server, particularly when using <code>id = "latest"</code>.  Note that this is not the same as running
<code><a href="#topic+orderly_pull_dependencies">orderly_pull_dependencies()</a></code>, then <code>orderly_run</code>
with <code>remote = NULL</code>, as the pull/run approach will use the
latest report in <em>your</em> archive but the <code>remote = "remote"</code> approach will use the latest approach in the
<em>remote</em> archive (which might be less recent).</p>
</td></tr>
<tr><td><code id="orderly_run_+3A_tags">tags</code></td>
<td>
<p>Character vector of tags to add to the report.  Tags
are immutable and cannot be removed once the report is run.
Tags added here will be <em>in addition</em> to any tags listed in
the <code style="white-space: pre;">&#8288;tags:&#8288;</code> field in <code>orderly.yml</code> and must be present
in <code>orderly_config.yml</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters are passed to the report as a named list, for example</p>
<pre>id &lt;- orderly::orderly_run("other", list(nmin = 0.2), root = path)
</pre>
<p>(see the examples).  The names of the parameters (here,
<code>nmin</code>) must correspond to declared parameters in the
<code>orderly.yml</code>.  It is an error if parameters without a
default are omitted, and it is an error if unknown parameters are
provided.
</p>
<p>Environment variables that are created in <code>orderly_envir.yml</code>
will be available while the report runs.  Those that begin with
<code>ORDERLY_</code> will be saved into the <code>orderly_run.rds</code>
within the <code style="white-space: pre;">&#8288;$env&#8288;</code> section (except for any that match the
patterns &quot;TOKEN&quot;, &quot;PAT&quot; or &quot;PASS&quot;).
</p>


<h3>Value</h3>

<p>The id of the newly created report
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderly_log">orderly_log()</a></code> for controlling display of log
messages (not just R output)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- orderly::orderly_example("demo")

# To run most reports, provide the report name (and the path if
# not running in the working directory, as is the case here):
id &lt;- orderly::orderly_run("minimal", root = path)

# Every report gets a unique identifier, based on the time (it is
# ISO 8601 time with random hex appended to end)
id

# After being run, a report is a "draft" and will exist in the
# drafts directory:
orderly::orderly_list_drafts(root = path)

# Draft reports are always stored in the path
# &lt;root&gt;/draft/&lt;name&gt;/&lt;id&gt;, so we have
dir(file.path(path, "draft", "minimal", id))

# which contains the files when the report was run.

# If a report has parameters, then these must be passed in as a
# named list.
id &lt;- orderly::orderly_run("other", list(nmin = 0.2), root = path)

# These parameters can be used in SQL queries or in the report
# code.
</code></pre>

<hr>
<h2 id='orderly_run_info'>Information on current orderly run</h2><span id='topic+orderly_run_info'></span>

<h3>Description</h3>

<p>This function allows inspection of some of orderly's metadata
during an orderly run.  The format returned is internal to orderly
and subject to change.  It is designed to be used within report
code.  To use in conjunction with
<code><a href="#topic+orderly_test_start">orderly_test_start()</a></code>, you must pass in the path to the
report in question.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_run_info(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_run_info_+3A_path">path</code></td>
<td>
<p>Path to the report currently being run.  This should
be left as <code>NULL</code> when running a report, and the path to
the report being run should be used when using
<code><a href="#topic+orderly_test_start">orderly_test_start()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of metadata about the current report
</p>


<h3>Warning</h3>

<p>It is important that this data is treated as <em>readonly</em>!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- orderly::orderly_example("demo")

# This example uses orderly_run_info within its script, saving the
# output to "output.rds"
readLines(file.path(path, "src", "use_dependency", "script.R"))

# Run the dependency:
id &lt;- orderly::orderly_run("other", list(nmin = 0), root = path)
orderly::orderly_commit(id, root = path)

# Then the report
id &lt;- orderly::orderly_run("use_dependency", root = path)

# This is the contents:
readRDS(file.path(path, "draft", "use_dependency", id, "info.rds"))
</code></pre>

<hr>
<h2 id='orderly_run_remote'>Run a report on a remote server</h2><span id='topic+orderly_run_remote'></span>

<h3>Description</h3>

<p>Run a report on a remote server.  Note that this is only supported
for remotes using OrderlyWeb at present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_run_remote(
  name,
  parameters = NULL,
  ref = NULL,
  timeout = NULL,
  wait = 3600,
  poll = 1,
  open = TRUE,
  stop_on_error = TRUE,
  stop_on_timeout = TRUE,
  progress = TRUE,
  root = NULL,
  locate = TRUE,
  instance = NULL,
  remote = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_run_remote_+3A_name">name</code></td>
<td>
<p>Name of the report</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_parameters">parameters</code></td>
<td>
<p>Parameters for the report</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_ref">ref</code></td>
<td>
<p>Optional reference, indicating which branch should be
used.  This cannot be used if the remote has <code>master_only</code>
set.</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_timeout">timeout</code></td>
<td>
<p>Time to tell the server to wait before killing the
report.</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_wait">wait</code></td>
<td>
<p>Time to wait for the report to be run; if the report
takes longer than this time to run but <code>timeout</code> is longer
it will remain running on the server but we will stop waiting
for it and instead throw an error.</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_poll">poll</code></td>
<td>
<p>Period to poll the server for results (in seconds)</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_open">open</code></td>
<td>
<p>Logical, indicating if the report should be opened in
a browser on completion (if supported by the remote)</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_stop_on_error">stop_on_error</code></td>
<td>
<p>Logical, indicating if we should throw an
error if the report fails.  If you set this to <code>FALSE</code> it
will be much easier to debug, but more annoying in scripts.  If
the report times out on the server (i.e., takes longer than
<code>timeout</code>) that counts as an error.</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_stop_on_timeout">stop_on_timeout</code></td>
<td>
<p>Logical, indicating if we should throw an
error if the report takes longer than <code>wait</code> seconds to
complete.</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_progress">progress</code></td>
<td>
<p>Logical, indicating if a progress spinner should
be included.</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_instance">instance</code></td>
<td>
<p>Select instance of the source database to be used,
where multiple instances are configured. Use a single unnamed
character string to indicate an instance to match. Will use
default if NULL.</p>
</td></tr>
<tr><td><code id="orderly_run_remote_+3A_remote">remote</code></td>
<td>
<p>Description of the location.  Typically this is a
character string indicating a remote specified in the
<code>remotes</code> block of your <code>orderly_config.yml</code>.  It is
also possible to pass in a directly created remote object (e.g.,
using <code><a href="#topic+orderly_remote_path">orderly_remote_path()</a></code>, or one provided by
another package).  If left <code>NULL</code>, then the default remote
for this orderly repository is used - by default that is the
first listed remote.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, this function is called only for its side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path_remote &lt;- orderly::orderly_example("demo")
path_local &lt;- orderly::orderly_example("demo")
remote &lt;- orderly::orderly_remote_path(path_remote)
# Currently, path remotes don't support run
try(orderly::orderly_run_remote(
  "minimal", remote = remote, root = path_local))
</code></pre>

<hr>
<h2 id='orderly_search'>Search for orderly reports matching criteria</h2><span id='topic+orderly_search'></span>

<h3>Description</h3>

<p>Search for orderly reports matching criteria.  This can be used to
find reports where a particular parameter or tag was used (it will
likely be expanded as time goes on - let us know if that would be
useful).  We search within versions of a single report only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_search(
  query,
  name,
  parameters = NULL,
  draft = FALSE,
  root = NULL,
  locate = TRUE,
  remote = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_search_+3A_query">query</code></td>
<td>
<p>The query string - see details and examples</p>
</td></tr>
<tr><td><code id="orderly_search_+3A_name">name</code></td>
<td>
<p>Name of the report to search.  Only a single report
can be searched at once.</p>
</td></tr>
<tr><td><code id="orderly_search_+3A_parameters">parameters</code></td>
<td>
<p>Named list of parameters (as would be passed to
<code><a href="#topic+orderly_run">orderly_run()</a></code>) if your query uses parameters on the
right-hand-side of an expression.</p>
</td></tr>
<tr><td><code id="orderly_search_+3A_draft">draft</code></td>
<td>
<p>Should draft reports be used searched?  This should
be used only in development.  Valid values are logical
(<code>TRUE</code>, <code>FALSE</code>) or use the string <code>newer</code> to
use draft reports where they are newer than archive reports.
For consistency, <code>always</code> and <code>never</code> are equivalent
to <code>TRUE</code> and <code>FALSE</code>, respectively.</p>
</td></tr>
<tr><td><code id="orderly_search_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_search_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_search_+3A_remote">remote</code></td>
<td>
<p>A remote to use, if you want to apply the query
remotely.  If this is used then <code>draft</code> cannot be set to
<code>TRUE</code> as remotes do not expose draft reports.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The query syntax is deliberately very simple; it may expand a bit
later.  At this point you can search for parameters and for tags,
and these can be combined.  Note that if you are using OrderlyWeb,
then only orderly (and not OrderlyWeb) tags are searched.
</p>
<p>The idea here is that the queries can be used to find ids that
match certain criteria for use as dependencies.  This function
lets you work out what would be resolved by the query, and using
this query string in a <code style="white-space: pre;">&#8288;depends:&#8288;</code> section will let you select
a report that matches some criteria.  For example, suppose that
you have report <code>A</code> that takes a parameter &quot;fruit&quot; with
values like &quot;apple&quot;, &quot;banana&quot;, and a report <code>B</code> that depends
on A.  You could then write:</p>
<pre>depends:
  A:
    id: latest(parameter:fruit == "apple")
    uses:
      summary.csv: summary.csv
</pre>
<p>To get the <code>summary.csv</code> file out of the latest report
<code>A</code> that was run with the &quot;fruit&quot; parameter set to &quot;apple&quot;.
If &quot;B&quot; itself takes parameters, you can use those parameters in
these query expressions like</p>
<pre>depends:
  A:
    id: latest(parameter:fruit == target_fruit)
    uses:
      summary.csv: summary.csv
</pre>
<p>(assuming that <code>B</code> takes a parameter <code>target_fruit</code>).
</p>
<p>The syntax for tags is simpler, one uses <code>tag:tagname</code> to
test for presence of a tag called &quot;tagname&quot;.
</p>
<p>Search queries can be joined by <code>&amp;&amp;</code> and <code>||</code> and
grouped using parentheses, these groups (or tags) can be negated
with <code>!</code>, so a complicated query expression might look like:</p>
<pre>(parameter:fruit == "apple" &amp;&amp; !tag:weekly) || parameter:fruit == "banana"
</pre>
<p>Be careful of comparing floating point numbers with <code>==</code> or
<code>!=</code> as they may not always return what you expect (for example
<code>sqrt(3)^2 == 3</code> is <code>FALSE</code>).
</p>
<p>In the documentation and error messages we may refer to the
left-hand-side of <code>:</code> as a &quot;namespace&quot;.  At this point the
only supported namespaces are <code>tag</code> and <code>parameter</code>.
</p>


<h3>Value</h3>

<p>A character vector of matching report ids, possibly
zero-length.  If the query is a &quot;latest&quot; query, then exactly one
report id, possibly NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a few reports here to actually query.  There is a report in
# the "demo" example called "other" that takes a parameter "nmin",
# which is used to filter data - it's not terribly important what it
# does here, but it can give us a set of reports to use.

# The demo set also includes configuration for two tags, called
# "dataset" and "plot" - the "dataset" tag will always be applied
# as it is listed in the orderly.yml but we can still add the
# "plot" tag interactively
root &lt;- orderly::orderly_example("demo")

# A helper function to mass-produce reports will reduce noise a bit
run1 &lt;- function(nmin, tags = NULL) {
  id &lt;- orderly_run("other", root = root, echo = FALSE,
                    parameters = list(nmin = nmin), tags = tags)
  orderly_commit(id, root = root)
  id
}

ids &lt;- c(run1(0.1), run1(0.2, "plot"), run1(0.3))

# We can then ask for all reports where the parameter nmin was more
# than some value
orderly::orderly_search("parameter:nmin &gt; 0.15", "other", root = root)

# Or use "&amp;&amp;" to find tags within a range
orderly::orderly_search("parameter:nmin &gt; 0.1 &amp;&amp; parameter:nmin &lt; 0.3",
                        "other", root = root)

# If a parameter is not present in some versions of a report you
# can use is.null to test for it (this is only ever the case if
# you have altered a report definition to add or remove a
# parameter)
orderly::orderly_search("is.null(parameter:nmin)", "other", root = root)

# We can look for tags
orderly::orderly_search("tag:plot", "other", root = root)

# or exclude them
orderly::orderly_search("!tag:plot", "other", root = root)

# or combine that with the presence/absence of a tag
orderly::orderly_search("parameter:nmin &gt; 0.15 &amp;&amp; !tag:plot",
                        "other", root = root)

# Use latest() over a query to find the latest report matching the
# query expression.
orderly::orderly_search("latest(parameter:nmin &gt; 0.15)",
                        "other", root = root)

# If no reports are found, then a zero-length character vector is returned
orderly::orderly_search("parameter:nmin &gt; 0.4", "other", root = root)

# Or, in the case of latest(), NA
orderly::orderly_search("latest(parameter:nmin &gt; 0.4)",
                        "other", root = root)
</code></pre>

<hr>
<h2 id='orderly_test_start'>Prepare a directory for orderly to use</h2><span id='topic+orderly_test_start'></span><span id='topic+orderly_test_check'></span>

<h3>Description</h3>

<p>For interactive testing of orderly code.  This runs through and
sets everything up as orderly would (creates a new working
directory and copies files into it, pulls data from the database,
copies over any dependent reports) but then rather than running
the report hands back to the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_test_start(
  name,
  parameters = NULL,
  envir = parent.frame(),
  root = NULL,
  locate = TRUE,
  instance = NULL,
  use_draft = FALSE,
  remote = NULL
)

orderly_test_check(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_test_start_+3A_name">name</code></td>
<td>
<p>Name of the report to run (see
<code><a href="#topic+orderly_list">orderly_list()</a></code>).  A leading <code style="white-space: pre;">&#8288;src/&#8288;</code> will be
removed if provided, allowing easier use of autocomplete.</p>
</td></tr>
<tr><td><code id="orderly_test_start_+3A_parameters">parameters</code></td>
<td>
<p>Parameters passed to the report. A named list of
parameters declared in the <code>orderly.yml</code>.  Each parameter
must be a scalar character, numeric, integer or logical.</p>
</td></tr>
<tr><td><code id="orderly_test_start_+3A_envir">envir</code></td>
<td>
<p>The parent of the environment that will be used to
evaluate the report script; by default a new environment will be
made with the global environment as the parent.</p>
</td></tr>
<tr><td><code id="orderly_test_start_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_test_start_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_test_start_+3A_instance">instance</code></td>
<td>
<p>Select instance of the source database to be used,
where multiple instances are configured.  Use a single
<em>unnamed</em> character string to indicate an instance to
match.  If given, then this name must be present in all
databases where instances are listed in
<code>orderly_config.yml</code>, and will be ignored by all database
where instances are not given.  See the &quot;orderly&quot; vignette for
further information.</p>
</td></tr>
<tr><td><code id="orderly_test_start_+3A_use_draft">use_draft</code></td>
<td>
<p>Should draft reports be used for dependencies?
This should be used only in development.  Valid values are
logical (<code>TRUE</code>, <code>FALSE</code>) or use the string
<code>newer</code> to use draft reports where they are newer than
archive reports.  For consistency, <code>always</code> and
<code>never</code> are equivalent to <code>TRUE</code> and <code>FALSE</code>,
respectively.</p>
</td></tr>
<tr><td><code id="orderly_test_start_+3A_remote">remote</code></td>
<td>
<p>Remote to use to resolve dependencies.  Use this in
order to run a report with the same dependencies as are
available on a remote server, particularly when using <code>id = "latest"</code>.  Note that this is not the same as running
<code><a href="#topic+orderly_pull_dependencies">orderly_pull_dependencies()</a></code>, then <code>orderly_run</code>
with <code>remote = NULL</code>, as the pull/run approach will use the
latest report in <em>your</em> archive but the <code>remote = "remote"</code> approach will use the latest approach in the
<em>remote</em> archive (which might be less recent).</p>
</td></tr>
<tr><td><code id="orderly_test_start_+3A_path">path</code></td>
<td>
<p>Path to the report that is currently being run</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Previous versions of orderly changed into the created directory
when using <code>orderly::orderly_test_start</code>, which allowed
interactive testing of a report, including ensuring that it has
created all expected outputs.  However, CRAN rules do not allow
changing the working directory, which significantly reduces the
usefulness of this function - as such we may remove it entirely in
a future version of orderly if it does not prove useful in this
more limited form.
</p>
<p>The new suggested workflow is:
</p>

<ol>
<li><p> run <code>orderly_test_start(...)</code> to prepare a report directory
</p>
</li>
<li><p> manually change into that directory following the printed
instructions
</p>
</li>
<li><p> use <code>orderly_test_check</code> to check that your report has created
the expected artefacts
</p>
</li>
<li><p> manually change back to your original directory
</p>
</li></ol>



<h3>Value</h3>

<p>The path to the report directory
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- orderly::orderly_example("minimal")
p &lt;- orderly::orderly_test_start("example", root = path)

# The data in the orderly example is now available to use
dat

# Check to see which artefacts have been created so far:
orderly::orderly_test_check(p)

# Manually the code that this report has in its script
png(file.path(p, "mygraph.png"))
barplot(setNames(dat$number, dat$name), las = 2)
dev.off()

# We now confirm that the artefact has been created:
orderly::orderly_test_check(p)
</code></pre>

<hr>
<h2 id='orderly_use_resource'>Add a resource to orderly.yml</h2><span id='topic+orderly_use_resource'></span><span id='topic+orderly_use_source'></span><span id='topic+orderly_use_package'></span><span id='topic+orderly_use_gitignore'></span>

<h3>Description</h3>

<p>Add one or more resources to an <code>orderly.yml</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderly_use_resource(
  resources,
  name = NULL,
  root = NULL,
  locate = TRUE,
  show = TRUE,
  edit = TRUE,
  prompt = TRUE
)

orderly_use_source(
  sources,
  name = NULL,
  root = NULL,
  locate = TRUE,
  show = TRUE,
  edit = TRUE,
  prompt = TRUE
)

orderly_use_package(
  packages,
  name = NULL,
  root = NULL,
  locate = TRUE,
  show = TRUE,
  edit = TRUE,
  prompt = TRUE
)

orderly_use_gitignore(
  root = NULL,
  locate = TRUE,
  show = TRUE,
  edit = TRUE,
  prompt = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderly_use_resource_+3A_resources">resources</code>, <code id="orderly_use_resource_+3A_sources">sources</code></td>
<td>
<p>Character vector of resources or sources
to add.  These must be filenames relative to the report
directory, must exist, and must not already be present in the
orderly.yml</p>
</td></tr>
<tr><td><code id="orderly_use_resource_+3A_name">name</code></td>
<td>
<p>Name of the report to modify.  Like
<code><a href="#topic+orderly_develop_start">orderly_develop_start()</a></code> this can be <code>NULL</code> if
you have already set the working directory to be the source
directory.</p>
</td></tr>
<tr><td><code id="orderly_use_resource_+3A_root">root</code></td>
<td>
<p>The path to an orderly root directory, or <code>NULL</code>
(the default) to search for one from the current working
directory if <code>locate</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_use_resource_+3A_locate">locate</code></td>
<td>
<p>Logical, indicating if the configuration should be
searched for.  If <code>TRUE</code> and <code>config</code> is not given,
then orderly looks in the working directory and up through its
parents until it finds an <code>orderly_config.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_use_resource_+3A_show">show</code></td>
<td>
<p>Logical, indicating if we should print the proposed
changes to screen</p>
</td></tr>
<tr><td><code id="orderly_use_resource_+3A_edit">edit</code></td>
<td>
<p>Logical, indicating if we should actually edit the
<code>orderly.yml</code> file.</p>
</td></tr>
<tr><td><code id="orderly_use_resource_+3A_prompt">prompt</code></td>
<td>
<p>Logical, indicating if we should prompt before
editing the orderly.yml file.  Only has an effect if <code>edit</code>
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orderly_use_resource_+3A_packages">packages</code></td>
<td>
<p>Character vector of package names to add.  These
must not already exist in the orderly.yml</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>orderly_use_gitignore</code> configures a basic
<code>.gitignore</code> file at the root of your orderly project that
will prevent files from being added to git.  This is only really
useful if you are using (or will use) git, but it is harmless at
worst.
</p>


<h3>Value</h3>

<p>Invisibly, this function returns information about the
file it would edit.  This information is primarily for debugging
purposes and the format is subject to change.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- orderly::orderly_example("minimal")

# Suppose we wanted to use the mtcars data within our report.
# First, the file must exist:
write.csv(mtcars, file.path(path, "src", "example", "mtcars.csv"),
          row.names = FALSE)

# Preview expected changes
orderly::orderly_use_resource("mtcars.csv", "example", path, edit = FALSE)

# Modify the orderly.yml file within src/example:
orderly::orderly_use_resource("mtcars.csv", "example", path, prompt = FALSE)

# The result is a file that now has a 'resources' section
# containing our new file
writeLines(readLines(file.path(path, "src", "example", "orderly.yml")))

# (of course, we'd still need to modify the script to use it).
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
