<!DOCTYPE html><html lang="en"><head><title>Help for package bayesTFR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesTFR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesTFR-package'>
<p>Bayesian Fertility Projection</p></a></li>
<li><a href='#bayesTFR-internal'>
<p>Internal Functions and datasets of bayesTFR</p></a></li>
<li><a href='#bayesTFR.mcmc'>
<p>MCMC Simulation Object</p></a></li>
<li><a href='#bayesTFR.mcmc.meta'>
<p>MCMC Simulation Meta Object</p></a></li>
<li><a href='#coda.list.mcmc'>
<p>Convertion to coda's Objects</p></a></li>
<li><a href='#convert.tfr.trajectories'>
<p>Converting TFR Trajectories into ACSII Files</p></a></li>
<li><a href='#country.names'>
<p>Accessing Country Names</p></a></li>
<li><a href='#DLcurve.plot'>
<p>Plotting  Posterior Distribution of the Double Logistic Function</p></a></li>
<li><a href='#get.country.object'>
<p>Accessing Country Information</p></a></li>
<li><a href='#get.cov.gammas'><p>Covariance Matrices of Gamma Parameters</p></a></li>
<li><a href='#get.est.model'>
<p>Accessing estimated bias and standard deviations</p></a></li>
<li><a href='#get.regtfr.prediction'>
<p>Accessing Subnational Prediction Objects</p></a></li>
<li><a href='#get.tfr.convergence'>
<p>Accessing a Convergence Object</p></a></li>
<li><a href='#get.tfr.estimation'>
<p>Get Past TFR Estimation</p></a></li>
<li><a href='#get.tfr.mcmc'>
<p>Accessing MCMC Results</p></a></li>
<li><a href='#get.tfr.parameter.traces'>
<p>Accessing MCMC Parameter Traces</p></a></li>
<li><a href='#get.tfr.prediction'>
<p>Accessing a Prediction Object</p></a></li>
<li><a href='#get.tfr.trajectories'>
<p>Accessing TFR Trajectories</p></a></li>
<li><a href='#get.thinned.tfr.mcmc'>
<p>Creating and Accessing Thinned MCMCs</p></a></li>
<li><a href='#get.total.iterations'>
<p>Total Number of Iterations</p></a></li>
<li><a href='#include'>
<p>Inclusion Codes</p></a></li>
<li><a href='#run.tfr.mcmc'>
<p>Running Markov Chain Monte Carlo for Parameters of Total Fertility Rate in Phase II</p></a></li>
<li><a href='#run.tfr.mcmc.extra'>
<p>Run MCMC for Extra Countries, Areas or Regions</p></a></li>
<li><a href='#run.tfr3.mcmc'>
<p>Running Markov Chain Monte Carlo for Parameters of Total Fertility Rate in Phase III</p></a></li>
<li><a href='#summary.bayesTFR.convergence'>
<p>Summary of a TFR Convergence Object</p></a></li>
<li><a href='#summary.bayesTFR.mcmc.set'>
<p>Summary Statistics for TFR Markov Chain Monte Carlo Chains</p></a></li>
<li><a href='#summary.bayesTFR.prediction'>
<p>Summary of a Prediction of the Total Fertility Rate</p></a></li>
<li><a href='#tfr_raw_data'>
<p>Raw TFR Data</p></a></li>
<li><a href='#tfr.diagnose'>
<p>Convergence Diagnostics of TFR Markov Chain Monte Carlo</p></a></li>
<li><a href='#tfr.dl.coverage'>
<p>Goodness of Fit of the Double Logistic Function</p></a></li>
<li><a href='#tfr.estimation.plot'>
<p>Plot TFR Estimation</p></a></li>
<li><a href='#tfr.map'>
<p>TFR World Map</p></a></li>
<li><a href='#tfr.median.set'>
<p>Editing Medians of the Projection</p></a></li>
<li><a href='#tfr.median.set.all'>
<p>Editing median for estimation and projections.</p></a></li>
<li><a href='#tfr.parameter.names'>
<p>Accessing Parameter Names</p></a></li>
<li><a href='#tfr.pardensity.plot'>
<p>Plotting MCMC Parameter Density</p></a></li>
<li><a href='#tfr.partraces.plot'>
<p>Plotting MCMC Parameter Traces</p></a></li>
<li><a href='#tfr.predict'>
<p>Generating Posterior Trajectories of the Total Fertility Rate</p></a></li>
<li><a href='#tfr.predict.extra'>
<p>Generating Posterior Trajectories of the Total Fertility Rate for Specific Countries or Regions</p></a></li>
<li><a href='#tfr.predict.subnat'>
<p>Generating Posterior Trajectories of Subnational TFR</p></a></li>
<li><a href='#tfr.raftery.diag'>
<p>Raftery Diagnostics for Parameters of the Total Fertility Rate</p></a></li>
<li><a href='#tfr.trajectories.plot'>
<p>Output of Posterior Distribution of TFR Trajectories</p></a></li>
<li><a href='#UN_time'>
<p>Dataset with UN-specific Time Coding</p></a></li>
<li><a href='#UN_variants'>
<p>Dataset with UN-specific Coding of Variants</p></a></li>
<li><a href='#write.projection.summary'>
<p>Writing Projection Summary Files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>7.4-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-01</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Fertility Projection</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, MASS, coda, graphics, grDevices, stats, utils,
wpp2019, data.table, lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rworldmap, snowFT, googleVis, sp, wpp2017, wpp2015, wpp2012,
wpp2010, ggplot2, sf, spData, scales</td>
</tr>
<tr>
<td>Description:</td>
<td>Making probabilistic projections of total fertility rate for all countries of the world, using a Bayesian hierarchical model &lt;<a href="https://doi.org/10.1007%2Fs13524-011-0040-5">doi:10.1007/s13524-011-0040-5</a>&gt; &lt;<a href="https://doi.org/10.18637%2Fjss.v106.i08">doi:10.18637/jss.v106.i08</a>&gt;. Subnational probabilistic projections are also supported &lt;<a href="https://doi.org/10.4054%2FDemRes.2018.38.60">doi:10.4054/DemRes.2018.38.60</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bayespop.csss.washington.edu">https://bayespop.csss.washington.edu</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-07 21:18:59 UTC; hana</td>
</tr>
<tr>
<td>Author:</td>
<td>Hana Sevcikova [cre, aut],
  Leontine Alkema [aut],
  Peiran Liu [aut],
  Adrian Raftery [aut],
  Bailey Fosdick [aut],
  Patrick Gerland [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hana Sevcikova &lt;hanas@uw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-08 09:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesTFR-package'>
Bayesian Fertility Projection
</h2><span id='topic+bayesTFR-package'></span><span id='topic+bayesTFR'></span>

<h3>Description</h3>

<p>Collection of functions for making probabilistic projections of total fertility rate (TFR) for all countries of the world, 
using a Bayesian hierarchical model (BHM) and the United Nations demographic time series. Functions for subnational projections are also available.
</p>


<h3>Details</h3>

<p>The projection follows a method developed by Alkema et al. (2011) and Raftery et al (2014). It uses historical data provided by the United Nations to simulate a posterior distribution of total fertility rates for all countries in the world simultaneously. 
</p>
<p>The estimation is split into two parts: 
</p>

<ol>
<li><p> BHM for fertility in a transition phase (Phase II), as described in Alkema et al. (2011),
</p>
</li>
<li><p> BHM for fertility in a post-transition phase (Phase III), as described in Raftery et al (2013).
</p>
</li></ol>

<p>The second part is optional and can be replaced by a simple AR(1) process.
</p>
<p>In addition, the package allows to assess uncertainty about the past (Liu and Rafftery 2020). Estimation and projection can be performed either for 5-year or 1-year time intervals.
</p>
<p>The main functions of the package are:
</p>

<ul>
<li> <p><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a>: Evokes running a Markov Chain Monte Carlo (MCMC) simulation for TFR in Phase II using one or more chains, possibly in parallel.  It results in a posterior sample of the mcmc parameters.  Existing simulation runs can be resumed using <a href="#topic+continue.tfr.mcmc">continue.tfr.mcmc</a>.
</p>
</li>
<li> <p><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a>: Starts MCMCs for TFR in Phase III. Existing simulation runs can be resumed using <a href="#topic+continue.tfr3.mcmc">continue.tfr3.mcmc</a>.
</p>
</li>
<li> <p><a href="#topic+tfr.predict">tfr.predict</a>: Using the posterior parameter samples it derives posterior trajectories of the total fertility rate for all countries.
</p>
</li>
<li> <p><a href="#topic+run.tfr.mcmc.extra">run.tfr.mcmc.extra</a>: Runs MCMC for extra countries or regions, i.e. for countries not included in the Bayesian hierarchical model. It can be also used for aggregations.
</p>
</li>
<li> <p><a href="#topic+tfr.predict.extra">tfr.predict.extra</a>: Generates predictions for extra countries or aggregated regions.
</p>
</li></ul>

<p>The order of the functions above roughly corresponds to a typical workflow when using the package: 1. run a Phase II MCMC simulation, 2. run a Phase III MCMC simulation (optional but recommended), 3. generate predictions, 4. analyze results (using the functions below). If there are countries that were not included in steps 1.-3., or if there are aggregated regions for which a prediction is desired, one proceeds with the two functions at the bottom of the list above, followed by the analyzing functions below.
</p>
<p>A number of functions analyzing results are included in the package:
</p>

<ul>
<li> <p><a href="#topic+tfr.trajectories.plot">tfr.trajectories.plot</a>: Shows the posterior trajectories for a given country, including their median and given probability intervals.
</p>
</li>
<li> <p><a href="#topic+tfr.trajectories.table">tfr.trajectories.table</a>: Shows the posterior trajectories for a given country in a tabular form.
</p>
</li>
<li> <p><a href="#topic+tfr.map">tfr.map</a>: Shows a TFR world map for a given projection period.
</p>
</li>
<li> <p><a href="#topic+DLcurve.plot">DLcurve.plot</a>: Shows the posterior curves of the double logistic function used in the simulation of PhaseII, including their median and given probability intervals.
</p>
</li>
<li> <p><a href="#topic+tfr.partraces.plot">tfr.partraces.plot</a> and <a href="#topic+tfr.partraces.cs.plot">tfr.partraces.cs.plot</a>: Plot the Phase II MCMC traces of country-independent parameters and country-specific parameters, respectively. <a href="#topic+tfr3.partraces.plot">tfr3.partraces.plot</a> and <a href="#topic+tfr3.partraces.cs.plot">tfr3.partraces.cs.plot</a> do the same for Phase III MCMCs.
</p>
</li>
<li> <p><a href="#topic+tfr.pardensity.plot">tfr.pardensity.plot</a> and <a href="#topic+tfr.pardensity.cs.plot">tfr.pardensity.cs.plot</a>: Plot the posterior density of the Phase II MCMCs for country-independent parameters and country-specific parameters, respectively. <a href="#topic+tfr3.pardensity.plot">tfr3.pardensity.plot</a> and <a href="#topic+tfr3.pardensity.cs.plot">tfr3.pardensity.cs.plot</a> do the same for Phase III MCMCs.
</p>
</li>
<li> <p><a href="#topic+summary.bayesTFR.mcmc.set">summary.bayesTFR.mcmc.set</a>: Summary function for the MCMC results.
</p>
</li>
<li> <p><a href="#topic+summary.bayesTFR.prediction">summary.bayesTFR.prediction</a>: Summary function for the prediction results.
</p>
</li></ul>

<p>For MCMC diagnostics, functions <a href="#topic+coda.list.mcmc">coda.list.mcmc</a> and <a href="#topic+coda.list.mcmc3">coda.list.mcmc3</a> create an object of type &ldquo;mcmc.list&rdquo; that can be used with the <span class="pkg">coda</span> package.  Furthermore, function <a href="#topic+tfr.diagnose">tfr.diagnose</a> and <a href="#topic+tfr3.diagnose">tfr3.diagnose</a> analyze the MCMCs using the Raftery diagnostics implemented in the <span class="pkg">coda</span> package and gives information about parameters that did not converge. 
</p>
<p>Existing simulation results can be accessed using the <a href="#topic+get.tfr.mcmc">get.tfr.mcmc</a> (Phase II) and <a href="#topic+get.tfr3.mcmc">get.tfr3.mcmc</a> (Phase III) functions.  An existing prediction can be accessed via <a href="#topic+get.tfr.prediction">get.tfr.prediction</a>. Existing convergence diagnostics can be accessed using the <a href="#topic+get.tfr.convergence">get.tfr.convergence</a>, <a href="#topic+get.tfr.convergence.all">get.tfr.convergence.all</a>, <a href="#topic+get.tfr3.convergence">get.tfr3.convergence</a> and <a href="#topic+get.tfr3.convergence.all">get.tfr3.convergence.all</a> functions.
</p>
<p>The historical national TFR data are taken from one of the packages <span class="pkg">wpp2019</span> (default), <span class="pkg">wpp2017</span>, <span class="pkg">wpp2015</span>, <span class="pkg">wpp2012</span> or <span class="pkg">wpp2010</span>, depending on users settings.
</p>
<p>Subnational TFR projections can be generated using <a href="#topic+tfr.predict.subnat">tfr.predict.subnat</a>. In this case, historical data must be provided by the user. Existing projections can be accessed from disk via <a href="#topic+get.regtfr.prediction">get.regtfr.prediction</a>. 
</p>


<h3>Note</h3>

<p>There is a directory <code>ex-data</code> shipped with the package which contains results from an example simulation, containing one chain with 60 iterations.  The Example section below shows how these results were created.  These data are used in Example sections throughout the manual.  The user can either reproduce the data in her/his local directory, or use the ones from the package.   
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova &lt;hanas@uw.edu&gt;, Leontine Alkema &lt;alkema@nus.edu.sg&gt;, Peiran Liu (prliu@uw.edu), Adrian Raftery &lt;raftery@uw.edu&gt;, Bailey Fosdick &lt;bfosdick@uw.edu&gt;, Patrick Gerland (gerland@un.org)
</p>
<p>Maintainer: Hana Sevcikova &lt;hanas@uw.edu&gt;
</p>


<h3>References</h3>

<p>Hana Sevcikova, Leontine Alkema, Adrian E. Raftery (2011). bayesTFR: An
R Package for Probabilistic Projections of the Total Fertility Rate.
Journal of Statistical Software, 43(1), 1-29. <a href="https://doi.org/10.18637/jss.v043.i01">doi:10.18637/jss.v043.i01</a>.
</p>
<p>Peiran Liu, Hana Sevcikova, Adrian E. Raftery (2023): Probabilistic Estimation and Projection of the Annual Total Fertility Rate Accounting for Past Uncertainty: A Major Update of the bayesTFR R Package. Journal of Statistical Software, 106(8), 1-36. <a href="https://doi.org/10.18637/jss.v106.i08">doi:10.18637/jss.v106.i08</a>.
</p>
<p>L. Alkema, A. E. Raftery, P. Gerland, S. J. Clark, F. Pelletier, Buettner, T., Heilig, G.K. (2011). Probabilistic Projections of the Total Fertility Rate for All Countries. Demography, Vol. 48, 815-839. <a href="https://doi.org/10.1007/s13524-011-0040-5">doi:10.1007/s13524-011-0040-5</a>.
</p>
<p>P. Liu, and A. E. Raftery (2020). Accounting for Uncertainty About Past Values In Probabilistic Projections of the Total Fertility Rate for All Countries. Annals of Applied Statistics, Vol 14, no. 2, 685-705. <a href="https://doi.org/10.1214/19-AOAS1294">doi:10.1214/19-AOAS1294</a>.
</p>
<p>Raftery, A.E., Alkema, L. and Gerland, P. (2014). Bayesian Population Projections for the United Nations.
Statistical Science, Vol. 29, 58-68. <a href="https://doi.org/10.1214/13-STS419">doi:10.1214/13-STS419</a>.
</p>
<p>Hana Sevcikova, Adrian E. Raftery, Patrick Gerland (2018). Probabilistic Projection of Subnational Total Fertility Rates. Demographic Research, Vol. 38(60), 1843-1884. <a href="https://doi.org/10.4054/DemRes.2018.38.60">doi:10.4054/DemRes.2018.38.60</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This command produces output data such as in the directory ex-data
sim.dir &lt;- tempfile()
# Phase II MCMCs
m &lt;- run.tfr.mcmc(nr.chains=1, iter=60, output.dir=sim.dir, seed=1, verbose=TRUE)
# Phase III MCMCs (not included in the package)
m3 &lt;- run.tfr3.mcmc(sim.dir=sim.dir, nr.chains=2, iter=100, thin=1, seed=1, verbose=TRUE)
# Prediction
pred &lt;- tfr.predict(m, burnin=30, burnin3=50, verbose=TRUE)
summary(pred, country='Ghana')
unlink(sim.dir, recursive=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='bayesTFR-internal'>
Internal Functions and datasets of bayesTFR 
</h2><span id='topic+burn.and.thin'></span><span id='topic+bdem.map.gvis'></span><span id='topic+bdem.parameter.traces'></span><span id='topic+diag.thin.indep'></span><span id='topic+DLcurve'></span><span id='topic+do.convert.trajectories'></span><span id='topic+do.get.tfr.parameter.traces'></span><span id='topic+do.get.traces'></span><span id='topic+do.get.traces.bayesTFR.mcmc'></span><span id='topic+do.meta.ini'></span><span id='topic+do.plot.tfr.pardensity'></span><span id='topic+do.plot.tfr.partraces'></span><span id='topic+do.read.un.file'></span><span id='topic+do.write.projection.summary'></span><span id='topic+do.write.values.into.file'></span><span id='topic+extract.plot.args'></span><span id='topic+filter.traces'></span><span id='topic+find.tau.and.DLcountries'></span><span id='topic+get.all.parameter.names'></span><span id='topic+get.all.parameter.names.cs'></span><span id='topic+get.all.parameter.names.extended'></span><span id='topic+get.ar1.parameters'></span><span id='topic+get.ar1.countries'></span><span id='topic+get.ar1.countries.index'></span><span id='topic+get.ar1.data'></span><span id='topic+get.burned.tfr.traces'></span><span id='topic+get.countries.index'></span><span id='topic+get.data.for.worldmap'></span><span id='topic+get.data.for.worldmap.bayesTFR.prediction'></span><span id='topic+get.data.imputed'></span><span id='topic+get.data.for.country.imputed'></span><span id='topic+get.data.matrix'></span><span id='topic+get.friendly.variant.names'></span><span id='topic+get.full.par.names'></span><span id='topic+get.full.par.names.cs'></span><span id='topic+get.half.child.variant'></span><span id='topic+get.lambda'></span><span id='topic+get.mcmc.list'></span><span id='topic+get.mcmc.list.bayesTFR.mcmc'></span><span id='topic+get.mcmc.list.bayesTFR.mcmc.set'></span><span id='topic+get.mcmc.list.bayesTFR.prediction'></span><span id='topic+get.mcmc.list.list'></span><span id='topic+get.mcmc.meta'></span><span id='topic+get.median.from.prediction'></span><span id='topic+get.mean.from.prediction'></span><span id='topic+get.meta.only'></span><span id='topic+get.newTFRcolnames'></span><span id='topic+get.nr.countries'></span><span id='topic+get.nrest.countries'></span><span id='topic+get.observed.time.matrix.and.regions'></span><span id='topic+get.other.parameter.names'></span><span id='topic+get.other.parameter.names.cs'></span><span id='topic+get.prediction.periods'></span><span id='topic+get.prediction.years'></span><span id='topic+get.projection.summary.header'></span><span id='topic+get.TFRmatrix.and.regions'></span><span id='topic+get.tfr.reconstructed'></span><span id='topic+get.tfr.shift'></span><span id='topic+get.tfr.shift.estimation'></span><span id='topic+get.thinned.burnin'></span><span id='topic+get.thinning.index'></span><span id='topic+get.totrans.parameter.names'></span><span id='topic+get.totrans.parameter.names.cs'></span><span id='topic+get.traj.ascii.header'></span><span id='topic+get.traj.quantiles'></span><span id='topic+get.trans.parameter.names'></span><span id='topic+get.trans.parameter.names.cs'></span><span id='topic+get.trajectories'></span><span id='topic+get.UN.variant.names'></span><span id='topic+get_eps_T'></span><span id='topic+get_eps_T_all'></span><span id='topic+ini.tfr.with.DL'></span><span id='topic+init.nodes'></span><span id='topic+init.nodes.cont'></span><span id='topic+load.tfr.parameter.traces'></span><span id='topic+load.tfr.parameter.traces.all'></span><span id='topic+load.tfr.parameter.traces.cs'></span><span id='topic+log_cond_U'></span><span id='topic+log_cond_abf_sd'></span><span id='topic+log_cond_const_sd'></span><span id='topic+log_cond_d_trans'></span><span id='topic+log_cond_Triangle_c4_trans'></span><span id='topic+log_cond_sigma0'></span><span id='topic+log_cond_sigma0.tau'></span><span id='topic+log_like_gammas'></span><span id='topic+make.tfr.prediction'></span><span id='topic+mcmc.continue.chain'></span><span id='topic+mcmc.ini'></span><span id='topic+mcmc.ini.extra'></span><span id='topic+mcmc.meta.ini'></span><span id='topic+mcmc.meta.ini.extra'></span><span id='topic+mcmc.run.chain'></span><span id='topic+mcmc.run.chain.extra'></span><span id='topic+mcmc.update.U'></span><span id='topic+mcmc.update.abS'></span><span id='topic+mcmc.update.abSsigma0const'></span><span id='topic+mcmc.update.d'></span><span id='topic+mcmc.update.Triangle_c4'></span><span id='topic+mcmc.update.gamma'></span><span id='topic+mcmc.update.sigma0const'></span><span id='topic+mcmc.update.sigma0.tau'></span><span id='topic+no.traces.loaded'></span><span id='topic+overwrite.colnames'></span><span id='topic+par.names.for.worldmap'></span><span id='topic+process.not.converged.parameters'></span><span id='topic+read.tfr.file'></span><span id='topic+read.UNlocations'></span><span id='topic+read.UNtfr'></span><span id='topic+remove.tfr.traces'></span><span id='topic+set_wpp_regions'></span><span id='topic+set.wpp.extra'></span><span id='topic+stop.if.country.not.DL'></span><span id='topic+store.bayesTFR.meta.object'></span><span id='topic+store.bayesTFR.object'></span><span id='topic+store.mcmc'></span><span id='topic+store.traj.ascii'></span><span id='topic+thinindep'></span><span id='topic+tfr.get.dlcurves'></span><span id='topic+tfr.info'></span><span id='topic+tfr.mcmc.sampling'></span><span id='topic+tfr.mcmc.sampling.extra'></span><span id='topic+tfr.set.identical'></span><span id='topic+tfr.identical'></span><span id='topic+write.table.into.file.cdep'></span><span id='topic+write.table.into.file.cindep'></span><span id='topic+write.values.into.file.cdep'></span><span id='topic+write.values.into.file.cindep'></span><span id='topic+.map.main.default'></span><span id='topic+.get.gamma.pars'></span><span id='topic+iso3166'></span><span id='topic+proposal_cov_gammas_cii'></span><span id='topic+correlation_predictors'></span>

<h3>Description</h3>

<p>These functions and datasets are not to be used directly by the user.
</p>

<hr>
<h2 id='bayesTFR.mcmc'>
MCMC Simulation Object
</h2><span id='topic+bayesTFR.mcmc'></span>

<h3>Description</h3>

<p>MCMC simulation object <code>bayesTFR.mcmc</code> containing information about one MCMC chain, either from Phase II or Phase III simulation. A set of such objects belonging to the same simulation together with a <code><a href="#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code> object constitute a <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> object. 
</p>


<h3>Details</h3>

<p>An object <code>bayesTFR.mcmc</code> points to a place on disk (element <code>output.dir</code>) where MCMC results from all iterations are stored. They can be retrieved to the memory using <code><a href="#topic+get.tfr.mcmc">get.tfr.mcmc</a>(...)</code> (Phase II) or <code><a href="#topic+get.tfr3.mcmc">get.tfr3.mcmc</a>(...)</code> (Phase III), and <code><a href="#topic+tfr.mcmc">tfr.mcmc</a>(...)</code>. 
</p>
<p>The object is in standard cases not to be manipulated by itself, but rather as part of a <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> object.
</p>


<h3>Value</h3>

<p>A <code>bayesTFR.mcmc</code> object contains parameters of the Bayesian hierarchical model, more specifically, their values from the last iteration.  If it is a <b>Phase II</b> object these parameters are: <br />
<code>psi, chi, a_sd, b_sd, const_sd, S_sd, sigma0, mean_eps_tau, sd_eps_tau, Triangle4</code> - non-country specific parameters, containing one value each.<br />
<code>alpha, delta</code> -  non-country specific parameters, containing three values each.<br />
<code>U_c, d_c, Triangle_c4</code> - country-specific parameters (1d array).<br />
<code>gamma_ci</code> - country-specific parameter with three values for each country, i.e. an <code class="reqn">n \times 3</code> matrix where <code class="reqn">n</code> is the number of countries.<br />
<b>Phase III</b> MCMC objects contain single-value parameters <code>mu</code>, <code>rho</code>, <code>sigma.mu</code>, <code>sigma.rho</code>, <code>sigma.eps</code> and <code class="reqn">n</code>-size vectors <code>mu.c</code> and <code>rho.c</code>.<br />
Furthermore, the object (independent of Phase) contains components:
</p>
<table role = "presentation">
<tr><td><code>iter</code></td>
<td>
<p>Total number of iterations the simulation was started with.</p>
</td></tr>
<tr><td><code>finished.iter</code></td>
<td>
<p>Number of iterations that were finished.  Results from the last finished iteration are stored in the parameters above.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>Length of the MCMC stored on disk. It differs from <code>finished.iter</code> only if <code>thin</code> is larger than one.</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>
<p>Thinning interval used when simulating the MCMCs.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>Identifier of this chain.</p>
</td></tr>
<tr><td><code>output.dir</code></td>
<td>
<p>Subdirectory (relative to <code>output.dir</code> in the <code><a href="#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code> object) where results of this chain are stored.</p>
</td></tr>
<tr><td><code>traces</code></td>
<td>
<p>This is a placeholder for keeping whole parameter traces in the memory.  If the processing operates in a low memory mode, it will be 0.  It can be filled in using the function <code><a href="#topic+get.tfr.mcmc">get.tfr.mcmc</a>(..., low.memory=FALSE)</code>. In such a case, <code>traces</code> is a <code class="reqn">I \times J</code> array where <code class="reqn">I</code> is the MCMC <code>length</code> and <code class="reqn">J</code> is the number of parameters.</p>
</td></tr>
<tr><td><code>traces.burnin</code></td>
<td>
<p>Burnin used to retrieve the traces, i.e. how many stored iterations are missing from the beginning in the <code>traces</code> array comparing to the &lsquo;raw&rsquo; traces on the disk.</p>
</td></tr>
<tr><td><code>rng.state</code></td>
<td>
<p>State of the random number generator at the end of the last finished interation.</p>
</td></tr>
<tr><td><code>compression.type</code></td>
<td>
<p>Type of compression of the underlying files.</p>
</td></tr>
<tr><td><code>meta</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code> used for simulation of this chain.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>, <code><a href="#topic+get.tfr.mcmc">get.tfr.mcmc</a></code>, <code><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a></code>, <code><a href="#topic+get.tfr3.mcmc">get.tfr3.mcmc</a></code>, <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code>, <code><a href="#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
# loads traces from one chain
m &lt;- get.tfr.mcmc(sim.dir, low.memory=FALSE, burnin=35, chain.ids=1)
# should have 25 rows, since 60 iterations in total minus 35 burnin
dim(tfr.mcmc(m, 1)$traces)
summary(m, chain.id=1)
## End(Not run)
</code></pre>

<hr>
<h2 id='bayesTFR.mcmc.meta'>
MCMC Simulation Meta Object
</h2><span id='topic+bayesTFR.mcmc.meta'></span>

<h3>Description</h3>

<p>Simulation meta object <code>bayesTFR.mcmc.meta</code> used by all chains of the same MCMC simulation. 
It contains information that is common to all chains. It is part of a <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> object.
</p>


<h3>Details</h3>

<p>The object is in standard cases not to be manipulated by itself, but rather as part of a <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> object.
</p>


<h3>Value</h3>

<p>A <code>bayesTFR.mcmc.meta</code> object contains various components that correspond to the input arguments 
of the <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code> and <code><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a></code> functions. Furthermore, it contains components:
</p>
<table role = "presentation">
<tr><td><code>nr.chains</code></td>
<td>
<p>Number of MCMC chains.</p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>Value 2 or 3, depending which Phase the object belongs to.</p>
</td></tr>
<tr><td><code>output.dir</code></td>
<td>
<p>Directory for storing simulation output.</p>
</td></tr>
</table>


<h3>Value - Phase II</h3>

<p>Furthermore, Phase II meta objects contain components:
</p>

<dl>
<dt>tfr_matrix_all</dt><dd><p>A <code class="reqn">q \times n</code> matrix with the United Nations TFR estimates. <code class="reqn">q</code> is number of years (see <code>T_end</code> below), <code class="reqn">n</code> is number of countries (see <code>nr_countries</code> below). The first <code class="reqn">n_e</code> columns correspond to countries included in the MCMC estimation (see <code>nr_countries_estimation</code> below), where <code class="reqn">n_e &lt;= n</code>.</p>
</dd>
<dt>tfr_matrix_observed</dt><dd><p>Like <code>tfr_matrix_all</code>, but it has <code>NA</code> values for years where no historical data is available (i.e. after the last observed time period).</p>
</dd>
<dt>tfr_matrix</dt><dd><p>Like <code>tfr_matrix_observed</code>, but it has <code>NA</code> values before and after country&rdquo;s fertility transition.</p>
</dd>
<dt>nr_countries</dt><dd><p>Number of countries included in the tfr matrices.</p>
</dd>
<dt>nr_countries_estimation</dt><dd><p>Number of countries included in the MCMC estimation. It must be smaller or equal to <code>nr_countries</code>.</p>
</dd>
<dt>tau_c</dt><dd><p>Estimated start year of the fertility decline for each country (as a row index within the tfr matrices). -1 means that the decline started before <code>start.year</code>.</p>
</dd>
<dt>id_Tistau</dt><dd><p>Index of countries for which <code>present.year</code> is equal to <code>tau_c</code>.</p>
</dd>
<dt>id_DL</dt><dd><p>Index of countries for which the projection is made using the double logistic function, i.e. high fertility countries.</p>
</dd>
<dt>id_early</dt><dd><p>Index of countries with early decline, i.e. countries for which <code>tau_c=-1</code>.</p>
</dd>
<dt>id_notearly</dt><dd><p>Index of countries with not early decline.</p>
</dd>
<dt>lambda_c</dt><dd><p>Start period of the recovery phase for each country (as an index of the <code>tfr_matrix</code>).</p>
</dd>
<dt>start_c</dt><dd><p>Maximum of <code>tau_c</code> and 1 for each country. Thus, it is a row index of the <code>tfr_matrix</code> where the fertility decline starts.</p>
</dd>
<dt>proposal_cov_gammas_cii</dt><dd><p>Proposal covariance matrices of <code class="reqn">\gamma_{ci}</code> for each country.</p>
</dd>
<dt>T_end</dt><dd><p>Number of years for which United Nations historical data are available (i.e. number of rows of <code>tfr_matrix</code>).</p>
</dd>
<dt>T_end_c</dt><dd><p>Like <code>T_end</code> but country specific.</p>
</dd>
<dt>regions</dt><dd><p>List of arrays of length <code>nr_countries</code>. These are: <br />
<code>name</code> - Region name for each country.<br />
<code>code</code> - Region code for each country. <br />
<code>area_name</code> - Area name for each country. <br />
<code>area_code</code> - Area code for each country. <br />
<code>country_name</code> - Array of country names. <br />
<code>country_code</code> - Array of country codes. <br />
Any country indices in the <code>bayesTFR.mcmc.meta</code> object are derived from this component.</p>
</dd>
</dl>



<h3>Value - Phase III</h3>

<p>Phase III meta objects contain additional components:
</p>

<dl>
<dt>id_phase3</dt><dd><p>Indices of countries included in the Phase III estimation. It is relative to the order of countries in the <code>region</code> object in the parent meta object.</p>
</dd>
<dt>nr.countries</dt><dd><p>Number of countries included in the estimation.</p>
</dd>
<dt>parent</dt><dd><p>Link to the Phase II meta object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Hana Sevcikova, Leontine Alkema
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>, <code><a href="#topic+get.tfr.mcmc">get.tfr.mcmc</a></code>, <code><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a></code>, <code><a href="#topic+get.tfr3.mcmc">get.tfr3.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
m &lt;- get.tfr.mcmc(sim.dir)
summary(m, meta.only = TRUE)
names(m$meta)
</code></pre>

<hr>
<h2 id='coda.list.mcmc'>
Convertion to coda's Objects
</h2><span id='topic+coda.list.mcmc'></span><span id='topic+coda.list.mcmc3'></span><span id='topic+coda.mcmc'></span><span id='topic+coda.mcmc.bayesTFR.mcmc'></span>

<h3>Description</h3>

<p>The functions convert MCMC traces (simulated using <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code> and <code><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a></code>) into objects that can be used with the <span class="pkg">coda</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coda.list.mcmc(mcmc = NULL, country = NULL, chain.ids = NULL, 
    sim.dir = file.path(getwd(), "bayesTFR.output"), 
    par.names = tfr.parameter.names(), 
    par.names.cs = tfr.parameter.names.cs(), 
    rm.const.pars = FALSE, burnin = 0, 
    low.memory = FALSE, ...)
    
coda.list.mcmc3(mcmc = NULL, country = NULL, chain.ids = NULL, 
    sim.dir = file.path(getwd(), "bayesTFR.output"), 
    par.names = tfr3.parameter.names(), 
    par.names.cs = tfr3.parameter.names.cs(), 
    burnin = 0, low.memory = FALSE, ...)
	
## S3 method for class 'bayesTFR.mcmc'
coda.mcmc(mcmc, country = NULL, 
    par.names = NULL, par.names.cs = NULL, 
    burnin = 0, thin = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coda.list.mcmc_+3A_mcmc">mcmc</code></td>
<td>
<p>In <code>coda.mcmc</code>, it is an object of class <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code>. In <code>coda.list.mcmc</code> and <code>coda.list.mcmc3</code>, it is either a list of <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code> objects, or an object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> or in case of <code>coda.list.mcmc</code> it can be <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>. If it is <code>NULL</code>, the MCMCs are loaded from <code>sim.dir</code>. Either <code>mcmc</code> or <code>sim.dir</code> must be given.</p>
</td></tr>
<tr><td><code id="coda.list.mcmc_+3A_country">country</code></td>
<td>
<p>Country name or code. It is used in connection with the <code>par.names.cs</code> argument (see below). 
</p>
</td></tr>
<tr><td><code id="coda.list.mcmc_+3A_chain.ids">chain.ids</code></td>
<td>

<p>Vector of chain identifiers. By default, all chains available in the <code>mcmc.list</code> object are included.
</p>
</td></tr>
<tr><td><code id="coda.list.mcmc_+3A_sim.dir">sim.dir</code></td>
<td>

<p>Directory with the MCMC simulation results. Only used if <code>mcmc.list</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="coda.list.mcmc_+3A_par.names">par.names</code></td>
<td>

<p>Names of country-independent parameters to be included. In <code>coda.mcmc</code> the default names are <code><a href="#topic+tfr.parameter.names">tfr.parameter.names</a>()</code> if the <code>mcmc</code> object is an MCMC of phase II or  <code><a href="#topic+tfr3.parameter.names">tfr3.parameter.names</a>()</code> if the MCMC is of phase III.
</p>
</td></tr>
<tr><td><code id="coda.list.mcmc_+3A_par.names.cs">par.names.cs</code></td>
<td>

<p>Names of country-specific parameters to be included. The argument <code>country</code> is used to filter out traces that correspond to a specific country. If <code>country</code> is not given, for each parameter, traces for all countries are included. In <code>coda.mcmc</code> the default names are <code><a href="#topic+tfr.parameter.names.cs">tfr.parameter.names.cs</a>()</code> if the <code>mcmc</code> object is an MCMC of phase II or  <code><a href="#topic+tfr3.parameter.names.cs">tfr3.parameter.names.cs</a>()</code> if the MCMC is of phase III.
</p>
</td></tr>
<tr><td><code id="coda.list.mcmc_+3A_rm.const.pars">rm.const.pars</code></td>
<td>

<p>Logical indicating if parameters with constant values should be removed.
</p>
</td></tr>
<tr><td><code id="coda.list.mcmc_+3A_burnin">burnin</code></td>
<td>

<p>Burnin indicating how many iterations should be removed from the beginning of each chain.
</p>
</td></tr>
<tr><td><code id="coda.list.mcmc_+3A_low.memory">low.memory</code></td>
<td>

<p>Logical indicating if the function should run in a memory-efficient mode.
</p>
</td></tr>
<tr><td><code id="coda.list.mcmc_+3A_thin">thin</code></td>
<td>
<p>Thinning interval.</p>
</td></tr>
<tr><td><code id="coda.list.mcmc_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to the <span class="pkg">coda</span>'s <code><a href="coda.html#topic+mcmc">mcmc</a></code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>coda.list.mcmc</code> is for accessing all chains of phase II MCMCs; Function <code>coda.list.mcmc3</code> is for accessing all chains of phase III MCMCs.
</p>


<h3>Value</h3>

<p>The function <code>coda.list.mcmc</code> and <code>coda.list.mcmc3</code> return an object of class &ldquo;mcmc.list&rdquo;. The function <code>coda.mcmc</code> returns an object of class &ldquo;mcmc&rdquo;, both defined in the <span class="pkg">coda</span> package.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>

<hr>
<h2 id='convert.tfr.trajectories'>
Converting TFR Trajectories into ACSII Files</h2><span id='topic+convert.tfr.trajectories'></span>

<h3>Description</h3>

<p>Converts TFR trajectories stored in a binary format into two CSV files of a UN-specific format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.tfr.trajectories(dir = file.path(getwd(), 'bayesTFR.output'), 
    n = 1000, subdir = "predictions", output.dir = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.tfr.trajectories_+3A_dir">dir</code></td>
<td>
<p>Directory containing the prediction object. It should correspond to the <code>output.dir</code> argument of the <code><a href="#topic+tfr.predict">tfr.predict</a></code> function.</p>
</td></tr>
<tr><td><code id="convert.tfr.trajectories_+3A_n">n</code></td>
<td>
<p>Number of trajectories to be stored. It can be either a single number or the word &ldquo;all&rdquo; in which case all trajectories are stored.</p>
</td></tr>
<tr><td><code id="convert.tfr.trajectories_+3A_subdir">subdir</code></td>
<td>
<p>Name of subdirectory of <code>dir</code> containing the prediction.</p>
</td></tr>
<tr><td><code id="convert.tfr.trajectories_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory in which the resulting files will be stored. If <code>NULL</code> the same directory is used as for the prediction.</p>
</td></tr>
<tr><td><code id="convert.tfr.trajectories_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates two files. One is called &ldquo;ascii_trajectories.csv&rdquo;, it is a comma-separated table with the following columns: 
</p>

<dl>
<dt>LocID</dt><dd><p>country code</p>
</dd> 
<dt>Period</dt><dd><p>prediction interval, e.g. 2015-2020</p>
</dd> 
<dt>Year</dt><dd><p>middle year of the prediction interval</p>
</dd>
<dt>Trajectory</dt><dd><p>identifier of the trajectory</p>
</dd>
<dt>TF</dt><dd><p>total fertility rate</p>
</dd>
</dl>

<p>The second file is called &ldquo;ascii_trajectories_wide.csv&rdquo;, it is also a comma-separated table and it contains the same information as above but in a &lsquo;transposed&rsquo; format. I.e. the data for one country are ordered in columns, thus, there is one column per country. The country columns are ordered alphabetically. 
</p>
<p>If <code>n</code> is smaller than the total number of trajectories, the trajectories are selected using equal spacing.</p>


<h3>Note</h3>

<p>This function is automatically called from the <code><a href="#topic+tfr.predict">tfr.predict</a></code> function, therefore in standard cases it will not be needed to call it directly. However, it can be useful for example, if different number of trajectories are to be converted, without having to re-run the prediction.</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.projection.summary">write.projection.summary</a></code>, <code><a href="#topic+tfr.predict">tfr.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
pred.dir &lt;- file.path(getwd(), "exampleTFRpred")

# stores 10 trajectories out of 35 (1x(60-25)) into 
# exampleTFRpred/predictions/ascii_trajectories.csv
tfr.predict(sim.dir=sim.dir, output.dir=pred.dir, use.tfr3=FALSE,
            burnin=25, save.as.ascii=10, verbose=TRUE)
            
# stores all 35 trajectories into the current directory
convert.tfr.trajectories(dir=pred.dir, n="all", output.dir=".", verbose=TRUE)

# Note: If the output.dir argument in tfr.predict is omitted, 
# call convert.tfr.trajectories with dir=sim.dir 

## End(Not run)
</code></pre>

<hr>
<h2 id='country.names'>
Accessing Country Names
</h2><span id='topic+country.names'></span>

<h3>Description</h3>

<p>The function returns country names for countries given either by their codes or by index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>country.names(meta, countries = NULL, index = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="country.names_+3A_meta">meta</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code>, <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code>, <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code>, or <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="country.names_+3A_countries">countries</code></td>
<td>
<p>Vector of country codes or indices. If it is not given, names of all countries are returned.</p>
</td></tr>
<tr><td><code id="country.names_+3A_index">index</code></td>
<td>
<p>Logical indicating if the argument <code>countries</code> is an index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function considers countries that are included in the simulations and predictions. If the argument <code>countries</code> is not given, all countries are returned in the same order as they are stored in the meta object. 
</p>


<h3>Value</h3>

<p>Vector of country names.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.countries.table">get.countries.table</a></code>, <code><a href="#topic+get.country.object">get.country.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
m &lt;- get.tfr.mcmc(sim.dir)
country.names(m)
# these two calls should give the same answer
country.names(m, c(800, 120))
country.names(m, c(15, 20), index=TRUE)
</code></pre>

<hr>
<h2 id='DLcurve.plot'>
Plotting  Posterior Distribution of the Double Logistic Function
</h2><span id='topic+DLcurve.plot'></span><span id='topic+DLcurve.plot.all'></span><span id='topic+tfr.world.dlcurves'></span><span id='topic+tfr.country.dlcurves'></span>

<h3>Description</h3>

<p>The functions for plotting and retrieving the posterior distribution of the double logistic function used in the simulation of Phase II. Plots include the median and given probability intervals of the distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DLcurve.plot(mcmc.list, country, burnin = NULL, pi = 80, tfr.max = 10, 
    nr.curves = NULL, predictive.distr = FALSE, ylim = NULL, 
    xlab = 'TFR (reversed)', ylab = 'TFR decrement', main = NULL, 
    show.legend = TRUE, col=c('black', 'red', "#00000020"), ...)
	
DLcurve.plot.all(mcmc.list = NULL, sim.dir = NULL, 
    output.dir = file.path(getwd(), 'DLcurves'),
    output.type = "png", burnin = NULL, verbose = FALSE, ...)
    
tfr.world.dlcurves(x, mcmc.list, burnin=NULL, countryUc=NULL, ...)

tfr.country.dlcurves(x, mcmc.list, country, burnin=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DLcurve.plot_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code> objects, an object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> or of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>. In case of <code>DLcurve.plot.all</code> if it si <code>NULL</code>, it is loaded from <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_country">country</code></td>
<td>
<p>Name or code of a country. The code can be either numeric or ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of parameter traces.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_pi">pi</code></td>
<td>
<p>Probability interval. It can be a single number or an array.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_tfr.max">tfr.max</code></td>
<td>
<p>Maximum TFR to be shown in the plot.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_nr.curves">nr.curves</code></td>
<td>
<p>Number of curves to be plotted. If <code>NULL</code>, all curves are plotted.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_predictive.distr">predictive.distr</code></td>
<td>
<p>Logical. If <code>TRUE</code>, an error term is added to each trajectory.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_ylim">ylim</code>, <code id="DLcurve.plot_+3A_xlab">xlab</code>, <code id="DLcurve.plot_+3A_ylab">ylab</code>, <code id="DLcurve.plot_+3A_main">main</code></td>
<td>
<p>Graphical parameters passed to the <code>plot</code> function.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical determining if the legend should be shown.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_col">col</code></td>
<td>
<p>Vector of colors in this order: 1. observed data points, 2. quantiles, 3. trajectories</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_...">...</code></td>
<td>
<p>For the plotting functions, there are additional graphical parameters. For <code>DLcurve.plot.all</code>, <code>...</code> contains also arguments
<code>pi</code>, <code>tfr.max</code> and <code>nr.curves</code>. For the <code>tfr.*.dlcurves</code> functions, 
these are arguments passed to the underlying functions (<code>predictive.distr</code> and <code>return.sigma</code> for obtaining a sample of the standard deviation of the error term ).</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the simulation results. Only relevant, if <code>mcmc.list</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which resulting graphs are stored.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_output.type">output.type</code></td>
<td>
<p>Type of the resulting files. It can be &ldquo;png&rdquo;, &ldquo;pdf&rdquo;, &ldquo;jpeg&rdquo;, &ldquo;bmp&rdquo;, &ldquo;tiff&rdquo;, or &ldquo;postscript&rdquo;.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_x">x</code></td>
<td>
<p>TFR values for which the double logistic should be computed.</p>
</td></tr>
<tr><td><code id="DLcurve.plot_+3A_countryuc">countryUc</code></td>
<td>
<p>Country to use the parameter U_c from (start of the fertility transition). If it is not given, the middle point of the prior distribution is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DLcurve.plot</code> plots double logistic curves for the given country.  <code>DLcurve.plot.all</code> creates such plots for all countries and stores them in <code>output.dir</code>. Parameters inputting the double logistic function are either thinned traces created by the <code><a href="#topic+tfr.predict">tfr.predict</a></code> function (if <code>mcmc.list</code> is an object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>), or they are selected by equal spacing from the MCMC traces. In the former case, <code>burnin</code> is set automatically; in the latter case, <code>burnin</code> defaults to 0 since such object has already been &ldquo;burned&rdquo;. If <code>nr.curves</code> is smaller than 2000, the median and probability intervals are computed on a sample of 2000 equally spaced data points, otherwise on all plotted curves.
</p>
<p>Function <code>tfr.world.dlcurves</code> returns the DL curves of the hierarchical distribution, conditioned on the starting point of the fertility transition in a given country (given by the <code>countryUc</code> argument). Function <code>tfr.country.dlcurves</code> returns DL curves for a given country. If <code>mcmc.list</code> is a prediction object, <code>burnin</code> should not be given, as such object has already been &ldquo;burned&rdquo;.  
</p>


<h3>Value</h3>

<p><code>tfr.world.dlcurves</code> and <code>tfr.country.dlcurves</code> return a matrix of size <code class="reqn">N \times M</code> where <code class="reqn">N</code> is the number of trajectories and <code class="reqn">M</code> is the number of values of <code class="reqn">x</code>. If the argument <code>return.sigma</code> is set to <code>TRUE</code>, the return value is a list with the first element being the DL values and the second element being a matrix of the standard deviation of the DL error term <code>sigma_eps</code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Leontine Alkema
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
mcmc.set &lt;- get.tfr.mcmc(sim.dir=sim.dir)
DLcurve.plot(country="Burkina Faso", mcmc.set, burnin=15)

# add the median of the hierarchical DL curves
x &lt;- seq(0, 10, length=100)
world &lt;- tfr.world.dlcurves(x, mcmc.set, burnin=15, countryUc="Burkina Faso")
qw &lt;- apply(world, 2, median) 
lines(x, qw, col='blue')

## End(Not run)
</code></pre>

<hr>
<h2 id='get.country.object'>
Accessing Country Information
</h2><span id='topic+get.country.object'></span><span id='topic+get.countries.table'></span><span id='topic+get.countries.table.bayesTFR.mcmc.set'></span><span id='topic+get.countries.table.bayesTFR.prediction'></span><span id='topic+get.countries.phase'></span><span id='topic+get.countries.phase.bayesTFR.mcmc.set'></span><span id='topic+get.countries.phase.bayesTFR.prediction'></span>

<h3>Description</h3>

<p>Function <code>get.country.object</code> returns an object containing country name, code and index. Functions <code>get.countries.table</code> return a data frame containing codes, names and optionally ISO character codes of all countries. Functions <code>get.countries.phase</code> return countries table with the TFR phase they are currently in (1, 2, or 3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.country.object(country, meta = NULL, country.table = NULL, index = FALSE)

## S3 method for class 'bayesTFR.mcmc.set'
get.countries.table(object, iso = FALSE, ...)
## S3 method for class 'bayesTFR.prediction'
get.countries.table(object, iso = FALSE, ...)

## S3 method for class 'bayesTFR.mcmc.set'
get.countries.phase(object, ...)
## S3 method for class 'bayesTFR.prediction'
get.countries.phase(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.country.object_+3A_country">country</code></td>
<td>
<p>Country name, code or index. If it is an index, the argument <code>index</code> must be set to <code>TRUE</code>. The code can be either numeric or ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="get.country.object_+3A_meta">meta</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code>. If it is not given, the argument <code>country.table</code> must be given.</p>
</td></tr>
<tr><td><code id="get.country.object_+3A_country.table">country.table</code></td>
<td>
<p>A table containing columns &ldquo;name&rdquo; and &ldquo;code&rdquo; from which the country info can be extracted. Only relevant, if <code>meta</code> is <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="get.country.object_+3A_index">index</code></td>
<td>
<p>Logical determining if the argument <code>country</code> is an index.</p>
</td></tr>
<tr><td><code id="get.country.object_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> or <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="get.country.object_+3A_iso">iso</code></td>
<td>
<p>Logical. If <code>TRUE</code>, two extra columns are added to the table, namely 2- and 3-characters ISO codes.</p>
</td></tr>
<tr><td><code id="get.country.object_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given partial information about a country (i.e. having either name or code or index), the function <code>get.country.object</code> returns  an object containing all three pieces of information. Only countries are considered that are included in the simulations and predictions. Country index is an internal index used in various components of a <code><a href="#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code> object.
</p>


<h3>Value</h3>

<p>Function <code>get.country.object</code> returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>name</code></td>
<td>
<p>Country name</p>
</td></tr>
<tr><td><code>code</code></td>
<td>
<p>Country numeric code</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>Country index</p>
</td></tr>
</table>
<p>Function <code>get.countries.table</code> returns a data frame with columns <code>code</code>, <code>name</code>, and optionally (if <code>iso</code> is <code>TRUE</code>) <code>iso2</code> and <code>iso3</code>.
</p>
<p>Function <code>get.countries.phase</code> returns a data frame with columns <code>code</code>, <code>name</code> and <code>phase</code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+country.names">country.names</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
m &lt;- get.tfr.mcmc(sim.dir)
# all five calls should give the same answer
get.country.object('China', m$meta)
get.country.object('CN', m$meta)
get.country.object(156, m$meta)
get.country.object(56, m$meta, index=TRUE)
get.country.object(156, NULL, country.table=get.countries.table(m))

# phase 3 countries
subset(get.countries.phase(m), phase == 3)
</code></pre>

<hr>
<h2 id='get.cov.gammas'>Covariance Matrices of Gamma Parameters
</h2><span id='topic+get.cov.gammas'></span>

<h3>Description</h3>

<p>From a given MCMC, obtain a covariance matrix of the <code class="reqn">\gamma_{ci}</code> (<code class="reqn">i=1,2,3</code>) parameters for each country <code class="reqn">c</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.cov.gammas(mcmc.set = NULL, sim.dir = NULL, burnin = 200, chain.id = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.cov.gammas_+3A_mcmc.set">mcmc.set</code></td>
<td>
<p>Object of class <code>bayesTFR.mcmc.set</code>. If it is <code>NULL</code>, the <code>sim.dir</code> is used to load existing simulation results.</p>
</td></tr>
<tr><td><code id="get.cov.gammas_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with existing MCMC simulation results. It is only used if <code>mcmc.set</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get.cov.gammas_+3A_burnin">burnin</code></td>
<td>
<p>Number of burn-in iterations to be discarded from the begining of the chain.</p>
</td></tr>
<tr><td><code id="get.cov.gammas_+3A_chain.id">chain.id</code></td>
<td>
<p>Identifier of the MCMC to be used. By default the first chain is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to speed-up MCMC convergence, the package contains default values of gamma covariance that were obtained from a previous run (they can be loaded using <code>data(proposal_cov_gammas_cii)</code>). However, this function allows to obtain new values and overwrite the default values by 
passing the resulting object to the <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code> function as the <code>proposal_cov_gammas</code> argument.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p>An array of size nr_countries <code class="reqn">\times</code> 3 <code class="reqn">\times</code> 3 containing values of the covariance matrix of <code class="reqn">\gamma_{ci}</code> (<code class="reqn">i=1,2,3</code>) for each country <code class="reqn">c</code>.</p>
</td></tr>
<tr><td><code>country_codes</code></td>
<td>
<p>A vector of size nr_countries. A covariance matrix <code>values[i,,]</code> corresponds to a country with the code <code>country_codes[i]</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leontine Alkema, Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
cov.gammas &lt;- get.cov.gammas(sim.dir=sim.dir, burnin=0)
m &lt;- run.tfr.mcmc(nr.chains=1, iter=10, proposal_cov_gammas=cov.gammas, verbose=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='get.est.model'>
Accessing estimated bias and standard deviations
</h2><span id='topic+get.bias.model'></span><span id='topic+get.std.model'></span><span id='topic+tfr.bias.sd'></span>

<h3>Description</h3>

<p>Functions for obtaining bias and standard deviation of the estimated models as well as the model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.bias.sd(mcmc.list = NULL, country = NULL, sim.dir = NULL, ...)
get.bias.model(mcmc.list = NULL, country = NULL, sim.dir = NULL, ...)
get.std.model(mcmc.list = NULL, country = NULL, sim.dir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.est.model_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> corresponding to Phase II MCMCs. If it is <code>NULL</code>, the object is loaded from the directory given by <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="get.est.model_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="get.est.model_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. Only used if <code>mcmc.list</code> is not given.</p>
</td></tr>
<tr><td><code id="get.est.model_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>get.bias.model</code> and <code>get.std.model</code> are used to obtain the model fit for estimated bias and standard deviation, respectively, when uncertainty about input data is taken into account. These are used in the MCMC steps stored in <code>mcmc.list</code>. Function <code>tfr.bias.sd</code> combines both infos into one object.
</p>


<h3>Value</h3>

<p>Functions <code>get.bias.model</code> and <code>get.std.model</code> return a list with
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p><code>lm</code> object corresponding to the linear model used to estimate the bias (in case of <code>get.bias.model</code>) and standard deviation (in case of <code>get.std.model</code>).</p>
</td></tr>
<tr><td><code>table</code></td>
<td>
<p><code>data.frame</code> object storing the bias/standard deviation of all possible combinations in the raw data sets for the given country.</p>
</td></tr>
</table>
<p>Function <code>tfr.bias.sd</code> consolidates these items into a single list where the elements are <code>model_bias</code>, <code>model_sd</code> and <code>table</code>.
</p>


<h3>Author(s)</h3>

<p>Peiran Liu, Hana Sevcikova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
mcmc.set &lt;- run.tfr.mcmc(nr.chains = 1, iter = 10, 
    output.dir = sim.dir, uncertainty = TRUE)
tfr.bias.sd(mcmc.set, "Nigeria")
unlink(sim.dir, recursive = TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='get.regtfr.prediction'>
Accessing Subnational Prediction Objects
</h2><span id='topic+get.regtfr.prediction'></span>

<h3>Description</h3>

<p>Retrieve subnational (regional) prediction results produced by <code><a href="#topic+tfr.predict.subnat">tfr.predict.subnat</a></code>, either for one country or for all available countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.regtfr.prediction(sim.dir, country = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.regtfr.prediction_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Simulation directory of the subnational predictions. It corresponds to the argument <code>output.dir</code> in <code><a href="#topic+tfr.predict.subnat">tfr.predict.subnat</a></code>.
</p>
</td></tr>
<tr><td><code id="get.regtfr.prediction_+3A_country">country</code></td>
<td>
<p>Numerical country code. If it is not given, all available subnational predictions are retrieved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictions for country <code class="reqn">x</code> are assumed to be stored in &ldquo;<code>sim.dir</code>/subnat/c<code class="reqn">x</code>&rdquo;.
</p>


<h3>Value</h3>

<p>If argument <code>country</code> is given, the function returns an object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>. If it is <code>NULL</code>, it returns a list of such objects. Names of the list items are the country codes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tfr.predict.subnat">tfr.predict.subnat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subnational example data
my.subtfr.file &lt;- file.path(find.package("bayesTFR"), 'extdata', 'subnational_tfr_template.txt')
subtfr &lt;- read.delim(my.subtfr.file, check.names=FALSE, stringsAsFactor=FALSE)
countries &lt;- unique(subtfr[, c("country_code", "country")])

# Directory with national projections (contains 30 trajectories for each country)
nat.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")

# Subnational projections for all three countries ()
subnat.dir &lt;- tempfile()
tfr.predict.subnat(countries$country_code, my.tfr.file=my.subtfr.file,
    sim.dir=nat.dir, output.dir=subnat.dir, start.year=2013)
    
# Retrieve results for all countries
preds &lt;- get.regtfr.prediction(subnat.dir)
names(preds)

# View tables of subregions for each country
for(i in 1:nrow(countries)) {
  cat("\n\n", countries$country[i], "\n")
  print(get.countries.table(preds[[as.character(countries$country_code[i])]]))
}
# Quantiles for individual subregions
tfr.trajectories.table(preds[["218"]], "Bolivar")

# Retrieve results for one country
pred &lt;- get.regtfr.prediction(subnat.dir, 218)
tfr.trajectories.plot(pred, "Loja")

# cleanup
unlink(subnat.dir)

# See more examples in ?tfr.predict.subnat
</code></pre>

<hr>
<h2 id='get.tfr.convergence'>
Accessing a Convergence Object
</h2><span id='topic+get.tfr.convergence'></span><span id='topic+get.tfr.convergence.all'></span><span id='topic+get.tfr3.convergence'></span><span id='topic+get.tfr3.convergence.all'></span>

<h3>Description</h3>

<p>The function loads objects of class <code><a href="#topic+bayesTFR.convergence">bayesTFR.convergence</a></code> from disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tfr.convergence(sim.dir = file.path(getwd(), "bayesTFR.output"), 
    thin=80, burnin = 2000)
	
get.tfr.convergence.all(sim.dir = file.path(getwd(), "bayesTFR.output"))

get.tfr3.convergence(sim.dir = file.path(getwd(), "bayesTFR.output"), 
    thin=60, burnin = 10000)
	
get.tfr3.convergence.all(sim.dir = file.path(getwd(), "bayesTFR.output"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tfr.convergence_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Simulation directory used for computing the diagnostics.</p>
</td></tr>
<tr><td><code id="get.tfr.convergence_+3A_thin">thin</code></td>
<td>
<p>Thinning interval used with this diagnostics.</p>
</td></tr>
<tr><td><code id="get.tfr.convergence_+3A_burnin">burnin</code></td>
<td>
<p>Burnin used for computing the diagnostics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>get.tfr.convergence</code> loads an object of class <code><a href="#topic+bayesTFR.convergence">bayesTFR.convergence</a></code> for the specific <code>thin</code> and <code>burnin</code> generated for Phase II MCMCs. Function <code>get.tfr.convergence.all</code> loads all Phase II <code><a href="#topic+bayesTFR.convergence">bayesTFR.convergence</a></code> objects available for <code>sim.dir</code>. Functions <code>get.tfr3.convergence</code> and <code>get.tfr3.convergence.all</code> do the same thing for Phase III MCMCs.
</p>


<h3>Value</h3>

<p><code>get.tfr.convergence</code> and <code>get.tfr3.convergence</code> return an object of class <code><a href="#topic+bayesTFR.convergence">bayesTFR.convergence</a></code>; <br />
<code>get.tfr.convergence.all</code> and <code>get.tfr3.convergence.all</code> return a list of objects of class <code><a href="#topic+bayesTFR.convergence">bayesTFR.convergence</a></code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesTFR.convergence">bayesTFR.convergence</a></code>, <code><a href="#topic+summary.bayesTFR.convergence">summary.bayesTFR.convergence</a></code>.
</p>

<hr>
<h2 id='get.tfr.estimation'>
Get Past TFR Estimation
</h2><span id='topic+get.tfr.estimation'></span>

<h3>Description</h3>

<p>Get past TFR estimation, including trajectories and quantiles if required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tfr.estimation(mcmc.list = NULL, country = NULL, 
    sim.dir = NULL, burnin = 0, thin = 1, probs = NULL, adjust = TRUE,
    country.code = deprecated(), ISO.code = deprecated())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tfr.estimation_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> corresponding Phase II MCMCs. If it is <code>NULL</code>, the object is loaded from the directory given by <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="get.tfr.estimation_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="get.tfr.estimation_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. Only used if <code>mcmc.list</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get.tfr.estimation_+3A_burnin">burnin</code></td>
<td>
<p>Burn-in for getting trajectories and quantiles. A positive burn-in <code class="reqn">x</code> will remove first <code class="reqn">x</code> iterations from each chain.</p>
</td></tr>
<tr><td><code id="get.tfr.estimation_+3A_thin">thin</code></td>
<td>
<p>Thin for getting trajectories and quantiles. Thinning level <code class="reqn">x</code> greater than 1 will store one iteration per <code class="reqn">x</code> samples.</p>
</td></tr>
<tr><td><code id="get.tfr.estimation_+3A_probs">probs</code></td>
<td>
<p>A vector of numbers between <code class="reqn">[0,1]</code> specifying which estimation quantiles should be outputted. If it is set to <code>NULL</code> no quantiles are returned. It can be set to the word &ldquo;mean&rdquo;, in which case the estimation mean is outputted.</p>
</td></tr>
<tr><td><code id="get.tfr.estimation_+3A_adjust">adjust</code></td>
<td>
<p>Logical indicating whether the adjusted median and trajectories should be returned.</p>
</td></tr>
<tr><td><code id="get.tfr.estimation_+3A_country.code">country.code</code>, <code id="get.tfr.estimation_+3A_iso.code">ISO.code</code></td>
<td>
<p>Deprecated arguments. Use argument <code>country</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to obtain the TFR estimation trajectories as well as corresponding quantiles if the <code>mcmc.list</code> has been obtained while taking account for uncertainty about the past, i.e. <code>uncertainty=TRUE</code> in <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>. Quantiles or the mean are included in the results if <code>probs</code> is not <code>NULL</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>tfr_table</code></td>
<td>
<p>Table storing the trajectories. It is a matrix with rows equal to number of trajectories, and column equal to number of time periods.</p>
</td></tr>
<tr><td><code>country.obj</code></td>
<td>
<p>A list storing information about the country which the trajectories and quantiles correspond to. It corresponds to the output of <code><a href="#topic+get.country.object">get.country.object</a></code>.</p>
</td></tr>
<tr><td><code>tfr_quantile</code></td>
<td>
<p>Optional. A data.table object, storing the quantiles or the mean of estimates for each time period as specified by the <code>probs</code> argument. The time periods are contained in the <code>year</code> column.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peiran Liu, Hana Sevcikova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
m &lt;- run.tfr.mcmc(nr.chains = 1, iter = 10, output.dir = sim.dir, uncertainty = TRUE)
get.tfr.estimation(m, "Nigeria", probs = c(0.1, 0.5, 0.9))
unlink(sim.dir, recursive = TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='get.tfr.mcmc'>
Accessing MCMC Results
</h2><span id='topic+get.tfr.mcmc'></span><span id='topic+has.tfr.mcmc'></span><span id='topic+tfr.mcmc'></span><span id='topic+tfr.mcmc.list'></span><span id='topic+get.tfr3.mcmc'></span><span id='topic+has.tfr3.mcmc'></span>

<h3>Description</h3>

<p>The function <code>get.tfr.mcmc</code> retrieves results of an MCMC simulation of Phase II and creates an object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code>. Function <code>has.tfr.mcmc</code> checks the existence of such results. Functions <code>get.tfr3.mcmc</code> and <code>has.tfr3.mcmc</code> do the same for Phase III MCMCs. Function <code>tfr.mcmc</code> extracts a single chain and <code>tfr.mcmc.list</code> extracts several or all chains from the simulation results. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tfr.mcmc(sim.dir = file.path(getwd(), "bayesTFR.output"), 
    chain.ids = NULL, low.memory = TRUE, burnin = 0, verbose = FALSE)

has.tfr.mcmc(sim.dir)

get.tfr3.mcmc(sim.dir = file.path(getwd(), "bayesTFR.output"), ...)

has.tfr3.mcmc(sim.dir)

tfr.mcmc(mcmc.set, chain.id)

tfr.mcmc.list(mcmc.set, chain.ids=NULL)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tfr.mcmc_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory where the simulation results are stored.</p>
</td></tr>
<tr><td><code id="get.tfr.mcmc_+3A_chain.ids">chain.ids</code></td>
<td>
<p>Chain identifiers in case only specific chains should be included in the resulting object. By default, all available chains are included.</p>
</td></tr>
<tr><td><code id="get.tfr.mcmc_+3A_low.memory">low.memory</code></td>
<td>
<p>If <code>FALSE</code> full MCMC traces are loaded into memory.</p>
</td></tr>
<tr><td><code id="get.tfr.mcmc_+3A_burnin">burnin</code></td>
<td>
<p>Burnin used for loading traces. Only relevant, if <code>low.memory=FALSE</code>.</p>
</td></tr>
<tr><td><code id="get.tfr.mcmc_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="get.tfr.mcmc_+3A_chain.id">chain.id</code></td>
<td>
<p>Chain identifier.</p>
</td></tr>
<tr><td><code id="get.tfr.mcmc_+3A_mcmc.set">mcmc.set</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code>.</p>
</td></tr>
<tr><td><code id="get.tfr.mcmc_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>get.tfr.mcmc</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>get.tfr.mcmc</code> is an accessor of results generated using <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code> and <code><a href="#topic+continue.tfr.mcmc">continue.tfr.mcmc</a></code>. Function <code>get.tfr3.mcmc</code> can be used to access results generated using <code><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a></code> and <code><a href="#topic+continue.tfr3.mcmc">continue.tfr3.mcmc</a></code>. 
</p>


<h3>Value</h3>

<p><code>get.tfr.mcmc</code> and <code>get.tfr3.mcmc</code> return an object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code>. <code>has.tfr.mcmc</code> and <code>has.tfr3.mcmc</code> return a logical value. <code>tfr.mcmc</code> returns an object of class <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code>, and <code>tfr.mcmc.list</code> returns a list of <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code> objects.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
m &lt;- get.tfr.mcmc(sim.dir)
summary(m)

# summary of the single chains
for(mc in tfr.mcmc.list(m)) print(summary(mc))
</code></pre>

<hr>
<h2 id='get.tfr.parameter.traces'>
Accessing MCMC Parameter Traces
</h2><span id='topic+get.tfr.parameter.traces'></span><span id='topic+get.tfr.parameter.traces.cs'></span><span id='topic+get.tfr3.parameter.traces'></span><span id='topic+get.tfr3.parameter.traces.cs'></span>

<h3>Description</h3>

<p>Functions for accessing traces of the MCMC parameters, either country-independent or country-specific. Functions <code>get.tfr.parameter.traces</code> and <code>get.tfr.parameter.traces.cs</code> access Phase II MCMCs; Functions <code>get.tfr3.parameter.traces</code> and <code>get.tfr3.parameter.traces.cs</code> access Phase III MCMCs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tfr.parameter.traces(mcmc.list, par.names = tfr.parameter.names(), 
    burnin = 0, thinning.index = NULL, thin = NULL)
    
get.tfr.parameter.traces.cs(mcmc.list, country.obj, 
    par.names=tfr.parameter.names.cs(), 
    burnin=0, thinning.index=NULL, thin=NULL)
    
get.tfr3.parameter.traces(mcmc.list, par.names = tfr3.parameter.names(), ...)
    
get.tfr3.parameter.traces.cs(mcmc.list, country.obj, 
    par.names=tfr3.parameter.names.cs(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tfr.parameter.traces_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code> objects.</p>
</td></tr>
<tr><td><code id="get.tfr.parameter.traces_+3A_country.obj">country.obj</code></td>
<td>
<p>Country object list (see <code><a href="#topic+get.country.object">get.country.object</a></code>).</p>
</td></tr>
<tr><td><code id="get.tfr.parameter.traces_+3A_par.names">par.names</code></td>
<td>
<p>Names of country-independent parameters (in case of <code>get.tfr.parameter.traces</code>) or country-specific parameters (in case of <code>get.tfr.parameter.traces.cs</code>) to be included.</p>
</td></tr>
<tr><td><code id="get.tfr.parameter.traces_+3A_burnin">burnin</code></td>
<td>
<p>Burnin indicating how many iterations should be removed from the beginning of each chain.</p>
</td></tr>
<tr><td><code id="get.tfr.parameter.traces_+3A_thinning.index">thinning.index</code></td>
<td>
<p>Index of the traces for thinning. If it is <code>NULL</code>, <code>thin</code> is used. <code>thinning.index</code> does not include <code>burnin</code>. For example, if there are two MCMC chains of length 1000, <code>burnin=200</code> and we want a sample of length 400, then the value should be <code>thinning.index=seq(1,1600, length=400)</code>.</p>
</td></tr>
<tr><td><code id="get.tfr.parameter.traces_+3A_thin">thin</code></td>
<td>
<p>Alternative to <code>thinning.index</code>. In the above example it would be <code>thin=4</code>.</p>
</td></tr>
<tr><td><code id="get.tfr.parameter.traces_+3A_...">...</code></td>
<td>
<p>Arguments passed to underlying functions (i.e. to <code>get.tfr.parameter.traces</code> or <code>get.tfr.parameter.traces.cs</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All functions return a matrix with columns being the parameters and rows being the MCMC values, attached to one another in case of multiple chains. <code>get.tfr.parameter.traces</code> and <code>get.tfr3.parameter.traces</code> return country-independent parameters, <code>get.tfr.parameter.traces.cs</code> and <code>get.tfr3.parameter.traces.cs</code> return country-specific parameters.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coda.list.mcmc">coda.list.mcmc</a></code> for another way of retrieving parameter traces. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
m &lt;- get.tfr.mcmc(sim.dir)
tfr.values &lt;- get.tfr.parameter.traces(m$mcmc.list, burnin=10, par.names="sigma0")
## Not run: 
hist(tfr.values, main=colnames(tfr.values))

## End(Not run)
tfr.values.cs &lt;- get.tfr.parameter.traces.cs(m$mcmc.list, 
                    get.country.object("Canada", meta=m$meta),
                    burnin=10, par.names="Triangle_c4")
## Not run: 
hist(tfr.values.cs, main=colnames(tfr.values.cs))

## End(Not run)
</code></pre>

<hr>
<h2 id='get.tfr.prediction'>
Accessing a Prediction Object
</h2><span id='topic+get.tfr.prediction'></span><span id='topic+has.tfr.prediction'></span><span id='topic+available.tfr.predictions'></span>

<h3>Description</h3>

<p>Function <code>get.tfr.prediction</code> retrieves results of a prediction and creates an object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>. Function <code>has.tfr.prediction</code> checks an existence of such results. Function <code>available.tfr.predictions</code> lists predictions available in the given simulation directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tfr.prediction(mcmc = NULL, sim.dir = NULL, mcmc.dir = NULL,
                    subdir = "predictions")

has.tfr.prediction(mcmc = NULL, sim.dir = NULL, subdir = "predictions")

available.tfr.predictions(mcmc = NULL, sim.dir = NULL, full.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tfr.prediction_+3A_mcmc">mcmc</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> used to make the prediction. It must correspond to a Phase II MCMC. If it is <code>NULL</code>, the prediction is loaded from directory given by <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="get.tfr.prediction_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory where the prediction is stored.  It should correspond to the value of the <code>output.dir</code> argument used in the <code><a href="#topic+tfr.predict">tfr.predict</a></code> function.  Only relevant if <code>mcmc</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get.tfr.prediction_+3A_mcmc.dir">mcmc.dir</code></td>
<td>
<p>Optional argument to be used only in a special case when the mcmc object contained in the prediction object was estimated in different directory than in the one to which it points to (for example due to moving or renaming the original directory). The argument causes that the mcmc is redirected to the given directory. It can be set to <code>NA</code> if no loading of the mcmc object is desired.</p>
</td></tr>
<tr><td><code id="get.tfr.prediction_+3A_subdir">subdir</code></td>
<td>
<p>Subdirectory of <code>sim.dir</code> for this particular prediction.</p>
</td></tr>
<tr><td><code id="get.tfr.prediction_+3A_full.names">full.names</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the directory names are given as full paths, otherwise (default) only the base names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mcmc</code> is not <code>NULL</code>, the search directory is set to <code>mcmc$meta$output.dir</code>. This approach assumes that the prediction was stored in the same directory as the MCMC simulation, i.e. the <code>output.dir</code> argument of the <code><a href="#topic+tfr.predict">tfr.predict</a></code> function was set to <code>NULL</code>. If it is not the case, the argument <code>mcmc.dir</code> should be used.
</p>
<p>Usually, all predictions are stored in the subdirectory &ldquo;predictions&rdquo; of the simulation directory. If the subdirectory has a different name, the argument <code>subdir</code> should be used. This allows to keep multiple predictions in one (MCMC) simulation directory.
</p>
<p>The function <code>available.tfr.predictions</code> can be used to view all available predictions in the simulation directory.  
</p>


<h3>Value</h3>

<p>Function <code>has.tfr.prediction</code> returns a logical indicating if a prediction exists for the given <code>mcmc</code>. 
</p>
<p>Function <code>available.tfr.predictions</code> returns a vector of directory names containing TFR predictions. 
</p>
<p>Function <code>get.tfr.prediction</code> returns an
object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>, <code><a href="#topic+tfr.predict">tfr.predict</a></code>, <code><a href="#topic+summary.bayesTFR.prediction">summary.bayesTFR.prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
pred &lt;- get.tfr.prediction(sim.dir=sim.dir)
summary(pred, country="Canada")
</code></pre>

<hr>
<h2 id='get.tfr.trajectories'>
Accessing TFR Trajectories
</h2><span id='topic+get.tfr.trajectories'></span>

<h3>Description</h3>

<p>Function for accessing TFR trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tfr.trajectories(tfr.pred, country)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tfr.trajectories_+3A_tfr.pred">tfr.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="get.tfr.trajectories_+3A_country">country</code></td>
<td>
<p>Name or code of a country. The code can be either numeric or ISO-2 or ISO-3 characters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function loads TFR trajectories for the given country from disk, offsets it if needed (see <code><a href="#topic+tfr.median.shift">tfr.median.shift</a></code>) and returns it as a matrix.
</p>


<h3>Value</h3>

<p>Array of size number of projection periods (including the present year) times the number of trajectories. The row names correspond to the mid-years of the prediction periods.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>, <code><a href="#topic+get.tfr.prediction">get.tfr.prediction</a></code>, <code><a href="#topic+tfr.trajectories.table">tfr.trajectories.table</a></code>, <code><a href="#topic+tfr.median.shift">tfr.median.shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output") 
pred &lt;- get.tfr.prediction(sim.dir=sim.dir)
get.tfr.trajectories(pred, "Germany")
</code></pre>

<hr>
<h2 id='get.thinned.tfr.mcmc'>
Creating and Accessing Thinned MCMCs
</h2><span id='topic+get.thinned.tfr.mcmc'></span><span id='topic+create.thinned.tfr.mcmc'></span>

<h3>Description</h3>

<p>The function <code>get.thinned.tfr.mcmc</code> accesses 
a thinned and burned version of the given Phase II MCMC set. <code>create.thinned.tfr.mcmc</code> creates or updates such a set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.thinned.tfr.mcmc(mcmc.set, thin = 1, burnin = 0)

create.thinned.tfr.mcmc(mcmc.set, thin = 1, burnin = 0, 
    output.dir = NULL, verbose = TRUE, uncertainty = FALSE,
    update.with.countries = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.thinned.tfr.mcmc_+3A_mcmc.set">mcmc.set</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> of Phase II.</p>
</td></tr>
<tr><td><code id="get.thinned.tfr.mcmc_+3A_thin">thin</code>, <code id="get.thinned.tfr.mcmc_+3A_burnin">burnin</code></td>
<td>
<p>Thinning interval and burnin used for creating or identifying the thinned object.</p>
</td></tr>
<tr><td><code id="get.thinned.tfr.mcmc_+3A_output.dir">output.dir</code></td>
<td>
<p>Output directory. It is only used if the output goes to a non-standard directory.</p>
</td></tr>
<tr><td><code id="get.thinned.tfr.mcmc_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="get.thinned.tfr.mcmc_+3A_uncertainty">uncertainty</code></td>
<td>
<p>If users want to save the thinned estimated TFR in the new mcmc object, this parameter should be set <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get.thinned.tfr.mcmc_+3A_update.with.countries">update.with.countries</code></td>
<td>
<p>If an existing set is to be updated, this should be a vector of country indices for the update.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>create.thinned.tfr.mcmc</code> is called from <code><a href="#topic+tfr.predict">tfr.predict</a></code> and thus, the resulting object contains exactly the same MCMCs used for generating projections. In addition, it can be also called from <code><a href="#topic+tfr.diagnose">tfr.diagnose</a></code> if desired, so that the projection process can re-use such a set that leads to a convergence. 
</p>
<p>The thinning is done as follows: The given <code>burnin</code> is removed from the beginning of each chain in the original MCMC set. Then each chain is thinned by <code>thin</code> using equal spacing and all chains are collapsed into one single chain per parameter. They are stored in the main simulation directory under the name &lsquo;<span class="file">thinned_mcmc_<em>t</em>_<em>b</em></span>&rsquo; where <em>t</em> is the value  of <code>thin</code> and <em>b</em> the value of <code>burnin</code>.   
</p>
<p>If <code>uncertainty=TRUE</code>, the estimated TFR is thinned and saved as well.
</p>


<h3>Value</h3>

<p>Both functions return an object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code>. <code>get.thinned.tfr.mcmc</code> returns <code>NULL</code> if such object does not exist.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code>, <code><a href="#topic+tfr.predict">tfr.predict</a></code>, <code><a href="#topic+tfr.diagnose">tfr.diagnose</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
m &lt;- run.tfr.mcmc(nr.chains=2, iter=30, seed=1, output.dir=sim.dir, verbose=TRUE)
tfr.predict(m, burnin=15, use.tfr3=FALSE) # creates thinned MCMCs
mb &lt;- get.thinned.tfr.mcmc(m, thin=1, burnin=15)
summary(mb, meta.only=TRUE) # length 30 = 2chains x (30-15)iters.
unlink(sim.dir, recursive=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='get.total.iterations'>
Total Number of Iterations
</h2><span id='topic+get.total.iterations'></span><span id='topic+get.stored.mcmc.length'></span>

<h3>Description</h3>

<p>Function <code>get.total.iterations</code> gives the total number of iterations of MCMCs summed over chains whith burnin being subtracted from each chain. Function <code>get.stored.mcmc.length</code> gives the total length of the MCMCs stored on disk minus those iterations that correspond to burnin. Result of the latter will be different from the former only if the MCMCs were run with value of <code>thin</code> larger than one. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.total.iterations(mcmc.list, burnin = 0)

get.stored.mcmc.length(mcmc.list, burnin = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.total.iterations_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code> objects.</p>
</td></tr>
<tr><td><code id="get.total.iterations_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be subtracted from each chain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
mcmc.set &lt;- get.tfr.mcmc(sim.dir=sim.dir)
get.total.iterations(mcmc.set$mcmc.list) # 60=1chain x 60iters
get.total.iterations(mcmc.set$mcmc.list, burnin=20) # 40=1x(60-20)

## Not run: 
sim.dir &lt;- tempfile()
m &lt;- run.tfr.mcmc(iter=10, nr.chains=2, output.dir=sim.dir, thin=5, verbose=TRUE)
get.total.iterations(m$mcmc.list) # 20=2x10
get.stored.mcmc.length(m$mcmc.list) # 6=2x3
unlink(sim.dir, recursive=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='include'>
Inclusion Codes
</h2><span id='topic+include'></span><span id='topic+include_2010'></span><span id='topic+include_2012'></span><span id='topic+include_2015'></span><span id='topic+include_2017'></span><span id='topic+include_2019'></span><span id='topic+include_2022'></span><span id='topic+include_2024'></span>

<h3>Description</h3>

<p>Data sets containing codes that determine which countries are to be included into a simulation or/and projections. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(include_2024)
data(include_2022)
data(include_2019)
data(include_2017)
data(include_2015)
data(include_2012)
data(include_2010)
</code></pre>


<h3>Format</h3>

<p>Data frames containing one record per country or region. It has the following variables:
</p>

<dl>
<dt><code>country_code</code></dt><dd><p>Numerical Location Code (3-digit codes following ISO 3166-1 numeric standard) - see <a href="https://en.wikipedia.org/wiki/ISO_3166-1_numeric">https://en.wikipedia.org/wiki/ISO_3166-1_numeric</a>.</p>
</dd>
<dt>include_code</dt><dd><p>Entries for which <code>include_code=2</code> are included in the MCMC estimation of the hyperparameters of the model. Entries for which <code>include_code</code> is 1 or 2 are included in the prediction. Entries with 0 are excluded from both.</p>
</dd></dl>



<h3>Details</h3>

<p>In a simulation, an <code>include_*</code> dataset is selected that corresponds to the given <code>wpp.year</code> passed to the function <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>. It is merged with a <code><a href="wpp2019.html#topic+tfr">tfr</a></code> dataset from the corresponding wpp package using the <code>country_code</code> column. Thus, the country entries in this dataset should correspond to entries in the <code>tfr</code> dataset.
</p>
<p>The package contains also a dataset called &lsquo;<span class="file">my_tfr_template</span>&rsquo; (in &lsquo;<span class="file">extdata</span>&rsquo; directory) which is a template for user-specified TFR time series. It has the same structure as the <code><a href="wpp2019.html#topic+tfr">tfr</a></code> dataset, except that most of the columns are optional. The only required column is <code>country_code</code> (see description of the argument <code>my.tfr.file</code> in <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>).
</p>


<h3>Source</h3>

<p>Data provided by the United Nations Population Division.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(include_2019)
head(include_2019)
</code></pre>

<hr>
<h2 id='run.tfr.mcmc'>
Running Markov Chain Monte Carlo for Parameters of Total Fertility Rate in Phase II
</h2><span id='topic+run.tfr.mcmc'></span><span id='topic+continue.tfr.mcmc'></span><span id='topic+bayesTFR.mcmc.set'></span>

<h3>Description</h3>

<p>Runs (or continues running) MCMCs for simulating the total fertility rate of all countries of the world (phase II), using a Bayesian hierarchical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.tfr.mcmc(nr.chains = 3, iter = 62000, 
    output.dir = file.path(getwd(), "bayesTFR.output"), 
    thin = 1, replace.output = FALSE, annual = FALSE, uncertainty = FALSE, 
    start.year = 1950, present.year = 2020, wpp.year = 2019, 
    my.tfr.file = NULL, my.locations.file = NULL, my.tfr.raw.file = NULL, 
    use.wpp.data = TRUE, ar.phase2 = FALSE, buffer.size = 100, 
    raw.outliers = c(-2, 1),
    U.c.low = 5.5, U.up = 8.8, U.width = 3,
    mean.eps.tau0 = -0.25, sd.eps.tau0 = 0.4, nu.tau0 = 2, 
    Triangle_c4.low = 1, Triangle_c4.up = 2.5, 
    Triangle_c4.trans.width = 2,
    Triangle4.0 = 0.3, delta4.0 = 0.8, nu4 = 2,
    S.low = 3.5, S.up = 6.5, S.width = 0.5, 
    a.low = 0, a.up = 0.2, a.width = 0.02, 
    b.low = a.low, b.up = a.up, b.width = 0.05, 
    sigma0.low = if (annual) 0.0045 else 0.01, sigma0.up = 0.6,  
    sigma0.width = 0.1, sigma0.min = 0.04, 
    const.low = 0.8, const.up = 2, const.width = 0.3, 
    d.low = 0.05, d.up = 0.5, d.trans.width = 1, 
    chi0 = -1.5, psi0 = 0.6, nu.psi0 = 2, 
    alpha0.p = c(-1, 0.5, 1.5), delta0 = 1, nu.delta0 = 2, 
    dl.p1 = 9, dl.p2 = 9, phase3.parameter=NULL,
    S.ini = NULL, a.ini = NULL, b.ini = NULL, sigma0.ini = NULL, 
    Triangle_c4.ini = NULL, const.ini = NULL, gamma.ini = 1, 
    phase3.starting.values = NULL, proposal_cov_gammas = NULL, 
    iso.unbiased = NULL, covariates = c("source", "method"), cont_covariates = NULL, 
    source.col.name="source", seed = NULL, parallel = FALSE, nr.nodes = nr.chains, 
    save.all.parameters = FALSE, compression.type = 'None',
    auto.conf = list(max.loops = 5, iter = 62000, iter.incr = 10000, 
        nr.chains = 3, thin = 80, burnin = 2000),
    verbose = FALSE, verbose.iter = 10, ...)
		
continue.tfr.mcmc(iter, chain.ids = NULL, 
    output.dir = file.path(getwd(), "bayesTFR.output"), 
    parallel = FALSE, nr.nodes = NULL, auto.conf = NULL,
    verbose = FALSE, verbose.iter = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.tfr.mcmc_+3A_nr.chains">nr.chains</code></td>
<td>
<p>Number of MCMC chains to run.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_iter">iter</code></td>
<td>
<p>Number of iterations to run in each chain. In addition to a single value, it can have the value &lsquo;auto&rsquo; in which case the function runs for the number of iterations given in the <code>auto.conf</code> list (see below), then checks if the MCMCs converged (using the <code>auto.conf</code> settings). If it did not converge, the procedure is repeated until convergence is reached or the number of repetition exceeded <code>auto.conf$max.loops</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory which the simulation output should be written into.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_thin">thin</code></td>
<td>
<p>Thinning interval between consecutive observations to be stored on disk.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_replace.output">replace.output</code></td>
<td>
<p>If <code>TRUE</code>, existing outputs in <code>output.dir</code> will be replaced by results of this simulation.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_annual">annual</code></td>
<td>
<p>If <code>TRUE</code>, the model will be trained based on annual TFR data.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the model described in Liu and Raftery(2020) which takes into account uncertainty about the past TFR observations is used. It will take the observations from <code><a href="#topic+rawTFR">rawTFR</a></code> or from a file given by <code>my.tfr.raw.file</code>, estimate the distribution of these observations with respect to the true TFR. Then instead of treating the observed data as true data, it assumes the true TFR is unknown and include an extra step for estimating past TFR.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_use.wpp.data">use.wpp.data</code></td>
<td>
<p>Logical indicating if default WPP data should be used, i.e. if <code>my.tfr.file</code> will be matched with the WPP data in terms of time periods and locations. If <code>FALSE</code>, it is assumed that the <code>my.tfr.file</code> contains all locations and time periods to be included in the simulation.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_ar.phase2">ar.phase2</code></td>
<td>
<p>Logical where <code>TRUE</code> implies that the autoregressive component on the residual (for Phase II) is considered as a global parameter. Only used if <code>annual</code> is <code>TRUE</code>. See details below.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_start.year">start.year</code></td>
<td>
<p>Start year for using historical data.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_present.year">present.year</code></td>
<td>
<p>End year for using historical data.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_wpp.year">wpp.year</code></td>
<td>
<p>Year for which WPP data is used. The functions loads a package called <span class="pkg">wpp</span><code class="reqn">x</code> where <code class="reqn">x</code> is the <code>wpp.year</code> and uses the <code>tfr*</code> datasets.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_my.tfr.file">my.tfr.file</code></td>
<td>
<p>File name containing user-specified TFR time series for one or more countries. See Details below.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_my.locations.file">my.locations.file</code></td>
<td>
<p>File name containing user-specified locations. See Details below.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_my.tfr.raw.file">my.tfr.raw.file</code></td>
<td>
<p>File name of the raw TFR, used when <code>uncertainty</code> is <code>TRUE</code>. See details below.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_buffer.size">buffer.size</code></td>
<td>
<p>Buffer size (in number of iterations) for keeping data in the memory. The smaller the <code>buffer.size</code> the more often will the process access the hard disk and thus, the slower the run. On the other hand, the smaller the <code>buffer.size</code> the less data will be lost in case of failure.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_raw.outliers">raw.outliers</code></td>
<td>
<p>Vector of size two giving the maximum annual decrease and increase of raw TFR change, respectively. The default values mean that any raw TFR data that decrease more than 2 or increase more than 1 in one year are considered as outliers.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_u.c.low">U.c.low</code>, <code id="run.tfr.mcmc_+3A_u.up">U.up</code></td>
<td>
<p>Lower and upper bound of the parameter <code class="reqn">U_c</code>, the start level of the fertility transition. The lower bound is set for each country as the maximum of <code>U.c.low</code> and the minimum of historical TFR for that country.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_u.width">U.width</code></td>
<td>
<p>Width for slice sampling used when updating the <code class="reqn">U_c</code> parameter.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_mean.eps.tau0">mean.eps.tau0</code>, <code id="run.tfr.mcmc_+3A_sd.eps.tau0">sd.eps.tau0</code></td>
<td>
<p>Mean and standard deviation of the prior distribution of <code class="reqn">m_{\tau}</code> which is the mean of the distortion terms <code class="reqn">\epsilon_{c,\tau}</code> in start periods <code class="reqn">\tau_c</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_nu.tau0">nu.tau0</code></td>
<td>
<p>The shape parameter of the prior Gamma distribution of <code class="reqn">1/s_{\tau}^2</code> is <code>nu.tau0</code>/2. <code class="reqn">s_{\tau}</code> is standard deviation of the distortion terms in start periods <code class="reqn">\tau_c</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_triangle_c4.low">Triangle_c4.low</code>, <code id="run.tfr.mcmc_+3A_triangle_c4.up">Triangle_c4.up</code></td>
<td>
<p>Lower and upper bound of the <code class="reqn">\Delta_{c4}</code> parameter.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_triangle_c4.trans.width">Triangle_c4.trans.width</code></td>
<td>
<p>Width for slice sampling used when updating the logit-transformed <code class="reqn">\Delta_{c4}</code> parameter.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_triangle4.0">Triangle4.0</code>, <code id="run.tfr.mcmc_+3A_delta4.0">delta4.0</code></td>
<td>
<p>Mean and standard deviation of the prior distribution of the <code class="reqn">\Delta_4</code> parameter which is the hierarchical mean of the logit-transformed <code class="reqn">\Delta_{c4}</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_nu4">nu4</code></td>
<td>
<p>The shape parameter of the prior Gamma distribution of <code class="reqn">1/\delta_4^2</code> is <code>nu4</code>/2. <code class="reqn">\delta_4</code> is standard deviation of the logit-transformed <code class="reqn">\Delta_{c4}</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_s.low">S.low</code>, <code id="run.tfr.mcmc_+3A_s.up">S.up</code></td>
<td>
<p>Lower and upper bound of the uniform prior distribution of the <code class="reqn">S</code> parameter which is the TFR at which the distortion has maximum variance.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_s.width">S.width</code></td>
<td>
<p>Width for slice sampling used when updating the <code class="reqn">S</code> parameter.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_a.low">a.low</code>, <code id="run.tfr.mcmc_+3A_a.up">a.up</code></td>
<td>
<p>Lower and upper bound of the uniform prior distribution of the <code class="reqn">a</code> parameter which is a coefficient for linear decrease of the TFR for TFR larger than <code class="reqn">S</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_a.width">a.width</code></td>
<td>
<p>Width for slice sampling used when updating the <code class="reqn">a</code> parameter.</p>
</td></tr>  
<tr><td><code id="run.tfr.mcmc_+3A_b.low">b.low</code>, <code id="run.tfr.mcmc_+3A_b.up">b.up</code></td>
<td>
<p>Lower and upper bound of the uniform prior distribution of the <code class="reqn">b</code> parameter which is a  coefficient for linear decrease of the TFR for TFR smaller than <code class="reqn">S</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_b.width">b.width</code></td>
<td>
<p>Width for slice sampling used when updating  the <code class="reqn">b</code> parameter.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_sigma0.low">sigma0.low</code>, <code id="run.tfr.mcmc_+3A_sigma0.up">sigma0.up</code></td>
<td>
<p>Lower and upper bound of the uniform prior distribution of the <code class="reqn">\sigma_0</code> parameter. <code class="reqn">\sigma_0^2</code> is the maximum variance of the distortions at TFR equals <code class="reqn">S</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_sigma0.width">sigma0.width</code></td>
<td>
<p>Width for slice sampling used when updating the <code class="reqn">\sigma_0</code> parameter.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_sigma0.min">sigma0.min</code></td>
<td>
<p>Minimum value that <code class="reqn">\sigma_0</code> can take.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_const.low">const.low</code>, <code id="run.tfr.mcmc_+3A_const.up">const.up</code></td>
<td>
<p>Lower and upper bound of the uniform prior distribution of the <code class="reqn">c</code> parameter which is the multiplier of standard deviation of the distortions before 1975.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_const.width">const.width</code></td>
<td>
<p>Width for slice sampling used when updating the <code class="reqn">c</code> parameter.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_d.low">d.low</code>, <code id="run.tfr.mcmc_+3A_d.up">d.up</code></td>
<td>
<p>Lower and upper bound of the parameter <code class="reqn">d_c</code>, the maximum annual decrement for country <code class="reqn">c</code>. (Note that in Alkema et al. this parameter is a five-years decrement.)</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_d.trans.width">d.trans.width</code></td>
<td>
<p>Width for slice sampling used when updating the logit-transformed <code class="reqn">d_c</code> parameter.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_chi0">chi0</code>, <code id="run.tfr.mcmc_+3A_psi0">psi0</code></td>
<td>
<p>Prior mean and standard deviation of the <code class="reqn">\chi</code> parameter which is the hierarchical mean of logit-transformed maximum decline parameter <code class="reqn">d_c</code>.</p>
</td></tr> 
<tr><td><code id="run.tfr.mcmc_+3A_nu.psi0">nu.psi0</code></td>
<td>
<p>The shape parameter of the prior Gamma distribution of <code class="reqn">1/\psi^2</code> is <code>nu.psi0</code>/2. <code class="reqn">\psi</code> is the standard devation of logit-transformed maximum decline parameter <code class="reqn">d_c</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_alpha0.p">alpha0.p</code></td>
<td>
<p>Vector of prior means of the <code class="reqn">\alpha_i</code> parameters, <code class="reqn">i=1,2,3</code>. <code class="reqn">\alpha_i</code> is the hierarchical mean of <code class="reqn">\gamma_{ci}</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_delta0">delta0</code></td>
<td>
<p>Prior standard deviation of the <code class="reqn">\alpha_i</code> parameters. It is a single value, i.e. the same standard deviation is used for all <code class="reqn">i</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_nu.delta0">nu.delta0</code></td>
<td>
<p>The shape parameter of the prior Gamma distribution of <code class="reqn">1/\delta_i^2</code> is <code>nu.delta0</code>/2. <code class="reqn">\delta_i</code> is the standard deviation of <code class="reqn">\gamma_{ci}</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_dl.p1">dl.p1</code>, <code id="run.tfr.mcmc_+3A_dl.p2">dl.p2</code></td>
<td>
<p>Values of the parameters <code class="reqn">p_1</code> and <code class="reqn">p_2</code> of the double logistic function.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_phase3.parameter">phase3.parameter</code></td>
<td>
<p>When <code>uncertainty=TRUE</code>, we need to combine the MCMC process for Phase II and Phase III together. This parameter is used to provide a list for phase3 initial ranges, such as <code>mu.prior.range</code>. If the input is <code>NULL</code>, the default values will be used.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_s.ini">S.ini</code></td>
<td>
<p>Initial value for the <code class="reqn">S</code> parameter. It can be a single value or an array of the size <code>nr.chains</code>.  By default, if <code>nr.chains</code> is 1, it is the middle point of the interval [<code>S.low, S.up</code>]. Otherwise, it is equally spaced distributed between <code>S.low</code> and <code>S.up</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_a.ini">a.ini</code></td>
<td>
<p>Initial value for the <code class="reqn">a</code> parameter. It can be a single value or an array of the size <code>nr.chains</code>.  By default, if <code>nr.chains</code> is 1, it is the middle point of the interval [<code>a.low, a.up</code>]. Otherwise, it is equally spaced distributed between <code>a.low</code> and <code>a.up</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_b.ini">b.ini</code></td>
<td>
<p>Initial value for the <code class="reqn">b</code> parameter. It can be a single value or an array of the size <code>nr.chains</code>.  By default, if <code>nr.chains</code> is 1, it is the middle point of the interval [<code>b.low, b.up</code>]. Otherwise, it is equally spaced distributed between <code>b.low</code> and <code>b.up</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_sigma0.ini">sigma0.ini</code></td>
<td>
<p>Initial value for the <code class="reqn">\sigma_0</code> parameter. It can be a single value or an array of the size <code>nr.chains</code>.  By default, if <code>nr.chains</code> is 1, it is the middle point of the interval [<code>sigma0.low, sigma0.up</code>]. Otherwise, it is equally spaced distributed between <code>sigma0.low</code> and <code>sigma0.up</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_triangle_c4.ini">Triangle_c4.ini</code></td>
<td>
<p>Initial value for the <code class="reqn">\Delta_{c4}</code> parameter. It can be a single value or an array of the size <code>nr.chains</code>.  By default, if <code>nr.chains</code> is 1, it is the middle point of the interval [<code>Triangle_c4.low, Triangle_c4.up</code>]. Otherwise, it is equally spaced distributed between <code>Triangle_c4.low</code> and <code>Triangle_c4.up</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_const.ini">const.ini</code></td>
<td>
<p>Initial value for the <code class="reqn">c</code> parameter. It can be a single value or an array of the size <code>nr.chains</code>.  By default, if <code>nr.chains</code> is 1, it is the middle point of the interval [<code>const.low, const.up</code>]. Otherwise, it is equally spaced distributed between <code>const.low</code> and <code>const.up</code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_gamma.ini">gamma.ini</code></td>
<td>
<p>Initial value for the <code class="reqn">\gamma_c</code> parameter. The same value is used for all countries.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_phase3.starting.values">phase3.starting.values</code></td>
<td>
<p>This parameter is used to provide a list of Phase 3 initial values, such as <code>mu.ini</code> and <code>rho.ini</code> in <code><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a></code>. If the input is <code>NULL</code>, the default values will be used.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_proposal_cov_gammas">proposal_cov_gammas</code></td>
<td>
<p>Proposal for the gamma covariance matrices for each country. It should be a list with two values: <code>values</code> and <code>country_codes</code>. The structure corresponds to the object returned by the function <code><a href="#topic+get.cov.gammas">get.cov.gammas</a></code>. By default the covariance matrices are obtained using <code>data(proposal_cov_gammas_cii)</code>. This argument overwrite the defaults for countries contained the argument.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_iso.unbiased">iso.unbiased</code></td>
<td>
<p>Codes of countries for which the vital registration TFR estimates are considered unbiased. Only used if <code>uncertainty = TRUE</code>. See details below.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_covariates">covariates</code>, <code id="run.tfr.mcmc_+3A_cont_covariates">cont_covariates</code></td>
<td>
<p>Categorical and continuous features used in estimating bias and standard deviation if <code>uncertainty = TRUE</code>. See details below.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_source.col.name">source.col.name</code></td>
<td>
<p>If <code>uncertainty</code> is <code>TRUE</code> this is a column name within the given covariates that determines the data source. It is used if <code>iso.unbiased</code> is given to identify the vital registration records.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_seed">seed</code></td>
<td>
<p>Seed of the random number generator. If <code>NULL</code> no seed is set. It can be used to generate reproducible results.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_parallel">parallel</code></td>
<td>
<p>Logical determining if the simulation should run multiple chains in parallel. If it is <code>TRUE</code>, the package <span class="pkg"><a href="snowFT.html#topic+snowFT">snowFT</a></span> is required. In such a case further arguments can be passed, see description of ....</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_nr.nodes">nr.nodes</code></td>
<td>
<p>Relevant only if <code>parallel</code> is <code>TRUE</code>. It gives the number of nodes for running the simulation in parallel. By default it equals to the number of chains.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_save.all.parameters">save.all.parameters</code></td>
<td>
<p>If <code>TRUE</code>, the distortion terms <code class="reqn">\epsilon_{c,t}</code> for all <code class="reqn">t</code> are stored on disk, otherwise not.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_compression.type">compression.type</code></td>
<td>
<p>One of &lsquo;None&rsquo;, &lsquo;gz&rsquo;, &lsquo;xz&rsquo;, &lsquo;bz&rsquo;, determining type of a compression of the MCMC files. Important: Do not use this option for a long MCMC simulation as this tends to cause very long run times due to slow reading!</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_auto.conf">auto.conf</code></td>
<td>
<p>List containing a configuration for an &lsquo;automatic&rsquo; run (see description of argument <code>iter</code>). Item <code>iter</code> gives the number of iterations in the first chunk of the MCMC simulation; item <code>iter.incr</code> gives the number of iterations in the following chunks; <code>nr.chains</code> gives the number of chains in all chunks of the MCMC simulation; items <code>thin</code> and <code>burnin</code> are used in the convergence diagnostics following each chunk; <code>max.loops</code> controls the maximum number of chunks. All items must be integer values. This argument is only used if the function argument <code>iter</code> is set to &lsquo;auto&rsquo;.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_verbose.iter">verbose.iter</code></td>
<td>
<p>Integer determining how often (in number of iterations) log messages are outputted during the estimation.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the function <code><a href="snowFT.html#topic+performParallel">performParallel</a></code>, if <code>parallel</code> is <code>TRUE</code>. For example <code>cltype</code> which is &lsquo;SOCK&rsquo; by default but can be set to &lsquo;MPI&rsquo;.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc_+3A_chain.ids">chain.ids</code></td>
<td>
<p>Array of chain identifiers that should be resumed. If it is <code>NULL</code>, all existing chains in <code>output.dir</code> are resumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>run.tfr.mcmc</code> creates an object of class <code><a href="#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code> and stores it in <code>output.dir</code>.  It launches <code>nr.chains</code> MCMCs, either sequentially or in parallel.  Parameter traces of each chain are stored as (possibly compressed) ASCII files in a subdirectory of <code>output.dir</code>, called <code>mc</code><em>x</em> where <em>x</em> is the identifier of that chain.  There is one file per parameter, named after the parameter with the suffix &ldquo;.txt&rdquo;, possibly followed by a compression suffix if <code>compression.type</code> is given.  Country-specific parameters (<code class="reqn">U, d, \gamma</code>) have the suffix <code>_c</code><em>y</em> where <em>y</em> is the country code.  In addition to the trace files, each <code>mc</code><em>x</em> directory contains the object <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code> in binary format.  All chain-specific files  are written into disk after the first, last and each <code>buffer.size</code>-th iteration.
</p>
<p>Using the function <code>continue.tfr.mcmc</code> one can continue simulating an existing MCMCs by <code>iter</code> iterations for either all or selected chains.
</p>
<p>The function loads observed data (further denoted as WPP dataset) from the <code><a href="wpp2019.html#topic+tfr">tfr</a></code> and <code><a href="wpp2019.html#topic+tfr_supplemental">tfr_supplemental</a></code> datasets in a <span class="pkg">wpp</span><code class="reqn">x</code> package where <code class="reqn">x</code> is the <code>wpp.year</code>. It is then merged with the  <code><a href="#topic+include">include</a></code> dataset that corresponds to the same <code>wpp.year</code>. The argument <code>my.tfr.file</code> can be used to overwrite those default data. If <code>use.wpp.data</code> is <code>FALSE</code>, it fully replaces the default dataset. Otherwise (by default), such a file can include a subset of countries contained in the WPP dataset, as well as a set of new countries. In the former case,
the function replaces the corresponding country data from the WPP dataset by values in this file. Only columns are replaced that match column names of the WPP dataset, and in addition, columns &lsquo;last.observed&rsquo; and &lsquo;include_code&rsquo; are used, if present. Countries are merged with WPP using the column &lsquo;country_code&rsquo;. In addition, in order the countries to be included in the simulation, in both cases (whether they are included in the WPP dataset or not), they must be contained in the table of locations (<code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code>). In addition, their corresponding <code><a href="#topic+include">include_code</a></code> must be set to 2. If the column &lsquo;include_code&rsquo; is present in <code>my.tfr.file</code>, its value overwrites the default include code, unless it is -1.  
</p>
<p>The default UN table of locations mentioned above can be overwritten/extended by using a file passed as the <code>my.locations.file</code> argument. Such a file must have the same structure as the <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code> dataset. Entries in this file will overwrite corresponding entries in <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code> matched by the column &lsquo;country_code&rsquo;. If there is no such entry in the default dataset, it will be appended. This option of appending new locations is especially useful in cases when <code>my.tfr.file</code> contains new countries/regions that are not included in <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code>. In such a case, one must provide a <code>my.locations.file</code> with a definition of those countries/regions.
</p>
<p>For simulation of the hyperparameters of the Bayesian hierarchical model, all countries are used that are included in the WPP dataset, possibly complemented by the <code>my.tfr.file</code>, that have <code>include_code</code> equal to 2. The hyperparameters are used to simulate country-specific parameters, which is done for all countries with <code>include_code</code> equal 1 or 2. The following values of <code>include_code</code> in <code>my.tfr.file</code> are recognized: -1 (do not overwrite the default include code), 0 (ignore), 1 (include in prediction but not estimation), 2 (include in both, estimation and prediction). Thus, the set of countries included in the estimation and prediction can be fully user-specific.
</p>
<p>Optionally, <code>my.tfr.file</code> can contain a column called <code>last.observed</code> containing the year of the last observation for each country. In such a case, the code would ignore any data after that time point. Furthermore, the function <code><a href="#topic+tfr.predict">tfr.predict</a></code> fills in the missing values using the median of the BHM procedure (stored in <code>tfr_matrix_reconstructed</code> of the <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code> object). For <code>last.observed</code> values that are below a middle year of a time interval <code class="reqn">[t_i, t_{i+1}]</code> (computed as <code class="reqn">t_i+3</code>) the last valid data point is the time interval <code class="reqn">[t_{i-1}, t_i]</code>, whereas for values larger equal a middle year, the data point in <code class="reqn">[t_i, t_{i+1}]</code> is valid.
</p>
<p>The package contains a dataset called &lsquo;<span class="file">my_tfr_template</span>&rsquo; (in &lsquo;<span class="file">extdata</span>&rsquo; directory) which is a template for user-specified <code>my.tfr.file</code>.
</p>
<p>The parameter <code>uncertainty</code> is set to control whether past TFR is considered to be precise (<code>FALSE</code>), or need to be estimated from the raw data (<code>TRUE</code>). In the latter case, the raw TFR observations are taken either from the <code><a href="#topic+rawTFR">rawTFR</a></code> dataset (default) or from a file given by the <code>my.tfr.raw.file</code> argument.  The Bayesian hierarchical model considers the past TFR as unknown, estimates it and stores in <code>output.dir</code>. Details can be found in Liu and Raftery (2020). The <code>covariates</code>, <code>cont_covariates</code> arguments are for listing categorical and continuous features for estimating bias and standard deviation of past TFR observations. If a country is known to have unbiased vital registration (VR) records, one can include it in the  <code>iso.unbiased</code> argument as those countries will estimate their past VR records to have 0 bias and 0.0161 standard deviation. The VR records are identified as having &ldquo;VR&rdquo; in the column given by <code>source.col.name</code> (&ldquo;source&rdquo; by default).
</p>
<p>If <code>annual=TRUE</code>, which implies using annual data for training the model, the parameter <code>ar.phase2</code> will be activated. If <code>ar.phase2</code> is set to <code>TRUE</code>, then the model of Phase II will change from <code class="reqn">d_{c,t} = g_{c,t} + \epsilon_{c,t}</code> to <code class="reqn">d_{c,t}-g_{c,t} = \phi(d_{c,t-1}-g_{c,t-1}) + \epsilon_{c,t}</code>. <code class="reqn">\phi</code> is considered as country-independent and is called <code>rho_phase2</code>.
</p>
<p>Furthermore, if <code>annual</code> is <code>TRUE</code> and <code>my.tfr.file</code> is given, the data in the file must be on annual basis and no matching with the WPP dataset takes place. 
</p>


<h3>Value</h3>

<p>An object of class <code>bayesTFR.mcmc.set</code> which is a list with two components:
</p>
<table role = "presentation">
<tr><td><code>meta</code></td>
<td>
<p>An object of class <code><a href="#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code>.</p>
</td></tr>
<tr><td><code>mcmc.list</code></td>
<td>
<p>A list of objects of class <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code>, one for each MCMC.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Leontine Alkema, Peiran Liu
</p>


<h3>References</h3>

<p>Peiran Liu, Hana Sevcikova, Adrian E. Raftery (2023): Probabilistic Estimation and Projection of the Annual Total Fertility Rate Accounting for Past Uncertainty: A Major Update of the bayesTFR R Package. Journal of Statistical Software, 106(8), 1-36. <a href="https://doi.org/10.18637/jss.v106.i08">doi:10.18637/jss.v106.i08</a>.
</p>
<p>L. Alkema, A. E. Raftery, P. Gerland, S. J. Clark, F. Pelletier, Buettner, T., Heilig, G.K. (2011). Probabilistic Projections of the Total Fertility Rate for All Countries. Demography, Vol. 48, 815-839. <a href="https://doi.org/10.1007/s13524-011-0040-5">doi:10.1007/s13524-011-0040-5</a>.
</p>
<p>P. Liu, and A. E. Raftery (2020). Accounting for Uncertainty About Past Values In Probabilistic Projections of the Total Fertility Rate for All Countries. Annals of Applied Statistics, Vol 14, no. 2, 685-705. <a href="https://doi.org/10.1214/19-AOAS1294">doi:10.1214/19-AOAS1294</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.tfr.mcmc">get.tfr.mcmc</a></code>, <code><a href="#topic+summary.bayesTFR.mcmc.set">summary.bayesTFR.mcmc.set</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
m &lt;- run.tfr.mcmc(nr.chains = 1, iter = 5, output.dir = sim.dir, verbose = TRUE)
summary(m)
m &lt;- continue.tfr.mcmc(iter = 5, verbose = TRUE)
summary(m)
unlink(sim.dir, recursive = TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='run.tfr.mcmc.extra'>
Run MCMC for Extra Countries, Areas or Regions
</h2><span id='topic+run.tfr.mcmc.extra'></span>

<h3>Description</h3>

<p>Run MCMC for extra countries, areas or regions. It uses the posterior distribution of model hyperparameters from an existing simulation to generate country-specific parameters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.tfr.mcmc.extra(sim.dir = file.path(getwd(), "bayesTFR.output"), 
    countries = NULL, my.tfr.file = NULL, 
    iter = NULL, thin = 1, thin.extra = 1, burnin = 2000,
    parallel = FALSE, nr.nodes = NULL,  my.locations.file = NULL,
    uncertainty = FALSE, my.tfr.raw.file = NULL, 
    use.wpp.data = TRUE, iso.unbiased = NULL, 
    covariates = c('source', 'method'), cont_covariates = NULL, 
    source.col.name = "source", average.gammas.cov = TRUE, 
    verbose = FALSE, verbose.iter = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.tfr.mcmc.extra_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with an existing simulation.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_countries">countries</code></td>
<td>
<p>Vector of country codes. These include codes of areas and regions (see column <code>country_code</code> in <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code>).</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_my.tfr.file">my.tfr.file</code></td>
<td>

<p>File name containing user-specified TFR time series for countries for which the simulation should run (see Details below).
</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_iter">iter</code></td>
<td>

<p>Number of iterations to be used for sampling from the posterior distribution of the hyperparameters. By default, the number of iterations used in the existing simulation is taken.
</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_thin">thin</code></td>
<td>

<p>Thinning interval for sampling from the posterior distribution of the hyperparameters.
</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_thin.extra">thin.extra</code></td>
<td>

<p>Thinning interval for the MCMC run for extra countries.
</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_burnin">burnin</code></td>
<td>

<p>Number of iterations discarded before sampling from the posterior distribution of the hyperparameters. It is also used when computing proposal of gamma covariance matrices (see <code><a href="#topic+get.cov.gammas">get.cov.gammas</a></code>).
</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_parallel">parallel</code></td>
<td>

<p>Logical determining if the simulation should run multiple chains in parallel.
</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_nr.nodes">nr.nodes</code></td>
<td>

<p>Relevant only if <code>parallel</code> is <code>TRUE</code>. It gives the number of nodes for running the simulation in parallel. By default it equals to the number of chains contained in the existing simulation.
</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_my.locations.file">my.locations.file</code></td>
<td>
<p>File name containing user-specified locations. See Details below.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Whether past TFR uncertainty is considered. If <code>TRUE</code>, countries listed in <code>countries</code> will be re-simulated with the model that accounts for past TFR estimation. It will take observations either from <code><a href="#topic+rawTFR">rawTFR</a></code> (default) or from a file given by <code>my.tfr.raw.file</code>, and estimate the distribution of these observations with respect to the true TFR. Then instead of treating the observed data as true data, it assumes the true TFR are unknown and includes an extra step for estimating past TFR.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_my.tfr.raw.file">my.tfr.raw.file</code></td>
<td>
<p>File name of the raw TFR used when uncertainty is <code>TRUE</code>. See details in <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_use.wpp.data">use.wpp.data</code></td>
<td>
<p>Logical indicating if default WPP data should be used, i.e. if <code>my.tfr.file</code> will be matched with the WPP data in terms of time periods and locations. If <code>FALSE</code>, it is assumed that the <code>my.tfr.file</code> contains all locations and time periods to be included in the simulation.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_iso.unbiased">iso.unbiased</code></td>
<td>
<p>Codes of countries for which the vital registration TFR estimates are considered unbiased. See details in <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_covariates">covariates</code>, <code id="run.tfr.mcmc.extra_+3A_cont_covariates">cont_covariates</code></td>
<td>
<p>Categorical and continuous features used in estimating bias and standard deviation if <code>uncertainty</code> is <code>TRUE</code>. See details in <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_source.col.name">source.col.name</code></td>
<td>
<p>If <code>uncertainty</code> is <code>TRUE</code> this is a column name within the given covariates that determines the data source. It is used if <code>iso.unbiased</code> is given to identify the vital registration records.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_average.gammas.cov">average.gammas.cov</code></td>
<td>
<p>Set this to <code>FALSE</code> if the processed country has been included in the main simulation. In such a case the proposal gamma covariance matrix is taken from the <code>proposal_cov_gammas_cii</code> dataset. By default, the matrix is taken as an average from all countries.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_verbose.iter">verbose.iter</code></td>
<td>
<p>Integer determining how often (in number of iterations) log messages are outputted during the estimation.</p>
</td></tr>
<tr><td><code id="run.tfr.mcmc.extra_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the function <code><a href="snowFT.html#topic+performParallel">performParallel</a></code>, if <code>parallel</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used to make predictions for countries, areas or regions (further denoted as &lsquo;countries&rsquo;) that were not included in the MCMC estimation (invoked by <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>). It creates MCMC traces for country-specific parameters. The purpose of this function is to have country-specific parameters available in order to be able to generate projections for additional countries or their aggregations, without having to re-run the often time-expensive MCMC simulation.
</p>
<p>The set of countries to be considered by this function can be given either by their codes, using the argument <code>countries</code>, in which case the countries must be included in the UN WPP <code><a href="wpp2019.html#topic+tfr">tfr</a></code> dataset. Or, it can be given by a user-specific TFR file, using the argument <code>my.tfr.file</code>. The <code>countries</code> argument haas a priority over <code>my.tfr.file</code>.
</p>
<p>In the default case of <code>uncertainty = FALSE</code>, the function will ignore all countries that were used in the existing MCMC simulation for estimating the hyperparameters. However, countries that already own country-specific parameters (e.g. because they were included in <code>my.tfr.file</code> passed to <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code> with <code>include_code = 1</code>, or from a previous pass of the <code>run.tfr.mcmc.extra</code> function) get their parameters recomputed. In case of <code>uncertainty = TRUE</code>, all specified  countries, regardless if they were included in the existing world simulation or not, get their parameters recomputed. It is therefore advisable to make a backup copy of the exisiting MCMC simulation, as there is a no easy way to revert the parameters to their original values. 
</p>
<p>Note that all affected countries should be included in the <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code> dataset, but unlike in <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>, their  <code>include_code</code> is ignored. As in the case of <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>, the default dataset of locations <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code> can be overwritten using a file of the same structure as <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code> passed via the <code>my.locations.file</code> argument. This file should be especially used, if TFR is simulated for new locations that are not included in <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code>.
</p>


<h3>Note</h3>

<p>If there is an existing projection for the directory <code>sim.dir</code>, use <code><a href="#topic+tfr.predict.extra">tfr.predict.extra</a></code> to obtain projections for the extra countries used in this function.</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Leontine Alkema, Peiran Liu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>, <code><a href="#topic+tfr.predict.extra">tfr.predict.extra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
m &lt;- run.tfr.mcmc(nr.chains = 1, iter = 20, output.dir = sim.dir, verbose = TRUE)
m &lt;- run.tfr.mcmc.extra(sim.dir = sim.dir, countries = c(908, 924), 
  burnin = 10, verbose = TRUE)
summary(m, country = 924)
pred &lt;- tfr.predict(m, burnin = 10, use.tfr3 = FALSE, verbose = TRUE)
summary(pred, country = 908)
unlink(sim.dir, recursive = TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='run.tfr3.mcmc'>
Running Markov Chain Monte Carlo for Parameters of Total Fertility Rate in Phase III
</h2><span id='topic+run.tfr3.mcmc'></span><span id='topic+continue.tfr3.mcmc'></span>

<h3>Description</h3>

<p>Runs (or continues running) MCMCs for simulating Phase III total fertility rate, using a Bayesian hierarchical version of an AR(1) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.tfr3.mcmc(sim.dir, nr.chains = 3, iter = 50000, thin = 10, 
    replace.output = FALSE, my.tfr.file = NULL, buffer.size = 100, 
    use.extra.countries = FALSE, 
    mu.prior.range = c(0, 2.1), rho.prior.range = c(0, 1 - .Machine$double.xmin), 
    sigma.mu.prior.range = c(1e-05, 0.318), sigma.rho.prior.range = c(1e-05, 0.289), 
    sigma.eps.prior.range = c(1e-05, 0.5), 
    mu.ini = NULL, mu.ini.range = mu.prior.range, 
    rho.ini = NULL, rho.ini.range = rho.prior.range, 
    sigma.mu.ini = NULL, sigma.mu.ini.range = sigma.mu.prior.range, 
    sigma.rho.ini = NULL, sigma.rho.ini.range = sigma.rho.prior.range, 
    sigma.eps.ini = NULL, sigma.eps.ini.range = sigma.eps.prior.range, 
    seed = NULL, parallel = FALSE, nr.nodes = nr.chains, compression.type = "None", 
    auto.conf = list(max.loops = 5, iter = 50000, iter.incr = 20000, nr.chains = 3, 
                    thin = 60, burnin = 10000), 
    verbose = FALSE, verbose.iter = 1000, ...)
        
continue.tfr3.mcmc(sim.dir, iter, chain.ids=NULL, 
    parallel = FALSE, nr.nodes = NULL, auto.conf = NULL,
    verbose=FALSE, verbose.iter = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.tfr3.mcmc_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with an existing simulation of phase II TFR (see <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>).</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_nr.chains">nr.chains</code></td>
<td>
<p>Number of MCMC chains to run.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_iter">iter</code></td>
<td>
<p>Number of iterations to run in each chain. In addition to a single value, it can have the value &lsquo;auto&rsquo; in which case the function runs for the number of iterations given in the <code>auto.conf</code> list (see below), then checks if the MCMCs converged (using the <code>auto.conf</code> settings). If it did not converge, the procedure is repeated until convergence is reached or the number of repetition exceeded <code>auto.conf$max.loops</code>.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_thin">thin</code></td>
<td>
<p>Thinning interval between consecutive observations to be stored on disk.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_replace.output">replace.output</code></td>
<td>
<p>If <code>TRUE</code>, previously stored results of a phase III simulation will be overwritten.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_my.tfr.file">my.tfr.file</code></td>
<td>
<p>File name containing user-specified TFR time series for one or more countries. See description of this argument in <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_buffer.size">buffer.size</code></td>
<td>
<p>Buffer size (in number of iterations) for keeping data in the memory.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_use.extra.countries">use.extra.countries</code></td>
<td>
<p>By default, only countries are used in the MCMCs that were assigned for estimation (i.e. their &lsquo;include_code&rsquo; is 2 in the <a href="#topic+include">include</a>) dataset and are in phase III at present time (argument <code>present.year</code> in <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>). If this argument is <code>TRUE</code>, countries that were added using <code><a href="#topic+run.tfr.mcmc.extra">run.tfr.mcmc.extra</a></code> and are in phase III are also included.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_mu.prior.range">mu.prior.range</code>, <code id="run.tfr3.mcmc_+3A_rho.prior.range">rho.prior.range</code>, <code id="run.tfr3.mcmc_+3A_sigma.mu.prior.range">sigma.mu.prior.range</code>, <code id="run.tfr3.mcmc_+3A_sigma.rho.prior.range">sigma.rho.prior.range</code>, <code id="run.tfr3.mcmc_+3A_sigma.eps.prior.range">sigma.eps.prior.range</code></td>
<td>
<p>Min and max for the prior (uniform) distribution of these paraemters.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_mu.ini">mu.ini</code>, <code id="run.tfr3.mcmc_+3A_rho.ini">rho.ini</code>, <code id="run.tfr3.mcmc_+3A_sigma.mu.ini">sigma.mu.ini</code>, <code id="run.tfr3.mcmc_+3A_sigma.rho.ini">sigma.rho.ini</code>, <code id="run.tfr3.mcmc_+3A_sigma.eps.ini">sigma.eps.ini</code></td>
<td>
<p>Initial value(s) of the parameters. It can be a single value or an array of the size <code>nr.chains</code>.  By default, if <code>nr.chains</code> is 1, it is the middle point of the corresponding range. Otherwise, it is uniformly randomly distributed within the range.
</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_mu.ini.range">mu.ini.range</code>, <code id="run.tfr3.mcmc_+3A_rho.ini.range">rho.ini.range</code>, <code id="run.tfr3.mcmc_+3A_sigma.mu.ini.range">sigma.mu.ini.range</code>, <code id="run.tfr3.mcmc_+3A_sigma.rho.ini.range">sigma.rho.ini.range</code>, <code id="run.tfr3.mcmc_+3A_sigma.eps.ini.range">sigma.eps.ini.range</code></td>
<td>
<p>Min and max for the initial values.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_seed">seed</code></td>
<td>
<p>Seed of the random number generator. If <code>NULL</code> no seed is set.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_parallel">parallel</code></td>
<td>
<p>Logical determining if the simulation should run multiple chains in parallel. If it is <code>TRUE</code>, the package <span class="pkg"><a href="snowFT.html#topic+snowFT">snowFT</a></span> is required.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_nr.nodes">nr.nodes</code></td>
<td>
<p>Relevant only if <code>parallel</code> is <code>TRUE</code>. It gives the number of nodes for running the simulation in parallel.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_compression.type">compression.type</code></td>
<td>
<p>One of &lsquo;None&rsquo;, &lsquo;gz&rsquo;, &lsquo;xz&rsquo;, &lsquo;bz&rsquo;, determining type of a compression of the MCMC files. Important: Do not use this option for a long MCMC simulation as this tends to cause very long run times due to slow reading!</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_auto.conf">auto.conf</code></td>
<td>
<p>List containing a configuration for an &lsquo;automatic&rsquo; run (see description of argument <code>iter</code>). Item <code>iter</code> gives the number of iterations in the first chunk of the MCMC simulation; item <code>iter.incr</code> gives the number of iterations in the following chunks; <code>nr.chains</code> gives the number of chains in all chunks of the MCMC simulation; items <code>thin</code> and <code>burnin</code> are used in the convergence diagnostics following each chunk; <code>max.loops</code> controls the maximum number of chunks. All items must be integer values. This argument is only used if the function argument <code>iter</code> is set to &lsquo;auto&rsquo;.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_verbose.iter">verbose.iter</code></td>
<td>
<p>Integer determining how often (in number of iterations) messages are outputted during the estimation.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the function <code><a href="snowFT.html#topic+performParallel">performParallel</a></code>, if <code>parallel</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="run.tfr3.mcmc_+3A_chain.ids">chain.ids</code></td>
<td>
<p>Array of chain identifiers that should be resumed. If it is <code>NULL</code>, all existing chains are resumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MCMCs are stored in <code>sim.dir</code> in a subdirectory called &ldquo;phaseIII&rdquo;. It has exactly the same structure as phase II MCMCs described in <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>bayesTFR.mcmc.set</code> which is a list with two components:
</p>
<table role = "presentation">
<tr><td><code>meta</code></td>
<td>
<p>An object of class <code><a href="#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code>.</p>
</td></tr>
<tr><td><code>mcmc.list</code></td>
<td>
<p>A list of objects of class <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code>, one for each MCMC.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>References</h3>

<p>Raftery, A.E., Alkema, L. and Gerland, P. (2014). Bayesian Population Projections for the United Nations.
Statistical Science, Vol. 29, 58-68. <a href="https://doi.org/10.1214/13-STS419">doi:10.1214/13-STS419</a>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>, <code><a href="#topic+get.tfr3.mcmc">get.tfr3.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
# Runs Phase II MCMCs (must be run before Phase III)
m &lt;- run.tfr.mcmc(nr.chains=1, iter=5, output.dir=sim.dir, verbose=TRUE)
# Runs Phase III MCMCs
m3 &lt;- run.tfr3.mcmc(sim.dir=sim.dir, nr.chains=2, iter=50, thin=1, verbose=TRUE)
m3 &lt;- continue.tfr3.mcmc(sim.dir=sim.dir, iter=10, verbose=TRUE)
summary(m3, burnin=10)
unlink(sim.dir, recursive=TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='summary.bayesTFR.convergence'>
Summary of a TFR Convergence Object
</h2><span id='topic+summary.bayesTFR.convergence'></span>

<h3>Description</h3>

<p>Summary of an object of class <code><a href="#topic+bayesTFR.convergence">bayesTFR.convergence</a></code> created using the <code><a href="#topic+tfr.diagnose">tfr.diagnose</a></code> or <code><a href="#topic+tfr3.diagnose">tfr3.diagnose</a></code>  functions. It gives an overview about parameters that did not converge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesTFR.convergence'
summary(object, expand = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bayesTFR.convergence_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.convergence">bayesTFR.convergence</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.convergence_+3A_expand">expand</code></td>
<td>
<p>By default, the function does not show parameters for each country for which there was no convergence, if the status is &lsquo;red&rsquo;. This argument can switch that option on.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.convergence_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tfr.diagnose">tfr.diagnose</a></code>, <code><a href="#topic+tfr3.diagnose">tfr3.diagnose</a></code>
</p>

<hr>
<h2 id='summary.bayesTFR.mcmc.set'>
Summary Statistics for TFR Markov Chain Monte Carlo Chains
</h2><span id='topic+summary.bayesTFR.mcmc.set'></span><span id='topic+print.summary.bayesTFR.mcmc.set'></span><span id='topic+print.summary.bayesTFR.mcmc.set.meta'></span><span id='topic+summary.bayesTFR.mcmc'></span>

<h3>Description</h3>

<p>Summary of an object <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> or <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code>, computed via <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code> or <code><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a></code>.  It can be obtained either for all countries or for a specific country, and either for all parameters or for specific parameters.  The function uses the <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code> function of the <span class="pkg">coda</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesTFR.mcmc.set'
summary(object, country = NULL, chain.id = NULL,
    par.names = NULL, par.names.cs = NULL, meta.only = FALSE, 
    thin = 1, burnin = 0, ...)
	
## S3 method for class 'bayesTFR.mcmc'
summary(object, country = NULL, par.names = NULL, par.names.cs = NULL, 
    thin = 1, burnin = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bayesTFR.mcmc.set_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> or <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.mcmc.set_+3A_country">country</code></td>
<td>
<p>Country name or code if a country-specific summary is desired. The code can be either numeric or ISO-2 or ISO-3 characters. By default, summary for all countries is generated.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.mcmc.set_+3A_chain.id">chain.id</code></td>
<td>
<p>Identifiers of MCMC chains. By default, all chains are considered.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.mcmc.set_+3A_par.names">par.names</code></td>
<td>
<p>Country independent parameters to be included in the summary. If the underlying object is an MCMC of phase II, the default names are given by <code><a href="#topic+tfr.parameter.names">tfr.parameter.names</a>()</code>, if it is phase III the names are <code><a href="#topic+tfr3.parameter.names">tfr3.parameter.names</a>()</code>.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.mcmc.set_+3A_par.names.cs">par.names.cs</code></td>
<td>
<p>Country-specific parameters to be included in the summary. If the underlying object is an MCMC of phase II, the default names are given by <code><a href="#topic+tfr.parameter.names.cs">tfr.parameter.names.cs</a>()</code>, if it is phase III the names are <code><a href="#topic+tfr3.parameter.names.cs">tfr3.parameter.names.cs</a>()</code>.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.mcmc.set_+3A_meta.only">meta.only</code></td>
<td>
<p>If it is <code>TRUE</code>, only meta information of the simulation is included.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.mcmc.set_+3A_thin">thin</code></td>
<td>
<p>Thinning interval. Only used if larger than the <code>thin</code> argument used in <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code> or <code><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.mcmc.set_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of each chain before computing the summary.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.mcmc.set_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code> function of the <span class="pkg">coda</span> package.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
m &lt;- get.tfr.mcmc(sim.dir)
summary(m, country="CZE", burnin=15)
</code></pre>

<hr>
<h2 id='summary.bayesTFR.prediction'>
Summary of a Prediction of the Total Fertility Rate
</h2><span id='topic+summary.bayesTFR.prediction'></span><span id='topic+print.summary.bayesTFR.prediction'></span>

<h3>Description</h3>

<p>Country-specific summary of an object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>, created using the function <code><a href="#topic+tfr.predict">tfr.predict</a></code>. The summary contains the mean, standard deviation and several commonly used quantiles of the simulated trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesTFR.prediction'
summary(object, country = NULL, compact = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bayesTFR.prediction_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.prediction_+3A_country">country</code></td>
<td>
<p>Country name or code. The code can be either numeric or ISO-2 or ISO-3 characters. If it is <code>NULL</code>, only prediction parameters are included.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.prediction_+3A_compact">compact</code></td>
<td>
<p>Logical switching between a smaller and larger number of displayed quantiles.</p>
</td></tr>
<tr><td><code id="summary.bayesTFR.prediction_+3A_...">...</code></td>
<td>
<p>A list of further arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
pred &lt;- tfr.predict(sim.dir=sim.dir, 
                    output.dir=file.path(getwd(), "exampleTFRpred"), 
                    use.tfr3=FALSE, burnin=15, verbose=TRUE)
# If the above function was run previously, do
# pred &lt;- get.tfr.prediction(sim.dir=file.path(getwd(), "exampleTFRpred"))
                                                        
summary(pred, country = "Ireland")

## End(Not run)
</code></pre>

<hr>
<h2 id='tfr_raw_data'>
Raw TFR Data
</h2><span id='topic+rawTFR'></span>

<h3>Description</h3>

<p>Data set containing the raw TFR estimates for all countries and the data quality covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("rawTFR")</code></pre>


<h3>Format</h3>

<p>A data frame with 12709 observations on the following 5 variables.
</p>

<dl>
<dt><code>country_code</code></dt><dd><p>Three-digit UN ISO-3166 code for the country of that observation is for.</p>
</dd>
<dt><code>year</code></dt><dd><p>a numeric vector for the year of the observation data.</p>
</dd>
<dt><code>tfr</code></dt><dd><p>TFR value.</p>
</dd>
<dt><code>method</code></dt><dd><p>Estimation method to obtain this value. One of the categorical data quality indicator.</p>
</dd>
<dt><code>source</code></dt><dd><p>Source of the data. One of the categorical data quality indicator.</p>
</dd>
</dl>



<h3>Details</h3>

<p>It is used as the default raw TFR data in a <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code> simulation. It can be used as a template for a user-defined data which can be provided via the <code>my.tfr.raw.file</code> argument of <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>. The &ldquo;method&rdquo; and &ldquo;source&rdquo; columns are used as the default data quality covariates.
</p>


<h3>Source</h3>

<p>Data provided by the United Nations Population Division.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rawTFR)
head(rawTFR)
</code></pre>

<hr>
<h2 id='tfr.diagnose'>
Convergence Diagnostics of TFR Markov Chain Monte Carlo
</h2><span id='topic+tfr.diagnose'></span><span id='topic+tfr3.diagnose'></span><span id='topic+bayesTFR.convergence'></span><span id='topic+has.mcmc.converged'></span>

<h3>Description</h3>

<p>Functions <code>tfr.diagnose</code> and <code>tfr3.diagnose</code> run convergence diagnostics of existing TFR MCMCs for phase II and phase III, respectively, using the <code>raftery.diag</code> function from the <span class="pkg">coda</span> package. <code>has.mcmc.converged</code> checks if the existing diagnostics converged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.diagnose(sim.dir, thin = 80, burnin = 2000, express = FALSE, 
    country.sampling.prop = NULL, keep.thin.mcmc=FALSE, verbose = TRUE)
    
tfr3.diagnose(sim.dir, thin = 60, burnin = 10000, express = TRUE, 
    country.sampling.prop = NULL, verbose = TRUE, ...)
    
has.mcmc.converged(diag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.diagnose_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results.</p>
</td></tr>
<tr><td><code id="tfr.diagnose_+3A_thin">thin</code></td>
<td>
<p>Thinning interval.</p>
</td></tr>
<tr><td><code id="tfr.diagnose_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of the parameter traces.</p>
</td></tr>
<tr><td><code id="tfr.diagnose_+3A_express">express</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the convergence diagnostics is run only on the country-independent parameters. If <code>FALSE</code>, the country-specific parameters are included in the diagnostics. The number of countries can be controlled by <code>country.sampling.prop</code>.</p>
</td></tr>
<tr><td><code id="tfr.diagnose_+3A_country.sampling.prop">country.sampling.prop</code></td>
<td>
<p>Proportion of countries that are included in the diagnostics. If it is <code>NULL</code> and <code>express=FALSE</code>, all countries are included. Setting here a number between 0 and 1, one can limit the number of countries which are then randomly sampled. Note that for long MCMCs, this argument may significantly influence the run-time of this function.</p>
</td></tr>
<tr><td><code id="tfr.diagnose_+3A_keep.thin.mcmc">keep.thin.mcmc</code></td>
<td>
<p>Logical. If <code>TRUE</code> the thinned traces used for computing the diagnostics are stored on disk (see <code><a href="#topic+create.thinned.tfr.mcmc">create.thinned.tfr.mcmc</a></code>). It is only available for phase II MCMCs.</p>
</td></tr>
<tr><td><code id="tfr.diagnose_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="tfr.diagnose_+3A_diag">diag</code></td>
<td>
<p>Object of class <code>bayesTFR.convergence</code>.</p>
</td></tr>
<tr><td><code id="tfr.diagnose_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diagnose functions invoke the <code><a href="#topic+tfr.raftery.diag">tfr.raftery.diag</a></code> (or <code><a href="#topic+tfr3.raftery.diag">tfr3.raftery.diag</a></code>) function separately for country-independent parameters and for country-specific parameters. It results in two possible states: red, i.e. it did not converge, and green, i.e. it converged.
The resulting object from <code>tfr.diagnose</code> is stored in <br /> &lsquo;<span class="file">{sim.dir}/diagnostics/bayesTFR.convergence_{thin}_{burnin}.rda</span>&rsquo; and can be accessed using the function <code><a href="#topic+get.tfr.convergence">get.tfr.convergence</a></code>. Function <code>tfr3.diagnose</code> stores its result into <br /> &lsquo;<span class="file">{sim.dir}/phaseIII/diagnostics/bayesTFR.convergence_{thin}_{burnin}.rda</span>&rsquo; which can be accessed via <code><a href="#topic+get.tfr3.convergence">get.tfr3.convergence</a></code>. 
</p>


<h3>Value</h3>

<p><code>has.mcmc.converged</code> returns a logical value determining if there is convergence or not.
</p>
<p><code>tfr.diagnose</code> and <code>tfr3.diagnose</code> return an object of class <code>bayesTFR.convergence</code> with components:
</p>
<table role = "presentation">
<tr><td><code>result</code></td>
<td>
<p>Table containing all not-converged parameters. Its columns include &lsquo;Total iterations needed&rsquo; and &lsquo;Remaining iterations&rsquo;.</p>
</td></tr>
<tr><td><code>lresult.country.independent</code></td>
<td>
<p>Number of rows in <code>result</code> that correspond to country-independent paramters. These rows are groupped at the beginning of the table.</p>
</td></tr>
<tr><td><code>country.independent</code></td>
<td>
<p>Result of <code><a href="#topic+tfr.raftery.diag">tfr.raftery.diag</a></code> processed on country-independent parameters.</p>
</td></tr>
<tr><td><code>country.specific</code></td>
<td>
<p>Result of <code><a href="#topic+tfr.raftery.diag">tfr.raftery.diag</a></code> processed on country-specific parameters.</p>
</td></tr>
<tr><td><code>iter.needed</code></td>
<td>
<p>Number of additional iterations suggested in order to achieve convergence.</p>
</td></tr>
<tr><td><code>iter.total</code></td>
<td>
<p>Total number of iterations of the original unthinned set of chains.</p>
</td></tr>
<tr><td><code>use.nr.traj</code></td>
<td>
<p>Suggestion for number of trajectories in generating predictions.</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>
<p>Burnin used.</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>
<p>Thinning interval used.</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>Vector of character strings containing the result status. Possible values: &lsquo;green&rsquo;, &lsquo;red&rsquo;.</p>
</td></tr>
<tr><td><code>mcmc.set</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> that corresponds to the original set of MCMCs on which the diagnostics was run.</p>
</td></tr>
<tr><td><code>thin.mcmc</code></td>
<td>
<p>If <code>keep.thin.mcmc</code> is <code>TRUE</code>, it is an object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> that corresponds to the thinned mcmc set on which the diagnostics was run, otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code>express</code></td>
<td>
<p>Value of the input argument <code>express</code>.</p>
</td></tr>
<tr><td><code>nr.countries</code></td>
<td>
<p>Vector with elements <code>used</code> - number of countries used in this diagnostics, and <code>total</code> - number of countries that this <code>mcmc.set</code> object was estimated on.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Leontine Alkema, Adrian Raftery
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tfr.raftery.diag">tfr.raftery.diag</a></code>, <code><a href="coda.html#topic+raftery.diag">raftery.diag</a></code>, <code><a href="#topic+summary.bayesTFR.convergence">summary.bayesTFR.convergence</a></code>, <code><a href="#topic+get.tfr.convergence">get.tfr.convergence</a></code>, <code><a href="#topic+create.thinned.tfr.mcmc">create.thinned.tfr.mcmc</a></code>
</p>

<hr>
<h2 id='tfr.dl.coverage'>
Goodness of Fit of the Double Logistic Function
</h2><span id='topic+tfr.dl.coverage'></span>

<h3>Description</h3>

<p>The function computes coverage, i.e. the ratio of observed data fitted within the given probability intervals of the predictive posterior distribution of the double logistic function, as well as the root mean square error and mean absolute error of the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.dl.coverage(sim.dir, pi = c(80, 90, 95), burnin = 2000, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.dl.coverage_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. If a prediction and its corresponding thinned MCMCs are available in the simulation directory, those are taken for assessing the goodness of fit.</p>
</td></tr>
<tr><td><code id="tfr.dl.coverage_+3A_pi">pi</code></td>
<td>
<p>Probability interval. It can be a single number or an array.</p>
</td></tr>
<tr><td><code id="tfr.dl.coverage_+3A_burnin">burnin</code></td>
<td>
<p>Burnin. Only relevant if <code>sim.dir</code> does not contain thinned chains.</p>
</td></tr>
<tr><td><code id="tfr.dl.coverage_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following components:
</p>
<table role = "presentation">
<tr><td><code>total.coverage</code></td>
<td>
<p>Vector of the coverage, one element per probability interval. For each <code>pi</code>, it is the ratio of the number of observed data points that fall within the probability interval of the posterior distribution over the total number of data points, i.e. TFR for all countries and historical time periods.</p>
</td></tr>
<tr><td><code>time.coverage</code></td>
<td>
<p>Matrix corresponding to the coverage computed per time period. (Rows correspond to probability intervals, columns correspond to time.) It is derived like <code>total.coverage</code> except that both, the nominator and denominator, contain only data points belonging to the corresponding time period.</p>
</td></tr>
<tr><td><code>country.coverage</code></td>
<td>
<p>Matrix corresponding to the coverage computed per country. (Rows correspond to probability intervals, columns correspond to countries.) It is derived like <code>total.coverage</code> except that both, the nominator and denominator, contain only data points belonging to the corresponding country.</p>
</td></tr>
<tr><td><code>total.rmse</code></td>
<td>
<p>Root mean square error as <code class="reqn">\sqrt{(1/n\sum(x-m)^2)}</code> where <code class="reqn">x</code> are observed data points, <code class="reqn">m</code> is the mean of the posterior distribution and <code class="reqn">n</code> is the number of data points. Here the sum is taken over all countries and historical time periods.</p>
</td></tr>
<tr><td><code>time.rmse</code></td>
<td>
<p>Like <code>total.rmse</code> except that each time period is considered separately.</p>
</td></tr>
<tr><td><code>country.rmse</code></td>
<td>
<p>Like <code>total.rmse</code> except that each country is considered separately.</p>
</td></tr>
<tr><td><code>total.mae</code></td>
<td>
<p>Mean absolute error as <code class="reqn">1/n\sum|x-m|</code> where <code class="reqn">x</code> are observed data points, <code class="reqn">m</code> is the median of the posterior distribution and <code class="reqn">n</code> is the number of data points. Here the sum is taken over all countries and historical time periods.</p>
</td></tr>
<tr><td><code>time.mae</code></td>
<td>
<p>Like <code>total.mae</code> except that each time period is considered separately.</p>
</td></tr>
<tr><td><code>country.mae</code></td>
<td>
<p>Like <code>total.mae</code> except that each country is considered separately.</p>
</td></tr>
<tr><td><code>pred.cdf</code></td>
<td>
<p><code class="reqn">T \times C</code> matrix (with <code class="reqn">T</code> being the number of time periods and <code class="reqn">C</code> being the number of countries), containing the predictive CDF of the observation, i.e. the quantile of each data point within the predictive posterior distribution.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>0-1 <code class="reqn">T \times C</code> matrix indicating if the corresponding data point was included in the goodness of fit computation. Zeros indicate missing historical values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To see the fit visually per country, use <code><a href="#topic+DLcurve.plot">DLcurve.plot</a>(..., predictive.distr=TRUE,...)</code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DLcurve.plot">DLcurve.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
tfr &lt;- get.tfr.mcmc(sim.dir)
# Note that this simulation is a toy example and thus has not converged.
gof &lt;- tfr.dl.coverage(sim.dir)
gof$time.coverage
DLcurve.plot(tfr, country=608, predictive.distr=TRUE, pi=c(80, 90, 95))

## End(Not run)
</code></pre>

<hr>
<h2 id='tfr.estimation.plot'>
Plot TFR Estimation
</h2><span id='topic+tfr.estimation.plot'></span>

<h3>Description</h3>

<p>Plot past TFR estimation results from a simulation that accounted for past TFR uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.estimation.plot(mcmc.list = NULL, country = NULL, sim.dir = NULL, 
    burnin = 0, thin = 1, pis = c(80, 95), plot.raw = TRUE, 
    grouping = "source", save.image = TRUE, plot.dir = "Estimation.plot", 
    adjust = TRUE, country.code = deprecated(), ISO.code = deprecated())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.estimation.plot_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> corresponding Phase II MCMCs. If it is <code>NULL</code>, the object is loaded from the directory given by <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="tfr.estimation.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="tfr.estimation.plot_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results.</p>
</td></tr>
<tr><td><code id="tfr.estimation.plot_+3A_burnin">burnin</code></td>
<td>
<p>Burn-in for getting trajectories and quantiles. A positive burn-in <code class="reqn">x</code> will remove first <code class="reqn">x</code> iterations from each chain.</p>
</td></tr>
<tr><td><code id="tfr.estimation.plot_+3A_thin">thin</code></td>
<td>
<p>Thin for getting trajectories and quantiles. Thinning level <code class="reqn">x</code> greater than 1 will store one iteration per <code class="reqn">x</code> samples</p>
</td></tr>
<tr><td><code id="tfr.estimation.plot_+3A_pis">pis</code></td>
<td>
<p>Probability interval. It can be a single number or an array of two numbers.</p>
</td></tr>
<tr><td><code id="tfr.estimation.plot_+3A_plot.raw">plot.raw</code></td>
<td>
<p>Whether raw data used for the estimation should be plotted.</p>
</td></tr>
<tr><td><code id="tfr.estimation.plot_+3A_grouping">grouping</code></td>
<td>
<p>If raw data is plotted, then grouping should be one of the categorical feature in the data, so that the color and shape of the raw data will differ for different groups.</p>
</td></tr>
<tr><td><code id="tfr.estimation.plot_+3A_save.image">save.image</code></td>
<td>
<p>Logical. Whether the resulting plot will be saved.</p>
</td></tr>
<tr><td><code id="tfr.estimation.plot_+3A_plot.dir">plot.dir</code></td>
<td>
<p>If <code>save.image=TRUE</code>, specify the directory for saving the plot.</p>
</td></tr>
<tr><td><code id="tfr.estimation.plot_+3A_adjust">adjust</code></td>
<td>
<p>Logical. By default, if the estimation median is adjusted using e.g. <code><a href="#topic+tfr.median.set.all">tfr.median.set.all</a></code>, the function plots the adjusted median. If <code>adjust=FALSE</code> the original (non-adjusted) median is plotted.</p>
</td></tr>
<tr><td><code id="tfr.estimation.plot_+3A_country.code">country.code</code>, <code id="tfr.estimation.plot_+3A_iso.code">ISO.code</code></td>
<td>
<p>Deprecated arguments. Use argument <code>country</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tfr.estimation.plot</code> plots posterior distribution of past TFR estimations for a given country. It only works if uncertainty is considered in the MCMC process.
</p>


<h3>Author(s)</h3>

<p>Peiran Liu, Hana Sevcikova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
mcmc.set &lt;- run.tfr.mcmc(nr.chains = 1, iter = 10, output.dir = sim.dir, 
    replace.output = TRUE, uncertainty = TRUE)
tfr.estimation.plot(mcmc.set, "Nigeria", save.image = FALSE)
unlink(sim.dir, recursive = TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='tfr.map'>
TFR World Map 
</h2><span id='topic+tfr.map'></span><span id='topic+tfr.ggmap'></span><span id='topic+tfr.map.all'></span><span id='topic+get.tfr.map.parameters'></span><span id='topic+tfr.map.gvis'></span>

<h3>Description</h3>

<p>Generate world maps of the total fertility rate for given projection period and quantile, using different techniques: <code>tfr.map</code> and <code>tfr.map.all</code> use <span class="pkg">rworldmap</span>, <code>tfr.ggmap</code> uses <span class="pkg">ggplot2</span>, and <code>tfr.map.gvis</code> creates an interactive map via <span class="pkg">GoogleVis</span>. In addition to TFR, all these functions allow to project country specific Phase II MCMC parameters into the world maps. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.map(pred, quantile = 0.5, 
    year = NULL, par.name = NULL, adjusted = FALSE,
    projection.index = 1, device = "dev.new", main = NULL, 
    resolution=c("coarse","low","less islands","li","high"),
    device.args = NULL, data.args = NULL, ...)

tfr.ggmap(pred, quantile = 0.5, 
    year = NULL, par.name = NULL, adjusted = FALSE,
    projection.index = 1, main = NULL, data.args = NULL, 
    viridis.option = "B", nr.cats = 10, same.scale = FALSE, 
    plot = TRUE, file.name = NULL, plot.size = 4, ...)
    
tfr.map.gvis(pred, year = NULL, quantile = 0.5, pi = 80, 
    par.name = NULL, adjusted = FALSE, ...)
    
tfr.map.all(pred, output.dir, output.type = "png", 
    tfr.range = NULL, nr.cats = 50, same.scale = TRUE, 
    quantile = 0.5, file.prefix='TFRwrldmap_', ...)
			
get.tfr.map.parameters(pred, tfr.range = NULL, 
    nr.cats = 50, same.scale = TRUE, quantile = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.map_+3A_pred">pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_quantile">quantile</code></td>
<td>
<p>Quantile for which the map should be generated. It must be equal to one of the values in <code>dimnames(pred$quantiles[[2]])</code>, i.e. 0, 0.025, 0.05, 0.1, 0.2, 0.25, 0.3, 0.4, 0.5, 0.6, 0.7, 0.75, 0.8, 0.9, 0.95, 0.975, 1. Value 0.5 corresponds to the median.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_year">year</code></td>
<td>
<p>Year to be plotted. It can be a year within a projection period or a year within an estimation period. In the latter case, the observed data are plotted. If not given, <code>projection.index</code> determines the projection year.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_par.name">par.name</code></td>
<td>
<p>Name of a country-specific parameter to be plotted. If <code>NULL</code>, the TFR is plotted. Allowed values are any of those returned by <code>tfr.parameter.names.cs.extended()</code> and &lsquo;lambda&rsquo; (see Details).</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_adjusted">adjusted</code></td>
<td>
<p>Logical indicating if the measure to be plotted is based on adjusted TFRs.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_projection.index">projection.index</code></td>
<td>
<p>Index of the projection to be displayed. It is only relevant if <code>year</code> is <code>NULL</code>. <code>projection.index=1</code> means the present year, <code>projection.index=2</code> means the first projection period after present year, etc..
</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_device">device</code></td>
<td>
<p>Device for displaying the map. It is passed to the <code><a href="rworldmap.html#topic+mapDevice">mapDevice</a></code> function of the <span class="pkg">rworldmap</span> package. If it is equal to &lsquo;dev.cur&rsquo;, the current device is used. Otherwise, it can be &lsquo;dev.new&rsquo;, &lsquo;png&rsquo;, &lsquo;pdf&rsquo; etc.
</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_main">main</code></td>
<td>

<p>Title for the map. If it is <code>NULL</code>, a default title is constructed from the projection year and quantile.
</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_resolution">resolution</code></td>
<td>
<p>Map resolution as implemented in <code><a href="rworldmap.html#topic+getMap">getMap</a></code>. High resolution requires the <span class="pkg">rworldxtra</span> package.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_device.args">device.args</code></td>
<td>
<p>List of 
additional arguments to be passed to the <code><a href="rworldmap.html#topic+mapDevice">mapDevice</a></code> function of the <span class="pkg">rworldmap</span> package.
</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_data.args">data.args</code></td>
<td>
<p>List of additional arguments to be passed to the underlying data retrieving function.</p>
</td></tr> 
<tr><td><code id="tfr.map_+3A_viridis.option">viridis.option</code></td>
<td>
<p>Argument <code>option</code> passed to the <code>ggplot2::scale_fill_viridis_c</code> function indicating the colormap. Available are &lsquo;magma&rsquo; (or &lsquo;A&rsquo;), &lsquo;inferno&rsquo; (or &lsquo;B&rsquo;, default), &lsquo;plasma&rsquo; (or &lsquo;C&rsquo;), &lsquo;viridis&rsquo; (or &lsquo;D&rsquo;) and &lsquo;cividis&rsquo; (or &lsquo;E&rsquo;).</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_nr.cats">nr.cats</code></td>
<td>
<p>Number of color categories.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_same.scale">same.scale</code></td>
<td>
<p>Logical controlling if maps for all projection years of this prediction object should be on the same color scale.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_plot">plot</code></td>
<td>
<p>Logical indicating if a plot should be shown. If <code>FALSE</code>, the function only returns the ggplot object.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_file.name">file.name</code></td>
<td>
<p>Name of a file to save the plot. If <code>NULL</code> nothing is saved. The type of the file is determined by its extension. Only used if <code>plot</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_plot.size">plot.size</code></td>
<td>
<p>Height of the plotting device in inches. The width is automatically set using the aspect ratio of 2.36. Only used if <code>plot</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which resulting maps are stored.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_output.type">output.type</code></td>
<td>
<p>Type of the resulting files. It can be &ldquo;png&rdquo;, &ldquo;pdf&rdquo;, &ldquo;jpeg&rdquo;, &ldquo;bmp&rdquo;, &ldquo;tiff&rdquo;, or &ldquo;postscript&rdquo;.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_tfr.range">tfr.range</code></td>
<td>
<p>Range of the total fertility rate to be displayed. It is of the form <code>c(</code><var>tfr.min</var>, <var>tfr.max</var><code>)</code>.
By default, the whole range is considered. Note that countries with values outside of the given range will appear white.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_file.prefix">file.prefix</code></td>
<td>
<p>Prefix for file names.</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_...">...</code></td>
<td>

<p>Arguments passed to the <code><a href="rworldmap.html#topic+mapCountryData">mapCountryData</a></code> function of the <span class="pkg">rworldmap</span> package. In case of <code>tfr.map.gvis</code> these are passed to the underlying data retrieving function (the same as <code>data.args</code>). In case of <code>tfr.ggmap</code> which uses <span class="pkg">ggplot2</span> they are passed to the <code>geom_sf</code> function.
</p>
</td></tr>
<tr><td><code id="tfr.map_+3A_pi">pi</code></td>
<td>
<p>Probability interval to be shown when a country is selected in an interactive map. The corresponding quantiles must be available (see argument <code>quantile</code> above).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tfr.map</code> creates a single map for a given projection period and quantile using the <span class="pkg">rworldmap</span> package. <code>tfr.map.all</code> generates a sequence of such maps, namely one for each projection period. If the package <span class="pkg">fields</span> is installed, a color bar legend at the botom of the map is created.
</p>
<p>Function <code>get.tfr.map.parameters</code> can be used in combination with <code>tfr.map</code>. (Note that <code>get.tfr.map.parameters</code> is called from inside of <code>tfr.map.all</code>.) It sets breakpoints for the color scheme using quantiles of a fitted gamma distribution.
</p>
<p>Function <code>tfr.ggmap</code> is similar to <code>tfr.map</code>, but used the <span class="pkg">ggplot2</span> package in combination with the <code>geom_sf</code> function.
</p>
<p>Function <code>tfr.map.gvis</code> creates an interactive map using the <span class="pkg">googleVis</span> package and opens it in an internet browser. It also generates a table of TFRs that can be sorted by columns interactively in the browser. 
</p>
<p>By default, <code>tfr.map</code>, <code>tfr.ggmap</code> and <code>tfr.map.gvis</code> produce maps of TFRs. Alternatively, the functions can be used to plot country-specific Phase II MCMC parameters into a world map. They are given by the argument <code>par.name</code>. In addition to the MCMC parameters, if <code>par.name='lambda'</code>, the period of the end of TFR decline (i.e. start of Phase III) is computed for each country and projected into the map. In such a case, for <code>tfr.map</code> we recommend to adjust the color scale in <code>tfr.map</code> e.g. using the arguments <code>catMethod='pretty'</code> and <code>numCats=20</code> (see <code><a href="rworldmap.html#topic+mapCountryData">mapCountryData</a></code>). 
</p>


<h3>Value</h3>

<p><code>get.tfr.map.parameters</code> returns a list with elements:
</p>
<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>The object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code> used in the function.</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>Value of the argument <code>quantile</code>.</p>
</td></tr>
<tr><td><code>catMethod</code></td>
<td>
<p>If the argument <code>same.scale</code> is <code>TRUE</code>, this element contains breakpoints for categorization. It is generated from a fitted gamma distribution. Otherwise, it is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>numCats</code></td>
<td>
<p>Number of categories.</p>
</td></tr>
<tr><td><code>coulourPalette</code></td>
<td>
<p>Subset of the rainbow palette, starting from dark blue and ending at red.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Additional arguments passed to the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Patrick Gerland, Adrian Raftery
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
pred &lt;- get.tfr.prediction(sim.dir=sim.dir)

# Using ggplot2
tfr.ggmap(pred)
tfr.ggmap(pred, year = 2100)

# Using rworldmap
# Uses heat colors and seven categories by default
tfr.map(pred)
# Uses more colors with more suitable categorization
params &lt;- get.tfr.map.parameters(pred)
do.call("tfr.map", params)
# Another projection year on the same scale
do.call("tfr.map", c(list(year=2043), params))

# Using Google Vizualization tool
tfr.map.gvis(pred)

## End(Not run)
</code></pre>

<hr>
<h2 id='tfr.median.set'>
Editing Medians of the Projection
</h2><span id='topic+tfr.median.set'></span><span id='topic+tfr.median.shift'></span><span id='topic+tfr.median.adjust'></span><span id='topic+tfr.median.reset'></span><span id='topic+tfr.shift.prediction.to.wpp'></span>

<h3>Description</h3>

<p>These functions are to be used by expert analysts. They allow to change the projection medians either to specific values, including the WPP values, or shift the medians by a given constant, or by a specific adjusting procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.median.set(sim.dir, country, values, years = NULL, ...)

tfr.median.shift(sim.dir, country, reset = FALSE, shift = 0, 
    from = NULL, to = NULL, ...)
    
tfr.median.adjust(sim.dir, countries, factor1 = 2/3, factor2 = 1/3, forceAR1 = FALSE,
    subdir = "predictions")

tfr.median.reset(sim.dir, countries = NULL, ...)

tfr.shift.prediction.to.wpp(sim.dir, subdir = "predictions", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.median.set_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory containing the prediction object.</p>
</td></tr>
<tr><td><code id="tfr.median.set_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country.</p>
</td></tr>
<tr><td><code id="tfr.median.set_+3A_countries">countries</code></td>
<td>
<p>Vector of country names or codes. If <code>NULL</code> in the <code>tfr.median.reset</code> function, the reset is done for all countries.</p>
</td></tr>
<tr><td><code id="tfr.median.set_+3A_values">values</code></td>
<td>
<p>Array of the new median values.</p>
</td></tr>
<tr><td><code id="tfr.median.set_+3A_years">years</code></td>
<td>
<p>Numeric vector giving years which <code>values</code> correspond to. Ideally it should be of the same length as <code>values</code>. If it is <code>NULL</code>,
<code>values</code> are set starting from the first prediction period. If <code>values</code> correspond to consecutive years, only the first year might be given here. A year <code class="reqn">t</code> represents a prediction period <code class="reqn">[t_i, t_{i+1}]</code> if <code class="reqn">t_i &lt; t \leq t_{i+1}</code>.</p>
</td></tr>
<tr><td><code id="tfr.median.set_+3A_reset">reset</code></td>
<td>
<p>Logical. If <code>TRUE</code> medians in a range of <code>from</code> and <code>to</code> are reset to their original values.</p>
</td></tr>
<tr><td><code id="tfr.median.set_+3A_shift">shift</code></td>
<td>
<p>Constant by which the medians should be offset. It is not used if <code>reset</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tfr.median.set_+3A_from">from</code></td>
<td>
<p>Year from which the offset/reset should start. By default, it starts at the first prediction period.</p>
</td></tr>
<tr><td><code id="tfr.median.set_+3A_to">to</code></td>
<td>
<p>Year until which the offset/reset should be done. By default, it is set to the last prediction period.</p>
</td></tr>
<tr><td><code id="tfr.median.set_+3A_factor1">factor1</code>, <code id="tfr.median.set_+3A_factor2">factor2</code></td>
<td>
<p>Adjusting factors for the first and second projection period, respectively (see below).</p>
</td></tr>
<tr><td><code id="tfr.median.set_+3A_forcear1">forceAR1</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the given countries are forced to enter Phase III (i.e. the AR(1) process) in the first projection period.</p>
</td></tr>
<tr><td><code id="tfr.median.set_+3A_subdir">subdir</code></td>
<td>
<p>Subdirectory of <code>sim.dir</code> containing the predictions.</p>
</td></tr>
<tr><td><code id="tfr.median.set_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying adjustment function. For <code>tfr.shift.prediction.to.wpp</code> it can be <code>stat</code> with values &ldquo;median&rdquo; (default) or &ldquo;mean&rdquo; to specify which statistics should be adjusted; <code>verbose</code> to show/hide the progress of the adjustment and <code>wpp.year</code> to adjust it to if it differs from the wpp year of the simulation. For the other functions it can be <code>subdir</code> to specify the location of the prediction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>tfr.median.set</code> can be used to set the medians of the given country to specific values. Function <code>tfr.median.shift</code> can be used to offset the medians by a specific constant, or to reset the medians to their original BHM values.
Function <code>tfr.median.adjust</code> runs the prediction procedure for the given countries with an additional decrement in the model in the first two projection periods. In the first projection period it is computed as <code>factor1*S</code> where <code>S</code> is a difference between observed decrement and the expected decrement (by the double logistic function) in the last observed period. In the second projection period, in the formula <code>factor1</code> is replaced by <code>factor2</code>. If <code>forceAR1</code> is set to <code>TRUE</code>, we recommend to set <code>factor1</code> and <code>factor2</code> to 0. The function then calls <code>tfr.median.set</code> in order to store the new median for each country.
</p>
<p>Function<code>tfr.shift.prediction.to.wpp</code> shifts the projected medians or means (if <code>stat</code> is &ldquo;mean&rdquo;), so that they correspond to the values found in the <code>tfrprojMed</code> datasets of the <span class="pkg">wpp</span> package that either corresponds to the package used for the simulation itself or is given by the <code>wpp.year</code> argument. If using <span class="pkg">wpp2022</span> or higher, the dataset name is automatically adjusted depending if it is an annual or a 5-year simulation. Note that regardless if it is an adjustment of the median or mean, the corresponding offset is always converted to a shift of the median. 
</p>
<p>Function <code>tfr.median.reset</code> resets medians of the given countries to the original values. By default it deletes adjustments for all countries.
</p>
<p>In all five functions, if a median is modified, the corresponding offset is stored in the prediction object (element <code>median.shift</code>) and the updated prediction object is written back to disk. All functions in the package that use trajectories and trajectory statistics use the <code>median.shift</code> values to offset the results correspondingly, i.e. trajectories are shifted the same way as the medians.
</p>


<h3>Value</h3>

<p>All functions return an updated object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Leontine Alkema</p>


<h3>See Also</h3>

<p><code><a href="#topic+tfr.median.set.all">tfr.median.set.all</a></code> for shifting estimation medians.</p>

<hr>
<h2 id='tfr.median.set.all'>
Editing median for estimation and projections.
</h2><span id='topic+tfr.median.set.all'></span><span id='topic+tfr.median.reset.estimation'></span><span id='topic+tfr.shift.estimation.to.wpp'></span>

<h3>Description</h3>

<p>These functions are to be used by expert analysts. They allow to change the estimation and projection medians to specific values or to the WPP values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.median.set.all(sim.dir, country, values, years = NULL, 
    burnin = 0, thin = 1, subdir = "predictions")

tfr.median.reset.estimation(sim.dir, countries = NULL)

tfr.shift.estimation.to.wpp(sim.dir, ..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.median.set.all_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory containing the prediction object.</p>
</td></tr>
<tr><td><code id="tfr.median.set.all_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country.</p>
</td></tr>
<tr><td><code id="tfr.median.set.all_+3A_countries">countries</code></td>
<td>
<p>Vector of country names or codes. If <code>NULL</code>, the reset is done for all countries.</p>
</td></tr>
<tr><td><code id="tfr.median.set.all_+3A_values">values</code></td>
<td>
<p>Array of the new median values.</p>
</td></tr>
<tr><td><code id="tfr.median.set.all_+3A_years">years</code></td>
<td>
<p>Numeric vector giving years which <code>values</code> correspond to. Ideally it should be of the same length as <code>values</code>.</p>
</td></tr>
<tr><td><code id="tfr.median.set.all_+3A_burnin">burnin</code></td>
<td>
<p>Burnin to use when computing the estimation median.</p>
</td></tr>
<tr><td><code id="tfr.median.set.all_+3A_thin">thin</code></td>
<td>
<p>Thinning interval to use when computing the estimation median.</p>
</td></tr>
<tr><td><code id="tfr.median.set.all_+3A_subdir">subdir</code></td>
<td>
<p>Subdirectory of <code>sim.dir</code> containing the predictions.</p>
</td></tr>
<tr><td><code id="tfr.median.set.all_+3A_...">...</code></td>
<td>
<p>Can be used to pass <code>burnin</code> <code>thin</code> to the underlying funcions.</p>
</td></tr>
<tr><td><code id="tfr.median.set.all_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> a progress of the adjustment is shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expert analysts can use these functions to adjust both prediction and estimation medians. Estimation medians can only be adjusted if the simulation was performed with <code>uncertainty = TRUE</code>. In such a case <code>years</code> can include past time periods. By default a union of estimation and projection time periods is considered when matched to <code>values</code>. 
</p>
<p>Function <code>tfr.shift.estimation.to.wpp</code> shifts the median estimation of all countries so that they match the values in the <code>tfr</code> dataset of the corresponding WPP package. Argument <code>burnin</code> and <code>thin</code> should be passed to compute the estimation medians.
</p>
<p>Function <code>tfr.median.reset.estimation</code> resets previous adjustments obtained using <code>tfr.median.set.all</code>. By default it resets adjustments for all countries.
</p>


<h3>Value</h3>

<p>Output is a list. If there are time periods matched to estimation, an object of class <code><a href="#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code> is included in the element <code>meta</code>. If there are time periods matched to years in prediction, then an object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code> is included in the element <code>pred</code>.
</p>
<p>Function <code>tfr.shift.estimation.to.wpp</code> returns the updated <code>mcmc.set</code> object.
</p>


<h3>Author(s)</h3>

<p>Peiran Liu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tfr.shift.prediction.to.wpp">tfr.shift.prediction.to.wpp</a></code> for shifting prediction medians to WPP values.</p>

<hr>
<h2 id='tfr.parameter.names'>
Accessing Parameter Names
</h2><span id='topic+tfr.parameter.names'></span><span id='topic+tfr.parameter.names.cs'></span><span id='topic+tfr.parameter.names.extended'></span><span id='topic+tfr.parameter.names.cs.extended'></span><span id='topic+tfr3.parameter.names'></span><span id='topic+tfr3.parameter.names.cs'></span>

<h3>Description</h3>

<p>Functions for accessing names of the MCMC parameters, either country-independent or country-specific.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.parameter.names(trans = NULL, meta = NULL)
tfr.parameter.names.cs(country.code = NULL, trans = NULL, back.trans = TRUE)
tfr.parameter.names.extended()
tfr.parameter.names.cs.extended(country.code = NULL)

tfr3.parameter.names()
tfr3.parameter.names.cs(country.code = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.parameter.names_+3A_trans">trans</code></td>
<td>
<p>It can be <code>NULL</code> or logical. If <code>TRUE</code>,
names of the transformable parameters (i.e. &lsquo;alpha&rsquo; in case of country-independent parameters, or &lsquo;gamma&rsquo; in case of country-specific parameters) are replaced by the names of the transformed parameters (i.e. &lsquo;alphat&rsquo;, or &lsquo;gammat&rsquo;). If <code>trans=FALSE</code>, there is no such replacement. If <code>trans=NULL</code>, all parameter names, 
including the transformable parameters are returned.</p>
</td></tr>
<tr><td><code id="tfr.parameter.names_+3A_meta">meta</code></td>
<td>
<p>It can be <code>NULL</code> or a <code><a href="#topic+bayesTFR.mcmc.meta">bayesTFR.mcmc.meta</a></code> object. If not <code>NULL</code> and its element <code>ar.phase2</code> is <code>TRUE</code> (i.e. the simulation considered an additional AR(1) parameter in the estimation), then the names include also &lsquo;phi&rsquo;.</p>
</td></tr>
<tr><td><code id="tfr.parameter.names_+3A_country.code">country.code</code></td>
<td>
<p>Country code. If it is given, the country-specific parameter names contain the postfix &lsquo;_c<code class="reqn">x</code>&rsquo; where <code class="reqn">x</code> is the <code>country.code</code>.</p>
</td></tr>
<tr><td><code id="tfr.parameter.names_+3A_back.trans">back.trans</code></td>
<td>
<p>Logical indicating if back-transformable parameter names (i.e. &lsquo;Triangle_c1&rsquo;, ..., &lsquo;Triangle_c3&rsquo;) should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tfr.parameter.names</code> returns names of the country-independent Phase II parameters.<br />
<code>tfr.parameter.names.cs</code> returns names of the country-specific Phase II parameters.<br />
<code>tfr.parameter.names.extended</code> returns names of all country-independent Phase II parameters, including the transformed parameters. Parameters &lsquo;alpha&rsquo;, &lsquo;delta&rsquo;, &lsquo;alphat&rsquo;, and&lsquo;deltat&rsquo; are in their extended format with the postfix &lsquo;_1&rsquo;, &lsquo;_2&rsquo; and &lsquo;_3&rsquo;. <br />
<code>tfr.parameter.names.cs.extended</code> returns names of all country-specific Phase II parameters, including the transformed parameters. Parameters &lsquo;gamma&rsquo; and&lsquo;gammat&rsquo; are in their extended format with the postfix &lsquo;_1&rsquo;, &lsquo;_2&rsquo; and &lsquo;_3&rsquo;.<br />
<code>tfr3.parameter.names</code> returns names of the country-independent Phase III parameters.<br />
<code>tfr3.parameter.names.cs</code> returns names of the country-specific Phase III parameters.<br />
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tfr.parameter.names()
tfr.parameter.names.extended()
tfr.parameter.names.cs()
tfr.parameter.names.cs.extended()
tfr3.parameter.names()
tfr3.parameter.names.cs()
</code></pre>

<hr>
<h2 id='tfr.pardensity.plot'>
Plotting MCMC Parameter Density
</h2><span id='topic+tfr.pardensity.plot'></span><span id='topic+tfr.pardensity.cs.plot'></span><span id='topic+tfr3.pardensity.plot'></span><span id='topic+tfr3.pardensity.cs.plot'></span>

<h3>Description</h3>

<p>Functions for plotting density of the posterior distribution of the MCMC parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.pardensity.plot(mcmc.list = NULL, 
    sim.dir = file.path(getwd(), "bayesTFR.output"), 
    chain.ids = NULL, par.names = tfr.parameter.names(trans = TRUE), 
    burnin = NULL, dev.ncol=5, low.memory = TRUE, ...)
    
tfr.pardensity.cs.plot(country, mcmc.list=NULL, 
    sim.dir=file.path(getwd(), "bayesTFR.output"), 
    chain.ids=NULL, par.names=tfr.parameter.names.cs(trans=TRUE), 
    burnin=NULL, dev.ncol=3, low.memory=TRUE, ...)
    
tfr3.pardensity.plot(mcmc.list = NULL, 
    sim.dir = file.path(getwd(), "bayesTFR.output"), 
    chain.ids = NULL, par.names = tfr3.parameter.names(), 
    burnin = NULL, dev.ncol=3, low.memory = TRUE, ...)
    
tfr3.pardensity.cs.plot(country, mcmc.list=NULL, 
    sim.dir=file.path(getwd(), "bayesTFR.output"), 
    chain.ids=NULL, par.names=tfr3.parameter.names.cs(), 
    burnin=NULL, dev.ncol=2, low.memory=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.pardensity.plot_+3A_country">country</code></td>
<td>
<p>Name or code of a country. The code can be either numeric or ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="tfr.pardensity.plot_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code><a href="#topic+bayesTFR.mcmc">bayesTFR.mcmc</a></code> objects, or an object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> or of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code> (allowed only for Phase II MCMCs). If it is <code>NULL</code>, the parameter values are loaded from <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="tfr.pardensity.plot_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. It is only used if <code>mcmc.list</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tfr.pardensity.plot_+3A_chain.ids">chain.ids</code></td>
<td>
<p>List of MCMC identifiers to be plotted. If it is <code>NULL</code>, all chains found in <code>mcmc.list</code> or <code>sim.dir</code> are plotted.</p>
</td></tr>
<tr><td><code id="tfr.pardensity.plot_+3A_par.names">par.names</code></td>
<td>
<p>Names of parameters for which density should be plotted. By default all (possibly transformed) country-independent parameters are plotted if used within <code>tfr.pardensity.plot</code> and <code>tfr3.pardensity.plot</code>, or country-specific parameters are plotted if used within <code>tfr.pardensity.cs.plot</code> and <code>tfr3.pardensity.cs.plot</code>.</p>
</td></tr>
<tr><td><code id="tfr.pardensity.plot_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of each chain.</p>
</td></tr>
<tr><td><code id="tfr.pardensity.plot_+3A_dev.ncol">dev.ncol</code></td>
<td>
<p>Number of column for the graphics device. If the number of parameters is smaller than <code>dev.ncol</code>, the number of columns is automatically decreased.</p>
</td></tr>
<tr><td><code id="tfr.pardensity.plot_+3A_low.memory">low.memory</code></td>
<td>
<p>Logical indicating if the processing should run in a low-memory mode. If it is <code>FALSE</code>, traces of all available parameters are loaded into memory. Otherwise, parameters are loaded as they are needed and are not kept in the memory.</p>
</td></tr>
<tr><td><code id="tfr.pardensity.plot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>density</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions plot the density of the posterior distribution either for country-independent parameters (<code>tfr.pardensity.plot</code> for phase II MCMCs and <code>tfr3.pardensity.plot</code> for phase III MCMCs) or for country-specific parameters (<code>tfr.pardensity.cs.plot</code> for phase II and <code>tfr3.pardensity.cs.plot</code> for phase III), one graph per parameter.  One can restrict it to specific chains by setting the <code>chain.ids</code> argument and to specific parameters by setting the <code>par.names</code> argument. 
</p>
<p>If <code>mcmc.list</code> is an object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code> (which is allowed in <code>tfr.pardensity.plot</code> and <code>tfr.pardensity.cs.plot</code> only) and if this object contains thinned traces, they are used instead of the full chains. In such a case, <code>burnin</code> and <code>chain.ids</code> cannot be modified - their value is set to the one used when the thinned traces were created, namely when running <code><a href="#topic+tfr.predict">tfr.predict</a></code>. In a situation with long MCMC chains, this approach can  significantly speed-up creation of the density plots.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tfr.partraces.plot">tfr.partraces.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
tfr.pardensity.plot(sim.dir=sim.dir)
tfr.pardensity.cs.plot(country="Ireland", sim.dir=sim.dir, bw=0.2)

## End(Not run)
</code></pre>

<hr>
<h2 id='tfr.partraces.plot'>
Plotting MCMC Parameter Traces
</h2><span id='topic+tfr.partraces.plot'></span><span id='topic+tfr.partraces.cs.plot'></span><span id='topic+tfr3.partraces.plot'></span><span id='topic+tfr3.partraces.cs.plot'></span>

<h3>Description</h3>

<p>Functions for plotting the MCMC parameter traces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.partraces.plot(mcmc.list = NULL, 
    sim.dir = file.path(getwd(), "bayesTFR.output"), chain.ids = NULL, 
    par.names = tfr.parameter.names(trans = TRUE), 
    nr.points = NULL, dev.ncol=5, low.memory = TRUE, ...)
	
tfr.partraces.cs.plot(country, mcmc.list = NULL, 
    sim.dir = file.path(getwd(), "bayesTFR.output"), chain.ids = NULL, 
    par.names = tfr.parameter.names.cs(trans = TRUE), 
    nr.points = NULL, dev.ncol=3, low.memory = TRUE, ...)
    
tfr3.partraces.plot(mcmc.list = NULL, 
    sim.dir = file.path(getwd(), "bayesTFR.output"), chain.ids = NULL, 
    par.names = tfr3.parameter.names(), 
    nr.points = NULL, dev.ncol=3, low.memory = TRUE, ...)
	
tfr3.partraces.cs.plot(country, mcmc.list = NULL, 
    sim.dir = file.path(getwd(), "bayesTFR.output"), chain.ids = NULL, 
    par.names = tfr3.parameter.names.cs(), 
    nr.points = NULL, dev.ncol=2, low.memory = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.partraces.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. The code can be either numeric or ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="tfr.partraces.plot_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code>bayesTFR.mcmc</code> objects, or an object of class <code>bayesTFR.mcmc.set</code> or of class <code>bayesTFR.prediction</code> (allowed only for Phase II MCMCs). If it is <code>NULL</code>, the traces are loaded from <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="tfr.partraces.plot_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. It is only used if <code>mcmc.list</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tfr.partraces.plot_+3A_chain.ids">chain.ids</code></td>
<td>
<p>List of MCMC identifiers to be plotted. If it is <code>NULL</code>, all chains found in <code>mcmc.list</code> or <code>sim.dir</code> are plotted.</p>
</td></tr>
<tr><td><code id="tfr.partraces.plot_+3A_par.names">par.names</code></td>
<td>
<p>Names of parameters for which traces should be plotted. By default all (possibly transformed) country-independent parameters are plotted if used within <code>tfr.partraces.plot</code> and <code>tfr3.partraces.plot</code>, or country-specific parameters are plotted if used within <code>tfr.partraces.cs.plot</code> and <code>tfr3.partraces.cs.plot</code>.</p>
</td></tr>
<tr><td><code id="tfr.partraces.plot_+3A_nr.points">nr.points</code></td>
<td>
<p>Number of points to be plotted. If <code>NULL</code>, all points are plotted, otherwise the traces are thinned evenly.</p>
</td></tr>
<tr><td><code id="tfr.partraces.plot_+3A_dev.ncol">dev.ncol</code></td>
<td>
<p>Number of column for the graphics device. If the number of parameters is smaller than <code>dev.ncol</code>, the number of columns is automatically decreased.</p>
</td></tr>
<tr><td><code id="tfr.partraces.plot_+3A_low.memory">low.memory</code></td>
<td>
<p>Logical indicating if the processing should run in a low-memory mode. If it is <code>FALSE</code>, traces of all available parameters are loaded into memory. Otherwise, parameters are loaded as they are needed and are not kept in the memory.</p>
</td></tr>
<tr><td><code id="tfr.partraces.plot_+3A_...">...</code></td>
<td>
<p>Additional graphical arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions plot MCMC traces either for country-independent parameters (<code>tfr.partraces.plot</code> for phase II MCMCs and <code>tfr3.partraces.plot</code> for phase III MCMCs) or for country-specific parameters (<code>tfr.partraces.cs.plot</code> for phase II MCMCs and <code>tfr3.partraces.cs.plot</code> for phase III MCMCs), one graph per parameter.  One can restrict it to specific chains by setting the <code>chain.ids</code> argument, and to specific parameters by setting the <code>par.names</code> argument.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coda.list.mcmc">coda.list.mcmc</a></code> for retrieving raw values of the traces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
tfr.partraces.plot(sim.dir=sim.dir)
tfr.partraces.cs.plot(country="Netherlands", sim.dir=sim.dir)

## End(Not run)
</code></pre>

<hr>
<h2 id='tfr.predict'>
Generating Posterior Trajectories of the Total Fertility Rate
</h2><span id='topic+tfr.predict'></span><span id='topic+bayesTFR.prediction'></span>

<h3>Description</h3>

<p>Using the posterior parameter samples simulated by <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code> (and possibly <code><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a></code>) the function  generates posterior trajectories for the total fertility rate for all countries of the world.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.predict(mcmc.set = NULL, end.year = 2100, 
    sim.dir = file.path(getwd(), "bayesTFR.output"), 
    replace.output = FALSE, start.year = NULL, 
    nr.traj = NULL, thin = NULL, burnin = 2000,
    use.diagnostics = FALSE, use.tfr3 = TRUE, burnin3 = 2000,
    mu = 2.1, rho = 0.8859, sigmaAR1 = 0.1016, min.tfr = 0.5,
    use.correlation = FALSE, save.as.ascii = 0, output.dir = NULL, 
    subdir = "predictions", low.memory = TRUE, seed = NULL, 
    verbose = TRUE, uncertainty = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.predict_+3A_mcmc.set">mcmc.set</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> corresponding Phase II MCMCs. If it is <code>NULL</code>, the object is loaded from the directory given by <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_end.year">end.year</code></td>
<td>
<p>End year of the prediction.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. It should equal to the <code>output.dir</code> argument in <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_replace.output">replace.output</code></td>
<td>
<p>Logical. If <code>TRUE</code>, existing predictions in <code>output.dir</code> will be replaced by results of this run.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_start.year">start.year</code></td>
<td>
<p>Start year of the prediction. By default the prediction is started at the next time period after <code>present.year</code> set in the estimation step. If <code>start.year</code> is smaller than the default, projections for countries and time periods that have data available after <code>start.year</code> are set to those data.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to be generated. If <code>NULL</code>, the argument <code>thin</code> is taken to determine the number of trajectories. If both are <code>NULL</code>, the number of trajectories corresponds to the size of the parameter sample.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_thin">thin</code></td>
<td>
<p>Thinning interval used for determining the number of trajectories. Only relevant, if <code>nr.traj</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of the parameter traces.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_use.diagnostics">use.diagnostics</code></td>
<td>
<p>Logical determining if an existing convergence diagnostics for phase II MCMCs should be used for choosing the values of <code>thin</code> and <code>burnin</code>. In such a case, arguments <code>nr.traj</code>, <code>thin</code> and <code>burnin</code> are ignored. The &lsquo;best&rsquo; values are chosen from results of running the <code><a href="#topic+tfr.diagnose">tfr.diagnose</a></code> function. Only diagnostics can be used that suggest a convergence of the underlying MCMCs. If there are more than one such objects, the one is chosen whose recommendation for the number of trajectories is larger and closest to 2000.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_use.tfr3">use.tfr3</code></td>
<td>
<p>Logical determining if phase III should be predicted via MCMCs (simulated via <code><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a></code>) or a classic AR(1) process. If <code>TRUE</code> but no phase III MCMCs were simulated, a warning is given and the prediction switches automatically to a classic AR(1) process.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_burnin3">burnin3</code></td>
<td>
<p>Burnin used for phase III MCMCs. Only relevant if <code>use.tfr3</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_save.as.ascii">save.as.ascii</code></td>
<td>
<p>Either a number determining how many trajectories should be converted into an ASCII file, or &ldquo;all&rdquo; in which case all trajectories are converted. It should be set to 0, if no conversion is desired.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which the resulting prediction object and the trajectories are stored. If it is <code>NULL</code>, it is set to either <code>sim.dir</code>, or to <code>output.dir</code> of <code>mcmc.set$meta</code> if <code>mcmc.set</code> is given.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_subdir">subdir</code></td>
<td>
<p>Subdirectory of <code>output.dir</code> to store the predictions. It is defined relative to <code>output.dir</code> and can only have one level.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_low.memory">low.memory</code></td>
<td>
<p>Logical indicating if the prediction should run in a low-memory mode. If it is <code>FALSE</code>, the whole traces of all parameters, including the burnin, are loaded into memory. Otherwise, burnins are discarded and parameters are loaded as they are needed and are not kept in the memory.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_mu">mu</code></td>
<td>
<p>Long-term mean <code class="reqn">\mu</code> in the AR(1) projection model. Only used if <code>use.tfr3</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_rho">rho</code></td>
<td>
<p>Autoregressive parameter <code class="reqn">\rho</code> in AR(1) projection model. If it is <code>NULL</code> it is estimated from the data. Only used if <code>use.tfr3</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_sigmaar1">sigmaAR1</code></td>
<td>
<p>Standard deviation <code class="reqn">s</code> of AR(1) distortion terms in short-term projections. If it is <code>NULL</code> it is estimated from the data. It can be a single value or a vector giving the standard deviations for single projections. If the vector is shorter than the number of projections simulated via the AR(1) process, the last value is repeated for the remaining projections. In case of a single value (default), the standard deviation is kept constant over all AR(1) projections. Only used if <code>use.tfr3</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_min.tfr">min.tfr</code></td>
<td>
<p>Smallest TFR value allowed.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_use.correlation">use.correlation</code></td>
<td>
<p>Logical. If <code>TRUE</code> the model errors are sampled jointly for all countries (Fosdick and Raftery, 2014).</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_seed">seed</code></td>
<td>
<p>Seed of the random number generator. If <code>NULL</code> no seed is set. It can be used to generate reproducible projections.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Logical. If the MCMC steps has considered uncertainty of past TFR and <code>uncertainty=TRUE</code>, starting point of prediction trajectories will be the last estimated trajectories of TFR. Otherwise, it will use last observed TFR as starting point of prediction.</p>
</td></tr>
<tr><td><code id="tfr.predict_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trajectories are generated using a distribution of country-specific decline curves (Alkema et al 2011) and either a classic AR(1) process or a country-specific AR(1) process (Raftery et al 2013).  Phase II parameter samples  simulated using <code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code> are used from all chains, from which the given burnin was discarded. They are evenly thinned to match <code>nr.traj</code> or using the <code>thin</code> argument. Such thinned parameter traces, collapsed into one chain, if they do not already exist, are stored on disk into the sub-directory &lsquo;<span class="file">{thinned_mcmc_<em>t</em>_<em>b</em></span>&rsquo; where <em>t</em> is the value  of <code>thin</code> and <em>b</em> the value of <code>burnin</code> (see <code><a href="#topic+create.thinned.tfr.mcmc">create.thinned.tfr.mcmc</a></code>). 
</p>
<p>If Phase III is projected using a BHM (i.e. if <code>use.tfr3</code> is <code>TRUE</code>), parameter samples simulated via <code><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a></code> are used from which burnin (given by <code>burnin3</code>) is discarded and the chains are evenly thinned in a way that the total size corresponds to the final size of the Phase II parameter samples. Countries for which there are no simulated country-specific Phase III parameters (e.g. because their TFR is still in Phase II or it is an aggregated region) use samples of the  &ldquo;world&rdquo; AR(1) parameters.
</p>
<p>The projection is run for all missing values before the present year, if any. Medians over the trajectories are used as  imputed values and the trajectories are discarded. The process then continues by projecting the future values where all generated trajectories are kept.
</p>
<p>The resulting prediction object is saved into &lsquo;<span class="file">{output.dir}/{subdir}</span>&rsquo;. Trajectories for all countries are saved into the same directory in a binary format, one file per country. At the end of the projection, if <code>save.as.ascii</code> is larger than 0, the function converts the given number of trajectories into a CSV file of a UN-specific format. They are selected by equal spacing (see function <code><a href="#topic+convert.tfr.trajectories">convert.tfr.trajectories</a></code> for more details on the conversion). In addition, two summary files are created: one in a user-friendly format, the other using a UN-specific coding of the variants and time (see <code><a href="#topic+write.projection.summary">write.projection.summary</a></code> for more details).
</p>


<h3>Value</h3>

<p>Object of class <code>bayesTFR.prediction</code> which is a list containing components:
</p>
<table role = "presentation">
<tr><td><code>quantiles</code></td>
<td>
<p>A <code class="reqn">n \times q \times p</code> array of quantile values computed on all trajectories. <code class="reqn">n</code> is the number of countries,
<code class="reqn">q</code> is the number of quantile bounds and <code class="reqn">p</code> is the number of projections.</p>
</td></tr>
<tr><td><code>traj.mean.sd</code></td>
<td>
<p>A <code class="reqn">n \times 2 \times p</code> array holding the mean of all trajectories in the first column and the standard deviation in the second column.
<code class="reqn">n</code> and <code class="reqn">p</code> are the number of countries and number of projections, respectively.</p>
</td></tr>
<tr><td><code>nr.traj</code></td>
<td>
<p>Number of trajectories.</p>
</td></tr>
<tr><td><code>trf_matrix_reconstructed</code></td>
<td>
<p>Matrix containing imputed TFR values on spots where the original TFR matrix has missing values, i.e. between the last observed data point and the present year. </p>
</td></tr>
<tr><td><code>output.directory</code></td>
<td>
<p>Directory where trajectories corresponding to this prediction are stored.</p>
</td></tr>
<tr><td><code>nr.projections</code></td>
<td>
<p>Number of projections.</p>
</td></tr>
<tr><td><code>burnin</code>, <code>thin</code>, <code>burnin3</code>, <code>thin3</code></td>
<td>
<p>Burnin and thin used for this prediction for Phase II and Phase III, respectively.</p>
</td></tr>
<tr><td><code>end.year</code></td>
<td>
<p>The end year of this prediction.</p>
</td></tr>
<tr><td><code>mu</code>, <code>rho</code>, <code>sigma_t</code>, <code>sigmaAR1</code></td>
<td>
<p>Parameters of the AR(1) process. <code>sigma_t</code> is a vector of actual values of the standard deviation <code class="reqn">s</code> used for each projection.</p>
</td></tr>
<tr><td><code>min.tfr</code></td>
<td>
<p>Input value of minimum threshold for TFR.</p>
</td></tr>
<tr><td><code>na.index</code></td>
<td>
<p>Index of trajectories for which at least one country got <code>NA</code> values.</p>
</td></tr>
<tr><td><code>mcmc.set</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.mcmc.set">bayesTFR.mcmc.set</a></code> used for this prediction, i.e. the burned, thinned, and collapsed MCMC chain.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Leontine Alkema, Peiran Liu, Bailey Fosdick
</p>


<h3>References</h3>

<p>Peiran Liu, Hana Sevcikova, Adrian E. Raftery (2023): Probabilistic Estimation and Projection of the Annual Total Fertility Rate Accounting for Past Uncertainty: A Major Update of the bayesTFR R Package. Journal of Statistical Software, 106(8), 1-36. <a href="https://doi.org/10.18637/jss.v106.i08">doi:10.18637/jss.v106.i08</a>.
</p>
<p>L. Alkema, A. E. Raftery, P. Gerland, S. J. Clark, F. Pelletier, Buettner, T., Heilig, G.K. (2011). Probabilistic Projections of the Total Fertility Rate for All Countries. Demography, Vol. 48, 815-839. <a href="https://doi.org/10.1007/s13524-011-0040-5">doi:10.1007/s13524-011-0040-5</a>.
</p>
<p>Raftery, A.E., Alkema, L. and Gerland, P. (2014). Bayesian Population Projections for the United Nations. Statistical Science, Vol. 29, 58-68. <a href="https://doi.org/10.1214/13-STS419">doi:10.1214/13-STS419</a>. 
</p>
<p>Fosdick, B., Raftery, A.E. (2014). Regional Probabilistic Fertility Forecasting by Modeling Between-Country Correlations. Demographic Research, Vol. 30, 1011-1034. <a href="https://doi.org/10.4054/demres.2014.30.35">doi:10.4054/demres.2014.30.35</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.tfr.mcmc">run.tfr.mcmc</a></code>, <code><a href="#topic+run.tfr3.mcmc">run.tfr3.mcmc</a></code>, <code><a href="#topic+create.thinned.tfr.mcmc">create.thinned.tfr.mcmc</a></code>, <code><a href="#topic+convert.tfr.trajectories">convert.tfr.trajectories</a></code>, <code><a href="#topic+write.projection.summary">write.projection.summary</a></code>,    
<code><a href="#topic+get.tfr.prediction">get.tfr.prediction</a></code>, <code><a href="#topic+summary.bayesTFR.prediction">summary.bayesTFR.prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
m &lt;- run.tfr.mcmc(nr.chains=1, iter=10, output.dir=sim.dir, verbose=TRUE)
m3 &lt;- run.tfr3.mcmc(sim.dir=sim.dir, nr.chains=2, iter=40, thin=1, verbose=TRUE)
pred &lt;- tfr.predict(m, burnin=0, burnin3=10, verbose=TRUE)
summary(pred, country="Iceland")
unlink(sim.dir, recursive=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='tfr.predict.extra'>
Generating Posterior Trajectories of the Total Fertility Rate for Specific Countries or Regions
</h2><span id='topic+tfr.predict.extra'></span>

<h3>Description</h3>

<p>Using the posterior parameter samples the function  generates posterior trajectories of the total fertility rate for given countries or regions. It is intended to be used after running <code><a href="#topic+run.tfr.mcmc.extra">run.tfr.mcmc.extra</a></code>, but it can be also used for purposes of testing specific settings on one or a few countries. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.predict.extra(sim.dir = file.path(getwd(), 'bayesTFR.output'), 
    prediction.dir = sim.dir, subdir = "predictions", countries = NULL, 
    save.as.ascii = 0, verbose = TRUE, uncertainty=FALSE,
    all.countries.required = TRUE, use.correlation = NULL)
	</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.predict.extra_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results.</p>
</td></tr>
<tr><td><code id="tfr.predict.extra_+3A_prediction.dir">prediction.dir</code></td>
<td>
<p>Directory where the prediction object and the trajectories are stored.</p>
</td></tr>
<tr><td><code id="tfr.predict.extra_+3A_subdir">subdir</code></td>
<td>
<p>Subdirectory of <code>prediction.dir</code> containing the predictions.</p>
</td></tr>
<tr><td><code id="tfr.predict.extra_+3A_countries">countries</code></td>
<td>
<p>Vector of country codes for which the prediction should be made. If it is <code>NULL</code>, the prediction is run for all countries that are included in the MCMC object but for which no prediction was generated.</p>
</td></tr>
<tr><td><code id="tfr.predict.extra_+3A_save.as.ascii">save.as.ascii</code></td>
<td>
<p>Either a number determining how many trajectories should be converted into an ascii file, or &ldquo;all&rdquo; in which case all trajectories are converted. It should be set to 0, if no conversion is desired. Note that the conversion is done on all countries.</p>
</td></tr>
<tr><td><code id="tfr.predict.extra_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="tfr.predict.extra_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Logical. If the MCMC steps considered uncertainty of past TFR and <code>uncertainty=TRUE</code>, starting point of prediction trajectories will be the last estimated trajectories of TFR. Otherwise, it will use the last observed TFR as starting point of prediction.</p>
</td></tr>
<tr><td><code id="tfr.predict.extra_+3A_all.countries.required">all.countries.required</code></td>
<td>
<p>If <code>FALSE</code> it is not required that MCMCs of all countries are present.</p>
</td></tr>
<tr><td><code id="tfr.predict.extra_+3A_use.correlation">use.correlation</code></td>
<td>
<p>If missing and if the number of countries is larger than one, it takes the same value as was used in the main simulation. For one country the default is <code>FALSE</code>. If this parameter is <code>TRUE</code> the model errors are sampled jointly for all countries included in this prediction (Fosdick and Raftery, 2014).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to use this function, a prediction object must exist, i.e. the function <code><a href="#topic+tfr.predict">tfr.predict</a></code> must have been processed prior to using this function.
</p>
<p>Trajectories for given countries or regions are generated and stored in binary format along with other countries (in <code>prediction_dir</code>). The existing prediction object is updated and stored in the same directory. If <code>save.as.ascii</code> is larger than zero, trajectories of ALL countries are converted to an ascii format. 
</p>


<h3>Value</h3>

<p>Updated object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tfr.predict">tfr.predict</a></code>
</p>

<hr>
<h2 id='tfr.predict.subnat'>
Generating Posterior Trajectories of Subnational TFR
</h2><span id='topic+tfr.predict.subnat'></span>

<h3>Description</h3>

<p>Generates posterior trajectories of the total fertility rate for subregions of given countries, using the Scale-AR(1) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.predict.subnat(countries, my.tfr.file, 
                sim.dir = file.path(getwd(), "bayesTFR.output"), 
                end.year = 2100, start.year = NULL, subdir = "predictions", 
                output.dir = NULL, annual = NULL, nr.traj = NULL, seed = NULL, 
                min.tfr = 0.5, ar.pars = NULL, save.as.ascii = 0, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.predict.subnat_+3A_countries">countries</code></td>
<td>
<p>Vector of numerical country codes or country names.</p>
</td></tr>
<tr><td><code id="tfr.predict.subnat_+3A_my.tfr.file">my.tfr.file</code></td>
<td>
<p>Tab-separated ASCII file containing the subnational TFR data. See Details for more information on its format.</p>
</td></tr>
<tr><td><code id="tfr.predict.subnat_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Simulation directory with the national projections generated using <code><a href="#topic+tfr.predict">tfr.predict</a></code>.</p>
</td></tr>
<tr><td><code id="tfr.predict.subnat_+3A_end.year">end.year</code></td>
<td>
<p>End year of the projections.</p>
</td></tr>
<tr><td><code id="tfr.predict.subnat_+3A_start.year">start.year</code></td>
<td>
<p>Start year of the projections. By default, projections start at the same time point as the national projections.</p>
</td></tr> 
<tr><td><code id="tfr.predict.subnat_+3A_subdir">subdir</code></td>
<td>
<p>Subdirectory of <code>sim.dir</code> containing the national predictions.</p>
</td></tr>
<tr><td><code id="tfr.predict.subnat_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which the resulting prediction objects and the trajectories are stored. See below for details.</p>
</td></tr>
<tr><td><code id="tfr.predict.subnat_+3A_annual">annual</code></td>
<td>
<p>Logical indicating if the subnational projection should be on an annual scale or a 5-year scale. By default, 
the scale is matched to the national simulation. If the subnational and national scales are not the same, the national trajectories are either interpolated (if <code>annual = TRUE</code> and the national simulation is not annual) or averaged to 5-year values (if <code>annual = FALSE</code> and the national simulation is annual).</p>
</td></tr>
<tr><td><code id="tfr.predict.subnat_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to be generated. If <code>NULL</code>, the number of trajectories in the national projections is used.</p>
</td></tr>
<tr><td><code id="tfr.predict.subnat_+3A_seed">seed</code></td>
<td>
<p>Seed of the random number generator. If NULL no seed is set. It can be used to generate reproducible projections.</p>
</td></tr>
<tr><td><code id="tfr.predict.subnat_+3A_min.tfr">min.tfr</code></td>
<td>
<p>Lower bound on TFR.</p>
</td></tr>
<tr><td><code id="tfr.predict.subnat_+3A_ar.pars">ar.pars</code></td>
<td>
<p>Named vector containing the parameter estimates of the AR(1) process. If given, it must have elements called <code>mu</code>, <code>rho</code> and <code>sigma</code>. By default for a 5-year simulation, <code>c(mu = 1, rho = 0.92464, sigma = 0.04522)</code> is used. For an annual simulation these default parameters are scaled to <code>c(mu = 1, rho = 0.98445, sigma = 0.02086)</code>, see details below.</p>
</td></tr>
<tr><td><code id="tfr.predict.subnat_+3A_save.as.ascii">save.as.ascii</code></td>
<td>
<p>Either a number determining how many trajectories should be converted into an ASCII file, or &ldquo;all&rdquo; in which case all trajectories are converted. By default no conversion is performed.</p>
</td></tr>
<tr><td><code id="tfr.predict.subnat_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the methodology described in Sevcikova et al (2017). Given a set of national bayesTFR projections, it applies the Scale-AR(1) model to each national trajectory and each subregion of given countries which yield subnational TFR projections. 
</p>
<p>The file on subnational data passed in <code>my.tfr.file</code> has to have a column &ldquo;country_code&rdquo; with numerical values corresponding to countries given in the argument <code>countries</code>, and column &ldquo;reg_code&rdquo; giving the numerical identifier of each subregion. Column &ldquo;name&rdquo; should be used for subregion name, and column &ldquo;country&rdquo; for country name. An optional column  &ldquo;include_code&rdquo; can be used to eliminate entries from processing. Entries with values of 1 or 2 will be included, all others will be ignored. Column &ldquo;last.observed&rdquo; can be used to define which time period contains the last observed data point (given as integer, e.g. year in the middle of the time period). Remaining columns define the time periods, e.g. &ldquo;2000-2005&rdquo;, &ldquo;2005-2010&rdquo; for a 5-year simulation, or &ldquo;2020&rdquo;, &ldquo;2021&rdquo; for an annual simulation. The package contains an example of such dataset, see Example below.
</p>
<p>The default AR(1) parameters were designed for a 5-year simulation, see Sevcikova et al (2017) for more detail. These are <code class="reqn">\mu = 1, \rho = 0.92464, \sigma = 0.04522</code>. We use the following conversion for the autoregressive parameter <code class="reqn">\rho</code> and the standard deviation <code class="reqn">\sigma</code> if an annual AR(1) process is desired: <code class="reqn">\rho^* = \rho^{(1/5)}, \sigma^* = \sigma * \sqrt{((1 - \rho^{(2/5)})/(1 - \rho^2))}</code>. The long-term mean <code class="reqn">\mu</code> stays the same for both processes. Thus, the annual parameters are  <code>c(mu = 1, rho = 0.98445, sigma = 0.02086)</code>. Note that if the <code>ar.pars</code> argument is specified by the user, it is assumed that the parameters have been scaled appropriately and thus, no conversion takes place.
</p>
<p>Argument <code>output.dir</code> gives a location on disk where results of the function should be stored. If it is <code>NULL</code> (default),  results are stored in the same directory as the national projections. In both cases a subdirectory called &ldquo;subnat&rdquo; is created in which each country has its own subfolder with the country code in its name. Each such subfolder contains the same type of outputs as in the national case generated using <code><a href="#topic+tfr.predict">tfr.predict</a></code>, most importantly a directory &ldquo;predictions&rdquo; with trajectories for each region.
</p>


<h3>Value</h3>

<p>A list of objects of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>. The name of each element includes its country code. Not all elements of the class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code> are available. For example, no <code>mcmc.set</code> is attached to these objects. Thus, not all functions that work with <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code> can be applied to these results.
</p>


<h3>Note</h3>

<p>Even though the resulting object contains subnational results, the names  of its elements are the same as in the national case. This allows to apply the same functions on both objects (subnational and national). However, it means that sometimes the meaning of the elements or function arguments does not match the subnational context. For example, various functions expect the argument <code>country</code>. When a subnational object is passed to such function, <code>country</code> means a subregion. 
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>References</h3>

<p>Hana Sevcikova, Adrian E. Raftery, Patrick Gerland (2018). Probabilistic Projection of Subnational Total Fertility Rates. Demographic Research, Vol. 38(60), 1843-1884. <a href="https://doi.org/10.4054/DemRes.2018.38.60">doi:10.4054/DemRes.2018.38.60</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.regtfr.prediction">get.regtfr.prediction</a></code>, <code><a href="#topic+tfr.predict">tfr.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># View the example data
my.subtfr.file &lt;- file.path(find.package("bayesTFR"), 'extdata', 'subnational_tfr_template.txt')
subtfr &lt;- read.delim(my.subtfr.file, check.names=FALSE)
head(subtfr)

# Directory with national projections (contains 30 trajectories for each country)
nat.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")

# Subnational projections for Australia and Canada
subnat.dir &lt;- tempfile()
preds &lt;- tfr.predict.subnat(c(36, 124), my.tfr.file=my.subtfr.file,
    sim.dir=nat.dir, output.dir=subnat.dir, start.year=2013)
names(preds)
get.countries.table(preds[["36"]])
summary(preds[["36"]], "Queensland")
tfr.trajectories.plot(preds[["36"]], "Queensland")

# plot subnational and national TFR in one plot
nat.pred &lt;- get.tfr.prediction(nat.dir)
tfr.trajectories.plot(preds[["36"]], 186, pi=80, half.child.variant=FALSE)
tfr.trajectories.plot(nat.pred, "Australia", half.child.variant=FALSE,
      add=TRUE, col=rep("darkgreen", 5), nr.traj=0, show.legend=FALSE)
legend("topright", c("regional TFR", "national TFR"), col=c("red", "darkgreen"), 
  lty=1, bty='n')

# Retrieve trajectories
trajs.Alberta &lt;- get.tfr.trajectories(preds[["124"]], "Alberta")
summary(t(trajs.Alberta))

# cleanup
unlink(subnat.dir)

# See more examples in ?get.regtfr.prediction
</code></pre>

<hr>
<h2 id='tfr.raftery.diag'>
Raftery Diagnostics for Parameters of the Total Fertility Rate
</h2><span id='topic+tfr.raftery.diag'></span><span id='topic+tfr3.raftery.diag'></span>

<h3>Description</h3>

<p>The functions compute the Raftery diagnostics for each parameter of MCMCs of phase II (<code>tfr.raftery.diag</code>) and phase III (<code>tfr3.raftery.diag</code>), taking median over all chains.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.raftery.diag(mcmc = NULL, 
    sim.dir = file.path(getwd(), "bayesTFR.output"), 
    burnin = 0, country = NULL,
    par.names = NA, par.names.cs = NA,
    country.sampling.prop = 1, verbose=TRUE, ...)

tfr3.raftery.diag(mcmc = NULL, 
    sim.dir = file.path(getwd(), "bayesTFR.output"), 
    burnin = 0, country = NULL,
    par.names = NA, par.names.cs = NA,
    country.sampling.prop = 1, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.raftery.diag_+3A_mcmc">mcmc</code></td>
<td>

<p>A <code>bayesTFR.mcmc</code> or <code>bayesTFR.mcmc.set</code> object.
</p>
</td></tr>
<tr><td><code id="tfr.raftery.diag_+3A_sim.dir">sim.dir</code></td>
<td>

<p>Directory with the MCMC simulation results. Only used if <code>mcmc</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="tfr.raftery.diag_+3A_burnin">burnin</code></td>
<td>

<p>Burnin.
</p>
</td></tr>
<tr><td><code id="tfr.raftery.diag_+3A_country">country</code></td>
<td>
<p>Name or code of a country. If it is given, country-specific parameters are reduced to parameters of that country.</p>
</td></tr>
<tr><td><code id="tfr.raftery.diag_+3A_par.names">par.names</code></td>
<td>

<p>Names of country-independent parameters for which the Raftery diagnostics should be computed. By default all parameters are used.
If it is <code>NULL</code>, no country-independent parameters are used.
</p>
</td></tr>
<tr><td><code id="tfr.raftery.diag_+3A_par.names.cs">par.names.cs</code></td>
<td>

<p>Names of country-specific parameters for which the Raftery diagnostics should be computed. By default all parameters are used.
If it is <code>NULL</code>, no country-specific parameters are used.
</p>
</td></tr>
<tr><td><code id="tfr.raftery.diag_+3A_country.sampling.prop">country.sampling.prop</code></td>
<td>
<p>Proportion of countries that are included in the diagnostics. It should be between 0 and 1. If it is smaller than 1, the countries are randomly sampled. It is only relevant if <code>par.names.cs</code> is not <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="tfr.raftery.diag_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="tfr.raftery.diag_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="#topic+coda.list.mcmc">coda.list.mcmc</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Raftery diagnostics is computed for each parameter, using <span class="pkg">coda</span>'s <code>raftery.diag</code> with r=0.0125, q=0.025 and q=0.975. Values of <code class="reqn">N</code> and burnin are taken as the median over chains. For each country-specific parameter, the maximum over all included countries of such medians is taken. 
</p>


<h3>Value</h3>

<p>List with the components:
</p>
<table role = "presentation">
<tr><td><code>Nmedian</code></td>
<td>
<p>2-d array of <code class="reqn">N</code>  values (processed as described in Details) with two rows: first corresponding to q=0.025, second corresponding to q=0.975. Each column corresponds to one parameter.</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>
<p>2-d array of the same structure as <code>Nmedian</code>, containing the burnin values (processed as described in Details).</p>
</td></tr>
<tr><td><code>not.converged.parameters</code></td>
<td>
<p>List with two elements, each of which is a data frame containing columns &ldquo;parameter.name&rdquo;, &ldquo;chain.id&rdquo;, and &ldquo;N&rdquo;. These are parameters for which the computed value of Raftery diagnostics <code class="reqn">N</code> is larger than the total number of finished iterations summed over all chains. The first element of the list corresponds to q=0.025, second corresponds to q=0.975.</p>
</td></tr>
<tr><td><code>not.converged.inchain.parameters</code></td>
<td>
<p>List of the same structure as <code>not.converged.parameters</code>. The parameters included are those for which the computed value of Raftery diagnostics <code class="reqn">N</code> is larger than the number of finished iterations in the corresponding chain.</p>
</td></tr>
<tr><td><code>N.country.indep</code></td>
<td>
<p>Data frame containing columns &ldquo;parameter.name&rdquo;, &ldquo;chain.id&rdquo;, &ldquo;N0.025&rdquo;, and &ldquo;N0.975&rdquo;. Each row gives <code class="reqn">N</code> computed with the two different <code class="reqn">q</code> for each country-independent parameter and chain.</p>
</td></tr>
<tr><td><code>N.country.spec</code></td>
<td>
<p>The same as <code>N.country.indep</code>, but here the country-specific parameters are considered.</p>
</td></tr>
<tr><td><code>Nmedian.country.spec</code></td>
<td>
<p>2-d array of <code class="reqn">N</code> values for country-specific parameters containing medians over chains.</p>
</td></tr>
<tr><td><code>thin.ind</code></td>
<td>
<p>List with elements '0.025', '0.975' and <code>median</code>. The first two elements are matrices with one row per chain and one column per parameter. They contain values of <code>thin</code> that makes the MCMC independent, for  q=0.025 and q=0.975, respectively. The <code>median</code> element is of the same structure as <code>Nmedian</code>, containing medians ove rows in the two matrices in this list.</p>
</td></tr>
<tr><td><code>nr.countries</code></td>
<td>
<p>Vector with elements <code>used</code> (number of countries used in this diagnostics) and <code>total</code> (number of countries that this <code>mcmc</code> object was estimated on).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+raftery.diag">raftery.diag</a></code>
</p>

<hr>
<h2 id='tfr.trajectories.plot'>
Output of Posterior Distribution of TFR Trajectories</h2><span id='topic+tfr.trajectories.plot'></span><span id='topic+tfr.trajectories.plot.all'></span><span id='topic+tfr.trajectories.table'></span>

<h3>Description</h3>

<p>The functions plot/tabulate the posterior distribution of TFR trajectories for a given country, or for all countries, including their median and given probability intervals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfr.trajectories.plot(tfr.pred, country, pi = c(80, 95), 
    half.child.variant = TRUE, nr.traj = NULL, 
    adjusted.only = TRUE, typical.trajectory = FALSE, 
    mark.estimation.points = FALSE,
    traj.index = NULL, show.mean = FALSE, show.median = TRUE,
    xlim = NULL, ylim = NULL, type = 'b', xlab = 'Year', ylab = 'TFR', 
    main = NULL, lwd = c(2, 2, 2, 2, 2, 1), 
    col=c('black', 'green', 'red', 'red', 'blue', '#00000020'),
    show.legend = TRUE, add = FALSE, uncertainty = FALSE, 
    col_unc = "purple", ...)
	
tfr.trajectories.plot.all(tfr.pred, 
    output.dir = file.path(getwd(), 'TFRtrajectories'),
    output.type = "png", main = NULL, verbose = FALSE, ...)
	
tfr.trajectories.table(tfr.pred, country, pi = c(80, 95), 
    half.child.variant = TRUE, adjusted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfr.trajectories.plot_+3A_tfr.pred">tfr.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_pi">pi</code></td>
<td>
<p>Probability interval. It can be a single number or an array.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_half.child.variant">half.child.variant</code></td>
<td>
<p>If <code>TRUE</code> the United Nations variant of &ldquo;<code>+/-0.5</code> child&rdquo; (relative to the median) is shown.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to be plotted. If <code>NULL</code>, all trajectories are plotted, otherwise they are thinned evenly.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_adjusted.only">adjusted.only</code></td>
<td>
<p>Logical. By default, if the projection or estimation median is adjusted using e.g. <code><a href="#topic+tfr.median.set">tfr.median.set</a></code> or <code><a href="#topic+tfr.median.set.all">tfr.median.set.all</a></code>, the function plots the adjusted median. If <code>adjusted.only=FALSE</code> the original (non-adjusted) median is plotted as well.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_typical.trajectory">typical.trajectory</code></td>
<td>
<p>Logical. If <code>TRUE</code> one trajectory is shown that has the smallest distance to the median.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_mark.estimation.points">mark.estimation.points</code></td>
<td>
<p>Logical. If <code>TRUE</code>, points that were not used in the estimation (phase I) are shown in lighter color than points in phase II and III.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_traj.index">traj.index</code></td>
<td>
<p>Vector of trajectory indices to show. If not given, the trajectories are selected using equidistant spacing.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_show.mean">show.mean</code>, <code id="tfr.trajectories.plot_+3A_show.median">show.median</code></td>
<td>
<p>Logical indicating if the mean or/and the median of the distribution should be shown.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_xlim">xlim</code>, <code id="tfr.trajectories.plot_+3A_ylim">ylim</code>, <code id="tfr.trajectories.plot_+3A_type">type</code>, <code id="tfr.trajectories.plot_+3A_xlab">xlab</code>, <code id="tfr.trajectories.plot_+3A_ylab">ylab</code></td>
<td>
<p>Graphical parameters passed to the <code>plot</code> function.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_lwd">lwd</code>, <code id="tfr.trajectories.plot_+3A_col">col</code></td>
<td>
<p>Vector of six elements giving the line width and color for: 1. observed data, 2. imputed missing data, 3. median, 4. quantiles, 5. half-child variant, 6. trajectories.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical controlling whether the legend should be drawn.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_add">add</code></td>
<td>
<p>Logical controlling whether the trajectories should be plotted into a new graphic device (<code>FALSE</code>) or into an existing device (<code>TRUE</code>). One can use this argument to plot trajectories from multiple countries into one graphics.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters. In addition, for <code>tfr.trajectories.plot.all</code>, <code>...</code> contains any of the arguments of <code>tfr.trajectories.plot</code>.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which resulting graphs are stored.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_output.type">output.type</code></td>
<td>
<p>Type of the resulting files. It can be &ldquo;png&rdquo;, &ldquo;pdf&rdquo;, &ldquo;jpeg&rdquo;, &ldquo;bmp&rdquo;, &ldquo;tiff&rdquo;, or &ldquo;postscript&rdquo;.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_main">main</code></td>
<td>
<p>Main title for the plot(s). In <code>tfr.trajectories.plot.all</code> any occurence of the string &ldquo;XXX&rdquo; is replaced by the country name.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Logical: <code>TRUE</code> means uncertainty of past TFR should be plotted with the same level of uncertainty interval.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_col_unc">col_unc</code></td>
<td>
<p>Color of past TFR estimation uncertainty plot.</p>
</td></tr>
<tr><td><code id="tfr.trajectories.plot_+3A_adjusted">adjusted</code></td>
<td>
<p>Logical. If <code>FALSE</code> the unadjusted values are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tfr.trajectories.plot</code> plots posterior distribution of TFR trajectories for a given country. <code>tfr.trajectories.table</code> gives the same output as a table. <code>tfr.trajectories.plot.all</code> creates a set of graphs (one per country) that are stored in <code>output.dir</code>. 
</p>
<p>The median and given probability intervals are computed using all available trajectories. Thus, <code>nr.traj</code> does not influence those values - it is used only to control the number of trajectories plotted.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Leontine Alkema, Peiran Liu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesTFR.prediction">bayesTFR.prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
pred &lt;- get.tfr.prediction(sim.dir)
tfr.trajectories.plot(pred, country="Burkina Faso", pi=c(80, 95))
tfr.trajectories.table(pred, country="Burkina Faso", pi=c(80, 95))

## End(Not run)
</code></pre>

<hr>
<h2 id='UN_time'>
Dataset with UN-specific Time Coding
</h2><span id='topic+UN_time'></span>

<h3>Description</h3>

<p>Dataset used by the UN for coding time. It is an TAB-separated ASCII file called &ldquo;UN_time.txt&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(UN_time)</code></pre>


<h3>Format</h3>

<p>A data frame with 1034 observations on the following 4 variables.
</p>

<dl>
<dt><code>TimeID</code></dt><dd><p>Time identifier.</p>
</dd>
<dt><code>TLabel</code></dt><dd><p>Label of the time, with minimum values of <code>1950</code> and <code>1950-1955</code>, and maximum values of   <code>2399</code>, <code>2400</code> and <code>2400-2405</code>.</p>
</dd>
<dt><code>TDate</code></dt><dd><p>Equal to <code>TLabel</code> if it is a single year, or the starting year of <code>TLabel</code>, if it is an interval.</p>
</dd>
<dt><code>Tinterval</code></dt><dd><p>Length of the time interval, or zero, if it is a single year.</p>
</dd>
</dl>



<h3>Details</h3>

<p>For 5-year period data, fertility rates are defined from 1 July of year (t) to 1 July of year (t+5), with 1 January of year (t+3) as exact mid-date. This means for example that data for 2000-2005, refer to the period between 2000.5 and 2005.5, with 2003.0 as exact mid-point.
</p>


<h3>Source</h3>

<p>Data provided by the United Nations Population Division
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(UN_time)
str(UN_time)
</code></pre>

<hr>
<h2 id='UN_variants'>
Dataset with UN-specific Coding of Variants
</h2><span id='topic+UN_variants'></span>

<h3>Description</h3>

<p>Dataset used by the UN for coding variants. It also includes variants for the lower and upper bounds of the 80 and 95% probability intervals, respectively, resulting from the Bayesian hierarchical model. The dataset is stored in a TAB-separated ASCII file called &ldquo;UN_variants.txt&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(UN_variants)</code></pre>


<h3>Format</h3>

<p>A data frame with 23 observations on the following 5 variables.
</p>

<dl>
<dt><code>RevID</code></dt><dd><p>Revision identifier.</p>
</dd>
<dt><code>VarID</code></dt><dd><p>Identifier of the variant.</p>
</dd>
<dt><code>Vshort</code></dt><dd><p>Short name of the variant.</p>
</dd>
<dt><code>VName</code></dt><dd><p>Full name of the variant.</p>
</dd>
<dt><code>VariantDomain</code></dt><dd><p>Domain of the variant.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data provided by the United Nations Population Division
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(UN_variants)
str(UN_variants)
</code></pre>

<hr>
<h2 id='write.projection.summary'>
Writing Projection Summary Files
</h2><span id='topic+write.projection.summary'></span>

<h3>Description</h3>

<p>The function creates two files containing projection summaries, such as the median, mean, the lower and upper bound of the 80 and 90% probability intervals, respectively, the +/- 0.5 child variant and the constant variant. One file is in a user-friendly format, whereas the other is in a UN-specific format with internal coding of the time and the variants. In addition, a file containing  some of the model parameters is created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.projection.summary(dir = file.path(getwd(), "bayesTFR.output"), 
    subdir = "predictions", output.dir = NULL, revision = NULL, adjusted = FALSE, 
    est.uncertainty = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.projection.summary_+3A_dir">dir</code></td>
<td>
<p>Directory containing the prediction object. It should correspond to the <code>output.dir</code> argument of the <code><a href="#topic+tfr.predict">tfr.predict</a></code> function.</p>
</td></tr>
<tr><td><code id="write.projection.summary_+3A_subdir">subdir</code></td>
<td>
<p>Subdirectory of <code>dir</code> containing the predictions.</p>
</td></tr>
<tr><td><code id="write.projection.summary_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory in which the resulting file will be stored. If <code>NULL</code> the same directory is used as for the prediction.</p>
</td></tr>
<tr><td><code id="write.projection.summary_+3A_revision">revision</code></td>
<td>
<p>UN WPP revision number. If <code>NULL</code> it is determined from the corresponding WPP year: WPP 2008 corresponds to revision 13, every subsequent WPP increases the revision number by one. Used as a constant in the second file only.</p>
</td></tr>
<tr><td><code id="write.projection.summary_+3A_adjusted">adjusted</code></td>
<td>
<p>Logical. By default the function writes summary using the original BHM projections. If the projection medians are adjusted (using e.g. <code><a href="#topic+tfr.median.set">tfr.median.set</a></code>), setting this argument to <code>TRUE</code> causes writing the adjusted projections.</p>
</td></tr>
<tr><td><code id="write.projection.summary_+3A_est.uncertainty">est.uncertainty</code></td>
<td>
<p>Logical. If <code>TRUE</code> and the simulation was generated with uncertainty around estimation, that uncertainty info is included in the summaries.</p>
</td></tr>
<tr><td><code id="write.projection.summary_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying functions. Here, argument <code>precision</code> can be set to determine the number of significant digits (default is 4).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first file that the function creates is called &lsquo;<span class="file">projection_summary_user_friendly.csv</span>&rsquo; (or &lsquo;<span class="file">projection_summary_user_friendly_adjusted.csv</span>&rsquo; if <code>adjusted=TRUE</code>), it is a comma-separated table with the following columns: 
</p>
<dl>
<dt>country_name</dt><dd><p>country name</p>
</dd>
<dt>country_code</dt><dd><p>country code</p>
</dd>
<dt>variant</dt><dd><p>name of the variant, such as &ldquo;median&rdquo;, &ldquo;lower 80&rdquo;, &ldquo;upper 80&rdquo;, &ldquo;lower 95&rdquo;, &ldquo;upper 95&rdquo;, &ldquo;mean&rdquo;, &ldquo;-0.5child&rdquo;, &ldquo;+0.5child&rdquo;, &ldquo;constant&rdquo;</p>
</dd>
<dt><em>period1:</em></dt><dd><p>e.g. &ldquo;2005-2010&rdquo;: TFR for the first time period. If <code>est.uncertainty</code> is <code>TRUE</code>, the first time period is the first observed time period. Otherwise it is the last observed one.</p>
</dd>
<dt><em>period2:</em></dt><dd><p>e.g. &ldquo;2010-2015&rdquo;: TFR for the second time period</p>
</dd>
<dt>...</dt><dd><p>further columns with TFR projections</p>
</dd>
</dl>

<p>The second file, called &lsquo;<span class="file">projection_summary.csv</span>&rsquo; (or &lsquo;<span class="file">projection_summary_adjusted.csv</span>&rsquo; if <code>adjusted=TRUE</code>), also comma-separated table, contains the same information as above in a UN-specific format:
</p>
<dl>
<dt>RevID</dt><dd><p>revision number, passed to the function as an argument</p>
</dd>
<dt>VarID</dt><dd><p>variant identifier, extracted from the <code><a href="#topic+UN_variants">UN_variants</a></code> dataset</p>
</dd>
<dt>LocID</dt><dd><p>country code</p>
</dd>
<dt>TimeID</dt><dd><p>time identifier, extracted from the <code><a href="#topic+UN_time">UN_time</a></code> dataset</p>
</dd>
<dt>TFR</dt><dd><p>the total fertility rate for this variant, location and time period</p>
</dd>
</dl>

<p>The third comma-separated file, called &lsquo;<span class="file">projection_summary_parameters.csv</span>&rsquo; contains the following columns:
</p>
<dl>
<dt>country_name</dt><dd><p>country name</p>
</dd>
<dt>country_code</dt><dd><p>country code</p>
</dd>
<dt>TF_time_start_decline</dt><dd><p>start period of TFR decline</p>
</dd>
<dt>TF_max</dt><dd><p>TFR at the onset of the fertitility transition (median of the <code class="reqn">U_c</code> parameter)</p>
</dd>
<dt>TF_max_decrement</dt><dd><p>maximum decrement of TFR decline (median of the <code class="reqn">d_c</code> parameter)</p>
</dd>
<dt>TF_end_level</dt><dd><p>median of the end level of the fertility transition (<code class="reqn">\Delta_{c4}</code> parameter)</p>
</dd>
<dt>TF_end_level_low</dt><dd><p>2.5 percentile of the <code class="reqn">\Delta_{c4}</code> distribution</p>
</dd>
<dt>TF_end_level_high</dt><dd><p>97.5 percentile of the <code class="reqn">\Delta_{c4}</code> distribution</p>
</dd>
<dt>TF_time_end_decline</dt><dd><p>period of the end decline, measured using the prediction median</p>
</dd>
</dl>

<p>Note that this file is not created if <code>adjusted=TRUE</code>.
</p>


<h3>Note</h3>

<p>This function is automatically called from the <code><a href="#topic+tfr.predict">tfr.predict</a></code> function, therefore in standard cases it will not be needed to call it directly.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convert.tfr.trajectories">convert.tfr.trajectories</a></code>, <code><a href="#topic+tfr.predict">tfr.predict</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
