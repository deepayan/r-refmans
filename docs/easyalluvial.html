<!DOCTYPE html><html><head><title>Help for package easyalluvial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {easyalluvial}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_imp_plot'><p>add bar plot of important features to model response alluvial plot</p></a></li>
<li><a href='#add_marginal_histograms'><p>add marginal histograms to alluvial plot</p></a></li>
<li><a href='#alluvial_long'><p>alluvial plot of data in long format</p></a></li>
<li><a href='#alluvial_model_response'><p>create model response plot</p></a></li>
<li><a href='#alluvial_model_response_caret'><p>create model response plot for caret models</p></a></li>
<li><a href='#alluvial_model_response_parsnip'><p>create model response plot for parsnip models</p></a></li>
<li><a href='#alluvial_wide'><p>alluvial plot of data in wide format</p></a></li>
<li><a href='#check_pkg_installed'><p>check if package is installed</p></a></li>
<li><a href='#get_data_space'><p>calculate data space</p></a></li>
<li><a href='#get_pdp_predictions'><p>get predictions compatible with the partial dependence plotting method</p></a></li>
<li><a href='#get_pdp_predictions_seq'><p>get predictions compatible with the partial dependence plotting method,</p>
sequential variant that only works for numeric predictions.</a></li>
<li><a href='#manip_bin_numerics'><p>bin numerical columns</p></a></li>
<li><a href='#manip_factor_2_numeric'><p>converts factor to numeric preserving numeric levels and order in</p>
character levels.</a></li>
<li><a href='#mtcars2'><p>mtcars dataset with cyl, vs, am ,gear, carb as factor variables and car model</p>
names as id</a></li>
<li><a href='#palette_filter'><p>color filters for any vector of hex color values</p></a></li>
<li><a href='#palette_increase_length'><p>increases length of palette by repeating colours</p></a></li>
<li><a href='#palette_plot_intensity'><p>plot colour intensity of palette</p></a></li>
<li><a href='#palette_plot_rgp'><p>plot rgb values of palette</p></a></li>
<li><a href='#palette_qualitative'><p>compose palette from qualitative RColorBrewer palettes</p></a></li>
<li><a href='#plot_all_hists'><p>plot marginal histograms of alluvial plot</p></a></li>
<li><a href='#plot_condensation'><p>Plot dataframe condensation potential</p></a></li>
<li><a href='#plot_hist'><p>plot histogram of alluvial plot variable</p></a></li>
<li><a href='#plot_imp'><p>plot feature importance</p></a></li>
<li><a href='#quarterly_flights'><p>Quarterly mean arrival delay times for a set of 402 flights</p></a></li>
<li><a href='#quarterly_sunspots'><p>Quarterly mean relative sunspots number from 1749-1983</p></a></li>
<li><a href='#tidy_imp'><p>tidy up dataframe containing model feature importance</p></a></li>
<li><a href='#titanic'><p>titanic data set'</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generate Alluvial Plots with a Single Line of Code</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/erblast/easyalluvial/">https://github.com/erblast/easyalluvial/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Alluvial plots are similar to sankey diagrams and visualise categorical data 
    over multiple dimensions as flows. (Rosvall M, Bergstrom CT (2010) Mapping Change in 
    Large Networks. PLoS ONE 5(1): e8694. &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0008694">doi:10.1371/journal.pone.0008694</a>&gt; 
    Their graphical grammar however is a bit more complex then that of a regular x/y 
    plots. The 'ggalluvial' package made a great job of translating that grammar into 
    'ggplot2' syntax and gives you many options to tweak the appearance of an alluvial 
    plot, however there still remains a multi-layered complexity that makes it difficult
    to use 'ggalluvial' for explorative data analysis. 'easyalluvial' provides a simple 
    interface to this package that allows you to produce a decent alluvial plot from any 
    dataframe in either long or wide format from a single line of code while also handling 
    continuous data. It is meant to allow a quick visualisation of entire dataframes 
    with a focus on different colouring options that can make alluvial plots a great 
    tool for data exploration. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, ISLR, nycflights13, vdiffr (&ge; 0.3.1),
pkgdown, mlbench, earth, workflows, future, furrr, e1071,
caret, parsnip, vip, rpart, glmnet, xgboost</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>purrr , tidyr (&ge; 1.0.0) , dplyr , forcats , ggalluvial (&ge;
0.9.1) , ggplot2 (&ge; 3.2.0) , ggridges , RColorBrewer , recipes
(&ge; 0.1.5) , rlang , stringr , magrittr , tibble , gridExtra ,
randomForest , progressr , progress</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 12:44:05 UTC; koneswab</td>
</tr>
<tr>
<td>Author:</td>
<td>Bjoern Koneswarakantha
    <a href="https://orcid.org/0000-0003-4585-7799"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bjoern Koneswarakantha &lt;datistics@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-07 13:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_imp_plot'>add bar plot of important features to model response alluvial plot</h2><span id='topic+add_imp_plot'></span>

<h3>Description</h3>

<p>adds bar plot of important features to model response alluvial plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_imp_plot(grid, p = NULL, data_input, plot = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_imp_plot_+3A_grid">grid</code></td>
<td>
<p>gtable or ggplot</p>
</td></tr>
<tr><td><code id="add_imp_plot_+3A_p">p</code></td>
<td>
<p>alluvial plot, optional if alluvial plot has already been passed as grid.  Default: NULL</p>
</td></tr>
<tr><td><code id="add_imp_plot_+3A_data_input">data_input</code></td>
<td>
<p>dataframe used to generate alluvial plot</p>
</td></tr>
<tr><td><code id="add_imp_plot_+3A_plot">plot</code></td>
<td>
<p>logical if plot should be drawn or not</p>
</td></tr>
<tr><td><code id="add_imp_plot_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="#topic+plot_imp">plot_imp</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>gtable
</p>


<h3>See Also</h3>

<p><code><a href="gridExtra.html#topic+arrangeGrob">arrangeGrob</a></code>
<code><a href="#topic+plot_imp">plot_imp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
df = mtcars2[, ! names(mtcars2) %in% 'ids' ]

train = caret::train( disp ~ .
                     , df
                     , method = 'rf'
                     , trControl = caret::trainControl( method = 'none' )
                     , importance = TRUE )

pred_train = caret::predict.train(train, df)

p = alluvial_model_response_caret(train, degree = 4, pred_train = pred_train)

p_grid = add_marginal_histograms(p, data_input = df)

p_grid = add_imp_plot(p_grid, p, data_input = df)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_marginal_histograms'>add marginal histograms to alluvial plot</h2><span id='topic+add_marginal_histograms'></span>

<h3>Description</h3>

<p>will add density histograms and frequency plots of original data
to alluvial plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_marginal_histograms(
  p,
  data_input,
  top = TRUE,
  keep_labels = FALSE,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_marginal_histograms_+3A_p">p</code></td>
<td>
<p>alluvial plot</p>
</td></tr>
<tr><td><code id="add_marginal_histograms_+3A_data_input">data_input</code></td>
<td>
<p>dataframe, input data that was used to create dataframe</p>
</td></tr>
<tr><td><code id="add_marginal_histograms_+3A_top">top</code></td>
<td>
<p>logical, position of histograms, if FALSE adds them at the bottom,
Default: TRUE</p>
</td></tr>
<tr><td><code id="add_marginal_histograms_+3A_keep_labels">keep_labels</code></td>
<td>
<p>logical, keep title and caption, Default: FALSE</p>
</td></tr>
<tr><td><code id="add_marginal_histograms_+3A_plot">plot</code></td>
<td>
<p>logical if plot should be drawn or not</p>
</td></tr>
<tr><td><code id="add_marginal_histograms_+3A_...">...</code></td>
<td>
<p>additional arguments for model response alluvial plot concerning
the response variable </p>
 <dl>
<dt>pred_train</dt><dd><p>display training
prediction, not necessary if pred_train has already been passed to
alluvial_model_response()</p>
</dd> <dt>scale</dt><dd><p>int, y-axis distance between the
ridge plots, Default: 400 </p>
</dd> <dt>resp_var</dt><dd><p>character vector, specify
response variable in data_input, if not set response variable will try to be
inferred, Default: NULL </p>
</dd> </dl>
</td></tr>
</table>


<h3>Value</h3>

<p>gtable
</p>


<h3>See Also</h3>

<p><code><a href="gridExtra.html#topic+arrangeGrob">arrangeGrob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
p = alluvial_wide(mtcars2, max_variables = 3)
p_grid = add_marginal_histograms(p, mtcars2)

## End(Not run)
</code></pre>

<hr>
<h2 id='alluvial_long'>alluvial plot of data in long format</h2><span id='topic+alluvial_long'></span>

<h3>Description</h3>

<p>Plots two variables of a dataframe on an alluvial plot. A third
variable can be added either to the left or the right of the alluvial plot
to provide coloring of the flows. All numerical variables are scaled,
centered and YeoJohnson transformed before binning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alluvial_long(
  data,
  key,
  value,
  id,
  fill = NULL,
  fill_right = T,
  bins = 5,
  bin_labels = c("LL", "ML", "M", "MH", "HH"),
  NA_label = "NA",
  order_levels_value = NULL,
  order_levels_key = NULL,
  order_levels_fill = NULL,
  complete = TRUE,
  fill_by = "first_variable",
  col_vector_flow = palette_qualitative() %&gt;% palette_filter(greys = F),
  col_vector_value = RColorBrewer::brewer.pal(9, "Greys")[c(3, 6, 4, 7, 5)],
  verbose = F,
  stratum_labels = T,
  stratum_label_type = "label",
  stratum_label_size = 4.5,
  stratum_width = 1/4,
  auto_rotate_xlabs = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alluvial_long_+3A_data">data</code></td>
<td>
<p>a dataframe</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_key">key</code></td>
<td>
<p>unquoted column name or string of x axis variable</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_value">value</code></td>
<td>
<p>unquoted column name or string of y axis variable</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_id">id</code></td>
<td>
<p>unquoted column name or string of id column</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_fill">fill</code></td>
<td>
<p>unquoted column name or string of fill variable which will be used to
color flows, Default: NULL</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_fill_right">fill_right</code></td>
<td>
<p>logical, TRUE fill variable is added to the right FALSE to
the left, Default: T</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_bins">bins</code></td>
<td>
<p>number of bins for automatic binning of numerical variables,
Default: 5</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_bin_labels">bin_labels</code></td>
<td>
<p>labels for bins, Default: c(&quot;LL&quot;, &quot;ML&quot;, &quot;M&quot;, &quot;MH&quot;, &quot;HH&quot;)</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_na_label">NA_label</code></td>
<td>
<p>character vector define label for missing data</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_order_levels_value">order_levels_value</code></td>
<td>
<p>character vector denoting order of y levels from low
to high, does not have to be complete can also just be used to bring levels
to the front, Default: NULL</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_order_levels_key">order_levels_key</code></td>
<td>
<p>character vector denoting order of x levels from low
to high, does not have to be complete can also just be used to bring levels
to the front, Default: NULL</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_order_levels_fill">order_levels_fill</code></td>
<td>
<p>character vector denoting order of color fill
variable levels from low to high, does not have to be complete can also just
be used to bring levels to the front, Default: NULL</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_complete">complete</code></td>
<td>
<p>logical, insert implicitly missing observations, Default: TRUE</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_fill_by">fill_by</code></td>
<td>
<p>one_of(c('first_variable', 'last_variable', 'all_flows',
'values')), Default: 'first_variable'</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_col_vector_flow">col_vector_flow</code></td>
<td>
<p>HEX color values for flows, Default: palette_filter( greys = F)</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_col_vector_value">col_vector_value</code></td>
<td>
<p>HEX color values  for y levels/values,
Default:RColorBrewer::brewer.pal(9, 'Greys')[c(3,6,4,7,5)]</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_verbose">verbose</code></td>
<td>
<p>logical, print plot summary, Default: F</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_stratum_labels">stratum_labels</code></td>
<td>
<p>logical, Default: TRUE</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_stratum_label_type">stratum_label_type</code></td>
<td>
<p>character, Default: &quot;label&quot;</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_stratum_label_size">stratum_label_size</code></td>
<td>
<p>numeric, Default: 4.5</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_stratum_width">stratum_width</code></td>
<td>
<p>double, Default: 1/4</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_auto_rotate_xlabs">auto_rotate_xlabs</code></td>
<td>
<p>logical, Default: TRUE</p>
</td></tr>
<tr><td><code id="alluvial_long_+3A_...">...</code></td>
<td>
<p>additional parameter passed to <code><a href="#topic+manip_bin_numerics">manip_bin_numerics</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alluvial_wide">alluvial_wide</a></code>
,<code><a href="ggalluvial.html#topic+geom_flow">geom_flow</a></code>, <code><a href="ggalluvial.html#topic+geom_stratum">geom_stratum</a></code>
,<code><a href="#topic+manip_bin_numerics">manip_bin_numerics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
 data = quarterly_flights

 alluvial_long( data, key = qu, value = mean_arr_delay, id = tailnum, fill_by = 'last_variable' )

 # more flow coloring variants ------------------------------------

 alluvial_long( data, key = qu, value = mean_arr_delay, id = tailnum, fill_by = 'first_variable' )
 alluvial_long( data, key = qu, value = mean_arr_delay, id = tailnum, fill_by = 'all_flows' )
 alluvial_long( data, key = qu, value = mean_arr_delay, id = tailnum, fill_by = 'value' )

 # color by additional variable carrier ---------------------------

 alluvial_long( data, key = qu, value = mean_arr_delay, fill = carrier, id = tailnum )

 # use same color coding for flows and y levels -------------------

 palette = c('green3', 'tomato')

 alluvial_long( data, qu, mean_arr_delay, tailnum, fill_by = 'value'
                , col_vector_flow = palette
                , col_vector_value = palette )


 # reorder levels ------------------------------------------------

 alluvial_long( data, qu, mean_arr_delay, tailnum, fill_by = 'first_variable'
               , order_levels_value = c('on_time', 'late') )

 alluvial_long( data, qu, mean_arr_delay, tailnum, fill_by = 'first_variable'
               , order_levels_key = c('Q4', 'Q3', 'Q2', 'Q1') )

require(dplyr)
require(magrittr)

 order_by_carrier_size = data %&gt;%
   group_by(carrier) %&gt;%
   count() %&gt;%
   arrange( desc(n) ) %&gt;%
   .[['carrier']]

 alluvial_long( data, qu, mean_arr_delay, tailnum, carrier
                , order_levels_fill = order_by_carrier_size )


## End(Not run)
</code></pre>

<hr>
<h2 id='alluvial_model_response'>create model response plot</h2><span id='topic+alluvial_model_response'></span>

<h3>Description</h3>

<p>alluvial plots are capable of displaying higher dimensional data
on a plane, thus lend themselves to plot the response of a statistical model
to changes in the input data across multiple dimensions. The practical limit
here is 4 dimensions. We need the data space (a sensible range of data
calculated based on the importance of the explanatory variables of the model
as created by <code><a href="#topic+get_data_space">get_data_space</a></code> and the predictions
returned by the model in response to the data space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alluvial_model_response(
  pred,
  dspace,
  imp,
  degree = 4,
  bin_labels = c("LL", "ML", "M", "MH", "HH"),
  col_vector_flow = c("#FF0065", "#009850", "#A56F2B", "#005EAA", "#710500", "#7B5380",
    "#9DD1D1"),
  method = "median",
  force = FALSE,
  params_bin_numeric_pred = list(bins = 5),
  pred_train = NULL,
  stratum_label_size = 3.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alluvial_model_response_+3A_pred">pred</code></td>
<td>
<p>vector, predictions, if method = 'pdp' use
<code><a href="#topic+get_pdp_predictions">get_pdp_predictions</a></code> to calculate predictions</p>
</td></tr>
<tr><td><code id="alluvial_model_response_+3A_dspace">dspace</code></td>
<td>
<p>data frame, returned by
<code><a href="#topic+get_data_space">get_data_space</a></code></p>
</td></tr>
<tr><td><code id="alluvial_model_response_+3A_imp">imp</code></td>
<td>
<p>dataframe, with not more then two columns one of them numeric
containing importance measures and one character or factor column containing
corresponding variable names as found in training data.</p>
</td></tr>
<tr><td><code id="alluvial_model_response_+3A_degree">degree</code></td>
<td>
<p>integer,  number of top important variables to select. For
plotting more than 4 will result in two many flows and the alluvial plot
will not be very readable, Default: 4</p>
</td></tr>
<tr><td><code id="alluvial_model_response_+3A_bin_labels">bin_labels</code></td>
<td>
<p>labels for prediction bins from low to high, Default: c(&quot;LL&quot;, &quot;ML&quot;,
&quot;M&quot;, &quot;MH&quot;, &quot;HH&quot;)</p>
</td></tr>
<tr><td><code id="alluvial_model_response_+3A_col_vector_flow">col_vector_flow</code></td>
<td>
<p>character vector, defines flow colours, Default:
c('#FF0065','#009850', '#A56F2B', '#005EAA', '#710500')</p>
</td></tr>
<tr><td><code id="alluvial_model_response_+3A_method">method</code></td>
<td>
<p>character vector, one of c('median', 'pdp') </p>

<dl>
<dt>median</dt><dd><p>sets variables that are not displayed to median mode, use with
regular predictions</p>
</dd> <dt>pdp</dt><dd><p>partial dependency plot method, for each
observation in the training data the displayed variable as are set to the
indicated values. The predict function is called for each modified
observation and the result is averaged, calculate predictions using
<code><a href="#topic+get_pdp_predictions">get_pdp_predictions</a></code> </p>
</dd> </dl>
<p>. Default: 'median'</p>
</td></tr>
<tr><td><code id="alluvial_model_response_+3A_force">force</code></td>
<td>
<p>logical, force plotting of over 1500 flows, Default: FALSE</p>
</td></tr>
<tr><td><code id="alluvial_model_response_+3A_params_bin_numeric_pred">params_bin_numeric_pred</code></td>
<td>
<p>list, additional parameters passed to
<code><a href="#topic+manip_bin_numerics">manip_bin_numerics</a></code> which is applied to the pred
parameter. Default: list( bins = 5, center = T, transform = T, scale = T)</p>
</td></tr>
<tr><td><code id="alluvial_model_response_+3A_pred_train">pred_train</code></td>
<td>
<p>numeric vector, base the automated binning of the pred vector on
the distribution of the training predictions. This is useful if marginal
histograms are added to the plot later. Default = NULL</p>
</td></tr>
<tr><td><code id="alluvial_model_response_+3A_stratum_label_size">stratum_label_size</code></td>
<td>
<p>numeric, Default: 3.5</p>
</td></tr>
<tr><td><code id="alluvial_model_response_+3A_...">...</code></td>
<td>
<p>additional parameters passed to
<code><a href="#topic+alluvial_wide">alluvial_wide</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>this model visualisation approach follows the &quot;visualising the model
in the dataspace&quot; principle as described in Wickham H, Cook D, Hofmann H
(2015) Visualizing statistical models: Removing the blindfold. Statistical
Analysis and Data Mining 8(4) &lt;doi:10.1002/sam.11271&gt;
</p>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alluvial_wide">alluvial_wide</a></code>,
<code><a href="#topic+get_data_space">get_data_space</a></code>,
<code><a href="#topic+alluvial_model_response_caret">alluvial_model_response_caret</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df = mtcars2[, ! names(mtcars2) %in% 'ids' ]
m = randomForest::randomForest( disp ~ ., df)
imp = m$importance
dspace = get_data_space(df, imp, degree = 3)
pred = predict(m, newdata = dspace)
alluvial_model_response(pred, dspace, imp, degree = 3)

# partial dependency plotting method
## Not run: 
 pred = get_pdp_predictions(df, imp
                            , .f_predict = randomForest:::predict.randomForest
                            , m
                            , degree = 3
                            , bins = 5)


 alluvial_model_response(pred, dspace, imp, degree = 3, method = 'pdp')
 
## End(Not run)
</code></pre>

<hr>
<h2 id='alluvial_model_response_caret'>create model response plot for caret models</h2><span id='topic+alluvial_model_response_caret'></span>

<h3>Description</h3>

<p>Wraps <code><a href="#topic+alluvial_model_response">alluvial_model_response</a></code> and
<code><a href="#topic+get_data_space">get_data_space</a></code> into one call for caret models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alluvial_model_response_caret(
  train,
  data_input,
  degree = 4,
  bins = 5,
  bin_labels = c("LL", "ML", "M", "MH", "HH"),
  col_vector_flow = c("#FF0065", "#009850", "#A56F2B", "#005EAA", "#710500", "#7B5380",
    "#9DD1D1"),
  method = "median",
  parallel = FALSE,
  params_bin_numeric_pred = list(bins = 5),
  pred_train = NULL,
  stratum_label_size = 3.5,
  force = F,
  resp_var = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alluvial_model_response_caret_+3A_train">train</code></td>
<td>
<p>caret train object</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_data_input">data_input</code></td>
<td>
<p>dataframe, input data</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_degree">degree</code></td>
<td>
<p>integer,  number of top important variables to select. For
plotting more than 4 will result in two many flows and the alluvial plot
will not be very readable, Default: 4</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_bins">bins</code></td>
<td>
<p>integer, number of bins for numeric variables, increasing this
number might result in too many flows, Default: 5</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_bin_labels">bin_labels</code></td>
<td>
<p>labels for the bins from low to high, Default: c(&quot;LL&quot;, &quot;ML&quot;,
&quot;M&quot;, &quot;MH&quot;, &quot;HH&quot;)</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_col_vector_flow">col_vector_flow</code></td>
<td>
<p>character vector, defines flow colours, Default:
c('#FF0065','#009850', '#A56F2B', '#005EAA', '#710500')</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_method">method</code></td>
<td>
<p>character vector, one of c('median', 'pdp') </p>

<dl>
<dt>median</dt><dd><p>sets variables that are not displayed to median mode, use with
regular predictions</p>
</dd> <dt>pdp</dt><dd><p>partial dependency plot method, for each
observation in the training data the displayed variables are set to the
indicated values. The predict function is called for each modified
observation and the result is averaged</p>
</dd> </dl>
<p>. Default: 'median'</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_parallel">parallel</code></td>
<td>
<p>logical, turn on parallel processing for pdp method. Default: FALSE</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_params_bin_numeric_pred">params_bin_numeric_pred</code></td>
<td>
<p>list, additional parameters passed to
<code><a href="#topic+manip_bin_numerics">manip_bin_numerics</a></code> which is applied to the pred
parameter. Default: list(bins = 5, center = T, transform = T, scale = T)</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_pred_train">pred_train</code></td>
<td>
<p>numeric vector, base the automated binning of the pred vector on
the distribution of the training predictions. This is useful if marginal
histograms are added to the plot later. Default = NULL</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_stratum_label_size">stratum_label_size</code></td>
<td>
<p>numeric, Default: 3.5</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_force">force</code></td>
<td>
<p>logical, force plotting of over 1500 flows, Default: FALSE</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_resp_var">resp_var</code></td>
<td>
<p>character, sometimes target variable cannot be inferred and
needs to be passed. Default NULL</p>
</td></tr>
<tr><td><code id="alluvial_model_response_caret_+3A_...">...</code></td>
<td>
<p>additional parameters passed to
<code><a href="#topic+alluvial_wide">alluvial_wide</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>this model visualisation approach follows the &quot;visualising the model
in the dataspace&quot; principle as described in Wickham H, Cook D, Hofmann H
(2015) Visualizing statistical models: Removing the blindfold. Statistical
Analysis and Data Mining 8(4) &lt;doi:10.1002/sam.11271&gt;
</p>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Parallel Processing</h3>

<p>We are using 'furrr' and the 'future' package to paralelize some of the
computational steps for calculating the predictions. It is up to the user
to register a compatible backend (see <a href="future.html#topic+plan">plan</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alluvial_wide">alluvial_wide</a></code>,
<code><a href="#topic+get_data_space">get_data_space</a></code>, <code><a href="caret.html#topic+varImp">varImp</a></code>,
<code><a href="caret.html#topic+extractPrediction">extractPrediction</a></code>,
<code><a href="#topic+get_data_space">get_data_space</a></code>,
<code><a href="#topic+get_pdp_predictions">get_pdp_predictions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(check_pkg_installed("caret", raise_error = FALSE)) {
  df = mtcars2[, ! names(mtcars2) %in% 'ids' ]

  train = caret::train( disp ~ .,
                        df,
                        method = 'rf',
                        trControl = caret::trainControl( method = 'none' ),
                        importance = TRUE )

  alluvial_model_response_caret(train, df, degree = 3)
}
# partial dependency plotting method
## Not run: 
future::plan("multisession")
alluvial_model_response_caret(train, df, degree = 3, method = 'pdp', parallel = TRUE)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='alluvial_model_response_parsnip'>create model response plot for parsnip models</h2><span id='topic+alluvial_model_response_parsnip'></span>

<h3>Description</h3>

<p>Wraps <code><a href="#topic+alluvial_model_response">alluvial_model_response</a></code> and
<code><a href="#topic+get_data_space">get_data_space</a></code> into one call for parsnip models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alluvial_model_response_parsnip(
  m,
  data_input,
  degree = 4,
  bins = 5,
  bin_labels = c("LL", "ML", "M", "MH", "HH"),
  col_vector_flow = c("#FF0065", "#009850", "#A56F2B", "#005EAA", "#710500", "#7B5380",
    "#9DD1D1"),
  method = "median",
  parallel = FALSE,
  params_bin_numeric_pred = list(bins = 5),
  pred_train = NULL,
  stratum_label_size = 3.5,
  force = F,
  resp_var = NULL,
  .f_imp = vip::vi_model,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alluvial_model_response_parsnip_+3A_m">m</code></td>
<td>
<p>parsnip model or trained workflow</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_data_input">data_input</code></td>
<td>
<p>dataframe, input data</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_degree">degree</code></td>
<td>
<p>integer,  number of top important variables to select. For
plotting more than 4 will result in two many flows and the alluvial plot
will not be very readable, Default: 4</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_bins">bins</code></td>
<td>
<p>integer, number of bins for numeric variables, increasing this
number might result in too many flows, Default: 5</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_bin_labels">bin_labels</code></td>
<td>
<p>labels for the bins from low to high, Default: c(&quot;LL&quot;, &quot;ML&quot;,
&quot;M&quot;, &quot;MH&quot;, &quot;HH&quot;)</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_col_vector_flow">col_vector_flow</code></td>
<td>
<p>character vector, defines flow colours, Default:
c('#FF0065','#009850', '#A56F2B', '#005EAA', '#710500')</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_method">method</code></td>
<td>
<p>character vector, one of c('median', 'pdp') </p>

<dl>
<dt>median</dt><dd><p>sets variables that are not displayed to median mode, use with
regular predictions</p>
</dd> <dt>pdp</dt><dd><p>partial dependency plot method, for each
observation in the training data the displayed variables are set to the
indicated values. The predict function is called for each modified
observation and the result is averaged</p>
</dd> </dl>
<p>. Default: 'median'</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_parallel">parallel</code></td>
<td>
<p>logical, turn on parallel processing for pdp method. Default: FALSE</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_params_bin_numeric_pred">params_bin_numeric_pred</code></td>
<td>
<p>list, additional parameters passed to
<code><a href="#topic+manip_bin_numerics">manip_bin_numerics</a></code> which is applied to the pred
parameter. Default: list(bins = 5, center = T, transform = T, scale = T)</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_pred_train">pred_train</code></td>
<td>
<p>numeric vector, base the automated binning of the pred vector on
the distribution of the training predictions. This is useful if marginal
histograms are added to the plot later. Default = NULL</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_stratum_label_size">stratum_label_size</code></td>
<td>
<p>numeric, Default: 3.5</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_force">force</code></td>
<td>
<p>logical, force plotting of over 1500 flows, Default: FALSE</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_resp_var">resp_var</code></td>
<td>
<p>character, sometimes target variable cannot be inferred and
needs to be passed. Default NULL</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_.f_imp">.f_imp</code></td>
<td>
<p>vip function that calculates feature importance, Default: vip::vi_model</p>
</td></tr>
<tr><td><code id="alluvial_model_response_parsnip_+3A_...">...</code></td>
<td>
<p>additional parameters passed to
<code><a href="#topic+alluvial_wide">alluvial_wide</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>this model visualisation approach follows the &quot;visualising the model
in the dataspace&quot; principle as described in Wickham H, Cook D, Hofmann H
(2015) Visualizing statistical models: Removing the blindfold. Statistical
Analysis and Data Mining 8(4) &lt;doi:10.1002/sam.11271&gt;
</p>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Parallel Processing</h3>

<p>We are using 'furrr' and the 'future' package to paralelize some of the
computational steps for calculating the predictions. It is up to the user
to register a compatible backend (see <a href="future.html#topic+plan">plan</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alluvial_wide">alluvial_wide</a></code>,
<code><a href="#topic+get_data_space">get_data_space</a></code>, <code><a href="caret.html#topic+varImp">varImp</a></code>,
<code><a href="caret.html#topic+extractPrediction">extractPrediction</a></code>,
<code><a href="#topic+get_data_space">get_data_space</a></code>,
<code><a href="#topic+get_pdp_predictions">get_pdp_predictions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(check_pkg_installed("parsnip", raise_error = FALSE) &amp;
   check_pkg_installed("vip", raise_error = FALSE)) {
  df = mtcars2[, ! names(mtcars2) %in% 'ids' ]

  m = parsnip::rand_forest(mode = "regression") %&gt;%
     parsnip::set_engine("randomForest") %&gt;%
     parsnip::fit(disp ~ ., data = df)

  alluvial_model_response_parsnip(m, df, degree = 3)
}
## Not run: 
# workflow --------------------------------- 
m &lt;- parsnip::rand_forest(mode = "regression") %&gt;%
  parsnip::set_engine("randomForest")

rec_prep = recipes::recipe(disp ~ ., df) %&gt;%
  recipes::prep()

wf &lt;- workflows::workflow() %&gt;%
  workflows::add_model(m) %&gt;%
  workflows::add_recipe(rec_prep) %&gt;%
  parsnip::fit(df)

alluvial_model_response_parsnip(wf, df, degree = 3)

# partial dependence plotting method -----
future::plan("multisession")
alluvial_model_response_parsnip(m, df, degree = 3, method = 'pdp', parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='alluvial_wide'>alluvial plot of data in wide format</h2><span id='topic+alluvial_wide'></span>

<h3>Description</h3>

<p>plots a dataframe as an alluvial plot. All numerical variables
are scaled, centered and YeoJohnson transformed before binning. Plots all
variables in the sequence as they appear in the dataframe until maximum
number of values is reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alluvial_wide(
  data,
  id = NULL,
  max_variables = 20,
  bins = 5,
  bin_labels = c("LL", "ML", "M", "MH", "HH"),
  NA_label = "NA",
  order_levels = NULL,
  fill_by = "first_variable",
  col_vector_flow = palette_qualitative() %&gt;% palette_filter(greys = F),
  col_vector_value = RColorBrewer::brewer.pal(9, "Greys")[c(4, 7, 5, 8, 6)],
  colorful_fill_variable_stratum = T,
  verbose = F,
  stratum_labels = T,
  stratum_label_type = "label",
  stratum_label_size = 4.5,
  stratum_width = 1/4,
  auto_rotate_xlabs = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alluvial_wide_+3A_data">data</code></td>
<td>
<p>a dataframe</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_id">id</code></td>
<td>
<p>unquoted column name of id column or character vector with id column
name</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_max_variables">max_variables</code></td>
<td>
<p>maximum number of variables, Default: 20</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_bins">bins</code></td>
<td>
<p>number of bins for numerical variables, Default: 5</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_bin_labels">bin_labels</code></td>
<td>
<p>labels for the bins from low to high, Default: c(&quot;LL&quot;, &quot;ML&quot;,
&quot;M&quot;, &quot;MH&quot;, &quot;HH&quot;)</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_na_label">NA_label</code></td>
<td>
<p>character vector, define label for missing data, Default: 'NA'</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_order_levels">order_levels</code></td>
<td>
<p>character vector denoting levels to be reordered from low
to high</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_fill_by">fill_by</code></td>
<td>
<p>one_of(c('first_variable', 'last_variable', 'all_flows',
'values')), Default: 'first_variable'</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_col_vector_flow">col_vector_flow</code></td>
<td>
<p>HEX colors for flows, Default: palette_filter( greys =
F)</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_col_vector_value">col_vector_value</code></td>
<td>
<p>Hex colors for y levels/values, Default:
RColorBrewer::brewer.pal(9, &quot;Greys&quot;)[c(3, 6, 4, 7, 5)]</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_colorful_fill_variable_stratum">colorful_fill_variable_stratum</code></td>
<td>
<p>logical, use flow colors to colorize
fill variable stratum, Default: TRUE</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_verbose">verbose</code></td>
<td>
<p>logical, print plot summary, Default: F</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_stratum_labels">stratum_labels</code></td>
<td>
<p>logical, Default: TRUE</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_stratum_label_type">stratum_label_type</code></td>
<td>
<p>character, Default: &quot;label&quot;</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_stratum_label_size">stratum_label_size</code></td>
<td>
<p>numeric, Default: 4.5</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_stratum_width">stratum_width</code></td>
<td>
<p>double, Default: 1/4</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_auto_rotate_xlabs">auto_rotate_xlabs</code></td>
<td>
<p>logical, Default: TRUE</p>
</td></tr>
<tr><td><code id="alluvial_wide_+3A_...">...</code></td>
<td>
<p>additional arguments passed to
<code><a href="#topic+manip_bin_numerics">manip_bin_numerics</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the hood this function converts the wide format into long
format. ggalluvial also offers a way to make alluvial plots directly from
wide format tables but it does not allow individual colouring of the stratum
segments. The tradeoff is that we can only order levels as a whole and not
individually by variable, Thus if some variables have levels with the same
name the order will be the same. If we want to change level order
independently we have to assign unique level names first.
</p>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alluvial_wide">alluvial_wide</a></code> ,
<code><a href="ggalluvial.html#topic+geom_flow">geom_flow</a></code> , <code><a href="ggalluvial.html#topic+geom_stratum">geom_stratum</a></code>
, <code><a href="#topic+manip_bin_numerics">manip_bin_numerics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
alluvial_wide( data = mtcars2, id = ids
                , max_variables = 3
                , fill_by = 'first_variable' )#'
# more coloring variants----------------------
alluvial_wide( data = mtcars2, id = ids
                , max_variables = 5
                , fill_by = 'last_variable' )

alluvial_wide( data = mtcars2, id = ids
                , max_variables = 5
                , fill_by = 'all_flows' )

alluvial_wide( data = mtcars2, id = ids
                , max_variables = 5
                , fill_by = 'first_variable' )

# manually order variable values and colour by stratum value

alluvial_wide( data = mtcars2, id = ids
                 , max_variables = 5
                 , fill_by = 'values'
                 , order_levels = c('4', '8', '6') )

## End(Not run)
</code></pre>

<hr>
<h2 id='check_pkg_installed'>check if package is installed</h2><span id='topic+check_pkg_installed'></span>

<h3>Description</h3>

<p>check if package is installed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pkg_installed(pkg, raise_error = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_pkg_installed_+3A_pkg">pkg</code></td>
<td>
<p>character, package name</p>
</td></tr>
<tr><td><code id="check_pkg_installed_+3A_raise_error">raise_error</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_pkg_installed("easyalluvial")
</code></pre>

<hr>
<h2 id='get_data_space'>calculate data space</h2><span id='topic+get_data_space'></span>

<h3>Description</h3>

<p>calculates a dataspace based on the modeling dataframe and the
importance of the explanatory variables. It only considers the most
important variables as defined by the degree parameter. It selects a number
(defined by bins) of sensible single values spread over the range of the
numeric variables and creates all possible value combinations among the most
important variables. The values of the remaining variables are set to
mode(factors) or median(numerics).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data_space(df, imp, degree = 4, bins = 5, max_levels = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_space_+3A_df">df</code></td>
<td>
<p>dataframe, training data</p>
</td></tr>
<tr><td><code id="get_data_space_+3A_imp">imp</code></td>
<td>
<p>dataframe, with not more then two columns one of them numeric
containing importance measures and one character or factor column containing
corresponding variable names as found in training data.</p>
</td></tr>
<tr><td><code id="get_data_space_+3A_degree">degree</code></td>
<td>
<p>integer,  number of top important variables to select. For
plotting more than 4 will result in two many flows and the alluvial plot
will not be very readable, Default: 4</p>
</td></tr>
<tr><td><code id="get_data_space_+3A_bins">bins</code></td>
<td>
<p>integer, number of bins for numeric variables, and maximum number
of levels for factor variables, increasing this number might result in too
many flows, Default: 5</p>
</td></tr>
<tr><td><code id="get_data_space_+3A_max_levels">max_levels</code></td>
<td>
<p>integer, maximum number of levels per factor variable, Default: 10</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It selects a the top most important variables based on the degree
parameter and bins the numeric variables using
<code><a href="#topic+manip_bin_numerics">manip_bin_numerics</a></code>, while leaving categoric
variables unchanged. The number of bins for each numeric variable is set to
bins -2. Next the median is picked for each of the bins and the min and the
max value is added for each numeric variable So that we get (median(bin) X
bins -2, max, min) for each numeric variable. Then all possible combinations
between those values and the  categoric factor levels are created. The total
number of all possible combinations defines the range of the data space. The
values of the remaining variables are set to mode(factors) or
median(numerics).
</p>
<p>this model visualisation approach follows the &quot;visualising the model
in the dataspace&quot; principle as described in Wickham H, Cook D, Hofmann H
(2015) Visualizing statistical models: Removing the blindfold. Statistical
Analysis and Data Mining 8(4) &lt;doi:10.1002/sam.11271&gt;
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alluvial_wide">alluvial_wide</a></code>,
<code><a href="#topic+manip_bin_numerics">manip_bin_numerics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df = mtcars2[, ! names(mtcars2) %in% 'ids' ]
m = randomForest::randomForest( disp ~ ., df)
imp = m$importance
dspace = get_data_space(df, imp)
</code></pre>

<hr>
<h2 id='get_pdp_predictions'>get predictions compatible with the partial dependence plotting method</h2><span id='topic+get_pdp_predictions'></span>

<h3>Description</h3>

<p>Alluvial plots are capable of displaying higher dimensional data
on a plane, thus lend themselves to plot the response of a statistical model
to changes in the input data across multiple dimensions. The practical limit
here is 4 dimensions while conventional partial dependence plots are limited
to 2 dimensions.
</p>
<p>Briefly the 4 variables with the highest feature importance for a given
model are selected and 5 values spread over the variable range are selected
for each. Then a grid of all possible combinations is created. All
none-plotted variables are set to the values found in the first row of the
training data set. Using this artificial data space model predictions are
being generated. This process is then repeated for each row in the training
data set and the overall model response is averaged in the end. Each of the
possible combinations is plotted as a flow which is coloured by the bin
corresponding to the average model response generated by that particular
combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pdp_predictions(
  df,
  imp,
  m,
  degree = 4,
  bins = 5,
  .f_predict = predict,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pdp_predictions_+3A_df">df</code></td>
<td>
<p>dataframe, training data</p>
</td></tr>
<tr><td><code id="get_pdp_predictions_+3A_imp">imp</code></td>
<td>
<p>dataframe, with not more then two columns one of them numeric
containing importance measures and one character or factor column containing
corresponding variable names as found in training data.</p>
</td></tr>
<tr><td><code id="get_pdp_predictions_+3A_m">m</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="get_pdp_predictions_+3A_degree">degree</code></td>
<td>
<p>integer,  number of top important variables to select. For
plotting more than 4 will result in two many flows and the alluvial plot
will not be very readable, Default: 4</p>
</td></tr>
<tr><td><code id="get_pdp_predictions_+3A_bins">bins</code></td>
<td>
<p>integer, number of bins for numeric variables, increasing this
number might result in too many flows, Default: 5</p>
</td></tr>
<tr><td><code id="get_pdp_predictions_+3A_.f_predict">.f_predict</code></td>
<td>
<p>corresponding model predict() function. Needs to accept 'm'
as the first parameter and use the 'newdata' parameter. Supply a wrapper for
predict functions with x-y syntax. For parallel processing the predict
method of object classes will not always get imported correctly to the worker
environment. We can pass the correct predict method via this parameter for 
example randomForest:::predict.randomForest. Note that a lot of modeling
packages do not export the predict method explicitly and it can only be found
using :::.</p>
</td></tr>
<tr><td><code id="get_pdp_predictions_+3A_parallel">parallel</code></td>
<td>
<p>logical, turn on parallel processing. Default: FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more on partial dependency plots see
[https://christophm.github.io/interpretable-ml-book/pdp.html].
</p>


<h3>Value</h3>

<p>vector, predictions
</p>


<h3>Parallel Processing</h3>

<p>We are using 'furrr' and the 'future' package to paralelize some of the
computational steps for calculating the predictions. It is up to the user
to register a compatible backend (see <a href="future.html#topic+plan">plan</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> df = mtcars2[, ! names(mtcars2) %in% 'ids' ]
 m = randomForest::randomForest( disp ~ ., df)
 imp = m$importance

 pred = get_pdp_predictions(df, imp
                            , m
                            , degree = 3
                            , bins = 5)

# parallel processing --------------------------
## Not run: 
 future::plan("multisession")
 
 # note that we have to pass the predict method via .f_predict otherwise
 # it will not be available in the worker's environment.
 
 pred = get_pdp_predictions(df, imp
                            , m
                            , degree = 3
                            , bins = 5,
                            , parallel = TRUE
                            , .f_predict = randomForest:::predict.randomForest)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_pdp_predictions_seq'>get predictions compatible with the partial dependence plotting method,
sequential variant that only works for numeric predictions.</h2><span id='topic+get_pdp_predictions_seq'></span>

<h3>Description</h3>

<p>has been replaced by pdp_predictions which can be paralelized
and also handles factor predictions. It is still used to test results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pdp_predictions_seq(df, imp, m, degree = 4, bins = 5, .f_predict = predict)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pdp_predictions_seq_+3A_df">df</code></td>
<td>
<p>dataframe, training data</p>
</td></tr>
<tr><td><code id="get_pdp_predictions_seq_+3A_imp">imp</code></td>
<td>
<p>dataframe, with not more then two columns one of them numeric
containing importance measures and one character or factor column containing
corresponding variable names as found in training data.</p>
</td></tr>
<tr><td><code id="get_pdp_predictions_seq_+3A_m">m</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="get_pdp_predictions_seq_+3A_degree">degree</code></td>
<td>
<p>integer,  number of top important variables to select. For
plotting more than 4 will result in two many flows and the alluvial plot
will not be very readable, Default: 4</p>
</td></tr>
<tr><td><code id="get_pdp_predictions_seq_+3A_bins">bins</code></td>
<td>
<p>integer, number of bins for numeric variables, increasing this
number might result in too many flows, Default: 5</p>
</td></tr>
<tr><td><code id="get_pdp_predictions_seq_+3A_.f_predict">.f_predict</code></td>
<td>
<p>corresponding model predict() function. Needs to accept 'm'
as the first parameter and use the 'newdata' parameter. Supply a wrapper for
predict functions with x-y syntax. For parallel processing the predict
method of object classes will not always get imported correctly to the worker
environment. We can pass the correct predict method via this parameter for 
example randomForest:::predict.randomForest. Note that a lot of modeling
packages do not export the predict method explicitly and it can only be found
using :::.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+get_pdp_predictions">get_pdp_predictions</a></code>
</p>

<hr>
<h2 id='manip_bin_numerics'>bin numerical columns</h2><span id='topic+manip_bin_numerics'></span>

<h3>Description</h3>

<p>centers, scales and Yeo Johnson transforms numeric variables in
a dataframe before binning into n bins of equal range. Outliers based on
boxplot stats are capped (set to min or max of boxplot stats).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manip_bin_numerics(
  x,
  bins = 5,
  bin_labels = c("LL", "ML", "M", "MH", "HH"),
  center = T,
  scale = T,
  transform = T,
  round_numeric = T,
  digits = 2,
  NA_label = "NA"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manip_bin_numerics_+3A_x">x</code></td>
<td>
<p>dataframe with numeric variables, or numeric vector</p>
</td></tr>
<tr><td><code id="manip_bin_numerics_+3A_bins">bins</code></td>
<td>
<p>number of bins for numerical variables, passed to cut as breaks
parameter, Default: 5</p>
</td></tr>
<tr><td><code id="manip_bin_numerics_+3A_bin_labels">bin_labels</code></td>
<td>
<p>labels for the bins from low to high, Default: c(&quot;LL&quot;,
&quot;ML&quot;, &quot;M&quot;, &quot;MH&quot;, &quot;HH&quot;). Can also be one of c('mean', 'median', 'min_max',
'cuts'), the corresponding summary function will supply the labels.</p>
</td></tr>
<tr><td><code id="manip_bin_numerics_+3A_center">center</code></td>
<td>
<p>logical, Default: T</p>
</td></tr>
<tr><td><code id="manip_bin_numerics_+3A_scale">scale</code></td>
<td>
<p>logical, Default: T</p>
</td></tr>
<tr><td><code id="manip_bin_numerics_+3A_transform">transform</code></td>
<td>
<p>logical, apply Yeo Johnson Transformation, Default: T</p>
</td></tr>
<tr><td><code id="manip_bin_numerics_+3A_round_numeric">round_numeric</code></td>
<td>
<p>logical, rounds numeric results if bin_labels is
supplied with a supported summary function name.</p>
</td></tr>
<tr><td><code id="manip_bin_numerics_+3A_digits">digits</code></td>
<td>
<p>integer, number of digits to round to</p>
</td></tr>
<tr><td><code id="manip_bin_numerics_+3A_na_label">NA_label</code></td>
<td>
<p>character vector, define label for missing data, Default:
'NA'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary( mtcars2 )
summary( manip_bin_numerics(mtcars2) )
summary( manip_bin_numerics(mtcars2, bin_labels = 'mean'))
summary( manip_bin_numerics(mtcars2, bin_labels = 'cuts'
  , scale = FALSE, center = FALSE, transform = FALSE))
</code></pre>

<hr>
<h2 id='manip_factor_2_numeric'>converts factor to numeric preserving numeric levels and order in
character levels.</h2><span id='topic+manip_factor_2_numeric'></span>

<h3>Description</h3>

<p>before converting we check whether the levels contain a number,
if they do the number will be preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manip_factor_2_numeric(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manip_factor_2_numeric_+3A_vec">vec</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>See Also</h3>

<p><code><a href="stringr.html#topic+str_detect">str_detect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fac_num = factor( c(1,3,8) )
fac_chr = factor( c('foo','bar') )
fac_chr_ordered = factor( c('a','b','c'), ordered = TRUE )

manip_factor_2_numeric( fac_num )
manip_factor_2_numeric( fac_chr )
manip_factor_2_numeric( fac_chr_ordered )
# does not work for decimal numbers
manip_factor_2_numeric(factor(c("A12", "B55", "10e4")))
manip_factor_2_numeric(factor(c("1.56", "4.56", "8.4")))
</code></pre>

<hr>
<h2 id='mtcars2'>mtcars dataset with cyl, vs, am ,gear, carb as factor variables and car model
names as id</h2><span id='topic+mtcars2'></span>

<h3>Description</h3>

<p>mtcars dataset with cyl, vs, am ,gear, carb as factor variables and car model
names as id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtcars2
</code></pre>


<h3>Format</h3>

<p>A data frame with 32 rows and 12 variables
</p>

<dl>
<dt>mpg</dt><dd><p>Miles/(US) gallon</p>
</dd>
<dt>cyl</dt><dd><p> Number of cylinders</p>
</dd>
<dt>disp</dt><dd><p>Displacement (cu.in.)</p>
</dd>
<dt>hp</dt><dd><p>Gross horsepower</p>
</dd>
<dt>drat</dt><dd><p>Rear axle ratio</p>
</dd>
<dt>wt</dt><dd><p>Weight (1000 lbs)</p>
</dd>
<dt>qsec</dt><dd><p> 1/4 mile time</p>
</dd>
<dt>vs</dt><dd><p>Engine</p>
</dd>
<dt>am</dt><dd><p>Transmission</p>
</dd>
<dt>gear</dt><dd><p>Number of forward gears</p>
</dd>
<dt>carb</dt><dd><p>Number of carburetors</p>
</dd>
<dt>ids</dt><dd><p>car model name</p>
</dd>
</dl>



<h3>Source</h3>

<p>datasets
</p>

<hr>
<h2 id='palette_filter'>color filters for any vector of hex color values</h2><span id='topic+palette_filter'></span>

<h3>Description</h3>

<p>filters are based on rgb values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette_filter(
  palette = palette_qualitative(),
  similar = F,
  greys = T,
  reds = T,
  greens = T,
  blues = T,
  dark = T,
  medium = T,
  bright = T,
  thresh_similar = 25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palette_filter_+3A_palette">palette</code></td>
<td>
<p>any vector with hex color values, Default: palette_qualitative()</p>
</td></tr>
<tr><td><code id="palette_filter_+3A_similar">similar</code></td>
<td>
<p>logical, allow similar colours, similar colours are detected using a
threshold (thresh_similar), two colours are similar when each value for RGB
is within threshold range of the corresponding RGB value of the second
colour, Default: F</p>
</td></tr>
<tr><td><code id="palette_filter_+3A_greys">greys</code></td>
<td>
<p>logical, allow grey colours, blue == green == blue , Default: T</p>
</td></tr>
<tr><td><code id="palette_filter_+3A_reds">reds</code></td>
<td>
<p>logical, allow red colours, blue &lt; 50 &amp; green &lt; 50  &amp; red &gt; 200 , Default:
T</p>
</td></tr>
<tr><td><code id="palette_filter_+3A_greens">greens</code></td>
<td>
<p>logical, allow green colours, green &gt; red &amp; green &gt; blue, Default: T</p>
</td></tr>
<tr><td><code id="palette_filter_+3A_blues">blues</code></td>
<td>
<p>logical, allow blue colours, blue &gt; green &amp; green &gt; red, Default: T</p>
</td></tr>
<tr><td><code id="palette_filter_+3A_dark">dark</code></td>
<td>
<p>logical, allow colours of dark intensity, sum( red, green, blue) &lt; 420 ,
Default: T</p>
</td></tr>
<tr><td><code id="palette_filter_+3A_medium">medium</code></td>
<td>
<p>logical, allow colours of medium intensity, between( sum( red, green,
blue), 420, 600) , Default: T</p>
</td></tr>
<tr><td><code id="palette_filter_+3A_bright">bright</code></td>
<td>
<p>logical, allow colours of bright intensity, sum( red, green, blue) &gt; 600, Default: T</p>
</td></tr>
<tr><td><code id="palette_filter_+3A_thresh_similar">thresh_similar</code></td>
<td>
<p>int, threshold for defining similar colours, see similar, Default: 25</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with hex colors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(magrittr)

palette_qualitative() %&gt;%
  palette_filter(thresh_similar = 0) %&gt;%
  palette_plot_intensity()

## Not run: 
# more examples---------------------------

palette_qualitative() %&gt;%
  palette_filter(thresh_similar = 25) %&gt;%
  palette_plot_intensity()

palette_qualitative() %&gt;%
  palette_filter(thresh_similar = 0, blues = FALSE) %&gt;%
  palette_plot_intensity()

## End(Not run)
</code></pre>

<hr>
<h2 id='palette_increase_length'>increases length of palette by repeating colours</h2><span id='topic+palette_increase_length'></span>

<h3>Description</h3>

<p>works for any vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette_increase_length(palette = palette_qualitative(), n = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palette_increase_length_+3A_palette">palette</code></td>
<td>
<p>any vector, Default: palette_qualitative()</p>
</td></tr>
<tr><td><code id="palette_increase_length_+3A_n">n</code></td>
<td>
<p>int, length, Default: 100</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with increased length
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(magrittr)

length(palette_qualitative())

palette_qualitative() %&gt;%
  palette_increase_length(100) %&gt;%
  length()
</code></pre>

<hr>
<h2 id='palette_plot_intensity'>plot colour intensity of palette</h2><span id='topic+palette_plot_intensity'></span>

<h3>Description</h3>

<p>sum of red green and blue values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette_plot_intensity(palette)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palette_plot_intensity_+3A_palette">palette</code></td>
<td>
<p>any vector containing color hex values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 plot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+palette_plot_rgp">palette_plot_rgp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(interactive()){
palette_qualitative() %&gt;%
  palette_filter( thresh = 25) %&gt;%
  palette_plot_intensity()
 }

## End(Not run)
</code></pre>

<hr>
<h2 id='palette_plot_rgp'>plot rgb values of palette</h2><span id='topic+palette_plot_rgp'></span>

<h3>Description</h3>

<p>grouped bar chart
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette_plot_rgp(palette)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palette_plot_rgp_+3A_palette">palette</code></td>
<td>
<p>any vector containing color hex values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 plot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+palette_plot_intensity">palette_plot_intensity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(interactive()){
palette_qualitative() %&gt;%
  palette_filter( thresh = 50) %&gt;%
  palette_plot_rgp()
 }

## End(Not run)
</code></pre>

<hr>
<h2 id='palette_qualitative'>compose palette from qualitative RColorBrewer palettes</h2><span id='topic+palette_qualitative'></span>

<h3>Description</h3>

<p>uses c('#FF0065','#009850', '#A56F2B', '#005EAA', '#710500', '#7B5380', '#9DD1D1')
and then adds all unique values found in all qualitative RColorBrewer palettes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette_qualitative()
</code></pre>


<h3>Value</h3>

<p>vector with hex values
</p>


<h3>See Also</h3>

<p><code><a href="RColorBrewer.html#topic+RColorBrewer">RColorBrewer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>palette_qualitative()
</code></pre>

<hr>
<h2 id='plot_all_hists'>plot marginal histograms of alluvial plot</h2><span id='topic+plot_all_hists'></span>

<h3>Description</h3>

<p>will create gtable with density histograms and frequency plots
of all variables of a given alluvial plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_all_hists(p, data_input, top = TRUE, keep_labels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_all_hists_+3A_p">p</code></td>
<td>
<p>alluvial plot</p>
</td></tr>
<tr><td><code id="plot_all_hists_+3A_data_input">data_input</code></td>
<td>
<p>dataframe, input data that was used to create dataframe</p>
</td></tr>
<tr><td><code id="plot_all_hists_+3A_top">top</code></td>
<td>
<p>logical, position of histograms, if FALSE adds them at the bottom,
Default: TRUE</p>
</td></tr>
<tr><td><code id="plot_all_hists_+3A_keep_labels">keep_labels</code></td>
<td>
<p>logical, keep title and caption, Default: FALSE</p>
</td></tr>
<tr><td><code id="plot_all_hists_+3A_...">...</code></td>
<td>
<p>additional arguments for specific alluvial plot types: pred_train
can be used to pass training predictions for model response alluvials</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gtable
</p>


<h3>See Also</h3>

<p><code><a href="gridExtra.html#topic+arrangeGrob">arrangeGrob</a></code>
</p>
<p><code><a href="#topic+add_marginal_histograms">add_marginal_histograms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
p = alluvial_wide(mtcars2, max_variables = 3)
plot_all_hists(p, mtcars2)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_condensation'>Plot dataframe condensation potential</h2><span id='topic+plot_condensation'></span>

<h3>Description</h3>

<p>plotting the condensation potential is meant as a decision aid
for which variables to include in an alluvial plot. All variables are
transformed to categoric variables and then two variables are selected by
which the dataframe will be grouped and summarized by. The pair that
results in the greatest condensation of the original dataframe is selected.
Then the next variable which offers the greatest condensation potential is
chosen until all variables have been added. The condensation in percent is
then plotted for each step along with the number of groups (flows) in the
dataframe. By experience it is not advisable to have more than 1500 flows
because then the alluvial plot will take a long time to render. If there is
a particular variable of interest in the dataframe this variable can be
chosen as a starting variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_condensation(df, first = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_condensation_+3A_df">df</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="plot_condensation_+3A_first">first</code></td>
<td>
<p>unquoted expression or string denoting the first variable to be
picked for condensation, Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 plot
</p>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+quosure">quosure</a></code> <code><a href="purrr.html#topic+reexports">reexports</a></code>
<code><a href="RColorBrewer.html#topic+RColorBrewer">RColorBrewer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 plot_condensation(mtcars2)

 plot_condensation(mtcars2, first = 'disp')

</code></pre>

<hr>
<h2 id='plot_hist'>plot histogram of alluvial plot variable</h2><span id='topic+plot_hist'></span>

<h3>Description</h3>

<p>helper function used by add_marginal_histograms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hist(var, p, data_input, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_hist_+3A_var">var</code></td>
<td>
<p>character vector, variable name</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_p">p</code></td>
<td>
<p>alluvial plot</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_data_input">data_input</code></td>
<td>
<p>dataframe used to create alluvial plot</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_...">...</code></td>
<td>
<p>additional arguments for specific alluvial plot types: pred_train
can be used to pass training predictions for model response alluvials</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='plot_imp'>plot feature importance</h2><span id='topic+plot_imp'></span>

<h3>Description</h3>

<p>plot important features of model response alluvial as bars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_imp(p, data_input, truncate_at = 50, color = "darkgrey")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_imp_+3A_p">p</code></td>
<td>
<p>alluvial plot</p>
</td></tr>
<tr><td><code id="plot_imp_+3A_data_input">data_input</code></td>
<td>
<p>dataframe used to generate alluvial plot</p>
</td></tr>
<tr><td><code id="plot_imp_+3A_truncate_at">truncate_at</code></td>
<td>
<p>integer, limit number of features to that value, Default: 50</p>
</td></tr>
<tr><td><code id="plot_imp_+3A_color">color</code></td>
<td>
<p>character vector, Default: 'darkgrey'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
df = mtcars2[, ! names(mtcars2) %in% 'ids' ]

train = caret::train( disp ~ .
                     , df
                     , method = 'rf'
                     , trControl = caret::trainControl( method = 'none' )
                     , importance = TRUE )

pred_train = caret::predict.train(train, df)

p = alluvial_model_response_caret(train, degree = 3, pred_train = pred_train)

plot_imp(p, mtcars2)


## End(Not run)
</code></pre>

<hr>
<h2 id='quarterly_flights'>Quarterly mean arrival delay times for a set of 402 flights</h2><span id='topic+quarterly_flights'></span>

<h3>Description</h3>

<p>Created from nycflights13::flights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quarterly_flights
</code></pre>


<h3>Format</h3>

<p>A data frame with 1608 rows and 6 variables
</p>

<dl>
<dt>tailnum</dt><dd>
<p>a unique identifier created from tailnum, origin, destination and carrier</p>
</dd>
<dt>carrier</dt><dd><p>carrier code</p>
</dd> <dt>origin</dt><dd><p>origin code</p>
</dd>
<dt>dest</dt><dd><p>destination code</p>
</dd> <dt>qu</dt><dd><p>quarter</p>
</dd>
<dt>mean_arr_delay</dt><dd><p>average delay on arrival as either on_time or late</p>
</dd>
</dl>



<h3>Source</h3>

<p>nycflights13::flights
</p>

<hr>
<h2 id='quarterly_sunspots'>Quarterly mean relative sunspots number from 1749-1983</h2><span id='topic+quarterly_sunspots'></span>

<h3>Description</h3>

<p>Quarterly mean relative sunspots number from 1749-1983
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quarterly_sunspots
</code></pre>


<h3>Format</h3>

<p>A data frame with 940 rows and 4 variables
</p>

<dl>
<dt>year</dt><dd></dd>
<dt>qu</dt><dd><p>quarter</p>
</dd> <dt>spots</dt><dd><p>total number of sunspots</p>
</dd>
<dt>mean_spots_per_year</dt><dd></dd>
</dl>



<h3>Source</h3>

<p>Andrews, D. F. and Herzberg, A. M. (1985) Data: A Collection of Problems from Many Fields for the Student and Research Worker. New York: Springer-Verlag.
</p>

<hr>
<h2 id='tidy_imp'>tidy up dataframe containing model feature importance</h2><span id='topic+tidy_imp'></span>

<h3>Description</h3>

<p>returns dataframe with exactly two columns, vars and imp and
aggregates dummy encoded variables. Helper function called by all functions
that take an imp parameter. Can be called manually if formula for
aggregating dummy encoded variables must be modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_imp(imp, df, .f = max, resp_var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_imp_+3A_imp">imp</code></td>
<td>
<p>dataframe or matrix with feature importance information</p>
</td></tr>
<tr><td><code id="tidy_imp_+3A_df">df</code></td>
<td>
<p>dataframe, modeling training data</p>
</td></tr>
<tr><td><code id="tidy_imp_+3A_.f">.f</code></td>
<td>
<p>window function, Default: max</p>
</td></tr>
<tr><td><code id="tidy_imp_+3A_resp_var">resp_var</code></td>
<td>
<p>character, prediction variable, can usually be inferred from 
imp and df. It does not work for all models and needs to be specified in those 
cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe </p>
 <dl>
<dt>vars</dt><dd><p>character column with feature names</p>
</dd>
<dt>imp</dt><dd><p>numerical column, importance values</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'># randomforest
df = mtcars2[, ! names(mtcars2) %in% 'ids' ]
m = randomForest::randomForest( disp ~ ., df)
imp = m$importance
tidy_imp(imp, df)

</code></pre>

<hr>
<h2 id='titanic'>titanic data set'</h2><span id='topic+titanic'></span>

<h3>Description</h3>

<p>titanic data set'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>titanic
</code></pre>


<h3>Format</h3>

<p>A data frame with 891 rows and 10 variables
</p>

<dl>
<dt>Survived</dt><dd><p>Survived</p>
</dd>
<dt>Pclass</dt><dd><p>Pclass</p>
</dd>
<dt>Sex</dt><dd><p>Sex</p>
</dd>
<dt>Age</dt><dd><p>Age</p>
</dd>
<dt>SibSp</dt><dd><p>SibSp</p>
</dd>
<dt>Parch</dt><dd><p>Parch</p>
</dd>
<dt>Fare</dt><dd><p>Fare</p>
</dd>
<dt>Cabin</dt><dd><p>Cabin</p>
</dd>
<dt>Embarked</dt><dd><p>Embarked</p>
</dd>
<dt>title</dt><dd><p>title</p>
</dd>
</dl>



<h3>Source</h3>

<p>datasets
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
