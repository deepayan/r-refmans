<!DOCTYPE html><html><head><title>Help for package WeightedCluster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WeightedCluster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.clustrange'>
<p>Build a clustrange object to compare different clustering solutions.</p></a></li>
<li><a href='#as.seqtree'>
<p>Convert a hierarchical clustering object to a seqtree object.</p></a></li>
<li><a href='#clustassoc'>
<p>Share of an association between an object (described by a dissimilarity matrix) and a covariate that is reproduced by a clustering solution.</p></a></li>
<li><a href='#fuzzyseqplot'>
<p>Plot sequences according to a fuzzy clustering.</p></a></li>
<li><a href='#seqclustname'>
<p>Automatic labeling of cluster using sequence medoids</p></a></li>
<li><a href='#seqnull'>
<p>Generate nonclustered sequence data according to different null models.</p></a></li>
<li><a href='#seqnullcqi'>
<p>Sequence Analysis Typologies Validation Using Parametric Bootstrap</p></a></li>
<li><a href='#seqpropclust'>
<p>Monothetic clustering of state sequences</p></a></li>
<li><a href='#wcAggregateCases'>
<p>Aggregate identical cases.</p></a></li>
<li><a href='#wcClusterQuality'><p>Cluster quality statistics</p></a></li>
<li><a href='#wcCmpCluster'>
<p>Automatic comparison of clustering methods.</p></a></li>
<li><a href='#wcKMedoids'>
<p>K-Medoids or PAM clustering of weighted data.</p></a></li>
<li><a href='#wcKMedRange'>
<p>Compute <code>wcKMedoids</code> clustering for different number of clusters.</p></a></li>
<li><a href='#wcSilhouetteObs'>
<p>Compute the silhouette of each object using weighted data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.6-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering of Weighted Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Studer [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Studer &lt;matthias.studer@unige.ch&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), TraMineR (&ge; 2.0-6), cluster</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, RColorBrewer, foreach, progressr, future, doFuture,
nnet</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit, knitr, isotone, vegan, lattice, progress</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Clusters state sequences and weighted data. It provides an optimized weighted PAM algorithm as well as functions for aggregating replicated cases, computing cluster quality measures for a range of clustering solutions and plotting (fuzzy) clusters of state sequences. Parametric bootstraps methods to validate typology of sequences are also provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://mephisto.unige.ch/weightedcluster/">http://mephisto.unige.ch/weightedcluster/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-06 14:14:17 UTC; studerm</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-07 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.clustrange'>
Build a clustrange object to compare different clustering solutions.
</h2><span id='topic+as.clustrange'></span><span id='topic+as.clustrange.twins'></span><span id='topic+as.clustrange.hclust'></span><span id='topic+plot.clustrange'></span><span id='topic+as.clustrange.dtclust'></span>

<h3>Description</h3>

<p>Build a clustrange object to compare different clustering solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.clustrange(object, diss, weights=NULL, R=1,  samplesize=NULL, ...)
## S3 method for class 'twins'
as.clustrange(object, diss, weights=NULL, R=1, samplesize=NULL, 
		ncluster=20, ...) 
## S3 method for class 'hclust'
as.clustrange(object, diss, weights=NULL, R=1, samplesize=NULL, 
		ncluster=20, ...) 
## S3 method for class 'dtclust'
as.clustrange(object, diss, weights=NULL, R=1, samplesize=NULL, 
		ncluster=20, labels = TRUE, ...)
## S3 method for class 'clustrange'
plot(x, stat="noCH", legendpos="bottomright", 
    norm="none", withlegend=TRUE, lwd=1, col=NULL, ylab="Indicators", 
	xlab="N clusters", conf.int=0.9, ci.method="none", ci.alpha=.3, line="t0", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.clustrange_+3A_object">object</code></td>
<td>
<p>The object to convert such as a data.frame.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_diss">diss</code></td>
<td>
<p>A dissimilarity matrix or a dist object (see <code><a href="stats.html#topic+dist">dist</a></code>).</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_weights">weights</code></td>
<td>
<p>Optional numerical vector containing weights.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_r">R</code></td>
<td>
<p>Optional number of bootstrap that can be used to build confidence intervals.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_samplesize">samplesize</code></td>
<td>
<p>Size of bootstrap sample. Default to sum of weights.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_ncluster">ncluster</code></td>
<td>
<p>Integer. Maximum number of cluster. The range will include all clustering solution starting from two to <code>ncluster</code>.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_labels">labels</code></td>
<td>
<p>Logical. If <code>TRUE</code>, rules to assign an object to a sequence is used to label the cluster (instead of a number).</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_x">x</code></td>
<td>
<p>A <code>clustrange</code> object to be plotted.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_stat">stat</code></td>
<td>
<p>Character. The list of statistics to plot or &quot;noCH&quot; to plot all statistics except &quot;CH&quot; and &quot;CHsq&quot; or &quot;all&quot; for all statistics. See <code><a href="#topic+wcClusterQuality">wcClusterQuality</a></code> for a list of possible values. It is also possible to use &quot;RHC&quot; to plot the quality measure 1-HC. Unlike HC, RHC should be maximized as all other quality measures.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_legendpos">legendpos</code></td>
<td>
<p>Character. legend position, see <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_norm">norm</code></td>
<td>
<p>Character. Normalization method of the statistics can be one of &quot;none&quot; (no normalization), &quot;range&quot; (given as (value -min)/(max-min), &quot;zscore&quot; (adjusted by mean and standard deviation) or &quot;zscoremed&quot; (adjusted by median and median of the difference to the median).</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_withlegend">withlegend</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the legend is not plotted.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_lwd">lwd</code></td>
<td>
<p>Numeric. Line width, see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_col">col</code></td>
<td>
<p>A vector of line colors, see <code><a href="graphics.html#topic+par">par</a></code>. If <code>NULL</code>, a default set of color is used.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_xlab">xlab</code></td>
<td>
<p>x axis label.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_ylab">ylab</code></td>
<td>
<p>y axis label.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_conf.int">conf.int</code></td>
<td>
<p>Confidence to build the confidence interval (default: 0.9).</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_ci.method">ci.method</code></td>
<td>
<p>Method used to build the confidence interval (only if bootstrap has been used, see R above). One of &quot;none&quot; (do not plot confidence interval), &quot;norm&quot; (based on normal approximation), &quot;perc&quot; (based on percentile).)</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_ci.alpha">ci.alpha</code></td>
<td>
<p>alpha color value used to plot the interval.</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_line">line</code></td>
<td>
<p>Which value should be plotted by the line? One of &quot;t0&quot; (value for actual sample), &quot;mean&quot; (average over all bootstraps), &quot;median&quot;(median over all bootstraps).</p>
</td></tr>
<tr><td><code id="as.clustrange_+3A_...">...</code></td>
<td>
<p>Additionnal parameters passed to/from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.clustrange</code> convert objects to <code>clustrange</code> objects. <code>clustrange</code> objects contains a list of clustering solution with associated statistics and can be used to find the optimal clustering solution.
</p>
<p>If <code>object</code> is a <code>data.frame</code> or a <code>matrix</code>, each column should be a clustering solution to be evaluated.
</p>
<p>If <code>object</code> is an <code>hclust</code> or <code>twins</code> objects (i.e. hierarchical clustering output, see <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="cluster.html#topic+diana">diana</a></code> or <code><a href="cluster.html#topic+agnes">agnes</a></code>), the function compute all clustering solution ranging from two to <code>ncluster</code> and compute the associated statistics.
</p>


<h3>Value</h3>

<p>An object of class <code>clustrange</code> with the following elements:
</p>

<dl>
<dt><code>clustering</code>:</dt><dd><p>A <code>data.frame</code> of all clustering solutions.</p>
</dd>
<dt><code>stats</code>:</dt><dd><p>A <code>matrix</code> containing the clustering statistics of each cluster solution.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See also <code><a href="#topic+clustassoc">clustassoc</a></code> (other cluster quality measures), <code><a href="#topic+wcKMedRange">wcKMedRange</a></code>, <code><a href="#topic+wcClusterQuality">wcClusterQuality</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
## Aggregating state sequence
aggMvad &lt;- wcAggregateCases(mvad[, 17:86], weights=mvad$weight)

## Creating state sequence object
mvad.seq &lt;- seqdef(mvad[aggMvad$aggIndex, 17:86], weights=aggMvad$aggWeights)

## COmpute distance using Hamming distance
diss &lt;- seqdist(mvad.seq, method="HAM")

## Ward clustering
wardCluster &lt;- hclust(as.dist(diss), method="ward", members=aggMvad$aggWeights)

## Computing clustrange from Ward clustering
wardRange &lt;- as.clustrange(wardCluster, diss=diss, 
		weights=aggMvad$aggWeights, ncluster=15)

## Plot all statistics (standardized)
plot(wardRange, stat="all", norm="zscoremed", lwd=3)

## Plot HC, RHC and ASW
plot(wardRange, stat=c("HC", "RHC", "ASWw"), norm="zscore", lwd=3)

</code></pre>

<hr>
<h2 id='as.seqtree'>
Convert a hierarchical clustering object to a seqtree object.
</h2><span id='topic+as.seqtree'></span><span id='topic+as.seqtree.twins'></span><span id='topic+as.seqtree.hclust'></span>

<h3>Description</h3>

<p>Convert a hierarchical clustering object to a seqtree object which can then be displayed using <code><a href="TraMineR.html#topic+seqtreedisplay">seqtreedisplay</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.seqtree(object, seqdata, diss, weighted=TRUE, ...)
## S3 method for class 'twins'
as.seqtree(object, seqdata, diss, weighted=TRUE, ncluster, ...)
## S3 method for class 'hclust'
as.seqtree(object, seqdata, diss, weighted=TRUE, ncluster, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.seqtree_+3A_object">object</code></td>
<td>
<p>An object to be converted to a <code><a href="TraMineR.html#topic+seqtree">seqtree</a></code>.</p>
</td></tr>
<tr><td><code id="as.seqtree_+3A_seqdata">seqdata</code></td>
<td>
<p>State sequence object.</p>
</td></tr>
<tr><td><code id="as.seqtree_+3A_diss">diss</code></td>
<td>
<p>A dissimilarity matrix or a dist object (see <code><a href="stats.html#topic+dist">dist</a></code>)</p>
</td></tr>
<tr><td><code id="as.seqtree_+3A_weighted">weighted</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>weights</code> of the <code>seqdata</code> object are taken to build the tree.</p>
</td></tr>
<tr><td><code id="as.seqtree_+3A_ncluster">ncluster</code></td>
<td>
<p>Maximum number of cluster. The tree will be builded until this number of cluster.</p>
</td></tr>
<tr><td><code id="as.seqtree_+3A_...">...</code></td>
<td>
<p>Additionnal parameters passed to/from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default <code>as.seqtree</code> try to convert the object to a <code>data.frame</code> assuming that it contains a list of nested clustering solutions. 
Be aware that <code>seqtree</code> and <code>as.seqtree</code> only support binary splits.
</p>
<p>If <code>object</code> is an <code>hclust</code> or <code>twins</code> objects (i.e. hierarchical clustering output, see <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="cluster.html#topic+diana">diana</a></code> or <code><a href="cluster.html#topic+agnes">agnes</a></code>), the function returns a <code>seqtree</code> object reproducing the agglomerative schedulde.
</p>


<h3>Value</h3>

<p>A <code><a href="TraMineR.html#topic+seqtree">seqtree</a></code> object.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
## Aggregating state sequence
aggMvad &lt;- wcAggregateCases(mvad[, 17:86], weights=mvad$weight)

## Creating state sequence object
mvad.seq &lt;- seqdef(mvad[aggMvad$aggIndex, 17:86], weights=aggMvad$aggWeights)

## COmpute distance using Hamming distance
diss &lt;- seqdist(mvad.seq, method="HAM")

## Ward clustering
wardCluster &lt;- hclust(as.dist(diss), method="ward", members=aggMvad$weight)

st &lt;- as.seqtree(wardCluster, seqdata=mvad.seq, diss=diss, weighted=TRUE, ncluster=10)

print(st)

## You typically want to run (You need to install GraphViz before)
## seqtreedisplay(st, type="d", border=NA)

</code></pre>

<hr>
<h2 id='clustassoc'>
Share of an association between an object (described by a dissimilarity matrix) and a covariate that is reproduced by a clustering solution.
</h2><span id='topic+clustassoc'></span><span id='topic+plot.clustassoc'></span>

<h3>Description</h3>

<p>The <code>clustassoc</code> measures to which extent a clustering solution can account for the relationship between a covariate and the objects of interest, i.e. the sequences or any other object described by a dissimilarity matrix. It can be used to guide the choice of the number of groups ensuring that the clustering captures the relevant information to account for a statistical relationship of interest. This is useful when the clustering is used in subsequent analyses, such as regressions. In this case, the within-cluster variation is ignored, as objects clustered together are described by a single value. Ensuring that the association is accounted for by the clustering can avoid drawing wrong conclusions (see Unterlerchner et al. 2023). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustassoc(clustrange, diss, covar, weights = NULL)
## S3 method for class 'clustassoc'
plot(x, stat=c("Unaccounted", "Remaining", "BIC"), type="b", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustassoc_+3A_clustrange">clustrange</code></td>
<td>
<p>A <code>clustrange</code> object regrouping the different clustering solutions to be evaluated. </p>
</td></tr>
<tr><td><code id="clustassoc_+3A_diss">diss</code></td>
<td>
<p>A dissimilarity matrix or a dist object (see <code><a href="stats.html#topic+dist">dist</a></code>).</p>
</td></tr>
<tr><td><code id="clustassoc_+3A_covar">covar</code></td>
<td>
<p>Vector (Numeric or factor): the covariate of interest. The type of the vector matters for the computation of the BIC (see details). If Numeric, a linear regression is used, while a multinomial regression is used for categorical/factor variables.</p>
</td></tr>
<tr><td><code id="clustassoc_+3A_weights">weights</code></td>
<td>
<p>Optional numerical vector containing weights.</p>
</td></tr>
<tr><td><code id="clustassoc_+3A_x">x</code></td>
<td>
<p>A <code>clustassoc</code> object to be plotted.</p>
</td></tr>
<tr><td><code id="clustassoc_+3A_stat">stat</code></td>
<td>
<p>The information to be plotted according to the number of groups. <code>"Unaccounted"</code> (default) plots the share of the association that is NOT accounted for by the clustering solution. <code>"Remaining"</code> plots the share of the overall variability/discrepancy of the object remaining when controlling for the clustering. <code>"BIC"</code> plots the BIC of a regression predicting the covariate using the clustering solution (see details).</p>
</td></tr>
<tr><td><code id="clustassoc_+3A_type">type</code></td>
<td>
<p>character indicating the type of plotting (see <code><a href="graphics.html#topic+plot.default">plot.default</a></code>). <code>"b"</code> plots points and lines.</p>
</td></tr>
<tr><td><code id="clustassoc_+3A_...">...</code></td>
<td>
<p>Additionnal parameters passed to/from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>clustassoc</code> measures to which extent a clustering solution can account for the relationship between a covariate and the objects of interest. It can be used to guide the choice of the number of groups of the clustering to ensure that it captures the relevant information to account for a statistical relationship of interest. 
</p>
<p>The method works as follows. The relationship between trajectories (or any objects described by a distance matrix) and covariates can be studied directly using discrepancy analysis (see Studer et al. 2011). It measures the strength of the relationship with a Pseudo-R2, measuring the share of the variation of the object explained by a covariate. The method works without prior clustering, and therefore, without data simplification. The method is provided by the <code>dissmfacw</code> function from the <code>TraMineR</code> package.
</p>
<p>Multifactor discrepancy analysis allows measuring a relationship while controlling for other covariates. the <code>clustassoc</code> function measures the remaining association between the objects and the covariate while controlling for the clustering. If the covariate Pseudo-R2 remains high (or at the same level), it means that the clustering does not capture the relationship between covariates and the objects. In other words, the clustering has simplified the relevant information to capture this relationship. Conversely, if the Pseudo-R2 is much lower, it means that the clustering reproduces the key information to understand the relationship. Using this strategy, the <code>clustassoc</code> measure the share of the original Pseudo-R2 that is taken into account by our clustering.
</p>
<p>The function also compute the BIC of a regression predicting the covariate using the clustering solution as proposed by Han et al. 2017. A lower BIC is to be preferred. The method is, however, less reliable than the previous one.
</p>


<h3>Value</h3>

<p>A <code>clustassoc</code> object containing the following information for each clustering:
</p>
<table>
<tr><td><code>Unaccounted</code></td>
<td>
<p>The share of the original association that is NOT accounted for by the clustering solution.</p>
</td></tr>
<tr><td><code>Remaining</code></td>
<td>
<p>The remaining strength of the association (share of the variability of the object) that is not accounted for by the clustering solution.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>The BIC of a model explaining the covariate using the clustering as explanatory variable. </p>
</td></tr>
<tr><td><code>Remaining</code></td>
<td>
<p>The remaining strength of the association (share of the variability of the object) that is not accounted for by the clustering solution.</p>
</td></tr>
<tr><td><code>numcluster</code></td>
<td>
<p>The number of clusters (and 1 means no clustering).</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Matthias Studer
</p>


<h3>References</h3>

<p>Unterlerchner, L., M. Studer and A. Gomensoro (2023). Back to the Features. Investigating the Relationship Between Educational Pathways and Income Using Sequence Analysis and Feature Extraction and Selection Approach. <em>Swiss Journal of Sociology</em>.
</p>
<p>Studer, M. 2013. WeightedCluster Library Manual: A Practical Guide to Creating Typologies of Trajectories in the Social Sciences with R.<em>LIVES Working Papers 2013(24)</em>: 1-32. 
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Mueller (2011). Discrepancy analysis of state sequences, <em>Sociological Methods and Research</em>, Vol. 40(3), 471-510, <a href="https://doi.org/10.1177/0049124111415372">doi:10.1177/0049124111415372</a>.
</p>
<p>Han, Y., A. C. Liefbroer and C. H. Elzinga. 2017. Comparing Methods of Classifying Life Courses: Sequence Analysis and Latent Class Analysis. <em>Longitudinal and Life Course Studies 8(4)</em>: 319-41. 
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+as.clustrange">as.clustrange</a></code> for cluster quality indexes, and the <code>dissmfacw</code> function from the <code>TraMineR</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)

## Small subsample to reduce computations
mvad &lt;- mvad[1:50,]

## Sequence object
mvad.seq &lt;- seqdef(mvad[, 17:86])

## Compute distance using Hamming distance
diss &lt;- seqdist(mvad.seq, method="HAM")

## Ward clustering
wardCluster &lt;- hclust(as.dist(diss), method="ward.D")

## Computing clustrange from Ward clustering up to 5 groups
wardRange &lt;- as.clustrange(wardCluster, diss=diss, ncluster=5)

## Compute clustassoc
## How many groups are required to account for the relationship 
## between trajectories and the gcse5eq covariate 
assoc &lt;- clustassoc(wardRange, covar=mvad$gcse5eq, diss=diss)

## Plot unaccounted share of the association 
## A value close to zero means that the relationship is accounted for.
## Here at least 2-4 groups are required
plot(assoc)

## Plot BIC
## A low value means that an association between trajectories and the covariate is identified.
## 2-3 groups show best results.
plot(assoc, stat="BIC")


## Plot remaining share of the variability of the sequences not explained by clustering
## A value close to zero means that there is no association left (similar)
## Here at least 2-4 groups are required
plot(assoc, stat="Remaining")

</code></pre>

<hr>
<h2 id='fuzzyseqplot'>
Plot sequences according to a fuzzy clustering.
</h2><span id='topic+fuzzyseqplot'></span>

<h3>Description</h3>

<p>This funciton propose a graphical representation of a fuzzy clustering results where sequences are weighted according to their cluster membership strength.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzyseqplot(seqdata, group = NULL, membership.threashold = 0, type = "i", 
			members.weighted = TRUE, memb.exp = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuzzyseqplot_+3A_seqdata">seqdata</code></td>
<td>

<p>State sequence object created with the <code>seqdef</code> function.
</p>
</td></tr>
<tr><td><code id="fuzzyseqplot_+3A_group">group</code></td>
<td>

<p>A fuzzy partition of the data, either as a membership matrix or as a <code>fanny</code> object.
</p>
</td></tr>
<tr><td><code id="fuzzyseqplot_+3A_membership.threashold">membership.threashold</code></td>
<td>

<p>Numeric. Minimum membership strength to be included in plots.
</p>
</td></tr>
<tr><td><code id="fuzzyseqplot_+3A_type">type</code></td>
<td>
<p>the type of the plot. Available types are <code>"d"</code> for state distribution plots (chronograms), <code>"f"</code> for sequence frequency plots, <code>"i"</code> for selected sequence index plots, <code>"I"</code> for whole set index plots, <code>"ms"</code> for plotting the sequence of modal states, <code>"mt"</code> for mean times plots, <code>"pc"</code> for parallel coordinate plots and &quot;r&quot; for representative sequence plots.
</p>
</td></tr>
<tr><td><code id="fuzzyseqplot_+3A_members.weighted">members.weighted</code></td>
<td>

<p>Logical. Should the sequences be weighted by their membership strength in each group before being plotted?
</p>
</td></tr>
<tr><td><code id="fuzzyseqplot_+3A_memb.exp">memb.exp</code></td>
<td>

<p>Optional. Fuzzyness parameter used in the <code>fanny</code> algorithm.
</p>
</td></tr>
<tr><td><code id="fuzzyseqplot_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="HH.html#topic+seqplot">seqplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dataset is augmented by repeating the sequence <code class="reqn">s_i</code> of individual <code class="reqn">i</code> <code class="reqn">k</code> times (i.e., once per cluster). We therefore have <code class="reqn">k</code> sequences for individual <code class="reqn">i</code>, denoted as <code class="reqn">s_{i1}... s_{ik}</code>. These sequences are therefore weighted according to their membership degree <code class="reqn">u_{i1}... u_{ik}</code>. Hence, even if the same sequence were repeated <code class="reqn">k</code> times, its total weight sum to 1. An additional categorical covariate is created in this augmented dataset that  specifies the cluster (ranging from 1 to <code class="reqn">k</code>) of the associated membership degree. This weighting strategy allows us to use any tools available for weighted sequence data (see <code><a href="HH.html#topic+seqplot">seqplot</a></code>).
</p>
<p>For index plots, we additionally suggest ordering the sequences according to membership degree by setting <code>sortv="membership"</code> (see example). The most typical sequence lies at the top of the subfigures, with a high membership degree; meanwhile, the bottom shows less-characteristic patterns. Restricting to sequences with the highest membership degree can be achieved with the <code>membership.treashold</code> argument. 
</p>


<h3>References</h3>

<p>Studer, M. (2018). Divisive property-based and fuzzy clustering for sequence analysis. In G. Ritschard and M. Studer (Eds.), <em>Sequence Analysis and Related Approaches: Innovative Methods and Applications</em>, Life Course Research and Social Policies.
</p>


<h3>See Also</h3>

<p>See also <code><a href="cluster.html#topic+fanny">fanny</a></code> for fuzzy clustering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(mvad)
	mvad.seq &lt;- seqdef(mvad[1:100, 17:86])

	## COmpute distance using Hamming distance
	diss &lt;- seqdist(mvad.seq, method="HAM")
	library(cluster)
	fclust &lt;- fanny(diss, k=2, diss=TRUE)
	
	fuzzyseqplot(mvad.seq, group=fclust, type="d")
	fuzzyseqplot(mvad.seq, group=fclust, type="I", sortv="membership")
	fuzzyseqplot(mvad.seq, group=fclust, type="f")
</code></pre>

<hr>
<h2 id='seqclustname'>
Automatic labeling of cluster using sequence medoids
</h2><span id='topic+seqclustname'></span>

<h3>Description</h3>

<p>This function automatically name the cluster using the sequence medoid of each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqclustname(seqdata, group, diss, weighted = TRUE, perc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqclustname_+3A_seqdata">seqdata</code></td>
<td>
<p>State sequence object (see <code>seqdef</code>).</p>
</td></tr>
<tr><td><code id="seqclustname_+3A_group">group</code></td>
<td>
<p>A vector of clustering membership.</p>
</td></tr>
<tr><td><code id="seqclustname_+3A_diss">diss</code></td>
<td>
<p>a dissimilarity matrix or a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="seqclustname_+3A_weighted">weighted</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>weights</code> of the <code>seqdata</code> object are taken to find the medoids.</p>
</td></tr>
<tr><td><code id="seqclustname_+3A_perc">perc</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the percentage of sequences in each cluster is added to the label of each group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor of clustering membership. The labels are defined using sequences medoids and optionnaly percentage of case in each cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
## Aggregating state sequence
aggMvad &lt;- wcAggregateCases(mvad[, 17:86], weights=mvad$weight)

## Creating state sequence object
mvad.seq &lt;- seqdef(mvad[aggMvad$aggIndex, 17:86], weights=aggMvad$aggWeights)
## Computing Hamming distance between sequence
diss &lt;- seqdist(mvad.seq, method="HAM")

## KMedoids using PAMonce method (clustering only)
clust5 &lt;- wcKMedoids(diss, k=5, weights=aggMvad$aggWeights)

clust5.labels &lt;- seqclustname(mvad.seq, clust5$clustering, diss=diss, perc=TRUE)
seqdplot(mvad.seq, group=clust5.labels)
</code></pre>

<hr>
<h2 id='seqnull'>
Generate nonclustered sequence data according to different null models. 
</h2><span id='topic+seqnull'></span>

<h3>Description</h3>

<p>This function generates sequence data that is similar to the original sequence data, but nonclusterd on specific aspects related to the sequencing, timing or time spend in the different states. The function is typically used by only specifying a model among <code>"combined"</code>, <code>"duration"</code>, <code>"sequencing"</code>, <code>"stateindep"</code> or 
<code>"Markov"</code>. The <code>"userpos"</code> model allows to fully specify a sequence generating model using a starting distribution and a transition rate matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqnull(seqdata, model = c("combined", "duration", "sequencing", 
        "stateindep", "Markov", "userpos"), imp.trans = NULL, 
		imp.trans.limit = -1, trate = "trate", begin = "freq", 
		time.varying = TRUE, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqnull_+3A_seqdata">seqdata</code></td>
<td>

<p>State sequence object of class <code>stslist</code>.
The sequence data to use.
Use <code>seqdef</code> to create such an object.
</p>
</td></tr>
<tr><td><code id="seqnull_+3A_model">model</code></td>
<td>

<p>String.
The model used to generate the nonclustered data. It can be one of <code>"combined"</code>, <code>"duration"</code>, <code>"sequencing"</code>, <code>"stateindep"</code>,
<code>"Markov"</code> or <code>"userpos"</code>. See the Details section.
</p>
</td></tr>
<tr><td><code id="seqnull_+3A_imp.trans">imp.trans</code></td>
<td>

<p>Optional named character vector listing impossible transitions. Names indicates starting states, while value destinations. Only used for <code>"combined"</code>, <code>"duration"</code> and <code>"sequencing"</code> models.
</p>
</td></tr>
<tr><td><code id="seqnull_+3A_imp.trans.limit">imp.trans.limit</code></td>
<td>

<p>Numeric. Optional. All transitions with a transition rates below (or equal) this value are considered impossible. Only used for <code>"combined"</code>, <code>"duration"</code> and <code>"sequencing"</code> models.
</p>
</td></tr>
<tr><td><code id="seqnull_+3A_trate">trate</code></td>
<td>

<p>String, matrix or array. Only used to specify the <code>"userpos"</code> model. It can be either a method to compute the time-varying transition rates, a matrix of transition rates used for all time points, or a time-varying transition rates matrix specified as an array. String values <code>"freq"</code> to use state distribution or <code>"trate"</code> to use transition rates.
</p>
</td></tr>
<tr><td><code id="seqnull_+3A_begin">begin</code></td>
<td>

<p>String or vector. Only used to specify the <code>"userpos"</code> model. Either a vector of probability for the first state in the sequence, or a method to compute it. String values <code>"freq"</code> to use state distribution at first time point or <code>"ofreq"</code> to use the overall (time-independent) state distribution.
</p>
</td></tr>
<tr><td><code id="seqnull_+3A_time.varying">time.varying</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the state distribution or the transition rate specified by the <code>trate</code> arguement (using a string) are computed separately for each time point. 
</p>
</td></tr>
<tr><td><code id="seqnull_+3A_weighted">weighted</code></td>
<td>

<p>Logicel. If <code>TRUE</code>, state distribution and transition rates are computed using the weights specified in <code>seqdata</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates sequence data that is similar to the original sequence data, but nonclusterd on specific aspects related to the sequencing, timing or time spend in the different states. The function is typically used by only specifying a model among <code>"combined"</code>, <code>"duration"</code>, <code>"sequencing"</code>, <code>"stateindep"</code> or 
<code>"Markov"</code>. The models are shortly described below. More information about their usefulness can be found in Studer (2021) (see below).
</p>
<p>The <code>"combined"</code>, <code>"duration"</code> and <code>"sequencing"</code> models generate sequence in spell format, by generating a vector of state and their attached durations. The <code>"combined"</code> model generate random sequencing and duration. The <code>"duration"</code> model only randomizes duration, while keeping the original sequencing of the states found in the data. Finally, the <code>"sequencing"</code> only randomizes the sequencing of the states and keep the time spent in a state as found in the data. 
</p>
<p>The <code>"stateindep"</code> model generate sequence by randomly selecting a state at each time point without taking into account the previous one. It can generate highly unlikely sequence because it doesn't account for coherence of trajectories over time. 
</p>
<p>The <code>"Markov"</code> model use a time-invariant (homogeneouns) transition rate matrix to generate the sequences. It can reveals difference in the timing of transitions.
</p>


<h3>Value</h3>

<p>A state sequence object of class <code>stslist</code>.
</p>


<h3>References</h3>

<p>Studer, M. (2021). Validating Sequence Analysis Typologies Using Parametric Bootstrap. <em>Sociological Methodology</em>. <a href="https://doi.org/10.1177/00811750211014232">doi:10.1177/00811750211014232</a>
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+seqnullcqi">seqnullcqi</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biofam)

bf.seq &lt;- seqdef(biofam[1:200,10:25])

##Plot the sequences generated by different null models.
seqdplot(seqnull(bf.seq, model="combined"))

seqdplot(seqnull(bf.seq, model="duration"))

seqdplot(seqnull(bf.seq, model="sequencing"))

seqdplot(seqnull(bf.seq, model="stateindep"))

seqdplot(seqnull(bf.seq, model="Markov"))

</code></pre>

<hr>
<h2 id='seqnullcqi'>
Sequence Analysis Typologies Validation Using Parametric Bootstrap 
</h2><span id='topic+seqnullcqi'></span><span id='topic+plot.seqnullcqi'></span><span id='topic+print.seqnullcqi'></span>

<h3>Description</h3>

<p><code>seqnullcqi</code> implements the methodology proposed by Studer (2021) for the validation of sequence analysis typologies using  parametric bootstraps. The method works by comparing the cluster quality of an observed typology with the quality obtained by clustering similar but nonclustered data. Several models to test the different structuring aspects of the sequences important in life-course research, namely, sequencing, timing, and duration (see function <code><a href="#topic+seqnull">seqnull</a></code>). This strategy allows identifying the key structural aspects captured by the observed typology. Plot and print methods of the <code>seqnullcqi</code> results are also provide. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqnullcqi(seqdata, clustrange, R, model=c("combined", "duration", "sequencing", 
                    "stateindep", "Markov", "userpos"), seqdist.args=list(), 
					kmedoid = FALSE, hclust.method="ward.D", 
					parallel=FALSE, ...)
		   
## S3 method for class 'seqnullcqi'
plot(x, stat, type = c("line", "density", "boxplot", "seqdplot"),
                          quant = 0.95, norm = TRUE, legendpos = "topright",
                          alpha = 0.2, ...)

## S3 method for class 'seqnullcqi'
print(x, norm=TRUE, quant=0.95, digits=2, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqnullcqi_+3A_seqdata">seqdata</code></td>
<td>
<p>State sequence object of class <code>stslist</code>. The sequence data to use. Use <code>seqdef</code> to create such an object.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_clustrange">clustrange</code></td>
<td>
<p>The clustering of the data to be validated as an object of class <code>clustrange</code>.	See <code><a href="#topic+as.clustrange">as.clustrange</a></code> or <code><a href="#topic+wcKMedRange">wcKMedRange</a></code> to create such an object.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_model">model</code></td>
<td>
<p>String. The model used to generate the similar but nonclustered data. It can be one of <code>"combined"</code>, <code>"duration"</code>, <code>"sequencing"</code>, <code>"stateindep"</code>, <code>"Markov"</code> or <code>"userpos"</code>. See <code><a href="#topic+seqnull">seqnull</a></code> for more information.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_r">R</code></td>
<td>
<p>The number of bootstraps.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_seqdist.args">seqdist.args</code></td>
<td>
<p>List of arguments passed to <code>seqdist</code> for computing the distances.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_kmedoid">kmedoid</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the PAM algorithm is used to cluster the data using  <code><a href="#topic+wcKMedRange">wcKMedRange</a></code>. If <code>FALSE</code>, <code>hclust</code> is used.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_hclust.method">hclust.method</code></td>
<td>
<p>String. Hierarchical method to use with <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+seqnullcqi">seqnullcqi</a></code> object to be plotted or printed.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_stat">stat</code></td>
<td>
<p>Character. The statistic to plot or &quot;all&quot; for all statistics. See <code><a href="#topic+wcClusterQuality">wcClusterQuality</a></code> for a list of possible values.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_type">type</code></td>
<td>
<p>Character. The type of graphic to be plotted. If <code>type="line"</code> (default), a transparent line representing the cluster quality index for each bootstrap is plotted using a separate line. If <code>type="density"</code>, the density of the maximum cluster quality index values among the different number of groups is plotted as well as the original cluster quality values. If <code>type="beanplot"</code>, beanplot of the distribution of the cluster quality index values for each number of groups is plotted separately. If <code>type="seqdplot"</code>, a state distribution sequence plot of the sequences generated with the null model is plotted (see <code>seqdplot</code>).</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_quant">quant</code></td>
<td>
<p>Numeric. Quantile to use for the confidence intervals.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_norm">norm</code></td>
<td>
<p>Logical. If <code>TRUE</code>, cluster quality indices are standardized using the mean and standard deviation of the null distribution.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_legendpos">legendpos</code></td>
<td>
<p>Character. legend position, see <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_alpha">alpha</code></td>
<td>
<p>Transparency parameter for the lines to be drawn (only for <code>type="line"</code>).</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_digits">digits</code></td>
<td>
<p>Number of digits to be printed.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Whether to initialize the parallel processing of the <code>future</code> package using the default <code><a href="future.html#topic+multisession">multisession</a></code> strategy. If <code>FALSE</code> (default), then the current <code><a href="future.html#topic+plan">plan</a></code> is used. If <code>TRUE</code>, <code><a href="future.html#topic+multisession">multisession</a></code> <code><a href="future.html#topic+plan">plan</a></code> is initialized using default values.</p>
</td></tr>
<tr><td><code id="seqnullcqi_+3A_...">...</code></td>
<td>
<p>Additionnal parameters passed to <code><a href="#topic+seqnull">seqnull</a></code> (for <code>seqnullcqi</code>) or <code><a href="graphics.html#topic+plot">plot</a></code> or <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>seqnullcqi</code> function provides a validation method for sequence analysis typologies using parametric bootstraps as proposed in Studer (2021). This method works by comparing the value of the cluster quality of an observed typology with the cluster quality obtained by clustering similar but nonclustered data. More precisely it works as follows. 
</p>

<ol>
<li><p> Cluster the observed sequence data and compute the associated cluster quality indices. 
</p>
</li>
<li><p> Repeat <code>R</code> times:
</p>

<ol>
<li><p> Generate similar but nonclustered data using a <em>null</em> model (see <code><a href="#topic+seqnull">seqnull</a></code> for available <em>null</em> models).
</p>
</li>
<li><p> Cluster the generated data using the same distance measure and clustering algorithm as in step 1. 
</p>
</li>
<li><p> Record the quality indices values of this null clustering. 
</p>
</li></ol>

</li>
<li><p> Compare the quality of the observed typology with the one obtained in the <code>R</code> bootstraps with the <em>null</em> sequence data using plot and print methods. 
</p>
</li>
<li><p> If the cluster quality measure of the observed typology is constantly higher than the ones obtained with <em>null</em> data, a &ldquo;good&rdquo; typology has been found.
</p>
</li></ol>

<p>Several <em>null</em> models are provided to test the different structuring aspects of the sequences important in life-course research, namely, sequencing, timing, and duration (see function <code><a href="#topic+seqnull">seqnull</a></code> and Studer, 2021). This strategy allows identifying the key structural aspects captured by the observed typology.
</p>


<h3>Value</h3>

<p><code>seqnullcqi</code> returns a <code>"seqnullcqi"</code> object with the following components:
</p>
<table>
<tr><td><code>seqdata</code></td>
<td>
<p>The sequence data generated by the null model (see <code><a href="#topic+seqnull">seqnull</a></code></p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>The cluster quality indices for the null data.</p>
</td></tr>
<tr><td><code>clustrange</code></td>
<td>
<p>The clustering of the data to be validated as an object of class <code>clustrange</code>.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>The number of bootstraps</p>
</td></tr>
<tr><td><code>kmedoid</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the PAM algorithm was used to cluster the data using  <code><a href="#topic+wcKMedRange">wcKMedRange</a></code>.</p>
</td></tr>
<tr><td><code>hclust.method</code></td>
<td>
<p>Hierarchical method to used with <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
<tr><td><code>seqdist.args</code></td>
<td>
<p>List of arguments passed to <code>seqdist</code> for computing the distances.</p>
</td></tr>
<tr><td><code>nullmodel</code></td>
<td>
<p>List of arguments passed to <code><a href="#topic+seqnull">seqnull</a></code> to generate the sequence data under the null model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Studer, M. (2021). Validating Sequence Analysis Typologies Using Parametric Bootstrap. <em>Sociological Methodology</em>. <a href="https://doi.org/10.1177/00811750211014232">doi:10.1177/00811750211014232</a>
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+seqnull">seqnull</a></code> for description of the null models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam)

## Create the sequence object
bf.seq &lt;- seqdef(biofam[sample.int(nrow(biofam), 100),10:25])

## Library fastcluster greatly improve computation time when using hclust
# library(fastcluster)
## Computing distances
diss &lt;- seqdist(bf.seq, method="HAM")
## Hierarchical clustering
hc &lt;- hclust(as.dist(diss), method="ward.D")
# Computing cluster quality measures.
clustqual &lt;- as.clustrange(hc, diss=diss, ncluster=7)

# Compute cluster quality measure for the null model "combined"
# seqdist.args should be the same as for seqdist above except the sequence data.
# Clustering methods should be the same as above.
bcq &lt;- seqnullcqi(bf.seq, clustqual, R=5, model=c("combined"), 
				seqdist.args=list(method="HAM"),
				hclust.method="ward.D")

# Print the results
bcq

## Different kind of plots

plot(bcq, stat="ASW", type="line")
plot(bcq, stat="ASW", type="density")
plot(bcq, stat="ASW", type="boxplot")

</code></pre>

<hr>
<h2 id='seqpropclust'>
Monothetic clustering of state sequences
</h2><span id='topic+seqpropclust'></span><span id='topic+wcPropertyClustering'></span><span id='topic+dtcut'></span>

<h3>Description</h3>

<p>Monothetic divisive clustering of the data using object properties. For state sequences object different set of properties are automoatically extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqpropclust(seqdata, diss, properties = c("state", "duration", "spell.age", 
		"spell.dur", "transition", "pattern", "AFtransition", "AFpattern", 
		"Complexity"), other.prop = NULL, prop.only = FALSE, pmin.support = 0.05, 
		max.k = -1, with.missing = TRUE, R = 1, weight.permutation = "diss", 
		min.size = 0.01, max.depth = 5, maxcluster = NULL, ...)
		
wcPropertyClustering(diss, properties, maxcluster = NULL, ...)
dtcut(st, k, labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqpropclust_+3A_seqdata">seqdata</code></td>
<td>
<p>State sequence object (see <code>seqdef</code>).</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_diss">diss</code></td>
<td>
<p>a dissimilarity matrix or a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_properties">properties</code></td>
<td>
<p>Character or <code>data.frame</code>. In <code>seqpropclust</code>, it can be a list of properties to be extracted from <code>seqdata</code>. It can also be a <code>data.frame</code> specifying the properties to use for the clustering.</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_other.prop">other.prop</code></td>
<td>
<p><code>data.frame</code>. Additional properties to be considered to cluster the sequences.</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_prop.only">prop.only</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the function returns a data.frame containing the extracted properties (without clustering the data).</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_pmin.support">pmin.support</code></td>
<td>
<p>Numeric. Minimum support (as a proportion of sequences). See <code>seqefsub</code>.</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_max.k">max.k</code></td>
<td>
<p>Numeric. The maximum number of events allowed in a subsequence. See <code>seqefsub</code>.</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_with.missing">with.missing</code></td>
<td>
<p>Logical. If <code>TRUE</code>, property of missing spell are also extracted.</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_r">R</code></td>
<td>
<p>Number of permutations used to assess the significance of the split. See <code>disstree</code>.</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_weight.permutation">weight.permutation</code></td>
<td>
<p>Weight permutation method: &quot;diss&quot; (attach weights to the dissimilarity matrix), &quot;replicate&quot; (replicate cases using weights), &quot;rounded-replicate&quot; (replicate case using rounded weights), &quot;random-sampling&quot; (random assignment of covariate profiles to the objects using distributions defined by the weights.). See <code>disstree</code>.</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_min.size">min.size</code></td>
<td>
<p>Minimum number of cases in a node, will be treated as a proportion if less than 1. See <code>disstree</code>.</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_max.depth">max.depth</code></td>
<td>
<p>Maximum depth of the tree. See <code>disstree</code>.</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_maxcluster">maxcluster</code></td>
<td>
<p>Maximum number of cluster to consider.</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_st">st</code></td>
<td>
<p>A divise clustering tree as produced by <code>seqpropclust</code></p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_k">k</code></td>
<td>
<p>The number of groups to extract.</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_labels">labels</code></td>
<td>
<p>Logical. If <code>TRUE</code>, rules to assign an object to a sequence is used to label the cluster (instead of a number).</p>
</td></tr>
<tr><td><code id="seqpropclust_+3A_...">...</code></td>
<td>
<p>Arguments passed to/from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method implement the DIVCLUS-T algorithm.
</p>


<h3>Value</h3>

<p>Return a <code>seqpropclust</code> object, which is (in fact) a <code>distree</code> object.  See <code>disstree</code>.
</p>


<h3>References</h3>

<p>Studer, M. (2018). Divisive property-based and fuzzy clustering for sequence analysis. In G. Ritschard and M. Studer (Eds.), <em>Sequence Analysis and Related Approaches: Innovative Methods and Applications</em>, Life Course Research and Social Policies. Springer.
</p>
<p>Piccarreta R, Billari FC (2007). Clustering work and family trajectories by using a divisive algorithm. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, 170(4), 1061-1078.
</p>
<p>Chavent M, Lechevallier Y, Briant O (2007). DIVCLUS-T: A monothetic divisive hierarchical clustering method. <em>Computational Statistics &amp; Data Analysis</em>, 52(2), 687-701.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.clustrange">as.clustrange</a></code>, <code>seqtreedisplay</code>, <code>disstree</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
mvad.seq &lt;- seqdef(mvad[1:100, 17:86])

## COmpute distance using Hamming distance
diss &lt;- seqdist(mvad.seq, method="HAM")

pclust &lt;- seqpropclust(mvad.seq , diss=diss, maxcluster=5, properties=c("state", "duration")) 

## Run it to visualize the results
##seqtreedisplay(pclust, type="d", border=NA, showdepth=TRUE)

pclustqual &lt;- as.clustrange(pclust, diss=diss, ncluster=5)
</code></pre>

<hr>
<h2 id='wcAggregateCases'>
Aggregate identical cases.
</h2><span id='topic+wcAggregateCases'></span><span id='topic+wcAggregateCases.matrix'></span><span id='topic+wcAggregateCases.data.frame'></span><span id='topic+wcAggregateCases.stslist'></span><span id='topic+print.wcAggregateCases'></span>

<h3>Description</h3>

<p>Function to aggregate identical cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wcAggregateCases(x, weights = NULL, ...)
## S3 method for class 'data.frame'
wcAggregateCases(x, weights=NULL, ...) 
## S3 method for class 'matrix'
wcAggregateCases(x, weights=NULL, ...) 
## S3 method for class 'stslist'
wcAggregateCases(x, weights=NULL, weighted=TRUE, ...)
## S3 method for class 'wcAggregateCases'
print(x,  ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wcAggregateCases_+3A_x">x</code></td>
<td>
<p>The object to aggregate.</p>
</td></tr>
<tr><td><code id="wcAggregateCases_+3A_weights">weights</code></td>
<td>
<p>Numeric. An optional case weights vector.</p>
</td></tr>
<tr><td><code id="wcAggregateCases_+3A_weighted">weighted</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the <code>weights</code> are taken from the sequence object (see <code>seqdef</code>).</p>
</td></tr>
<tr><td><code id="wcAggregateCases_+3A_...">...</code></td>
<td>
<p>Optional additionnal arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>wcAggregateCases</code> object with the following components:
</p>

<dl>
<dt>aggIndex</dt><dd><p>Index of the unique cases in the original object data.</p>
</dd>
<dt>aggWeights</dt><dd><p>Aggregated case weights</p>
</dd>
<dt>disaggIndex</dt><dd><p>Index of the original object data in the unique cases.</p>
</dd>
<dt>disaggWeights</dt><dd><p>Original weights used.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
## Taking only the father unemployment and 
## success at the end of compulsory schooling.
myData &lt;- mvad[ , c("funemp", "gcse5eq")]
## Computing aggregated cases informations
ac &lt;- wcAggregateCases(myData, weights=mvad$weight)
print(ac)
## Retrieving unique cases in the original data set
uniqueData &lt;- myData[ac$aggIndex, ]
## Table from original data
table.orig &lt;- xtabs(mvad$weight~funemp+gcse5eq, data=myData)

## Table from aggregated data
table.agg &lt;- xtabs(ac$aggWeights~funemp+gcse5eq, data=uniqueData)

## Both table are equal, no information is lost 
## (only the call command is different)
all(table.orig == table.agg)

</code></pre>

<hr>
<h2 id='wcClusterQuality'>Cluster quality statistics</h2><span id='topic+wcClusterQuality'></span>

<h3>Description</h3>

<p>Compute several quality statistics of a given clustering solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wcClusterQuality(diss, clustering, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wcClusterQuality_+3A_diss">diss</code></td>
<td>
<p>A dissimilarity matrix or a dist object (see <code><a href="stats.html#topic+dist">dist</a></code>)</p>
</td></tr>
<tr><td><code id="wcClusterQuality_+3A_clustering">clustering</code></td>
<td>
<p>Factor. A vector of clustering membership.</p>
</td></tr>
<tr><td><code id="wcClusterQuality_+3A_weights">weights</code></td>
<td>
<p>optional numerical vector containing weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute several quality statistics of a given clustering solution. See value for details.
</p>


<h3>Value</h3>

<p>A list with two elements <code>stats</code> and <code>ASW</code>:
</p>

<dl>
<dt><code>stats</code></dt><dd><p>with the following statistics:</p>
</dd>
</dl>

<dl>
<dt>PBC</dt><dd><p>Point Biserial Correlation. Correlation between the given distance matrice and a distance which equal to zero for individuals in the same cluster and one otherwise.</p>
</dd>
<dt>HG</dt><dd><p>Hubert's Gamma. Same as previous but using Kendall's Gamma coefficient.</p>
</dd>
<dt>HGSD</dt><dd><p>Hubert's Gamma (Somers'D). Same as previous but using Somers' D coefficient.</p>
</dd>
<dt>ASW</dt><dd><p>Average Silhouette width (observation).</p>
</dd>
<dt>ASWw</dt><dd><p>Average Silhouette width (weighted).</p>
</dd>
<dt>CH</dt><dd><p>Calinski-Harabasz index (Pseudo F statistics computed from distances).</p>
</dd>
<dt>R2</dt><dd><p>Share of the discrepancy explained by the clustering solution.</p>
</dd>
<dt>CHsq</dt><dd><p>Calinski-Harabasz index (Pseudo F statistics computed from <em>squared</em> distances).</p>
</dd>
<dt>R2sq</dt><dd><p>Share of the discrepancy explained by the clustering solution (computed using <em>squared</em> distances).</p>
</dd>
<dt>HC</dt><dd><p>Hubert's C coefficient.</p>
</dd>
</dl>

<dl>
<dt><code>ASW</code>:</dt><dd><p>The Average Silhouette Width of each cluster, one column for each ASW measure.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
## Aggregating state sequence
aggMvad &lt;- wcAggregateCases(mvad[, 17:86], weights=mvad$weight)

## Creating state sequence object
mvad.seq &lt;- seqdef(mvad[aggMvad$aggIndex, 17:86], weights=aggMvad$aggWeights)
## Computing Hamming distance between sequence
diss &lt;- seqdist(mvad.seq, method="HAM")

## KMedoids using PAMonce method (clustering only)
clust5 &lt;- wcKMedoids(diss, k=5, weights=aggMvad$aggWeights, cluster.only=TRUE)

## Compute the silhouette of each observation
qual &lt;- wcClusterQuality(diss, clust5, weights=aggMvad$aggWeights)

print(qual)

</code></pre>

<hr>
<h2 id='wcCmpCluster'>
Automatic comparison of clustering methods.
</h2><span id='topic+wcCmpCluster'></span><span id='topic+print.clustrangefamily'></span><span id='topic+plot.clustrangefamily'></span><span id='topic+summary.clustrangefamily'></span>

<h3>Description</h3>

<p>Automatically compute different clustering solutions and associated quality measures to help identifying the best one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wcCmpCluster(diss, weights = NULL, maxcluster, method = "all", pam.combine = TRUE)
## S3 method for class 'clustrangefamily'
print(x, max.rank=1, ...)
## S3 method for class 'clustrangefamily'
summary(object, max.rank=1, ...)
## S3 method for class 'clustrangefamily'
plot(x, group="stat", method="all", pam.combine=FALSE, 
    stat="noCH", norm="none", withlegend=TRUE, lwd=1, col=NULL, legend.prop=NA, 
	rows=NA, cols=NA, main=NULL, xlab="", ylab="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wcCmpCluster_+3A_diss">diss</code></td>
<td>
<p>A dissimilarity matrix or a dist object (see <code><a href="stats.html#topic+dist">dist</a></code>).</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_weights">weights</code></td>
<td>
<p>Optional numerical vector containing weights.</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_maxcluster">maxcluster</code></td>
<td>
<p>Integer. Maximum number of cluster. The range will include all clustering solution starting from two to <code>ncluster</code>.</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_method">method</code></td>
<td>
<p>A vector of hierarchical clustering methods to compute or <code>"all"</code> for all methods. 
Possible values include &quot;ward&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot;, &quot;centroid&quot; (using <code><a href="stats.html#topic+hclust">hclust</a></code>), 
&quot;pam&quot; (using <code><a href="#topic+wcKMedRange">wcKMedRange</a></code>), &quot;diana&quot; (only for unweighted datasets using <code><a href="cluster.html#topic+diana">diana</a></code>), 
&quot;beta.flexible&quot; (only for unweighted datasets using <code><a href="cluster.html#topic+agnes">agnes</a></code>)</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_pam.combine">pam.combine</code></td>
<td>
<p>Logical. Should we try all combinations of hierarchical and PAM clustering?</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_x">x</code></td>
<td>
<p>A <code>clustrangefamily</code> object to plot or print</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_object">object</code></td>
<td>
<p>A <code>clustrangefamily</code> object to summarize</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_max.rank">max.rank</code></td>
<td>
<p>Integer. The different number of solution to print/summarize</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_group">group</code></td>
<td>
<p>One of <code>"stat"</code> or <code>"method"</code>. If <code>"stat"</code>, plots are grouped by statistics, otherwise by clustering methods.</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_stat">stat</code></td>
<td>
<p>Character. The list of statistics to plot or &quot;noCH&quot; to plot all statistics except &quot;CH&quot; and &quot;CHsq&quot; or &quot;all&quot; for all statistics. See <code><a href="#topic+wcClusterQuality">wcClusterQuality</a></code> for a list of possible values. It is also possible to use &quot;RHC&quot; to plot the quality measure 1-HC. Unlike HC, RHC should be maximized as all other quality measures.</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_norm">norm</code></td>
<td>
<p>Character. Normalization method of the statistics can be one of &quot;none&quot; (no normalization), &quot;range&quot; (given as (value -min)/(max-min), &quot;zscore&quot; (adjusted by mean and standard deviation) or &quot;zscoremed&quot; (adjusted by median and median of the difference to the median).</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_withlegend">withlegend</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the legend is not plotted.</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_lwd">lwd</code></td>
<td>
<p>Numeric. Line width, see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_col">col</code></td>
<td>
<p>A vector of line colors, see <code><a href="graphics.html#topic+par">par</a></code>. If <code>NULL</code>, a default set of color is used.</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_legend.prop">legend.prop</code></td>
<td>
<p>When <code>withlegend=TRUE</code>, sets the proportion of the graphic area used for plotting the legend. Default value is set according to the place (bottom or right of the graphic area) where the legend is plotted. Values from 0 to 1.</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_rows">rows</code>, <code id="wcCmpCluster_+3A_cols">cols</code></td>
<td>
<p>optional arguments to arrange plots.</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_xlab">xlab</code></td>
<td>
<p>x axis label.</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_ylab">ylab</code></td>
<td>
<p>y axis label.</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_main">main</code></td>
<td>
<p>main title of the plot.</p>
</td></tr>
<tr><td><code id="wcCmpCluster_+3A_...">...</code></td>
<td>
<p>Additionnal parameters passed to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>clustrangefamily</code> with the following elements:
</p>

<dl>
<dt>Method name:</dt><dd><p>the results of <code><a href="#topic+as.clustrange">as.clustrange</a></code> objects under each method name (see argument <code>method</code> for a list of possible values)</p>
</dd>
<dt><code>allstats</code>:</dt><dd><p>A <code>matrix</code> containing the clustering statistics for each cluster solution and method.</p>
</dd>
<dt><code>param</code>:</dt><dd><p>The parameters set when the function was called.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See Also <code><a href="#topic+as.clustrange">as.clustrange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)

#Creating state sequence object
mvad.seq &lt;- seqdef(mvad[, 17:86])

# COmpute distance using Hamming distance
diss &lt;- seqdist(mvad.seq, method="HAM")

#Ward clustering
allClust &lt;- wcCmpCluster(diss, maxcluster=15, method=c("average", "pam", "beta.flexible"), 
                         pam.combine=FALSE)

summary(allClust, max.rank=3)

##Plot PBC, RHC and ASW
plot(allClust, stat=c("PBC", "RHC", "ASW"), norm="zscore", lwd=2)


##Plot PBC, RHC and ASW grouped by cluster method
plot(allClust, group="method", stat=c("PBC", "RHC", "ASW"), norm="zscore", lwd=2)
</code></pre>

<hr>
<h2 id='wcKMedoids'>
K-Medoids or PAM clustering of weighted data.
</h2><span id='topic+wcKMedoids'></span>

<h3>Description</h3>

<p>K-Medoids or PAM clustering of weighted data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	wcKMedoids(diss, k, weights=NULL, npass = 1, initialclust=NULL, 
		method="PAMonce", cluster.only = FALSE, debuglevel=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wcKMedoids_+3A_diss">diss</code></td>
<td>
<p>A dissimilarity matrix or a dist object (see <code><a href="stats.html#topic+dist">dist</a></code>).</p>
</td></tr>
<tr><td><code id="wcKMedoids_+3A_k">k</code></td>
<td>
<p>Integer. The number of cluster.</p>
</td></tr>
<tr><td><code id="wcKMedoids_+3A_weights">weights</code></td>
<td>
<p>Numeric. Optional numerical vector containing case weights.</p>
</td></tr>
<tr><td><code id="wcKMedoids_+3A_npass">npass</code></td>
<td>
<p>Integer. Number of random start solution to test.</p>
</td></tr>
<tr><td><code id="wcKMedoids_+3A_initialclust">initialclust</code></td>
<td>
<p>An integer vector, a factor, an &quot;hclust&quot; or a &quot;twins&quot; object. Can be either the index of the initial medoids (length should equal to <code>k</code>) or a vector specifying an initial clustering solution (length should then be equal to the number of observation.). If <code>initialclust</code> is an &quot;hclust&quot; or a &quot;twins&quot; object, then the initial clustering solution is taken from the hierarchical clustering in <code>k</code> groups.</p>
</td></tr>
<tr><td><code id="wcKMedoids_+3A_method">method</code></td>
<td>
<p>Character. One of &quot;KMedoids&quot;, &quot;PAM&quot; or &quot;PAMonce&quot; (default). See details.</p>
</td></tr>
<tr><td><code id="wcKMedoids_+3A_cluster.only">cluster.only</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the quality of the retained solution is computed.</p>
</td></tr>
<tr><td><code id="wcKMedoids_+3A_debuglevel">debuglevel</code></td>
<td>
<p>Integer. If greater than zero, print some debugging messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>K-Medoids algorithms aim at finding the best partition of the data in a k predefined number of groups. 
Based on a dissimilarity matrix, those algorithms seeks to minimize the (weighted) sum of distance to the medoid of each group. 
The medoid is defined as the observation that minimize the sum of distance to the other observations of this group.
The function <code>wcKMedoids</code> support three differents algorithms specified using the <code>method</code> argument:
</p>

<dl>
<dt>&quot;KMedoids&quot;</dt><dd><p>Start with a random solution and then iteratively adapt the medoids using an algorithm similar to kmeans. Part of the code is inspired (but completely rewritten) by the C clustering library (see de Hoon et al. 2010). If you use this solution, you should set npass&gt;1 to try several solution.</p>
</dd>
<dt>&quot;PAM&quot;</dt><dd><p>See <code><a href="cluster.html#topic+pam">pam</a></code> in the <code>cluster</code> library. This code is based on the one available in the <code><a href="survival.html#topic+cluster">cluster</a></code> library (Maechler et al. 2011). The advantage over the previous method is that it try to minimize a global criteria instead of a local one.</p>
</dd>
<dt>&quot;PAMonce&quot;</dt><dd><p>Same as previous but with two optimizations. First, the optimization presented by Reynolds et al. 2006. Second, only evaluate possible swap if the dissimilarity is greater than zero. This algorithm is used by default.</p>
</dd>
</dl>

<p>wcKMedoids works differently according to the <code>diss</code> argument. It may be faster using a matrix but require more memory (since all distances are stored twice). 
All combination between <code>method</code> and <code>diss</code> argument are possible, except for the &quot;PAM&quot; algorithm were only distance matrix may be used (use the &quot;PAMonce&quot; algorithm instead).
</p>


<h3>Value</h3>

<p>An integer vector with the index of the medoids associated with each observation.</p>


<h3>References</h3>

<p>Maechler, M., P. Rousseeuw, A. Struyf, M. Hubert and K. Hornik (2011).
cluster: Cluster Analysis Basics and Extensions. 
R package version 1.14.1 &mdash; For new features, see the 'Changelog' file (in the package source).
</p>
<p>Hoon, M. d.; Imoto, S. &amp; Miyano, S.  (2010). 
The C Clustering Library. Manual
</p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+pam">pam</a></code> in the cluster library, <code><a href="#topic+wcClusterQuality">wcClusterQuality</a></code>, <code><a href="#topic+wcKMedRange">wcKMedRange</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
## Aggregating state sequence
aggMvad &lt;- wcAggregateCases(mvad[, 17:86], weights=mvad$weight)

## Creating state sequence object
mvad.seq &lt;- seqdef(mvad[aggMvad$aggIndex, 17:86], weights=aggMvad$aggWeights)
## Computing Hamming distance between sequence
diss &lt;- seqdist(mvad.seq, method="HAM")

## K-Medoids
clust5 &lt;- wcKMedoids(diss, k=5, weights=aggMvad$aggWeights)

## clust5$clustering contains index number of each medoids
## Those medoids are
unique(clust5$clustering)

## Print the medoids sequences
print(mvad.seq[unique(clust5$clustering), ], informat="SPS")

## Some info about the clustering
print(clust5)

## Plot sequences according to clustering solution.
seqdplot(mvad.seq, group=clust5$clustering)

</code></pre>

<hr>
<h2 id='wcKMedRange'>
Compute <code><a href="#topic+wcKMedoids">wcKMedoids</a></code> clustering for different number of clusters.
</h2><span id='topic+wcKMedRange'></span>

<h3>Description</h3>

<p>Compute <code><a href="#topic+wcKMedoids">wcKMedoids</a></code> clustering for different number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wcKMedRange(diss, kvals, weights=NULL, R=1,  samplesize=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wcKMedRange_+3A_diss">diss</code></td>
<td>
<p>A dissimilarity matrix or a dist object (see <code><a href="stats.html#topic+dist">dist</a></code>).</p>
</td></tr>
<tr><td><code id="wcKMedRange_+3A_kvals">kvals</code></td>
<td>
<p>A numeric vector containing the number of cluster to compute.</p>
</td></tr>
<tr><td><code id="wcKMedRange_+3A_weights">weights</code></td>
<td>
<p>Numeric. Optional numerical vector containing case weights.</p>
</td></tr>
<tr><td><code id="wcKMedRange_+3A_r">R</code></td>
<td>
<p>Optional number of bootstrap that can be used to build confidence intervals.</p>
</td></tr>
<tr><td><code id="wcKMedRange_+3A_samplesize">samplesize</code></td>
<td>
<p>Size of bootstrap sample. Default to sum of weights.</p>
</td></tr>
<tr><td><code id="wcKMedRange_+3A_...">...</code></td>
<td>
<p>Additionnal parameters passed to <code><a href="#topic+wcKMedoids">wcKMedoids</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute a <code>clustrange</code> object using the <code><a href="#topic+wcKMedoids">wcKMedoids</a></code> method. <code>clustrange</code> objects contains a list of clustering solution with associated statistics and can be used to find the optimal clustering solution.
</p>
<p>See <code><a href="#topic+as.clustrange">as.clustrange</a></code> for more details.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+as.clustrange">as.clustrange</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
## Aggregating state sequence
aggMvad &lt;- wcAggregateCases(mvad[, 17:86], weights=mvad$weight)

## Creating state sequence object
mvad.seq &lt;- seqdef(mvad[aggMvad$aggIndex, 17:86], weights=aggMvad$aggWeights)

## Compute distance using Hamming distance
diss &lt;- seqdist(mvad.seq, method="HAM")

## Pam clustering
pamRange &lt;- wcKMedRange(diss, 2:15)

## Plot all statistics (standardized)
plot(pamRange, stat="all", norm="zscoremed", lwd=3)

## Plotting sequences in 3 groups
seqdplot(mvad.seq, group=pamRange$clustering$cluster3)
</code></pre>

<hr>
<h2 id='wcSilhouetteObs'>
Compute the silhouette of each object using weighted data.
</h2><span id='topic+wcSilhouetteObs'></span>

<h3>Description</h3>

<p>Compute the silhouette of each object using weighted data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wcSilhouetteObs(diss, clustering, weights = NULL, measure="ASW")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wcSilhouetteObs_+3A_diss">diss</code></td>
<td>
<p>A dissimilarity matrix or a dist object (see <code><a href="stats.html#topic+dist">dist</a></code>)</p>
</td></tr>
<tr><td><code id="wcSilhouetteObs_+3A_clustering">clustering</code></td>
<td>
<p>Factor. A vector of clustering membership.</p>
</td></tr>
<tr><td><code id="wcSilhouetteObs_+3A_weights">weights</code></td>
<td>
<p>optional numerical vector containing weights.</p>
</td></tr>
<tr><td><code id="wcSilhouetteObs_+3A_measure">measure</code></td>
<td>
<p>&quot;ASW&quot; or &quot;ASWw&quot;, the measure of the silhouette. See the WeigthedCluster vignettes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code><a href="cluster.html#topic+silhouette">silhouette</a></code> function in the <code><a href="survival.html#topic+cluster">cluster</a></code> package for a detailed explanation of the silhouette.
</p>


<h3>Value</h3>

<p>A numeric vector containing the silhouette of each observation.</p>


<h3>References</h3>

<p>Maechler, M., P. Rousseeuw, A. Struyf, M. Hubert and K. Hornik (2011).
cluster: Cluster Analysis Basics and Extensions. 
R package version 1.14.1 &mdash; For new features, see the 'Changelog' file (in the package source).
</p>


<h3>See Also</h3>

<p>See also <code><a href="cluster.html#topic+silhouette">silhouette</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mvad)
## Aggregating state sequence
aggMvad &lt;- wcAggregateCases(mvad[, 17:86], weights=mvad$weight)

## Creating state sequence object
mvad.seq &lt;- seqdef(mvad[aggMvad$aggIndex, 17:86], weights=aggMvad$aggWeights)
## Computing Hamming distance between sequence
diss &lt;- seqdist(mvad.seq, method="HAM")

## KMedoids using PAMonce method (clustering only)
clust5 &lt;- wcKMedoids(diss, k=5, weights=aggMvad$aggWeights, cluster.only=TRUE)

## Compute the silhouette of each observation
sil &lt;- wcSilhouetteObs(diss, clust5, weights=aggMvad$aggWeights, measure="ASWw")

## If you want to compute the average silhouette width, 
## you should take weights into account
weighted.mean(sil, w=aggMvad$aggWeights)

## Plotting sequences ordred by silhouette width, 
## best classified are draw on the top.
seqIplot(mvad.seq, group=clust5, sortv=sil)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
