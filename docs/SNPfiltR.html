<!DOCTYPE html><html><head><title>Help for package SNPfiltR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SNPfiltR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assess_missing_data_pca'><p>Vizualise how missing data thresholds affect sample clustering</p></a></li>
<li><a href='#assess_missing_data_tsne'><p>Vizualise how missing data thresholds affect sample clustering</p></a></li>
<li><a href='#distance_thin'><p>Filter a vcf file based on distance between SNPs on a given scaffold</p></a></li>
<li><a href='#filter_allele_balance'><p>Filter out heterozygous genotypes failing an allele balance check</p></a></li>
<li><a href='#filter_biallelic'><p>Remove SNPs with more than two alleles</p></a></li>
<li><a href='#hard_filter'><p>Hard filter a vcf file by depth and genotype quality (gq)</p></a></li>
<li><a href='#max_depth'><p>Vizualise and filter based on mean depth across all called SNPs</p></a></li>
<li><a href='#min_mac'><p>Vizualise, filter based on Minor Allele Count (MAC)</p></a></li>
<li><a href='#missing_by_sample'><p>Vizualise missing data per sample, remove samples above a missing data cutoff</p></a></li>
<li><a href='#missing_by_snp'><p>Vizualise missing data per SNP, remove SNPs above a missing data cutoff</p></a></li>
<li><a href='#popmap'><p>Popmap for example scrub-jay vcfR file</p></a></li>
<li><a href='#SNPfiltR'><p>SNPfiltR: A package for interactively visualizing and filtering SNP datasets</p></a></li>
<li><a href='#vcfR.example'><p>Example scrub-jay vcfR file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interactively Filter SNP Datasets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Is designed to interactively and reproducibly visualize and filter SNP
	(single-nucleotide polymorphism) datasets. This R-based implementation of SNP
	and genotype filters facilitates 
	an interactive and iterative SNP filtering pipeline, which can be documented
	reproducibly via Rmarkdown. 'SNPfiltR' contains functions for visualizing 
	various quality and missing data metrics for a SNP dataset, and then filtering
	the dataset based on user specified cutoffs.
	All functions take 'vcfR' objects as input, which can easily be
	generated by reading standard vcf (variant call format) files into R using 
	the R package 'vcfR' (Knaus and Gr√ºnwald) (&lt;<a href="https://doi.org/10.1111%2F1755-0998.12549">doi:10.1111/1755-0998.12549</a>&gt;). 
	Each 'SNPfiltR' function can return a newly filtered vcfR object, which can then be
	written to a local directory in standard vcf format using the 'vcfR' package,
	for downstream population genetic and phylogenetic analyses.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>vcfR, ggplot2, Rtsne, cluster, adegenet, gridExtra, ggridges,
stats, graphics, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-17 16:20:15 UTC; devder</td>
</tr>
<tr>
<td>Author:</td>
<td>Devon DeRaad <a href="https://orcid.org/0000-0003-3105-985X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Devon DeRaad &lt;devonderaad@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-17 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='assess_missing_data_pca'>Vizualise how missing data thresholds affect sample clustering</h2><span id='topic+assess_missing_data_pca'></span>

<h3>Description</h3>

<p>This function can be run in two ways: 1) Without 'thresholds' specified. This will run a PCA
for the input vcf without filtering, and visualize the clustering of samples in two-dimensional
space, coloring each sample according to a priori population assignment given in the popmap.
2) With 'thresholds' specified. This will filter your input vcf file to the specified
missing data thresholds, and run a PCA for each filtering iteration.
For each iteration, a 2D plot will be output showing clustering according to the
specified popmap. This option is ideal for assessing the effects of missing data
on clustering patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assess_missing_data_pca(
  vcfR,
  popmap = NULL,
  thresholds = NULL,
  clustering = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assess_missing_data_pca_+3A_vcfr">vcfR</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="assess_missing_data_pca_+3A_popmap">popmap</code></td>
<td>
<p>set of population assignments that will be used to color code the plots</p>
</td></tr>
<tr><td><code id="assess_missing_data_pca_+3A_thresholds">thresholds</code></td>
<td>
<p>optionally specify a vector of missing data filtering thresholds to explore</p>
</td></tr>
<tr><td><code id="assess_missing_data_pca_+3A_clustering">clustering</code></td>
<td>
<p>use partitioning around medoids (PAM) to do unsupervised
clustering on the output? (default = TRUE, max clusters = # of levels in popmap + 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a series of plots showing the clustering of all samples in two-dimensional space
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assess_missing_data_pca(vcfR = SNPfiltR::vcfR.example,
popmap = SNPfiltR::popmap,
thresholds = c(.6,.8))
</code></pre>

<hr>
<h2 id='assess_missing_data_tsne'>Vizualise how missing data thresholds affect sample clustering</h2><span id='topic+assess_missing_data_tsne'></span>

<h3>Description</h3>

<p>This function can be run in two ways: 1) Without 'thresholds' specified. This will run t-SNE
for the input vcf without filtering, and visualize the clustering of samples in two-dimensional
space, coloring each sample according to a priori population assignment given in the popmap.
2) With 'thresholds' specified. This will filter your input vcf file to the specified
missing data thresholds, and run a t-SNE clustering analysis for each filtering iteration.
For each iteration, a 2D plot will be output showing clustering according to the
specified popmap. This option is ideal for assessing the effects of missing data
on clustering patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assess_missing_data_tsne(
  vcfR,
  popmap = NULL,
  thresholds = NULL,
  perplexity = NULL,
  iterations = NULL,
  initial_dims = NULL,
  clustering = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assess_missing_data_tsne_+3A_vcfr">vcfR</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="assess_missing_data_tsne_+3A_popmap">popmap</code></td>
<td>
<p>set of population assignments that will be used to color code the plots</p>
</td></tr>
<tr><td><code id="assess_missing_data_tsne_+3A_thresholds">thresholds</code></td>
<td>
<p>a vector specifying the missing data filtering thresholds to explore</p>
</td></tr>
<tr><td><code id="assess_missing_data_tsne_+3A_perplexity">perplexity</code></td>
<td>
<p>numerical value specifying the perplexity paramter during t-SNE (default: 5)</p>
</td></tr>
<tr><td><code id="assess_missing_data_tsne_+3A_iterations">iterations</code></td>
<td>
<p>a numerical value specifying the number of iterations for t-SNE
(default: 1000)</p>
</td></tr>
<tr><td><code id="assess_missing_data_tsne_+3A_initial_dims">initial_dims</code></td>
<td>
<p>a numerical value specifying the number of
initial_dimensions for t-SNE (default: 5)</p>
</td></tr>
<tr><td><code id="assess_missing_data_tsne_+3A_clustering">clustering</code></td>
<td>
<p>use partitioning around medoids (PAM) to do unsupervised
clustering on the output? (default = TRUE, max clusters = # of levels in popmap + 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a series of plots showing the clustering of all samples in two-dimensional space
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assess_missing_data_tsne(vcfR = SNPfiltR::vcfR.example,
popmap = SNPfiltR::popmap,
thresholds = .8)
</code></pre>

<hr>
<h2 id='distance_thin'>Filter a vcf file based on distance between SNPs on a given scaffold</h2><span id='topic+distance_thin'></span>

<h3>Description</h3>

<p>This function requires a vcfR object as input, and returns a vcfR object filtered
to retain only SNPs greater than a specified distance apart on each scaffold.
The function starts by automatically retaining the first SNP on a given scaffold,
and then subsequently keeping the next SNP that is greater than the specified distance away,
until it reaches the end of the scaffold/chromosome. This function scales well with
an increasing number of SNPs, but poorly with an increasing number of scaffolds/chromosomes.
For this reason, there is a built in progress bar,
to monitor potentially long-running executions with many scaffolds.
This type of filtering is often employed to reduce linkage among input SNPs,
especially for downstream input to programs like structure, which require unlinked SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_thin(vcfR, min.distance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_thin_+3A_vcfr">vcfR</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="distance_thin_+3A_min.distance">min.distance</code></td>
<td>
<p>a numeric value representing the smallest distance (in base-pairs)
allowed between SNPs after distance thinning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An identical vcfR object, except that SNPs separated by less than the
specified distance have been removed from the file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance_thin(vcfR = SNPfiltR::vcfR.example, min.distance = 1000)
</code></pre>

<hr>
<h2 id='filter_allele_balance'>Filter out heterozygous genotypes failing an allele balance check</h2><span id='topic+filter_allele_balance'></span>

<h3>Description</h3>

<p>This function requires a vcfR object as input, and returns a vcfR object filtered
to convert heterozygous sites with an allele balance falling outside of the
specified ratio to 'NA'. If no ratio is specified, a default .25-.75 limit is imposed.
From the <a href="https://www.ddocent.com/filtering/">dDocent filtering page</a> &quot;Allele balance:
a number between 0 and 1 representing the ratio of reads showing the reference allele to
all reads, considering only reads from individuals called as heterozygous, we expect that the
allele balance in our data (for real loci) should be close to 0.5&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_allele_balance(vcfR, min.ratio = NULL, max.ratio = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_allele_balance_+3A_vcfr">vcfR</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="filter_allele_balance_+3A_min.ratio">min.ratio</code></td>
<td>
<p>minumum allele ratio for a called het</p>
</td></tr>
<tr><td><code id="filter_allele_balance_+3A_max.ratio">max.ratio</code></td>
<td>
<p>maximum allele ratio for a called het</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An identical vcfR object, except that genotypes failing the allele balance
filter have been converted to 'NA'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filter_allele_balance(vcfR = SNPfiltR::vcfR.example)
</code></pre>

<hr>
<h2 id='filter_biallelic'>Remove SNPs with more than two alleles</h2><span id='topic+filter_biallelic'></span>

<h3>Description</h3>

<p>This function simply removes any SNPs from the vcf file which contains more than
two alleles. Many downstream applications require
SNPs to be biallelic, so this filter is generally a good idea during processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_biallelic(vcfR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_biallelic_+3A_vcfr">vcfR</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vcfR object with SNPs containing more than two alleles removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filter_biallelic(vcfR = SNPfiltR::vcfR.example)
</code></pre>

<hr>
<h2 id='hard_filter'>Hard filter a vcf file by depth and genotype quality (gq)</h2><span id='topic+hard_filter'></span>

<h3>Description</h3>

<p>This function requires a vcfR object as input.
The user can then specify the minimum value for depth of coverage required to retain
a called genotype (must be numeric).
Additionally, the user can specify a minimum genotype quality required to retain
a called genotype (again, must be numeric).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hard_filter(vcfR, depth = NULL, gq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hard_filter_+3A_vcfr">vcfR</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="hard_filter_+3A_depth">depth</code></td>
<td>
<p>an integer representing the minimum depth for genotype calls that you
wish to retain
(e.g. 'depth = 5' would remove all genotypes with a sequencing depth of 4 reads or less)</p>
</td></tr>
<tr><td><code id="hard_filter_+3A_gq">gq</code></td>
<td>
<p>an integer representing the minimum genotype quality for
genotype calls that you wish to retain
(e.g. 'gq = 30' would remove all genotypes with a quality score of 29 or lower)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vcfR object input, with the sites failing specified filters converted to 'NA'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hard_filter(vcfR = SNPfiltR::vcfR.example, depth = 5)
hard_filter(vcfR = SNPfiltR::vcfR.example, depth = 5, gq = 30)
</code></pre>

<hr>
<h2 id='max_depth'>Vizualise and filter based on mean depth across all called SNPs</h2><span id='topic+max_depth'></span>

<h3>Description</h3>

<p>This function can be run in two ways: 1) specify vcfR object only. This will
visualize the distribution of mean depth per sample across all SNPs in your vcf file,
and will not alter your vcf file. 2) specify vcfR object, and set 'maxdepth' = 'integer value'.
This option will show you where your specified cutoff falls in the distribution of SNP depth,
and remove all SNPs with a mean depth above the specified threshold from the vcf.
Super high depth loci are likely multiple loci stuck together into a single paralogous locus.
Note: This function filters on a 'per SNP' basis rather than a 'per genotype' basis,
otherwise it would disproportionately remove genotypes from our deepest sequenced samples
(because sequencing depth is so variable between samples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_depth(vcfR, maxdepth = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_depth_+3A_vcfr">vcfR</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="max_depth_+3A_maxdepth">maxdepth</code></td>
<td>
<p>an integer specifying the maximum mean depth for a SNP to be retained</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vcfR object input, with SNPs above the 'maxdepth' cutoff removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>max_depth(vcfR = SNPfiltR::vcfR.example)
max_depth(vcfR = SNPfiltR::vcfR.example, maxdepth = 100)
</code></pre>

<hr>
<h2 id='min_mac'>Vizualise, filter based on Minor Allele Count (MAC)</h2><span id='topic+min_mac'></span>

<h3>Description</h3>

<p>This function can be run in two ways: 1) Without 'min.mac' specified. This will return
a folded site frequency spectrum (SFS), without performing any filtering on the vcf file. Or
2) With 'min.mac' specified. This will also print the folded SFS and
show you where your specified min. MAC count falls. It will then return your vcfR object
with SNPs falling below your min. MAC threshold removed.
Note: previous filtering steps (especially removing samples) may have resulted
in invariant SNPs (MAC =0). For this reason it's a good idea to run min_mac(vcfR, min.mac=1)
before using a SNP dataset in downstream analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_mac(vcfR, min.mac = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_mac_+3A_vcfr">vcfR</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="min_mac_+3A_min.mac">min.mac</code></td>
<td>
<p>an integer specifying the minimum minor allele count for a
SNP to be retained (e.g. 'min.mac=3' would remove all SNPs with a MAC of 2 or less)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if 'min.mac' is not specified, the allele frequency spectrum is returned.
If 'min.mac' is specified, SNPs falling below the MAC cutoff will be removed,
and the filtered vcfR object will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>min_mac(vcfR=SNPfiltR::vcfR.example)
</code></pre>

<hr>
<h2 id='missing_by_sample'>Vizualise missing data per sample, remove samples above a missing data cutoff</h2><span id='topic+missing_by_sample'></span>

<h3>Description</h3>

<p>This function can be run in two ways: 1) Without 'cutoff' specified. This will vizualise the
amount of missing data in each sample across a variety of potential missing data cutoffs.
Additionally, it will show you a dotplot ordering the amount of overall missing data
in each sample. Based on these visualizations, you can make an informed decision on what
you think might be an optimal cutoff to remove samples that are missing too much data to
be retained for downstream analyses. 2) with 'cutoff' specified.
This option will show you the dotplot with the cutoff you set, and then
remove samples above the missing data cutoff you set, and return the filtered vcf to you.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_by_sample(vcfR, popmap = NULL, cutoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_by_sample_+3A_vcfr">vcfR</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="missing_by_sample_+3A_popmap">popmap</code></td>
<td>
<p>if specifies, it must be a two column dataframe with columns names 'id' and 'pop'.
IDs must match the IDs in the vcfR object</p>
</td></tr>
<tr><td><code id="missing_by_sample_+3A_cutoff">cutoff</code></td>
<td>
<p>a numeric value between 0-1 specifying the maximum proportion of missing data
allowed in a sample to be retained for downstream analyses</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: This decision is highly project specific, but these visualizations should help
you get a feel for how very low data samples cannot be rescued simply by a missing
data SNP filter. If you want to remove specific samples from your vcf that cannot
be specified with a simple cutoff refer to this great
<a href="https://knausb.github.io/vcfR_documentation/sequence_coverage.html">tutorial</a>
which is the basis for the code underlying this function.
</p>


<h3>Value</h3>

<p>if 'cutoff' is not specified, will return a dataframe containing the average
depth and proportion missing data in each sample. If 'cutoff' is specified, the samples
falling above the missing data cutoff
will be removed, and the filtered vcfR object will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>missing_by_sample(vcfR = SNPfiltR::vcfR.example)
missing_by_sample(vcfR = SNPfiltR::vcfR.example, cutoff = .7)
</code></pre>

<hr>
<h2 id='missing_by_snp'>Vizualise missing data per SNP, remove SNPs above a missing data cutoff</h2><span id='topic+missing_by_snp'></span>

<h3>Description</h3>

<p>This function can be run in two ways: 1) Without 'cutoff' specified. This will vizualise the
amount of missing data in each sample across a variety of potential missing data cutoffs.
Additionally, it will show you dotplots visualizing the number of total SNPs retained across
a variety of filtering cutoffs, and the total proportion of missing data.
Based on these visualizations, you can make an informed decision on what you think might be an
optimal cutoff to minimize the overall missingness of your dataset while still retaining an
appropriate amount of SNPs for the downstream inferences you hope to make 2) with 'cutoff'
specified. This option will show you the dotplots with the cutoff you set,
and then remove SNPs above the missing data cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_by_snp(vcfR, cutoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_by_snp_+3A_vcfr">vcfR</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="missing_by_snp_+3A_cutoff">cutoff</code></td>
<td>
<p>a numeric value between 0-1 specifying the maximum proportion of missing data
allowed in a SNP to be retained for downstream analyses</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if 'cutoff' is not specified, will return a dataframe containing the proportion
missing data and the total SNPs retained across each filtering level. If 'cutoff' is
specified, SNPs falling above the missing data cutoff will be removed,
and the filtered vcfR object will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>missing_by_snp(vcfR = SNPfiltR::vcfR.example)
missing_by_snp(vcfR = SNPfiltR::vcfR.example, cutoff = .6)
</code></pre>

<hr>
<h2 id='popmap'>Popmap for example scrub-jay vcfR file</h2><span id='topic+popmap'></span>

<h3>Description</h3>

<p>A dataset containing the sample name and population assignment for the 20
scrub-jay samples in SNPfilR::vcfR.example . The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(popmap)
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and 2 variables
</p>


<h3>Details</h3>


<ul>
<li><p> id. unique sample identifier
</p>
</li>
<li><p> pop. population assignment for each individual
</p>
</li></ul>


<hr>
<h2 id='SNPfiltR'>SNPfiltR: A package for interactively visualizing and filtering SNP datasets</h2><span id='topic+SNPfiltR'></span>

<h3>Description</h3>

<p>The SNPfiltR package allows users to interactively visualize the effects of
relevant filters on their datasets in order to optimize filtering parameters
rather than simply following historical precedent. Each function takes a
variant call format (vcf) file, stored in local memory as a vcfR object, as input.
Most functions can be run without specified cutoffs, in order to visualize the
distribution of the parameter of interest in your given dataset. Then the same
function can be run with a specified cutoff, and a filtered vcfR object
will be returned. For detailed documentation and vignettes showing fully implemented
SNP filtering pipelines, please go to: devonderaad.github.io/SNPfiltR
</p>

<hr>
<h2 id='vcfR.example'>Example scrub-jay vcfR file</h2><span id='topic+vcfR.example'></span>

<h3>Description</h3>

<p>A vcfR object containing 500 SNPs for 20 individuals. Species assignments for
each individual can be accessed via SNPfiltR::popmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vcfR.example)
</code></pre>


<h3>Format</h3>

<p>A vcfR object containing 500 SNPs for 20 individuals
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
