<!DOCTYPE html><html><head><title>Help for package fossil</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fossil}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fossil-package'>
<p>fossil: Palaeoecological and Palaeogeographical Analysis Tools</p></a></li>
<li><a href='#ACE'><p>Abundance- and Incidence-based Coverage Estimators</p></a></li>
<li><a href='#aic.nest'><p>Nestedness of samples using AIC</p></a></li>
<li><a href='#bootstrap'><p>Bootstrap Species Richness Estimator</p></a></li>
<li><a href='#chao.sd'><p>Chao's estimation of standard error</p></a></li>
<li><a href='#chao.sorenson'><p>Chao's Jaccard and Sorenson Estimators of Shared Species</p></a></li>
<li><a href='#chao1'><p>Chao's Species Estimators</p></a></li>
<li><a href='#coi'><p>Cohesiveness Index for Relational Clustering</p></a></li>
<li><a href='#create.lats'><p>Creating a table of Latitudes and Longitudes</p></a></li>
<li><a href='#create.matrix'><p>Creating species locality matrices</p></a></li>
<li><a href='#deg.dist'><p>Haversine Distance Formula</p></a></li>
<li><a href='#dino.mst'><p>Calculate a Minimum Spanning Tree or Network</p></a></li>
<li><a href='#earth.bear'><p>Bearings Between Geographic Locations</p></a></li>
<li><a href='#earth.dist'><p>Calculating Geographic Distances</p></a></li>
<li><a href='#earth.poly'><p>Calculating a Minimum Convex Polygon</p></a></li>
<li><a href='#earth.tri'><p>Calculating the Surface Area Enclosed by Three Geographic Points</p></a></li>
<li><a href='#ecol.dist'><p>Creating a Distance Matrix</p></a></li>
<li><a href='#euler.rot'><p>Calculate the Euler Rotation of a Point</p></a></li>
<li><a href='#fdata'><p>A Sample Species Abundance Dataset</p></a></li>
<li><a href='#int.chao'><p>Internal function for chao estimators</p></a></li>
<li><a href='#jack1'><p>First- and second-order jacknife estimators</p></a></li>
<li><a href='#lats2Shape'><p>Converting a Table of Latitudes and Longitudes to a Shapefile</p></a></li>
<li><a href='#loc.map'><p>Mapping Points on a Global Map</p></a></li>
<li><a href='#localoptima'><p>Function to Find Local Optimization for clustering</p></a></li>
<li><a href='#msn.map'><p>Mapping a Minimum Spanning Tree</p></a></li>
<li><a href='#msn2Shape'><p>Convert a Minimum spanning Network or Tree to Shapefile</p></a></li>
<li><a href='#mstlines'><p>Display a Minimum Spanning Tree or Network</p></a></li>
<li><a href='#new.lat.long'><p>Find a New Latitude and Longitude</p></a></li>
<li><a href='#nmds.mst'><p>Creating NMDS plots with overlain Minimum Spanning Trees</p></a></li>
<li><a href='#rand.index'><p>Rand Index and Adjusted Rand Index</p></a></li>
<li><a href='#rclust'><p>Relational Clustering</p></a></li>
<li><a href='#rclust.dist'><p>Relational Clustering</p></a></li>
<li><a href='#rclust.null'><p>Relational Clustering</p></a></li>
<li><a href='#rclust.weights'><p>Relational Clustering</p></a></li>
<li><a href='#relational.clustering'><p>Relational Clustering</p></a></li>
<li><a href='#sac'><p>Calculate Species Area Curves</p></a></li>
<li><a href='#sim.occ'><p>Simulated Species Occurrence data</p></a></li>
<li><a href='#similarity'><p>Similarity/Dissimilarity Indices</p></a></li>
<li><a href='#spp.est'><p>Estimating Species Diversity</p></a></li>
<li><a href='#tri.ineq'><p>Testing for the Triangle Inequality</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Palaeoecological and Palaeogeographical Analysis Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew J. Vavrek &lt;matthew@matthewvavrek.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew J. Vavrek &lt;matthew@matthewvavrek.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>sp, maps, shapefiles</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of analytical tools useful in analysing ecological and geographical data sets, both ancient and modern. The package includes functions for estimating species richness (Chao 1 and 2, ACE, ICE, Jacknife), shared species/beta diversity, species area curves and geographic distances and areas.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://matthewvavrek.com/programs-and-code/fossil/">http://matthewvavrek.com/programs-and-code/fossil/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-22 23:31:07 UTC; matthew</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-23 11:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='fossil-package'>
fossil: Palaeoecological and Palaeogeographical Analysis Tools
</h2><span id='topic+fossil-package'></span><span id='topic+fossil'></span>

<h3>Description</h3>

<p>A set of analytical tools useful in analysing ecological and geographical data sets, both ancient and modern. The package includes functions for estimating species richness (Chao 1 and 2, ACE, ICE, Jacknife), shared species/beta diversity, species area curves and geographic distances.
</p>


<h3>Details</h3>

<p>The fossil package is designed to be used by palaeoecologists and palaeobiogeographers, providing to them a set of useful tools including species similarity indices, species estimators, minimum spanning tree/forest functions, and an assortment of other useful tools.</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek &lt;matthew@matthewvavrek.com&gt;
</p>

<hr>
<h2 id='ACE'>Abundance- and Incidence-based Coverage Estimators</h2><span id='topic+ACE'></span><span id='topic+ICE'></span>

<h3>Description</h3>

<p>Computes the extrapolated species richness of a population using the Abundance-
and Incidence-based Coerage Estimators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACE(x, taxa.row = TRUE)
ICE(x, taxa.row = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ACE_+3A_x">x</code></td>
<td>
<p>a vector, matrix or data frame of positive integers or zero of any size</p>
</td></tr>
<tr><td><code id="ACE_+3A_taxa.row">taxa.row</code></td>
<td>
<p>whether each row of the matrix is a different taxon; if so, value is T</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions compute the ACE and ICE richness estimators, respectively.
Both functions will accept a vector, matrix or data frame of any size made up of positive
integers and zeros. Matrices are by default treated such that each row is a
different taxon and each column is a sample or locality, however if they are
arranged with the taxa as columns, change the argument <code>taxa.row</code> to FALSE
Take note that <code>ACE</code> is intended only for use with abundance data, and not
presence absence data. While <code>ICE</code> will accept abundance matrices, it
will internally convert the matrix to presence absence data. Note that if 
<code>ACE</code> returns NaN or Inf as a value, that Chao1 will be used in it's place
as per the recommendation made by Colwell in EstimateS.
</p>


<h3>Value</h3>

<p>A value representing a minimum number of species present in the assemblage if 
the entire population were to be censused.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek, with recommendations from the EstimateS reference manual by R.K. Colwell</p>


<h3>References</h3>

<p>Chao, A., M.-C. Ma, &amp; M. C. K. Yang. 1993. Stopping rules and estimation for 
recapture debugging with unequal failure rates. Biometrika 80, 193-201.
</p>
<p>Chao, A., W.-H. Hwang, Y.-C. Chen, and C.-Y. Kuo. 2000. Estimating the number of
shared species in two communities. Statistica Sinica 10:227-246.
</p>
<p>Chazdon, R. L., R. K. Colwell, J. S. Denslow, &amp; M. R. Guariguata. 1998.
Statistical methods for estimating species richness of woody regeneration in
primary and secondary rain forests of NE Costa Rica. Pp. 285-309 in F.
Dallmeier and J. A. Comiskey, eds. Forest biodiversity research, monitoring
and modeling: Conceptual background and Old World case studies. Parthenon
Publishing, Paris.</p>


<h3>See Also</h3>

<p>For related species estimators, see <code><a href="#topic+chao1">chao1</a></code>, <code><a href="#topic+bootstrap">bootstrap</a></code> and <code><a href="#topic+jack1">jack1</a></code>, and <code><a href="#topic+spp.est">spp.est</a></code> to calculate multiple indices at once.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## sample vector
a&lt;-c(0,5,1,1,2,0,0,1,0,0,8,45)
ACE(a)


## matrix format
a&lt;-matrix(c(0,5,1,1,2,0,0,1,0,0,8,45),4,3)
ACE(a)
ICE(a)

## presence absence matrix
a&lt;-matrix(c(0,1,1,1,1,0,0,1,0,0,1,1),4,3)
ACE(a)
ICE(a)

</code></pre>

<hr>
<h2 id='aic.nest'>Nestedness of samples using AIC</h2><span id='topic+aic.nest'></span>

<h3>Description</h3>

<p>Test if two empirical samples are drwan from the same or different communities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    aic.nest(comm1, comm2, base=exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aic.nest_+3A_comm1">comm1</code>, <code id="aic.nest_+3A_comm2">comm2</code></td>
<td>
<p>lists of abundance data from two empirical samples</p>
</td></tr>
<tr><td><code id="aic.nest_+3A_base">base</code></td>
<td>
<p>base of the log used in the calculation of Shannon's diversity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests if two empirical samples are drawn from the same community, based on the AIC scores.
</p>


<h3>Value</h3>

<p>returns two AIC scores, the first assuming the two empirical samples are drawn from the same distribution, the other assuming the two empirical samples are from different distributions
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+simpson">simpson</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#for example, two different communities
a&lt;-c(12,4,12,1,4,0,6,5,0,0,0)
b&lt;-c(0,11,4,3,6,7,7,2,23,5,8)

#if the aic score is lower, it is the better model
aic.nest(a,b)

#from the same community
a&lt;-c(5,6,5,6,5,6,5,6,5,2,1,1)
b&lt;-c(2,3,2,3,2,3,2,3,2,1,0,0)
aic.nest(a,b)
</code></pre>

<hr>
<h2 id='bootstrap'>Bootstrap Species Richness Estimator</h2><span id='topic+bootstrap'></span>

<h3>Description</h3>

<p>Computes the bootstrap species richness estimator for abundance or presence-absence data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(x, taxa.row = TRUE, abund = TRUE, samples = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_x">x</code></td>
<td>
<p>a vector, matrix or data frame of positive integers or zero of any size</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_taxa.row">taxa.row</code></td>
<td>
<p>whether each row of the matrix is a different taxon</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_abund">abund</code></td>
<td>
<p>whether the input is abundance (or presence/absence) based</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_samples">samples</code></td>
<td>
<p>if input is a vector file, the number of samples must be
included</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bootstrap estimator 
</p>


<h3>Value</h3>

<p>Returns a single value for the Bootstrap Species Estimator
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>Smith, E.P. &amp; van Belle, G. 1984. Nonparametric estimation of species richness. Biometrics 40, 119-129.</p>


<h3>See Also</h3>

<p><code><a href="#topic+jack1">jack1</a></code>, <code><a href="#topic+ACE">ACE</a></code>, <code><a href="#topic+chao1">chao1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## sample vector
a&lt;-c(0,5,1,1,2,0,0,1,0,0,8,45)
bootstrap(a,samples=45)

## matrix format
a&lt;-matrix(c(0,5,1,1,2,0,0,1,0,0,8,45),4,3)
bootstrap(a)
bootstrap(a,,FALSE)


## presence absence matrix
a&lt;-matrix(c(0,1,1,1,1,0,0,1,0,0,1,1),4,3)
bootstrap(a,,FALSE)
</code></pre>

<hr>
<h2 id='chao.sd'>Chao's estimation of standard error</h2><span id='topic+chao.sd'></span>

<h3>Description</h3>

<p>Computes the standard error for <code>chao1</code> or <code>chao2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chao.sd(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chao.sd_+3A_x">x</code></td>
<td>
<p>a vector of abundances or frequencies of occurrences</p>
</td></tr>
</table>


<h3>Details</h3>

<p>primarily designed to be used internally by <code>spp.est</code> to calculate the 
errors for the chao estimators
</p>


<h3>Value</h3>

<p>returns a value for standard deviation for <code>chao1</code> or <code>chao2</code>
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>Colwell, R.K. 2010. EstimateS: Statistical estimation of species richness and shared species from samples. Version 8.2. User's Guide and application published at: http://purl.oclc.org/estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chao1">chao1</a></code>, <code><a href="#topic+spp.est">spp.est</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## sample vector
a&lt;-c(0,5,1,1,2,0,0,1,0,0,8,45)
chao.sd(a)

</code></pre>

<hr>
<h2 id='chao.sorenson'>Chao's Jaccard and Sorenson Estimators of Shared Species</h2><span id='topic+chao.sorenson'></span><span id='topic+chao.jaccard'></span>

<h3>Description</h3>

<p>Chao's Jaccard and Sorenson shared species estimators for use with incomplete datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chao.sorenson(x, y)
chao.jaccard(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chao.sorenson_+3A_x">x</code></td>
<td>
<p>species from group A</p>
</td></tr>
<tr><td><code id="chao.sorenson_+3A_y">y</code></td>
<td>
<p>species from group B</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You must provide two separate vectors, with species arranged in the same 
order, from area A and B. If species are present in one site but not the 
other, these must be recorded for both sites; the site where they are not 
found should be coded as a zero. Species not present at either site are 
ignored.
</p>


<h3>Value</h3>

<p>Returns the Chao-Jaccard or Chao-Sorenson similarity index for the two sites 
in question.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>Chao, A., R. L. Chazdon, et al. 2005. A new statistical approach 
for assessing similarity of species composition with incidence and abundance 
data. Ecology Letters 8: 148-159.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bray.curtis">bray.curtis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Species counts from two different locations
a &lt;- c(1,0,4,3,5,0,0,7)
b &lt;- c(2,1,3,0,0,1,0,6)
chao.sorenson(a,b)
chao.jaccard(a,b)

</code></pre>

<hr>
<h2 id='chao1'>Chao's Species Estimators</h2><span id='topic+chao1'></span><span id='topic+chao2'></span>

<h3>Description</h3>

<p>Computes the Chao species estimator for abundance or presence-absence data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chao1(x, taxa.row = TRUE)
chao2(x, taxa.row = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chao1_+3A_x">x</code></td>
<td>
<p>a vector, matrix or data frame with species by samples</p>
</td></tr>
<tr><td><code id="chao1_+3A_taxa.row">taxa.row</code></td>
<td>
<p>a logical argument if the species are the rows or columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chao1</code> will return an estimate of species richness based on a vector or matrix of abundance data, while <code>chao2</code> will return an estimate of species richness based on incidence data. Note that <code>chao1</code> estimator is for abundance data only. The <code>chao2</code> estimator can be given abundance data and it will automagically convert it to incidence data, but due to the nature of the estimator, the data must contain more than one sample (ie the data must be arranged in a minimum 2 by 2 matrix).
</p>


<h3>Value</h3>

<p>returns a value for the Chao Species Estimator for a the given data.
</p>


<h3>Note</h3>

<p>While the function will still return a value, if all the species abundances are equal to 1 in the input to <code>chao1</code>, a warning will be raised, and the value returned will be equal to the number of species observed.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>Chao, A. 1984. Non-parametric estimation of the number of classes in a 
population. Scandinavian Journal of Statistics 11: 265-270.
</p>
<p>Chao, A. 1987. Estimating the Population Size for Capture-Recapture Data 
with Unequal Catchability. Biometrics 43: 783-791.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jack1">jack1</a></code>, <code><a href="#topic+bootstrap">bootstrap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## sample vector
a&lt;-c(0,5,1,1,2,0,0,1,0,0,8,45)
chao1(a)

## matrix format
a&lt;-matrix(c(0,5,1,1,2,0,0,1,0,0,8,45),4,3)
chao1(a)
chao2(a)

## presence absence matrix
a&lt;-matrix(c(0,1,1,1,1,0,0,1,0,0,1,1),4,3)
chao1(a)
chao2(a)
</code></pre>

<hr>
<h2 id='coi'>Cohesiveness Index for Relational Clustering</h2><span id='topic+coi'></span>

<h3>Description</h3>

<p>Computes Cohesiveness Index for a Cluster Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coi(mst, groups)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coi_+3A_mst">mst</code></td>
<td>
<p>A minimum spanning tree matrix (binary)</p>
</td></tr>
<tr><td><code id="coi_+3A_groups">groups</code></td>
<td>
<p>A vector with the group/cluster assignments for each sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a something
</p>


<h3>Note</h3>

<p>While the function will still return a value, if all the species abundances are equal to 1 in the input to <code>chao1</code>, a warning will be raised, and the value returned will be equal to the number of species observed.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+rclust">rclust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## sample vector
a&lt;-c(0,5,1,1,2,0,0,1,0,0,8,45)
chao1(a)

## matrix format
a&lt;-matrix(c(0,5,1,1,2,0,0,1,0,0,8,45),4,3)
chao1(a)
chao2(a)

## presence absence matrix
a&lt;-matrix(c(0,1,1,1,1,0,0,1,0,0,1,1),4,3)
chao1(a)
chao2(a)
</code></pre>

<hr>
<h2 id='create.lats'>Creating a table of Latitudes and Longitudes</h2><span id='topic+create.lats'></span>

<h3>Description</h3>

<p>Create a matrix of locations with a column of latitudes and longitudes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  create.lats(x, loc="locality", long="longitude", lat="latitude")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.lats_+3A_x">x</code></td>
<td>
<p>a table arranged in columnar format, with one column
indicating the locations, another the latitude and another the longitude</p>
</td></tr>
<tr><td><code id="create.lats_+3A_loc">loc</code></td>
<td>
<p>the name or number of the column giving the names  of the
locations to be used</p>
</td></tr>
<tr><td><code id="create.lats_+3A_long">long</code></td>
<td>
<p>the name or number of the column giving the longitude of the
locations</p>
</td></tr>
<tr><td><code id="create.lats_+3A_lat">lat</code></td>
<td>
<p>the name or number of the column giving the latitude of the
locations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will create a location table with longitude (X) and latitude (Y) or their equivalents
for every location. This function ceates a matrix in the format needed for most of the geographic functions found in the fossil package.
</p>


<h3>Value</h3>

<p>A matrix with a column of longitude and latitude, respectively with rownames
correspnding to each location
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.matrix">create.matrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#to reproduce the fdata.lats dataset
data(fdata.list)
create.lats(fdata.list, loc="locality", long="longitude", lat="latitude")
</code></pre>

<hr>
<h2 id='create.matrix'>Creating species locality matrices</h2><span id='topic+create.matrix'></span>

<h3>Description</h3>

<p>Create a matrix with taxa as rows and occurrences or samples as columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  create.matrix(
  x,
  tax.name="genus",
  locality="locality",
  time.col=NULL,
  time=NULL, 
  abund=FALSE,
  abund.col="abundance"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.matrix_+3A_x">x</code></td>
<td>
<p>a table arranged in columnar format, with at least one column
indicating name of taxa and another giving location or sample</p>
</td></tr>
<tr><td><code id="create.matrix_+3A_tax.name">tax.name</code></td>
<td>
<p>the name or number of the column giving the taxonomic names to 
be used (the rows of the matrix to be created)</p>
</td></tr>
<tr><td><code id="create.matrix_+3A_locality">locality</code></td>
<td>
<p>the name or number of the column giving the locations of the 
samples (the columns of the matrix to be created)</p>
</td></tr>
<tr><td><code id="create.matrix_+3A_time.col">time.col</code></td>
<td>
<p>what is the column name or number containing the time periods; 
if left null, filtering for time willbe ignored</p>
</td></tr>
<tr><td><code id="create.matrix_+3A_time">time</code></td>
<td>
<p>what time periods to keep for the matrix; if left null, filtering 
for time willbe ignored</p>
</td></tr>
<tr><td><code id="create.matrix_+3A_abund">abund</code></td>
<td>
<p>whether to record abundances of taxa; if left FALSE, a binary
(presence/absence) matrix is created</p>
</td></tr>
<tr><td><code id="create.matrix_+3A_abund.col">abund.col</code></td>
<td>
<p>column name or number containing abundance values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function to convert large lists of data into matrices of 
species (rows) and locations (columns). The parameters can be adjusted to 
create either a binary (presence/absence) or abundance matrix. The setup of 
the table is largely flexible; simply input the column names or numbers 
containing the pertinent information. To filter data according to time, both 
the time column and the time period must be specified. For abundance, the 
default title for the abundance column is simply &quot;abundance&quot;; the function 
will not work if you have chosen to include abundances (<code>abund = TRUE</code> 
but the name of the abundance column is incorrect.</p>


<h3>Value</h3>

<p>A matrix of taxa (rows) by localities (columns).
</p>


<h3>Note</h3>

<p>At present, the function will ignore rows where the taxon name is <code>NA</code>, <code>NULL</code>, <code>''</code> (empty character value) or <code>' '</code> (single space), as these labels typically represent an unknown taxa, which would be inappropriate to include in most analyses.</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.lats">create.lats</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#converting the fdata.list dataset into a matrix of species (rows) 
#by samples (columns) with abundance data
data(fdata.list)
create.matrix(fdata.list, tax.name = "species", abund=TRUE)

#same data set, but now for an occurrence matrix
create.matrix(fdata.list, tax.name = "species", locality = "locality")

</code></pre>

<hr>
<h2 id='deg.dist'>Haversine Distance Formula</h2><span id='topic+deg.dist'></span>

<h3>Description</h3>

<p>Haversine formula to calculate distances between points on the earth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg.dist(
	long1, 
	lat1, 
	long2, 
	lat2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deg.dist_+3A_long1">long1</code></td>
<td>
<p>longitude of location 1</p>
</td></tr>
<tr><td><code id="deg.dist_+3A_lat1">lat1</code></td>
<td>
<p>latitude of location 1</p>
</td></tr>
<tr><td><code id="deg.dist_+3A_long2">long2</code></td>
<td>
<p>longitude of location 2</p>
</td></tr>
<tr><td><code id="deg.dist_+3A_lat2">lat2</code></td>
<td>
<p>latitude of location 2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will calculate the shortest distance (portion of a Great Circle) in kilometers between two points on the Earth given their latitude and longitude.
</p>


<h3>Value</h3>

<p>Arc distance between two points on the Earth's surface in kilometers.
</p>


<h3>Note</h3>

<p>The distance calculated may be up to 0.2% inaccurate, as this function treats the Earth as a sphere with a circumference of 40041.47 km (mean circumference), rather than an ellipsoid like it actually is.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>The formulas for the Haversine distance function were taken from the Dr. Math website at <a href="http://mathforum.org/library/drmath/view/55417.html">http://mathforum.org/library/drmath/view/55417.html</a></p>


<h3>See Also</h3>

<p>To calculate pairwise distances between a list of points see <code><a href="#topic+earth.dist">earth.dist</a></code>, or to calculate an area enclosed by three points on the Earth's surface, see <code><a href="#topic+earth.tri">earth.tri</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##distance between 23 degrees N 54 degrees E and 32 degrees S 67 degrees E
deg.dist(23,54,-32,67)
</code></pre>

<hr>
<h2 id='dino.mst'>Calculate a Minimum Spanning Tree or Network</h2><span id='topic+dino.mst'></span><span id='topic+dino.msn'></span>

<h3>Description</h3>

<p>Methods for calculating a minimum spanning tree or network between a number of 
points given a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dino.mst(x, random.start = TRUE, random.search = TRUE)
dino.msn(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dino.mst_+3A_x">x</code></td>
<td>
<p>a distance matrix for any number of points</p>
</td></tr>
<tr><td><code id="dino.mst_+3A_random.start">random.start</code></td>
<td>
<p>If the minimum spanning tree is to start at a random point and not the first given site (default is TRUE)</p>
</td></tr>
<tr><td><code id="dino.mst_+3A_random.search">random.search</code></td>
<td>
<p>If there is more than one shortest possible branch, should one be chosen randomly</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ensure that a distance matrix is used, and not a similarity matrix, otherwise the result given will be highly incorrect.
</p>


<h3>Value</h3>

<p>Returns a binary matrix where connections between points are denoted by a 1.
</p>


<h3>Author(s)</h3>

<p>Yvonnick Noel, Julien Claude and Emmanuel Paradis with modifications from Matthew Vavrek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dino.dist">dino.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#minimum spanning tree for the fdata set
data(fdata.mat)
fdata.dist&lt;-dino.dist(fdata.mat)
dino.mst&lt;-dino.mst(fdata.dist)
</code></pre>

<hr>
<h2 id='earth.bear'>Bearings Between Geographic Locations</h2><span id='topic+earth.bear'></span>

<h3>Description</h3>

<p>Calculate the bearing in degrees clockwise from True North between any two 
points on the globe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>earth.bear(long1, lat1, long2, lat2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="earth.bear_+3A_long1">long1</code></td>
<td>
<p>Longitude of site 1</p>
</td></tr>
<tr><td><code id="earth.bear_+3A_lat1">lat1</code></td>
<td>
<p>Latitude of site 1</p>
</td></tr>
<tr><td><code id="earth.bear_+3A_long2">long2</code></td>
<td>
<p>Longitude of site 2</p>
</td></tr>
<tr><td><code id="earth.bear_+3A_lat2">lat2</code></td>
<td>
<p>Latitude of site 2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the bearing in degrees clockwise from True North between any two 
points on the globe. Primarily designed to be used with other included 
geographic tools.
</p>


<h3>Value</h3>

<p>Returns a value in degrees from True North between two geographic points.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>Haversine formula from Math Forums: Ask Dr. Math at http://mathforum.org/dr.math/</p>


<h3>See Also</h3>

<p><code><a href="#topic+earth.poly">earth.poly</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>earth.bear(-100, 30, 20, -40)
</code></pre>

<hr>
<h2 id='earth.dist'>Calculating Geographic Distances</h2><span id='topic+earth.dist'></span>

<h3>Description</h3>

<p>Create a distance matrix (lower triangle) between a list of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>earth.dist(lats, dist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="earth.dist_+3A_lats">lats</code></td>
<td>
<p>a table with a longitude and latitude column respectively as the 
first two columns</p>
</td></tr>
<tr><td><code id="earth.dist_+3A_dist">dist</code></td>
<td>
<p>A logical argument whether to create a distance matrix (lower 
triangle) or full matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will calculate the pairwise distances between all points 
given and return either a distance or full matrix as specified. All coordinates 
must be in decimal degrees.
</p>


<h3>Value</h3>

<p>Returns a matrix of distances in kilometers between a list of longitudes and 
latitudes.
</p>


<h3>Note</h3>

<p>Large datasets may take some time to process, as the number of distances 
to calculate is factorial in nature.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek, with suggestions from Anton Korobeynikovs</p>


<h3>See Also</h3>

<p><code><a href="#topic+deg.dist">deg.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fdata.lats)
earth.dist(fdata.lats)
</code></pre>

<hr>
<h2 id='earth.poly'>Calculating a Minimum Convex Polygon</h2><span id='topic+earth.poly'></span>

<h3>Description</h3>

<p>Calculate a minimum convex polygon for a collection of points without knowing 
what points form the vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>earth.poly(lats)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="earth.poly_+3A_lats">lats</code></td>
<td>
<p>a table with a longitude and latitude column respectively as the first two columns, or a SpatialPoints object with longitude/latitude</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will calculate the area of a minimum convex polygon/convex hull for a spherical surface (ie points on a globe).
</p>


<h3>Value</h3>

<p>The function will return a list consisting of the area in $km^2$ (<code>\$area</code>) and a vector with the row numbers of the vertices (<code>\$vertices</code>)
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+earth.tri">earth.tri</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#1/8th the surface area of the earth
a &lt;- matrix(c(0, 0, 0, 90, 90, 0, 25, 25), 4, 2, byrow = TRUE)
earth.poly(a)
</code></pre>

<hr>
<h2 id='earth.tri'>Calculating the Surface Area Enclosed by Three Geographic Points</h2><span id='topic+earth.tri'></span>

<h3>Description</h3>

<p>Calculate the true area on a sphere enclosed by three points on the earth's surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>earth.tri(long1, lat1, long2, lat2, long3, lat3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="earth.tri_+3A_long1">long1</code></td>
<td>
<p>Longitude of site 1</p>
</td></tr>
<tr><td><code id="earth.tri_+3A_lat1">lat1</code></td>
<td>
<p>Latitude of site 1</p>
</td></tr>
<tr><td><code id="earth.tri_+3A_long2">long2</code></td>
<td>
<p>Longitude of site 2</p>
</td></tr>
<tr><td><code id="earth.tri_+3A_lat2">lat2</code></td>
<td>
<p>Latitude of site 2</p>
</td></tr>
<tr><td><code id="earth.tri_+3A_long3">long3</code></td>
<td>
<p>Longitude of site 3</p>
</td></tr>
<tr><td><code id="earth.tri_+3A_lat3">lat3</code></td>
<td>
<p>Latitude of site 3</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function to find the area enclosed by three points on the surface of the 
earth, given their latitudes and longitudes. This function is primarily 
designed to be a component of <code><a href="#topic+earth.poly">earth.poly</a></code>, which is likely a more 
useful function for most applications.
</p>


<h3>Value</h3>

<p>Returns a value in kilometers squared of the area enclosed by the three points.
</p>


<h3>Note</h3>

<p>The distance calculated may be up to 0.2% inaccurate, as this function treats the Earth as a sphere with a circumference of 40041.47 km (mean circumference), rather than an ellipsoid like it actually is. 
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>Wolfram Mathworld, <a href="http://mathworld.wolfram.com/SphericalTriangle.html">http://mathworld.wolfram.com/SphericalTriangle.html</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+earth.poly">earth.poly</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#1/8th the surface area of the earth
earth.tri(0, 0, 0, 90, 90, 0)

</code></pre>

<hr>
<h2 id='ecol.dist'>Creating a Distance Matrix</h2><span id='topic+ecol.dist'></span><span id='topic+dino.dist'></span>

<h3>Description</h3>

<p>Create a distance matrix between any number of locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecol.dist(x, method = sorenson, type = "dis")
dino.dist(x, method = sorenson, type = "dis")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecol.dist_+3A_x">x</code></td>
<td>
<p>matrix of taxa (or equivalent data) in rows by columns of localities 
(or equivalent)</p>
</td></tr>
<tr><td><code id="ecol.dist_+3A_method">method</code></td>
<td>
<p>the distance/similarity index to compute</p>
</td></tr>
<tr><td><code id="ecol.dist_+3A_type">type</code></td>
<td>
<p>if the matrix is to be a distance ('dis') or similarity ('sim) matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This will create a distance (or similarity) matrix using any of the provided 
indices: <code><a href="#topic+sorenson">sorenson</a></code>, <code><a href="#topic+simpson">simpson</a></code>, 
<code><a href="#topic+bray.curtis">bray.curtis</a></code>, <code><a href="#topic+jaccard">jaccard</a></code>, <code><a href="#topic+morisita.horn">morisita.horn</a></code>,
<code><a href="#topic+chao.jaccard">chao.jaccard</a></code> and <code><a href="#topic+chao.sorenson">chao.sorenson</a></code>. Creating a 
distance matrix will give a value of 1 for the most distantly related sites, 
while similarity index will give a value of 1 for the most similar sites.
</p>
<p><code>dino.dist</code> is an old name for the function, and is in the process of being deprecated.
</p>


<h3>Value</h3>

<p>A distance matrix (lower triangle) giving the pairwise distance indices 
between all points. 
</p>


<h3>Note</h3>

                                
<p>To use a user generated distance index, type the name of the function to be 
used for method, and the function will use that function instead. Note that 
the function internally provides two equal length vectors at a time to the 
distance calculation function. 
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+sorenson">sorenson</a></code>, <code><a href="#topic+simpson">simpson</a></code>, 
<code><a href="#topic+bray.curtis">bray.curtis</a></code>, <code><a href="#topic+jaccard">jaccard</a></code>, <code><a href="#topic+morisita.horn">morisita.horn</a></code>,
<code><a href="#topic+chao.jaccard">chao.jaccard</a></code> and <code><a href="#topic+chao.sorenson">chao.sorenson</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##example using fdata.mat
data(fdata.mat)
ecol.dist(fdata.mat)
ecol.dist(fdata.mat,simpson,"sim")

</code></pre>

<hr>
<h2 id='euler.rot'>Calculate the Euler Rotation of a Point</h2><span id='topic+euler.rot'></span>

<h3>Description</h3>

<p>Calculate the rotation of a point on the Earth for a given Euler pole. The rotation assumes a shperical earth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler.rot(lat1, long1, rotdeg, lat2, long2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euler.rot_+3A_lat1">lat1</code></td>
<td>
<p>Euler-pole latitude</p>
</td></tr>
<tr><td><code id="euler.rot_+3A_long1">long1</code></td>
<td>
<p>Euler-pole longitude</p>
</td></tr>
<tr><td><code id="euler.rot_+3A_rotdeg">rotdeg</code></td>
<td>
<p>Rotation about Euler-pole</p>
</td></tr>
<tr><td><code id="euler.rot_+3A_lat2">lat2</code></td>
<td>
<p>Latitude of point to be converted</p>
</td></tr>
<tr><td><code id="euler.rot_+3A_long2">long2</code></td>
<td>
<p>longitude of point to be converted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Locations of the Euler pole and the point to be rotated must be given in decimal degrees.
</p>


<h3>Value</h3>

<p>Rotated latitude and longitude of the provided point in decimal degrees.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p> ~put references to the literature/web site here ~ </p>

<hr>
<h2 id='fdata'>A Sample Species Abundance Dataset</h2><span id='topic+fdata.list'></span><span id='topic+fdata.mat'></span><span id='topic+fdata.lats'></span>

<h3>Description</h3>

<p>A simple hypothetical data set used in many of the examples.
</p>


<h3>Value</h3>

<p>There are 3 datasets, however 2 of them (<code>fdata.mat</code> and <code>fdata.lats</code>) derive from the first (<code>fdata.list</code>). <code>fdata.list</code> is a table with 5 columns descriing the sample site, species name, abundance, and location in latitude/longitude. <code>fdata.mat</code> is a 12 by 12 species abundance matrix (12 unique species and 12 unique samples/localities) that can be recreated from the original table of occurrences using the <code>create.matrix()</code> function; likewise, the <code>fdata.lats()</code> contains the locations of each of the samples, and can be created using the <code>create.lats()</code>
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fdata.list)
</code></pre>

<hr>
<h2 id='int.chao'>Internal function for chao estimators</h2><span id='topic+int.chao'></span>

<h3>Description</h3>

<p>Computes the Chao species estimator for both <code>chao1</code> and <code>chao2</code>
estimators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int.chao(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int.chao_+3A_x">x</code></td>
<td>
<p>a vector of positive integers or zero of any length</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is typically only called internally by the functions <code>chao1</code>
and <code>chao2</code>. The function has a built in bias correction, such that it
will not return values of infinity or non-numbers.
</p>


<h3>Value</h3>

<p>Estimated numer of species using the Chao estimator.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>Chao, A. 1984. Nonparametric estimation of the number of classes in a population.
Scandinavian Journal of Statistics 11: 265-270.</p>


<h3>See Also</h3>

<p>For the more useful implementations of the Chao estimator, see <code><a href="#topic+chao1">chao1</a></code> for the abundance based estimator or <code><a href="#topic+chao2">chao2</a></code> for the incidence based estimator</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create example data set
a&lt;-c(4,5,1,1,2,0,0,1,3,0,8,45,23)
int.chao(a)

## a data set which would give NaN using classic (ie not bias corrected) version
a&lt;-c(4,5,0,0,2,0,0,0,3,0,8,45,23)
int.chao(a)
</code></pre>

<hr>
<h2 id='jack1'>First- and second-order jacknife estimators</h2><span id='topic+jack1'></span><span id='topic+jack2'></span>

<h3>Description</h3>

<p>Computes the extrapolated species richness of a population using first- or
second-order jacknife stimators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jack1(x, taxa.row = TRUE, abund = TRUE)
jack2(x, taxa.row = TRUE, abund = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jack1_+3A_x">x</code></td>
<td>
<p>a vector, matrix or data frame of positive integers or zero of any size</p>
</td></tr>
<tr><td><code id="jack1_+3A_taxa.row">taxa.row</code></td>
<td>
<p>whether each row of the matrix is a different taxon; if so, value is set to TRUE</p>
</td></tr>
<tr><td><code id="jack1_+3A_abund">abund</code></td>
<td>
<p>If true, data is assumed to be abundance, if false, presence
absence is assumed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions compute the first and second-order jacknife species richness
estimators, respectively. Both functions will accept a vector, matrix or data
frame of any size made up of positive integers and zeros. Matrices are by
default treated such that each row is a different taxon and each column is a
sample or locality, however if they are arranged with the taxa as columns,
change the argument <code>taxa.row</code> to FALSE. If the data is abundance based,
<code>abund</code> should be set to TRUE. If <code>abund</code> is set to FALSE, the data
will be converted to presence/absence if not already in that format. For
single vectors/columns, <code>taxa.row</code> and <code>abund</code> are ignored.
</p>


<h3>Value</h3>

<p>The value returned is the Jackknife estimated species diversity of the dataset in question.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>Burnham, K.P. &amp; W.S. Overton. 1978. Estimation of the size of a closed population when capture probabilities vary among animals. Biometrika 65, 623-633.
</p>
<p>Burnham, K.P. &amp; W.S. Overton. 1979. Robust estimation of population size when capture probabilities vary among animals. Ecology 60, 927-936.
</p>
<p>Heltshe, J. &amp; Forrester, N.E. 1983 . Estimating species richness using the jackknife procedure. Biometrics 39, 1-11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ACE">ACE</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## sample vector
a&lt;-c(0,5,1,1,2,0,0,1,0,0,8,45)
jack1(a)

## matrix format
a&lt;-matrix(c(0,5,1,1,2,0,0,1,0,0,8,45),4,3)
jack1(a)
jack2(a)
jack2(a,abund = FALSE)

## presence absence matrix of the above abundance matrix
a&lt;-matrix(c(0,1,1,1,1,0,0,1,0,0,1,1),4,3)
jack1(a)
jack2(a)
jack2(a, abund = FALSE)
</code></pre>

<hr>
<h2 id='lats2Shape'>Converting a Table of Latitudes and Longitudes to a Shapefile</h2><span id='topic+lats2Shape'></span>

<h3>Description</h3>

<p>A helper function to convert a table of latitudes and longitudes (and 
associated attributes, if applicable) into a shapefile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lats2Shape(lats)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lats2Shape_+3A_lats">lats</code></td>
<td>
<p>a table with a latitude and longitude column respectively with associated attributes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The table to be converted must contain as it's first two columns the latitude 
(or Y) and longitude (or X) values to be converted. Any other number of 
columns in any format can also be attached, and will be included in the 
attribute table.
</p>


<h3>Value</h3>

<p>A shapefile object which can be written to file using <code>write.shapefile</code>
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+msn2Shape">msn2Shape</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#use fdata.lats as dataset
data(fdata.lats)
shape.lats&lt;-lats2Shape(fdata.lats)
write.shapefile(shape.lats, file='/path/to/write/lats')

## End(Not run)
</code></pre>

<hr>
<h2 id='loc.map'>Mapping Points on a Global Map</h2><span id='topic+loc.map'></span>

<h3>Description</h3>

<p>A function to plot any number of points given their latitude and longitude 
respectively on a map of the world.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loc.map(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loc.map_+3A_x">x</code></td>
<td>
<p>a table with a longitude and latitude column respectively with 
optional associated attributes</p>
</td></tr>
<tr><td><code id="loc.map_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the <code>plot</code> call</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function, which automatically zooms in and centers the map 
view on the input points. The <code>...</code> allow the user to adjust the usual 
parameters for a scatterplot outlined by <code><a href="graphics.html#topic+par">par</a></code>. 
</p>


<h3>Value</h3>

<p>Plots a map of the world focused on the locations provided.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+msn.map">msn.map</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#plotting the fdata sample set
data(fdata.lats)
loc.map(fdata.lats)

</code></pre>

<hr>
<h2 id='localoptima'>Function to Find Local Optimization for clustering</h2><span id='topic+localoptima'></span>

<h3>Description</h3>

<p>A function meant to be used internally be the <code>relational.clustering</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localoptima(dist, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localoptima_+3A_dist">dist</code></td>
<td>
<p>Distance matrix to be used</p>
</td></tr>
<tr><td><code id="localoptima_+3A_group">group</code></td>
<td>
<p>group designations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes a distance matrix and a vector with the group identifications for each sample locality (or equivalent). It is mainly meant to be used internally by the <code>relational.clustering</code> function to optimize the initial clustering and find the local (which hopefully is also the global) optimal organization, such that each member of a group is more similar to the other members in it's group (on average) than to any other groups.
</p>


<h3>Value</h3>

<p>Arc distance between two points on the Earth's surface in kilometers.
</p>


<h3>Note</h3>

<p>The distance calculated may be up to 0.2% inaccurate, as this function 
treats the Earth as a sphere with a circumference of 40003 km, rather than an
ellipsoid like it actually is.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p>To calculate pairwise distances between a list of points see <code><a href="#topic+earth.dist">earth.dist</a></code>, or to calculate an area enclosed by three points on the Earth's surface, see <code><a href="#topic+earth.tri">earth.tri</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##distance between 23 degrees N 54 degrees E and 32 degrees S 67 degrees E
deg.dist(23,54,-32,67)
</code></pre>

<hr>
<h2 id='msn.map'>Mapping a Minimum Spanning Tree</h2><span id='topic+msn.map'></span>

<h3>Description</h3>

<p>Creating a quick and focused map using a world map for gegraphically referenced 
visualization within R of a minimum spanning tree or network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msn.map(msn, lat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msn.map_+3A_msn">msn</code></td>
<td>
<p>minimum spanning tree or network to be used</p>
</td></tr>
<tr><td><code id="msn.map_+3A_lat">lat</code></td>
<td>
<p>the lats</p>
</td></tr>
<tr><td><code id="msn.map_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for quick visualization of georeferenced minimum spanning trees, and is not meant for creating figure quality images due to lack of fine control over many functions
</p>


<h3>Value</h3>

<p>Returns a map of the globe, focused in on any set of georeferenced localities.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+dino.msn">dino.msn</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##add examples

</code></pre>

<hr>
<h2 id='msn2Shape'>Convert a Minimum spanning Network or Tree to Shapefile</h2><span id='topic+msn2Shape'></span>

<h3>Description</h3>

<p>A helper function to convert a minimum spanning tree or network into shapefile 
format. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msn2Shape(msn, lats, dist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msn2Shape_+3A_msn">msn</code></td>
<td>
<p>a minimum spanning tree or network (binary matrix)</p>
</td></tr>
<tr><td><code id="msn2Shape_+3A_lats">lats</code></td>
<td>
<p>a matrix or data frame with the latitude and longitude of the 
sites as the first two columns respectively</p>
</td></tr>
<tr><td><code id="msn2Shape_+3A_dist">dist</code></td>
<td>
<p>Optional argument to include distance values in final output; if 
wanted, a distance matrix (lower triangle) with the localities in the same 
order as in the MSN are required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will take a minimum spanning tree or network object, along with 
the georeferenced locations of the sites, and convert it into a shapefile for 
use with GIS. The <code>msn</code> argument requires a minimu spanning tree or 
network object, and the lat argument requires some form of location for each 
of the points, typically a matrix with latitude and longitude columns 
respectively.
</p>


<h3>Value</h3>

<p>A shapefile which can be output using the <code>write.shapefile</code> function for
use with a GIS program.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+lats2Shape">lats2Shape</a></code> for a function to convert a lat/long table to 
a shapefile</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#import both fdata.lats and fdata.mat
data(fdata.lats)
data(fdata.mat)
fdata.dist&lt;-dino.dist(fdata.mat)
fdata.mst&lt;-dino.mst(fdata.dist)
shape.mst&lt;-msn2Shape(fdata.mst, fdata.lats)
write.shapefile(shape.mst, file='/path/to/write/mst')

## End(Not run)
</code></pre>

<hr>
<h2 id='mstlines'>Display a Minimum Spanning Tree or Network</h2><span id='topic+mstlines'></span>

<h3>Description</h3>

<p>a method of displaying a Minimum Spanning Tree/Network over a given set of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstlines(mst, x, y = NULL, pts.names = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstlines_+3A_mst">mst</code></td>
<td>
<p>a minimum spanning tree or network object</p>
</td></tr>
<tr><td><code id="mstlines_+3A_x">x</code></td>
<td>
<p>either a table with the first two columns that of the x and y coordinates respectively, or simply that of the x coordinate</p>
</td></tr>
<tr><td><code id="mstlines_+3A_y">y</code></td>
<td>
<p>an optional argument if the y coordinates were not given in argument x</p>
</td></tr>
<tr><td><code id="mstlines_+3A_pts.names">pts.names</code></td>
<td>
<p>If there is more than one shortest possible branch, should one be chosen randomly</p>
</td></tr>
<tr><td><code id="mstlines_+3A_...">...</code></td>
<td>
<p>arguments to be passed to lines()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function to plot the lines of a minimum spanning tree/forest on a plot; works as a frontend for <code>lines</code>.</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+dino.dist">dino.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#plot with overlain MST for fdata dataset
data(fdata.lats)
data(fdata.mat)
fdata.dist&lt;-dino.dist(fdata.mat)
fdata.mst&lt;-dino.mst(fdata.dist)
plot(coordinates(fdata.lats))
mstlines(fdata.mst, coordinates(fdata.lats))
</code></pre>

<hr>
<h2 id='new.lat.long'>Find a New Latitude and Longitude</h2><span id='topic+new.lat.long'></span>

<h3>Description</h3>

<p>Find a new location using an original location (latitude and longitude) along with a bearing and distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.lat.long(long, lat, bearing, distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new.lat.long_+3A_long">long</code></td>
<td>
<p>original longitude</p>
</td></tr>
<tr><td><code id="new.lat.long_+3A_lat">lat</code></td>
<td>
<p>original latitude</p>
</td></tr>
<tr><td><code id="new.lat.long_+3A_bearing">bearing</code></td>
<td>
<p>bearing from original point to new location, degrees from North</p>
</td></tr>
<tr><td><code id="new.lat.long_+3A_distance">distance</code></td>
<td>
<p>distance to location</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length 2 with the new latitude and longitude respectively
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+deg.dist">deg.dist</a></code>, <code><a href="#topic+earth.bear">earth.bear</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#Travel from 0,0 to a new location at a bearing of 45 degrees 
#from North (clockwise) and 1000 km away
new.lat.long(long = 0, lat = 0, bearing = 45, distance = 1000)
</code></pre>

<hr>
<h2 id='nmds.mst'>Creating NMDS plots with overlain Minimum Spanning Trees</h2><span id='topic+nmds.mst'></span>

<h3>Description</h3>

<p>This is a helper function which will plot an NMDS with an overlain MST
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmds.mst(nmds, mst, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmds.mst_+3A_nmds">nmds</code></td>
<td>
<p>an NMDS created using the ecodist program</p>
</td></tr>
<tr><td><code id="nmds.mst_+3A_mst">mst</code></td>
<td>
<p>a minimum spanning tree or network (binary matrix)</p>
</td></tr>
<tr><td><code id="nmds.mst_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the <code>plot</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At the moment, the function requires an NMDS created using the ecodist program, howver the minimum spanning tree can be any one which creates a binary matrix showing connections (ie <code><a href="#topic+dino.mst">dino.mst</a></code>).
</p>


<h3>Value</h3>

<p>Plots a non-metric multidimensional scaling plot with an overlain minimum 
spanning tree showing connections between the points.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+dino.msn">dino.msn</a></code>, <code><a href="#topic+dino.mst">dino.mst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#use fdata.mat as dataset, and use the \code{ecodist} package for the \code{nmds()} function
data(fdata.mat)
z &lt;- ecol.dist(fdata.mat)
a &lt;- dino.msn(z)
b &lt;- nmds(z)
nmds.mst(b, a)

## End(Not run)
</code></pre>

<hr>
<h2 id='rand.index'>Rand Index and Adjusted Rand Index</h2><span id='topic+rand.index'></span><span id='topic+adj.rand.index'></span>

<h3>Description</h3>

<p>Measures to compare the similarity of two clustering outcomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand.index(group1, group2)
adj.rand.index(group1, group2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand.index_+3A_group1">group1</code></td>
<td>
<p>first cluster identity matrix</p>
</td></tr>
<tr><td><code id="rand.index_+3A_group2">group2</code></td>
<td>
<p>second cluster identity matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the Rand Index for two different clustering outcomes. The Rand Index gives a value between 0 and 1, where 1 means the two clustering outcomes match identicaly. 
</p>
<p>The Adjusted Rand Index rescales the index, taking into account that random chance will cause some objects to occupy the same clusters, so the Rand Index will never actually be zero.
</p>


<h3>Value</h3>

<p>a single value between 0 and 1
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>Rand, W.M. 1971. Objective criteria for the evaluation of clustering methods. Journal of the American Statistical Association 66: 846&ndash;850.
</p>
<p>Hubert, L. and Arabie, P. 1985. Comparing partitions. Journal of Classification. 2: 193&ndash;218.
</p>


<h3>See Also</h3>

<p>To cluster the data, use the function <code><a href="#topic+rclust">rclust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a hypothetical clustering outcome with 2 distinct clusters
g1 &lt;- sample(1:2, size=10, replace=TRUE)
g2 &lt;- sample(1:3, size=10, replace=TRUE)
rand.index(g1, g2)
</code></pre>

<hr>
<h2 id='rclust'>Relational Clustering</h2><span id='topic+rclust'></span>

<h3>Description</h3>

<p>A method to cluster a number of samples using a relational (dissimila
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rclust(dist, clusters = 2, runs = 10, counter = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rclust_+3A_dist">dist</code></td>
<td>
<p>pairwise distance matrix</p>
</td></tr>
<tr><td><code id="rclust_+3A_clusters">clusters</code></td>
<td>
<p>final number of clusters</p>
</td></tr>
<tr><td><code id="rclust_+3A_runs">runs</code></td>
<td>
<p>number of randomizations to run</p>
</td></tr>
<tr><td><code id="rclust_+3A_counter">counter</code></td>
<td>
<p>use counter to display current run number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will return a cluster identity vector. The number of clusters requested must be 2 or greater, but 1/2 or less than the total number of samples, as the function requires at least 2 samples per cluster.
</p>


<h3>Value</h3>

<p>The vector returned will be the same length as the number of samples provided in the original <code>dist</code> matrix. The samples will have been clustered into the same number of clusters as defined in <code>clusters</code>
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+rclust.dist">rclust.dist</a></code>, <code><a href="#topic+rclust.null">rclust.null</a></code>, <code><a href="#topic+rclust.weights">rclust.weights</a></code> and <code><a href="#topic+coi">coi</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#a null solution for the fdata example data set
data(fdata.mat)
fd.dist &lt;- dino.dist(fdata.mat)
rclust(fd.dist, clusters = 2, runs = 10)
</code></pre>

<hr>
<h2 id='rclust.dist'>Relational Clustering</h2><span id='topic+rclust.dist'></span>

<h3>Description</h3>

<p>Provides a distance matrix intra- and inter-group average distances based on a clustering solution and a dissimilarity matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rclust.dist(groups, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rclust.dist_+3A_groups">groups</code></td>
<td>
<p>cluster identity vector</p>
</td></tr>
<tr><td><code id="rclust.dist_+3A_dist">dist</code></td>
<td>
<p>original pairwise distance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates a distance matrix for each cluster, giving the average within group pairwise distance and the average between group pairwise distance.
</p>


<h3>Value</h3>

<p>A matrix <code class="reqn">c</code> by <code class="reqn">c</code> in size, where <code class="reqn">c</code> is the number of clusters
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p>To cluster the data, use the function <code><a href="#topic+rclust">rclust</a></code>; see as well <code><a href="#topic+rclust.weights">rclust.weights</a></code>, <code><a href="#topic+rclust.null">rclust.null</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#a null solution for the fdata example data set
data(fdata.mat)
fd.dist &lt;- dino.dist(fdata.mat)
fd.clust &lt;- rclust(fd.dist, 2)
rclust.dist(fd.clust, fd.dist)
</code></pre>

<hr>
<h2 id='rclust.null'>Relational Clustering</h2><span id='topic+rclust.null'></span>

<h3>Description</h3>

<p>A Monte Carlo method for calculating a null/random clustering solution based on the type and arrangement of a known clustering solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rclust.null(groups, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rclust.null_+3A_groups">groups</code></td>
<td>
<p>cluster identity vector</p>
</td></tr>
<tr><td><code id="rclust.null_+3A_dist">dist</code></td>
<td>
<p>original pairwise distance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates a random/null clustering solution based on a given solution. It resamples the data and reassigns samples to groups, keeping the same group sizes.
</p>


<h3>Value</h3>

<p>A matrix equal in rows to the number of clusters originally given, with two columns for mean within group distance and standard deviation respectively.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p>To cluster the data, use the function <code><a href="#topic+rclust">rclust</a></code>; see as well <code><a href="#topic+rclust.weights">rclust.weights</a></code>, <code><a href="#topic+rclust.dist">rclust.dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#a null solution for the fdata example data set
data(fdata.mat)
fd.dist &lt;- dino.dist(fdata.mat)
fd.clust &lt;- rclust(fd.dist, 2)
rclust.null(fd.clust, fd.dist)
</code></pre>

<hr>
<h2 id='rclust.weights'>Relational Clustering</h2><span id='topic+rclust.weights'></span>

<h3>Description</h3>

<p>A method to cluster a number of samples using a relational (dissimila
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rclust.weights(groups, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rclust.weights_+3A_groups">groups</code></td>
<td>
<p>cluster identity vector</p>
</td></tr>
<tr><td><code id="rclust.weights_+3A_dist">dist</code></td>
<td>
<p>original pairwise distance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an n by c sized matrix, where n is the number of samples and c is the number of groups, of the average distances for each sample from itself to all the members of another group (<code class="reqn">c_{i}</code>).
</p>


<h3>Value</h3>

<p>A matrix of of size n (samples) by c (groups).
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p>To cluster the data, use the function <code><a href="#topic+rclust">rclust</a></code>; see as well <code><a href="#topic+rclust.dist">rclust.dist</a></code>, <code><a href="#topic+rclust.null">rclust.null</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fdata.mat)
fd.dist &lt;- dino.dist(fdata.mat)
fd.clust &lt;- rclust(fd.dist, 2)
rclust.weights(fd.clust, fd.dist)
</code></pre>

<hr>
<h2 id='relational.clustering'>Relational Clustering</h2><span id='topic+relational.clustering'></span>

<h3>Description</h3>

<p>A method to cluter a number of samples using a relational (dissimila
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relational.clustering(dist, clusters = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relational.clustering_+3A_dist">dist</code></td>
<td>
<p>pairwise distance matrix</p>
</td></tr>
<tr><td><code id="relational.clustering_+3A_clusters">clusters</code></td>
<td>
<p>number of clusters required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will calculate the shortest distance (portion of a Great Circle)
in kilometers between two points on the Earth given their latitude and 
longitude.
</p>


<h3>Value</h3>

<p>Arc distance between two points on the Earth's surface in kilometers.
</p>


<h3>Note</h3>

<p>The distance calculated may be up to 0.2% inaccurate, as this function 
treats the Earth as a sphere with a circumference of 40003 km, rather than an
ellipsoid like it actually is.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>The formulas for the Haversine distance function were taken from the Dr. Math website at <a href="http://mathforum.org/library/drmath/view/55417.html">http://mathforum.org/library/drmath/view/55417.html</a></p>


<h3>See Also</h3>

<p>To calculate pairwise distances between a list of points see <code><a href="#topic+earth.dist">earth.dist</a></code>, or to calculate an area enclosed by three points on the Earth's surface, see <code><a href="#topic+earth.tri">earth.tri</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##distance between 23 degrees N 54 degrees E and 32 degrees S 67 degrees E
deg.dist(23,54,-32,67)
</code></pre>

<hr>
<h2 id='sac'>Calculate Species Area Curves</h2><span id='topic+sac'></span>

<h3>Description</h3>

<p>Calculating a species area curve for a set of georeferenced localities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sac(lats, spp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sac_+3A_lats">lats</code></td>
<td>
<p>a table with a longitude and latitude column respectively as the first two columns, or a SpatialPoints object with longitude/latitude</p>
</td></tr>
<tr><td><code id="sac_+3A_spp">spp</code></td>
<td>
<p>A matrix/data frame of species (rows) by samples/localities (columns)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This will take a set of geographic coordinates along with a table of species by localities and return a list consisting of a matrix (<code>$areavsspp</code>) with a column of total area and of total species present, and a vector (<code>ranks</code>) with the order the samples were added in. The area is calculated by starting with the most central point, and adding those points closest to it, calculating a minimum spanning polygon as each new site is added, until all points are used.
</p>


<h3>Value</h3>

<p>Returns a list of a matrix with columns of total area and total species recorded respectively and a vector of sample orders.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+earth.dist">earth.dist</a></code>, <code><a href="#topic+earth.poly">earth.poly</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#fdata species/area relationship
data(fdata.lats)
data(fdata.mat)
a&lt;-sac(fdata.lats, fdata.mat)
plot(log(a$areavsspp))
</code></pre>

<hr>
<h2 id='sim.occ'>Simulated Species Occurrence data</h2><span id='topic+sim.occ'></span>

<h3>Description</h3>

<p>A function to simulate a species occurrence data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.occ(total.species = 100, endemics = 0.1, regions = 3, locs = 30, avg.abund = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.occ_+3A_total.species">total.species</code></td>
<td>
<p>The total number of species in the region (i.e. the number of rows in the result matrix)</p>
</td></tr>
<tr><td><code id="sim.occ_+3A_endemics">endemics</code></td>
<td>
<p>The proportion of endemic species for the entire region</p>
</td></tr>
<tr><td><code id="sim.occ_+3A_regions">regions</code></td>
<td>
<p>The number of areas of endemicity</p>
</td></tr>
<tr><td><code id="sim.occ_+3A_locs">locs</code></td>
<td>
<p>The number of samples/locatlities per region of endemicity</p>
</td></tr>
<tr><td><code id="sim.occ_+3A_avg.abund">avg.abund</code></td>
<td>
<p>The 'average' abundance of a species for any given sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a matrix of $c$ rows of species (given by <code>total.species</code>) with $n$ number of sample columns (where $n$ equals $regions*locs$). The given abundance of any species at a given sample is determined by a log normal distribution, with each species being randomly assigned a value from <code>rnorm()</code>. The number of endemics for any given region is equal to $total.species*endemics/regions$. An endemic is conseidered to only occur within a given region, and all other non-ndemic species are considered to be 'cosmopolitan' and can occur in any region. The <code>avg.abund</code> value affects how many species are recovered at a given site, and for any given run there are typically species that are not present in the sample but are present in the region.
</p>


<h3>Value</h3>

<p>Returns a matrix of simulated species abundances per locality.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+ecol.dist">ecol.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a dataset with 2 regions and 5 samples per region
sim.occ(regions=2, locs=5)
</code></pre>

<hr>
<h2 id='similarity'>Similarity/Dissimilarity Indices</h2><span id='topic+bray.curtis'></span><span id='topic+euclidean'></span><span id='topic+jaccard'></span><span id='topic+simpson'></span><span id='topic+sorenson'></span><span id='topic+manhattan'></span><span id='topic+morisita.horn'></span><span id='topic+ochiai'></span><span id='topic+kulczynski'></span><span id='topic+braun.blanquet'></span>

<h3>Description</h3>

<p>Functions to calculate the ecological distance between two groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>braun.blanquet(x, y)
bray.curtis(x, y)
euclidean(x,y)
kulczynski(x,y)
jaccard(x, y)
manhattan(x, y)
morisita.horn(x, y)
ochiai(x, y)
simpson(x, y)
sorenson(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarity_+3A_x">x</code></td>
<td>
<p>species from group A</p>
</td></tr>
<tr><td><code id="similarity_+3A_y">y</code></td>
<td>
<p>species from group B</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You must provide two separate vectors, with species arranged in the same 
order, from area A and B. If species are present in one site but not the 
other, these must be recorded for both sites; the site where they are not 
found should be coded as a zero. For details on each index, please consult the references.
</p>


<h3>Value</h3>

<p>Returns the similarity index for the two sites in question. 
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>Shi, G. R. 1993. Multivariate data analysis in palaeoecology and palaeobiogeography &ndash; a review. Palaeogeography, Palaeoclimatology, Palaeoecology 105: 199&ndash;234.
</p>
<p>Magurran, A. E. 2004. Measuring Biological Diversity. Oxford, Blackwell.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dino.dist">dino.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Species counts from two different locations
a &lt;- c(1,0,4,3,5,0,0,7)
b &lt;- c(2,1,3,0,0,1,0,6)
bray.curtis(a,b)
jaccard(a,b)
simpson(a,b)
sorenson(a,b)
morisita.horn(a,b)
</code></pre>

<hr>
<h2 id='spp.est'>Estimating Species Diversity</h2><span id='topic+spp.est'></span>

<h3>Description</h3>

<p>Estimate the diversity of a sample(s) using a number of species diversity 
estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spp.est(x, rand = 10, abund = TRUE, counter = FALSE, max.est = 'all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spp.est_+3A_x">x</code></td>
<td>
<p>A vector, matrix or data frame with species as rows and 
locations/samples as columns</p>
</td></tr>
<tr><td><code id="spp.est_+3A_rand">rand</code></td>
<td>
<p>The number of times to run the internal randomizations; default 
is set to 10</p>
</td></tr>
<tr><td><code id="spp.est_+3A_abund">abund</code></td>
<td>
<p>If the data is abundance or presence/absence; default is set to 
TRUE for abundance</p>
</td></tr>
<tr><td><code id="spp.est_+3A_counter">counter</code></td>
<td>
<p>Whether or not to provide a running total of progress of randomizations</p>
</td></tr>
<tr><td><code id="spp.est_+3A_max.est">max.est</code></td>
<td>
<p>The value to go up to for the analysis; default is set to the same as the total number of samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will accept a vector, matrix or data frame of species by samples 
and return a large matrix with various species estimation values.
</p>


<h3>Value</h3>

<p>Returns a table with the following column names if <code>abund=TRUE</code>:
</p>
<table>
<tr><td><code>N.obs</code></td>
<td>
<p>Total sample size</p>
</td></tr> 
<tr><td><code>S.obs</code></td>
<td>
<p>Number of observed species</p>
</td></tr>
<tr><td><code>S.obs(+95%)</code></td>
<td>
<p>95% upper confidence interval</p>
</td></tr>  
<tr><td><code>S.obs(-95%)</code></td>
<td>
<p>95% lower confidence interval</p>
</td></tr>  
<tr><td><code>Chao1</code></td>
<td>
<p>Chao Species Estimation</p>
</td></tr>
<tr><td><code>Chao1(upper)</code></td>
<td>
<p>95% upper confidence interval</p>
</td></tr> 
<tr><td><code>Chao1(lower)</code></td>
<td>
<p>95% lower confidence interval</p>
</td></tr>
<tr><td><code>ACE</code></td>
<td>
<p>Abundance-based Coverage Estimator</p>
</td></tr>
<tr><td><code>ACE(upper)</code></td>
<td>
<p>95% upper confidence interval</p>
</td></tr> 
<tr><td><code>ACE(lower)</code></td>
<td>
<p>95% lower confidence interval</p>
</td></tr>
<tr><td><code>Jack1</code></td>
<td>
<p>First Order Jacknife Estimator</p>
</td></tr>
<tr><td><code>Jack1(upper)</code></td>
<td>
<p>95% upper confidence interval</p>
</td></tr>
<tr><td><code>Jack1(lower)</code></td>
<td>
<p>95% lower confidence interval</p>
</td></tr>
</table>
<p>Returns a table with the following column names if <code>abund=FALSE</code>:
</p>
<table>
<tr><td><code>N.obs</code></td>
<td>
<p>Total sample size</p>
</td></tr> 
<tr><td><code>S.obs</code></td>
<td>
<p>Number of observed species</p>
</td></tr>
<tr><td><code>S.obs(+95%)</code></td>
<td>
<p>95% upper confidence interval</p>
</td></tr>  
<tr><td><code>S.obs(-95%)</code></td>
<td>
<p>95% lower confidence interval</p>
</td></tr>  
<tr><td><code>Chao2</code></td>
<td>
<p>Chao Species Estimation</p>
</td></tr>
<tr><td><code>Chao2(upper)</code></td>
<td>
<p>95% upper confidence interval</p>
</td></tr> 
<tr><td><code>Chao2(lower)</code></td>
<td>
<p>95% lower confidence interval</p>
</td></tr>
<tr><td><code>ICE</code></td>
<td>
<p>Incidence-based Coverage Estimator</p>
</td></tr>
<tr><td><code>ICE(upper)</code></td>
<td>
<p>95% upper confidence interval</p>
</td></tr> 
<tr><td><code>ICE(lower)</code></td>
<td>
<p>95% lower confidence interval</p>
</td></tr>
<tr><td><code>Jack1</code></td>
<td>
<p>First Order Jacknife Estimator</p>
</td></tr>
<tr><td><code>Jack1(upper)</code></td>
<td>
<p>95% upper confidence interval</p>
</td></tr>
<tr><td><code>Jack1(lower)</code></td>
<td>
<p>95% lower confidence interval</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function can be very long to run due to its iterative nature. The 
randomizations are initially set to 10 so the process will run relatively 
quickly, but a low value for randomizations will not give nicely smoothed 
curves.
</p>
<p>Also, in some cases due to the nature of some of the functions, they provide no answer, such as is common with the Chao standard deviation. In this case, the Chao upper and lower bounds are simply 95% confidence intervals based on the actual Chao estimator.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>References</h3>

<p>The original idea for a program similar to this came from the 
extremely useful EstimateS program by Robert K. Colwell
</p>
<p>Colwell, R.K. 2010. EstimateS: Statistical estimation of species richness and shared species from samples. Version 8.2. User's Guide and application published at: http://purl.oclc.org/estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chao1">chao1</a></code>, <code><a href="#topic+jack1">jack1</a></code>, <code><a href="#topic+bootstrap">bootstrap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#abundance example with sample data set
data(fdata.mat)
spp.est(fdata.mat, abund = TRUE, counter = FALSE)

#occurrence example with sample data set
data(fdata.mat)
spp.est(fdata.mat, abund = FALSE, counter = FALSE)

</code></pre>

<hr>
<h2 id='tri.ineq'>Testing for the Triangle Inequality</h2><span id='topic+tri.ineq'></span>

<h3>Description</h3>

<p>Determines if a distance matrix obeys the triangle inequality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.ineq(dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri.ineq_+3A_dist">dist</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests if a distance matrix respects the triangle inequality. Often with non-monotonic distance measures and complex data a situation can arise where the triangle inequality (where no single side of a triangle is greater in length than the sum of the other two sides) is not respected.
</p>


<h3>Value</h3>

<p>Returns a TRUE if the inequality is respected, and a FALSE if there is any situation where the triangle inequality is not respected.
</p>


<h3>Author(s)</h3>

<p>Matthew Vavrek</p>


<h3>See Also</h3>

<p><code><a href="#topic+ecol.dist">ecol.dist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## sample distance matrix with an impossible triangle
a&lt;-matrix(0.2, 4,4)
a[4,2]&lt;-0.8
a&lt;-as.dist(a)
tri.ineq(a)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
