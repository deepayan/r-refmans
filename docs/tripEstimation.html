<!DOCTYPE html><html><head><title>Help for package tripEstimation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tripEstimation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.image.pimg'><p>Convert to image list</p></a></li>
<li><a href='#astro'><p>Calculations for position of the sun and moon</p></a></li>
<li><a href='#behav.bin'><p> Bin MCMC chains.</p></a></li>
<li><a href='#bits'><p> Set and get bits from binary masks.</p></a></li>
<li><a href='#chain.read'><p> Manage MCMC cache.</p></a></li>
<li><a href='#elevation'><p> Calculate elevation of astronomical objects</p></a></li>
<li><a href='#get.mask'><p>Create, access and manipulate spatial masks</p></a></li>
<li><a href='#initialize.x'><p> Diagnose and initialize light level estimation.</p></a></li>
<li><a href='#julday'><p> Julian day and Julian century calculations from date-time values</p></a></li>
<li><a href='#metropolis'><p> Metropolis-Hastings sampler for location estimation for archival and satellite tag</p></a></li>
<li><a href='#mkCalibration'><p>Create calibration of solar elevation to measured light level.</p></a></li>
<li><a href='#mkLookup'><p> Create a lookup function to query locations against spatial masks</p></a></li>
<li><a href='#norm.proposal'><p>Manage proposal functions tune variance for metropolis sampler</p></a></li>
<li><a href='#old.metropolis'><p>Older versions of solar location estimation</p></a></li>
<li><a href='#pick'><p>Choose twilight segments interactively from light data.</p></a></li>
<li><a href='#pimg.list'><p>Create a collection of probability images, for MCMC binning.</p></a></li>
<li><a href='#satellite.model'><p> Function to create a satellite model object for metropolis location sampler</p></a></li>
<li><a href='#solar'><p> Calculate solar postion parameters</p></a></li>
<li><a href='#solar.model'><p> Function to create a solar model object for metropolis location sampler</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Metropolis Sampler and Supporting Functions for Estimating
Animal Movement from Archival Tags and Satellite Fixes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0-46</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, mgcv, reproj, sp, zoo</td>
</tr>
<tr>
<td>Description:</td>
<td>Data handling and estimation functions for animal movement
    estimation from archival or satellite tags. Helper functions are included
    for making image summaries binned by time interval from Markov Chain Monte Carlo
    simulations. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Trackage/tripEstimation">https://github.com/Trackage/tripEstimation</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Trackage/tripEstimation">https://github.com/Trackage/tripEstimation</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-21 14:08:24 UTC; gdal</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael D. Sumner [aut, cre],
  Simon Wotherspoon [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael D. Sumner &lt;mdsumner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-21 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.image.pimg'>Convert to image list</h2><span id='topic+as.image.pimg'></span><span id='topic+as.matrix.pimg'></span><span id='topic+combine'></span><span id='topic+coords.pimg'></span><span id='topic+unzipper'></span><span id='topic+as.local.pimg'></span>

<h3>Description</h3>

<p>Converts Probability image (pimage) component to standard R xyz list
image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.image.pimg(pimg)
combine(pimgs, subset = 1:length(pimgs))
coords.pimg(pimg)
unzipper(px)
as.local.pimg(pimg)
## S3 method for class 'pimg'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.image.pimg_+3A_pimg">pimg</code></td>
<td>
<p>Probability image component</p>
</td></tr>
<tr><td><code id="as.image.pimg_+3A_pimgs">pimgs</code></td>
<td>
 <p><code>pimgs</code>  </p>
</td></tr>
<tr><td><code id="as.image.pimg_+3A_subset">subset</code></td>
<td>
 <p><code>subset</code> </p>
</td></tr>
<tr><td><code id="as.image.pimg_+3A_px">px</code></td>
<td>
 <p><code>px</code> </p>
</td></tr>
<tr><td><code id="as.image.pimg_+3A_x">x</code></td>
<td>
<p><code>x</code></p>
</td></tr>
<tr><td><code id="as.image.pimg_+3A_...">...</code></td>
<td>
<p><code>...</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.image.pimg</code> returns a <code>image</code> list with vectors x,y and z matrix
</p>
<p><code>as.matrix.pimg</code> returns just the local matrix populated in the parent
</p>
<p><code>combine</code> returns the collective matrix, in <code>image</code> xyz form
</p>
<p><code>coords.pimg</code> returns the rectilinear coordinates of the pimg parent
</p>
<p><code>unzipper</code> returns a <code>pimg.list</code> by combining multiple compatible ones together and resolving their temporal order
</p>
<p><code>as.local.pimg</code> returns the <code>pimg</code> in local form
</p>


<h3>Author(s)</h3>

<p>Michael D. Sumner</p>

<hr>
<h2 id='astro'>Calculations for position of the sun and moon</h2><span id='topic+astro'></span><span id='topic+EQUHOR'></span><span id='topic+FRAC'></span><span id='topic+LMST'></span><span id='topic+lunar'></span><span id='topic+mini.sun'></span><span id='topic+MJD'></span><span id='topic+POLAR'></span>

<h3>Description</h3>

<p>This set of functions provides simple position calculations for the sun and moon,
taken from Pascal routines published in Montenbruck and Pfleger (1994, Dunlop).
</p>
<p>These are completely independent from the (specifically optimized) solar elevation
calculations available via [elevation and solar].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>astro(lon, lat, astro.calc)

EQUHOR(DEC, TAU, PHI)

FRAC(x)

LMST(MJDay, LAMBDA)

lunar(time)

mini.sun(time)

MJD(date)

POLAR(X, Y, Z)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="astro_+3A_lon">lon</code></td>
<td>
<p>vector of <code>lon</code>gitudes</p>
</td></tr>
<tr><td><code id="astro_+3A_lat">lat</code></td>
<td>
<p>vector of <code>lat</code>itudes</p>
</td></tr>
<tr><td><code id="astro_+3A_astro.calc">astro.calc</code></td>
<td>
<p>list object containing <code>RA</code> right ascension </p>
</td></tr>

<tr><td><code id="astro_+3A_dec">DEC</code></td>
<td>
<p>declination</p>
</td></tr>
<tr><td><code id="astro_+3A_tau">TAU</code></td>
<td>
<p><code>TAU</code>  </p>
</td></tr>
<tr><td><code id="astro_+3A_phi">PHI</code></td>
<td>
 <p><code>PHI</code>  </p>
</td></tr>

<tr><td><code id="astro_+3A_x">x</code></td>
<td>
<p>number</p>
</td></tr>

<tr><td><code id="astro_+3A_mjday">MJDay</code></td>
<td>
<p> modified julian day </p>
</td></tr>
<tr><td><code id="astro_+3A_lambda">LAMBDA</code></td>
<td>
<p><code>LAMBDA</code> </p>
</td></tr>

<tr><td><code id="astro_+3A_time">time</code></td>
<td>
<p> vector of date-times in POSIXct format </p>
</td></tr>

<tr><td><code id="astro_+3A_date">date</code></td>
<td>
<p> vector of date-times in POSIXct format </p>
</td></tr>

<tr><td><code id="astro_+3A_x">X</code></td>
<td>
<p> x-coordinate</p>
</td></tr>
<tr><td><code id="astro_+3A_y">Y</code></td>
<td>
<p> y-coordinate </p>
</td></tr>
<tr><td><code id="astro_+3A_z">Z</code></td>
<td>
<p> z-coordinate </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>astro</code> returns a list object with the components of the moon or sun's
position,
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>rho component </p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>theta component - elevation</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>phi component - azimuth</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Some of this could be faster (particularly the use of LMST in &quot;astro&quot; is not precalculated)
</p>


<h3>Note</h3>

<p>Thanks to Nick.Ellis@csiro.au for pointing out a mistake pre-0.0-27
</p>


<h3>Author(s)</h3>

<p>Michael D. Sumner</p>


<h3>References</h3>

<pre>@BOOK{,
  title = {Astronomy on the Personal Computer},
  publisher = {Springer-Verlag, Berlin},
  year = {1994},
  author = {Oliver Montenbruck and Thomas Pfleger},
  edition = {2  (translated from German by Storm Dunlop)},
}</pre>

<h3>See Also</h3>

<p> See Also <code><a href="#topic+elevation">elevation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## the moon
tm &lt;- Sys.time() + seq(by = 3600, length = 100)
moon &lt;- lunar(tm)
rtp &lt;- astro(147, -42, moon)
op &lt;- par(mfrow = c(2,1))
plot(tm, rtp$theta, main = "lunar elevation, Hobart")
plot(tm, rtp$phi, main = "lunar azimuth, Hobart")
par(op)

## the sun
tm &lt;- Sys.time() + seq(by = 3600, length = 100)
sun &lt;- mini.sun(tm)
rtp &lt;- astro(147, -42, sun)
op &lt;- par(mfrow = c(2,1))
plot(tm, rtp$theta, main = "solar elevation, Hobart")
plot(tm, rtp$phi, main = "solar azimuth, Hobart")
par(op)
  elev.gmt &lt;- mkElevationSeg(1, tm)
  plot(tm, rtp$theta, main = "solar elevation mini.sun versus NOAA")
  lines(tm, elev.gmt(1, 147, -42))

</code></pre>

<hr>
<h2 id='behav.bin'> Bin MCMC chains.  </h2><span id='topic+behav.bin'></span><span id='topic+bin.pimg'></span><span id='topic+chunk.bin'></span>

<h3>Description</h3>

<p>Bin MCMC chains in probability image summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>behav.bin(z, pimgs, weights = NULL)
bin.pimg(pimg, xy, w = 1)
chunk.bin(filename, pimgs, weights = NULL, chunk = 2000, proj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="behav.bin_+3A_z">z</code></td>
<td>
 <p><code>z</code>  </p>
</td></tr>
<tr><td><code id="behav.bin_+3A_pimgs">pimgs</code></td>
<td>
  <p><code>pimgs</code>  </p>
</td></tr>
<tr><td><code id="behav.bin_+3A_weights">weights</code></td>
<td>
  <p><code>weights</code>  </p>
</td></tr>
<tr><td><code id="behav.bin_+3A_pimg">pimg</code></td>
<td>
  <p><code>pimg</code>  </p>
</td></tr>
<tr><td><code id="behav.bin_+3A_xy">xy</code></td>
<td>
  <p><code>xy</code>  </p>
</td></tr>
<tr><td><code id="behav.bin_+3A_w">w</code></td>
<td>
  <p><code>w</code>  </p>
</td></tr>
<tr><td><code id="behav.bin_+3A_filename">filename</code></td>
<td>
  <p><code>filename</code>  </p>
</td></tr>
<tr><td><code id="behav.bin_+3A_chunk">chunk</code></td>
<td>
  <p><code>chunk</code>  </p>
</td></tr>
<tr><td><code id="behav.bin_+3A_proj">proj</code></td>
<td>
  <p><code>proj</code>  </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>behav.bin</code> returns a <code>pimg.list</code>
</p>
<p><code>bin.pimg</code> and <code>chunk.bin</code> provide work flow for <code>behav.bin</code>, to do the local binning and
control the overal job
</p>

<hr>
<h2 id='bits'> Set and get bits from binary masks.  </h2><span id='topic+bits'></span><span id='topic+bits+3C-'></span>

<h3>Description</h3>

<p>Utility functions to access bits from numeric values,
for the efficient storage of spatial masks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bits(object, bit)

bits(object, bit) &lt;-  value
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="bits_+3A_object">object</code></td>
<td>
<p> a numeric value </p>
</td></tr>
<tr><td><code id="bits_+3A_bit">bit</code></td>
<td>
<p> the desired bit</p>
</td></tr>

<tr><td><code id="bits_+3A_value">value</code></td>
<td>
<p> logical value to set bit to </p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="rlang"><b>R</b></span> uses 32-bit integers, so we can (easily) access 31 binary matrices in each numeric
matrix.   This is very useful for storing long time-series of spatial masks,
required for track-location estimation from archival tags.
</p>


<h3>Value</h3>

<p>A numeric object with the given bit set, or a logical value designating the
status of the given bit.
</p>


<h3>Note</h3>

<p> The 32nd bit is harder to access, so we ignore it.
</p>


<h3>Author(s)</h3>

<p> Michael D. Sumner </p>


<h3>See Also</h3>

<p> See Also  <code><a href="#topic+get.mask">get.mask</a></code> for a higher level access of a mask object </p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 1L
bits(a, 0)  ## 1
bits(a, 2) &lt;- 1
a   # 5

</code></pre>

<hr>
<h2 id='chain.read'> Manage MCMC cache.  </h2><span id='topic+chain.read'></span><span id='topic+chain.dim'></span><span id='topic+chain.write'></span>

<h3>Description</h3>

<p>These functions read and write to cache files for storing long MCMC
outputs from model functions, such as <code><a href="#topic+solar.model">solar.model</a></code> or
<code><a href="#topic+satellite.model">satellite.model</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain.read(filename)
chain.dim(filename)
chain.write(filename, A, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain.read_+3A_filename">filename</code></td>
<td>
<p> cache file for model chain </p>
</td></tr>
<tr><td><code id="chain.read_+3A_a">A</code></td>
<td>
<p> chain array </p>
</td></tr>
<tr><td><code id="chain.read_+3A_append">append</code></td>
<td>
<p> append to existing file or overwrite? </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>chain.read</code> returns the actual array of MCMC samples from an archived file
</p>
<p><code>chain.dim</code> reports the dimensions of the archived file
</p>
<p><code>chain.write</code> writes an array of MCMC samples to an archive file
</p>


<h3>Author(s)</h3>

<p>Michael D. Sumner and Simon Wotherspoon</p>


<h3>See Also</h3>

<p><code>pimg.list</code></p>

<hr>
<h2 id='elevation'> Calculate elevation of astronomical objects</h2><span id='topic+elevation'></span>

<h3>Description</h3>

<p>Function to calculate elevation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elevation(lon, lat, sun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elevation_+3A_lon">lon</code></td>
<td>
<p> vector of longitude values</p>
</td></tr>
<tr><td><code id="elevation_+3A_lat">lat</code></td>
<td>
<p> vector of latitude values </p>
</td></tr>
<tr><td><code id="elevation_+3A_sun">sun</code></td>
<td>
<p> pre-stored values  as returned by
<code><a href="#topic+solar">solar</a></code> or <code><a href="#topic+lunar">lunar</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>elevation</code> returns a numeric vector of solar (or lunar) elevation as degrees above or below the horizone
</p>


<h3>Author(s)</h3>

<p>Michael D. Sumner</p>


<h3>References</h3>

<p><a href="https://gml.noaa.gov/grad/solcalc/azel.html">https://gml.noaa.gov/grad/solcalc/azel.html</a>
</p>

<hr>
<h2 id='get.mask'>Create, access and manipulate spatial masks</h2><span id='topic+get.mask'></span><span id='topic+mkSmall'></span><span id='topic+set.mask+3C-'></span><span id='topic+mkMaskObject'></span>

<h3>Description</h3>

<p>Spatial masks are stored using the xyz-list structure used by
<code><a href="Matrix.html#topic+image">image</a></code> or as a series of masks stored as bits in the z-component
as matrix or array object.     <code>get.mask</code> is used to extract a specific
mask from the binary storage, and mkSmall can be used to quickly down-sample
an existing mask or image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mask(masks, k)

mkSmall(lst, thin = 10)

set.mask(object, segment) &lt;-  value

mkMaskObject(xs, ys, nsegs)

</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="get.mask_+3A_masks">masks</code></td>
<td>
<p> A list object with components x, y, and z containing spatial masks </p>
</td></tr>
<tr><td><code id="get.mask_+3A_k">k</code></td>
<td>
<p> specifies the k-th mask</p>
</td></tr>

<tr><td><code id="get.mask_+3A_lst">lst</code></td>
<td>
<p> an xyz-list structure with z containing either a matrix or array </p>
</td></tr>
<tr><td><code id="get.mask_+3A_thin">thin</code></td>
<td>
<p> integer factor to down-sample grid </p>
</td></tr>

<tr><td><code id="get.mask_+3A_object">object</code></td>
<td>
<p> array Mask object </p>
</td></tr>
<tr><td><code id="get.mask_+3A_segment">segment</code></td>
<td>
<p> segment number to be modified in the mask </p>
</td></tr>
<tr><td><code id="get.mask_+3A_value">value</code></td>
<td>
<p> individual mask to be set </p>
</td></tr>




<tr><td><code id="get.mask_+3A_xs">xs</code></td>
<td>

<p>x coordinates of mask cells
</p>
</td></tr>
<tr><td><code id="get.mask_+3A_ys">ys</code></td>
<td>

<p>y coordinates of mask cells
</p>
</td></tr>
<tr><td><code id="get.mask_+3A_nsegs">nsegs</code></td>
<td>

<p>number of segments to be represented
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of type logical</p>


<h3>Author(s)</h3>

<p> Michael D. Sumner</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mkLookup">mkLookup</a></code> for the use of these masks to query individual
locations and locations measured over time.
See <code><a href="#topic+bits">bits</a></code> for the underlying mechanism to set and get mask bits.
</p>
<p>For the use of the xyz-list structure see <code><a href="Matrix.html#topic+image">image</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
      data(volcano)
      d &lt;- list(x = seq(-10, 10, length = nrow(volcano)),
                y = seq(-5, 5, length = ncol(volcano)),
                z = array(0L, c(nrow(volcano), ncol(volcano), 2)) )
      mv &lt;- min(volcano)

      for (i in 0:61) {
        blk &lt;- (i %/% 31) + 1
        bit &lt;- (i - 1) %% 31
        bits(d$z[,,blk], bit) &lt;- volcano &gt; (mv + i*1.6 )
      }
      for (i in 0:61) image(get.mask(d, i))

      ## an object with 62 masks is only twice the size of the source data
      object.size(d) / object.size(volcano)

      ## plot a smaller version
      image(get.mask(d, 20), 5)


</code></pre>

<hr>
<h2 id='initialize.x'> Diagnose and initialize light level estimation. </h2><span id='topic+initialize.x'></span><span id='topic+position.logp'></span><span id='topic+show.segment'></span><span id='topic+light.quantile'></span>

<h3>Description</h3>

<p>Primarily for the purposes of initializing the estimation, these functions
can also be used for diagnostic purposes.   <code>position.logp</code> produces
grids of simplistic position likelihood for each twilight and uses
those to initialize positions for running estimations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position.logp(model, x1, x2, xrest = NULL, subset = 1:model$n,
initialize.x = TRUE, start = NULL, end = NULL, prob = 0.8, winoffset = 5)

initialize.x(model, x1, x2, xrest = NULL)

light.quantile(model, chain, day, seg, probl = c(0.025, 0.5, 0.975))

show.segment(model, chain, segment, day, light, k, n = 50, ...)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="initialize.x_+3A_model">model</code></td>
<td>
<p> estimation model object </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_x1">x1</code></td>
<td>
<p> vector of x-coordinates defining the prior grid </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_x2">x2</code></td>
<td>
<p> vector of y-coordinates defining the prior grid </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_xrest">xrest</code></td>
<td>
<p> value for remaining parameters - default is light attenuation </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_subset">subset</code></td>
<td>
<p> evaluate subset of segments - default uses all </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_initialize.x">initialize.x</code></td>
<td>
<p>logical - create initial points for x? </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_prob">prob</code></td>
<td>
<p>probability - threshold to apply to overlapping quantiles,
defaults to 0.8</p>
</td></tr>
<tr><td><code id="initialize.x_+3A_winoffset">winoffset</code></td>
<td>
<p>an odd-numbered window size to use when intersecting
subseqent segments - defaults to 5</p>
</td></tr>


<tr><td><code id="initialize.x_+3A_chain">chain</code></td>
<td>
<p> chain object from estimation </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_day">day</code></td>
<td>
<p> POSIXct vector of date-times </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_seg">seg</code></td>
<td>
<p> desired segment </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_probl">probl</code></td>
<td>
<p> probability level for quantile </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_start">start</code></td>
<td>
<p>known position of release  </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_end">end</code></td>
<td>
<p>known position of recapture </p>
</td></tr>

<tr><td><code id="initialize.x_+3A_segment">segment</code></td>
<td>
<p> vector of segment data </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_light">light</code></td>
<td>
<p> vector of light data </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_k">k</code></td>
<td>
<p> desired segment to show </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_n">n</code></td>
<td>
<p> length of vector to evaluate  </p>
</td></tr>
<tr><td><code id="initialize.x_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The primary function here is <code>position.logp</code>, for
initializing the estimation for <code><a href="#topic+solar.model">solar.model</a></code> and
<code><a href="#topic+metropolis0">metropolis0</a></code>.  </p>


<h3>Value</h3>

<p><code>initialize.x</code> returns a matrix with 3 columns, lon,lat,attenuation
<code>position.logp</code> returns a list with model running components
<code>show.segment</code> is used for its side effect, a plot of light level for a twilight segment
<code>light.quantile</code> returns a numeric vector
</p>


<h3>Author(s)</h3>

<p>Michael D. Sumner </p>

<hr>
<h2 id='julday'> Julian day and Julian century calculations from date-time values </h2><span id='topic+julday'></span><span id='topic+julcent'></span>

<h3>Description</h3>

<p>Date values required by <code><a href="#topic+solar">solar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>julday(tm)

julcent(time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="julday_+3A_tm">tm</code></td>
<td>
<p> vector of date-times </p>
</td></tr>
<tr><td><code id="julday_+3A_time">time</code></td>
<td>
<p> vector of date-times </p>
</td></tr>
</table>


<h3>Value</h3>

<p>return numeric values
</p>


<h3>Author(s)</h3>

<p> Michael D. Sumner </p>


<h3>References</h3>

<p><a href="https://gml.noaa.gov/grad/solcalc/azel.html">https://gml.noaa.gov/grad/solcalc/azel.html</a></p>

<hr>
<h2 id='metropolis'> Metropolis-Hastings sampler for location estimation for archival and satellite tag </h2><span id='topic+metropolis'></span><span id='topic+metropolis0'></span>

<h3>Description</h3>

<p>These functions provide a direct implementation of the Metropolis-Hastings algorithm, for
calculating marginal posterior (locations and full-track estimates)
properties using Markov Chain Monte Carlo. The
sampler is written completely in <span class="rlang"><b>R</b></span>, vectorized to be as fast as possible. The sampler can
include likelihood functions for large data records (including light and water temperature), as
well as <em>mask</em> functions for simpler rejection sources. Behavioural constraints are
implemented using a red/black update, so that location estimates <em>X</em> and <em>Z</em> may
be estimated in an efficient manner. The parameter estimates may be cached and later
queried arbitrarily.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metropolis(model, iters = 1000, thin = 10, start.x = NULL, start.z = NULL)

metropolis0(model, iters = 1000, thin = 10, start.x = NULL, start.z =
NULL)


</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="metropolis_+3A_model">model</code></td>
<td>
<p> model for estimation, such as one created by <code><a href="#topic+solar.model">solar.model</a></code> </p>
</td></tr>
<tr><td><code id="metropolis_+3A_iters">iters</code></td>
<td>
<p> number of iterations to run</p>
</td></tr>
<tr><td><code id="metropolis_+3A_thin">thin</code></td>
<td>
<p> number of iterations to thin by </p>
</td></tr>
<tr><td><code id="metropolis_+3A_start.x">start.x</code></td>
<td>
<p> starting points for the primary locations  </p>
</td></tr>
<tr><td><code id="metropolis_+3A_start.z">start.z</code></td>
<td>
<p> starting points for the intermediate locations
(midpoints between the <code>start.x</code> points is a good first guess </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+metropolis0">metropolis0</a></code> is a slightly different version of <code><a href="#topic+metropolis">metropolis</a></code>
that enables an initialization step, required to find parameter estimates that are
consistent with any masks used. It is difficult to make this step more elegant, and so
we live with the two versions.
</p>
<p>In terms of the estimates, X's have <code>m</code> records with <code>n</code> parameters, where <code>m</code>
is the number of data records in time (twilights for archival tags, Argos estimates for satellite
tags) and <code>n</code> is at least x-coordinate, y-coordinate and maybe k-attenuation for light.
Z's have <code>m-1</code> records with 2 parameters for 'x' and 'y' (which are usually Longitude and
Latitude). These parameters may be increased or changed, they are tied only to the likelihood
functions used, not the sampler itself. Also, coordinate transformations may be used inside the model
and likelihood functions, in order to use an appropriate map projection. Solar calculations rely on
lon/lat and so this step does slow down light level geo-location.
</p>


<h3>Value</h3>

<p>A MCM <em>Chain</em> stored as a list containing
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>The model object used by the sampler</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The last <code>iters</code> X-samples accepted, stored as an <code>c(m, n, iters)</code> array </p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>The last <code>iters</code> Z-samples accepted, stored as an <code>c(m - 1, 2, iters)</code></p>
</td></tr>
<tr><td><code>last.x</code></td>
<td>
<p>The last accepted X-sample, stored as a <code>c(m, n)</code> matrix</p>
</td></tr>
<tr><td><code>last.z</code></td>
<td>
<p>The last accepted Z-sample, stored as a <code>c(m, 2)</code> matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Michael D. Sumner and Simon Wotherspoon</p>


<h3>References</h3>

<p>Sumner, Wotherspoon and Hindell (2009). Bayesian Estimation of Animal Movement from Archival and Satellite Tags, PLoS ONE. <a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0007324">https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0007324</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+solar.model">solar.model</a></code>, <code><a href="#topic+satellite.model">satellite.model</a></code> </p>

<hr>
<h2 id='mkCalibration'>Create calibration of solar elevation to measured light level.</h2><span id='topic+mkCalibration'></span>

<h3>Description</h3>

<p>Using a set of light level data from a known location create a calibration
function to return the expected light level given solar elevation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkCalibration(x, known = NULL, elim = c(-36, 12), choose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkCalibration_+3A_x">x</code></td>
<td>
<p> a data frame containing at least <code>gmt</code> and <code>light</code></p>
</td></tr>
<tr><td><code id="mkCalibration_+3A_known">known</code></td>
<td>
<p> a known position - as a 2-element <code>c(x, y)</code> coordinate </p>
</td></tr>
<tr><td><code id="mkCalibration_+3A_elim">elim</code></td>
<td>
<p> a 2-element vector of the range of solar elevation to define </p>
</td></tr>
<tr><td><code id="mkCalibration_+3A_choose">choose</code></td>
<td>
<p> logical -  choose segments from a plot or use all the data?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that the data frame <code>x</code> has columns &quot;gmt&quot; with POSIXct
date-times and &quot;light&quot; with numeric light level data. 
</p>


<h3>Value</h3>

<p>A function, defined by <code>approxfun</code>. 
</p>


<h3>Author(s)</h3>

<p> Michael D. Sumner</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+approxfun">approxfun</a></code> </p>

<hr>
<h2 id='mkLookup'> Create a lookup function to query locations against spatial masks</h2><span id='topic+mkLookup'></span>

<h3>Description</h3>

<p>Simple pixel spacing is used to overlay point locations on a spatial grid, or
a series of grids. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkLookup(x, by.segment = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkLookup_+3A_x">x</code></td>
<td>
<p> an xyz-list with matrix or array of masks </p>
</td></tr>
<tr><td><code id="mkLookup_+3A_by.segment">by.segment</code></td>
<td>
<p>logical - is the mask to be queried separately for each time step? </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function, with one argument - a matrix of points - that returns a logical
vector indicating the overlay of each point against the masks. 
</p>


<h3>Note</h3>

 
<p>Very little error checking is done.
</p>


<h3>Author(s)</h3>

<p> Michael D. Sumner</p>


<h3>See Also</h3>

 <p><code><a href="#topic+get.mask">get.mask</a></code> and related examples for creating and using 
masks. 
</p>
<p>See <code><a href="sp.html#topic+over">over</a></code>  for more general capabilities for overlays. </p>

<hr>
<h2 id='norm.proposal'>Manage proposal functions tune variance for metropolis sampler</h2><span id='topic+norm.proposal'></span><span id='topic+mvnorm.proposal'></span><span id='topic+bmvnorm.proposal'></span>

<h3>Description</h3>

<p>Generate new proposals for the x from the current. Generates all x at once.</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm.proposal(m, n, sigma)

mvnorm.proposal(m, n, Sigma)

bmvnorm.proposal(m, n, Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm.proposal_+3A_m">m</code></td>
<td>
<p> number of records </p>
</td></tr>
<tr><td><code id="norm.proposal_+3A_n">n</code></td>
<td>
<p> number of parameters</p>
</td></tr>
<tr><td><code id="norm.proposal_+3A_sigma">sigma</code></td>
<td>
<p> variance </p>
</td></tr>
<tr><td><code id="norm.proposal_+3A_sigma">Sigma</code></td>
<td>
<p> variance </p>
</td></tr>
</table>


<h3>Details</h3>

<p>norm.proposal - Independent Normal proposal - every component is independent, with
variances of individual components determined by sigma.  The
recycling rule applies to sigma, so sigma may be a scalar, an m
vector or a m by n matrix.
</p>
<p>mvnorm.proposal - Multivariate Normal proposal - all components of all points are
correlated.  In this case Sigma is the joint covariance of the m*n
components of the proposal points.
</p>
<p>bmvnorm.proposal - Block Multivariate Normal proposal - components of points are
correlated, but points are independent. Here Sigma is an array of m
covariance matrices that determine the covariance of the m proposal
points.
</p>


<h3>Value</h3>

<p>An list object with get, set and tune functions to manage the state of the proposals. 
</p>
<table>
<tr><td><code>proposal</code></td>
<td>
<p>propose new set of parameters from last</p>
</td></tr>
<tr><td><code>get</code></td>
<td>
<p>get variance values </p>
</td></tr>
<tr><td><code>set</code></td>
<td>
<p>set variance values</p>
</td></tr>
<tr><td><code>tune</code></td>
<td>
<p>tune the variance for proposal functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Simon Wotherspoon </p>

<hr>
<h2 id='old.metropolis'>Older versions of solar location estimation</h2><span id='topic+old.metropolis'></span><span id='topic+old.dist.gc'></span><span id='topic+old.find.init'></span><span id='topic+old.mkLookup'></span><span id='topic+mkElevationSeg'></span><span id='topic+mkNLPosterior'></span><span id='topic+k.prior'></span>

<h3>Description</h3>

<p>Some deprecated functions, originally used purely for light level estimation before
the sampling algorithm was generalized for satellite models as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkElevationSeg(segments, day)

mkNLPosterior(segments, day, light, calib)

old.dist.gc(x1, x2 = NULL)

old.find.init(mask, nseg, nlpost, pars = c("Lon", "Lat", "k"))

old.metropolis(nlpost, lookup, p0, cov0, start, end, iter = 1000, step = 100)

old.mkLookup(x, binArray = TRUE)

k.prior(seg, ps)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="old.metropolis_+3A_segments">segments</code></td>
<td>
<p> vector identifying the segment of each time and light
value</p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_day">day</code></td>
<td>
<p> date-time values in POSIXct </p>
</td></tr>

<tr><td><code id="old.metropolis_+3A_light">light</code></td>
<td>
<p>vector of light data </p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_calib">calib</code></td>
<td>
<p>calibration function for light levels</p>
</td></tr>


<tr><td><code id="old.metropolis_+3A_x1">x1</code></td>
<td>
<p>matrix of track locations</p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_x2">x2</code></td>
<td>
<p> matrix of track locations (optional second part) </p>
</td></tr>

<tr><td><code id="old.metropolis_+3A_mask">mask</code></td>
<td>
<p> image object of masked areas </p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_nseg">nseg</code></td>
<td>
<p> number of (twilight) segments </p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_nlpost">nlpost</code></td>
<td>
<p> negative log posterior function</p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_pars">pars</code></td>
<td>
<p> names of parameters </p>
</td></tr>

<tr><td><code id="old.metropolis_+3A_lookup">lookup</code></td>
<td>
<p> lookup function for masked areas </p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_p0">p0</code></td>
<td>
<p> initial locations for sampler </p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_cov0">cov0</code></td>
<td>
<p> covariance matrix for sampler </p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_start">start</code></td>
<td>
<p> known start parameters</p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_end">end</code></td>
<td>
<p> known end parameters</p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_iter">iter</code></td>
<td>
<p> number of iterations </p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_step">step</code></td>
<td>
<p> number of thinning iterations per <code>iter</code></p>
</td></tr>

<tr><td><code id="old.metropolis_+3A_x">x</code></td>
<td>
<p> image-like object of matrix or array of binary masks </p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_binarray">binArray</code></td>
<td>
<p> logical: are the masks compressed into bits? </p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_seg">seg</code></td>
<td>
<p> segment </p>
</td></tr>
<tr><td><code id="old.metropolis_+3A_ps">ps</code></td>
<td>
<p> light attenuation value  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are included for legacy purposes, this was the
original implementation. 
</p>


<h3>Value</h3>

<p>If it is a LIST, use
</p>


<h3>Author(s)</h3>

<p>Michael D. Sumner</p>


<h3>See Also</h3>

<p> Please use the more up to date function
<code><a href="#topic+metropolis">metropolis</a></code>, with the models such as
<code><a href="#topic+solar.model">solar.model</a></code> or <code><a href="#topic+satellite.model">satellite.model</a></code>.  </p>

<hr>
<h2 id='pick'>Choose twilight segments interactively from light data. </h2><span id='topic+pick'></span><span id='topic+picksegs'></span>

<h3>Description</h3>

<p><code>pick</code> plots up series of light data agains record ID, allowing the user to click on the
beginnings and ends of twilight in sequence. <code>picksegs</code> generates a vector
of segment IDs for each record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick(id, val, nsee = 10000)

picksegs(twind, n)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="pick_+3A_id">id</code></td>
<td>
<p>index vector to identify records</p>
</td></tr>
<tr><td><code id="pick_+3A_val">val</code></td>
<td>
<p> sequence of data (light levels) to choose segments from</p>
</td></tr>
<tr><td><code id="pick_+3A_nsee">nsee</code></td>
<td>
<p> number of points to plot per screen </p>
</td></tr>

<tr><td><code id="pick_+3A_twind">twind</code></td>
<td>
<p> vector of index pairs generated by <code>pick</code></p>
</td></tr>
<tr><td><code id="pick_+3A_n">n</code></td>
<td>
<p>Number of segments values required - length of record</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pick</code> returns a vector where each value (obtained using <code><a href="graphics.html#topic+locator">locator</a></code>
is the x coordinate for the begin or end of a twilight.
</p>
<p><code>picksegs</code> uses these paired indexes to return a vector of segment IDs, with NAs
for non-twilight periods.
</p>


<h3>Warning </h3>

<p>Segments are expected to be chosen as non-overlapping. </p>


<h3>Note</h3>

<p> It seems best to choose more of the light data than less, using the
<code>ekstrom</code> keyword to <code><a href="#topic+solar.model">solar.model</a></code> we can limit the solar
elevation used.
</p>


<h3>Author(s)</h3>

<p> Michael D. Sumner </p>


<h3>Examples</h3>

<pre><code class='language-R'> d &lt;- sin(seq(0, 10, by = 0.01))
 id &lt;- 1:length(d)
 ## choose a series of start-begin pairs
 if (interactive()) {
 pk &lt;- pick(id, d, 1000)
 ## your start/ends should be marked as blue versus red
 plot(id, d, col = c("red", "blue")[is.na(picksegs(pk, 1000))+1])
 }
</code></pre>

<hr>
<h2 id='pimg.list'>Create a collection of probability images, for MCMC binning. </h2><span id='topic+pimg.list'></span><span id='topic+pimg'></span>

<h3>Description</h3>

<p>Pimage lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pimg(xmin, xmax, xn, ymin, ymax, yn)
pimg.list(times, xlim, ylim, img.dim, Z = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pimg.list_+3A_xmin">xmin</code></td>
<td>
  <p><code>xmin</code>  </p>
</td></tr>
<tr><td><code id="pimg.list_+3A_xmax">xmax</code></td>
<td>
  <p><code>xmax</code>  </p>
</td></tr>
<tr><td><code id="pimg.list_+3A_xn">xn</code></td>
<td>
  <p><code>xn</code>  </p>
</td></tr>
<tr><td><code id="pimg.list_+3A_ymin">ymin</code></td>
<td>
  <p><code>ymin</code>  </p>
</td></tr>
<tr><td><code id="pimg.list_+3A_ymax">ymax</code></td>
<td>
  <p><code>ymax</code>  </p>
</td></tr>
<tr><td><code id="pimg.list_+3A_yn">yn</code></td>
<td>
  <p><code>yn</code>  </p>
</td></tr>
<tr><td><code id="pimg.list_+3A_times">times</code></td>
<td>
  <p><code>times</code>  </p>
</td></tr>
<tr><td><code id="pimg.list_+3A_xlim">xlim</code></td>
<td>
  <p><code>xlim</code>  </p>
</td></tr>
<tr><td><code id="pimg.list_+3A_ylim">ylim</code></td>
<td>
  <p><code>ylim</code>  </p>
</td></tr>
<tr><td><code id="pimg.list_+3A_img.dim">img.dim</code></td>
<td>
  <p><code>img.dim</code>  </p>
</td></tr>
<tr><td><code id="pimg.list_+3A_z">Z</code></td>
<td>
  <p><code>Z</code>  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a Pimage list
</p>

<hr>
<h2 id='satellite.model'> Function to create a satellite model object for metropolis location sampler </h2><span id='topic+satellite.model'></span>

<h3>Description</h3>

<p>A model to manage likelihood functions, environmental masks and behavioural
likelihood functions for pre-derived satellite locations. There are some options for configuration,
but this
may be considered a template for any given model. The model <em>function</em> exists
simply to make the object construction simple.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="satellite.model_+3A_day">day</code></td>
<td>
<p> vector of date-times for each light level </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_x">X</code></td>
<td>
<p> matrix of pre-derived satellite locations </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_proposal.x">proposal.x</code></td>
<td>
<p> function from object managing X proposals </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_proposal.z">proposal.z</code></td>
<td>
<p> function from object managing Z proposals </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_mask.x">mask.x</code></td>
<td>
<p> lookup function for X's against masks </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_mask.z">mask.z</code></td>
<td>
<p> lookup function for Z's against masks </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_fix.release">fix.release</code></td>
<td>
<p> logical - is the release point known? </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_fix.recapture">fix.recapture</code></td>
<td>
<p> logical - is the recapture point known? </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_start.x">start.x</code></td>
<td>
<p> starting positions for the primary locations, see <code><a href="#topic+position.logp">position.logp</a></code> </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_start.z">start.z</code></td>
<td>
<p> starting positions for the intermediat locations. </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_posn.sigma">posn.sigma</code></td>
<td>
<p> variance for locations </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_behav.dist">behav.dist</code></td>
<td>
<p> distribution to use for behavioural constraint </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_behav.mean">behav.mean</code></td>
<td>
<p> mean to use for behavioural distribution </p>
</td></tr>
<tr><td><code id="satellite.model_+3A_behav.sd">behav.sd</code></td>
<td>
<p> variance for behavioural distribution</p>
</td></tr>
<tr><td><code id="satellite.model_+3A_proj.string">proj.string</code></td>
<td>
<p> PROJ.4 string for coordinate system used </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>posn.sigma</code> may be a single value for all estimates, or a vector of values for each position
estimate.
</p>
<p>Transformation of coordinates is supported via a simple function that
only performs coordinate transforms if <code>proj.string</code> is not
longlat.
</p>


<h3>Value</h3>

<p> See <code>solar.model</code> for some related detail.  </p>


<h3>Note</h3>

<p>These are simple wrapper functions to create the desired model for use
in <code><a href="#topic+metropolis">metropolis</a></code>. These models are structurally very simple
and may be easily edited as required.  </p>


<h3>Author(s)</h3>

<p> Michael D. Sumner </p>


<h3>References</h3>

<p>Sumner, Wotherspoon and Hindell (2009). Bayesian Estimation of Animal Movement from Archival and Satellite Tags, PLoS ONE. <a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0007324">https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0007324</a></p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+solar.model">solar.model</a></code> for the counterpart model
for estimating positions for light tags. </p>

<hr>
<h2 id='solar'> Calculate solar postion parameters</h2><span id='topic+solar'></span>

<h3>Description</h3>

<p>Pre-calculates astronomical solar position components for
Earth-location sampling functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solar(day)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solar_+3A_day">day</code></td>
<td>
<p> vector of date-time values </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the following values for each input time:
</p>
<table>
<tr><td><code>solarTime</code></td>
<td>
<p>solar time</p>
</td></tr>
<tr><td><code>sinSolarDec</code></td>
<td>
<p>sine solar declination</p>
</td></tr>
<tr><td><code>cosSolarDec</code></td>
<td>
<p>cosine solar declination</p>
</td></tr>
</table>


<h3>Note</h3>

<p>No account is made for horizon refraction, but this was available in the original
(Javascript) code.
</p>


<h3>Author(s)</h3>

<p> Michael D. Sumner </p>


<h3>References</h3>

 <p><a href="https://gml.noaa.gov/grad/solcalc/azel.html">https://gml.noaa.gov/grad/solcalc/azel.html</a></p>

<hr>
<h2 id='solar.model'> Function to create a solar model object for metropolis location sampler </h2><span id='topic+solar.model'></span>

<h3>Description</h3>

<p>A solar model to manage likelihood functions, environmental masks and behavioural
likelihood functions. There are several options for configuring the model, and this
may be considered a template for any given model. The model <em>function</em> exists
simply to make the object construction simple.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solar.model(segments, day, light,
	proposal.x, proposal.z, mask.x, mask.z,
	fix.release = TRUE, fix.recapture = TRUE,
	calibration,
	light.sigma = 7, k.sigma = 10,
	behav = "speed", behav.dist = "gamma",
	behav.mean, behav.sd,
	proj.string = "+proj=longlat",
   ekstrom = c(-5, 3, light.sigma),
         ekstrom.limit = "light")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solar.model_+3A_segments">segments</code></td>
<td>
<p> vector identifying twilight segment</p>
</td></tr>
<tr><td><code id="solar.model_+3A_day">day</code></td>
<td>
<p> vector of date-times for each light level</p>
</td></tr>
<tr><td><code id="solar.model_+3A_light">light</code></td>
<td>
<p> vector of light levels </p>
</td></tr>
<tr><td><code id="solar.model_+3A_proposal.x">proposal.x</code></td>
<td>
<p> function from object managing X proposals </p>
</td></tr>
<tr><td><code id="solar.model_+3A_proposal.z">proposal.z</code></td>
<td>
<p> function from object managing Z proposals </p>
</td></tr>
<tr><td><code id="solar.model_+3A_mask.x">mask.x</code></td>
<td>
<p> lookup function for X's against masks </p>
</td></tr>
<tr><td><code id="solar.model_+3A_mask.z">mask.z</code></td>
<td>
<p> lookup function for Z's against masks </p>
</td></tr>
<tr><td><code id="solar.model_+3A_fix.release">fix.release</code></td>
<td>
<p> logical - is the release point known? </p>
</td></tr>
<tr><td><code id="solar.model_+3A_fix.recapture">fix.recapture</code></td>
<td>
<p> logical - is the recapture point known? </p>
</td></tr>
<tr><td><code id="solar.model_+3A_calibration">calibration</code></td>
<td>
<p> calibration function for predicted light level for solar elevation</p>
</td></tr>
<tr><td><code id="solar.model_+3A_light.sigma">light.sigma</code></td>
<td>
<p> variance for light data </p>
</td></tr>
<tr><td><code id="solar.model_+3A_k.sigma">k.sigma</code></td>
<td>
<p> variance for light attenuation </p>
</td></tr>
<tr><td><code id="solar.model_+3A_behav">behav</code></td>
<td>
<p> model distributions to be used for behaviour - defaults to &quot;speed&quot;</p>
</td></tr>
<tr><td><code id="solar.model_+3A_behav.dist">behav.dist</code></td>
<td>
<p> distribution to be used for behaviour </p>
</td></tr>
<tr><td><code id="solar.model_+3A_behav.mean">behav.mean</code></td>
<td>
<p> mean for behavioural distribution </p>
</td></tr>
<tr><td><code id="solar.model_+3A_behav.sd">behav.sd</code></td>
<td>
<p> variance for behavioural distribution </p>
</td></tr>
<tr><td><code id="solar.model_+3A_proj.string">proj.string</code></td>
<td>
<p> PROJ.4 string for coordinate system used </p>
</td></tr>
<tr><td><code id="solar.model_+3A_ekstrom">ekstrom</code></td>
<td>
<p> parameters to use for ekstrom limit - min elevation, max elevation, sigma for outside that range </p>
</td></tr>
<tr><td><code id="solar.model_+3A_ekstrom.limit">ekstrom.limit</code></td>
<td>
<p> mode of ekstrom limit to impose - defaults to &quot;light&quot; </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vectors of <code>segments</code>, <code>day</code> and <code>light</code> are expected to
be of the same length.
</p>
<p>Fixed recapture and release points are treated specially for ease of sampling, but
the sampling is written to be general for any fixed locations.
</p>
<p>Behavioural models may be specified either as lognormal or log-gamma. By editing the
function created as <code>logp.behavioural</code> this may be specified differently.
</p>
<p>Transformation of coordinates is supported via a simple function that only performs coordinate
transforms if <code>proj.string</code> is not longlat.
</p>


<h3>Value</h3>

<p>proposal.x(x) - generates new proposals for the x from the current
x.  Generates all x at once.
</p>
<p>proposal.z(z) - generates new proposals for the x from the current
z.  Generates all z at once.
</p>
<p>mask.x(x) - mask function for the x. Simultaneously tests all x and
returns a vector of booleans indicating which are acceptable.
</p>
<p>mask.z(z) - mask function for the z. Simultaneously tests all z and
returns a vector of booleans indicating which are acceptable.
</p>
<p>logp.position(x) - Given the set of x, returns a vector that gives
the contribution each x make to the log posterior based on position
alone.
</p>
<p>logp.behavourial(k,xa,z,xb) - Computes the contribution to the log
posterior from the behavioural model on a subset of segments that
make up the path.  Here k is a vector of the segment numbers, where
the segments pass from xa to z to xb, and the function returns the
contribution to the log posterior from each segment. This is the
only function expected to work with only a subset of the x and z.
</p>
<p>start.x - suggested starting points for the x
</p>
<p>start.z - suggested starting points for the z
</p>
<p>The only function that must operate on a subset of the x/z is
logp.behavourial.  All the other functions operate on all x or z
simultaneously, simplifying the implementation for the user.
</p>
<p>Note that x can consist of several parameters, not just the
locations, but we assume the first two components of each x specify
the location.  For example, in the light level models each x is
(lon,lat,k) where k is the attenuation of the light level.
</p>
<p>Some details of this implementation are not as nice as they could
be.  First, it would be better if did not calculate the
contributions to the posterior for points the mask rejects. Also,
it may be better to separate the specification of the functions
that generate proposals from the other functions, so that we can
tune the proposal distributions without re-generating the whole
model specification.
</p>


<h3>Author(s)</h3>

<p> Simon Wotherspoon and Michael Sumner</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
