<!DOCTYPE html><html><head><title>Help for package bnpsd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bnpsd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bnpsd'><p>A package for modeling and simulating an admixed population</p></a></li>
<li><a href='#admix_prop_1d_circular'><p>Construct admixture proportion matrix for circular 1D geography</p></a></li>
<li><a href='#admix_prop_1d_linear'><p>Construct admixture proportion matrix for 1D geography</p></a></li>
<li><a href='#admix_prop_indep_subpops'><p>Construct admixture proportion matrix for independent subpopulations</p></a></li>
<li><a href='#coanc_admix'><p>Construct the coancestry matrix of an admixture model</p></a></li>
<li><a href='#coanc_to_kinship'><p>Transform coancestry matrix to kinship matrix</p></a></li>
<li><a href='#coanc_tree'><p>Calculate coancestry matrix corresponding to a tree</p></a></li>
<li><a href='#draw_all_admix'><p>Simulate random allele frequencies and genotypes from the BN-PSD admixture model</p></a></li>
<li><a href='#draw_genotypes_admix'><p>Draw genotypes from the admixture model</p></a></li>
<li><a href='#draw_p_anc'><p>Draw random Uniform or Beta ancestral allele frequencies</p></a></li>
<li><a href='#draw_p_subpops'><p>Draw allele frequencies for independent subpopulations</p></a></li>
<li><a href='#draw_p_subpops_tree'><p>Draw allele frequencies for subpopulations related by a tree</p></a></li>
<li><a href='#fit_tree'><p>Fit a tree structure to a coancestry matrix</p></a></li>
<li><a href='#fixed_loci'><p>Identify fixed loci</p></a></li>
<li><a href='#fst_admix'><p>Calculate FST for the admixed individuals</p></a></li>
<li><a href='#make_p_ind_admix'><p>Construct individual-specific allele frequency matrix under the PSD admixture model</p></a></li>
<li><a href='#scale_tree'><p>Scale a coancestry tree</p></a></li>
<li><a href='#tree_additive'><p>Calculate additive edges for a coancestry tree, or viceversa</p></a></li>
<li><a href='#tree_reindex_tips'><p>Reindex tree tips in order of appearance in edges</p></a></li>
<li><a href='#tree_reorder'><p>Reorder tree tips to best match a desired order</p></a></li>
<li><a href='#undiff_af'><p>Undifferentiate an allele distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulate Genotypes from the BN-PSD Admixture Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.13</td>
</tr>
<tr>
<td>Description:</td>
<td>The Pritchard-Stephens-Donnelly (PSD) admixture model has k intermediate subpopulations from which n individuals draw their alleles dictated by their individual-specific admixture proportions.  The BN-PSD model additionally imposes the Balding-Nichols (BN) allele frequency model to the intermediate populations, which therefore evolved independently from a common ancestral population T with subpopulation-specific FST (Wright's fixation index) parameters.  The BN-PSD model can be used to yield complex population structures.  This simulation approach is now extended to subpopulations related by a tree.  Method described in Ochoa and Storey (2021) &lt;<a href="https://doi.org/10.1371%2Fjournal.pgen.1009241">doi:10.1371/journal.pgen.1009241</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ape, nnls</td>
</tr>
<tr>
<td>Suggests:</td>
<td>popkin (&ge; 1.3.9), testthat, knitr, rmarkdown, RColorBrewer</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/StoreyLab/bnpsd/">https://github.com/StoreyLab/bnpsd/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/StoreyLab/bnpsd/issues">https://github.com/StoreyLab/bnpsd/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-23 13:54:05 UTC; viiia</td>
</tr>
<tr>
<td>Author:</td>
<td>Alejandro Ochoa <a href="https://orcid.org/0000-0003-4928-3403"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  John D. Storey <a href="https://orcid.org/0000-0001-5992-402X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alejandro Ochoa &lt;alejandro.ochoa@duke.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-25 12:50:26 UTC</td>
</tr>
</table>
<hr>
<h2 id='bnpsd'>A package for modeling and simulating an admixed population</h2><span id='topic+bnpsd'></span><span id='topic+bnpsd-package'></span>

<h3>Description</h3>

<p>The underlying model is called the BN-PSD admixture model, which combines the Balding-Nichols (BN) allele frequency model for the intermediate subpopulations with the Pritchard-Stephens-Donnelly (PSD) model of individual-specific admixture proportions.
The BN-PSD model enables the simulation of complex population structures, ideal for illustrating challenges in kinship coefficient and FST estimation.
Simulated loci are drawn independently (in linkage equilibrium).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alejandro Ochoa <a href="mailto:alejandro.ochoa@duke.edu">alejandro.ochoa@duke.edu</a> (<a href="https://orcid.org/0000-0003-4928-3403">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> John D. Storey <a href="mailto:jstorey@princeton.edu">jstorey@princeton.edu</a> (<a href="https://orcid.org/0000-0001-5992-402X">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/StoreyLab/bnpsd/">https://github.com/StoreyLab/bnpsd/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/StoreyLab/bnpsd/issues">https://github.com/StoreyLab/bnpsd/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># dimensions of data/model
# number of loci
m_loci &lt;- 10
# number of individuals
n_ind &lt;- 5
# number of intermediate subpops
k_subpops &lt;- 2

# define population structure
# FST values for k = 2 subpopulations
inbr_subpops &lt;- c( 0.1, 0.3 )
# admixture proportions from 1D geography
admix_proportions &lt;- admix_prop_1d_linear( n_ind, k_subpops, sigma = 1 )
# also available:
# - admix_prop_1d_circular
# - admix_prop_indep_subpops

# get pop structure parameters of the admixed individuals
# the coancestry matrix
coancestry &lt;- coanc_admix( admix_proportions, inbr_subpops )
# FST of admixed individuals
Fst &lt;- fst_admix( admix_proportions, inbr_subpops )

# draw all random allele freqs and genotypes
out &lt;- draw_all_admix( admix_proportions, inbr_subpops, m_loci )
# genotypes
X &lt;- out$X
# ancestral allele frequencies (AFs)
p_anc &lt;- out$p_anc

# OR... draw each vector or matrix separately
# provided for additional flexibility
# ancestral AFs
p_anc &lt;- draw_p_anc( m_loci )
# independent subpops (intermediate) AFs
p_subpops &lt;- draw_p_subpops( p_anc, inbr_subpops )
# individual-specific AFs
p_ind &lt;- make_p_ind_admix( p_subpops, admix_proportions )
# genotypes
X &lt;- draw_genotypes_admix( p_ind )

### Examples with a tree for intermediate subpopulations

# tree allows for correlated subpopulations
# (prev examples had independent subpopulations)

# best to start by specifying tree in Newick string format
tree_str &lt;- '(S1:0.1,(S2:0.1,S3:0.1)N1:0.1)T;'
# and turn it into `phylo` object using the `ape` package
library(ape)
tree_subpops &lt;- read.tree( text = tree_str )
# true coancestry matrix corresponding to this tree
coanc_subpops &lt;- coanc_tree( tree_subpops )

# admixture proportions from 1D geography
# (constructed again but for k=3 tree)
k_subpops &lt;- nrow( coanc_subpops )
admix_proportions &lt;- admix_prop_1d_linear( n_ind, k_subpops, sigma = 0.5 )

# get pop structure parameters of the admixed individuals
# the coancestry matrix
coancestry &lt;- coanc_admix( admix_proportions, coanc_subpops )
# FST of admixed individuals
Fst &lt;- fst_admix( admix_proportions, coanc_subpops )

# draw all random allele freqs and genotypes, tree version
out &lt;- draw_all_admix( admix_proportions, tree_subpops = tree_subpops, m_loci = m_loci )
# genotypes
X &lt;- out$X
# ancestral allele frequencies (AFs)
p_anc &lt;- out$p_anc

# OR... draw tree subpops (intermediate) AFs separately
p_subpops_tree &lt;- draw_p_subpops_tree( p_anc, tree_subpops )

</code></pre>

<hr>
<h2 id='admix_prop_1d_circular'>Construct admixture proportion matrix for circular 1D geography</h2><span id='topic+admix_prop_1d_circular'></span>

<h3>Description</h3>

<p>Assumes <code>k_subpops</code> intermediate subpopulations placed along a circumference (the [<code>0</code>, <code>2 * pi</code>] line that wraps around) with even spacing spread by random walks (see details below), then <code>n_ind</code> individuals sampled equally spaced in [<code>coord_ind_first</code>,<code>coord_ind_last</code>] (default [<code>0</code>, <code>2 * pi</code>] with a small gap so first and last individual do not overlap) draw their admixture proportions relative to the Von Mises density that models the random walks of each of these intermediate subpopulations.
The spread of the random walks is <code>sigma = 1 / sqrt(kappa)</code> of the Von Mises density.
If <code>sigma</code> is missing, it can be set indirectly by providing three variables: (1) the desired bias coefficient <code>bias_coeff</code>, (2) the coancestry matrix of the intermediate subpopulations <code>coanc_subpops</code> (up to a scalar factor), and (3) the final <code>fst</code> of the admixed individuals (see details below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_prop_1d_circular(
  n_ind,
  k_subpops,
  sigma = NA,
  coord_ind_first = 2 * pi/(2 * n_ind),
  coord_ind_last = 2 * pi * (1 - 1/(2 * n_ind)),
  bias_coeff = NA,
  coanc_subpops = NULL,
  fst = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="admix_prop_1d_circular_+3A_n_ind">n_ind</code></td>
<td>
<p>Number of individuals</p>
</td></tr>
<tr><td><code id="admix_prop_1d_circular_+3A_k_subpops">k_subpops</code></td>
<td>
<p>Number of intermediate subpopulations</p>
</td></tr>
<tr><td><code id="admix_prop_1d_circular_+3A_sigma">sigma</code></td>
<td>
<p>Spread of intermediate subpopulations (approximate standard deviation of Von Mises densities, see above)
The edge cases <code>sigma = 0</code> and <code>sigma = Inf</code> are handled appropriately!</p>
</td></tr>
<tr><td><code id="admix_prop_1d_circular_+3A_coord_ind_first">coord_ind_first</code></td>
<td>
<p>Location of first individual</p>
</td></tr>
<tr><td><code id="admix_prop_1d_circular_+3A_coord_ind_last">coord_ind_last</code></td>
<td>
<p>Location of last individual
</p>
<p>OPTIONS FOR BIAS COEFFICIENT VERSION</p>
</td></tr>
<tr><td><code id="admix_prop_1d_circular_+3A_bias_coeff">bias_coeff</code></td>
<td>
<p>If <code>sigma</code> is <code>NA</code>, this bias coefficient is required.</p>
</td></tr>
<tr><td><code id="admix_prop_1d_circular_+3A_coanc_subpops">coanc_subpops</code></td>
<td>
<p>If <code>sigma</code> is <code>NA</code>, this intermediate subpops coancestry is required.
It can be provided as a <code>k_subpops</code>-by-<code>k_subpops</code> matrix, a length-<code>k_subpops</code> population inbreeding vector (for independent subpopulations, where between-subpop coancestries are zero) or scalar (if population inbreeding values are all equal and coancestries are zero).
This <code>coanc_subpops</code> can be in the wrong scale (it cancels out in calculations), which is returned corrected, to result in the desired <code>fst</code> (next).</p>
</td></tr>
<tr><td><code id="admix_prop_1d_circular_+3A_fst">fst</code></td>
<td>
<p>If <code>sigma</code> is <code>NA</code>, this FST of the admixed individuals is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assuming the full range of [<code>0</code>, <code>2 * pi</code>] is considered, and the first and last individuals do not overlap, the gap between individuals is <code>delta = 2 * pi / n</code>.
To not have any individuals on the edge, we place the first individual at <code>delta / 2</code> and the last at <code>2 * pi - delta / 2</code>.
The location of subpopulation <code>j</code> is <code>delta / 2 + ( j - 1/2 ) / k * (2 * pi - delta)</code>, chosen to agree with the default correspondence between individuals and subpopulations of the linear 1D geography admixture scenario (<code><a href="#topic+admix_prop_1d_linear">admix_prop_1d_linear()</a></code>).
</p>
<p>If <code>sigma</code> is <code>NA</code>, its value is determined from the desired <code>bias_coeff</code>, <code>coanc_subpops</code> up to a scalar factor, and <code>fst</code>.
Uniform weights for the final generalized FST are assumed.
The scale of <code>coanc_subpops</code> is irrelevant because it cancels out in <code>bias_coeff</code>; after <code>sigma</code> is found, <code>coanc_subpops</code> is rescaled to give the desired final FST.
However, the function stops if any rescaled <code>coanc_subpops</code> values are greater than 1, which are not allowed since they are IBD probabilities.
</p>


<h3>Value</h3>

<p>If <code>sigma</code> was provided, returns the <code>n_ind</code>-by-<code>k_subpops</code> admixture proportion matrix (<code>admix_proportions</code>).
If <code>sigma</code> is missing, returns a named list containing:
</p>

<ul>
<li> <p><code>admix_proportions</code>: the <code>n_ind</code>-by-<code>k_subpops</code> admixture proportion matrix.
If <code>coanc_subpops</code> had names, they are copied to the columns of this matrix.
</p>
</li>
<li> <p><code>coanc_subpops</code>: the input <code>coanc_subpops</code> rescaled.
</p>
</li>
<li> <p><code>sigma</code>: the fit value of the spread of intermediate subpopulations
</p>
</li>
<li> <p><code>coanc_factor</code>: multiplicative factor used to rescale <code>coanc_subpops</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># admixture matrix for 1000 individuals drawing alleles from 10 subpops
# simple version: spread of about 2 standard deviations along the circular 1D geography
# (just set sigma)
admix_proportions &lt;- admix_prop_1d_circular(n_ind = 1000, k_subpops = 10, sigma = 2)

# advanced version: a similar model but with a bias coefficient of exactly 1/2
# (must provide bias_coeff, coanc_subpops, and fst in lieu of sigma)
k_subpops &lt;- 10
# FST vector for intermediate independent subpops, up to a factor (will be rescaled below)
coanc_subpops &lt;- 1 : k_subpops
obj &lt;- admix_prop_1d_circular(
    n_ind = 1000,
    k_subpops = k_subpops,
    bias_coeff = 0.5,
    coanc_subpops = coanc_subpops,
    fst = 0.1 # desired final FST of admixed individuals
)

# in this case return value is a named list with three items:
admix_proportions &lt;- obj$admix_proportions

# rescaled coancestry data (matrix or vector) for intermediate subpops
coanc_subpops &lt;- obj$coanc_subpops

# and the sigma that gives the desired bias_coeff and final FST
sigma &lt;- obj$sigma

</code></pre>

<hr>
<h2 id='admix_prop_1d_linear'>Construct admixture proportion matrix for 1D geography</h2><span id='topic+admix_prop_1d_linear'></span>

<h3>Description</h3>

<p>Assumes <code>k_subpops</code> intermediate subpopulations placed along a line at locations <code>1 : k_subpops</code> spread by random walks, then <code>n_ind</code> individuals equally spaced in [<code>coord_ind_first</code>,<code>coord_ind_last</code>] draw their admixture proportions relative to the Normal density that models the random walks of each of these intermediate subpopulations.
The spread of the random walks (the standard deviation of the Normal densities) is <code>sigma</code>.
If <code>sigma</code> is missing, it can be set indirectly by providing three variables: (1) the desired bias coefficient <code>bias_coeff</code>, (2) the coancestry matrix of the intermediate subpopulations <code>coanc_subpops</code> (up to a scalar factor), and (3) the final <code>fst</code> of the admixed individuals (see details below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_prop_1d_linear(
  n_ind,
  k_subpops,
  sigma = NA,
  coord_ind_first = 0.5,
  coord_ind_last = k_subpops + 0.5,
  bias_coeff = NA,
  coanc_subpops = NULL,
  fst = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="admix_prop_1d_linear_+3A_n_ind">n_ind</code></td>
<td>
<p>Number of individuals.</p>
</td></tr>
<tr><td><code id="admix_prop_1d_linear_+3A_k_subpops">k_subpops</code></td>
<td>
<p>Number of intermediate subpopulations.</p>
</td></tr>
<tr><td><code id="admix_prop_1d_linear_+3A_sigma">sigma</code></td>
<td>
<p>Spread of intermediate subpopulations (standard deviation of normal densities).
The edge cases <code>sigma = 0</code> and <code>sigma = Inf</code> are handled appropriately!</p>
</td></tr>
<tr><td><code id="admix_prop_1d_linear_+3A_coord_ind_first">coord_ind_first</code></td>
<td>
<p>Location of first individual (default <code>0.5</code>).</p>
</td></tr>
<tr><td><code id="admix_prop_1d_linear_+3A_coord_ind_last">coord_ind_last</code></td>
<td>
<p>Location of last individual (default <code>k_subpops + 0.5</code>).
</p>
<p>OPTIONS FOR BIAS COEFFICIENT VERSION</p>
</td></tr>
<tr><td><code id="admix_prop_1d_linear_+3A_bias_coeff">bias_coeff</code></td>
<td>
<p>If <code>sigma</code> is <code>NA</code>, this bias coefficient is required.</p>
</td></tr>
<tr><td><code id="admix_prop_1d_linear_+3A_coanc_subpops">coanc_subpops</code></td>
<td>
<p>If <code>sigma</code> is <code>NA</code>, this intermediate subpops coancestry is required.
It can be provided as a <code>k_subpops</code>-by-<code>k_subpops</code> matrix, a length-<code>k_subpops</code> population inbreeding vector (for independent subpopulations, where between-subpop coancestries are zero) or scalar (if population inbreeding values are all equal and coancestries are zero).
This <code>coanc_subpops</code> can be in the wrong scale (it cancels out in calculations), which is returned corrected, to result in the desired <code>fst</code> (next).</p>
</td></tr>
<tr><td><code id="admix_prop_1d_linear_+3A_fst">fst</code></td>
<td>
<p>If <code>sigma</code> is <code>NA</code>, this FST of the admixed individuals is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>sigma</code> is <code>NA</code>, its value is determined from the desired <code>bias_coeff</code>, <code>coanc_subpops</code> up to a scalar factor, and <code>fst</code>.
Uniform weights for the final generalized FST are assumed.
The scale of <code>coanc_subpops</code> is irrelevant because it cancels out in <code>bias_coeff</code>; after <code>sigma</code> is found, <code>coanc_subpops</code> is rescaled to give the desired final FST.
However, the function stops if any rescaled <code>coanc_subpops</code> values are greater than 1, which are not allowed since they are IBD probabilities.
</p>


<h3>Value</h3>

<p>If <code>sigma</code> was provided, returns the <code>n_ind</code>-by-<code>k_subpops</code> admixture proportion matrix (<code>admix_proportions</code>).
If <code>sigma</code> is missing, returns a named list containing:
</p>

<ul>
<li> <p><code>admix_proportions</code>: the <code>n_ind</code>-by-<code>k_subpops</code> admixture proportion matrix.
If <code>coanc_subpops</code> had names, they are copied to the columns of this matrix.
</p>
</li>
<li> <p><code>coanc_subpops</code>: the input <code>coanc_subpops</code> rescaled.
</p>
</li>
<li> <p><code>sigma</code>: the fit value of the spread of intermediate subpopulations
</p>
</li>
<li> <p><code>coanc_factor</code>: multiplicative factor used to rescale <code>coanc_subpops</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># admixture matrix for 1000 individuals drawing alleles from 10 subpops
# simple version: spread of 2 standard deviations along the 1D geography
# (just set sigma)
admix_proportions &lt;- admix_prop_1d_linear(n_ind = 1000, k_subpops = 10, sigma = 2)

# as sigma approaches zero, admix_proportions approaches the independent subpopulations matrix
admix_prop_1d_linear(n_ind = 10, k_subpops = 2, sigma = 0)

# advanced version: a similar model but with a bias coefficient of exactly 1/2
# (must provide bias_coeff, coanc_subpops, and fst in lieu of sigma)
k_subpops &lt;- 10
# FST vector for intermediate independent subpops, up to a factor (will be rescaled below)
coanc_subpops &lt;- 1 : k_subpops
obj &lt;- admix_prop_1d_linear(
    n_ind = 1000,
    k_subpops = k_subpops,
    bias_coeff = 0.5,
    coanc_subpops = coanc_subpops,
    fst = 0.1 # desired final FST of admixed individuals
)

# in this case return value is a named list with three items:
# admixture proportions
admix_proportions &lt;- obj$admix_proportions

# rescaled coancestry data (matrix or vector) for intermediate subpops
coanc_subpops &lt;- obj$coanc_subpops

# and the sigma that gives the desired bias_coeff and final FST
sigma &lt;- obj$sigma

</code></pre>

<hr>
<h2 id='admix_prop_indep_subpops'>Construct admixture proportion matrix for independent subpopulations</h2><span id='topic+admix_prop_indep_subpops'></span>

<h3>Description</h3>

<p>This function constructs an admixture proportion matrix where every individuals is actually unadmixed (draws its full ancestry from a single intermediate subpopulation).
The inputs are the vector of subpopulation labels <code>labs</code> for every individual (length <code>n</code>), and
the length-<code>k</code> vector of unique subpopulations <code>subpops</code> in the desired order.
If <code>subpops</code> is missing, the sorted unique subpopulations observed in <code>labs</code> is used.
This function returns the admixture proportion matrix, for each individual 1 for the column corresponding to its subpopulation, 0 otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_prop_indep_subpops(labs, subpops = sort(unique(labs)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="admix_prop_indep_subpops_+3A_labs">labs</code></td>
<td>
<p>Length-<code>n</code> vector of subpopulation labels</p>
</td></tr>
<tr><td><code id="admix_prop_indep_subpops_+3A_subpops">subpops</code></td>
<td>
<p>Optional length-<code>k</code> vector of unique subpopulations in desired order.
Stops if <code>subpops</code> does not contain all unique labels in <code>labs</code> (no error if <code>subpops</code> contains additional labels).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>n</code>-by-<code>k</code> admixture proportion matrix.
The unique subpopulation labels are given in the column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># vector of subpopulation memberships
labs &lt;- c(1, 1, 1, 2, 2, 3, 1)
# admixture matrix with subpopulations (along columns) sorted
admix_proportions &lt;- admix_prop_indep_subpops(labs)

# declare subpopulations in custom order
subpops &lt;- c(3, 1, 2)
# columns will be reordered to match subpops as provided
admix_proportions &lt;- admix_prop_indep_subpops(labs, subpops)

# declare subpopulations with unobserved labels
subpops &lt;- 1:5
# note columns 4 and 5 will be false for all individuals
admix_proportions &lt;- admix_prop_indep_subpops(labs, subpops)

</code></pre>

<hr>
<h2 id='coanc_admix'>Construct the coancestry matrix of an admixture model</h2><span id='topic+coanc_admix'></span>

<h3>Description</h3>

<p>The <code>n</code>-by-<code>n</code> coancestry matrix <code>Theta</code> of admixed individuals is determined by the <code>n</code>-by-<code>k</code> admixture proportion matrix <code>Q</code> and the <code>k</code>-by-<code>k</code> intermediate subpopulation coancestry matrix <code>Psi</code>, given by <code>Theta = Q %*% Psi %*% t(Q)</code>.
In the more restricted BN-PSD model, <code>Psi</code> is a diagonal matrix (with FST values for the intermediate subpopulations along the diagonal, zero values off-diagonal).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coanc_admix(admix_proportions, coanc_subpops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coanc_admix_+3A_admix_proportions">admix_proportions</code></td>
<td>
<p>The <code>n</code>-by-<code>k</code> admixture proportion matrix</p>
</td></tr>
<tr><td><code id="coanc_admix_+3A_coanc_subpops">coanc_subpops</code></td>
<td>
<p>The intermediate subpopulation coancestry, given either as a <code>k</code>-by-<code>k</code> matrix (for the complete admixture model), or the length-<code>k</code> vector of intermediate subpopulation FST values (for the BN-PSD model; implies zero coancestry between subpopulations), or a scalar FST value shared by all intermediate subpopulations (also implies zero coancestry between subpopulations).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a precaution, function stops if both inputs have names and the column names of <code>admix_proportions</code> and the names in <code>coanc_subpops</code> disagree, which might be because these two matrices are not aligned or there is some other inconsistency.
</p>


<h3>Value</h3>

<p>The <code>n</code>-by-<code>n</code> coancestry matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a trivial case: unadmixed individuals from independent subpopulations
# number of individuals and subpops
n_ind &lt;- 5
# unadmixed individuals
admix_proportions &lt;- diag(rep.int(1, n_ind))
# equal Fst for all subpops
coanc_subpops &lt;- 0.2
# diagonal coancestry matryx
coancestry &lt;- coanc_admix(admix_proportions, coanc_subpops)

# a more complicated admixture model
# number of individuals
n_ind &lt;- 5
# number of intermediate subpops
k_subpops &lt;- 2
# non-trivial admixture proportions
admix_proportions &lt;- admix_prop_1d_linear(n_ind, k_subpops, sigma = 1)
# different Fst for each of the k_subpops
coanc_subpops &lt;- c(0.1, 0.3)
# non-trivial coancestry matrix
coancestry &lt;- coanc_admix(admix_proportions, coanc_subpops)

</code></pre>

<hr>
<h2 id='coanc_to_kinship'>Transform coancestry matrix to kinship matrix</h2><span id='topic+coanc_to_kinship'></span>

<h3>Description</h3>

<p>If <code>Theta</code> is the coancestry matrix and <code>Phi</code> is the kinship matrix (both are <code>n</code>-by-<code>n</code> symmetric), then these matrices agree off-diagonal, but the diagonal gets transformed as
<code>diag( Phi ) = ( 1 + diag( Theta ) ) / 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coanc_to_kinship(coancestry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coanc_to_kinship_+3A_coancestry">coancestry</code></td>
<td>
<p>The <code>n</code>-by-<code>n</code> coancestry matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>n</code>-by-<code>n</code> kinship matrix, preserving column and row names.
</p>


<h3>See Also</h3>

<p>The inverse function is given by <code><a href="popkin.html#topic+inbr_diag">popkin::inbr_diag()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a trivial case: unadmixed individuals from independent subpopulations
# number of individuals/subpops
n_ind &lt;- 5
# unadmixed individuals
admix_proportions &lt;- diag(rep.int(1, n_ind))
# equal Fst for all subpops
inbr_subpops &lt;- 0.2
# diagonal coancestry matryx
coancestry &lt;- coanc_admix(admix_proportions, inbr_subpops)
kinship &lt;- coanc_to_kinship(coancestry)

# a more complicated admixture model
# number of individuals
n_ind &lt;- 5
# number of intermediate subpops
k_subpops &lt;- 2
# non-trivial admixture proportions
admix_proportions &lt;- admix_prop_1d_linear(n_ind, k_subpops, sigma = 1)
# different Fst for each of the k subpops
inbr_subpops &lt;- c(0.1, 0.3)
# non-trivial coancestry matrix
coancestry &lt;- coanc_admix(admix_proportions, inbr_subpops)
kinship &lt;- coanc_to_kinship( coancestry )

</code></pre>

<hr>
<h2 id='coanc_tree'>Calculate coancestry matrix corresponding to a tree</h2><span id='topic+coanc_tree'></span>

<h3>Description</h3>

<p>This function calculates the coancestry matrix of the subpopulations which are tip nodes in the input tree.
The edges of this tree are coancestry values relative to the parent node of each child node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coanc_tree(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coanc_tree_+3A_tree">tree</code></td>
<td>
<p>The coancestry tree relating the <code>k_subpops</code> subpopulations.
Must be a <code>phylo</code> object from the <code>ape</code> package (see <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code>).
This tree may have a valid root edge (non-NULL <code>tree$root.edge</code> between 0 and 1), which is incorporated in the output calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation takes into account that total coancestries are non-linear functions of the per-edge coancestries.
Interestingly, the calculation can be simplified by a simple transformation performed by <code><a href="#topic+tree_additive">tree_additive()</a></code>, see that for more information.
The self-coancestry (diagonal values) are the total coancestries of the tip nodes.
The coancestry between different subpopulations is the total coancestry of their last common ancestor node.
</p>


<h3>Value</h3>

<p>The <code>k_subpops</code>-by-<code>k_subpops</code> coancestry matrix.
The order of subpopulations along the rows and columns of this matrix matches <code>tree$tip.label</code>.
The tip labels of the tree are copied to the row and column names of this matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_tree">fit_tree()</a></code> for the inverse function (when applied to coancestry matrices generated by a tree without noise).
</p>
<p><code><a href="#topic+tree_additive">tree_additive()</a></code> for calculating the additive edges.
This function is called internally by <code>coanc_tree</code> but the additive edges are not returned here, so call <code><a href="#topic+tree_additive">tree_additive()</a></code> if you desired them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for simulating a tree with `rtree`
library(ape)

# a typical, non-trivial example
# number of tip subpopulations
k_subpops &lt;- 3
# simulate a random tree
tree_subpops &lt;- rtree( k_subpops )
# coancestry matrix of subpopulations
coancestry &lt;- coanc_tree( tree_subpops )

</code></pre>

<hr>
<h2 id='draw_all_admix'>Simulate random allele frequencies and genotypes from the BN-PSD admixture model</h2><span id='topic+draw_all_admix'></span>

<h3>Description</h3>

<p>This function returns simulated ancestral, intermediate, and individual-specific allele frequencies and genotypes given the admixture structure, as determined by the admixture proportions and the vector or tree of intermediate subpopulation FST values.
The function is a wrapper around <code><a href="#topic+draw_p_anc">draw_p_anc()</a></code>, <code><a href="#topic+draw_p_subpops">draw_p_subpops()</a></code>/<code><a href="#topic+draw_p_subpops_tree">draw_p_subpops_tree()</a></code>, <code><a href="#topic+make_p_ind_admix">make_p_ind_admix()</a></code>, and <code><a href="#topic+draw_genotypes_admix">draw_genotypes_admix()</a></code> with additional features such as requiring polymorphic loci.
Importantly, by default fixed loci (where all individuals were homozygous for the same allele) are re-drawn from the start (starting from the ancestral allele frequencies) so no fixed loci are in the output and no biases are introduced by re-drawing genotypes conditional on any of the previous allele frequencies (ancestral, intermediate, or individual-specific).
Below <code>m_loci</code> (also <code>m</code>) is the number of loci, <code>n</code> is the number of individuals, and <code>k</code> is the number of intermediate subpopulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_all_admix(
  admix_proportions,
  inbr_subpops = NULL,
  m_loci,
  tree_subpops = NULL,
  want_genotypes = TRUE,
  want_p_ind = FALSE,
  want_p_subpops = FALSE,
  want_p_anc = TRUE,
  verbose = FALSE,
  require_polymorphic_loci = TRUE,
  maf_min = 0,
  beta = NA,
  p_anc = NULL,
  p_anc_distr = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_all_admix_+3A_admix_proportions">admix_proportions</code></td>
<td>
<p>The <code>n</code>-by-<code>k</code> matrix of admixture proportions.</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_inbr_subpops">inbr_subpops</code></td>
<td>
<p>The length-<code>k</code> vector (or scalar) of intermediate subpopulation FST values.
Either this or <code>tree_subpops</code> must be provided (but not both).</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_m_loci">m_loci</code></td>
<td>
<p>The number of loci to draw.</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_tree_subpops">tree_subpops</code></td>
<td>
<p>The coancestry tree relating the <code>k</code> intermediate subpopulations.
Must be a <code>phylo</code> object from the <code>ape</code> package (see <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code>).
Either this or <code>inbr_subpops</code> must be provided (but not both).</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_want_genotypes">want_genotypes</code></td>
<td>
<p>If <code>TRUE</code> (default), includes the matrix of random genotypes in the return list.</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_want_p_ind">want_p_ind</code></td>
<td>
<p>If <code>TRUE</code> (NOT default), includes the matrix of individual-specific allele frequencies in the return list.
Note that by default <code>p_ind</code> is not constructed in full at all, instead a fast low-memory algorithm constructs it in parts as needed only; beware that setting <code>want_p_ind = TRUE</code> increases memory usage in comparison.</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_want_p_subpops">want_p_subpops</code></td>
<td>
<p>If <code>TRUE</code> (NOT default), includes the matrix of random intermediate subpopulation allele frequencies in the return list.</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_want_p_anc">want_p_anc</code></td>
<td>
<p>If <code>TRUE</code> (default), includes the vector of random ancestral allele frequencies in the return list.</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, prints messages for every stage in the algorithm.</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_require_polymorphic_loci">require_polymorphic_loci</code></td>
<td>
<p>If <code>TRUE</code> (default), returned genotype matrix will not include any fixed loci (loci that happened to be fixed are drawn again, starting from their ancestral allele frequencies, and checked iteratively until no fixed loci remain, so that the final number of polymorphic loci is exactly <code>m_loci</code>).</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_maf_min">maf_min</code></td>
<td>
<p>The minimum minor allele frequency (default zero), to extend the working definition of &quot;fixed&quot; above to include rare variants.
This helps simulate a frequency-based locus ascertainment bias.
Loci with minor allele frequencies less than or <em>equal</em> to this value are treated as fixed (passed to <code><a href="#topic+fixed_loci">fixed_loci()</a></code>).
This parameter has no effect if <code>require_polymorphic_loci</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_beta">beta</code></td>
<td>
<p>Shape parameter for a symmetric Beta for ancestral allele frequencies <code>p_anc</code>.
If <code>NA</code> (default), <code>p_anc</code> is uniform with range in [0.01, 0.5].
Otherwise, <code>p_anc</code> has a symmetric Beta distribution with range in [0, 1].
Has no effect if either <code>p_anc</code> or <code>p_anc_distr</code> options are non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_p_anc">p_anc</code></td>
<td>
<p>If provided, it is used as the ancestral allele frequencies (instead of drawing random ones).  Must either be a scalar or a length-<code>m_loci</code> vector.
If scalar and <code>want_p_anc = TRUE</code>, then the returned <code>p_anc</code> is the scalar value repeated <code>m_loci</code> times (it is always a vector).
If a locus was fixed and has to be redrawn, the ancestral allele frequency in <code>p_anc</code> is retained and only downstream allele frequencies and genotypes are redrawn (contrast to <code>p_anc_distr</code> below).</p>
</td></tr>
<tr><td><code id="draw_all_admix_+3A_p_anc_distr">p_anc_distr</code></td>
<td>
<p>If provided, ancestral allele frequencies are drawn with replacement from this vector (which may have any length) or function, instead of from <code><a href="#topic+draw_p_anc">draw_p_anc()</a></code>.
If a function, must accept a single parameter specifying the number of loci to draw.
If a locus was fixed and has to be redrawn, the ancestral allele frequency is redrawn from the distribution (contrast to <code>p_anc</code> above).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a precaution, function stops if both the column names of <code>admix_proportions</code> and the names in <code>inbr_subpops</code> or <code>tree_subpops</code> exist and disagree, which might be because these two data are not aligned or there is some other inconsistency.
</p>


<h3>Value</h3>

<p>A named list with the following items (which may be missing depending on options):
</p>

<ul>
<li> <p><code>X</code>: An <code>m</code>-by-<code>n</code> matrix of genotypes.
Included if <code>want_genotypes = TRUE</code>.
</p>
</li>
<li> <p><code>p_anc</code>: A length-<code>m</code> vector of ancestral allele frequencies.
Included if <code>want_p_anc = TRUE</code>.
</p>
</li>
<li> <p><code>p_subpops</code>: An <code>m</code>-by-<code>k</code> matrix of intermediate subpopulation allele frequencies
Included if <code>want_p_subpops = TRUE</code>.
</p>
</li>
<li> <p><code>p_ind</code>: An <code>m</code>-by-<code>n</code> matrix of individual-specific allele frequencies.
Included if <code>want_p_ind = TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># dimensions
# number of loci
m_loci &lt;- 10
# number of individuals
n_ind &lt;- 5
# number of intermediate subpops
k_subpops &lt;- 2

# define population structure
# FST values for k = 2 subpopulations
inbr_subpops &lt;- c(0.1, 0.3)
# admixture proportions from 1D geography
admix_proportions &lt;- admix_prop_1d_linear(n_ind, k_subpops, sigma = 1)

# draw all random allele freqs and genotypes
out &lt;- draw_all_admix(admix_proportions, inbr_subpops, m_loci)

# return value is a list with these items:

# genotypes
X &lt;- out$X

# ancestral AFs
p_anc &lt;- out$p_anc

# # these are excluded by default, but would be included if ...
# # ... `want_p_subpops == TRUE`
# # intermediate subpopulation AFs
# p_subpops &lt;- out$p_subpops
# 
# # ... `want_p_ind == TRUE`
# # individual-specific AFs
# p_ind &lt;- out$p_ind

</code></pre>

<hr>
<h2 id='draw_genotypes_admix'>Draw genotypes from the admixture model</h2><span id='topic+draw_genotypes_admix'></span>

<h3>Description</h3>

<p>Given the Individual-specific Allele Frequency (IAF) matrix <code>p_ind</code> for <code>m</code> loci (rows) and <code>n</code> individuals (columns), the genotype matrix <code>X</code> (same dimensions as <code>p_ind</code>) is drawn from the Binomial distribution equivalent to
<code>X[ i, j ] &lt;- rbinom( 1, 2, p_ind[ i, j ] )</code>,
except the function is more efficient.
If <code>admix_proportions</code> is provided as the second argument (a matrix with <code>n</code> individuals along rows and <code>k</code> intermediate subpopulations along the columns), the first argument <code>p_ind</code> is treated as the intermediate subpopulation allele frequency matrix (must be <code>m</code>-by-<code>k</code>) and the IAF matrix is equivalent to
<code>p_ind %*% t( admix_proportions )</code>.
However, in this case the function computes the IAF matrix in parts only, never stored in full, greatly reducing memory usage.
If <code>admix_proportions</code> is missing, then <code>p_ind</code> is treated as the IAF matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_genotypes_admix(p_ind, admix_proportions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_genotypes_admix_+3A_p_ind">p_ind</code></td>
<td>
<p>The <code>m</code>-by-<code>n</code> IAF matrix (if <code>admix_proportions</code> is missing) or the <code>m</code>-by-<code>k</code> intermediate subpopulation allele frequency matrix (if <code>admix_proportions</code> is present).</p>
</td></tr>
<tr><td><code id="draw_genotypes_admix_+3A_admix_proportions">admix_proportions</code></td>
<td>
<p>The optional <code>n</code>-by-<code>k</code> admixture proportion matrix (to draw data from the admixture model using reduced memory, by not fully forming the IAF matrix).
If provided, and if both <code>admix_proportions</code> and <code>p_ind</code> have column names, and if they disagree, the function stops as a precaution, as this suggests the data is misaligned or inconsistent in some way.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>m</code>-by-<code>n</code> genotype matrix.
If <code>admix_proportions</code> is missing, the row and column names of <code>p_ind</code> are copied to this output.
If <code>admix_proportions</code> is present, the row names of the output are the row names of <code>p_ind</code>, while the column names of the output are the row names of <code>admix_proportions</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dimensions
# number of loci
m_loci &lt;- 10
# number of individuals
n_ind &lt;- 5
# number of intermediate subpops
k_subpops &lt;- 2

# define population structure
# FST values for k = 2 subpops
inbr_subpops &lt;- c(0.1, 0.3)
# non-trivial admixture proportions
admix_proportions &lt;- admix_prop_1d_linear(n_ind, k_subpops, sigma = 1)

# draw allele frequencies
# vector of ancestral allele frequencies
p_anc &lt;- draw_p_anc(m_loci)

# matrix of intermediate subpop allele freqs
p_subpops &lt;- draw_p_subpops(p_anc, inbr_subpops)

# matrix of individual-specific allele frequencies
p_ind &lt;- make_p_ind_admix(p_subpops, admix_proportions)

# draw genotypes from intermediate subpops (one individual each)
X_subpops &lt;- draw_genotypes_admix(p_subpops)

# and genotypes for admixed individuals
X_ind &lt;- draw_genotypes_admix(p_ind)

# draw genotypes for admixed individuals without p_ind intermediate
# (p_ind is computed internally in parts, never stored in full,
# reducing memory use substantially)
X_ind &lt;- draw_genotypes_admix(p_subpops, admix_proportions)

</code></pre>

<hr>
<h2 id='draw_p_anc'>Draw random Uniform or Beta ancestral allele frequencies</h2><span id='topic+draw_p_anc'></span>

<h3>Description</h3>

<p>This is simply a wrapper around <code><a href="stats.html#topic+Uniform">stats::runif()</a></code> or <code><a href="stats.html#topic+Beta">stats::rbeta()</a></code> (depending on parameters) with different defaults and additional validations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_p_anc(m_loci, p_min = 0.01, p_max = 0.5, beta = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_p_anc_+3A_m_loci">m_loci</code></td>
<td>
<p>Number of loci to draw.</p>
</td></tr>
<tr><td><code id="draw_p_anc_+3A_p_min">p_min</code></td>
<td>
<p>Minimum allele frequency to draw (Uniform case only).</p>
</td></tr>
<tr><td><code id="draw_p_anc_+3A_p_max">p_max</code></td>
<td>
<p>Maximum allele frequency to draw (Uniform case only).</p>
</td></tr>
<tr><td><code id="draw_p_anc_+3A_beta">beta</code></td>
<td>
<p>Shape parameter for a symmetric Beta.
If <code>NA</code> (default), Uniform(<code>p_min</code>, <code>p_max</code>) is used.
Otherwise, a Symmetric Beta is used and the user-specified range is ignored (values in [0, 1] will be returned).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-<code>m</code> vector of random ancestral allele frequencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default is uniform with range between 0.01 and 0.5
p_anc &lt;- draw_p_anc(m_loci = 10)

# Use of `beta` triggers a symmetric Beta distribution.
# This parameter has increased density for rare minor allele frequencies,
# resembling the 1000 Genomes allele frequency distribution
p_anc &lt;- draw_p_anc(m_loci = 10, beta = 0.03)

</code></pre>

<hr>
<h2 id='draw_p_subpops'>Draw allele frequencies for independent subpopulations</h2><span id='topic+draw_p_subpops'></span>

<h3>Description</h3>

<p>The allele frequency matrix <code>P</code> for <code>m_loci</code> loci (rows) and <code>k_subpops</code> independent subpopulations (columns) are drawn from the Balding-Nichols distribution with ancestral allele frequencies <code>p_anc</code> and FST parameters <code>inbr_subpops</code> equivalent to
<code>P[ i, j ] &lt;- rbeta( 1, nu_j * p_anc[i], nu_j * ( 1 - p_anc[i] ) )</code>,
where <code>nu_j &lt;- 1 / inbr_subpops[j] - 1</code>.
The actual function is more efficient than the above code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_p_subpops(p_anc, inbr_subpops, m_loci = NA, k_subpops = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_p_subpops_+3A_p_anc">p_anc</code></td>
<td>
<p>The scalar or length-<code>m_loci</code> vector of ancestral allele frequencies per locus.</p>
</td></tr>
<tr><td><code id="draw_p_subpops_+3A_inbr_subpops">inbr_subpops</code></td>
<td>
<p>The scalar or length-<code>k_subpops</code> vector of subpopulation FST values.</p>
</td></tr>
<tr><td><code id="draw_p_subpops_+3A_m_loci">m_loci</code></td>
<td>
<p>If <code>p_anc</code> is scalar, optionally provide the desired number of loci (lest only one locus be simulated).
Stops if both <code>length(p_anc) &gt; 1</code> and <code>m_loci</code> is not <code>NA</code> and they disagree.</p>
</td></tr>
<tr><td><code id="draw_p_subpops_+3A_k_subpops">k_subpops</code></td>
<td>
<p>If <code>inbr_subpops</code> is a scalar, optionally provide the desired number of subpopulations (lest a single subpopulation be simulated).
Stops if both <code>length(inbr_subpops) &gt; 1</code> and <code>k_subpops</code> is not <code>NA</code> and they disagree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>m_loci</code>-by-<code>k_subpops</code> matrix of independent subpopulation allele frequencies.
If <code>p_anc</code> is length-<code>m_loci</code> with names, these are copied to the row names of this output matrix.
If <code>inbr_subpops</code> is length-<code>k_subpops</code> with names, these are copied to the column names of this output matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw_p_subpops_tree">draw_p_subpops_tree()</a></code> for version for subpopulations related by a tree, which can therefore be non-independent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a typical, non-trivial example
# number of loci
m_loci &lt;- 10
# random vector of ancestral allele frequencies
p_anc &lt;- draw_p_anc(m_loci)
# FST values for two subpops
inbr_subpops &lt;- c(0.1, 0.3)
# matrix of intermediate subpop allele freqs
p_subpops &lt;- draw_p_subpops(p_anc, inbr_subpops)

# special case of scalar p_anc
p_subpops &lt;- draw_p_subpops(p_anc = 0.5, inbr_subpops, m_loci = m_loci)
stopifnot ( nrow( p_subpops ) == m_loci )

# special case of scalar inbr_subpops
k_subpops &lt;- 2
p_subpops &lt;- draw_p_subpops(p_anc, inbr_subpops = 0.2, k_subpops = k_subpops)
stopifnot ( ncol( p_subpops ) == k_subpops )

# both main parameters scalars but return value still matrix
p_subpops &lt;- draw_p_subpops(p_anc = 0.5, inbr_subpops = 0.2, m_loci = m_loci, k_subpops = k_subpops)
stopifnot ( nrow( p_subpops ) == m_loci )
stopifnot ( ncol( p_subpops ) == k_subpops )

# passing scalar parameters without setting dimensions separately results in a 1x1 matrix
p_subpops &lt;- draw_p_subpops(p_anc = 0.5, inbr_subpops = 0.2)
stopifnot ( nrow( p_subpops ) == 1 )
stopifnot ( ncol( p_subpops ) == 1 )

</code></pre>

<hr>
<h2 id='draw_p_subpops_tree'>Draw allele frequencies for subpopulations related by a tree</h2><span id='topic+draw_p_subpops_tree'></span>

<h3>Description</h3>

<p>The allele frequency matrix <code>P</code> for <code>m_loci</code> loci (rows) and <code>k_subpops</code> subpopulations (columns) are drawn from the Balding-Nichols distribution.
If the allele frequency in the parent node is <code>p</code> and the FST parameter of the child node from the parent node is <code>F</code>, then the allele frequency in the child node is drawn from
<code>rbeta( 1, nu * p, nu * ( 1 - p ) )</code>,
where <code>nu &lt;- 1 / F - 1</code>.
This function iterates drawing allele frequencies through the tree structure, therefore allowing covariance between subpopulations that share branches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_p_subpops_tree(p_anc, tree_subpops, m_loci = NA, nodes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_p_subpops_tree_+3A_p_anc">p_anc</code></td>
<td>
<p>The scalar or length-<code>m_loci</code> vector of ancestral allele frequencies per locus.</p>
</td></tr>
<tr><td><code id="draw_p_subpops_tree_+3A_tree_subpops">tree_subpops</code></td>
<td>
<p>The coancestry tree relating the <code>k_subpops</code> subpopulations.
Must be a <code>phylo</code> object from the <code>ape</code> package (see <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code>).
The edge lengths of this tree must be the FST parameters relating parent and child subpopulations.</p>
</td></tr>
<tr><td><code id="draw_p_subpops_tree_+3A_m_loci">m_loci</code></td>
<td>
<p>If <code>p_anc</code> is scalar, optionally provide the desired number of loci (lest only one locus be simulated).
Stops if both <code>length(p_anc) &gt; 1</code> and <code>m_loci</code> is not <code>NA</code> and they disagree.</p>
</td></tr>
<tr><td><code id="draw_p_subpops_tree_+3A_nodes">nodes</code></td>
<td>
<p>If <code>FALSE</code> (default), returns allele frequencies of &quot;tip&quot; subpopulations only; otherwise returns all allele frequencies, including internal nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>m_loci</code>-by-<code>k_subpops</code> matrix of independent subpopulation allele frequencies.
If <code>nodes = FALSE</code>, columns include only tip subpopulations.
If <code>nodes = TRUE</code>, internal node subpopulations are also included (in this case the input <code>p_anc</code> is returned in the column corresponding to the root node).
In all cases subpopulations are ordered as indexes in the tree, which normally implies the tip nodes are listed first, followed by the internal nodes (as in <code>tree_subpops$edge</code> matrix, see <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code> for details).
The <code>tree_subpops</code> tip and node names are copied to the column names of this output matrix (individual names may be blank if missing in tree (such as for internal nodes); column names are <code>NULL</code> if all <code>tree_subpops</code> tip labels were blank, regardless of internal node labels).
If <code>p_anc</code> is length-<code>m_loci</code> with names, these names are copied to the row names of this output matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw_p_subpops">draw_p_subpops()</a></code> for version for independent subpopulations.
</p>
<p>For &quot;phylo&quot; tree class, see <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for simulating a tree with `rtree`
library(ape)

# a typical, non-trivial example
# number of tip subpopulations
k_subpops &lt;- 3
# number of loci
m_loci &lt;- 10
# random vector of ancestral allele frequencies
p_anc &lt;- draw_p_anc(m_loci)
# simulate tree
tree_subpops &lt;- rtree( k_subpops )
# matrix of intermediate subpop allele freqs
p_subpops &lt;- draw_p_subpops_tree(p_anc, tree_subpops)

</code></pre>

<hr>
<h2 id='fit_tree'>Fit a tree structure to a coancestry matrix</h2><span id='topic+fit_tree'></span>

<h3>Description</h3>

<p>Implements a heuristic algorithm to find the optimal tree topology based on joining pairs of subpopulations with the highest between-coancestry values, and averaging parent coancestries for the merged nodes (a variant of WPGMA hierarchical clustering <code><a href="stats.html#topic+hclust">stats::hclust()</a></code>).
Branch lengths are optimized using the non-negative least squares approach <code><a href="nnls.html#topic+nnls">nnls::nnls()</a></code>, which minimize the residual square error between the given coancestry matrix and the model coancestry implied by the tree.
This algorithm recovers the true tree when the input coancestry truly belongs to this tree and there is no estimation error (i.e. it is the inverse function of <code><a href="#topic+coanc_tree">coanc_tree()</a></code>), and performs well for coancestry estimates (i.e. the result of simulating genotypes from the true tree, i.e. from <code><a href="#topic+draw_all_admix">draw_all_admix()</a></code>, and estimating the coancestry using <code><a href="popkin.html#topic+popkin">popkin::popkin()</a></code> followed by <code><a href="popkin.html#topic+inbr_diag">popkin::inbr_diag()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_tree(coancestry, method = "mcquitty")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_tree_+3A_coancestry">coancestry</code></td>
<td>
<p>The coancestry matrix to fit a tree to.</p>
</td></tr>
<tr><td><code id="fit_tree_+3A_method">method</code></td>
<td>
<p>The hierarchical clustering method (passed to <code><a href="stats.html#topic+hclust">stats::hclust()</a></code>).
While all <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> methods are supported, only two really make sense for this application: &quot;mcquitty&quot; (i.e. WPGMA, default) and &quot;average&quot; (UPGMA).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree is bifurcating by construction, but edges may equal zero if needed, effectively resulting in multifurcation, although this code makes no attempt to merge nodes with zero edges.
For best fit to arbitrary data, the root edge is always fit to the data (may also be zero).
Data fit may be poor if the coancestry does not correspond to a tree, particularly if there is admixture between subpopulations.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> object from the <code>ape</code> package (see <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code>), with two additional list elements at the end:
</p>

<ul>
<li> <p><code>edge</code>: (standard <code>phylo</code>.)  A matrix describing the tree topology, listing parent and child node indexes.
</p>
</li>
<li> <p><code>Nnode</code>: (standard <code>phylo</code>.)  Number of internal (non-leaf) nodes.
</p>
</li>
<li> <p><code>tip.label</code>: (standard <code>phylo</code>.)  Labels for tips (leaf nodes), in order of index as in <code>edge</code> matrix above.
These match the row names of the input <code>coancestry</code> matrix, or if names are missing, the row indexes of this matrix are used (in both cases, labels may be reordered compared to <code>rownames( coancestry )</code>).
Tips are ordered as they appear in the above <code>edge</code> matrix (ensuring visual agreement in plots between the tree and its resulting coancestry matrix via <code><a href="#topic+coanc_tree">coanc_tree()</a></code>), and in an order that matches the input <code>coancestry</code>'s subpopulation order as much as possible (tree constraints do not permit arbitrary tip orders, but a heuristic implemented in <code><a href="#topic+tree_reorder">tree_reorder()</a></code> is used to determine a reasonable order when an exact match is not possible).
</p>
</li>
<li> <p><code>edge.length</code>: (standard <code>phylo</code>.)  Values of edge lengths in same order as rows of <code>edge</code> matrix above.
</p>
</li>
<li> <p><code>root.edge</code>: (standard <code>phylo</code>.)  Value of root edge length.
</p>
</li>
<li> <p><code>rss</code>:  The residual sum of squares of the model coancestry versus the input coancestry.
</p>
</li>
<li> <p><code>edge.length.add</code>: Additive edge values (regarding their effect on coancestry, as opposed to <code>edge.length</code> which are probabilities, see <code><a href="#topic+coanc_tree">coanc_tree()</a></code>)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+coanc_tree">coanc_tree()</a></code>) for the inverse function (when the coancestry corresponds exactly to a tree).
</p>
<p><code><a href="#topic+tree_reorder">tree_reorder()</a></code> for reordering tree structure so that tips appear in a particular desired order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a random tree
library(ape)
k &lt;- 5
tree &lt;- rtree( k )
# true coancestry matrix for this tree
coanc &lt;- coanc_tree( tree )

# now recover tree from this coancestry matrix:
tree2 &lt;- fit_tree( coanc )
# tree2 equals tree!

</code></pre>

<hr>
<h2 id='fixed_loci'>Identify fixed loci</h2><span id='topic+fixed_loci'></span>

<h3>Description</h3>

<p>A locus is &quot;fixed&quot; if the non-missing sub-vector contains all 0's or all 2's (the locus is completely homozygous for one allele or completely homozygous for the other allele).
This function tests each locus, returning a vector that is <code>TRUE</code> for each fixed locus, <code>FALSE</code> otherwise.
Loci with only missing elements (<code>NA</code>) are treated as fixed.
The parameter <code>maf_min</code> extends the &quot;fixed&quot; definition to loci whose minor allele frequency is smaller or equal than this value.
Below <code>m</code> is the number of loci, and <code>n</code> is the number of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed_loci(X, maf_min = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed_loci_+3A_x">X</code></td>
<td>
<p>The <code>m</code>-by-<code>n</code> genotype matrix</p>
</td></tr>
<tr><td><code id="fixed_loci_+3A_maf_min">maf_min</code></td>
<td>
<p>The minimum minor allele frequency (default zero), to extend the working definition of &quot;fixed&quot; to include rare variants.
Loci with minor allele frequencies less than or <em>equal</em> to this value are marked as fixed.
Must be a scalar between 0 and 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-<code>m</code> boolean vector where the <code>i</code> element is <code>TRUE</code> if locus <code>i</code> is fixed or completely missing, <code>FALSE</code> otherwise.
If <code>X</code> had row names, they are copied to the names of this output vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># here's a toy genotype matrix
X &lt;- matrix(
       data = c(
              2, 2, NA,  # fixed locus (with one missing element)
              0, NA, 0,  # another fixed locus, for opposite allele
              1, 1, 1,   # NOT fixed (heterozygotes are not considered fixed)
              0, 1, 2,   # a completely variable locus
              0, 0, 1,   # a somewhat "rare" variant
              NA, NA, NA # completely missing locus (will be treated as fixed)
             ),
       ncol = 3, byrow = TRUE)

# test that we get the desired values
stopifnot(
  fixed_loci(X) == c(TRUE, TRUE, FALSE, FALSE, FALSE, TRUE)
)

# the "rare" variant gets marked as "fixed" if we set `maf_min` to its frequency
stopifnot(
  fixed_loci(X, maf_min = 1/6) == c(TRUE, TRUE, FALSE, FALSE, TRUE, TRUE)
)

</code></pre>

<hr>
<h2 id='fst_admix'>Calculate FST for the admixed individuals</h2><span id='topic+fst_admix'></span>

<h3>Description</h3>

<p>This function returns the generalized FST of the admixed individuals given their admixture proportion matrix, the coancestry matrix of intermediate subpopulations (or its special cases, see <code>coanc_subpops</code> parameter below), and optional weights for individuals.
This FST equals the weighted mean of the diagonal of the coancestry matrix (see <code><a href="#topic+coanc_admix">coanc_admix()</a></code>).
Below there are <code>n</code> individuals and <code>k</code> intermediate subpopulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fst_admix(admix_proportions, coanc_subpops, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fst_admix_+3A_admix_proportions">admix_proportions</code></td>
<td>
<p>The <code>n</code>-by-<code>k</code> admixture proportion matrix</p>
</td></tr>
<tr><td><code id="fst_admix_+3A_coanc_subpops">coanc_subpops</code></td>
<td>
<p>Either the <code>k</code>-by-<code>k</code> intermediate subpopulation coancestry matrix (for the complete admixture model), or the length-<code>k</code> vector of intermediate subpopulation FST values (for the BN-PSD model; assumes zero coancestries between subpopulations), or a scalar FST value shared by all intermediate subpopulations (also assumes zero coancestry between subpopulations).</p>
</td></tr>
<tr><td><code id="fst_admix_+3A_weights">weights</code></td>
<td>
<p>Optional length-<code>n</code> vector of weights for individuals that define their generalized FST (default uniform weights)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a precaution, function stops if both inputs have names and the column names of <code>admix_proportions</code> and the names in <code>coanc_subpops</code> disagree, which might be because these two matrices are not aligned or there is some other inconsistency.
</p>


<h3>Value</h3>

<p>The generalized FST of the admixed individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set desired parameters
# number of individuals
n_ind &lt;- 1000
# number of intermediate subpopulations
k_subpops &lt;- 10

# differentiation of intermediate subpopulations
coanc_subpops &lt;- ( 1 : k_subpops ) / k_subpops

# construct admixture proportions
admix_proportions &lt;- admix_prop_1d_linear(n_ind, k_subpops, sigma = 1)

# lastly, calculate Fst!!! (uniform weights in this case)
fst_admix(admix_proportions, coanc_subpops)

</code></pre>

<hr>
<h2 id='make_p_ind_admix'>Construct individual-specific allele frequency matrix under the PSD admixture model</h2><span id='topic+make_p_ind_admix'></span>

<h3>Description</h3>

<p>Here <code>m</code> is the number of loci, <code>n</code> the number of individuals, and <code>k</code> the number of intermediate subpopulations.
The <code>m</code>-by-<code>n</code> individual-specific allele frequency matrix <code>p_ind</code> is constructed from the <code>m</code>-by-<code>k</code> intermediate subpopulation allele frequency matrix <code>p_subpops</code> and the <code>n</code>-by-<code>k</code> admixture proportion matrix <code>admix_proportions</code> equivalent to
<code>p_ind &lt;- p_subpops %*% t( admix_proportions )</code>.
This function is a wrapper around <code><a href="base.html#topic+tcrossprod">tcrossprod()</a></code>, but also ensures the output allele frequencies are in [0, 1] (otherwise not guaranteed due to limited machine precision).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_p_ind_admix(p_subpops, admix_proportions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_p_ind_admix_+3A_p_subpops">p_subpops</code></td>
<td>
<p>The <code>m</code>-by-<code>k</code> matrix of intermediate subpopulation allele frequencies.</p>
</td></tr>
<tr><td><code id="make_p_ind_admix_+3A_admix_proportions">admix_proportions</code></td>
<td>
<p>The <code>n</code>-by-<code>k</code> matrix of admixture proportions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>admix_proportions</code> and <code>p_subpops</code> have column names, and if they disagree, the function stops as a precaution, as this suggests the data is misaligned or inconsistent in some way.
</p>


<h3>Value</h3>

<p>The <code>m</code>-by-<code>n</code> matrix of individual-specific allele frequencies <code>p_ind</code>.
Row names equal those from <code>p_subpops</code>, and column names equal rownames from <code>admix_proportions</code>, if present.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data dimensions
# number of loci
m_loci &lt;- 10
# number of individuals
n_ind &lt;- 5
# number of intermediate subpops
k_subpops &lt;- 2

# FST values for k = 2 subpops
inbr_subpops &lt;- c(0.1, 0.3)

# non-trivial admixture proportions
admix_proportions &lt;- admix_prop_1d_linear(n_ind, k_subpops, sigma = 1)

# random vector of ancestral allele frequencies
p_anc &lt;- draw_p_anc(m_loci)

# matrix of intermediate subpop allele freqs
p_subpops &lt;- draw_p_subpops(p_anc, inbr_subpops)

# matrix of individual-specific allele frequencies
p_ind &lt;- make_p_ind_admix(p_subpops, admix_proportions)

</code></pre>

<hr>
<h2 id='scale_tree'>Scale a coancestry tree</h2><span id='topic+scale_tree'></span>

<h3>Description</h3>

<p>Scale by a scalar <code>factor</code> all the edges (<code style="white-space: pre;">&#8288;$edge.length&#8288;</code>) of a <code>phylo</code> object from the <code>ape</code> package, including the root edge (<code style="white-space: pre;">&#8288;$root.edge&#8288;</code>) if present, and additive edges (<code style="white-space: pre;">&#8288;$edge.length.add&#8288;</code>, present in trees returned by <code><a href="#topic+fit_tree">fit_tree()</a></code>).
Stops if any of the edges exceed 1 before or after scaling (since these edges are IBD probabilities).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_tree(tree, factor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_tree_+3A_tree">tree</code></td>
<td>
<p>The coancestry tree to edit.</p>
</td></tr>
<tr><td><code id="scale_tree_+3A_factor">factor</code></td>
<td>
<p>The scalar factor to multiply all edges.
Must be non-negative, and not be so large that any edge exceeds 1 after scaling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The edited tree with all edges scaled as desired.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code> for reading <code>phylo</code> objects and their definition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a random tree
library(ape)
k &lt;- 5
tree &lt;- rtree( k )

# scale this tree
tree_scaled &lt;- scale_tree( tree, 0.5 )

</code></pre>

<hr>
<h2 id='tree_additive'>Calculate additive edges for a coancestry tree, or viceversa</h2><span id='topic+tree_additive'></span>

<h3>Description</h3>

<p>A coancestry tree has IBD probabilities as edge values, which describe how each child and parent subpopulation in the tree is related.
This means that each parameter is relative to its parent subpopulation (varies per edge), and they are not in general IBD probabilities from the root.
This function computes &quot;additive&quot; edges that corresponds more closely with the coancestry matrix of this tree, which gives parameters relative to the root (ancestral) population (see details below).
The additive edges are computed on a new element of the tree <code>phylo</code> object, so they do not overwrite the probabilistic edges.
The reverse option assumes that the main edges of the <code>phylo</code> object are additive edges, then calculates the probabilistic edges and stores as the main edges and moves the original additive edges on the new element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_additive(tree, rev = FALSE, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_additive_+3A_tree">tree</code></td>
<td>
<p>The coancestry tree with either probabilistic edges (if <code>rev = FALSE</code>) or additive edges (if <code>rev = TRUE</code>) as the main edges (stored in <code>tree$edge.length</code>).
Must be a <code>phylo</code> object from the <code>ape</code> package (see <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code>).
This tree may have a valid root edge (non-NULL <code>tree$root.edge</code> between 0 and 1), which is incorporated in the output calculations.
Function stops if the input data is not valid.
Probabilistic edges are valid if and only if they are all between zero and one.
Additive edges are valid if and only if they are all non-negative and the sum of edges between the root and each tip (leaf node) does not exceed 1.</p>
</td></tr>
<tr><td><code id="tree_additive_+3A_rev">rev</code></td>
<td>
<p>If <code>FALSE</code> (default), assumes the main edges are probabilistic values, and calculates additive values.
If <code>TRUE</code>, assumes main edges are additive values, and calculates probabilistic values.</p>
</td></tr>
<tr><td><code id="tree_additive_+3A_force">force</code></td>
<td>
<p>If <code>FALSE</code> (default), function stops if input tree already has additive edges (if <code>tree$edge.length.add</code> is not <code>NULL</code>).
If <code>TRUE</code>, these values are ignored and overwritten.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation takes into account that total coancestries are non-linear combinations of the per-edge coancestries.
For example, if the root node is <code>A</code>, and subpopulation <code>C</code> is connected to <code>A</code> only through an internal node <code>B</code>, then its total self-coancestry <code>coanc_A_C</code> relative to <code>A</code> is given by <code>coanc_A_B</code> (the coancestry between <code>A</code> and <code>B</code>) and <code>coanc_B_C</code> (the coancestry between <code>B</code> and <code>C</code>) by
<code>coanc_A_C = coanc_A_B + coanc_B_C * ( 1 - coanc_A_B )</code>.
This transformation ensures that the total coancestry is a probability that does not exceed one even when the per-edge coancestries sum to a value greater than one.
The &quot;additive&quot; edge for <code>B</code> and <code>C</code> is <code>coanc_B_C * ( 1 - coanc_A_B )</code>, so it is the probabilistic edge <code>coanc_B_C</code> shrunk by <code>1 - coanc_A_B</code>, which can then just be added to the parent edge <code>coanc_A_B</code> to give the total coancestry <code>coanc_A_C</code>.
This transformation is iterated for all nodes in the tree, noting that roots <code>B</code> connected to the root node <code>A</code> have equal probabilistic and additive edges <code>coanc_A_B</code> (unless the tree has a root edge, in which case that one is used to transform as above), and the edge of a node <code>C</code> not directly connected to a root uses the calculated edge <code>coanc_A_C</code> as above to shrink its children's edges into the additive scale.
</p>


<h3>Value</h3>

<p>The input <code>phylo</code> object extended so that the main edges (<code>tree$edge.length</code>) are probabilistic edges, and the additive edges are stored in <code>tree$edge.length.add</code>.
This is so for both values of <code>rev</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coanc_tree">coanc_tree()</a></code>, the key application facilitated by additive edges.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for simulating a tree with `rtree`
library(ape)

# SETUP: number of tip subpopulations
k &lt;- 5
# simulate a random tree
# edges are drawn from Uniform(0, 1), so these are valid probabilistic edges
tree &lt;- rtree( k )
# inspect edges
tree$edge.length

# RUN calculate additive edges (safe to overwrite object)
tree &lt;- tree_additive( tree )
# inspect edges again
# probabilistic edges are still main edges:
tree$edge.length
# additive edges are here
tree$edge.length.add


# let's go backwards now, starting from the additive edges
# SETUP
# these are harder to simulate, so let's copy the previous value to the main edges
tree$edge.length &lt;- tree$edge.length.add
# and delete the extra entry (if it's present, function stops)
tree$edge.length.add &lt;- NULL
# inspect before
tree$edge.length

# RUN reverse version (safe to overwrite object again)
tree &lt;- tree_additive( tree, rev = TRUE )
# inspect after
# probabilistic edges are main edges:
tree$edge.length
# additive edges (previously main edges) were moved here
tree$edge.length.add

</code></pre>

<hr>
<h2 id='tree_reindex_tips'>Reindex tree tips in order of appearance in edges</h2><span id='topic+tree_reindex_tips'></span>

<h3>Description</h3>

<p>The <code>phylo</code> object from the <code>ape</code> package (see <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code>) permits mismatches between the order of tips as present in the tip labels vector (<code>tree$tip.label</code>) and in the edge matrix (<code>tree$edge</code>), which can cause mismatches in plots and other settings.
This function reindexes edges and tips so that they agree in tip order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_reindex_tips(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_reindex_tips_+3A_tree">tree</code></td>
<td>
<p>A <code>phylo</code> object from the <code>ape</code> package (see <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code>).
Works with standard <code>phylo</code> objects, and also with our extended trees (in that additive edges <code>tree$edge.length.add</code> are recalculated after reordering if they were present).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Order mismatches between tip labels vector and edge matrix can lead to disagreeing order downstream, in variables that order tips as in the labels vector (such as the coancestry matrices output by our <code><a href="#topic+coanc_tree">coanc_tree()</a></code>) and tree plots (whose order is guided by the edge matrix, particularly when the edge matrix is ordered by clade as in <code><a href="ape.html#topic+reorder.phylo">ape::reorder.phylo()</a></code>).
</p>
<p>This function first reorders the edges of the input tree using <code><a href="ape.html#topic+reorder.phylo">ape::reorder.phylo()</a></code> with default option <code>order = 'cladewise'</code>, which will list edges and tip nodes in plotting order.
Then tips are indexed so that the first tip to appear has index 1 in the edge matrix (and consequently appears first in the tip labels vector), the second has index 2, and so on.
Thus, the output tree has both edges and tips reordered, to have a consistent tip order and best experience visualizing trees and their coancestry matrices.
</p>


<h3>Value</h3>

<p>The modified <code>tree</code> (<code>phylo</code> object) with reordered edges and tips.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree_reorder">tree_reorder()</a></code> for reordering tree structure so that tips appear in a particular desired order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a random tree
library(ape)
k &lt;- 5
tree &lt;- rtree( k )

# trees constructed this way are already ordered as desired, so this function doesn't change it:
tree2 &lt;- tree_reindex_tips( tree )
# tree2 equals tree!

# let's scramble the edges on purpose
# to create an example where reindexing is needed

tree_rand &lt;- tree
# new order of edges
indexes &lt;- sample( Nedge( tree_rand ) )
# reorder all edge values
tree_rand$edge &lt;- tree_rand$edge[ indexes, ]
tree_rand$edge.length &lt;- tree_rand$edge.length[ indexes ]
# now let's reorder edges slightly so tree is more reasonable-looking
# (otherwise plot looks tangled)
tree_rand &lt;- reorder( tree_rand, order = 'postorder' )
# you can now see that, unless permutation got lucky,
# the order of the tip labels in the vector and on the plot disagree:
tree_rand$tip.label
plot( tree_rand )

# now reorder tips to match plotting order (as defined in the `edge` matrix)
tree_rand &lt;- tree_reindex_tips( tree_rand )
# now tip labels vector and plot should agree in order:
# (plot was not changed)
tree_rand$tip.label
plot( tree_rand )

</code></pre>

<hr>
<h2 id='tree_reorder'>Reorder tree tips to best match a desired order</h2><span id='topic+tree_reorder'></span>

<h3>Description</h3>

<p>This functions reorganizes the tree structure so that its tips appear in a desired order if possible, or in a reasonably close order when an exact solution is impossible.
This tip order in the output tree is the same in both the tip labels vector (<code>tree$tip.label</code>) and edge matrix (<code>tree$edge</code>), ensured by using <code><a href="#topic+tree_reindex_tips">tree_reindex_tips()</a></code> internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_reorder(tree, labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_reorder_+3A_tree">tree</code></td>
<td>
<p>A <code>phylo</code> object from the <code>ape</code> package (see <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code>).
Works with standard <code>phylo</code> objects, and also with our extended trees (in that additive edges <code>tree$edge.length.add</code> are recalculated after reordering if they were present).</p>
</td></tr>
<tr><td><code id="tree_reorder_+3A_labels">labels</code></td>
<td>
<p>A character vector with all tip labels in the desired order.
Must contain each tip label in <code>tree</code> exactly once.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has the same goal as <code><a href="ape.html#topic+rotate">ape::rotateConstr()</a></code>, which implements a different heuristic algorithm that did not perform well in our experience.
</p>


<h3>Value</h3>

<p>The modified <code>tree</code> (<code>phylo</code> object) with reordered edges and tips.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree_reindex_tips">tree_reindex_tips()</a></code> to reorder tips in the labels vector to match the edge matrix order, which ensures agreement in plots (assuming plot show desired order already).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a random tree
library(ape)
k &lt;- 5
tree &lt;- rtree( k )
# let's set the current labels as the desired order
labels &lt;- tree$tip.label

# now let's scramble the edges on purpose
# to create an example where reordering is needed

tree_rand &lt;- tree
# new order of edges
indexes &lt;- sample( Nedge( tree_rand ) )
# reorder all edge values
tree_rand$edge &lt;- tree_rand$edge[ indexes, ]
tree_rand$edge.length &lt;- tree_rand$edge.length[ indexes ]
# now let's reorder edges slightly so tree is more reasonable-looking
# (otherwise plot looks tangled)
tree_rand &lt;- reorder( tree_rand, order = 'postorder' )
# the order of the tip labels in the vector and on the plot disagree with each other:
tree_rand$tip.label
plot( tree_rand )

# now reorder tree object so tips are in the desired order:
tree_rand &lt;- tree_reorder( tree_rand, labels )
# now tip labels vector and plot should agree in order:
# (the original tree was recovered!)
tree_rand$tip.label
plot( tree_rand )

# order the tree in a different way than the original order
labels &lt;- paste0( 't', 1 : k )
# in this case, it's often impossible to get a perfect output order
# (because the tree structure constrains the possible plot orders),
# but this function tries its best to get close to the desired order
tree2 &lt;- tree_reorder( tree, labels )
plot(tree2)

</code></pre>

<hr>
<h2 id='undiff_af'>Undifferentiate an allele distribution</h2><span id='topic+undiff_af'></span>

<h3>Description</h3>

<p>This function takes a vector of allele frequencies and a mean kinship value, and returns a new distribution of allele frequencies that is consistent with reversing differentiation with the given kinship, in the sense that the new distribution is more concentrated around the middle (0.5) than the input/original by an amount predicted from theory.
The new distribution is created by weighing the input distribution with a random mixing distribution with a lower variance.
An automatic method is provided that always selects a Beta distribution with just the right concentration to work for the given data and kinship.
Explicit methods are also provided for more control, but are more likely to result in errors when mixing variances are not small enough (see details below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undiff_af(
  p,
  kinship_mean,
  distr = c("auto", "uniform", "beta", "point"),
  alpha = 1,
  eps = 10 * .Machine$double.eps
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="undiff_af_+3A_p">p</code></td>
<td>
<p>A vector of observed allele frequencies.</p>
</td></tr>
<tr><td><code id="undiff_af_+3A_kinship_mean">kinship_mean</code></td>
<td>
<p>The mean kinship value of the differentiation to reverse.</p>
</td></tr>
<tr><td><code id="undiff_af_+3A_distr">distr</code></td>
<td>
<p>Name of the mixing distribution to use.
</p>

<ul>
<li><p> &quot;auto&quot; picks a symmetric Beta distribution with parameters that ensure a small enough variance to succeed.
</p>
</li>
<li><p> &quot;beta&quot; is a symmetric Beta distribution with parameter <code>alpha</code> as provided below.
</p>
</li>
<li><p> &quot;uniform&quot; is a uniform distribution (same as &quot;beta&quot; with <code>alpha = 1</code>).
</p>
</li>
<li><p> &quot;point&quot; is a distribution fully concentrated/fixed at 0.5 (same as the limit of &quot;beta&quot; with <code>alpha = Inf</code>, which has zero variance).
</p>
</li></ul>
</td></tr>
<tr><td><code id="undiff_af_+3A_alpha">alpha</code></td>
<td>
<p>Shape parameter for <code>distr = "beta"</code>, ignored otherwise.</p>
</td></tr>
<tr><td><code id="undiff_af_+3A_eps">eps</code></td>
<td>
<p>If <code>distr = "auto"</code>, this small value is added to the calculated <code>alpha</code> to avoid roundoff errors and ensuring that the mixing variance is smaller than the maximum allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model: Suppose we started from an allele frequency <code>p0</code> with expectation 0.5 and variance <code>V0</code>.
Differentiation creates a new (sample) allele frequency <code>p1</code> without changing its mean (<code>E(p1|p0) = p0</code>) and with a conditional variance given by the mean kinship <code>phi</code>: <code>Var(p1|p0) = p0*(1-p0)*phi</code>.
The total variance of the new distribution (calculated using the law of total variance) equals
<code>V1 = Var(p1) = phi/4 + (1-phi)*V0</code>.
(Also <code>E(p1) = 0.5</code>).
So the new variance is greater for <code>phi&gt;0</code> (note <code>V0 &lt;= 1/4</code> for any distribution bounded in (0,1)).
Thus, given <code>V1</code> and <code>phi</code>, the goal is to construct a new distribution with the original, lower variance of <code>V0 = (V1-phi/4)/(1-phi)</code>.
An error is thrown if <code>V1 &lt; phi/4</code> in input data, which is inconsistent with this assumed model.
</p>
<p>Construction of &quot;undifferentiated&quot; allele frequencies:
<code>p_out = w*p_in + (1-w)*p_mix</code>, where <code>p_in</code> is the input with sample variance <code>V_in</code> (<code>V1</code> in above model) and <code>p_mix</code> is a random draw from the mixing distribution <code>distr</code> with expectation 0.5 and known variance <code>V_mix</code>.
The output variance is <code>V_out = w^2*V_in + (1-w)^2*V_mix</code>, which we set to the desired <code>V_out = (V_in-phi/4)/(1-phi)</code> (<code>V0</code> in above model) and solve for <code>w</code> (the largest of the two quadratic roots is used).
An error is thrown if <code>V_mix &gt; V_out</code> (the output variance must be larger than the mixing variance).
This error is avoided by manually adjusting choice of <code>distr</code> and <code>alpha</code> (for <code>distr = "beta"</code>), or preferably with <code>distr = "auto"</code> (default), which selects a Beta distribution with <code>alpha = (1/(4*V_out)-1)/2 + eps</code> that is guaranteed to work for any valid <code>V_out</code> (assuming <code>V_in &lt; phi/4</code>).
</p>


<h3>Value</h3>

<p>A list with the new distribution and several other informative statistics, which are named elements:
</p>

<ul>
<li> <p><code>p</code>: A new vector of allele frequencies with the same length as input <code>p</code>, with the desired variance (see details) obtained by weighing the input <code>p</code> with new random data from distribution <code>distr</code>.
</p>
</li>
<li> <p><code>w</code>: The weight used for the input data (<code>1-w</code> for the mixing distribution).
</p>
</li>
<li> <p><code>kinship_mean_max</code>: The maximum mean kinship possible for undifferentiating this data (equals four times the input variance (see details), which results in zero output variance).
</p>
</li>
<li> <p><code>V_in</code>: sample variance of input <code>p</code>, assuming its expectation is 0.5.
</p>
</li>
<li> <p><code>V_out</code>: target variance of output <code>p</code>.
</p>
</li>
<li> <p><code>V_mix</code>: variance of mixing distribution.
</p>
</li>
<li> <p><code>alpha</code>: the value of <code>alpha</code> used for symmetric Beta mixing distribution, informative if <code>distr = "auto"</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># create random uniform data for these many loci
m &lt;- 100
p &lt;- runif( m )
# differentiate the distribution using Balding-Nichols model
F &lt;- 0.1
nu &lt;- 1 / F - 1
p2 &lt;- rbeta( m, p * nu, (1 - p) * nu )

# now undifferentiate with this function
# NOTE in this particular case `F` is also the mean kinship
# default "automatic" distribution recommended
# (avoids possible errors for specific distributions)
p3 &lt;- undiff_af( p2, F )$p

# note p3 does not equal p exactly (original is unrecoverable)
# but variances (assuming expectation is 0.5 for all) should be close to each other,
# and both be lower than p2's variance:
V1 &lt;- mean( ( p - 0.5 )^2 )
V2 &lt;- mean( ( p2 - 0.5 )^2 )
V3 &lt;- mean( ( p3 - 0.5 )^2 )
# so p3 is stochastically consistent with p as far as the variance is concerned

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
