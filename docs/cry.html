<!DOCTYPE html><html><head><title>Help for package cry</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cry}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#angle'><p>Constructor for an S3 object of class &quot;angle&quot;</p></a></li>
<li><a href='#avei_vs_res'><p>Mean and standard deviation in resolution shells.</p></a></li>
<li><a href='#bravais'><p>Constructor for an S3 object of class &quot;bravais&quot;</p></a></li>
<li><a href='#calculate_cell_volume'><p>S3 generic to compute cell volume</p></a></li>
<li><a href='#calculate_cell_volume.rec_unit_cell'><p>Volume of a reciprocal unit cell (in angstroms^(-3))</p></a></li>
<li><a href='#calculate_cell_volume.unit_cell'><p>Volume of a unit cell (in angstroms^3)</p></a></li>
<li><a href='#change_COLSRC'><p>Change COLSRC date and time stamp</p></a></li>
<li><a href='#check_angle_validity'><p>Validity and compatibility of a cry object of class 'angle'</p></a></li>
<li><a href='#check_bravais_validity'><p>Validity and compatibility of a cry object of class 'bravais'</p></a></li>
<li><a href='#check_cryst_symm_validity'><p>Validity and compatibility of a cry object of class 'cryst_symm'</p></a></li>
<li><a href='#check_merged_reflections_validity'><p>Validity and compatibility of a cry object of</p>
class 'merged_reflections'</a></li>
<li><a href='#check_rec_unit_cell_validity'><p>Validity and compatibility of a cry object of class 'rec_unit_cell'</p></a></li>
<li><a href='#check_unit_cell_validity'><p>Validity and compatibility of a cry object of class 'unit_cell'</p></a></li>
<li><a href='#check_validity'><p>Validity and compatibility of cry objects</p></a></li>
<li><a href='#create_merged_reflections'><p>S3 generic to create merged_reflections objects</p></a></li>
<li><a href='#create_merged_reflections.default'><p>Default method for generic &quot;create_merged_reflections&quot;</p></a></li>
<li><a href='#create_rec_unit_cell'><p>S3 generic to create rec_unit_cell objects</p></a></li>
<li><a href='#create_rec_unit_cell.bravais'><p>Reciprocal unit cell starting from a Bravais symbol</p></a></li>
<li><a href='#create_rec_unit_cell.cryst_symm'><p>Reciprocal unit cell from a 'cryst_symm' object</p></a></li>
<li><a href='#create_rec_unit_cell.default'><p>Default method for generic &quot;create_rec_unit_cell&quot;</p></a></li>
<li><a href='#create_rec_unit_cell.unit_cell'><p>Reciprocal unit cell starting from a unit cell</p></a></li>
<li><a href='#create_unit_cell'><p>S3 generic to create unit_cell objects</p></a></li>
<li><a href='#create_unit_cell.bravais'><p>Unit cell starting from a Bravais symbol</p></a></li>
<li><a href='#create_unit_cell.cryst_symm'><p>Unit cell from a 'cryst_symm' object</p></a></li>
<li><a href='#create_unit_cell.default'><p>Default method for generic &quot;create_unit_cell&quot;</p></a></li>
<li><a href='#create_unit_cell.rec_unit_cell'><p>Unit cell starting from a reciprocal unit cell</p></a></li>
<li><a href='#cryst_symm'><p>Constructor for an S3 object of class &quot;cryst_symm&quot;.</p></a></li>
<li><a href='#crystal_family'><p>Crystal family corresponding to given space group.</p></a></li>
<li><a href='#crystal_system'><p>Crystal system corresponding to given space group.</p></a></li>
<li><a href='#deplete_systematic_absences'><p>Deplete systematic absences</p></a></li>
<li><a href='#extract_symmetry_info'><p>Information on a specific space group</p></a></li>
<li><a href='#find_symm_setting'><p>Find specific space group setting</p></a></li>
<li><a href='#findHM'><p>Correct spelling for Herman-Mauguin space groups symbols</p></a></li>
<li><a href='#frac_to_orth'><p>From fractional to orthogonal coordinates</p></a></li>
<li><a href='#full_symm_strings'><p>Symmetry operations in human readable form</p></a></li>
<li><a href='#generate_miller'><p>Generate Miller indices</p></a></li>
<li><a href='#hkl_to_reso'><p>Calculates resolution, given the Miller indices</p></a></li>
<li><a href='#lattice_stuff'><p>Calculation of useful lattice parameters</p></a></li>
<li><a href='#lowest_uc_compatible_SG'><p>Space group compatible with given cell</p></a></li>
<li><a href='#merged_reflections'><p>Constructor for an S3 object of class &quot;merged_reflections&quot;.</p></a></li>
<li><a href='#num_symm_settings'><p>Number of space group settings</p></a></li>
<li><a href='#op_xyz_list_to_matrix_list'><p>List of matrices and vectors of a specific space group</p></a></li>
<li><a href='#op_xyz_to_matrix'><p>Human-readable symmetry operator into matrix and vector</p></a></li>
<li><a href='#orth_to_frac'><p>From orthogonal to fractional coordinates</p></a></li>
<li><a href='#plot_SHELX'><p>Plot SHELXC log files</p></a></li>
<li><a href='#print.angle'><p>Print method for an object of class &quot;angle&quot;.</p></a></li>
<li><a href='#print.bravais'><p>Print method for an object of class &quot;bravais&quot;.</p></a></li>
<li><a href='#print.cryst_symm'><p>Print method for an object of class &quot;cryst_symm&quot;.</p></a></li>
<li><a href='#print.rec_unit_cell'><p>Print method for an object of class &quot;rec_unit_cell&quot;.</p></a></li>
<li><a href='#print.unit_cell'><p>Print method for an object of class &quot;unit_cell&quot;.</p></a></li>
<li><a href='#read_SHELX_log'><p>Reads and SHELXD log files</p></a></li>
<li><a href='#readCIF'><p>Reads and output a CIF file</p></a></li>
<li><a href='#readmm_CIF'><p>Reads and output an mmCIF file</p></a></li>
<li><a href='#readMTZ'><p>Load an MTZ file</p></a></li>
<li><a href='#readMTZHeader'><p>Reads and output an MTZ header</p></a></li>
<li><a href='#readpd_rtv'><p>Reads and output a CIF file for powder diffraction</p></a></li>
<li><a href='#readSF_CIF'><p>Reads and output an CIF file</p></a></li>
<li><a href='#readsm_REFL'><p>Reads and output an CIF file</p></a></li>
<li><a href='#readXDS_ASCII'><p>Load an XDS_ASCII file.</p></a></li>
<li><a href='#readXDS_ASCIIHeader'><p>Load an XDS_ASCII file's header.</p></a></li>
<li><a href='#rec_unit_cell'><p>Constructor for an S3 object of class &quot;rec_unit_cell.</p></a></li>
<li><a href='#syminfo_to_matrix_list'><p>Operators of a specific space group in matrix form</p></a></li>
<li><a href='#syminfo_to_op_xyz_list'><p>Operators of a specific space group</p></a></li>
<li><a href='#symm_to_cell_const'><p>Cell parameter constrains from symmetry</p></a></li>
<li><a href='#sysabs'><p>Locate systematic absences</p></a></li>
<li><a href='#theme_cry'><p>cry theme for ggplot2</p></a></li>
<li><a href='#translate_SG'><p>Translation of space group symbols, numbers, etc.</p></a></li>
<li><a href='#unit_cell'><p>Constructor for an S3 object of class &quot;unit_cell.</p></a></li>
<li><a href='#writeMTZ'><p>Write data to an MTZ file</p></a></li>
<li><a href='#writeXDS_ASCII'><p>Write data to an XDS_ASCII file.</p></a></li>
<li><a href='#xtal_mat01'><p>Matrix for cell orthogonalisation (first choice)</p></a></li>
<li><a href='#xtal_mat02'><p>Matrix for cell orthogonalisation (second choice)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistics for Structural Crystallography</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-05</td>
</tr>
<tr>
<td>Description:</td>
<td>Reading and writing of files in the most commonly used formats of
  structural crystallography. It includes functions to work with a variety
  of statistics used in this field and functions to perform basic
  crystallographic computing. References: D. G. Waterman, J. Foadi, G. Evans 
  (2011) &lt;<a href="https://doi.org/10.1107%2FS0108767311084303">doi:10.1107/S0108767311084303</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, zoo, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, markdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jfoadi.github.io/cry/">https://jfoadi.github.io/cry/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-05 14:03:56 UTC; james</td>
</tr>
<tr>
<td>Author:</td>
<td>James Foadi [cre, aut],
  David Waterman [aut],
  Rita Giordano [aut],
  Kutumbarao Nidamarthi [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Foadi &lt;james_foadi@yahoo.co.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-10 08:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='angle'>Constructor for an S3 object of class &quot;angle&quot;</h2><span id='topic+angle'></span>

<h3>Description</h3>

<p>Constructor for an S3 object of class &quot;angle&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle(ang, rad_flag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle_+3A_ang">ang</code></td>
<td>
<p>A real number, in degrees or radians depending on rad_flag.</p>
</td></tr>
<tr><td><code id="angle_+3A_rad_flag">rad_flag</code></td>
<td>
<p>A logical flag. If FALSE, the value is meant to be in radians.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;angle&quot; whose numerical value is always in degrees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an angle of 60 degrees
ang1 &lt;- angle(60)
class(ang1)
</code></pre>

<hr>
<h2 id='avei_vs_res'>Mean and standard deviation in resolution shells.</h2><span id='topic+avei_vs_res'></span>

<h3>Description</h3>

<p>Calculates averages and standard deviations of the input vector quantity for all
reflections, corresponding to shells of resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avei_vs_res(nbin, resos, II = NULL, m = max(resos), M = min(resos))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avei_vs_res_+3A_nbin">nbin</code></td>
<td>
<p>A positive integer. The number of resolution shells.</p>
</td></tr>
<tr><td><code id="avei_vs_res_+3A_resos">resos</code></td>
<td>
<p>A vector of real quantities. These are the resolutions (in angstroms)
corresponding to the data vector, II. If the data vector is missing, the averages
will be computed just for resos.</p>
</td></tr>
<tr><td><code id="avei_vs_res_+3A_ii">II</code></td>
<td>
<p>A vector of real quantities. This is the key quantity whose averages
and standard deviations are calculated. If <code>II</code> is set to <code>NULL</code>, resolutions
averages and standard deviations will be the calculated quantities.</p>
</td></tr>
<tr><td><code id="avei_vs_res_+3A_m">m</code></td>
<td>
<p>Minimum (highest) resolution (in angstroms). Data with resolution smaller than m
will be ignored when calculating the averages.</p>
</td></tr>
<tr><td><code id="avei_vs_res_+3A_m">M</code></td>
<td>
<p>Maximum (lowest) resolution (in angstroms). Data with resolution larger than M
will be ignored when calculating the averages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Binning is done with inverse resolutions in order to have lower resolutions
correspond to small numbers and high resolutions to large numbers. The output
<code>mids</code>, <code>ave</code> and <code>sd</code> correspond to inverse resolutions.
</p>


<h3>Value</h3>

<p>A named list of length 4. <code>counts</code> is a vector of integers, the number of
reflections in each resolution shell. <code>mids</code> is the representative inverse resolution
for each resolution shell; the value is decided by the function <code>hist</code>. <code>ave</code>
is the average value in each resolution shell and <code>sd</code> is the corresponding standard
deviation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"1dei_phases.mtz")
lmtz &lt;- readMTZ(filename)
hkl &lt;- lmtz$reflections[,1:3]
II &lt;- lmtz$reflections[,4]
cpars &lt;- lmtz$header$CELL
resos &lt;- hkl_to_reso(hkl[,1],hkl[,2],hkl[,3],
                     cpars[1],cpars[2],cpars[3],
                     cpars[4],cpars[5],cpars[6])
ltmp &lt;- avei_vs_res(20,resos,II)
plot(ltmp$mids,ltmp$ave,type="b",pch=16)
</code></pre>

<hr>
<h2 id='bravais'>Constructor for an S3 object of class &quot;bravais&quot;</h2><span id='topic+bravais'></span>

<h3>Description</h3>

<p>There are 14 Bravais lattices. They are represented by a two-letter symbol:
aP, mP, mS, oP, oS, oF, oI, tP, tI, hP, hR, cP, cF, cI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bravais(bt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bravais_+3A_bt">bt</code></td>
<td>
<p>A two-letter character, denoting the Bravais type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;bravais&quot;. It is a named list of length 4. The first slot, &quot;bt&quot;, is
the universally-used two-letter symbol. The second, third and fourth slots are, respectively,
&quot;cr_fam&quot; (the corresponding crystal family), &quot;cr_sys&quot; (the corresponding crystal system) and
&quot;lt_sys&quot; (the corresponding lattice system).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># mS is a monoclinic, face-centred Bravais lattice
bt &lt;- bravais("mS")
class(bt)
bt[1:4]

</code></pre>

<hr>
<h2 id='calculate_cell_volume'>S3 generic to compute cell volume</h2><span id='topic+calculate_cell_volume'></span>

<h3>Description</h3>

<p>The volume of a unit cell and a reciprocal unit cell can be calculated starting
from specific objects, files, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_cell_volume(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_cell_volume_+3A_x">x</code></td>
<td>
<p>An object used to select a method. Either an object of class
unit_cell or an object of class rec_unit_cell.</p>
</td></tr>
<tr><td><code id="calculate_cell_volume_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>V A real number. The volume (in angstroms^3 or angstroms^-3)
of the input unit cell or reciprocal unit cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the volume of a unit cell
uc &lt;- unit_cell(20)
V &lt;- calculate_cell_volume(uc)

# Calculate the volume of the corresponding reciprocal cell
ruc &lt;- create_rec_unit_cell(uc)
Vrec &lt;- calculate_cell_volume(ruc)
V*Vrec  # Should be 1!

</code></pre>

<hr>
<h2 id='calculate_cell_volume.rec_unit_cell'>Volume of a reciprocal unit cell (in angstroms^(-3))</h2><span id='topic+calculate_cell_volume.rec_unit_cell'></span>

<h3>Description</h3>

<p>Method of the S3 generic class &quot;calculate_cell_volume&quot;, to calculate the
volume, in reciprocal cubic angstroms, of the reciprocal unit cell corresponding
to the input object of class &quot;rec_unit_cell&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rec_unit_cell'
calculate_cell_volume(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_cell_volume.rec_unit_cell_+3A_x">x</code></td>
<td>
<p>An object of class &quot;rec_unit_cell&quot;.</p>
</td></tr>
<tr><td><code id="calculate_cell_volume.rec_unit_cell_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the calculate_cell_volume methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive numeric, the volume in reciprocal cubic angstroms of the
reciprocal unit cell corresponding to the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a monoclinic cell and the corresponding reciprocal
bt &lt;- bravais("mP")
uc &lt;- create_unit_cell(bt)
ruc &lt;- create_rec_unit_cell(uc)

# Calculate reciprocall cell volume
calculate_cell_volume(ruc)

</code></pre>

<hr>
<h2 id='calculate_cell_volume.unit_cell'>Volume of a unit cell (in angstroms^3)</h2><span id='topic+calculate_cell_volume.unit_cell'></span>

<h3>Description</h3>

<p>Method of the S3 generic class &quot;calculate_cell_volume&quot;, to calculate the
volume, in cubic angstroms, of the unit cell corresponding to the input
object of class &quot;unit_cell&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unit_cell'
calculate_cell_volume(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_cell_volume.unit_cell_+3A_x">x</code></td>
<td>
<p>An object of class &quot;unit_cell&quot;.</p>
</td></tr>
<tr><td><code id="calculate_cell_volume.unit_cell_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the calculate_cell_volume methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive numeric, the volume in cubic angstroms of the unit cell
corresponding to the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a monoclinic cell
bt &lt;- bravais("mP")
uc &lt;- create_unit_cell(bt)
print(uc)

# Calculate cell volume
calculate_cell_volume(uc)

</code></pre>

<hr>
<h2 id='change_COLSRC'>Change COLSRC date and time stamp</h2><span id='topic+change_COLSRC'></span>

<h3>Description</h3>

<p>Function to update the <code>created</code> column of the data
frame <code>COLSRC</code> with current date and time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_COLSRC(hdr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_COLSRC_+3A_hdr">hdr</code></td>
<td>
<p>A data frame. The <code>COLSRC</code> data frame included
in the <code>header</code> component of the named list
obtained with <code><a href="#topic+readMTZ">readMTZ</a></code> or
<code><a href="#topic+readMTZHeader">readMTZHeader</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The COLSRC data frame of an MTZ header has a column called
<code>created</code> which displays the date and time at which the
MTZ file data columns were created. When writing out a
modified list obtained from reading an MTZ file, one might
want to change the <code>created</code> column with the current
date and time. Other specific types of change can be operated
by handling the <code>COLSRC</code> data frame in an *ad hoc* manner.
</p>


<h3>Value</h3>

<p>The <code>hdr</code> input data frame with the <code>created</code>
column of the <code>COLSRC</code> data frame changed to
display the current date and time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read a sample MTZ file
datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"1dei_phases.mtz")
lMTZ &lt;- readMTZ(filename)

# Original COLSRC
print(lMTZ$header$COLSRC)

# Update date and time stamp
lMTZ$header &lt;- change_COLSRC(lMTZ$header)

# New COLSRC
print(lMTZ$header$COLSRC)

</code></pre>

<hr>
<h2 id='check_angle_validity'>Validity and compatibility of a cry object of class 'angle'</h2><span id='topic+check_angle_validity'></span>

<h3>Description</h3>

<p>An object of class 'angle' is a numeric with logical attribute &quot;rad_flag&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_angle_validity(x, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_angle_validity_+3A_x">x</code></td>
<td>
<p>Object of class angle.</p>
</td></tr>
<tr><td><code id="check_angle_validity_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE, the function
prints a message on the errors, if any
(default is FALSE, i.e. no message printed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ans A logical value. TRUE means that the input is
a valid object of class 'angle'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an object of class angle
x &lt;- angle(80)

# Check its validity
check_angle_validity(x)

# Modify the 'rad_flag' attribute
attr(x,"rad_flag") &lt;- 12.5

# Check its validity
check_angle_validity(x,TRUE)

</code></pre>

<hr>
<h2 id='check_bravais_validity'>Validity and compatibility of a cry object of class 'bravais'</h2><span id='topic+check_bravais_validity'></span>

<h3>Description</h3>

<p>An object of class 'bravais' is a named list of length 4. The first slot, &quot;bt&quot;, is
the universally-used two-letter symbol. The second, third and fourth slots are, respectively,
&quot;cr_fam&quot; (the corresponding crystal family), &quot;cr_sys&quot; (the corresponding crystal system) and
&quot;lt_sys&quot; (the corresponding lattice system).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_bravais_validity(x, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_bravais_validity_+3A_x">x</code></td>
<td>
<p>Object of class 'bravais'.</p>
</td></tr>
<tr><td><code id="check_bravais_validity_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE, the function
prints a message on the errors, if any
(default is FALSE, i.e. no message printed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ans A logical value. TRUE means that the input is
a valid object of class 'bravais'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an object of class 'bravais'
x &lt;- bravais("mP")

# Check its validity
check_bravais_validity(x,TRUE)

</code></pre>

<hr>
<h2 id='check_cryst_symm_validity'>Validity and compatibility of a cry object of class 'cryst_symm'</h2><span id='topic+check_cryst_symm_validity'></span>

<h3>Description</h3>

<p>An object of class 'cryst_symm' is a named list of length 4. The first field is a
character string, the second field is a <code class="reqn">3\times 3</code> array and the third and fourth
field are <code class="reqn">3 \times 1</code> arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cryst_symm_validity(x, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_cryst_symm_validity_+3A_x">x</code></td>
<td>
<p>Object of class 'cryst_symm'.</p>
</td></tr>
<tr><td><code id="check_cryst_symm_validity_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE, the function
prints a message on the errors, if any
(default is FALSE, i.e. no message printed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ans A logical value. TRUE means that the input is a valid object of class'cryst_symm'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an object of class 'cryst_symm'
x &lt;- cryst_symm(15)

# Check its validity
check_cryst_symm_validity(x)

# Now change a field
x$PG[[1]] &lt;- matrix(rep(0,times=9),ncol=3)

# Check validity again
check_cryst_symm_validity(x,TRUE)

</code></pre>

<hr>
<h2 id='check_merged_reflections_validity'>Validity and compatibility of a cry object of
class 'merged_reflections'</h2><span id='topic+check_merged_reflections_validity'></span>

<h3>Description</h3>

<p>An object of class 'merged_reflections' is a named list of
length 4:
</p>

<dl>
<dt>ruc</dt><dd><p>An object of class &quot;rec_unit_cell&quot;.</p>
</dd>
<dt>csym</dt><dd><p>An object of class &quot;cryst_symm&quot;.</p>
</dd>
<dt>records</dt><dd><p>A data frame containing the data.</p>
</dd>
<dt>dtypes</dt><dd><p>A character vector containing the
type of data (Miller indices, structure
factors, etc).</p>
</dd>
</dl>

<p>Internal consistency must be displayed between the object
'ruc' and the object 'csym' because groups of crystallographic
symmetries are compatible only with certain unit cells (and,
accordingly, certain reciprocal cells).
It is not possible to check consistency between dtypes and
the nature of data in each column of the data frame 'records',
but a check about length of 'dtypes' and number of columns is
possible. Therefore, the user should pay attention to the
nature of his/her data. Also, merged reflection data, having
to be compatible with crystal symmetry, have to display the
appropriate systematic absences. Users interested in keeping
systematic absences in the object, might want to look at the
object of class &quot;raw_reflections&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_merged_reflections_validity(x, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_merged_reflections_validity_+3A_x">x</code></td>
<td>
<p>Object of class 'merged_reflections'.</p>
</td></tr>
<tr><td><code id="check_merged_reflections_validity_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE, the function
prints a message on the errors, if any.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ans A logical value. TRUE means that the input is
a valid object of class'merged_reflections'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an object of class 'merged_reflections'
# (default ara data associated with a cubic cell)
x &lt;- merged_reflections()

# Check its validity
check_merged_reflections_validity(x)

# Now change reciprocal unit cell (to triclinic)
uc &lt;- unit_cell(10,20,30,30,50,70)
ruc &lt;- create_rec_unit_cell(uc)
x$ruc &lt;- ruc

# Check validity again
check_merged_reflections_validity(x)

</code></pre>

<hr>
<h2 id='check_rec_unit_cell_validity'>Validity and compatibility of a cry object of class 'rec_unit_cell'</h2><span id='topic+check_rec_unit_cell_validity'></span>

<h3>Description</h3>

<p>An object of class 'rec_unit_cell' is a named list of length 6. The first three fields are
numeric, the last three of class 'angle'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_rec_unit_cell_validity(x, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_rec_unit_cell_validity_+3A_x">x</code></td>
<td>
<p>Object of class 'rec_unit_cell'.</p>
</td></tr>
<tr><td><code id="check_rec_unit_cell_validity_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE, the function
prints a message on the errors, if any
(default is FALSE, i.e. no message printed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ans A logical value. TRUE means that the input is a
valid object of class'rec_unit_cell'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an object of class 'rec_unit_cell'
x &lt;- create_rec_unit_cell()

# Check its validity
check_rec_unit_cell_validity(x)

# Now change a field
x$alphar &lt;- 123

# Check validity again
check_rec_unit_cell_validity(x,TRUE)

</code></pre>

<hr>
<h2 id='check_unit_cell_validity'>Validity and compatibility of a cry object of class 'unit_cell'</h2><span id='topic+check_unit_cell_validity'></span>

<h3>Description</h3>

<p>An object of class 'unit_cell' is a named list of length 6. The first three fields are
numeric, the last three of class 'angle'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_unit_cell_validity(x, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_unit_cell_validity_+3A_x">x</code></td>
<td>
<p>Object of class 'unit_cell'.</p>
</td></tr>
<tr><td><code id="check_unit_cell_validity_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE, the function
prints a message on the errors, if any
(default is FALSE, i.e. no message printed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ans A logical value. TRUE means that the input is a
valid object of class'unit_cell'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an object of class 'unit_cell'
x &lt;- create_unit_cell()

# Check its validity
check_unit_cell_validity(x)

# Now change a field
x$alpha &lt;- 123

# Check validity again
check_unit_cell_validity(x,TRUE)

</code></pre>

<hr>
<h2 id='check_validity'>Validity and compatibility of cry objects</h2><span id='topic+check_validity'></span>

<h3>Description</h3>

<p>Compatibility of cry objects The objects that can be created in cry are subject to issues of
compatibility of the parameters forming them. For example, the unit cell of a cubic system
cannot have the a, b, c sides different from each other. The present function returns TRUE if
all parts composing the object are compatible with each other. Otherwise it returns FALSE and
one or more warnings with details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_validity(x, y = NULL, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_validity_+3A_x">x</code></td>
<td>
<p>A first object of one of the new cry classes.</p>
</td></tr>
<tr><td><code id="check_validity_+3A_y">y</code></td>
<td>
<p>A second  object of one of the new cry classes.</p>
</td></tr>
<tr><td><code id="check_validity_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE, the function
prints a message on the errors, if any
(default is FALSE, i.e. no message printed).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available checks for individual objects are:
</p>

<ul>
<li> <p><strong>angle</strong> (unit cell angle)
</p>
</li>
<li> <p><strong>bravais</strong> (Bravais system)
</p>
</li>
<li> <p><strong>unit_cell</strong> (unit cell)
</p>
</li>
<li> <p><strong>rec_unit_cell</strong> (reciprocal unit cell)
</p>
</li>
<li> <p><strong>cryst_symm</strong> (crystallographic symmetry)
</p>
</li>
<li> <p><strong>merged_reflections</strong> (scaled and merged data)
</p>
</li></ul>

<p>The available checks for couple of objects are:
</p>

<ul>
<li> <p><strong>bravais</strong> and <strong>unit_cell</strong>
</p>
</li>
<li> <p><strong>unit_cell</strong> and <strong>cryst_symm</strong>
</p>
</li></ul>



<h3>Value</h3>

<p>ans A logical value. ans = TRUE means that either the parameters of the single
object (if only one input is provided) are valid parameters, or that the two objects are
compatible with each other.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a cubic cell with side 50
uc &lt;- create_unit_cell(50)

# Create an object of class "cryst_symm"
crsym &lt;- cryst_symm("P m -3")

# Are they compatible with each other?
check_validity(uc,crsym,TRUE)

</code></pre>

<hr>
<h2 id='create_merged_reflections'>S3 generic to create merged_reflections objects</h2><span id='topic+create_merged_reflections'></span>

<h3>Description</h3>

<p>The merged_reflections object can be created starting from
specific objects, files, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_merged_reflections(ruc, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_merged_reflections_+3A_ruc">ruc</code></td>
<td>
<p>An object used to select a method.</p>
</td></tr>
<tr><td><code id="create_merged_reflections_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mrefs An object of class &quot;merged_reflections&quot;. It is a named
list of length 4 whose names are:
</p>

<dl>
<dt>ruc</dt><dd><p>An object of class &quot;rec_unit_cell&quot;.</p>
</dd>
<dt>csym</dt><dd><p>An object of class &quot;cryst_symm&quot;.</p>
</dd>
<dt>records</dt><dd><p>A data frame containing the data.</p>
</dd>
<dt>dtypes</dt><dd><p>A character vector containing the
type of data (Miller indices, structure
factors, etc).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Create a default merged_reflections object (no arguments)
mrefs &lt;- create_merged_reflections()
print(mrefs)

# Create merged_reflections object from symmetry
csym &lt;- cryst_symm("P 3")
mrefs &lt;- create_merged_reflections(csym=csym)
print(mrefs)

</code></pre>

<hr>
<h2 id='create_merged_reflections.default'>Default method for generic &quot;create_merged_reflections&quot;</h2><span id='topic+create_merged_reflections.default'></span>

<h3>Description</h3>

<p>This method is an alternative call to 'merged_reflections'.
.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
create_merged_reflections(
  ruc = NULL,
  csym = NULL,
  records = NULL,
  dtypes = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_merged_reflections.default_+3A_ruc">ruc</code></td>
<td>
<p>An object of class 'rec_unit_cell'.</p>
</td></tr>
<tr><td><code id="create_merged_reflections.default_+3A_csym">csym</code></td>
<td>
<p>An object of class 'cryst_symm'.</p>
</td></tr>
<tr><td><code id="create_merged_reflections.default_+3A_records">records</code></td>
<td>
<p>A data frame containing all reflections coming
from the x-ray data collection on the crystal. This
data frame must include at least the three Miller
indices, H, K, L (of dtype &quot;H&quot;).</p>
</td></tr>
<tr><td><code id="create_merged_reflections.default_+3A_dtypes">dtypes</code></td>
<td>
<p>A character vector whose length is the same as
the number of columns in 'records'. One character (a
capital letter) is associated with each type of data.
For example, a Miller index is of dtype &quot;H&quot;; a structure
amplitude is of dtype &quot;F&quot;; an anomalous difference is of
dtype &quot;D&quot;; etc (see details later).</p>
</td></tr>
<tr><td><code id="create_merged_reflections.default_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the
create_merged_reflections methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;merged_reflections&quot;. It is a named
list of length 4 whose names are:
</p>

<dl>
<dt>ruc</dt><dd><p>An object of class &quot;rec_unit_cell&quot;.</p>
</dd>
<dt>csym</dt><dd><p>An object of class &quot;cryst_symm&quot;.</p>
</dd>
<dt>records</dt><dd><p>A data frame containing the data.</p>
</dd>
<dt>dtypes</dt><dd><p>A character vector containing the
type of data (Miller indices, structure
factors, etc).</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+merged_reflections">merged_reflections</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create merged data for a cubic (10 angstrom) unit cell
# of space group P 2 3. Data up to 5 angstroms resolution
mrefs &lt;- create_merged_reflections()
print(mrefs)

</code></pre>

<hr>
<h2 id='create_rec_unit_cell'>S3 generic to create rec_unit_cell objects</h2><span id='topic+create_rec_unit_cell'></span>

<h3>Description</h3>

<p>The rec_unit_cell object can be created starting from specific objects, files, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_rec_unit_cell(ar, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_rec_unit_cell_+3A_ar">ar</code></td>
<td>
<p>An object or objects used to select a method. These can be
reciprocal unit cell parameters, an object of class
rec_unit_cell, etc.</p>
</td></tr>
<tr><td><code id="create_rec_unit_cell_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;rec_unit_cell&quot;. It is a named list of length 6 whose
last three slots are of &quot;angle&quot; class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a rec_unit_cell in default (no arguments)
ruc &lt;- create_rec_unit_cell()
print(ruc)
</code></pre>

<hr>
<h2 id='create_rec_unit_cell.bravais'>Reciprocal unit cell starting from a Bravais symbol</h2><span id='topic+create_rec_unit_cell.bravais'></span>

<h3>Description</h3>

<p>Method to create a &quot;rec_unit_cell&quot; object starting from a &quot;bravais&quot; object.
The Bravais symbols indicate the 14 possible Bravais lattices. A few
examples are &quot;aP&quot;, &quot;oF&quot;, etc. The cell parameters assigned are assigned
randomly, but are compatible with the Bravais lattice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bravais'
create_rec_unit_cell(ar, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_rec_unit_cell.bravais_+3A_ar">ar</code></td>
<td>
<p>An object of class &quot;bravais&quot;.</p>
</td></tr>
<tr><td><code id="create_rec_unit_cell.bravais_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the create_rec_unit_cell methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;rec_unit_cell&quot;. It is a named list of length 6 whose
last three slots are of &quot;angle&quot; class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a "rec_unit_cell" object from a monoclinic primitive Bravais lattice
# Cell parameters generated automatically.
bt &lt;- bravais("mP")
ruc &lt;- create_rec_unit_cell(bt)
print(ruc)

</code></pre>

<hr>
<h2 id='create_rec_unit_cell.cryst_symm'>Reciprocal unit cell from a 'cryst_symm' object</h2><span id='topic+create_rec_unit_cell.cryst_symm'></span>

<h3>Description</h3>

<p>Method to create an object of class &quot;rec_unit_cell&quot; starting
from an object of class 'cryst_symm'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cryst_symm'
create_rec_unit_cell(ar, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_rec_unit_cell.cryst_symm_+3A_ar">ar</code></td>
<td>
<p>An object of class 'cryst_symm'.</p>
</td></tr>
<tr><td><code id="create_rec_unit_cell.cryst_symm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the
create_rec_unit_cell.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The symmetry of a space group imposes constrains on the
parameters of unit cells. For example, the cubic group P 2 3
means that all cell sides have to be equal and all angles
have to be equal to 90 degrees. This function suggests the
appropriate reciprocal cell compatible with the given space
group.
</p>


<h3>Value</h3>

<p>An object of class &quot;rec_unit_cell&quot;. It is a named list
of length 6 whose last three slots are of class
'angle'. The cell parameters are calculated from those
of the corresponding unit cell. The default unit cell
parameters are a=10, b=20, c=15, alpha=70, beta=80,
gamma=100. When constrains due to symmetry are
required, b and c might be equaled to a, alpha, beta
and gamma might be set to 90, gamma might be set to
120 and the three angles might be set equal to each
other.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Symmetry "C 1 2/c 1"
csym &lt;- cryst_symm("C 1 2/c 1")

# Reciprocal unit_cell
ruc &lt;- create_rec_unit_cell(csym)
print(ruc)

</code></pre>

<hr>
<h2 id='create_rec_unit_cell.default'>Default method for generic &quot;create_rec_unit_cell&quot;</h2><span id='topic+create_rec_unit_cell.default'></span>

<h3>Description</h3>

<p>This method is an alternative call to &quot;rec_unit_cell&quot;
.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
create_rec_unit_cell(
  ar = NULL,
  br = NULL,
  cr = NULL,
  aar = NULL,
  bbr = NULL,
  ccr = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_rec_unit_cell.default_+3A_ar">ar</code></td>
<td>
<p>A real number. One of the reciprocal unit cell's side lengths, in 1/angstroms.</p>
</td></tr>
<tr><td><code id="create_rec_unit_cell.default_+3A_br">br</code></td>
<td>
<p>A real number. One of the reciprocal unit cell's side lengths, in 1/angstroms.</p>
</td></tr>
<tr><td><code id="create_rec_unit_cell.default_+3A_cr">cr</code></td>
<td>
<p>A real number. One of the reciprocal unit cell's side lengths, in 1/angstroms.</p>
</td></tr>
<tr><td><code id="create_rec_unit_cell.default_+3A_aar">aar</code></td>
<td>
<p>A real number. One of the reciprocal unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="create_rec_unit_cell.default_+3A_bbr">bbr</code></td>
<td>
<p>A real number. One of the reciprocal unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="create_rec_unit_cell.default_+3A_ccr">ccr</code></td>
<td>
<p>A real number. One of the reciprocal unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="create_rec_unit_cell.default_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the create_rec_unit_cell methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;rec_unit_cell&quot;. It is a named list of length 6 whose
last three slots are of &quot;angle&quot; class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rec_unit_cell">rec_unit_cell</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a reciprocal cubic cell with side 1/50
ruc &lt;- create_rec_unit_cell(1/50)
print(ruc)

</code></pre>

<hr>
<h2 id='create_rec_unit_cell.unit_cell'>Reciprocal unit cell starting from a unit cell</h2><span id='topic+create_rec_unit_cell.unit_cell'></span>

<h3>Description</h3>

<p>Method to create an object of class &quot;rec_unit_cell&quot; starting from an object of
class &quot;unit_cell&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unit_cell'
create_rec_unit_cell(ar, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_rec_unit_cell.unit_cell_+3A_ar">ar</code></td>
<td>
<p>An object of class &quot;unit_cell&quot;.</p>
</td></tr>
<tr><td><code id="create_rec_unit_cell.unit_cell_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the create_rec_unit_cell methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;rec_unit_cell&quot;. It is a named list of length 6 whose
last three slots are of &quot;angle&quot; class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a "rec_unit_cell" object starting from a cubic cell object
uc &lt;- unit_cell()
print(uc)
ruc &lt;- create_rec_unit_cell(uc)
print(ruc)

</code></pre>

<hr>
<h2 id='create_unit_cell'>S3 generic to create unit_cell objects</h2><span id='topic+create_unit_cell'></span>

<h3>Description</h3>

<p>The unit_cell object can be created starting from specific objects, files, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_unit_cell(a, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_unit_cell_+3A_a">a</code></td>
<td>
<p>An object or objects used to select a method. These can be
cell parameters, an object of class rec_unit_cell, etc.</p>
</td></tr>
<tr><td><code id="create_unit_cell_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;unit_cell&quot;. It is a named list of length 6 whose
last three slots are of class &quot;angle&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a unit_cell in default (no arguments)
uc &lt;- create_unit_cell()
print(uc)
</code></pre>

<hr>
<h2 id='create_unit_cell.bravais'>Unit cell starting from a Bravais symbol</h2><span id='topic+create_unit_cell.bravais'></span>

<h3>Description</h3>

<p>Method to create a &quot;unit_cell&quot; object starting from a &quot;bravais&quot; object.
The Bravais symbols indicate the 14 possible Bravais lattices. A few
examples are &quot;aP&quot;, &quot;oF&quot;, etc. The cell parameters assigned are assigned
randomly, but are compatible with the Bravais lattice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bravais'
create_unit_cell(a, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_unit_cell.bravais_+3A_a">a</code></td>
<td>
<p>An object of class &quot;bravais&quot;.</p>
</td></tr>
<tr><td><code id="create_unit_cell.bravais_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the create_unit_cell methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;unit_cell&quot;. It is a named list of length 6 whose
last three slots are of &quot;angle&quot; class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a "unit_cell" object from a monoclinic primitive Bravais lattice
# Cell parameters generated automatically.
bt &lt;- bravais("mP")
uc &lt;- create_unit_cell(bt)
print(uc)

</code></pre>

<hr>
<h2 id='create_unit_cell.cryst_symm'>Unit cell from a 'cryst_symm' object</h2><span id='topic+create_unit_cell.cryst_symm'></span>

<h3>Description</h3>

<p>Method to create an object of class &quot;unit_cell&quot; starting
from an object of class 'cryst_symm'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cryst_symm'
create_unit_cell(a, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_unit_cell.cryst_symm_+3A_a">a</code></td>
<td>
<p>An object of class 'cryst_symm'.</p>
</td></tr>
<tr><td><code id="create_unit_cell.cryst_symm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the create_unit_cell.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The symmetry of a space group imposes constrains on the
parameters of unit cells. For example, the cubic group P 2 3
means that all cell sides have to be equal and all angles
have to be equal to 90 degrees. This function suggests the
appropriate unit cell compatible with the given space group.
</p>


<h3>Value</h3>

<p>An object of class &quot;unit_cell&quot;. It is a named list
of length 6 whose last three slots are of class
'angle'. Default cell parameters are a=10, b=20, c=15,
alpha=70, beta=80, gamma=100. When constrains due to
symmetry are required, b and c might be equaled to a,
alpha, beta and gamma might be set to 90, gamma might
be set to 120 and the three angles might be set
equal to each other.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Symmetry "C 1 2/c 1"
csym &lt;- cryst_symm("C 1 2/c 1")

# Unit_cell
uc &lt;- create_unit_cell(csym)
print(uc)

</code></pre>

<hr>
<h2 id='create_unit_cell.default'>Default method for generic &quot;create_unit_cell&quot;</h2><span id='topic+create_unit_cell.default'></span>

<h3>Description</h3>

<p>This method is an alternative call to &quot;unit_cell&quot;
.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
create_unit_cell(
  a = NULL,
  b = NULL,
  c = NULL,
  aa = NULL,
  bb = NULL,
  cc = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_unit_cell.default_+3A_a">a</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="create_unit_cell.default_+3A_b">b</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="create_unit_cell.default_+3A_c">c</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="create_unit_cell.default_+3A_aa">aa</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="create_unit_cell.default_+3A_bb">bb</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="create_unit_cell.default_+3A_cc">cc</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="create_unit_cell.default_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the create_unit_cell methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;unit_cell&quot;. It is a named list of length 6 whose
last three slots are of &quot;angle&quot; class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unit_cell">unit_cell</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a cubic cell with side 50
uc &lt;- create_unit_cell(50)
print(uc)

</code></pre>

<hr>
<h2 id='create_unit_cell.rec_unit_cell'>Unit cell starting from a reciprocal unit cell</h2><span id='topic+create_unit_cell.rec_unit_cell'></span>

<h3>Description</h3>

<p>Method to create an object of class &quot;unit_cell&quot; starting from an object of
class &quot;rec_unit_cell&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rec_unit_cell'
create_unit_cell(a, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_unit_cell.rec_unit_cell_+3A_a">a</code></td>
<td>
<p>An object of class &quot;rec_unit_cell&quot;.</p>
</td></tr>
<tr><td><code id="create_unit_cell.rec_unit_cell_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the create_unit_cell methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;unit_cell&quot;. It is a named list of length 6 whose
last three slots are of &quot;angle&quot; class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a "unit_cell" object starting from a reciprocal cubic cell object
ruc &lt;- rec_unit_cell()
print(ruc)
uc &lt;- create_unit_cell(ruc)
print(uc)

</code></pre>

<hr>
<h2 id='cryst_symm'>Constructor for an S3 object of class &quot;cryst_symm&quot;.</h2><span id='topic+cryst_symm'></span>

<h3>Description</h3>

<p>This represents a crystallographic space group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cryst_symm(SG = NULL, set = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cryst_symm_+3A_sg">SG</code></td>
<td>
<p>A character string or an integer identifying the space group. There are 230
used space group in crystallography and each one corresponds to a unique and so-called
extended Hermann-Mauguin symbol. An example is space group number 19, identified by the
extended Hermann-Mauguin symbol &quot;P 21 21 21&quot;. Several formats are possible and some of them
are now rarely used. Attempts are made to transform the input into a correct Hermann-Mauguin
symbol, but if all fails, a warning is raised and the space group P 1 is assigned.</p>
</td></tr>
<tr><td><code id="cryst_symm_+3A_set">set</code></td>
<td>
<p>An integer defining which setting of many possible for the given space group. Some
crystallographic space groups can be implemented with small variants known as &quot;settings&quot;.
If the input SG is an extended Hermann-Mauguin symbol, set is ignored, as it is already
specified by the xHM symbol.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor can be used with less than the full set of two input parameters,
to create an object of class cryst_symm corresponding to space group P 1. If the input
string is not recognised, a warning is raised and space group P 1 is assigned.
</p>


<h3>Value</h3>

<p>An object of class &quot;cryst_symm&quot;. It is a named list of length 4. The names are, &quot;SG&quot;,
&quot;PG&quot;, &quot;T&quot; and &quot;C&quot;.
</p>

<ul>
<li><p>1) SG. This is a string containing the correct extended Hermann-Mauguin symbol.
</p>
</li>
<li><p>2) PG. This is a list whose elements are all the <code class="reqn">3\times 3</code> matrices forming
the point-group part of the symmetry transformation.
</p>
</li>
<li><p>3) T. This is a list whose elements are all the <code class="reqn">3\times 1</code> vectors forming
the translational part of the symmetry transformation.
</p>
</li>
<li><p>4) C. This is a list whose elements are all the <code class="reqn">3\times 1</code> vectors forming
the centering of the unit cell.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># The symplest symmetry: P 1
crsym &lt;- cryst_symm("P 1")
print(crsym)

# The second space group: P -1
crsym &lt;- cryst_symm(2)
print(crsym)

# Something more complicated
crsym &lt;- cryst_symm("P 21 21 21")
print(crsym)

</code></pre>

<hr>
<h2 id='crystal_family'>Crystal family corresponding to given space group.</h2><span id='topic+crystal_family'></span>

<h3>Description</h3>

<p>Crystal family corresponding to given space group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crystal_family(gn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crystal_family_+3A_gn">gn</code></td>
<td>
<p>A natural integer (1,2,3,...). the space group number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string, the name of the crystal family associated
with the given space group. If the input integer does not correspond
any existing space group, the function returns NULL and throws a
warning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># P1 is part of the TRICLINIC family
crystal_family(1)

# The object returned is a string
cfam &lt;- crystal_family(1)
class(cfam)
</code></pre>

<hr>
<h2 id='crystal_system'>Crystal system corresponding to given space group.</h2><span id='topic+crystal_system'></span>

<h3>Description</h3>

<p>Crystal system corresponding to given space group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crystal_system(gn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crystal_system_+3A_gn">gn</code></td>
<td>
<p>A natural integer (1,2,3,...). the space group number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string, the name of the crystal system associated
with the given space group. If the input integer does not correspond
any existing space group, the function returns NULL and throws a
warning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># P1 is part of the TRICLINIC system
crystal_system(1)

# The object returned is a string
csys &lt;- crystal_system(1)
class(csys)
</code></pre>

<hr>
<h2 id='deplete_systematic_absences'>Deplete systematic absences</h2><span id='topic+deplete_systematic_absences'></span>

<h3>Description</h3>

<p>Remove systematically-absent reflections from a data frame
in which Miller indices are in the first three columns.
The systematically-absent reflections are determined by the
specific space group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deplete_systematic_absences(hkl, SG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deplete_systematic_absences_+3A_hkl">hkl</code></td>
<td>
<p>A data frame with first three columns H, K, L
corresponding to the three Miller indices. This is
normally the 'record' data frame in an object of
class &quot;merged_reflections&quot;.</p>
</td></tr>
<tr><td><code id="deplete_systematic_absences_+3A_sg">SG</code></td>
<td>
<p>A character. The extended Hermann-Mauguin symbol
of the crystallographic space group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Crystallography symmetry forces constraints on data from
x-ray diffraction. One of these constraints consists in the
full cancellation of reflections with certain Miller indices.
It is said that the reflection with that specific Miller index
is systematically absent. For example, in data corresponding
to a crystal with space group C 2, general reflections like
(h,k,l) must obey h+k=2n (even number). Thus, the Miller
indices (2,3,1) are a systematic absence because 2+3=5 (odd).
</p>


<h3>Value</h3>

<p>hkl The same data frame acquired from input, depleted
of all systematic absences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># C 2 monoclinic space group
SG &lt;-"C 1 2 1"

# Create an arbitrary cell compatible with C 2
uc &lt;- unit_cell(10,15,10,90,110,90)

# Crete the related reciprocal cell
ruc &lt;- create_rec_unit_cell(uc)

# Create a full data frame of Miller indices
hkl &lt;- expand.grid(H=-4:4,K=-4:4,L=-4:4)

# Get rid of systematic absences
new_hkl &lt;- deplete_systematic_absences(hkl,SG)

# Compare first 10 items of original and depleted arrays
hkl[1:10,]
new_hkl[1:10,]

</code></pre>

<hr>
<h2 id='extract_symmetry_info'>Information on a specific space group</h2><span id='topic+extract_symmetry_info'></span>

<h3>Description</h3>

<p>Returns human-readable information on a specific input space group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_symmetry_info(SG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_symmetry_info_+3A_sg">SG</code></td>
<td>
<p>A character string. The extended Hermann-Mauguin symbol (e.g. 'P 1 1 21')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Crystallographic symmetry is fundamental in crystallography. It affects the way
atoms are arranged in a unit cell, the pattern of reflections in reciprocal space
and many other common occurrences in crystallography. This function returns a named
list with human-readable character strings which detail key symmetry information.
</p>


<h3>Value</h3>

<p>infostring A named list with fields corresponding to those in the CCP4 symmetry
library. The fields' name are:
</p>

<ul>
<li><p><strong>NUMBER</strong> standard spacegroup number
</p>
</li>
<li><p><strong>BASISOP</strong> change of basis operator
</p>
</li>
<li><p><strong>CCP4</strong> CCP4 spacegroup number e.g. 1003 (0 if not a CCP4 group)
</p>
</li>
<li><p><strong>HALL</strong> Hall symbol
</p>
</li>
<li><p><strong>xHM</strong> extended Hermann Mauguin symbol
</p>
</li>
<li><p><strong>OLD</strong> CCP4 spacegroup name (blank if not a CCP4 group)
</p>
</li>
<li><p><strong>LAUE</strong> Laue group symbol
</p>
</li>
<li><p><strong>PATT</strong> Patterson group symbol
</p>
</li>
<li><p><strong>PGRP</strong> Point group symbol
</p>
</li>
<li><p><strong>HKLASU</strong> reciprocal space asymmetric unit (with respect to standard setting)
</p>
</li>
<li><p><strong>MAPASU_CCP4</strong> CCP4 real space asymmetric unit (with respect to standard setting.
Negative ranges if not a CCP4 group)
</p>
</li>
<li><p><strong>MAPASU_ZERO</strong> origin based real space asymmetric unit (with respect to current
setting)
</p>
</li>
<li><p><strong>MAPASU_NONZ</strong> non-origin based real space asymmetric uni (with respect to
current setting)
</p>
</li>
<li><p><strong>CHESHIRE</strong> Cheshire cell (with respect to standard setting)
</p>
</li>
<li><p><strong>SYMOP</strong> list of primitive symmetry operators
</p>
</li>
<li><p><strong>CENOP</strong> list of centering operators
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># This is the full information for space group number 19, P 21 21 21
SG &lt;- translate_SG(19)
ltmp &lt;- extract_symmetry_info(SG)
ltmp

</code></pre>

<hr>
<h2 id='find_symm_setting'>Find specific space group setting</h2><span id='topic+find_symm_setting'></span>

<h3>Description</h3>

<p>Although a space group is uniquely defined, i.e. the symmetry
operations defining it are uniquely given, the choice of
vectors that defines a unit cell for that symmetry is not
unique. The different choices are known as settings. Most
space groups have only one setting, but it is possible to find
space groups with several settings. For example, &quot;C 1 2/c 1&quot;
has 18 settings. The xHM symbol for setting 1 is
&quot;C 1 2/c 1&quot;, the symbol for setting 2 is &quot;A 1 2/n 1&quot;, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_symm_setting(SG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_symm_setting_+3A_sg">SG</code></td>
<td>
<p>A character string indicating the extended
Hermann-Mauguin symbol for the space group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>set An integer equal to the specific setting
corresponding to the given xHM symbol.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># P2 (group number 4) has three settings
nsets &lt;- find_symm_setting("P 1 2 1")
print(nsets)

</code></pre>

<hr>
<h2 id='findHM'>Correct spelling for Herman-Mauguin space groups symbols</h2><span id='topic+findHM'></span>

<h3>Description</h3>

<p>The commonly-used spelling of a crystallographic space group does not match the correct definition
given by the Herman-Mauguin symbols which define all space groups in a unique and precise way. This
function attempt to translate a tentative string into a possible Herman-Mauguin symbol, if it finds
one. If the input string is already in the extended Herman-Mauguin form, the same string is returned
as output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findHM(sym_xHM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findHM_+3A_sym_xhm">sym_xHM</code></td>
<td>
<p>A character string. The space group symbol in its commonly-used spelling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SG A character string. The extended Hermann-Mauguin symbol (e.g. 'P 1 1 21').
</p>


<h3>Examples</h3>

<pre><code class='language-R'># P21
print(find("P 21"))

# P -1
print(find("P-1"))

</code></pre>

<hr>
<h2 id='frac_to_orth'>From fractional to orthogonal coordinates</h2><span id='topic+frac_to_orth'></span>

<h3>Description</h3>

<p>This function transforms any number of fractional coordinates <code class="reqn">(x_f,y_f,z_f)</code>,
arranged as a vector or in a matrix or data frame, into the corresponding number
of orthogonal coordinates <code class="reqn">(x,y,z)</code>, arranged in the same format.
</p>

<ol>
<li><p> ochoice = 1: X axis along a; Y axis normal to a, in the (a,b) plane;
Z axis normal to X and Y (and therefore parallel to
c*).
</p>
</li>
<li><p> ochoice = 2: this is also called &quot;Cambridge setting&quot;. The X axis is
along a*; the Y axis lies in the (a*,b*) plane; the Z
axis is, consequently, along c.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>frac_to_orth(xyzf, a, b, c, aa, bb, cc, ochoice = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frac_to_orth_+3A_xyzf">xyzf</code></td>
<td>
<p>A vector or <code class="reqn">n\times 3</code> matrix or data frame of fractional crystal coordinates.</p>
</td></tr>
<tr><td><code id="frac_to_orth_+3A_a">a</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="frac_to_orth_+3A_b">b</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="frac_to_orth_+3A_c">c</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="frac_to_orth_+3A_aa">aa</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="frac_to_orth_+3A_bb">bb</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="frac_to_orth_+3A_cc">cc</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="frac_to_orth_+3A_ochoice">ochoice</code></td>
<td>
<p>A natural integer indicating the choice of orthogonal transformation.
1 corresponds to the first choice and 2 to the second choice in
Giacovazzo's book (see <code><a href="#topic+xtal_mat01">xtal_mat01</a></code> and <code><a href="#topic+xtal_mat02">xtal_mat02</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">n\times 3</code> matrix or data frame of orthogonal coordinates corresponding
to the fractional coordinates provided in the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Matrix containing 3 fractional coordinates
xyzf &lt;- matrix(c(0.1,0.2,0.3,0.2,0.6,0.7,0.15,0.28,0.55),ncol=3,byrow=TRUE)

# Cartesian coordinates
xyz &lt;- frac_to_orth(xyzf,10,30,20,90,90,90,1)
</code></pre>

<hr>
<h2 id='full_symm_strings'>Symmetry operations in human readable form</h2><span id='topic+full_symm_strings'></span>

<h3>Description</h3>

<p>This function returns the full set of symmetry operations in human-readable form,
each one as a character string starting with 'SYMM'. These are the common crystallographic
symmetry operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full_symm_strings(SG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full_symm_strings_+3A_sg">SG</code></td>
<td>
<p>A character string. The extended Hermann-Mauguin symbol (e.g. 'P 1 1 21')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Symm_string A character vector whose components are strings starting by 'SYMM'
and containing the symmetry operations of the given group in human-readable form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># P1 has only one symmetry operation
SG &lt;- "P 1"
symm_string &lt;- full_symm_strings(SG)
print(symm_string)

# P 21 21 21 is has many more operations
SG &lt;- "P 21 21 21"
symm_string &lt;- full_symm_strings(SG)
print(symm_string)

</code></pre>

<hr>
<h2 id='generate_miller'>Generate Miller indices</h2><span id='topic+generate_miller'></span>

<h3>Description</h3>

<p>Function to create a data frame with complete set of Miller
indices, up to a given resolution (in angstroms).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_miller(uc, SG, reso)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_miller_+3A_uc">uc</code></td>
<td>
<p>An object of class &quot;unit_cell&quot;.</p>
</td></tr>
<tr><td><code id="generate_miller_+3A_sg">SG</code></td>
<td>
<p>A character string or a number indicating the
extended Hermann-Mauguin symbol for the space group.</p>
</td></tr>
<tr><td><code id="generate_miller_+3A_reso">reso</code></td>
<td>
<p>A real number. The highest data resolution, in
angstroms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Miller indices are named H, K, L in the data frame. Only
values of (H,K,L) corresponding to a resolution d(h,k,l) &gt;=
reso (in angstroms), are included. The full list does not
include systematic absences corresponding to the specific
symmetry of the crystal.
</p>


<h3>Value</h3>

<p>hkl A data frame with columns H, K, L corresponding
to the three Miller indices, and a columns S
corresponding to their inverse resolutions (in
angstroms).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># C 2 monoclinic space group
SG &lt;- "C 1 2 1"

# Create an arbitrary cell compatible with C 2
uc &lt;- unit_cell(10,15,10,90,110,90)

# Generate Miller indices to 5 angstroms resolution
reso &lt;- 5
hkl &lt;- generate_miller(uc,SG,reso)

# Display first 10 indices
hkl[1:10,]

</code></pre>

<hr>
<h2 id='hkl_to_reso'>Calculates resolution, given the Miller indices</h2><span id='topic+hkl_to_reso'></span>

<h3>Description</h3>

<p>Calculates resolution, given the Miller indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hkl_to_reso(h, k, l, a, b, c, aa, bb, cc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hkl_to_reso_+3A_h">h</code></td>
<td>
<p>An integer, A Miller index.</p>
</td></tr>
<tr><td><code id="hkl_to_reso_+3A_k">k</code></td>
<td>
<p>An integer, A Miller index.</p>
</td></tr>
<tr><td><code id="hkl_to_reso_+3A_l">l</code></td>
<td>
<p>An integer, A Miller index.</p>
</td></tr>
<tr><td><code id="hkl_to_reso_+3A_a">a</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="hkl_to_reso_+3A_b">b</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="hkl_to_reso_+3A_c">c</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="hkl_to_reso_+3A_aa">aa</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="hkl_to_reso_+3A_bb">bb</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="hkl_to_reso_+3A_cc">cc</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive, real number. The resolution associated with (h,k,l), in angstroms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadir &lt;- system.file("extdata",package="cry")
fname &lt;- file.path(datadir,"1dei_phases.mtz")
hdr &lt;- readMTZHeader(fname,message=FALSE)
ucell &lt;- hdr$CELL
reso1 &lt;- hkl_to_reso(1,0,0,ucell[1],ucell[2],ucell[3],ucell[4],ucell[5],ucell[6])
print(reso1)  # Low resolution
reso2 &lt;- hkl_to_reso(20,20,20,ucell[1],ucell[2],ucell[3],ucell[4],ucell[5],ucell[6])
reso2  # High resolution
</code></pre>

<hr>
<h2 id='lattice_stuff'>Calculation of useful lattice parameters</h2><span id='topic+lattice_stuff'></span>

<h3>Description</h3>

<p>Calculation of useful lattice parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lattice_stuff(a, b, c, aa, bb, cc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lattice_stuff_+3A_a">a</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="lattice_stuff_+3A_b">b</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="lattice_stuff_+3A_c">c</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="lattice_stuff_+3A_aa">aa</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="lattice_stuff_+3A_bb">bb</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="lattice_stuff_+3A_cc">cc</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of real numbers and length 16. The names are:
</p>

<ul>
<li><p>sa.   Sine(aa)
</p>
</li>
<li><p>sb.   Sine(bb)
</p>
</li>
<li><p>sc.   Sine(cc)
</p>
</li>
<li><p>ca.   Cosine(aa)
</p>
</li>
<li><p>cb.   Cosine(bb)
</p>
</li>
<li><p>cc.   Cosine(cc)
</p>
</li>
<li><p>ar.   a* (reciprocal cell side length)
</p>
</li>
<li><p>br.   b* (reciprocal cell side length)
</p>
</li>
<li><p>cr.   c* (reciprocal cell side length)
</p>
</li>
<li><p>sar.  Sine of a reciprocal cell angle
</p>
</li>
<li><p>sbr.  Sine of a reciprocal cell angle
</p>
</li>
<li><p>scr.  Sine of a reciprocal cell angle
</p>
</li>
<li><p>car.  Cosine of a reciprocal cell angle
</p>
</li>
<li><p>cbr.  Cosine of a reciprocal cell angle
</p>
</li>
<li><p>ccr.  Cosine of a reciprocal cell angle
</p>
</li>
<li><p>V.    Volume of the unit cell in cubic angstroms
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>datadir &lt;- system.file("extdata",package="cry")
fname &lt;- file.path(datadir,"1dei_phases.mtz")
hdr &lt;- readMTZHeader(fname,message=FALSE)
ucell &lt;- hdr$CELL
vtmp &lt;- lattice_stuff(ucell[1],ucell[2],ucell[3],ucell[4],ucell[5],ucell[6])
vtmp[1:3]
vtmp[4:6]
vtmp[7:9]
vtmp[10:12]
vtmp[13:15]
vtmp[16]
</code></pre>

<hr>
<h2 id='lowest_uc_compatible_SG'>Space group compatible with given cell</h2><span id='topic+lowest_uc_compatible_SG'></span>

<h3>Description</h3>

<p>This function returns the space group, among those compatible
with the given unit cell, with the lowest symmetry group
number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowest_uc_compatible_SG(uc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowest_uc_compatible_SG_+3A_uc">uc</code></td>
<td>
<p>An object of class 'unit_cell'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A given unit cell is compatible with several symmetries.
For example, a cell with different sides and different
angles, also different from 90 degrees, is compatible with
the triclinic lattice system, which corresponds to space
groups P1 and P -1. A cell with different sides, alpha = 90,
gamma=90 and beta different from 90, is compatible with the
monoclinic lattice system, which corresponds to space groups
from number 3 (&quot;P 1 2 1&quot;) to number 15 (C 1 2/c 1&quot;). In the
first case this function returns &quot;P 1&quot;, while in the second
case it returns &quot;P 1 2 1&quot;.
</p>


<h3>Value</h3>

<p>csym An object of class 'cryst_symm', corresponding
to the selected, lowest symmetry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Monoclinic cell
uc &lt;- unit_cell(10,20,15,90,110,90)

# The selected space group is "P 1 2 1"
csym &lt;- lowest_uc_compatible_SG(uc)
print(csym)

</code></pre>

<hr>
<h2 id='merged_reflections'>Constructor for an S3 object of class &quot;merged_reflections&quot;.</h2><span id='topic+merged_reflections'></span>

<h3>Description</h3>

<p>This represents scaled and merged x-ray data from one crystal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merged_reflections(ruc = NULL, csym = NULL, records = NULL, dtypes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merged_reflections_+3A_ruc">ruc</code></td>
<td>
<p>An object of class &quot;rec_unit_cell&quot; (which represents
a reciprocal unit cell).</p>
</td></tr>
<tr><td><code id="merged_reflections_+3A_csym">csym</code></td>
<td>
<p>An object of class &quot;cryst_symm&quot; (which represents
a crystallographic symmetry group).</p>
</td></tr>
<tr><td><code id="merged_reflections_+3A_records">records</code></td>
<td>
<p>A data frame containing all reflections coming
from the x-ray data collection on the crystal. This
data frame must include at least the three Miller
indices, H, K, L (of dtype &quot;H&quot;).</p>
</td></tr>
<tr><td><code id="merged_reflections_+3A_dtypes">dtypes</code></td>
<td>
<p>A character vector whose length is the same as
the number of columns in 'records'. One character (a
capital letter) is associated with each type of data.
For example, a Miller index is of dtype &quot;H&quot;; a structure
amplitude is of dtype &quot;F&quot;; an anomalous difference is of
dtype &quot;D&quot;; etc (see details later).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the constructor is used without arguments, the default
object created will be create reflections for a cubic crystal
with cell of side 10 angstroms, and symmetry P 2 3, up to 5
angstroms resolution. The only available columns
will be of dtype &quot;H&quot;, named H, K, L (the Miller indices), and
of dtype &quot;S&quot;, inverse resoluton, named S.
</p>
<p>The possible dtypes are:
</p>

<dl>
<dt>H</dt><dd><p>Miller index</p>
</dd>
<dt>S</dt><dd><p>Inverse resolution (1/angstroms)</p>
</dd>
<dt>J</dt><dd><p>Reflection intensity</p>
</dd>
<dt>F</dt><dd><p>Amplitude of a structure factor</p>
</dd>
<dt>D</dt><dd><p>Anomalous difference</p>
</dd>
<dt>Q</dt><dd><p>Standard deviation of J, F, D</p>
</dd>
<dt>G</dt><dd><p>Amplitude associated with a Friedel pair (F(+), F(-))</p>
</dd>
<dt>L</dt><dd><p>Standard deviation of G</p>
</dd>
<dt>K</dt><dd><p>Intensity associated with G (I(+), I(-))</p>
</dd>
<dt>M</dt><dd><p>Standard deviation of K</p>
</dd>
<dt>E</dt><dd><p>Amplitude of the normalised structure factors</p>
</dd>
<dt>P</dt><dd><p>Phase angle (in degrees)</p>
</dd>
<dt>W</dt><dd><p>Weight of some sort</p>
</dd>
<dt>A</dt><dd><p>Phase probability coefficients (Hendrickson-Lattman)</p>
</dd>
<dt>B</dt><dd><p>Batch number (from raw data)</p>
</dd>
<dt>I</dt><dd><p>Any other integer</p>
</dd>
<dt>R</dt><dd><p>Any other real</p>
</dd>
</dl>

<p>More values can become available in a future release.
</p>


<h3>Value</h3>

<p>An object of class &quot;merged_reflections&quot;. It is a named
list of length 4 whose names are:
</p>

<dl>
<dt>ruc</dt><dd><p>An object of class &quot;rec_unit_cell&quot;.</p>
</dd>
<dt>csym</dt><dd><p>An object of class &quot;cryst_symm&quot;.</p>
</dd>
<dt>records</dt><dd><p>A data frame containing the data.</p>
</dd>
<dt>dtypes</dt><dd><p>A character vector containing the
type of data (Miller indices, structure
factors, etc).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Create an orthorombic (default) cell
uc &lt;- unit_cell(10,30,15)

# Create the related reciprocal cell
ruc &lt;- create_rec_unit_cell(uc)

# Create symmetry (P n c 2)
csym &lt;- cryst_symm(30)

# Create a few records (these include syst. absences)
records &lt;- expand.grid(H=-2:2,K=-2:2,L=-2:2)
print(length(records[,1]))

# dtypes are all H
dtypes &lt;- c("H","H","H")

# Create merged_reflections object with H, K, L
# Systematic absences have been eliminated
mrefs &lt;- merged_reflections(ruc,csym,records,dtypes)
print(length(mrefs$records[,1]))

</code></pre>

<hr>
<h2 id='num_symm_settings'>Number of space group settings</h2><span id='topic+num_symm_settings'></span>

<h3>Description</h3>

<p>Although a space group is uniquely defined, i.e. the symmetry operations defining it
is uniquely given, the choice of vectors that defines a unit cell for that symmetry
is not unique. The different choices are known as settings. Most space groups have only
one setting, but it is possible to find space groups with several settings. For example,
&quot;C 1 2/c 1&quot; has 18 settings. While the xHM symbol for setting 1 is &quot;C 1 2/c 1&quot;, the
symbol for setting 2 is &quot;A 1 2/n 1&quot;, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_symm_settings(SG = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_symm_settings_+3A_sg">SG</code></td>
<td>
<p>A character string or a number indicating the space group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nsett The number of setting for the given space group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># P 1 21 1 (group number 4) has three settings
num_symm_settings(4)

# Find the extended Hermann-Mauguin symbols
translate_SG(4,"number","xHM",1)$msg
translate_SG(4,"number","xHM",2)$msg
translate_SG(4,"number","xHM",3)$msg

</code></pre>

<hr>
<h2 id='op_xyz_list_to_matrix_list'>List of matrices and vectors of a specific space group</h2><span id='topic+op_xyz_list_to_matrix_list'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">3\times 3</code> matrices and <code class="reqn">3\times 1</code> vectors corresponding to point group
operations, group translations and cell centring of a given space group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>op_xyz_list_to_matrix_list(op_xyz_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="op_xyz_list_to_matrix_list_+3A_op_xyz_list">op_xyz_list</code></td>
<td>
<p>A named list made of two vectors. The first vector, SYMOP, contains strings
describing the symmetry operators. The second vector, CENOP, contains strings describing the
centring of the unit cell.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A crystallographic space group consists of a series of transformations on a point
<code class="reqn">(x_f,y_f,z_f)</code> in space that are mathematically implemented as the product of
a <code class="reqn">3\times 3</code> point-group matrix and the point fractional coordinates, <code class="reqn">(x_f,y_f,z_f)</code>,
followed by a sum with a <code class="reqn">3\times 1</code> translation vector. The complete set of points thus
produced can be cloned into a new and shifted set translated of an amount represented by a
<code class="reqn">3\times 1</code> centring vector.
</p>


<h3>Value</h3>

<p>mat_ops_list A named list consisting of 3 lists. The first list, PG, contains
<code class="reqn">3\times 3</code> point group matrices; the second list, T, contains the same number of
<code class="reqn">3\times 1</code> translation vectors. The first matrix is always the identity matrix, the first
translation vector is always the null vector. The third list, C, consists of centering vectors;
the first centering vector is always the null vector. To summarize, the output looks like the
following:
</p>
<p>[[ [[I,M2,M3,...,Mn]] , [[O,V2,V3,...,Vn]] , [[O,C2,C3,...,Cm]] ]]
where:
I                = identity    3X3 matrix
0                = null        3X1 vector
M2,M3,...,Mn     = point group 3X3 matrices
V2,V3,...,Cn     = translation 3X1 vectors
C2,C3,...,Cm     = centering   3X1 vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Symmetry operators for space group number 3, P 1 2 1
SG &lt;- "P 1 2 1"
op_xyz_list &lt;- syminfo_to_op_xyz_list(SG)
mat_ops_list &lt;- op_xyz_list_to_matrix_list(op_xyz_list)
names(mat_ops_list)

</code></pre>

<hr>
<h2 id='op_xyz_to_matrix'>Human-readable symmetry operator into matrix and vector</h2><span id='topic+op_xyz_to_matrix'></span>

<h3>Description</h3>

<p>Returns a <code class="reqn">3\times 3</code> matrix and <code class="reqn">3\times 1</code> vector corresponding to either a
symmetry operator or a centering operator in human-readable, string form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>op_xyz_to_matrix(op_xyz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="op_xyz_to_matrix_+3A_op_xyz">op_xyz</code></td>
<td>
<p>A symmetry or centering operation in the form of a
human-readable string, e.g. -x+1/2,-y,z+1/2'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A string describing a symmetry or a centering operation has a format similar to, for instance,
'-x+1/2,-y,z+1/2'. Such a string corresponds to the symmetry operation represented
mathematically by the following matrix and vector:
</p>
<p style="text-align: center;"><code class="reqn">
  \left(\begin{array}{rrr}
  -1 &amp; 0 &amp; 0 \\
  0 &amp; -1 &amp; 0 \\
  0 &amp; 0 &amp; 1
  \end{array}\right)\quad,\quad
  \left(\begin{array}{r}
  1/2 \\
  0 \\
  1/2
  \end{array}\right)
</code>
</p>

<p>Where symmetry operations in human-readable form are useful for the subjective reasoning
in crystallography, their mathematical counterpart is needed for all practical calculations.
</p>


<h3>Value</h3>

<p>mat_ops A named list including a <code class="reqn">3\times 3</code> matrix 'R' and a
<code class="reqn">3\times 1</code> vector 'T'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reflection and translation
sop &lt;- '-x,y+1/2,z'
mat_ops &lt;- op_xyz_to_matrix(sop)
print(mat_ops)

</code></pre>

<hr>
<h2 id='orth_to_frac'>From orthogonal to fractional coordinates</h2><span id='topic+orth_to_frac'></span>

<h3>Description</h3>

<p>This function transforms any number of orthogonal coordinates <code class="reqn">(x,y,z)</code>,
arranged as a vector or in a matrix or data frame, into the corresponding number
of fractional coordinates <code class="reqn">(x_f,y_f,z_f)</code>, arranged in the same format.
</p>

<ol>
<li><p> ochoice = 1: X axis along a; Y axis normal to a, in the (a,b) plane;
Z axis normal to X and Y (and therefore parallel to
c*).
</p>
</li>
<li><p> ochoice = 2: this is also called &quot;Cambridge setting&quot;. The X axis is
along a*; the Y axis lies in the (a*,b*) plane; the Z
axis is, consequently, along c.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>orth_to_frac(xyz, a, b, c, aa, bb, cc, ochoice = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orth_to_frac_+3A_xyz">xyz</code></td>
<td>
<p>A vector or <code class="reqn">n\times 3</code> matrix or data frame of orthogonal crystal coordinates.</p>
</td></tr>
<tr><td><code id="orth_to_frac_+3A_a">a</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="orth_to_frac_+3A_b">b</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="orth_to_frac_+3A_c">c</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="orth_to_frac_+3A_aa">aa</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="orth_to_frac_+3A_bb">bb</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="orth_to_frac_+3A_cc">cc</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="orth_to_frac_+3A_ochoice">ochoice</code></td>
<td>
<p>A natural integer indicating the choice of orthogonal transformation.
1 corresponds to the first choice and 2 to the second choice in
Giacovazzo's book (see <code><a href="#topic+xtal_mat01">xtal_mat01</a></code> and <code><a href="#topic+xtal_mat02">xtal_mat02</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">n\times 3</code> matrix or data frame of fractional coordinates corresponding
to the orthogonal coordinates provided in the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Matrix containing 3 orthogonal coordinates
xyz &lt;- matrix(c(5, 15, 10, 2, 10, 8, 1, 1, 1),ncol=3,byrow=TRUE)

# Fractional coordinates
xyzf &lt;- orth_to_frac(xyz,10,30,20,90,90,90,1)
</code></pre>

<hr>
<h2 id='plot_SHELX'>Plot SHELXC log files</h2><span id='topic+plot_SHELX'></span>

<h3>Description</h3>

<p>Plot SHELXC log files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_SHELX(filename, filename_e, var, type, title_chart)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_SHELX_+3A_filename">filename</code></td>
<td>
<p>A data frame in output from <code>{read_SHELX_log}</code>.</p>
</td></tr>
<tr><td><code id="plot_SHELX_+3A_filename_e">filename_e</code></td>
<td>
<p>A data frame with the inverted hand from shelxe</p>
</td></tr>
<tr><td><code id="plot_SHELX_+3A_var">var</code></td>
<td>
<p>the variable to be plotted vs the resolution</p>
</td></tr>
<tr><td><code id="plot_SHELX_+3A_type">type</code></td>
<td>
<p>indicate the type of file, possible value are &quot;shelxc&quot;,
&quot;shelxd&quot; and &quot;shelxe&quot;.</p>
</td></tr>
<tr><td><code id="plot_SHELX_+3A_title_chart">title_chart</code></td>
<td>
<p>title of the chart.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graphical object from ggplot2 class that contains
the solution founded by SHELX log file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadir &lt;- system.file("extdata",package="cry")
## SHELXC
shelxc_log &lt;- file.path(datadir,"shelxc.log")
shelxc &lt;- read_SHELX_log(shelxc_log)
plot_shelxc &lt;- plot_SHELX(filename = shelxc, var = shelxc$I_sig,
type = "shelxc", title_chart = "SHELXC")
plot_shelxc
## SHELXD
shelxd_log &lt;- file.path(datadir,"shelxd.log")
shelxd &lt;- read_SHELX_log(shelxd_log)
plot_shelxd &lt;- plot_SHELX(filename = shelxd, type = "shelxd",
title_chart = "SHELXD")
plot_shelxd
## SHELXE
filename_i &lt;- file.path(datadir,"shelxe_i.log")
shelxe_i &lt;- read_SHELX_log(filename_i)
filename_o &lt;- file.path(datadir,"shelxe_o.log")
shelxe_o &lt;- read_SHELX_log(filename_o)
plot_shelxe &lt;- plot_SHELX(filename = shelxe_i,
filename_e = shelxe_o, type = "shelxe", title_chart = "SHELXE")
plot_shelxe

</code></pre>

<hr>
<h2 id='print.angle'>Print method for an object of class &quot;angle&quot;.</h2><span id='topic+print.angle'></span>

<h3>Description</h3>

<p>The value is displayed in degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'angle'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.angle_+3A_x">x</code></td>
<td>
<p>An object of class &quot;angle&quot;.</p>
</td></tr>
<tr><td><code id="print.angle_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the print methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No values. A message is displayed which includes
information on the angle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an angle of 90 degrees using radians
ang1 &lt;- angle(pi/2,FALSE)

# Display its value
print(ang1)
</code></pre>

<hr>
<h2 id='print.bravais'>Print method for an object of class &quot;bravais&quot;.</h2><span id='topic+print.bravais'></span>

<h3>Description</h3>

<p>The Bravais lattice and related crystal family, crystal system and lattice system
are displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bravais'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bravais_+3A_x">x</code></td>
<td>
<p>An object of class &quot;bravais&quot;.</p>
</td></tr>
<tr><td><code id="print.bravais_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the print methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No values. A message is displayed which includes
information on the Bravais lattice.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a triclinic Bravais lattice
bt &lt;- bravais()

# Display its value
print(bt)
</code></pre>

<hr>
<h2 id='print.cryst_symm'>Print method for an object of class &quot;cryst_symm&quot;.</h2><span id='topic+print.cryst_symm'></span>

<h3>Description</h3>

<p>xxx
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cryst_symm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cryst_symm_+3A_x">x</code></td>
<td>
<p>An object of class &quot;cryst_symm&quot;.</p>
</td></tr>
<tr><td><code id="print.cryst_symm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the print methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No values. A message is displayed which includes
information on the crystallographic symmetry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an object of P 2 symmetry
crsym &lt;- cryst_symm("P 2")

# Display its value
print(crsym)

</code></pre>

<hr>
<h2 id='print.rec_unit_cell'>Print method for an object of class &quot;rec_unit_cell&quot;.</h2><span id='topic+print.rec_unit_cell'></span>

<h3>Description</h3>

<p>The values are displayed in 1/angstroms and degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rec_unit_cell'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rec_unit_cell_+3A_x">x</code></td>
<td>
<p>An object of class &quot;rec_unit_cell&quot;.</p>
</td></tr>
<tr><td><code id="print.rec_unit_cell_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the print methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No values. A message is displayed which includes
information on the reciprocal unit cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a cubic reciprocal unit cell
ruc &lt;- rec_unit_cell(1/10,1/10,1/10,90,90,90)

# Display its value
print(ruc)
</code></pre>

<hr>
<h2 id='print.unit_cell'>Print method for an object of class &quot;unit_cell&quot;.</h2><span id='topic+print.unit_cell'></span><span id='topic+print.merged_reflections'></span>

<h3>Description</h3>

<p>The values are displayed in angstroms and degrees
</p>
<p>The output includes details on the unit cell, the crystal
symmetry and the first 10 records (data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unit_cell'
print(x, ...)

## S3 method for class 'merged_reflections'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.unit_cell_+3A_x">x</code></td>
<td>
<p>An object of class &quot;merged_reflections&quot;.</p>
</td></tr>
<tr><td><code id="print.unit_cell_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the print methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No values. A message is displayed which includes
information on the unit cell.
</p>
<p>No values. A message is displayed which includes
information on the reflections contained in this object
and the crystal structure they relate to.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a cubic unit cell
uc &lt;- unit_cell(10,10,10,90,90,90)

# Display its value
print(uc)
# Create a default 'merged_reflections' object
mrefs &lt;- merged_reflections()

# Display its value
print(mrefs)

</code></pre>

<hr>
<h2 id='read_SHELX_log'>Reads and SHELXD log files</h2><span id='topic+read_SHELX_log'></span>

<h3>Description</h3>

<p>Reads and SHELXD log files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_SHELX_log(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_SHELX_log_+3A_filename">filename</code></td>
<td>
<p>A character string. The path to a valid log file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. Each name correspond to a valid field in the log
header.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"shelxc.log")
ltmp &lt;- read_SHELX_log(filename)
print(names(ltmp))

</code></pre>

<hr>
<h2 id='readCIF'>Reads and output a CIF file</h2><span id='topic+readCIF'></span>

<h3>Description</h3>

<p>Reads and output a CIF file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readCIF(filename, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readCIF_+3A_filename">filename</code></td>
<td>
<p>A character string. The path to a valid CIF file.</p>
</td></tr>
<tr><td><code id="readCIF_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE (default) the function prints
a message highlighting what is included in the cif file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. Each name correspond to a valid field in the cif.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"AMS_DATA.cif")
lCIF &lt;- readCIF(filename)
print(names(lCIF))
print(lCIF$INTRO$CELL)
print(lCIF$INTRO$HALL)
print(lCIF$INTRO$HM)
print(lCIF$SYMM)

</code></pre>

<hr>
<h2 id='readmm_CIF'>Reads and output an mmCIF file</h2><span id='topic+readmm_CIF'></span>

<h3>Description</h3>

<p>Reads and output an mmCIF file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readmm_CIF(filename, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readmm_CIF_+3A_filename">filename</code></td>
<td>
<p>A character string. The path to a valid
CIF file.</p>
</td></tr>
<tr><td><code id="readmm_CIF_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE (default) the
function prints a message highlighting
what is included in the cif file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. Each name correspond to a valid
field in the cif.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"3syu.cif")
lCIF &lt;- readmm_CIF(filename)
print(names(lCIF))
print(lCIF$HEADER$Entry)
print(lCIF$HEADER$Symmtery)
print(lCIF$HEADER$CELL)
print(lCIF$EXP_DETAILS$CRYSTAL_CON$VAL)

</code></pre>

<hr>
<h2 id='readMTZ'>Load an MTZ file</h2><span id='topic+readMTZ'></span>

<h3>Description</h3>

<p>Reads mtz files and store both header information and
reflection data records in named lists. A third list is
used, if the mtz file is an unmerged file, for storing batch
headers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMTZ(filename, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMTZ_+3A_filename">filename</code></td>
<td>
<p>A character string. The path to a valid mtz
file.</p>
</td></tr>
<tr><td><code id="readMTZ_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE the
function prints a message highlighting data
included in the mtz file. Default value is
<code>message=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of length 3. The first element is
called &quot;reflections&quot; and is a dataframe with as
many columns as are included in the mtz file.
The name of each column of the dataframe coincides
with the name of the corresponding column in the mtz.
The second element is called &quot;header&quot; and is a named
list in which each name correspond to a valid field
in the mtz header (see details in
<code><a href="#topic+readMTZHeader">readMTZHeader</a></code>).
The third element is called
&quot;batch_header&quot; and is a list with as many elements as
the number of batches (images) included in the mtz
file. Each list element is, itself, a named list
including all the useful variables stored in batch
headers. If no batch headers are contained in the file
(merged mtz), the batch_header element is NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"1dei_phases.mtz")
ltmp &lt;- readMTZ(filename)
print(names(ltmp))
print(class(ltmp$reflections))
str(ltmp$reflections)
print(class(ltmp$header))
print(class(ltmp$batch_header))

refs &lt;- ltmp$reflections
print(colnames(refs))
print(range(refs$H))

</code></pre>

<hr>
<h2 id='readMTZHeader'>Reads and output an MTZ header</h2><span id='topic+readMTZHeader'></span>

<h3>Description</h3>

<p>An MTZ file is a binary file created to carry information on
x-ray diffraction experiments on crystals. It includes x-ray
diffraction data and information on the experiment and the
crystal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMTZHeader(filename, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMTZHeader_+3A_filename">filename</code></td>
<td>
<p>A character string. The path to a valid mtz file.</p>
</td></tr>
<tr><td><code id="readMTZHeader_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE the function prints
a message highlighting what is included in the mtz header.
Default value is <code>message=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a named list whose components are
the <code>reflections</code>, the <code>header</code> and the
<code>batch_header</code>. The <code>header</code> is a named list whose
components are:
</p>

<dl>
<dt>TITLE</dt><dd><p>A character string containing the title of the
MTZ file.</p>
</dd>
<dt>NCOL</dt><dd><p>Number of columns in data frame
<code>reflections</code>.</p>
</dd>
<dt>CELL</dt><dd><p>A numeric vector of length 6, containing the
unit cell parameters.</p>
</dd>
<dt>SORT</dt><dd><p>An integer vector of length 5, containing the
sort order of the first 5 columns of data.</p>
</dd>
<dt>SYMINF</dt><dd><p>Un-named list with 6 components: the number
of symmetry operations (an integer), the number of
primitive operations (an integer), the lattice type
(a one-letter character), the space group number (an
integer), the space group name (a 10-letter character
string) and the point group name (a 6-letter character).</p>
</dd>
<dt>RESO</dt><dd><p>Minimum and maximum data resolution, stored as
<code class="reqn">{1/d^2}</code>.</p>
</dd>
<dt>NDIF</dt><dd><p>Number of datasets whose reflection data are
present in the file.</p>
</dd>
<dt>SYMM</dt><dd><p>A character vector whose length depends on the
type of symmetry. It describes the symmetry operations in
human-readable format, International Tables style. Each
string is 80 characters long.</p>
</dd>
<dt>PROJECT</dt><dd><p>A data frame whose rows provide an ID and a
name (called &quot;pname&quot;) for the projects for which the data
contained have been produced.</p>
</dd>
<dt>CRYSTAL</dt><dd><p>A data frame whose rows provide an ID and a
name (called &quot;pname&quot;) for the crystals for which the data
contained have been produced.</p>
</dd>
<dt>DATASET</dt><dd><p>A data frame whose rows provide an ID and a
name (called &quot;pname&quot;) for the datasets included in the
reflections record.</p>
</dd>
<dt>DCELL</dt><dd><p>A data frame whose rows contain the
<code>CRYSTAL</code> IDs and cell parameters of each crystal
that has contributed to the data in the reflections record.</p>
</dd>
<dt>DWAVEL</dt><dd><p>A data frame whose rows contain the
<code>DATASET</code> IDs and the wavelength with which the
reflection data were collected.</p>
</dd>
<dt>COLUMN</dt><dd><p>A data frame describing the type of data
included in the reflections record. The data frame includes
the labels for each column, the dtype (see
<code><a href="#topic+merged_reflections">merged_reflections</a></code>) for each column, min and
max values and the <code>DATASET</code> ID.</p>
</dd>
<dt>COLSRC</dt><dd><p>A data frame with three columns. The first
includes the labels of each reflections record column. The
second includes a time stamp of when each data column was
created. The third is the dataset ID as a string.</p>
</dd>
<dt>COLGRP</dt><dd><p>A character string vector where each component
is an 80-letters string describing the name and type of
data.</p>
</dd>
<dt>HISTORY</dt><dd><p>A character string vector of variable length.
Each component is an 80-letter string summarising the steps
that lead to the current reflections record. HISTORY can
contain a maximum of 30 lines.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A named list. Each name correspond to a valid field in the mtz
header (see details).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"1dei_phases.mtz")
ltmp &lt;- readMTZHeader(filename)
print(names(ltmp))
print(ltmp$CELL)
print(ltmp$SYMM)

</code></pre>

<hr>
<h2 id='readpd_rtv'>Reads and output a CIF file for powder diffraction</h2><span id='topic+readpd_rtv'></span>

<h3>Description</h3>

<p>Reads and output a CIF file for powder diffraction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readpd_rtv(filename, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readpd_rtv_+3A_filename">filename</code></td>
<td>
<p>A character string. The path to a valid CIF file.</p>
</td></tr>
<tr><td><code id="readpd_rtv_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE (default) the function prints
a message highlighting what is included in the cif file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. Each name correspond to a valid field in the powder
diffraction Rietveld processed CIF.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"e-65-00i60-Isup2.rtv")
lCIF &lt;- readpd_rtv(filename)
print(names(lCIF))
print(lCIF$INTRO$CELL)
print(lCIF$INTRO$HALL)
print(lCIF$INTRO$HM)
print(lCIF$REFL)

</code></pre>

<hr>
<h2 id='readSF_CIF'>Reads and output an CIF file</h2><span id='topic+readSF_CIF'></span>

<h3>Description</h3>

<p>Reads and output an CIF file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSF_CIF(filename, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSF_CIF_+3A_filename">filename</code></td>
<td>
<p>A character string. The path to a valid CIF file.</p>
</td></tr>
<tr><td><code id="readSF_CIF_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE (default) the function prints
a message highlighting what is included in the cif file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. Each name correspond to a valid field in the SF cif.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"1dei-sf.cif")
lCIF &lt;- readSF_CIF(filename)
print(names(lCIF))
print(lCIF$INTRO$CELL)
print(lCIF$INTRO$HALL)
print(lCIF$INTRO$HM)
print(lCIF$REFL)
</code></pre>

<hr>
<h2 id='readsm_REFL'>Reads and output an CIF file</h2><span id='topic+readsm_REFL'></span>

<h3>Description</h3>

<p>Reads and output an CIF file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readsm_REFL(filename, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readsm_REFL_+3A_filename">filename</code></td>
<td>
<p>A character string. The path to a valid small molecule
reflection file. Typically a hkl or an fcf file.</p>
</td></tr>
<tr><td><code id="readsm_REFL_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE (default) the function prints
a message highlighting what is included in the cif file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. Each name correspond to a valid field in the fcf or hkl file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"1dei-sf.cif")
lCIF &lt;- readsm_REFL(filename)
print(names(lCIF))
print(lCIF$INTRO$CELL)
print(lCIF$SYMM)
print(lCIF$REFL)
</code></pre>

<hr>
<h2 id='readXDS_ASCII'>Load an XDS_ASCII file.</h2><span id='topic+readXDS_ASCII'></span>

<h3>Description</h3>

<p>Function to load XDS_ASCII.HKL files into a named list with
three components called <em>processing_info</em>, <em>header</em>
and <em>reflections</em> (see details further down).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readXDS_ASCII(filename, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readXDS_ASCII_+3A_filename">filename</code></td>
<td>
<p>A character string. The path to a valid
XDS ASCII file.</p>
</td></tr>
<tr><td><code id="readXDS_ASCII_+3A_message">message</code></td>
<td>
<p>A logical variable. If TRUE (default) the
function prints a message highlighting what is
included in the xds header. If <code>filename</code> is not a valid XDS
ascii file, the function returns 'NULL' and
prints out a warning message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads in all data from an XDS_ASCII data file
and organises them into a named list. The list's name are:
</p>

<dl>
<dt>processing_info</dt><dd><p>This list component includes three
logical variables, MERGE, FRIEDEL and PROFILE. Their
TRUE/FALSE value reflect features of the XDS_ASCII
file connected with the specific processing performed
to obtain the file itself
(for more details see <a href="https://xds.mr.mpg.de/">https://xds.mr.mpg.de/</a>).</p>
</dd>
<dt>header</dt><dd><p>This list includes several components, like
for instance SPACE_GROUP_NUMBER or
UNIT_CELL_CONSTANTS, which give informations
on the crystal and the experiment generating
the data.</p>
</dd>
<dt>reflections</dt><dd><p>This data.frame includes the actual
experimental data, i.e. the observations
collected during the X-ray diffraction
experiment on the crystal (or crystals).
The number and type of columns can vary.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A named list (see details).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load one of the XDS ASCII files included with
# this distribution of cry
datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"xds00_ascii.hkl")
ltmp &lt;- readXDS_ASCII(filename,message=FALSE)
print(names(ltmp))
print(ltmp$reflections[1:5,])

</code></pre>

<hr>
<h2 id='readXDS_ASCIIHeader'>Load an XDS_ASCII file's header.</h2><span id='topic+readXDS_ASCIIHeader'></span>

<h3>Description</h3>

<p>This function reads information from the header of an
XDS_ASCII.HKL data file and organises it into a named list
with a variable number of components, according to the type
of XDS_ASCII.HKL file (see details in
<code><a href="#topic+readXDS_ASCII">readXDS_ASCII</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readXDS_ASCIIHeader(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readXDS_ASCIIHeader_+3A_filename">filename</code></td>
<td>
<p>A character string. The path to a valid
XDS ASCII file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. Each name correspond to a valid field in
the xds header. If <code>filename</code> is not a valid XDS
ascii file, the function returns 'NULL' and prints out
a warning message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load one of the XDS ASCII files included with
# this distribution of cry
datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"xds00_ascii.hkl")
ltmp &lt;- readXDS_ASCIIHeader(filename)
print(names(ltmp))

</code></pre>

<hr>
<h2 id='rec_unit_cell'>Constructor for an S3 object of class &quot;rec_unit_cell.</h2><span id='topic+rec_unit_cell'></span>

<h3>Description</h3>

<p>This represents a crystal reciprocal unit cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rec_unit_cell(
  ar = NULL,
  br = NULL,
  cr = NULL,
  aar = NULL,
  bbr = NULL,
  ccr = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rec_unit_cell_+3A_ar">ar</code></td>
<td>
<p>A real number. One of the reciprocal unit cell's side lengths, in 1/angstroms.</p>
</td></tr>
<tr><td><code id="rec_unit_cell_+3A_br">br</code></td>
<td>
<p>A real number. One of the reciprocal unit cell's side lengths, in 1/angstroms.</p>
</td></tr>
<tr><td><code id="rec_unit_cell_+3A_cr">cr</code></td>
<td>
<p>A real number. One of the reciprocal unit cell's side lengths, in 1/angstroms.</p>
</td></tr>
<tr><td><code id="rec_unit_cell_+3A_aar">aar</code></td>
<td>
<p>A real number. One of the reciprocal unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="rec_unit_cell_+3A_bbr">bbr</code></td>
<td>
<p>A real number. One of the reciprocal unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="rec_unit_cell_+3A_ccr">ccr</code></td>
<td>
<p>A real number. One of the reciprocal unit cell's angles, in degrees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor can be used with less than the full set of six input parameters,
to create reciprocal unit cells for the cubic, tetragonal and orthogonal systems. Objects
of &quot;rec_unit_cell&quot; class can also be created with no parameters (default to a reciprocal cubic
cell of side length 0.1 1/angstroms).
</p>


<h3>Value</h3>

<p>An object of class &quot;rec_unit_cell&quot;. It is a named list of length 6 whose
last three slots are of &quot;angle&quot; class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a monoclinic reciprocal unit cell
ruc &lt;- unit_cell(0.115,0.033,0.077,90,120,90)
print(ruc)

# Create a cubic cell (default)
ruc &lt;- rec_unit_cell()
print(ruc)

# Create a reciprocal cubic cell with side 1/20
ruc &lt;- rec_unit_cell(1/20)
print(ruc)

# Create a reciprocal tetragonal unit cell with sides 1/20 and 1/60
ruc &lt;- rec_unit_cell(1/20,1/60)
print(ruc)

# Create a reciprocal orthogonal unit cell
ruc &lt;- rec_unit_cell(1/40,1/15,1/30)
print(ruc)

</code></pre>

<hr>
<h2 id='syminfo_to_matrix_list'>Operators of a specific space group in matrix form</h2><span id='topic+syminfo_to_matrix_list'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">3\times 3</code> matrices and <code class="reqn">3\times 1</code> vectors corresponding to point group
operations, group translations and cell centring of a given space group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syminfo_to_matrix_list(SG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syminfo_to_matrix_list_+3A_sg">SG</code></td>
<td>
<p>A character string. The extended Hermann-Mauguin symbol (e.g. 'P 1 1 21')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A crystallographic space group consists of a series of transformations on a point
<code class="reqn">(x_f,y_f,z_f)</code> in space that are mathematically implemented as the product of
a <code class="reqn">3\times 3</code> point-group matrix and the point fractional coordinates, <code class="reqn">(x_f,y_f,z_f)</code>,
followed by a sum with a <code class="reqn">3\times 1</code> translation vector. The complete set of points thus
produced can be cloned into a new and shifted set translated of an amount represented by a
<code class="reqn">3\times 1</code> centring vector.
</p>


<h3>Value</h3>

<p>mat_ops_list A named list consisting of 3 lists. The first list, PG, contains
<code class="reqn">3\times 3</code> point group matrices; the second list, T, contains the same number of
<code class="reqn">3\times 1</code> translation vectors. The first matrix is always the identity matrix, the first
translation vector is always the null vector. The third list, C, consists of centering vectors;
the first centering vector is always the null vector. To summarize, the output looks like the
following:
</p>
<p>[[ [[I,M2,M3,...,Mn]] , [[O,V2,V3,...,Vn]] , [[O,C2,C3,...,Cm]] ]]
where:
I                = identity    3X3 matrix
0                = null        3X1 vector
M2,M3,...,Mn     = point group 3X3 matrices
V2,V3,...,Cn     = translation 3X1 vectors
C2,C3,...,Cm     = centering   3X1 vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Symmetry operators for space group number 4, P 1 21 1
SG &lt;- "P 1 21 1"
mat_ops &lt;- syminfo_to_matrix_list(SG)
print(mat_ops)

</code></pre>

<hr>
<h2 id='syminfo_to_op_xyz_list'>Operators of a specific space group</h2><span id='topic+syminfo_to_op_xyz_list'></span>

<h3>Description</h3>

<p>Returns human-readable symmetry operators corresponding to a specific input space group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syminfo_to_op_xyz_list(SG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syminfo_to_op_xyz_list_+3A_sg">SG</code></td>
<td>
<p>A character string. The extended Hermann-Mauguin symbol (e.g. 'P 1 1 21')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A crystallographic space group includes a set of symmetry operators that can be expressed
like operations on the (x,y,z) fractional coordinates of atoms in a unit cell. So, for example,
The only operator associated with the space group P 1 is &quot;x,y,z&quot;, while the four operators
associated with P 21 21 21 are &quot;symop x,y,z&quot;, &quot;symop -x+1/2,-y,z+1/2&quot;, &quot;symop x+1/2,-y+1/2,-z&quot;,
&quot;symop -x,y+1/2,-z+1/2&quot;.
</p>


<h3>Value</h3>

<p>op_xyz_list A named list made of two vectors. The first vector, SYMOP, contains strings
describing the symmetry operators. The second vector, CENOP, contains strings describing the
centring of the unit cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Symmetry operators for space group number 3, P 1 2 1
SG &lt;- "P 1 2 1"
ltmp &lt;- syminfo_to_op_xyz_list(SG)
ltmp

</code></pre>

<hr>
<h2 id='symm_to_cell_const'>Cell parameter constrains from symmetry</h2><span id='topic+symm_to_cell_const'></span>

<h3>Description</h3>

<p>This function returns a set of constrains, as string character
expressions, imposed by the specific symmetry group on the
given unit cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symm_to_cell_const(SG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symm_to_cell_const_+3A_sg">SG</code></td>
<td>
<p>A character string indicating the extended
Hermann-Mauguin symbol for the space group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Space group symmetry imposes certain constraints on the
values that unit cell parameters can take. For example, the
symmetry represented by the monoclinic space group of extended
Hermann-Mauguin symbol &quot;P 1 2 1&quot; is compatible with a unit cell
in which alpha=gamma=90.
</p>
<p>There is just a handful of constrains for unit cells. Here they
are indicated with the following set of specific strings:
</p>

<ul>
<li> <p><strong>'No constrains'</strong> Like in a triclinic cell.
</p>
</li>
<li> <p><strong>'alpha=90'</strong> The alpha angle is fixed at 90
degrees.
</p>
</li>
<li> <p><strong>'beta=90'</strong> The beta angle is fixed at 90
degrees.
</p>
</li>
<li> <p><strong>'gamma=90'</strong> The gamma angle is fixed at 90
degrees.
</p>
</li>
<li> <p><strong>'gamma=120'</strong> The gamma angle is fixed at 120
degrees.
</p>
</li>
<li> <p><strong>'alpha=beta=gamma'</strong> The three angle have the
same value, different
from 90 degrees.
</p>
</li>
<li> <p><strong>'a=b'</strong> Cell side a is equal to cell side b.
</p>
</li>
<li> <p><strong>'a=b=c'</strong> The three cell sides are equal.
</p>
</li></ul>



<h3>Value</h3>

<p>vcons A character vector. Each component is a string,
like 'alpha=90' or 'a=b', that describes the
type of constrain to be applied to a unit cell
of a crystal structure with given space group
symmetry (see above).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># P 1 1 2 (group number 3) corresponds to setting 2
SG &lt;- translate_SG(3,set=2)

# Constrains for this symmetry
stmp &lt;- symm_to_cell_const(SG)
print(stmp)

# R 3 (rombohedral setting)
stmp &lt;- symm_to_cell_const("R 3 :R")
print(stmp)

</code></pre>

<hr>
<h2 id='sysabs'>Locate systematic absences</h2><span id='topic+sysabs'></span>

<h3>Description</h3>

<p>Given an mX3 matrix of Miller indices, this function returns
those indices corresponding to valid reflections, i.e. to
reflections which are not systematic absences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sysabs(hkl, SG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sysabs_+3A_hkl">hkl</code></td>
<td>
<p>An mX3 matrix or a data frame whose rows are the
three integers corresponding to the Miller
indices.</p>
</td></tr>
<tr><td><code id="sysabs_+3A_sg">SG</code></td>
<td>
<p>A character. The extended Hermann-Mauguin symbol
of the crystallographic space group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Crystallography symmetry forces constraints on data from
x-ray diffraction. One of these constraints consists in the
full cancellation of reflections with certain Miller indices.
It is said that the reflection with that specific Miller index
is systematically absent. For example, in data corresponding
to a crystal with space group C 2, general reflections like
(h,k,l) must obey h+k=2n (even number). Thus, the Miller
indices (2,3,1) are a systematic absence because 2+3=5 (odd).
</p>


<h3>Value</h3>

<p>idx A vector of integers corresponding to the
position, in the array <code>mhkl</code>, in which the
Miller indices ARE NOT systematically absent.
The position of systematically-absent reflections
can be found using !idx.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># C 2 monoclinic space group (special setting)
csym &lt;- cryst_symm(15,set=5)
print(csym$SG)

# Create a full data frame of Miller indices
hkl &lt;- expand.grid(H=-4:4,K=-4:4,L=-4:4)

# Index corresponding to valid reflections
# (not systematic absences)
idx &lt;- sysabs(hkl,csym$SG)

# Indices for all reflections
fulldx &lt;- 1:length(hkl[,1])

# Index corresponding to systematic absences
jdx &lt;- fulldx[-idx]

# A couple of systematic absences
hkl[jdx[1:2],]

</code></pre>

<hr>
<h2 id='theme_cry'>cry theme for ggplot2</h2><span id='topic+theme_cry'></span>

<h3>Description</h3>

<p>cry theme for ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_cry()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 plot_SHELX(obj_shelxc, var = obj_shelxc$Chi_sq, type = "shelxc",
 title_chart = "Chis ^2") + theme_cry

## End(Not run)
</code></pre>

<hr>
<h2 id='translate_SG'>Translation of space group symbols, numbers, etc.</h2><span id='topic+translate_SG'></span>

<h3>Description</h3>

<p>Function to find out space group symbol given number and vice-versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_SG(value, SG_in = "number", SG_out = "xHM", set = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_SG_+3A_value">value</code></td>
<td>
<p>A string or an integer number corresponding to the space group
being investigated.</p>
</td></tr>
<tr><td><code id="translate_SG_+3A_sg_in">SG_in</code></td>
<td>
<p>A string representing the space group format for the input.
Possible values are:
</p>

<ul>
<li><p>1) &quot;number&quot;
</p>
</li>
<li><p>2) &quot;ccp4&quot;
</p>
</li>
<li><p>3) &quot;Hall&quot;
</p>
</li>
<li><p>4) &quot;xHM&quot;
</p>
</li>
<li><p>5) &quot;old&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="translate_SG_+3A_sg_out">SG_out</code></td>
<td>
<p>A string representing the space group format for the output.
Possible values are:
</p>

<ul>
<li><p>1) &quot;number&quot;
</p>
</li>
<li><p>2) &quot;ccp4&quot;
</p>
</li>
<li><p>3) &quot;Hall&quot;
</p>
</li>
<li><p>4) &quot;xHM&quot;
</p>
</li>
<li><p>5) &quot;old&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="translate_SG_+3A_set">set</code></td>
<td>
<p>Specific setting for the given space group. A number like 1,2,...
It is used if for a same symbol there are more than one choice.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns either a number of a specific symbol corresponding to a
crystallographic space group. The input is an integer number or a character symbol
identifying a specific space group. The output is, similarly, the corresponding
character symbol or number, according to what is specified in the input.
Possible formats are:
</p>

<ul>
<li><p>1) Space group number
</p>
</li>
<li><p>2) Hall symbol (e.g. ' P 2yb (z,x,y)')
</p>
</li>
<li><p>3) Extended Hermann-Mauguin symbol (e.g. 'P 1 1 21')
</p>
</li></ul>

<p>If more than one setting is implied in an ambiguous way in the input value,
then the first setting will be selected by default for the output value,
unless argument &quot;set&quot; is set to another value.
</p>


<h3>Value</h3>

<p>list_SG A named list with two fields. The first field, &quot;msg&quot;, is a
character string representing the space group format needed
as output. Possible values are the same as those for SG_in.
The second field, &quot;ans&quot;, is TRUE only if a valid symbol for
&quot;msg&quot; is found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Space Group P1 corresponds to number 1
translate_SG(value=1,SG_in="number",SG_out="xHM")

</code></pre>

<hr>
<h2 id='unit_cell'>Constructor for an S3 object of class &quot;unit_cell.</h2><span id='topic+unit_cell'></span>

<h3>Description</h3>

<p>This represents a crystal unit cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit_cell(a = NULL, b = NULL, c = NULL, aa = NULL, bb = NULL, cc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unit_cell_+3A_a">a</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="unit_cell_+3A_b">b</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="unit_cell_+3A_c">c</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="unit_cell_+3A_aa">aa</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="unit_cell_+3A_bb">bb</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="unit_cell_+3A_cc">cc</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor can be used with less than the full set of six input parameters,
to create unit cells for the cubic, tetragonal and orthogonal systems. Objects
of &quot;unit_cell&quot; class can also be created with no parameters (default to a cubic
cell of side length 10 angstroms).
</p>


<h3>Value</h3>

<p>An object of class &quot;unit_cell&quot;. It is a named list of length 6 whose
last three slots are of &quot;angle&quot; class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a monoclinic unit cell
uc &lt;- unit_cell(10,30,15,90,60,90)
print(uc)

# Create a cubic cell (default)
uc &lt;- unit_cell()
print(uc)

# Create a cubic cell with side 20
uc &lt;- unit_cell(20)
print(uc)

# Create a tetragonal unit cell with sides 20 and 60
uc &lt;- unit_cell(20,60)
print(uc)

# Create an orthogonal unit cell
uc &lt;- unit_cell(40,15,30)
print(uc)

</code></pre>

<hr>
<h2 id='writeMTZ'>Write data to an MTZ file</h2><span id='topic+writeMTZ'></span>

<h3>Description</h3>

<p>Write reflections and experimental information
to an MTZ file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeMTZ(reflections, header, filename, title = NULL, batch_header = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeMTZ_+3A_reflections">reflections</code></td>
<td>
<p>A data frame containing all reflection
records in columns. This is usually derived
from modifications of a previously existing
data frame obtained using
<code><a href="#topic+readMTZ">readMTZ</a></code>.</p>
</td></tr>
<tr><td><code id="writeMTZ_+3A_header">header</code></td>
<td>
<p>A list whose components are other R objects. This
is normally derived from the reading of another
MTZ file using <code><a href="#topic+readMTZ">readMTZ</a></code>. See further
details at <code><a href="#topic+readMTZHeader">readMTZHeader</a></code>.</p>
</td></tr>
<tr><td><code id="writeMTZ_+3A_filename">filename</code></td>
<td>
<p>A character string. The path to a valid mtz
file. If a file with the same name exists, it
will be deleted.</p>
</td></tr>
<tr><td><code id="writeMTZ_+3A_title">title</code></td>
<td>
<p>A character string. The character string
associated with the TITLE keyword in an MTZ file.
This feature makes it easy to quickly identify the
data file in <a href="https://www.ccp4.ac.uk">CCP4</a>
programs. Default (NULL) is for the output file
to have the same title as the input file.</p>
</td></tr>
<tr><td><code id="writeMTZ_+3A_batch_header">batch_header</code></td>
<td>
<p>A named list including information at data
collection time. This component is present
only for raw (unmerged) intensity data
produce after the diffraction images
integration. Merged MTZ reflection files
have <code>batch_header=NULL</code>.
Names and types depend on
the type of experiment (more information
on this can be found at
<a href="https://www.ccp4.ac.uk">CCP4</a>.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return any R object. It outputs
an MTZ reflection file to some target location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read the 1dei_phases data included in the package
datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"1dei_phases.mtz")
lMTZ &lt;- readMTZ(filename)

# Change dataset name
print(lMTZ$header$DATASET)
lMTZ$header$DATASET[2,2] &lt;- "New CRY dataset"

# Add one HISTORY line (string has to be 80-letters long)
addhist &lt;- "From CRY 0.3.0 - run on Apr 2 20:12:00 2021"
n &lt;- nchar(addhist)
nblanks &lt;- 80-n
for (i in 1:nblanks) addhist &lt;- paste0(addhist," ")
lMTZ$header$HISTORY &lt;- c(lMTZ$header$HISTORY,addhist)

# Write to a new MTZ file
wd &lt;- tempdir()
fname &lt;- file.path(wd,"new.mtz")
writeMTZ(lMTZ$reflections,lMTZ$header,fname)

</code></pre>

<hr>
<h2 id='writeXDS_ASCII'>Write data to an XDS_ASCII file.</h2><span id='topic+writeXDS_ASCII'></span>

<h3>Description</h3>

<p>Function to write an XDS_ASCII-tye named list to a file with
XDS_ASCII format (unmerged or merged).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeXDS_ASCII(proc_info, header, reflections, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeXDS_ASCII_+3A_proc_info">proc_info</code></td>
<td>
<p>The first component of an XDS_ASCII-type
object. It includes up to three
components, <code>MERGE</code>, <code>FRIEDEL</code>
and <code>PROFILE_FITTING</code> (this last
component is missing for files with
merged observations, obtained with the
program XSCALE).</p>
</td></tr>
<tr><td><code id="writeXDS_ASCII_+3A_header">header</code></td>
<td>
<p>The second component of an XDS_ASCII-type object.
This object includes several other objects (see
<code><a href="#topic+readXDS_ASCII">readXDS_ASCII</a></code>).</p>
</td></tr>
<tr><td><code id="writeXDS_ASCII_+3A_reflections">reflections</code></td>
<td>
<p>The third component of an XDS_ASCII-type
object. It contains the data (the
experimental observations). See
<code><a href="#topic+readXDS_ASCII">readXDS_ASCII</a></code> for more details.</p>
</td></tr>
<tr><td><code id="writeXDS_ASCII_+3A_filename">filename</code></td>
<td>
<p>A character string. The path to a valid
XDS_ASCII file. If a file with the same name
exists, it will be deleted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The XDS_ASCII-type named list includes three components,
<code>processing_info</code>, <code>header</code> and <code>reflections</code>
(see <code><a href="#topic+readXDS_ASCII">readXDS_ASCII</a></code>).
</p>


<h3>Value</h3>

<p>This function does not return any R object. It outputs
an XDS_ASCII reflection file to some target location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load one of the XDS ASCII files included with
# this distribution of cry
datadir &lt;- system.file("extdata",package="cry")
filename &lt;- file.path(datadir,"xds00_ascii.hkl")
lXDS &lt;- readXDS_ASCII(filename)

# Change date
print(lXDS$header$DATE)
lXDS$header$DATE &lt;- "7-Apr-2021"

# Write to a file called "new.hkl"
wd &lt;- tempdir()
fname &lt;- file.path(wd,"new.hkl")
writeXDS_ASCII(lXDS$processing_info,lXDS$header,
               lXDS$reflections,fname)

</code></pre>

<hr>
<h2 id='xtal_mat01'>Matrix for cell orthogonalisation (first choice)</h2><span id='topic+xtal_mat01'></span>

<h3>Description</h3>

<p>Given the cell parameters, this function returns a matrix for
transforming fractional to orthogonal coordinates, corresponding
to the first choice in Giacovazzo's book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtal_mat01(a, b, c, aa, bb, cc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtal_mat01_+3A_a">a</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="xtal_mat01_+3A_b">b</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="xtal_mat01_+3A_c">c</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="xtal_mat01_+3A_aa">aa</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="xtal_mat01_+3A_bb">bb</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="xtal_mat01_+3A_cc">cc</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">3\times </code>$ matrix <code class="reqn">M</code> that transforms a <code class="reqn">3\times 1</code> vector of fractional
coordinates into a <code class="reqn">3\times 1</code> vector of orthogonal coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fractional coordinates
Xf = c(0.1,0.4,0.8)

# Orthorombic unit cell
M = xtal_mat01(10,40,20,90,90,90)

# Cartesian coordinates
Xc = M%*%Xf
</code></pre>

<hr>
<h2 id='xtal_mat02'>Matrix for cell orthogonalisation (second choice)</h2><span id='topic+xtal_mat02'></span>

<h3>Description</h3>

<p>Given the cell parameters, this function returns a matrix for
transforming fractional to orthogonal coordinates, corresponding
to the second choice in Giacovazzo's book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtal_mat02(a, b, c, aa, bb, cc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtal_mat02_+3A_a">a</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="xtal_mat02_+3A_b">b</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="xtal_mat02_+3A_c">c</code></td>
<td>
<p>A real number. One of the unit cell's side lengths, in angstroms.</p>
</td></tr>
<tr><td><code id="xtal_mat02_+3A_aa">aa</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="xtal_mat02_+3A_bb">bb</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
<tr><td><code id="xtal_mat02_+3A_cc">cc</code></td>
<td>
<p>A real number. One of the unit cell's angles, in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">3\times </code>$ matrix <code class="reqn">M</code> that transforms a <code class="reqn">3\times 1</code> vector of fractional
coordinates into a <code class="reqn">3\times 1</code> vector of orthogonal coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fractional coordinates
Xf = c(0.1,0.4,0.8)

# Orthorombic unit cell
M = xtal_mat02(10,40,20,90,90,90)

# Cartesian coordinates
Xc = M%*%Xf
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
