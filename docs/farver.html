<!DOCTYPE html><html><head><title>Help for package farver</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {farver}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#farver-package'><p>farver: High Performance Colour Space Manipulation</p></a></li>
<li><a href='#as_white_ref'><p>Convert value to a tristimulus values normalised to Y=100</p></a></li>
<li><a href='#compare_colour'><p>Calculate the distance between colours</p></a></li>
<li><a href='#convert_colour'><p>Convert between colour spaces</p></a></li>
<li><a href='#decode_colour'><p>Decode RGB hex-strings into colour values</p></a></li>
<li><a href='#encode_colour'><p>Encode colours into RGB hex-strings</p></a></li>
<li><a href='#manip_channel'><p>Modify colour space channels in hex-encoded colour strings</p></a></li>
<li><a href='#native-encoding'><p>Convert to and from the R native colour representation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High Performance Colour Space Manipulation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>The encoding of colour can be handled in many different ways,
    using different colour spaces. As different colour spaces have
    different uses, efficient conversion between these representations are
    important. The 'farver' package provides a set of functions that gives
    access to very fast colour space conversion and comparisons
    implemented in C++, and offers speed improvements over the
    'convertColor' function in the 'grDevices' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://farver.data-imaginist.com">https://farver.data-imaginist.com</a>,
<a href="https://github.com/thomasp85/farver">https://github.com/thomasp85/farver</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/farver/issues">https://github.com/thomasp85/farver/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-13 08:31:27 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Berendea Nicolae [aut] (Author of the ColorSpace C++ library),
  Romain François <a href="https://orcid.org/0000-0002-2444-4226"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Posit, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomas.pedersen@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-13 09:33:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='farver-package'>farver: High Performance Colour Space Manipulation</h2><span id='topic+farver'></span><span id='topic+farver-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>The encoding of colour can be handled in many different ways, using different colour spaces. As different colour spaces have different uses, efficient conversion between these representations are important. The 'farver' package provides a set of functions that gives access to very fast colour space conversion and comparisons implemented in C++, and offers speed improvements over the 'convertColor' function in the 'grDevices' package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomas.pedersen@posit.co">thomas.pedersen@posit.co</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Berendea Nicolae (Author of the ColorSpace C++ library)
</p>
</li>
<li><p> Romain François <a href="mailto:romain@purrple.cat">romain@purrple.cat</a> (<a href="https://orcid.org/0000-0002-2444-4226">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://farver.data-imaginist.com">https://farver.data-imaginist.com</a>
</p>
</li>
<li> <p><a href="https://github.com/thomasp85/farver">https://github.com/thomasp85/farver</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/farver/issues">https://github.com/thomasp85/farver/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_white_ref'>Convert value to a tristimulus values normalised to Y=100</h2><span id='topic+as_white_ref'></span>

<h3>Description</h3>

<p>This function can take either the name of a standardised illuminants, x
and y chromaticity coordinates or X, Y, and Z tristimulus values and converts
it to tristimulus values normalised to Y=100. All Illuminant series A-F are
supported and can be queried both on the CIE 1931 2° and CIE 1964 10°
chromaticity coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_white_ref(x, fow = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_white_ref_+3A_x">x</code></td>
<td>
<p>A string giving the name of the standardized illuminant or a
2 (chromaticity) or 3 (trsitimulus) length numeric vector.</p>
</td></tr>
<tr><td><code id="as_white_ref_+3A_fow">fow</code></td>
<td>
<p>The field-of-view for the illuminant - either <code>2</code> or <code>10</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-length vector with tristimulus values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using names
as_white_ref('D65')

# Using chromaticity values
as_white_ref(c(0.3, 0.4))
</code></pre>

<hr>
<h2 id='compare_colour'>Calculate the distance between colours</h2><span id='topic+compare_colour'></span>

<h3>Description</h3>

<p>There are many ways to measure the distance between colours. <code>farver</code>
provides 5 different algorithms, ranging from simple euclidean distance in
RGB space, to different perceptual measures such as CIE2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_colour(
  from,
  to = NULL,
  from_space,
  to_space = from_space,
  method = "euclidean",
  white_from = "D65",
  white_to = white_from,
  lightness = 2,
  chroma = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_colour_+3A_from">from</code>, <code id="compare_colour_+3A_to">to</code></td>
<td>
<p>Numeric matrices with colours to compare - the format is the
same as that for <code><a href="#topic+convert_colour">convert_colour()</a></code>. If <code>to</code> is not set <code>from</code> will be
compared with itself and only the upper triangle will get calculated</p>
</td></tr>
<tr><td><code id="compare_colour_+3A_from_space">from_space</code>, <code id="compare_colour_+3A_to_space">to_space</code></td>
<td>
<p>The colour space of <code>from</code> and <code>to</code> respectively.
<code>to_space</code> defaults to be the same as <code>from_space</code>.</p>
</td></tr>
<tr><td><code id="compare_colour_+3A_method">method</code></td>
<td>
<p>The method to use for comparison. Either <code>'euclidean'</code>,
<code>'cie1976'</code>, <code>'cie94'</code>, <code>'cie2000'</code>, or <code>'cmc'</code></p>
</td></tr>
<tr><td><code id="compare_colour_+3A_white_from">white_from</code>, <code id="compare_colour_+3A_white_to">white_to</code></td>
<td>
<p>The white reference of the from and to colour
space. Will only have an effect for relative colour spaces such as Lab and
luv. Any value accepted by <code><a href="#topic+as_white_ref">as_white_ref()</a></code> allowed.</p>
</td></tr>
<tr><td><code id="compare_colour_+3A_lightness">lightness</code>, <code id="compare_colour_+3A_chroma">chroma</code></td>
<td>
<p>Weight of lightness vs chroma when using CMC. Common
values are <code>2</code> and <code>1</code> (default) for acceptability and <code>1</code> and <code>1</code> for
imperceptibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the same number of rows as colours in <code>from</code>
and the same number of columns as colours in <code>to</code>. If <code>to</code> is not given, only
the upper triangle will be returned.
</p>


<h3>Handling of non-finite and out of bounds values</h3>

<p><code>NA</code>, <code>NaN</code>, <code>-Inf</code>, and <code>Inf</code> are treated as invalid input and will result
in <code>NA</code> values for the colour. If a given colourspace has finite bounds in
some of their channels, the input will be capped before conversion, and the
output will be capped before returning, so that both input and output colours
are valid colours in their respective space. This means that converting back
and forth between two colourspaces may result in a change in the colour if
the gamut of one of the spaces is less than the other.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- decode_colour(rainbow(10))
h &lt;- decode_colour(heat.colors(15))

# Compare two sets of colours
compare_colour(r, h, 'rgb', method = 'cie2000')

# Compare a set of colours with itself
compare_colour(r, from_space = 'rgb', method = 'cmc')

# Compare colours from different colour spaces
h_luv &lt;- convert_colour(h, 'rgb', 'luv')
compare_colour(r, h_luv, 'rgb', 'luv')

</code></pre>

<hr>
<h2 id='convert_colour'>Convert between colour spaces</h2><span id='topic+convert_colour'></span>

<h3>Description</h3>

<p>This function lets you convert between different representations of colours.
The API is reminiscent of <code><a href="grDevices.html#topic+convertColor">grDevices::convertColor()</a></code>, but the performance is
much better. It is not assured that <code>grDevices::convertColor()</code> and
<code>convert_colour()</code> provide numerically equivalent conversion at 16bit level as
the formula used are potentially slightly different. For all intend and
purpose, the resulting colours will be equivalent though.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_colour(colour, from, to, white_from = "D65", white_to = white_from)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_colour_+3A_colour">colour</code></td>
<td>
<p>A numeric matrix (or an object coercible to one) with colours
encoded in the rows and the different colour space values in the columns. For
all colourspaces except <code>'cmyk'</code> this will mean a matrix with three columns -
for <code>'cmyk'</code> it means four columns.</p>
</td></tr>
<tr><td><code id="convert_colour_+3A_from">from</code>, <code id="convert_colour_+3A_to">to</code></td>
<td>
<p>The input and output colour space. Allowed values are: <code>"cmy"</code>,
<code>"cmyk"</code>, <code>"hsl"</code>, <code>"hsb"</code>, <code>"hsv"</code>, <code>"lab"</code> (CIE L*ab), <code>"hunterlab"</code>
(Hunter Lab), <code>"oklab"</code>, <code>"lch"</code> (CIE Lch(ab) / polarLAB), <code>"luv"</code>,
<code>"rgb"</code> (sRGB), <code>"xyz"</code>, <code>"yxy"</code> (CIE xyY), <code>"hcl"</code> (CIE Lch(uv) / polarLuv),
or <code>"oklch"</code> (Polar form of oklab)</p>
</td></tr>
<tr><td><code id="convert_colour_+3A_white_from">white_from</code>, <code id="convert_colour_+3A_white_to">white_to</code></td>
<td>
<p>The white reference of the from and to colour
space. Will only have an effect for relative colour spaces such as Lab and
luv. Any value accepted by <code><a href="#topic+as_white_ref">as_white_ref()</a></code> allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the same number of rows as <code>colour</code> and either
3 or 4 columns depending on the value of <code>to</code>. If <code>colour</code> is given as a
<code>data.frame</code> the output will be a data.frame as well
</p>


<h3>Handling of non-finite and out of bounds values</h3>

<p><code>NA</code>, <code>NaN</code>, <code>-Inf</code>, and <code>Inf</code> are treated as invalid input and will result
in <code>NA</code> values for the colour. If a given colourspace has finite bounds in
some of their channels, the input will be capped before conversion, and the
output will be capped before returning, so that both input and output colours
are valid colours in their respective space. This means that converting back
and forth between two colourspaces may result in a change in the colour if
the gamut of one of the spaces is less than the other.
</p>


<h3>Note</h3>

<p>This function and <code><a href="grDevices.html#topic+convertColor">convertColor()</a></code> are not
numerically equivalent due to rounding errors, but for all intend and purpose
they give the same results.
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+convertColor">grDevices::convertColor()</a></code>, <code><a href="grDevices.html#topic+col2rgb">grDevices::col2rgb()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spectrum &lt;- decode_colour(rainbow(10))
spec_lab &lt;- convert_colour(spectrum, 'rgb', 'lab')
spec_lab

# Convert between different white references
convert_colour(spec_lab, 'lab', 'lab', white_from = 'D65', white_to = 'F10')

</code></pre>

<hr>
<h2 id='decode_colour'>Decode RGB hex-strings into colour values</h2><span id='topic+decode_colour'></span>

<h3>Description</h3>

<p>This is a version of <code><a href="grDevices.html#topic+col2rgb">grDevices::col2rgb()</a></code> that returns the colour values in
the standard form expected by farver (matrix with a row per colour). As with
<code><a href="#topic+encode_colour">encode_colour()</a></code> it can do colour conversion on the fly, meaning that you can
decode a hex string directly into any of the supported colour spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_colour(colour, alpha = FALSE, to = "rgb", white = "D65", na_value = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_colour_+3A_colour">colour</code></td>
<td>
<p>A character vector of hex-encoded values or a valid colour name
as given in <code><a href="grDevices.html#topic+colors">grDevices::colours()</a></code>.</p>
</td></tr>
<tr><td><code id="decode_colour_+3A_alpha">alpha</code></td>
<td>
<p>If <code>TRUE</code> the alpha channel will be returned as well (scaled
between 0 and 1). If no alpha channel exists in the colour it will be
assumed 1. If <code>FALSE</code> any alpha channel is ignored.</p>
</td></tr>
<tr><td><code id="decode_colour_+3A_to">to</code></td>
<td>
<p>The output colour space. Allowed values are: <code>"cmy"</code>,
<code>"cmyk"</code>, <code>"hsl"</code>, <code>"hsb"</code>, <code>"hsv"</code>, <code>"lab"</code> (CIE L*ab), <code>"hunterlab"</code>
(Hunter Lab), <code>"oklab"</code>, <code>"lch"</code> (CIE Lch(ab) / polarLAB), <code>"luv"</code>,
<code>"rgb"</code> (sRGB), <code>"xyz"</code>, <code>"yxy"</code> (CIE xyY), <code>"hcl"</code> (CIE Lch(uv) / polarLuv),
or <code>"oklch"</code> (Polar form of oklab)</p>
</td></tr>
<tr><td><code id="decode_colour_+3A_white">white</code></td>
<td>
<p>The white reference of the output colour space. Will only have
an effect for relative colour spaces such as Lab and luv. Any value accepted
by <code><a href="#topic+as_white_ref">as_white_ref()</a></code> allowed.</p>
</td></tr>
<tr><td><code id="decode_colour_+3A_na_value">na_value</code></td>
<td>
<p>A valid colour string or <code>NA</code> to use when <code>colour</code> contains
<code>NA</code> elements. The general approach in farver is to carry <code>NA</code> values over,
but if you want to mimick <code><a href="grDevices.html#topic+col2rgb">col2rgb()</a></code> you should set
<code>na_value = 'transparent'</code>, i.e. treat <code>NA</code> as transparent white.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with a row for each element in <code>colour</code> and either
3, 4, or 5 columns depending on the value of <code>alpha</code> and <code>to</code>.
</p>


<h3>Handling of non-finite and out of bounds values</h3>

<p><code>NA</code>, <code>NaN</code>, <code>-Inf</code>, and <code>Inf</code> are treated as invalid input and will result
in <code>NA</code> values for the colour. If a given colourspace has finite bounds in
some of their channels, the input will be capped before conversion, and the
output will be capped before returning, so that both input and output colours
are valid colours in their respective space. This means that converting back
and forth between two colourspaces may result in a change in the colour if
the gamut of one of the spaces is less than the other.
</p>


<h3>See Also</h3>

<p>Other encoding and decoding functions: 
<code><a href="#topic+encode_colour">encode_colour</a>()</code>,
<code><a href="#topic+manip_channel">manip_channel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># basic use
decode_colour(c('#43e1f6', 'steelblue', '#67ce9fe4'))

# Return alpha as well (no alpha value is interpreted as 1)
decode_colour(c('#43e1f6', 'steelblue', '#67ce9fe4'), alpha = TRUE)

# Decode directly into specific colour space
decode_colour(c('#43e1f6', 'steelblue', '#67ce9fe4'), to = 'lch')

</code></pre>

<hr>
<h2 id='encode_colour'>Encode colours into RGB hex-strings</h2><span id='topic+encode_colour'></span>

<h3>Description</h3>

<p>This is a version of <code><a href="grDevices.html#topic+rgb">grDevices::rgb()</a></code> that works with the standard colour
format used in farver (matrix or data.frame with colours in rows). It further
support taking input from any colour space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_colour(colour, alpha = NULL, from = "rgb", white = "D65")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode_colour_+3A_colour">colour</code></td>
<td>
<p>A numeric matrix (or an object coercible to one) with colours
encoded in the rows and the different colour space values in the columns. For
all colourspaces except <code>'cmyk'</code> this will mean a matrix with three columns -
for <code>'cmyk'</code> it means four columns.</p>
</td></tr>
<tr><td><code id="encode_colour_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector between 0 and 1. Will be recycled to the number
of rows in <code>colour</code>. If <code>NULL</code> or a single <code>NA</code> it will be ignored.</p>
</td></tr>
<tr><td><code id="encode_colour_+3A_from">from</code></td>
<td>
<p>The input colour space. Allowed values are: <code>"cmy"</code>,
<code>"cmyk"</code>, <code>"hsl"</code>, <code>"hsb"</code>, <code>"hsv"</code>, <code>"lab"</code> (CIE L*ab), <code>"hunterlab"</code>
(Hunter Lab), <code>"oklab"</code>, <code>"lch"</code> (CIE Lch(ab) / polarLAB), <code>"luv"</code>,
<code>"rgb"</code> (sRGB), <code>"xyz"</code>, <code>"yxy"</code> (CIE xyY), <code>"hcl"</code> (CIE Lch(uv) / polarLuv),
or <code>"oklch"</code> (Polar form of oklab)</p>
</td></tr>
<tr><td><code id="encode_colour_+3A_white">white</code></td>
<td>
<p>The white reference of the input colour space. Will only have an
effect for relative colour spaces such as Lab and luv. Any value accepted by
<code><a href="#topic+as_white_ref">as_white_ref()</a></code> allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with colours encoded as <code style="white-space: pre;">&#8288;#RRGGBB(AA)&#8288;</code>
</p>


<h3>Handling of non-finite and out of bounds values</h3>

<p><code>NA</code>, <code>NaN</code>, <code>-Inf</code>, and <code>Inf</code> are treated as invalid input and will result
in <code>NA</code> values for the colour. If a given colourspace has finite bounds in
some of their channels, the input will be capped before conversion, and the
output will be capped before returning, so that both input and output colours
are valid colours in their respective space. This means that converting back
and forth between two colourspaces may result in a change in the colour if
the gamut of one of the spaces is less than the other.
</p>


<h3>Note</h3>

<p>The output may differ slightly from that of <code><a href="grDevices.html#topic+rgb">grDevices::rgb()</a></code> since
<code>rgb()</code> doesn't round numeric values correctly.
</p>


<h3>See Also</h3>

<p>Other encoding and decoding functions: 
<code><a href="#topic+decode_colour">decode_colour</a>()</code>,
<code><a href="#topic+manip_channel">manip_channel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spectrum &lt;- decode_colour(rainbow(10))

encode_colour(spectrum)

# Attach alpha values
encode_colour(spectrum, alpha = c(0.5, 1))

# Encode from a different colour space
spectrum_hcl &lt;- convert_colour(spectrum, 'rgb', 'hcl')
encode_colour(spectrum_hcl, from = 'hcl')

</code></pre>

<hr>
<h2 id='manip_channel'>Modify colour space channels in hex-encoded colour strings</h2><span id='topic+manip_channel'></span><span id='topic+set_channel'></span><span id='topic+add_to_channel'></span><span id='topic+multiply_channel'></span><span id='topic+raise_channel'></span><span id='topic+cap_channel'></span><span id='topic+get_channel'></span>

<h3>Description</h3>

<p>This set of functions allows you to modify colours as given by strings,
whithout first decoding them. For large vectors of colour values this should
provide a considerable speedup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_channel(
  colour,
  channel,
  value,
  space = "rgb",
  white = "D65",
  na_value = NA
)

add_to_channel(
  colour,
  channel,
  value,
  space = "rgb",
  white = "D65",
  na_value = NA
)

multiply_channel(
  colour,
  channel,
  value,
  space = "rgb",
  white = "D65",
  na_value = NA
)

raise_channel(
  colour,
  channel,
  value,
  space = "rgb",
  white = "D65",
  na_value = NA
)

cap_channel(
  colour,
  channel,
  value,
  space = "rgb",
  white = "D65",
  na_value = NA
)

get_channel(colour, channel, space = "rgb", white = "D65", na_value = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manip_channel_+3A_colour">colour</code></td>
<td>
<p>A character string giving colours, either as hexadecimal
strings or accepted colour names.</p>
</td></tr>
<tr><td><code id="manip_channel_+3A_channel">channel</code></td>
<td>
<p>The channel to modify or extract as a single letter, or
<code>'alpha'</code> for the alpha channel.</p>
</td></tr>
<tr><td><code id="manip_channel_+3A_value">value</code></td>
<td>
<p>The value to modify with</p>
</td></tr>
<tr><td><code id="manip_channel_+3A_space">space</code></td>
<td>
<p>The colour space the channel pertains to. Allowed values are:
<code>"cmy"</code>, <code>"cmyk"</code>, <code>"hsl"</code>, <code>"hsb"</code>, <code>"hsv"</code>, <code>"lab"</code> (CIE L*ab), <code>"hunterlab"</code>
(Hunter Lab), <code>"oklab"</code> , <code>"lch"</code> (CIE Lch(ab) / polarLAB), <code>"luv"</code>,
<code>"rgb"</code> (sRGB), <code>"xyz"</code>, <code>"yxy"</code> (CIE xyY), <code>"hcl"</code> (CIE Lch(uv) / polarLuv),
or <code>"oklch"</code> (Polar form of oklab)</p>
</td></tr>
<tr><td><code id="manip_channel_+3A_white">white</code></td>
<td>
<p>The white reference of the channel colour space. Will only have
an effect for relative colour spaces such as Lab and luv. Any value accepted
by <code><a href="#topic+as_white_ref">as_white_ref()</a></code> allowed.</p>
</td></tr>
<tr><td><code id="manip_channel_+3A_na_value">na_value</code></td>
<td>
<p>A valid colour string or <code>NA</code> to use when <code>colour</code> contains
<code>NA</code> elements. The general approach in farver is to carry <code>NA</code> values over,
but if you want to mimick <code><a href="grDevices.html#topic+col2rgb">col2rgb()</a></code> you should set
<code>na_value = 'transparent'</code>, i.e. treat <code>NA</code> as transparent white.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the same length as <code>colour</code> (or a numeric
vector in the case of <code>get_channel()</code>)
</p>


<h3>See Also</h3>

<p>Other encoding and decoding functions: 
<code><a href="#topic+decode_colour">decode_colour</a>()</code>,
<code><a href="#topic+encode_colour">encode_colour</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spectrum &lt;- rainbow(10)

# set a specific channel
set_channel(spectrum, 'r', c(10, 50))
set_channel(spectrum, 'l', 50, space = 'lab')
set_channel(spectrum, 'alpha', c(0.5, 1))

# Add value to channel
add_to_channel(spectrum, 'r', c(10, 50))
add_to_channel(spectrum, 'l', 50, space = 'lab')

# Multiply a channel
multiply_channel(spectrum, 'r', c(10, 50))
multiply_channel(spectrum, 'l', 50, space = 'lab')

# set a lower bound on a channel
raise_channel(spectrum, 'r', c(10, 50))
raise_channel(spectrum, 'l', 20, space = 'lab')

# set an upper bound on a channel
cap_channel(spectrum, 'r', c(100, 50))
cap_channel(spectrum, 'l', 20, space = 'lab')

</code></pre>

<hr>
<h2 id='native-encoding'>Convert to and from the R native colour representation</h2><span id='topic+native-encoding'></span><span id='topic+encode_native'></span><span id='topic+decode_native'></span>

<h3>Description</h3>

<p>Colours in R are internally encoded as integers when they are passed around
to graphics devices. The encoding splits the 32 bit in the integer between
red, green, blue, and alpha, so that each get 8 bit, equivalent to 256
values. It is very seldom that an R user is subjected to this representation,
but it is present in the <code>nativeRaster</code> format which can be obtained from
e.g. capturing the content of a graphic device (using <code>dev.capture()</code>) or reading
in PNG files using <code>png::readPNG(native = TRUE)</code>. It is very rare that you
might need to convert back and forth between this format, but it is provided
here for completeness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_native(colour, ...)

decode_native(colour)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="native-encoding_+3A_colour">colour</code></td>
<td>
<p>For <code>encode_native</code> either a vector of hex-encoded
colours/colour names or a matrix encoding colours in any of the supported
colour spaces. If the  latter, the colours will be encoded to a hex string
using <code><a href="#topic+encode_colour">encode_colour()</a></code> first. For <code>decode_native</code> it is a vector of
integers.</p>
</td></tr>
<tr><td><code id="native-encoding_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+encode_colour">encode_colour()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>encode_native()</code> returns an integer vector and <code>decode_native()</code>
returns a character vector, both matching the length of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get native representation of navyblue and #228B22
native_col &lt;- encode_native(c('navyblue', '#228B22'))
native_col

# Convert back
decode_native(native_col)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
