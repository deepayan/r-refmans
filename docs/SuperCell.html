<!DOCTYPE html><html lang="en"><head><title>Help for package SuperCell</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SuperCell}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anndata_2_supercell'><p>Convert Anndata metacell object (Metacell-2 or SEACells) to Super-cell like object</p></a></li>
<li><a href='#build_knn_graph'><p>Build kNN graph</p></a></li>
<li><a href='#build_knn_graph_nn2'><p>Build kNN graph using RANN::nn2</p>
(used in <code>"build_knn_graph"</code>)</a></li>
<li><a href='#cell_lines'><p>Cancer cell lines dataset</p></a></li>
<li><a href='#knn_graph_from_dist'><p>Build kNN graph from distance</p>
(used in <code>"build_knn_graph"</code>)</a></li>
<li><a href='#metacell2_anndata_2_supercell'><p>Convert Metacells (Metacell-2) to Super-cell like object</p></a></li>
<li><a href='#sc_mixing_score'><p>Compute mixing of single-cells within supercell</p></a></li>
<li><a href='#SCimplify'><p>Detection of metacells with the SuperCell approach</p></a></li>
<li><a href='#SCimplify_for_velocity'><p>Construct super-cells from spliced and un-spliced matrices</p></a></li>
<li><a href='#SCimplify_from_embedding'><p>Detection of metacells with the SuperCell approach from low dim representation</p></a></li>
<li><a href='#supercell_2_sce'><p>Super-cells to SingleCellExperiment object</p></a></li>
<li><a href='#supercell_2_Seurat'><p>Super-cells to Seurat object</p></a></li>
<li><a href='#supercell_assign'><p>Assign super-cells to the most aboundant cluster</p></a></li>
<li><a href='#supercell_cluster'><p>Cluster super-cell data</p></a></li>
<li><a href='#supercell_DimPlot'><p>Plot metacell 2D plot (PCA, UMAP, tSNE etc)</p></a></li>
<li><a href='#supercell_estimate_velocity'><p>Run RNAvelocity for super-cells (slightly modified from <a href="https://github.com/velocyto-team/velocyto.R">https://github.com/velocyto-team/velocyto.R</a>)</p>
Not yet adjusted for super-cell size (not sample-weighted)</a></li>
<li><a href='#supercell_FindAllMarkers'><p>Differential expression analysis of supep-cell data. Most of the parameters are the same as in Seurat FindAllMarkers (for simplicity)</p></a></li>
<li><a href='#supercell_FindMarkers'><p>Differential expression analysis of supep-cell data. Most of the parameters are the same as in Seurat FindMarkers (for simplicity)</p></a></li>
<li><a href='#supercell_GE'><p>Simplification of scRNA-seq dataset</p></a></li>
<li><a href='#supercell_GE_idx'><p>Simplification of scRNA-seq dataset (old version, not used since 12.02.2021)</p></a></li>
<li><a href='#supercell_GeneGenePlot'><p>Gene-gene correlation plot</p></a></li>
<li><a href='#supercell_GeneGenePlot_single'><p>Plot  Gene-gene correlation plot for 1 feature</p></a></li>
<li><a href='#supercell_merge'><p>Merging independent SuperCell objects</p></a></li>
<li><a href='#supercell_mergeGE'><p>Merging metacell gene expression matrices from several independent SuperCell objects</p></a></li>
<li><a href='#supercell_plot'><p>Plot metacell NW</p></a></li>
<li><a href='#supercell_plot_GE'><p>Plot super-cell NW colored by an expression of a gene (gradient color)</p></a></li>
<li><a href='#supercell_plot_tSNE'><p>Plot super-cell tSNE</p>
(Use supercell_DimPlot instead)
Plots super-cell tSNE (result of supercell_tSNE)</a></li>
<li><a href='#supercell_plot_UMAP'><p>Plot super-cell UMAP</p>
(Use supercell_DimPlot instead)
Plots super-cell UMAP (result of supercell_UMAP)</a></li>
<li><a href='#supercell_prcomp'><p>compute PCA for super-cell data (sample-weighted data)</p></a></li>
<li><a href='#supercell_purity'><p>Compute purity of super-cells</p></a></li>
<li><a href='#supercell_rescale'><p>Rescale supercell object</p></a></li>
<li><a href='#supercell_silhouette'><p>Compute Silhouette index accounting for samlpe size (super cells size) ###</p></a></li>
<li><a href='#supercell_tSNE'><p>Compute tSNE of super-cells</p></a></li>
<li><a href='#supercell_UMAP'><p>Compute UMAP of super-cells</p></a></li>
<li><a href='#supercell_VlnPlot'><p>Violin plots</p></a></li>
<li><a href='#supercell_VlnPlot_single'><p>Plot  Violin plot for 1 feature</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simplification of scRNA-Seq Data by Merging Together Similar
Cells</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Aggregates large single-cell data into metacell dataset by merging together gene expression of very similar cells. 'SuperCell' uses 'velocyto.R' &lt;<a href="https://doi.org/10.1038%2Fs41586-018-0414-6">doi:10.1038/s41586-018-0414-6</a>&gt; <a href="https://github.com/velocyto-team/velocyto.R">https://github.com/velocyto-team/velocyto.R</a> for RNA velocity. We also recommend installing 'scater' Bioconductor package &lt;<a href="https://doi.org/10.18129%2FB9.bioc.scater">doi:10.18129/B9.bioc.scater</a>&gt; <a href="https://bioconductor.org/packages/release/bioc/html/scater.html">https://bioconductor.org/packages/release/bioc/html/scater.html</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GfellerLab/SuperCell/issues">https://github.com/GfellerLab/SuperCell/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Software</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mteleman.github.io/drat">https://mteleman.github.io/drat</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, RANN, WeightedCluster, corpcor, weights, Hmisc,
Matrix, matrixStats, plyr, irlba, grDevices, patchwork,
ggplot2, umap, entropy, Rtsne, dbscan, scales, plotfunctions,
proxy, methods, rlang,</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SingleCellExperiment, SummarizedExperiment, cowplot, scater,
Seurat, knitr, rmarkdown, remotes, bluster, velocyto.R,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-25 11:08:29 UTC; admin</td>
</tr>
<tr>
<td>Author:</td>
<td>Mariia Bilous [aut],
  Leonard Herault [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leonard Herault &lt;leonard.herault@unil.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-25 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anndata_2_supercell'>Convert Anndata metacell object (Metacell-2 or SEACells) to Super-cell like object</h2><span id='topic+anndata_2_supercell'></span>

<h3>Description</h3>

<p>Convert Anndata metacell object (Metacell-2 or SEACells) to Super-cell like object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anndata_2_supercell(adata, simplification.algo = "unknown")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anndata_2_supercell_+3A_adata">adata</code></td>
<td>
<p>anndata object of metacells
(for example, the output of <a href="https://metacells.readthedocs.io/en/latest/_modules/metacells/pipeline/collect.html#collect_metacells"><code>collect_metacells()</code></a> for Metacells
or the output of <a href="https://github.com/dpeerlab/SEACells/blob/406ebd3a7ee200788358464b345fa0c8d88fda69/SEACells/core.py#L532"><code>SEACells.core.summarize_by_SEACell</code></a>)
</p>
<p>Please, **make sure**, adata has &lsquo;uns[&rsquo;sc.obs']' field containing observation information of single-cell data, in particular,
a column 'membership' (single-cell assignemnt to metacells)</p>
</td></tr>
<tr><td><code id="anndata_2_supercell_+3A_simplification.algo">simplification.algo</code></td>
<td>
<p>metacell construction algorithm (i.e., Metacell2 or SEACells)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of super-cell like object (similar to the output of <a href="#topic+SCimplify">SCimplify</a>)
</p>

<hr>
<h2 id='build_knn_graph'>Build kNN graph</h2><span id='topic+build_knn_graph'></span>

<h3>Description</h3>

<p>Build kNN graph either from distance (from == &quot;dist&quot;) or from coordinates (from == &quot;coordinates&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_knn_graph(
  X,
  k = 5,
  from = c("dist", "coordinates"),
  use.nn2 = TRUE,
  return_neighbors_order = FALSE,
  dist_method = "euclidean",
  cor_method = "pearson",
  p = 2,
  directed = FALSE,
  DoSNN = FALSE,
  which.snn = c("bluster", "dbscan"),
  pruning = NULL,
  kmin = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_knn_graph_+3A_x">X</code></td>
<td>
<p>either distance or matrix of coordinates (rows are samples and cols are coordinates)</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_k">k</code></td>
<td>
<p>kNN parameter</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_from">from</code></td>
<td>
<p>from which data type to build kNN network: &quot;dist&quot; if X is a distance (dissimilarity) or &quot;coordinates&quot; if X is a matrix with coordinates as cols and cells as rows</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_use.nn2">use.nn2</code></td>
<td>
<p>whether use <a href="RANN.html#topic+nn2">nn2</a> method to buid kNN network faster (available only for &quot;coordinates&quot; option)</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_return_neighbors_order">return_neighbors_order</code></td>
<td>
<p>whether return order of neighbors (not available for nn2 option)</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_dist_method">dist_method</code></td>
<td>
<p>method to compute dist (if X is a matrix of coordinates) available: c(&quot;cor&quot;, &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;, &quot;minkowski&quot;)</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_cor_method">cor_method</code></td>
<td>
<p>if distance is computed as correlation (dist_method == &quot;cor), which type of correlation to use (available: &quot;pearson&quot;, &quot;kendall&quot;, &quot;spearman&quot;)</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_p">p</code></td>
<td>
<p>p param in <code>"dist"</code> function</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_directed">directed</code></td>
<td>
<p>whether to build a directed graph</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_dosnn">DoSNN</code></td>
<td>
<p>whether to apply shared nearest neighbors (default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_which.snn">which.snn</code></td>
<td>
<p>whether to use <a href="bluster.html#topic+neighborsToSNNGraph">neighborsToSNNGraph</a> or <a href="dbscan.html#topic+sNN">sNN</a> for sNN graph construction</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_pruning">pruning</code></td>
<td>
<p>quantile to perform edge pruning (default is <code>NULL</code> - no pruning applied) based on PCA distance distribution</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_kmin">kmin</code></td>
<td>
<p>keep at least <code>kmin</code> edges in single-cell graph when pruning applied (idnored if <code>is.null(pruning)</code>)</p>
</td></tr>
<tr><td><code id="build_knn_graph_+3A_...">...</code></td>
<td>
<p>other parameters of <a href="bluster.html#topic+neighborsToSNNGraph">neighborsToSNNGraph</a> or <a href="dbscan.html#topic+sNN">sNN</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p> graph.knn - igraph object
</p>
</li>
<li><p> order - Nxk matrix with indices of k nearest neighbors ordered by relevance (from 1st to k-th)
</p>
</li></ul>


<hr>
<h2 id='build_knn_graph_nn2'>Build kNN graph using RANN::nn2
(used in <code>"build_knn_graph"</code>)</h2><span id='topic+build_knn_graph_nn2'></span>

<h3>Description</h3>

<p>Build kNN graph using RANN::nn2
(used in <code>"build_knn_graph"</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_knn_graph_nn2(
  X,
  k = min(5, ncol(X)),
  mode = "all",
  DoSNN = FALSE,
  which.snn = c("bluster", "dbscan"),
  pruning = NULL,
  kmin = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_knn_graph_nn2_+3A_x">X</code></td>
<td>
<p>matrix of coordinates (rows are samples and cols are coordinates)</p>
</td></tr>
<tr><td><code id="build_knn_graph_nn2_+3A_k">k</code></td>
<td>
<p>kNN parameter</p>
</td></tr>
<tr><td><code id="build_knn_graph_nn2_+3A_mode">mode</code></td>
<td>
<p>mode of <a href="igraph.html#topic+graph_from_adj_list">graph_from_adj_list</a> ('all' &ndash; undirected graph, 'out' &ndash; directed graph)</p>
</td></tr>
<tr><td><code id="build_knn_graph_nn2_+3A_dosnn">DoSNN</code></td>
<td>
<p>whether to apply shared nearest neighbors (default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="build_knn_graph_nn2_+3A_which.snn">which.snn</code></td>
<td>
<p>whether to use <a href="bluster.html#topic+neighborsToSNNGraph">neighborsToSNNGraph</a> or <a href="dbscan.html#topic+sNN">sNN</a> for sNN graph construction</p>
</td></tr>
<tr><td><code id="build_knn_graph_nn2_+3A_pruning">pruning</code></td>
<td>
<p>quantile to perform edge pruning (default is <code>NULL</code> - no pruning applied) based on PCA distance distribution</p>
</td></tr>
<tr><td><code id="build_knn_graph_nn2_+3A_kmin">kmin</code></td>
<td>
<p>keep at least <code>kmin</code> edges in single-cell graph when pruning applied (idnored if <code>is.null(pruning)</code>)</p>
</td></tr>
<tr><td><code id="build_knn_graph_nn2_+3A_...">...</code></td>
<td>
<p>other parameters of <a href="bluster.html#topic+neighborsToSNNGraph">neighborsToSNNGraph</a> or <a href="dbscan.html#topic+sNN">sNN</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p> graph.knn - igraph object
</p>
</li></ul>


<hr>
<h2 id='cell_lines'>Cancer cell lines dataset</h2><span id='topic+cell_lines'></span>

<h3>Description</h3>

<p>ScRNA-seq data of 5 cancer cell lines from [Tian et al., 2019](https://doi.org/10.1038/s41592-019-0425-8).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_lines
</code></pre>


<h3>Format</h3>

<p>A list with gene expression (i.e., log-normalized counts) (GE), and metadata data (meta):
</p>

<dl>
<dt>GE</dt><dd><p>gene expression (log-normalized counts) matrix</p>
</dd>
<dt>meta</dt><dd><p>cells metadata (cell line annotation)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data available at authors' [GitHub](https://github.com/LuyiTian/sc_mixology/blob/master/data/) under file name *sincell_with_class_5cl.Rdata*.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1038/s41592-019-0425-8">doi:10.1038/s41592-019-0425-8</a>
</p>

<hr>
<h2 id='knn_graph_from_dist'>Build kNN graph from distance
(used in <code>"build_knn_graph"</code>)</h2><span id='topic+knn_graph_from_dist'></span>

<h3>Description</h3>

<p>Build kNN graph from distance
(used in <code>"build_knn_graph"</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn_graph_from_dist(D, k = 5, return_neighbors_order = TRUE, mode = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knn_graph_from_dist_+3A_d">D</code></td>
<td>
<p>dist matrix or dist object (preferentially)</p>
</td></tr>
<tr><td><code id="knn_graph_from_dist_+3A_k">k</code></td>
<td>
<p>kNN parameter</p>
</td></tr>
<tr><td><code id="knn_graph_from_dist_+3A_return_neighbors_order">return_neighbors_order</code></td>
<td>
<p>whether return order of neighbors (not available for nn2 option)</p>
</td></tr>
<tr><td><code id="knn_graph_from_dist_+3A_mode">mode</code></td>
<td>
<p>mode of <a href="igraph.html#topic+graph_from_adj_list">graph_from_adj_list</a> ('all' &ndash; undirected graph, 'out' &ndash; directed graph)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p> graph.knn - igraph object
</p>
</li>
<li><p> order - Nxk matrix with indices of k nearest neighbors ordered by relevance (from 1st to k-th)
</p>
</li></ul>


<hr>
<h2 id='metacell2_anndata_2_supercell'>Convert Metacells (Metacell-2) to Super-cell like object</h2><span id='topic+metacell2_anndata_2_supercell'></span>

<h3>Description</h3>

<p>Convert Metacells (Metacell-2) to Super-cell like object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metacell2_anndata_2_supercell(adata, obs.sc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metacell2_anndata_2_supercell_+3A_adata">adata</code></td>
<td>
<p>anndata object of metacells (the output of <a href="https://metacells.readthedocs.io/en/latest/_modules/metacells/pipeline/collect.html#collect_metacells"><code>collect_metacells()</code></a>)</p>
</td></tr>
<tr><td><code id="metacell2_anndata_2_supercell_+3A_obs.sc">obs.sc</code></td>
<td>
<p>a dataframe of the single-cell anndata object used to compute metacells (anndata after applying <a href="https://metacells.readthedocs.io/en/latest/_modules/metacells/pipeline/divide_and_conquer.html#divide_and_conquer_pipeline"><code>divide_and_conquer_pipeline()</code></a> function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of super-cell like object (similar to the output of <a href="#topic+SCimplify">SCimplify</a>)
</p>

<hr>
<h2 id='sc_mixing_score'>Compute mixing of single-cells within supercell</h2><span id='topic+sc_mixing_score'></span>

<h3>Description</h3>

<p>Compute mixing of single-cells within supercell
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_mixing_score(SC, clusters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sc_mixing_score_+3A_sc">SC</code></td>
<td>
<p>super-cell object (output of <a href="#topic+SCimplify">SCimplify</a> function)</p>
</td></tr>
<tr><td><code id="sc_mixing_score_+3A_clusters">clusters</code></td>
<td>
<p>vector of clustering assignment (reference assignment)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of single-cell mixing within super-cell it belongs to, which is defined as:
1 - proportion of cells of the same annotation (e.g., cell type) within the same super-cell
With 0 meaning that super-cell consists of single cells from one cluster (reference assignment) and higher values correspond to higher cell type mixing within super-cell
</p>

<hr>
<h2 id='SCimplify'>Detection of metacells with the SuperCell approach</h2><span id='topic+SCimplify'></span>

<h3>Description</h3>

<p>This function detects metacells (former super-cells) from single-cell gene expression matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCimplify(
  X,
  genes.use = NULL,
  genes.exclude = NULL,
  cell.annotation = NULL,
  cell.split.condition = NULL,
  n.var.genes = min(1000, nrow(X)),
  gamma = 10,
  k.knn = 5,
  do.scale = TRUE,
  n.pc = 10,
  fast.pca = TRUE,
  do.approx = FALSE,
  approx.N = 20000,
  block.size = 10000,
  seed = 12345,
  igraph.clustering = c("walktrap", "louvain"),
  return.singlecell.NW = TRUE,
  return.hierarchical.structure = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SCimplify_+3A_x">X</code></td>
<td>
<p>log-normalized gene expression matrix with rows to be genes and cols to be cells</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_genes.use">genes.use</code></td>
<td>
<p>a vector of genes used to compute PCA</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_genes.exclude">genes.exclude</code></td>
<td>
<p>a vector of genes to be excluded when computing PCA</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_cell.annotation">cell.annotation</code></td>
<td>
<p>a vector of cell type annotation, if provided, metacells that contain single cells of different cell type annotation will be split in multiple pure metacell (may result in slightly larger numbe of metacells than expected with a given gamma)</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_cell.split.condition">cell.split.condition</code></td>
<td>
<p>a vector of cell conditions that must not be mixed in one metacell. If provided, metacells will be split in condition-pure metacell (may result in significantly(!) larger number of metacells than expected)</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_n.var.genes">n.var.genes</code></td>
<td>
<p>if <code>"genes.use"</code> is not provided, <code>"n.var.genes"</code> genes with the largest variation are used</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_gamma">gamma</code></td>
<td>
<p>graining level of data (proportion of number of single cells in the initial dataset to the number of metacells in the final dataset)</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_k.knn">k.knn</code></td>
<td>
<p>parameter to compute single-cell kNN network</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_do.scale">do.scale</code></td>
<td>
<p>whether to scale gene expression matrix when computing PCA</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_n.pc">n.pc</code></td>
<td>
<p>number of principal components to use for construction of single-cell kNN network</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_fast.pca">fast.pca</code></td>
<td>
<p>use <a href="irlba.html#topic+irlba">irlba</a> as a faster version of prcomp (one used in Seurat package)</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_do.approx">do.approx</code></td>
<td>
<p>compute approximate kNN in case of a large dataset (&gt;50'000)</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_approx.n">approx.N</code></td>
<td>
<p>number of cells to subsample for an approximate approach</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_block.size">block.size</code></td>
<td>
<p>number of cells to map to the nearest metacell at the time (for approx coarse-graining)</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_seed">seed</code></td>
<td>
<p>seed to use to subsample cells for an approximate approach</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_igraph.clustering">igraph.clustering</code></td>
<td>
<p>clustering method to identify metacells (available methods &quot;walktrap&quot; (default) and &quot;louvain&quot; (not recommended, gamma is ignored)).</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_return.singlecell.nw">return.singlecell.NW</code></td>
<td>
<p>whether return single-cell network (which consists of approx.N if <code>"do.approx"</code> or all cells otherwise)</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_return.hierarchical.structure">return.hierarchical.structure</code></td>
<td>
<p>whether return hierarchical structure of metacell</p>
</td></tr>
<tr><td><code id="SCimplify_+3A_...">...</code></td>
<td>
<p>other parameters of <a href="#topic+build_knn_graph">build_knn_graph</a> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p> graph.supercells - igraph object of a simplified network (number of nodes corresponds to number of metacells)
</p>
</li>
<li><p> membership - assigmnent of each single cell to a particular metacell
</p>
</li>
<li><p> graph.singlecells - igraph object (kNN network) of single-cell data
</p>
</li>
<li><p> supercell_size - size of metacells (former super-cells)
</p>
</li>
<li><p> gamma - requested graining level
</p>
</li>
<li><p> N.SC - number of obtained metacells
</p>
</li>
<li><p> genes.use - used genes
</p>
</li>
<li><p> do.approx - whether approximate coarse-graining was perfirmed
</p>
</li>
<li><p> n.pc - number of principal components used for metacells construction
</p>
</li>
<li><p> k.knn - number of neighbors to build single-cell graph
</p>
</li>
<li><p> sc.cell.annotation. - single-cell cell type annotation (if provided)
</p>
</li>
<li><p> sc.cell.split.condition. - single-cell split condition (if provided)
</p>
</li>
<li><p> SC.cell.annotation. - super-cell cell type annotation (if was provided for single cells)
</p>
</li>
<li><p> SC.cell.split.condition. - super-cell split condition (if was provided for single cells)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(cell_lines) # list with GE - gene expression matrix (logcounts), meta - cell meta data
GE &lt;- cell_lines$GE

SC &lt;- SCimplify(GE,  # log-normalized gene expression matrix
                gamma = 20, # graining level
                n.var.genes = 1000,
                k.knn = 5, # k for kNN algorithm
                n.pc = 10, # number of principal components to use
                do.approx = TRUE) #


</code></pre>

<hr>
<h2 id='SCimplify_for_velocity'>Construct super-cells from spliced and un-spliced matrices</h2><span id='topic+SCimplify_for_velocity'></span>

<h3>Description</h3>

<p>Construct super-cells from spliced and un-spliced matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCimplify_for_velocity(emat, nmat, gamma = NULL, membership = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SCimplify_for_velocity_+3A_emat">emat</code></td>
<td>
<p>spliced (exonic) count matrix</p>
</td></tr>
<tr><td><code id="SCimplify_for_velocity_+3A_nmat">nmat</code></td>
<td>
<p>unspliced (nascent) count matrix</p>
</td></tr>
<tr><td><code id="SCimplify_for_velocity_+3A_gamma">gamma</code></td>
<td>
<p>graining level of data (proportion of number of single cells in the initial dataset to the number of super-cells in the final dataset)</p>
</td></tr>
<tr><td><code id="SCimplify_for_velocity_+3A_membership">membership</code></td>
<td>
<p>metacell membership vector (if provided, will be used for <code>emat</code>, <code>nmat</code> metacell matrices averaging)</p>
</td></tr>
<tr><td><code id="SCimplify_for_velocity_+3A_...">...</code></td>
<td>
<p>other parameters from <a href="#topic+SCimplify">SCimplify</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing vector of membership, spliced count and un-spliced count matrices
</p>

<hr>
<h2 id='SCimplify_from_embedding'>Detection of metacells with the SuperCell approach from low dim representation</h2><span id='topic+SCimplify_from_embedding'></span>

<h3>Description</h3>

<p>This function detects metacells (former super-cells) from single-cell gene expression matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCimplify_from_embedding(
  X,
  cell.annotation = NULL,
  cell.split.condition = NULL,
  gamma = 10,
  k.knn = 5,
  n.pc = 10,
  do.approx = FALSE,
  approx.N = 20000,
  block.size = 10000,
  seed = 12345,
  igraph.clustering = c("walktrap", "louvain"),
  return.singlecell.NW = TRUE,
  return.hierarchical.structure = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SCimplify_from_embedding_+3A_x">X</code></td>
<td>
<p>low dimensional embedding matrix with rows to be cells and cols to be low-dim components</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_cell.annotation">cell.annotation</code></td>
<td>
<p>a vector of cell type annotation, if provided, metacells that contain single cells of different cell type annotation will be split in multiple pure metacell (may result in slightly larger numbe of metacells than expected with a given gamma)</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_cell.split.condition">cell.split.condition</code></td>
<td>
<p>a vector of cell conditions that must not be mixed in one metacell. If provided, metacells will be split in condition-pure metacell (may result in significantly(!) larger number of metacells than expected)</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_gamma">gamma</code></td>
<td>
<p>graining level of data (proportion of number of single cells in the initial dataset to the number of metacells in the final dataset)</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_k.knn">k.knn</code></td>
<td>
<p>parameter to compute single-cell kNN network</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_n.pc">n.pc</code></td>
<td>
<p>number of principal components to use for construction of single-cell kNN network</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_do.approx">do.approx</code></td>
<td>
<p>compute approximate kNN in case of a large dataset (&gt;50'000)</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_approx.n">approx.N</code></td>
<td>
<p>number of cells to subsample for an approximate approach</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_block.size">block.size</code></td>
<td>
<p>number of cells to map to the nearest metacell at the time (for approx coarse-graining)</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_seed">seed</code></td>
<td>
<p>seed to use to subsample cells for an approximate approach</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_igraph.clustering">igraph.clustering</code></td>
<td>
<p>clustering method to identify metacells (available methods &quot;walktrap&quot; (default) and &quot;louvain&quot; (not recommended, gamma is ignored)).</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_return.singlecell.nw">return.singlecell.NW</code></td>
<td>
<p>whether return single-cell network (which consists of approx.N if <code>"do.approx"</code> or all cells otherwise)</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_return.hierarchical.structure">return.hierarchical.structure</code></td>
<td>
<p>whether return hierarchical structure of metacell</p>
</td></tr>
<tr><td><code id="SCimplify_from_embedding_+3A_...">...</code></td>
<td>
<p>other parameters of <a href="#topic+build_knn_graph">build_knn_graph</a> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p> graph.supercells - igraph object of a simplified network (number of nodes corresponds to number of metacells)
</p>
</li>
<li><p> membership - assigmnent of each single cell to a particular metacell
</p>
</li>
<li><p> graph.singlecells - igraph object (kNN network) of single-cell data
</p>
</li>
<li><p> supercell_size - size of metacells (former super-cells)
</p>
</li>
<li><p> gamma - requested graining level
</p>
</li>
<li><p> N.SC - number of obtained metacells
</p>
</li>
<li><p> genes.use - used genes (NA due to low-dim representation)
</p>
</li>
<li><p> do.approx - whether approximate coarse-graining was perfirmed
</p>
</li>
<li><p> n.pc - number of principal components used for metacells construction
</p>
</li>
<li><p> k.knn - number of neighbors to build single-cell graph
</p>
</li>
<li><p> sc.cell.annotation. - single-cell cell type annotation (if provided)
</p>
</li>
<li><p> sc.cell.split.condition. - single-cell split condition (if provided)
</p>
</li>
<li><p> SC.cell.annotation. - super-cell cell type annotation (if was provided for single cells)
</p>
</li>
<li><p> SC.cell.split.condition. - super-cell split condition (if was provided for single cells)
</p>
</li></ul>


<hr>
<h2 id='supercell_2_sce'>Super-cells to SingleCellExperiment object</h2><span id='topic+supercell_2_sce'></span>

<h3>Description</h3>

<p>This function transforms super-cell gene expression and super-cell partition into <a href="SingleCellExperiment.html#topic+SingleCellExperiment">SingleCellExperiment</a> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_2_sce(
  SC.GE,
  SC,
  fields = c(),
  var.genes = NULL,
  do.preproc = TRUE,
  is.log.normalized = TRUE,
  do.center = TRUE,
  do.scale = TRUE,
  ncomponents = 50
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_2_sce_+3A_sc.ge">SC.GE</code></td>
<td>
<p>gene expression matrix with genes as rows and cells as columns</p>
</td></tr>
<tr><td><code id="supercell_2_sce_+3A_sc">SC</code></td>
<td>
<p>super-cell (output of <a href="#topic+SCimplify">SCimplify</a> function)</p>
</td></tr>
<tr><td><code id="supercell_2_sce_+3A_fields">fields</code></td>
<td>
<p>which fields of <code>SC</code> to use as cell metadata</p>
</td></tr>
<tr><td><code id="supercell_2_sce_+3A_var.genes">var.genes</code></td>
<td>
<p>set of genes used as a set of variable features of SingleCellExperiment (by default is the set of genes used to generate super-cells)</p>
</td></tr>
<tr><td><code id="supercell_2_sce_+3A_do.preproc">do.preproc</code></td>
<td>
<p>whether to do prepocessing, including data normalization, scaling, HVG, PCA, nearest neighbors, <code>TRUE</code> by default, change to <code>FALSE</code> to speed up conversion</p>
</td></tr>
<tr><td><code id="supercell_2_sce_+3A_is.log.normalized">is.log.normalized</code></td>
<td>
<p>whether <code>SC.GE</code> is log-normalized counts. If yes, then SingleCellExperiment field <code>assay name = 'logcounts'</code> else <code>assay name = 'counts'</code></p>
</td></tr>
<tr><td><code id="supercell_2_sce_+3A_do.center">do.center</code></td>
<td>
<p>whether to center gene expression matrix to compute PCA</p>
</td></tr>
<tr><td><code id="supercell_2_sce_+3A_do.scale">do.scale</code></td>
<td>
<p>whether to scale gene expression matrix to compute PCA</p>
</td></tr>
<tr><td><code id="supercell_2_sce_+3A_ncomponents">ncomponents</code></td>
<td>
<p>number of principal components to compute</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="SingleCellExperiment.html#topic+SingleCellExperiment">SingleCellExperiment</a> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cell_lines)
SC           &lt;- SCimplify(cell_lines$GE, gamma = 20)
SC$ident     &lt;- supercell_assign(clusters = cell_lines$meta, supercell_membership = SC$membership)
SC.GE        &lt;- supercell_GE(cell_lines$GE, SC$membership)
sce          &lt;- supercell_2_sce(SC.GE = SC.GE, SC = SC, fields = c("ident"))

</code></pre>

<hr>
<h2 id='supercell_2_Seurat'>Super-cells to Seurat object</h2><span id='topic+supercell_2_Seurat'></span>

<h3>Description</h3>

<p>This function transforms super-cell gene expression and super-cell partition into <a href="Seurat.html#topic+Seurat">Seurat</a> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_2_Seurat(
  SC.GE,
  SC,
  fields = c(),
  var.genes = NULL,
  do.preproc = TRUE,
  is.log.normalized = TRUE,
  do.center = TRUE,
  do.scale = TRUE,
  N.comp = NULL,
  output.assay.version = "v4"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_2_Seurat_+3A_sc.ge">SC.GE</code></td>
<td>
<p>gene expression matrix with genes as rows and cells as columns</p>
</td></tr>
<tr><td><code id="supercell_2_Seurat_+3A_sc">SC</code></td>
<td>
<p>super-cell (output of <a href="#topic+SCimplify">SCimplify</a> function)</p>
</td></tr>
<tr><td><code id="supercell_2_Seurat_+3A_fields">fields</code></td>
<td>
<p>which fields of <code>SC</code> to use as cell metadata</p>
</td></tr>
<tr><td><code id="supercell_2_Seurat_+3A_var.genes">var.genes</code></td>
<td>
<p>set of genes used as a set of variable features of Seurat (by default is the set of genes used to generate super-cells), ignored if <code>!do.preproc</code></p>
</td></tr>
<tr><td><code id="supercell_2_Seurat_+3A_do.preproc">do.preproc</code></td>
<td>
<p>whether to do prepocessing, including data normalization, scaling, HVG, PCA, nearest neighbors, <code>TRUE</code> by default, change to <code>FALSE</code> to speed up conversion</p>
</td></tr>
<tr><td><code id="supercell_2_Seurat_+3A_is.log.normalized">is.log.normalized</code></td>
<td>
<p>whether <code>SC.GE</code> is log-normalized counts. If yes, then Seurat field <code>data</code> is replaced with <code>counts</code> after normalization (see 'Details' section), ignored if <code>!do.preproc</code></p>
</td></tr>
<tr><td><code id="supercell_2_Seurat_+3A_do.center">do.center</code></td>
<td>
<p>whether to center gene expression matrix to compute PCA, ignored if <code>!do.preproc</code></p>
</td></tr>
<tr><td><code id="supercell_2_Seurat_+3A_do.scale">do.scale</code></td>
<td>
<p>whether to scale gene expression matrix to compute PCA, ignored if <code>!do.preproc</code></p>
</td></tr>
<tr><td><code id="supercell_2_Seurat_+3A_n.comp">N.comp</code></td>
<td>
<p>number of principal components to use for construction of single-cell kNN network, ignored if <code>!do.preproc</code></p>
</td></tr>
<tr><td><code id="supercell_2_Seurat_+3A_output.assay.version">output.assay.version</code></td>
<td>
<p>version of the seurat assay in output, <code>`"v4"`</code> by default, <code>`"v5"`</code> requires <a href="Seurat.html#topic+Seurat">Seurat</a> v5 installed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the input of <a href="Seurat.html#topic+CreateSeuratObject">CreateSeuratObject</a> should be unnormalized count matrix (UMIs or TPMs, see <a href="Seurat.html#topic+CreateSeuratObject">CreateSeuratObject</a>).
Thus, we manually set field <code>`assays$RNA@data`</code> to <code>SC.GE</code> if <code>is.log.normalized == TRUE</code>.
Avoid running <a href="Seurat.html#topic+NormalizeData">NormalizeData</a> for the obtained Seurat object, otherwise this will overwrite field <code>`assays$RNA@data`</code>.
If you have run <a href="Seurat.html#topic+NormalizeData">NormalizeData</a>, then make sure to replace <code>`assays$RNA@data`</code> with correct matrix by running
<code>`your_seurat@assays$RNA@data &lt;- your_seurat@assays$RNA@counts`</code>.
</p>
<p>Since super-cells have different size (consist of different number of single cells), we use sample-weighted algorithms for all
possible steps of the downstream analysis, including scaling and dimensionality reduction. Thus, generated Seurat object  comes
with the results of sample-wighted scaling (available as <code>`your_seurat@assays$RNA@scale.data`</code> or
<code>`your_seurat@assays$RNA@misc[["scale.data.weighted"]]`</code> to reproduce if the first one has been overwritten) and PCA (available as
<code>`your_seurat@reductions$pca`</code> or <code>`your_seurat@reductions$pca_weighted`</code> to reproduce if the first one has been overwritten).
</p>


<h3>Value</h3>

<p><a href="Seurat.html#topic+Seurat">Seurat</a> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cell_lines)
SC           &lt;- SCimplify(X=cell_lines$GE, gamma = 20)
SC$ident     &lt;- supercell_assign(clusters = cell_lines$meta, supercell_membership = SC$membership)
SC.GE        &lt;- supercell_GE(cell_lines$GE, SC$membership)
m.seurat     &lt;- supercell_2_Seurat(SC.GE = SC.GE, SC = SC, fields = c("ident"))

</code></pre>

<hr>
<h2 id='supercell_assign'>Assign super-cells to the most aboundant cluster</h2><span id='topic+supercell_assign'></span>

<h3>Description</h3>

<p>Assign super-cells to the most aboundant cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_assign(
  clusters,
  supercell_membership,
  method = c("jaccard", "relative", "absolute")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_assign_+3A_clusters">clusters</code></td>
<td>
<p>a vector of clustering assignment</p>
</td></tr>
<tr><td><code id="supercell_assign_+3A_supercell_membership">supercell_membership</code></td>
<td>
<p>a vector of assignment of single-cell data to super-cells (membership field of <a href="#topic+SCimplify">SCimplify</a> function output)</p>
</td></tr>
<tr><td><code id="supercell_assign_+3A_method">method</code></td>
<td>
<p>method to define the most abuldant cell cluster within super-cells. Available: &quot;jaccard&quot; (default), &quot;relative&quot;, &quot;absolute&quot;.
</p>

<ul>
<li><p> jaccard - assignes super-cell to cluster with the maximum jaccard coefficient (recommended)
</p>
</li>
<li><p> relative - assignes super-cell to cluster with the maximum relative abundance (normalized by cluster size), may result in assignment of super-cells to poorly represented (small) cluser due to normalizetaion
</p>
</li>
<li><p> absolute - assignes super-cell to cluster with the maximum absolute abundance within super-cell, may result in disappearence of poorly represented (small) clusters
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of super-cell assignment to clusters
</p>

<hr>
<h2 id='supercell_cluster'>Cluster super-cell data</h2><span id='topic+supercell_cluster'></span>

<h3>Description</h3>

<p>Cluster super-cell data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_cluster(
  D,
  k = 5,
  supercell_size = NULL,
  algorithm = c("hclust", "PAM"),
  method = NULL,
  return.hcl = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_cluster_+3A_d">D</code></td>
<td>
<p>a dissimilarity matrix or a dist object</p>
</td></tr>
<tr><td><code id="supercell_cluster_+3A_k">k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="supercell_cluster_+3A_supercell_size">supercell_size</code></td>
<td>
<p>a vector with supercell size (ordered the same way as in D)</p>
</td></tr>
<tr><td><code id="supercell_cluster_+3A_algorithm">algorithm</code></td>
<td>
<p>which algorithm to use to compute clustering: <code>"hclust"</code> (default) or <code>"PAM"</code> (see <a href="WeightedCluster.html#topic+wcKMedoids">wcKMedoids</a>)</p>
</td></tr>
<tr><td><code id="supercell_cluster_+3A_method">method</code></td>
<td>
<p>which method of algorithm to use: </p>

<ul>
<li><p> for <code>"hclust"</code>: &quot;ward.D&quot;, &quot;ward.D2&quot; (default), &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot; or &quot;centroid&quot;, (see <a href="stats.html#topic+hclust">hclust</a>)
</p>
</li>
<li><p> for <code>"PAM"</code>: &quot;KMedoids&quot;, &quot;PAM&quot; or &quot;PAMonce&quot; (default), (see <a href="WeightedCluster.html#topic+wcKMedoids">wcKMedoids</a>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="supercell_cluster_+3A_return.hcl">return.hcl</code></td>
<td>
<p>whether to return a result of <code>"hclust"</code> (only for <code>"hclust"</code> algorithm)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p> clustering - vector of clustering assignment of super-cells
</p>
</li>
<li><p> algo - the algorithm used
</p>
</li>
<li><p> method - method used with an algorithm
</p>
</li>
<li><p> hlc - <a href="stats.html#topic+hclust">hclust</a> result (only for <code>"hclust"</code> algorithm when <code>return.hcl</code> is TRUE)
</p>
</li></ul>


<hr>
<h2 id='supercell_DimPlot'>Plot metacell 2D plot (PCA, UMAP, tSNE etc)</h2><span id='topic+supercell_DimPlot'></span>

<h3>Description</h3>

<p>Plots 2d representation of metacells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_DimPlot(
  SC,
  groups = NULL,
  dim.name = "PCA",
  dim.1 = 1,
  dim.2 = 2,
  color.use = NULL,
  asp = 1,
  alpha = 0.7,
  title = NULL,
  do.sqtr.rescale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_DimPlot_+3A_sc">SC</code></td>
<td>
<p>SuperCell computed metacell object (the output of <a href="#topic+SCimplify">SCimplify</a>)</p>
</td></tr>
<tr><td><code id="supercell_DimPlot_+3A_groups">groups</code></td>
<td>
<p>an assigment of metacells to any group (for ploting in different colors)</p>
</td></tr>
<tr><td><code id="supercell_DimPlot_+3A_dim.name">dim.name</code></td>
<td>
<p>name of the dimensionality reduction to plot (must be a field in <code>SC</code>)</p>
</td></tr>
<tr><td><code id="supercell_DimPlot_+3A_dim.1">dim.1</code></td>
<td>
<p>dimension to plot on X-axis</p>
</td></tr>
<tr><td><code id="supercell_DimPlot_+3A_dim.2">dim.2</code></td>
<td>
<p>dimension to plot on Y-axis</p>
</td></tr>
<tr><td><code id="supercell_DimPlot_+3A_color.use">color.use</code></td>
<td>
<p>colros to use for groups, if <code>NULL</code>, an automatic palette of colors will be applied</p>
</td></tr>
<tr><td><code id="supercell_DimPlot_+3A_asp">asp</code></td>
<td>
<p>aspect ratio</p>
</td></tr>
<tr><td><code id="supercell_DimPlot_+3A_alpha">alpha</code></td>
<td>
<p>a rotation of the layout (either provided or computed)</p>
</td></tr>
<tr><td><code id="supercell_DimPlot_+3A_title">title</code></td>
<td>
<p>a title of a plot</p>
</td></tr>
<tr><td><code id="supercell_DimPlot_+3A_do.sqtr.rescale">do.sqtr.rescale</code></td>
<td>
<p>whether to sqrt-scale node size (to balance plot if some metacells are large and covers smaller metacells)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="ggplot2.html#topic+ggplot">ggplot</a>
</p>

<hr>
<h2 id='supercell_estimate_velocity'>Run RNAvelocity for super-cells (slightly modified from <a href="https://github.com/velocyto-team/velocyto.R">https://github.com/velocyto-team/velocyto.R</a>)
Not yet adjusted for super-cell size (not sample-weighted)</h2><span id='topic+supercell_estimate_velocity'></span>

<h3>Description</h3>

<p>Run RNAvelocity for super-cells (slightly modified from <a href="https://github.com/velocyto-team/velocyto.R">https://github.com/velocyto-team/velocyto.R</a>)
Not yet adjusted for super-cell size (not sample-weighted)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_estimate_velocity(
  emat,
  nmat,
  smat = NULL,
  membership = NULL,
  supercell_size = NULL,
  do.run.avegaring = (ncol(emat) == length(membership)),
  kCells = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_estimate_velocity_+3A_emat">emat</code></td>
<td>
<p>spliced (exonic) count matrix (see <a href="https://github.com/velocyto-team/velocyto.R">https://github.com/velocyto-team/velocyto.R</a>)</p>
</td></tr>
<tr><td><code id="supercell_estimate_velocity_+3A_nmat">nmat</code></td>
<td>
<p>unspliced (nascent) count matrix (<a href="https://github.com/velocyto-team/velocyto.R">https://github.com/velocyto-team/velocyto.R</a>)</p>
</td></tr>
<tr><td><code id="supercell_estimate_velocity_+3A_smat">smat</code></td>
<td>
<p>optional spanning read matrix (used in offset calculations) (<a href="https://github.com/velocyto-team/velocyto.R">https://github.com/velocyto-team/velocyto.R</a>)</p>
</td></tr>
<tr><td><code id="supercell_estimate_velocity_+3A_membership">membership</code></td>
<td>
<p>supercell membership ('membership' field of <a href="#topic+SCimplify">SCimplify</a>)</p>
</td></tr>
<tr><td><code id="supercell_estimate_velocity_+3A_supercell_size">supercell_size</code></td>
<td>
<p>a vector with supercell size (if emat and nmat provided at super-cell level)</p>
</td></tr>
<tr><td><code id="supercell_estimate_velocity_+3A_do.run.avegaring">do.run.avegaring</code></td>
<td>
<p>whether to run averaging of emat &amp; nmat (if nmat provided at a single-cell level)</p>
</td></tr>
<tr><td><code id="supercell_estimate_velocity_+3A_kcells">kCells</code></td>
<td>
<p>number of k nearest neighbors (NN) to use in slope calculation smoothing (see <a href="https://github.com/velocyto-team/velocyto.R">https://github.com/velocyto-team/velocyto.R</a>)</p>
</td></tr>
<tr><td><code id="supercell_estimate_velocity_+3A_...">...</code></td>
<td>
<p>other parameters from <a href="https://github.com/velocyto-team/velocyto.R">https://github.com/velocyto-team/velocyto.R</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>results of <a href="https://github.com/velocyto-team/velocyto.R">https://github.com/velocyto-team/velocyto.R</a> plus metacell size vector
</p>

<hr>
<h2 id='supercell_FindAllMarkers'>Differential expression analysis of supep-cell data. Most of the parameters are the same as in Seurat <a href="Seurat.html#topic+FindAllMarkers">FindAllMarkers</a> (for simplicity)</h2><span id='topic+supercell_FindAllMarkers'></span>

<h3>Description</h3>

<p>Differential expression analysis of supep-cell data. Most of the parameters are the same as in Seurat <a href="Seurat.html#topic+FindAllMarkers">FindAllMarkers</a> (for simplicity)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_FindAllMarkers(
  ge,
  clusters,
  supercell_size = NULL,
  genes.use = NULL,
  logfc.threshold = 0.25,
  min.expr = 0,
  min.pct = 0.1,
  seed = 12345,
  only.pos = FALSE,
  return.extra.info = FALSE,
  do.bootstrapping = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_FindAllMarkers_+3A_ge">ge</code></td>
<td>
<p>gene expression matrix for super-cells (rows - genes, cols - super-cells)</p>
</td></tr>
<tr><td><code id="supercell_FindAllMarkers_+3A_clusters">clusters</code></td>
<td>
<p>a vector with clustering information (ordered the same way as in <code>ge</code>)</p>
</td></tr>
<tr><td><code id="supercell_FindAllMarkers_+3A_supercell_size">supercell_size</code></td>
<td>
<p>a vector with supercell size (ordered the same way as in <code>ge</code>)</p>
</td></tr>
<tr><td><code id="supercell_FindAllMarkers_+3A_genes.use">genes.use</code></td>
<td>
<p>set of genes to test. Defeult &ndash; all genes in <code>ge</code></p>
</td></tr>
<tr><td><code id="supercell_FindAllMarkers_+3A_logfc.threshold">logfc.threshold</code></td>
<td>
<p>log fold change threshold for genes to be considered in the further analysis</p>
</td></tr>
<tr><td><code id="supercell_FindAllMarkers_+3A_min.expr">min.expr</code></td>
<td>
<p>minimal expression (default 0)</p>
</td></tr>
<tr><td><code id="supercell_FindAllMarkers_+3A_min.pct">min.pct</code></td>
<td>
<p>remove genes with lower percentage of detection from the set of genes which will be tested</p>
</td></tr>
<tr><td><code id="supercell_FindAllMarkers_+3A_seed">seed</code></td>
<td>
<p>random seed to use</p>
</td></tr>
<tr><td><code id="supercell_FindAllMarkers_+3A_only.pos">only.pos</code></td>
<td>
<p>whether to compute only positive (upregulated) markers</p>
</td></tr>
<tr><td><code id="supercell_FindAllMarkers_+3A_return.extra.info">return.extra.info</code></td>
<td>
<p>whether to return extra information about test and its statistics. Default is FALSE.</p>
</td></tr>
<tr><td><code id="supercell_FindAllMarkers_+3A_do.bootstrapping">do.bootstrapping</code></td>
<td>
<p>whether to perform bootstrapping when computing standard error and p-value in <a href="weights.html#topic+wtd.t.test">wtd.t.test</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of results of <a href="#topic+supercell_FindMarkers">supercell_FindMarkers</a>
</p>

<hr>
<h2 id='supercell_FindMarkers'>Differential expression analysis of supep-cell data. Most of the parameters are the same as in Seurat <a href="Seurat.html#topic+FindMarkers">FindMarkers</a> (for simplicity)</h2><span id='topic+supercell_FindMarkers'></span>

<h3>Description</h3>

<p>Differential expression analysis of supep-cell data. Most of the parameters are the same as in Seurat <a href="Seurat.html#topic+FindMarkers">FindMarkers</a> (for simplicity)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_FindMarkers(
  ge,
  supercell_size = NULL,
  clusters,
  ident.1,
  ident.2 = NULL,
  genes.use = NULL,
  logfc.threshold = 0.25,
  min.expr = 0,
  min.pct = 0.1,
  seed = 12345,
  only.pos = FALSE,
  return.extra.info = FALSE,
  do.bootstrapping = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_FindMarkers_+3A_ge">ge</code></td>
<td>
<p>gene expression matrix for super-cells (rows - genes, cols - super-cells)</p>
</td></tr>
<tr><td><code id="supercell_FindMarkers_+3A_supercell_size">supercell_size</code></td>
<td>
<p>a vector with supercell size (ordered the same way as in <code>ge</code>)</p>
</td></tr>
<tr><td><code id="supercell_FindMarkers_+3A_clusters">clusters</code></td>
<td>
<p>a vector with clustering information (ordered the same way as in <code>ge</code>)</p>
</td></tr>
<tr><td><code id="supercell_FindMarkers_+3A_ident.1">ident.1</code></td>
<td>
<p>name(s) of cluster for which markers are computed</p>
</td></tr>
<tr><td><code id="supercell_FindMarkers_+3A_ident.2">ident.2</code></td>
<td>
<p>name(s) of clusters for comparison. If <code>NULL</code> (defauld), then all the other clusters used</p>
</td></tr>
<tr><td><code id="supercell_FindMarkers_+3A_genes.use">genes.use</code></td>
<td>
<p>set of genes to test. Defeult &ndash; all genes in <code>ge</code></p>
</td></tr>
<tr><td><code id="supercell_FindMarkers_+3A_logfc.threshold">logfc.threshold</code></td>
<td>
<p>log fold change threshold for genes to be considered in the further analysis</p>
</td></tr>
<tr><td><code id="supercell_FindMarkers_+3A_min.expr">min.expr</code></td>
<td>
<p>minimal expression (default 0)</p>
</td></tr>
<tr><td><code id="supercell_FindMarkers_+3A_min.pct">min.pct</code></td>
<td>
<p>remove genes with lower percentage of detection from the set of genes which will be tested</p>
</td></tr>
<tr><td><code id="supercell_FindMarkers_+3A_seed">seed</code></td>
<td>
<p>random seed to use</p>
</td></tr>
<tr><td><code id="supercell_FindMarkers_+3A_only.pos">only.pos</code></td>
<td>
<p>whether to compute only positive (upregulated) markers</p>
</td></tr>
<tr><td><code id="supercell_FindMarkers_+3A_return.extra.info">return.extra.info</code></td>
<td>
<p>whether to return extra information about test and its statistics. Default is FALSE.</p>
</td></tr>
<tr><td><code id="supercell_FindMarkers_+3A_do.bootstrapping">do.bootstrapping</code></td>
<td>
<p>whether to perform bootstrapping when computing standard error and p-value in <a href="weights.html#topic+wtd.t.test">wtd.t.test</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with a test name (t-test), statisctics, adjusted p-values, logFC, percenrage of detection in eacg ident and mean expresiion
</p>

<hr>
<h2 id='supercell_GE'>Simplification of scRNA-seq dataset</h2><span id='topic+supercell_GE'></span>

<h3>Description</h3>

<p>This function converts (i.e., averages or sums up) gene-expression matrix of single-cell data into a gene expression
matrix of metacells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_GE(
  ge,
  groups,
  mode = c("average", "sum"),
  weights = NULL,
  do.median.norm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_GE_+3A_ge">ge</code></td>
<td>
<p>gene expression matrix (or any coordinate matrix) with genes as rows and cells as cols</p>
</td></tr>
<tr><td><code id="supercell_GE_+3A_groups">groups</code></td>
<td>
<p>vector of membership (assignment of single-cell to metacells)</p>
</td></tr>
<tr><td><code id="supercell_GE_+3A_mode">mode</code></td>
<td>
<p>string indicating whether to average or sum up 'ge' within metacells</p>
</td></tr>
<tr><td><code id="supercell_GE_+3A_weights">weights</code></td>
<td>
<p>vector of a cell weight (NULL by default), used for computing average gene expression withing cluster of metaells</p>
</td></tr>
<tr><td><code id="supercell_GE_+3A_do.median.norm">do.median.norm</code></td>
<td>
<p>whether to normalize by median value (FALSE by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of simplified (averaged withing groups) data with ncol equal to number of groups and nrows as in the initial dataset
</p>

<hr>
<h2 id='supercell_GE_idx'>Simplification of scRNA-seq dataset (old version, not used since 12.02.2021)</h2><span id='topic+supercell_GE_idx'></span>

<h3>Description</h3>

<p>This function converts gene-expression matrix of single-cell data into a gene expression
matrix of super-cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_GE_idx(ge, groups, weights = NULL, do.median.norm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_GE_idx_+3A_ge">ge</code></td>
<td>
<p>gene expression matrix (or any coordinate matrix) with genes as rows and cells as cols</p>
</td></tr>
<tr><td><code id="supercell_GE_idx_+3A_groups">groups</code></td>
<td>
<p>vector of membership (assignment of single-cell to super-cells)</p>
</td></tr>
<tr><td><code id="supercell_GE_idx_+3A_weights">weights</code></td>
<td>
<p>vector of a cell weight (NULL by default), used for computing average gene expression withing cluster of super-cells</p>
</td></tr>
<tr><td><code id="supercell_GE_idx_+3A_do.median.norm">do.median.norm</code></td>
<td>
<p>whether to normalize by median value (FALSE by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of simplified (averaged withing groups) data with ncol equal to number of groups and nrows as in the initial dataset
</p>

<hr>
<h2 id='supercell_GeneGenePlot'>Gene-gene correlation plot</h2><span id='topic+supercell_GeneGenePlot'></span>

<h3>Description</h3>

<p>Plots gene-gene expression and computes their correaltion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_GeneGenePlot(
  ge,
  gene_x,
  gene_y,
  supercell_size = NULL,
  clusters = NULL,
  color.use = NULL,
  idents = NULL,
  pt.size = 1,
  alpha = 0.9,
  x.max = NULL,
  y.max = NULL,
  same.x.lims = FALSE,
  same.y.lims = FALSE,
  ncol = NULL,
  combine = TRUE,
  sort.by.corr = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_GeneGenePlot_+3A_ge">ge</code></td>
<td>
<p>a gene expression matrix of super-cells (ncol same as number of super-cells)</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_gene_x">gene_x</code></td>
<td>
<p>gene or vector of genes (if vector, has to be the same lenght as gene_y)</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_gene_y">gene_y</code></td>
<td>
<p>gene or vector of genes (if vector, has to be the same lenght as gene_x)</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_supercell_size">supercell_size</code></td>
<td>
<p>a vector with supercell size (ordered the same way as in <code>ge</code>)</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_clusters">clusters</code></td>
<td>
<p>a vector with clustering information (ordered the same way as in <code>ge</code>)</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_color.use">color.use</code></td>
<td>
<p>colors for idents</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_idents">idents</code></td>
<td>
<p>idents (clusters) to plot (default all)</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_pt.size">pt.size</code></td>
<td>
<p>point size (if supercells have identical sizes)</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_alpha">alpha</code></td>
<td>
<p>transparency</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_x.max">x.max</code></td>
<td>
<p>max of x axis</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_y.max">y.max</code></td>
<td>
<p>max of y axis</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_same.x.lims">same.x.lims</code></td>
<td>
<p>same x axis for all plots</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_same.y.lims">same.y.lims</code></td>
<td>
<p>same y axis for all plots</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_ncol">ncol</code></td>
<td>
<p>number of colums in combined plot</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_combine">combine</code></td>
<td>
<p>combine plots into a single <a href="patchwork.html#topic+patchwork">patchwork</a>ed ggplot object. If FALSE, return a list of ggplot</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_+3A_sort.by.corr">sort.by.corr</code></td>
<td>
<p>whether to sort plots by absolute value of correlation (fist plot genes with largest (anti-)correlation)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p> p - is a combined ggplot or list of ggplots if <code>combine = TRUE</code>
</p>
</li>
<li><p> w.cor - weighted correlation between genes
</p>
</li></ul>

<p>a list, where
</p>

<hr>
<h2 id='supercell_GeneGenePlot_single'>Plot  Gene-gene correlation plot for 1 feature</h2><span id='topic+supercell_GeneGenePlot_single'></span>

<h3>Description</h3>

<p>Used for <a href="#topic+supercell_GeneGenePlot">supercell_GeneGenePlot</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_GeneGenePlot_single(
  ge_x,
  ge_y,
  gene_x_name,
  gene_y_name,
  supercell_size = NULL,
  clusters = NULL,
  color.use = NULL,
  x.max = NULL,
  y.max = NULL,
  pt.size = 1,
  alpha = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_GeneGenePlot_single_+3A_ge_x">ge_x</code></td>
<td>
<p>first gene expression vector (same length as number of super-cells)</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_single_+3A_ge_y">ge_y</code></td>
<td>
<p>second gene expression vector (same length as number of super-cells)</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_single_+3A_gene_x_name">gene_x_name</code></td>
<td>
<p>name of gene x</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_single_+3A_gene_y_name">gene_y_name</code></td>
<td>
<p>name of gene y</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_single_+3A_supercell_size">supercell_size</code></td>
<td>
<p>a vector with supercell size (ordered the same way as in <code>ge</code>)</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_single_+3A_clusters">clusters</code></td>
<td>
<p>a vector with clustering information (ordered the same way as in <code>ge</code>)</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_single_+3A_color.use">color.use</code></td>
<td>
<p>colors for idents</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_single_+3A_x.max">x.max</code></td>
<td>
<p>max of x axis</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_single_+3A_y.max">y.max</code></td>
<td>
<p>max of y axis</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_single_+3A_pt.size">pt.size</code></td>
<td>
<p>point size (0 by default)</p>
</td></tr>
<tr><td><code id="supercell_GeneGenePlot_single_+3A_alpha">alpha</code></td>
<td>
<p>transparency of dots</p>
</td></tr>
</table>

<hr>
<h2 id='supercell_merge'>Merging independent SuperCell objects</h2><span id='topic+supercell_merge'></span>

<h3>Description</h3>

<p>This function merges independent SuperCell objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_merge(SCs, fields = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_merge_+3A_scs">SCs</code></td>
<td>
<p>list of SuperCell objects (results of <a href="#topic+SCimplify">SCimplify</a> )</p>
</td></tr>
<tr><td><code id="supercell_merge_+3A_fields">fields</code></td>
<td>
<p>which additional fields (e.g., metadata) of the the SuperCell objects to keep when merging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li><p> membership - assignment of each single cell to a particular metacell
</p>
</li>
<li><p> cell.ids - the original ids of single-cells
</p>
</li>
<li><p> supercell_size - size of metacells (former super-cells)
</p>
</li>
<li><p> gamma -  graining level of the merged object (estimated as an average size of metacells as the independent SuperCell objects might have different graining levels)
</p>
</li>
<li><p> N.SC - number of obtained metacells
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(cell_lines) # list with GE - gene expression matrix (logcounts), meta - cell meta data
GE &lt;- cell_lines$GE
cell.meta &lt;- cell_lines$meta

cell.idx.HCC827 &lt;- which(cell.meta == "HCC827")
cell.idx.H838   &lt;- which(cell.meta == "H838")

SC.HCC827 &lt;- SCimplify(GE[,cell.idx.HCC827],  # log-normalized gene expression matrix
                gamma = 20, # graining level
                n.var.genes = 1000,
                k.knn = 5, # k for kNN algorithm
                n.pc = 10) # number of principal components to use
SC.HCC827$cell.line &lt;- supercell_assign(
    cell.meta[cell.idx.HCC827],
    supercell_membership = SC.HCC827$membership)

SC.H838 &lt;- SCimplify(GE[,cell.idx.H838],  # log-normalized gene expression matrix
                gamma = 30, # graining level
                n.var.genes = 1000, # number of top var genes to use for the dim reduction
                k.knn = 5, # k for kNN algorithm
                n.pc = 15) # number of proncipal components to use
SC.H838$cell.line &lt;- supercell_assign(
    cell.meta[cell.idx.H838],
    supercell_membership = SC.H838$membership)

SC.merged &lt;- supercell_merge(list(SC.HCC827, SC.H838), fields = c("cell.line"))

# compute metacell gene expression for SC.HCC827
SC.GE.HCC827 &lt;- supercell_GE(GE[, cell.idx.HCC827], groups = SC.HCC827$membership)
# compute metacell gene expression for SC.H838
SC.GE.H838 &lt;- supercell_GE(GE[, cell.idx.H838], groups = SC.H838$membership)
# merge GE matricies
SC.GE.merged &lt;- supercell_mergeGE(list(SC.GE.HCC827, SC.GE.H838))


</code></pre>

<hr>
<h2 id='supercell_mergeGE'>Merging metacell gene expression matrices from several independent SuperCell objects</h2><span id='topic+supercell_mergeGE'></span>

<h3>Description</h3>

<p>This function merges independent SuperCell objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_mergeGE(SC.GEs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_mergeGE_+3A_sc.ges">SC.GEs</code></td>
<td>
<p>list of metacell gene expression matricies (result of <a href="#topic+supercell_GE">supercell_GE</a> ), make sure the order of the gene expression metricies is the same as in the call of <a href="#topic+supercell_merge">supercell_merge</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a merged matrix of gene expression
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see examples in \link{supercell_merge}

</code></pre>

<hr>
<h2 id='supercell_plot'>Plot metacell NW</h2><span id='topic+supercell_plot'></span>

<h3>Description</h3>

<p>Plot metacell NW
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_plot(
  SC.nw,
  group = NULL,
  color.use = NULL,
  lay.method = c("nicely", "fr", "components", "drl", "graphopt"),
  lay = NULL,
  alpha = 0,
  seed = 12345,
  main = NA,
  do.frames = TRUE,
  do.extra.log.rescale = FALSE,
  do.directed = FALSE,
  log.base = 2,
  do.extra.sqtr.rescale = FALSE,
  frame.color = "black",
  weights = NULL,
  min.cell.size = 0,
  return.meta = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_plot_+3A_sc.nw">SC.nw</code></td>
<td>
<p>a super-cell (metacell) network (a field <code>supercell_network</code> of the output of <a href="#topic+SCimplify">SCimplify</a>)</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_group">group</code></td>
<td>
<p>an assigment of metacells to any group (for ploting in different colors)</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_color.use">color.use</code></td>
<td>
<p>colros to use for groups, if <code>NULL</code>, an automatic palette of colors will be applied</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_lay.method">lay.method</code></td>
<td>
<p>method to compute layout of the network (for the moment there several available: &quot;nicely&quot;
for <a href="igraph.html#topic+layout_nicely">layout_nicely</a> and &quot;fr&quot; for <a href="igraph.html#topic+layout_with_fr">layout_with_fr</a>, &quot;components&quot; for <a href="igraph.html#topic+layout_components">layout_components</a>,
&quot;drl&quot; for <a href="igraph.html#topic+layout_with_drl">layout_with_drl</a>, &quot;graphopt&quot; for <a href="igraph.html#topic+layout_with_graphopt">layout_with_graphopt</a>). If your dataset has clear clusters, use &quot;components&quot;</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_lay">lay</code></td>
<td>
<p>a particular layout of a graph to plot (in is not <code>NULL</code>, <code>lay.method</code> is ignored and new layout is not computed)</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_alpha">alpha</code></td>
<td>
<p>a rotation of the layout (either provided or computed)</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_seed">seed</code></td>
<td>
<p>a random seed used to compute graph layout</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_main">main</code></td>
<td>
<p>a title of a plot</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_do.frames">do.frames</code></td>
<td>
<p>whether to keep vertex.frames in the plot</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_do.extra.log.rescale">do.extra.log.rescale</code></td>
<td>
<p>whether to log-scale node size (to balance plot if some metacells are large and covers smaller metacells)</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_do.directed">do.directed</code></td>
<td>
<p>whether to plot edge direction</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_log.base">log.base</code></td>
<td>
<p>base with thich to log-scale node size</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_do.extra.sqtr.rescale">do.extra.sqtr.rescale</code></td>
<td>
<p>whether to sqrt-scale node size (to balance plot if some metacells are large and covers smaller metacells)</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_frame.color">frame.color</code></td>
<td>
<p>color of node frames, black by default</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_weights">weights</code></td>
<td>
<p>edge weights used for some layout algorithms</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_min.cell.size">min.cell.size</code></td>
<td>
<p>do not plot cells with smaller size</p>
</td></tr>
<tr><td><code id="supercell_plot_+3A_return.meta">return.meta</code></td>
<td>
<p>whether to return all the meta data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot of a super-cell network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cell_lines) # list with GE - gene expression matrix (logcounts), meta - cell meta data
GE &lt;- cell_lines$GE
cell.meta &lt;- cell_lines$meta

SC &lt;- SCimplify(GE,  # gene expression matrix
                gamma = 20) # graining level

# Assign metacell to a cell line
SC2cellline  &lt;- supercell_assign(
    clusters = cell.meta, # single-cell assignment to cell lines
    supercell_membership = SC$membership) # single-cell assignment to metacells

# Plot metacell network colored by cell line
supercell_plot(SC$graph.supercells, # network
               group = SC2cellline, # group assignment
               main = "Metacell colored by cell line assignment",
               lay.method = 'nicely')


</code></pre>

<hr>
<h2 id='supercell_plot_GE'>Plot super-cell NW colored by an expression of a gene (gradient color)</h2><span id='topic+supercell_plot_GE'></span>

<h3>Description</h3>

<p>Plot super-cell NW colored by an expression of a gene (gradient color)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_plot_GE(
  SC.nw,
  ge,
  color.use = c("gray", "blue"),
  n.color.gradient = 10,
  main = NA,
  legend.side = 4,
  gene.name = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_plot_GE_+3A_sc.nw">SC.nw</code></td>
<td>
<p>a super-cell network (a field <code>supercell_network</code> of the output of <a href="#topic+SCimplify">SCimplify</a>)</p>
</td></tr>
<tr><td><code id="supercell_plot_GE_+3A_ge">ge</code></td>
<td>
<p>a gene expression vector (same length as number of super-cells)</p>
</td></tr>
<tr><td><code id="supercell_plot_GE_+3A_color.use">color.use</code></td>
<td>
<p>colors of gradient</p>
</td></tr>
<tr><td><code id="supercell_plot_GE_+3A_n.color.gradient">n.color.gradient</code></td>
<td>
<p>number of bins of the gradient, default is 10</p>
</td></tr>
<tr><td><code id="supercell_plot_GE_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="supercell_plot_GE_+3A_legend.side">legend.side</code></td>
<td>
<p>a side parameter of <a href="plotfunctions.html#topic+gradientLegend">gradientLegend</a> function (default is 4)</p>
</td></tr>
<tr><td><code id="supercell_plot_GE_+3A_gene.name">gene.name</code></td>
<td>
<p>name of gene of for which gene expression is plotted</p>
</td></tr>
<tr><td><code id="supercell_plot_GE_+3A_...">...</code></td>
<td>
<p>rest of the parameters of <a href="#topic+supercell_plot">supercell_plot</a> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot of a super-cell network with color representing an expression level
</p>

<hr>
<h2 id='supercell_plot_tSNE'>Plot super-cell tSNE
(Use <a href="#topic+supercell_DimPlot">supercell_DimPlot</a> instead)
Plots super-cell tSNE (result of <a href="#topic+supercell_tSNE">supercell_tSNE</a>)</h2><span id='topic+supercell_plot_tSNE'></span>

<h3>Description</h3>

<p>Plot super-cell tSNE
(Use <a href="#topic+supercell_DimPlot">supercell_DimPlot</a> instead)
Plots super-cell tSNE (result of <a href="#topic+supercell_tSNE">supercell_tSNE</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_plot_tSNE(
  SC,
  groups,
  tSNE_name = "SC_tSNE",
  color.use = NULL,
  asp = 1,
  alpha = 0.7,
  title = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_plot_tSNE_+3A_sc">SC</code></td>
<td>
<p>super-cell structure (output of <a href="#topic+SCimplify">SCimplify</a>) with a field <code>tSNE_name</code> containing tSNE result</p>
</td></tr>
<tr><td><code id="supercell_plot_tSNE_+3A_groups">groups</code></td>
<td>
<p>coloring metacells by groups</p>
</td></tr>
<tr><td><code id="supercell_plot_tSNE_+3A_tsne_name">tSNE_name</code></td>
<td>
<p>the mane of the field containing tSNE result</p>
</td></tr>
<tr><td><code id="supercell_plot_tSNE_+3A_color.use">color.use</code></td>
<td>
<p>colors of groups</p>
</td></tr>
<tr><td><code id="supercell_plot_tSNE_+3A_asp">asp</code></td>
<td>
<p>plot aspect ratio</p>
</td></tr>
<tr><td><code id="supercell_plot_tSNE_+3A_alpha">alpha</code></td>
<td>
<p>transparency of</p>
</td></tr>
<tr><td><code id="supercell_plot_tSNE_+3A_title">title</code></td>
<td>
<p>title of the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="ggplot2.html#topic+ggplot">ggplot</a>
</p>

<hr>
<h2 id='supercell_plot_UMAP'>Plot super-cell UMAP
(Use <a href="#topic+supercell_DimPlot">supercell_DimPlot</a> instead)
Plots super-cell UMAP (result of <a href="#topic+supercell_UMAP">supercell_UMAP</a>)</h2><span id='topic+supercell_plot_UMAP'></span>

<h3>Description</h3>

<p>Plot super-cell UMAP
(Use <a href="#topic+supercell_DimPlot">supercell_DimPlot</a> instead)
Plots super-cell UMAP (result of <a href="#topic+supercell_UMAP">supercell_UMAP</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_plot_UMAP(
  SC,
  groups,
  UMAP_name = "SC_UMAP",
  color.use = NULL,
  asp = 1,
  alpha = 0.7,
  title = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_plot_UMAP_+3A_sc">SC</code></td>
<td>
<p>super-cell structure (output of <a href="#topic+SCimplify">SCimplify</a>) with a field <code>UMAP_name</code> containing UMAP result</p>
</td></tr>
<tr><td><code id="supercell_plot_UMAP_+3A_groups">groups</code></td>
<td>
<p>coloring metacells by groups</p>
</td></tr>
<tr><td><code id="supercell_plot_UMAP_+3A_umap_name">UMAP_name</code></td>
<td>
<p>the mane of the field containing UMAP result</p>
</td></tr>
<tr><td><code id="supercell_plot_UMAP_+3A_color.use">color.use</code></td>
<td>
<p>colors of groups</p>
</td></tr>
<tr><td><code id="supercell_plot_UMAP_+3A_asp">asp</code></td>
<td>
<p>plot aspect ratio</p>
</td></tr>
<tr><td><code id="supercell_plot_UMAP_+3A_alpha">alpha</code></td>
<td>
<p>transparency of</p>
</td></tr>
<tr><td><code id="supercell_plot_UMAP_+3A_title">title</code></td>
<td>
<p>title of the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="ggplot2.html#topic+ggplot">ggplot</a>
</p>

<hr>
<h2 id='supercell_prcomp'>compute PCA for super-cell data (sample-weighted data)</h2><span id='topic+supercell_prcomp'></span>

<h3>Description</h3>

<p>compute PCA for super-cell data (sample-weighted data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_prcomp(
  X,
  genes.use = NULL,
  genes.exclude = NULL,
  supercell_size = NULL,
  k = 20,
  do.scale = TRUE,
  do.center = TRUE,
  fast.pca = TRUE,
  seed = 12345
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_prcomp_+3A_x">X</code></td>
<td>
<p>super-cell transposed gene expression matrix (! where rows represent super-cells and cols represent genes)</p>
</td></tr>
<tr><td><code id="supercell_prcomp_+3A_genes.use">genes.use</code></td>
<td>
<p>genes to use for dimensionality reduction</p>
</td></tr>
<tr><td><code id="supercell_prcomp_+3A_genes.exclude">genes.exclude</code></td>
<td>
<p>genes to exclude from dimensionaloty reduction</p>
</td></tr>
<tr><td><code id="supercell_prcomp_+3A_supercell_size">supercell_size</code></td>
<td>
<p>a vector with supercell sizes (ordered the same way as in X)</p>
</td></tr>
<tr><td><code id="supercell_prcomp_+3A_k">k</code></td>
<td>
<p>number of components to compute</p>
</td></tr>
<tr><td><code id="supercell_prcomp_+3A_do.scale">do.scale</code></td>
<td>
<p>scale data before PCA</p>
</td></tr>
<tr><td><code id="supercell_prcomp_+3A_do.center">do.center</code></td>
<td>
<p>center data before PCA</p>
</td></tr>
<tr><td><code id="supercell_prcomp_+3A_fast.pca">fast.pca</code></td>
<td>
<p>whether to run fast PCA (works for datasets with |super-cells| &gt; 50)</p>
</td></tr>
<tr><td><code id="supercell_prcomp_+3A_seed">seed</code></td>
<td>
<p>a seed to use for <code>set.seed</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same object as <a href="stats.html#topic+prcomp">prcomp</a> result
</p>

<hr>
<h2 id='supercell_purity'>Compute purity of super-cells</h2><span id='topic+supercell_purity'></span>

<h3>Description</h3>

<p>Compute purity of super-cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_purity(
  clusters,
  supercell_membership,
  method = c("max_proportion", "entropy")[1]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_purity_+3A_clusters">clusters</code></td>
<td>
<p>vector of clustering assignment (reference assignment)</p>
</td></tr>
<tr><td><code id="supercell_purity_+3A_supercell_membership">supercell_membership</code></td>
<td>
<p>vector of assignment of single-cell data to super-cells (membership field of <a href="#topic+SCimplify">SCimplify</a> function output)</p>
</td></tr>
<tr><td><code id="supercell_purity_+3A_method">method</code></td>
<td>
<p>method to compute super-cell purity.
<code>"max_proportion"</code> if the purity is defined as a proportion of the most abundant cluster (cell type) within super-cell or
<code>"entropy"</code> if the purity is defined as the Shanon entropy of the cell types super-cell consists of.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of super-cell purity, which is defined as:
- proportion of the most abundant cluster within super-cell for <code>method = "max_proportion"</code> or
- Shanon entropy for <code>method = "entropy"</code>.
With 1 meaning that super-cell consists of single cells from one cluster (reference assignment)
</p>

<hr>
<h2 id='supercell_rescale'>Rescale supercell object</h2><span id='topic+supercell_rescale'></span>

<h3>Description</h3>

<p>This function recomputes super-cell structure at a different graining level (<code>gamma</code>) or
for a specific number of super-cells (<code>N.SC</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_rescale(SC.object, gamma = NULL, N.SC = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_rescale_+3A_sc.object">SC.object</code></td>
<td>
<p>super-cell object (an output from <a href="#topic+SCimplify">SCimplify</a> function)</p>
</td></tr>
<tr><td><code id="supercell_rescale_+3A_gamma">gamma</code></td>
<td>
<p>new grainig level (provide either <code>gamma</code> or <code>N.SC</code>)</p>
</td></tr>
<tr><td><code id="supercell_rescale_+3A_n.sc">N.SC</code></td>
<td>
<p>new number of super-cells (provide either <code>gamma</code> or <code>N.SC</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same object as <a href="#topic+SCimplify">SCimplify</a> at a new graining level
</p>

<hr>
<h2 id='supercell_silhouette'>Compute Silhouette index accounting for samlpe size (super cells size) ###</h2><span id='topic+supercell_silhouette'></span>

<h3>Description</h3>

<p>Compute Silhouette index accounting for samlpe size (super cells size) ###
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_silhouette(x, dist, supercell_size = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_silhouette_+3A_x">x</code></td>
<td>
<p>&ndash; clustering</p>
</td></tr>
<tr><td><code id="supercell_silhouette_+3A_dist">dist</code></td>
<td>
<p>- distance among super-cells</p>
</td></tr>
<tr><td><code id="supercell_silhouette_+3A_supercell_size">supercell_size</code></td>
<td>
<p>&ndash; super-cell size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>silhouette result
</p>

<hr>
<h2 id='supercell_tSNE'>Compute tSNE of super-cells</h2><span id='topic+supercell_tSNE'></span>

<h3>Description</h3>

<p>Computes tSNE of super-cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_tSNE(
  SC,
  PCA_name = "SC_PCA",
  n.comp = NULL,
  perplexity = 30,
  seed = 12345,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_tSNE_+3A_sc">SC</code></td>
<td>
<p>super-cell structure (output of <a href="#topic+SCimplify">SCimplify</a>) with a field <code>PCA_name</code> containig PCA result</p>
</td></tr>
<tr><td><code id="supercell_tSNE_+3A_pca_name">PCA_name</code></td>
<td>
<p>name of <code>SC</code> field containing result of <a href="#topic+supercell_prcomp">supercell_prcomp</a></p>
</td></tr>
<tr><td><code id="supercell_tSNE_+3A_n.comp">n.comp</code></td>
<td>
<p>number of vector of principal components to use for computing tSNE</p>
</td></tr>
<tr><td><code id="supercell_tSNE_+3A_perplexity">perplexity</code></td>
<td>
<p>perplexity parameter (parameter of <a href="Rtsne.html#topic+Rtsne">Rtsne</a>)</p>
</td></tr>
<tr><td><code id="supercell_tSNE_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
<tr><td><code id="supercell_tSNE_+3A_...">...</code></td>
<td>
<p>other parameters of <a href="Rtsne.html#topic+Rtsne">Rtsne</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="Rtsne.html#topic+Rtsne">Rtsne</a> result
</p>

<hr>
<h2 id='supercell_UMAP'>Compute UMAP of super-cells</h2><span id='topic+supercell_UMAP'></span>

<h3>Description</h3>

<p>Computes UMAP of super-cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_UMAP(SC, PCA_name = "SC_PCA", n.comp = NULL, n_neighbors = 15, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_UMAP_+3A_sc">SC</code></td>
<td>
<p>super-cell structure (output of <a href="#topic+SCimplify">SCimplify</a>) with a field <code>PCA_name</code> containing PCA result</p>
</td></tr>
<tr><td><code id="supercell_UMAP_+3A_pca_name">PCA_name</code></td>
<td>
<p>name of <code>SC</code> field containing result of <a href="#topic+supercell_prcomp">supercell_prcomp</a></p>
</td></tr>
<tr><td><code id="supercell_UMAP_+3A_n.comp">n.comp</code></td>
<td>
<p>number of vector of principal components to use for computing UMAP</p>
</td></tr>
<tr><td><code id="supercell_UMAP_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>number of neighbors (parameter of  <a href="umap.html#topic+umap">umap</a>)</p>
</td></tr>
<tr><td><code id="supercell_UMAP_+3A_...">...</code></td>
<td>
<p>other parameters of <a href="umap.html#topic+umap">umap</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="umap.html#topic+umap">umap</a> result
</p>

<hr>
<h2 id='supercell_VlnPlot'>Violin plots</h2><span id='topic+supercell_VlnPlot'></span>

<h3>Description</h3>

<p>Violin plots (similar to <a href="Seurat.html#topic+VlnPlot">VlnPlot</a> with some changes for super-cells)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_VlnPlot(
  ge,
  supercell_size = NULL,
  clusters,
  features = NULL,
  idents = NULL,
  color.use = NULL,
  pt.size = 0,
  pch = "o",
  y.max = NULL,
  y.min = NULL,
  same.y.lims = FALSE,
  adjust = 1,
  ncol = NULL,
  combine = TRUE,
  angle.text.y = 90,
  angle.text.x = 45
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_VlnPlot_+3A_ge">ge</code></td>
<td>
<p>a gene expression matrix (ncol same as number of super-cells)</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_supercell_size">supercell_size</code></td>
<td>
<p>a vector with supercell size (ordered the same way as in <code>ge</code>)</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_clusters">clusters</code></td>
<td>
<p>a vector with clustering information (ordered the same way as in <code>ge</code>)</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_features">features</code></td>
<td>
<p>name of genes of for which gene expression is plotted</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_idents">idents</code></td>
<td>
<p>idents (clusters) to plot (default all)</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_color.use">color.use</code></td>
<td>
<p>colors for idents</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_pt.size">pt.size</code></td>
<td>
<p>point size (0 by default)</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_pch">pch</code></td>
<td>
<p>shape of jitter dots</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_y.max">y.max</code></td>
<td>
<p>max of y axis</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_y.min">y.min</code></td>
<td>
<p>min of y axis</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_same.y.lims">same.y.lims</code></td>
<td>
<p>same y axis for all plots</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_adjust">adjust</code></td>
<td>
<p>param of geom_violin</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_ncol">ncol</code></td>
<td>
<p>number of columns in combined plot</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_combine">combine</code></td>
<td>
<p>combine plots into a single <a href="patchwork.html#topic+patchwork">patchwork</a>ed ggplot object. If FALSE, return a list of ggplot</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_angle.text.y">angle.text.y</code></td>
<td>
<p>rotation of y text</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_+3A_angle.text.x">angle.text.x</code></td>
<td>
<p>rotation of x text</p>
</td></tr>
</table>


<h3>Value</h3>

<p>combined ggplot or list of ggplots if <code>combine = TRUE</code>
</p>

<hr>
<h2 id='supercell_VlnPlot_single'>Plot  Violin plot for 1 feature</h2><span id='topic+supercell_VlnPlot_single'></span>

<h3>Description</h3>

<p>Used for supercell_VlnPlot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercell_VlnPlot_single(
  ge1,
  supercell_size = NULL,
  clusters,
  feature = NULL,
  color.use = NULL,
  pt.size = 0,
  pch = "o",
  y.max = NULL,
  y.min = NULL,
  adjust = 1,
  angle.text.y = 90,
  angle.text.x = 45
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supercell_VlnPlot_single_+3A_ge1">ge1</code></td>
<td>
<p>a gene expression vector (same length as number of super-cells)</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_single_+3A_supercell_size">supercell_size</code></td>
<td>
<p>a vector with supercell size (ordered the same way as in <code>ge</code>)</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_single_+3A_clusters">clusters</code></td>
<td>
<p>a vector with clustering information (ordered the same way as in <code>ge</code>)</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_single_+3A_feature">feature</code></td>
<td>
<p>gene to plot</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_single_+3A_color.use">color.use</code></td>
<td>
<p>colors for idents</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_single_+3A_pt.size">pt.size</code></td>
<td>
<p>point size (0 by default)</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_single_+3A_pch">pch</code></td>
<td>
<p>shape of jitter dots</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_single_+3A_y.max">y.max</code></td>
<td>
<p>max of y axis</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_single_+3A_y.min">y.min</code></td>
<td>
<p>min of y axis</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_single_+3A_adjust">adjust</code></td>
<td>
<p>param of geom_violin</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_single_+3A_angle.text.y">angle.text.y</code></td>
<td>
<p>rotation of y text</p>
</td></tr>
<tr><td><code id="supercell_VlnPlot_single_+3A_angle.text.x">angle.text.x</code></td>
<td>
<p>rotation of x text</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
