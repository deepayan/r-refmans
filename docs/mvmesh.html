<!DOCTYPE html><html lang="en"><head><title>Help for package mvmesh</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvmesh}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#HollowRectangle'><p>Subdivide a hyperrectangle with a standard grid</p></a></li>
<li><a href='#HollowTube'><p>Define tubes in n-dimensions</p></a></li>
<li><a href='#mvhist'><p>Multivariate histograms</p></a></li>
<li><a href='#mvmesh-geom'><p>Miscellaneous computational geometry and utility functions</p></a></li>
<li><a href='#mvmesh-methods'><p>Methods to print and draw mvmesh objects</p></a></li>
<li><a href='#mvmesh-package'><p>Multivariate meshes and histograms in arbitrary dimensions</p></a></li>
<li><a href='#mvmeshmisc'><p>Miscellaneous functions used by/with mvmesh</p></a></li>
<li><a href='#PolarSphere'><p>Define a mesh on the unit sphere/ball in n-dimensions determined by a polar coordinates grid.</p></a></li>
<li><a href='#rmvmesh'><p>Simulate from a mesh</p></a></li>
<li><a href='#UnitSimplex'><p>Define a mesh on the unit simplex or the canonical simplex</p></a></li>
<li><a href='#UnitSphere'><p>Define a mesh on a unit ball in n-dimensions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Meshes and Histograms in Arbitrary Dimensions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-09</td>
</tr>
<tr>
<td>Author:</td>
<td>John P. Nolan</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John P. Nolan &lt;jpnolan@american.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), rcdd, rgl, geometry, abind, SimplicialCubature</td>
</tr>
<tr>
<td>Description:</td>
<td>Define, manipulate and plot meshes on simplices, spheres, balls, rectangles and tubes.
 Directional and other multivariate histograms are provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-10 03:07:34 UTC; John</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-11 21:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='HollowRectangle'>Subdivide a hyperrectangle with a standard grid
</h2><span id='topic+HollowRectangle'></span><span id='topic+SolidRectangle'></span><span id='topic+mvmeshRectBreaks'></span><span id='topic+NextMultiIndex'></span>

<h3>Description</h3>

<p><code>EdgeSubdivision</code> implements the 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HollowRectangle( a, b, breaks=5, silent=FALSE )
SolidRectangle( a, b, breaks=5, silent=FALSE )
mvmeshRectBreaks( a, b, breaks, silent ) 
NextMultiIndex( i, n )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HollowRectangle_+3A_a">a</code></td>
<td>
<p>vector specifying the &quot;lower left&quot; vertex of the rectangle
</p>
</td></tr>
<tr><td><code id="HollowRectangle_+3A_b">b</code></td>
<td>
<p>vector specifying the &quot;upper right&quot; vertex of the rectangle
</p>
</td></tr>
<tr><td><code id="HollowRectangle_+3A_breaks">breaks</code></td>
<td>
<p>a specification of the subdivision scheme.  See details below.
</p>
</td></tr>
<tr><td><code id="HollowRectangle_+3A_silent">silent</code></td>
<td>
<p>indicates whether or not to warn the caller if the subdivision
determined by 'breaks' covers the whole hyperrectangle [a,b]. 
</p>
</td></tr>
<tr><td><code id="HollowRectangle_+3A_i">i</code></td>
<td>
<p>integer vector
</p>
</td></tr>
<tr><td><code id="HollowRectangle_+3A_n">n</code></td>
<td>
<p>integer vector
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>RectangularMesh</code> computes an rectangular mesh on the hyperrectangle
[a,b] = [a[1],b[1]] x [a[2],b[2]] x ... x [a[n],b[n]].   It is similar to
the function <code>mesh</code> in CRAN package plot3D, but works for dimension d=2,3,4,...
</p>
<p>'breaks' determines how 
each component is divided, it is motivated by the argument breaks in <code>hist</code>.
If 'breaks' is a vector of length n, then breaks[i] gives the number of evenly
sized bins in coordinate i, spread out over the range [a[i],b[i]].
If 'breaks' is a single number m, then each component
is subdivided into that many bins, i.e. this is equivalent to breaks=rep(m,n).
Thus the default breaks=6 subdivides each coordinate into 6 bins.  
Finally, if a more complicated subdivision is desired, 'breaks' can a list
with n fields.  breaks[[i]] should be a vector of dividing points for coordinate i.
See the example below. In this last case, where the bin boundaries are explictly
defined, 'a' and 'b' are not used (other than a possible warning if the specified
bins do not cover the rectangle given by 'a' and 'b').
</p>


<h3>Value</h3>

<p>An object of class &quot;mvmesh&quot;  as described in <code><a href="#topic+mvmesh">mvmesh</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SolidRectangle( a=c(1,3), b=c(2,7), breaks=2 )
SolidRectangle( a=c(1,3), b=c(2,7), breaks=c(4,10) )
SolidRectangle( a=c(1,3), b=c(2,7), 
    breaks=list( seq(1,3,by=0.25), seq(2,7,by=1) ) )
HollowRectangle( a=c(1,3), b=c(2,7), breaks=2 )
HollowRectangle( a=c(1,3), b=c(2,7), breaks=c(4,10) )
HollowRectangle( a=c(1,3), b=c(2,7), 
    breaks=list( seq(1,3,by=0.25), seq(2,7,by=1) ) )
    

## Not run: 
plot( SolidRectangle( a=c(1,3), b=c(2,7), breaks=3 ), show.labels=TRUE )
plot( SolidRectangle( a=c(1,3), b=c(2,7), breaks=c(4,10) ), show.labels=TRUE )
plot( SolidRectangle( a=c(1,3), b=c(2,7), 
    breaks=list( seq(1,3,by=0.25), seq(2,7,by=1) ) ), show.labels=TRUE )
plot( SolidRectangle( a=c(1,3), b=c(2,7), breaks=3 ), show.labels=TRUE, 
    label.values=letters[1:9], col='green' )
    
plot( HollowRectangle( a=c(1,3,0), b=c(6,7,6), breaks=3 ), show.labels=TRUE, col='blue')
plot( HollowRectangle( a=c(1,3), b=c(2,7), breaks=3 ), show.labels=TRUE )
plot( HollowRectangle( a=c(1,3), b=c(2,7), breaks=c(4,10) ), show.labels=TRUE )
plot( HollowRectangle( a=c(1,3), b=c(2,7), 
    breaks=list( seq(1,3,by=0.25), seq(2,7,by=1) ) ), show.labels=TRUE )
plot( HollowRectangle( a=c(1,3), b=c(2,7), breaks=3 ), show.labels=TRUE, 
    label.values=letters[1:9], col='green' )

## End(Not run)    
</code></pre>

<hr>
<h2 id='HollowTube'>Define tubes in n-dimensions
</h2><span id='topic+HollowTube'></span><span id='topic+SolidTube'></span>

<h3>Description</h3>

<p>Define a 'horizontal' tube, either hollow or solid, in n dimensions</p>


<h3>Usage</h3>

<pre><code class='language-R'>HollowTube( n, k.x=1, k.circumference=2, method="dyadic", p=2 )
SolidTube( n, k.x=1, k.circumference=2, method="dyadic", p=2 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HollowTube_+3A_n">n</code></td>
<td>
<p>Dimension of the space
</p>
</td></tr>
<tr><td><code id="HollowTube_+3A_k.x">k.x</code></td>
<td>
<p>Number of subdivisions along the x[1] direction (first component)
</p>
</td></tr>
<tr><td><code id="HollowTube_+3A_k.circumference">k.circumference</code></td>
<td>
<p>Number of subdivisions around the circumference; note the meaning of
this depends on the value of <code>method</code>.
</p>
</td></tr>
<tr><td><code id="HollowTube_+3A_method">method</code></td>
<td>
<p>&quot;dyadic&quot; or &quot;edgewise&quot;: the former recursively subdivides the sphere to get
a more uniform grid; the latter uses a faster method using one edgewise subdivision.
</p>
</td></tr>
<tr><td><code id="HollowTube_+3A_p">p</code></td>
<td>
<p>Power used in the l^p norm; p=2 is the Euclidean norm
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>HollowTube</code> computes an approximation to a tube, an (n-1) dimensional 
surface in n space.  The tube is 'horizontal', e.g. the center line of the tube is the x-axis with
0 &lt;= x[1] &lt;= 1 and radius 1;
use <code>AffineTransform</code> to rotate, stretch or translate.  
The mesh is basically constructed by taking the cross product of an x[1] subdivision
with an (n-1) dimensional sphere; the optional arguments <code>k.circumference, method, p</code> are used in
a call to <code>UnitSphere</code> to specify the sphere.  The default value of p=2 gives a tube
with round/Euclidean cross section; using a different p will make the cross sections of the tube
a ball in the Lp norm.  
</p>
<p><code>SolidTube</code> computes an approximation to a solid tube, an n dimensional solid in
n space.  
</p>


<h3>Value</h3>

<p>an object of class &quot;mvmesh&quot;  as described in <code><a href="#topic+mvmesh">mvmesh</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HollowTube( n=3 )
SolidTube( n=3 )

## Not run: 
plot( HollowTube(  n=3, k.x=3, k.circumference=2 ), show.faces=TRUE, col='red', alpha=0.5 )
plot( SolidTube( n=3, k.x=5, k.circumference=2 ), col='blue' )

# use non-Euclidean sphere to define wall of tube 
plot( HollowTube(  n=3, k.x=10, k.circumference=2, p=0.6 ), col='green')

## End(Not run)
</code></pre>

<hr>
<h2 id='mvhist'>Multivariate histograms</h2><span id='topic+mvhist'></span><span id='topic+histDirectional'></span><span id='topic+histDirectionalQuantileThreshold'></span><span id='topic+histDirectionalAbsoluteThreshold'></span><span id='topic+histSimplex'></span><span id='topic+histRectangular'></span><span id='topic+TallyHrep'></span><span id='topic+TallyCones'></span><span id='topic+DrawPillars'></span>

<h3>Description</h3>

<p>Tabulate and plot histograms for multivariate data, including directional histograms</p>


<h3>Usage</h3>

<pre><code class='language-R'>histDirectional( x, k, p=2, plot.type="default", freq=TRUE, positive.only=FALSE, 
     report="summary", label.orthants=TRUE, normalize.by.area=FALSE, ... )
histDirectionalQuantileThreshold( x, probs=1, p=2, k=3, positive.only=FALSE, ... )
histDirectionalAbsoluteThreshold( x, thresholds=0, p=2, k=3, positive.only=FALSE,...)     
histRectangular( x, breaks=10, plot.type="default", freq=TRUE, report="summary", ... )
histSimplex( x, S, plot.type="default", freq=TRUE, report="summary", ... )

TallyHrep( x, H, report="summary" )  
DrawPillars( S, height, shift=rep(0.0,3), ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvhist_+3A_x">x</code></td>
<td>
<p>data in an (n x d) matrix; rows are d-dimensional data vectors
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_k">k</code></td>
<td>
<p>number of subdivisions
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_p">p</code></td>
<td>
<p>power of p-norm
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_freq">freq</code></td>
<td>
<p>TRUE for a frequency histogram, FALSE for a relative frequency histogram.  See note about normalize.by.area
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_normalize.by.area">normalize.by.area</code></td>
<td>
<p>if TRUE, then the counts are normalized by the surface area of the corresponding
simplex on the sphere.  This is useful since in general the surface area varies and counts will vary 
accordingly.  In particular, isotropic data will not appear isotropic without setting this to TRUE.
If TRUE, the value of freq is ignored: the histogram always shows count/surface area
</p>
</td></tr> 
<tr><td><code id="mvhist_+3A_breaks">breaks</code></td>
<td>
<p>specifes the subdivision of the region; see 'breaks' in <code><a href="#topic+SolidRectangle">SolidRectangle</a></code>
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_plot.type">plot.type</code></td>
<td>
<p>type of plot, see details below
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_positive.only">positive.only</code></td>
<td>
<p>If TRUE, look only in the first orthant
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_report">report</code></td>
<td>
<p>level of warning messages; one of &quot;summary&quot;, &quot;all&quot;, &quot;none&quot;.
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_label.orthants">label.orthants</code></td>
<td>
<p>If plot.type=&quot;index&quot;, this controls whether or not the orthants are labeled on the plot.
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_probs">probs</code></td>
<td>
<p>vector of probabilites specifying what fraction of the extremes to keep
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_thresholds">thresholds</code></td>
<td>
<p>vector of thresholds specifying cutoff for extremes to keep
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_...">...</code></td>
<td>
<p>Optional arguments to plot
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_s">S</code></td>
<td>
<p>(vps x d x nS) array of simplices in V representation, see <code><a href="#topic+V2Hrep">V2Hrep</a></code>
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_h">H</code></td>
<td>
<p>array of simplices in H representation, see <code><a href="#topic+V2Hrep">V2Hrep</a></code>
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_height">height</code></td>
<td>
<p>vector of length nS giving the heights of the pillars
</p>
</td></tr>
<tr><td><code id="mvhist_+3A_shift">shift</code></td>
<td>
<p>shift of the pillars, typically (0,0,0) for 2d data or (0,0,z0) for 3d data
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate and plot multivariate histograms.  
<code>histDirectional</code> plots a directional histogram for all the data, 
<code>histDirectionalQuantileThreshold</code> plots <code>m=length(probs)</code> directional histograms,
with plot i using the top probs[i] fraction of the data, 
<code>histDirectionalAbsoluteThreshold</code>  plots <code>m=length(cut.off)</code> directional histograms,
with plot i using the top probs[i] fraction of the data, 
<code>histSimplex</code> plots histogram based on simplices specified in <code>S</code>,
<code>histRectangular</code> plots histogram based on a rectangular grid,
</p>
<p>In all cases, the bins are simplices described in the H-representation and tallied by <code>TallyHrep</code>.
<code>TallyCones</code> does a similar function for cones from the origin and generated by a list of base simplices.
</p>
<p>'plot.type' values depend on the type of plot being used.  Possible values are:
</p>

<ul>
<li><p> &quot;none&quot; - does not show a plot, just return the counts
</p>
</li>
<li><p> &quot;index&quot; - shows a histogram of simplex index number versus count, does not show the 
geometry, but works in any dimension
</p>
</li>
<li><p> &quot;pillars&quot; - shows a 3D plot with pillars/columns having base the shape of the 
simplices and height proportional to frequency counts.
When the points are 2D, this works for <code>histRectangular</code> and <code>histSimplex</code>; when the points are 3D, this only
works for <code>histRectangular</code>.  <code>DrawPillars</code> is used to plot the pillars.
</p>
</li>
<li><p> &quot;counts&quot; - shows frequency counts as a number in the center of each simplex
</p>
</li>
<li><p> &quot;radial&quot; - <code>histDirectional</code> only, shows radial spikes proportional to the counts 
</p>
</li>
<li><p> &quot;grayscale&quot; - <code>histDirectional</code> only, color codes simplices proportional to the counts 
</p>
</li>
<li><p> &quot;orthogonal&quot; - <code>histDirectional</code> only, shows radial spikes proportional to the counts 
</p>
</li>
<li><p> &quot;default&quot; - type depends on the dimension of the data and type of histogram
</p>
</li></ul>



<h3>Value</h3>

<p>A plot is drawn (unless plot.type=&quot;none&quot;).  A list is returned invisibly, with fields:
</p>

<ul>
<li><p> counts - frequency count in each bin
</p>
</li>
<li><p> nrejects - number of x values not in any bin
</p>
</li>
<li><p> nties - number of points in more than one bin (if bins are set up to be non-overlapping, 
this should only occur on a shared edge between two simplices)
</p>
</li>
<li><p> nx - total number of data points in x
</p>
</li>
<li><p> rel.freq - counts/nx
</p>
</li>
<li><p> rel.rejects - nrejects/nx
</p>
</li>
<li><p> mesh - object of type mvmesh, see <code><a href="#topic+mvmesh">mvmesh</a></code>
</p>
</li>
<li><p> plot.type - input value
</p>
</li>
<li><p> report - input value
</p>
</li></ul>



<h3>Warning</h3>

<p>This is experimental code, and not throughly tested.  If you have problems, please let me know.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# two dimensional, isotropic
x &lt;- matrix( rnorm(8000), ncol=2 )
histDirectional( x, k=1 )

## Not run: 

histRectangular( x, breaks=5 )

# some directional 2-dim data
n &lt;- 1000
A &lt;- matrix( c(1,2, 4,1), nrow=2,ncol=2)
x2 &lt;- matrix( 0.0, nrow=n, ncol=2 )
for (i in 1:n) { x2[i,] &lt;- A 
dev.new(); par(mfrow=c(2,2))
plot(x2,main="Raw data",col='red')
histDirectionalQuantileThreshold( x2, probs=c(1,0.25,0.1), p=1, 
    positive.only=TRUE, col='green',lwd=3)
dev.new(); par(mfrow=c(2,2))
histDirectionalAbsoluteThreshold( x2, thresholds=c(0,50,100,200), p=1, 
    positive.only=TRUE, col='blue',lwd=3)


# three dimensional positive data
x3 &lt;- matrix( abs(rnorm(9000)), ncol=3 )
histDirectional( x3, k=3, positive.only=TRUE, col='blue', lwd=3 )
histRectangular( x3, breaks=4 )

demo(mvhist) # shows a range of multivariate histograms
}


## End(Not run)
</code></pre>

<hr>
<h2 id='mvmesh-geom'>Miscellaneous computational geometry and utility functions
</h2><span id='topic+Icosahedron'></span><span id='topic+AffineTransform'></span><span id='topic+Rotate2D'></span><span id='topic+Rotate3D'></span><span id='topic+MatchRow'></span><span id='topic+H2Vrep'></span><span id='topic+V2Hrep'></span><span id='topic+SatisfyHrep'></span><span id='topic+HrepCones'></span><span id='topic+EdgeSubdivision'></span><span id='topic+EdgeSubdivisionMulti'></span><span id='topic+ConvertBase'></span><span id='topic+NumVertices'></span><span id='topic+PointCoord'></span><span id='topic+SimplexCoord'></span><span id='topic+SVIFromColor'></span><span id='topic+IntersectMultipleSimplicesV'></span><span id='topic+IntersectMultipleSimplicesH'></span><span id='topic+Intersect2SimplicesH'></span><span id='topic+Lift2UnitSimplex'></span>

<h3>Description</h3>

<p><code>EdgeSubdivision</code> calculates an equal area/volume subdivision of a simplex.
<code>AffineTransform</code> defines a new mesh by translating all points x to x' = A 
<code>Rotate2D</code> and <code>Rotate3D</code> calculate rotation matrices for use by <code>AffineTransform</code>.
</p>
<p><code>Icosahedron</code> returns the vertices of an icosahedron with vertices on the unit sphere
</p>
<p>Other functions are internal functions, use at your own risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EdgeSubdivision( n, k )
EdgeSubdivisionMulti( V, SVI, k, normalize = FALSE, p = 2)
ConvertBase( m, b, n)
NumVertices( n, k, single = TRUE)
PointCoord( S, color )
SimplexCoord( S, color )
SVIFromColor( S, T )

MatchRow(v, table, first = 1, last = nrow(table))
AffineTransform( mesh, A, shift ) 
Rotate2D( theta )
Rotate3D( theta )
Icosahedron( )

V2Hrep( S ) 
H2Vrep( H ) 
SatisfyHrep( x, Hsingle )
HrepCones( S )
IntersectMultipleSimplicesV( S1, S2 )
IntersectMultipleSimplicesH( H1, H2, skip.redundant=FALSE )
Intersect2SimplicesH( H1, H2, tessellate=FALSE, skip.redundant=FALSE )
Lift2UnitSimplex(S)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvmesh-geom_+3A_v">v</code></td>
<td>
<p>a vector of length n
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_table">table</code></td>
<td>
<p>matrix of size m3 x n
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_first">first</code></td>
<td>
<p>row to start search
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_last">last</code></td>
<td>
<p>row to end search
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_mesh">mesh</code></td>
<td>
<p>object of class &quot;mvmesh&quot;
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_a">A</code></td>
<td>
<p>n x n matrix
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_shift">shift</code></td>
<td>
<p>shift vector of length n 
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_theta">theta</code></td>
<td>
<p>rotation angle; in 2D, this is a single angle; in 3D is it a vector of length 3,
with theta[i] giving rotation around i-th axis
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_k">k</code></td>
<td>
<p>number of subdivisions
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_n">n</code></td>
<td>
<p>dimension of simplex
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_v">V</code></td>
<td>
<p>matrix of vertices; each row is a point in R^n
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_normalize">normalize</code></td>
<td>
<p>TRUE to normalize vertices to lie on the unit sphere in the l^p norm
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_p">p</code></td>
<td>
<p>power in the l^p norm
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_s">S</code>, <code id="mvmesh-geom_+3A_s1">S1</code>, <code id="mvmesh-geom_+3A_s2">S2</code></td>
<td>
<p>matrix of size (vps x n) specifying the vertices of a single simplex; S[j,] is the j-th vertex of S
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_svi">SVI</code></td>
<td>
<p>Simplex Vertex Indices, see <code><a href="#topic+mvmesh">mvmesh</a></code>
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_m">m</code></td>
<td>
<p>positive integer to be converted to base 'b'
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_b">b</code></td>
<td>
<p>positive integer, the base used to expess 'x'
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_single">single</code></td>
<td>
<p>If TRUE, return only one value; if FALSE, return table of values
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_color">color</code></td>
<td>
<p>color matrix, internal matrix used by <code>EdgeSubdivision</code> to subdivide a simplex
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_t">T</code></td>
<td>
<p>array giving a list of color matrices
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_h">H</code>, <code id="mvmesh-geom_+3A_h1">H1</code>, <code id="mvmesh-geom_+3A_h2">H2</code></td>
<td>
<p>array of simplices in the H-representation, H[,,k] is the H-representation for the k-th simplex
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_x">x</code></td>
<td>
<p>matrix with columns giving the points
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_hsingle">Hsingle</code></td>
<td>
<p>matrix giving the H-representation of a single simplex
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_tessellate">tessellate</code></td>
<td>
<p>TRUE to tessellate the resulting intersection
</p>
</td></tr>
<tr><td><code id="mvmesh-geom_+3A_skip.redundant">skip.redundant</code></td>
<td>
<p>TRUE to skip the call to <code>rcdd::redundant</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>AffineTransform</code> computes a new mesh from a previous one, with each vertex v being replaced
by A 
<code>Rotate3D</code> computes a 3D rotation matrix.
</p>
<p><code>Icosahedron</code> returns the vertices of the icosahedron with vertices on the
unit sphere
</p>
<p><code>H2Vrep</code> converts from the half-space (H) representation to the vertex (V) representation
of a simplex.  <code>V2Hrep</code> converts from the V-representation to the H-representation.
It is assumed that all the resulting value are of the same dimension.  If this is not the case,
an error will occur.  To work with such cases, call the function separately for each simplex and save the result in 
different size objects. The one place where this can occur with mvmesh objects is with a
PolarSphere or PolarBall: at the places where polar coordinates are nonunique, vertices
will repeat and the H-representation will have fewer constraints than other simplices.
</p>
<p><code>IntersectMultipleSimplicesV</code> computes the pairwise intersection of two lists of simplices given in the V-representation.
<code>IntersectMultipleSimplicesH</code> computes the pairwise intersection of two lists of simplices given in the H-representation.
<code>Intersect2SimplicesH</code> computes the intersection of two simplices, both specified in the H-representation.
</p>
<p><code>Lift2UnitSimplex</code> reverses the projection from the unit simplex in n-space to the first (n-1) coordinates.  That is,
it 'lifts' each  (n-1) dimensional simplex in R^(n-1) to the unit simplex in R^n by appending an n-th coordinate, with x[n] &lt;- 1-sum(x[1:(n-1)]).
</p>


<h3>Value</h3>

<p><code>MatchRow</code> returns an integer vector, showing which rows of table match v.
If there are no matches, it returns integer(0).
</p>
<p><code>AffineTransform</code> returns an object of class &quot;mvmesh&quot;. 
<code>Rotate2D</code> returns a 2 x 2 rotation matrix, 
<code>Rotate3D</code> returns a 3 x 3 rotation matrix.
</p>
<p><code>EdgeSubdivision</code> computes an edgewise subdivision of a simplex using the method of 
Edelsbrunner and Grayson. The algorithm of Concalves, et. al. was implemented in R.  It is a coordinate free
method. <code>ConvertBase</code> is an internal routine used by the subdivision algorithm.
<code>NumVertices</code> is a utility routine to recursively 
calculate the number of vertices in an edgewise subdivision.
</p>
<p><code>EdgeSubdivMulti</code> is roughly a vectorized version of <code>EdgeSubdivison</code>. It takes a list
of simplices, and performs a k-subdivision of each simplex for function <code>UnitSphere</code> and
related functions.  Since some simplices may share edges, the
same vertex can be occur multiple times, so this function goes through the resulting 
vertices and eliminates repeats.  This function is not meant to be called by an end user; it is not 
guaranteed to be general. 
</p>
<p><code>ConvertBase</code> is an internal function that converts a positve integer 'x' to an 'n' digit base 'b' representation.
<code>NumVertices</code> is an internal function that computes the number of simplices in an 
edgewise subdivision (without doing the subdivision).
<code>PointCoord</code> is an internal function that computes a single vertex of a simplex.  
<code>SimplexCoord</code> is an internal function that computes the coordinates of a simplex 'S' given color matrix 'color'.
<code>SVIFromColor</code> is an internal function that computes the SVI from a starting simplex 'S' and color array 'T'.
</p>
<p>Note that rays and lines are not allowed in <code>V2Hrep</code>; use rcdd funtion <code>makeH</code> directly to use them.
</p>
<p><code>EdgeSubdivision</code> returns a color matrix, a coordinate free representaion of the subdivision.
One generally uses <code>UnitSimplex</code> or <code>UnitBall</code> to get a vertex representation of the subdivision.
</p>
<p><code>EdgeSubdivMulti</code> returns a list of class 'mvmesh'
</p>


<h3>References</h3>

<p>Edelsbrunner and Grayson, Discrete Comput. Geom., Vol 24, 707-719 (2000).
</p>
<p>Goncalves, Palhares, Takahashi, and Mesquita, Algorithm 860: SimpleS &ndash; 
an extension of Freudenthal's simplex subdivision, ACM Trans. Math. Softw., 
32, 609-621 (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Icosahedron( )

T &lt;- EdgeSubdivision( n=2, k=2 )
T

ConvertBase( 10, 2, 6 )  # note order of digits

NumVertices( n=4, k=8, single=FALSE )

S &lt;- rbind( diag(rep(1,2)), c(0,0) ) # solid simplex in 2D
PointCoord( S, T[,,1] )

SimplexCoord( S, T[,,1] )

SVIFromColor( S, T )

S1 &lt;- rbind( c(0,0,0), diag( rep(1,3) ) )
S2 &lt;- rbind( c(1,1,1), diag( rep(1,3) ) )
S3 &lt;- rbind( c(1,1,1), c(0,1,0), c(1,0,0), c(1,1,0) )
S &lt;- array( c(S1,S2,S3), dim=c(4,3,3) )

( H1 &lt;- V2Hrep( S ) )
( S4 &lt;- H2Vrep( H1 ) )

( H2 &lt;- HrepCones( UnitSphere(n=2,k=1)$S )[,,2] )  # cone between 0 &lt;= y &lt;= x, x &gt;= 0
x &lt;- matrix( rnorm(100), ncol=2 )
( i &lt;- SatisfyHrep( x, H2 ) )
x[i,]

(table &lt;- matrix( c(1:12,1:3 ), ncol=3, byrow=TRUE ))
MatchRow( 1:3, table )

## Not run: 
plot( Icosahedron( ), col="green" )

mesh &lt;- SolidSimplex( n=3, k=2 )
plot(mesh, col="blue")
mesh2 &lt;- AffineTransform( mesh, A=Rotate3D( rep(pi/2,3) ), shift=c(1,1,1) ) 
plot(mesh2, new.plot=FALSE, col="red" )



## End(Not run)
</code></pre>

<hr>
<h2 id='mvmesh-methods'>Methods to print and draw mvmesh objects</h2><span id='topic+print.mvmesh'></span><span id='topic+plot.mvmesh'></span><span id='topic+DrawSimplex2d'></span><span id='topic+DrawSimplex3d'></span>

<h3>Description</h3>

<p>Print summary of a mesh and plot 2D and 3D simplices.  The 2D plot routines use the
standard R plots; 3D plot routines use the rgl package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvmesh'
print( x, ... )
## S3 method for class 'mvmesh'
plot( x, new.plot=TRUE, show.points=FALSE, show.edges=TRUE, show.faces=FALSE, 
                     show.labels = FALSE, label.values=NULL, ... )
DrawSimplex2d(S,label,show.labels,mvmesh.type,show.edges=TRUE,show.faces=FALSE,...)
DrawSimplex3d(S,label,show.labels,mvmesh.type,show.edges=TRUE,show.faces=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvmesh-methods_+3A_x">x</code></td>
<td>
<p>an object of class &quot;mvmesh&quot;, usually from one of the functions 
<code>UnitSimplex</code>, <code>SolidSimplex</code>,
<code>UnitSphere</code>, <code>UnitBall</code>, <code>RectangularMesh</code>, etc.
</p>
</td></tr>
<tr><td><code id="mvmesh-methods_+3A_new.plot">new.plot</code></td>
<td>
<p>If TRUE, start a new plot; otherwise add to an existing plot
</p>
</td></tr>
<tr><td><code id="mvmesh-methods_+3A_show.points">show.points</code></td>
<td>
<p>If TRUE, show vertices (use cex= to change size)
</p>
</td></tr>
<tr><td><code id="mvmesh-methods_+3A_show.edges">show.edges</code></td>
<td>
<p>If TRUE, show edges
</p>
</td></tr>
<tr><td><code id="mvmesh-methods_+3A_show.faces">show.faces</code></td>
<td>
<p>If TRUE, fill in solid faces (only works in certain cases); otherwise show edges
</p>
</td></tr>
<tr><td><code id="mvmesh-methods_+3A_show.labels">show.labels</code></td>
<td>
<p>If TRUE, an identifying label will be drawn inside each simplex
</p>
</td></tr>
<tr><td><code id="mvmesh-methods_+3A_label.values">label.values</code></td>
<td>
<p>values to display if show.label=TRUE; defaults to 1,2,3,...
</p>
</td></tr>
<tr><td><code id="mvmesh-methods_+3A_...">...</code></td>
<td>
<p>Optional argument to plot functions to set color, alpha, etc.
</p>
</td></tr>
<tr><td><code id="mvmesh-methods_+3A_label">label</code></td>
<td>
<p>Integer to label current simplex
</p>
</td></tr>
<tr><td><code id="mvmesh-methods_+3A_s">S</code></td>
<td>
<p>a simplex, an n x m matrix with columns S[,1],...,S[,m] giving the vertices
</p>
</td></tr>
<tr><td><code id="mvmesh-methods_+3A_mvmesh.type">mvmesh.type</code></td>
<td>
<p>integer code identifying what type of mesh this is, see the
definition of class &quot;mvmesh&quot; in <code><a href="#topic+mvmesh">mvmesh</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print</code> will print out summary information about a mesh object
</p>
<p><code>plot</code> will plot a mesh, calling <code>DrawSimplex2d</code> or <code>DrawSimplex3d</code> 
to plot a each simplex as appropriate for the dimension.  These routines are meant to
give a basic display; not all rgl capabilities are used.
</p>


<h3>Value</h3>

<p>A plot is drawn, usually nothing is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print( SolidSimplex( n=3, k=2 ) )

## Not run: 

plot( SolidSimplex( n=3, k=2 ), col='red' )


## End(Not run)
</code></pre>

<hr>
<h2 id='mvmesh-package'>Multivariate meshes and histograms in arbitrary dimensions</h2><span id='topic+mvmesh'></span>

<h3>Description</h3>

<p>Define, manipulate and plot multivariate meshes/grids in n-dimensional 
Euclidean space. Multivariate histograms based on these meshes are provided.</p>


<h3>Details</h3>

<p>A range of multivariate problems require working with simplices, spheres, balls, 
rectangular and tubular meshes in dimension n &gt; 1.
The multivariate histogram functions in this package provide routines to tabulate
and display multivariate data.  For example, 
directional histograms tablulate the number of points in a
sequence of directions, see function <code><a href="#topic+histDirectional">histDirectional</a></code>.
Multivariate stable distributions and multivariate extreme value distributions are
defined by a measure
on a sphere or simplex.  Also, simulation of generalized spherical laws involves a triangulation
of some surface.  Numerical quadrature problems on a region or surface in n space require the ability to specify and
work with meshes, e.g. packages <code>SphericalCubature</code> and <code>SimplicialCubature</code>.
Finally, these meshes can be used on their own to create and plot multivariate shapes not in the <code>rgl</code> package.
</p>
<p>A key goal for this package is that the dimension n is not limited to 2 or 3, but in principle can
be arbitrary. Of course, as n increases compute times and required memory will increase 
quickly.  This package uses existing methods from computational geometry that work
in arbitrary dimension.  Several of these functions were written as prototypes, so
getting something to work was the immediate goal, speed was not.
</p>
<p>In this documentation we will use the term grid to mean a collection of points,
usually approximately evenly spread on a solid or surface.  We will use the term mesh to mean both
the grid, and the grouping information that tells which points make up the
simplices that triangulate/tesselate the region.
</p>
<p>Please let me know if you find any mistakes.  I will try to fix bugs promptly.
Constructive comments for improvements are welcome;  
actually implementing any suggestions will be dependent on time constraints.
</p>
<p>This research was supported by an agreement with Cornell University, Operations 
Research &amp; Information Engineering, under contract W911NF-12-1-0385 from the Army 
Research Development and Engineering Command.
</p>
<p>Version history: 
</p>

<ul>
<li><p> 1.0 original package
</p>
</li>
<li><p> 1.1 added functions <code>histDirectionalQuantileThreshold</code>, <br />
<code>histDirectionalAbsoluteeThreshold</code>, <code>HollowTube</code>, <code>SolidTube</code>, <code>Lift2UnitSimplex</code>, <br />
<code>IntersectMultipleSimplicesV</code>, <code>IntersectMultipleSimplicesH</code>, <code>Intersect2SimplicesH</code> <br />
</p>
</li>
<li><p> 1.2 added new functions <code>mvmeshFromSVI</code>, <code>mvmeshfromSimplices</code>, <code>mvmeshFromVertices</code>, <code>rtesselation</code>,
new argument normalize.by.area in <code>histDirectional</code>, new argument label.orthants in <code>histDirectional</code>.  Speed up 3d plots. 
</p>
</li>
<li><p> 1.3 replace <code>rtessellation</code> with more general <code>rmvmesh</code>; add argument 'm' to mvmeshFromSVI; rename
<code>RectangularMesh</code> to <code>SolidRectangle</code>; add <code>HollowRectangle</code>; fix <code>Icosahedron</code> to correctly set 'm'.
</p>
</li>
<li><p> 1.4 fix a bug in <code>IntersectMultipleSimplicesH</code>.
</p>
</li>
<li><p> 1.5 add new return value 'which.simplex' to <code>TallyHrep</code>; for each data point x[,i], it identifies which simplex contains that point; 
minor change in <code>Intersect2SimplicesH</code>; change 'octant' to 'orthant' to correctly describe what happens in all dimensions;
improve <code>IntersectMultipleSimplicesH</code> and <code>Intersect2SimplicesH</code>
</p>
</li>
<li><p> 1.6 correct an unused argument in documentation.
</p>
</li></ul>



<h3>Programming details and notes</h3>

<p>The remainder of this section describes some of the internal details of the package.
It is not needed for the average user.
</p>
<p>Points in n-dimensional space are stored in row vectors as is customary in R. 
All simplices considered in this package are convex. 
A single convex simplex can be described/stored in two ways:
</p>

<ul>
<li><p> A vps x n matrix of (doubles) S; the rows S[1,], S[2, ], etc. are the vertices in R^n.  
The simplex is the convex hull of the vertices. Note: vps stands for 'vertices per simplex'.
</p>
</li>
<li><p> An nV x n matrix of (doubles) vertices V with rows giving the
points in R^n, and an integer vector of length vps called SVI (Simplex Vertex Indices) 
that specifies which vertices make up a simplex.  
</p>
</li></ul>

<p>Both of these descriptions have their uses, so the core functions in this package calculate
both.   To store all the relevant
information needed, the basic functions in this package return an object of class mvmesh.  
An object of class mvmesh has the following fields, extending the definitions
above from a single simplex to a list of simplices:
</p>

<ul>
<li><p> type - a string describing the mesh, e.g. &quot;UnitSimplex&quot; (see table below)
</p>
</li>
<li><p> mvmesh.type - an integer specifying the type of mesh (see table below)
</p>
</li>
<li><p> n - dimension of the space
</p>
</li>
<li><p> m - dimension of the mesh, e.g. the unit sphere in n=3 dimensions is an m=2 dimensional
surface (see table below)
</p>
</li>
<li><p> vps - vertices per simplex, the number of vertices that define a simplex, which must be the
same for all simplices in this mesh (see table below)
</p>
</li>
<li><p> S - an (vps x n x nS) array, with S[ , ,k] specifying the vertices of k-th simplex
</p>
</li>
<li><p> V - an (nV x n) matrix giving the distinct vertices in the list of simplices (repeated vertices in 
S that are on common edges are removed)
</p>
</li>
<li><p> SVI - an integer (vps x nS) matrix which specifies the indices of the vertices that make up the simplices in S.
SVI = Simplex Vertex Indices.  SVI[ ,k] gives the subscripts in the vertex array V that determine the k-th simplex in S
</p>
</li>
<li><p> other fields are specific to the type of mesh.  Generally, they describe the parameters that 
were used to generate the mesh
</p>
</li></ul>


<table>
<tr>
 <td style="text-align: left;">
type                   </td><td style="text-align: center;"> mvmesh.type     </td><td style="text-align: center;"> m   </td><td style="text-align: center;"> vps </td>
</tr>
<tr>
 <td style="text-align: left;">
---------------------  </td><td style="text-align: center;"> ------------- </td><td style="text-align: center;"> ------ </td><td style="text-align: center;"> ------ </td>
</tr>
<tr>
 <td style="text-align: left;">
UnitSimplex           </td><td style="text-align: center;"> 1              </td><td style="text-align: center;"> n-1 </td><td style="text-align: center;"> n    </td>
</tr>
<tr>
 <td style="text-align: left;">
SolidSimplex          </td><td style="text-align: center;"> 2              </td><td style="text-align: center;"> n   </td><td style="text-align: center;"> n+1  </td>
</tr>
<tr>
 <td style="text-align: left;">
UnitSphere, edgewise  </td><td style="text-align: center;"> 3              </td><td style="text-align: center;"> n-1 </td><td style="text-align: center;"> n    </td>
</tr>
<tr>
 <td style="text-align: left;">
UnitSphere, dyadic    </td><td style="text-align: center;"> 4              </td><td style="text-align: center;"> n-1 </td><td style="text-align: center;"> n    </td>
</tr>
<tr>
 <td style="text-align: left;">
UnitBall, edgewise    </td><td style="text-align: center;"> 5              </td><td style="text-align: center;"> n   </td><td style="text-align: center;"> n+1  </td>
</tr>
<tr>
 <td style="text-align: left;">
UnitBall, dyadic      </td><td style="text-align: center;"> 6              </td><td style="text-align: center;"> n   </td><td style="text-align: center;"> n+1  </td>
</tr>
<tr>
 <td style="text-align: left;">
SolidRectangle        </td><td style="text-align: center;"> 7              </td><td style="text-align: center;"> n   </td><td style="text-align: center;"> 2^n  </td>
</tr>
<tr>
 <td style="text-align: left;">
Icosahedron           </td><td style="text-align: center;"> 8              </td><td style="text-align: center;"> 2   </td><td style="text-align: center;"> 3    </td>
</tr>
<tr>
 <td style="text-align: left;">
PolarSphere           </td><td style="text-align: center;"> 9              </td><td style="text-align: center;"> n-1 </td><td style="text-align: center;"> 2^(n-1) </td>
</tr>
<tr>
 <td style="text-align: left;">
PolarBall             </td><td style="text-align: center;"> 10             </td><td style="text-align: center;"> n   </td><td style="text-align: center;"> 2^(n-1) + 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
HollowTube            </td><td style="text-align: center;"> 11             </td><td style="text-align: center;"> n-1 </td><td style="text-align: center;"> 2*(n-1) </td>
</tr>
<tr>
 <td style="text-align: left;">
SolidTube             </td><td style="text-align: center;"> 12             </td><td style="text-align: center;"> n   </td><td style="text-align: center;"> 2*n </td>
</tr>
<tr>
 <td style="text-align: left;">
HollowRectangle       </td><td style="text-align: center;"> 13             </td><td style="text-align: center;"> n   </td><td style="text-align: center;"> 2^(n-1)  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
                                        
<p>There are two generic S3 methods for objects of class mvmesh: print and plot.  
They are basic.  The plot command only works for dimensions n=2 and n=3, is slow,
and has some limitations.  The main goal of this package is to provide grids/meshes in 
arbitrary dimensions, where plots are not possible.
</p>
<p>This package represents points in n dimensional space as 
double precision numbers.  This is convenient, but has potential problems.
For example, determining whether points lie on a line or in a plane or on a sphere may
not be possible with floating point arithmetic because coordinates can't be
represented exactly.  The computational geometry package rcdd on CRAN
gives a way around this by using exact rational arithmetic.  Using rational arithemetic works
fine when points can be expressed as rational numbers, but not for points shifted by an irrational
number or on more general surfaces, e.g. (sqrt(2)/2,sqrt(2)/2) is on the unit circle, but
cannot be represented exactly as a rational number.  Since we want to work in more
situations, we use floating point numbers everywhere, accepting the fact that points may not
be represented exactly.  When the required package <code>rcdd</code> is loaded,
it prints out a warning message about double precision numbers and
encourages the use of rational arithmetic.  I do not know how to suppress this message.
That package warns that using doubles can lead to crashes in certain circumstances.
I don't know what circumstances cause crashes; I have not seen any in the kinds of 
computations done in this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>UnitSimplex( n=2, k=3 )
UnitBall( n=3, k= 2 )

## Not run: 

plot( SolidSimplex( n=2, k=3 ), col="red" )
title("2d solid simplex")

plot( SolidSimplex( n=3, k=4 ) )
plot(  UnitSimplex( n=3,k=4), new.plot=FALSE, col="red", lwd=5 )
title3d("solid and unit simplex in 3d")
rgl.viewpoint( -45, 15)

# two plots on one window
plot( UnitSphere( n=3, k=2 ), col="blue")
mesh2 &lt;- AffineTransform( UnitBall( n=3,k=2 ), A=diag(c(1,1,1)), shift=c(3,0,0) )
plot( mesh2, new.plot=FALSE, col="magenta" )
title3d("unit sphere and ball in 3d")


demo(mvmesh) # shows a range of meshes
demo(mvhist) # shows a range of multivariate histograms

## End(Not run)

</code></pre>

<hr>
<h2 id='mvmeshmisc'>Miscellaneous functions used by/with mvmesh</h2><span id='topic+mvmeshmisc'></span><span id='topic+mvmeshFromSimplices'></span><span id='topic+mvmeshFromSVI'></span><span id='topic+mvmeshFromVertices'></span><span id='topic+mvmeshCombine'></span><span id='topic+uniqueRowsFromDoubleArray'></span>

<h3>Description</h3>

<p>Utilities for working with mvmesh objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvmeshFromSimplices(  S )
mvmeshFromSVI(  V, SVI, m )
mvmeshFromVertices( V )
mvmeshCombine( mesh1, mesh2 )
uniqueRowsFromDoubleArray( A )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvmeshmisc_+3A_s">S</code></td>
<td>
<p>simplices, an (vps x n x nS) array, with S[ , ,k] specifying the vertices of k-th simplex 
</p>
</td></tr>
<tr><td><code id="mvmeshmisc_+3A_v">V</code></td>
<td>
<p>(nV x n) matrix giving the distinct vertices in the list of simplices
</p>
</td></tr>
<tr><td><code id="mvmeshmisc_+3A_svi">SVI</code></td>
<td>
<p>integer (vps x nS) matrix which specifies the indices of the vertices that make up the simplices in S
</p>
</td></tr>
<tr><td><code id="mvmeshmisc_+3A_m">m</code></td>
<td>
<p>integer dimension of the mesh, less than or equal n=dimension of the space
</p>
</td></tr>
<tr><td><code id="mvmeshmisc_+3A_mesh1">mesh1</code>, <code id="mvmeshmisc_+3A_mesh2">mesh2</code></td>
<td>
<p>objects of class &quot;mvmesh&quot;
</p>
</td></tr>
<tr><td><code id="mvmeshmisc_+3A_a">A</code></td>
<td>
<p>a matrix of doubles
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Experimental functions. They allow one to build mvmesh objects manually 
by specifying just simplices (<code>mvmeshFromSimplices</code>), 
or just vertices (<code>mvmeshFromVertices</code>), or vertices and grouping information (<code>mvmeshFromSVI</code>).
<code>mvmeshCombines</code> combines two meshes with the same values of n, m and vps.  The resulting objects can usually be plotted by the plot method, 
but other operations may fail.  In particular, vertices common to both meshes will be repeated.
</p>


<h3>Value</h3>

<p>undocumented
</p>


<h3>Warning</h3>

<p>This is experimental code, and not throughly tested.  Function names, arguments, and what they do may change in the future.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo(mvmeshmisc) 

## End(Not run)

</code></pre>

<hr>
<h2 id='PolarSphere'>Define a mesh on the unit sphere/ball in n-dimensions determined by a polar coordinates grid.
</h2><span id='topic+PolarSphere'></span><span id='topic+PolarBall'></span><span id='topic+Polar2Rectangular'></span><span id='topic+Rectangular2Polar'></span>

<h3>Description</h3>

<p>Subdivide the unit ball or sphere into simplices in
arbitrary dimensions using a rectangular grid on the polar parameterization of the sphere.
</p>
<p>The general n-dimensional polar coordinates to and from rectangular coordinates transformations 
are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PolarSphere(n, breaks=c(rep(4,n-2),8), p = 2, positive.only = FALSE)
PolarBall( n, breaks=c(rep(4,n-2),8), p=2, positive.only=FALSE )
Rectangular2Polar( x )
Polar2Rectangular( r, theta )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PolarSphere_+3A_n">n</code></td>
<td>
<p>Dimension of the space; the Polar sphere is an (n-1) dimensional manifold
</p>
</td></tr>
<tr><td><code id="PolarSphere_+3A_breaks">breaks</code></td>
<td>
<p>specification of the partition of in the angle space theta.  See the definition of
'breaks' in <code><a href="#topic+SolidRectangle">SolidRectangle</a></code>.
</p>
</td></tr>
<tr><td><code id="PolarSphere_+3A_p">p</code></td>
<td>
<p>Power used in the l^p norm; p=2 is the Euclidean norm
</p>
</td></tr>
<tr><td><code id="PolarSphere_+3A_positive.only">positive.only</code></td>
<td>
<p>TRUE means restrict to the positive orthant; FALSE gives the full ball
</p>
</td></tr>
<tr><td><code id="PolarSphere_+3A_r">r</code></td>
<td>
<p>a vector of radii of length m.
</p>
</td></tr>
<tr><td><code id="PolarSphere_+3A_theta">theta</code></td>
<td>
<p>a (n-1) x m matrix of angles.
</p>
</td></tr>
<tr><td><code id="PolarSphere_+3A_x">x</code></td>
<td>
<p> (n x m) matrix, with column j being the point in n-dimensional space.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PolarSphere</code> computes an approximation to the unit sphere using a rectangular
grid in the polar angle space.
<code>PolarBall</code> uses a partition of the polar sphere and joins those simplices to 
the origin to approximately partition the unit ball.
<code>LpNorm</code> computes the l^p norm of each columns of <code>x</code>.
</p>
<p><code>Polar2Rectangular</code> and <code>Rectangular2Polar</code> convert between the polar coordinate
representation  (r,theta[1],...,theta[n-1]) and the rectangular coordinates (x[1],...,x[n]).
</p>
<p>n dimensional polar coordinates are given by the following: <br />
rectangular x=(x[1],...,x[n])  corresponds to
polar  (r,theta[1],...,theta[n-1]) by <br />
x[1]  = r*cos(theta[1]) <br />
x[2]  = r*sin(theta[1])*cos(theta[2]) <br />
x[3]  = r*sin(theta[1])*sin(theta[2])*cos(theta[3]) <br />
... <br />
x[n-1]= r*sin(theta[1])*sin(theta[2])*...*sin(theta[n-2])*cos(theta[n-1]) <br />
x[n]  = r*sin(theta[1])*sin(theta[2])*...*sin(theta[n-2])*sin(theta[n-1]) <br />
</p>
<p>Here theta[1],...,theta[n-2] in [0,pi), and theta[n-1] in [0,2*pi). 
This is the parameterization described in the Wikipedia webpage for &quot;n-sphere&quot;.
Note that this is NOT a 1-1 transformation: when theta[1]=0, it follows
that x[2]=x[3]=...=x[n]=0.  This is analagous to all longitude lines going
through the north pole in standard 3d spherical coordinates.
</p>
<p>For multivariate integration, the Jacobian of the above tranformation
is J(theta) = r^(n-1) * prod( sin(theta[1:(n-2)])^((n-2):1) );
note that theta[n-1] does not appear in the Jacobian.
</p>


<h3>Value</h3>

<p><code>PolarSphere</code> and <code>PolarBall</code> return an object of class 
&quot;mvmesh&quot;  as described in <code><a href="#topic+mvmesh">mvmesh</a></code>.
<code>Polar2Rectangular</code> returns an (n x m) matrix of rectangular coordinates.
<code>Rectangular2Polar</code> returns a list with fields:
</p>
<table role = "presentation">
<tr><td><code>r</code></td>
<td>
<p>a vector of length m containing the radii</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>an (n x m) matrix of angles</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>PolarSphere(  n=3, breaks=4)
PolarBall( n=3, breaks=4 )

(x &lt;- matrix( 1:10, ncol=2 ))
(a &lt;- Rectangular2Polar( x ))
Polar2Rectangular( a$r, a$theta )

(x &lt;- matrix( 1:12, ncol=4 ))
(a &lt;- Rectangular2Polar( x ))
Polar2Rectangular( a$r, a$theta )

## Not run: 
plot( PolarSphere( n=2, breaks=8 ) )
plot( PolarBall( n=2, breaks=8 ) )

plot( PolarSphere( n=3, breaks=c(4,8) ) )
plot( PolarBall( n=3, breaks=c(4,8) ) )

## End(Not run)

</code></pre>

<hr>
<h2 id='rmvmesh'>Simulate from a mesh</h2><span id='topic+rmvmesh'></span>

<h3>Description</h3>

<p>Simulate from a mvmesh object</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvmesh( n, mesh, weights=rep(1,ncol(mesh$SVI) ) )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmvmesh_+3A_mesh">mesh</code></td>
<td>
<p>object of class &quot;mvmesh&quot;
</p>
</td></tr>
<tr><td><code id="rmvmesh_+3A_n">n</code></td>
<td>
<p>number of vectors to simulate
</p>
</td></tr>
<tr><td><code id="rmvmesh_+3A_weights">weights</code></td>
<td>
<p>weights used for simulation
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rmvmesh</code> allows you to sample from an mvmesh object, simplex j is sampled with probability weights[j]. Note that if the simplices are of
different sizes, and the weights are uniform, this will result in uniform sampling among the simplices, but different densities on different faces.
See the example below with alternating weights.  If you want to get a uniform density, set the weights equal to the <code>m</code> dimensional volume of the 
simplices that make up the meshes.
</p>
<p><code>rmvmesh</code> works for any mesh where the <code>m</code> dimensional simplices are convex 
combinations of <code>(m+1)</code> vertices i.e. <code>vps=m+1</code>.
This works whatever the dimension of the embedding space is, and whether or not things have been rotated, scaled or shifted by <code>AffineTransform</code>.
It also works with an unaltered SolidRectangle or HollowRectangle.  
<code>mvmesh</code> does not currently work with mvmesh objects of type PolarSphere, PolarBall, HollowTube, or SolidTube; nor does it work with rectangles that have
been altered  by <code>AffineTransform</code>.
</p>
<p>Note that <code>rmvmesh</code> samples from the mesh, not from the idealized object.  In particular, in the example below with a unit sphere,
the sampled points are from the tessellation approximation to the sphere, not from the unit sphere itself.  So (with probability one), all
points will have length less than 1.
</p>


<h3>Value</h3>

<p>A matrix of values x: x[1, ],x[2, ],...,x[n, ] are vectors sampled from the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sphere &lt;- UnitSphere( n=3, k=2 )
plot(sphere)
x &lt;- rmvmesh( 1000, sphere )
points3d( x, col='red' )

box &lt;- HollowRectangle( a=c(0,2,-1), b=c(1,5,3), breaks=3 )
plot(box)
x &lt;- rmvmesh( 500, box )
points3d( x, col='blue', size=5 )


plot(box)
nS &lt;- ncol(box$SVI) # number of simplices in box
weights &lt;- rep( c(0,1), nS/2 )  # alternating 0,1 weights
x &lt;- rmvmesh( 10000, box, weights )
points3d( x, col='green', size=5 )


## End(Not run)
</code></pre>

<hr>
<h2 id='UnitSimplex'>Define a mesh on the unit simplex or the canonical simplex
</h2><span id='topic+UnitSimplex'></span><span id='topic+SolidSimplex'></span>

<h3>Description</h3>

<p>Defines an equal area/volume subdivision of the unit simplex and the canonical simplex in R^n.
The unit simplex is the (n-1) dimensional simplex with
vertices (1,0,0,...,0), (0,1,0,...,0), ...,(0,0,0,...,1), i.e. all x &gt;= 0
with sum(x)==1.
</p>
<p>The solid simplex is the n dimensional simplex with
vertices (1,0,0,...,0), (0,1,0,...,0), ...,(0,0,0,...,1), and (0,0,...,0),
i.e. all x &gt;= 0 with sum(x) &lt;= 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnitSimplex(n, k )
SolidSimplex( n, k )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UnitSimplex_+3A_n">n</code></td>
<td>
<p>dimension of the space
</p>
</td></tr>
<tr><td><code id="UnitSimplex_+3A_k">k</code></td>
<td>
<p>number of subdivisions
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>EdgeSubdivision</code> is called to
do a k-subdivision of each edge, and then that output is converted to a matrix of vertices.
</p>


<h3>Value</h3>

<p>an object of class &quot;mvmesh&quot; as described in <code><a href="#topic+mvmesh">mvmesh</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
UnitSimplex( n=2, k=3 )
SolidSimplex( n=2, k=3 ) 

UnitSimplex( n=3, k=2 )
SolidSimplex( n=3, k=2 )

UnitSimplex( n=5, k=4 )
SolidSimplex( n=5, k=4 )

## Not run: 
plot( UnitSimplex( n=2, k=3 ) )
plot( SolidSimplex( n=2, k=3 ) )

plot( UnitSimplex( n=3, k=2 ) )
plot( SolidSimplex( n=3, k=2 ) )


## End(Not run)
</code></pre>

<hr>
<h2 id='UnitSphere'>Define a mesh on a unit ball in n-dimensions
</h2><span id='topic+UnitSphere'></span><span id='topic+UnitSphereDyadic'></span><span id='topic+UnitSphereEdgewise'></span><span id='topic+UnitBall'></span><span id='topic+LpNorm'></span>

<h3>Description</h3>

<p>Subdivide the unit ball or sphere into approximately equal simplices in
arbitrary dimenions.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnitSphere(n, k, method = "dyadic", p = 2, positive.only = FALSE)
UnitSphereEdgewise(n, k, p, positive.only)
UnitSphereDyadic(n, k, start = "diamond", p, positive.only)
UnitBall( n, k, method="dyadic", p=2, positive.only=FALSE )
LpNorm(x, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UnitSphere_+3A_n">n</code></td>
<td>
<p>Dimension of the space; the unit sphere is an (n-1) dimensional manifold
</p>
</td></tr>
<tr><td><code id="UnitSphere_+3A_k">k</code></td>
<td>
<p>Number of subdivisions
</p>
</td></tr>
<tr><td><code id="UnitSphere_+3A_method">method</code></td>
<td>
<p>&quot;dyadic&quot; or &quot;edgewise&quot;: the former recursively subdivides the sphere to get
a more uniform grid; the latter uses a faster method using one edgewise subdivision.
</p>
</td></tr>
<tr><td><code id="UnitSphere_+3A_p">p</code></td>
<td>
<p>Power used in the l^p norm; p=2 is the Euclidean norm
</p>
</td></tr>
<tr><td><code id="UnitSphere_+3A_positive.only">positive.only</code></td>
<td>
<p>TRUE means restrict to the positive orthant; FALSE gives the full ball
</p>
</td></tr>
<tr><td><code id="UnitSphere_+3A_start">start</code></td>
<td>
<p>starting shape: &quot;diamond&quot; or &quot;icosahedron&quot;
</p>
</td></tr>
<tr><td><code id="UnitSphere_+3A_x">x</code></td>
<td>
<p>Matrix of points in n-dimensions;  each column is a point in R^n
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>UnitSphere</code> computes a hyperspherical triangle approximation to the unit sphere.
It calls either <code>UnitSphereDyadic</code> or <code>UnitSphereEdgewise</code>
based on 'method'.  Both work by subdividing the first orthant, and then rotating that
subdivision around to other orthants.   This is important for some uses of these functions; it
guarantees that all vertices of a simplex are in a single orthant.
Note that 'k' has a different meaning for the different methods.  When
method=&quot;dyadic&quot;, k specifies the number of dyadic subdivisions.  When method=&quot;edgewise&quot;, 
k specifies the number of subdivisions as in <code><a href="#topic+UnitSimplex">UnitSimplex</a></code>, which is then
projected outward to the unit sphere.  So when n=2, a dyadic subdivision with k=2 will
result in 16 edges, whereas an edgewise subdivions with k=2 results in 8 edges.
</p>
<p><code>UnitBall</code> computes an approximate simplicial approximation to the unit ball.  Specifically,
it generates cones with one vertex at the origin and the other vertices on the surface
of the unit sphere; these later vertices are from <code>UnitSphere</code>.  If k is large, these cones
will be very narrow/thin. 
</p>


<h3>Value</h3>

<p>an object of class &quot;mvmesh&quot;  as described in <code><a href="#topic+mvmesh">mvmesh</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>UnitSphere( n=2, k=2, method="edgewise", positive.only=TRUE )
UnitSphere( n=2, k=2, method="edgewise" )

UnitSphere( n=3, k=2, method="edgewise", positive.only=TRUE )
UnitSphere( n=3, k=2, method="edgewise" )

UnitBall( n=2, k=2, method="edgewise", positive.only=TRUE )
UnitBall( n=2, k=2, method="edgewise" )

UnitSphere( n=3, k=2, method="dyadic", positive.only=TRUE )
UnitSphere( n=3, k=2, method="dyadic" )

UnitBall( n=3, k=2, method="dyadic", positive.only=TRUE )
UnitBall( n=3, k=2, method="dyadic" )

UnitSphere(  n=3, k=2 )
UnitBall( n=3, k=2 )

x &lt;- c(3,-1,2)
LpNorm( x, p=2 )

## Not run: 
plot( UnitSphere(  n=3, k=2 ), show.label=TRUE )
plot( UnitBall( n=3, k=2 ) )


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
