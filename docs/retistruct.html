<!DOCTYPE html><html lang="en-GB"><head><title>Help for package retistruct</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {retistruct}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AnnotatedOutline'><p>Class containing functions and data relating to annotating outlines</p></a></li>
<li><a href='#azel.to.sphere.colatitude'><p>Convert azimuth-elevation coordinates to spherical coordinates</p></a></li>
<li><a href='#azimuthal.conformal'><p>Azimuthal conformal or stereographic or Wulff projection</p></a></li>
<li><a href='#azimuthal.equalarea'><p>Lambert azimuthal equal area projection</p></a></li>
<li><a href='#azimuthal.equidistant'><p>Azimuthal equidistant projection</p></a></li>
<li><a href='#bary.to.sphere.cart'><p>Convert barycentric coordinates of points in mesh on sphere</p>
to cartesian coordinates</a></li>
<li><a href='#central.angle'><p>Central angle between two points on a sphere</p></a></li>
<li><a href='#checkDatadir'><p>Check the whether  directory contains valid data</p></a></li>
<li><a href='#circle'><p>Return points on the unit circle</p></a></li>
<li><a href='#compute.intersections.sphere'><p>Find the intersection of a plane with edges of triangles on</p>
a sphere</a></li>
<li><a href='#compute.kernel.estimate'><p>Kernel estimate over grid</p></a></li>
<li><a href='#CountSet'><p>Subclass of <code>FeatureSet</code> to represent counts centred</p>
on points</a></li>
<li><a href='#create.polar.cart.grid'><p>Create grid on projection of hemisphere onto plane</p></a></li>
<li><a href='#csv.read.dataset'><p>Read a retinal dataset in CSV format</p></a></li>
<li><a href='#dE'><p>The deformation energy gradient function</p></a></li>
<li><a href='#depthplot3D'><p>Draw the &quot;flat&quot; outline in 3D with depth information</p></a></li>
<li><a href='#directories'><p>File system directories used by shinyFiles</p></a></li>
<li><a href='#E'><p>The deformation energy function</p></a></li>
<li><a href='#Ecart'><p>The deformation energy function</p></a></li>
<li><a href='#f'><p>Piecewise smooth function used in area penalty</p></a></li>
<li><a href='#Fcart'><p>The deformation energy gradient function</p></a></li>
<li><a href='#FeatureSet'><p>Superclass containing functions and data relating to sets of</p>
features in flat <code>Outline</code>s</a></li>
<li><a href='#FeatureSetCommon'><p>Class containing functionality common to <code>FeatureSet</code>s and</p>
<code>ReconstructedFeatureSet</code>s</a></li>
<li><a href='#fire'><p>The FIRE algorithm</p></a></li>
<li><a href='#flatplot'><p>Plot &quot;flat&quot; (unreconstructed) representation of outline</p></a></li>
<li><a href='#flatplot.AnnotatedOutline'><p>Flat plot of AnnotatedOutline</p></a></li>
<li><a href='#flatplot.Outline'><p>Flat plot of outline</p></a></li>
<li><a href='#flatplot.ReconstructedOutline'><p>Flat plot of reconstructed outline</p></a></li>
<li><a href='#flatplot.StitchedOutline'><p>Flat plot of AnnotatedOutline</p></a></li>
<li><a href='#flatplot.TriangulatedOutline'><p>Plot flat <code>TriangulatedOutline</code>.</p></a></li>
<li><a href='#flipped.triangles'><p>Determine indices of triangles that are flipped</p></a></li>
<li><a href='#flipped.triangles.cart'><p>Determine indices of triangles that are flipped</p></a></li>
<li><a href='#fp'><p>Piecewise smooth function used in area penalty</p></a></li>
<li><a href='#Fragment'><p>Construct an outline object. This sanitises the input points</p>
<code>P</code>, as described below.</a></li>
<li><a href='#identity.transform'><p>The identity transformation</p></a></li>
<li><a href='#idt.read.dataset'><p>Read one of the Thompson lab's retinal datasets</p></a></li>
<li><a href='#ijroi.read.dataset'><p>Read a retinal dataset in IJROI format</p></a></li>
<li><a href='#ijroimulti.read.dataset'><p>Read a retinal dataset in IJROI format</p></a></li>
<li><a href='#interpolate.image'><p>Interpolate values in image</p></a></li>
<li><a href='#invert.sphere'><p>Invert sphere about its centre</p></a></li>
<li><a href='#invert.sphere.to.hemisphere'><p>Invert sphere to hemisphere</p></a></li>
<li><a href='#karcher.mean.sphere'><p>Karcher mean on the sphere</p></a></li>
<li><a href='#kde.compute.concentration'><p>Find the optimal concentration for a set of data</p></a></li>
<li><a href='#kde.fhat'><p>Kernel density estimate on sphere using Fisherian density</p>
with polar coordinates</a></li>
<li><a href='#kde.fhat.cart'><p>Kernel density estimate on sphere using Fisherian density</p>
with Cartesian coordinates</a></li>
<li><a href='#kde.L'><p>Estimate of the log likelihood of the points mu given a</p>
particular value of the concentration kappa</a></li>
<li><a href='#kr.compute.concentration'><p>Find the optimal concentration for a set of data</p></a></li>
<li><a href='#kr.sscv'><p>Cross validation estimate of the least squares error of the</p>
points mu given a particular value of the concentration kappa</a></li>
<li><a href='#kr.yhat'><p>Kernel regression on sphere using Fisherian density with</p>
polar coordinates</a></li>
<li><a href='#kr.yhat.cart'><p>Kernel regression on sphere using Fisherian density with</p>
Cartesian coordinates</a></li>
<li><a href='#LandmarkSet'><p>Subclass of <code>FeatureSet</code> to represent points</p></a></li>
<li><a href='#line.line.intersection'><p>Determine intersection between two lines</p></a></li>
<li><a href='#list_to_R6'><p>Convert an list created by R6_to_list() into an R6 object.</p></a></li>
<li><a href='#list.datasets'><p>List datasets underneath a directory</p></a></li>
<li><a href='#lvsLplot'><p>Plot the fractional change in length of mesh edges</p></a></li>
<li><a href='#morph.dataset.to.parabola'><p>Morph a flat dataset to a parabola for testing purposes</p></a></li>
<li><a href='#name.list'><p>Return a new version of the list in which any unnamed elements</p>
have been given standardised names</a></li>
<li><a href='#normalise.angle'><p>Bring angle into range</p></a></li>
<li><a href='#orthographic'><p>Orthographic projection</p></a></li>
<li><a href='#Outline'><p>Class containing basic information about flat outlines</p></a></li>
<li><a href='#OutlineCommon'><p>Class containing functionality common to flat and reconstructed outlines</p></a></li>
<li><a href='#panlabel'><p>Ancillary function to place labels</p></a></li>
<li><a href='#parabola.arclength'><p>Arc length of a parabola y=x^2/4f</p></a></li>
<li><a href='#parabola.invarclength'><p>Inverse arc length of a parabola y=x^2/4f</p></a></li>
<li><a href='#parse.dependencies'><p>Parse dependencies</p></a></li>
<li><a href='#PathOutline'><p>Add point fullcuts to the outline</p></a></li>
<li><a href='#PointSet'><p>Subclass of <code>FeatureSet</code> to represent points</p></a></li>
<li><a href='#polar.cart.to.sphere.spherical'><p>Convert polar projection in Cartesian coordinates to</p>
spherical coordinates on sphere</a></li>
<li><a href='#polartext'><p>Put text on the polar plot</p></a></li>
<li><a href='#projection'><p>Plot projection of a reconstructed outline</p></a></li>
<li><a href='#projection.ReconstructedOutline'><p>Projection of a reconstructed outline</p></a></li>
<li><a href='#projection.RetinalReconstructedOutline'><p>Plot projection of reconstructed dataset</p></a></li>
<li><a href='#R6_to_list'><p>Convert an R6 object into a list, ignoring functions and</p>
environments</a></li>
<li><a href='#Rcart'><p>Restore points to spherical manifold</p></a></li>
<li><a href='#read.datacounts'><p>Read data counts in CSV format</p></a></li>
<li><a href='#read.datapoints'><p>Read data points in CSV format</p></a></li>
<li><a href='#ReconstructedCountSet'><p>Class containing functions and data to map CountSets to</p>
ReconstructedOutlines</a></li>
<li><a href='#ReconstructedFeatureSet'><p>Class containing functions and data to map FeatureSets to</p>
ReconstructedOutlines</a></li>
<li><a href='#ReconstructedLandmarkSet'><p>Class containing functions and data to map LandmarkSets to</p>
ReconstructedOutlines</a></li>
<li><a href='#ReconstructedOutline'><p>Class containing functions to reconstruct StitchedOutlines</p>
and store the associated data</a></li>
<li><a href='#ReconstructedPointSet'><p>Class containing functions and data to map PointSets to</p>
ReconstructedOutlines</a></li>
<li><a href='#remove.identical.consecutive.rows'><p>Remove identical consecutive rows from a matrix</p></a></li>
<li><a href='#remove.intersections'><p>Remove intersections between adjacent segments in a closed</p>
path</a></li>
<li><a href='#report'><p>Reporting utility function</p></a></li>
<li><a href='#RetinalOutline'><p>Class containing functions and data relating to retinal outlines</p></a></li>
<li><a href='#RetinalReconstructedOutline'><p>A version of ReconstructedOutline that is specific to</p>
retinal datasets</a></li>
<li><a href='#retistruct'><p>Start the Retistruct GUI</p></a></li>
<li><a href='#retistruct.batch'><p>Batch operation using the parallel package</p></a></li>
<li><a href='#retistruct.batch.export.matlab'><p>Export data from reconstruction data files to MATLAB</p></a></li>
<li><a href='#retistruct.batch.figures'><p>Plot figures for a batch of reconstructions</p></a></li>
<li><a href='#retistruct.batch.get.titrations'><p>Get titrations from a directory of reconstructions</p></a></li>
<li><a href='#retistruct.batch.plot.titrations'><p>Plot titrations</p></a></li>
<li><a href='#retistruct.batch.summary'><p>Extract summary data for a batch of reconstructions</p></a></li>
<li><a href='#retistruct.check.markup'><p>Retistruct check markup</p></a></li>
<li><a href='#retistruct.cli'><p>Process a dataset with a time limit</p></a></li>
<li><a href='#retistruct.cli.figure'><p>Print a figure to file</p></a></li>
<li><a href='#retistruct.cli.process'><p>Process a dataset, saving results to disk</p></a></li>
<li><a href='#retistruct.export.matlab'><p>Save reconstruction data in MATLAB format</p></a></li>
<li><a href='#retistruct.read.dataset'><p>Read a retinal dataset</p></a></li>
<li><a href='#retistruct.read.markup'><p>Read the markup data</p></a></li>
<li><a href='#retistruct.read.recdata'><p>Read the reconstruction data from file</p></a></li>
<li><a href='#retistruct.reconstruct'><p>Reconstruct a retina</p></a></li>
<li><a href='#retistruct.save.markup'><p>Save markup</p></a></li>
<li><a href='#retistruct.save.recdata'><p>Save reconstruction data</p></a></li>
<li><a href='#rotate.axis'><p>Rotate axis of sphere</p></a></li>
<li><a href='#server'><p>Retistruct Shiny Server</p></a></li>
<li><a href='#simplifyFragment'><p>Simplify an outline object by removing short edges</p></a></li>
<li><a href='#simplifyOutline'><p>Simplify an outline object by removing short edges</p></a></li>
<li><a href='#sinusoidal'><p>Sinusoidal projection</p></a></li>
<li><a href='#sphere.cart.to.sphere.dualwedge'><p>Convert from Cartesian to &lsquo;dual-wedge&rsquo; coordinates</p></a></li>
<li><a href='#sphere.cart.to.sphere.spherical'><p>Convert from Cartesian to spherical coordinates</p></a></li>
<li><a href='#sphere.cart.to.sphere.wedge'><p>Convert from Cartesian to 'wedge' coordinates</p></a></li>
<li><a href='#sphere.spherical.to.polar.cart'><p>Convert spherical coordinates on sphere to  polar</p>
projection in Cartesian coordinates</a></li>
<li><a href='#sphere.spherical.to.sphere.cart'><p>Convert from spherical to Cartesian coordinates</p></a></li>
<li><a href='#sphere.tri.area'><p>Area of triangles on a sphere</p></a></li>
<li><a href='#sphere.wedge.to.sphere.cart'><p>Convert from 'wedge' to Cartesian coordinates</p></a></li>
<li><a href='#spherical.to.polar.area'><p>Convert latitude on sphere to radial variable in</p>
area-preserving projection</a></li>
<li><a href='#sphericalplot'><p>Spherical plot of reconstructed outline</p></a></li>
<li><a href='#sphericalplot.ReconstructedOutline'><p>Spherical plot of reconstructed outline</p></a></li>
<li><a href='#StitchedOutline'><p>Class containing functions and data relating to Stitching outlines</p></a></li>
<li><a href='#strain.colours'><p>Generate colours for strain plots</p></a></li>
<li><a href='#stretchMesh'><p>Stretch mesh</p></a></li>
<li><a href='#tri.area'><p>Area of triangles on a plane</p></a></li>
<li><a href='#tri.area.signed'><p>&quot;Signed area&quot; of triangles on a plane</p></a></li>
<li><a href='#TriangulatedFragment'><p>Class to triangulate Fragments</p></a></li>
<li><a href='#TriangulatedOutline'><p>Class containing functions and data relating to Triangulation</p></a></li>
<li><a href='#ui'><p>Retistruct UI</p></a></li>
<li><a href='#vecnorm'><p>Vector norm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Retinal Reconstruction Program</td>
</tr>
<tr>
<td>Description:</td>
<td>Reconstructs retinae by morphing a flat surface with cuts
    (a dissected flat-mount retina) onto a curvilinear surface (the
    standard retinal shape). It can estimate the position of a point
    on the intact adult retina to within 8 degrees of arc (3.6% of
    nasotemporal axis). The coordinates in reconstructed retinae can
    be transformed to visuotopic coordinates. For more details see
    Sterratt, D. C., Lyngholm, D., Willshaw, D. J. and Thompson, I. D.
    (2013) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1002921">doi:10.1371/journal.pcbi.1002921</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://davidcsterratt.github.io/retistruct/">http://davidcsterratt.github.io/retistruct/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidcsterratt/retistruct/issues">https://github.com/davidcsterratt/retistruct/issues</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-07</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreign, RImageJROI, png, ttutils, sp, geometry (&ge; 0.4.3),
RTriangle (&ge; 1.6-0.9), rgl, R.matlab, R6, tiff, shiny,
shinyjs, shinyFiles, bslib, fs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, testthat</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-07 23:13:14 UTC; dcs</td>
</tr>
<tr>
<td>Author:</td>
<td>David C. Sterratt [aut, cre, cph],
  Daniel Lyngholm [aut, cph],
  Jan Okul [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David C. Sterratt &lt;david.c.sterratt@ed.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-10 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AnnotatedOutline'>Class containing functions and data relating to annotating outlines</h2><span id='topic+AnnotatedOutline'></span>

<h3>Description</h3>

<p>An AnnotatedOutline contains a function to annotate
tears on the outline.
</p>


<h3>Value</h3>

<p>AnnotatedOutline object, with extra fields for tears
latitude of rim <code>phi0</code> and index of fixed point <code>i0</code>.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+OutlineCommon">retistruct::OutlineCommon</a></code> -&gt; <code><a href="#topic+Outline">retistruct::Outline</a></code> -&gt; <code><a href="#topic+PathOutline">retistruct::PathOutline</a></code> -&gt; <code>AnnotatedOutline</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>tears</code></dt><dd><p>Matrix in which each row represents a cut by the
indices into the outline points of the apex (<code>V0</code>) and
backward (<code>VB</code>) and forward (<code>VF</code>) points</p>
</dd>
<dt><code>fullcuts</code></dt><dd><p>Matrix in which each row represents a cut by the
indices into the outline points of the apex (<code>V0</code>) and
backward (<code>VB</code>) and forward (<code>VF</code>) points</p>
</dd>
<dt><code>phi0</code></dt><dd><p>rim angle in radians</p>
</dd>
<dt><code>lambda0</code></dt><dd><p>longitude of fixed point</p>
</dd>
<dt><code>i0</code></dt><dd><p>index of fixed point</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AnnotatedOutline-new"><code>AnnotatedOutline$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-labelTearPoints"><code>AnnotatedOutline$labelTearPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-whichTear"><code>AnnotatedOutline$whichTear()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-getTear"><code>AnnotatedOutline$getTear()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-getTears"><code>AnnotatedOutline$getTears()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-computeTearRelationships"><code>AnnotatedOutline$computeTearRelationships()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-addTear"><code>AnnotatedOutline$addTear()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-removeTear"><code>AnnotatedOutline$removeTear()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-checkTears"><code>AnnotatedOutline$checkTears()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-setFixedPoint"><code>AnnotatedOutline$setFixedPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-getFixedPoint"><code>AnnotatedOutline$getFixedPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-getRimSet"><code>AnnotatedOutline$getRimSet()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-getBoundarySets"><code>AnnotatedOutline$getBoundarySets()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-ensureFixedPointInRim"><code>AnnotatedOutline$ensureFixedPointInRim()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-labelFullCutPoints"><code>AnnotatedOutline$labelFullCutPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-addFullCut"><code>AnnotatedOutline$addFullCut()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-whichFullCut"><code>AnnotatedOutline$whichFullCut()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-removeFullCut"><code>AnnotatedOutline$removeFullCut()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-computeFullCutRelationships"><code>AnnotatedOutline$computeFullCutRelationships()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-getFullCut"><code>AnnotatedOutline$getFullCut()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-getFullCuts"><code>AnnotatedOutline$getFullCuts()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-addPoints"><code>AnnotatedOutline$addPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-getRimLengths"><code>AnnotatedOutline$getRimLengths()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnotatedOutline-clone"><code>AnnotatedOutline$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="clearFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-clearFeatureSets'><code>retistruct::OutlineCommon$clearFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSet"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSet'><code>retistruct::OutlineCommon$getFeatureSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSetTypes"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSetTypes'><code>retistruct::OutlineCommon$getFeatureSetTypes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSets'><code>retistruct::OutlineCommon$getFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getIDs"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getIDs'><code>retistruct::OutlineCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="addFeatureSet"><a href='../../retistruct/html/Outline.html#method-Outline-addFeatureSet'><code>retistruct::Outline$addFeatureSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getDepth"><a href='../../retistruct/html/Outline.html#method-Outline-getDepth'><code>retistruct::Outline$getDepth()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragment"><a href='../../retistruct/html/Outline.html#method-Outline-getFragment'><code>retistruct::Outline$getFragment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentIDs'><code>retistruct::Outline$getFragmentIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentIDsFromPointIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentIDsFromPointIDs'><code>retistruct::Outline$getFragmentIDsFromPointIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentPointIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentPointIDs'><code>retistruct::Outline$getFragmentPointIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentPoints"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentPoints'><code>retistruct::Outline$getFragmentPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getImage"><a href='../../retistruct/html/Outline.html#method-Outline-getImage'><code>retistruct::Outline$getImage()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getOutlineLengths"><a href='../../retistruct/html/Outline.html#method-Outline-getOutlineLengths'><code>retistruct::Outline$getOutlineLengths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getOutlineSet"><a href='../../retistruct/html/Outline.html#method-Outline-getOutlineSet'><code>retistruct::Outline$getOutlineSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPoints"><a href='../../retistruct/html/Outline.html#method-Outline-getPoints'><code>retistruct::Outline$getPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPointsScaled"><a href='../../retistruct/html/Outline.html#method-Outline-getPointsScaled'><code>retistruct::Outline$getPointsScaled()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPointsXY"><a href='../../retistruct/html/Outline.html#method-Outline-getPointsXY'><code>retistruct::Outline$getPointsXY()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="mapFragment"><a href='../../retistruct/html/Outline.html#method-Outline-mapFragment'><code>retistruct::Outline$mapFragment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="mapPids"><a href='../../retistruct/html/Outline.html#method-Outline-mapPids'><code>retistruct::Outline$mapPids()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="replaceImage"><a href='../../retistruct/html/Outline.html#method-Outline-replaceImage'><code>retistruct::Outline$replaceImage()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="PathOutline" data-id="insertPoint"><a href='../../retistruct/html/PathOutline.html#method-PathOutline-insertPoint'><code>retistruct::PathOutline$insertPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="PathOutline" data-id="nextPoint"><a href='../../retistruct/html/PathOutline.html#method-PathOutline-nextPoint'><code>retistruct::PathOutline$nextPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="PathOutline" data-id="stitchSubpaths"><a href='../../retistruct/html/PathOutline.html#method-PathOutline-stitchSubpaths'><code>retistruct::PathOutline$stitchSubpaths()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AnnotatedOutline-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$new(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters to <code><a href="#topic+PathOutline">PathOutline</a></code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-AnnotatedOutline-labelTearPoints"></a>



<h4>Method <code>labelTearPoints()</code></h4>

<p>Label a set of three unlabelled points supposed
to refer to the apex and vertices of a tear with the <code>V0</code>
(Apex), <code>VF</code> (forward vertex) and <code>VB</code> (backward vertex) labels.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$labelTearPoints(pids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pids</code></dt><dd><p>the vector of three indices</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of indices labelled with <code>V0</code>, <code>VF</code> and <code>VB</code>
</p>


<hr>
<a id="method-AnnotatedOutline-whichTear"></a>



<h4>Method <code>whichTear()</code></h4>

<p>Return index of tear in an AnnotatedOutline in which a point appears
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$whichTear(pid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pid</code></dt><dd><p>ID of point</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ID of tear
</p>


<hr>
<a id="method-AnnotatedOutline-getTear"></a>



<h4>Method <code>getTear()</code></h4>

<p>Return indices of tear in AnnotatedOutline
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$getTear(tid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tid</code></dt><dd><p>Tear ID, which can be returned from <code>whichTear()</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of three point IDs, labelled with <code>V0</code>,
<code>VF</code> and <code>VB</code>
</p>


<hr>
<a id="method-AnnotatedOutline-getTears"></a>



<h4>Method <code>getTears()</code></h4>

<p>Get tears
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$getTears()</pre></div>



<h5>Returns</h5>

<p>Matrix of tears
</p>


<hr>
<a id="method-AnnotatedOutline-computeTearRelationships"></a>



<h4>Method <code>computeTearRelationships()</code></h4>

<p>Compute the parent relationships for a potential
set of tears. The function throws an error if tears overlap.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$computeTearRelationships(tears = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tears</code></dt><dd><p>Matrix containing columns <code>V0</code> (Apices of tears)
<code>VB</code> (Backward vertices of tears) and <code>VF</code> (Forward
vertices of tears)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List containing
</p>

<dl>
<dt><code>Rset</code></dt><dd><p>the set of points on the rim</p>
</dd>
<dt><code>TFset</code></dt><dd><p>list containing indices of points in each forward tear</p>
</dd>
<dt><code>TBset</code></dt><dd><p>list containing indices of points in each backward tear</p>
</dd>
<dt><code>h</code></dt><dd><p>correspondence mapping</p>
</dd>
<dt><code>hf</code></dt><dd><p>correspondence mapping in forward direction for
points on boundary</p>
</dd>
<dt><code>hb</code></dt><dd><p>correspondence mapping in backward direction for
points on boundary</p>
</dd>
</dl>



<hr>
<a id="method-AnnotatedOutline-addTear"></a>



<h4>Method <code>addTear()</code></h4>

<p>Add tear to an AnnotatedOutline
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$addTear(pids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pids</code></dt><dd><p>Vector of three point IDs to be added</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AnnotatedOutline-removeTear"></a>



<h4>Method <code>removeTear()</code></h4>

<p>Remove tear from an AnnotatedOutline
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$removeTear(tid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tid</code></dt><dd><p>Tear ID, which can be returned from <code>whichTear()</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-AnnotatedOutline-checkTears"></a>



<h4>Method <code>checkTears()</code></h4>

<p>Check that all tears are correct.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$checkTears()</pre></div>



<h5>Returns</h5>

<p>If all is OK, returns empty vector.  If not, returns
indices of problematic tears.
</p>


<hr>
<a id="method-AnnotatedOutline-setFixedPoint"></a>



<h4>Method <code>setFixedPoint()</code></h4>

<p>Set fixed point
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$setFixedPoint(i0, name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i0</code></dt><dd><p>Index of fixed point</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of fixed point</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AnnotatedOutline-getFixedPoint"></a>



<h4>Method <code>getFixedPoint()</code></h4>

<p>Get point ID of fixed point
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$getFixedPoint()</pre></div>



<h5>Returns</h5>

<p>Point ID of fixed point
</p>


<hr>
<a id="method-AnnotatedOutline-getRimSet"></a>



<h4>Method <code>getRimSet()</code></h4>

<p>Get point IDs of points on rim
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$getRimSet()</pre></div>



<h5>Returns</h5>

<p>Point IDs of points on rim. If the outline has been
stitched (see <code><a href="#topic+StitchedOutline">StitchedOutline</a></code>), the point IDs
will be ordered in the direction of the
forward pointer.
</p>


<hr>
<a id="method-AnnotatedOutline-getBoundarySets"></a>



<h4>Method <code>getBoundarySets()</code></h4>

<p>Get point IDs of points on boundaries
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$getBoundarySets()</pre></div>



<h5>Returns</h5>

<p>List of Point IDs of points on the boundaries.
If the outline has been stitched (see <code><a href="#topic+StitchedOutline">StitchedOutline</a></code>),
the point IDs in each
element of the list will be ordered in the direction of the
forward pointer, and the boundary that is longest will be
named as <code>Rim</code>. If the outline has not been stitched,
the list will have one element named <code>Rim</code>.
</p>


<hr>
<a id="method-AnnotatedOutline-ensureFixedPointInRim"></a>



<h4>Method <code>ensureFixedPointInRim()</code></h4>

<p>Ensure that the fixed point <code>i0</code> is in the rim, not a tear.
Alters object in which <code>i0</code> may have been changed.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$ensureFixedPointInRim()</pre></div>


<hr>
<a id="method-AnnotatedOutline-labelFullCutPoints"></a>



<h4>Method <code>labelFullCutPoints()</code></h4>

<p>Label a set of four unlabelled points supposed to refer to a
cut.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$labelFullCutPoints(pids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pids</code></dt><dd><p>the vector of point indices</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AnnotatedOutline-addFullCut"></a>



<h4>Method <code>addFullCut()</code></h4>

<p>Add cut to an AnnotatedOutline
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$addFullCut(pids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pids</code></dt><dd><p>Vector of three point IDs to be added</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AnnotatedOutline-whichFullCut"></a>



<h4>Method <code>whichFullCut()</code></h4>

<p>Return index of cut in an AnnotatedOutline in which a point
appears
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$whichFullCut(pid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pid</code></dt><dd><p>ID of point</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ID of cut
</p>


<hr>
<a id="method-AnnotatedOutline-removeFullCut"></a>



<h4>Method <code>removeFullCut()</code></h4>

<p>Remove cut from an AnnotatedOutline
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$removeFullCut(cid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cid</code></dt><dd><p>FullCut ID, which can be returned from
<code>whichFullCut</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-AnnotatedOutline-computeFullCutRelationships"></a>



<h4>Method <code>computeFullCutRelationships()</code></h4>

<p>Compute the cut relationships between the points
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$computeFullCutRelationships(fullcuts)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fullcuts</code></dt><dd><p>Matrix containing columns <code>VB0</code>,
and <code>VB1</code> (Backward vertices of fullcuts) and <code>VF0</code> and <code>VF1</code> (Forward
vertices of fullcuts)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List containing
</p>

<dl>
<dt><code>Rset</code></dt><dd><p>the set of points on the rim</p>
</dd>
<dt><code>TFset</code></dt><dd><p>list containing indices of points in each forward cut</p>
</dd>
<dt><code>TBset</code></dt><dd><p>list containing indices of points in each backward cut</p>
</dd>
<dt><code>h</code></dt><dd><p>correspondence mapping</p>
</dd>
<dt><code>hf</code></dt><dd><p>correspondence mapping in forward direction for
points on boundary</p>
</dd>
<dt><code>hb</code></dt><dd><p>correspondence mapping in backward direction for
points on boundary</p>
</dd>
</dl>



<hr>
<a id="method-AnnotatedOutline-getFullCut"></a>



<h4>Method <code>getFullCut()</code></h4>

<p>Return indices of fullcuts in AnnotatedOutline
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$getFullCut(cid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cid</code></dt><dd><p>FullCut ID, which can be returned from <code>whichFullCut</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of four point IDs, labelled with <code>VF1</code>,
<code>VF1</code>, <code>VB0</code> and <code>VB1</code>
</p>


<hr>
<a id="method-AnnotatedOutline-getFullCuts"></a>



<h4>Method <code>getFullCuts()</code></h4>

<p>Return indices of fullcuts in AnnotatedOutline
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$getFullCuts()</pre></div>



<h5>Returns</h5>

<p>Matrix in which each row contains point IDs, for the forward and backward
sides of the cut: <code>VF0</code>, <code>VF1</code>, <code>VB0</code> and <code>VB1</code>
</p>


<hr>
<a id="method-AnnotatedOutline-addPoints"></a>



<h4>Method <code>addPoints()</code></h4>

<p>Add points to the outline register of points
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$addPoints(P, fid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>2 column matrix of points to add</p>
</dd>
<dt><code>fid</code></dt><dd><p>fragment id of the points</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The ID of each added point in the register. If points already
exist a point will not be created in the register,
but an ID will be returned
</p>


<hr>
<a id="method-AnnotatedOutline-getRimLengths"></a>



<h4>Method <code>getRimLengths()</code></h4>

<p>Get lengths of edges on rim
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$getRimLengths()</pre></div>



<h5>Returns</h5>

<p>Vector of rim lengths
</p>


<hr>
<a id="method-AnnotatedOutline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnotatedOutline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- rbind(c(1,1),   c(2,1),  c(2,-1),
           c(1,-1),  c(1,-2), c(-1,-2),
           c(-1,-1), c(-2,-1),c(-2,1),
           c(-1,1),  c(-1,2), c(1,2))
o &lt;- TriangulatedOutline$new(P)
o$addTear(c(3, 4, 5))
o$addTear(c(6, 7, 8))
o$addTear(c(9, 10, 11))
o$addTear(c(12, 1, 2))
flatplot(o)

P &lt;- list(rbind(c(1,1), c(2,1), c(2.5,2), c(3,1), c(4,1), c(1,4)),
          rbind(c(-1,1), c(-1,4), c(-2,3), c(-2,2), c(-3,2), c(-4,1)),
          rbind(c(-4,-1), c(-1,-1), c(-1,-4)),
          rbind(c(1,-1), c(2,-1), c(2.5,-2), c(3,-1), c(4,-1), c(1,-4)))
o &lt;- AnnotatedOutline$new(P)
o$addTear(c(2, 3, 4))
o$addTear(c(17, 18, 19))
o$addTear(c(9, 10, 11))
o$addFullCut(c(1, 5, 16, 20))
flatplot(o)
</code></pre>

<hr>
<h2 id='azel.to.sphere.colatitude'>Convert azimuth-elevation coordinates to spherical coordinates</h2><span id='topic+azel.to.sphere.colatitude'></span>

<h3>Description</h3>

<p>Convert azimuth-elevation coordinates to spherical coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>azel.to.sphere.colatitude(r, r0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="azel.to.sphere.colatitude_+3A_r">r</code></td>
<td>
<p>Coordinates of points in azimuth-elevation coordinates
represented as  2 column matrix with column names <code>alpha</code>
(elevation) and <code>theta</code> (azimuth).</p>
</td></tr>
<tr><td><code id="azel.to.sphere.colatitude_+3A_r0">r0</code></td>
<td>
<p>Direction of the axis of the sphere on which to project
represented as a 2 column matrix of with column names <code>alpha</code>
(elevation) and <code>theta</code> (azimuth).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-column matrix of spherical coordinates of points with
column names <code>psi</code> (colatitude) and <code>lambda</code> (longitude).
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r0 &lt;- cbind(alpha=0, theta=0)
r &lt;- rbind(r0, r0+c(1,0), r0-c(1,0), r0+c(0,1), r0-c(0,1))
azel.to.sphere.colatitude(r, r0)
</code></pre>

<hr>
<h2 id='azimuthal.conformal'>Azimuthal conformal or stereographic or Wulff projection</h2><span id='topic+azimuthal.conformal'></span>

<h3>Description</h3>

<p>Azimuthal conformal or stereographic or Wulff projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>azimuthal.conformal(r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="azimuthal.conformal_+3A_r">r</code></td>
<td>
<p>2-column Matrix of spherical coordinates of points on
sphere. Column names are <code>phi</code> and <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="azimuthal.conformal_+3A_...">...</code></td>
<td>
<p>Arguments not used by this projection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-column Matrix of Cartesian coordinates of points on polar
projection. Column names should be <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p>This is a special case with the point centred on the
projection being the South Pole. The MathWorld equations are for
the more general case.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Map_projection">https://en.wikipedia.org/wiki/Map_projection</a>,
<a href="http://mathworld.wolfram.com/StereographicProjection.html">http://mathworld.wolfram.com/StereographicProjection.html</a>
Fisher, N. I., Lewis, T., and Embleton,
B. J. J. (1987). Statistical analysis of spherical data. Cambridge
University Press, Cambridge, UK.
</p>

<hr>
<h2 id='azimuthal.equalarea'>Lambert azimuthal equal area projection</h2><span id='topic+azimuthal.equalarea'></span>

<h3>Description</h3>

<p>Lambert azimuthal equal area projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>azimuthal.equalarea(r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="azimuthal.equalarea_+3A_r">r</code></td>
<td>
<p>2-column Matrix of spherical coordinates of points on
sphere. Column names are <code>phi</code> and <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="azimuthal.equalarea_+3A_...">...</code></td>
<td>
<p>Arguments not used by this projection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-column Matrix of Cartesian coordinates of points on polar
projection. Column names should be <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p>This is a special case with the point centred on the
projection being the South Pole. The MathWorld equations are for
the more general case.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Map_projection">https://en.wikipedia.org/wiki/Map_projection</a>,
<a href="http://mathworld.wolfram.com/LambertAzimuthalEqual-AreaProjection.html">http://mathworld.wolfram.com/LambertAzimuthalEqual-AreaProjection.html</a>
Fisher, N. I., Lewis, T., and Embleton,
B. J. J. (1987). Statistical analysis of spherical data. Cambridge
University Press, Cambridge, UK.
</p>

<hr>
<h2 id='azimuthal.equidistant'>Azimuthal equidistant projection</h2><span id='topic+azimuthal.equidistant'></span>

<h3>Description</h3>

<p>Azimuthal equidistant projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>azimuthal.equidistant(r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="azimuthal.equidistant_+3A_r">r</code></td>
<td>
<p>2-column Matrix of spherical coordinates of points on
sphere. Column names are <code>phi</code> and <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="azimuthal.equidistant_+3A_...">...</code></td>
<td>
<p>Arguments not used by this projection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-column Matrix of Cartesian coordinates of points on polar
projection. Column names should be <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p>This is a special case with the point centred on the
projection being the South Pole. The MathWorld equations are for
the more general case.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Map_projection">https://en.wikipedia.org/wiki/Map_projection</a>,
<a href="http://mathworld.wolfram.com/AzimuthalEquidistantProjection.html">http://mathworld.wolfram.com/AzimuthalEquidistantProjection.html</a>
</p>

<hr>
<h2 id='bary.to.sphere.cart'>Convert barycentric coordinates of points in mesh on sphere
to cartesian coordinates</h2><span id='topic+bary.to.sphere.cart'></span>

<h3>Description</h3>

<p>Given a triangular mesh on a sphere described by mesh locations
(<code>phi</code>, <code>lambda</code>), a radius <code>R</code> and a triangulation
<code>Trt</code>, determine the Cartesian coordinates of points <code>cb</code>
given in barycentric coordinates with respect to the mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bary.to.sphere.cart(phi, lambda, R, Trt, cb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bary.to.sphere.cart_+3A_phi">phi</code></td>
<td>
<p>Latitudes of mesh points</p>
</td></tr>
<tr><td><code id="bary.to.sphere.cart_+3A_lambda">lambda</code></td>
<td>
<p>Longitudes of mesh points</p>
</td></tr>
<tr><td><code id="bary.to.sphere.cart_+3A_r">R</code></td>
<td>
<p>Radius of sphere</p>
</td></tr>
<tr><td><code id="bary.to.sphere.cart_+3A_trt">Trt</code></td>
<td>
<p>Triangulation</p>
</td></tr>
<tr><td><code id="bary.to.sphere.cart_+3A_cb">cb</code></td>
<td>
<p>Object returned by tsearch containing information on the
triangle in which a point occurs and the barycentric coordinates
within that triangle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An N-by-3 matrix of the Cartesian coordinates of the points
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='central.angle'>Central angle between two points on a sphere</h2><span id='topic+central.angle'></span>

<h3>Description</h3>

<p>On a sphere the central angle between two points is defined as the
angle whose vertex is the centre of the sphere and that subtends
the arc formed by the great circle between the points. This
function computes the central angle for two points <code class="reqn">(\phi_1,
\lambda_1)</code> and <code class="reqn">(\phi_2,\lambda_2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>central.angle(phi1, lambda1, phi2, lambda2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="central.angle_+3A_phi1">phi1</code></td>
<td>
<p>Latitude of first point</p>
</td></tr>
<tr><td><code id="central.angle_+3A_lambda1">lambda1</code></td>
<td>
<p>Longitude of first point</p>
</td></tr>
<tr><td><code id="central.angle_+3A_phi2">phi2</code></td>
<td>
<p>Latitude of second point</p>
</td></tr>
<tr><td><code id="central.angle_+3A_lambda2">lambda2</code></td>
<td>
<p>Longitude of second point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Central angle
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>Source</h3>

<p>Wikipedia <a href="https://en.wikipedia.org/wiki/Central_angle">https://en.wikipedia.org/wiki/Central_angle</a>
</p>

<hr>
<h2 id='checkDatadir'>Check the whether  directory contains valid data</h2><span id='topic+checkDatadir'></span>

<h3>Description</h3>

<p>Check the whether  directory contains valid data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDatadir(dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkDatadir_+3A_dir">dir</code></td>
<td>
<p>Directory to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>dir</code> contains valid data;
<code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='circle'>Return points on the unit circle</h2><span id='topic+circle'></span>

<h3>Description</h3>

<p>Return points on the unit circle in an anti-clockwise
direction. If <code>L</code> is not specified <code>n</code> points are
returned. If <code>L</code> is specified, the same number of points are
returned as there are elements in <code>L</code>, the interval between
successive points being proportional to <code>L</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle(n = 12, L = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circle_+3A_n">n</code></td>
<td>
<p>Number of points</p>
</td></tr>
<tr><td><code id="circle_+3A_l">L</code></td>
<td>
<p>Intervals between points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cartesian coordinates of the points
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='compute.intersections.sphere'>Find the intersection of a plane with edges of triangles on
a sphere</h2><span id='topic+compute.intersections.sphere'></span>

<h3>Description</h3>

<p>Find the intersections of the plane defined by the normal <code>n</code> and the
distance <code>d</code> expressed as a fractional distance along the side of
each triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.intersections.sphere(phi, lambda, T, n, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute.intersections.sphere_+3A_phi">phi</code></td>
<td>
<p>Latitude of grid points on sphere centred on origin.</p>
</td></tr>
<tr><td><code id="compute.intersections.sphere_+3A_lambda">lambda</code></td>
<td>
<p>Longitude of grid points on sphere centred on origin.</p>
</td></tr>
<tr><td><code id="compute.intersections.sphere_+3A_t">T</code></td>
<td>
<p>Triangulation</p>
</td></tr>
<tr><td><code id="compute.intersections.sphere_+3A_n">n</code></td>
<td>
<p>Normal of plane</p>
</td></tr>
<tr><td><code id="compute.intersections.sphere_+3A_d">d</code></td>
<td>
<p>Distance of plane along normal from origin.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with same dimensions as <code>T</code>. Each row gives
the intersection of the plane  with the corresponding triangle in
<code>T</code>. Column 1 gives the fractional distance from vertex 2 to
vertex 3. Column 2 gives the fractional distance from vertex 3 to
vertex 1. Column 2 gives the fractional distance from vertex 1 to
vertex 2. A value of <code>NaN</code> indicates that the corresponding
edge lies in the plane. A value of <code>Inf</code> indicates that the
edge lies parallel to the plane but outside it.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='compute.kernel.estimate'>Kernel estimate over grid</h2><span id='topic+compute.kernel.estimate'></span>

<h3>Description</h3>

<p>Compute a kernel estimate over a grid and do a contour analysis
of this estimate. The contour heights the determined by finding
heights that exclude a certain fraction of the probability. For
example, the 95
and it should enclose about 5
are specified by  the <code>contour.levels</code> option; by default
they are <code>c(5, 25, 50, 75, 95)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.kernel.estimate(Dss, phi0, fhat, compute.conc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute.kernel.estimate_+3A_dss">Dss</code></td>
<td>
<p>List of datasets. The first two columns of each datasets
are coordinates of points on the sphere in spherical polar
(latitude, <code>phi</code>, and longitude, <code>lambda</code>)
coordinates. In the case kernel smoothing, there is a third column
of values of dependent variables at those points.</p>
</td></tr>
<tr><td><code id="compute.kernel.estimate_+3A_phi0">phi0</code></td>
<td>
<p>Rim angle in radians</p>
</td></tr>
<tr><td><code id="compute.kernel.estimate_+3A_fhat">fhat</code></td>
<td>
<p>Function such as <code><a href="#topic+kde.fhat">kde.fhat</a></code> or
<code><a href="#topic+kr.yhat">kr.yhat</a></code> to compute the density given data and a
value of the concentration parameter <code>kappa</code> of the Fisher
density.</p>
</td></tr>
<tr><td><code id="compute.kernel.estimate_+3A_compute.conc">compute.conc</code></td>
<td>
<p>Function to return the optimal value of the
concentration parameter kappa given the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table role = "presentation">
<tr><td><code>kappa</code></td>
<td>
<p>The concentration parameter</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>A pseudo-bandwidth parameter, the inverse of the square root of <code>kappa</code>. Units of degrees.</p>
</td></tr>
<tr><td><code>flevels</code></td>
<td>
<p>Contour levels.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>Labels of the contours.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>Raw density estimate drawn on non-area-preserving projection. Comprises locations of gridlines in Cartesian coordinates (<code>xs</code> and <code>ys</code>), density estimates at these points, <code>f</code> and location of maximum in Cartesian coordinates (<code>max</code>).</p>
</td></tr>
<tr><td><code>gpa</code></td>
<td>
<p>Raw density estimate drawn on area-preserving projection. Comprises same elements as above.</p>
</td></tr>
<tr><td><code>contour.areas</code></td>
<td>
<p>Area of each individual contour. One level may have more than one contour; this shows the areas of all such contours.</p>
</td></tr>
<tr><td><code>tot.contour.areas</code></td>
<td>
<p>Data frame containing the total area within the contours at each level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='CountSet'>Subclass of <code><a href="#topic+FeatureSet">FeatureSet</a></code> to represent counts centred
on points</h2><span id='topic+CountSet'></span>

<h3>Description</h3>

<p>A CountSet contains information about points located
on <code><a href="#topic+Outline">Outline</a></code>s. Each CountSet contains a list of
matrices, each of which has columns labelled <code>X</code> and
<code>Y</code> describing the cartesian coordinates (in the unscaled
coordinate frame) of the centres of boxes in the Outline, and a
column <code>C</code> representing the counts in those boxes.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+FeatureSetCommon">retistruct::FeatureSetCommon</a></code> -&gt; <code><a href="#topic+FeatureSet">retistruct::FeatureSet</a></code> -&gt; <code>CountSet</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CountSet-new"><code>CountSet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CountSet-reconstruct"><code>CountSet$reconstruct()</code></a>
</p>
</li>
<li> <p><a href="#method-CountSet-clone"><code>CountSet$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getCol"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getCol'><code>retistruct::FeatureSetCommon$getCol()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeature"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeature'><code>retistruct::FeatureSetCommon$getFeature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeatures"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeatures'><code>retistruct::FeatureSetCommon$getFeatures()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIDs"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIDs'><code>retistruct::FeatureSetCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIndex"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIndex'><code>retistruct::FeatureSetCommon$getIndex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="setID"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-setID'><code>retistruct::FeatureSetCommon$setID()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CountSet-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>CountSet$new(data = NULL, cols = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>List of matrices describing data. Each matrix
should have columns named <code>X</code>, <code>Y</code> and <code>C</code></p>
</dd>
<dt><code>cols</code></dt><dd><p>Named vector of colours for each data set. The name is
used as the ID (label) for the data set. The colours should be names
present in the output of the <code><a href="grDevices.html#topic+colors">colors</a></code> function</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CountSet-reconstruct"></a>



<h4>Method <code>reconstruct()</code></h4>

<p>Map the CountSet to a <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>CountSet$reconstruct(ro)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ro</code></dt><dd><p>The <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-CountSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CountSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='create.polar.cart.grid'>Create grid on projection of hemisphere onto plane</h2><span id='topic+create.polar.cart.grid'></span>

<h3>Description</h3>

<p>Create grid on projection of hemisphere onto plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.polar.cart.grid(pa, res, phi0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.polar.cart.grid_+3A_pa">pa</code></td>
<td>
<p>If <code>TRUE</code>, make this an area-preserving projection</p>
</td></tr>
<tr><td><code id="create.polar.cart.grid_+3A_res">res</code></td>
<td>
<p>Resolution of grid</p>
</td></tr>
<tr><td><code id="create.polar.cart.grid_+3A_phi0">phi0</code></td>
<td>
<p>Value of <code>phi0</code> at edge of grid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>
<table role = "presentation">
<tr><td><code>s</code></td>
<td>
<p>Grid locations in spherical coordinates</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Grid locations in Cartesian coordinates on plane</p>
</td></tr>
<tr><td><code>xs</code></td>
<td>
<p>X grid line locations in Cartesian coordinates on plane</p>
</td></tr>
<tr><td><code>ys</code></td>
<td>
<p>Y grid line locations in Cartesian coordinates on plane</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='csv.read.dataset'>Read a retinal dataset in CSV format</h2><span id='topic+csv.read.dataset'></span>

<h3>Description</h3>

<p>Read a retinal dataset in CSV format. Each dataset is a folder
containing a file called outline.csv that specifies the outline in
X-Y coordinates. It may also contain a file <code>datapoints.csv</code>,
containing the locations of data points and a file
<code>datacounts.csv</code>, containing the locations of data counts;
see <code><a href="#topic+read.datapoints">read.datapoints</a></code> and
<code><a href="#topic+read.datacounts">read.datacounts</a></code> for the formats of these files. The
folder may also contain a file <code>od.csv</code> specifying the
coordinates of the optic disc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csv.read.dataset(dataset, report = message)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csv.read.dataset_+3A_dataset">dataset</code></td>
<td>
<p>Path to directory containing <code>outline.csv</code></p>
</td></tr>
<tr><td><code id="csv.read.dataset_+3A_report">report</code></td>
<td>
<p>Function to report progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+RetinalOutline">RetinalOutline</a></code> object
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='dE'>The deformation energy gradient function</h2><span id='topic+dE'></span>

<h3>Description</h3>

<p>The function that computes the gradient of the  energy (or error)
of the deformation of the mesh from the flat outline to the
sphere. This depends on the locations of the points given in
spherical coordinates. The function is designed to take these as a
vector that is received from the <code>optim</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dE(
  p,
  Cu,
  C,
  L,
  B,
  Tr,
  A,
  R,
  Rset,
  i0,
  phi0,
  lambda0,
  Nphi,
  N,
  alpha = 1,
  x0,
  nu = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dE_+3A_p">p</code></td>
<td>
<p>Parameter vector of <code>phi</code> and <code>lambda</code></p>
</td></tr>
<tr><td><code id="dE_+3A_cu">Cu</code></td>
<td>
<p>The upper part of the connectivity matrix</p>
</td></tr>
<tr><td><code id="dE_+3A_c">C</code></td>
<td>
<p>The connectivity matrix</p>
</td></tr>
<tr><td><code id="dE_+3A_l">L</code></td>
<td>
<p>Length of each edge in the flattened outline</p>
</td></tr>
<tr><td><code id="dE_+3A_b">B</code></td>
<td>
<p>Connectivity matrix</p>
</td></tr>
<tr><td><code id="dE_+3A_tr">Tr</code></td>
<td>
<p>Triangulation in the flattened outline</p>
</td></tr>
<tr><td><code id="dE_+3A_a">A</code></td>
<td>
<p>Area of each triangle in the flattened outline</p>
</td></tr>
<tr><td><code id="dE_+3A_r">R</code></td>
<td>
<p>Radius of the sphere</p>
</td></tr>
<tr><td><code id="dE_+3A_rset">Rset</code></td>
<td>
<p>Indices of points on the rim</p>
</td></tr>
<tr><td><code id="dE_+3A_i0">i0</code></td>
<td>
<p>Index of fixed point on rim</p>
</td></tr>
<tr><td><code id="dE_+3A_phi0">phi0</code></td>
<td>
<p>Latitude at which sphere curtailed</p>
</td></tr>
<tr><td><code id="dE_+3A_lambda0">lambda0</code></td>
<td>
<p>Longitude of fixed points</p>
</td></tr>
<tr><td><code id="dE_+3A_nphi">Nphi</code></td>
<td>
<p>Number of free values of <code>phi</code></p>
</td></tr>
<tr><td><code id="dE_+3A_n">N</code></td>
<td>
<p>Number of points in sphere</p>
</td></tr>
<tr><td><code id="dE_+3A_alpha">alpha</code></td>
<td>
<p>Area penalty scaling coefficient</p>
</td></tr>
<tr><td><code id="dE_+3A_x0">x0</code></td>
<td>
<p>Area penalty cut-off coefficient</p>
</td></tr>
<tr><td><code id="dE_+3A_nu">nu</code></td>
<td>
<p>Power to which to raise area</p>
</td></tr>
<tr><td><code id="dE_+3A_verbose">verbose</code></td>
<td>
<p>How much information to report</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector representing the derivative of the energy of this
particular configuration with respect to the parameter vector
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='depthplot3D'>Draw the &quot;flat&quot; outline in 3D with depth information</h2><span id='topic+depthplot3D'></span>

<h3>Description</h3>

<p>Draw the &quot;flat&quot; outline in 3D with depth information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthplot3D(r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="depthplot3D_+3A_r">r</code></td>
<td>
<p><code><a href="#topic+TriangulatedOutline">TriangulatedOutline</a></code> object</p>
</td></tr>
<tr><td><code id="depthplot3D_+3A_...">...</code></td>
<td>
<p>Parameters depending on class of <code>r</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='directories'>File system directories used by shinyFiles</h2><span id='topic+directories'></span>

<h3>Description</h3>

<p>File system directories used by shinyFiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directories
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='E'>The deformation energy function</h2><span id='topic+E'></span>

<h3>Description</h3>

<p>The function that computes the energy (or error) of the
deformation of the mesh from the flat outline to the sphere. This
depends on the locations of the points given in spherical
coordinates. The function is designed to take these as a vector
that is received from the <code>optim</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E(
  p,
  Cu,
  C,
  L,
  B,
  Tr,
  A,
  R,
  Rset,
  i0,
  phi0,
  lambda0,
  Nphi,
  N,
  alpha = 1,
  x0,
  nu = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="E_+3A_p">p</code></td>
<td>
<p>Parameter vector of <code>phi</code> and <code>lambda</code></p>
</td></tr>
<tr><td><code id="E_+3A_cu">Cu</code></td>
<td>
<p>The upper part of the connectivity matrix</p>
</td></tr>
<tr><td><code id="E_+3A_c">C</code></td>
<td>
<p>The connectivity matrix</p>
</td></tr>
<tr><td><code id="E_+3A_l">L</code></td>
<td>
<p>Length of each edge in the flattened outline</p>
</td></tr>
<tr><td><code id="E_+3A_b">B</code></td>
<td>
<p>Connectivity matrix</p>
</td></tr>
<tr><td><code id="E_+3A_tr">Tr</code></td>
<td>
<p>Triangulation in the flattened outline</p>
</td></tr>
<tr><td><code id="E_+3A_a">A</code></td>
<td>
<p>Area of each triangle in the flattened outline</p>
</td></tr>
<tr><td><code id="E_+3A_r">R</code></td>
<td>
<p>Radius of the sphere</p>
</td></tr>
<tr><td><code id="E_+3A_rset">Rset</code></td>
<td>
<p>Indices of points on the rim</p>
</td></tr>
<tr><td><code id="E_+3A_i0">i0</code></td>
<td>
<p>Index of fixed point on rim</p>
</td></tr>
<tr><td><code id="E_+3A_phi0">phi0</code></td>
<td>
<p>Latitude at which sphere curtailed</p>
</td></tr>
<tr><td><code id="E_+3A_lambda0">lambda0</code></td>
<td>
<p>Longitude of fixed points</p>
</td></tr>
<tr><td><code id="E_+3A_nphi">Nphi</code></td>
<td>
<p>Number of free values of <code>phi</code></p>
</td></tr>
<tr><td><code id="E_+3A_n">N</code></td>
<td>
<p>Number of points in sphere</p>
</td></tr>
<tr><td><code id="E_+3A_alpha">alpha</code></td>
<td>
<p>Area scaling coefficient</p>
</td></tr>
<tr><td><code id="E_+3A_x0">x0</code></td>
<td>
<p>Area cut-off coefficient</p>
</td></tr>
<tr><td><code id="E_+3A_nu">nu</code></td>
<td>
<p>Power to which to raise area</p>
</td></tr>
<tr><td><code id="E_+3A_verbose">verbose</code></td>
<td>
<p>How much information to report</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value, representing the energy of this particular
configuration
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='Ecart'>The deformation energy function</h2><span id='topic+Ecart'></span>

<h3>Description</h3>

<p>The function that computes the energy (or error) of the
deformation of the mesh from the flat outline to the sphere. This
depends on the locations of the points given in spherical
coordinates. The function is designed to take these as a vector
that is received from the <code>optim</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ecart(P, Cu, L, Tr, A, R, alpha = 1, x0, nu = 1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ecart_+3A_p">P</code></td>
<td>
<p>N-by-3 matrix of point coordinates</p>
</td></tr>
<tr><td><code id="Ecart_+3A_cu">Cu</code></td>
<td>
<p>The upper part of the connectivity matrix</p>
</td></tr>
<tr><td><code id="Ecart_+3A_l">L</code></td>
<td>
<p>Length of each edge in the flattened outline</p>
</td></tr>
<tr><td><code id="Ecart_+3A_tr">Tr</code></td>
<td>
<p>Triangulation in the flattened outline</p>
</td></tr>
<tr><td><code id="Ecart_+3A_a">A</code></td>
<td>
<p>Area of each triangle in the flattened outline</p>
</td></tr>
<tr><td><code id="Ecart_+3A_r">R</code></td>
<td>
<p>Radius of sphere</p>
</td></tr>
<tr><td><code id="Ecart_+3A_alpha">alpha</code></td>
<td>
<p>Area penalty scaling coefficient</p>
</td></tr>
<tr><td><code id="Ecart_+3A_x0">x0</code></td>
<td>
<p>Area penalty cut-off coefficient</p>
</td></tr>
<tr><td><code id="Ecart_+3A_nu">nu</code></td>
<td>
<p>Power to which to raise area</p>
</td></tr>
<tr><td><code id="Ecart_+3A_verbose">verbose</code></td>
<td>
<p>How much information to report</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value, representing the energy of this particular
configuration
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='f'>Piecewise smooth function used in area penalty</h2><span id='topic+f'></span>

<h3>Description</h3>

<p>Piecewise, smooth function that increases linearly with negative arguments.
</p>
<p style="text-align: center;"><code class="reqn">    f(x) = \left\{
       \begin{array}{ll}
         -(x - x_0/2) &amp; x &lt; 0 \\
         \frac{1}{2x_0}(x - x_0)^2 &amp; 0 &lt; x &lt;x_0 \\
         0 &amp; x \ge x_0
         \end{array} \right.
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>f(x, x0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_+3A_x">x</code></td>
<td>
<p>Main argument</p>
</td></tr>
<tr><td><code id="f_+3A_x0">x0</code></td>
<td>
<p>The cut-off parameter. Above this value the function is zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the function.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='Fcart'>The deformation energy gradient function</h2><span id='topic+Fcart'></span>

<h3>Description</h3>

<p>The function that computes the gradient of the  energy (or error)
of the deformation of the mesh from the flat outline to the
sphere. This depends on the locations of the points given in
spherical coordinates. The function is designed to take these as a
vector that is received from the <code>optim</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fcart(P, C, L, Tr, A, R, alpha = 1, x0, nu = 1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fcart_+3A_p">P</code></td>
<td>
<p>N-by-3 matrix of point coordinates</p>
</td></tr>
<tr><td><code id="Fcart_+3A_c">C</code></td>
<td>
<p>The connectivity matrix</p>
</td></tr>
<tr><td><code id="Fcart_+3A_l">L</code></td>
<td>
<p>Length of each edge in the flattened outline</p>
</td></tr>
<tr><td><code id="Fcart_+3A_tr">Tr</code></td>
<td>
<p>Triangulation in the flattened outline</p>
</td></tr>
<tr><td><code id="Fcart_+3A_a">A</code></td>
<td>
<p>Area of each triangle in the flattened outline</p>
</td></tr>
<tr><td><code id="Fcart_+3A_r">R</code></td>
<td>
<p>Radius of sphere</p>
</td></tr>
<tr><td><code id="Fcart_+3A_alpha">alpha</code></td>
<td>
<p>Area penalty scaling coefficient</p>
</td></tr>
<tr><td><code id="Fcart_+3A_x0">x0</code></td>
<td>
<p>Area penalty cut-off coefficient</p>
</td></tr>
<tr><td><code id="Fcart_+3A_nu">nu</code></td>
<td>
<p>Power to which to raise area</p>
</td></tr>
<tr><td><code id="Fcart_+3A_verbose">verbose</code></td>
<td>
<p>How much information to report</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector representing the derivative of the energy of this
particular configuration with respect to the parameter vector
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='FeatureSet'>Superclass containing functions and data relating to sets of
features in flat <code><a href="#topic+Outline">Outline</a></code>s</h2><span id='topic+FeatureSet'></span>

<h3>Description</h3>

<p>A FeatureSet contains information about features
located on <code><a href="#topic+Outline">Outline</a></code>s. Each FeatureSet contains a
list of matrices, each of which has columns labelled <code>X</code>
and <code>Y</code> describing the cartesian coordinates of points on
the Outline, in the unscaled coordinate frame. Derived classes,
e.g. a <code><a href="#topic+CountSet">CountSet</a></code>, may have extra columns. Each matrix
in the list has an associated label and colour, which is used by
plotting functions.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+FeatureSetCommon">retistruct::FeatureSetCommon</a></code> -&gt; <code>FeatureSet</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FeatureSet-new"><code>FeatureSet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FeatureSet-clone"><code>FeatureSet$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getCol"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getCol'><code>retistruct::FeatureSetCommon$getCol()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeature"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeature'><code>retistruct::FeatureSetCommon$getFeature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeatures"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeatures'><code>retistruct::FeatureSetCommon$getFeatures()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIDs"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIDs'><code>retistruct::FeatureSetCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIndex"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIndex'><code>retistruct::FeatureSetCommon$getIndex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="setID"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-setID'><code>retistruct::FeatureSetCommon$setID()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FeatureSet-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>FeatureSet$new(data = NULL, cols = NULL, type = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>List of matrices describing data. Each matrix
should have columns named <code>X</code> and <code>Y</code></p>
</dd>
<dt><code>cols</code></dt><dd><p>Named vector of colours for each data set. The name is
used as the ID (label) for the data set. The colours should be names
present in the output of the <code><a href="grDevices.html#topic+colors">colors</a></code> function</p>
</dd>
<dt><code>type</code></dt><dd><p>String</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FeatureSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FeatureSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='FeatureSetCommon'>Class containing functionality common to <code><a href="#topic+FeatureSet">FeatureSet</a></code>s and
<code><a href="#topic+ReconstructedFeatureSet">ReconstructedFeatureSet</a></code>s</h2><span id='topic+FeatureSetCommon'></span>

<h3>Description</h3>

<p>An FeatureSetCommon has functionality for retrieving
sets of features (e.g. points or landmarks associated with an
outline)
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>data</code></dt><dd><p>List of matrices describing data</p>
</dd>
<dt><code>cols</code></dt><dd><p>Vector of colours for each data set</p>
</dd>
<dt><code>type</code></dt><dd><p>String giving type of feature set</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FeatureSetCommon-getIndex"><code>FeatureSetCommon$getIndex()</code></a>
</p>
</li>
<li> <p><a href="#method-FeatureSetCommon-getIDs"><code>FeatureSetCommon$getIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-FeatureSetCommon-setID"><code>FeatureSetCommon$setID()</code></a>
</p>
</li>
<li> <p><a href="#method-FeatureSetCommon-getFeature"><code>FeatureSetCommon$getFeature()</code></a>
</p>
</li>
<li> <p><a href="#method-FeatureSetCommon-getFeatures"><code>FeatureSetCommon$getFeatures()</code></a>
</p>
</li>
<li> <p><a href="#method-FeatureSetCommon-getCol"><code>FeatureSetCommon$getCol()</code></a>
</p>
</li>
<li> <p><a href="#method-FeatureSetCommon-clone"><code>FeatureSetCommon$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FeatureSetCommon-getIndex"></a>



<h4>Method <code>getIndex()</code></h4>

<p>Get numeric index of features
</p>


<h5>Usage</h5>

<div class="r"><pre>FeatureSetCommon$getIndex(fid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fid</code></dt><dd><p>Feature ID (string)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FeatureSetCommon-getIDs"></a>



<h4>Method <code>getIDs()</code></h4>

<p>Get IDs of features
</p>


<h5>Usage</h5>

<div class="r"><pre>FeatureSetCommon$getIDs()</pre></div>



<h5>Returns</h5>

<p>Vector of IDs of features
</p>


<hr>
<a id="method-FeatureSetCommon-setID"></a>



<h4>Method <code>setID()</code></h4>

<p>Set name
</p>


<h5>Usage</h5>

<div class="r"><pre>FeatureSetCommon$setID(i, fid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>Numeric index of feature</p>
</dd>
<dt><code>fid</code></dt><dd><p>Feature ID (string)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FeatureSetCommon-getFeature"></a>



<h4>Method <code>getFeature()</code></h4>

<p>Get feature by feature ID
</p>


<h5>Usage</h5>

<div class="r"><pre>FeatureSetCommon$getFeature(fid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fid</code></dt><dd><p>Feature ID string</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Matrix describing feature
</p>


<hr>
<a id="method-FeatureSetCommon-getFeatures"></a>



<h4>Method <code>getFeatures()</code></h4>

<p>Get all features
</p>


<h5>Usage</h5>

<div class="r"><pre>FeatureSetCommon$getFeatures()</pre></div>


<hr>
<a id="method-FeatureSetCommon-getCol"></a>



<h4>Method <code>getCol()</code></h4>

<p>Get colour in which to plot feature ID
</p>


<h5>Usage</h5>

<div class="r"><pre>FeatureSetCommon$getCol(fid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fid</code></dt><dd><p>Feature ID string</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FeatureSetCommon-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FeatureSetCommon$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='fire'>The FIRE algorithm</h2><span id='topic+fire'></span>

<h3>Description</h3>

<p>This is an implementation of the FIRE algorithm for structural
relaxation put forward by Bitzek et al. (2006)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fire(
  r,
  force,
  restraint,
  m = 1,
  dt = 0.1,
  maxmove = 100,
  dtmax = 1,
  Nmin = 5,
  finc = 1.1,
  fdec = 0.5,
  astart = 0.1,
  fa = 0.99,
  a = 0.1,
  nstep = 100,
  tol = 1e-05,
  verbose = FALSE,
  report = message
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fire_+3A_r">r</code></td>
<td>
<p>Initial locations of particles</p>
</td></tr>
<tr><td><code id="fire_+3A_force">force</code></td>
<td>
<p>Force function</p>
</td></tr>
<tr><td><code id="fire_+3A_restraint">restraint</code></td>
<td>
<p>Restraint function</p>
</td></tr>
<tr><td><code id="fire_+3A_m">m</code></td>
<td>
<p>Masses of points</p>
</td></tr>
<tr><td><code id="fire_+3A_dt">dt</code></td>
<td>
<p>Initial time step</p>
</td></tr>
<tr><td><code id="fire_+3A_maxmove">maxmove</code></td>
<td>
<p>Maximum distance to move in any time step</p>
</td></tr>
<tr><td><code id="fire_+3A_dtmax">dtmax</code></td>
<td>
<p>Maximum time step</p>
</td></tr>
<tr><td><code id="fire_+3A_nmin">Nmin</code></td>
<td>
<p>Number of steps after which to start increasing <code>dt</code></p>
</td></tr>
<tr><td><code id="fire_+3A_finc">finc</code></td>
<td>
<p>Fractional increase in <code>dt</code> per time step</p>
</td></tr>
<tr><td><code id="fire_+3A_fdec">fdec</code></td>
<td>
<p>Fractional decrease in <code>dt</code> after a stop</p>
</td></tr>
<tr><td><code id="fire_+3A_astart">astart</code></td>
<td>
<p>Starting value of <code>a</code> after a stop</p>
</td></tr>
<tr><td><code id="fire_+3A_fa">fa</code></td>
<td>
<p>Fraction of <code>a</code> to retain after each step</p>
</td></tr>
<tr><td><code id="fire_+3A_a">a</code></td>
<td>
<p>Initial value of <code>a</code></p>
</td></tr>
<tr><td><code id="fire_+3A_nstep">nstep</code></td>
<td>
<p>Maximum number of steps</p>
</td></tr>
<tr><td><code id="fire_+3A_tol">tol</code></td>
<td>
<p>Tolerance - if RMS force is below this value, stop and
report convergence</p>
</td></tr>
<tr><td><code id="fire_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> report progress verbosely</p>
</td></tr>
<tr><td><code id="fire_+3A_report">report</code></td>
<td>
<p>Function to report progress when <code>verbose</code> is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing <code>x</code>, the positions of the points,
<code>conv</code>, which is 0 if convergence as occurred and 1 otherwise,
and <code>frms</code>, the root mean square of the forces on the
particles.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>References</h3>

<p>Bitzek, E., Koskinen, P., Gähler, F., Moseler, M.,
and Gumbsch, P. (2006). Structural relaxation made
simple. Phys. Rev. Lett., 97:170201.
</p>

<hr>
<h2 id='flatplot'>Plot &quot;flat&quot; (unreconstructed) representation of outline</h2><span id='topic+flatplot'></span>

<h3>Description</h3>

<p>Plot &quot;flat&quot; (unreconstructed) representation of outline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flatplot_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Outline">Outline</a></code>, <code><a href="#topic+AnnotatedOutline">AnnotatedOutline</a></code>,  <code><a href="#topic+StitchedOutline">StitchedOutline</a></code> &amp;c object</p>
</td></tr>
<tr><td><code id="flatplot_+3A_...">...</code></td>
<td>
<p>Other plotting parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='flatplot.AnnotatedOutline'>Flat plot of AnnotatedOutline</h2><span id='topic+flatplot.AnnotatedOutline'></span>

<h3>Description</h3>

<p>Plot flat <code><a href="#topic+AnnotatedOutline">AnnotatedOutline</a></code>. The user markup is
displayed by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AnnotatedOutline'
flatplot(x, axt = "n", xlim = NULL, ylim = NULL, markup = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flatplot.AnnotatedOutline_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+AnnotatedOutline">AnnotatedOutline</a></code> object</p>
</td></tr>
<tr><td><code id="flatplot.AnnotatedOutline_+3A_axt">axt</code></td>
<td>
<p>whether to plot axes</p>
</td></tr>
<tr><td><code id="flatplot.AnnotatedOutline_+3A_xlim">xlim</code></td>
<td>
<p>x-limits</p>
</td></tr>
<tr><td><code id="flatplot.AnnotatedOutline_+3A_ylim">ylim</code></td>
<td>
<p>y-limits</p>
</td></tr>
<tr><td><code id="flatplot.AnnotatedOutline_+3A_markup">markup</code></td>
<td>
<p>If <code>TRUE</code>, plot markup</p>
</td></tr>
<tr><td><code id="flatplot.AnnotatedOutline_+3A_...">...</code></td>
<td>
<p>Other plotting parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='flatplot.Outline'>Flat plot of outline</h2><span id='topic+flatplot.Outline'></span>

<h3>Description</h3>

<p>Plot flat <code><a href="#topic+Outline">Outline</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Outline'
flatplot(
  x,
  axt = "n",
  xlim = NULL,
  ylim = NULL,
  add = FALSE,
  image = TRUE,
  scalebar = 1,
  rimset = FALSE,
  pids = FALSE,
  pid.joggle = 0,
  lwd.outline = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flatplot.Outline_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Outline">Outline</a></code> object</p>
</td></tr>
<tr><td><code id="flatplot.Outline_+3A_axt">axt</code></td>
<td>
<p>whether to plot axes</p>
</td></tr>
<tr><td><code id="flatplot.Outline_+3A_xlim">xlim</code></td>
<td>
<p>x limits</p>
</td></tr>
<tr><td><code id="flatplot.Outline_+3A_ylim">ylim</code></td>
<td>
<p>y limits</p>
</td></tr>
<tr><td><code id="flatplot.Outline_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, don't draw axes; add to existing plot.</p>
</td></tr>
<tr><td><code id="flatplot.Outline_+3A_image">image</code></td>
<td>
<p>If <code>TRUE</code> the image (if it is present) is
displayed behind the outline</p>
</td></tr>
<tr><td><code id="flatplot.Outline_+3A_scalebar">scalebar</code></td>
<td>
<p>If  numeric and if the Outline has a <code>scale</code>
field, a scale bar of length <code>scalebar</code> mm is plotted.  If
<code>scalebar</code> is <code>FALSE</code> or there is no scale information
in the <code><a href="#topic+Outline">Outline</a></code> <code>x</code> the scale bar is suppressed.</p>
</td></tr>
<tr><td><code id="flatplot.Outline_+3A_rimset">rimset</code></td>
<td>
<p>If <code>TRUE</code>, plot the points computed to be in the rim in the colour specified by the option <code>rimset.col</code></p>
</td></tr>
<tr><td><code id="flatplot.Outline_+3A_pids">pids</code></td>
<td>
<p>If <code>TRUE</code>, plot point IDs</p>
</td></tr>
<tr><td><code id="flatplot.Outline_+3A_pid.joggle">pid.joggle</code></td>
<td>
<p>Amount to joggle point IDs by randomly</p>
</td></tr>
<tr><td><code id="flatplot.Outline_+3A_lwd.outline">lwd.outline</code></td>
<td>
<p>Line width of outline</p>
</td></tr>
<tr><td><code id="flatplot.Outline_+3A_...">...</code></td>
<td>
<p>Other plotting parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='flatplot.ReconstructedOutline'>Flat plot of reconstructed outline</h2><span id='topic+flatplot.ReconstructedOutline'></span>

<h3>Description</h3>

<p>Plot <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code> object. This adds a mesh
of gridlines from the spherical retina (described by points
<code>phi</code>, <code>lambda</code> and triangulation <code>Trt</code> and cut-off
point <code>phi0</code>) onto a flattened retina (described by points
<code>P</code> and triangulation <code>T</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ReconstructedOutline'
flatplot(
  x,
  axt = "n",
  xlim = NULL,
  ylim = NULL,
  grid = TRUE,
  strain = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flatplot.ReconstructedOutline_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code> object</p>
</td></tr>
<tr><td><code id="flatplot.ReconstructedOutline_+3A_axt">axt</code></td>
<td>
<p>whether to plot axes</p>
</td></tr>
<tr><td><code id="flatplot.ReconstructedOutline_+3A_xlim">xlim</code></td>
<td>
<p>x-limits</p>
</td></tr>
<tr><td><code id="flatplot.ReconstructedOutline_+3A_ylim">ylim</code></td>
<td>
<p>y-limits</p>
</td></tr>
<tr><td><code id="flatplot.ReconstructedOutline_+3A_grid">grid</code></td>
<td>
<p>Whether or not to show the grid lines of
latitude and longitude</p>
</td></tr>
<tr><td><code id="flatplot.ReconstructedOutline_+3A_strain">strain</code></td>
<td>
<p>Whether or not to show the strain</p>
</td></tr>
<tr><td><code id="flatplot.ReconstructedOutline_+3A_...">...</code></td>
<td>
<p>Other plotting parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='flatplot.StitchedOutline'>Flat plot of AnnotatedOutline</h2><span id='topic+flatplot.StitchedOutline'></span>

<h3>Description</h3>

<p>Plot flat <code><a href="#topic+StitchedOutline">StitchedOutline</a></code>. If the optional argument
<code>stitch</code> is <code>TRUE</code> the user markup is displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'StitchedOutline'
flatplot(x, axt = "n", xlim = NULL, ylim = NULL, stitch = TRUE, lwd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flatplot.StitchedOutline_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+AnnotatedOutline">AnnotatedOutline</a></code> object</p>
</td></tr>
<tr><td><code id="flatplot.StitchedOutline_+3A_axt">axt</code></td>
<td>
<p>whether to plot axes</p>
</td></tr>
<tr><td><code id="flatplot.StitchedOutline_+3A_xlim">xlim</code></td>
<td>
<p>x-limits</p>
</td></tr>
<tr><td><code id="flatplot.StitchedOutline_+3A_ylim">ylim</code></td>
<td>
<p>y-limits</p>
</td></tr>
<tr><td><code id="flatplot.StitchedOutline_+3A_stitch">stitch</code></td>
<td>
<p>If <code>TRUE</code>, plot stitch</p>
</td></tr>
<tr><td><code id="flatplot.StitchedOutline_+3A_lwd">lwd</code></td>
<td>
<p>Line width</p>
</td></tr>
<tr><td><code id="flatplot.StitchedOutline_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='flatplot.TriangulatedOutline'>Plot flat <code><a href="#topic+TriangulatedOutline">TriangulatedOutline</a></code>.</h2><span id='topic+flatplot.TriangulatedOutline'></span>

<h3>Description</h3>

<p>Plot flat <code><a href="#topic+TriangulatedOutline">TriangulatedOutline</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TriangulatedOutline'
flatplot(x, axt = "n", xlim = NULL, ylim = NULL, mesh = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flatplot.TriangulatedOutline_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+TriangulatedOutline">TriangulatedOutline</a></code> object</p>
</td></tr>
<tr><td><code id="flatplot.TriangulatedOutline_+3A_axt">axt</code></td>
<td>
<p>whether to plot axes</p>
</td></tr>
<tr><td><code id="flatplot.TriangulatedOutline_+3A_xlim">xlim</code></td>
<td>
<p>x-limits</p>
</td></tr>
<tr><td><code id="flatplot.TriangulatedOutline_+3A_ylim">ylim</code></td>
<td>
<p>y-limits</p>
</td></tr>
<tr><td><code id="flatplot.TriangulatedOutline_+3A_mesh">mesh</code></td>
<td>
<p>If <code>TRUE</code>, plot mesh</p>
</td></tr>
<tr><td><code id="flatplot.TriangulatedOutline_+3A_...">...</code></td>
<td>
<p>Other plotting parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='flipped.triangles'>Determine indices of triangles that are flipped</h2><span id='topic+flipped.triangles'></span>

<h3>Description</h3>

<p>In the projection of points onto the sphere, some triangles maybe
flipped, i.e. in the wrong orientation.  This functions determines
which triangles are flipped by computing the vector pointing to
the centre of each triangle and comparing this direction to vector
product of two sides of the triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipped.triangles(Ps, Trt, R = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flipped.triangles_+3A_ps">Ps</code></td>
<td>
<p>N-by-2 matrix with columns containing latitudes
(<code>phi</code>) and longitudes (<code>lambda</code>) of N points</p>
</td></tr>
<tr><td><code id="flipped.triangles_+3A_trt">Trt</code></td>
<td>
<p>Triangulation of points</p>
</td></tr>
<tr><td><code id="flipped.triangles_+3A_r">R</code></td>
<td>
<p>Radius of sphere</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>
<table role = "presentation">
<tr><td><code>flipped</code></td>
<td>
<p>Indices of in rows of <code>Trt</code> of flipped triangles.</p>
</td></tr>
<tr><td><code>cents</code></td>
<td>
<p>Vectors of centres.</p>
</td></tr>
<tr><td><code>areas</code></td>
<td>
<p>Areas of triangles.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='flipped.triangles.cart'>Determine indices of triangles that are flipped</h2><span id='topic+flipped.triangles.cart'></span>

<h3>Description</h3>

<p>In the projection of points onto the sphere, some triangles maybe
flipped, i.e. in the wrong orientation.  This function determines
which triangles are flipped by computing the vector pointing to
the centre of each triangle and comparing this direction to vector
product of two sides of the triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipped.triangles.cart(P, Trt, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flipped.triangles.cart_+3A_p">P</code></td>
<td>
<p>Points in Cartesian coordinates</p>
</td></tr>
<tr><td><code id="flipped.triangles.cart_+3A_trt">Trt</code></td>
<td>
<p>Triangulation of points</p>
</td></tr>
<tr><td><code id="flipped.triangles.cart_+3A_r">R</code></td>
<td>
<p>Radius of sphere</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>
<table role = "presentation">
<tr><td><code>flipped</code></td>
<td>
<p>Indices of in rows of <code>Trt</code> of flipped triangles.</p>
</td></tr>
<tr><td><code>cents</code></td>
<td>
<p>Vectors of centres.</p>
</td></tr>
<tr><td><code>areas</code></td>
<td>
<p>Areas of triangles.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='fp'>Piecewise smooth function used in area penalty</h2><span id='topic+fp'></span>

<h3>Description</h3>

<p>Derivative of <code><a href="#topic+f">f</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fp(x, x0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fp_+3A_x">x</code></td>
<td>
<p>Main argument</p>
</td></tr>
<tr><td><code id="fp_+3A_x0">x0</code></td>
<td>
<p>The cut-off parameter. Above this value the function is zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the function.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='Fragment'>Construct an outline object. This sanitises the input points
<code>P</code>, as described below.</h2><span id='topic+Fragment'></span>

<h3>Description</h3>

<p>Construct an outline object. This sanitises the input points
<code>P</code>, as described below.
</p>
<p>Construct an outline object. This sanitises the input points
<code>P</code>, as described below.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>P</code></dt><dd><p>A N-by-2 matrix of points of the <code>Outline</code>
arranged in anticlockwise order</p>
</dd>
<dt><code>gf</code></dt><dd><p>For each row of <code>P</code>, the index of <code>P</code> that
is next in the outline travelling anticlockwise (forwards)</p>
</dd>
<dt><code>gb</code></dt><dd><p>For each row of <code>P</code>, the index of <code>P</code> that
is next in the outline travelling clockwise (backwards)</p>
</dd>
<dt><code>h</code></dt><dd><p>For each row of <code>P</code>, the cut of that
point (which will be to itself initially)</p>
</dd>
<dt><code>A.tot</code></dt><dd><p>Total area of the Fragment</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Fragment-initializeFromPoints"><code>Fragment$initializeFromPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-Fragment-clone"><code>Fragment$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Fragment-initializeFromPoints"></a>



<h4>Method <code>initializeFromPoints()</code></h4>

<p>Initialise a Fragment from a set of points
</p>


<h5>Usage</h5>

<div class="r"><pre>Fragment$initializeFromPoints(P)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>An N-by-2 matrix of points of the <code>Outline</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Fragment-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Fragment$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='identity.transform'>The identity transformation</h2><span id='topic+identity.transform'></span>

<h3>Description</h3>

<p>The identity transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identity.transform(r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identity.transform_+3A_r">r</code></td>
<td>
<p>Coordinates of points in spherical coordinates
represented as  2 column matrix with column names <code>phi</code>
(latitude) and <code>lambda</code> (longitude).</p>
</td></tr>
<tr><td><code id="identity.transform_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Identical matrix
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='idt.read.dataset'>Read one of the Thompson lab's retinal datasets</h2><span id='topic+idt.read.dataset'></span>

<h3>Description</h3>

<p>Read one of the Thompson lab's retinal datasets. Each dataset is a
folder containing a SYS file in SYSTAT format and a MAP file in
text format. The SYS file specifies the locations of the data
points and the MAP file specifies the outline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idt.read.dataset(dataset, report = message, d.close = 0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idt.read.dataset_+3A_dataset">dataset</code></td>
<td>
<p>Path to directory containing as SYS and MAP file</p>
</td></tr>
<tr><td><code id="idt.read.dataset_+3A_report">report</code></td>
<td>
<p>Function to report progress</p>
</td></tr>
<tr><td><code id="idt.read.dataset_+3A_d.close">d.close</code></td>
<td>
<p>Maximum distance between points for them to count
as the same point. This is expressed as a fraction of the width of
the outline.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns the outline of the retina. In order to do so,
it has to join up the segments of the MAP file. The tracings are
not always precise; sometimes there are gaps between points that
are actually the same point. The parameter <code>d.close</code> specifies
how close points must be to count as the same point.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dataset</code></td>
<td>
<p>The path to the directory given as an argument</p>
</td></tr>
<tr><td><code>raw</code></td>
<td>
<p>List containing</p>

<dl>
<dt><code>map</code></dt><dd><p>The raw MAP data</p>
</dd>
<dt><code>sys</code></dt><dd><p>The raw SYS data</p>
</dd>
</dl>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>The points of the outline</p>
</td></tr>
<tr><td><code>gf</code></td>
<td>
<p>Forward pointers along the outline</p>
</td></tr>
<tr><td><code>gb</code></td>
<td>
<p>Backward pointers along the outline</p>
</td></tr>
<tr><td><code>Ds</code></td>
<td>
<p>List of datapoints</p>
</td></tr>
<tr><td><code>Ss</code></td>
<td>
<p>List of landmark lines</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='ijroi.read.dataset'>Read a retinal dataset in IJROI format</h2><span id='topic+ijroi.read.dataset'></span>

<h3>Description</h3>

<p>Read a retinal dataset in IJROI format. Each dataset is a folder
containing a file called <code>outline.roi</code> that specifies the
outline in X-Y coordinates. It may also contain a file
<code>datapoints.csv</code>, containing the locations of data points;
see <code><a href="#topic+read.datapoints">read.datapoints</a></code> for the format of this file. The
folder may also contain a file <code>od.roi</code> specifying the
coordinates of the optic disc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ijroi.read.dataset(dataset, report = report)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ijroi.read.dataset_+3A_dataset">dataset</code></td>
<td>
<p>Path to directory containing <code>outline.roi</code></p>
</td></tr>
<tr><td><code id="ijroi.read.dataset_+3A_report">report</code></td>
<td>
<p>Function to report progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+RetinalOutline">RetinalOutline</a></code> object
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='ijroimulti.read.dataset'>Read a retinal dataset in IJROI format</h2><span id='topic+ijroimulti.read.dataset'></span>

<h3>Description</h3>

<p>Read a retinal dataset in IJROI format. Each dataset is a folder
containing a file called <code>outline.roi</code> that specifies the
outline in X-Y coordinates. It may also contain a file
<code>datapoints.csv</code>, containing the locations of data points;
see <code><a href="#topic+read.datapoints">read.datapoints</a></code> for the format of this file. The
folder may also contain a file <code>od.roi</code> specifying the
coordinates of the optic disc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ijroimulti.read.dataset(dataset)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ijroimulti.read.dataset_+3A_dataset">dataset</code></td>
<td>
<p>Path to directory containing <code>outline.roi</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+RetinalOutline">RetinalOutline</a></code> object
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='interpolate.image'>Interpolate values in image</h2><span id='topic+interpolate.image'></span>

<h3>Description</h3>

<p>Interpolate values in image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate.image(im, P, invert.y = FALSE, wmin = 10, wmax = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate.image_+3A_im">im</code></td>
<td>
<p>image to interpolate</p>
</td></tr>
<tr><td><code id="interpolate.image_+3A_p">P</code></td>
<td>
<p>N by 2 matrix of x, y values at which to interpolate. x
is in range <code>[0, ncol(im)]</code> and y is in range <code>[0, nrow(im)]</code></p>
</td></tr>
<tr><td><code id="interpolate.image_+3A_invert.y">invert.y</code></td>
<td>
<p>If <code>FALSE</code> (the default), the y coordinate is
zero at the top of the image. <code>TRUE</code> the zero y coordinate
is at the bottom.</p>
</td></tr>
<tr><td><code id="interpolate.image_+3A_wmin">wmin</code></td>
<td>
<p>minimum window size for inferring NA values</p>
</td></tr>
<tr><td><code id="interpolate.image_+3A_wmax">wmax</code></td>
<td>
<p>maximum window size for inferring NA values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of N interpolated values
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='invert.sphere'>Invert sphere about its centre</h2><span id='topic+invert.sphere'></span>

<h3>Description</h3>

<p>Invert sphere about its centre
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert.sphere(r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invert.sphere_+3A_r">r</code></td>
<td>
<p>Coordinates of points in spherical coordinates
represented as  2 column matrix with column names <code>phi</code>
(latitude) and <code>lambda</code> (longitude).</p>
</td></tr>
<tr><td><code id="invert.sphere_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix in same format, but with <code>pi</code> added to lambda
and <code>phi</code> negated.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='invert.sphere.to.hemisphere'>Invert sphere to hemisphere</h2><span id='topic+invert.sphere.to.hemisphere'></span>

<h3>Description</h3>

<p>Invert image of a partial sphere and scale the longitude so that
points at latitude <code>phi0</code> is projected onto a longitude of 0
degrees (the equator).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert.sphere.to.hemisphere(r, phi0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invert.sphere.to.hemisphere_+3A_r">r</code></td>
<td>
<p>Coordinates of points in spherical coordinates
represented as  2 column matrix with column names <code>phi</code>
(latitude) and <code>lambda</code> (longitude).</p>
</td></tr>
<tr><td><code id="invert.sphere.to.hemisphere_+3A_phi0">phi0</code></td>
<td>
<p>The latitude to map onto the equator</p>
</td></tr>
<tr><td><code id="invert.sphere.to.hemisphere_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix in same format, but with <code>pi</code> added to lambda
and <code>phi</code> negated and scaled so that the longitude
<code>phi0</code> is projected to 0 degrees (the equator)
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='karcher.mean.sphere'>Karcher mean on the sphere</h2><span id='topic+karcher.mean.sphere'></span>

<h3>Description</h3>

<p>The Karcher mean of a set of points on a manifold is defined as
the point whose sum of squared Riemann distances to the points is
minimal. On a sphere using spherical coordinates this distance
can be computed using the formula for central angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>karcher.mean.sphere(x, na.rm = FALSE, var = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="karcher.mean.sphere_+3A_x">x</code></td>
<td>
<p>Matrix of points on sphere as N-by-2 matrix with labelled
columns <code>phi</code> (latitude) and <code>lambda</code> (longitude)</p>
</td></tr>
<tr><td><code id="karcher.mean.sphere_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values should
be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="karcher.mean.sphere_+3A_var">var</code></td>
<td>
<p>logical value indicating whether variance should be
returned too.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of means with components named <code>phi</code> and
<code>lambda</code>. If <code>var</code> is <code>TRUE</code>, a list containing
mean and variance in elements <code>mean</code> and <code>var</code>.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>References</h3>

<p>Heo, G. and Small, C. G. (2006). Form representations
and means for landmarks: A survey and comparative
study. <em>Computer Vision and Image Understanding</em>,
102:188-203.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+central.angle">central.angle</a></code>
</p>

<hr>
<h2 id='kde.compute.concentration'>Find the optimal concentration for a set of data</h2><span id='topic+kde.compute.concentration'></span>

<h3>Description</h3>

<p>Find the optimal concentration for a set of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde.compute.concentration(mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kde.compute.concentration_+3A_mu">mu</code></td>
<td>
<p>Data in spherical coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimal concentration
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='kde.fhat'>Kernel density estimate on sphere using Fisherian density
with polar coordinates</h2><span id='topic+kde.fhat'></span>

<h3>Description</h3>

<p>Kernel density estimate on sphere using Fisherian density
with polar coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde.fhat(r, mu, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kde.fhat_+3A_r">r</code></td>
<td>
<p>Locations at which to estimate density in polar
coordinates</p>
</td></tr>
<tr><td><code id="kde.fhat_+3A_mu">mu</code></td>
<td>
<p>Locations of data points in polar coordinates</p>
</td></tr>
<tr><td><code id="kde.fhat_+3A_kappa">kappa</code></td>
<td>
<p>Concentration parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of density estimates
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='kde.fhat.cart'>Kernel density estimate on sphere using Fisherian density
with Cartesian coordinates</h2><span id='topic+kde.fhat.cart'></span>

<h3>Description</h3>

<p>Kernel density estimate on sphere using Fisherian density
with Cartesian coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde.fhat.cart(r, mu, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kde.fhat.cart_+3A_r">r</code></td>
<td>
<p>Locations at which to estimate density in Cartesian
coordinates on unit sphere</p>
</td></tr>
<tr><td><code id="kde.fhat.cart_+3A_mu">mu</code></td>
<td>
<p>Locations of data points in Cartesian coordinates on
unit sphere</p>
</td></tr>
<tr><td><code id="kde.fhat.cart_+3A_kappa">kappa</code></td>
<td>
<p>Concentration parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of density estimates
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='kde.L'>Estimate of the log likelihood of the points mu given a
particular value of the concentration kappa</h2><span id='topic+kde.L'></span>

<h3>Description</h3>

<p>Estimate of the log likelihood of the points mu given a
particular value of the concentration kappa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde.L(mu, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kde.L_+3A_mu">mu</code></td>
<td>
<p>Locations of data points in Cartesian coordinates on
unit sphere</p>
</td></tr>
<tr><td><code id="kde.L_+3A_kappa">kappa</code></td>
<td>
<p>Concentration parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log likelihood of data
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='kr.compute.concentration'>Find the optimal concentration for a set of data</h2><span id='topic+kr.compute.concentration'></span>

<h3>Description</h3>

<p>Find the optimal concentration for a set of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kr.compute.concentration(mu, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kr.compute.concentration_+3A_mu">mu</code></td>
<td>
<p>Locations in Cartesian coordinates (independent variables)</p>
</td></tr>
<tr><td><code id="kr.compute.concentration_+3A_y">y</code></td>
<td>
<p>Values at locations (dependent variables)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimal concentration
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='kr.sscv'>Cross validation estimate of the least squares error of the
points mu given a particular value of the concentration kappa</h2><span id='topic+kr.sscv'></span>

<h3>Description</h3>

<p>Cross validation estimate of the least squares error of the
points mu given a particular value of the concentration kappa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kr.sscv(mu, y, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kr.sscv_+3A_mu">mu</code></td>
<td>
<p>Locations in Cartesian coordinates (independent variables)</p>
</td></tr>
<tr><td><code id="kr.sscv_+3A_y">y</code></td>
<td>
<p>Values at locations (dependent variables)</p>
</td></tr>
<tr><td><code id="kr.sscv_+3A_kappa">kappa</code></td>
<td>
<p>Concentration parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Least squares error
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='kr.yhat'>Kernel regression on sphere using Fisherian density with
polar coordinates</h2><span id='topic+kr.yhat'></span>

<h3>Description</h3>

<p>Kernel regression on sphere using Fisherian density with
polar coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kr.yhat(r, mu, y, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kr.yhat_+3A_r">r</code></td>
<td>
<p>Locations at which to estimate dependent variables in
polar coordinates</p>
</td></tr>
<tr><td><code id="kr.yhat_+3A_mu">mu</code></td>
<td>
<p>Locations in polar coordinates (independent variables)</p>
</td></tr>
<tr><td><code id="kr.yhat_+3A_y">y</code></td>
<td>
<p>Values at data points (dependent variables)</p>
</td></tr>
<tr><td><code id="kr.yhat_+3A_kappa">kappa</code></td>
<td>
<p>Concentration parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimates of dependent variables at locations <code>r</code>
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='kr.yhat.cart'>Kernel regression on sphere using Fisherian density with
Cartesian coordinates</h2><span id='topic+kr.yhat.cart'></span>

<h3>Description</h3>

<p>Kernel regression on sphere using Fisherian density with
Cartesian coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kr.yhat.cart(r, mu, y, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kr.yhat.cart_+3A_r">r</code></td>
<td>
<p>Locations at which to estimate dependent variables in
Cartesian coordinates</p>
</td></tr>
<tr><td><code id="kr.yhat.cart_+3A_mu">mu</code></td>
<td>
<p>Locations in Cartesian coordinates (independent variables)</p>
</td></tr>
<tr><td><code id="kr.yhat.cart_+3A_y">y</code></td>
<td>
<p>Values at locations (dependent variables)</p>
</td></tr>
<tr><td><code id="kr.yhat.cart_+3A_kappa">kappa</code></td>
<td>
<p>Concentration parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimates of dependent variables at locations <code>r</code>
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='LandmarkSet'>Subclass of <code><a href="#topic+FeatureSet">FeatureSet</a></code> to represent points</h2><span id='topic+LandmarkSet'></span>

<h3>Description</h3>

<p>A LandmarkSet contains information about points
located on <code><a href="#topic+Outline">Outline</a></code>s. Each LandmarkSet contains a
list of matrices, each of which has columns labelled <code>X</code>
and <code>Y</code> describing the cartesian coordinates (in the
unscaled coordinate frame) of points in landmarks on the
Outline.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+FeatureSetCommon">retistruct::FeatureSetCommon</a></code> -&gt; <code><a href="#topic+FeatureSet">retistruct::FeatureSet</a></code> -&gt; <code>LandmarkSet</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LandmarkSet-new"><code>LandmarkSet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LandmarkSet-reconstruct"><code>LandmarkSet$reconstruct()</code></a>
</p>
</li>
<li> <p><a href="#method-LandmarkSet-clone"><code>LandmarkSet$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getCol"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getCol'><code>retistruct::FeatureSetCommon$getCol()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeature"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeature'><code>retistruct::FeatureSetCommon$getFeature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeatures"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeatures'><code>retistruct::FeatureSetCommon$getFeatures()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIDs"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIDs'><code>retistruct::FeatureSetCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIndex"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIndex'><code>retistruct::FeatureSetCommon$getIndex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="setID"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-setID'><code>retistruct::FeatureSetCommon$setID()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-LandmarkSet-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>LandmarkSet$new(data = NULL, cols = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>List of matrices describing data. Each matrix
should have columns named <code>X</code> and <code>Y</code></p>
</dd>
<dt><code>cols</code></dt><dd><p>Named vector of colours for each data set. The name is
used as the ID (label) for the data set. The colours should be names
present in the output of the <code><a href="grDevices.html#topic+colors">colors</a></code> function</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LandmarkSet-reconstruct"></a>



<h4>Method <code>reconstruct()</code></h4>

<p>Map the LandmarkSet to a <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>LandmarkSet$reconstruct(ro)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ro</code></dt><dd><p>The <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-LandmarkSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LandmarkSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='line.line.intersection'>Determine intersection between two lines</h2><span id='topic+line.line.intersection'></span>

<h3>Description</h3>

<p>Determine the intersection of two lines L1 and L2 in two dimensions,
using the formula described by Weisstein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line.line.intersection(P1, P2, P3, P4, interior.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="line.line.intersection_+3A_p1">P1</code></td>
<td>
<p>vector containing x,y coordinates of one end of L1</p>
</td></tr>
<tr><td><code id="line.line.intersection_+3A_p2">P2</code></td>
<td>
<p>vector containing x,y coordinates of other end of L1</p>
</td></tr>
<tr><td><code id="line.line.intersection_+3A_p3">P3</code></td>
<td>
<p>vector containing x,y coordinates of one end of L2</p>
</td></tr>
<tr><td><code id="line.line.intersection_+3A_p4">P4</code></td>
<td>
<p>vector containing x,y coordinates of other end of L2</p>
</td></tr>
<tr><td><code id="line.line.intersection_+3A_interior.only">interior.only</code></td>
<td>
<p>boolean flag indicating whether only
intersections inside L1 and L2 should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing x,y coordinates of intersection of L1
and L2.  If L1 and L2 are parallel, this is infinite-valued.  If
<code>interior.only</code> is <code>TRUE</code>, then when the intersection
does not occur between P1 and P2 and P3 and P4, a vector
containing <code>NA</code>s is returned.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>Source</h3>

<p>Weisstein, Eric W. &quot;Line-Line Intersection.&quot;
From MathWorld&ndash;A Wolfram Web Resource.
<a href="http://mathworld.wolfram.com/Line-LineIntersection.html">http://mathworld.wolfram.com/Line-LineIntersection.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Intersection of two intersecting lines
line.line.intersection(c(0, 0), c(1, 1), c(0, 1), c(1, 0))

## Two lines that don't intersect
line.line.intersection(c(0, 0), c(0, 1), c(1, 0), c(1, 1))
</code></pre>

<hr>
<h2 id='list_to_R6'>Convert an list created by R6_to_list() into an R6 object.</h2><span id='topic+list_to_R6'></span>

<h3>Description</h3>

<p>Convert an list created by R6_to_list() into an R6 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_to_R6(l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_to_R6_+3A_l">l</code></td>
<td>
<p>list created by R6_to_list()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R6 object or list list
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='list.datasets'>List datasets underneath a directory</h2><span id='topic+list.datasets'></span>

<h3>Description</h3>

<p>List valid datasets underneath a directory. This reports all
directories that appear to be valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.datasets(path = ".", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list.datasets_+3A_path">path</code></td>
<td>
<p>Directory path to start searching from</p>
</td></tr>
<tr><td><code id="list.datasets_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> report on progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of directories containing datasets
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='lvsLplot'>Plot the fractional change in length of mesh edges</h2><span id='topic+lvsLplot'></span>

<h3>Description</h3>

<p>Plot the fractional change in length of mesh edges. The length of
each edge in the mesh in the reconstructed object is plotted
against each edge in the spherical object. The points are
colour-coded according to the amount of log strain each edge is
under.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lvsLplot(r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lvsLplot_+3A_r">r</code></td>
<td>
<p><code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code> object</p>
</td></tr>
<tr><td><code id="lvsLplot_+3A_...">...</code></td>
<td>
<p>Other plotting parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='morph.dataset.to.parabola'>Morph a flat dataset to a parabola for testing purposes</h2><span id='topic+morph.dataset.to.parabola'></span>

<h3>Description</h3>

<p>Morph a flat dataset to a parabola for testing purposes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morph.dataset.to.parabola(
  orig.dataset = file.path(system.file(package = "retistruct"), "extdata", "smi32-csv"),
  morphed.dataset = NA,
  f = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="morph.dataset.to.parabola_+3A_orig.dataset">orig.dataset</code></td>
<td>
<p>Directory of original dataset</p>
</td></tr>
<tr><td><code id="morph.dataset.to.parabola_+3A_morphed.dataset">morphed.dataset</code></td>
<td>
<p>Directory to write morphed dataset to. If
NA, a temporary directory will be created</p>
</td></tr>
<tr><td><code id="morph.dataset.to.parabola_+3A_f">f</code></td>
<td>
<p>Focus of parabola</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Path to <code>morphed.dataset</code>
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='name.list'>Return a new version of the list in which any unnamed elements
have been given standardised names</h2><span id='topic+name.list'></span>

<h3>Description</h3>

<p>Return a new version of the list in which any unnamed elements
have been given standardised names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name.list(l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name.list_+3A_l">l</code></td>
<td>
<p>the list with unnamed elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list with standardised names
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='normalise.angle'>Bring angle into range</h2><span id='topic+normalise.angle'></span>

<h3>Description</h3>

<p>Bring angle into range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise.angle(theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalise.angle_+3A_theta">theta</code></td>
<td>
<p>Angle to bring into range <code>[-pi, pi]</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalised angle
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='orthographic'>Orthographic projection</h2><span id='topic+orthographic'></span>

<h3>Description</h3>

<p>Orthographic projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthographic(r, proj.centre = cbind(phi = 0, lambda = 0), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orthographic_+3A_r">r</code></td>
<td>
<p>Latitude-longitude coordinates in a matrix with columns
labelled <code>phi</code> (latitude) and <code>lambda</code> (longitude)</p>
</td></tr>
<tr><td><code id="orthographic_+3A_proj.centre">proj.centre</code></td>
<td>
<p>Location of centre of projection as matrix with
column names <code>phi</code> (elevation) and <code>lambda</code> (longitude).</p>
</td></tr>
<tr><td><code id="orthographic_+3A_...">...</code></td>
<td>
<p>Arguments not used by this projection.n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two-column matrix with columns labelled <code>x</code> and
<code>y</code> of locations of projection of coordinates on plane
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Map_projection">https://en.wikipedia.org/wiki/Map_projection</a>,
<a href="http://mathworld.wolfram.com/OrthographicProjection.html">http://mathworld.wolfram.com/OrthographicProjection.html</a>
</p>

<hr>
<h2 id='Outline'>Class containing basic information about flat outlines</h2><span id='topic+Outline'></span>

<h3>Description</h3>

<p>An Outline has contains the polygon describing the
outline and an image associated with the outline.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+OutlineCommon">retistruct::OutlineCommon</a></code> -&gt; <code>Outline</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>P</code></dt><dd><p>A N-by-2 matrix of points of the <code>Outline</code>
arranged in anticlockwise order</p>
</dd>
<dt><code>scale</code></dt><dd><p>The length of one unit of <code>P</code> in the X-Y plane in arbitrary units</p>
</dd>
<dt><code>scalez</code></dt><dd><p>The length of one unit of <code>P</code> in the Z-direction in arbitrary units</p>
</dd>
<dt><code>units</code></dt><dd><p>String giving units of scaled P, e.g. &ldquo;um&rdquo;</p>
</dd>
<dt><code>gf</code></dt><dd><p>For each row of <code>P</code>, the index of <code>P</code> that
is next in the outline travelling anticlockwise (forwards)</p>
</dd>
<dt><code>gb</code></dt><dd><p>For each row of <code>P</code>, the index of <code>P</code> that
is next in the outline travelling clockwise (backwards)</p>
</dd>
<dt><code>h</code></dt><dd><p>For each row of <code>P</code>, the cut of that
point (which will be to itself initially)</p>
</dd>
<dt><code>im</code></dt><dd><p>An image as a <code>raster</code> object</p>
</dd>
<dt><code>dm</code></dt><dd><p>Depthmap, with same dimensions as <code>im</code>, which indicates
height of each pixel in Z-direction</p>
</dd>
<dt><code>A.fragments</code></dt><dd><p>Areas of fragments</p>
</dd>
<dt><code>dm.inferna.window.min</code></dt><dd><p>Minimum window size (in pixels) for inferring missing values in depthmaps</p>
</dd>
<dt><code>dm.inferna.window.max</code></dt><dd><p>Minimum window size (in pixels) for inferring missing values in depthmaps</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Outline-new"><code>Outline$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getImage"><code>Outline$getImage()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-replaceImage"><code>Outline$replaceImage()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-mapFragment"><code>Outline$mapFragment()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-mapPids"><code>Outline$mapPids()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getDepth"><code>Outline$getDepth()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-addPoints"><code>Outline$addPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getFragmentPointIDs"><code>Outline$getFragmentPointIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getFragmentPoints"><code>Outline$getFragmentPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getFragment"><code>Outline$getFragment()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getFragmentIDsFromPointIDs"><code>Outline$getFragmentIDsFromPointIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getFragmentIDs"><code>Outline$getFragmentIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getPoints"><code>Outline$getPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getPointsXY"><code>Outline$getPointsXY()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getPointsScaled"><code>Outline$getPointsScaled()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getRimSet"><code>Outline$getRimSet()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getOutlineSet"><code>Outline$getOutlineSet()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-getOutlineLengths"><code>Outline$getOutlineLengths()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-addFeatureSet"><code>Outline$addFeatureSet()</code></a>
</p>
</li>
<li> <p><a href="#method-Outline-clone"><code>Outline$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="clearFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-clearFeatureSets'><code>retistruct::OutlineCommon$clearFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSet"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSet'><code>retistruct::OutlineCommon$getFeatureSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSetTypes"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSetTypes'><code>retistruct::OutlineCommon$getFeatureSetTypes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSets'><code>retistruct::OutlineCommon$getFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getIDs"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getIDs'><code>retistruct::OutlineCommon$getIDs()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Outline-new"></a>



<h4>Method <code>new()</code></h4>

<p>Construct an outline object. This sanitises the
input points <code>P</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$new(
  fragments = list(),
  scale = NA,
  im = NULL,
  scalez = NA,
  dm = NULL,
  units = NA
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fragments</code></dt><dd><p>A list of N-by-2 matrix of points for each fragment of the <code>Outline</code></p>
</dd>
<dt><code>scale</code></dt><dd><p>The length of one unit of <code>P</code> in arbitrary units</p>
</dd>
<dt><code>im</code></dt><dd><p>The image as a <code>raster</code> object</p>
</dd>
<dt><code>scalez</code></dt><dd><p>The length of one unit of <code>P</code> in the Z-direction in arbitrary units. If <code>NA</code>, the depthmap is ignored.</p>
</dd>
<dt><code>dm</code></dt><dd><p>Depthmap, with same dimensions as <code>im</code>, which indicates
height of each pixel in Z-direction</p>
</dd>
<dt><code>units</code></dt><dd><p>String giving units of scaled P, e.g. &ldquo;um&rdquo;</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Outline-getImage"></a>



<h4>Method <code>getImage()</code></h4>

<p>Image accessor
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getImage()</pre></div>



<h5>Returns</h5>

<p>An image as a <code>raster</code> object
</p>


<hr>
<a id="method-Outline-replaceImage"></a>



<h4>Method <code>replaceImage()</code></h4>

<p>Image setter
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$replaceImage(im)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>im</code></dt><dd><p>An image as a <code>raster</code> object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Outline-mapFragment"></a>



<h4>Method <code>mapFragment()</code></h4>

<p>Map the point IDs of a <a href="#topic+Fragment">Fragment</a> on the
point IDs of this Outline
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$mapFragment(fragment, pids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fragment</code></dt><dd><p><a href="#topic+Fragment">Fragment</a> to map</p>
</dd>
<dt><code>pids</code></dt><dd><p>Point IDs in Outline of points in <a href="#topic+Fragment">Fragment</a></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Outline-mapPids"></a>



<h4>Method <code>mapPids()</code></h4>

<p>Map references to points
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$mapPids(x, y, pids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>References to point indices in source</p>
</dd>
<dt><code>y</code></dt><dd><p>References to existing point indices in target</p>
</dd>
<dt><code>pids</code></dt><dd><p>IDs of points in point register</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New references to point indices in target
</p>


<hr>
<a id="method-Outline-getDepth"></a>



<h4>Method <code>getDepth()</code></h4>

<p>Get depth of points P
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getDepth(P)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>matrix containing unscaled X-Y coordinates of points</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of unscaled Z coordinates of points P
</p>


<hr>
<a id="method-Outline-addPoints"></a>



<h4>Method <code>addPoints()</code></h4>

<p>Add points to the outline register of points
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$addPoints(P, fid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>2 or 3 column matrix of points to add</p>
</dd>
<dt><code>fid</code></dt><dd><p>ID of fragment to which to add  the points</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The ID of each added point in the register. If points already
exist a point will not be created in the register,
but an ID will be returned
</p>


<hr>
<a id="method-Outline-getFragmentPointIDs"></a>



<h4>Method <code>getFragmentPointIDs()</code></h4>

<p>Get the point IDs in a fragment
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getFragmentPointIDs(fid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fid</code></dt><dd><p>fragment id of the points</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of point IDs, i.e. indices of the rows in
the matrices returned by <code>getPoints</code> and
<code>getPointsScaled</code>
</p>


<hr>
<a id="method-Outline-getFragmentPoints"></a>



<h4>Method <code>getFragmentPoints()</code></h4>

<p>Get the points in a fragment
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getFragmentPoints(fid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fid</code></dt><dd><p>fragment id of the points</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of points
</p>


<hr>
<a id="method-Outline-getFragment"></a>



<h4>Method <code>getFragment()</code></h4>

<p>Get fragment
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getFragment(fid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fid</code></dt><dd><p>Fragment ID</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The  <code><a href="#topic+Fragment">Fragment</a></code> object with ID fid
</p>


<hr>
<a id="method-Outline-getFragmentIDsFromPointIDs"></a>



<h4>Method <code>getFragmentIDsFromPointIDs()</code></h4>

<p>Get fragment IDs from point IDS
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getFragmentIDsFromPointIDs(pids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pids</code></dt><dd><p>Vector of point IDs</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The Fragment ID to which each point belongs
</p>


<hr>
<a id="method-Outline-getFragmentIDs"></a>



<h4>Method <code>getFragmentIDs()</code></h4>

<p>Get fragment IDs
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getFragmentIDs()</pre></div>



<h5>Returns</h5>

<p>IDs of all fragments
</p>


<hr>
<a id="method-Outline-getPoints"></a>



<h4>Method <code>getPoints()</code></h4>

<p>Get unscaled mesh points
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getPoints(pids = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pids</code></dt><dd><p>IDs of point to return</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Matrix with columns <code>X</code>, <code>Y</code> and <code>Z</code>
</p>


<hr>
<a id="method-Outline-getPointsXY"></a>



<h4>Method <code>getPointsXY()</code></h4>

<p>Get X-Y coordinates of unscaled mesh points
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getPointsXY(pids = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pids</code></dt><dd><p>IDs of point to return</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Matrix with columns <code>X</code> and <code>Y</code>
</p>


<hr>
<a id="method-Outline-getPointsScaled"></a>



<h4>Method <code>getPointsScaled()</code></h4>

<p>Get scaled mesh points
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getPointsScaled()</pre></div>



<h5>Returns</h5>

<p>Matrix with columns <code>X</code> and <code>Y</code> which is
exactly <code>scale</code> times the matrix returned by <code>getPoints</code>
</p>


<hr>
<a id="method-Outline-getRimSet"></a>



<h4>Method <code>getRimSet()</code></h4>

<p>Get set of points on rim
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getRimSet()</pre></div>



<h5>Returns</h5>

<p>Vector of point IDs, i.e. indices of the rows in
the matrices returned by <code>getPoints</code> and
<code>getPointsScaled</code>
</p>


<hr>
<a id="method-Outline-getOutlineSet"></a>



<h4>Method <code>getOutlineSet()</code></h4>

<p>Get points on the edge of the outline
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getOutlineSet()</pre></div>



<h5>Returns</h5>

<p>Vector of points IDs on outline
</p>


<hr>
<a id="method-Outline-getOutlineLengths"></a>



<h4>Method <code>getOutlineLengths()</code></h4>

<p>Get lengths of edges of the outline
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$getOutlineLengths()</pre></div>



<h5>Returns</h5>

<p>Vector of lengths of edges connecting neighbouring points
</p>


<hr>
<a id="method-Outline-addFeatureSet"></a>



<h4>Method <code>addFeatureSet()</code></h4>

<p>Add a <a href="#topic+FeatureSet">FeatureSet</a>, e.g. a <a href="#topic+PointSet">PointSet</a>
or <a href="#topic+LandmarkSet">LandmarkSet</a>
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$addFeatureSet(fs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fs</code></dt><dd><p><a href="#topic+FeatureSet">FeatureSet</a> to add</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Outline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Outline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='OutlineCommon'>Class containing functionality common to flat and reconstructed outlines</h2><span id='topic+OutlineCommon'></span>

<h3>Description</h3>

<p>An OutlineCommon has functionality for retrieving
sets of features (e.g. points or landmarks associated with an
outline)
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>version</code></dt><dd><p>Version of reconstruction file data format</p>
</dd>
<dt><code>featureSets</code></dt><dd><p>List of feature sets associated with the outline, which may be of various types, e.g. a <a href="#topic+PointSet">PointSet</a> or <a href="#topic+LandmarkSet">LandmarkSet</a></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OutlineCommon-getFeatureSets"><code>OutlineCommon$getFeatureSets()</code></a>
</p>
</li>
<li> <p><a href="#method-OutlineCommon-getFeatureSet"><code>OutlineCommon$getFeatureSet()</code></a>
</p>
</li>
<li> <p><a href="#method-OutlineCommon-clearFeatureSets"><code>OutlineCommon$clearFeatureSets()</code></a>
</p>
</li>
<li> <p><a href="#method-OutlineCommon-getIDs"><code>OutlineCommon$getIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-OutlineCommon-getFeatureSetTypes"><code>OutlineCommon$getFeatureSetTypes()</code></a>
</p>
</li>
<li> <p><a href="#method-OutlineCommon-clone"><code>OutlineCommon$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-OutlineCommon-getFeatureSets"></a>



<h4>Method <code>getFeatureSets()</code></h4>

<p>Get all the feature sets
</p>


<h5>Usage</h5>

<div class="r"><pre>OutlineCommon$getFeatureSets()</pre></div>



<h5>Returns</h5>

<p>List of <a href="#topic+FeatureSet">FeatureSet</a>s associated with the outline
</p>


<hr>
<a id="method-OutlineCommon-getFeatureSet"></a>



<h4>Method <code>getFeatureSet()</code></h4>

<p>Get all feature sets of a particular type, e.g. <a href="#topic+PointSet">PointSet</a> or <a href="#topic+LandmarkSet">LandmarkSet</a>
</p>


<h5>Usage</h5>

<div class="r"><pre>OutlineCommon$getFeatureSet(type)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>The type of the feature set as a string</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>All <a href="#topic+FeatureSet">FeatureSet</a>s of that type
</p>


<hr>
<a id="method-OutlineCommon-clearFeatureSets"></a>



<h4>Method <code>clearFeatureSets()</code></h4>

<p>Clear all feature sets from the outline
</p>


<h5>Usage</h5>

<div class="r"><pre>OutlineCommon$clearFeatureSets()</pre></div>


<hr>
<a id="method-OutlineCommon-getIDs"></a>



<h4>Method <code>getIDs()</code></h4>

<p>Get all the distinct IDs contained in the <a href="#topic+FeatureSet">FeatureSet</a>s
</p>


<h5>Usage</h5>

<div class="r"><pre>OutlineCommon$getIDs()</pre></div>



<h5>Returns</h5>

<p>Vector of IDs
</p>


<hr>
<a id="method-OutlineCommon-getFeatureSetTypes"></a>



<h4>Method <code>getFeatureSetTypes()</code></h4>

<p>Get all the distinct types of <a href="#topic+FeatureSet">FeatureSet</a>s
</p>


<h5>Usage</h5>

<div class="r"><pre>OutlineCommon$getFeatureSetTypes()</pre></div>



<h5>Returns</h5>

<p>Vector of types as strings, e.g. <var>PointSet</var>, <var>LandmarkSet</var>
</p>


<hr>
<a id="method-OutlineCommon-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OutlineCommon$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='panlabel'>Ancillary function to place labels</h2><span id='topic+panlabel'></span>

<h3>Description</h3>

<p>Ancillary function to place labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panlabel(panlabel, line = -0.7)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panlabel_+3A_panlabel">panlabel</code></td>
<td>
<p>Label text</p>
</td></tr>
<tr><td><code id="panlabel_+3A_line">line</code></td>
<td>
<p>Line on which to appear</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='parabola.arclength'>Arc length of a parabola y=x^2/4f</h2><span id='topic+parabola.arclength'></span>

<h3>Description</h3>

<p>Arc length of a parabola y=x^2/4f
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parabola.arclength(x1, x2, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parabola.arclength_+3A_x1">x1</code></td>
<td>
<p>x co-ordinate of start of arc</p>
</td></tr>
<tr><td><code id="parabola.arclength_+3A_x2">x2</code></td>
<td>
<p>x co-ordinate of end of arc</p>
</td></tr>
<tr><td><code id="parabola.arclength_+3A_f">f</code></td>
<td>
<p>focal length of parabola</p>
</td></tr>
</table>


<h3>Value</h3>

<p>length of parabola arc
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='parabola.invarclength'>Inverse arc length of a parabola y=x^2/4f</h2><span id='topic+parabola.invarclength'></span>

<h3>Description</h3>

<p>Inverse arc length of a parabola y=x^2/4f
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parabola.invarclength(x1, s, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parabola.invarclength_+3A_x1">x1</code></td>
<td>
<p>co-ordinate of start of arc</p>
</td></tr>
<tr><td><code id="parabola.invarclength_+3A_s">s</code></td>
<td>
<p>length of parabola arc to follow</p>
</td></tr>
<tr><td><code id="parabola.invarclength_+3A_f">f</code></td>
<td>
<p>focal length of parabola</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x co-ordinate of end of arc
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='parse.dependencies'>Parse dependencies</h2><span id='topic+parse.dependencies'></span>

<h3>Description</h3>

<p>Parse dependencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.dependencies(deps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse.dependencies_+3A_deps">deps</code></td>
<td>
<p>Text produced by, e.g., <code>installed.packages()["packagename","Suggests"]</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Table with package column, relationship column and version number
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='PathOutline'>Add point fullcuts to the outline</h2><span id='topic+PathOutline'></span>

<h3>Description</h3>

<p>Add point fullcuts to the outline
</p>
<p>Add point fullcuts to the outline
</p>


<h3>Details</h3>

<p>The member function <code>stitchSubpaths()</code> stitches together two
subpaths of the outline. One subpath is stitched in the forward
direction from the point indexed by <code>VF0</code> to the point
indexed by <code>VF1</code>. The other is stitched in the backward
direction from <code>VB0</code> to <code>VB1</code>. Each point in the subpath
is linked to points in the opposing pathway at an equal or
near-equal fraction along. If a point exists in the opposing
pathway within a distance <code>epsilon</code> of the projection, this
point is connected. If no point exists within this tolerance, a
new point is created.
</p>


<h3>Value</h3>

<p>To the <code><a href="#topic+Outline">Outline</a></code> object this adds
</p>
<table role = "presentation">
<tr><td><code>hf</code></td>
<td>
<p>point cut mapping in forward direction for
points on boundary</p>
</td></tr>
<tr><td><code>hb</code></td>
<td>
<p>point cut mapping in backward direction for
points on boundary</p>
</td></tr>
</table>


<h3>Super classes</h3>

<p><code><a href="#topic+OutlineCommon">retistruct::OutlineCommon</a></code> -&gt; <code><a href="#topic+Outline">retistruct::Outline</a></code> -&gt; <code>PathOutline</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>hf</code></dt><dd><p>Forward fullcuts</p>
</dd>
<dt><code>hb</code></dt><dd><p>Backward fullcuts</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PathOutline-addPoints"><code>PathOutline$addPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-PathOutline-nextPoint"><code>PathOutline$nextPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-PathOutline-insertPoint"><code>PathOutline$insertPoint()</code></a>
</p>
</li>
<li> <p><a href="#method-PathOutline-stitchSubpaths"><code>PathOutline$stitchSubpaths()</code></a>
</p>
</li>
<li> <p><a href="#method-PathOutline-clone"><code>PathOutline$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="clearFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-clearFeatureSets'><code>retistruct::OutlineCommon$clearFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSet"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSet'><code>retistruct::OutlineCommon$getFeatureSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSetTypes"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSetTypes'><code>retistruct::OutlineCommon$getFeatureSetTypes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSets'><code>retistruct::OutlineCommon$getFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getIDs"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getIDs'><code>retistruct::OutlineCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="addFeatureSet"><a href='../../retistruct/html/Outline.html#method-Outline-addFeatureSet'><code>retistruct::Outline$addFeatureSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getDepth"><a href='../../retistruct/html/Outline.html#method-Outline-getDepth'><code>retistruct::Outline$getDepth()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragment"><a href='../../retistruct/html/Outline.html#method-Outline-getFragment'><code>retistruct::Outline$getFragment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentIDs'><code>retistruct::Outline$getFragmentIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentIDsFromPointIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentIDsFromPointIDs'><code>retistruct::Outline$getFragmentIDsFromPointIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentPointIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentPointIDs'><code>retistruct::Outline$getFragmentPointIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentPoints"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentPoints'><code>retistruct::Outline$getFragmentPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getImage"><a href='../../retistruct/html/Outline.html#method-Outline-getImage'><code>retistruct::Outline$getImage()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getOutlineLengths"><a href='../../retistruct/html/Outline.html#method-Outline-getOutlineLengths'><code>retistruct::Outline$getOutlineLengths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getOutlineSet"><a href='../../retistruct/html/Outline.html#method-Outline-getOutlineSet'><code>retistruct::Outline$getOutlineSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPoints"><a href='../../retistruct/html/Outline.html#method-Outline-getPoints'><code>retistruct::Outline$getPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPointsScaled"><a href='../../retistruct/html/Outline.html#method-Outline-getPointsScaled'><code>retistruct::Outline$getPointsScaled()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPointsXY"><a href='../../retistruct/html/Outline.html#method-Outline-getPointsXY'><code>retistruct::Outline$getPointsXY()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getRimSet"><a href='../../retistruct/html/Outline.html#method-Outline-getRimSet'><code>retistruct::Outline$getRimSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="initialize"><a href='../../retistruct/html/Outline.html#method-Outline-initialize'><code>retistruct::Outline$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="mapFragment"><a href='../../retistruct/html/Outline.html#method-Outline-mapFragment'><code>retistruct::Outline$mapFragment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="mapPids"><a href='../../retistruct/html/Outline.html#method-Outline-mapPids'><code>retistruct::Outline$mapPids()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="replaceImage"><a href='../../retistruct/html/Outline.html#method-Outline-replaceImage'><code>retistruct::Outline$replaceImage()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PathOutline-addPoints"></a>



<h4>Method <code>addPoints()</code></h4>

<p>Add points to the outline register of points
</p>


<h5>Usage</h5>

<div class="r"><pre>PathOutline$addPoints(P, fid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>2 column matrix of points to add</p>
</dd>
<dt><code>fid</code></dt><dd><p>fragment id of the points</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The ID of each added point in the register. If points already
exist a point will not be created in the register,
but an ID will be returned
</p>


<hr>
<a id="method-PathOutline-nextPoint"></a>



<h4>Method <code>nextPoint()</code></h4>

<p>Get next point in path for
</p>


<h5>Usage</h5>

<div class="r"><pre>PathOutline$nextPoint(pids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pids</code></dt><dd><p>Point IDs of points to get next position</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PathOutline-insertPoint"></a>



<h4>Method <code>insertPoint()</code></h4>

<p>Insert point at a fractional distance between points
</p>


<h5>Usage</h5>

<div class="r"><pre>PathOutline$insertPoint(i0, i1, f)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i0</code></dt><dd><p>Point ID of first point</p>
</dd>
<dt><code>i1</code></dt><dd><p>Point ID of second point</p>
</dd>
<dt><code>f</code></dt><dd><p>Fraction of distance  between points <code>i0</code> and
<code>i1</code> at which to insert point</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PathOutline-stitchSubpaths"></a>



<h4>Method <code>stitchSubpaths()</code></h4>

<p>Stitch subpaths
</p>


<h5>Usage</h5>

<div class="r"><pre>PathOutline$stitchSubpaths(VF0, VF1, VB0, VB1, epsilon)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>VF0</code></dt><dd><p>First vertex of &ldquo;forward&rdquo; subpath</p>
</dd>
<dt><code>VF1</code></dt><dd><p>Second vertex of &ldquo;forward&rdquo; subpath</p>
</dd>
<dt><code>VB0</code></dt><dd><p>First vertex of &ldquo;backward&rdquo; subpath</p>
</dd>
<dt><code>VB1</code></dt><dd><p>Second vertex of &ldquo;backward&rdquo; subpath</p>
</dd>
<dt><code>epsilon</code></dt><dd><p>Minimum distance between points</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PathOutline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PathOutline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='PointSet'>Subclass of <code><a href="#topic+FeatureSet">FeatureSet</a></code> to represent points</h2><span id='topic+PointSet'></span>

<h3>Description</h3>

<p>A PointSet contains information about points located
on <code><a href="#topic+Outline">Outline</a></code>s. Each PointSet contains a list of
matrices, each of which has columns labelled <code>X</code> and
<code>Y</code> describing the cartesian coordinates (in the unscaled
coordinate frame) of points on the Outline.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+FeatureSetCommon">retistruct::FeatureSetCommon</a></code> -&gt; <code><a href="#topic+FeatureSet">retistruct::FeatureSet</a></code> -&gt; <code>PointSet</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PointSet-new"><code>PointSet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PointSet-reconstruct"><code>PointSet$reconstruct()</code></a>
</p>
</li>
<li> <p><a href="#method-PointSet-clone"><code>PointSet$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getCol"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getCol'><code>retistruct::FeatureSetCommon$getCol()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeature"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeature'><code>retistruct::FeatureSetCommon$getFeature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeatures"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeatures'><code>retistruct::FeatureSetCommon$getFeatures()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIDs"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIDs'><code>retistruct::FeatureSetCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIndex"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIndex'><code>retistruct::FeatureSetCommon$getIndex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="setID"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-setID'><code>retistruct::FeatureSetCommon$setID()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PointSet-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>PointSet$new(data = NULL, cols = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>List of matrices describing data. Each matrix
should have columns named <code>X</code> and <code>Y</code></p>
</dd>
<dt><code>cols</code></dt><dd><p>Named vector of colours for each data set. The name is
used as the ID (label) for the data set. The colours should be names
present in the output of the <code><a href="grDevices.html#topic+colors">colors</a></code> function</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PointSet-reconstruct"></a>



<h4>Method <code>reconstruct()</code></h4>

<p>Map the PointSet to a <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>PointSet$reconstruct(ro)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ro</code></dt><dd><p>The <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-PointSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PointSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='polar.cart.to.sphere.spherical'>Convert polar projection in Cartesian coordinates to
spherical coordinates on sphere</h2><span id='topic+polar.cart.to.sphere.spherical'></span>

<h3>Description</h3>

<p>This is the inverse of <code><a href="#topic+sphere.spherical.to.polar.cart">sphere.spherical.to.polar.cart</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polar.cart.to.sphere.spherical(r, pa = FALSE, preserve = "latitude")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polar.cart.to.sphere.spherical_+3A_r">r</code></td>
<td>
<p>2-column Matrix of Cartesian coordinates of points on
polar projection. Column names should be <code>x</code> and <code>y</code></p>
</td></tr>
<tr><td><code id="polar.cart.to.sphere.spherical_+3A_pa">pa</code></td>
<td>
<p>If <code>TRUE</code>, make this an area-preserving projection</p>
</td></tr>
<tr><td><code id="polar.cart.to.sphere.spherical_+3A_preserve">preserve</code></td>
<td>
<p>Quantity to preserve locally in the
projection. Options are <code>latitude</code>, <code>area</code> or
<code>angle</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-column Matrix of spherical coordinates of points on
sphere. Column names are <code>phi</code> and <code>lambda</code>.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='polartext'>Put text on the polar plot</h2><span id='topic+polartext'></span>

<h3>Description</h3>

<p>Place text at bottom right of <code><a href="#topic+projection">projection</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polartext(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polartext_+3A_text">text</code></td>
<td>
<p>Test to place</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='projection'>Plot projection of a reconstructed outline</h2><span id='topic+projection'></span>

<h3>Description</h3>

<p>Plot projection of a reconstructed outline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projection(r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="projection_+3A_r">r</code></td>
<td>
<p>Object such as a <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code></p>
</td></tr>
<tr><td><code id="projection_+3A_...">...</code></td>
<td>
<p>Other plotting parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='projection.ReconstructedOutline'>Projection of a reconstructed outline</h2><span id='topic+projection.ReconstructedOutline'></span>

<h3>Description</h3>

<p>Draw a projection of a <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code>. This method sets up
the grid lines and the angular labels and draws the image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ReconstructedOutline'
projection(
  r,
  transform = identity.transform,
  axisdir = cbind(phi = 90, lambda = 0),
  projection = azimuthal.equalarea,
  proj.centre = cbind(phi = 0, lambda = 0),
  lambdalim = c(-180, 180),
  philim = c(-90, 90),
  labels = c(0, 90, 180, 270),
  mesh = FALSE,
  grid = TRUE,
  grid.bg = "transparent",
  grid.int.minor = 15,
  grid.int.major = 45,
  colatitude = TRUE,
  pole = FALSE,
  image = TRUE,
  markup = TRUE,
  add = FALSE,
  max.proj.dim = getOption("max.proj.dim"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="projection.ReconstructedOutline_+3A_r">r</code></td>
<td>
<p><code>ReconstructedOutline</code> object</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_transform">transform</code></td>
<td>
<p>Transform function to apply to spherical coordinates
before rotation</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_axisdir">axisdir</code></td>
<td>
<p>Direction of axis (North pole) of sphere in
external space as matrix with column names <code>phi</code> (elevation)
and <code>lambda</code> (longitude).</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_projection">projection</code></td>
<td>
<p>Projection in which to display object,
e.g. <code><a href="#topic+azimuthal.equalarea">azimuthal.equalarea</a></code> or <code><a href="#topic+sinusoidal">sinusoidal</a></code></p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_proj.centre">proj.centre</code></td>
<td>
<p>Location of centre of projection as matrix with
column names <code>phi</code> (elevation) and <code>lambda</code> (longitude).</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_lambdalim">lambdalim</code></td>
<td>
<p>Limits of longitude (in degrees) to display</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_philim">philim</code></td>
<td>
<p>Limits of latitude (in degrees) to display</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_labels">labels</code></td>
<td>
<p>Vector of 4 labels to plot at 0, 90, 180 and 270 degrees</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_mesh">mesh</code></td>
<td>
<p>If <code>TRUE</code>, plot mesh</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_grid">grid</code></td>
<td>
<p>Whether or not to show the grid lines of
latitude and longitude</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_grid.bg">grid.bg</code></td>
<td>
<p>Background colour of the grid</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_grid.int.minor">grid.int.minor</code></td>
<td>
<p>Interval between minor grid lines in degrees</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_grid.int.major">grid.int.major</code></td>
<td>
<p>Interval between major grid lines in degrees</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_colatitude">colatitude</code></td>
<td>
<p>If <code>TRUE</code> have radial labels plotted with
respect to colatitude rather than latitude</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_pole">pole</code></td>
<td>
<p>If <code>TRUE</code> indicate the pole with a &quot;*&quot;</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_image">image</code></td>
<td>
<p>If <code>TRUE</code>, show the image</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_markup">markup</code></td>
<td>
<p>If <code>TRUE</code>, plot markup, i.e. reconstructed fullcuts and tears</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, don't draw axes; add to existing plot.</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_max.proj.dim">max.proj.dim</code></td>
<td>
<p>Maximum width of the image created in pixels</p>
</td></tr>
<tr><td><code id="projection.ReconstructedOutline_+3A_...">...</code></td>
<td>
<p>Graphical parameters to pass to plotting functions</p>
</td></tr>
</table>

<hr>
<h2 id='projection.RetinalReconstructedOutline'>Plot projection of reconstructed dataset</h2><span id='topic+projection.RetinalReconstructedOutline'></span>

<h3>Description</h3>

<p>Plot projection of reconstructed dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RetinalReconstructedOutline'
projection(
  r,
  transform = identity.transform,
  projection = azimuthal.equalarea,
  axisdir = cbind(phi = 90, lambda = 0),
  proj.centre = cbind(phi = 0, lambda = 0),
  lambdalim = c(-180, 180),
  datapoints = TRUE,
  datapoint.means = TRUE,
  datapoint.contours = FALSE,
  grouped = FALSE,
  grouped.contours = FALSE,
  landmarks = TRUE,
  mesh = FALSE,
  grid = TRUE,
  image = TRUE,
  ids = r$getIDs(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_r">r</code></td>
<td>
<p><code><a href="#topic+RetinalReconstructedOutline">RetinalReconstructedOutline</a></code> object</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_transform">transform</code></td>
<td>
<p>Transform function to apply to spherical coordinates
before rotation</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_projection">projection</code></td>
<td>
<p>Projection in which to display object,
e.g. <code><a href="#topic+azimuthal.equalarea">azimuthal.equalarea</a></code> or <code><a href="#topic+sinusoidal">sinusoidal</a></code></p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_axisdir">axisdir</code></td>
<td>
<p>Direction of axis (North pole) of sphere in external space</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_proj.centre">proj.centre</code></td>
<td>
<p>Location of centre of projection as matrix with
column names <code>phi</code> (elevation) and <code>lambda</code> (longitude).</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_lambdalim">lambdalim</code></td>
<td>
<p>Limits of longitude (in degrees) to display</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_datapoints">datapoints</code></td>
<td>
<p>If <code>TRUE</code>, display data points</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_datapoint.means">datapoint.means</code></td>
<td>
<p>If <code>TRUE</code>, display Karcher mean of data points.</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_datapoint.contours">datapoint.contours</code></td>
<td>
<p>If <code>TRUE</code>, display contours around
the data points generated using Kernel Density Estimation.</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_grouped">grouped</code></td>
<td>
<p>If <code>TRUE</code>, display grouped data.</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_grouped.contours">grouped.contours</code></td>
<td>
<p>If <code>TRUE</code>, display contours around
the grouped data generated using Kernel Regression.</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_landmarks">landmarks</code></td>
<td>
<p>If <code>TRUE</code>, display landmarks.</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_mesh">mesh</code></td>
<td>
<p>If <code>TRUE</code>, display the triangular mesh used in reconstruction</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_grid">grid</code></td>
<td>
<p>If <code>TRUE</code>, show grid lines</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_image">image</code></td>
<td>
<p>If <code>TRUE</code>, show the reconstructed image</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_ids">ids</code></td>
<td>
<p>IDs of groups of data within a dataset, returned using
<code>getIDs</code>.</p>
</td></tr>
<tr><td><code id="projection.RetinalReconstructedOutline_+3A_...">...</code></td>
<td>
<p>Graphical parameters to pass to plotting functions</p>
</td></tr>
</table>

<hr>
<h2 id='R6_to_list'>Convert an R6 object into a list, ignoring functions and
environments</h2><span id='topic+R6_to_list'></span>

<h3>Description</h3>

<p>Convert an R6 object into a list, ignoring functions and
environments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R6_to_list(r, path = "", envs = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R6_to_list_+3A_r">r</code></td>
<td>
<p>R6 object or list</p>
</td></tr>
<tr><td><code id="R6_to_list_+3A_path">path</code></td>
<td>
<p>root of the path to the list - no need to supply. Not
used but could be developed for pretty-printing</p>
</td></tr>
<tr><td><code id="R6_to_list_+3A_envs">envs</code></td>
<td>
<p>list of environments already encountered - do not set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with structure mirroring the R6 object.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='Rcart'>Restore points to spherical manifold</h2><span id='topic+Rcart'></span>

<h3>Description</h3>

<p>Restore points to spherical manifold after an update of the
Lagrange integration rule
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rcart(P, R, Rset, i0, phi0, lambda0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rcart_+3A_p">P</code></td>
<td>
<p>Point positions as N-by-3 matrix</p>
</td></tr>
<tr><td><code id="Rcart_+3A_r">R</code></td>
<td>
<p>Radius of sphere</p>
</td></tr>
<tr><td><code id="Rcart_+3A_rset">Rset</code></td>
<td>
<p>Indices of points on rim</p>
</td></tr>
<tr><td><code id="Rcart_+3A_i0">i0</code></td>
<td>
<p>Index of fixed point</p>
</td></tr>
<tr><td><code id="Rcart_+3A_phi0">phi0</code></td>
<td>
<p>FullCut-off of curtailed sphere in radians</p>
</td></tr>
<tr><td><code id="Rcart_+3A_lambda0">lambda0</code></td>
<td>
<p>Longitude of fixed point on rim</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Points projected back onto sphere
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='read.datacounts'>Read data counts in CSV format</h2><span id='topic+read.datacounts'></span>

<h3>Description</h3>

<p>Read data counts from a file &lsquo;<span class="file">datacounts.csv</span>&rsquo; in the
directory <code>dataset</code>. The CSV file should contain two columns
for every dataset. Each pair of columns must contain a unique name
in the first cell of the first row and a valid colour in the
second cell of the first row. In the remaining rows, the X
coordinates of data counts should be in the first column and the Y
coordinates should be in the second column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.datacounts(dataset)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.datacounts_+3A_dataset">dataset</code></td>
<td>
<p>Path to directory containing <code>dataponts.csv</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing
</p>
<table role = "presentation">
<tr><td><code>Ds</code></td>
<td>
<p>List of sets of data counts. Each set comprises a 2-column matrix and each set is named.</p>
</td></tr>
<tr><td><code>cols</code></td>
<td>
<p>List of colours for each dataset. There is one element that corresponds to each element of <code>Ds</code> and which bears the same name.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='read.datapoints'>Read data points in CSV format</h2><span id='topic+read.datapoints'></span>

<h3>Description</h3>

<p>Read data points from a file <code>dataponts.csv</code> in the directory
<code>dataset</code>. The CSV should contain two columns for every
dataset. Each pair of columns must contain a unique name in the
first cell of the first row  and a valid colour in the second
cell of the first row. In the remaining rows, the X coordinates of
data points should be in the first column and the Y coordinates
should be in the second column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.datapoints(dataset)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.datapoints_+3A_dataset">dataset</code></td>
<td>
<p>Path to directory containing <code>dataponts.csv</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing
</p>
<table role = "presentation">
<tr><td><code>Ds</code></td>
<td>
<p>List of sets of datapoints. Each set comprises a 2-column matrix and each set is named.</p>
</td></tr>
<tr><td><code>cols</code></td>
<td>
<p>List of colours for each dataset. There is one element that corresponds to each element of <code>Ds</code> and which bears the same name.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='ReconstructedCountSet'>Class containing functions and data to map <a href="#topic+CountSet">CountSet</a>s to
<a href="#topic+ReconstructedOutline">ReconstructedOutline</a>s</h2><span id='topic+ReconstructedCountSet'></span>

<h3>Description</h3>

<p>A ReconstructedCountSet contains information about
features located on <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code>s. Each
ReconstructedCountSet contains a list of matrices, each of which
has columns labelled <code>phi</code> (latitude) and <code>lambda</code>
(longitude) describing the spherical coordinates of points on
the ReconstructedOutline, and a column <code>C</code> representing the
counts at these points.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+FeatureSetCommon">retistruct::FeatureSetCommon</a></code> -&gt; <code><a href="#topic+ReconstructedFeatureSet">retistruct::ReconstructedFeatureSet</a></code> -&gt; <code>ReconstructedCountSet</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>KR</code></dt><dd><p>Kernel regression</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ReconstructedCountSet-new"><code>ReconstructedCountSet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedCountSet-getKR"><code>ReconstructedCountSet$getKR()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedCountSet-clone"><code>ReconstructedCountSet$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getCol"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getCol'><code>retistruct::FeatureSetCommon$getCol()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeature"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeature'><code>retistruct::FeatureSetCommon$getFeature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeatures"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeatures'><code>retistruct::FeatureSetCommon$getFeatures()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIDs"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIDs'><code>retistruct::FeatureSetCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIndex"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIndex'><code>retistruct::FeatureSetCommon$getIndex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="setID"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-setID'><code>retistruct::FeatureSetCommon$setID()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ReconstructedCountSet-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedCountSet$new(fs = NULL, ro = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fs</code></dt><dd><p><code><a href="#topic+FeatureSet">FeatureSet</a></code> to reconstruct</p>
</dd>
<dt><code>ro</code></dt><dd><p><code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code> to which feature
set should be mapped</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ReconstructedCountSet-getKR"></a>



<h4>Method <code>getKR()</code></h4>

<p>Get kernel regression estimate of grouped data points
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedCountSet$getKR()</pre></div>



<h5>Returns</h5>

<p>Kernel regression computed using
<code><a href="#topic+compute.kernel.estimate">compute.kernel.estimate</a></code>
</p>


<hr>
<a id="method-ReconstructedCountSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedCountSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='ReconstructedFeatureSet'>Class containing functions and data to map <a href="#topic+FeatureSet">FeatureSet</a>s to
<a href="#topic+ReconstructedOutline">ReconstructedOutline</a>s</h2><span id='topic+ReconstructedFeatureSet'></span>

<h3>Description</h3>

<p>A ReconstructedFeatureSet contains information about
features located on <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code>s. Each
ReconstructedFeatureSet contains a list of matrices, each of
which has columns labelled <code>phi</code> (latitude) and
<code>lambda</code> (longitude) describing the spherical coordinates
of points on the ReconstructedOutline. Derived classes, e.g. a
<code><a href="#topic+ReconstructedCountSet">ReconstructedCountSet</a></code>, may have extra columns.
Each matrix in the list has an associated label and colour,
which is used by plotting functions.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+FeatureSetCommon">retistruct::FeatureSetCommon</a></code> -&gt; <code>ReconstructedFeatureSet</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ReconstructedFeatureSet-new"><code>ReconstructedFeatureSet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedFeatureSet-clone"><code>ReconstructedFeatureSet$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getCol"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getCol'><code>retistruct::FeatureSetCommon$getCol()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeature"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeature'><code>retistruct::FeatureSetCommon$getFeature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeatures"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeatures'><code>retistruct::FeatureSetCommon$getFeatures()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIDs"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIDs'><code>retistruct::FeatureSetCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIndex"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIndex'><code>retistruct::FeatureSetCommon$getIndex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="setID"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-setID'><code>retistruct::FeatureSetCommon$setID()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ReconstructedFeatureSet-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedFeatureSet$new(fs = NULL, ro = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fs</code></dt><dd><p><code><a href="#topic+FeatureSet">FeatureSet</a></code> to reconstruct</p>
</dd>
<dt><code>ro</code></dt><dd><p><code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code> to which feature
set should be mapped</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ReconstructedFeatureSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedFeatureSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='ReconstructedLandmarkSet'>Class containing functions and data to map <a href="#topic+LandmarkSet">LandmarkSet</a>s to
<a href="#topic+ReconstructedOutline">ReconstructedOutline</a>s</h2><span id='topic+ReconstructedLandmarkSet'></span>

<h3>Description</h3>

<p>A ReconstructedLandmarkSet contains information about
features located on <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code>s. Each
ReconstructedLandmarkSet contains a list of matrices, each of
which has columns labelled <code>phi</code> (latitude) and
<code>lambda</code> (longitude) describing the spherical coordinates
of points on the ReconstructedOutline.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+FeatureSetCommon">retistruct::FeatureSetCommon</a></code> -&gt; <code><a href="#topic+ReconstructedFeatureSet">retistruct::ReconstructedFeatureSet</a></code> -&gt; <code>ReconstructedLandmarkSet</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ReconstructedLandmarkSet-clone"><code>ReconstructedLandmarkSet$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getCol"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getCol'><code>retistruct::FeatureSetCommon$getCol()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeature"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeature'><code>retistruct::FeatureSetCommon$getFeature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeatures"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeatures'><code>retistruct::FeatureSetCommon$getFeatures()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIDs"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIDs'><code>retistruct::FeatureSetCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIndex"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIndex'><code>retistruct::FeatureSetCommon$getIndex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="setID"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-setID'><code>retistruct::FeatureSetCommon$setID()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedFeatureSet" data-id="initialize"><a href='../../retistruct/html/ReconstructedFeatureSet.html#method-ReconstructedFeatureSet-initialize'><code>retistruct::ReconstructedFeatureSet$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ReconstructedLandmarkSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedLandmarkSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='ReconstructedOutline'>Class containing functions to reconstruct <a href="#topic+StitchedOutline">StitchedOutline</a>s
and store the associated data</h2><span id='topic+ReconstructedOutline'></span>

<h3>Description</h3>

<p>The function <code>reconstruct</code> reconstructs outline
into spherical surface Reconstruct outline into spherical
surface.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+OutlineCommon">retistruct::OutlineCommon</a></code> -&gt; <code>ReconstructedOutline</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ol</code></dt><dd><p>Annotated outline</p>
</dd>
<dt><code>ol0</code></dt><dd><p>Original Annotated outline</p>
</dd>
<dt><code>Pt</code></dt><dd><p>Transformed cartesian mesh points</p>
</dd>
<dt><code>Trt</code></dt><dd><p>Transformed triangulation</p>
</dd>
<dt><code>Ct</code></dt><dd><p>Transformed links</p>
</dd>
<dt><code>Cut</code></dt><dd><p>Transformed links</p>
</dd>
<dt><code>Bt</code></dt><dd><p>Transformed binary vector representation
of edge indices onto a binary vector representation of the
indices of the points linked by the edge</p>
</dd>
<dt><code>Lt</code></dt><dd><p>Transformed lengths</p>
</dd>
<dt><code>ht</code></dt><dd><p>Transformed correspondences</p>
</dd>
<dt><code>u</code></dt><dd><p>Indices of unique points in untransformed space</p>
</dd>
<dt><code>U</code></dt><dd><p>Transformed indices of unique points in untransformed space</p>
</dd>
<dt><code>Rsett</code></dt><dd><p>Transformed rim set</p>
</dd>
<dt><code>i0t</code></dt><dd><p>Transformed marker</p>
</dd>
<dt><code>H</code></dt><dd><p>mapping from edges onto corresponding edges</p>
</dd>
<dt><code>Ht</code></dt><dd><p>Transformed mapping from edges onto corresponding edges</p>
</dd>
<dt><code>phi0</code></dt><dd><p>Rim angle</p>
</dd>
<dt><code>R</code></dt><dd><p>Radius of spherical template</p>
</dd>
<dt><code>lambda0</code></dt><dd><p>Longitude of pole on rim</p>
</dd>
<dt><code>lambda</code></dt><dd><p>Longitudes of transformed mesh points</p>
</dd>
<dt><code>phi</code></dt><dd><p>Latitudes of transformed mesh points</p>
</dd>
<dt><code>Ps</code></dt><dd><p>Location of mesh point on sphere in spherical coordinates</p>
</dd>
<dt><code>n</code></dt><dd><p>Number of mesh points</p>
</dd>
<dt><code>alpha</code></dt><dd><p>Weighting of areas in energy function</p>
</dd>
<dt><code>x0</code></dt><dd><p>Area cut-off coefficient</p>
</dd>
<dt><code>nflip0</code></dt><dd><p>Initial number flipped triangles</p>
</dd>
<dt><code>nflip</code></dt><dd><p>Final number flipped triangles</p>
</dd>
<dt><code>opt</code></dt><dd><p>Optimisation object</p>
</dd>
<dt><code>E.tot</code></dt><dd><p>Energy function including area</p>
</dd>
<dt><code>E.l</code></dt><dd><p>Energy function based on lengths alone</p>
</dd>
<dt><code>mean.strain</code></dt><dd><p>Mean strain</p>
</dd>
<dt><code>mean.logstrain</code></dt><dd><p>Mean log strain</p>
</dd>
<dt><code>titration</code></dt><dd><p>Titrated data structure, saved by <code>titrate</code></p>
</dd>
<dt><code>debug</code></dt><dd><p>Debug function</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ReconstructedOutline-loadOutline"><code>ReconstructedOutline$loadOutline()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-reconstruct"><code>ReconstructedOutline$reconstruct()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-mergePointsEdges"><code>ReconstructedOutline$mergePointsEdges()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-projectToSphere"><code>ReconstructedOutline$projectToSphere()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-getStrains"><code>ReconstructedOutline$getStrains()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-optimiseMapping"><code>ReconstructedOutline$optimiseMapping()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-optimiseMappingCart"><code>ReconstructedOutline$optimiseMappingCart()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-transformImage"><code>ReconstructedOutline$transformImage()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-getIms"><code>ReconstructedOutline$getIms()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-getTearCoords"><code>ReconstructedOutline$getTearCoords()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-getFullCutCoords"><code>ReconstructedOutline$getFullCutCoords()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-getNonRimBoundaryCoords"><code>ReconstructedOutline$getNonRimBoundaryCoords()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-getFeatureSet"><code>ReconstructedOutline$getFeatureSet()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-reconstructFeatureSets"><code>ReconstructedOutline$reconstructFeatureSets()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-getPoints"><code>ReconstructedOutline$getPoints()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-mapFlatToSpherical"><code>ReconstructedOutline$mapFlatToSpherical()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-titrate"><code>ReconstructedOutline$titrate()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedOutline-clone"><code>ReconstructedOutline$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="clearFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-clearFeatureSets'><code>retistruct::OutlineCommon$clearFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSetTypes"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSetTypes'><code>retistruct::OutlineCommon$getFeatureSetTypes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSets'><code>retistruct::OutlineCommon$getFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getIDs"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getIDs'><code>retistruct::OutlineCommon$getIDs()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ReconstructedOutline-loadOutline"></a>



<h4>Method <code>loadOutline()</code></h4>

<p>Load <a href="#topic+AnnotatedOutline">AnnotatedOutline</a> into ReconstructedOutline object
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$loadOutline(
  ol,
  n = 500,
  alpha = 8,
  x0 = 0.5,
  plot.3d = FALSE,
  dev.flat = NA,
  dev.polar = NA,
  report = retistruct::report,
  debug = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ol</code></dt><dd><p><code><a href="#topic+AnnotatedOutline">AnnotatedOutline</a></code> object, containing the following information</p>
</dd>
<dt><code>n</code></dt><dd><p>Number of points in triangulation.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>Area scaling coefficient</p>
</dd>
<dt><code>x0</code></dt><dd><p>Area cut-off coefficient</p>
</dd>
<dt><code>plot.3d</code></dt><dd><p>Whether to show 3D picture during optimisation.</p>
</dd>
<dt><code>dev.flat</code></dt><dd><p>Device to plot grid onto. Value of <code>NA</code> (default)
means no plotting.</p>
</dd>
<dt><code>dev.polar</code></dt><dd><p>Device display projection. Value of NA
(default) means no plotting.</p>
</dd>
<dt><code>report</code></dt><dd><p>Function to report progress.</p>
</dd>
<dt><code>debug</code></dt><dd><p>If <code>TRUE</code> print extra debugging output</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ReconstructedOutline-reconstruct"></a>



<h4>Method <code>reconstruct()</code></h4>

<p>Reconstruct
Reconstruction proceeds in a number of stages:
</p>

<ol>
<li><p> The flat object is triangulated with at least <code>n</code>
triangles. This can introduce new vertices in the rim.
</p>
</li>
<li><p> The triangulated object is stitched.
</p>
</li>
<li><p> The stitched object is triangulated again, but this time it
is not permitted to add extra vertices to the rim.
</p>
</li>
<li><p> The corresponding points determined by the stitching process
are merged to form a new set of merged points and a new
triangulation.
</p>
</li>
<li><p> The merged points are projected roughly to a sphere.
</p>
</li>
<li><p> The locations of the points on the sphere are moved so as to
minimise the energy function.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$reconstruct(
  plot.3d = FALSE,
  dev.flat = NA,
  dev.polar = NA,
  shinyOutput = NA,
  report = getOption("retistruct.report")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot.3d</code></dt><dd><p>If <code>TRUE</code> make a 3D plot in an RGL window</p>
</dd>
<dt><code>dev.flat</code></dt><dd><p>Device handle for plotting flatplot updates to. If
<code>NA</code> don't make any flat plots</p>
</dd>
<dt><code>dev.polar</code></dt><dd><p>Device handle for plotting polar plot updates
to. If <code>NA</code> don't make any polar plots.</p>
</dd>
<dt><code>shinyOutput</code></dt><dd><p>A Shiny output element used to render and display a
plot in the application. If <code>NA</code> or <code>NULL</code> don't output to Shiny.</p>
</dd>
<dt><code>report</code></dt><dd><p>Function to report progress.</p>
</dd>
<dt><code>Control</code></dt><dd><p>argument to pass to <code>optim</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-ReconstructedOutline-mergePointsEdges"></a>



<h4>Method <code>mergePointsEdges()</code></h4>

<p>Merge stitched points and edges.
Create merged and transformed versions (all suffixed with <code>t</code>)
of a number of existing variables, as well
as a matrix <code>Bt</code>, which maps a binary vector representation
of edge indices onto a binary vector representation of the
indices of the points linked by the edge.
Sets following fields
</p>

<dl>
<dt><code>Pt</code></dt><dd><p>Transformed point locations</p>
</dd>
<dt><code>Trt</code></dt><dd><p>Transformed triangulation</p>
</dd>
<dt><code>Ct</code></dt><dd><p>Transformed connection set</p>
</dd>
<dt><code>Cut</code></dt><dd><p>Transformed symmetric connection set</p>
</dd>
<dt><code>Bt</code></dt><dd><p>Transformed binary vector representation
of edge indices onto a binary vector representation of the
indices of the points linked by the edge</p>
</dd>
<dt><code>Lt</code></dt><dd><p>Transformed edge lengths</p>
</dd>
<dt><code>ht</code></dt><dd><p>Transformed correspondences</p>
</dd>
<dt><code>u</code></dt><dd><p>Indices of unique points in untransformed space</p>
</dd>
<dt><code>U</code></dt><dd><p>Transformed indices of unique points in untransformed space</p>
</dd>
<dt><code>Rset</code></dt><dd><p>The set of points on the rim (which has been reordered)</p>
</dd>
<dt><code>Rsett</code></dt><dd><p>Transformed set of points on rim</p>
</dd>
<dt><code>i0t</code></dt><dd><p>Transformed index of the landmark</p>
</dd>
<dt><code>H</code></dt><dd><p>mapping from edges onto corresponding edges</p>
</dd>
<dt><code>Ht</code></dt><dd><p>Transformed mapping from edges onto corresponding edges</p>
</dd>
</dl>



<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$mergePointsEdges()</pre></div>


<hr>
<a id="method-ReconstructedOutline-projectToSphere"></a>



<h4>Method <code>projectToSphere()</code></h4>

<p>Project mesh points in the flat outline onto a sphere
This takes the mesh points from the flat outline and maps them to
the curtailed sphere. It uses the area of the flat outline and
<code>phi0</code> to determine the radius <code>R</code> of the sphere. It
tries to get a good first approximation by using the function
<code><a href="#topic+stretchMesh">stretchMesh</a></code>.
The following fields are set:
</p>

<dl>
<dt><code>phi</code></dt><dd><p>Latitude of mesh points.</p>
</dd>
<dt><code>lmabda</code></dt><dd><p>Longitude of mesh points.</p>
</dd>
<dt><code>R</code></dt><dd><p>Radius of sphere.</p>
</dd>
</dl>



<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$projectToSphere()</pre></div>


<hr>
<a id="method-ReconstructedOutline-getStrains"></a>



<h4>Method <code>getStrains()</code></h4>

<p>Return strains edges are under in spherical retina
Set information about how edges on the sphere
have been deformed from their flat state.
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$getStrains()</pre></div>



<h5>Returns</h5>

<p>A list containing two data frames <code>flat</code> and <code>spherical</code>.
Each data frame contains for each edge in the flat or spherical meshes:
</p>

<dl>
<dt><code>L</code></dt><dd><p>Length of the edge in the flat outline </p>
</dd>
<dt><code>l</code></dt><dd><p>Length of the corresponding edge on the sphere</p>
</dd>
<dt><code>strain</code></dt><dd><p>The strain of each connection</p>
</dd>
<dt><code>logstrain</code></dt><dd><p>The logarithmic strain of each connection</p>
</dd>
</dl>



<hr>
<a id="method-ReconstructedOutline-optimiseMapping"></a>



<h4>Method <code>optimiseMapping()</code></h4>

<p>Optimise the mapping from the flat outline to the sphere
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$optimiseMapping(
  alpha = 4,
  x0 = 0.5,
  nu = 1,
  optim.method = "BFGS",
  plot.3d = FALSE,
  dev.flat = NA,
  dev.polar = NA,
  shinyOutput = NULL,
  control = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>Area penalty scaling coefficient</p>
</dd>
<dt><code>x0</code></dt><dd><p>Area penalty cut-off coefficient</p>
</dd>
<dt><code>nu</code></dt><dd><p>Power to which to raise area</p>
</dd>
<dt><code>optim.method</code></dt><dd><p>Method to pass to <code>optim</code></p>
</dd>
<dt><code>plot.3d</code></dt><dd><p>If <code>TRUE</code> make a 3D plot in an RGL window</p>
</dd>
<dt><code>dev.flat</code></dt><dd><p>Device handle for plotting flatplot updates to. If</p>
</dd>
<dt><code>dev.polar</code></dt><dd><p>Device handle for plotting polar plot updates
to. If <code>NA</code> don't make any polar plots.</p>
</dd>
<dt><code>shinyOutput</code></dt><dd><p>A Shiny output element used to render and display a
plot in the application.
<code>NA</code> don't make any flat plots</p>
</dd>
<dt><code>control</code></dt><dd><p>Control argument to pass to <code>optim</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-ReconstructedOutline-optimiseMappingCart"></a>



<h4>Method <code>optimiseMappingCart()</code></h4>

<p>Optimise the mapping from the flat outline to the sphere
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$optimiseMappingCart(
  alpha = 4,
  x0 = 0.5,
  nu = 1,
  method = "BFGS",
  plot.3d = FALSE,
  dev.flat = NA,
  dev.polar = NA,
  shinyOutput = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>Area penalty scaling coefficient</p>
</dd>
<dt><code>x0</code></dt><dd><p>Area penalty cut-off coefficient</p>
</dd>
<dt><code>nu</code></dt><dd><p>Power to which to raise area</p>
</dd>
<dt><code>method</code></dt><dd><p>Method to pass to <code>optim</code></p>
</dd>
<dt><code>plot.3d</code></dt><dd><p>If <code>TRUE</code> make a 3D plot in an RGL window</p>
</dd>
<dt><code>dev.flat</code></dt><dd><p>Device handle for plotting grid to</p>
</dd>
<dt><code>dev.polar</code></dt><dd><p>Device handle for plotting polar plot to</p>
</dd>
<dt><code>shinyOutput</code></dt><dd><p>A Shiny output element used to render and display a
plot in the application.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra arguments to pass to <code><a href="#topic+fire">fire</a></code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-ReconstructedOutline-transformImage"></a>



<h4>Method <code>transformImage()</code></h4>

<p>Transform an image into the reconstructed space
Transform an image into the reconstructed space. The four corner
coordinates of each pixel are transformed into spherical
coordinates and a mask matrix with the same dimensions as
<code>im</code> is created. This has <code>TRUE</code> for pixels that should
be displayed and <code>FALSE</code> for ones that should not.
Sets the field
</p>

<dl>
<dt><code>ims</code></dt><dd><p>Coordinates of corners of pixels in spherical coordinates</p>
</dd>
</dl>



<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$transformImage()</pre></div>


<hr>
<a id="method-ReconstructedOutline-getIms"></a>



<h4>Method <code>getIms()</code></h4>

<p>Get coordinates of corners of pixels of image in spherical
coordinates
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$getIms()</pre></div>



<h5>Returns</h5>

<p>Coordinates of corners of pixels in spherical coordinates
</p>


<hr>
<a id="method-ReconstructedOutline-getTearCoords"></a>



<h4>Method <code>getTearCoords()</code></h4>

<p>Get locations of tears in spherical coordinates
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$getTearCoords()</pre></div>



<h5>Returns</h5>

<p>List containing locations of tears in spherical coordinates
</p>


<hr>
<a id="method-ReconstructedOutline-getFullCutCoords"></a>



<h4>Method <code>getFullCutCoords()</code></h4>

<p>Get locations of fullcuts in spherical coordinates
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$getFullCutCoords()</pre></div>



<h5>Returns</h5>

<p>List containing locations of fullcuts in spherical coordinates
</p>


<hr>
<a id="method-ReconstructedOutline-getNonRimBoundaryCoords"></a>



<h4>Method <code>getNonRimBoundaryCoords()</code></h4>

<p>Get location of non-rim boundaries in spherical coordinates
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$getNonRimBoundaryCoords()</pre></div>



<h5>Returns</h5>

<p>List containing locations of non-rim boundaries in spherical coordinates
</p>


<hr>
<a id="method-ReconstructedOutline-getFeatureSet"></a>



<h4>Method <code>getFeatureSet()</code></h4>

<p>Get <a href="#topic+ReconstructedFeatureSet">ReconstructedFeatureSet</a>
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$getFeatureSet(type)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>Base type of <a href="#topic+FeatureSet">FeatureSet</a> as string.
E.g. <code>PointSet</code> returns a <a href="#topic+ReconstructedPointSet">ReconstructedPointSet</a></p>
</dd>
</dl>

</div>


<hr>
<a id="method-ReconstructedOutline-reconstructFeatureSets"></a>



<h4>Method <code>reconstructFeatureSets()</code></h4>

<p>Reconstruct any attached feature sets.
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$reconstructFeatureSets()</pre></div>


<hr>
<a id="method-ReconstructedOutline-getPoints"></a>



<h4>Method <code>getPoints()</code></h4>

<p>Get mesh points in spherical coordinates
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$getPoints()</pre></div>



<h5>Returns</h5>

<p>Matrix with columns <code>phi</code> (latitude) and <code>lambda</code>
(longitude)
</p>


<hr>
<a id="method-ReconstructedOutline-mapFlatToSpherical"></a>



<h4>Method <code>mapFlatToSpherical()</code></h4>

<p>Return location of point on sphere corresponding
to point on the flat outline
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$mapFlatToSpherical(P)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>Cartesian coordinates  on flat outline as a matrix
with <code>X</code> and <code>Y</code> columns</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ReconstructedOutline-titrate"></a>



<h4>Method <code>titrate()</code></h4>

<p>Try a range of values of phi0s in the reconstruction, recording the
energy of the mapping in each case.
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$titrate(
  alpha = 8,
  x0 = 0.5,
  byd = 1,
  len.up = 5,
  len.down = 20
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>Area penalty scaling coefficient</p>
</dd>
<dt><code>x0</code></dt><dd><p>Area cut-off coefficient</p>
</dd>
<dt><code>byd</code></dt><dd><p>Increments in degrees</p>
</dd>
<dt><code>len.up</code></dt><dd><p>How many increments to go up from starting value of
<code>phi0</code> in <code>r</code>.</p>
</dd>
<dt><code>len.down</code></dt><dd><p>How many increments to go up from starting value
of <code>phi0</code> in <code>r</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ReconstructedOutline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedOutline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='ReconstructedPointSet'>Class containing functions and data to map <a href="#topic+PointSet">PointSet</a>s to
<a href="#topic+ReconstructedOutline">ReconstructedOutline</a>s</h2><span id='topic+ReconstructedPointSet'></span>

<h3>Description</h3>

<p>A ReconstructedPointSet contains information about
features located on <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code>s. Each
ReconstructedPointSet contains a list of matrices, each of
which has columns labelled <code>phi</code> (latitude) and
<code>lambda</code> (longitude) describing the spherical coordinates
of points on the ReconstructedOutline.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+FeatureSetCommon">retistruct::FeatureSetCommon</a></code> -&gt; <code><a href="#topic+ReconstructedFeatureSet">retistruct::ReconstructedFeatureSet</a></code> -&gt; <code>ReconstructedPointSet</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>KDE</code></dt><dd><p>Kernel density estimate, computed using
<code><a href="#topic+compute.kernel.estimate">compute.kernel.estimate</a></code> in <code>getKDE</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ReconstructedPointSet-getMean"><code>ReconstructedPointSet$getMean()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedPointSet-getHullarea"><code>ReconstructedPointSet$getHullarea()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedPointSet-getKDE"><code>ReconstructedPointSet$getKDE()</code></a>
</p>
</li>
<li> <p><a href="#method-ReconstructedPointSet-clone"><code>ReconstructedPointSet$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getCol"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getCol'><code>retistruct::FeatureSetCommon$getCol()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeature"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeature'><code>retistruct::FeatureSetCommon$getFeature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getFeatures"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getFeatures'><code>retistruct::FeatureSetCommon$getFeatures()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIDs"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIDs'><code>retistruct::FeatureSetCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="getIndex"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-getIndex'><code>retistruct::FeatureSetCommon$getIndex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="FeatureSetCommon" data-id="setID"><a href='../../retistruct/html/FeatureSetCommon.html#method-FeatureSetCommon-setID'><code>retistruct::FeatureSetCommon$setID()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedFeatureSet" data-id="initialize"><a href='../../retistruct/html/ReconstructedFeatureSet.html#method-ReconstructedFeatureSet-initialize'><code>retistruct::ReconstructedFeatureSet$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ReconstructedPointSet-getMean"></a>



<h4>Method <code>getMean()</code></h4>

<p>Get Karcher mean of datapoints in spherical coordinates
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedPointSet$getMean()</pre></div>



<h5>Returns</h5>

<p>Karcher mean of datapoints in spherical coordinates
</p>


<hr>
<a id="method-ReconstructedPointSet-getHullarea"></a>



<h4>Method <code>getHullarea()</code></h4>

<p>Get area of convex hull around data points on sphere
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedPointSet$getHullarea()</pre></div>



<h5>Returns</h5>

<p>Area in degrees squared
</p>


<hr>
<a id="method-ReconstructedPointSet-getKDE"></a>



<h4>Method <code>getKDE()</code></h4>

<p>Get kernel density estimate of data points
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedPointSet$getKDE()</pre></div>



<h5>Returns</h5>

<p>See <code><a href="#topic+compute.kernel.estimate">compute.kernel.estimate</a></code>
</p>


<hr>
<a id="method-ReconstructedPointSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ReconstructedPointSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='remove.identical.consecutive.rows'>Remove identical consecutive rows from a matrix</h2><span id='topic+remove.identical.consecutive.rows'></span>

<h3>Description</h3>

<p>This is similar to unique(), but spares rows which are duplicated, but
at different points in the matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.identical.consecutive.rows(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove.identical.consecutive.rows_+3A_p">P</code></td>
<td>
<p>Source matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with identical consecutive rows removed.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='remove.intersections'>Remove intersections between adjacent segments in a closed
path</h2><span id='topic+remove.intersections'></span>

<h3>Description</h3>

<p>Suppose segments AB and CD intersect.  Point B is replaced by the
intersection point, defined B'.  Point C is replaced by a point C'
on the line B'D. The maximum distance of B'C' is given by the
parameter d. If the distance l B'D is less than 2d, the distance
B'C' is l/2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.intersections(P, d = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove.intersections_+3A_p">P</code></td>
<td>
<p>The points, as a 2-column matrix</p>
</td></tr>
<tr><td><code id="remove.intersections_+3A_d">d</code></td>
<td>
<p>Criterion for maximum distance when points are inserted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new closed path without intersections
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='report'>Reporting utility function</h2><span id='topic+report'></span>

<h3>Description</h3>

<p>Calls function specified by option <code>retistruct.report</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="report_+3A_x">x</code></td>
<td>
<p>First arguments to reporting function</p>
</td></tr>
<tr><td><code id="report_+3A_...">...</code></td>
<td>
<p>Arguments to reporting function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='RetinalOutline'>Class containing functions and data relating to retinal outlines</h2><span id='topic+RetinalOutline'></span>

<h3>Description</h3>

<p>In addition to fields inherited from
<a href="#topic+StitchedOutline">StitchedOutline</a>, a RetinalOutline contains a
<code>dataset</code> field, describing the system path to dataset
directory and metadata specific to retinae and some formats of
retinae
</p>
<p>An <code>retinalOutline</code> object. This contains the following fields:
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+OutlineCommon">retistruct::OutlineCommon</a></code> -&gt; <code><a href="#topic+Outline">retistruct::Outline</a></code> -&gt; <code><a href="#topic+PathOutline">retistruct::PathOutline</a></code> -&gt; <code><a href="#topic+AnnotatedOutline">retistruct::AnnotatedOutline</a></code> -&gt; <code><a href="#topic+TriangulatedOutline">retistruct::TriangulatedOutline</a></code> -&gt; <code><a href="#topic+StitchedOutline">retistruct::StitchedOutline</a></code> -&gt; <code>RetinalOutline</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>DVflip</code></dt><dd><p><code>TRUE</code> if the raw data is flipped in
the dorsoventral direction</p>
</dd>
<dt><code>side</code></dt><dd><p>The side of the eye (&ldquo;Left&rdquo; or &ldquo;Right&rdquo;)</p>
</dd>
<dt><code>dataset</code></dt><dd><p>File system path to dataset directory</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RetinalOutline-new"><code>RetinalOutline$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RetinalOutline-clone"><code>RetinalOutline$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="clearFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-clearFeatureSets'><code>retistruct::OutlineCommon$clearFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSet"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSet'><code>retistruct::OutlineCommon$getFeatureSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSetTypes"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSetTypes'><code>retistruct::OutlineCommon$getFeatureSetTypes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSets'><code>retistruct::OutlineCommon$getFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getIDs"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getIDs'><code>retistruct::OutlineCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="addFeatureSet"><a href='../../retistruct/html/Outline.html#method-Outline-addFeatureSet'><code>retistruct::Outline$addFeatureSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getDepth"><a href='../../retistruct/html/Outline.html#method-Outline-getDepth'><code>retistruct::Outline$getDepth()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragment"><a href='../../retistruct/html/Outline.html#method-Outline-getFragment'><code>retistruct::Outline$getFragment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentIDs'><code>retistruct::Outline$getFragmentIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentIDsFromPointIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentIDsFromPointIDs'><code>retistruct::Outline$getFragmentIDsFromPointIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentPointIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentPointIDs'><code>retistruct::Outline$getFragmentPointIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentPoints"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentPoints'><code>retistruct::Outline$getFragmentPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getImage"><a href='../../retistruct/html/Outline.html#method-Outline-getImage'><code>retistruct::Outline$getImage()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getOutlineLengths"><a href='../../retistruct/html/Outline.html#method-Outline-getOutlineLengths'><code>retistruct::Outline$getOutlineLengths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getOutlineSet"><a href='../../retistruct/html/Outline.html#method-Outline-getOutlineSet'><code>retistruct::Outline$getOutlineSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPoints"><a href='../../retistruct/html/Outline.html#method-Outline-getPoints'><code>retistruct::Outline$getPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPointsScaled"><a href='../../retistruct/html/Outline.html#method-Outline-getPointsScaled'><code>retistruct::Outline$getPointsScaled()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPointsXY"><a href='../../retistruct/html/Outline.html#method-Outline-getPointsXY'><code>retistruct::Outline$getPointsXY()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="mapFragment"><a href='../../retistruct/html/Outline.html#method-Outline-mapFragment'><code>retistruct::Outline$mapFragment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="mapPids"><a href='../../retistruct/html/Outline.html#method-Outline-mapPids'><code>retistruct::Outline$mapPids()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="replaceImage"><a href='../../retistruct/html/Outline.html#method-Outline-replaceImage'><code>retistruct::Outline$replaceImage()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="PathOutline" data-id="insertPoint"><a href='../../retistruct/html/PathOutline.html#method-PathOutline-insertPoint'><code>retistruct::PathOutline$insertPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="PathOutline" data-id="nextPoint"><a href='../../retistruct/html/PathOutline.html#method-PathOutline-nextPoint'><code>retistruct::PathOutline$nextPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="PathOutline" data-id="stitchSubpaths"><a href='../../retistruct/html/PathOutline.html#method-PathOutline-stitchSubpaths'><code>retistruct::PathOutline$stitchSubpaths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="addFullCut"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-addFullCut'><code>retistruct::AnnotatedOutline$addFullCut()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="addPoints"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-addPoints'><code>retistruct::AnnotatedOutline$addPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="addTear"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-addTear'><code>retistruct::AnnotatedOutline$addTear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="checkTears"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-checkTears'><code>retistruct::AnnotatedOutline$checkTears()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="computeFullCutRelationships"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-computeFullCutRelationships'><code>retistruct::AnnotatedOutline$computeFullCutRelationships()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="computeTearRelationships"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-computeTearRelationships'><code>retistruct::AnnotatedOutline$computeTearRelationships()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="ensureFixedPointInRim"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-ensureFixedPointInRim'><code>retistruct::AnnotatedOutline$ensureFixedPointInRim()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getFixedPoint"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getFixedPoint'><code>retistruct::AnnotatedOutline$getFixedPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getFullCut"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getFullCut'><code>retistruct::AnnotatedOutline$getFullCut()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getFullCuts"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getFullCuts'><code>retistruct::AnnotatedOutline$getFullCuts()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getRimLengths"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getRimLengths'><code>retistruct::AnnotatedOutline$getRimLengths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getRimSet"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getRimSet'><code>retistruct::AnnotatedOutline$getRimSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getTear"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getTear'><code>retistruct::AnnotatedOutline$getTear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getTears"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getTears'><code>retistruct::AnnotatedOutline$getTears()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="labelFullCutPoints"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-labelFullCutPoints'><code>retistruct::AnnotatedOutline$labelFullCutPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="labelTearPoints"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-labelTearPoints'><code>retistruct::AnnotatedOutline$labelTearPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="removeFullCut"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-removeFullCut'><code>retistruct::AnnotatedOutline$removeFullCut()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="removeTear"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-removeTear'><code>retistruct::AnnotatedOutline$removeTear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="setFixedPoint"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-setFixedPoint'><code>retistruct::AnnotatedOutline$setFixedPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="whichFullCut"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-whichFullCut'><code>retistruct::AnnotatedOutline$whichFullCut()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="whichTear"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-whichTear'><code>retistruct::AnnotatedOutline$whichTear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="TriangulatedOutline" data-id="mapTriangulatedFragment"><a href='../../retistruct/html/TriangulatedOutline.html#method-TriangulatedOutline-mapTriangulatedFragment'><code>retistruct::TriangulatedOutline$mapTriangulatedFragment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="TriangulatedOutline" data-id="triangulate"><a href='../../retistruct/html/TriangulatedOutline.html#method-TriangulatedOutline-triangulate'><code>retistruct::TriangulatedOutline$triangulate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="StitchedOutline" data-id="getBoundarySets"><a href='../../retistruct/html/StitchedOutline.html#method-StitchedOutline-getBoundarySets'><code>retistruct::StitchedOutline$getBoundarySets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="StitchedOutline" data-id="isStitched"><a href='../../retistruct/html/StitchedOutline.html#method-StitchedOutline-isStitched'><code>retistruct::StitchedOutline$isStitched()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="StitchedOutline" data-id="stitchFullCuts"><a href='../../retistruct/html/StitchedOutline.html#method-StitchedOutline-stitchFullCuts'><code>retistruct::StitchedOutline$stitchFullCuts()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="StitchedOutline" data-id="stitchTears"><a href='../../retistruct/html/StitchedOutline.html#method-StitchedOutline-stitchTears'><code>retistruct::StitchedOutline$stitchTears()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RetinalOutline-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>RetinalOutline$new(..., dataset = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters to superclass constructors</p>
</dd>
<dt><code>dataset</code></dt><dd><p>File system path to dataset directory</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RetinalOutline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RetinalOutline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='RetinalReconstructedOutline'>A version of <a href="#topic+ReconstructedOutline">ReconstructedOutline</a> that is specific to
retinal datasets</h2><span id='topic+RetinalReconstructedOutline'></span>

<h3>Description</h3>

<p>A RetinalReconstructedOutline overrides methods of
<a href="#topic+ReconstructedOutline">ReconstructedOutline</a> so that they return data point and
landmark coordinates that have been transformed according to the
values of <code>DVflip</code> and <code>side</code>. When reconstructing, it
also computes the &ldquo;Optic disc displacement&rdquo;, i.e. the
number of degrees subtended between the optic disc and the pole.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+OutlineCommon">retistruct::OutlineCommon</a></code> -&gt; <code><a href="#topic+ReconstructedOutline">retistruct::ReconstructedOutline</a></code> -&gt; <code>RetinalReconstructedOutline</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>EOD</code></dt><dd><p>Optic disc displacement in degrees</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RetinalReconstructedOutline-getIms"><code>RetinalReconstructedOutline$getIms()</code></a>
</p>
</li>
<li> <p><a href="#method-RetinalReconstructedOutline-getTearCoords"><code>RetinalReconstructedOutline$getTearCoords()</code></a>
</p>
</li>
<li> <p><a href="#method-RetinalReconstructedOutline-reconstruct"><code>RetinalReconstructedOutline$reconstruct()</code></a>
</p>
</li>
<li> <p><a href="#method-RetinalReconstructedOutline-getFeatureSet"><code>RetinalReconstructedOutline$getFeatureSet()</code></a>
</p>
</li>
<li> <p><a href="#method-RetinalReconstructedOutline-clone"><code>RetinalReconstructedOutline$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="clearFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-clearFeatureSets'><code>retistruct::OutlineCommon$clearFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSetTypes"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSetTypes'><code>retistruct::OutlineCommon$getFeatureSetTypes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSets'><code>retistruct::OutlineCommon$getFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getIDs"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getIDs'><code>retistruct::OutlineCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="getFullCutCoords"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-getFullCutCoords'><code>retistruct::ReconstructedOutline$getFullCutCoords()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="getNonRimBoundaryCoords"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-getNonRimBoundaryCoords'><code>retistruct::ReconstructedOutline$getNonRimBoundaryCoords()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="getPoints"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-getPoints'><code>retistruct::ReconstructedOutline$getPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="getStrains"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-getStrains'><code>retistruct::ReconstructedOutline$getStrains()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="loadOutline"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-loadOutline'><code>retistruct::ReconstructedOutline$loadOutline()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="mapFlatToSpherical"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-mapFlatToSpherical'><code>retistruct::ReconstructedOutline$mapFlatToSpherical()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="mergePointsEdges"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-mergePointsEdges'><code>retistruct::ReconstructedOutline$mergePointsEdges()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="optimiseMapping"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-optimiseMapping'><code>retistruct::ReconstructedOutline$optimiseMapping()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="optimiseMappingCart"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-optimiseMappingCart'><code>retistruct::ReconstructedOutline$optimiseMappingCart()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="projectToSphere"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-projectToSphere'><code>retistruct::ReconstructedOutline$projectToSphere()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="reconstructFeatureSets"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-reconstructFeatureSets'><code>retistruct::ReconstructedOutline$reconstructFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="titrate"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-titrate'><code>retistruct::ReconstructedOutline$titrate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="ReconstructedOutline" data-id="transformImage"><a href='../../retistruct/html/ReconstructedOutline.html#method-ReconstructedOutline-transformImage'><code>retistruct::ReconstructedOutline$transformImage()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RetinalReconstructedOutline-getIms"></a>



<h4>Method <code>getIms()</code></h4>

<p>Get coordinates of corners of pixels of image in spherical
coordinates, transformed according to the value of <code>DVflip</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>RetinalReconstructedOutline$getIms()</pre></div>



<h5>Returns</h5>

<p>Coordinates of corners of pixels in spherical coordinates
</p>


<hr>
<a id="method-RetinalReconstructedOutline-getTearCoords"></a>



<h4>Method <code>getTearCoords()</code></h4>

<p>Get location of tear coordinates in spherical coordinates,
transformed according to the value of <code>DVflip</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>RetinalReconstructedOutline$getTearCoords()</pre></div>



<h5>Returns</h5>

<p>Location of tear coordinates in spherical coordinates
</p>


<hr>
<a id="method-RetinalReconstructedOutline-reconstruct"></a>



<h4>Method <code>reconstruct()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RetinalReconstructedOutline$reconstruct(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters to <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-RetinalReconstructedOutline-getFeatureSet"></a>



<h4>Method <code>getFeatureSet()</code></h4>

<p>Get <a href="#topic+ReconstructedFeatureSet">ReconstructedFeatureSet</a>, transformed
according to the value of <code>DVflip</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>RetinalReconstructedOutline$getFeatureSet(type)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>Base type of <a href="#topic+FeatureSet">FeatureSet</a> as string.
E.g. <code>PointSet</code> returns a <a href="#topic+ReconstructedPointSet">ReconstructedPointSet</a></p>
</dd>
</dl>

</div>


<hr>
<a id="method-RetinalReconstructedOutline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RetinalReconstructedOutline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct'>Start the Retistruct GUI</h2><span id='topic+retistruct'></span>

<h3>Description</h3>

<p>Start the Retistruct GUI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct()
</code></pre>


<h3>Value</h3>

<p>Object with <code>getData()</code> method to return
reconstructed retina data and environment <code>this</code> which
contains variables in object.
</p>

<hr>
<h2 id='retistruct.batch'>Batch operation using the parallel package</h2><span id='topic+retistruct.batch'></span>

<h3>Description</h3>

<p>This function reconstructs a number of  datasets, using the R
<code>parallel</code> package to distribute the reconstruction of
multiple datasets across CPUs. If <code>datasets</code> is not specified
the function recurses through a directory tree starting at
<code>tldir</code>, determining whether the directory contains valid raw
data and markup, and performing the reconstruction if it does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.batch(
  tldir = ".",
  outputdir = tldir,
  datasets = NULL,
  device = "pdf",
  titrate = FALSE,
  cpu.time.limit = 3600,
  mc.cores = getOption("mc.cores", 2L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.batch_+3A_tldir">tldir</code></td>
<td>
<p>If datasets is not specified, the top level of the
directory tree through which to recurse in order to find
datasets.</p>
</td></tr>
<tr><td><code id="retistruct.batch_+3A_outputdir">outputdir</code></td>
<td>
<p>directory in which to dump a log file and images</p>
</td></tr>
<tr><td><code id="retistruct.batch_+3A_datasets">datasets</code></td>
<td>
<p>Vector of dataset directories to reconstruct</p>
</td></tr>
<tr><td><code id="retistruct.batch_+3A_device">device</code></td>
<td>
<p>string indicating what type of graphics output
required. Options are <code>"pdf"</code> and <code>"png"</code>.</p>
</td></tr>
<tr><td><code id="retistruct.batch_+3A_titrate">titrate</code></td>
<td>
<p>Whether to &quot;titrate&quot; the reconstruction for
different values of <code>phi0</code>. See
<code>titrate.reconstructedOutline</code>.</p>
</td></tr>
<tr><td><code id="retistruct.batch_+3A_cpu.time.limit">cpu.time.limit</code></td>
<td>
<p>amount of CPU after which to terminate the
process</p>
</td></tr>
<tr><td><code id="retistruct.batch_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use. Defaults to the value
given by the option <code>mc.cores</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.batch.export.matlab'>Export data from reconstruction data files to MATLAB</h2><span id='topic+retistruct.batch.export.matlab'></span>

<h3>Description</h3>

<p>Recurse through a directory tree, determining whether the
directory contains valid derived data and converting
&lsquo;<span class="file">r.rData</span>&rsquo; files to files in MATLAB format named &lsquo;<span class="file">r.mat</span>&rsquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.batch.export.matlab(tldir = ".")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.batch.export.matlab_+3A_tldir">tldir</code></td>
<td>
<p>The top level of the directory tree through which to
recurse</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.batch.figures'>Plot figures for a batch of reconstructions</h2><span id='topic+retistruct.batch.figures'></span>

<h3>Description</h3>

<p>Recurse through a directory tree, determining whether the
directory contains valid derived data and plotting graphs if it
does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.batch.figures(tldir = ".", outputdir = tldir, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.batch.figures_+3A_tldir">tldir</code></td>
<td>
<p>The top level directory of the tree through which to
recurse.</p>
</td></tr>
<tr><td><code id="retistruct.batch.figures_+3A_outputdir">outputdir</code></td>
<td>
<p>Directory in which to dump a log file and images</p>
</td></tr>
<tr><td><code id="retistruct.batch.figures_+3A_...">...</code></td>
<td>
<p>Parameters passed to plotting functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.batch.get.titrations'>Get titrations from a directory of reconstructions</h2><span id='topic+retistruct.batch.get.titrations'></span>

<h3>Description</h3>

<p>Get titrations from a directory of reconstructions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.batch.get.titrations(tldir = ".")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.batch.get.titrations_+3A_tldir">tldir</code></td>
<td>
<p>The top level directory of the tree through which to
recurse. The files have to have been reconstructed with the
<code>titrate</code> option to <code><a href="#topic+retistruct.batch">retistruct.batch</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='retistruct.batch.plot.titrations'>Plot titrations</h2><span id='topic+retistruct.batch.plot.titrations'></span>

<h3>Description</h3>

<p>Plot titrations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.batch.plot.titrations(tdat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.batch.plot.titrations_+3A_tdat">tdat</code></td>
<td>
<p>Output of <code><a href="#topic+retistruct.batch.get.titrations">retistruct.batch.get.titrations</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='retistruct.batch.summary'>Extract summary data for a batch of reconstructions</h2><span id='topic+retistruct.batch.summary'></span>

<h3>Description</h3>

<p>Recurse through a directory tree, determining whether the
directory contains valid derived data and extracting summary data
if it does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.batch.summary(tldir = ".", cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.batch.summary_+3A_tldir">tldir</code></td>
<td>
<p>The top level directory of the tree through which to
recurse.</p>
</td></tr>
<tr><td><code id="retistruct.batch.summary_+3A_cache">cache</code></td>
<td>
<p>If <code>TRUE</code> use the cached statistics rather than
generate on the fly (which is slower).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containing summary data
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.check.markup'>Retistruct check markup</h2><span id='topic+retistruct.check.markup'></span>

<h3>Description</h3>

<p>Check that markup such as tears and the nasal or dorsal points are present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.check.markup(o)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.check.markup_+3A_o">o</code></td>
<td>
<p>Outline object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all markup is present, return <code>TRUE</code>. Otherwise
return <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.cli'>Process a dataset with a time limit</h2><span id='topic+retistruct.cli'></span>

<h3>Description</h3>

<p>This calls <code><a href="#topic+retistruct.cli.process">retistruct.cli.process</a></code> with a time limit
specified by <code>cpu.time.limit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.cli(
  dataset,
  cpu.time.limit = Inf,
  outputdir = NA,
  device = "pdf",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.cli_+3A_dataset">dataset</code></td>
<td>
<p>Path to dataset to process</p>
</td></tr>
<tr><td><code id="retistruct.cli_+3A_cpu.time.limit">cpu.time.limit</code></td>
<td>
<p>Time limit in seconds</p>
</td></tr>
<tr><td><code id="retistruct.cli_+3A_outputdir">outputdir</code></td>
<td>
<p>Directory in which to save any figures</p>
</td></tr>
<tr><td><code id="retistruct.cli_+3A_device">device</code></td>
<td>
<p>String representing device to print figures to</p>
</td></tr>
<tr><td><code id="retistruct.cli_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+retistruct.cli.process">retistruct.cli.process</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprising
</p>
<table role = "presentation">
<tr><td><code>status</code></td>
<td>
<p>0 for success, 1 for reaching
<code>cpu.time.limit</code> and 2 for an unknown error</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>The time take in seconds</p>
</td></tr>
<tr><td><code>mess</code></td>
<td>
<p>Any error message</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.cli.figure'>Print a figure to file</h2><span id='topic+retistruct.cli.figure'></span>

<h3>Description</h3>

<p>Print a figure to file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.cli.figure(
  dataset,
  outputdir,
  device = "pdf",
  width = 6,
  height = 6,
  res = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.cli.figure_+3A_dataset">dataset</code></td>
<td>
<p>Path to dataset to process</p>
</td></tr>
<tr><td><code id="retistruct.cli.figure_+3A_outputdir">outputdir</code></td>
<td>
<p>Directory in which to save any figures</p>
</td></tr>
<tr><td><code id="retistruct.cli.figure_+3A_device">device</code></td>
<td>
<p>String representing device to print figures to</p>
</td></tr>
<tr><td><code id="retistruct.cli.figure_+3A_width">width</code></td>
<td>
<p>Width of figures in inches</p>
</td></tr>
<tr><td><code id="retistruct.cli.figure_+3A_height">height</code></td>
<td>
<p>Height of figures in inches</p>
</td></tr>
<tr><td><code id="retistruct.cli.figure_+3A_res">res</code></td>
<td>
<p>Resolution of figures in dpi (only applies to bitmap
devices)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.cli.process'>Process a dataset, saving results to disk</h2><span id='topic+retistruct.cli.process'></span>

<h3>Description</h3>

<p>This function processes a <code>dataset</code>, saving the
reconstruction data and MATLAB export data to the <code>dataset</code>
directory and printing figures to <code>outputdir</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.cli.process(
  dataset,
  outputdir = NA,
  device = "pdf",
  titrate = FALSE,
  matlab = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.cli.process_+3A_dataset">dataset</code></td>
<td>
<p>Path to dataset to process</p>
</td></tr>
<tr><td><code id="retistruct.cli.process_+3A_outputdir">outputdir</code></td>
<td>
<p>Directory in which to save any figures</p>
</td></tr>
<tr><td><code id="retistruct.cli.process_+3A_device">device</code></td>
<td>
<p>String representing device to print figures to</p>
</td></tr>
<tr><td><code id="retistruct.cli.process_+3A_titrate">titrate</code></td>
<td>
<p>Whether to titrate or not</p>
</td></tr>
<tr><td><code id="retistruct.cli.process_+3A_matlab">matlab</code></td>
<td>
<p>Whether to save to MATLAB or not</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.export.matlab'>Save reconstruction data in MATLAB format</h2><span id='topic+retistruct.export.matlab'></span>

<h3>Description</h3>

<p>Save as a MATLAB object certain fields of an object <code>r</code> of
class<code><a href="#topic+RetinalReconstructedOutline">RetinalReconstructedOutline</a></code> to a file called
<code>r.mat</code> in the directory <code>r$dataset</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.export.matlab(r, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.export.matlab_+3A_r">r</code></td>
<td>
<p><code><a href="#topic+RetinalReconstructedOutline">RetinalReconstructedOutline</a></code> object</p>
</td></tr>
<tr><td><code id="retistruct.export.matlab_+3A_filename">filename</code></td>
<td>
<p>Filename of output file. If not specified, is
<code>r.mat</code> in the same directory as the input files</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.read.dataset'>Read a retinal dataset</h2><span id='topic+retistruct.read.dataset'></span>

<h3>Description</h3>

<p>Read a retinal dataset in one of three formats; for information on
formats see <code><a href="#topic+idt.read.dataset">idt.read.dataset</a></code>,
<code><a href="#topic+csv.read.dataset">csv.read.dataset</a></code> and
<code><a href="#topic+ijroi.read.dataset">ijroi.read.dataset</a></code>. The format is autodetected from
the files in the directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.read.dataset(dataset, report = message, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.read.dataset_+3A_dataset">dataset</code></td>
<td>
<p>Path to directory containing the files
corresponding to each format.</p>
</td></tr>
<tr><td><code id="retistruct.read.dataset_+3A_report">report</code></td>
<td>
<p>Function to report progress. Set to <code>FALSE</code> for
no reporting.</p>
</td></tr>
<tr><td><code id="retistruct.read.dataset_+3A_...">...</code></td>
<td>
<p>Parameters passed to the format-specific functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+RetinalOutline">RetinalOutline</a></code> object
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.read.markup'>Read the markup data</h2><span id='topic+retistruct.read.markup'></span>

<h3>Description</h3>

<p>Read the markup data contained in the files &lsquo;<span class="file">markup.csv</span>&rsquo;,
&lsquo;<span class="file">P.csv</span>&rsquo; and &lsquo;<span class="file">T.csv</span>&rsquo; in the directory &lsquo;<span class="file">dataset</span>&rsquo;,
which is specified in the reconstruction object <code>r</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.read.markup(a, error = stop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.read.markup_+3A_a">a</code></td>
<td>
<p>Dataset object, containing <code>dataset</code> path</p>
</td></tr>
<tr><td><code id="retistruct.read.markup_+3A_error">error</code></td>
<td>
<p>Function to run on error, by default <code>stop()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tear information is contained in the files &lsquo;<span class="file">P.csv</span>&rsquo; and
&lsquo;<span class="file">T.csv</span>&rsquo;. The first file contains the locations of outline
points that the tears were marked up on. The second file contains
the indices of the apex and backward and forward vertices of each
tear. It is necessary to have the file of points just in case the
algorithm that determines <code>P</code> in
<code><a href="#topic+retistruct.read.dataset">retistruct.read.dataset</a></code> has changed since the markup
of the tears.
</p>
<p>The remaining information is contained in the file
&lsquo;<span class="file">markup.csv</span>&rsquo;.
</p>
<p>If <code>DVflip</code> is specified, the locations of points <code>P</code>
flipped in the <code class="reqn">y</code>-direction. This operation also requires the
swapping of <code>gf</code>  and <code>gb</code> and <code>VF</code> and <code>VB</code>.
</p>


<h3>Value</h3>

<p>o <code>RetinalDataset</code> object
</p>
<table role = "presentation">
<tr><td><code>V0</code></td>
<td>
<p>Indices in <code>P</code> of apices of tears</p>
</td></tr>
<tr><td><code>VB</code></td>
<td>
<p>Indices in <code>P</code> of backward vertices of tears</p>
</td></tr>
<tr><td><code>VF</code></td>
<td>
<p>Indices in <code>P</code> of backward vertices of tears</p>
</td></tr>
<tr><td><code>iN</code></td>
<td>
<p>Index in <code>P</code> of nasal point, or <code>NA</code> if not marked</p>
</td></tr>
<tr><td><code>iD</code></td>
<td>
<p>Index in <code>P</code> of dorsal point, or <code>NA</code> if not marked</p>
</td></tr>
<tr><td><code>iOD</code></td>
<td>
<p>Index in <code>Ss</code> of optic disc </p>
</td></tr>
<tr><td><code>phi0</code></td>
<td>
<p>Angle of rim in degrees</p>
</td></tr>
<tr><td><code>DVflip</code></td>
<td>
<p>Boolean variable indicating if dorsoventral (DV) axis has been flipped</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.read.recdata'>Read the reconstruction data from file</h2><span id='topic+retistruct.read.recdata'></span>

<h3>Description</h3>

<p>Given an outline object with a <code>dataset</code> field, read the
reconstruction data from the file &lsquo;<span class="file"><var>dataset</var>/r.Rdata</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.read.recdata(o, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.read.recdata_+3A_o">o</code></td>
<td>
<p>Outline object containing <code>dataset</code> field</p>
</td></tr>
<tr><td><code id="retistruct.read.recdata_+3A_check">check</code></td>
<td>
<p>If <code>TRUE</code> check that the base information in the
reconstruction object is the same as the base data in source
files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the reconstruction data exists, return a reconstruction
object, else return the outline object <code>o</code>.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.reconstruct'>Reconstruct a retina</h2><span id='topic+retistruct.reconstruct'></span>

<h3>Description</h3>

<p>Reconstruct a retina
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.reconstruct(
  a,
  report = NULL,
  plot.3d = FALSE,
  dev.flat = NA,
  dev.polar = NA,
  shinyOutput = NULL,
  debug = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.reconstruct_+3A_a">a</code></td>
<td>
<p><code><a href="#topic+RetinalOutline">RetinalOutline</a></code> object with tear and
cut annotations</p>
</td></tr>
<tr><td><code id="retistruct.reconstruct_+3A_report">report</code></td>
<td>
<p>Function to report progress. Set to <code>FALSE</code> for
no reporting or to <code>NULL</code> to inherit from the argument given to <code><a href="#topic+retistruct.read.dataset">retistruct.read.dataset</a></code></p>
</td></tr>
<tr><td><code id="retistruct.reconstruct_+3A_plot.3d">plot.3d</code></td>
<td>
<p>If <code>TRUE</code> show progress in a 3D plot</p>
</td></tr>
<tr><td><code id="retistruct.reconstruct_+3A_dev.flat">dev.flat</code></td>
<td>
<p>The ID of the device to which to plot the flat
representation</p>
</td></tr>
<tr><td><code id="retistruct.reconstruct_+3A_dev.polar">dev.polar</code></td>
<td>
<p>The ID of the device to which to plot the polar
representation</p>
</td></tr>
<tr><td><code id="retistruct.reconstruct_+3A_shinyoutput">shinyOutput</code></td>
<td>
<p>A Shiny output element used to render and display a
plot in the application.</p>
</td></tr>
<tr><td><code id="retistruct.reconstruct_+3A_debug">debug</code></td>
<td>
<p>If <code>TRUE</code> print extra debugging output</p>
</td></tr>
<tr><td><code id="retistruct.reconstruct_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to
<code><a href="#topic+RetinalReconstructedOutline">RetinalReconstructedOutline</a></code> constructor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+RetinalReconstructedOutline">RetinalReconstructedOutline</a></code> object
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.save.markup'>Save markup</h2><span id='topic+retistruct.save.markup'></span>

<h3>Description</h3>

<p>Save the markup in the <code><a href="#topic+RetinalOutline">RetinalOutline</a></code> <code>a</code> to a
file called <code>markup.csv</code> in the directory <code>a$dataset</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.save.markup(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.save.markup_+3A_a">a</code></td>
<td>
<p><code><a href="#topic+RetinalOutline">RetinalOutline</a></code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='retistruct.save.recdata'>Save reconstruction data</h2><span id='topic+retistruct.save.recdata'></span>

<h3>Description</h3>

<p>Save the reconstruction data in an object <code>r</code> of class
<code><a href="#topic+RetinalReconstructedOutline">RetinalReconstructedOutline</a></code> to a file called
<code>r.Rdata</code> in the directory <code>r$dataset</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retistruct.save.recdata(r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retistruct.save.recdata_+3A_r">r</code></td>
<td>
<p><code><a href="#topic+RetinalReconstructedOutline">RetinalReconstructedOutline</a></code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='rotate.axis'>Rotate axis of sphere</h2><span id='topic+rotate.axis'></span>

<h3>Description</h3>

<p>This rotates points on sphere by specifying the direction its
polar axis, i.e. the axis going through (90, 0), should point
after (a) a rotation about an axis through the points (0, 0) and
(0, 180) and (b) rotation about the original polar axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate.axis(r, r0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate.axis_+3A_r">r</code></td>
<td>
<p>Coordinates of points in spherical coordinates
represented as  2 column matrix with column names <code>phi</code>
(latitude) and <code>lambda</code> (longitude).</p>
</td></tr>
<tr><td><code id="rotate.axis_+3A_r0">r0</code></td>
<td>
<p>Direction of the polar axis of the sphere on which to project
represented as a 2 column matrix of with column names <code>phi</code>
(latitude) and <code>lambda</code> (longitude).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-column matrix of spherical coordinates of points with
column names <code>phi</code> (latitude) and <code>lambda</code> (longitude).
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r0 &lt;- cbind(phi=0, lambda=-pi/2)
r &lt;- rbind(r0, r0+c(1,0), r0-c(1,0), r0+c(0,1), r0-c(0,1))
r &lt;- cbind(phi=pi/2, lambda=0)
rotate.axis(r, r0)
</code></pre>

<hr>
<h2 id='server'>Retistruct Shiny Server</h2><span id='topic+server'></span>

<h3>Description</h3>

<p>The R shiny server responsible for storing a state for each
session, handling inputs from the UI to the server, and plotting outputs
to the UI. The arguments are all handled by the shiny package and this
function should not be instantiated manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>server(input, output, session)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="server_+3A_input">input</code></td>
<td>
<p>object that holds the UI state (Managed automatically by shiny)</p>
</td></tr>
<tr><td><code id="server_+3A_output">output</code></td>
<td>
<p>sends new outputs to the UI (Managed automatically by shiny)</p>
</td></tr>
<tr><td><code id="server_+3A_session">session</code></td>
<td>
<p>controls each open instance (Managed automatically by shiny)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Okul
</p>

<hr>
<h2 id='simplifyFragment'>Simplify an outline object by removing short edges</h2><span id='topic+simplifyFragment'></span>

<h3>Description</h3>

<p>Simplify a fragment object by removing vertices bordering short
edges while not encroaching on any of the outline. At present,
this is done by finding concave vertices. It is safe to remove
these, at the expense of increasing the area a bit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplifyFragment(P, min.frac.length = 0.001, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simplifyFragment_+3A_p">P</code></td>
<td>
<p>points to simplify</p>
</td></tr>
<tr><td><code id="simplifyFragment_+3A_min.frac.length">min.frac.length</code></td>
<td>
<p>the minimum length as a fraction of the
total length of the outline.</p>
</td></tr>
<tr><td><code id="simplifyFragment_+3A_plot">plot</code></td>
<td>
<p>whether to display plotting or not during simplification</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simplified <code>outline</code> object
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='simplifyOutline'>Simplify an outline object by removing short edges</h2><span id='topic+simplifyOutline'></span>

<h3>Description</h3>

<p>Simplify a outline object by removing vertices bordering short
edges while not encroaching on any of the outline. At present,
this is done by finding concave vertices. It is safe to remove
these, at the expense of increasing the area a bit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplifyOutline(P, min.frac.length = 0.001, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simplifyOutline_+3A_p">P</code></td>
<td>
<p>points to simplify</p>
</td></tr>
<tr><td><code id="simplifyOutline_+3A_min.frac.length">min.frac.length</code></td>
<td>
<p>the minimum length as a fraction of the
total length of the outline.</p>
</td></tr>
<tr><td><code id="simplifyOutline_+3A_plot">plot</code></td>
<td>
<p>whether to display plotting or not during simplification</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simplified <code>outline</code> object
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='sinusoidal'>Sinusoidal projection</h2><span id='topic+sinusoidal'></span>

<h3>Description</h3>

<p>Sinusoidal projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinusoidal(
  r,
  proj.centre = cbind(phi = 0, lambda = 0),
  lambdalim = NULL,
  lines = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sinusoidal_+3A_r">r</code></td>
<td>
<p>Latitude-longitude coordinates in a matrix with columns
labelled <code>phi</code> (latitude) and <code>lambda</code>
(longitude). Alternatively string &quot;boundary&quot;, indicating that
boundary of projection should be drawn.</p>
</td></tr>
<tr><td><code id="sinusoidal_+3A_proj.centre">proj.centre</code></td>
<td>
<p>Location of centre of projection as matrix with
column names <code>phi</code> (elevation) and <code>lambda</code>
(longitude). Currently only longitude is used by this function.</p>
</td></tr>
<tr><td><code id="sinusoidal_+3A_lambdalim">lambdalim</code></td>
<td>
<p>Limits of longitude to plot</p>
</td></tr>
<tr><td><code id="sinusoidal_+3A_lines">lines</code></td>
<td>
<p>If this is <code>TRUE</code> create breaks of <code>NA</code>s
when lines cross the limits of longitude. This prevents lines
crossing the centre of the projection.</p>
</td></tr>
<tr><td><code id="sinusoidal_+3A_...">...</code></td>
<td>
<p>Arguments not used by this projection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two-column matrix with columns labelled <code>x</code> and
<code>y</code> of locations of projection of coordinates on plane
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Map_projection">https://en.wikipedia.org/wiki/Map_projection</a>,
<a href="http://mathworld.wolfram.com/SinusoidalProjection.html">http://mathworld.wolfram.com/SinusoidalProjection.html</a>
</p>

<hr>
<h2 id='sphere.cart.to.sphere.dualwedge'>Convert from Cartesian to &lsquo;dual-wedge&rsquo; coordinates</h2><span id='topic+sphere.cart.to.sphere.dualwedge'></span>

<h3>Description</h3>

<p>Convert points in 3D cartesian space to locations of points on
sphere in &lsquo;dual-wedge&rsquo; coordinates (<var>fx</var>, <var>fy</var>).  Wedges
are defined by planes inclined at angle running through a line
between poles on the rim above the x axis or the y-axis.  <var>fx</var>
and <var>fy</var> are the fractional distances along the circle defined
by the intersection of this plane and the curtailed sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere.cart.to.sphere.dualwedge(P, phi0, R = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphere.cart.to.sphere.dualwedge_+3A_p">P</code></td>
<td>
<p>locations of points on sphere as N-by-3 matrix with
labelled columns <code>X</code>, <code>Y</code> and <code>Z</code></p>
</td></tr>
<tr><td><code id="sphere.cart.to.sphere.dualwedge_+3A_phi0">phi0</code></td>
<td>
<p>rim angle as colatitude</p>
</td></tr>
<tr><td><code id="sphere.cart.to.sphere.dualwedge_+3A_r">R</code></td>
<td>
<p>radius of sphere</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-column Matrix of &lsquo;wedge&rsquo; coordinates of points on
sphere. Column names are <code>phi</code> and <code>lambda</code>.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='sphere.cart.to.sphere.spherical'>Convert from Cartesian to spherical coordinates</h2><span id='topic+sphere.cart.to.sphere.spherical'></span>

<h3>Description</h3>

<p>Convert locations on the surface of a sphere in cartesian
(X, Y, Z) coordinates to spherical (phi, lambda) coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere.cart.to.sphere.spherical(P, R = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphere.cart.to.sphere.spherical_+3A_p">P</code></td>
<td>
<p>locations of points on sphere as N-by-3 matrix with
labelled columns &quot;X&quot;, &quot;Y&quot; and &quot;Z&quot;</p>
</td></tr>
<tr><td><code id="sphere.cart.to.sphere.spherical_+3A_r">R</code></td>
<td>
<p>radius of sphere</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that all points are lying on the surface of a sphere
of radius R.
</p>


<h3>Value</h3>

<p>N-by-2 Matrix with columns (&quot;phi&quot; and &quot;lambda&quot;) of
locations of points in spherical coordinates
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='sphere.cart.to.sphere.wedge'>Convert from Cartesian to 'wedge' coordinates</h2><span id='topic+sphere.cart.to.sphere.wedge'></span>

<h3>Description</h3>

<p>Convert points in 3D cartesian space to locations of points on
sphere in 'wedge' coordinates (<var>psi</var>, <var>f</var>).  Wedges are
defined by planes inclined at an angle <var>psi</var> running through a
line between poles on the rim above the x axis.  <var>f</var> is the
fractional distance along the circle defined by the intersection
of this plane and the curtailed sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere.cart.to.sphere.wedge(P, phi0, R = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphere.cart.to.sphere.wedge_+3A_p">P</code></td>
<td>
<p>locations of points on sphere as N-by-3 matrix with
labelled columns &quot;X&quot;, &quot;Y&quot; and &quot;Z&quot;</p>
</td></tr>
<tr><td><code id="sphere.cart.to.sphere.wedge_+3A_phi0">phi0</code></td>
<td>
<p>rim angle as colatitude</p>
</td></tr>
<tr><td><code id="sphere.cart.to.sphere.wedge_+3A_r">R</code></td>
<td>
<p>radius of sphere</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-column Matrix of 'wedge' coordinates of points on
sphere. Column names are <code>phi</code> and <code>lambda</code>.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='sphere.spherical.to.polar.cart'>Convert spherical coordinates on sphere to  polar
projection in Cartesian coordinates</h2><span id='topic+sphere.spherical.to.polar.cart'></span>

<h3>Description</h3>

<p>This is the inverse of <code><a href="#topic+polar.cart.to.sphere.spherical">polar.cart.to.sphere.spherical</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere.spherical.to.polar.cart(r, pa = FALSE, preserve = "latitude")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphere.spherical.to.polar.cart_+3A_r">r</code></td>
<td>
<p>2-column Matrix of spherical coordinates of points on
sphere. Column names are <code>phi</code> and <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="sphere.spherical.to.polar.cart_+3A_pa">pa</code></td>
<td>
<p>If <code>TRUE</code>, make this an area-preserving projection</p>
</td></tr>
<tr><td><code id="sphere.spherical.to.polar.cart_+3A_preserve">preserve</code></td>
<td>
<p>Quantity to preserve locally in the
projection. Options are <code>latitude</code>, <code>area</code> or
<code>angle</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-column Matrix of Cartesian coordinates of points on polar
projection. Column names should be <code>x</code> and <code>y</code>
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='sphere.spherical.to.sphere.cart'>Convert from spherical to Cartesian coordinates</h2><span id='topic+sphere.spherical.to.sphere.cart'></span>

<h3>Description</h3>

<p>Convert locations of points on sphere in spherical coordinates to
points in 3D cartesian space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere.spherical.to.sphere.cart(Ps, R = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphere.spherical.to.sphere.cart_+3A_ps">Ps</code></td>
<td>
<p>N-by-2 matrix with columns containing latitudes
(<code>phi</code>) and longitudes (<code>lambda</code>) of N points</p>
</td></tr>
<tr><td><code id="sphere.spherical.to.sphere.cart_+3A_r">R</code></td>
<td>
<p>radius of sphere</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An N-by-3 matrix in which each row is the cartesian (X, Y,
Z) coordinates of each point
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='sphere.tri.area'>Area of triangles on a sphere</h2><span id='topic+sphere.tri.area'></span>

<h3>Description</h3>

<p>This uses L'Hullier's theorem to compute the spherical excess and
hence the area of the spherical triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere.tri.area(P, Tr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphere.tri.area_+3A_p">P</code></td>
<td>
<p>2-column matrix of vertices of triangles given in
spherical polar coordinates. Columns need to be labelled
<code>phi</code> (latitude) and <code>lambda</code> (longitude).</p>
</td></tr>
<tr><td><code id="sphere.tri.area_+3A_tr">Tr</code></td>
<td>
<p>3-column matrix of indices of rows of <code>P</code> giving
triangulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vectors of areas of triangles in units of steradians
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>Source</h3>

<p>Wolfram MathWorld
<a href="http://mathworld.wolfram.com/SphericalTriangle.html">http://mathworld.wolfram.com/SphericalTriangle.html</a> and
<a href="http://mathworld.wolfram.com/SphericalExcess.html">http://mathworld.wolfram.com/SphericalExcess.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Something that should be an eighth of a sphere, i.e. pi/2
P &lt;- cbind(phi=c(0, 0, pi/2), lambda=c(0, pi/2, pi/2))
Tr &lt;- cbind(1, 2, 3)
## The result of this should be 0.5
print(sphere.tri.area(P, Tr)/pi)

## Now a small triangle
P1 &lt;- cbind(phi=c(0, 0, 0.01), lambda=c(0, 0.01, 0.01))
Tr1 &lt;- cbind(1, 2, 3)
## The result of this should approximately 0.01^2/2
print(sphere.tri.area(P, Tr)/(0.01^2/2))

## Now check that it works for both
P &lt;- rbind(P, P1)
Tr &lt;- rbind(1:3, 4:6)
## Should have two components
print(sphere.tri.area(P, Tr))
</code></pre>

<hr>
<h2 id='sphere.wedge.to.sphere.cart'>Convert from 'wedge' to Cartesian coordinates</h2><span id='topic+sphere.wedge.to.sphere.cart'></span>

<h3>Description</h3>

<p>This in the inverse of <code><a href="#topic+sphere.cart.to.sphere.wedge">sphere.cart.to.sphere.wedge</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere.wedge.to.sphere.cart(psi, f, phi0, R = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphere.wedge.to.sphere.cart_+3A_psi">psi</code></td>
<td>
<p>vector of slice angles of N points</p>
</td></tr>
<tr><td><code id="sphere.wedge.to.sphere.cart_+3A_f">f</code></td>
<td>
<p>vector of fractional distances of N points</p>
</td></tr>
<tr><td><code id="sphere.wedge.to.sphere.cart_+3A_phi0">phi0</code></td>
<td>
<p>rim angle as colatitude</p>
</td></tr>
<tr><td><code id="sphere.wedge.to.sphere.cart_+3A_r">R</code></td>
<td>
<p>radius of sphere</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An N-by-3 matrix in which each row is the cartesian (X, Y,
Z) coordinates of each point
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='spherical.to.polar.area'>Convert latitude on sphere to radial variable in
area-preserving projection</h2><span id='topic+spherical.to.polar.area'></span>

<h3>Description</h3>

<p>Project spherical coordinate system <code class="reqn">(\phi, \lambda)</code> to a polar
coordinate system <code class="reqn">(\rho, \lambda)</code> such that the area of each
small region is preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spherical.to.polar.area(phi, R = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spherical.to.polar.area_+3A_phi">phi</code></td>
<td>
<p>Latitude</p>
</td></tr>
<tr><td><code id="spherical.to.polar.area_+3A_r">R</code></td>
<td>
<p>Radius</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This requires </p>
<p style="text-align: center;"><code class="reqn">R^2\delta\phi\cos\phi\delta\lambda =
\rho\delta\rho\delta\lambda</code>
</p>
<p>.  Hence </p>
<p style="text-align: center;"><code class="reqn">R^2\int^{\phi}_{-\pi/2}
\cos\phi' d\phi' = \int_0^{\rho} \rho' d\rho'</code>
</p>
<p>.  Solving gives
<code class="reqn">\rho^2/2=R^2(\sin\phi+1)</code> and hence
</p>
<p style="text-align: center;"><code class="reqn">\rho=R\sqrt{2(\sin\phi+1)}</code>
</p>
<p>.
</p>
<p>As a check, consider that total area needs to be preserved.  If
<code class="reqn">\rho_0</code> is maximum value of new variable then
<code class="reqn">A=2\pi R^2(\sin(\phi_0)+1)=\pi\rho_0^2</code>. So
<code class="reqn">\rho_0=R\sqrt{2(\sin\phi_0+1)}</code>, which agrees with the formula
above.
</p>


<h3>Value</h3>

<p>Coordinate <code>rho</code> that has the dimensions of length
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='sphericalplot'>Spherical plot of reconstructed outline</h2><span id='topic+sphericalplot'></span>

<h3>Description</h3>

<p>Spherical plot of reconstructed outline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphericalplot(r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphericalplot_+3A_r">r</code></td>
<td>
<p>Object inheriting <code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code></p>
</td></tr>
<tr><td><code id="sphericalplot_+3A_...">...</code></td>
<td>
<p>Parameters depending on class of <code>r</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='sphericalplot.ReconstructedOutline'>Spherical plot of reconstructed outline</h2><span id='topic+sphericalplot.ReconstructedOutline'></span>

<h3>Description</h3>

<p>Draw a spherical plot of reconstructed outline. This method just
draws the mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ReconstructedOutline'
sphericalplot(r, strain = FALSE, surf = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphericalplot.ReconstructedOutline_+3A_r">r</code></td>
<td>
<p><code><a href="#topic+ReconstructedOutline">ReconstructedOutline</a></code> object</p>
</td></tr>
<tr><td><code id="sphericalplot.ReconstructedOutline_+3A_strain">strain</code></td>
<td>
<p>If <code>TRUE</code>, plot the strain</p>
</td></tr>
<tr><td><code id="sphericalplot.ReconstructedOutline_+3A_surf">surf</code></td>
<td>
<p>If <code>TRUE</code>, plot the surface</p>
</td></tr>
<tr><td><code id="sphericalplot.ReconstructedOutline_+3A_...">...</code></td>
<td>
<p>Other graphics parameters &ndash; not used at present</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='StitchedOutline'>Class containing functions and data relating to Stitching outlines</h2><span id='topic+StitchedOutline'></span>

<h3>Description</h3>

<p>A StitchedOutline contains a function to stitch the
tears and fullcuts, setting the correspondences <code>hf</code>, <code>hb</code> and
<code>h</code>
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+OutlineCommon">retistruct::OutlineCommon</a></code> -&gt; <code><a href="#topic+Outline">retistruct::Outline</a></code> -&gt; <code><a href="#topic+PathOutline">retistruct::PathOutline</a></code> -&gt; <code><a href="#topic+AnnotatedOutline">retistruct::AnnotatedOutline</a></code> -&gt; <code><a href="#topic+TriangulatedOutline">retistruct::TriangulatedOutline</a></code> -&gt; <code>StitchedOutline</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Rset</code></dt><dd><p>the set of points on the rim</p>
</dd>
<dt><code>TFset</code></dt><dd><p>list containing indices of points in each forward tear</p>
</dd>
<dt><code>CFset</code></dt><dd><p>list containing indices of points in each forward cut</p>
</dd>
<dt><code>epsilon</code></dt><dd><p>the minimum distance between points, set
automatically</p>
</dd>
<dt><code>tearsStitched</code></dt><dd><p>Boolean indicating if tears have been stitched</p>
</dd>
<dt><code>fullCutsStitched</code></dt><dd><p>Boolean indicating if full cuts have been stitched</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-StitchedOutline-new"><code>StitchedOutline$new()</code></a>
</p>
</li>
<li> <p><a href="#method-StitchedOutline-stitchTears"><code>StitchedOutline$stitchTears()</code></a>
</p>
</li>
<li> <p><a href="#method-StitchedOutline-stitchFullCuts"><code>StitchedOutline$stitchFullCuts()</code></a>
</p>
</li>
<li> <p><a href="#method-StitchedOutline-isStitched"><code>StitchedOutline$isStitched()</code></a>
</p>
</li>
<li> <p><a href="#method-StitchedOutline-getBoundarySets"><code>StitchedOutline$getBoundarySets()</code></a>
</p>
</li>
<li> <p><a href="#method-StitchedOutline-clone"><code>StitchedOutline$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="clearFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-clearFeatureSets'><code>retistruct::OutlineCommon$clearFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSet"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSet'><code>retistruct::OutlineCommon$getFeatureSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSetTypes"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSetTypes'><code>retistruct::OutlineCommon$getFeatureSetTypes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSets'><code>retistruct::OutlineCommon$getFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getIDs"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getIDs'><code>retistruct::OutlineCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="addFeatureSet"><a href='../../retistruct/html/Outline.html#method-Outline-addFeatureSet'><code>retistruct::Outline$addFeatureSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getDepth"><a href='../../retistruct/html/Outline.html#method-Outline-getDepth'><code>retistruct::Outline$getDepth()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragment"><a href='../../retistruct/html/Outline.html#method-Outline-getFragment'><code>retistruct::Outline$getFragment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentIDs'><code>retistruct::Outline$getFragmentIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentIDsFromPointIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentIDsFromPointIDs'><code>retistruct::Outline$getFragmentIDsFromPointIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentPointIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentPointIDs'><code>retistruct::Outline$getFragmentPointIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentPoints"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentPoints'><code>retistruct::Outline$getFragmentPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getImage"><a href='../../retistruct/html/Outline.html#method-Outline-getImage'><code>retistruct::Outline$getImage()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getOutlineLengths"><a href='../../retistruct/html/Outline.html#method-Outline-getOutlineLengths'><code>retistruct::Outline$getOutlineLengths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getOutlineSet"><a href='../../retistruct/html/Outline.html#method-Outline-getOutlineSet'><code>retistruct::Outline$getOutlineSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPoints"><a href='../../retistruct/html/Outline.html#method-Outline-getPoints'><code>retistruct::Outline$getPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPointsScaled"><a href='../../retistruct/html/Outline.html#method-Outline-getPointsScaled'><code>retistruct::Outline$getPointsScaled()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPointsXY"><a href='../../retistruct/html/Outline.html#method-Outline-getPointsXY'><code>retistruct::Outline$getPointsXY()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="mapFragment"><a href='../../retistruct/html/Outline.html#method-Outline-mapFragment'><code>retistruct::Outline$mapFragment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="mapPids"><a href='../../retistruct/html/Outline.html#method-Outline-mapPids'><code>retistruct::Outline$mapPids()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="replaceImage"><a href='../../retistruct/html/Outline.html#method-Outline-replaceImage'><code>retistruct::Outline$replaceImage()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="PathOutline" data-id="insertPoint"><a href='../../retistruct/html/PathOutline.html#method-PathOutline-insertPoint'><code>retistruct::PathOutline$insertPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="PathOutline" data-id="nextPoint"><a href='../../retistruct/html/PathOutline.html#method-PathOutline-nextPoint'><code>retistruct::PathOutline$nextPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="PathOutline" data-id="stitchSubpaths"><a href='../../retistruct/html/PathOutline.html#method-PathOutline-stitchSubpaths'><code>retistruct::PathOutline$stitchSubpaths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="addFullCut"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-addFullCut'><code>retistruct::AnnotatedOutline$addFullCut()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="addPoints"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-addPoints'><code>retistruct::AnnotatedOutline$addPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="addTear"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-addTear'><code>retistruct::AnnotatedOutline$addTear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="checkTears"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-checkTears'><code>retistruct::AnnotatedOutline$checkTears()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="computeFullCutRelationships"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-computeFullCutRelationships'><code>retistruct::AnnotatedOutline$computeFullCutRelationships()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="computeTearRelationships"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-computeTearRelationships'><code>retistruct::AnnotatedOutline$computeTearRelationships()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="ensureFixedPointInRim"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-ensureFixedPointInRim'><code>retistruct::AnnotatedOutline$ensureFixedPointInRim()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getFixedPoint"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getFixedPoint'><code>retistruct::AnnotatedOutline$getFixedPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getFullCut"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getFullCut'><code>retistruct::AnnotatedOutline$getFullCut()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getFullCuts"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getFullCuts'><code>retistruct::AnnotatedOutline$getFullCuts()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getRimLengths"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getRimLengths'><code>retistruct::AnnotatedOutline$getRimLengths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getRimSet"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getRimSet'><code>retistruct::AnnotatedOutline$getRimSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getTear"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getTear'><code>retistruct::AnnotatedOutline$getTear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getTears"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getTears'><code>retistruct::AnnotatedOutline$getTears()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="labelFullCutPoints"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-labelFullCutPoints'><code>retistruct::AnnotatedOutline$labelFullCutPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="labelTearPoints"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-labelTearPoints'><code>retistruct::AnnotatedOutline$labelTearPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="removeFullCut"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-removeFullCut'><code>retistruct::AnnotatedOutline$removeFullCut()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="removeTear"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-removeTear'><code>retistruct::AnnotatedOutline$removeTear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="setFixedPoint"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-setFixedPoint'><code>retistruct::AnnotatedOutline$setFixedPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="whichFullCut"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-whichFullCut'><code>retistruct::AnnotatedOutline$whichFullCut()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="whichTear"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-whichTear'><code>retistruct::AnnotatedOutline$whichTear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="TriangulatedOutline" data-id="mapTriangulatedFragment"><a href='../../retistruct/html/TriangulatedOutline.html#method-TriangulatedOutline-mapTriangulatedFragment'><code>retistruct::TriangulatedOutline$mapTriangulatedFragment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="TriangulatedOutline" data-id="triangulate"><a href='../../retistruct/html/TriangulatedOutline.html#method-TriangulatedOutline-triangulate'><code>retistruct::TriangulatedOutline$triangulate()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-StitchedOutline-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>StitchedOutline$new(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters to superclass constructors</p>
</dd>
</dl>

</div>


<hr>
<a id="method-StitchedOutline-stitchTears"></a>



<h4>Method <code>stitchTears()</code></h4>

<p>Stitch together the incisions and tears by inserting new
points in the tears and creating correspondences between new
points.
</p>


<h5>Usage</h5>

<div class="r"><pre>StitchedOutline$stitchTears()</pre></div>


<hr>
<a id="method-StitchedOutline-stitchFullCuts"></a>



<h4>Method <code>stitchFullCuts()</code></h4>

<p>Stitch together the fullcuts by inserting new
points in the tears and creating correspondences between new
points.
</p>


<h5>Usage</h5>

<div class="r"><pre>StitchedOutline$stitchFullCuts()</pre></div>


<hr>
<a id="method-StitchedOutline-isStitched"></a>



<h4>Method <code>isStitched()</code></h4>

<p>Test if the outline has been stitched
</p>


<h5>Usage</h5>

<div class="r"><pre>StitchedOutline$isStitched()</pre></div>



<h5>Returns</h5>

<p>Boolean, indicating if the outline has been stitched or not
</p>


<hr>
<a id="method-StitchedOutline-getBoundarySets"></a>



<h4>Method <code>getBoundarySets()</code></h4>

<p>Get point IDs of points on boundaries
</p>


<h5>Usage</h5>

<div class="r"><pre>StitchedOutline$getBoundarySets()</pre></div>



<h5>Returns</h5>

<p>List of Point IDs of points on the boundaries.
If the outline has been stitched,
the point IDs in each
element of the list will be ordered in the direction of the
forward pointer, and the boundary that is longest will be
named as <code>Rim</code>. If the outline has not been stitched,
the list will have one element named <code>Rim</code>.
</p>


<hr>
<a id="method-StitchedOutline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>StitchedOutline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='strain.colours'>Generate colours for strain plots</h2><span id='topic+strain.colours'></span>

<h3>Description</h3>

<p>Generate colours for strain plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strain.colours(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strain.colours_+3A_x">x</code></td>
<td>
<p>Vector of values of log strain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of colours corresponding to strains
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='stretchMesh'>Stretch mesh</h2><span id='topic+stretchMesh'></span>

<h3>Description</h3>

<p>Stretch the mesh in the flat retina to a circular outline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stretchMesh(Cu, L, i.fix, P.fix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stretchMesh_+3A_cu">Cu</code></td>
<td>
<p>Edge matrix</p>
</td></tr>
<tr><td><code id="stretchMesh_+3A_l">L</code></td>
<td>
<p>Lengths in flat outline</p>
</td></tr>
<tr><td><code id="stretchMesh_+3A_i.fix">i.fix</code></td>
<td>
<p>Indices of fixed points</p>
</td></tr>
<tr><td><code id="stretchMesh_+3A_p.fix">P.fix</code></td>
<td>
<p>Coordinates of fixed points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New matrix of 2D point locations
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='tri.area'>Area of triangles on a plane</h2><span id='topic+tri.area'></span>

<h3>Description</h3>

<p>Area of triangles on a plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.area(P, Tr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tri.area_+3A_p">P</code></td>
<td>
<p>3-column matrix of vertices of triangles</p>
</td></tr>
<tr><td><code id="tri.area_+3A_tr">Tr</code></td>
<td>
<p>3-column matrix of indices of rows of <code>P</code> giving
triangulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vectors of areas of triangles
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='tri.area.signed'>&quot;Signed area&quot; of triangles on a plane</h2><span id='topic+tri.area.signed'></span>

<h3>Description</h3>

<p>&quot;Signed area&quot; of triangles on a plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.area.signed(P, Tr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tri.area.signed_+3A_p">P</code></td>
<td>
<p>3-column matrix of vertices of triangles</p>
</td></tr>
<tr><td><code id="tri.area.signed_+3A_tr">Tr</code></td>
<td>
<p>3-column matrix of indices of rows of <code>P</code> giving
triangulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vectors of signed areas of triangles. Positive sign
indicates points are anticlockwise direction; negative indicates
clockwise.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='TriangulatedFragment'>Class to triangulate <a href="#topic+Fragment">Fragment</a>s</h2><span id='topic+TriangulatedFragment'></span>

<h3>Description</h3>

<p>A TriangulatedFragment contains a function to create a
triangulated mesh over an fragment, and fields to hold the mesh
information.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Fragment">retistruct::Fragment</a></code> -&gt; <code>TriangulatedFragment</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Tr</code></dt><dd><p>3 column matrix in which each row contains IDs of
points of each triangle</p>
</dd>
<dt><code>A</code></dt><dd><p>Area of each triangle in the  mesh - has same number of
elements as there are rows of <code>T</code></p>
</dd>
<dt><code>Cu</code></dt><dd><p>2 column matrix in which each row contains IDs of
points of edge in mesh</p>
</dd>
<dt><code>L</code></dt><dd><p>Length of each edge in the mesh - has same number of
elements as there are rows of <code>Cu</code></p>
</dd>
<dt><code>A.signed</code></dt><dd><p>Signed area of each triangle generated using
<code><a href="#topic+tri.area.signed">tri.area.signed</a></code>. Positive sign indicates points are
anticlockwise direction; negative indicates clockwise.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TriangulatedFragment-new"><code>TriangulatedFragment$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TriangulatedFragment-clone"><code>TriangulatedFragment$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Fragment" data-id="initializeFromPoints"><a href='../../retistruct/html/Fragment.html#method-Fragment-initializeFromPoints'><code>retistruct::Fragment$initializeFromPoints()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TriangulatedFragment-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor
</p>


<h5>Usage</h5>

<div class="r"><pre>TriangulatedFragment$new(
  fragment,
  n = 200,
  suppress.external.steiner = FALSE,
  report = message
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fragment</code></dt><dd><p><a href="#topic+Fragment">Fragment</a> to triangulate</p>
</dd>
<dt><code>n</code></dt><dd><p>Minimum number of points in the triangulation</p>
</dd>
<dt><code>suppress.external.steiner</code></dt><dd><p>If <code>TRUE</code> prevent the
addition of points in the outline. This happens to maintain
triangle quality.</p>
</dd>
<dt><code>report</code></dt><dd><p>Function to report progress</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TriangulatedFragment-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TriangulatedFragment$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='TriangulatedOutline'>Class containing functions and data relating to Triangulation</h2><span id='topic+TriangulatedOutline'></span>

<h3>Description</h3>

<p>A TriangulatedOutline contains a function to create a
triangulated mesh over an outline, and fields to hold the mesh
information. Note that areas and lengths are all scaled using
the value of the <code>scale</code> field.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+OutlineCommon">retistruct::OutlineCommon</a></code> -&gt; <code><a href="#topic+Outline">retistruct::Outline</a></code> -&gt; <code><a href="#topic+PathOutline">retistruct::PathOutline</a></code> -&gt; <code><a href="#topic+AnnotatedOutline">retistruct::AnnotatedOutline</a></code> -&gt; <code>TriangulatedOutline</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Tr</code></dt><dd><p>3 column matrix in which each row contains IDs of
points of each triangle</p>
</dd>
<dt><code>A</code></dt><dd><p>Area of each triangle in the mesh - has same number of
elements as there are rows of <code>T</code></p>
</dd>
<dt><code>A.tot</code></dt><dd><p>Total area of the mesh</p>
</dd>
<dt><code>Cu</code></dt><dd><p>2 column matrix in which each row contains IDs of</p>
</dd>
<dt><code>L</code></dt><dd><p>Length of each edge in the mesh - has same number of
elements as there are rows of <code>Cu</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TriangulatedOutline-triangulate"><code>TriangulatedOutline$triangulate()</code></a>
</p>
</li>
<li> <p><a href="#method-TriangulatedOutline-mapTriangulatedFragment"><code>TriangulatedOutline$mapTriangulatedFragment()</code></a>
</p>
</li>
<li> <p><a href="#method-TriangulatedOutline-clone"><code>TriangulatedOutline$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="clearFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-clearFeatureSets'><code>retistruct::OutlineCommon$clearFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSet"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSet'><code>retistruct::OutlineCommon$getFeatureSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSetTypes"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSetTypes'><code>retistruct::OutlineCommon$getFeatureSetTypes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getFeatureSets"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getFeatureSets'><code>retistruct::OutlineCommon$getFeatureSets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="OutlineCommon" data-id="getIDs"><a href='../../retistruct/html/OutlineCommon.html#method-OutlineCommon-getIDs'><code>retistruct::OutlineCommon$getIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="addFeatureSet"><a href='../../retistruct/html/Outline.html#method-Outline-addFeatureSet'><code>retistruct::Outline$addFeatureSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getDepth"><a href='../../retistruct/html/Outline.html#method-Outline-getDepth'><code>retistruct::Outline$getDepth()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragment"><a href='../../retistruct/html/Outline.html#method-Outline-getFragment'><code>retistruct::Outline$getFragment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentIDs'><code>retistruct::Outline$getFragmentIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentIDsFromPointIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentIDsFromPointIDs'><code>retistruct::Outline$getFragmentIDsFromPointIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentPointIDs"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentPointIDs'><code>retistruct::Outline$getFragmentPointIDs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getFragmentPoints"><a href='../../retistruct/html/Outline.html#method-Outline-getFragmentPoints'><code>retistruct::Outline$getFragmentPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getImage"><a href='../../retistruct/html/Outline.html#method-Outline-getImage'><code>retistruct::Outline$getImage()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getOutlineLengths"><a href='../../retistruct/html/Outline.html#method-Outline-getOutlineLengths'><code>retistruct::Outline$getOutlineLengths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getOutlineSet"><a href='../../retistruct/html/Outline.html#method-Outline-getOutlineSet'><code>retistruct::Outline$getOutlineSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPoints"><a href='../../retistruct/html/Outline.html#method-Outline-getPoints'><code>retistruct::Outline$getPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPointsScaled"><a href='../../retistruct/html/Outline.html#method-Outline-getPointsScaled'><code>retistruct::Outline$getPointsScaled()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="getPointsXY"><a href='../../retistruct/html/Outline.html#method-Outline-getPointsXY'><code>retistruct::Outline$getPointsXY()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="mapFragment"><a href='../../retistruct/html/Outline.html#method-Outline-mapFragment'><code>retistruct::Outline$mapFragment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="mapPids"><a href='../../retistruct/html/Outline.html#method-Outline-mapPids'><code>retistruct::Outline$mapPids()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="Outline" data-id="replaceImage"><a href='../../retistruct/html/Outline.html#method-Outline-replaceImage'><code>retistruct::Outline$replaceImage()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="PathOutline" data-id="insertPoint"><a href='../../retistruct/html/PathOutline.html#method-PathOutline-insertPoint'><code>retistruct::PathOutline$insertPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="PathOutline" data-id="nextPoint"><a href='../../retistruct/html/PathOutline.html#method-PathOutline-nextPoint'><code>retistruct::PathOutline$nextPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="PathOutline" data-id="stitchSubpaths"><a href='../../retistruct/html/PathOutline.html#method-PathOutline-stitchSubpaths'><code>retistruct::PathOutline$stitchSubpaths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="addFullCut"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-addFullCut'><code>retistruct::AnnotatedOutline$addFullCut()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="addPoints"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-addPoints'><code>retistruct::AnnotatedOutline$addPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="addTear"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-addTear'><code>retistruct::AnnotatedOutline$addTear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="checkTears"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-checkTears'><code>retistruct::AnnotatedOutline$checkTears()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="computeFullCutRelationships"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-computeFullCutRelationships'><code>retistruct::AnnotatedOutline$computeFullCutRelationships()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="computeTearRelationships"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-computeTearRelationships'><code>retistruct::AnnotatedOutline$computeTearRelationships()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="ensureFixedPointInRim"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-ensureFixedPointInRim'><code>retistruct::AnnotatedOutline$ensureFixedPointInRim()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getBoundarySets"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getBoundarySets'><code>retistruct::AnnotatedOutline$getBoundarySets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getFixedPoint"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getFixedPoint'><code>retistruct::AnnotatedOutline$getFixedPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getFullCut"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getFullCut'><code>retistruct::AnnotatedOutline$getFullCut()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getFullCuts"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getFullCuts'><code>retistruct::AnnotatedOutline$getFullCuts()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getRimLengths"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getRimLengths'><code>retistruct::AnnotatedOutline$getRimLengths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getRimSet"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getRimSet'><code>retistruct::AnnotatedOutline$getRimSet()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getTear"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getTear'><code>retistruct::AnnotatedOutline$getTear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="getTears"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-getTears'><code>retistruct::AnnotatedOutline$getTears()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="initialize"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-initialize'><code>retistruct::AnnotatedOutline$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="labelFullCutPoints"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-labelFullCutPoints'><code>retistruct::AnnotatedOutline$labelFullCutPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="labelTearPoints"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-labelTearPoints'><code>retistruct::AnnotatedOutline$labelTearPoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="removeFullCut"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-removeFullCut'><code>retistruct::AnnotatedOutline$removeFullCut()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="removeTear"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-removeTear'><code>retistruct::AnnotatedOutline$removeTear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="setFixedPoint"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-setFixedPoint'><code>retistruct::AnnotatedOutline$setFixedPoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="whichFullCut"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-whichFullCut'><code>retistruct::AnnotatedOutline$whichFullCut()</code></a></span></li>
<li><span class="pkg-link" data-pkg="retistruct" data-topic="AnnotatedOutline" data-id="whichTear"><a href='../../retistruct/html/AnnotatedOutline.html#method-AnnotatedOutline-whichTear'><code>retistruct::AnnotatedOutline$whichTear()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TriangulatedOutline-triangulate"></a>



<h4>Method <code>triangulate()</code></h4>

<p>Triangulate (mesh) outline
</p>


<h5>Usage</h5>

<div class="r"><pre>TriangulatedOutline$triangulate(n = 200, suppress.external.steiner = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Desired number of points in mesh</p>
</dd>
<dt><code>suppress.external.steiner</code></dt><dd><p>Boolean variable describing
whether to insert external Steiner points - see
<a href="#topic+TriangulatedFragment">TriangulatedFragment</a></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TriangulatedOutline-mapTriangulatedFragment"></a>



<h4>Method <code>mapTriangulatedFragment()</code></h4>

<p>Map the point IDs of a <a href="#topic+TriangulatedFragment">TriangulatedFragment</a> on the
point IDs of this Outline
</p>


<h5>Usage</h5>

<div class="r"><pre>TriangulatedOutline$mapTriangulatedFragment(fragment, pids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fragment</code></dt><dd><p><a href="#topic+TriangulatedFragment">TriangulatedFragment</a> to map</p>
</dd>
<dt><code>pids</code></dt><dd><p>Point IDs in TriangulatedOutline of points in <a href="#topic+TriangulatedFragment">TriangulatedFragment</a></p>
</dd>
</dl>

</div>


<hr>
<a id="method-TriangulatedOutline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TriangulatedOutline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- rbind(c(1,1),   c(2,1),  c(2,-1),
           c(1,-1),  c(1,-2), c(-1,-2),
           c(-1,-1), c(-2,-1),c(-2,1),
           c(-1,1),  c(-1,2), c(1,2))
o &lt;- TriangulatedOutline$new(P)
o$addTear(c(3, 4, 5))
o$addTear(c(6, 7, 8))
o$addTear(c(9, 10, 11))
o$addTear(c(12, 1, 2))
flatplot(o)

P &lt;- list(rbind(c(1,1), c(2,1), c(2.5,2), c(3,1), c(4,1), c(1,4)),
              rbind(c(-1,1), c(-1,4), c(-2,3), c(-2,2), c(-3,2), c(-4,1)),
              rbind(c(-4,-1), c(-1,-1), c(-1,-4)),
              rbind(c(1,-1), c(2,-1), c(2.5,-2), c(3,-1), c(4,-1), c(1,-4)))
o &lt;- TriangulatedOutline$new(P)
##' o$addTear(c(2, 3, 4))
o$addTear(c(17, 18, 19))
o$addTear(c(9, 10, 11))
o$addFullCut(c(1, 5, 16, 20))
flatplot(o)
</code></pre>

<hr>
<h2 id='ui'>Retistruct UI</h2><span id='topic+ui'></span>

<h3>Description</h3>

<p>The Shiny UI element, runs on a browser and is similar to HTML, attempted to
mimic the original Retistruct UI as closely as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui
</code></pre>


<h3>Format</h3>

<p>An object of class <code>shiny.tag.list</code> (inherits from <code>list</code>) of length 4.
</p>


<h3>Author(s)</h3>

<p>Jan Okul
</p>

<hr>
<h2 id='vecnorm'>Vector norm</h2><span id='topic+vecnorm'></span>

<h3>Description</h3>

<p>Vector norm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecnorm(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecnorm_+3A_x">X</code></td>
<td>
<p>Vector or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a vector, returns the 2-norm  of the
vector. If a matrix, returns the 2-norm of each row of the matrix
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
