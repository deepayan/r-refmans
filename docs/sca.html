<!DOCTYPE html><html lang="en"><head><title>Help for package sca</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sca}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#agglomblock'><p>Agglomerate Two Block-Components in SCA</p></a></li>
<li><a href='#allcrit'><p>Simple Component Quality Criterion Computation</p></a></li>
<li><a href='#corcomp'><p>Covariance and Correlation Matrix of Components P on S</p></a></li>
<li><a href='#firstpcres'><p>First Principal Component of Residuals given Components</p></a></li>
<li><a href='#hearlossC'><p>Hearing Loss Correlation Data</p></a></li>
<li><a href='#maxmatrix'><p>Largest Element in Correlation Matrix</p></a></li>
<li><a href='#nextdiff'><p>Compute the Next Simple Difference-Component for SCA</p></a></li>
<li><a href='#percent'><p>Simple Formatting of Percentages</p></a></li>
<li><a href='#pitpropC'><p>Pitprops Strength Correlation Data</p></a></li>
<li><a href='#quickcrit'><p>Additional Contribution of New Component to the SC System</p></a></li>
<li><a href='#reflexesC'><p>Human Reflexes Correlation Data</p></a></li>
<li><a href='#sca'><p>Simple Component Analysis &ndash; Interactively</p></a></li>
<li><a href='#shrinkdiff'><p>Shrink Component Towards a Simple Difference-Component in SCA</p></a></li>
<li><a href='#simpvector'><p>Simplify a (Principal Component) Vector to a Simple Component</p></a></li>
<li><a href='#sortmatrix'><p>Sort Simple Component Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Simple Component Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-29</td>
</tr>
<tr>
<td>Description:</td>
<td>Simple Component Analysis (SCA) often provides much more
   interpretable components than Principal Components (PCA) while still
   representing much of the variability in the data.</td>
</tr>
<tr>
<td>Author:</td>
<td>Valentin Rousson &lt;rousson@ifspm.unizh.ch&gt; and Martin Maechler</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, Matrix</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 14:59:51 UTC; maechler</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='agglomblock'>Agglomerate Two Block-Components in SCA</h2><span id='topic+agglomblock'></span>

<h3>Description</h3>

<p>Agglomerate the two block-components which are <em>closest</em>
according to the specified <code>cluster</code>ing method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agglomblock(S, P, cluster = c("median","single","complete"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agglomblock_+3A_s">S</code></td>
<td>
<p>correlation/covariance matrix</p>
</td></tr>
<tr><td><code id="agglomblock_+3A_p">P</code></td>
<td>
<p>component matrix</p>
</td></tr>
<tr><td><code id="agglomblock_+3A_cluster">cluster</code></td>
<td>
<p>character specifying the clustering method; default
<code>"median"</code>, see <code><a href="#topic+sca">sca</a>(*, cluster=)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New component matrix with one block component less.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sca">sca</a></code>, also for references</p>

<hr>
<h2 id='allcrit'>Simple Component Quality Criterion Computation</h2><span id='topic+allcrit'></span><span id='topic+sccrit'></span>

<h3>Description</h3>

<p>Compute simple component criterion for components <code>P</code> on
cor.matrix <code>S</code> (cumulative), using <code>sccrit()</code>.
</p>
<p>Function <code>allcrit()</code> computes even more criteria, some derived
from <code>sccrit()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allcrit(S, P, criterion, sortP = TRUE)
 sccrit(S, P, criterion, sortP = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allcrit_+3A_s">S</code></td>
<td>
<p>correlation/covariance matrix</p>
</td></tr>
<tr><td><code id="allcrit_+3A_p">P</code></td>
<td>
<p>component matrix</p>
</td></tr>
<tr><td><code id="allcrit_+3A_criterion">criterion</code></td>
<td>
<p>character string specifying the optimality criterion
to be used in <code>sccrit()</code> for evaluating a system of simple
components.  One of <code>"csv"</code> (corrected sum of variances) or
<code>"blp"</code> (best linear predictor).</p>
</td></tr>
<tr><td><code id="allcrit_+3A_sortp">sortP</code></td>
<td>
<p>logical indicating if <code>P</code> should be sorted; if true,
<code>sortmatrix(S,P)</code> used in lieu of <code>P</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sccrit()</code> returns a numeric vector, the criterion computed
(cumulatively).
</p>
<p><code>allcrit()</code> returns a list with components <code>varpc</code>,
<code>varsc</code>, <code>cumpc</code>, <code>cumsc</code>, <code>opt</code>, <code>corsc</code>,
and <code>maxcor</code>;
see the description of the <code>allcrit</code> component in the return value
of <code><a href="#topic+sca">sca</a>()</code>.
</p>


<h3>Author(s)</h3>

<p>Valentin Rousson <a href="mailto:rousson@ifspm.unizh.ch">rousson@ifspm.unizh.ch</a> and
Martin Maechler <a href="mailto:maechler@stat.math.ethz.ch">maechler@stat.math.ethz.ch</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+quickcrit">quickcrit</a></code>, <code><a href="#topic+sca">sca</a></code>, also for references.</p>

<hr>
<h2 id='corcomp'>Covariance and Correlation Matrix of Components P on S</h2><span id='topic+corcomp'></span><span id='topic+covcomp'></span>

<h3>Description</h3>

<p><code>covcomp</code> returns the variance-covariance matrix of the
components P on S, and <code>corcomp</code> returns the correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corcomp(S, P)
covcomp(S, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corcomp_+3A_s">S</code></td>
<td>
<p>correlation/covariance matrix of the <code class="reqn">p</code> original variables.</p>
</td></tr>
<tr><td><code id="corcomp_+3A_p">P</code></td>
<td>
<p>component matrix of dimension <code class="reqn">p \times b</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square <code class="reqn">b \times b</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Valentin Rousson <a href="mailto:rousson@ifspm.unizh.ch">rousson@ifspm.unizh.ch</a> and
Martin Maechler <a href="mailto:maechler@stat.math.ethz.ch">maechler@stat.math.ethz.ch</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sca">sca</a></code>, also for references</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USJudgeRatings)
S.jr &lt;- cor(USJudgeRatings)
sca.jr &lt;- sca(S.jr, b=4, inter=FALSE)
Vr &lt;- covcomp(S.jr, P = sca.jr$simplemat)
Vr
Cr &lt;- corcomp(S.jr, P = sca.jr$simplemat)
Cr
</code></pre>

<hr>
<h2 id='firstpcres'>First Principal Component of Residuals given Components</h2><span id='topic+firstpcres'></span>

<h3>Description</h3>

<p>Return the first principal component of residuals of <code>S</code> given
the components <code>P</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstpcres(S, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="firstpcres_+3A_s">S</code></td>
<td>
<p>correlation/covariance matrix</p>
</td></tr>
<tr><td><code id="firstpcres_+3A_p">P</code></td>
<td>
<p>component matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector; actually, the first eigenvector of
<code class="reqn">S - A' (A P)^{-1} A</code> where <code class="reqn">A := P' S</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sca">sca</a></code>, also for references</p>

<hr>
<h2 id='hearlossC'>Hearing Loss Correlation Data</h2><span id='topic+hearlossC'></span>

<h3>Description</h3>

<p>The data consist of eight measurements of hearing loss taken on 100
males, aged 39, who had no indication of hearing difficulties.  These
measurements are decibel loss (in comparison to a reference standard)  at
frequencies 500Hz, 1000Hz, 2000Hz and 4000Hz for the left and the right
ear, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hearlossC)</code></pre>


<h3>Format</h3>

<p>Eight Variables, first the ones for &ldquo;Left&rdquo;, than for the &ldquo;Right&rdquo;.
The frequences are abbreviated, e.g., <code>2k</code> for <em>2000 Hz</em> or
<code>5c</code> for <em>500 Hz</em>.
The variable names are (in this order)
<code>"Left5c",  "Left1k",  "Left2k",  "Left4k",
    "Right5c", "Right1k", "Right2k", "Right4k"</code>.
</p>


<h3>Source</h3>

<p>This is the correlation matrix of data described in Chapter 5 of
Jackson (1991).
</p>


<h3>References</h3>

<p>Jackson, J.E. (1991)
<em>A User's Guide to Principal Components</em>.
John Wiley, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hearlossC)
symnum(hearlossC)
sca(hearlossC) # -&gt; explains 89.46% instead of 91.62
</code></pre>

<hr>
<h2 id='maxmatrix'>Largest Element in Correlation Matrix</h2><span id='topic+maxmatrix'></span>

<h3>Description</h3>

<p>return position and value of the largest element of a correlation matrix R
(without taking into account the diagonal elements)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxmatrix(R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxmatrix_+3A_r">R</code></td>
<td>
<p>a square symmetric numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>
<table role = "presentation">
<tr><td><code>row</code></td>
<td>
<p>row index of maximum</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>col index of maximum</p>
</td></tr>
<tr><td><code>val</code></td>
<td>
<p>value of maximum, i.e. <code>val == R[row,col]</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sca">sca</a></code>, also for references</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(reflexesC)
maxmatrix(reflexesC) # -&gt;  0.98 at  [1, 2]
</code></pre>

<hr>
<h2 id='nextdiff'>Compute the Next Simple Difference-Component for SCA</h2><span id='topic+nextdiff'></span>

<h3>Description</h3>

<p>Compute the next simple difference-component; this is an auxiliary
function for <code><a href="#topic+sca">sca</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextdiff(S, P, withinblock, criterion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nextdiff_+3A_s">S</code></td>
<td>
<p>correlation/covariance matrix</p>
</td></tr>
<tr><td><code id="nextdiff_+3A_p">P</code></td>
<td>
<p>component matrix</p>
</td></tr>
<tr><td><code id="nextdiff_+3A_withinblock">withinblock</code></td>
<td>
<p>logical indicating whether any given
difference-component should only involve variables belonging to the
same block-component.</p>
</td></tr>
<tr><td><code id="nextdiff_+3A_criterion">criterion</code></td>
<td>
<p>character string specifying the optimality criterion,
see <code><a href="#topic+sccrit">sccrit</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="#topic+firstpcres">firstpcres</a>(S,P)</code> and subsequently
<code><a href="#topic+shrinkdiff">shrinkdiff</a>()</code>, the latter in a loop when
<code>withinblock</code> is true.
</p>
<p>In order to ensure uniqueness, we ensure that the first (non zero)
entry of the principal component is always <em>positive</em>.
</p>


<h3>Value</h3>

<p>a list with components
</p>
<table role = "presentation">
<tr><td><code>P</code></td>
<td>
<p>the new component matrix, i.e. the input <code>P</code> with one
new column appended.</p>
</td></tr>
<tr><td><code>nextpc</code></td>
<td>
<p>the next principal component with many entries set to 0.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valentin Rousson <a href="mailto:rousson@ifspm.unizh.ch">rousson@ifspm.unizh.ch</a> and
Martin Maechler <a href="mailto:maechler@stat.math.ethz.ch">maechler@stat.math.ethz.ch</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+shrinkdiff">shrinkdiff</a></code>; <code><a href="#topic+sca">sca</a></code>, also for references</p>

<hr>
<h2 id='percent'>Simple Formatting of Percentages</h2><span id='topic+percent'></span>

<h3>Description</h3>

<p>Returns strings of the same length as <code>p</code>, displaying the
<code>100 * p</code> percentages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percent(p, d = 0, sep = " ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="percent_+3A_p">p</code></td>
<td>
<p>number(s) in <code class="reqn">[0,1]</code> &ndash; to be &ldquo;displayed&rdquo; as percentage(s).</p>
</td></tr>
<tr><td><code id="percent_+3A_d">d</code></td>
<td>
<p>number of digits after decimal point.</p>
</td></tr>
<tr><td><code id="percent_+3A_sep">sep</code></td>
<td>
<p>separator to use before the final <code>"%"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of the same length as <code>p</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>Examples</h3>

<pre><code class='language-R'>percent(0.25)
noquote(percent((1:10)/10))
(pc &lt;- percent((1:10)/30, 1, sep=""))
noquote(pc)
</code></pre>

<hr>
<h2 id='pitpropC'>Pitprops Strength Correlation Data</h2><span id='topic+pitpropC'></span>

<h3>Description</h3>

<p>This correlation matrix was published in Jeffers (1967) and was calculated
from 180 observations. The 13 variables were used as explanatory variables
in a regression problem which arised from a study on the strength of
pitprops cut from home-grown timber.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pitpropC)</code></pre>


<h3>Format</h3>

<p>Its a correlation matrix of 13 variables which have the following meaning:
</p>

<table>
<tr>
 <td style="text-align: right;">
    [,1] </td><td style="text-align: left;">  TOPDIAM </td><td style="text-align: left;">  Top diameter of the prop in inches</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,2] </td><td style="text-align: left;">  LENGTH  </td><td style="text-align: left;">  Length of the prop in inches</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,3] </td><td style="text-align: left;">  MOIST   </td><td style="text-align: left;">  Moisture content of the prop, expressed as a percentage of
    				the dry weight</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,4] </td><td style="text-align: left;">  TESTSG  </td><td style="text-align: left;">  Specific gravity of the timber at the time of the test</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,5] </td><td style="text-align: left;">  OVENSG  </td><td style="text-align: left;">  Oven-dry specific gravity of the timber</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,6] </td><td style="text-align: left;">  RINGTOP </td><td style="text-align: left;">  Number of annual rings at the top of the prop</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,7] </td><td style="text-align: left;">  RINGBUT </td><td style="text-align: left;">  Number of annual rings at the base of the prop</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,8] </td><td style="text-align: left;">  BOWMAX  </td><td style="text-align: left;">  Maximum bow in inches</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,9] </td><td style="text-align: left;">  BOWDIST </td><td style="text-align: left;">  Distance of the point of maximum bow from the top of the
				prop in inches</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,10]</td><td style="text-align: left;">  WHORLS  </td><td style="text-align: left;">  Number of knot whorls</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,11]</td><td style="text-align: left;">  CLEAR   </td><td style="text-align: left;">  Length of clear prop from the top of the prop in inches</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,12]</td><td style="text-align: left;">  KNOTS   </td><td style="text-align: left;">  Average number of knots per whorl</td>
</tr>
<tr>
 <td style="text-align: right;">
    [,13]</td><td style="text-align: left;">  DIAKNOT </td><td style="text-align: left;">  Average diameter of the knots in inches
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Jeffers (1967) replaced these 13 variables by their first six
principal components.  As noted by Vines (2000), this is an example
where simple structure has proven difficult to detect in the past.
</p>


<h3>References</h3>

<p>Jeffers, J.N.R. (1967)
Two case studies in the application of principal components analysis.
<em>Appl. Statist.</em> <b>16</b>, 225&ndash;236.
</p>
<p>Vines, S.K. (2000)
Simple principal components.
<em>Appl. Statist.</em> <b>49</b>, 441&ndash;451.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pitpropC)
symnum(pitpropC)
</code></pre>

<hr>
<h2 id='quickcrit'>Additional Contribution of New Component to the SC System</h2><span id='topic+quickcrit'></span>

<h3>Description</h3>

<p>Compute the additional contribution of a new component to the simple
component system P on S.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickcrit(newcomp, S, P, criterion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quickcrit_+3A_newcomp">newcomp</code></td>
<td>
<p>numeric vector, typically the result of
<code><a href="#topic+simpvector">simpvector</a>()</code>.</p>
</td></tr>
<tr><td><code id="quickcrit_+3A_s">S</code></td>
<td>
<p>correlation/covariance matrix</p>
</td></tr>
<tr><td><code id="quickcrit_+3A_p">P</code></td>
<td>
<p>component matrix</p>
</td></tr>
<tr><td><code id="quickcrit_+3A_criterion">criterion</code></td>
<td>
<p>character string specifying the optimality criterion,
see <code><a href="#topic+sccrit">sccrit</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sccrit">sccrit</a></code>; further <code><a href="#topic+sca">sca</a></code>, also for
references.</p>

<hr>
<h2 id='reflexesC'>Human Reflexes Correlation Data</h2><span id='topic+reflexesC'></span>

<h3>Description</h3>

<p>This correlation matrix was published in Jolliffe (2002, p.58).  The data
consist of measurements of strength of reflexes at ten sites of the body,
taken for 143 individuals. The variables come in five pairs, corresponding
to right and left measurements on triceps, biceps, wrists, knees and
ankles, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(reflexesC)</code></pre>


<h3>Format</h3>

<p>It is a <code class="reqn">10 x 10</code> correlation matrix, i.e. symmetric, and
diagonal <code>1</code>.
The five pairs of variables are (in this order)
<code>"triceps.R", "triceps.L", "biceps.R", "biceps.L",
    "wrist.R", "wrist.L", "knee.R", "knee.L",
    "ankle.R", "ankle.L"</code>.
</p>


<h3>References</h3>

<p>Jolliffe, I.T. (2002)
Principal Component Analysis (2nd ed.).
Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(reflexesC)
symnum(reflexesC)
sca(reflexesC)  # sca gets 97.95%  of PCA
</code></pre>

<hr>
<h2 id='sca'>Simple Component Analysis &ndash; Interactively</h2><span id='topic+sca'></span><span id='topic+print.simpcomp'></span>

<h3>Description</h3>

<p>A system of simple components calculated from a correlation (or
variance-covariance) matrix is built (interactively if <code>interactive =
    TRUE</code>) following the methodology of Rousson and Gasser (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sca(S, b = if(interactive) 5, d = 0, qmin = if(interactive) 0 else 5,
    corblocks = if(interactive) 0 else 0.3,
    criterion = c("csv", "blp"), cluster = c("median","single","complete"),
    withinblock = TRUE, invertsigns = FALSE,
    interactive = dev.interactive())
## S3 method for class 'simpcomp'
print(x, ndec = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sca_+3A_s">S</code></td>
<td>
<p>the correlation (or variance-covariance) matrix to be analyzed.</p>
</td></tr>
<tr><td><code id="sca_+3A_b">b</code></td>
<td>
<p>the number of block-components initially proposed.</p>
</td></tr>
<tr><td><code id="sca_+3A_d">d</code></td>
<td>
<p>the number of difference-components initially proposed.</p>
</td></tr>
<tr><td><code id="sca_+3A_qmin">qmin</code></td>
<td>
<p>if larger than zero, the number of difference-components
is chosen such that the system contains at least <code>qmin</code>
components (overriding argument <code>d</code>!).</p>
</td></tr>
<tr><td><code id="sca_+3A_corblocks">corblocks</code></td>
<td>
<p>if larger than zero, the number of block-components
is chosen such that correlations among them are all smaller than
<code>corblocks</code> (overriding argument <code>b</code>).</p>
</td></tr>
<tr><td><code id="sca_+3A_criterion">criterion</code></td>
<td>
<p>character string specifying the optimality criterion
to be used for evaluating a system of simple components.  One of
<code>"csv"</code> (corrected sum of variances) or <code>"blp"</code> (best
linear predictor); can be abbreviated.</p>
</td></tr>
<tr><td><code id="sca_+3A_cluster">cluster</code></td>
<td>
<p>character string specifying the clustering method to be
used in the definition of the block-components.  One of
<code>"single"</code> (single linkage), <code>"median"</code> (median linkage)
or <code>"complete"</code> (complete linkage) can be abbreviated.</p>
</td></tr>
<tr><td><code id="sca_+3A_withinblock">withinblock</code></td>
<td>
<p>a logical indicating whether any given
difference-component should only involve variables belonging to the
same block-component.</p>
</td></tr>
<tr><td><code id="sca_+3A_invertsigns">invertsigns</code></td>
<td>
<p>a logical indicating whether the sign of some
variables should be inverted initially in order to avoid negative
correlations.</p>
</td></tr>
<tr><td><code id="sca_+3A_interactive">interactive</code></td>
<td>
<p>a logical indicating whether the system of simple
components should be built interactively.  If <code>interactive=FALSE</code>, an
optimal system of simple components is automatically calculated
without any intervention of the user (according to <code>b</code> or
<code>corblocks</code>, and to <code>d</code> or <code>qmin</code>).
</p>
<p>By default, <code>interactive = <a href="grDevices.html#topic+dev.interactive">dev.interactive</a>()</code> (which is
true if <code><a href="base.html#topic+interactive">interactive</a>()</code> and <code><a href="base.html#topic+.Device">.Device</a></code> is an
interactive graphics device).</p>
</td></tr>
<tr><td><code id="sca_+3A_x">x</code></td>
<td>
<p>an object of class <code>sca</code>, typically the result of
<code><a href="#topic+sca">sca</a>(..)</code>.</p>
</td></tr>
<tr><td><code id="sca_+3A_ndec">ndec</code></td>
<td>
<p>number of decimals <em>after</em> the dot, for the
percentages printed.</p>
</td></tr>
<tr><td><code id="sca_+3A_...">...</code></td>
<td>
<p>further arguments, passed to and from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When confronted with a large number <code class="reqn">p</code> of variables measuring
different aspects of a same theme, the practitionner may like to
summarize the information into a limited number <code class="reqn">q</code> of components.  A
<em>component</em> is a linear combination of the original variables, and
the weights in this linear combination are called the <em>loadings</em>.
Thus, a system of components is defined by a <code class="reqn">p</code> times <code class="reqn">q</code> dimensional
matrix of loadings.
</p>
<p>Among all systems of components, principal components (PCs) are
optimal in many ways.  In particular, the first few PCs extract a
maximum of the variability of the original variables and they are
uncorrelated, such that the extracted information is organized in an
optimal way: we may look at one PC after the other, separately,
without taking into account the rest.
</p>
<p>Unfortunately PCs are often difficult to interpret. The goal of Simple
Component Analysis is to replace (or to supplement) the optimal but
non-interpretable PCs by suboptimal but interpretable <em>simple
components</em>. The proposal of Rousson and Gasser (2003) is to look for
an optimal system of components, but only among the simple ones,
according to some definition of optimality and simplicity. The outcome
of their method is a simple matrix of loadings calculated from the
correlation matrix <code class="reqn">S</code> of the original variables.
</p>
<p>Simplicity is not a guarantee for interpretability (but it helps in
this regard).  Thus, the user may wish to partly modify an optimal
system of simple components in order to enhance
interpretability.  While PCs are by definition 100% optimal, the
optimal system of simple components proposed by the procedure <code>sca</code>
may be, say, 95%, optimal, whereas the simple system altered by the
user may be, say, 93% optimal. It is ultimately to the user to decide
if the gain in interpretability is worth the loss of optimality.
</p>
<p>The interactive procedure <code>sca</code> is intended to assist the user in
his/her choice for an interptetable system of simple components. The
algorithm consists of three distinct stages and proceeds in an
interative way. At each step of the procedure, a simple matrix of
loadings is displayed in a window. The user may alter this matrix by
clicking on its entries, following the instructions given there.  If
all the loadings of a component share the same sign, it is a
&ldquo;block-component&rdquo;.  If some loadings are positive and some loadings
are negative, it is a &ldquo;difference-component&rdquo;.  Block-components are
arguably easier to interpret than
difference-components. Unfortunately, PCs almost always contain only
one block-component. In the procedure <code>sca</code>, the user may choose the
number of block-components in the system, the rationale being to have
as many block-components such that correlations among them are below
some cut-off value (typically .3 or .4).
</p>
<p>Simple block-components should define a partition of the original
variables. This is done in the first stage of the procedure <code>sca</code>. An
agglomerative hierarchical clustering procedure is used there.
</p>
<p>The second stage of the procedure <code>sca</code> consists in the definition of
simple difference-components.  Those are obtained as simplified
versions of some appropriate &ldquo;residual components&rdquo;. The idea is to
retain the large loadings (in absolute value) of these residual
components and to shrink to zero the small ones. For each
difference-component, the interactive procedure <code>sca</code> displays the
loadings of the corresponding residual component (at the right side of
the window), such that the user may know which variables are
especially important for the definition of this component.
</p>
<p>At the third stage of the interactive procedure <code>sca</code>, it is possible
to remove some of the difference-components from the system.
</p>
<p>For many examples, it is possible to find a simple system which is 90%
or 95% optimal, and where correlations between components are below 0.3
or 0.4. When the structure in the correlation matrix is complicated, it
might be advantageous to invert the sign of some of the variables in
order to avoid as much as possible negative correlations. This can be
done using the option &lsquo;invertsigns=TRUE&rsquo;.
</p>
<p>In principle, simple components can be calculated from a correlation
matrix or from a variance-covariance matrix. However, the definition
of simplicity used is not well adapted to the latter case, such that
it will result in systems which are far from being 100%
optimal. Thus, it is advised to define simple components from a
correlation matrix, not from a variance-covariance matrix.
</p>


<h3>Value</h3>

<p>An object of class <code>simpcomp</code> which is basically as list with
the following components:
</p>
<table role = "presentation">
<tr><td><code>simplemat</code></td>
<td>
<p>an integer matrix defining a system of simple
components.  The rows correspond to variables and the columns correspond to
components.</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>loadings of simple components.  This is a
version of <code>simplemat</code>, normalized by a version of
<code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
<tr><td><code>allcrit</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> containing the following components:
</p>

<dl>
<dt>varpc</dt><dd><p>a vector containing the percentage of total
variability accounted by each of the the first <code>nblock + ndiff</code>
principal components of <code>S</code>.</p>
</dd>
<dt>varsc</dt><dd><p>a vector containing the percentage of total
variability accounted by each of the simple components defined by
<code>simplemat</code>.</p>
</dd>
<dt>cumpc</dt><dd><p>the sum of varpc, indicating the percentage of total
variability accounted by the first <code>nblock + ndiff</code> principal
components of <code>S</code>.</p>
</dd>
<dt>cumsc</dt><dd><p>a score indicating the percentage of total
variability accounted by the system of simple
components. <code>cumsc</code> is calculated according to <code>criterion</code>.</p>
</dd>
<dt>opt</dt><dd><p>indicates the optimality of the system of simple
components and is computed as <code>cumsc/cumpc</code>.</p>
</dd>
<dt>corsc</dt><dd><p>correlation matrix of the simple components defined
by <code>simplemat</code>.</p>
</dd>
<dt>maxcor</dt><dd><p>a list with the following components:
</p>

<dl>
<dt>row</dt><dd><p>label of the row of the maximum value in <code>corsc</code>.</p>
</dd>
<dt>col</dt><dd><p>label of the column of the maximum value in <code>corsc</code>.</p>
</dd>
<dt>val</dt><dd><p>maximum value in <code>corsc</code> (in absolute value).</p>
</dd>
</dl>

</dd>
</dl>
</td></tr>
<tr><td><code>nblock</code></td>
<td>
<p>number of block-components in <code>simplemat</code>.</p>
</td></tr>
<tr><td><code>ndiff</code></td>
<td>
<p>number of difference-components in <code>simplemat</code>.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>as above.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>as above.</p>
</td></tr>
<tr><td><code>withinblock</code></td>
<td>
<p>as above.</p>
</td></tr>
<tr><td><code>invertsigns</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code>vardata</code></td>
<td>
<p>the correlation (or variance-covariance) matrix which
was analyzed. In principle it should be equal to argument <code>S</code> above,
except if it has been transformed in order to avoid negative
correlations.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>PCA already is known to be &ldquo;non-unique&rdquo; in the sense that the
principal directions (eigen vectors, <code><a href="base.html#topic+eigen">eigen</a></code>) are only
determined up to a factor <code class="reqn">\pm 1</code>, i.e., sign change.
</p>
<p>Consequently results may change depending e.g., only on the Lapack / BLAS
library used.


This is even more the case for SCA, notably in artificial situations
such as the &lsquo;<span class="file">tests/artif3.R</span>&rsquo; in the sources of <a href="https://CRAN.R-project.org/package=sca"><span class="pkg">sca</span></a>.
</p>


<h3>Author(s)</h3>

<p>Valentin Rousson <a href="mailto:rousson@ifspm.unizh.ch">rousson@ifspm.unizh.ch</a> and
Martin Maechler <a href="mailto:maechler@stat.math.ethz.ch">maechler@stat.math.ethz.ch</a>.</p>


<h3>References</h3>

<p>Rousson, Valentin and Gasser, Theo (2004)
Simple Component Analysis.
<em>JRSS: Series C (Applied Statistics)</em> <b>53</b>(4), 539&ndash;555;
<a href="https://doi.org/10.1111/j.1467-9876.2004.05359.x">doi:10.1111/j.1467-9876.2004.05359.x</a>
</p>
<p>Rousson, V. and Gasser, Th. (2003)
<em>Some Case Studies of Simple Component Analysis</em>.
Manuscript, <em>no longer</em> available as
&lsquo;<span class="file">https://www.biostat.uzh.ch/research/manuscripts/scacases.pdf</span>&rsquo;
</p>
<p>Gervini, D. and Rousson, V. (2003)
<em>Some Proposals for Evaluating Systems of Components in Dimension
Reduction Problems</em>.
Submitted.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+prcomp">prcomp</a></code> (for PCA), etc.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pitpropC)
sc.pitp &lt;- sca(pitpropC, interactive=FALSE)
sc.pitp
## to see it's low-level components:
str(sc.pitp)

## Let `X' be a matrix containing some data set whose rows correspond to
## subjects and whose columns correspond to variables. For example:

library(MASS)
SigU &lt;- function(p, rho) { r &lt;- diag(p); r[col(r) != row(r)] &lt;- rho; r}
rmvN &lt;- function(n,p, rho)
        mvrnorm(n, mu=rep(0,p), Sigma = SigU(p, rho))
X &lt;- cbind(rmvN(100, 3, 0.7),
           rmvN(100, 2, 0.9),
           rmvN(100, 4, 0.8))

## An optimal simple system with at least 5 components for the data in `X',
## where the number of block-components is such that correlations among
## them are all smaller than 0.4, can be automatically obtained as:

(r &lt;- sca(cor(X), qmin=5, corblocks=0.4, interactive=FALSE))

## On the other hand, an optimal simple system with two block-components
## and two difference-components for the data in `X' can be automatically
## obtained as:

(r &lt;- sca(cor(X), b=2, d=2, qmin=0, corblocks=0, interactive=FALSE))

## The resulting simple matrix is contained in `r$simplemat'.
## A matrix of scores for such simple components can then be obtained as:

(Z &lt;- scale(X) %*% r$loadings)

## On the other hand, scores of simple components calculated from the
## variance-covariance matrix of `X' can be obtained as:

r &lt;- sca(var(X), b=2, d=2, qmin=0, corblocks=0, interactive=FALSE)
Z &lt;- scale(X, scale=FALSE) %*% r$loadings

## One can also use the program interactively as follows:

if(interactive()) {
  r &lt;- sca(cor(X), corblocks=0.4, qmin=5, interactive = TRUE)

  ## Since the interactive part of the program is active here, the proposed
  ## system can then be  modified according to the user's wishes. The
  ## result of the procedure will be contained in `r'.
}

</code></pre>

<hr>
<h2 id='shrinkdiff'>Shrink Component Towards a Simple Difference-Component in SCA</h2><span id='topic+shrinkdiff'></span>

<h3>Description</h3>

<p>Shrinks a (principal) component towards a simple difference-component
in <code><a href="#topic+sca">sca</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrinkdiff(zcomp, S, P, criterion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shrinkdiff_+3A_zcomp">zcomp</code></td>
<td>
<p>a component vector to be <em>simplified</em>.</p>
</td></tr>
<tr><td><code id="shrinkdiff_+3A_s">S</code></td>
<td>
<p>correlation/covariance matrix</p>
</td></tr>
<tr><td><code id="shrinkdiff_+3A_p">P</code></td>
<td>
<p>component matrix</p>
</td></tr>
<tr><td><code id="shrinkdiff_+3A_criterion">criterion</code></td>
<td>
<p>character string specifying the optimality criterion,
see <code><a href="#topic+sccrit">sccrit</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the components
</p>
<table role = "presentation">
<tr><td><code>scompmax</code></td>
<td>
<p>a new simple component vector, typically result of
<code><a href="#topic+simpvector">simpvector</a></code>.</p>
</td></tr>
<tr><td><code>critmax</code></td>
<td>
<p>the (optimal) value of the criterion, achieved for
<code>scompmax</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sca">sca</a></code>, also for references</p>

<hr>
<h2 id='simpvector'>Simplify a (Principal Component) Vector to a Simple Component</h2><span id='topic+simpvector'></span>

<h3>Description</h3>

<p>Simplifies the vector <code>x</code> to become a &ldquo;simple&rdquo; component vector
(of the same size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpvector(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simpvector_+3A_x">x</code></td>
<td>
<p>numeric vector of length <code>n</code>, say.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &ldquo;simplified&rdquo; version of <code>x</code>, i.e. an integer vector of the
same length and each entry with the same signs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sca">sca</a></code>, also for references</p>


<h3>Examples</h3>

<pre><code class='language-R'> x0 &lt;- c(-2:3, 3:-1,0:3,1,1)
 cbind(x0, simpvector(x0)) # entries (-11, 0, 3)
</code></pre>

<hr>
<h2 id='sortmatrix'>Sort Simple Component Matrix</h2><span id='topic+sortmatrix'></span>

<h3>Description</h3>

<p>Reorder the columns of a component matrix <code>P</code> by decreasing
variances of components where the block-components come first, the
difference components afterwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortmatrix(S, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sortmatrix_+3A_s">S</code></td>
<td>
<p>correlation/covariance matrix</p>
</td></tr>
<tr><td><code id="sortmatrix_+3A_p">P</code></td>
<td>
<p>component matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix which is just <code>P</code> with columns reordered.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sca">sca</a></code>, also for references</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
