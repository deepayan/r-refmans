<!DOCTYPE html><html lang="en-US"><head><title>Help for package raptr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {raptr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#raptr'><p>raptr: Representative and Adequate Prioritization Toolkit in R</p></a></li>
<li><a href='#amount.held'><p>Extract amount held for a solution</p></a></li>
<li><a href='#amount.target'><p>Amount targets</p></a></li>
<li><a href='#as.list'><p>Convert object to list</p></a></li>
<li><a href='#AttributeSpace'><p>Create new AttributeSpace object</p></a></li>
<li><a href='#AttributeSpace-class'><p>AttributeSpace: An S4 class to represent an attribute space.</p></a></li>
<li><a href='#AttributeSpaces'><p>Create new AttributeSpaces object</p></a></li>
<li><a href='#AttributeSpaces-class'><p>AttributeSpaces: An S4 class to represent a collection of attribute spaces</p>
for different species.</a></li>
<li><a href='#basemap'><p>Basemap</p></a></li>
<li><a href='#blank.raster'><p>Blank raster</p></a></li>
<li><a href='#cache'><p>Get and set cache methods</p></a></li>
<li><a href='#calcBoundaryData'><p>Calculate boundary data for planning units</p></a></li>
<li><a href='#calcSpeciesAverageInPus'><p>Calculate average value for species data in planning units</p></a></li>
<li><a href='#casestudy_data'><p>Case-study dataset for a conservation planning exercise</p></a></li>
<li><a href='#convert2PolySet'><p>Convert object to PolySet data</p></a></li>
<li><a href='#DemandPoints'><p>Create new DemandPoints object</p></a></li>
<li><a href='#DemandPoints-class'><p>DemandPoints: An S4 class to represent demand points</p></a></li>
<li><a href='#dp.subset'><p>Subset demand points</p></a></li>
<li><a href='#GurobiOpts'><p>Create GurobiOpts object</p></a></li>
<li><a href='#GurobiOpts-class'><p>GurobiOpts: An S4 class to represent Gurobi parameters</p></a></li>
<li><a href='#is.cached'><p>Test if hash is cached in a Rap object</p></a></li>
<li><a href='#is.comparable'><p>Compare Rap objects</p></a></li>
<li><a href='#is.GurobiInstalled'><p>Test if Gurobi is installed</p></a></li>
<li><a href='#logging.file'><p>Log file</p></a></li>
<li><a href='#make.DemandPoints'><p>Generate demand points for RAP</p></a></li>
<li><a href='#make.RapData'><p>Make data for RAP using minimal inputs</p></a></li>
<li><a href='#ManualOpts'><p>Create ManualOpts object</p></a></li>
<li><a href='#ManualOpts-class'><p>ManualOpts: An S4 class to represent parameters for manually specified</p>
solutions</a></li>
<li><a href='#maximum.targets'><p>Maximum targets</p></a></li>
<li><a href='#names'><p>Names</p></a></li>
<li><a href='#PlanningUnitPoints'><p>Create new PlanningUnitPoints object</p></a></li>
<li><a href='#PlanningUnitPoints-class'><p>PlanningUnitPoints: An S4 class to represent planning units in an attribute</p>
space</a></li>
<li><a href='#plot'><p>Plot object</p></a></li>
<li><a href='#PolySet-class'><p>PolySet</p></a></li>
<li><a href='#print'><p>Print objects</p></a></li>
<li><a href='#prob.subset'><p>Subset probabilities above a threshold</p></a></li>
<li><a href='#pu.subset'><p>Subset planning units</p></a></li>
<li><a href='#randomPoints'><p>Sample random points from a SpatRaster</p></a></li>
<li><a href='#rap'><p>Generate prioritizations using RAP</p></a></li>
<li><a href='#RapData'><p>Create new RapData object</p></a></li>
<li><a href='#RapData-class'><p>RapData: An S4 class to represent RAP input data</p></a></li>
<li><a href='#RapOpts-class'><p>RapOpts class</p></a></li>
<li><a href='#RapReliableOpts'><p>Create RapReliableOpts object</p></a></li>
<li><a href='#RapReliableOpts-class'><p>RapReliableOpts: An S4 class to represent input parameters for the reliable</p>
formulation of RAP.</a></li>
<li><a href='#RapResults'><p>Create RapResults object</p></a></li>
<li><a href='#RapResults-class'><p>RapResults: An S4 class to represent RAP results</p></a></li>
<li><a href='#RapSolved'><p>Create new RapSolved object</p></a></li>
<li><a href='#RapSolved-class'><p>RapSolved: An S4 class to represent RAP inputs and outputs</p></a></li>
<li><a href='#raptr-deprecated'><p>Deprecation notice</p></a></li>
<li><a href='#RapUnreliableOpts'><p>Create RapUnreliableOpts object</p></a></li>
<li><a href='#RapUnreliableOpts-class'><p>RapUnreliableOpts: An S4 class to represent parameters for the unreliable</p>
RAP problem</a></li>
<li><a href='#RapUnsolved'><p>Create a new RapUnsolved object</p></a></li>
<li><a href='#RapUnsolved-class'><p>RapUnsolved: An S4 class to represent RAP inputs</p></a></li>
<li><a href='#read.RapResults'><p>Read RAP results</p></a></li>
<li><a href='#rrap.proportion.held'><p>Proportion held using reliable RAP formulation.</p></a></li>
<li><a href='#score'><p>Solution score</p></a></li>
<li><a href='#selections'><p>Extract solution selections</p></a></li>
<li><a href='#show'><p>Show objects</p></a></li>
<li><a href='#sim.pus'><p>Simulate planning units</p></a></li>
<li><a href='#sim.space'><p>Simulate attribute space data for RAP</p></a></li>
<li><a href='#sim.species'><p>Simulate species distribution data for RAP</p></a></li>
<li><a href='#simulated_data'><p>Simulated dataset for a conservation planning exercise</p></a></li>
<li><a href='#solve'><p>Solve RAP object</p></a></li>
<li><a href='#SolverOpts-class'><p>SolverOpts class</p></a></li>
<li><a href='#space.held'><p>Extract attribute space held for a solution</p></a></li>
<li><a href='#space.plot'><p>Plot space</p></a></li>
<li><a href='#space.target'><p>Attribute space targets</p></a></li>
<li><a href='#spp.plot'><p>Plot species</p></a></li>
<li><a href='#spp.subset'><p>Subset species</p></a></li>
<li><a href='#summary'><p>Summary of solutions</p></a></li>
<li><a href='#update'><p>Update object</p></a></li>
<li><a href='#urap.proportion.held'><p>Proportion held using unreliable RAP formulation.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Representative and Adequate Prioritization Toolkit in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Biodiversity is in crisis. The overarching aim of conservation
    is to preserve biodiversity patterns and processes. To this end, protected
    areas are established to buffer species and preserve biodiversity processes.
    But resources are limited and so protected areas must be cost-effective.
    This package contains tools to generate plans for protected areas
    (prioritizations), using spatially explicit targets for biodiversity
    patterns and processes. To obtain solutions in a feasible amount  of time,
    this package uses the commercial 'Gurobi' software (obtained from
    <a href="https://www.gurobi.com/">https://www.gurobi.com/</a>). For more information on using
    this package, see Hanson et al. (2018) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12862">doi:10.1111/2041-210X.12862</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, methods, stats, graphics, grDevices, sp (&ge; 1.4.6),
Matrix (&ge; 1.4.1), assertthat (&ge; 0.2.1), boot (&ge; 1.3.28),
PBSmapping (&ge; 2.73.0), scales (&ge; 1.2.0), shape (&ge; 1.4.6),
adehabitatHR (&ge; 0.4.19), RColorBrewer (&ge; 1.1.3), ggplot2 (&ge;
3.4.0), hypervolume (&ge; 2.0.7), ks (&ge; 1.13.5), mvtnorm (&ge;
1.1.3), withr (&ge; 2.5.0),</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), sf (&ge; 1.0.9), terra (&ge; 1.6.47)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, roxygen2, rmarkdown, testthat, RgoogleMaps (&ge;
1.4.5.3), dplyr (&ge; 1.0.8), vegan (&ge; 2.6.2), gurobi (&ge;
8.0.0), gridExtra (&ge; 2.3), rgl (&ge; 1.0.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, BH</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jeffrey-hanson.com/raptr/">https://jeffrey-hanson.com/raptr/</a>,
<a href="https://github.com/jeffreyhanson/raptr">https://github.com/jeffreyhanson/raptr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jeffreyhanson/raptr/issues">https://github.com/jeffreyhanson/raptr/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'raptr-internal.R' 'generics.R'
'DemandPoints.R' 'misc.R' 'PlanningUnitPoints.R'
'AttributeSpace.R' 'AttributeSpaces.R' 'GurobiOpts.R'
'ManualOpts.R' 'calcSpeciesAverageInPus.R' 'calcBoundaryData.R'
'RapData.R' 'RapReliableOpts.R' 'RapResults.R'
'RapUnreliableOpts.R' 'RapUnsolved.R' 'RapSolved.R'
'convert2PolySet.R' 'data.R' 'deprecated.R' 'package.R' 'rap.R'
'rrap.proportion.held.R' 'sim.pus.R' 'sim.space.R'
'sim.species.R' 'urap.proportion.held.R' 'zzz.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-27 20:24:35 UTC; jeff</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey O Hanson [aut, cre],
  Jonathan R Rhodes [aut],
  Hugh P Possingham [aut],
  Richard A Fuller [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeffrey O Hanson &lt;jeffrey.hanson@uqconnect.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-28 11:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='raptr'>raptr: Representative and Adequate Prioritization Toolkit in R</h2><span id='topic+raptr'></span><span id='topic+raptr-package'></span>

<h3>Description</h3>

<p>Biodiversity is in crisis. The overarching aim of conservation is to preserve
biodiversity patterns and processes. To this end, protected areas are
established to buffer species and preserve biodiversity processes. But
resources are limited and so protected areas must be cost-effective. This
package contains tools to generate plans for protected areas
(prioritizations). Conservation planning data are used to construct an
optimization problem, which is then solved to yield prioritizations. To
solve the optimization problems in a feasible amount of time, this package
uses the commercial 'Gurobi' software package (obtained from
<a href="https://www.gurobi.com/">https://www.gurobi.com/</a>). For more information on using
this package, see Hanson et al. (2018).
</p>


<h3>Details</h3>

<p>The main classes used in this package are used to store input data and
prioritizations:
</p>

<dl>
<dt><a href="#topic+GurobiOpts-class">GurobiOpts</a></dt><dd><p>parameters for solving optimization
problems using Gurobi.</p>
</dd>
<dt><a href="#topic+RapReliableOpts-class">RapReliableOpts</a></dt><dd><p>parameters for the reliable
formulation of RAP.</p>
</dd>
<dt><a href="#topic+RapUnreliableOpts-class">RapUnreliableOpts</a></dt><dd><p>parameters for the unreliable
formulation of RAP.</p>
</dd>
<dt><a href="#topic+RapData-class">RapData</a></dt><dd><p>planning unit, species data, and demand
points for RAP.</p>
</dd>
<dt><a href="#topic+RapUnsolved-class">RapUnsolved</a></dt><dd><p>contains all the data and input
parameters required to generate prioritizations using RAP. This class
contains a <a href="#topic+GurobiOpts-class">GurobiOpts</a> object, a
<a href="#topic+RapReliableOpts-class">RapReliableOpts</a> or <a href="#topic+RapUnreliableOpts-class">RapUnreliableOpts</a>
object, and a <a href="#topic+RapData-class">RapData</a> object.</p>
</dd>
<dt><a href="#topic+RapResults-class">RapResults</a></dt><dd><p>prioritizations and summary
statistics on their performance.</p>
</dd>
<dt><a href="#topic+RapSolved-class">RapSolved</a></dt><dd><p>contains all the input data,
parameters and output data. This class contains all the objects in a
<code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> object and also a <a href="#topic+RapResults-class">RapResults</a>
object.</p>
</dd>
</dl>

<p>Type <code>vignette("raptr")</code> for a tutorial on how to use this package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jeffrey O Hanson <a href="mailto:jeffrey.hanson@uqconnect.edu.au">jeffrey.hanson@uqconnect.edu.au</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jonathan R Rhodes
</p>
</li>
<li><p> Hugh P Possingham
</p>
</li>
<li><p> Richard A Fuller
</p>
</li></ul>



<h3>References</h3>

<p>Hanson JO, Rhodes JR, Possingham HP &amp; Fuller RA (2018)
raptr: Representative and Adequate Prioritization&quot;,
Toolkit in R. <em>Methods in Ecology &amp; Evolution</em>,&quot;,
<strong>9</strong>: 320&ndash;330. DOI: 10.1111/2041-210X.12862.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jeffrey-hanson.com/raptr/">https://jeffrey-hanson.com/raptr/</a>
</p>
</li>
<li> <p><a href="https://github.com/jeffreyhanson/raptr">https://github.com/jeffreyhanson/raptr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jeffreyhanson/raptr/issues">https://github.com/jeffreyhanson/raptr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='amount.held'>Extract amount held for a solution</h2><span id='topic+amount.held'></span><span id='topic+amount.held.RapSolved'></span>

<h3>Description</h3>

<p>This function returns the amount held for each species in a solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amount.held(x, y, species)

## S3 method for class 'RapSolved'
amount.held(x, y = 0, species = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amount.held_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapResults">RapResults()</a></code> or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="amount.held_+3A_y">y</code></td>
<td>
<p>Available inputs include: <code>NULL</code> to return all values,
<code>integer</code> number specifying the solution for which the value should
be returned, and <code>0</code> to return the value for the best solution.</p>
</td></tr>
<tr><td><code id="amount.held_+3A_species">species</code></td>
<td>
<p><code>NULL</code> for all species or <code>integer</code> indicating
species.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> or <code>numeric</code> vector depending on
arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapResults">RapResults()</a></code>, <code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_rs)

# amount held (%) in best solution for each species
amount.held(sim_rs, 0)

# amount held (%) in best solution for species 1
amount.held(sim_rs, 0, 1)

# amount held (%) in second solution for each species
amount.held(sim_rs, 2)

# amount held (%) in each solution for each species
amount.held(sim_rs, NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='amount.target'>Amount targets</h2><span id='topic+amount.target'></span><span id='topic+amount.target+3C-'></span><span id='topic+amount.target.RapData'></span><span id='topic+amount.target+3C-.RapData'></span><span id='topic+amount.target.RapUnsolOrSol'></span><span id='topic+amount.target+3C-.RapUnsolOrSol'></span>

<h3>Description</h3>

<p>This function sets or returns the target amounts for each species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amount.target(x, species)

amount.target(x, species) &lt;- value

## S3 method for class 'RapData'
amount.target(x, species = NULL)

## S3 replacement method for class 'RapData'
amount.target(x, species = NULL) &lt;- value

## S3 method for class 'RapUnsolOrSol'
amount.target(x, species = NULL)

## S3 replacement method for class 'RapUnsolOrSol'
amount.target(x, species = NULL) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amount.target_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="amount.target_+3A_species">species</code></td>
<td>
<p><code>NULL</code> for all species or <code>integer</code> indicating
species.</p>
</td></tr>
<tr><td><code id="amount.target_+3A_value">value</code></td>
<td>
<p><code>numeric</code> new target.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapResults">RapResults()</a></code>,
<code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_rs)

# extract amount targets for all species
amount.target(sim_rs)

# set amount targets for all species
amount.target(sim_rs) &lt;- 0.1

# extract amount targets for first species
amount.target(sim_rs, 1)

# set amount targets for for first species
amount.target(sim_rs, 1) &lt;- 0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='as.list'>Convert object to list</h2><span id='topic+as.list'></span><span id='topic+as.list.GurobiOpts'></span>

<h3>Description</h3>

<p>Convert <code><a href="#topic+GurobiOpts">GurobiOpts()</a></code> object to list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GurobiOpts'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.list_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+GurobiOpts">GurobiOpts()</a></code> object.</p>
</td></tr>
<tr><td><code id="as.list_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code>
</p>


<h3>Note</h3>

<p>This function will not include the <code>NumberSolutions</code> slot, the
<code>MultipleSolutionsMethod</code> slot, or the <code>TimeLimit</code> slot if it is
not finite.
</p>


<h3>See Also</h3>

<p><code>GurobiOpts</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# make GuboriOpts object
x &lt;- GurobiOpts()

# convert to list
as.list(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='AttributeSpace'>Create new AttributeSpace object</h2><span id='topic+AttributeSpace'></span>

<h3>Description</h3>

<p>This function creates a new <code>AttributeSpace</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AttributeSpace(planning.unit.points, demand.points, species)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AttributeSpace_+3A_planning.unit.points">planning.unit.points</code></td>
<td>
<p><code><a href="#topic+PlanningUnitPoints">PlanningUnitPoints()</a></code> for planning
unit in the space.</p>
</td></tr>
<tr><td><code id="AttributeSpace_+3A_demand.points">demand.points</code></td>
<td>
<p><code><a href="#topic+DemandPoints">DemandPoints()</a></code> object for the space.</p>
</td></tr>
<tr><td><code id="AttributeSpace_+3A_species">species</code></td>
<td>
<p><code>integer</code> species identifier to indicate which species the
space is associated with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>AttributeSpace</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+DemandPoints-class">DemandPoints</a>, <a href="#topic+PlanningUnitPoints-class">PlanningUnitPoints</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
space &lt;- AttributeSpace(
 PlanningUnitPoints(
   matrix(rnorm(100), ncol = 2),
   seq_len(50)
 ),
 DemandPoints(
   matrix(rnorm(100), ncol = 2),
   runif(50)
  ),
 species = 1L
)

## End(Not run)
</code></pre>

<hr>
<h2 id='AttributeSpace-class'>AttributeSpace: An S4 class to represent an attribute space.</h2><span id='topic+AttributeSpace-class'></span>

<h3>Description</h3>

<p>This class is used to store planning unit points and demand points for a
single species in an attribute space.
</p>


<h3>Slots</h3>


<dl>
<dt><code>planning.unit.points</code></dt><dd><p><code><a href="#topic+PlanningUnitPoints">PlanningUnitPoints()</a></code> object for planning
unit in the space.</p>
</dd>
<dt><code>demand.points</code></dt><dd><p><code><a href="#topic+DemandPoints">DemandPoints()</a></code> object for the space.</p>
</dd>
<dt><code>species</code></dt><dd><p><code>integer</code> species id to indicate which species the space
is associated with.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+DemandPoints-class">DemandPoints</a>,
<a href="#topic+PlanningUnitPoints-class">PlanningUnitPoints</a>.
</p>

<hr>
<h2 id='AttributeSpaces'>Create new AttributeSpaces object</h2><span id='topic+AttributeSpaces'></span>

<h3>Description</h3>

<p>This function creates a new <code>AttributeSpaces</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AttributeSpaces(spaces, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AttributeSpaces_+3A_spaces">spaces</code></td>
<td>
<p><code>list</code> of <code><a href="#topic+AttributeSpace">AttributeSpace()</a></code> objects for
different species.</p>
</td></tr>
<tr><td><code id="AttributeSpaces_+3A_name">name</code></td>
<td>
<p><code>character</code> name to identify the attribute space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>AttributeSpaces</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+AttributeSpace-class">AttributeSpace</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
space1 &lt;- AttributeSpace(
  PlanningUnitPoints(
    matrix(rnorm(100), ncol = 2),
    seq_len(50)
  ),
  DemandPoints(
    matrix(rnorm(100), ncol = 2),
    runif(50)
  ),
  species = 1L
)

space2 &lt;- AttributeSpace(
  PlanningUnitPoints(
    matrix(rnorm(100), ncol = 2),
    seq_len(50)
  ),
  DemandPoints(
    matrix(rnorm(100), ncol = 2),
    runif(50)
  ),
  species = 2L
)

spaces &lt;- AttributeSpaces(list(space1, space2), "spaces")

## End(Not run)
</code></pre>

<hr>
<h2 id='AttributeSpaces-class'>AttributeSpaces: An S4 class to represent a collection of attribute spaces
for different species.</h2><span id='topic+AttributeSpaces-class'></span>

<h3>Description</h3>

<p>This class is used to store a collection of attribute spaces for different
species.
</p>


<h3>Slots</h3>


<dl>
<dt><code>spaces</code></dt><dd><p><code>list</code> of <code><a href="#topic+AttributeSpace">AttributeSpace()</a></code> objects for
different species.</p>
</dd>
<dt><code>name</code></dt><dd><p><code>character</code> name to identify the attribute space.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+AttributeSpace-class">AttributeSpace</a>.
</p>

<hr>
<h2 id='basemap'>Basemap</h2><span id='topic+basemap'></span><span id='topic+basemap.RapData'></span><span id='topic+basemap.RapSolved'></span>

<h3>Description</h3>

<p>This function retrieves google map data for planning units. The google map
data is cached to provide fast plotting capabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basemap(x, basemap = "hybrid", grayscale = FALSE, force.reset = FALSE)

## S3 method for class 'RapData'
basemap(x, basemap = "hybrid", grayscale = FALSE, force.reset = FALSE)

## S3 method for class 'RapSolved'
basemap(x, basemap = "none", grayscale = FALSE, force.reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basemap_+3A_x">x</code></td>
<td>
<p><code>RapData</code>, <code>RapUnsolved</code>, <code>RapSolved</code> object.</p>
</td></tr>
<tr><td><code id="basemap_+3A_basemap">basemap</code></td>
<td>
<p><code>character</code> type of base map to display. Valid names are
<code>"roadmap"</code>, <code>"mobile"</code>, <code>"satellite"</code>, <code>"terrain"</code>,
<code>"hybrid"</code>, <code>"mapmaker-roadmap"</code>, <code>"mapmaker-hybrid"</code>.</p>
</td></tr>
<tr><td><code id="basemap_+3A_grayscale">grayscale</code></td>
<td>
<p><code>logical</code> should base map be gray scale?</p>
</td></tr>
<tr><td><code id="basemap_+3A_force.reset">force.reset</code></td>
<td>
<p><code>logical</code> ignore data in cache? Setting this as
ignore will make function slower but may avoid bugs in cache system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> with google map data.
</p>


<h3>See Also</h3>

<p><code>RgoogleMaps::GetMap.bbox()</code>, <code><a href="#topic+plot">plot()</a></code>.
</p>

<hr>
<h2 id='blank.raster'>Blank raster</h2><span id='topic+blank.raster'></span>

<h3>Description</h3>

<p>This functions creates a blank <code>SpatRaster</code> based on the spatial extent of a
<code>sf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blank.raster(x, res)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blank.raster_+3A_x">x</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf::st_sf()</a></code> object.</p>
</td></tr>
<tr><td><code id="blank.raster_+3A_res">res</code></td>
<td>
<p><code>numeric</code> <code>vector</code> specifying resolution of the output raster
in the x and y dimensions. If <code>vector</code> is of length one, then the
pixels are assumed to be square.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# make sf data
polys &lt;- sim.pus(225L)

# make raster from sf
blank.raster(polys, 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='cache'>Get and set cache methods</h2><span id='topic+cache'></span><span id='topic+cache+2CRapData+2Ccharacter+2CANY-method'></span><span id='topic+cache+2CRapData+2Ccharacter+2Cmissing-method'></span><span id='topic+cache+2CRapResults+2Ccharacter+2CANY-method'></span><span id='topic+cache+2CRapResults+2Ccharacter+2Cmissing-method'></span>

<h3>Description</h3>

<p>Getter and setter methods for caches in RapData and RapResults object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache(x, name, y)

## S4 method for signature 'RapData,character,ANY'
cache(x, name, y)

## S4 method for signature 'RapData,character,missing'
cache(x, name, y)

## S4 method for signature 'RapResults,character,ANY'
cache(x, name, y)

## S4 method for signature 'RapResults,character,missing'
cache(x, name, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cache_+3A_x">x</code></td>
<td>
<p><code>RapData</code> or <code>RapResults</code> object</p>
</td></tr>
<tr><td><code id="cache_+3A_name">name</code></td>
<td>
<p><code>character</code> hash.</p>
</td></tr>
<tr><td><code id="cache_+3A_y">y</code></td>
<td>
<p>if <code>ANY</code> this object gets cached with name, else if
<code>missing</code> the object hashed at name gets returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ANY</code> or <code>NULL</code> depends on <code>y</code> argument.
</p>


<h3>Note</h3>

<p>caches are implemented using environments, the hash is used as the
name of the object in the environment.
</p>

<hr>
<h2 id='calcBoundaryData'>Calculate boundary data for planning units</h2><span id='topic+calcBoundaryData'></span><span id='topic+calcBoundaryData.PolySet'></span><span id='topic+calcBoundaryData.SpatialPolygons'></span><span id='topic+calcBoundaryData.sf'></span>

<h3>Description</h3>

<p>This function calculates boundary length data. Be aware that this
function is designed with performance in mind, and as a consequence, if this
function is used improperly then it may crash R. Furthermore, multipart
polygons with touching edges will likely result in inaccuracies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcBoundaryData(x, tol, length.factor, edge.factor)

## S3 method for class 'PolySet'
calcBoundaryData(x, tol = 0.001, length.factor = 1, edge.factor = 1)

## S3 method for class 'SpatialPolygons'
calcBoundaryData(x, tol = 0.001, length.factor = 1, edge.factor = 1)

## S3 method for class 'sf'
calcBoundaryData(x, tol = 0.001, length.factor = 1, edge.factor = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcBoundaryData_+3A_x">x</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf::st_sf()</a></code> or <code>PBSMapping::PolySet</code> object.</p>
</td></tr>
<tr><td><code id="calcBoundaryData_+3A_tol">tol</code></td>
<td>
<p><code>numeric</code> to specify precision of calculations. In other
words, how far apart vertices have to be to be considered different?</p>
</td></tr>
<tr><td><code id="calcBoundaryData_+3A_length.factor">length.factor</code></td>
<td>
<p><code>numeric</code> to scale boundary lengths.</p>
</td></tr>
<tr><td><code id="calcBoundaryData_+3A_edge.factor">edge.factor</code></td>
<td>
<p><code>numeric</code> to scale boundary lengths for edges that
do not have any neighbors, such as those that occur along the margins.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with 'id1' (<code>integer</code>), 'id2'
(<code>integer</code>), and 'amount' (<code>numeric</code>) columns.
</p>


<h3>See Also</h3>

<p>This function is based on the algorithm in QMARXAN
<a href="https://github.com/tsw-apropos/qmarxan">https://github.com/tsw-apropos/qmarxan</a> for calculating boundary
length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simulate planning units
sim_pus &lt;- sim.pus(225L)

# calculate boundary data
bound.dat &lt;- calcBoundaryData(sim_pus)

# print summary of boundary data
summary(bound.dat)

## End(Not run)
</code></pre>

<hr>
<h2 id='calcSpeciesAverageInPus'>Calculate average value for species data in planning units</h2><span id='topic+calcSpeciesAverageInPus'></span><span id='topic+calcSpeciesAverageInPus.SpatialPolygons'></span><span id='topic+calcSpeciesAverageInPus.SpatialPolygonsDataFrame'></span><span id='topic+calcSpeciesAverageInPus.sf'></span>

<h3>Description</h3>

<p>This function calculates the average of species values in each planning unit.
By default all polygons will be treated as having separate ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSpeciesAverageInPus(x, ...)

## S3 method for class 'SpatialPolygons'
calcSpeciesAverageInPus(x, y, ids = seq_len(terra::nlyr(y)), ...)

## S3 method for class 'SpatialPolygonsDataFrame'
calcSpeciesAverageInPus(x, y, ids = seq_len(terra::nlyr(y)), field = NULL, ...)

## S3 method for class 'sf'
calcSpeciesAverageInPus(x, y, ids = seq_len(terra::nlyr(y)), field = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcSpeciesAverageInPus_+3A_x">x</code></td>
<td>
<p><code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code> object.</p>
</td></tr>
<tr><td><code id="calcSpeciesAverageInPus_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="calcSpeciesAverageInPus_+3A_y">y</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object.</p>
</td></tr>
<tr><td><code id="calcSpeciesAverageInPus_+3A_ids">ids</code></td>
<td>
<p><code>integer</code> vector of ids. Defaults to indices of layers in
argument to <code>y</code>.</p>
</td></tr>
<tr><td><code id="calcSpeciesAverageInPus_+3A_field">field</code></td>
<td>
<p><code>integer</code> index or <code>character</code> name of column with
planning unit ids. Valid only when <code>x</code> is a
<code><a href="sf.html#topic+sf">sf::st_sf()</a></code> or <code><a href="sp.html#topic+SpatialPolygons">sp::SpatialPolygonsDataFrame()</a></code> object.
Default behavior is to treat each polygon as a different planning unit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> object.
</p>


<h3>Note</h3>

<p>Although earlier versions of the package had an additional <code>ncores</code>
parameter, this parameter has been deprecated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simulate data
sim_pus &lt;- sim.pus(225L)
sim_spp &lt;- terra::rast(
  lapply(c("uniform", "normal", "bimodal"),
         sim.species, n = 1, res = 1, x = sim_pus)
)

# calculate average for 1 species
puvspr1.dat &lt;- calcSpeciesAverageInPus(sim_pus, sim_spp[[1]])

# calculate average for multiple species
puvspr2.dat &lt;- calcSpeciesAverageInPus(sim_pus, sim_spp)

## End(Not run)
</code></pre>

<hr>
<h2 id='casestudy_data'>Case-study dataset for a conservation planning exercise</h2><span id='topic+casestudy_data'></span><span id='topic+cs_pus'></span><span id='topic+cs_spp'></span><span id='topic+cs_space'></span>

<h3>Description</h3>

<p>This dataset contains data to generate example prioritizations for the
pale-headed Rosella (<em>Platycercus adscitus</em>) in Queensland, Australia.
</p>


<h3>Format</h3>


<dl>
<dt><code>"cs_pus.gpkg"</code></dt><dd><p>Geopackage file</p>
</dd>
<dt><code>"cs_species.tif"</code></dt><dd><p>GeoTIFF file.</p>
</dd>
<dt><code>"cs_space.tif"</code></dt><dd><p>GeoTIFF file.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The objects in the dataset are listed below.
</p>

<dl>
<dt><code>"cs_pus.gpkg"</code></dt><dd><p>Geopackage file containing planning units.
The units were generated as <code class="reqn">30km^2</code> squares across the
species' range, and then clipped to the Queensland, Australia
(using data obtained from the Australia Bureau of Statistics; <a href="https://www.abs.gov.au/ausstats/abs@.nsf/mf/1259.0.30.001?OpenDocument">https://www.abs.gov.au/ausstats/abs@.nsf/mf/1259.0.30.001?OpenDocument</a>).
They were then overlaid with Australia's protected area
network (obtained from the World Database on Protected Areas
(WDPA) at <a href="https://www.protectedplanet.net/en">https://www.protectedplanet.net/en</a>). This
attribute table has 3 fields. The <code>area</code> field denotes
the amount of land encompassed by each unit, the <code>cost</code>
field is set to 1 for all units, and the <code>status</code> field
indicates if 50% or more of the units' extent is covered by
protected areas.</p>
</dd>
<dt><code>"cs_spp.tif"</code></dt><dd><p>GeoTIFF file containing probability
distribution map for the <em>P. adscitus</em> clipped to
Queensland, Australia. This map was derived from records
obtained from The Atlas of Living Australia.</p>
</dd>
<dt><code>"cs_space.tif"</code></dt><dd><p>GeoTIFF file describing broad-scale climate
variation across Queensland
(obtained from <a href="https://worldclim.org/">https://worldclim.org/</a>,
and resampled to <code class="reqn">10km^2</code> resolution).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
cs_pus &lt;- sf::read_sf(
 system.file("extdata", "cs_pus.gpkg", package = "raptr")
)
cs_spp &lt;- terra::rast(
  system.file("extdata", "cs_spp.tif", package = "raptr")
)
cs_space &lt;- terra::rast(
  system.file("extdata", "cs_space.tif", package = "raptr")
)

# plot data
plot(cs_pus)
plot(cs_spp)
plot(cs_space)

## End(Not run)
</code></pre>

<hr>
<h2 id='convert2PolySet'>Convert object to PolySet data</h2><span id='topic+convert2PolySet'></span><span id='topic+convert2PolySet.SpatialPolygonsDataFrame'></span><span id='topic+convert2PolySet.SpatialPolygons'></span><span id='topic+convert2PolySet.sf'></span>

<h3>Description</h3>

<p>This function converts <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> and
<code><a href="sp.html#topic+SpatialPolygons">sp::SpatialPolygonsDataFrame()</a></code> objects to
<code>PBSmapping::PolySet()</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2PolySet(x, n_preallocate)

## S3 method for class 'SpatialPolygonsDataFrame'
convert2PolySet(x, n_preallocate = 10000L)

## S3 method for class 'SpatialPolygons'
convert2PolySet(x, n_preallocate = 10000L)

## S3 method for class 'sf'
convert2PolySet(x, n_preallocate = 10000L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2PolySet_+3A_x">x</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf::st_sf()</a></code>, <code><a href="sp.html#topic+SpatialPolygons">sp::SpatialPolygons()</a></code> or
<code><a href="sp.html#topic+SpatialPolygons">sp::SpatialPolygonsDataFrame()</a></code> object.</p>
</td></tr>
<tr><td><code id="convert2PolySet_+3A_n_preallocate">n_preallocate</code></td>
<td>
<p><code>integer</code> How much memory should be preallocated
for processing? Ideally, this number should equal the number of vertices
in the <code><a href="sp.html#topic+SpatialPolygons">sp::SpatialPolygons()</a></code> object. If data processing is
taking too long consider increasing this value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PBSmapping::PolySet()</code> object.
</p>


<h3>Note</h3>

<p>Be aware that this function is designed to be as fast as possible, but
as a result it depends on C++ code and if used inappropriately this
function will crash R.
</p>


<h3>See Also</h3>

<p>For a slower, more stable equivalent see
<code>maptools::SpatialPolygons2PolySet</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate sf object
sim_pus &lt;- sim.pus(225L)

# convert to PolySet
x &lt;- convert2PolySet(sim_pus)

## End(Not run)
</code></pre>

<hr>
<h2 id='DemandPoints'>Create new DemandPoints object</h2><span id='topic+DemandPoints'></span>

<h3>Description</h3>

<p>This function creates a new <code>DemandPoints</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DemandPoints(coords, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DemandPoints_+3A_coords">coords</code></td>
<td>
<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> of coordinates for each demand point.</p>
</td></tr>
<tr><td><code id="DemandPoints_+3A_weights">weights</code></td>
<td>
<p><code>numeric</code> weights for each demand point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>DemandPoints</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+DemandPoints-class">DemandPoints</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# make demand points
dps &lt;- DemandPoints(
 matrix(rnorm(100), ncol=2),
 runif(50)
)

# print object
print(dps)

## End(Not run)
</code></pre>

<hr>
<h2 id='DemandPoints-class'>DemandPoints: An S4 class to represent demand points</h2><span id='topic+DemandPoints-class'></span>

<h3>Description</h3>

<p>This class is used to store demand point information.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coords</code></dt><dd><p><code><a href="base.html#topic+matrix">base::matrix()</a></code> of coordinates for each demand point.</p>
</dd>
<dt><code>weights</code></dt><dd><p><code>numeric</code> weights for each demand point.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+DemandPoints">DemandPoints()</a></code>.
</p>

<hr>
<h2 id='dp.subset'>Subset demand points</h2><span id='topic+dp.subset'></span><span id='topic+dp.subset.RapData'></span><span id='topic+dp.subset.RapUnsolOrSol'></span>

<h3>Description</h3>

<p>Subset demand points from a <code><a href="#topic+RapData">RapData()</a></code>,
<code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dp.subset(x, space, species, points)

## S3 method for class 'RapData'
dp.subset(x, space, species, points)

## S3 method for class 'RapUnsolOrSol'
dp.subset(x, space, species, points)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dp.subset_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="dp.subset_+3A_space">space</code></td>
<td>
<p><code>integer</code> vector to specify the index of the space to
subset demand points from.</p>
</td></tr>
<tr><td><code id="dp.subset_+3A_species">species</code></td>
<td>
<p><code>integer</code> vector to specify the index of the species to
subset demand points from.</p>
</td></tr>
<tr><td><code id="dp.subset_+3A_points">points</code></td>
<td>
<p><code>integer</code> vector to specify the index of demand points to
subset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+RapData">RapData()</a></code> or <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> object depending
on input object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>,
<code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_ru)

# generate new object with first 10 planning units
sim_ru2 &lt;- dp.subset(sim_ru, 1, 1, seq_len(10))

## End(Not run)
</code></pre>

<hr>
<h2 id='GurobiOpts'>Create GurobiOpts object</h2><span id='topic+GurobiOpts'></span>

<h3>Description</h3>

<p>This function creates a new GurobiOpts object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GurobiOpts(
  Threads = 1L,
  MIPGap = 0.1,
  Method = 0L,
  Presolve = 2L,
  TimeLimit = NA_integer_,
  NumberSolutions = 1L,
  MultipleSolutionsMethod = c("benders.cuts", "solution.pool.0", "solution.pool.1",
    "solution.pool.2")[1],
  NumericFocus = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GurobiOpts_+3A_threads">Threads</code></td>
<td>
<p><code>integer</code> number of cores to use for processing.
Defaults to 1L.</p>
</td></tr>
<tr><td><code id="GurobiOpts_+3A_mipgap">MIPGap</code></td>
<td>
<p><code>numeric</code> MIP gap specifying minimum solution quality.
Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="GurobiOpts_+3A_method">Method</code></td>
<td>
<p><code>integer</code> Algorithm to use for solving model. Defaults to
0L.</p>
</td></tr>
<tr><td><code id="GurobiOpts_+3A_presolve">Presolve</code></td>
<td>
<p><code>integer</code> code for level of computation in presolve
(lp_solve parameter). Defaults to 2.</p>
</td></tr>
<tr><td><code id="GurobiOpts_+3A_timelimit">TimeLimit</code></td>
<td>
<p><code>integer</code> number of seconds to allow for solving.
Defaults to <code>NA_integer_</code>, and so a time limit is not imposed.</p>
</td></tr>
<tr><td><code id="GurobiOpts_+3A_numbersolutions">NumberSolutions</code></td>
<td>
<p><code>integer</code> number of solutions to generate.
Defaults to 1L.</p>
</td></tr>
<tr><td><code id="GurobiOpts_+3A_multiplesolutionsmethod">MultipleSolutionsMethod</code></td>
<td>
<p><code>integer</code> name of method to obtain
multiple solutions (used when <code>NumberSolutions</code> is greater than one).
Available options are <code>"benders.cuts"</code>, <code>"solution.pool.0"</code>,
<code>"solution.pool.1"</code>, and <code>"solution.pool.2"</code>. The
<code>"benders.cuts"</code> method produces a set of distinct solutions that
are all within the optimality gap. The <code>"solution.pool.0"</code>
method returns all solutions identified whilst trying to find
a solution that is within the specified optimality gap. The
<code>"solution.pool.1"</code> method finds one solution within the optimality
gap and a number of additional solutions that are of any level of quality
(such that the total number of solutions is equal to
<code>number_solutions</code>). The <code>"solution.pool.2"</code> finds a
specified number of solutions that are nearest to optimality. The
search pool methods correspond to the parameters used by the Gurobi
software suite (see <a href="https://www.gurobi.com/documentation/8.0/refman/poolsearchmode.html#parameter:PoolSearchMode">https://www.gurobi.com/documentation/8.0/refman/poolsearchmode.html#parameter:PoolSearchMode</a>).
Defaults to <code>"benders.cuts"</code>.</p>
</td></tr>
<tr><td><code id="GurobiOpts_+3A_numericfocus">NumericFocus</code></td>
<td>
<p><code>integer</code> how much effort should Gurobi focus on
addressing numerical issues? Defaults to <code>0L</code> such that minimal effort
is spent to reduce run time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>GurobiOpts</code> object
</p>


<h3>See Also</h3>

<p><a href="#topic+GurobiOpts-class">GurobiOpts</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create GurobiOpts object using default parameters
GurobiOpts(Threads = 1L, MIPGap = 0.1, Method = 0L, Presolve=2L,
           TimeLimit = NA_integer_, NumberSolutions = 1L, NumericFocus = 0L)

## End(Not run)
</code></pre>

<hr>
<h2 id='GurobiOpts-class'>GurobiOpts: An S4 class to represent Gurobi parameters</h2><span id='topic+GurobiOpts-class'></span>

<h3>Description</h3>

<p>This class is used to store Gurobi input parameters.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Threads</code></dt><dd><p><code>integer</code> number of cores to use for processing. Defaults
to 1L.</p>
</dd>
<dt><code>MIPGap</code></dt><dd><p><code>numeric</code> MIP gap specifying minimum solution quality.
Defaults to 0.1.</p>
</dd>
<dt><code>Method</code></dt><dd><p><code>integer</code> Algorithm to use for solving model. Defaults to
0L.</p>
</dd>
<dt><code>Presolve</code></dt><dd><p><code>integer</code> code for level of computation in presolve.
Defaults to 2.</p>
</dd>
<dt><code>TimeLimit</code></dt><dd><p><code>integer</code> number of seconds to allow for solving.
Defaults to NA_integer_, and so a time limit is not imposed.</p>
</dd>
<dt><code>NumberSolutions</code></dt><dd><p><code>integer</code> number of solutions to generate.
Defaults to 1L.</p>
</dd>
<dt><code>MultipleSolutionsMethod</code></dt><dd><p><code>integer</code> name of method to obtain
multiple solutions (used when <code>NumberSolutions</code> is greater than one).
Available options are <code>"benders.cuts"</code>, <code>"solution.pool.0"</code>,
<code>"solution.pool.1"</code>, and <code>"solution.pool.2"</code>. The
<code>"benders.cuts"</code> method produces a set of distinct solutions that
are all within the optimality gap. The <code>"solution.pool.0"</code>
method returns all solutions identified whilst trying to find
a solution that is within the specified optimality gap. The
<code>"solution.pool.1"</code> method finds one solution within the optimality
gap and a number of additional solutions that are of any level of quality
(such that the total number of solutions is equal to
<code>number_solutions</code>). The <code>"solution.pool.2"</code> finds a
specified number of solutions that are nearest to optimality. The
search pool methods correspond to the parameters used by the Gurobi
software suite (see <a href="https://www.gurobi.com/documentation/8.0/refman/poolsearchmode.html#parameter:PoolSearchMode">https://www.gurobi.com/documentation/8.0/refman/poolsearchmode.html#parameter:PoolSearchMode</a>).
Defaults to <code>"benders.cuts"</code>.</p>
</dd>
<dt><code>NumericFocus</code></dt><dd><p><code>integer</code> how much effort should Gurobi focus on
addressing numerical issues? Defaults to <code>0L</code> such that minimal effort
is spent to reduce run time.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+GurobiOpts">GurobiOpts()</a></code>.
</p>

<hr>
<h2 id='is.cached'>Test if hash is cached in a Rap object</h2><span id='topic+is.cached'></span><span id='topic+is.cached+2CRapData+2Ccharacter-method'></span><span id='topic+is.cached+2CRapResults+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Tests if hash is cached in Rap object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.cached(x, name)

## S4 method for signature 'RapData,character'
is.cached(x, name)

## S4 method for signature 'RapResults,character'
is.cached(x, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.cached_+3A_x">x</code></td>
<td>
<p><code>RapData</code> or <code>RapResults</code> object</p>
</td></tr>
<tr><td><code id="is.cached_+3A_name">name</code></td>
<td>
<p><code>character</code> hash.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code> Is it cached?
</p>


<h3>Note</h3>

<p>caches are implemented using environments, the hash is used as the
name of the object in the environment.
</p>

<hr>
<h2 id='is.comparable'>Compare Rap objects</h2><span id='topic+is.comparable'></span><span id='topic+is.comparable+2CRapData+2CRapData-method'></span><span id='topic+is.comparable+2CRapUnsolOrSol+2CRapUnsolOrSol-method'></span><span id='topic+is.comparable+2CRapData+2CRapUnsolOrSol-method'></span><span id='topic+is.comparable+2CRapUnsolOrSol+2CRapData-method'></span>

<h3>Description</h3>

<p>This function checks objects to see if they share the same input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.comparable(x, y)

## S4 method for signature 'RapData,RapData'
is.comparable(x, y)

## S4 method for signature 'RapUnsolOrSol,RapUnsolOrSol'
is.comparable(x, y)

## S4 method for signature 'RapData,RapUnsolOrSol'
is.comparable(x, y)

## S4 method for signature 'RapUnsolOrSol,RapData'
is.comparable(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.comparable_+3A_x">x</code></td>
<td>
<p><code>RapData</code>, <code>RapUnsolved</code>, or <code>RapSolved</code> object.</p>
</td></tr>
<tr><td><code id="is.comparable_+3A_y">y</code></td>
<td>
<p><code>RapData</code>, <code>RapUnsolved</code>, or <code>RapSolved</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code> are the objects based on the same data?
</p>


<h3>See Also</h3>

<p><a href="#topic+RapData-class">RapData</a>, <a href="#topic+RapUnsolved-class">RapUnsolved</a>,
<a href="#topic+RapSolved-class">RapSolved</a>.
</p>

<hr>
<h2 id='is.GurobiInstalled'>Test if Gurobi is installed</h2><span id='topic+is.GurobiInstalled'></span>

<h3>Description</h3>

<p>This function determines if the Gurobi R package is installed on the
computer and that it can be used <code><a href="base.html#topic+options">base::options()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.GurobiInstalled(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.GurobiInstalled_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> should messages be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code> Is it installed and ready to use?
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">base::options()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# check if Gurobi is installed
is.GurobiInstalled()

# print cached status of installation
options()$GurobiInstalled

## End(Not run)
</code></pre>

<hr>
<h2 id='logging.file'>Log file</h2><span id='topic+logging.file'></span><span id='topic+logging.file.RapResults'></span><span id='topic+logging.file.RapSolved'></span>

<h3>Description</h3>

<p>This function returns the Gurobi log file (*.log) associated with solving
an optimization problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logging.file(x, y)

## S3 method for class 'RapResults'
logging.file(x, y = 0)

## S3 method for class 'RapSolved'
logging.file(x, y = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logging.file_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapResults">RapResults()</a></code> or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="logging.file_+3A_y">y</code></td>
<td>
<p>Available inputs include: <code>NULL</code> to return all values,
<code>integer</code> number specifying the solution for which the log file should
be returned, and <code>0</code> to return log file for the best solution.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The term logging file was used due to collisions with the <code>log</code>
function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapResults">RapResults()</a></code>, <code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_rs)

# log file for the best solution
cat(logging.file(sim_rs, 0))

# log file for the second solution
cat(logging.file(sim_rs, 2))

# log files for all solutions
cat(logging.file(sim_rs, NULL))

## End(Not run)
</code></pre>

<hr>
<h2 id='make.DemandPoints'>Generate demand points for RAP</h2><span id='topic+make.DemandPoints'></span>

<h3>Description</h3>

<p>This function generates demand points to characterize a distribution of
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.DemandPoints(
  points,
  n = 100L,
  quantile = 0.5,
  kernel.method = c("ks", "hypervolume")[1],
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.DemandPoints_+3A_points">points</code></td>
<td>
<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> object containing points.</p>
</td></tr>
<tr><td><code id="make.DemandPoints_+3A_n">n</code></td>
<td>
<p><code>integer</code> number of demand points to use for each attribute
space for each species. Defaults to <code>100L</code>.</p>
</td></tr>
<tr><td><code id="make.DemandPoints_+3A_quantile">quantile</code></td>
<td>
<p><code>numeric</code> quantile to generate demand points within. If
0 then demand points are generated across the full range of values the
<code>points</code> intersect. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="make.DemandPoints_+3A_kernel.method">kernel.method</code></td>
<td>
<p><code>character</code> name of kernel method to use to
generate demand points. Defaults to <code>'ks'</code>.</p>
</td></tr>
<tr><td><code id="make.DemandPoints_+3A_...">...</code></td>
<td>
<p>arguments passed to kernel density estimating functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Broadly speaking, demand points are generated by fitting a kernal
to the input <code>points</code>. A shape is then fit to the extent of
the kernal, and then points are randomly generated inside the shape. The
demand points are generated as random points inside the shape. The weights
for each demand point are calculated the estimated density of input points
at the demand point. By supplying 'ks' as an argument to <code>method</code> in
<code>kernel.method</code>, the shape is defined using a minimum convex polygon
<code><a href="adehabitatHR.html#topic+mcp">adehabitatHR::mcp()</a></code> and <code><a href="ks.html#topic+kde">ks::kde()</a></code> is used to fit
the kernel. Note this can only be used when the data is low-dimensional (d
&lt; 3). By supplying <code>"hypervolume"</code> as an argument to <code>method</code>,
the <code><a href="hypervolume.html#topic+hypervolume">hypervolume::hypervolume()</a></code> function is used to create the
demand points. This method can be used for hyper-dimensional data
(<code class="reqn">d &lt;&lt; 3</code>).
</p>


<h3>Value</h3>

<p>A new <code><a href="#topic+DemandPoints">DemandPoints()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="hypervolume.html#topic+hypervolume">hypervolume::hypervolume()</a></code>, <code><a href="ks.html#topic+kde">ks::kde()</a></code>,
<code><a href="adehabitatHR.html#topic+mcp">adehabitatHR::mcp()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set random number generator seed
set.seed(500)

# load data
cs_spp &lt;- terra::rast(
  system.file("extdata", "cs_spp.tif", package = "raptr")
)
cs_space &lt;- terra::rast(
  system.file("extdata", "cs_space.tif", package = "raptr")
)

# generate species points
species.points &lt;- randomPoints(cs_spp[[1]], n = 100, prob = TRUE)
env.points &lt;- as.matrix(terra::extract(cs_space, species.points))

# generate demand points for a 1d space using ks
dps1 &lt;- make.DemandPoints(points = env.points[, 1], kernel.method = "ks")

# print object
print(dps1)

# generate demand points for a 2d space using hypervolume
dps2 &lt;- make.DemandPoints(
  points = env.points,
  kernel.method = "hypervolume",
  samples.per.point = 50,
  verbose = FALSE
)

# print object
print(dps2)

## End(Not run)
</code></pre>

<hr>
<h2 id='make.RapData'>Make data for RAP using minimal inputs</h2><span id='topic+make.RapData'></span>

<h3>Description</h3>

<p>This function prepares spatially explicit planning unit, species data, and
landscape data layers for RAP processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.RapData(
  pus,
  species,
  spaces = NULL,
  amount.target = 0.2,
  space.target = 0.2,
  n.demand.points = 100L,
  kernel.method = c("ks", "hypervolume")[1],
  quantile = 0.5,
  species.points = NULL,
  n.species.points = ceiling(0.2 * terra::global(species, "sum", na.rm = TRUE)[[1]]),
  include.geographic.space = TRUE,
  scale = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.RapData_+3A_pus">pus</code></td>
<td>
<p><code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code> with planning unit data.</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_species">species</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> with species probability
distribution data.</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_spaces">spaces</code></td>
<td>
<p><code>list</code> of/or <code><a href="terra.html#topic+rast">terra::rast()</a></code> representing
projects of attribute space over geographic space. Use a <code>list</code> to
denote separate attribute spaces.</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_amount.target">amount.target</code></td>
<td>
<p><code>numeric</code> vector for area targets (%) for each
species. Defaults to 0.2 for each attribute space for each species.</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_space.target">space.target</code></td>
<td>
<p><code>numeric</code> vector for attribute space targets (%)
for each species. Defaults to 0.2 for each attribute space for each
species and each space.</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_n.demand.points">n.demand.points</code></td>
<td>
<p><code>integer</code> number of demand points to use for
each attribute space for each species. Defaults to 100L.</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_kernel.method">kernel.method</code></td>
<td>
<p><code>character</code> name of kernel method to use to
generate demand points. Use either <code>"ks"</code> or <code>"hypervolume"</code>.</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_quantile">quantile</code></td>
<td>
<p><code>numeric</code> quantile to generate demand points within. If
<code>species.points</code> intersect. Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_species.points">species.points</code></td>
<td>
<p><code>list</code> of/or <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> object species presence
records. Use a
<code>list</code> of objects to represent different species. Must have the same
number of elements as <code>species</code>. If not supplied then use
<code>n.species.points</code> to sample points from the species distributions.</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_n.species.points">n.species.points</code></td>
<td>
<p><code>numeric</code> vector specifying the number points
to sample the species distributions to use to generate demand points.
Defaults to 20% of the distribution.</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_include.geographic.space">include.geographic.space</code></td>
<td>
<p><code>logical</code> should the geographic space
be considered an attribute space?</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_scale">scale</code></td>
<td>
<p><code>logical</code> scale the attribute spaces to unit mean and
standard deviation? This prevents overflow. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> print statements during processing?</p>
</td></tr>
<tr><td><code id="make.RapData_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+calcBoundaryData">calcBoundaryData()</a></code> and
<code><a href="#topic+calcSpeciesAverageInPus">calcSpeciesAverageInPus()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>RapData</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+RapData-class">RapData</a>, <code><a href="#topic+RapData">RapData()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
cs_pus &lt;- sf::read_sf(
 system.file("extdata", "cs_pus.gpkg", package = "raptr")
)
cs_spp &lt;- terra::rast(
  system.file("extdata", "cs_spp.tif", package = "raptr")
)
cs_space &lt;- terra::rast(
  system.file("extdata", "cs_space.tif", package = "raptr")
)
# make RapData object using the first 10 planning units in the dat
x &lt;- make.RapData(cs_pus[1:10,], cs_spp, cs_space,
                  include.geographic.space = TRUE)
# print object
print(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='ManualOpts'>Create ManualOpts object</h2><span id='topic+ManualOpts'></span>

<h3>Description</h3>

<p>This function creates a new ManualOpts object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ManualOpts(NumberSolutions = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ManualOpts_+3A_numbersolutions">NumberSolutions</code></td>
<td>
<p><code>integer</code> number of solutions to generate.
Defaults to 1L.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>ManualOpts()</code> object
</p>


<h3>See Also</h3>

<p><a href="#topic+ManualOpts-class">ManualOpts</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create ManualOpts object
ManualOpts(NumberSolutions = 1L)

## End(Not run)
</code></pre>

<hr>
<h2 id='ManualOpts-class'>ManualOpts: An S4 class to represent parameters for manually specified
solutions</h2><span id='topic+ManualOpts-class'></span>

<h3>Description</h3>

<p>This class is used to store parameters.
</p>


<h3>Slots</h3>


<dl>
<dt><code>NumberSolutions</code></dt><dd><p><code>integer</code> number of solutions.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+ManualOpts">ManualOpts()</a></code>.
</p>

<hr>
<h2 id='maximum.targets'>Maximum targets</h2><span id='topic+maximum.targets'></span><span id='topic+maximum.targets.RapUnsolOrSol'></span>

<h3>Description</h3>

<p>This function accepts a <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> object and returns a
<code>data.frame</code> containing the amount-based and space-based targets for
each species and attribute space. These are calculated using a
prioritization that contains all the available planning units. Note that the
maximum amount-based targets are always 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximum.targets(x, verbose)

## S3 method for class 'RapUnsolOrSol'
maximum.targets(x, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maximum.targets_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="maximum.targets_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> should messages be printed during
calculations? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load RapSolved objects
data(sim_ru)

# calculate maximum metrics
maximum.targets(sim_ru)

## End(Not run)
</code></pre>

<hr>
<h2 id='names'>Names</h2><span id='topic+names'></span><span id='topic+names+3C-.RapData'></span><span id='topic+names.RapData'></span><span id='topic+names+3C-.RapUnsolOrSol'></span><span id='topic+names.RapUnsolOrSol'></span>

<h3>Description</h3>

<p>This function sets or returns the species names in an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'RapData'
names(x) &lt;- value

## S3 method for class 'RapData'
names(x)

## S3 replacement method for class 'RapUnsolOrSol'
names(x) &lt;- value

## S3 method for class 'RapUnsolOrSol'
names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="names_+3A_value">value</code></td>
<td>
<p>new species names.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>,
<code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_rs)

# show names
names(sim_rs)

# change names
names(sim_rs) &lt;- c('spp1', 'spp2', 'spp3')

# show new names
names(sim_rs)

## End(Not run)
</code></pre>

<hr>
<h2 id='PlanningUnitPoints'>Create new PlanningUnitPoints object</h2><span id='topic+PlanningUnitPoints'></span>

<h3>Description</h3>

<p>This function creates a new <code>PlanningUnitPoints</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlanningUnitPoints(coords, ids)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlanningUnitPoints_+3A_coords">coords</code></td>
<td>
<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> coordinates for each point.</p>
</td></tr>
<tr><td><code id="PlanningUnitPoints_+3A_ids">ids</code></td>
<td>
<p><code>integer</code> planning unit ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>PlanningUnitPoints</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+AttributeSpace-class">AttributeSpace</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create PlanningUnitPoints object
x &lt;- PlanningUnitPoints(matrix(rnorm(150), ncol = 1), seq_len(150))

# print object
print(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='PlanningUnitPoints-class'>PlanningUnitPoints: An S4 class to represent planning units in an attribute
space</h2><span id='topic+PlanningUnitPoints-class'></span>

<h3>Description</h3>

<p>This class is used to planning units in an attribute space.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coords</code></dt><dd><p><code><a href="base.html#topic+matrix">base::matrix()</a></code> coordinates for each point.</p>
</dd>
<dt><code>ids</code></dt><dd><p><code>integer</code> planning unit ids.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+AttributeSpace">AttributeSpace()</a></code>.
</p>

<hr>
<h2 id='plot'>Plot object</h2><span id='topic+plot'></span><span id='topic+plot+2CRapSolved+2Cnumeric-method'></span><span id='topic+plot+2CRapSolved+2Cmissing-method'></span><span id='topic+plot+2CRapSolved+2CRapSolved-method'></span>

<h3>Description</h3>

<p>This function plots the solutions contained in <code><a href="#topic+RapSolved">RapSolved()</a></code>
objects. It can be used to show a single solution, or the the selection
frequencies of planning units contained in a single <code><a href="#topic+RapSolved">RapSolved()</a></code>
object. Additionally, two <code><a href="#topic+RapSolved">RapSolved()</a></code> objects can be supplied to
plot the differences between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RapSolved,numeric'
plot(x, y, basemap = "none",
 pu.color.palette = c("#e5f5f9", "#00441b", "#FFFF00", "#FF0000"), alpha =
 ifelse(basemap == "none", 1, 0.7), grayscale = FALSE, main = NULL,
 force.reset = FALSE)

## S4 method for signature 'RapSolved,missing'
plot(x, y, basemap = "none",
pu.color.palette = c("PuBu", "#FFFF00", "#FF0000"),
alpha = ifelse(basemap == "none", 1, 0.7),
grayscale = FALSE, main = NULL,
force.reset = FALSE)

## S4 method for signature 'RapSolved,RapSolved'
plot(x, y, i = NULL, j = i,
basemap = "none",
pu.color.palette = ifelse(is.null(i), c("RdYlBu", "#FFFF00",
"#FF0000"), "Accent"),
alpha = ifelse(basemap == "none", 1, 0.7),
grayscale = FALSE, main = NULL, force.reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>Available inputs are: <code>NULL</code> to plot selection frequencies,
<code>numeric</code> number to plot a specific solution,
<code>0</code> to plot the best solution, and a <code><a href="#topic+RapSolved">RapSolved()</a></code>
object to plot differences in solutions between objects. Defaults to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_basemap">basemap</code></td>
<td>
<p><code>character</code> object indicating the type of basemap to use
(see <code><a href="#topic+basemap">basemap()</a></code>). Valid options include <code>"none"</code>,
<code>"roadmap"</code>, <code>"mobile"</code>, <code>"satellite"</code>, <code>"terrain"</code>,
<code>"hybrid"</code>, <code>"mapmaker-roadmap"</code>, <code>"mapmaker-hybrid"</code>.
Defaults to <code>"none"</code> such that no basemap is shown.</p>
</td></tr>
<tr><td><code id="plot_+3A_pu.color.palette">pu.color.palette</code></td>
<td>
<p><code>character</code> vector of colors to indicate
planning unit statuses.
If plotting selection frequencies (i.e., <code>j = NULL</code>), then
defaults to a <code>c("PuBu", "#FFFF00", "#FF0000")</code>.
Here, the first element corresponds to a color palette
(per <code><a href="RColorBrewer.html#topic+ColorBrewer">RColorBrewer::brewer.pal()</a></code>) and the last two elements
indicate the colors for locked in and locked out planning units.
Otherwise, the parameter defaults to a <code>character</code> vector of
<code>c("grey30", "green", "yellow", "black", "gray80", "red", "orange")</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_alpha">alpha</code></td>
<td>
<p><code>numeric</code> value to indicating the transparency level for
coloring the planning units.</p>
</td></tr>
<tr><td><code id="plot_+3A_grayscale">grayscale</code></td>
<td>
<p><code>logical</code> should the basemap be gray-scaled?</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p><code>character</code> title for the plot. Defaults to <code>NULL</code> and
a default title is used.</p>
</td></tr>
<tr><td><code id="plot_+3A_force.reset">force.reset</code></td>
<td>
<p><code>logical</code> if basemap data has been cached, should it
be re-downloaded?</p>
</td></tr>
<tr><td><code id="plot_+3A_i">i</code></td>
<td>
<p>Available inputs are: <code>NULL</code> to plot selection frequencies.
<code>numeric</code> to plot a specific solution, <code>0</code> to plot the best
solution. This argument is only used when <code>y</code> is a
<code><a href="#topic+RapSolved">RapSolved()</a></code> object. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_j">j</code></td>
<td>
<p>Available inputs are: <code>NULL</code> to plot selection frequencies.
<code>numeric</code> to plot a specific solution, <code>0</code> to plot the best
solution. This argument is only used when <code>y</code> is a
<code><a href="#topic+RapSolved">RapSolved()</a></code> object. Defaults to argument <code>j</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the <span class="pkg">RgoogleMaps</span> package to be installed
in order to create display a basemap.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data set with solutions
data(sim_rs)

# plot selection frequencies
plot(sim_rs)

# plot best solution
plot(sim_rs, 0)

# plot second solution
plot(sim_rs, 2)

# plot different between best and second solutions
plot(sim_rs, sim_rs, 0 ,2)

## End(Not run)
</code></pre>

<hr>
<h2 id='PolySet-class'>PolySet</h2><span id='topic+PolySet-class'></span><span id='topic+PolySet'></span>

<h3>Description</h3>

<p>Object contains PolySet data.
</p>


<h3>See Also</h3>

<p><code><a href="PBSmapping.html#topic+PolySet">PBSmapping::PolySet()</a></code>.
</p>

<hr>
<h2 id='print'>Print objects</h2><span id='topic+print'></span><span id='topic+print.AttributeSpace'></span><span id='topic+print.AttributeSpaces'></span><span id='topic+print.GurobiOpts'></span><span id='topic+print.ManualOpts'></span><span id='topic+print.RapData'></span><span id='topic+print.RapReliableOpts'></span><span id='topic+print.RapResults'></span><span id='topic+print.RapUnreliableOpts'></span><span id='topic+print.RapUnsolved'></span><span id='topic+print.RapSolved'></span>

<h3>Description</h3>

<p>Prints objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AttributeSpace'
print(x, ..., header = TRUE)

## S3 method for class 'AttributeSpaces'
print(x, ..., header = TRUE)

## S3 method for class 'GurobiOpts'
print(x, ..., header = TRUE)

## S3 method for class 'ManualOpts'
print(x, ..., header = TRUE)

## S3 method for class 'RapData'
print(x, ..., header = TRUE)

## S3 method for class 'RapReliableOpts'
print(x, ..., header = TRUE)

## S3 method for class 'RapResults'
print(x, ..., header = TRUE)

## S3 method for class 'RapUnreliableOpts'
print(x, ..., header = TRUE)

## S3 method for class 'RapUnsolved'
print(x, ...)

## S3 method for class 'RapSolved'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+GurobiOpts">GurobiOpts()</a></code>, <code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code>,
<code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code>, <code><a href="#topic+RapData">RapData()</a></code>,
<code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, <code><a href="#topic+RapResults">RapResults()</a></code>, or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="print_+3A_header">header</code></td>
<td>
<p><code>logical</code> should object header be included?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GurobiOpts">GurobiOpts()</a></code>, <code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code>,
<code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code>, <code><a href="#topic+RapData">RapData()</a></code>,
<code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, <code><a href="#topic+RapResults">RapResults()</a></code>,
<code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_ru, sim_rs)

# print GurobiOpts object
print(GurobiOpts())

# print RapReliableOpts object
print(RapReliableOpts())

# print RapUnreliableOpts object
print(RapUnreliableOpts())

# print RapData object
print(sim_ru@data)

# print RapUnsolved object
print(sim_ru)

# print RapResults object
print(sim_rs@results)

# print RapSolved object
print(sim_rs)

## End(Not run)
</code></pre>

<hr>
<h2 id='prob.subset'>Subset probabilities above a threshold</h2><span id='topic+prob.subset'></span><span id='topic+prob.subset.RapData'></span><span id='topic+prob.subset.RapUnsolOrSol'></span>

<h3>Description</h3>

<p>This function subsets out probabilities assigned to planning units above a
threshold. It effectively sets the probability that species inhabit planning
units to zero if they are below the threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob.subset(x, species, threshold)

## S3 method for class 'RapData'
prob.subset(x, species, threshold)

## S3 method for class 'RapUnsolOrSol'
prob.subset(x, species, threshold)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob.subset_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="prob.subset_+3A_species">species</code></td>
<td>
<p><code>integer</code> vector specifying the index of the species to
which the threshold should be applied.</p>
</td></tr>
<tr><td><code id="prob.subset_+3A_threshold">threshold</code></td>
<td>
<p><code>numeric</code> probability to use a threshold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+RapData">RapData()</a></code> or <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> object depending
on input object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>,
<code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_ru)

# generate new object with first 10 planning units
sim_ru2 &lt;- prob.subset(sim_ru, seq_len(3), c(0.1, 0.2, 0.3))

## End(Not run)
</code></pre>

<hr>
<h2 id='pu.subset'>Subset planning units</h2><span id='topic+pu.subset'></span><span id='topic+pu.subset.RapData'></span><span id='topic+pu.subset.RapUnsolOrSol'></span>

<h3>Description</h3>

<p>Subset planning units from a <code><a href="#topic+RapData">RapData()</a></code>,
<code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pu.subset(x, pu)

## S3 method for class 'RapData'
pu.subset(x, pu)

## S3 method for class 'RapUnsolOrSol'
pu.subset(x, pu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pu.subset_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="pu.subset_+3A_pu">pu</code></td>
<td>
<p><code>integer</code> vector to specify the index of planning units to
subset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+RapData">RapData()</a></code> or <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> object depending
on input object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>,
<code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_ru)

# generate new object with first 10 planning units
sim_ru2 &lt;- pu.subset(sim_ru, seq_len(10))

## End(Not run)
</code></pre>

<hr>
<h2 id='randomPoints'>Sample random points from a SpatRaster</h2><span id='topic+randomPoints'></span>

<h3>Description</h3>

<p>This function generates random points in a <code><a href="terra.html#topic+rast">terra::rast()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomPoints(mask, n, prob = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomPoints_+3A_mask">mask</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object</p>
</td></tr>
<tr><td><code id="randomPoints_+3A_n">n</code></td>
<td>
<p><code>integer</code> number of points to sample</p>
</td></tr>
<tr><td><code id="randomPoints_+3A_prob">prob</code></td>
<td>
<p><code>logical</code> should the raster values be used as weights?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> with x-coordinates, y-coordinates, and
cell values.
</p>


<h3>See Also</h3>

<p>This function is similar to <code>dismo::randomPoints</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simulate data
sim_pus &lt;- sim.pus(225L)
sim_spp &lt;- sim.species(sim_pus, model = "normal", n = 1, res = 0.25)

# generate points
pts1 &lt;- randomPoints(sim_spp, n = 5)
pts2 &lt;- randomPoints(sim_spp, n = 5, prob = TRUE)

# plot points
plot(sim_spp)
points(pts1, col = "red")
points(pts2, col = "black")

## End(Not run)
</code></pre>

<hr>
<h2 id='rap'>Generate prioritizations using RAP</h2><span id='topic+rap'></span>

<h3>Description</h3>

<p>This is a general function to create Rap objects from scratch and solve them
to generate solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rap(
  pus,
  species,
  spaces = NULL,
  formulation = c("unreliable", "reliable")[1],
  solve = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rap_+3A_pus">pus</code></td>
<td>
<p><code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code> object representing planning
units.</p>
</td></tr>
<tr><td><code id="rap_+3A_species">species</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> object with species distribution
data.</p>
</td></tr>
<tr><td><code id="rap_+3A_spaces">spaces</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> or <code>list</code> of <code><a href="terra.html#topic+rast">terra::rast()</a></code> objects. Each
elements denotes the spatial distribution for each space. Defaults to
<code>NULL</code> such that spaces are generated automatically.</p>
</td></tr>
<tr><td><code id="rap_+3A_formulation">formulation</code></td>
<td>
<p><code>character</code> to indicate if the <code>"unreliable"</code> or
<code>"reliable"</code> formulation should be used to generate prioritizations.
Defaults to <code>"unreliable"</code>.</p>
</td></tr>
<tr><td><code id="rap_+3A_solve">solve</code></td>
<td>
<p><code>logical</code> should solutions be generated?</p>
</td></tr>
<tr><td><code id="rap_+3A_...">...</code></td>
<td>
<p>arguments are passed to <code><a href="#topic+GurobiOpts">GurobiOpts()</a></code>,
<code><a href="#topic+make.RapData">make.RapData()</a></code>, and <code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code> or
<code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code><a href="#topic+RapSolved">RapSolved()</a></code> object if <code>solve</code> is <code>TRUE</code>,
otherwise an <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> is returned.
</p>


<h3>Note</h3>

<p>Type <code>vignette("raptr")</code> to see the package vignette for a
tutorial.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GurobiOpts">GurobiOpts()</a></code>, <code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code>,
<code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code> <code><a href="#topic+RapData">RapData()</a></code>,
<code><a href="#topic+RapResults">RapResults()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>,
<code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>

<hr>
<h2 id='RapData'>Create new RapData object</h2><span id='topic+RapData'></span>

<h3>Description</h3>

<p>This function creates a &quot;RapData&quot; object using pre-processed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RapData(
  pu,
  species,
  targets,
  pu.species.probabilities,
  attribute.spaces,
  boundary,
  polygons = NA,
  skipchecks = FALSE,
  .cache = new.env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RapData_+3A_pu">pu</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code> planning unit data. Columns must be
&quot;cost&quot; (<code>numeric</code>), &quot;area&quot; (<code>numeric</code>), and &quot;status&quot;
(<code>integer</code>).</p>
</td></tr>
<tr><td><code id="RapData_+3A_species">species</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code> with species data. Columns
must be &quot;name&quot; (<code>character</code>).</p>
</td></tr>
<tr><td><code id="RapData_+3A_targets">targets</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code> with species data.
Columns must be &quot;species&quot; (<code>integer</code>), &quot;target&quot; (<code>integer</code>),
&quot;proportion&quot; (<code>numeric</code>).</p>
</td></tr>
<tr><td><code id="RapData_+3A_pu.species.probabilities">pu.species.probabilities</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code> with data on
the probability of species in each planning unit. Columns must be
&quot;species&quot;, (<code>integer</code>), &quot;pu&quot; (<code>integer</code>), and &quot;value&quot;
(<code>numeric</code>).</p>
</td></tr>
<tr><td><code id="RapData_+3A_attribute.spaces">attribute.spaces</code></td>
<td>
<p><code>list</code> of <code><a href="#topic+AttributeSpaces">AttributeSpaces()</a></code> objects
with the demand points and planning unit coordinates.</p>
</td></tr>
<tr><td><code id="RapData_+3A_boundary">boundary</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code> with data on the shared
boundary length of planning units. Columns must be &quot;id1&quot;
(<code>integer</code>), &quot;id2&quot; (<code>integer</code>), and &quot;boundary&quot; (<code>integer</code>).</p>
</td></tr>
<tr><td><code id="RapData_+3A_polygons">polygons</code></td>
<td>
<p><code><a href="PBSmapping.html#topic+PolySet">PBSmapping::PolySet()</a></code> planning unit spatial data
or <code>NULL</code> if data not available.</p>
</td></tr>
<tr><td><code id="RapData_+3A_skipchecks">skipchecks</code></td>
<td>
<p><code>logical</code> Skip data integrity checks? May improve
speed for big data sets.</p>
</td></tr>
<tr><td><code id="RapData_+3A_.cache">.cache</code></td>
<td>
<p><code><a href="base.html#topic+environment">base::environment()</a></code> used to cache calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>RapData</code> object.
</p>


<h3>Note</h3>

<p>Generally, users are not encouraged to change arguments to
<code>.cache</code>.
</p>


<h3>See Also</h3>

<p><code><a href="PBSmapping.html#topic+PolySet">PBSmapping::PolySet()</a></code>, <code><a href="sp.html#topic+SpatialPoints">sp::SpatialPoints()</a></code>,
<code><a href="sp.html#topic+SpatialPoints">sp::SpatialPointsDataFrame()</a></code>, <code><a href="#topic+make.RapData">make.RapData()</a></code>,
<a href="#topic+RapData-class">RapData</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
cs_pus &lt;- sf::read_sf(
 system.file("extdata", "cs_pus.gpkg", package = "raptr")
)
cs_spp &lt;- terra::rast(
  system.file("extdata", "cs_spp.tif", package = "raptr")
)
cs_space &lt;- terra::rast(
  system.file("extdata", "cs_space.tif", package = "raptr")
)

# create data for RapData object
attribute.spaces &lt;- list(
  AttributeSpaces(name = "geographic", list(
    AttributeSpace(
      planning.unit.points = PlanningUnitPoints(
        suppressWarnings(
          sf::st_coordinates(sf::st_centroid(cs_pus[1:10, ]))
        ),
        seq_len(10)
      ),
      demand.points = make.DemandPoints(
        randomPoints(cs_spp[[1]], n = 10, prob = TRUE)
      ),
      species = 1L
    ))
  ),
  AttributeSpaces(name = "environmental", list(
    AttributeSpace(
      planning.unit.points = PlanningUnitPoints(
        as.matrix(terra::extract(
          cs_space[[1]], as(cs_pus[1:10, ], "SpatVector"),
          fun = "mean",
          ID = FALSE
        )),
        seq_len(10)
      ),
      demand.points = make.DemandPoints(
        as.matrix(terra::as.data.frame(cs_space[[1]], na.rm = TRUE))
      ),
      species = 1L
    )
 ))
)
pu.species.probabilities &lt;- calcSpeciesAverageInPus(
  cs_pus[1:10,], cs_spp[[1]]
)
polygons &lt;- convert2PolySet(cs_pus[1:10, ])
boundary &lt;- calcBoundaryData(cs_pus[1:10, ])

# create RapData object
x &lt;- RapData(
  pu = cs_pus[1:10, ], species = data.frame(name = "test"),
  target = data.frame(species = 1L, target = 0:2, proportion = 0.2),
  pu.species.probabilities = pu.species.probabilities,
  attribute.spaces = attribute.spaces,
  polygons = polygons,
  boundary = boundary
)

# print object
print(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='RapData-class'>RapData: An S4 class to represent RAP input data</h2><span id='topic+RapData-class'></span>

<h3>Description</h3>

<p>This class is used to store RAP input data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>polygons</code></dt><dd><p><code><a href="PBSmapping.html#topic+PolySet">PBSmapping::PolySet()</a></code> planning unit spatial data
or <code>NULL</code> if data not available.</p>
</dd>
<dt><code>pu</code></dt><dd><p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code> planning unit data. Columns must be
&quot;cost&quot; (<code>numeric</code>), &quot;area&quot; (<code>numeric</code>), and &quot;status&quot;
(<code>integer</code>).</p>
</dd>
<dt><code>species</code></dt><dd><p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code> with species data. Columns must
be &quot;name&quot; (<code>character</code>.</p>
</dd>
<dt><code>targets</code></dt><dd><p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code> with species data. Columns must
be &quot;species&quot; (<code>integer</code>), &quot;target&quot; (<code>integer</code>), &quot;proportion&quot;
(<code>numeric</code>).</p>
</dd>
<dt><code>pu.species.probabilities</code></dt><dd><p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code> with data on
the probability of species in each planning unit. Columns must be &quot;species&quot;
(<code>integer</code>), &quot;pu&quot; (<code>integer</code>), and &quot;value&quot; (<code>numeric</code>).</p>
</dd>
<dt><code>attribute.spaces</code></dt><dd><p><code>list</code> of <code>AttributeSpaces</code> objects with
the demand points and planning unit coordinates.</p>
</dd>
<dt><code>boundary</code></dt><dd><p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code> with data on the shared
boundary length of planning units. Columns must be &quot;id1&quot; (<code>integer</code>),
&quot;id2&quot; (<code>integer</code>), and &quot;boundary&quot; (<code>numeric</code>).</p>
</dd>
<dt><code>skipchecks</code></dt><dd><p><code>logical</code> Skip data integrity checks? May improve
speed for big data sets.</p>
</dd>
<dt><code>.cache</code></dt><dd><p><code><a href="base.html#topic+environment">base::environment()</a></code> used to cache calculations.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="PBSmapping.html#topic+PolySet">PBSmapping::PolySet()</a></code>.
</p>

<hr>
<h2 id='RapOpts-class'>RapOpts class</h2><span id='topic+RapOpts-class'></span><span id='topic+RapOpts'></span>

<h3>Description</h3>

<p>Object is either <code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code> or
<code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code>.
</p>

<hr>
<h2 id='RapReliableOpts'>Create RapReliableOpts object</h2><span id='topic+RapReliableOpts'></span>

<h3>Description</h3>

<p>This function creates a new RapReliableOpts object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RapReliableOpts(BLM = 0, failure.multiplier = 1.1, max.r.level = 5L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RapReliableOpts_+3A_blm">BLM</code></td>
<td>
<p><code>numeric</code> boundary length modifier. Defaults to 0.</p>
</td></tr>
<tr><td><code id="RapReliableOpts_+3A_failure.multiplier">failure.multiplier</code></td>
<td>
<p><code>numeric</code> multiplier for failure planning
unit. Defaults to 1.1.</p>
</td></tr>
<tr><td><code id="RapReliableOpts_+3A_max.r.level">max.r.level</code></td>
<td>
<p><code>numeric</code> maximum R failure level for approximation.
Defaults to 5L.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RapReliableOpts</code> object
</p>


<h3>See Also</h3>

<p><a href="#topic+RapReliableOpts-class">RapReliableOpts</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create RapReliableOpts using defaults
RapReliableOpts(BLM = 0, failure.multiplier = 1.1, max.r.level = 5L)

## End(Not run)
</code></pre>

<hr>
<h2 id='RapReliableOpts-class'>RapReliableOpts: An S4 class to represent input parameters for the reliable
formulation of RAP.</h2><span id='topic+RapReliableOpts-class'></span>

<h3>Description</h3>

<p>This class is used to store input parameters for the reliable formulation of
RAP.
</p>


<h3>Slots</h3>


<dl>
<dt><code>BLM</code></dt><dd><p><code>numeric</code> boundary length modifier. Defaults to 0.</p>
</dd>
<dt><code>failure.multiplier</code></dt><dd><p><code>numeric</code> multiplier for failure planning
unit. Defaults to 1.1.</p>
</dd>
<dt><code>max.r.level</code></dt><dd><p><code>numeric</code> maximum R failure level for approximation.
Defaults to 5L.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code>.
</p>

<hr>
<h2 id='RapResults'>Create RapResults object</h2><span id='topic+RapResults'></span>

<h3>Description</h3>

<p>This function creates a new <code><a href="#topic+RapResults">RapResults()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RapResults(
  summary,
  selections,
  amount.held,
  space.held,
  logging.file,
  .cache = new.env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RapResults_+3A_summary">summary</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code> with summary information on
solutions. See details below for more information.</p>
</td></tr>
<tr><td><code id="RapResults_+3A_selections">selections</code></td>
<td>
<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> with binary selections. The
cell <code class="reqn">x_{ij}</code> denotes if planning unit <code class="reqn">j</code> is selected in the
<code class="reqn">i</code>'th solution.</p>
</td></tr>
<tr><td><code id="RapResults_+3A_amount.held">amount.held</code></td>
<td>
<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> with the amount held for each
species in each solution.</p>
</td></tr>
<tr><td><code id="RapResults_+3A_space.held">space.held</code></td>
<td>
<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> with the proportion of
attribute space sampled for each species in each solution.</p>
</td></tr>
<tr><td><code id="RapResults_+3A_logging.file">logging.file</code></td>
<td>
<p><code>character</code> Gurobi log files.</p>
</td></tr>
<tr><td><code id="RapResults_+3A_.cache">.cache</code></td>
<td>
<p><code><a href="base.html#topic+environment">base::environment()</a></code> used to cache calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>summary</code> table follows Marxan conventions (
<a href="https://marxansolutions.org/">https://marxansolutions.org/</a>). The columns
are:
</p>

<dl>
<dt>Run_Number</dt><dd><p>The index of each solution in the object.</p>
</dd>
<dt>Status</dt><dd><p>The status of the solution. The values in this column
correspond to outputs from the Gurobi software package (<a href="https://www.gurobi.com/documentation/6.5/refman/optimization_status_codes.html">https://www.gurobi.com/documentation/6.5/refman/optimization_status_codes.html</a>).</p>
</dd>
<dt>Score</dt><dd><p>The objective function for the solution.</p>
</dd>
<dt>Cost</dt><dd><p>Total cost associated with a solution.</p>
</dd>
<dt>Planning_Units</dt><dd><p>Number of planning units selected in a solution.</p>
</dd>
<dt>Connectivity_Total</dt><dd><p>The total amount of shared boundary length between
all planning units. All solutions in the same object should have equal
values for this column.</p>
</dd>
<dt>Connectivity_In</dt><dd><p>The amount of shared boundary length among planning
units selected in the solution.</p>
</dd>
<dt>Connectivity_Edge</dt><dd><p>The amount of exposed boundary length in the
solution.</p>
</dd>
<dt>Connectivity_Out</dt><dd><p>The number of shared boundary length among planning
units not selected in the solution.</p>
</dd>
<dt>Connectivity_Fraction</dt><dd><p>The ratio of shared boundary length in the
solution (<code>Connectivity_In</code>) to the total amount of boundary length
(<code>Connectivity_Edge</code>). This ratio is an indicator of solution quality.
Solutions with a lower ratio will have less planning units and will be more
efficient.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>RapResults</code> object
</p>


<h3>Note</h3>

<p>slot <code>best</code> is automatically determined based on data in
<code>summary</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+RapResults-class">RapResults</a> <code><a href="#topic+read.RapResults">read.RapResults()</a></code>.
</p>

<hr>
<h2 id='RapResults-class'>RapResults: An S4 class to represent RAP results</h2><span id='topic+RapResults-class'></span>

<h3>Description</h3>

<p>This class is used to store RAP results.
</p>


<h3>Details</h3>

<p>The <code>summary</code> table follows Marxan conventions
(<a href="https://marxansolutions.org/">https://marxansolutions.org/</a>). The columns
are:
</p>

<dl>
<dt>Run_Number</dt><dd><p>The index of each solution in the object.</p>
</dd>
<dt>Status</dt><dd><p>The status of the solution. The values in this column
correspond to outputs from the Gurobi software package (<a href="https://www.gurobi.com/documentation/6.5/refman/optimization_status_codes.html">https://www.gurobi.com/documentation/6.5/refman/optimization_status_codes.html</a>).</p>
</dd>
<dt>Score</dt><dd><p>The objective function for the solution.</p>
</dd>
<dt>Cost</dt><dd><p>Total cost associated with a solution.</p>
</dd>
<dt>Planning_Units</dt><dd><p>Number of planning units selected in a solution.</p>
</dd>
<dt>Connectivity_Total</dt><dd><p>The total amount of shared boundary length between
all planning units. All solutions in the same object should have equal
values for this column.</p>
</dd>
<dt>Connectivity_In</dt><dd><p>The amount of shared boundary length among planning
units selected in the solution.</p>
</dd>
<dt>Connectivity_Edge</dt><dd><p>The amount of exposed boundary length in the
solution.</p>
</dd>
<dt>Connectivity_Out</dt><dd><p>The number of shared boundary length among planning
units not selected in the solution.</p>
</dd>
<dt>Connectivity_Fraction</dt><dd><p>The ratio of shared boundary length in the
solution (<code>Connectivity_In</code>) to the total amount of boundary length
(<code>Connectivity_Edge</code>). This ratio is an indicator of solution quality.
Solutions with a lower ratio will have less planning units and will be more
efficient.</p>
</dd>
</dl>



<h3>Slots</h3>


<dl>
<dt><code>summary</code></dt><dd><p><code><a href="base.html#topic+data.frame">base::data.frame()</a></code> with summary information on
solutions.</p>
</dd>
<dt><code>selections</code></dt><dd><p><code><a href="base.html#topic+matrix">base::matrix()</a></code> with binary selections. The cell
<code class="reqn">x_{ij}</code> denotes if planning unit <code class="reqn">j</code> is selected in the
<code class="reqn">i</code>'th solution.</p>
</dd>
<dt><code>amount.held</code></dt><dd><p><code><a href="base.html#topic+matrix">base::matrix()</a></code> with the amount held for each
species in each solution.</p>
</dd>
<dt><code>space.held</code></dt><dd><p><code><a href="base.html#topic+matrix">base::matrix()</a></code> with the proportion of attribute
space sampled for each species in each solution.</p>
</dd>
<dt><code>best</code></dt><dd><p><code>integer</code> with index of best solution.</p>
</dd>
<dt><code>logging.file</code></dt><dd><p><code>character</code> Gurobi log files.</p>
</dd>
<dt><code>.cache</code></dt><dd><p><code><a href="base.html#topic+environment">base::environment()</a></code> used to store extra data.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+RapResults">RapResults()</a></code>, <code><a href="#topic+read.RapResults">read.RapResults()</a></code>.
</p>

<hr>
<h2 id='RapSolved'>Create new RapSolved object</h2><span id='topic+RapSolved'></span>

<h3>Description</h3>

<p>This function creates a <code><a href="#topic+RapSolved">RapSolved()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RapSolved(unsolved, solver, results)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RapSolved_+3A_unsolved">unsolved</code></td>
<td>
<p><code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="RapSolved_+3A_solver">solver</code></td>
<td>
<p><code><a href="#topic+GurobiOpts">GurobiOpts()</a></code> or <code><a href="#topic+ManualOpts">ManualOpts()</a></code> object.</p>
</td></tr>
<tr><td><code id="RapSolved_+3A_results">results</code></td>
<td>
<p><code><a href="#topic+RapResults">RapResults()</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+RapSolved">RapSolved()</a></code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+RapSolved-class">RapSolved</a>, <a href="#topic+RapResults-class">RapResults</a>,
<code>link{solve}</code>.
</p>

<hr>
<h2 id='RapSolved-class'>RapSolved: An S4 class to represent RAP inputs and outputs</h2><span id='topic+RapSolved-class'></span>

<h3>Description</h3>

<p>This class is used to store RAP input and output data in addition to input
parameters.
</p>


<h3>Slots</h3>


<dl>
<dt><code>opts</code></dt><dd><p><code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code> or <code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code>
object used to store input parameters.</p>
</dd>
<dt><code>solver</code></dt><dd><p><code><a href="#topic+GurobiOpts">GurobiOpts()</a></code> or <code><a href="#topic+ManualOpts">ManualOpts()</a></code> object
used to store solver information/parameters.</p>
</dd>
<dt><code>data</code></dt><dd><p><code><a href="#topic+RapData">RapData()</a></code> object used to store input data.</p>
</dd>
<dt><code>results</code></dt><dd><p><code><a href="#topic+RapResults">RapResults()</a></code> object used to store results.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+RapReliableOpts-class">RapReliableOpts</a>,
<a href="#topic+RapUnreliableOpts-class">RapUnreliableOpts</a>, <a href="#topic+RapData-class">RapData</a>,
<a href="#topic+RapResults-class">RapResults</a>.
</p>

<hr>
<h2 id='raptr-deprecated'>Deprecation notice</h2><span id='topic+raptr-deprecated'></span><span id='topic+SpatialPolygons2PolySet'></span>

<h3>Description</h3>

<p>The functions listed here are deprecated.
This means that they once existed in earlier versions of the
of the <span class="pkg">raptr</span> package, but they have since been removed
entirely, replaced by other functions, or renamed as other functions
in newer versions.
To help make it easier to transition to new versions of the <span class="pkg">raptr</span>
package, we have listed alternatives for deprecated the functions
(where applicable).
If a function is described as being renamed, then this means
that only the name of the function has changed
(i.e., the inputs, outputs, and underlying code remain the same).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpatialPolygons2PolySet(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raptr-deprecated_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following functions have been deprecated:
</p>

<dl>
<dt><code>SpatialPolygons2PolySet()</code></dt><dd><p>renamed
as the <code><a href="#topic+convert2PolySet">convert2PolySet()</a></code> function.</p>
</dd>
</dl>


<hr>
<h2 id='RapUnreliableOpts'>Create RapUnreliableOpts object</h2><span id='topic+RapUnreliableOpts'></span>

<h3>Description</h3>

<p>This function creates a new RapUnreliableOpts object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RapUnreliableOpts(BLM = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RapUnreliableOpts_+3A_blm">BLM</code></td>
<td>
<p><code>numeric</code> boundary length modifier. Defaults to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code> object
</p>


<h3>See Also</h3>

<p><a href="#topic+RapUnreliableOpts-class">RapUnreliableOpts</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create RapUnreliableOpts using defaults
RapUnreliableOpts(BLM = 0)

## End(Not run)
</code></pre>

<hr>
<h2 id='RapUnreliableOpts-class'>RapUnreliableOpts: An S4 class to represent parameters for the unreliable
RAP problem</h2><span id='topic+RapUnreliableOpts-class'></span>

<h3>Description</h3>

<p>This class is used to store input parameters for the unreliable RAP problem
formulation.
</p>


<h3>Slots</h3>


<dl>
<dt><code>BLM</code></dt><dd><p><code>numeric</code> boundary length modifier. Defaults to 0.</p>
</dd>
</dl>

<hr>
<h2 id='RapUnsolved'>Create a new RapUnsolved object</h2><span id='topic+RapUnsolved'></span>

<h3>Description</h3>

<p>This function creates a <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> object using a
<code><a href="#topic+GurobiOpts">GurobiOpts()</a></code>, a <code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code> or
<code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code> object, and a <code><a href="#topic+RapData">RapData()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RapUnsolved(opts, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RapUnsolved_+3A_opts">opts</code></td>
<td>
<p><code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code> or <code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code>
object.</p>
</td></tr>
<tr><td><code id="RapUnsolved_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+RapData">RapData()</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+RapReliableOpts-class">RapReliableOpts</a>,
<a href="#topic+RapUnreliableOpts-class">RapUnreliableOpts</a>, <a href="#topic+RapData-class">RapData</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set random number generator seed
set.seed(500)

# load data
cs_pus &lt;- sf::read_sf(
 system.file("extdata", "cs_pus.gpkg", package = "raptr")
)
cs_spp &lt;- terra::rast(
  system.file("extdata", "cs_spp.tif", package = "raptr")
)

# create inputs for RapUnsolved
ro &lt;- RapUnreliableOpts()
rd &lt;- make.RapData(cs_pus[seq_len(10), ], cs_spp, NULL,
                   include.geographic.space = TRUE,n.demand.points = 5L)

# create RapUnsolved object
ru &lt;- RapUnsolved(ro, rd)

# print object
print(ru)

## End(Not run)
</code></pre>

<hr>
<h2 id='RapUnsolved-class'>RapUnsolved: An S4 class to represent RAP inputs</h2><span id='topic+RapUnsolved-class'></span>

<h3>Description</h3>

<p>This class is used to store RAP input data and input parameters.
</p>


<h3>Slots</h3>


<dl>
<dt><code>opts</code></dt><dd><p><code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code> or <code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code>
object used to store input parameters.</p>
</dd>
<dt><code>data</code></dt><dd><p><code><a href="#topic+RapData">RapData()</a></code> object used to store input data.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+RapReliableOpts-class">RapReliableOpts</a>,
<a href="#topic+RapUnreliableOpts-class">RapUnreliableOpts</a>, <a href="#topic+RapData-class">RapData</a>.
</p>

<hr>
<h2 id='read.RapResults'>Read RAP results</h2><span id='topic+read.RapResults'></span>

<h3>Description</h3>

<p>This function reads files output from Gurobi and returns a <code>RapResults</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.RapResults(
  opts,
  data,
  model.list,
  logging.file,
  solution.list,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.RapResults_+3A_opts">opts</code></td>
<td>
<p><code>RapReliableOpts</code> or <code>RapUnreliableOpts</code> object</p>
</td></tr>
<tr><td><code id="read.RapResults_+3A_data">data</code></td>
<td>
<p><code>RapData</code> object</p>
</td></tr>
<tr><td><code id="read.RapResults_+3A_model.list">model.list</code></td>
<td>
<p><code>list</code> object containing Gurobi model data</p>
</td></tr>
<tr><td><code id="read.RapResults_+3A_logging.file">logging.file</code></td>
<td>
<p><code>character</code> Gurobi log files.</p>
</td></tr>
<tr><td><code id="read.RapResults_+3A_solution.list">solution.list</code></td>
<td>
<p><code>list</code> object containing Gurobi solution data.</p>
</td></tr>
<tr><td><code id="read.RapResults_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> print progress messages? Defaults to
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RapResults</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code>, <code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code>,
<code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapResults">RapResults()</a></code>.
</p>

<hr>
<h2 id='rrap.proportion.held'>Proportion held using reliable RAP formulation.</h2><span id='topic+rrap.proportion.held'></span>

<h3>Description</h3>

<p>This is a convenience function to quickly calculate the proportion of
variation that one set of points captures in a another set of points using
the reliable formulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrap.proportion.held(
  pu.coordinates,
  pu.probabilities,
  dp.coordinates,
  dp.weights,
  failure.distance,
  maximum.r.level = as.integer(length(pu.probabilities))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rrap.proportion.held_+3A_pu.coordinates">pu.coordinates</code></td>
<td>
<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> of planning unit
coordinates.</p>
</td></tr>
<tr><td><code id="rrap.proportion.held_+3A_pu.probabilities">pu.probabilities</code></td>
<td>
<p><code>numeric</code> vector of planning unit probabilities.</p>
</td></tr>
<tr><td><code id="rrap.proportion.held_+3A_dp.coordinates">dp.coordinates</code></td>
<td>
<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> of demand point coordinates.</p>
</td></tr>
<tr><td><code id="rrap.proportion.held_+3A_dp.weights">dp.weights</code></td>
<td>
<p><code>numeric</code> vector of demand point weights.</p>
</td></tr>
<tr><td><code id="rrap.proportion.held_+3A_failure.distance">failure.distance</code></td>
<td>
<p><code>numeric</code> indicating the cost of the failure
planning unit.</p>
</td></tr>
<tr><td><code id="rrap.proportion.held_+3A_maximum.r.level">maximum.r.level</code></td>
<td>
<p><code>integer</code> maximum failure (R) level to use for
calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> value indicating the proportion of variation that the
demand points explain in the planning units
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rrap.proportion.held(as.matrix(iris[1:2,-5]), runif(1:2),
                     as.matrix(iris[1:5,-5]), runif(1:5), 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='score'>Solution score</h2><span id='topic+score'></span><span id='topic+score.RapResults'></span><span id='topic+score.RapSolved'></span>

<h3>Description</h3>

<p>Extract solution score from <code><a href="#topic+RapResults">RapResults()</a></code> or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score(x, y)

## S3 method for class 'RapResults'
score(x, y = 0)

## S3 method for class 'RapSolved'
score(x, y = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapResults">RapResults()</a></code> or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="score_+3A_y">y</code></td>
<td>
<p>Available inputs include: <code>NULL</code> to return all scores,
<code>integer</code> number specifying the solution for which the score should
be returned, and <code>0</code> to return score for the best solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> or <code>numeric</code> vector with solution score(s)
depending on arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapResults">RapResults()</a></code>, <code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_rs)

# score for the best solution
score(sim_rs, 0)

# score for the second solution
score(sim_rs, 2)

# score for all solutions
score(sim_rs, NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='selections'>Extract solution selections</h2><span id='topic+selections'></span><span id='topic+selections.RapResults'></span><span id='topic+selections.RapSolved'></span>

<h3>Description</h3>

<p>Extract selections for a given solution from a <code><a href="#topic+RapResults">RapResults()</a></code> or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selections(x, y)

## S3 method for class 'RapResults'
selections(x, y = 0)

## S3 method for class 'RapSolved'
selections(x, y = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selections_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapResults">RapResults()</a></code> or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="selections_+3A_y">y</code></td>
<td>
<p><code>NULL</code> to return all values, <code>integer</code> 0 to return values
for the best solution, <code>integer</code> value greater than 0 for <code>y</code>'th
solution value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> or <code>numeric</code> vector depending on
arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapResults">RapResults()</a></code>, <code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_rs)

# selections for the best solution
selections(sim_rs, 0)

# selections for the second solution
selections(sim_rs, 2)

# selections for each solution
selections(sim_rs)

## End(Not run)
</code></pre>

<hr>
<h2 id='show'>Show objects</h2><span id='topic+show'></span><span id='topic+show+2CGurobiOpts-method'></span><span id='topic+show+2CManualOpts-method'></span><span id='topic+show+2CRapData-method'></span><span id='topic+show+2CRapReliableOpts-method'></span><span id='topic+show+2CRapResults-method'></span><span id='topic+show+2CRapUnreliableOpts-method'></span><span id='topic+show+2CRapUnsolved-method'></span><span id='topic+show+2CRapSolved-method'></span>

<h3>Description</h3>

<p>Shows objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GurobiOpts'
show(object)

## S4 method for signature 'ManualOpts'
show(object)

## S4 method for signature 'RapData'
show(object)

## S4 method for signature 'RapReliableOpts'
show(object)

## S4 method for signature 'RapResults'
show(object)

## S4 method for signature 'RapUnreliableOpts'
show(object)

## S4 method for signature 'RapUnsolved'
show(object)

## S4 method for signature 'RapSolved'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+GurobiOpts">GurobiOpts()</a></code>, <code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code>,
<code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code>, <code><a href="#topic+RapData">RapData()</a></code>,
<code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, <code><a href="#topic+RapResults">RapResults()</a></code>, or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GurobiOpts">GurobiOpts()</a></code>, <code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code>,
<code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code>, <code><a href="#topic+RapData">RapData()</a></code>,
<code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, <code><a href="#topic+RapResults">RapResults()</a></code>,
<code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_ru, sim_rs)

# show GurobiOpts object
GurobiOpts()

# show RapReliableOpts object
RapReliableOpts()

# show RapUnreliableOpts object
RapUnreliableOpts()

# show RapData object
sim_ru@data

# show RapUnsolved object
sim_ru

# show RapResults object
sim_rs@results

# show RapSolved object
sim_rs

## End(Not run)
</code></pre>

<hr>
<h2 id='sim.pus'>Simulate planning units</h2><span id='topic+sim.pus'></span>

<h3>Description</h3>

<p>This function simulates planning units for RAP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.pus(
  n,
  xmn = -sqrt(n)/2,
  xmx = sqrt(n)/2,
  ymn = -sqrt(n)/2,
  ymx = sqrt(n)/2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.pus_+3A_n">n</code></td>
<td>
<p><code>integer</code> number of planning units. Note <code>sqrt(n)</code> must yield
a valid number.</p>
</td></tr>
<tr><td><code id="sim.pus_+3A_xmn">xmn</code></td>
<td>
<p><code>numeric</code> value for minimum x-coordinate.</p>
</td></tr>
<tr><td><code id="sim.pus_+3A_xmx">xmx</code></td>
<td>
<p><code>numeric</code> value for maximum x-coordinate.</p>
</td></tr>
<tr><td><code id="sim.pus_+3A_ymn">ymn</code></td>
<td>
<p><code>numeric</code> value for minimum y-coordinate.</p>
</td></tr>
<tr><td><code id="sim.pus_+3A_ymx">ymx</code></td>
<td>
<p><code>numeric</code> value for maximum y-coordinate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Square planning units are generated in the shape of a square.
Default coordinate arguments are such that the planning units will be
centered at origin. The data slot contains an &quot;id&quot; (<code>integer</code>),
&quot;cost&quot; (<code>numeric</code>), &quot;status&quot; (<code>integer</code>), and &quot;area&quot;
(<code>numeric</code>).
</p>


<h3>Value</h3>

<p><code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code> with planning units.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate 225 square planning units arranged in a square
# with 1 unit height / width
x &lt;- sim.pus(225)

# generate 225 rectangular pus arranged in a square
y &lt;- sim.pus(225, xmn = -5, xmx = 10, ymn = -5, ymx = 5)
par(mfrow = c(1, 2))
plot(x, main = "x")
plot(y, main = "y")
par(mfrow = c(1, 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='sim.space'>Simulate attribute space data for RAP</h2><span id='topic+sim.space'></span><span id='topic+sim.space.SpatRaster'></span><span id='topic+sim.space.SpatialPolygons'></span><span id='topic+sim.space.sf'></span>

<h3>Description</h3>

<p>This function simulates attribute space data for RAP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.space(x, ...)

## S3 method for class 'SpatRaster'
sim.space(x, d = 2, model = 0.2, ...)

## S3 method for class 'SpatialPolygons'
sim.space(x, res, d = 2, model = 0.2, ...)

## S3 method for class 'sf'
sim.space(x, res, d = 2, model = 0.2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.space_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> or <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> object delineating
the spatial extent for the study area.</p>
</td></tr>
<tr><td><code id="sim.space_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="sim.space_+3A_d">d</code></td>
<td>
<p><code>integer</code> number of dimensions. Defaults to 2.</p>
</td></tr>
<tr><td><code id="sim.space_+3A_model">model</code></td>
<td>
<p><code>numeric</code> scale parameter for simulating spatially
auto-correlated data using Gaussian random fields.
Higher values produce patchier data with more well defined clusters,
and lower values produce more evenly distributed data.
Defaults to 0.2.</p>
</td></tr>
<tr><td><code id="sim.space_+3A_res">res</code></td>
<td>
<p><code>numeric</code> resolution to simulate distributions. Only needed
when <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> are supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> with layers for each dimension of the space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simulate planning units
sim_pus &lt;- sim.pus(225L)

# simulate 1d space using SpatRaster
s1 &lt;- sim.space(blank.raster(sim_pus, 1), d = 1)

# simulate 1d space using sf
s2 &lt;- sim.space(sim_pus, res = 1, d = 1)

# simulate 2d space using sf
s3 &lt;- sim.space(sim_pus, res = 1, d = 2)

# plot simulated spaces
par(mfrow = c(2,2))
plot(s1, main = "s1")
plot(s2, main = "s2")
plot(s3[[1]], main = "s3: first dimension")
plot(s3[[2]], main = "s3: second dimension")

## End(Not run)
</code></pre>

<hr>
<h2 id='sim.species'>Simulate species distribution data for RAP</h2><span id='topic+sim.species'></span><span id='topic+sim.species.SpatRaster'></span><span id='topic+sim.species.SpatialPolygons'></span><span id='topic+sim.species.sf'></span>

<h3>Description</h3>

<p>This function simulates species distributions for RAP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.species(x, ...)

## S3 method for class 'SpatRaster'
sim.species(x, n = 1, model = "normal", ...)

## S3 method for class 'SpatialPolygons'
sim.species(x, res, n = 1, model = "normal", ...)

## S3 method for class 'sf'
sim.species(x, res, n = 1, model = "normal", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.species_+3A_x">x</code></td>
<td>
<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> or <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> object delineating
the spatial extent for the study area.</p>
</td></tr>
<tr><td><code id="sim.species_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="sim.species_+3A_n">n</code></td>
<td>
<p><code>integer</code> number of species. Defaults to 1.</p>
</td></tr>
<tr><td><code id="sim.species_+3A_model">model</code></td>
<td>
<p><code>character</code> or <code>numeric</code> for simulating data.
If a <code>character</code> value is supplied, then the following values can
can be used to simulate species distributions with particular
characteristics:
<code>"uniform"</code>, <code>"normal"</code>, and <code>"bimodal"</code>.
If a <code>numeric</code> value is supplied, then this is used to simulate
species distributions using a Gaussian random field, where the
<code>numeric</code> value is treated as the scale parameter.
Defaults to <code>"normal"</code>.</p>
</td></tr>
<tr><td><code id="sim.species_+3A_res">res</code></td>
<td>
<p><code>numeric</code> resolution to simulate distributions. Only needed
when <code><a href="sf.html#topic+sf">sf::st_sf()</a></code> are supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> with layers for each species.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# make polygons
sim_pus &lt;- sim.pus(225L)

# simulate 1 uniform species distribution using SpatRaster
s1 &lt;- sim.species(blank.raster(sim_pus, 1), n = 1, model = "uniform")

# simulate 1 uniform species distribution based on sf
s2 &lt;- sim.species(sim_pus, res = 1, n = 1, model = "uniform")

# simulate 1 normal species distributions
s3 &lt;- sim.species(sim_pus, res = 1, n = 1, model = "normal")

# simulate 1 bimodal species distribution
s4 &lt;- sim.species(sim_pus, res = 1, n = 1, model = "bimodal")

# simulate 1 species distribution using a random field
s5 &lt;- sim.species(sim_pus, res = 1, n = 1, model = 0.2)

# plot simulations
par(mfrow = c(2,2))
plot(s2, main = "constant")
plot(s3, main = "normal")
plot(s4, main = "bimodal")
plot(s5, main = "random field")

## End(Not run)
</code></pre>

<hr>
<h2 id='simulated_data'>Simulated dataset for a conservation planning exercise</h2><span id='topic+simulated_data'></span><span id='topic+sim_ru'></span><span id='topic+sim_rs'></span>

<h3>Description</h3>

<p>This dataset contains all the data needed to generate prioritizations for
three simulated species. This dataset contains planning units, species
distribution maps, and demand points for each species. For the purposes of
exploring the behaviour of the problem, demand points were generated using
the centroids of planning units and the probability that they are occupied
by the species. Note that methodology is not encouraged for real-world
conservation planning.
</p>


<h3>Format</h3>


<dl>
<dt>sim_ru</dt><dd><p><code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> object with all the simulated data.</p>
</dd>
<dt>sim_rs</dt><dd><p><code><a href="#topic+RapSolved">RapSolved()</a></code> object with 5 near-optimal solutions.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The species were simulated to represent various simplified species
distributions.
</p>

<dl>
<dt>uniform</dt><dd><p>This species has an equal probability (0.5) of occurring in
all planning units.</p>
</dd>
<dt>normal</dt><dd><p>This species has a single range-core where it is most likely
to be found. It is less likely to be found in areas further
away from the center of its range.</p>
</dd>
<dt>bimodal</dt><dd><p>This species has two distinct ecotypes. Each ecotype has its
own core and marginal area.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_ru, sim_rs)

# plot species distributions
spp.plot(sim_ru, 1)
spp.plot(sim_ru, 2)
spp.plot(sim_ru, 3)

# plot selection frequencies
plot(sim_rs)

# plot best solution
plot(sim_rs, 0)

## End(Not run)
</code></pre>

<hr>
<h2 id='solve'>Solve RAP object</h2><span id='topic+solve'></span><span id='topic+solve+2CRapUnsolOrSol+2Cmissing-method'></span><span id='topic+solve+2CRapUnsolOrSol+2CGurobiOpts-method'></span><span id='topic+solve+2CRapUnsolOrSol+2Cmatrix-method'></span><span id='topic+solve+2CRapUnsolOrSol+2Cnumeric-method'></span><span id='topic+solve+2CRapUnsolOrSol+2Clogical-method'></span>

<h3>Description</h3>

<p>This function uses Gurobi to find prioritizations using the input parameter
and data stored in a <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> object, and returns a
<code><a href="#topic+RapSolved">RapSolved()</a></code> object with outputs in it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RapUnsolOrSol,missing'
solve(a, b, ..., verbose = FALSE)

## S4 method for signature 'RapUnsolOrSol,GurobiOpts'
solve(a, b, verbose = FALSE)

## S4 method for signature 'RapUnsolOrSol,matrix'
solve(a, b, verbose = FALSE)

## S4 method for signature 'RapUnsolOrSol,numeric'
solve(a, b, verbose = FALSE)

## S4 method for signature 'RapUnsolOrSol,logical'
solve(a, b, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solve_+3A_a">a</code></td>
<td>
<p><code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="solve_+3A_b">b</code></td>
<td>
<p><code>missing</code> to generate solutions using Gurobi. Prioritizations
can be specified using  <code>logical</code>, <code>numeric</code>, or
<code><a href="base.html#topic+matrix">base::matrix()</a></code> objects. This may be useful for evaluating the
performance of solutions obtained using other software.</p>
</td></tr>
<tr><td><code id="solve_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="solve_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> should messages be printed during creation of
the initial model matrix?.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+RapSolved">RapSolved()</a></code> object
</p>


<h3>Note</h3>

<p>This function is used to solve a <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> object that
has all of its inputs generated. The rap function (without lower case 'r')
provides a more general interface for generating inputs and outputs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, <code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load RapUnsolved object
data(sim_ru)
# solve it using Gurobi
sim_rs &lt;- solve(sim_ru)

# evaluate manually specified solution using planning unit indices
sim_rs2 &lt;- solve(sim_ru, seq_len(10))

# evaluate manually specifed solution using binary selections
sim_rs3 &lt;- solve(sim_ru, c(rep(TRUE, 10), rep(FALSE, 90)))

#  evaluate multiple manually specified solutions
sim_rs4 &lt;- solve(sim_ru, matrix(sample(c(0, 1), size = 500, replace = TRUE),
                 ncol = 100, nrow = 5))

## End(Not run)
</code></pre>

<hr>
<h2 id='SolverOpts-class'>SolverOpts class</h2><span id='topic+SolverOpts-class'></span><span id='topic+SolverOpts'></span>

<h3>Description</h3>

<p>Object stores parameters used to solve problems.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GurobiOpts">GurobiOpts()</a></code>.
</p>

<hr>
<h2 id='space.held'>Extract attribute space held for a solution</h2><span id='topic+space.held'></span><span id='topic+space.held.RapSolved'></span>

<h3>Description</h3>

<p>This function returns the attribute space held for each species in a
solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>space.held(x, y, species, space)

## S3 method for class 'RapSolved'
space.held(x, y = 0, species = NULL, space = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="space.held_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapResults">RapResults()</a></code> or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="space.held_+3A_y">y</code></td>
<td>
<p>Available inputs include: <code>NULL</code> to return all values,
<code>integer</code> number specifying the solution for which the value should
be returned, and <code>0</code> to return the value for the best solution.</p>
</td></tr>
<tr><td><code id="space.held_+3A_species">species</code></td>
<td>
<p><code>NULL</code> for all species or <code>integer</code> indicating
species.</p>
</td></tr>
<tr><td><code id="space.held_+3A_space">space</code></td>
<td>
<p><code>NULL</code> for all spaces or <code>integer</code> indicating a
specific space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapResults">RapResults()</a></code>, <code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_rs)

# space held (%) for each species in best solution
space.held(sim_rs, 0)

# space held (%) for each species in second solution
space.held(sim_rs, 2)

# space held (%) for each species in each solution
space.held(sim_rs)

## End(Not run)
</code></pre>

<hr>
<h2 id='space.plot'>Plot space</h2><span id='topic+space.plot'></span><span id='topic+space.plot.RapData'></span><span id='topic+space.plot.RapUnsolved'></span><span id='topic+space.plot.RapSolved'></span>

<h3>Description</h3>

<p>This function plots the distribution of planning units and the distribution
of demand points for a particular species in an attribute space.
Note that this function only works for attribute spaces with one, two, or
three dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>space.plot(x, species, space, ...)

## S3 method for class 'RapData'
space.plot(
  x,
  species,
  space = 1,
  pu.color.palette = c("#4D4D4D4D", "#00FF0080", "#FFFF0080", "#FF00004D"),
  main = NULL,
  ...
)

## S3 method for class 'RapUnsolved'
space.plot(
  x,
  species,
  space = 1,
  pu.color.palette = c("#4D4D4D4D", "#00FF0080", "#FFFF0080", "#FF00004D"),
  main = NULL,
  ...
)

## S3 method for class 'RapSolved'
space.plot(
  x,
  species,
  space = 1,
  y = 0,
  pu.color.palette = c("#4D4D4D4D", "#00FF0080", "#FFFF0080", "#FF00004D"),
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="space.plot_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="space.plot_+3A_species">species</code></td>
<td>
<p><code>character</code> name of species, or <code>integer</code> index for
species.</p>
</td></tr>
<tr><td><code id="space.plot_+3A_space">space</code></td>
<td>
<p><code>integer</code> index of attribute space.</p>
</td></tr>
<tr><td><code id="space.plot_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="space.plot_+3A_pu.color.palette">pu.color.palette</code></td>
<td>
<p><code>character</code> vector of colors indicate planning unit
statuses. Defaults to <code>c("grey30", "green", "black", "red")</code> which
indicate not selected, selected, locked in, and locked out (respectively).</p>
</td></tr>
<tr><td><code id="space.plot_+3A_main">main</code></td>
<td>
<p><code>character</code> title for the plot. Defaults to <code>NULL</code> and
a default title is used.</p>
</td></tr>
<tr><td><code id="space.plot_+3A_y">y</code></td>
<td>
<p><code>integer</code> number specifying the solution to be plotted. The
value <code>0</code> can be used to plot the best solution.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load RapSolved objects
data(sim_ru, sim_rs)

# plot first species in first attribute space
space.plot(sim_ru, 1, 1)

# plot distribution of solutions for first species in first attribute space
space.plot(sim_rs, 1, 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='space.target'>Attribute space targets</h2><span id='topic+space.target'></span><span id='topic+space.target+3C-'></span><span id='topic+space.target.RapData'></span><span id='topic+space.target+3C-.RapData'></span><span id='topic+space.target.RapUnsolOrSol'></span><span id='topic+space.target+3C-.RapUnsolOrSol'></span>

<h3>Description</h3>

<p>This function sets or returns the attribute space targets for each species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>space.target(x, species, space)

space.target(x, species, space) &lt;- value

## S3 method for class 'RapData'
space.target(x, species = NULL, space = NULL)

## S3 replacement method for class 'RapData'
space.target(x, species = NULL, space = NULL) &lt;- value

## S3 method for class 'RapUnsolOrSol'
space.target(x, species = NULL, space = NULL)

## S3 replacement method for class 'RapUnsolOrSol'
space.target(x, species = NULL, space = NULL) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="space.target_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="space.target_+3A_species">species</code></td>
<td>
<p><code>NULL</code> for all species or <code>integer</code> indicating species.</p>
</td></tr>
<tr><td><code id="space.target_+3A_space">space</code></td>
<td>
<p><code>NULL</code> for all spaces or <code>integer</code> indicating a space.</p>
</td></tr>
<tr><td><code id="space.target_+3A_value">value</code></td>
<td>
<p><code>numeric</code> new target.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> or <code>matrix</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapResults">RapResults()</a></code>, <code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_rs)

# extract space targets for all species
space.target(sim_rs)

# set space targets for all species
space.target(sim_rs) &lt;- 0.1

# extract target for first species for first space
space.target(sim_rs, 1, 1)

# set space targets for first species for first space
space.target(sim_rs, 1, 1) &lt;- 0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='spp.plot'>Plot species</h2><span id='topic+spp.plot'></span><span id='topic+spp.plot.RapData'></span><span id='topic+spp.plot.RapUnsolved'></span><span id='topic+spp.plot.RapSolved'></span>

<h3>Description</h3>

<p>This function plots the distribution of species across the study area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spp.plot(x, species, ...)

## S3 method for class 'RapData'
spp.plot(
  x,
  species,
  prob.color.palette = "YlGnBu",
  pu.color.palette = c("#4D4D4D", "#00FF00", "#FFFF00", "#FF0000"),
  basemap = "none",
  alpha = ifelse(identical(basemap, "none"), 1, 0.7),
  grayscale = FALSE,
  main = NULL,
  force.reset = FALSE,
  ...
)

## S3 method for class 'RapUnsolved'
spp.plot(
  x,
  species,
  prob.color.palette = "YlGnBu",
  pu.color.palette = c("#4D4D4D", "#00FF00", "#FFFF00", "#FF0000"),
  basemap = "none",
  alpha = ifelse(basemap == "none", 1, 0.7),
  grayscale = FALSE,
  main = NULL,
  force.reset = FALSE,
  ...
)

## S3 method for class 'RapSolved'
spp.plot(
  x,
  species,
  y = 0,
  prob.color.palette = "YlGnBu",
  pu.color.palette = c("#4D4D4D", "#00FF00", "#FFFF00", "#FF0000"),
  basemap = "none",
  alpha = ifelse(basemap == "none", 1, 0.7),
  grayscale = FALSE,
  main = NULL,
  force.reset = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spp.plot_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="spp.plot_+3A_species">species</code></td>
<td>
<p><code>character</code> name of species, or <code>integer</code> index for
species.</p>
</td></tr>
<tr><td><code id="spp.plot_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="spp.plot_+3A_prob.color.palette">prob.color.palette</code></td>
<td>
<p><code>character</code> name of color palette to denote
probability of occupancy of the species in planning units (see
<code><a href="RColorBrewer.html#topic+ColorBrewer">RColorBrewer::brewer.pal()</a></code>). Defaults to <code>"YlGnBu"</code>.</p>
</td></tr>
<tr><td><code id="spp.plot_+3A_pu.color.palette">pu.color.palette</code></td>
<td>
<p><code>character</code> vector of colors to indicate planning
unit statuses. Defaults to <code>c("grey30", "green", "black", "red")</code> which
indicate not selected, selected, locked in, and locked out (respectively).</p>
</td></tr>
<tr><td><code id="spp.plot_+3A_basemap">basemap</code></td>
<td>
<p><code>character</code> object indicating the type of basemap to use
(see <code><a href="#topic+basemap">basemap()</a></code>). Valid options include <code>"none"</code>,
<code>"roadmap"</code>, <code>"mobile"</code>, <code>"satellite"</code>, <code>"terrain"</code>,
<code>"hybrid"</code>, <code>"mapmaker-roadmap"</code>, <code>"mapmaker-hybrid"</code>.
Defaults to <code>"none"</code> such that no basemap is shown.</p>
</td></tr>
<tr><td><code id="spp.plot_+3A_alpha">alpha</code></td>
<td>
<p><code>numeric</code> value to indicating the transparency level for
coloring the planning units.</p>
</td></tr>
<tr><td><code id="spp.plot_+3A_grayscale">grayscale</code></td>
<td>
<p><code>logical</code> should the basemap be gray-scaled?</p>
</td></tr>
<tr><td><code id="spp.plot_+3A_main">main</code></td>
<td>
<p><code>character</code> title for the plot. Defaults to <code>NULL</code> and
a default title is used.</p>
</td></tr>
<tr><td><code id="spp.plot_+3A_force.reset">force.reset</code></td>
<td>
<p><code>logical</code> if basemap data has been cached, should it
be re-downloaded?</p>
</td></tr>
<tr><td><code id="spp.plot_+3A_y">y</code></td>
<td>
<p><code>NULL</code> <code>integer</code> 0 to return values for the best
solution, <code>integer</code> value greater than 0 for <code>y</code>'th solution
value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the <span class="pkg">RgoogleMaps</span> package to be installed
in order to create display a basemap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load RapSolved objects
data(sim_ru, sim_rs)

# plot first species in sim_ru
spp.plot(sim_ru, species = 1)

# plot "bimodal" species in sim_rs
spp.plot(sim_rs, species = "bimodal")

## End(Not run)
</code></pre>

<hr>
<h2 id='spp.subset'>Subset species</h2><span id='topic+spp.subset'></span><span id='topic+spp.subset.RapData'></span><span id='topic+spp.subset.RapUnsolOrSol'></span>

<h3>Description</h3>

<p>Subset species from a <code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spp.subset(x, species)

## S3 method for class 'RapData'
spp.subset(x, species)

## S3 method for class 'RapUnsolOrSol'
spp.subset(x, species)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spp.subset_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="spp.subset_+3A_species">species</code></td>
<td>
<p><code>integer</code>, or <code>character</code> vectors to specify the
index or species names to subset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+RapData">RapData()</a></code> or <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> object depending
on input object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapData">RapData()</a></code>, <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>,
<code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_ru)

# generate new object with only species 1
sim_ru2 &lt;- spp.subset(sim_ru, 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary'>Summary of solutions</h2><span id='topic+summary'></span>

<h3>Description</h3>

<p>Extracts summary of solutions in a <code><a href="#topic+RapResults">RapResults()</a></code> or
<code><a href="#topic+RapSolved">RapSolved()</a></code> object.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+RapResults">RapResults()</a></code>, or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This table follows Marxan conventions
(<a href="https://marxansolutions.org/">https://marxansolutions.org/</a>). The
columns are:
</p>

<dl>
<dt>Run_Number</dt><dd><p>The index of each solution in the object.</p>
</dd>
<dt>Status</dt><dd><p>The status of the solution. The values in this column
correspond to outputs from the Gurobi software package (<a href="https://www.gurobi.com/documentation/6.5/refman/optimization_status_codes.html">https://www.gurobi.com/documentation/6.5/refman/optimization_status_codes.html</a>).</p>
</dd>
<dt>Score</dt><dd><p>The objective function for the solution.</p>
</dd>
<dt>Cost</dt><dd><p>Total cost associated with a solution.</p>
</dd>
<dt>Planning_Units</dt><dd><p>Number of planning units selected in a solution.</p>
</dd>
<dt>Connectivity_Total</dt><dd><p>The total amount of shared boundary length between
all planning units. All solutions in the same object should have equal
values for this column.</p>
</dd>
<dt>Connectivity_In</dt><dd><p>The amount of shared boundary length among planning
units selected in the solution.</p>
</dd>
<dt>Connectivity_Edge</dt><dd><p>The amount of exposed boundary length in the
solution.</p>
</dd>
<dt>Connectivity_Out</dt><dd><p>The number of shared boundary length among planning
units not selected in the solution.</p>
</dd>
<dt>Connectivity_Fraction</dt><dd><p>The ratio of shared boundary length in the
solution (<code>Connectivity_In</code>) to the total amount of boundary length
(<code>Connectivity_Edge</code>). This ratio is an indicator of solution quality.
Solutions with a lower ratio will have less planning units and will be more
efficient.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>data.frame</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RapResults">RapResults()</a></code>, <code><a href="#topic+RapSolved">RapSolved()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_rs)

# show summary
summary(sim_rs)

## End(Not run)
</code></pre>

<hr>
<h2 id='update'>Update object</h2><span id='topic+update'></span><span id='topic+update.GurobiOpts'></span><span id='topic+update.ManualOpts'></span><span id='topic+update.RapData'></span><span id='topic+update.RapReliableOpts'></span><span id='topic+update.RapUnreliableOpts'></span><span id='topic+update.RapUnsolOrSol'></span>

<h3>Description</h3>

<p>This function updates parameters or data stored in an existing
<code><a href="#topic+GurobiOpts">GurobiOpts()</a></code>, <code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code>,
<code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code>, <code><a href="#topic+RapData">RapData()</a></code>,
<code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GurobiOpts'
update(
  object,
  Threads = NULL,
  MIPGap = NULL,
  Method = NULL,
  Presolve = NULL,
  TimeLimit = NULL,
  NumberSolutions = NULL,
  MultipleSolutionsMethod = NULL,
  NumericFocus = NULL,
  ...
)

## S3 method for class 'ManualOpts'
update(object, NumberSolutions = NULL, ...)

## S3 method for class 'RapData'
update(
  object,
  species = NULL,
  space = NULL,
  name = NULL,
  amount.target = NULL,
  space.target = NULL,
  pu = NULL,
  cost = NULL,
  status = NULL,
  ...
)

## S3 method for class 'RapReliableOpts'
update(object, BLM = NULL, failure.multiplier = NULL, max.r.level = NULL, ...)

## S3 method for class 'RapUnreliableOpts'
update(object, BLM = NULL, ...)

## S3 method for class 'RapUnsolOrSol'
update(object, ..., formulation = NULL, solve = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+GurobiOpts">GurobiOpts()</a></code>, <code><a href="#topic+RapUnreliableOpts">RapUnreliableOpts()</a></code>,
<code><a href="#topic+RapReliableOpts">RapReliableOpts()</a></code>, <code><a href="#topic+RapData">RapData()</a></code>,
<code><a href="#topic+RapUnsolved">RapUnsolved()</a></code>, or <code><a href="#topic+RapSolved">RapSolved()</a></code> object.</p>
</td></tr>
<tr><td><code id="update_+3A_threads">Threads</code></td>
<td>
<p><code>integer</code> number of cores to use for processing.</p>
</td></tr>
<tr><td><code id="update_+3A_mipgap">MIPGap</code></td>
<td>
<p><code>numeric</code> MIP gap specifying minimum solution quality.</p>
</td></tr>
<tr><td><code id="update_+3A_method">Method</code></td>
<td>
<p><code>integer</code> Algorithm to use for solving model.</p>
</td></tr>
<tr><td><code id="update_+3A_presolve">Presolve</code></td>
<td>
<p><code>integer</code> code for level of computation in presolve.</p>
</td></tr>
<tr><td><code id="update_+3A_timelimit">TimeLimit</code></td>
<td>
<p><code>integer</code> number of seconds to allow for solving.</p>
</td></tr>
<tr><td><code id="update_+3A_numbersolutions">NumberSolutions</code></td>
<td>
<p><code>integer</code> number of solutions to generate.</p>
</td></tr>
<tr><td><code id="update_+3A_multiplesolutionsmethod">MultipleSolutionsMethod</code></td>
<td>
<p><code>integer</code> name of method to obtain
multiple solutions (used when <code>NumberSolutions</code> is greater than one).
Available options are <code>"benders.cuts"</code>, <code>"solution.pool.0"</code>,
<code>"solution.pool.1"</code>, and <code>"solution.pool.2"</code>. The
<code>"benders.cuts"</code> method produces a set of distinct solutions that
are all within the optimality gap. The <code>"solution.pool.0"</code>
method returns all solutions identified whilst trying to find
a solution that is within the specified optimality gap. The
<code>"solution.pool.1"</code> method finds one solution within the optimality
gap and a number of additional solutions that are of any level of quality
(such that the total number of solutions is equal to
<code>number_solutions</code>). The <code>"solution.pool.2"</code> finds a
specified number of solutions that are nearest to optimality. The
search pool methods correspond to the parameters used by the Gurobi
software suite (see <a href="https://www.gurobi.com/documentation/8.0/refman/poolsearchmode.html#parameter:PoolSearchMode">https://www.gurobi.com/documentation/8.0/refman/poolsearchmode.html#parameter:PoolSearchMode</a>).
Defaults to <code>"benders.cuts"</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_numericfocus">NumericFocus</code></td>
<td>
<p><code>integer</code> how much effort should Gurobi focus on
addressing numerical issues? Defaults to <code>0L</code> such that minimal effort
is spent to reduce run time.</p>
</td></tr>
<tr><td><code id="update_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="#topic+update.RapReliableOpts">update.RapReliableOpts()</a></code>,
<code><a href="#topic+update.RapUnreliableOpts">update.RapUnreliableOpts()</a></code>, or <code><a href="#topic+update.RapData">update.RapData()</a></code>.</p>
</td></tr>
<tr><td><code id="update_+3A_species">species</code></td>
<td>
<p><code>integer</code> or <code>character</code> denoting species for which
targets or name should be updated.</p>
</td></tr>
<tr><td><code id="update_+3A_space">space</code></td>
<td>
<p><code>integer</code> denoting space for which targets should be
updated.</p>
</td></tr>
<tr><td><code id="update_+3A_name">name</code></td>
<td>
<p><code>character</code> to rename species.</p>
</td></tr>
<tr><td><code id="update_+3A_amount.target">amount.target</code></td>
<td>
<p><code>numeric</code> vector for new area targets (%) for the
specified species.</p>
</td></tr>
<tr><td><code id="update_+3A_space.target">space.target</code></td>
<td>
<p><code>numeric</code> vector for new attribute space targets
(%) for the specified species and attribute spaces.</p>
</td></tr>
<tr><td><code id="update_+3A_pu">pu</code></td>
<td>
<p><code>integer</code> planning unit indices that need to be updated.</p>
</td></tr>
<tr><td><code id="update_+3A_cost">cost</code></td>
<td>
<p><code>numeric</code> new costs for specified planning units.</p>
</td></tr>
<tr><td><code id="update_+3A_status">status</code></td>
<td>
<p><code>integer</code> new statuses for specified planning units.</p>
</td></tr>
<tr><td><code id="update_+3A_blm">BLM</code></td>
<td>
<p><code>numeric</code> boundary length modifier.</p>
</td></tr>
<tr><td><code id="update_+3A_failure.multiplier">failure.multiplier</code></td>
<td>
<p><code>numeric</code> multiplier for failure planning
unit.</p>
</td></tr>
<tr><td><code id="update_+3A_max.r.level">max.r.level</code></td>
<td>
<p><code>numeric</code> maximum R failure level for approximation.</p>
</td></tr>
<tr><td><code id="update_+3A_formulation">formulation</code></td>
<td>
<p><code>character</code> indicating new problem formulation to
use. This can be either &quot;unreliable&quot; or &quot;reliable&quot;. The default is
<code>NULL</code> so that formulation in <code>object</code> is used.</p>
</td></tr>
<tr><td><code id="update_+3A_solve">solve</code></td>
<td>
<p><code>logical</code> should the problem be solved? This argument is
only valid for <code><a href="#topic+RapUnsolved">RapUnsolved()</a></code> and <code><a href="#topic+RapSolved">RapSolved()</a></code>
objects. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+GurobiOpts-class">GurobiOpts</a>,
<a href="#topic+RapUnreliableOpts-class">RapUnreliableOpts</a>,
<a href="#topic+RapReliableOpts-class">RapReliableOpts</a>, <a href="#topic+RapData-class">RapData</a>,
<a href="#topic+RapUnsolved-class">RapUnsolved</a>, or <a href="#topic+RapSolved-class">RapSolved</a> object
depending on argument to <code>x</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+GurobiOpts-class">GurobiOpts</a>,
<a href="#topic+RapUnreliableOpts-class">RapUnreliableOpts</a>,
<a href="#topic+RapReliableOpts-class">RapReliableOpts</a>, <a href="#topic+RapData-class">RapData</a>,
<a href="#topic+RapUnsolved-class">RapUnsolved</a>, <a href="#topic+RapSolved-class">RapSolved</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data
data(sim_ru, sim_rs)

# GurobiOpts
x &lt;- GurobiOpts(MIPGap = 0.7)
y &lt;- update(x, MIPGap = 0.1)
print(x)
print(y)

# RapUnreliableOpts
x &lt;- RapUnreliableOpts(BLM = 10)
y &lt;- update(x, BLM = 2)
print(x)
print(y)

# RapReliableOpts
x &lt;- RapReliableOpts(failure.multiplier = 2)
y &lt;- update(x, failure.multiplier = 4)
print(x)
print(y)

# RapData
x &lt;- sim_ru@data
y &lt;- update(x, space.target = c(0.4, 0.7, 0.1))
print(space.target(x))
print(space.target(y))

## RapUnsolved
x &lt;- sim_ru
y &lt;- update(x, amount.target = c(0.1, 0.2, 0.3), BLM = 3, solve = FALSE)
print(x@opts@BLM); print(amount.target(x))
print(y@opts@BLM); print(space.target(y))

## RapSolved
x &lt;- sim_rs
y &lt;- update(x, space.target = c(0.4, 0.6, 0.9), BLM = 100, Presolve = 1L,
            solve = FALSE)
print(x@opts@BLM); print(amount.target(x))
print(y@opts@BLM); print(space.target(y))

## End(Not run)
</code></pre>

<hr>
<h2 id='urap.proportion.held'>Proportion held using unreliable RAP formulation.</h2><span id='topic+urap.proportion.held'></span>

<h3>Description</h3>

<p>This is a convenience function to quickly calculate the proportion of
variation that one set of points captures in a another set of points using
the unreliable formulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>urap.proportion.held(x, y, y.weights = rep(1, nrow(y)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="urap.proportion.held_+3A_x">x</code></td>
<td>
<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> of points</p>
</td></tr>
<tr><td><code id="urap.proportion.held_+3A_y">y</code></td>
<td>
<p><code><a href="base.html#topic+matrix">base::matrix()</a></code> of points</p>
</td></tr>
<tr><td><code id="urap.proportion.held_+3A_y.weights">y.weights</code></td>
<td>
<p><code>numeric</code> vector of weights for each point in
<code>y</code>. Defaults to equal weights for all points in <code>y</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> value indicating the proportion of variation that
<code>x</code> explains in <code>y</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
urap.proportion.held(as.matrix(iris[1:2,-5]), as.matrix(iris[1:5,-5]))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
