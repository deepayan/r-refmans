<!DOCTYPE html><html><head><title>Help for package proto</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {proto}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#proto-package'><p>Object-Oriented Programming with the Prototype Model</p></a></li>
<li><a href='#proto'><p>Prototype object-based programming</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Prototype Object-Based Programming</td>
</tr>
<tr>
<td>Description:</td>
<td>An object oriented system using object-based, also
	called prototype-based, rather than class-based object oriented ideas.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hadley/proto">https://github.com/hadley/proto</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hadley/proto/issues">https://github.com/hadley/proto/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1.9000</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-10-28 22:08:08 UTC; hadley</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [cre],
  Gabor Grothendieck [aut],
  Louis Kates [aut],
  Thomas Petzoldt [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@rstudio.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-10-29 00:23:07</td>
</tr>
</table>
<hr>
<h2 id='proto-package'>Object-Oriented Programming with the Prototype Model</h2><span id='topic+proto-package'></span>

<h3>Description</h3>

<p>Object-oriented programming with the prototype model.  <code>"proto"</code>
facilitates object-oriented programming using an approach that emphasizes
objects rather than classes (although it is powerful enough to readily
represent classes too).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cat("parent\n")
oop &lt;- proto(x = 10, view = function(.) paste("this is a:", .$x))
oop$ls()
oop$view()

cat("override view in parent\n")
ooc1 &lt;- oop$proto(view = function(.) paste("this is a: ***", .$x, "***"))
ooc1$view()

cat("override x in parent\n")
ooc2 &lt;- oop$proto(x = 20)
ooc2$view()
</code></pre>

<hr>
<h2 id='proto'>Prototype object-based programming</h2><span id='topic+proto'></span><span id='topic+as.proto'></span><span id='topic+as.proto.environment'></span><span id='topic+as.proto.list'></span><span id='topic+as.proto.data.frame'></span><span id='topic+as.proto.proto'></span><span id='topic+isnot.function'></span><span id='topic+is.proto'></span><span id='topic++24.proto'></span><span id='topic++24+3C-.proto'></span><span id='topic+with.proto'></span><span id='topic+str.proto'></span><span id='topic+.'></span><span id='topic+this'></span><span id='topic+.that'></span><span id='topic+that'></span><span id='topic+.super'></span><span id='topic+super'></span><span id='topic+print.instantiatedProtoMethod'></span><span id='topic+as.proto'></span><span id='topic+as.proto.environment'></span><span id='topic+as.proto.proto'></span><span id='topic+as.proto.list'></span><span id='topic+is.proto'></span>

<h3>Description</h3>

<p><code>proto</code> creates or modifies objects of the proto object oriented
system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proto(. = parent.env(envir), expr = { }, envir = new.env(parent =
  parent.frame()), ..., funEnvir = envir)

as.proto(x, ...)

## S3 method for class 'environment'
as.proto(x, ...)

## S3 method for class 'proto'
as.proto(x, ...)

## S3 method for class 'list'
as.proto(x, envir, parent, all.names = FALSE, ...,
  funEnvir = envir, SELECT = function(x) TRUE)

is.proto(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proto_+3A_.">.</code></td>
<td>
<p>the parent object of the new object.  May be a proto object or an
environment.</p>
</td></tr>
<tr><td><code id="proto_+3A_expr">expr</code></td>
<td>
<p>a series of statements enclosed in braces that define the
variables and methods of the object.  Empty braces, the default, may be used
if there are no variables or methods to add at this time.</p>
</td></tr>
<tr><td><code id="proto_+3A_envir">envir</code></td>
<td>
<p>an existing prototype object or environment into which the
variables and methods defined in <code>expr</code> are placed.  If omitted a new
object is created.</p>
</td></tr>
<tr><td><code id="proto_+3A_...">...</code></td>
<td>
<p>for <code>proto</code> these are components to be embedded in the new
object.  For <code>as.proto.list</code> these are arguments to pass to
<code>proto</code> in the case that a new object is created.  for <code>$.proto</code>
the method is evaluated at these arguments.</p>
</td></tr>
<tr><td><code id="proto_+3A_funenvir">funEnvir</code></td>
<td>
<p>the environment of methods passed via ... are
automatically set to this environment.  Normally this argument is omitted,
defaulting to <code>envir</code>; however, one can specify <code>FALSE</code> to cause
their environment to not be set or one can specify some other environment or
proto object to which their environment is to be set.</p>
</td></tr>
<tr><td><code id="proto_+3A_x">x</code></td>
<td>
<p>a list.</p>
</td></tr>
<tr><td><code id="proto_+3A_parent">parent</code></td>
<td>
<p>a prototype object or environment which is to be used as the
parent of the object.  If <code>envir</code> is specified then its parent is
coerced to <code>parent</code>.</p>
</td></tr>
<tr><td><code id="proto_+3A_all.names">all.names</code></td>
<td>
<p>only names not starting with a dot are copied unless
all.names is TRUE.</p>
</td></tr>
<tr><td><code id="proto_+3A_select">SELECT</code></td>
<td>
<p>a function which given an object returns <code>TRUE</code> or
<code>FALSE</code> such that only those for which <code>SELECT</code> returns
<code>TRUE</code> are kept in the returned <code>proto</code> object.</p>
</td></tr>
<tr><td><code id="proto_+3A_list">list</code></td>
<td>
<p>list whose components are an alternate way to specifying
arguments in place of <code>...{}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>proto</code> class is an <code>S3</code> subclass of the R <code>environment</code>
class. In particular this implies that <code>proto</code> objects have single
inheritance and mutable state as all environments do. The <code>proto</code>
function creates and modifies objects of the <code>proto</code> class.  It (1)
sets the parent of codeenvir to <code>parent</code>, (2) evaluates <code>expr</code> in
the <code>envir</code> environment and (3) lazily evaluates the arguments in
<code>...{}</code> in the parent environment resetting the environment of any
functions (where the resetting is also done lazily).  All such functions are
known as methods and should have the receiver object as their first
argument. Conventionally this is <code>.</code> (i.e. a dot).  Also <code>.that</code>
and <code>.super</code> variables are added to the environment <code>envir</code>.
These point to the object itself and its parent, respectively. Note that
<code>proto</code> can be used as a method and overridden like any other method.
This allows objects to have object-specific versions of <code>proto</code>.  There
also exist <code>that()</code> and <code>super()</code> functions which have the same
purpose as <code>.that</code> and <code>.super</code> but do not rely on the
<code>.that</code> and <code>.super</code>.  <code>.that</code>, <code>.super</code>, <code>that()</code>
and <code>super()</code> can only be used within methods that have their object as
their environment.  In addition <code>that()</code> and <code>super()</code> may only be
used within the top level of such methods ( and not within functions within
such methods).
</p>
<p><code>as.proto</code> is a generic with methods for environments, proto objects
and lists.
</p>
<p><code>as.proto.list</code> copies each component, <code>el</code>, of the list <code>x</code>
into the the environment or proto object <code>envir</code> for which
<code>FUN(el)</code> is <code>TRUE</code>.  Components whose name begins with a dot,
<code>.</code>, are not copied unless <code>all.names</code> is <code>TRUE</code> (and
<code>FUN(el)</code> is <code>TRUE</code>). The result is a proto object whose parent is
<code>parent</code>. If <code>envir</code> is omitted a new object is created through a
call to <code>proto</code> with <code>parent</code> and <code>...{}</code> as arguments. If
<code>parent</code> is also omitted then the current environment is the parent.
Note that if <code>parent</code> is a proto object with its own <code>proto</code>
method then the <code>proto</code> method of the parent will override the one
described here in which case the functionality may differ.
</p>
<p><code>$</code> can be used to access or set variables and methods in an object.
</p>
<p>When <code>$</code> is used for getting variables and methods, calls of the form
<code>obj$v</code> search for v in <code>obj</code> and if not found search upwards
through the ancestors of <code>obj</code> until found unless the name <code>v</code>
begins with two dots <code>..</code>.  In that case no upward search is done.
</p>
<p>If <code>meth</code> is a function then <code>obj$meth</code> is an object of class
<code>c("instantiatedProtoMethod", "function")</code> which is a <code>proto</code>
method with the first, i.e. proto slot, already filled in. It is normally
used in the context of a call to a method, e.g. <code>obj$meth(x,y)</code>. There
also exists <code>print.instantiatedProtoMethod</code> for printing such objects.
Be aware that an instantiated proto method is not the same as a proto
method.  An instantiated proto method has its first argument filled (with
the receiver object) whereas the first argument of a proto method does not.
If it is desired to actually return the method as a value not in the context
of a call then use the form <code>obj$with(meth)</code> or <code>obj[[meth]]</code>
which are similar to <code>with(obj, meth)</code> except that the variation using
<code>with</code> will search through ancestors while <code>[[</code> will not search
through ancestors). The difference between <code>obj$meth</code> and
<code>obj$with(meth)</code> is that in the first case <code>obj</code> implicitly
provides the first argument to the call so that <code>obj$meth(x,y)</code> and
<code>obj$with(meth)(obj,x,y)</code> are equivalent while in the case of
<code>obj$with(meth)</code> the first argument is not automatically inserted.
</p>
<p><code>$.proto</code> also has a multiple argument form.  If three or more
arguments are present then they specify the arguments at which the
instantiated method is to be evaluated.  In this form the receiver object
must be specified explicitly.  This form can be used in situations where the
highest speed is required such as in the inner loops of computations.
</p>
<p>The forms <code>.that$meth</code> and <code>.super$meth</code> are special and should
only be used within methods.  <code>.that</code> refers to the object in which the
current method is located and <code>.super</code> refers to the parent of
<code>.that</code>.  In both cases the receiver object must be specified as the
first argument &ndash; the receiver is not automatically inserted as with other
usages of <code>$</code>.
</p>
<p><code>$</code> can be used to set variables and methods in an object. No ancestors
are searched for the set form of <code>$</code>. If the variable is the special
variable <code>.super</code> then not only is the variable set but the object's
parent is set to <code>.super</code>.
</p>
<p>A <code>with</code> method is available for <code>proto</code> objects.
</p>
<p><code>is.proto(p)</code> returns TRUE if p is a prototype object.
</p>
<p><code>str.proto</code> is provided for inspecting <code>proto</code> objects.
</p>


<h3>Value</h3>

<p><code>proto</code> and <code>as.proto</code> all return proto objects.
</p>


<h3>Note</h3>

<p>proto methods can be used with environments but some care must be
taken.  Problems can be avoided by always using proto objects in these
cases.  This note discusses the pitfalls of using environments for those
cases where such interfacing is needed.
</p>
<p>If <code>e</code> is an environment then <code>e$x</code> will only search for <code>x</code>
in <code>e</code> and no further whereas if <code>e</code> were a proto object its
ancestors will be searched as well. For example, if the parent of a
<code>proto</code> object is an <code>environment</code> but not itself a <code>proto</code>
object then <code>.super$x</code> references in the methods of that object will
only look as far as the parent.
</p>
<p>Also note that the form <code>e$meth(...)</code> when used with an environment
will not automatically insert <code>e</code> as the first argument and so
environments can only be used with methods by using the more verbose
<code>e$meth(e, ...)</code>.  Even then it is not exactly equivalent since
<code>meth</code> will only be looked up in <code>e</code> but not its ancestors. To get
precise equivalence write the even more verbose <code>with(e, meth)(e,
...)</code>.
</p>
<p>If the user has a proto object <code>obj</code> which is a child of the global
environment and whose methods use <code>.super</code> then <code>.super</code> will
refer to an environment, not a proto object (unless the global environment
is coerced to a proto object) and therefore be faced with the search
situation discussed above.  One solution is to create an empty root object
between the global environment and <code>obj</code> as in this diagram <code>Root
&lt;- obj$.super &lt;- proto(.GlobalEnv)</code> where <code>Root</code> is the root object.
Now <code>.super</code> references will reference <code>Root</code>, which is a proto
object so search will occur as expected.  <code>proto</code> does not provide such
a root object automatically but the user can create one easily, if desired.
</p>
<p>Although not recommended, it possible to coerce the global environment to a
proto object by issuing the command <code>as.proto(.GlobalEnv)</code>.  This will
effectively make the global environment a proto root object but has the
potential to break other software, although the authors have not actually
found any software that it breaks.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.list">as.list</a></code>, <code><a href="base.html#topic+names">names</a></code>,
<code><a href="base.html#topic+environment">environment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oo &lt;- proto(expr = {
   x = c(10, 20, 15, 19, 17)
   location = function(.) mean(.$x) # 1st arg is object
   rms = function(.) sqrt(mean((.$x - .$location())^2))
   bias = function(., b) .$x &lt;- .$x + b
})

debug(oo$with(rms)) # cannot use oo$rms to pass method as a value
undebug(oo$with(rms)) # cannot use oo$rms to pass method as a value

oo2 &lt;- oo$proto( location = function(.) median(.$x) )
oo2$rms()      # note that first argument is omitted.
oo2$ls()       # list components of oo2
oo2$as.list()  # contents of oo2 as a list
oo2            # oo2 itself
oo2$parent.env() # same
oo2$parent.env()$as.list() # contents of parent of oo2
oo2$print()
oo2$ls()
oo2$str()
oo3 &lt;- oo2
oo2$identical(oo3)
oo2$identical(oo)

# start off with Root to avoid problem cited in Note
Root &lt;- proto()
oop &lt;- Root$proto(a = 1, incr = function(.) .$a &lt;- .$a+1)
ooc &lt;- oop$proto(a = 3) # ooc is child of oop but with a=3
ooc$incr()
ooc$a      # 4

# same but proto overridden to force a to be specified
oop$proto &lt;- function(., a) { .super$proto(., a=a) }
## Not run: 
ooc2 &lt;- oop$proto() # Error. Argument "a" is missing, with no default.

## End(Not run)
ooc2 &lt;- oop$proto(a = 10)
ooc2$incr()
ooc2$a # 11

# use of with to eliminate having to write .$a
o2 &lt;- proto(a = 1, incr = function(.) with(., a &lt;- a+1))
o2c &lt;- as.proto(o2$as.list()) # o2c is a clone of o2
o2d &lt;- o2$proto()  # o2d is a child of o2
o2$a &lt;- 2
o2c$a  # a not changed by assignment in line above
o2d$a # a is changed since a not found in o2d so found in o2

p &lt;- proto(a = 0, incr = function(., x) .$a &lt;- .$a + x)
pc &lt;- p$proto(a = 100)

p$incr(7)
p$incr(x=7)
p$a

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
