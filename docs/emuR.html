<!DOCTYPE html><html><head><title>Help for package emuR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {emuR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.EPG'><p>expand EPG</p></a></li>
<li><a href='#[.spectral'><p>Expand spectral</p></a></li>
<li><a href='#[.trackdata'><p>Expand trackdata</p></a></li>
<li><a href='#add_files'><p>Add files to emuDB</p></a></li>
<li><a href='#AddListRemoveAttrDefLabelGroup'><p>Add / List / Remove labelGroup to / of / from attributeDefinition of emuDB</p></a></li>
<li><a href='#AddListRemoveLabelGroup'><p>Add / List / Remove global labelGroup to / of / from emuDB</p></a></li>
<li><a href='#AddListRemoveLevelDefinitions'><p>Add / List / Remove level definition to / of / from emuDB</p></a></li>
<li><a href='#AddListRemoveLinkDefinition'><p>Add / List / Remove linkDefinition to / of / from emuDB</p></a></li>
<li><a href='#AddListRemovePerspective'><p>Add / List / Remove perspective to / of / from emuDB</p></a></li>
<li><a href='#AddListRemoveSsffTrackDefinition'><p>Add / List / Remove ssffTrackDefinition to / from / of emuDB</p></a></li>
<li><a href='#AddListRenameRemoveAttributeDefinitions'><p>Add / List / Rename / Remove attribute definition to / of / from emuDB</p></a></li>
<li><a href='#as.matrix.emusegs'><p>as.matrix.emusegs</p></a></li>
<li><a href='#as.spectral'><p>Function to convert an object into an object of class 'spectral'.</p></a></li>
<li><a href='#as.trackdata'><p>Create an Emu trackdata object</p></a></li>
<li><a href='#autobuild_linkFromTimes'><p>Autobuild links between two levels using their time information</p></a></li>
<li><a href='#bark'><p>Convert Hertz to Bark and Bark to Hertz</p></a></li>
<li><a href='#bayes.dist'><p>bayes dist</p></a></li>
<li><a href='#bayes.lab'><p>bayes lab</p></a></li>
<li><a href='#bayesian.metric'><p>bayesian metric</p></a></li>
<li><a href='#bayesplot'><p>bayesplot</p></a></li>
<li><a href='#bind'><p>class method bind data</p></a></li>
<li><a href='#bind.default'><p>data binding</p></a></li>
<li><a href='#bind.trackdata'><p>bind trackdata</p></a></li>
<li><a href='#bridge'><p>Three-columned matrix</p></a></li>
<li><a href='#buildtrack'><p>Build trackdata objects from the output of by()</p></a></li>
<li><a href='#by.trackdata'><p>A method of the generic function by for objects of class 'trackdata'</p></a></li>
<li><a href='#cbind.trackdata'><p>A method of the generic function cbind for objects of class 'trackdata'</p></a></li>
<li><a href='#cen.sub'><p>Subfunction of cen</p></a></li>
<li><a href='#classify'><p>classify</p></a></li>
<li><a href='#classplot'><p>Produce a classification plot from discriminant or SVM modelling</p></a></li>
<li><a href='#closest'><p>closest</p></a></li>
<li><a href='#convert_BPFCollection'><p>Convert a Bas Partitur File Collection (audio and BAS Partitur files) to an emuDB</p></a></li>
<li><a href='#convert_legacyEmuDB'><p>Convert legacy EMU database to the emuDB format</p></a></li>
<li><a href='#convert_TextGridCollection'><p>Convert a TextGridCollection (e.g. .wav &amp; .TextGrid files) to emuDB</p></a></li>
<li><a href='#convert_txtCollection'><p>Converts a collection of audio files and plain text transcriptions into an emuDB</p></a></li>
<li><a href='#convert_wideToLong'><p>convert tracks of a tibble trackdata object to the long form</p></a></li>
<li><a href='#coutts'><p>Segment list of words, read speech, female speaker of Australian English</p>
from database epgcoutts</a></li>
<li><a href='#coutts.epg'><p>EPG-compressed trackdata from the segment list coutts</p></a></li>
<li><a href='#coutts.l'><p>Vector of word label from the segment list coutts</p></a></li>
<li><a href='#coutts.rms'><p>rms Data to coutts segment list</p></a></li>
<li><a href='#coutts.sam'><p>Trackdata of acoustic waveforms from the segment list coutts</p></a></li>
<li><a href='#coutts2'><p>Segment list, same as coutts but at a slower speech rate</p></a></li>
<li><a href='#coutts2.epg'><p>EPG-compressed trackdata from the segment list coutts2</p></a></li>
<li><a href='#coutts2.l'><p>Vector of word label from the segment list coutts2</p></a></li>
<li><a href='#coutts2.sam'><p>Trackdata of acoustic waveforms from the segment list coutts2</p></a></li>
<li><a href='#cr'><p>Plot digital sinuoids.</p></a></li>
<li><a href='#create_emuDB'><p>Create empty emuDB</p></a></li>
<li><a href='#create_emuRdemoData'><p>Create demo data for the emuR package</p></a></li>
<li><a href='#create_emuRtrackdata'><p>create emuRtrackdata object</p></a></li>
<li><a href='#create_itemsInLevel'><p>Create new items programmatically</p></a></li>
<li><a href='#create_links'><p>create links between items</p></a></li>
<li><a href='#create_spectrogram_image_as_raster'><p>Create spectrogram image as raster</p></a></li>
<li><a href='#crplot'><p>Function to plot a digital sinusoid and the circle from which it is</p>
derived.</a></li>
<li><a href='#dapply'><p>apply a function to each part of a trackdata object</p></a></li>
<li><a href='#dbnorm'><p>Function to dB-normalise spectral objects</p></a></li>
<li><a href='#dbtopower'><p>Function for inter-converting between decibels and a linear scale</p></a></li>
<li><a href='#dct'><p>Discrete Cosine Transformation</p></a></li>
<li><a href='#dcut'><p>Function to extract a vector or matrix from EMU-Trackdata at a single time</p>
point of to create another EMU-trackdata object between two times.</a></li>
<li><a href='#ddiff'><p>Differentiation of tracks</p></a></li>
<li><a href='#delete_itemsInLevel'><p>Delete items programmatically</p></a></li>
<li><a href='#demo.all'><p>Emu segment list</p></a></li>
<li><a href='#demo.all.f0'><p>F0 track data for segment list demo.vowels</p></a></li>
<li><a href='#demo.all.fm'><p>Formant track data for segment list demo.vowels</p></a></li>
<li><a href='#demo.all.rms'><p>Emu track data for a rms track for segment list demo.all</p></a></li>
<li><a href='#demo.vowels'><p>Emu segment List</p></a></li>
<li><a href='#demo.vowels.f0'><p>F0 track data for segment list demo.vowels</p></a></li>
<li><a href='#demo.vowels.fm'><p>Formant track data for segment list demo.vowels</p></a></li>
<li><a href='#dextract'><p>Extract a subset of data from a trackdata object</p></a></li>
<li><a href='#dextract.lab'><p>Extract a subset of data from a trackdata object</p></a></li>
<li><a href='#dim.trackdata'><p>A method of the generic function dim for objects of class 'trackdata'</p></a></li>
<li><a href='#dimnames.trackdata'><p>Dimnames of trackdata object</p></a></li>
<li><a href='#dip'><p>Segment list of diphthongs, two speakers one male, one female , Standard</p>
North German, read speech from database kielread</a></li>
<li><a href='#dip.fdat'><p>Trackdata of formants from the segment list dip</p></a></li>
<li><a href='#dip.l'><p>Vector of phoneme labels from the segment list dip</p></a></li>
<li><a href='#dip.spkr'><p>Vector of speaker labels from the segment list dip</p></a></li>
<li><a href='#distance'><p>distance</p></a></li>
<li><a href='#dplot'><p>A function to plot one or more columns of EMU-trackdata as a function of</p>
time (DEPRECATED see below)</a></li>
<li><a href='#dsmooth'><p>Smooth the data in a trackdata object.</p></a></li>
<li><a href='#dtime'><p>time signal times</p></a></li>
<li><a href='#duplicate_level'><p>Duplicate level</p></a></li>
<li><a href='#dur'><p>duration</p></a></li>
<li><a href='#dur.emusegs'><p>Duration of segments (NOTE: does not work for new default resultType = &quot;tibble&quot; of <code>query()</code>)</p></a></li>
<li><a href='#dur.trackdata'><p>Duration of trackdata elements</p></a></li>
<li><a href='#e.dft'><p>Spectral vector of a single E vowel produced by a male speaker of Standard</p>
North German.</a></li>
<li><a href='#ellipse'><p>Calculate ellipse coordinates</p></a></li>
<li><a href='#emuR-package'><p>emuR - Main Package of the EMU Speech Database Management System</p></a></li>
<li><a href='#emuRsegs'><p>emuR segment list</p></a></li>
<li><a href='#emuRtrackdata'><p>emuR track data object</p></a></li>
<li><a href='#emusegs.database'><p>emusegs database</p></a></li>
<li><a href='#emusegs.query'><p>emusegs query</p></a></li>
<li><a href='#emusegs.type'><p>segment list type</p></a></li>
<li><a href='#engassim'><p>Segment list of a sequence of syllable final n or N preceding k or g ,</p>
isolated words single speaker, Australian English female from database
epgassim.</a></li>
<li><a href='#engassim.epg'><p>EPG-compressed trackdata from the segment list engassim</p></a></li>
<li><a href='#engassim.l'><p>Vector of phonetic labels from the segment list engassim: nK = nk,ng , sK =</p>
sk,sg</a></li>
<li><a href='#engassim.w'><p>Vector of word labels from the segment list engassim.</p></a></li>
<li><a href='#epgai'><p>Electropalatographic contact indices</p></a></li>
<li><a href='#epgcog'><p>Electropalatographic centre of gravity</p></a></li>
<li><a href='#epggs'><p>Plot a grey-scale image of palatographic data.</p></a></li>
<li><a href='#epgplot'><p>Plot palatographic data</p></a></li>
<li><a href='#epgsum'><p>Sum contacts in palatograms.</p></a></li>
<li><a href='#eplot'><p>Plot ellipses for two-dimensional data (DEPRECATED see below)</p></a></li>
<li><a href='#euclidean'><p>Find the inter-euclidean distance for a data matrix</p></a></li>
<li><a href='#expand_labels'><p>Label each data sample</p></a></li>
<li><a href='#export_BPFCollection'><p>Exports an emuDB into a BAS Partitur File (BPF) Collection</p></a></li>
<li><a href='#export_seglistToTxtCollection'><p>Exports a segment list to txt collection</p></a></li>
<li><a href='#export_TextGridCollection'><p>Export annotations of emuDB to TextGrid collection</p></a></li>
<li><a href='#fapply'><p>Function that applies a function to an EMU spectral object</p></a></li>
<li><a href='#frames'><p>frames</p></a></li>
<li><a href='#frames.time'><p>Find the time and position of a data element.</p></a></li>
<li><a href='#freqtoint'><p>Function to find the column number corresponding to frequencies of a</p>
spectral object</a></li>
<li><a href='#fric'><p>Segment list of word-medial s or z one male speaker of Standard North</p>
German, read speech from database kielread.</a></li>
<li><a href='#fric.dft'><p>Spectral trackdata object from the segment list fric.</p></a></li>
<li><a href='#fric.l'><p>Vector of labels from the segment list fric</p></a></li>
<li><a href='#fric.w'><p>Vector of word labels from the segment list fric.</p></a></li>
<li><a href='#gerst.sub'><p>gerst sub</p></a></li>
<li><a href='#get_trackdata'><p>Get trackdata from loaded emuDB</p></a></li>
<li><a href='#get.time.element'><p>Get data for a given time</p></a></li>
<li><a href='#get.trackkeywrd'><p>get trackkeywrd</p></a></li>
<li><a href='#import_mediaFiles'><p>Import media files to emuDB</p></a></li>
<li><a href='#is.seglist'><p>is seglist</p></a></li>
<li><a href='#is.spectral'><p>Function to test whether the object is of class &quot;spectral&quot;</p></a></li>
<li><a href='#is.trackdata'><p>Test whether an object is an Emu trackdata object</p></a></li>
<li><a href='#isol'><p>Segment list of vowels in a d d context isolated word speech, one male</p>
speaker of Australian English from database isolated.</a></li>
<li><a href='#isol.fdat'><p>Trackdata of formants from the segment list isol</p></a></li>
<li><a href='#isol.l'><p>Vector of vowel phoneme labels from the segment list isol</p></a></li>
<li><a href='#label'><p>Get labels / utterances from segment list</p></a></li>
<li><a href='#label_convert'><p>convert label</p></a></li>
<li><a href='#label_num'><p>num label</p></a></li>
<li><a href='#linear'><p>Perform linear time normalisation on trackdata.</p></a></li>
<li><a href='#linear.av'><p>linear av</p></a></li>
<li><a href='#list_bundles'><p>List bundles of emuDB</p></a></li>
<li><a href='#list_files'><p>List files of emuDB</p></a></li>
<li><a href='#list_sampleRates'><p>List sample rates of media and annotation (_annot.json) files</p></a></li>
<li><a href='#list_sessions'><p>List sessions of emuDB</p></a></li>
<li><a href='#load_emuDB'><p>Load emuDB</p></a></li>
<li><a href='#lob.sub'><p>lob sub</p></a></li>
<li><a href='#locus'><p>Calculate locus equations for two-dimensional data</p></a></li>
<li><a href='#mahal'><p>Classify using Mahalanobis distance</p></a></li>
<li><a href='#mahal.dist'><p>Calculate mahalanobis distances</p></a></li>
<li><a href='#mahalanobis.metric'><p>mahalanobis metric</p></a></li>
<li><a href='#make.emuRsegs'><p>Make emuDB segment list</p></a></li>
<li><a href='#make.seglist'><p>Make an Emu segment list from the various components</p></a></li>
<li><a href='#makelab'><p>Write out ESPS-style label files</p></a></li>
<li><a href='#matscan'><p>Read matrix data from a file</p></a></li>
<li><a href='#mel'><p>Convert Hz to the mel scale</p></a></li>
<li><a href='#mel.default'><p>mel default</p></a></li>
<li><a href='#modify.seglist'><p>Modify one of the components of an Emu segment list</p></a></li>
<li><a href='#moments'><p>Function to calculate statistical moments</p></a></li>
<li><a href='#mu.colour'><p>Function for specifying color, linetype, and line-widths in EMU plotting</p>
functions.</a></li>
<li><a href='#mu.colour.get'><p>get a EMU color</p></a></li>
<li><a href='#mu.legend'><p>make a EMU legend</p></a></li>
<li><a href='#mu.linetype.get'><p>mu linetype get</p></a></li>
<li><a href='#muclass'><p>Find common elements in vectors</p></a></li>
<li><a href='#nearey.sub'><p>nearey sub</p></a></li>
<li><a href='#norm'><p>Normalise speech data</p></a></li>
<li><a href='#normalize_length'><p>Normalize length of segments contained in a <code>data.frame</code> like object returned by <code>get_trackdata</code></p></a></li>
<li><a href='#outliers'><p>outliers</p></a></li>
<li><a href='#palate'><p>Obtain a three-dimensional palatographic array</p></a></li>
<li><a href='#perform'><p>Performance (hit rate) of a confusion matrix</p></a></li>
<li><a href='#plafit'><p>Calculate the coefficients of a parabola</p></a></li>
<li><a href='#plot.spectral'><p>Plot spectra from EMU spectral objects</p></a></li>
<li><a href='#plot.trackdata'><p>Produces time-series plots from trackdata</p></a></li>
<li><a href='#polhom'><p>Segment list of four Polish homorganic fricatives from database epgpolish.</p></a></li>
<li><a href='#polhom.epg'><p>EPG-compressed trackdata from the segment list polhom</p></a></li>
<li><a href='#polhom.l'><p>Vector of phonetic labels from the segment list polhom</p></a></li>
<li><a href='#polygonplot'><p>polygonplot</p></a></li>
<li><a href='#print.emuRsegs'><p>Print emuRsegs segment list</p></a></li>
<li><a href='#print.emuRtrackdata'><p>Print emuRtrackdata object</p></a></li>
<li><a href='#print.emusegs'><p>print emusegs</p></a></li>
<li><a href='#print.trackdata'><p>print trackdata</p></a></li>
<li><a href='#query'><p>Query emuDB</p></a></li>
<li><a href='#rad'><p>Function to convert between Hertz and Radians</p></a></li>
<li><a href='#radians'><p>Converts degrees to radians</p></a></li>
<li><a href='#randomise.segs'><p>Randomise or Reverse items in a segment list</p></a></li>
<li><a href='#rbind.trackdata'><p>A method of the generic function rbind for objects of class trackdata</p></a></li>
<li><a href='#read_bundleList'><p>read bundleList</p></a></li>
<li><a href='#read.emusegs'><p>Create an Emu segment list from a file</p></a></li>
<li><a href='#rename_bundles'><p>Rename bundles in emuDB</p></a></li>
<li><a href='#rename_emuDB'><p>Rename emuDB</p></a></li>
<li><a href='#replace_itemLabels'><p>Replace item labels</p></a></li>
<li><a href='#requery_hier'><p>Requery hierarchical context of a segment list in an emuDB</p></a></li>
<li><a href='#requery_seq'><p>Requery sequential context of segment list in an emuDB</p></a></li>
<li><a href='#resample_annots'><p>Resample annotations (<code>_annot.json</code>) files of emuDB</p></a></li>
<li><a href='#rescale.gerst'><p>rescale gerst</p></a></li>
<li><a href='#rescale.lob'><p>rescale lob</p></a></li>
<li><a href='#rescale.nearey'><p>rescale nearey</p></a></li>
<li><a href='#runBASwebservice_all'><p>Runs several BAS webservices, starting from an orthographic transcription</p></a></li>
<li><a href='#runBASwebservice_chunker'><p>Creates a chunk segmentation using the webservice Chunker.</p></a></li>
<li><a href='#runBASwebservice_g2pForPronunciation'><p>Creates canonical pronunciation attributes for a tier of tokenized orthographical words.</p></a></li>
<li><a href='#runBASwebservice_g2pForTokenization'><p>Tokenizes an orthographic transcription.</p></a></li>
<li><a href='#runBASwebservice_maus'><p>Runs MAUS webservice to create a phonetic segmentation</p></a></li>
<li><a href='#runBASwebservice_minni'><p>Creates a rough phonetic segmentation by running the phoneme decoder webservice MINNI.</p></a></li>
<li><a href='#runBASwebservice_pho2sylCanonical'><p>Adds syllabified word labels to a word level that already contains canonical pronunciations.</p></a></li>
<li><a href='#runBASwebservice_pho2sylSegmental'><p>Creates a syllable segmentation on the basis of a phonetic segmentation.</p></a></li>
<li><a href='#segmentlist'><p>Segment list</p></a></li>
<li><a href='#serve'><p>Serve EMU database to EMU-webApp</p></a></li>
<li><a href='#SetGetlevelCanvasesOrder'><p>Set / Get level canvases order of emuDB</p></a></li>
<li><a href='#SetGetRemoveLegalLabels'><p>Set / Get / Remove legal labels of attributeDefinition of emuDB</p></a></li>
<li><a href='#SetGetSignalCanvasesOrder'><p>Set / Get signalCanvasesOrder of / to / from emuDB</p></a></li>
<li><a href='#shift'><p>Function to shift the elements of a vector.</p></a></li>
<li><a href='#Slope.test'><p>Slope Test</p></a></li>
<li><a href='#sort.emuRsegs'><p>Sort emuRsegs segment list by session, bundle and sample_start</p></a></li>
<li><a href='#sortmatrix'><p>Sort matrix by label</p></a></li>
<li><a href='#splitstring'><p>Split a string into words.</p></a></li>
<li><a href='#start.emusegs'><p>Start and end times for EMU segment lists and trackdata objects</p></a></li>
<li><a href='#summary.emuDBhandle'><p>Print summary of loaded EMU database (emuDB).</p></a></li>
<li><a href='#summary.emusegs'><p>summary emusegs</p></a></li>
<li><a href='#summary.trackdata'><p>summary trackdata</p></a></li>
<li><a href='#track.gradinfo'><p>Calculate gradient summary information for trackdata</p></a></li>
<li><a href='#track.gradinfo.sub'><p>track gradinfo sub</p></a></li>
<li><a href='#trackdata'><p>Track data object</p></a></li>
<li><a href='#trackfreq'><p>function to find the frequencies of a spectral object</p></a></li>
<li><a href='#tracktimes'><p>Get the track times from EMU trackdata objects</p></a></li>
<li><a href='#train'><p>Train a Gaussian Model</p></a></li>
<li><a href='#trapply'><p>A method of the generic function by for objects of class 'trackdata'</p></a></li>
<li><a href='#update_itemsInLevel'><p>Update items programmatically</p></a></li>
<li><a href='#vowlax'><p>Segment list of four lax vowels, read speech, one male and one female</p>
speaker of Standard North German from database kielread.</a></li>
<li><a href='#vowlax.df'><p>Data frame of various parameters and labels from the segment list vowlax</p></a></li>
<li><a href='#vowlax.dft.5'><p>Spectral matrix centred at the temporal midpoint of the vowels from the</p>
segment list vowlax.</a></li>
<li><a href='#vowlax.fdat'><p>Trackdata of formants from the segment list vowlax</p></a></li>
<li><a href='#vowlax.fdat.5'><p>Matrix of formant data extracted at the temporal midpoint from the segment</p>
list vowlax.</a></li>
<li><a href='#vowlax.fund'><p>Trackdata of fundamental frequency from the segment list vowlax</p></a></li>
<li><a href='#vowlax.fund.5'><p>Vector of fundamental frequency extracted at the temporal midpoint from the</p>
segment list vowlax.</a></li>
<li><a href='#vowlax.l'><p>Vector of phoneme labels from the segment list vowlax</p></a></li>
<li><a href='#vowlax.left'><p>Vector of labels preceding the vowels from the segment list vowlax</p></a></li>
<li><a href='#vowlax.right'><p>Vector of labels following the vowels from the segment list vowlax</p></a></li>
<li><a href='#vowlax.rms'><p>Trackdata of RMS energy from the segment list vowlax</p></a></li>
<li><a href='#vowlax.rms.5'><p>Vector of RMS energy values at the temporal midpoint extracted at the</p>
temporal midpoint from the segment list vowlax</a></li>
<li><a href='#vowlax.spkr'><p>Vector of speaker labels from the segment list vowlax.</p></a></li>
<li><a href='#vowlax.word'><p>Vector of word labels from the segment list vowlax.</p></a></li>
<li><a href='#wordlax.l'><p>Vector of word labels from segment list wordlax</p></a></li>
<li><a href='#write_bundleList'><p>write bundleList</p></a></li>
<li><a href='#write.emusegs'><p>Write an Emu segment list to a file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-15</td>
</tr>
<tr>
<td>Title:</td>
<td>Main Package of the EMU Speech Database Management System</td>
</tr>
<tr>
<td>Description:</td>
<td>Provide the EMU Speech Database Management System (EMU-SDMS) with
    database management, data extraction, data preparation and data
    visualization facilities. See <a href="https://ips-lmu.github.io/The-EMU-SDMS-Manual/">https://ips-lmu.github.io/The-EMU-SDMS-Manual/</a>
    for more details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tools, utils, graphics, methods, rlang, stringr (&ge; 1.4.0),
uuid, base64enc, shiny, wrassp (&ge; 0.1.4), jsonlite (&ge; 1.6.1),
RSQLite (&ge; 2.0.0), DBI (&ge; 0.3.1), httpuv (&ge; 1.3.2), dplyr
(&ge; 0.7.8), readr (&ge; 1.1.1), tibble (&ge; 1.4.2), purrr (&ge;
0.2.4), tidyr(&ge; 0.8.2), mime(&ge; 0.6), rstudioapi(&ge; 0.10),
httr(&ge; 1.4.1), V8(&ge; 3.4.0), cli(&ge; 2.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>stats, grDevices, MASS, ggplot2(&ge; 2.1.0), testthat(&ge;
0.7.1.99), compare(&ge; 0.2.4), knitr(&ge; 1.7), rmarkdown(&ge;
0.9.2)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ZipData:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/IPS-LMU/emuR">https://github.com/IPS-LMU/emuR</a>,
<a href="https://ips-lmu.github.io/The-EMU-SDMS-Manual/">https://ips-lmu.github.io/The-EMU-SDMS-Manual/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/IPS-LMU/emuR/issues">https://github.com/IPS-LMU/emuR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-15 22:07:50 UTC; markus</td>
</tr>
<tr>
<td>Author:</td>
<td>Markus Jochim <a href="https://orcid.org/0000-0002-5638-4870"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Raphael Winkelmann [aut],
  Klaus Jaensch [aut, ctb],
  Steve Cassidy [aut, ctb],
  Jonathan Harrington [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Markus Jochim &lt;markusjochim@phonetik.uni-muenchen.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-15 22:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.EPG'>expand EPG</h2><span id='topic++5B.EPG'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EPG'
palates[i, j, k]
</code></pre>

<hr>
<h2 id='+5B.spectral'>Expand spectral</h2><span id='topic++5B.spectral'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectral'
dat[i, j, drop]
</code></pre>

<hr>
<h2 id='+5B.trackdata'>Expand trackdata</h2><span id='topic++5B.trackdata'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackdata'
dataset[i, j, ...]
</code></pre>

<hr>
<h2 id='add_files'>Add files to emuDB</h2><span id='topic+add_files'></span>

<h3>Description</h3>

<p>Add files to existing bundles of specified session of emuDB.
Do not use this function to import new recordings (media files) and create bundles; 
see <code>?import_mediaFiles</code> to import new recordings.
The files that are found in <code>dir</code> that have the extension 
<code>fileExtension</code> will be copied into the according bundle
folder that have the same basename as the file. Note that the 
same bundle name may appear in different sessions, therefore you must 
specify the session in <code>targetSessionName</code>. For 
more information on the structural elements of an emuDB 
see <code>vignette{emuDB}</code>.
Note that adding files does not mean the emuDB is automatically using these, unless
you have defined the usage of these files (e.g. by ssffTrackDefinitions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_files(emuDBhandle, dir, fileExtension, targetSessionName = "0000")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_files_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="add_files_+3A_dir">dir</code></td>
<td>
<p>directory containing files to be added</p>
</td></tr>
<tr><td><code id="add_files_+3A_fileextension">fileExtension</code></td>
<td>
<p>file extension of files to be added. If no . (dot) is found 
in this string (e.g. &quot;zcr&quot;) then the bundle name matching is performed by removing 
<code>paste0(".", fileExtension)</code> from the files (&quot;/path/to/msajc003.zcr&quot; will become &quot;msajc003&quot;) 
and the according bundle name will be searched. If a . (dot) if found within this string 
(e.g. &quot;_annot.json&quot;) then the entire string is remove without prepending a . (dot) (&quot;/path/to/msajc003_annot.json&quot; will then become &quot;msajc003&quot;)</p>
</td></tr>
<tr><td><code id="add_files_+3A_targetsessionname">targetSessionName</code></td>
<td>
<p>name of sessions containing 
bundles that the files will be added to</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

# specify path to folder containing the following
# files we wish to add to: 
# msajc003.zcr, msajc010.zcr, msajc012.zcr, msajc015.zcr, 
# msajc022.zcr, msajc023.zcr and msajc057.zcr 
path2dir = "/path/to/dir/"

# add the files to session "0000" of the "ae" emuDB
add_files(emuDBhandle = ae,
          dir = path2dir,
          fileExtension = "zcr",
          targetSessionName = "0000")


## End(Not run)
</code></pre>

<hr>
<h2 id='AddListRemoveAttrDefLabelGroup'>Add / List / Remove labelGroup to / of / from attributeDefinition of emuDB</h2><span id='topic+AddListRemoveAttrDefLabelGroup'></span><span id='topic+add_attrDefLabelGroup'></span><span id='topic+list_attrDefLabelGroups'></span><span id='topic+remove_attrDefLabelGroup'></span>

<h3>Description</h3>

<p>Add / List / Remove label group to / of / from a specific attribute definition. 
This label group can be used as a short hand  
to reference groups of labels specific
to an attribute definition (compared to global label groups that 
are added by <code><a href="#topic+add_labelGroup">add_labelGroup</a></code>) in a 
<code><a href="#topic+query">query</a></code>. A common example would be to
add a label group for something like the phonetic
category of nasals to be able reference them 
as &quot;nasals&quot; in a <code><a href="#topic+query">query</a></code>. For more information 
on the structural elements of an emuDB see <code>vignette(emuDB)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_attrDefLabelGroup(
  emuDBhandle,
  levelName,
  attributeDefinitionName,
  labelGroupName,
  labelGroupValues
)

list_attrDefLabelGroups(emuDBhandle, levelName, attributeDefinitionName)

remove_attrDefLabelGroup(
  emuDBhandle,
  levelName,
  attributeDefinitionName,
  labelGroupName
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddListRemoveAttrDefLabelGroup_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="AddListRemoveAttrDefLabelGroup_+3A_levelname">levelName</code></td>
<td>
<p>name of level</p>
</td></tr>
<tr><td><code id="AddListRemoveAttrDefLabelGroup_+3A_attributedefinitionname">attributeDefinitionName</code></td>
<td>
<p>name of attributeDefinition</p>
</td></tr>
<tr><td><code id="AddListRemoveAttrDefLabelGroup_+3A_labelgroupname">labelGroupName</code></td>
<td>
<p>name of label group</p>
</td></tr>
<tr><td><code id="AddListRemoveAttrDefLabelGroup_+3A_labelgroupvalues">labelGroupValues</code></td>
<td>
<p>character vector of labels</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>add_labelGroup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

sampaNasals = c("m", "F", "n", "J", "N")

# add these values to the default Phonetic attribute
# definition of the Phonetic level of the ae emuDB
add_attrDefLabelGroup(emuDBhandle = ae,
                      levelName = "Phonetic",
                      attributeDefinitionName = "Phonetic",
                      labelGroupName = "sampaNasals",
                      labelGroupValues = sampaNasals)

# query the labelGroup
query(ae, "Phonetic=sampaNasals")


# list attribute definition label groups
# of attributeDefinition "Phonetic" of the level "Phonetic"
# of the ae emuDB
list_attrDefLabelGroups(emuDBhandle = ae, 
                        levelName = "Phonetic" , 
                        attributeDefinitionName = "Phonetic")

# remove the newly added attrDefLabelGroup
remove_attrDefLabelGroup(emuDBhandle = ae,
                         levelName = "Phonetic",
                         attributeDefinitionName = "Phonetic",
                         labelGroupName = "sampaNasals")


## End(Not run)

</code></pre>

<hr>
<h2 id='AddListRemoveLabelGroup'>Add / List / Remove global labelGroup to / of / from emuDB</h2><span id='topic+AddListRemoveLabelGroup'></span><span id='topic+add_labelGroup'></span><span id='topic+list_labelGroups'></span><span id='topic+remove_labelGroup'></span>

<h3>Description</h3>

<p>Add / List / Remove label group that can be used as a short hand  
to reference groups of labels that are globally defined
for the entire database (compared to attribute definition
specific label groups that 
are added by <code><a href="#topic+add_attrDefLabelGroup">add_attrDefLabelGroup</a></code>) in a 
<code><a href="#topic+query">query</a></code>. A common example would be to
add a label group for something like the phonetic
category of nasals to be able to reference them 
as &quot;nasals&quot; in a <code><a href="#topic+query">query</a></code>. 
In theory you could use a labelGroupName as a label instance within the
level, but since this could lead to serious confusion, it is better avoided.
For users transitioning from the legacy EMU system: Do not confuse a 
labelGroup with legal labels: a labelGroup 
had the unfortunate name 'legal labels' in the legacy EMU system.  
For more information on the structural elements of an emuDB 
see <code>vignette{emuDB}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_labelGroup(emuDBhandle, name, values)

list_labelGroups(emuDBhandle)

remove_labelGroup(emuDBhandle, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddListRemoveLabelGroup_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="AddListRemoveLabelGroup_+3A_name">name</code></td>
<td>
<p>name of label group</p>
</td></tr>
<tr><td><code id="AddListRemoveLabelGroup_+3A_values">values</code></td>
<td>
<p>character vector of labels</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>add_attrDefLabelGroup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

sampaNasals = c("m", "F", "n", "J", "N")

# add these values to the ae emuDB
# as a globally available labelGroup
add_labelGroup(emuDBhandle = ae,
               name = "sampaNasals",
               values = sampaNasals)

# query the labelGroup in the "Phonetic" level
query(emuDBhandle = ae, 
      query = "Phonetic == sampaNasals")

# query the labelGroup in the "Phoneme" level
query(emuDBhandle = ae, 
      query = "Phoneme == sampaNasals")

# list global label groups of ae emuDB
list_labelGroups(emuDBhandle = ae)

# remove the newly added labelGroup
remove_labelGroup(emuDBhandle = ae,
                  name = "sampaNasals")

## End(Not run)

</code></pre>

<hr>
<h2 id='AddListRemoveLevelDefinitions'>Add / List / Remove level definition to / of / from emuDB</h2><span id='topic+AddListRemoveLevelDefinitions'></span><span id='topic+add_levelDefinition'></span><span id='topic+list_levelDefinitions'></span><span id='topic+remove_levelDefinition'></span>

<h3>Description</h3>

<p>Add / List / Remove database operation functions for level definitions. 
A level is a more general term for what is often referred to as a &quot;tier&quot;. 
It is more general in the sense that people usually 
expect tiers to contain time information. Levels 
can either contain time information if they are of the 
type &quot;EVENT&quot; or of the type &quot;SEGMENT&quot; but are timeless 
if they are of the type &quot;ITEM&quot;. For more information 
on the structural elements of an emuDB see <code>vignette(emuDB)</code>.
Note that a level cannot be removed, if it contains instances of annotation items
or if it is linked to another level. Further note, renaming a level definition 
can be done using <code><a href="#topic+rename_attributeDefinition">rename_attributeDefinition</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_levelDefinition(
  emuDBhandle,
  name,
  type,
  rewriteAllAnnots = TRUE,
  verbose = TRUE
)

list_levelDefinitions(emuDBhandle)

remove_levelDefinition(
  emuDBhandle,
  name,
  rewriteAllAnnots = TRUE,
  force = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddListRemoveLevelDefinitions_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="AddListRemoveLevelDefinitions_+3A_name">name</code></td>
<td>
<p>name of level definition</p>
</td></tr>
<tr><td><code id="AddListRemoveLevelDefinitions_+3A_type">type</code></td>
<td>
<p>type of level definition (&quot;SEGMENT&quot;,&quot;EVENT&quot;,&quot;ITEM&quot;)</p>
</td></tr>
<tr><td><code id="AddListRemoveLevelDefinitions_+3A_rewriteallannots">rewriteAllAnnots</code></td>
<td>
<p>should changes be written to file system (_annot.json files) (intended for expert use only)</p>
</td></tr>
<tr><td><code id="AddListRemoveLevelDefinitions_+3A_verbose">verbose</code></td>
<td>
<p>Show progress bars and further information</p>
</td></tr>
<tr><td><code id="AddListRemoveLevelDefinitions_+3A_force">force</code></td>
<td>
<p>delete all items incl. links pointing to those items from the levels</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

# add level called "Phonetic2" to the ae emuDB
# that could for example contain the transcriptions of a second annotator
add_levelDefinition(emuDBhandle = ae,
                    name = "Phonetic2",
                    type = "SEGMENT")
                    
# list level definition of ae emuDB
list_levelDefinitions(emuDBhandle = ae)

# remove newly added level definition
remove_levelDefinitions(emuDBhandle = ae,
                        name = "Phonetic2")

## End(Not run)

</code></pre>

<hr>
<h2 id='AddListRemoveLinkDefinition'>Add / List / Remove linkDefinition to / of / from emuDB</h2><span id='topic+AddListRemoveLinkDefinition'></span><span id='topic+add_linkDefinition'></span><span id='topic+list_linkDefinitions'></span><span id='topic+remove_linkDefinition'></span>

<h3>Description</h3>

<p>Add / List / Remove new link definition to / of / from emuDB. A link definition
specifies the relationship between two levels, the
super-level and the sub-level. The entirety of all link 
definitions of a emuDB specifies the 
hierarchical structure of the database. For more information
on the structural elements of an emuDB see <code>vignette(emuDB)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_linkDefinition(emuDBhandle, type, superlevelName, sublevelName)

list_linkDefinitions(emuDBhandle)

remove_linkDefinition(
  emuDBhandle,
  superlevelName,
  sublevelName,
  force = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddListRemoveLinkDefinition_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="AddListRemoveLinkDefinition_+3A_type">type</code></td>
<td>
<p>type of linkDefinition (either <code>"ONE_TO_MANY"</code>, <code>"MANY_TO_MANY"</code> or <code>"ONE_TO_ONE"</code>)</p>
</td></tr>
<tr><td><code id="AddListRemoveLinkDefinition_+3A_superlevelname">superlevelName</code></td>
<td>
<p>name of super-level of linkDefinition</p>
</td></tr>
<tr><td><code id="AddListRemoveLinkDefinition_+3A_sublevelname">sublevelName</code></td>
<td>
<p>name of sub-level of linkDefinition</p>
</td></tr>
<tr><td><code id="AddListRemoveLinkDefinition_+3A_force">force</code></td>
<td>
<p>delete all links belonging to the linkDefinition (<strong>USE WITH CAUTION! VERY INVASIVE AKTION!</strong>)</p>
</td></tr>
<tr><td><code id="AddListRemoveLinkDefinition_+3A_verbose">verbose</code></td>
<td>
<p>be verbose. Ask to delete links if <code>force</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Link type descriptions:
</p>

<ul>
<li><p><code>"ONE_TO_MANY"</code>: A single ITEM of the super-level can be linked to multiple ITEMs of the sub-level
</p>
</li>
<li><p><code>"MANY_TO_MANY"</code>: Multiple ITEMs of the super-level can be linked to multiple ITEMs of the sub-level
</p>
</li>
<li><p><code>"ONE_TO_ONE"</code>: A single ITEM of the super-level can be linked to a single ITEM of the sub-level
</p>
</li></ul>

<p>For all link types the rule applies that no links are allowed to cross any other links.
Further, a linkDefinition can not be removed, if there are links present in the emuDB.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded emuDB that was converted
# using the convert_TextGridCollection function called myTGcolDB
# (see ?load_emuDB and ?convert_TextGridCollection for more information)

# add link definition from super-level "Phoneme"
# to sub-level "Phonetic" of type "ONE_TO_MANY"
# for myTGcolDB emuDB
add_linkDefinition(emuDBhandle = myTGcolDB,
                   type = "ONE_TO_MANY",
                   superlevelName = "Phoneme",
                   sublevelName = "Phonetic")

# list link definitions for myTGcolDB emuDB
list_linkDefinitions(emuDBhandle = myTGcolDB)

# remove newly added link definition
remove_linkDefinition(emuDBhandle = myTGcolDB,
                      superlevelName = "Phoneme",
                      sublevelName = "Phonetic")



## End(Not run)
</code></pre>

<hr>
<h2 id='AddListRemovePerspective'>Add / List / Remove perspective to / of / from emuDB</h2><span id='topic+AddListRemovePerspective'></span><span id='topic+add_perspective'></span><span id='topic+list_perspectives'></span><span id='topic+remove_perspective'></span>

<h3>Description</h3>

<p>Add / List / Remove perspective to / of / from emuDB. The EMU-webApp subdivides different ways 
to look at an emuDB into so called perspectives. These perspectives, 
between which you can switch in the web application, contain 
information on what levels are displayed, which ssffTracks are drawn, 
and so on. For more information on the structural elements of an emuDB 
see <code>vignette{emuDB}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_perspective(emuDBhandle, name)

list_perspectives(emuDBhandle)

remove_perspective(emuDBhandle, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddListRemovePerspective_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="AddListRemovePerspective_+3A_name">name</code></td>
<td>
<p>name of perspective</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

# add perspective called "justTones" to the ae emuDB
add_perspective(emuDBhandle = ae,
                name = "justTones") 
                
# add levelCanvasOrder so only the "Tone" level is displayed
set_levelCanvasesOrder(emuDBhandle = ae, 
                       perspectiveName = "justTones", 
                       order = c("Tone"))

# list perspectives of ae emuDB
list_perspectives(emuDBhandle = ae)

# remove newly added perspective
remove_perspective(emuDBhandle = ae,
                   name = "justTones")
                   

## End(Not run)

</code></pre>

<hr>
<h2 id='AddListRemoveSsffTrackDefinition'>Add / List / Remove ssffTrackDefinition to / from / of emuDB</h2><span id='topic+AddListRemoveSsffTrackDefinition'></span><span id='topic+add_ssffTrackDefinition'></span><span id='topic+list_ssffTrackDefinitions'></span><span id='topic+remove_ssffTrackDefinition'></span>

<h3>Description</h3>

<p>Add / List / Remove ssffTrackDefinition to / from / of emuDB. 
An ssffTrack (often simply referred to as a track) references 
data that is stored in the Simple Signal File Format (SSFF) 
in the according bundle folders. The two most common types of data are:
</p>

<ul>
<li><p>complementary data that was acquired during the recording 
such as data acquired during electromagnetic 
articulographic (EMA) or electropalatography (EPG) recordings;
</p>
</li>
<li><p>derived data, i.e. data that was calculated from the original audio signal 
such as formant values and their bandwidths or the short-term Root Mean Square amplitude of the signal.
</p>
</li></ul>

<p>For more information on the structural elements of an emuDB see <code>vignette(emuDB)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_ssffTrackDefinition(
  emuDBhandle,
  name,
  columnName = NULL,
  fileExtension = NULL,
  fileFormat = NULL,
  onTheFlyFunctionName = NULL,
  onTheFlyParams = NULL,
  onTheFlyOptLogFilePath = NULL,
  verbose = TRUE,
  interactive = TRUE
)

list_ssffTrackDefinitions(emuDBhandle)

remove_ssffTrackDefinition(emuDBhandle, name, deleteFiles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddListRemoveSsffTrackDefinition_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="AddListRemoveSsffTrackDefinition_+3A_name">name</code></td>
<td>
<p>name of ssffTrackDefinition</p>
</td></tr>
<tr><td><code id="AddListRemoveSsffTrackDefinition_+3A_columnname">columnName</code></td>
<td>
<p>columnName of ssffTrackDefinition.
If the <code>onTheFlyFunctionName</code> parameter is set and columnName isn't, the
<code>columnName</code> will default to the first entry in <code>wrasspOutputInfos[[onTheFlyFunctionName]]$tracks</code>.</p>
</td></tr>
<tr><td><code id="AddListRemoveSsffTrackDefinition_+3A_fileextension">fileExtension</code></td>
<td>
<p>fileExtension of ssffTrackDefinitions.
If the <code>onTheFlyFunctionName</code> parameter is set and fileExtension isn't, the
<code>fileExtension</code> will default to the first entry in <code>wrasspOutputInfos[[onTheFlyFunctionName]]$ext</code>.</p>
</td></tr>
<tr><td><code id="AddListRemoveSsffTrackDefinition_+3A_fileformat">fileFormat</code></td>
<td>
<p>(optional) file format of ssffTrackDefinition. This is currently in test phase. Can be ssff,
Rda or NULL. Defaults to ssff.</p>
</td></tr>
<tr><td><code id="AddListRemoveSsffTrackDefinition_+3A_ontheflyfunctionname">onTheFlyFunctionName</code></td>
<td>
<p>name of wrassp function to do on-the-fly calculation. If set to the name of a wrassp 
signal processing function, not only the emuDB schema is extended by the ssffTrackDefintion but also 
the track itself is calculated from the signal file and stored in the emuDB. See <code>names(wrasspOutputInfos)</code>
for a list of all the signal processing functions provided by the wrassp package.</p>
</td></tr>
<tr><td><code id="AddListRemoveSsffTrackDefinition_+3A_ontheflyparams">onTheFlyParams</code></td>
<td>
<p>a list of parameters that will be given to the function 
passed in by the onTheFlyFunctionName parameter. This list can easily be 
generated using the <code><a href="base.html#topic+formals">formals</a></code> function on the according signal processing function 
provided by the wrassp package and then setting the
parameter one wishes to change.</p>
</td></tr>
<tr><td><code id="AddListRemoveSsffTrackDefinition_+3A_ontheflyoptlogfilepath">onTheFlyOptLogFilePath</code></td>
<td>
<p>path to optional log file for on-the-fly function</p>
</td></tr>
<tr><td><code id="AddListRemoveSsffTrackDefinition_+3A_verbose">verbose</code></td>
<td>
<p>Show progress bars and further information</p>
</td></tr>
<tr><td><code id="AddListRemoveSsffTrackDefinition_+3A_interactive">interactive</code></td>
<td>
<p>ask user for confirmation</p>
</td></tr>
<tr><td><code id="AddListRemoveSsffTrackDefinition_+3A_deletefiles">deleteFiles</code></td>
<td>
<p>delete files that belong to ssffTrackDefinition on removal</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

# add ssff track definition to ae emuDB
# calculating the according SSFF files (.zcr) on-the-fly
# using the wrassp function "zcrana" (zero-crossing-rate analysis)
add_ssffTrackDefinition(emuDBhandle = ae,
                        name = "ZCRtrack",
                        onTheFlyFunctionName = "zcrana")
                        
# add ssff track definition to ae emuDB
# for SSFF files that will be added later (either
# by adding files to the emuDB using 
# the add_files() function or by calculating
# them using the according function provided 
# by the wrassp package)
add_ssffTrackDefinition(emuDBhandle = ae,
                        name = "formants",
                        columnName = "fm",
                        fileExtension = "fms")

# list ssff track definitions for ae emuDB
list_ssffTrackDefinitions(emuDBhandle = ae)

# remove newly added ssff track definition (does not delete 
# the actual .zcr files)
remove_ssffTrackDefinition(emuDBhandle = ae,
                           name = "ZCRtrack")


## End(Not run)

</code></pre>

<hr>
<h2 id='AddListRenameRemoveAttributeDefinitions'>Add / List / Rename / Remove attribute definition to / of / from emuDB</h2><span id='topic+AddListRenameRemoveAttributeDefinitions'></span><span id='topic+add_attributeDefinition'></span><span id='topic+list_attributeDefinitions'></span><span id='topic+rename_attributeDefinition'></span><span id='topic+remove_attributeDefinition'></span>

<h3>Description</h3>

<p>Add / List / Rename / Remove database operation functions for attribute
definition to / of / from an existing level definition of an emuDB.
Attribute definitions can be viewed as definitions of
parallel labels for the annotational units (ITEMs) of the emuDB. 
Each level definition is required to have at least one 
default attribute definition that has the same name as the level definition
(automatically created by <code><a href="#topic+add_levelDefinition">add_levelDefinition</a></code>). For more 
information on the structural elements of an emuDB see <code>vignette(emuDB)</code>.
Note that as with level definitions, an attribute definition to a level cannot be removed,
if it contains labels in the emuDB.
</p>
<p>As the only one of these operations, <code>rename_attributeDefinition</code> can
also be used to manipulate (i.e. rename) a level definition. It is therefore
not necessary to specify the name of the level that the attribute definition
belongs to. While renaming a level or attribute definition, emuR will
(1) rewrite the levelDefinitions in DBconfig, (2) rewrite the
linkDefinitions in DBconfig, (3) rewrite the perspectives in DBconfig,
(4) rewrite the anagestConfig in DBconfig, and (5) rewrite all _annot.json
files. (5) May take quite a while, depending on the number of bundles in the
database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_attributeDefinition(
  emuDBhandle,
  levelName,
  name,
  type = "STRING",
  rewriteAllAnnots = TRUE,
  verbose = TRUE
)

list_attributeDefinitions(emuDBhandle, levelName)

rename_attributeDefinition(
  emuDBhandle,
  origAttrDef,
  newAttrDef,
  verbose = TRUE
)

remove_attributeDefinition(
  emuDBhandle,
  levelName,
  name,
  force = FALSE,
  rewriteAllAnnots = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddListRenameRemoveAttributeDefinitions_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="AddListRenameRemoveAttributeDefinitions_+3A_levelname">levelName</code></td>
<td>
<p>name of level</p>
</td></tr>
<tr><td><code id="AddListRenameRemoveAttributeDefinitions_+3A_name">name</code></td>
<td>
<p>name of attributeDefinition</p>
</td></tr>
<tr><td><code id="AddListRenameRemoveAttributeDefinitions_+3A_type">type</code></td>
<td>
<p>type of attributeDefinition (currently only &quot;STRING&quot;)</p>
</td></tr>
<tr><td><code id="AddListRenameRemoveAttributeDefinitions_+3A_rewriteallannots">rewriteAllAnnots</code></td>
<td>
<p>should changes be written to file system (_annot.json files) (intended for expert use only)</p>
</td></tr>
<tr><td><code id="AddListRenameRemoveAttributeDefinitions_+3A_verbose">verbose</code></td>
<td>
<p>if set to <code>TRUE</code>, more status messages are printed</p>
</td></tr>
<tr><td><code id="AddListRenameRemoveAttributeDefinitions_+3A_origattrdef">origAttrDef</code></td>
<td>
<p>name of level/attribute definition in emuDB that is to be changed</p>
</td></tr>
<tr><td><code id="AddListRenameRemoveAttributeDefinitions_+3A_newattrdef">newAttrDef</code></td>
<td>
<p>new name that shall be assigned to the level/attribute definition</p>
</td></tr>
<tr><td><code id="AddListRenameRemoveAttributeDefinitions_+3A_force">force</code></td>
<td>
<p>delete all attribute definitions in annotations (== label entries)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

# add additional attribute definition to the "Phonetic" level
# of the ae emuDB that will contain the UTF8 IPA
# symbols of the phonetic transcriptions
add_attributeDefinition(emuDBhandle = ae,
                        levelName = "Phonetic",
                        name = "IPA-UTF8")
                        
# list attribute definitions for level "Word"
# of the ae emuDB
list_attributeDefinitions(emuDBhandle = ae, 
                          levelName = "Word")

# remove newly added attributeDefinition
remove_attributeDefinition(emuDBhandle = ae,
                           levelName = "Phonetic",
                           name = "IPA-UTF8")

## End(Not run)

</code></pre>

<hr>
<h2 id='as.matrix.emusegs'>as.matrix.emusegs</h2><span id='topic+as.matrix.emusegs'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emusegs'
as.matrix(x, ...)
</code></pre>

<hr>
<h2 id='as.spectral'>Function to convert an object into an object of class 'spectral'.</h2><span id='topic+as.spectral'></span>

<h3>Description</h3>

<p>The function converts a vector, matrix, or EMU-trackdata object into an
object of the same class and of class 'spectral'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.spectral(trackdata, fs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.spectral_+3A_trackdata">trackdata</code></td>
<td>
<p>A vector, matrix, or EMU-trackdata object.</p>
</td></tr>
<tr><td><code id="as.spectral_+3A_fs">fs</code></td>
<td>
<p>Either a single element numeric vector, or a numeric vector of
the same length as the length of trackdata if trackdata is a vector, or of
the same number of rows as trackdata</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If fs is a single element numeric vector, then the frequencies of trackdata
are defined to extend to fs/2. If fs is missing, then the frequencies are
0:(N-1) where N is the length of trackdata.
</p>


<h3>Value</h3>

<p>The same object but of class 'spectral'.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.spectral">is.spectral</a></code> <code><a href="#topic+plot.spectral">plot.spectral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vec = 1:10
as.spectral(vec, 2000)
mat = rbind(1:10, 1:10)
as.spectral(mat)
# turn a spectral trackdata object into a trackdata object
tr = as.trackdata(rbind(fric.dft$data), fric.dft$index, fric.dft$ftime)
# turn it into a spectral trackdata object with sampling freq 16 kHz
tr = as.spectral(tr, 16000)
# list the frequencies
trackfreq(tr)
# Notice that only the $data is made into a spectral matrix,
# not the entire trackdata object
# so this is trackdata
class(tr)
# this is a spectral matrix
class(tr$data)




</code></pre>

<hr>
<h2 id='as.trackdata'>Create an Emu trackdata object</h2><span id='topic+as.trackdata'></span>

<h3>Description</h3>

<p>Create an Emu trackdata object from a raw data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.trackdata(data, index, ftime, trackname = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.trackdata_+3A_data">data</code></td>
<td>
<p>A two dimensional matrix of numerical data.</p>
</td></tr>
<tr><td><code id="as.trackdata_+3A_index">index</code></td>
<td>
<p>Segment index, one row per segment, two columns give the start
and end rows in the <code>data</code> matrix for each segment.</p>
</td></tr>
<tr><td><code id="as.trackdata_+3A_ftime">ftime</code></td>
<td>
<p>A two column matrix with one row per segment, gives the start
and end times in milliseconds for each segment.</p>
</td></tr>
<tr><td><code id="as.trackdata_+3A_trackname">trackname</code></td>
<td>
<p>The name of the track.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Emu trackdata objects contain possibly multi-column numerical data
corresponding to a set of segments from a database.  Data for each segment
takes up a number of rows in the main <code>data</code> matrix, the start and end
rows are stored in the <code>index</code> component.  The <code>ftime</code> component
contains the start and end times of the segment data.
</p>
<p>Trackdata objects are returned by the <code><a href="#topic+get_trackdata">get_trackdata</a></code> function.
</p>


<h3>Value</h3>

<p>The components are bound into a trackdata object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_trackdata">get_trackdata</a></code> <code><a href="#topic+dplot">dplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# make a trackdata object of two data segments
data1 &lt;- matrix( 1:10, ncol=2 )
data2 &lt;- matrix( 11:20, ncol=2 )

nd1 &lt;- nrow(data1)
nd2 &lt;- nrow(data2)
index &lt;- rbind( c( 1, nd1 ), c(nd1+1,nd1+nd2) )

times &lt;- rbind( c( 100.0, 110.0 ), c( 200.0, 210.0 ) )

tdata &lt;- as.trackdata( rbind( data1, data2 ), index, times, trackname="fake")

# describe the data
summary(tdata)
# get the data for the first segment
tdata[1]
# and the second
tdata[2]


</code></pre>

<hr>
<h2 id='autobuild_linkFromTimes'>Autobuild links between two levels using their time information</h2><span id='topic+autobuild_linkFromTimes'></span>

<h3>Description</h3>

<p>Autobuild links between two time levels. This is typically done when converting from 
a database / annotation format that allows parallel time tiers / levels but does 
not permit annotational units to be linked to each other, except by 
matching time information (such as Praat's TextGrid format). The super-level has to be of the 
type SEGMENT and the sub-level either of type EVENT or of type SEGMENT. If
this is the case and a according link definition is defined for the emuDB,
this function automatically links the events or segments of the sub-level which occur
within (startSample to (startSample + sampleDur)) the segments of the super-level to those segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autobuild_linkFromTimes(
  emuDBhandle,
  superlevelName,
  sublevelName,
  rewriteAllAnnots = TRUE,
  convertSuperlevel = FALSE,
  backupLevelAppendStr = "-autobuildBackup",
  newLinkDefType = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autobuild_linkFromTimes_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="autobuild_linkFromTimes_+3A_superlevelname">superlevelName</code></td>
<td>
<p>name of level to link from (link definition required in emuDB)</p>
</td></tr>
<tr><td><code id="autobuild_linkFromTimes_+3A_sublevelname">sublevelName</code></td>
<td>
<p>name of level to link to (link definition required in emuDB)</p>
</td></tr>
<tr><td><code id="autobuild_linkFromTimes_+3A_rewriteallannots">rewriteAllAnnots</code></td>
<td>
<p>should changes be written to file system (_annot.json files) after 
completing autobuild process (intended for expert use only)</p>
</td></tr>
<tr><td><code id="autobuild_linkFromTimes_+3A_convertsuperlevel">convertSuperlevel</code></td>
<td>
<p>if set to TRUE a backup of the superlevel will be created and the actual
superlevel will be converted to a level of type ITEM</p>
</td></tr>
<tr><td><code id="autobuild_linkFromTimes_+3A_backuplevelappendstr">backupLevelAppendStr</code></td>
<td>
<p>string appended to level name for backup level</p>
</td></tr>
<tr><td><code id="autobuild_linkFromTimes_+3A_newlinkdeftype">newLinkDefType</code></td>
<td>
<p>type of new linkDefinition (either <code>"ONE_TO_MANY"</code>, 
<code>"MANY_TO_MANY"</code> or <code>"ONE_TO_ONE"</code>) which is passed to 
<code><a href="#topic+add_linkDefinition">add_linkDefinition</a></code>. If NULL (the default) <code><a href="#topic+add_linkDefinition">add_linkDefinition</a></code> 
isn't called and a linkDefintion is expected to be present.</p>
</td></tr>
<tr><td><code id="autobuild_linkFromTimes_+3A_verbose">verbose</code></td>
<td>
<p>show progress bars and further information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The type of link definition (ONE_TO_MANY, MANY_TO_MANY, ONE_TO_ONE) is relevant whether a link
is generated or not (e.g. overlapping segments are linked in a MANY_TO_MANY relationship 
but not in a ONE_TO_MANY relationship). For more information on the structural 
elements of an emuDB see <code>vignette(emuDB)</code>.
</p>


<h3>See Also</h3>

<p>add_linkDefinition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded myTGcolDB emuDB 
# (see ?create_emuRdemoData, ?convert_TextGridCollection, 
#  and vignette(emuR_intro) for more information)

# add linkDefinition as one has to be present for
# the autobuild function to work
add_linkDefinition(emuDBhandle = myTGcolDB, 
                   type = "ONE_TO_MANY",
                   superlevelName = "Syllable",
                   sublevelName = "Phoneme")
  
# envoke autobuild function to build hierarchy for converted TextGridCollection
autobuild_linkFromTimes(emuDBhandle = myTGcolDB, 
                        superlevelName = "Syllable",
                        sublevelName = "Phoneme",
                        convertSuperlevel = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='bark'>Convert Hertz to Bark and Bark to Hertz</h2><span id='topic+bark'></span><span id='topic+bark.trackdata'></span><span id='topic+bark.spectral'></span><span id='topic+bark.default'></span>

<h3>Description</h3>

<p>The calculation is done using the formulae Traunmueller (1990)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bark(f, inv = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bark_+3A_f">f</code></td>
<td>
<p>A vector or matrix of data or a spectral object.</p>
</td></tr>
<tr><td><code id="bark_+3A_inv">inv</code></td>
<td>
<p>A single element logical vector. If FALSE, data are converted from
Hertz to Bark, if TRUE, data are converted from Bark to Hertz. (Does not apply
if 'data' is an oject of class 'spectral'.</p>
</td></tr>
<tr><td><code id="bark_+3A_...">...</code></td>
<td>
<p>for generic only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'data' is a spectral object, then
</p>
<p>the frequencies are changed so that they are proportional
</p>
<p>to the Bark scale and such that the Bark intervals
</p>
<p>between frequencies are con stant between the lowest
</p>
<p>and highest frequencies. More specifically,
</p>
<p>suppose that a spectral object has frequencies
</p>
<p>at 0, 1000, 2000, 3000, 4000 Hz. Then the corresponding
</p>
<p>frequencies extend in Bark between 0 and 17.46329 Bark
</p>
<p>in four equal intervals, and linear interpolation
</p>
<p>is used with the 'approx' function to obtain
</p>
<p>the dB values at those frequencies. Negative frequencies
</p>
<p>which are obtained for values of about less than 40 Hz
</p>
<p>are removed in the case of spectral objects.
</p>


<h3>Value</h3>

<p>A vector or matrix or spectral object of the same length and dimensions as
data.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>References</h3>

<p>Traunmueller, H. (1990) &quot;Analytical expressions for the
tonotopic sensory scale&quot; J. Acoust. Soc. Am. 88: 97-100.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mel">mel</a></code>,
</p>
<p><code><a href="#topic+plot.spectral">plot.spectral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



   # convert Hertz values to Bark

        vec &lt;- c(500, 1500, 2500)

        vec

        bark(vec)



        

        # convert Hertz values to Bark and back to Hertz

        bark(bark(vec, inv=TRUE))

        



        # convert the $data values in a trackdata object to Bark

        # create a new track data object

        t1 &lt;- dip.fdat

        t1[1]

        



        # convert Hertz to Bark

        t1$data &lt;- bark(t1$data)

        t1[1]



# warp the frequency axis of a spectral object such

# that it is proportional to the Bark scale.

w = bark(e.dft)

oldpar = par(mfrow=c(1,2))

plot(w, type="l")



# The values of w are at equal Bark intervals. Compare

# with

plot(e.dft, freq=bark(trackfreq(e.dft)))

# the latter has a greater concentration of values

# in a higher frequency range.

par(oldpar)


</code></pre>

<hr>
<h2 id='bayes.dist'>bayes dist</h2><span id='topic+bayes.dist'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes.dist(data, train, labels = NULL)
</code></pre>

<hr>
<h2 id='bayes.lab'>bayes lab</h2><span id='topic+bayes.lab'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes.lab(data, train)
</code></pre>

<hr>
<h2 id='bayesian.metric'>bayesian metric</h2><span id='topic+bayesian.metric'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesian.metric(data, mean, cov, invcov)
</code></pre>

<hr>
<h2 id='bayesplot'>bayesplot</h2><span id='topic+bayesplot'></span>

<h3>Description</h3>

<p>bayesplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesplot(
  data,
  train,
  N = 10,
  ellipse = FALSE,
  labs = NULL,
  xlab = "",
  ylab = "",
  colour = TRUE,
  ...
)
</code></pre>

<hr>
<h2 id='bind'>class method bind data</h2><span id='topic+bind'></span>

<h3>Description</h3>

<p>binds data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind(a, ...)
</code></pre>

<hr>
<h2 id='bind.default'>data binding</h2><span id='topic+bind.default'></span>

<h3>Description</h3>

<p>binds data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
bind(...)
</code></pre>

<hr>
<h2 id='bind.trackdata'>bind trackdata</h2><span id='topic+bind.trackdata'></span>

<h3>Description</h3>

<p>binds different trackdata objects together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackdata'
bind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind.trackdata_+3A_...">...</code></td>
<td>
<p>trackdata objects</p>
</td></tr>
</table>

<hr>
<h2 id='bridge'>Three-columned matrix</h2><span id='topic+bridge'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>Three-columned matrix
</p>

<hr>
<h2 id='buildtrack'>Build trackdata objects from the output of by()</h2><span id='topic+buildtrack'></span>

<h3>Description</h3>

<p>buildtrack() converts a list that is the output of by.trackdata() into a
trackdata object if the list components are matrices whose rows are
successive values in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildtrack(mylist, ftime = NULL, trackname = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildtrack_+3A_mylist">mylist</code></td>
<td>
<p>a list that ist output from by()</p>
</td></tr>
<tr><td><code id="buildtrack_+3A_ftime">ftime</code></td>
<td>
<p>ftime</p>
</td></tr>
<tr><td><code id="buildtrack_+3A_trackname">trackname</code></td>
<td>
<p>name of track data object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default of by.trackdata() is to return a list. If each element of the
list consists of a matrix whose rows are values occurring at the times
given by the row dimension names of the matrix, then buildtrack() can be
used to convert the list into a trackdata object. If the times are not
given in the row dimension names, then these can be supplied as an
additional argument to buildtrack()
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+by">by</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   #vowlax.fdat is a track data objects of formant of the vowlax segment list
   #calculate the difference between adjacent formant values
   p = by(vowlax.fdat[1,2],INDICES=NULL, diff)
   
   p
   
   
   #now build a track data object out of these values
   m = buildtrack(p)
   
   m

</code></pre>

<hr>
<h2 id='by.trackdata'>A method of the generic function by for objects of class 'trackdata'</h2><span id='topic+by.trackdata'></span><span id='topic+by'></span>

<h3>Description</h3>

<p>A given function 'FUN' is applied to the data corresponding to each segment
of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackdata'
by(data, INDICES = NULL, FUN, ..., simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by.trackdata_+3A_data">data</code></td>
<td>
<p>a track data object</p>
</td></tr>
<tr><td><code id="by.trackdata_+3A_indices">INDICES</code></td>
<td>
<p>a list of segment indices, like a label vector</p>
</td></tr>
<tr><td><code id="by.trackdata_+3A_fun">FUN</code></td>
<td>
<p>a function that is applied to each segment</p>
</td></tr>
<tr><td><code id="by.trackdata_+3A_...">...</code></td>
<td>
<p>arguments of the function fun</p>
</td></tr>
<tr><td><code id="by.trackdata_+3A_simplify">simplify</code></td>
<td>
<p>simplify = TRUE , output is a matrix; simplify = FALSE a
list is returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is the same as trapply but with the extension to subsume calculation to
groups of segments. Note, if you do not want to apply the function fun to a
special group of segments, use <a href="#topic+trapply">trapply</a> instead.
</p>


<h3>Value</h3>

<p>list or vector
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trapply">trapply</a></code>, <code><a href="#topic+by">by</a></code>, <code><a href="#topic+trackdata">trackdata</a></code>
<code><a href="#topic+dapply">dapply</a></code> <code><a href="stats.html#topic+smooth">smooth</a></code> <code><a href="base.html#topic+apply">apply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(demo.vowels)
  data(demo.vowels.fm)


   #mean F1 subsumed for each vowel
   ################################
   lab = label(demo.vowels)
   by(demo.vowels.fm[,1], lab ,sapply,mean,simplify=FALSE)


   #mean F1 subsumed for segment onsets mids and offsets
   ##############################################
   data = demo.vowels.fm
   llabs = NULL
   for (ind in 1:dim(data$ftime)[1]) {
     seglabs = rep("mid",data$index[ind,2]-data$index[ind,1]+1)
     seglabs[1] = "on"
     seglabs[length(seglabs)] = "off"
     llabs = as.vector(c(llabs , seglabs))
   }

   by(demo.vowels.fm[,1], llabs , sapply, mean , simplify=FALSE)

   #mean F1 subsumed for segment onsets mids and offsets subsumed for each vowel
   #####################################################################
   by(demo.vowels.fm[,1], list(lab = lab, llabs = llabs) , sapply, mean , simplify=FALSE)



</code></pre>

<hr>
<h2 id='cbind.trackdata'>A method of the generic function cbind for objects of class 'trackdata'</h2><span id='topic+cbind.trackdata'></span><span id='topic+cbind'></span>

<h3>Description</h3>

<p>Different track data objects from one segment list are bound by combining
the $data columns of the track data object by columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackdata'
cbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind.trackdata_+3A_...">...</code></td>
<td>
<p>track data objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All track data objects have to be track data of the same segment list.
Thus $index and $ftime values have to be identically for all track data
objects.  Track data objects are created by get_trackdata().  The number of
rows of the track data objects must match.
</p>


<h3>Value</h3>

<p>A track data object with the same $index and ftime values of the
source track data objects and with $data that includes all columns of
$data of the source track data objects.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cbind">cbind</a></code>, <code><a href="#topic+rbind.trackdata">rbind.trackdata</a></code>
<code><a href="#topic+trackdata">trackdata</a></code> <code><a href="#topic+get_trackdata">get_trackdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   data(vowlax)
   
   #segment list vowlax - first segment only 
   vowlax[1,]
   
   #F0 track data object for vowlax - first segment only 
   vowlax.fund[1,]
   
   #rms track data object for vowlax - first segment only 
   vowlax.rms[1,]
      
   
   #now combine both track data objects
   fund.rms.lax = cbind(vowlax.fund, vowlax.rms)
   
   #the combined track data object - first segment only
   #The first column keeps vowlax.fund data, the second keeps vowlax.rms data 
   fund.rms.lax[1,]


</code></pre>

<hr>
<h2 id='cen.sub'>Subfunction of cen</h2><span id='topic+cen.sub'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cen.sub(data)
</code></pre>

<hr>
<h2 id='classify'>classify</h2><span id='topic+classify'></span>

<h3>Description</h3>

<p>classifies data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify(data, train, metric = "bayes")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_+3A_data">data</code></td>
<td>
<p>data to classify</p>
</td></tr>
<tr><td><code id="classify_+3A_train">train</code></td>
<td>
<p>training data</p>
</td></tr>
<tr><td><code id="classify_+3A_metric">metric</code></td>
<td>
<p>bayes or mahal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The classification matrix.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## The function is currently defined as
function (data, train, metric = "bayes") 
{
    probs &lt;- distance(data, train, metric = metric)
    if (metric == "bayes") {
        best &lt;- apply(probs, 1, max)
    }
    else if (metric == "mahal") {
        best &lt;- apply(probs, 1, min)
    }
    result &lt;- rep("", length(best))
    for (lab in 1:length(train$label)) {
        tmp &lt;- probs[, lab] == best
        result[tmp] &lt;- train$label[lab]
    }
    result
  }

</code></pre>

<hr>
<h2 id='classplot'>Produce a classification plot from discriminant or SVM modelling</h2><span id='topic+classplot'></span>

<h3>Description</h3>

<p>The function classifies all point specified within the ranges of xlim and
ylim based on the training model specified in model. It then produces a
two-dimensional plot colour-coded for classifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classplot(
  model,
  xlim,
  ylim,
  N = 100,
  pch = 15,
  col = NULL,
  legend = TRUE,
  position = "topright",
  bg = "gray90",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classplot_+3A_model">model</code></td>
<td>
<p>A two-dimensional training model output from qda(), lda() of
MASS package , or svm() of e1071 package</p>
</td></tr>
<tr><td><code id="classplot_+3A_xlim">xlim</code></td>
<td>
<p>A vector of two numeric elements specifying the range on the
x-axis (parameter 1) over which classifications should be made</p>
</td></tr>
<tr><td><code id="classplot_+3A_ylim">ylim</code></td>
<td>
<p>A vector of two elements specifying the range on the y-axis
(parameter 2) over which classifications should be made</p>
</td></tr>
<tr><td><code id="classplot_+3A_n">N</code></td>
<td>
<p>A vector of one numeric element which specifies the density of
classification (greater N gives higher density). The default is 100.</p>
</td></tr>
<tr><td><code id="classplot_+3A_pch">pch</code></td>
<td>
<p>A single element numeric vector specifying the plotting symbol
to be used in the classification plot. Defaults to 15.</p>
</td></tr>
<tr><td><code id="classplot_+3A_col">col</code></td>
<td>
<p>Either Null in which case the colours for the separate classes
are col = c(1, 2, ...n) where n is the number of classes; or else a vector
specifying the desired colours that is the same length as there are
classes.</p>
</td></tr>
<tr><td><code id="classplot_+3A_legend">legend</code></td>
<td>
<p>A single element logical vector specifying whether a legend
should be drawn. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="classplot_+3A_position">position</code></td>
<td>
<p>A single element vector specifying the position in the
figure where the legend should be drawn. Defaults to &quot;topright&quot;</p>
</td></tr>
<tr><td><code id="classplot_+3A_bg">bg</code></td>
<td>
<p>A single element vector specifying the background colour on which
the legend should be drawn.</p>
</td></tr>
<tr><td><code id="classplot_+3A_...">...</code></td>
<td>
<p>Further arguments to plot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+qda">qda</a></code>, <code><a href="MASS.html#topic+lda">lda</a></code>, svm of e1071
package. There is a function plot.svm which produces a prettier plot for
SVMs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)
# Data from female speaker 68
temp = vowlax.spkr=="68"
# Quadratic discriminant analysis
fm.qda = qda(vowlax.fdat.5[temp,1:2], vowlax.l[temp])
# Linear discriminant analysis
fm.lda = lda(vowlax.fdat.5[temp,1:2], vowlax.l[temp])

xlim=c(0,1000)
ylim=c(0,3000)

oldpar = par(mfrow=c(1,2))
classplot(fm.qda, xlim=xlim, ylim=ylim, main="QDA")
classplot(fm.lda, xlim=xlim, ylim=ylim, main="LDA")

par(oldpar)


# install.packages("e1071")
# library(e1071)
# Support vector machine
## Not run: fm.svm = svm(vowlax.fdat.5[temp,1:2], factor(vowlax.l[temp]))
## Not run: xlim = range(vowlax.fdat.5[temp,1])
## Not run: ylim = range(vowlax.fdat.5[temp,2])
## Not run: classplot(fm.svm, xlim=xlim, ylim=ylim, xlab="F1", ylab="F2", main="SVM")          

</code></pre>

<hr>
<h2 id='closest'>closest</h2><span id='topic+closest'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closest(vec, val)
</code></pre>

<hr>
<h2 id='convert_BPFCollection'>Convert a Bas Partitur File Collection (audio and BAS Partitur files) to an emuDB</h2><span id='topic+convert_BPFCollection'></span>

<h3>Description</h3>

<p>Converts a Bas Partitur File Collection to an emuDB. Expects a collection of the following form:
One master directory &lt;sourceDir&gt; containing any number of file pairs (= bundles). A file pair 
consists of an audio file with the extension &lt;audioExt&gt; and a BPF file with the extension &lt;bpfExt&gt;. 
Apart from extensions, the names of corresponding audio and BPF files must be identical. Each BPF 
file is converted into an emuDB annot file. An emuDB config file matching the data base is created 
after parsing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_BPFCollection(
  sourceDir,
  targetDir,
  dbName,
  bpfExt = "par",
  audioExt = "wav",
  extractLevels = NULL,
  refLevel = NULL,
  newLevels = NULL,
  newLevelClasses = NULL,
  segmentToEventLevels = NULL,
  unifyLevels = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_BPFCollection_+3A_sourcedir">sourceDir</code></td>
<td>
<p>path to the directory containing the Bas Partitur File collection</p>
</td></tr>
<tr><td><code id="convert_BPFCollection_+3A_targetdir">targetDir</code></td>
<td>
<p>directory where the new emuDB should be saved; if it does not exist, 
the function tries to create one</p>
</td></tr>
<tr><td><code id="convert_BPFCollection_+3A_dbname">dbName</code></td>
<td>
<p>name given to the new emuDB</p>
</td></tr>
<tr><td><code id="convert_BPFCollection_+3A_bpfext">bpfExt</code></td>
<td>
<p>extension of BPF files (default = &quot;par&quot;)</p>
</td></tr>
<tr><td><code id="convert_BPFCollection_+3A_audioext">audioExt</code></td>
<td>
<p>extension of audio files (default = &quot;wav&quot;)</p>
</td></tr>
<tr><td><code id="convert_BPFCollection_+3A_extractlevels">extractLevels</code></td>
<td>
<p>optional vector containing the names of levels that should be extracted. 
If NULL (the default) all levels found in the BPF collection are extracted.</p>
</td></tr>
<tr><td><code id="convert_BPFCollection_+3A_reflevel">refLevel</code></td>
<td>
<p>optional name of level used as reference for symbolic links. If NULL (the default), a link-less data base is created.</p>
</td></tr>
<tr><td><code id="convert_BPFCollection_+3A_newlevels">newLevels</code></td>
<td>
<p>optional vector containing names of levels in the BPF collection that are not part of the standard 
BPF levels. See <a href="http://www.bas.uni-muenchen.de/forschung/Bas/BasFormatseng.html#Partitur_tiersdef">http://www.bas.uni-muenchen.de/forschung/Bas/BasFormatseng.html#Partitur_tiersdef</a> for details on 
standard BPF levels.</p>
</td></tr>
<tr><td><code id="convert_BPFCollection_+3A_newlevelclasses">newLevelClasses</code></td>
<td>
<p>optional vector containing the classes of levels in the newLevels vector as integers. 
Must have the same length and order as newLevels.</p>
</td></tr>
<tr><td><code id="convert_BPFCollection_+3A_segmenttoeventlevels">segmentToEventLevels</code></td>
<td>
<p>optional vector containing names of segment levels with overlapping segments. 
The parser treats segments on these levels as events (SEGMENT xyz becomes EVENT xyz_start and EVENT xyz_end). 
If a level contains segmental overlap but is not in this vector, the parser will throw an error. If overlap 
resolution leads to event overlap (e.g. if one segment's end coincides with the next segment's start), an error is thrown either way. If in doubt whether a level contains segmental overlap, try running the converter with segmentToEventLevels = NULL and see whether an error occurs.</p>
</td></tr>
<tr><td><code id="convert_BPFCollection_+3A_unifylevels">unifyLevels</code></td>
<td>
<p>optional vector containing names of levels to be unified with the reference level. This means that 
they are treated as labels of the reference level rather than independent items. At the moment, only purely symbolic 
(class 1) levels can be unified. Links between the reference level and levels in unifyLevels must be one-to-one.</p>
</td></tr>
<tr><td><code id="convert_BPFCollection_+3A_verbose">verbose</code></td>
<td>
<p>display infos, warnings and show progress bar</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>convert_TextGridCollection, convert_legacyEmuDB
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: a dir with equally named file pairs *.wav and *.par
# (see ?create_emuRdemoData on how to create a demo)

# convert file pairs *.wav and *.par in /tmp/BPF_collection into emuRDB 'NewEmuR' in 
# dir /tmp/DirNewEmuR; the tier 'ORT' acts as the (word) reference tier; the 
# tier 'KAN' is one-to-one bound to 'ORT' as a label
convert_BPFCollection("/tmp/BPF_collection","/tmp/DirNewEmuR",'NewEmuR',
        bpfExt='par',audioExt='wav',refLevel='ORT',unifyLevels=c('KAN'))


## End(Not run)

</code></pre>

<hr>
<h2 id='convert_legacyEmuDB'>Convert legacy EMU database to the emuDB format</h2><span id='topic+convert_legacyEmuDB'></span>

<h3>Description</h3>

<p>Converts an existing legacy EMU database to emuDB database structure. 
Copies or rewrites signal files and converts the database configuration and annotation data.
The legacy database must be addressed by its template file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_legacyEmuDB(
  emuTplPath,
  targetDir,
  dbUUID = uuid::UUIDgenerate(),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_legacyEmuDB_+3A_emutplpath">emuTplPath</code></td>
<td>
<p>EMU template file path</p>
</td></tr>
<tr><td><code id="convert_legacyEmuDB_+3A_targetdir">targetDir</code></td>
<td>
<p>target directory</p>
</td></tr>
<tr><td><code id="convert_legacyEmuDB_+3A_dbuuid">dbUUID</code></td>
<td>
<p>optional UUID of emuDB, will be generated by default</p>
</td></tr>
<tr><td><code id="convert_legacyEmuDB_+3A_verbose">verbose</code></td>
<td>
<p>be verbose, default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="convert_legacyEmuDB_+3A_...">...</code></td>
<td>
<p>currently available additional options:
</p>

<ul>
<li><p><code>rewriteSSFFTracks</code>: if <code>TRUE</code>, rewrite SSFF tracks instead of copying 
the file to get rid of big endian encoded SSFF files (SPARC), default: <code>TRUE</code>
</p>
</li>
<li><p><code>ignoreMissingSSFFTrackFiles</code>: if <code>TRUE</code>, missing SSFF track files 
are ignored, if <code>FALSE</code> an error will be generated, default: <code>TRUE</code>
</p>
</li>
<li><p><code>sourceFileTextEncoding</code>: encoding of legacy database text files (template, 
label and hlb files), possible values: NULL, &quot;latin1&quot;, &quot;UTF-8&quot; &quot;bytes&quot; or &quot;unknown&quot; 
:default <code>NULL</code> (uses encoding of operating system platform)
</p>
</li>
<li><p><code>symbolicLinkSignalFiles</code>: if <code>TRUE</code>, signal files are symbolic 
linked instead of copied. Implies: <code>rewriteSSFFTracks=FALSE</code>, Default: <code>FALSE</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The database will be converted if the legacy database template file <code>emuTplPath</code> could 
be found and successfully loaded and parsed. The legacy template file usually has the extension '.tpl'. 
The UUID of the new emuDB will be randomly generated by default. If <code>targetDir</code> does not exist, 
the directory and its parents will be created. A new directory with the name of the database and the 
suffix '_emuDB' will be created in the <code>targetDir</code>. If the new database directory exists 
already, the function stops with an error. The template file is converted to a JSON file.
</p>
<p>Some of the flags of the legacy EMU template files are ignored (lines with this syntax: &quot;set [flagName] [flagValue]&quot;, 
known ignored flag names are: 'LabelTracks', 'SpectrogramWhiteLevel', 'HierarchyViewLevels', 'SignalViewLevels'). 
Legacy EMU utterances are reorganized to sessions and bundles. The naming of the sessions depends on the wildcard 
path pattern of the primary track: If the path contains no wildcard, only one session with the name '0000' will be created. 
If the path contains one wildcard path element, the names of the directories matching the pattern will be used as session names. 
If the path contains more than one wildcard path element, the session name is the concatenation of directory names 
separated by an underscore character.
</p>
<p>Media files (usually WAV files) are copied, SSFF track files are rewritten using the ASSP library of package
<code>wrassp</code> by default (see option <code>rewriteSSFFTracks</code> below, see also <a href="wrassp.html#topic+read.AsspDataObj">read.AsspDataObj</a> 
<a href="wrassp.html#topic+write.AsspDataObj">write.AsspDataObj</a>). Annotations in EMU hierarchy (.hlb) files and ESPS label files are 
converted to one JSON file per bundle (utterance). Only those files get copied, which match the scheme 
of the template file. Additional files in the legacy database directories are ignored. The legacy EMU 
database will not be modified. For more information on the structural elements of an emuDB see <code>vignette{emuDB}</code>.
</p>
<p><code>options</code> is a list of key value pairs:
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load_emuDB">load_emuDB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Convert legacy EMU database specified by EMU 
## template file /mydata/EMU_legacy/ae/ae.tpl to directory /mydata/EMU/
## and load it afterwards

convert_legacyEmuDB("/mydata/EMU_legacy/ae/ae.tpl","/mydata/EMU/")
ae=load_emuDB("/mydata/EMU/ae_emuDB")

## Convert database "ae" and do not rewrite SSFF tracks 

convert_legacyEmuDB("/mydata/EMU_legacy/ae/ae.tpl",
"/mydata/EMU/",
options=list(rewriteSSFFTracks=FALSE))

## Convert legacy database "ae" from emuR demo data and load converted emuDB

create_emuRdemoData()
demoTplPath=file.path(tempdir(),"emuR_demoData/legacy_ae/ae.tpl")
targetDir=file.path(tempdir(),"converted_to_emuR")
convert_legacyEmuDB(demoTplPath,targetDir)
dbHandle=load_emuDB(file.path(targetDir,"ae_emuDB"))


## End(Not run)

</code></pre>

<hr>
<h2 id='convert_TextGridCollection'>Convert a TextGridCollection (e.g. .wav &amp; .TextGrid files) to emuDB</h2><span id='topic+convert_TextGridCollection'></span>

<h3>Description</h3>

<p>Converts a TextGridCollection to an emuDB by searching a given directory for .wav &amp; .TextGrid files (default
extensions) with the same base name. First, the function generates a file pair list 
containing paths to files with the same base
name. It then generates an emuDB DBconfig based on the first TextGrid in this list which specifies 
the allowed level names and types in the new emuDB. After this it converts all file pairs to the new format,
checking whether they comply to the newly generated database configuration. For 
more information on the emuDB format see <code>vignette{emuDB}</code>.
Note that since Praat TextGrids do not permit explicit hierarchical structures, the created emuDB does not contain
any links or link definitions. You can however use the <code><a href="#topic+autobuild_linkFromTimes">autobuild_linkFromTimes</a></code> function after the conversion process
to automatically build a hierarchal structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_TextGridCollection(
  dir,
  dbName,
  targetDir,
  tgExt = "TextGrid",
  audioExt = "wav",
  tierNames = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_TextGridCollection_+3A_dir">dir</code></td>
<td>
<p>path to directory containing the TextGridCollection (nested directory structures are permitted as the 
function recursively searches through directories, generating the session names from dir. structure)</p>
</td></tr>
<tr><td><code id="convert_TextGridCollection_+3A_dbname">dbName</code></td>
<td>
<p>name given to the new emuDB</p>
</td></tr>
<tr><td><code id="convert_TextGridCollection_+3A_targetdir">targetDir</code></td>
<td>
<p>directory where to save the new emuDB</p>
</td></tr>
<tr><td><code id="convert_TextGridCollection_+3A_tgext">tgExt</code></td>
<td>
<p>extension of TextGrid files (default=TextGrid, meaning file names of the form baseName.TextGrid)</p>
</td></tr>
<tr><td><code id="convert_TextGridCollection_+3A_audioext">audioExt</code></td>
<td>
<p>extension of audio files (default=wav, meaning file names of the form baseName.wav)</p>
</td></tr>
<tr><td><code id="convert_TextGridCollection_+3A_tiernames">tierNames</code></td>
<td>
<p>character vector containing names of tiers to extract and convert. If NULL (the default) all
tiers are converted.</p>
</td></tr>
<tr><td><code id="convert_TextGridCollection_+3A_verbose">verbose</code></td>
<td>
<p>display infos &amp; show progress bar</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##########################################################
# prerequisite: directory containing .wav &amp; .TextGrid files
# (see \code{?create_emuRdemoData} how to create demo data)

# convert TextGridCollection and store 
# new emuDB in folder provided by tempdir()
convert_TextGridCollection(dir = "/path/to/directory/",
                           dbName = "myTGcolDB",
                           targetDir = tempdir())


# same as above but this time only convert 
# the information stored in the "Syllable" and "Phonetic" tiers
convert_TextGridCollection(dir = "/path/to/directory/", 
                           dbName = "myTGcolDB", 
                           targetDir = tempdir(),
                           tierNames = c("Syllable", "Phonetic"))


## End(Not run) 
</code></pre>

<hr>
<h2 id='convert_txtCollection'>Converts a collection of audio files and plain text transcriptions into an emuDB</h2><span id='topic+convert_txtCollection'></span>

<h3>Description</h3>

<p>This function takes as input pairs of media files (i.e. wav files) and plain text
transcriptions files. It creates a new emuDB with one bundle per media file, and
turns the associated transcription into an item in that bundle. For this purpose,
media files and text files belonging to the same bundle must be named identically
(with the exception of their respective file extensions). The newly created
emuDB is stored in the target directory, and its handle is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_txtCollection(
  dbName,
  sourceDir,
  targetDir,
  txtExtension = "txt",
  mediaFileExtension = "wav",
  attributeDefinitionName = "transcription",
  cleanWhitespaces = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_txtCollection_+3A_dbname">dbName</code></td>
<td>
<p>name of the new emuDB</p>
</td></tr>
<tr><td><code id="convert_txtCollection_+3A_sourcedir">sourceDir</code></td>
<td>
<p>directory containing the plain text transcription files and media files</p>
</td></tr>
<tr><td><code id="convert_txtCollection_+3A_targetdir">targetDir</code></td>
<td>
<p>directory where the new emuDB will be stored</p>
</td></tr>
<tr><td><code id="convert_txtCollection_+3A_txtextension">txtExtension</code></td>
<td>
<p>file extension of transcription files</p>
</td></tr>
<tr><td><code id="convert_txtCollection_+3A_mediafileextension">mediaFileExtension</code></td>
<td>
<p>file extension of media files</p>
</td></tr>
<tr><td><code id="convert_txtCollection_+3A_attributedefinitionname">attributeDefinitionName</code></td>
<td>
<p>label name of the transcription items</p>
</td></tr>
<tr><td><code id="convert_txtCollection_+3A_cleanwhitespaces">cleanWhitespaces</code></td>
<td>
<p>if true, any sequence of whitespaces in the transcription (including newlines and tabs)
is transformed into a single blank</p>
</td></tr>
<tr><td><code id="convert_txtCollection_+3A_verbose">verbose</code></td>
<td>
<p>display progress bar</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>convert_BPFCollection, convert_TextGridCollection
</p>

<hr>
<h2 id='convert_wideToLong'>convert tracks of a tibble trackdata object to the long form</h2><span id='topic+convert_wideToLong'></span>

<h3>Description</h3>

<p>Converts a trackdata tibble object of the form (==wide):
</p>

<table>
<tr>
 <td style="text-align: left;">
sl_rowIdx </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> T1 </td><td style="text-align: left;"> T2 </td><td style="text-align: left;"> T3 </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> TN</td>
</tr>
<tr>
 <td style="text-align: left;">
1 </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> T1_value </td><td style="text-align: left;"> T2_value </td><td style="text-align: left;"> T3_value </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> TN_value
</td>
</tr>

</table>

<p>to its long form equivalent:
</p>

<table>
<tr>
 <td style="text-align: left;">
sl_rowIdx </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> track_name </td><td style="text-align: left;"> track_value </td>
</tr>
<tr>
 <td style="text-align: left;">
1 </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> T1 </td><td style="text-align: left;"> T1_value </td>
</tr>
<tr>
 <td style="text-align: left;">
1 </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> T2 </td><td style="text-align: left;"> T2_value </td>
</tr>
<tr>
 <td style="text-align: left;">
1 </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> T3 </td><td style="text-align: left;"> T3_value </td>
</tr>
<tr>
 <td style="text-align: left;">
... </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> ... </td>
</tr>
<tr>
 <td style="text-align: left;">
1 </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> TN </td><td style="text-align: left;"> TN_value </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>convert_wideToLong(td, calcFreqs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_wideToLong_+3A_td">td</code></td>
<td>
<p>wide form trackdata tibble object</p>
</td></tr>
<tr><td><code id="convert_wideToLong_+3A_calcfreqs">calcFreqs</code></td>
<td>
<p>calculate an additional column containing 
frequency values from 0-nyquist frequency that match T1-TN (can be quite useful for spectral data)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>long form trackdata tibble object
</p>

<hr>
<h2 id='coutts'>Segment list of words, read speech, female speaker of Australian English
from database epgcoutts</h2><span id='topic+coutts'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>segmentlist
</p>

<hr>
<h2 id='coutts.epg'>EPG-compressed trackdata from the segment list coutts</h2><span id='topic+coutts.epg'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>segmentlist
</p>

<hr>
<h2 id='coutts.l'>Vector of word label from the segment list coutts</h2><span id='topic+coutts.l'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>segmentlist
</p>

<hr>
<h2 id='coutts.rms'>rms Data to coutts segment list</h2><span id='topic+coutts.rms'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>segmentlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coutts.rms)

</code></pre>

<hr>
<h2 id='coutts.sam'>Trackdata of acoustic waveforms from the segment list coutts</h2><span id='topic+coutts.sam'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>trackdata object
</p>

<hr>
<h2 id='coutts2'>Segment list, same as coutts but at a slower speech rate</h2><span id='topic+coutts2'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>segmentlist
</p>

<hr>
<h2 id='coutts2.epg'>EPG-compressed trackdata from the segment list coutts2</h2><span id='topic+coutts2.epg'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>trackdata object
</p>

<hr>
<h2 id='coutts2.l'>Vector of word label from the segment list coutts2</h2><span id='topic+coutts2.l'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of word label
</p>

<hr>
<h2 id='coutts2.sam'>Trackdata of acoustic waveforms from the segment list coutts2</h2><span id='topic+coutts2.sam'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>trackdata object
</p>

<hr>
<h2 id='cr'>Plot digital sinuoids.</h2><span id='topic+cr'></span>

<h3>Description</h3>

<p>The function plots and/or sums digital sinusoids for different parameter
settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cr(
  A = 1,
  k = 1,
  p = 0,
  N = 16,
  samfreq = NULL,
  duration = NULL,
  const = NULL,
  expon = NULL,
  plotf = TRUE,
  ylim = NULL,
  xlim = NULL,
  values = FALSE,
  xlab = "Time (number of points)",
  ylab = "Amplitude",
  type = "b",
  bw = NULL,
  dopoints = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cr_+3A_a">A</code></td>
<td>
<p>A vector of amplitude values. Defaults to A = 1</p>
</td></tr>
<tr><td><code id="cr_+3A_k">k</code></td>
<td>
<p>A vector of cycles (repetitions). Defaults to k = 1</p>
</td></tr>
<tr><td><code id="cr_+3A_p">p</code></td>
<td>
<p>A vector of phase values between -pi/2 and pi/2. Defaults to 0.</p>
</td></tr>
<tr><td><code id="cr_+3A_n">N</code></td>
<td>
<p>The number of points in the signal. Defaults to 16.</p>
</td></tr>
<tr><td><code id="cr_+3A_samfreq">samfreq</code></td>
<td>
<p>If NULL, then a sinusoid is plotted with a frequency of k
cycles per N points. Otherwise, if samfreq is an numeric, then the argument
to k is interpreted as the frequency in Hz and the sinusoid at that
frequency is plotted for however many points are specified by N. For
example, if samfreq is 40 (Hz), and if N is 40 and k = 1, then 1 cycle of a
1 Hz sinusoid will be plotted.</p>
</td></tr>
<tr><td><code id="cr_+3A_duration">duration</code></td>
<td>
<p>Specify the duration in ms. If NULL, the default, then the
duration of the sinusoid is in points (N), otherwise if a numeric value is
supplied, then in ms. For example, 1/2 second of a 1 cycle sinusoid at a
sampling frequency of 40 Hz: duration = 500, k = 1, samfreq=40. A ms value
can be supplied only if the sampling frequency is also specified.</p>
</td></tr>
<tr><td><code id="cr_+3A_const">const</code></td>
<td>
<p>A single numeric vector for shifting the entire sinusoid up or
down the y-axis. For example, when const is 5, then 5 + s, where s is the
sinusoid is plotted. Defaults to 0 (zero).</p>
</td></tr>
<tr><td><code id="cr_+3A_expon">expon</code></td>
<td>
<p>A numeric vector. If supplied, then what is plotted is
expon[j]<code class="reqn">\mbox{\textasciicircum}</code>(c(0:(N - 1) * A cos (2 * pi * k/N
* (0:(N-1))). For example, a decaying sinusoid is produced with
cr(expon=-0.9). Defaults to NULL (i.e. to expon = 1).</p>
</td></tr>
<tr><td><code id="cr_+3A_plotf">plotf</code></td>
<td>
<p>A single-valued logical vector. If TRUE (default), the sinusoid
is plotted.</p>
</td></tr>
<tr><td><code id="cr_+3A_ylim">ylim</code></td>
<td>
<p>A two-valued numeric vector for specifying the y-axis range.</p>
</td></tr>
<tr><td><code id="cr_+3A_xlim">xlim</code></td>
<td>
<p>A two-valued numeric vector for specifying the y-axis range.</p>
</td></tr>
<tr><td><code id="cr_+3A_values">values</code></td>
<td>
<p>If TRUE, then the values of the sinusoid are listed. Defaults to
FALSE.</p>
</td></tr>
<tr><td><code id="cr_+3A_xlab">xlab</code></td>
<td>
<p>A character vector for plotting the x-axis title.</p>
</td></tr>
<tr><td><code id="cr_+3A_ylab">ylab</code></td>
<td>
<p>A character vector for plotting the y-axis title.</p>
</td></tr>
<tr><td><code id="cr_+3A_type">type</code></td>
<td>
<p>A character vector for specifying the line type (see par)</p>
</td></tr>
<tr><td><code id="cr_+3A_bw">bw</code></td>
<td>
<p>A numeric vector for specifying the bandwidth, if the sampling
frequency is supplied. The bandwidth is converted to an exponential (see
expon using exp( - rad(bw/2, samfreq = samfreq).</p>
</td></tr>
<tr><td><code id="cr_+3A_dopoints">dopoints</code></td>
<td>
<p>this is now redundant.</p>
</td></tr>
<tr><td><code id="cr_+3A_...">...</code></td>
<td>
<p>Option for supplying further graphical parameters - see par.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crplot">crplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# cosine wave
cr()

# doubling the frequency, 1/3 amplitude, phase = pi/4, 50 points
cr(A=1/3, k=2, p=pi/4, N=50)

# sum 3 sinusoids of different frequencies)
cr(k=c(1, 3, 4))

# sum 2 sinusoids of different parameters
cr(c(1, 2), c(2, 10), c(0, -pi/3), N=200, type="l")


# store the above to a vector and overlay with noise
v = cr(c(1, 2), c(2, 10), c(0, -pi/3), N=200, type="l", values=TRUE)
r = runif(200, -3, 3)
v = v+r
plot(0:199, v, type="l")


# 100 points of a 50 Hz sinusoid with a 4 Hz bandwidth 
# at a sampling frequency of 200 Hz
cr(k=50, bw=4, samfreq=2000, N=100)

# the same but shift the y-axis by +4 (d.c. offset=+4)
cr(const=4, k=50, bw=4, samfreq=2000, N=100)

# sinusoid multiplied by a decaying exponential (same effect as bandwidth)
cr(expon=-0.95,  N=200, type="l")


</code></pre>

<hr>
<h2 id='create_emuDB'>Create empty emuDB</h2><span id='topic+create_emuDB'></span>

<h3>Description</h3>

<p>Creates an empty emuDB in the target directory specified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_emuDB(
  name,
  targetDir,
  mediaFileExtension = "wav",
  store = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_emuDB_+3A_name">name</code></td>
<td>
<p>of new emuDB</p>
</td></tr>
<tr><td><code id="create_emuDB_+3A_targetdir">targetDir</code></td>
<td>
<p>target directory to store the emuDB to</p>
</td></tr>
<tr><td><code id="create_emuDB_+3A_mediafileextension">mediaFileExtension</code></td>
<td>
<p>defines mediaFileExtention (NOTE: currently only 
'wav' (the default) is supported by all components of EMU)</p>
</td></tr>
<tr><td><code id="create_emuDB_+3A_store">store</code></td>
<td>
<p>store new created emuDB to file system</p>
</td></tr>
<tr><td><code id="create_emuDB_+3A_verbose">verbose</code></td>
<td>
<p>display infos &amp; show progress bar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a new directory [name]_emuDB in targetDir. By default 
the emuDB is created in the R session, written to the filesystem and 
then purged from the R session.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create empty emuDB in folder provided by tempdir()
create_emuDB(name = "myNewEmuDB", 
             targetDir = tempdir())

## End(Not run)
</code></pre>

<hr>
<h2 id='create_emuRdemoData'>Create demo data for the emuR package</h2><span id='topic+create_emuRdemoData'></span>

<h3>Description</h3>

<p>Create a folder within the folder specified
by the dir argument called emuR_demoData.
This folder contains the folders:
</p>

<ul>
<li><p>ae_emuDB: Containing an emuDB that adheres to the new format specification 
(as expected by the <code><a href="#topic+load_emuDB">load_emuDB</a></code> function). See <code>vignette(emuDB)</code> 
for more information on this database format.
</p>
</li>
<li><p>BPF_collection: Containing a BAS Partitur Format (BPF) file collection (as
expected by the <code><a href="#topic+convert_BPFCollection">convert_BPFCollection</a></code> function)
</p>
</li>
<li><p>legacy_ae: Containing a legacyEmuDB (as expected by the 
<code><a href="#topic+convert_legacyEmuDB">convert_legacyEmuDB</a></code> function)
</p>
</li>
<li><p>TextGrid_collection: Containing a TextGrid file collection 
(as expected from the <code><a href="#topic+convert_TextGridCollection">convert_TextGridCollection</a></code> function)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>create_emuRdemoData(dir = tempdir(), precache = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_emuRdemoData_+3A_dir">dir</code></td>
<td>
<p>directory to create demo data in (default= tempdir())</p>
</td></tr>
<tr><td><code id="create_emuRdemoData_+3A_precache">precache</code></td>
<td>
<p>creates an on-file-system cache for the ae emuDB to allow fast loading
(see <code>load_emuDB</code> for details about the emuDB file cache)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# create demo data directory in directory
# provided by the tempdir function
create_emuRdemoData(dir = tempdir())

## End(Not run)
</code></pre>

<hr>
<h2 id='create_emuRtrackdata'>create emuRtrackdata object</h2><span id='topic+create_emuRtrackdata'></span>

<h3>Description</h3>

<p>Joins <code><a href="#topic+emuRsegs">emuRsegs</a></code> and <code><a href="#topic+trackdata">trackdata</a></code> objects
to create an <code><a href="#topic+emuRtrackdata">emuRtrackdata</a></code> object that is a sub-class of
a <code><a href="base.html#topic+data.frame">data.frame</a></code> object. This object 
can be viewed as a flat version of a <code><a href="#topic+trackdata">trackdata</a></code> object that also 
contains all the information of a <code><a href="#topic+emuRsegs">emuRsegs</a></code> object. It is meant to
ease integration with other packages as it is based on the well known 
<code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_emuRtrackdata(sl, td)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_emuRtrackdata_+3A_sl">sl</code></td>
<td>
<p>seglist of class <code><a href="#topic+emuRsegs">emuRsegs</a></code></p>
</td></tr>
<tr><td><code id="create_emuRtrackdata_+3A_td">td</code></td>
<td>
<p><code><a href="#topic+trackdata">trackdata</a></code> object generated from sl</p>
</td></tr>
</table>


<h3>Value</h3>

<p>emuRtrackdata object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

# query emuDB (to get object of class emuRsegs)
sl = query(emuDBhandle = ae, 
           query = "Phonetic == i:")
           
# get formats for SEGMENTs in sl (to get object of class trackdata)
td = get_trackdata(emuDBhandle = ae, 
                   seglist = sl,
                   onTheFlyFunctionName = "forest")

# create emuRtrackdata object
create_emuRtrackdata(sl = sl, td = td)


## End(Not run)
</code></pre>

<hr>
<h2 id='create_itemsInLevel'>Create new items programmatically</h2><span id='topic+create_itemsInLevel'></span>

<h3>Description</h3>

<p>Create annotation items programmatically on a single level.
You have to pass in a data frame, called <code>itemsToCreate</code>, describing
the new items. The required columns depend on the type of the level (ITEM,
EVENT, or SEGMENT).
</p>
<p>This function belongs to emuRs CRUD family of functions, which let the user
manipulate items programmatically:
</p>

<ul>
<li><p> Create items (<a href="#topic+create_itemsInLevel">create_itemsInLevel</a>)
</p>
</li>
<li><p> Read items (<a href="#topic+query">query</a>)
</p>
</li>
<li><p> Update items (<a href="#topic+update_itemsInLevel">update_itemsInLevel</a>)
</p>
</li>
<li><p> Delete items (<a href="#topic+delete_itemsInLevel">delete_itemsInLevel</a>))
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>create_itemsInLevel(
  emuDBhandle,
  itemsToCreate,
  calculateEndTimeForSegments = TRUE,
  allowGapsAndOverlaps = FALSE,
  rewriteAllAnnots = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_itemsInLevel_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <a href="#topic+load_emuDB">load_emuDB</a></p>
</td></tr>
<tr><td><code id="create_itemsInLevel_+3A_itemstocreate">itemsToCreate</code></td>
<td>
<p>A data frame with the columns:
</p>

<ul>
<li> <p><code>session</code> (character)
</p>
</li>
<li> <p><code>bundle</code> (character)
</p>
</li>
<li> <p><code>level</code> (character)
</p>
</li>
<li> <p><code>attribute</code> (character)
</p>
</li>
<li> <p><code>labels</code> (character)
</p>
</li>
<li> <p><code>start_item_seq_idx</code> (numeric; only when <code>level</code> refers to a ITEM-typed
level)
</p>
</li>
<li> <p><code>start</code> (numeric, milliseconds; only when <code>level</code> refers to an EVENT-typed
or SEGMENT-typed level)
</p>
</li>
<li> <p><code>end</code> (numeric, milliseconds; only when <code>level</code> refers to a SEGMENT-typed
level and <code>calculateEndTimeForSegments</code> is <code>FALSE</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="create_itemsInLevel_+3A_calculateendtimeforsegments">calculateEndTimeForSegments</code></td>
<td>
<p><em>Only applicable if the level type is SEGMENT.</em>
If set to <code>TRUE</code>, then each segments end time is automatically aligned
with the start time of the following segment. In that case, user-provided
end times are ignored. The last segments end time is the end time of the
annotated media file. If set to <code>FALSE</code>, then the user has to provide
an end time for each segment.</p>
</td></tr>
<tr><td><code id="create_itemsInLevel_+3A_allowgapsandoverlaps">allowGapsAndOverlaps</code></td>
<td>
<p><em>Only applicable if the level type is SEGMENT
and <code>calculateEndTimeForSegments</code> is <code>FALSE</code>.</em>
If set to <code>FALSE</code>, this function fails when <code>itemsToCreate</code> contains
gaps or overlaps between segments. The offending segments are returned invisibly.
You can inspect them by assigning the return value to a variable. The return
value will include a new column <code>gap_samples</code> that indicates the size
of the gap (positive values) or overlap (negative values) with the previous
segment, respectively. It is measured in audio samples, not in milliseconds.
Setting this to <code>TRUE</code> allows the function to complete even with gaps
and/or overlaps, but this is <strong>not recommended as it can cause bugs in
the EMU-webApp</strong>.</p>
</td></tr>
<tr><td><code id="create_itemsInLevel_+3A_rewriteallannots">rewriteAllAnnots</code></td>
<td>
<p>should changes be written to file system (_annot.json
files) (intended for expert use only)</p>
</td></tr>
<tr><td><code id="create_itemsInLevel_+3A_verbose">verbose</code></td>
<td>
<p>if set to <code>TRUE</code>, more status messages are printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates new annotation items on an existing level, in existing
bundles.
</p>
<p>Regardless of the type of level you are creating items on, your input data
frame <code>itemsToCreate</code> must describe your new items by specifying the columns
<code>session</code>, <code>bundle</code>, <code>level</code>, <code>attribute</code> and <code>labels</code>. <code>level</code> must have the
same value for all rows, as we can only create items on one level at a time.
</p>
<p><code>attribute</code> must also have the same value for all rows, and it must be an
existing attribute that belongs to the <code>level</code>.
</p>
<p>A major use case for this function is to obtain a segment list using <a href="#topic+query">query</a>,
modify the segment list and feed it to this function. That is why the column
<code>labels</code> has a plural name: segment lists also have a column <code>labels</code> and
not <code>label</code>. The same is true for the sequence index columns introduced below.
</p>
<p>Creating new items works differently depending on the level type. The three
types are explained in the following sections.
</p>


<h4>Levels of type ITEM</h4>

<p>In addition to the columns that are always required, ITEM-typed levels require
a column with a sequence index to be present in the <code>itemsToCreate</code> data
frame. Its name must be <code>start_item_seq_idx</code>. This name was chosen instead
of <code>sequence_index</code> because it is present as a column name in segment lists
obtained with <a href="#topic+query">query</a>. That makes it easer to use a segment list as input to
<code><a href="#topic+create_itemsInLevel">create_itemsInLevel()</a></code>.
</p>
<p>Along the time axis, there can be multiple annotation items on every level.
Their order within the level is given by their sequence index. All <em>existing</em>
items have a natural-valued sequence index and there are no gaps in the
sequences (i.e. if a level contains N annotation items, they are indexed 1..N).
</p>
<p>Any newly created item must be given a sequence index. The sequence index may
be real-valued (it will automatically be replaced with a natural value). To
prepend the new item to the existing ones, pass a value lower than one. To
append it to the existing items, you can either pass <code>NA</code> or any value that
you know is greater than N (the number of existing items in that level). It
does not need to be exactly N+1. To place the new item between two existing
ones, use any real value between the sequence indexes of the existing neighbors.
</p>
<p>If you are appending multiple items at the same time, every sequence index
(including <code>NA</code>) can only be used once per session/bundle/level combination
(because session/bundle/level/sequence index are the unique identifier of an
item).
</p>
<p>After creating the items, all sequence indexes (which may now be real-valued,
natural-valued or NA) are sorted in ascending order and then replaced with
the values 1..N, where N is the number of items on that level. While sorting,
<code>NA</code> values are placed at the end.
</p>



<h4>Levels of type EVENT</h4>

<p>In addition to the columns that are always required, EVENT-typed levels require
a column with the time of the event to be present in the <code>itemsToCreate</code> data
frame. Its name must be <code>start</code>. This name was chosen because it is present
as a column name in segment lists obtained with <a href="#topic+query">query</a>. That makes it easer
to use a segment list as input to <code><a href="#topic+create_itemsInLevel">create_itemsInLevel()</a></code>. The <code>end</code> column
in segment lists is 0 for EVENT-typed levels.
</p>
<p>The <code>start</code> column must be given in milliseconds.
</p>
<p>You cannot create an EVENT item at a point on the time axis where another
item already exists on the same level. If you specify such an event, the
entire function will fail.
</p>



<h4>Levels of type SEGMENT</h4>

<p>You can only create SEGMENT-typed items in bundles where the respective level
is empty.
</p>
<p>In addition to the columns that are always required, SEGMENT-typed levels
require the column <code>start</code> to be present in the <code>itemsToCreate</code> data frame,
representing the start time of the segment. It must be given in milliseconds.
</p>
<p>Segments also need to have an end, and there are two strategies to determine
the end. Either, you explicitly provide an <code>end</code> column in the <code>itemsToCreate</code>
data frame. It must be given in milliseconds. If you do that, you have to
specify the <code>calculateEndTimeForSegments</code> parameter as <code>FALSE</code>.
</p>
<p>Alternatively, you can leave <code>calculateEndTimeForSegments</code> at <code>TRUE</code> (which
is the default) and provide your <code>itemsToCreate</code> data frame without an <code>end</code>
column. In that case, the end time will be aligned to the next neighbors
start time. The end time of the last segment will be aligned with the end of
the annotated media file.
</p>


<hr>
<h2 id='create_links'>create links between items</h2><span id='topic+create_links'></span>

<h3>Description</h3>

<p>create links between items
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_links(emuDBhandle, links, rewriteAllAnnots = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_links_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="create_links_+3A_links">links</code></td>
<td>
<p>data.frame like object containing linking information. The required columns
are: 
</p>

<ul>
<li> <p><code>session</code>: 
</p>
</li>
<li> <p><code>bundle</code>
</p>
</li>
<li> <p><code>from_id</code>
</p>
</li>
<li> <p><code>to_id</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="create_links_+3A_rewriteallannots">rewriteAllAnnots</code></td>
<td>
<p>should changes be written to file system (_annot.json
files) (intended for expert use only)</p>
</td></tr>
<tr><td><code id="create_links_+3A_verbose">verbose</code></td>
<td>
<p>if set to <code>TRUE</code>, more status messages are printed</p>
</td></tr>
</table>

<hr>
<h2 id='create_spectrogram_image_as_raster'>Create spectrogram image as raster</h2><span id='topic+create_spectrogram_image_as_raster'></span>

<h3>Description</h3>

<p>Create spectrogram image as raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_spectrogram_image_as_raster(
  audioFilePath,
  begin = 0,
  end = 0,
  windowSizeInSecs = 0.01,
  alpha = 0.16,
  lowerFreq = 0,
  upperFreq = 5000,
  window = "GAUSS",
  dynRangeInDB = 70,
  audioChannel = 1,
  preEmphasisFilterFactor = 0.97,
  invert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_spectrogram_image_as_raster_+3A_audiofilepath">audioFilePath</code></td>
<td>
<p>path to audio file to plot spectrogram of</p>
</td></tr>
<tr><td><code id="create_spectrogram_image_as_raster_+3A_begin">begin</code></td>
<td>
<p>begin time in seconds (passed into begin parameter of <code>wrassp::read.AsspDataObj</code>)</p>
</td></tr>
<tr><td><code id="create_spectrogram_image_as_raster_+3A_end">end</code></td>
<td>
<p>end time in seconds (passed into end parameter of <code>wrassp::read.AsspDataObj</code>)</p>
</td></tr>
<tr><td><code id="create_spectrogram_image_as_raster_+3A_windowsizeinsecs">windowSizeInSecs</code></td>
<td>
<p>window size in seconds</p>
</td></tr>
<tr><td><code id="create_spectrogram_image_as_raster_+3A_alpha">alpha</code></td>
<td>
<p>value of spectrogram</p>
</td></tr>
<tr><td><code id="create_spectrogram_image_as_raster_+3A_lowerfreq">lowerFreq</code></td>
<td>
<p>lower frequency limit of spectrogram</p>
</td></tr>
<tr><td><code id="create_spectrogram_image_as_raster_+3A_upperfreq">upperFreq</code></td>
<td>
<p>upper frequency limit of spectrogram</p>
</td></tr>
<tr><td><code id="create_spectrogram_image_as_raster_+3A_window">window</code></td>
<td>
<p>window type used in spectrogram calculation. Allowed values
are:
</p>

<ul>
<li><p> &quot;BARTLETT&quot;
</p>
</li>
<li><p> &quot;BARTLETTHANN&quot;
</p>
</li>
<li><p> &quot;BLACKMAN&quot;
</p>
</li>
<li><p> &quot;COSINE&quot;
</p>
</li>
<li><p> &quot;GAUSS&quot; (the default)
</p>
</li>
<li><p> &quot;HAMMING&quot;
</p>
</li>
<li><p> &quot;HANN&quot;
</p>
</li>
<li><p> &quot;LANCZOS&quot;
</p>
</li>
<li><p> &quot;RECTANGULAR&quot;
</p>
</li>
<li><p> &quot;TRIANGULAR&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="create_spectrogram_image_as_raster_+3A_dynrangeindb">dynRangeInDB</code></td>
<td>
<p>dynamic range in DB of spectrogram</p>
</td></tr>
<tr><td><code id="create_spectrogram_image_as_raster_+3A_audiochannel">audioChannel</code></td>
<td>
<p>channel of audio file to draw spectrogram of (only
applicable when using multi-channel audio files)</p>
</td></tr>
<tr><td><code id="create_spectrogram_image_as_raster_+3A_preemphasisfilterfactor">preEmphasisFilterFactor</code></td>
<td>
<p>used in time domain for amplifying high-freqs</p>
</td></tr>
<tr><td><code id="create_spectrogram_image_as_raster_+3A_invert">invert</code></td>
<td>
<p>invert the colors of the spectrogram</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a image raster object
</p>

<hr>
<h2 id='crplot'>Function to plot a digital sinusoid and the circle from which it is
derived.</h2><span id='topic+crplot'></span>

<h3>Description</h3>

<p>A digital sinusoid is derived the movement of a point around a circle.  The
function shows the relationship between the two for various parameter
settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crplot(
  A = 1,
  k = 1,
  p = 0,
  N = 16,
  const = NULL,
  figsize = 8,
  npoints = 500,
  col = 1,
  cplot = TRUE,
  splot = TRUE,
  numplot = TRUE,
  axes = TRUE,
  incircle = TRUE,
  arrow = TRUE,
  linetype = 1,
  textplot = NULL,
  lineplot = NULL,
  ylab = "Amplitude",
  super = NULL,
  xaxlab = NULL,
  type = "b",
  xlab = "Time (number of points)",
  fconst = 3.5/3.1,
  pointconst = 1.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crplot_+3A_a">A</code></td>
<td>
<p>Amplitude of the circle/sinusoid.</p>
</td></tr>
<tr><td><code id="crplot_+3A_k">k</code></td>
<td>
<p>Frequency of the sinusoid</p>
</td></tr>
<tr><td><code id="crplot_+3A_p">p</code></td>
<td>
<p>Phase of the sinusoid</p>
</td></tr>
<tr><td><code id="crplot_+3A_n">N</code></td>
<td>
<p>Number of points per cycle or revolution.</p>
</td></tr>
<tr><td><code id="crplot_+3A_const">const</code></td>
<td>
<p>A constant corresponding to k + A*cos(2*pi*k+p)</p>
</td></tr>
<tr><td><code id="crplot_+3A_figsize">figsize</code></td>
<td>
<p>Set the figure size as pin &lt;- c(figsize, figsize/2).
Defaults to figsize = 8.</p>
</td></tr>
<tr><td><code id="crplot_+3A_npoints">npoints</code></td>
<td>
<p>The number of points used in plotting the circle. Defaults
to 500</p>
</td></tr>
<tr><td><code id="crplot_+3A_col">col</code></td>
<td>
<p>An integer for the color in plotting the sinusoid and points
around the circle</p>
</td></tr>
<tr><td><code id="crplot_+3A_cplot">cplot</code></td>
<td>
<p>Now redundant</p>
</td></tr>
<tr><td><code id="crplot_+3A_splot">splot</code></td>
<td>
<p>Now redundant</p>
</td></tr>
<tr><td><code id="crplot_+3A_numplot">numplot</code></td>
<td>
<p>Logical. If TRUE (defaults), the digital points around the
circle are numbered</p>
</td></tr>
<tr><td><code id="crplot_+3A_axes">axes</code></td>
<td>
<p>Logical. If TRUE, plot axes.</p>
</td></tr>
<tr><td><code id="crplot_+3A_incircle">incircle</code></td>
<td>
<p>Logical. If TRUE, plot an the angle between digital points in
the circle.</p>
</td></tr>
<tr><td><code id="crplot_+3A_arrow">arrow</code></td>
<td>
<p>Logical. If TRUE, plot an arrow on incircle showing the direction
of movement.</p>
</td></tr>
<tr><td><code id="crplot_+3A_linetype">linetype</code></td>
<td>
<p>Specify a linetype. Same function as lty in plot</p>
</td></tr>
<tr><td><code id="crplot_+3A_textplot">textplot</code></td>
<td>
<p>A list containing $radius, $textin, $pivals for plotting
text at specified angles and radii on the circle. $radius: a vector of
amplitudes of the radii at which the text is to be plotted; $textin: a
vector of character labels to be plotted; $pivals: the angle, in radians
relative to zero radians (top of the circle) at which the text is to be
plotted. Defaults to NULL</p>
</td></tr>
<tr><td><code id="crplot_+3A_lineplot">lineplot</code></td>
<td>
<p>Plot lines from the centre of the circle to the
circumference. lineplot is a vector specifying the angle in radians (zero
corresponds to the top of the circle)</p>
</td></tr>
<tr><td><code id="crplot_+3A_ylab">ylab</code></td>
<td>
<p>Specify a y-axis label.</p>
</td></tr>
<tr><td><code id="crplot_+3A_super">super</code></td>
<td>
<p>Superimpose a part solid circle and corresponding sinusoid.
This needs to be a list containing $first and $last, which are values
between 0 and 2*pi defining the beginning and ending of the part circle
which is to be superimposed</p>
</td></tr>
<tr><td><code id="crplot_+3A_xaxlab">xaxlab</code></td>
<td>
<p>Now redundant</p>
</td></tr>
<tr><td><code id="crplot_+3A_type">type</code></td>
<td>
<p>Specify a type.</p>
</td></tr>
<tr><td><code id="crplot_+3A_xlab">xlab</code></td>
<td>
<p>Specify an x-axis label.</p>
</td></tr>
<tr><td><code id="crplot_+3A_fconst">fconst</code></td>
<td>
<p>A single element numeric vector for the aspect ratio in a
postscript plot. Defaults to 3.5/3.1 which is appropriate for a postscript
setting of setps(h=4, w=4)</p>
</td></tr>
<tr><td><code id="crplot_+3A_pointconst">pointconst</code></td>
<td>
<p>The radius for plotting the numbers around the circle.
Defaults to 1.2 * A</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>References</h3>

<p>Harrington, J, &amp; Cassidy, S. 1999. Techniques in Speech
Acoustics. Kluwer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cr">cr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
crplot()
# sine wave
crplot(p=-pi/2)

crplot(k=3)

# aliasing
crplot(k=15)

</code></pre>

<hr>
<h2 id='dapply'>apply a function to each part of a trackdata object</h2><span id='topic+dapply'></span>

<h3>Description</h3>

<p>Given an Emu trackdata object, <code>dapply</code> will apply a given function to
the data corresponding to each segment of data. The result is a new
trackdata object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dapply(trackdata, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dapply_+3A_trackdata">trackdata</code></td>
<td>
<p>An Emu trackdata object</p>
</td></tr>
<tr><td><code id="dapply_+3A_fun">fun</code></td>
<td>
<p>A function taking a matrix of data and a vector of times and
returning a list with components <code>$data</code> and <code>$ftime</code>.</p>
</td></tr>
<tr><td><code id="dapply_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dapply</code> can be used to apply an arbitrary function to trackdata
extracted from an Emu database. It can be used for example to smooth the
data (see <code><a href="#topic+dsmooth">dsmooth</a></code>) or differentiate it (see
<code><a href="#topic+ddiff">ddiff</a></code>).
</p>
<p>Trackdata is made up of three components: a matrix of data <code>$data</code>, a
matrix of indexes (<code>$index</code>) and a matrix of segment times
(<code>$ftime</code>).  The indexes contain the start and end rows for each
segment in the trackdata, the time matrix contains the start and end times
of each data segment.
</p>
<p>The function <code>fun</code> supplied to <code>dapply</code> should take one matrix of
data (corresponding to one segment) and a vector of two times being the
start and end of the data.  It should return a modified data matrix, which
can have any number of rows or columns, and a new pair of start and end
times.  The new start and end times are necessary because the operation
applied might shorten or interpolate the data and hence change the times
corresponding to the first and last rows of data.
</p>


<h3>Value</h3>

<p>An Emu trackdata object with components: </p>
<table>
<tr><td><code>data</code></td>
<td>
<p>A matrix of
data with all segments concatenated by row.</p>
</td></tr> <tr><td><code>index</code></td>
<td>
<p>A two column
matrix of the start and end rows for each segment</p>
</td></tr> <tr><td><code>ftime</code></td>
<td>
<p>A two
column matrix of the start and end times for each segment</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+dsmooth">dsmooth</a></code> <code><a href="#topic+ddiff">ddiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(dip)
## formant data of the first segment in segment list dip
fm &lt;- dip.fdat[1]

testfun &lt;- function(data, ftime, n) {
  ## return only the first n rows of data
  ## doesn't check to see if there really are n rows...
  newdata &lt;- data[1:n,]
  ## calculate a new end time
  interval &lt;- (ftime[2]-ftime[1])/nrow(data)
  ftime[2] &lt;- ftime[1] + interval*n
  ## now return the required list 
  return( list( data=newdata, ftime=ftime ) )
}

fm.first3 &lt;- dapply( fm, testfun, 3 )
fm.first10 &lt;- dapply( fm, testfun, 10 )


</code></pre>

<hr>
<h2 id='dbnorm'>Function to dB-normalise spectral objects</h2><span id='topic+dbnorm'></span>

<h3>Description</h3>

<p>The function can be used to rescale a spectrum to a dB value at a
particular frequency - for example, to rescale the spectrum so that 3000 Hz
has 0 dB and all other values are shifted in relation to this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbnorm(specdata, f = 0, db = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbnorm_+3A_specdata">specdata</code></td>
<td>
<p>An object of class 'spectral'</p>
</td></tr>
<tr><td><code id="dbnorm_+3A_f">f</code></td>
<td>
<p>A single element vector specifying the frequency. Defaults to 0</p>
</td></tr>
<tr><td><code id="dbnorm_+3A_db">db</code></td>
<td>
<p>A single element vector specifying the dB value to which the
spectrum is to be rescaled. Defaults to zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class with rescaled dB values. The default is
to rescale the dB-values of the spectrum to 0 dB at 0 Hz.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbtopower">dbtopower</a></code> <code><a href="#topic+plot.spectral">plot.spectral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# normalise to - 40 dB at 1500 Hz
res = dbnorm(e.dft, 1500, 0)
# compare the two
ylim = range(c(res, e.dft))
plot(e.dft, ylim=ylim, type="l")
oldpar = par(new=TRUE)
plot(res, ylim=ylim, type="l", col=2)

par(oldpar)

</code></pre>

<hr>
<h2 id='dbtopower'>Function for inter-converting between decibels and a linear scale</h2><span id='topic+dbtopower'></span>

<h3>Description</h3>

<p>The function converts from decibels to a linear scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbtopower(specdata, const = 10, base = 10, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbtopower_+3A_specdata">specdata</code></td>
<td>
<p>A numeric object or an object of class trackdata</p>
</td></tr>
<tr><td><code id="dbtopower_+3A_const">const</code></td>
<td>
<p>A single element numeric vector. Defaults to 10</p>
</td></tr>
<tr><td><code id="dbtopower_+3A_base">base</code></td>
<td>
<p>A single element numeric vector. Defaults to 10</p>
</td></tr>
<tr><td><code id="dbtopower_+3A_inv">inv</code></td>
<td>
<p>Logical. If TRUE, then the conversion is from a logarithmic to an
anti-logarithmic form, otherwise the other way round</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns base<code class="reqn">\mbox{\textasciicircum}</code>(specdata/const)
if inv=FALSE, otherwise, const * log(dat, base=base). If the object to which
this function is applied is of class 'trackdata' then this function is
applied to $data.
</p>


<h3>Value</h3>

<p>An object of the same class.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbtopower">dbtopower</a></code> <code><a href="#topic+plot.spectral">plot.spectral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# convert 10 dB to a power ratio
vec = dbtopower(10)
# convert dB-data to a power ratio and back to decibels
res = dbtopower(vowlax.dft.5)
res = dbtopower(res, inv=TRUE)

</code></pre>

<hr>
<h2 id='dct'>Discrete Cosine Transformation</h2><span id='topic+dct'></span>

<h3>Description</h3>

<p>Obtain the coefficients of the discrete cosine transformation (DCTRUE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dct(data, m = NULL, fit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dct_+3A_data">data</code></td>
<td>
<p>a vector or single column matrix of numeric values to which the
2nd order polynomial is to be fitted.</p>
</td></tr>
<tr><td><code id="dct_+3A_m">m</code></td>
<td>
<p>The number of DCT coefficients that are returned or on which the
smoothed trajectory is based. Defaults to NULL which returns coefficients
of frequencies k = 0, 1,2 .. N-1 where N is the length of the input signal,
wav. If fit = TRUE and k = NULL, then the the sum of all the cosine waves
whose amplitudes are the DCT coefficients are returned - which is equal to
the original signal. k must be between 2 and the length of the signal.</p>
</td></tr>
<tr><td><code id="dct_+3A_fit">fit</code></td>
<td>
<p>if FALSE, return the DCT coefficients; if TRUE, the values of the
smoothed trajectory are returned based on summing the cosine waves of the k
lowest ordered DCT coefficients, where k is the argument given below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the DCT coefficients for any vector or
single-columned matrix. The function can also be used to obtain a smoothed
trajectory of the input data by summing the cosine waves derived from the
first few DCT coefficients.
</p>
<p>The algorithm first reflects the input signal about the last data point, N.
Thus if the input signal vec if of length N, the algorithm creates a vector
c(vec, rev(vec[-c(1,N)])). and the R fft function is applied to this
reflected signal. The DCT coefficients are real part of what is returned by
fft i.e.  the amplitudes of the cosine waves of frequencies k = 0, 1, 2,
...2 *(N-1) radians per sample. The phase is zero in all cases. The
amplitudes are calculated in such a way such that if these cosine waves are
summed, the original (reflected) signal is reconstructed. What is returned
by dct() are the amplitudes of the cosine waves (DCT coefficients) up to a
frequency of N radians/sample, i.e. a vector of cosine wave amplitudes that
has the same length as the original signal and of frequencies k = 0, 1, 2,
... (N-1).  Alternatively, if fit=TRUE, a smoothed signal of the same length
as the original signal is obtained based on a summation of the lowest
ordered DCT coefficients. This dct() algorithm returns very similar values
to DCT() with inv=FALSE written by Catherine Watson and used in Watson &amp;
Harrington (1999).
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>References</h3>

<p>Watson, C. &amp; Harrington, J. (1999). Acoustic evidence for
dynamic formant trajectories in Australian English vowels. Journal of the
Acoustical Society of America, 106, 458-468.
</p>
<p>Zahorian, S., and Jagharghi, A. (1993). Spectral-shape features versus
formants as acoustic correlates for vowels, Journal of the Acoustical
Society of America, 94, 19661982.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plafit">plafit</a></code> <code><a href="#topic+by">by</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vowlax)
# obtain the first four DCT coefficients 
# (frequencies k = 0, 1, 2, 3) for some 
# first formant frequency data
vec &lt;- vowlax.fdat[1,1]$data
dct(vec, m=4)

# obtain the corresponding smoothed
# trajectory
dct(vec, m=4 , fit=TRUE)

</code></pre>

<hr>
<h2 id='dcut'>Function to extract a vector or matrix from EMU-Trackdata at a single time
point of to create another EMU-trackdata object between two times.</h2><span id='topic+dcut'></span><span id='topic+dcut.sub'></span>

<h3>Description</h3>

<p>A general purpose tool for extracting data from track objects either at a
particular time, or between two times. The times can be values in
milliseconds or proportional times between zero (the onset) and one (the
offset).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcut(
  trackdata,
  left.time,
  right.time,
  single = TRUE,
  average = TRUE,
  prop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcut_+3A_trackdata">trackdata</code></td>
<td>
<p>An Emu trackdata object.</p>
</td></tr>
<tr><td><code id="dcut_+3A_left.time">left.time</code></td>
<td>
<p>Either: a numeric vector of the same length as there are
observations in trackdata. Or: a single value between 0 and 1. In the first
case, the left time boundary of trackdata[n,] is cut at left.time[n], in
the second case, and if prop=TRUE, it is cut at that proportional time.</p>
</td></tr>
<tr><td><code id="dcut_+3A_right.time">right.time</code></td>
<td>
<p>Either: a numeric vector of the same length as there are
observations in trackdata. Or: a single value between 0 and 1. In the first
case, the right time boundary of trackdata[n,] is cut at right.time[n], in
the second case, and if prop=TRUE, it is cut at that proportional time.</p>
</td></tr>
<tr><td><code id="dcut_+3A_single">single</code></td>
<td>
<p>If TRUE, one value is returned per segment. This applies when
the requested time falls between two track frames. When single=TRUE, the
preceding value is returned, unless average=TRUE (see below), in which case
the average value of the two frames is returned. when the right.time
argument is omitted</p>
</td></tr>
<tr><td><code id="dcut_+3A_average">average</code></td>
<td>
<p>A single element logical vector - see single above. Applies
only when the right.times argument is omitted and when single = TRUE</p>
</td></tr>
<tr><td><code id="dcut_+3A_prop">prop</code></td>
<td>
<p>If TRUE left.time and right.time are interpreted as
proportions, if FALSE, they are interpreted as millisecond times</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts data from each segment of a trackdata object.
</p>
<p>If 'prop=FALSE' the time arguments ('left.time' and 'right.time') are
interpreted as millisecond times and each should be a vector with the same
length as the number of segments in 'trackdata'.  If 'prop=TRUE' the time
arguments should be single values between zero (the onset of the segment)
and one (the offset).
</p>
<p>If 'right.time' is omitted then a single data point corresponding to
'left.time' for each segment is returned.
</p>


<h3>Value</h3>

<p>A trackdata object if both 'left.time' and 'right.time' are
specified, otherwise a matrix if 'right.time' is unspecified and the
trackdata object has multiple columns of data or a vector if right.time' is
unspecified and the trackdata object has a single column of data.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_trackdata">get_trackdata</a></code>, <code><a href="#topic+dplot">dplot</a></code>, <code><a href="#topic+eplot">eplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
     # the data values of the trackdata object at the temporal midpoint
     # (midvals is matrix of F1 and F2 data)
     dip.fdat[1:10]
     midvals &lt;- dcut(dip.fdat, 0.5, prop=TRUE)
     midvals[1:10,]
     
     
     # the data values of the trackdata object between 
     # extending from 20
     # (bet is a trackdata object of F1 and F2 values)
     bet &lt;- dcut(dip.fdat, 0.2, 0.8, prop=TRUE)
     bet[1]
     

     # the data values of the trackdata object at 30 ms after
     # the start time of the trackdata object
     # (time30 is a matrix of F1 and F2 data
     times &lt;- dip.fdat$ftime[,1]+30
     times[1:10]
     time30 &lt;- dcut(dip.fdat, times)
     time30[1:10]
     

     # the data values of the trackdata object 
     # between the  start time and 30 ms after the start  time
     # (int is a trackdata object of F1 and F2 values extending
     # from the start of the diphthongs up to 30 ms after the diphthongs)
     int &lt;- dcut(dip.fdat, dip.fdat$ftime[,1], times)
     int[1]
 
</code></pre>

<hr>
<h2 id='ddiff'>Differentiation of tracks</h2><span id='topic+ddiff'></span><span id='topic+ddiff.sub'></span>

<h3>Description</h3>

<p>Differentiates a list, as returned by track, to the nth order, readjusting
the index and ftime values each time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddiff(dataset, n = 1, smoothing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddiff_+3A_dataset">dataset</code></td>
<td>
<p>track data object - a list as returned by track</p>
</td></tr>
<tr><td><code id="ddiff_+3A_n">n</code></td>
<td>
<p>the order of differentiation</p>
</td></tr>
<tr><td><code id="ddiff_+3A_smoothing">smoothing</code></td>
<td>
<p>if TRUE track is smoothed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>

<hr>
<h2 id='delete_itemsInLevel'>Delete items programmatically</h2><span id='topic+delete_itemsInLevel'></span>

<h3>Description</h3>

<p>Delete annotation items programmatically. You have to pass in a
data frame, called <code>itemsToDelete</code>, describing these items. The required
columns are described below.
</p>
<p>This function belongs to emuRs CRUD family of functions, which let the user
manipulate items programmatically:
</p>

<ul>
<li><p> Create items (<a href="#topic+create_itemsInLevel">create_itemsInLevel</a>)
</p>
</li>
<li><p> Read items (<a href="#topic+query">query</a>)
</p>
</li>
<li><p> Update items (<a href="#topic+update_itemsInLevel">update_itemsInLevel</a>)
</p>
</li>
<li><p> Delete items (<a href="#topic+delete_itemsInLevel">delete_itemsInLevel</a>))
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>delete_itemsInLevel(
  emuDBhandle,
  itemsToDelete,
  sayYes = FALSE,
  rewriteAllAnnots = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_itemsInLevel_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <a href="#topic+load_emuDB">load_emuDB</a></p>
</td></tr>
<tr><td><code id="delete_itemsInLevel_+3A_itemstodelete">itemsToDelete</code></td>
<td>
<p>A data frame with the columns:
</p>

<ul>
<li> <p><code>session</code> (character)
</p>
</li>
<li> <p><code>bundle</code> (character)
</p>
</li>
<li> <p><code>start_item_id</code> (numeric)
</p>
</li></ul>
</td></tr>
<tr><td><code id="delete_itemsInLevel_+3A_sayyes">sayYes</code></td>
<td>
<p>When you call this function, it warns you about problems it
may create. You can skip that question if you set the <code>sayYes</code> parameter to
TRUE. This is useful when you want to use the function non-interactively.</p>
</td></tr>
<tr><td><code id="delete_itemsInLevel_+3A_rewriteallannots">rewriteAllAnnots</code></td>
<td>
<p>should changes be written to file system (_annot.json
files) (intended for expert use only)</p>
</td></tr>
<tr><td><code id="delete_itemsInLevel_+3A_verbose">verbose</code></td>
<td>
<p>if set to <code>TRUE</code>, more status messages are printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes annotation items from existing levels. Your input data
frame <code>itemsToDelete</code> must describe the items by specifying the columns
<code>session</code>, <code>bundle</code>, and <code>start_item_id</code>.
</p>
<p>Be careful with this function: You can use it to create problematic situations,
for example gaps in the annotation levels, and the function currently has
no checks to prevent this. Instead, you need to explicitly confirm that you
are aware of this, either by setting <code>sayYes</code> to <code>TRUE</code> or by interactively
responding yes to the prompt this function presents.
</p>
<p>A major use case for this function is to obtain a segment list using <a href="#topic+query">query</a>,
possibly modify the segment list and feed it to this function. That is why
the column <code>start_item_id</code> is not called <code>item_id</code>: segment lists include
the former column name, not the latter.
</p>

<hr>
<h2 id='demo.all'>Emu segment list</h2><span id='topic+demo.all'></span>

<h3>Description</h3>

<p>Segment list of the demo database that is part of the Emu system.  It is
the result of a database query, that searched all segments at level
Phonetic.
</p>


<h3>Format</h3>

<p>First Column labels Second start time of the segment Third end time
of the segment Fourth utterance name of the utterance the segment was found
</p>


<h3>Details</h3>

<p>A segment list is created via <code><a href="#topic+query">query</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demo.vowels">demo.vowels</a></code> <code><a href="#topic+segmentlist">segmentlist</a></code>
</p>

<hr>
<h2 id='demo.all.f0'>F0 track data for segment list demo.vowels</h2><span id='topic+demo.all.f0'></span>

<h3>Description</h3>

<p>A track list of the demo database that is part of the Emu system.  It is
the result of get F0 data for the segment list demo.vowels (see
data(demo.vowels)).
</p>


<h3>Format</h3>

<p>An object with $index, $ftime and $data
</p>
<p>index: a two columned matrix with the range of the $data rows that belong
to the segment ftime: a two columned matrix with the times marks of the
segment data: a one columned matrix with the F0 values
</p>


<h3>Details</h3>

<p>A track list is created via the <code><a href="#topic+get_trackdata">get_trackdata</a></code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demo.all.rms">demo.all.rms</a></code> <code><a href="#topic+segmentlist">segmentlist</a></code>
<code><a href="#topic+trackdata">trackdata</a></code>
</p>

<hr>
<h2 id='demo.all.fm'>Formant track data for segment list demo.vowels</h2><span id='topic+demo.all.fm'></span>

<h3>Description</h3>

<p>A track list of the demo database that is part of the Emu system.  It is
the result of get fm data for the segment list demo.vowels (see
data(demo.vowels)).
</p>


<h3>Format</h3>

<p>index: a two columned matrix with the range of the $data rows that
belong to the segment ftime: a two columned matrix with the times marks of
the segment data: a three columned matrix with the formant values of the
first three formants for each segment
</p>


<h3>Details</h3>

<p>A track list is created via the <code><a href="#topic+get_trackdata">get_trackdata</a></code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demo.all.rms">demo.all.rms</a></code> <code><a href="#topic+segmentlist">segmentlist</a></code>
<code><a href="#topic+trackdata">trackdata</a></code>
</p>

<hr>
<h2 id='demo.all.rms'>Emu track data for a rms track for segment list demo.all</h2><span id='topic+demo.all.rms'></span>

<h3>Description</h3>

<p>A track list of the demo database that is part of the Emu system.  It is
the result of get rms data for the segment list demo.all (data(demo.all)).
</p>


<h3>Format</h3>

<p>A object with $index, $ftime and $data
</p>
<p>index: a two columned matrix with the range of the $data rows that belong
to the segment ftime: a two columned matrix with the times marks of the
segment data: a vector with the rms data
</p>


<h3>Details</h3>

<p>A track list is created via the <code><a href="#topic+get_trackdata">get_trackdata</a></code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demo.vowels.fm">demo.vowels.fm</a></code> <code><a href="#topic+segmentlist">segmentlist</a></code>
<code><a href="#topic+trackdata">trackdata</a></code>
</p>

<hr>
<h2 id='demo.vowels'>Emu segment List</h2><span id='topic+demo.vowels'></span>

<h3>Description</h3>

<p>Segment list of the demo database that is part of the Emu system.  It is
the result of a database query, that searched all vowel segments at level
Phonetic.
</p>


<h3>Format</h3>

<p>First Column labels Second start time of the segment Third end time
of the segment Fourth utterance name of the utterance the segment was found
</p>


<h3>Details</h3>

<p>A segment list is created via <code><a href="#topic+query">query</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demo.all">demo.all</a></code> <code><a href="#topic+segmentlist">segmentlist</a></code>
</p>

<hr>
<h2 id='demo.vowels.f0'>F0 track data for segment list demo.vowels</h2><span id='topic+demo.vowels.f0'></span>

<h3>Description</h3>

<p>A track list of the demo database that is part of the Emu system.  It is the
result of get F0 data for the segment list demo.vowels (see
data(demo.vowels)).
</p>


<h3>Format</h3>

<p>An object with $index, $ftime and $data
</p>
<p>index: a two columned matrix with the range of the $data rows that belong
to the segment ftime: a two columned matrix with the times marks of the
segment data: a one columned matrix with the F0 values
</p>


<h3>Details</h3>

<p>A track list is created via the <code><a href="#topic+get_trackdata">get_trackdata</a></code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demo.all.rms">demo.all.rms</a></code> <code><a href="#topic+segmentlist">segmentlist</a></code>
<code><a href="#topic+trackdata">trackdata</a></code>
</p>

<hr>
<h2 id='demo.vowels.fm'>Formant track data for segment list demo.vowels</h2><span id='topic+demo.vowels.fm'></span>

<h3>Description</h3>

<p>A track list of the demo database that is part of the Emu system.  It is the
result of get fm data for the segment list demo.vowels (see
data(demo.vowels)).
</p>


<h3>Format</h3>

<p>index: a two columned matrix with the range of the $data rows that
belong to the segment ftime: a two columned matrix with the times marks of
the segment data: a three columned matrix with the formant values of the
first three formants for each segment
</p>


<h3>Details</h3>

<p>A track list is created via the <code><a href="#topic+get_trackdata">get_trackdata</a></code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demo.all.rms">demo.all.rms</a></code> <code><a href="#topic+segmentlist">segmentlist</a></code>
<code><a href="#topic+trackdata">trackdata</a></code>
</p>

<hr>
<h2 id='dextract'>Extract a subset of data from a trackdata object</h2><span id='topic+dextract'></span><span id='topic+dextract.sub'></span>

<h3>Description</h3>

<p>A function that cuts up trackdata either at a proportional time or
proportionally between two times. It is a subsidiary function of dplot()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dextract(dataset, start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dextract_+3A_dataset">dataset</code></td>
<td>
<p>A trackdata object</p>
</td></tr>
<tr><td><code id="dextract_+3A_start">start</code></td>
<td>
<p>A single valued numeric vector corresponding to a proportional
time between zero (the onset of the trackdata) and one (the offset of the
trackdata).</p>
</td></tr>
<tr><td><code id="dextract_+3A_end">end</code></td>
<td>
<p>As start, but optional</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If both start and end are specified, a trackdata object is
returned, otherwise a vector if the original trackdata is one-dimensional
and the end argument is not used, or a matrix if the original trackdata has
more than one dimension and the end argument is not used
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code>dcut</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(demo.vowels.f0)
data(demo.vowels.fm)

form = demo.vowels.fm
# get the formants at the midpoint: f50 is a matrix
# same as dcut(form, .5, prop=TRUE)
f50 = dextract(form, 0.5)
# get the formants between the 25% and 75% time points
# fcut is a trackdata object
# same as dcut(form, .25, .75, prop=TRUE)
fcut = dextract(form, 0.25, 0.75)
# get  F0 at the midpoint. fzero50 is a vector
# same as dcut(fzero, .5, prop=TRUE)
fzero = demo.vowels.f0
fzero50 = dextract(fzero, 0.5)


</code></pre>

<hr>
<h2 id='dextract.lab'>Extract a subset of data from a trackdata object</h2><span id='topic+dextract.lab'></span>

<h3>Description</h3>

<p>Extract a subset of data from a trackdata object according to the label in
the parallel label vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dextract.lab(dataset, labs, labtype = unique(labs))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dextract.lab_+3A_dataset">dataset</code></td>
<td>
<p>A trackdata object returned from <code>track</code>.</p>
</td></tr>
<tr><td><code id="dextract.lab_+3A_labs">labs</code></td>
<td>
<p>A vector of labels parallel to <code>trackdata$index</code>, i.e. one
for each segment in the trackdata.</p>
</td></tr>
<tr><td><code id="dextract.lab_+3A_labtype">labtype</code></td>
<td>
<p>A vector of labels for which data is to be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trackdata object which is a subset of <code>trackdata</code> containing
only the data for those labels in <code>labtype</code>.  The result has the same
components as the input <code>trackdata</code>:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p> A vector or matrix of numerical data. </p>
</td></tr> <tr><td><code>index</code></td>
<td>
<p> A two
column matrix giving the start and end indices into the data vector for
each segment. </p>
</td></tr> <tr><td><code>ftime</code></td>
<td>
<p> A two column matrix giving the start and end
times for each segment. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p>track, dextract, get.time.element, frames.time
</p>

<hr>
<h2 id='dim.trackdata'>A method of the generic function dim for objects of class 'trackdata'</h2><span id='topic+dim.trackdata'></span><span id='topic+dim'></span>

<h3>Description</h3>

<p>The function returns the dimension attributes of a track data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackdata'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim.trackdata_+3A_x">x</code></td>
<td>
<p>a track data object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns the dimension attributes of a track data object as the
number of segments x number of tracks.  c(nrow(x$index), ncol(x$data))
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   #isol.fdat is the formant track of the segment list isol

   #write out the dimension of the track data object 
   dim(isol.fdat)

   #because there are 13 segments
   isol.fdat$ftime

   #and there are 4 rows for each segment (see here for the first segment)
   isol.fdat$data[1,]

</code></pre>

<hr>
<h2 id='dimnames.trackdata'>Dimnames of trackdata object</h2><span id='topic+dimnames.trackdata'></span>

<h3>Description</h3>

<p>returns dimension names of trackdata objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackdata'
dimnames(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimnames.trackdata_+3A_x">x</code></td>
<td>
<p>trackdata object</p>
</td></tr>
</table>

<hr>
<h2 id='dip'>Segment list of diphthongs, two speakers one male, one female , Standard
North German, read speech from database kielread</h2><span id='topic+dip'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>segmentlist
</p>

<hr>
<h2 id='dip.fdat'>Trackdata of formants from the segment list dip</h2><span id='topic+dip.fdat'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>trackdata object
</p>

<hr>
<h2 id='dip.l'>Vector of phoneme labels from the segment list dip</h2><span id='topic+dip.l'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of phoneme lables
</p>

<hr>
<h2 id='dip.spkr'>Vector of speaker labels from the segment list dip</h2><span id='topic+dip.spkr'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of speaker labels
</p>

<hr>
<h2 id='distance'>distance</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(data, train, labels = NULL, metric = "bayes")
</code></pre>

<hr>
<h2 id='dplot'>A function to plot one or more columns of EMU-trackdata as a function of
time (DEPRECATED see below)</h2><span id='topic+dplot'></span><span id='topic+dplot.norm'></span><span id='topic+dplot.time'></span>

<h3>Description</h3>

<p>A general purpose routine for plotting EMU-trackdata on a single plot.
Tracks can be aligned at an arbitrary position, length normalised or
averaged. The plots can be colour-coded for different category types.
DEPRECATED as this function does not play well with with the new 
resultType = &quot;tibble&quot; of <code>get_trackdata()</code>. See 
<a href="https://ips-lmu.github.io/The-EMU-SDMS-Manual/recipe-plottingSnippets.html">https://ips-lmu.github.io/The-EMU-SDMS-Manual/recipe-plottingSnippets.html</a>
for an alternative plotting routines using ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dplot(
  x,
  labs = NULL,
  offset = 0,
  prop = TRUE,
  average = FALSE,
  xlim = NULL,
  ylim = NULL,
  lty = FALSE,
  normalise = FALSE,
  colour = TRUE,
  lwd = NULL,
  pch = NULL,
  legend = "topright",
  axes = TRUE,
  type = "l",
  n = 20,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dplot_+3A_x">x</code></td>
<td>
<p>An EMU-trackdata object</p>
</td></tr>
<tr><td><code id="dplot_+3A_labs">labs</code></td>
<td>
<p>A label vector with one element for each row in 'dataset'</p>
</td></tr>
<tr><td><code id="dplot_+3A_offset">offset</code></td>
<td>
<p>Either: A single numeric vector between 0 and 1. 0 and 1
denote synchronize the trackdata at their temporal onsets and offsets
respectively; 0.5 denotes synchronization at the temporal midpoint, etc. Or
a numeric vector of the same length as x specifying the synchronisation
point per segment</p>
</td></tr>
<tr><td><code id="dplot_+3A_prop">prop</code></td>
<td>
<p>A single element character vector specifying whether the tracks
should be aligned proportionally or relative to millisecond times. Defaults
to proportional alignment</p>
</td></tr>
<tr><td><code id="dplot_+3A_average">average</code></td>
<td>
<p>If TRUE, the data for each unique label in 'labs' is
averaged</p>
</td></tr>
<tr><td><code id="dplot_+3A_xlim">xlim</code></td>
<td>
<p>A vector of two numeric values specifying the x-axis range</p>
</td></tr>
<tr><td><code id="dplot_+3A_ylim">ylim</code></td>
<td>
<p>A vector of two numeric values specifying the y-axis range</p>
</td></tr>
<tr><td><code id="dplot_+3A_lty">lty</code></td>
<td>
<p>A single element logical vector. Defaults to FALSE.  If TRUE, plot
each label type in a different linetype</p>
</td></tr>
<tr><td><code id="dplot_+3A_normalise">normalise</code></td>
<td>
<p>If TRUE, the data for each segment is linearly time
normalised so that all observations have the same length. The number of
points used in the linear time normalisation is control by the argument n.</p>
</td></tr>
<tr><td><code id="dplot_+3A_colour">colour</code></td>
<td>
<p>A single element logical vector. Defaults to TRUE to plot each
label type in a different colour</p>
</td></tr>
<tr><td><code id="dplot_+3A_lwd">lwd</code></td>
<td>
<p>A code passed to the lwd argument in plotting functions. 'lwd'
can be either a single element numeric vector, or its length must be equal
to the number of unique types in labs. For example, if lwd=3 and if labs =
c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;), then the output is c(3, 3, 3, 3). Alternatively, if
lwd = c(2,3,1), then the output is c(2, 3, 2, 1) for the same example. The
default is NULL in which case all lines are drawn with lwd=1</p>
</td></tr>
<tr><td><code id="dplot_+3A_pch">pch</code></td>
<td>
<p>A code passed to the pch argument in plotting functions.
Functions in the same way as lwd above</p>
</td></tr>
<tr><td><code id="dplot_+3A_legend">legend</code></td>
<td>
<p>Either a character vector to plot the legend. Possible values
are: &quot;bottomright&quot;', '&quot;bottom&quot;', '&quot;bottomleft&quot;', '&quot;left&quot;', '&quot;topleft&quot;',
'&quot;top&quot;', '&quot;topright&quot;', '&quot;right&quot;' and '&quot;center&quot;'. This places the legend on
the inside of the plot frame at the given location. Partial argument
matching is used. Or a logical vector: legend = FALSE suppresses legend
plotting. legend = TRUE plots it at the default, legend = &quot;topright&quot;</p>
</td></tr>
<tr><td><code id="dplot_+3A_axes">axes</code></td>
<td>
<p>A single element logical vector. Defaults to TRUE to plot the axes</p>
</td></tr>
<tr><td><code id="dplot_+3A_type">type</code></td>
<td>
<p>The default line type. Default to &quot;l&quot; for a line plot</p>
</td></tr>
<tr><td><code id="dplot_+3A_n">n</code></td>
<td>
<p>A single element numeric vector. Only used if normalise=TRUE. The
number of data points used to linearly time normalise each track</p>
</td></tr>
<tr><td><code id="dplot_+3A_...">...</code></td>
<td>
<p>graphical options <a href="graphics.html#topic+par">par</a></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dcut">dcut</a></code> <code><a href="#topic+get_trackdata">get_trackdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

   # Plot of column 1 (which happens to be the 1st formant) of an EMU-trackdata object
   dplot(dip.fdat[,1])
	

   # As above but only observations 1 to 5
   dplot(dip.fdat[1:5,1])
	

   #  column 2 (which happens to be of the second formant) and colour-coded
   # for each label-type
   dplot(dip.fdat[,2], dip.l)
	

   # put the legend bottom left
   dplot(dip.fdat[,2], dip.l, legend="bottomleft")
	

   # as above with no legend and averaged per category
   dplot(dip.fdat[,2], dip.l, legend=FALSE, average=TRUE)
	

   # both formants averaged
   dplot(dip.fdat[,1:2], dip.l, average=TRUE)
	

   # F2 only with linear-time normalisation
   dplot(dip.fdat[,2], dip.l, norm=TRUE)
	

   # linear time-normalisation, both formants and averaged
   dplot(dip.fdat[,1:2], dip.l, norm=TRUE, average=TRUE)
	

   # synchronise at the temporal midpoint before averaging, F2 only
   dplot(dip.fdat[,2], dip.l, offset=0.5, average=TRUE)
	

   # synchronise 60 ms before the diphthong offset
   dplot(dip.fdat[,2], dip.l, offset=dip.fdat$ftime[,2]-60, prop=FALSE)
	

   # as above averaged, no colour with linetype, 
# different plot symbols double line thickness in the range between +- 20 ms
   dplot(dip.fdat[,2], dip.l, offset=dip.fdat$ftime[,2]-60, prop=FALSE,
   average=TRUE, colour=FALSE, lty=TRUE, pch=1:3, lwd =2, type="b", xlim=c(-20, 20))




</code></pre>

<hr>
<h2 id='dsmooth'>Smooth the data in a trackdata object.</h2><span id='topic+dsmooth'></span><span id='topic+dsmooth.sub'></span>

<h3>Description</h3>

<p>Smooths each dataset in a trackdata object using a running mean smoother.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsmooth(dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsmooth_+3A_dataset">dataset</code></td>
<td>
<p>A trackdata object as returned from <code>track</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code>dapply</code> function to apply <code>smooth</code> to the
data for each segment.
</p>


<h3>Value</h3>

<p>The result of applying the <code>smooth</code> function to each column of
the data for each segment in the trackdata object.
</p>


<h3>See Also</h3>

<p>smooth, dapply
</p>

<hr>
<h2 id='dtime'>time signal times</h2><span id='topic+dtime'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtime(dataset, times, single = TRUE, average = TRUE)
</code></pre>

<hr>
<h2 id='duplicate_level'>Duplicate level</h2><span id='topic+duplicate_level'></span>

<h3>Description</h3>

<p>Duplicate level of emuDB including all of its items and its various 
attributeDefinitions. If the <code>duplicateLinks</code> variable is set 
to <code>TRUE</code> all the links to and from the original items are 
duplicated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicate_level(
  emuDBhandle,
  levelName,
  duplicateLevelName,
  duplicateLinks = TRUE,
  linkDuplicates = FALSE,
  linkDefType = "ONE_TO_ONE",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicate_level_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle object (see <a href="#topic+load_emuDB">load_emuDB</a>)</p>
</td></tr>
<tr><td><code id="duplicate_level_+3A_levelname">levelName</code></td>
<td>
<p>name of level in emuDB that is to be duplicated</p>
</td></tr>
<tr><td><code id="duplicate_level_+3A_duplicatelevelname">duplicateLevelName</code></td>
<td>
<p>name given to newly duplicated level</p>
</td></tr>
<tr><td><code id="duplicate_level_+3A_duplicatelinks">duplicateLinks</code></td>
<td>
<p>if set to <code>TRUE</code> (the default) all the
links to and from the original items are duplicated to point to the 
new items of the new duplicate level.</p>
</td></tr>
<tr><td><code id="duplicate_level_+3A_linkduplicates">linkDuplicates</code></td>
<td>
<p>link the duplicated ITEMs to the originals. This
can only be set to <code>TRUE</code> if <code>duplicateLinks</code> is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="duplicate_level_+3A_linkdeftype">linkDefType</code></td>
<td>
<p>type given to link definition. Only relevant if <code>linkDuplicates</code>
is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="duplicate_level_+3A_verbose">verbose</code></td>
<td>
<p>show progress bars and further information</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+load_emuDB">load_emuDB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

# duplicate Phonetic level
duplicate_level(ae, levelName = "Phonetic",
                    duplicateLevelName = "Phonetic2")


## End(Not run)

</code></pre>

<hr>
<h2 id='dur'>duration</h2><span id='topic+dur'></span>

<h3>Description</h3>

<p>calculates durations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dur(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dur_+3A_x">x</code></td>
<td>
<p>???</p>
</td></tr>
</table>

<hr>
<h2 id='dur.emusegs'>Duration of segments (NOTE: does not work for new default resultType = &quot;tibble&quot; of <code>query()</code>)</h2><span id='topic+dur.emusegs'></span>

<h3>Description</h3>

<p>duration of segments is calculated for each segment in the segment list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emusegs'
dur(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dur.emusegs_+3A_x">x</code></td>
<td>
<p>a segment list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of durations
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>

<hr>
<h2 id='dur.trackdata'>Duration of trackdata elements</h2><span id='topic+dur.trackdata'></span>

<h3>Description</h3>

<p>Duration of segments is calculated for each element in the trackdata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackdata'
dur(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dur.trackdata_+3A_x">x</code></td>
<td>
<p>a trackdata object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of durations
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>

<hr>
<h2 id='e.dft'>Spectral vector of a single E vowel produced by a male speaker of Standard
North German.</h2><span id='topic+e.dft'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>spectral vector
</p>

<hr>
<h2 id='ellipse'>Calculate ellipse coordinates</h2><span id='topic+ellipse'></span>

<h3>Description</h3>

<p>Calculates ellipse coordinates for eplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse(x, y, rx, ry, orient, incr = 360/100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipse_+3A_x">x</code></td>
<td>
<p>X coordinate of center</p>
</td></tr>
<tr><td><code id="ellipse_+3A_y">y</code></td>
<td>
<p>y coordinate of center</p>
</td></tr>
<tr><td><code id="ellipse_+3A_rx">rx</code></td>
<td>
<p>Radius in the x direction</p>
</td></tr>
<tr><td><code id="ellipse_+3A_ry">ry</code></td>
<td>
<p>Radius in the y direction</p>
</td></tr>
<tr><td><code id="ellipse_+3A_orient">orient</code></td>
<td>
<p>Orientation, in radians. The angle of the major axis to the x
axis.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_incr">incr</code></td>
<td>
<p>The increment between points, in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of x and y coordinates for the ellipse.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eplot">eplot</a></code>
</p>

<hr>
<h2 id='emuR-package'>emuR - Main Package of the EMU Speech Database Management System</h2><span id='topic+emuR-package'></span><span id='topic+emuR'></span>

<h3>Description</h3>

<p>The emuR package provides the next iteration of the EMU Speech 
Database Management System with database management, data 
extraction, data preparation and data visualization facilities.
</p>


<h3>Details</h3>

<p>This package is part of the next iteration of the EMU Speech Database Management System (EMU-SDMS) 
which aims to be as close to an all-in-one solution for generating, manipulating, querying, 
analyzing and managing speech databases as possible. 
For an overview of the system please visit this URL: <a href="http://ips-lmu.github.io/EMU.html">http://ips-lmu.github.io/EMU.html</a>.
</p>
<p>It can be viewed as the main component of the EMU-SDMS as it acts as 
the central instance that is able to interact with every component of the system.
It takes care of database managing duties by being able to interact with a speech 
database that is stored in the emuDB format. Further, it has easy to understand and 
learn yet expressive and powerful querying mechanics, that allow the user to easily query 
the annotation structures of the database. Lastly it provides easy data extraction 
capabilities that extract data (e.g. formant values) which corresponds to the 
result of a query.
</p>
<p>For an introduction to the emuR package please see the <code>emuR_intro</code> vignette 
by calling: <code>vignette('emuR_intro')</code> 
</p>
<p>For information about the <code>emuDB</code> database format please see the <code>emuDB</code>
vignette by calling: <code>vignette('emuDB')</code>
</p>
<p>For information about the query language used by the EMU-SDMS please see the <code>EQL</code>
vignette by calling: <code>vignette('EQL')</code>
</p>
<p>Typical work-flow in emuR (emuDB required):
</p>

<ol>
<li><p> Load database into current R session - <code><a href="#topic+load_emuDB">load_emuDB</a></code>
</p>
</li>
<li><p> Database annotation / visual inspection - 
<code><a href="#topic+serve">serve</a></code> and connect the EMU-webApp to the local server
</p>
</li>
<li><p> Query database - <code><a href="#topic+query">query</a></code> (sometimes 
followed by <code><a href="#topic+requery_hier">requery_hier</a></code> or <code><a href="#topic+requery_seq">requery_seq</a></code>)
</p>
</li>
<li><p> Get trackdata (e.g. formant values) for the result 
of a query - <code><a href="#topic+get_trackdata">get_trackdata</a></code>
</p>
</li>
<li><p> Data preparation
</p>
</li>
<li><p> Visual data inspection
</p>
</li>
<li><p> Further analysis and statistical processing
</p>
</li></ol>

<p>TIP: for a browsable overview of all the functions provided by emuR simply
run the command <code>help.start()</code> -&gt; click on packages -&gt; click on emuR
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Markus Jochim <a href="mailto:markusjochim@phonetik.uni-muenchen.de">markusjochim@phonetik.uni-muenchen.de</a> (<a href="https://orcid.org/0000-0002-5638-4870">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Raphael Winkelmann <a href="mailto:raphael@phonetik.uni-muenchen.de">raphael@phonetik.uni-muenchen.de</a>
</p>
</li>
<li><p> Klaus Jaensch <a href="mailto:klausj@phonetik.uni-muenchen.de">klausj@phonetik.uni-muenchen.de</a> [contributor]
</p>
</li>
<li><p> Steve Cassidy <a href="mailto:steve.cassidy@mq.edu.au">steve.cassidy@mq.edu.au</a> [contributor]
</p>
</li>
<li><p> Jonathan Harrington <a href="mailto:jmh@phonetik.uni-muenchen.de">jmh@phonetik.uni-muenchen.de</a> [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Harrington, J. (2010). The Phonetic Analysis of Speech Corpora.
Blackwell.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/IPS-LMU/emuR">https://github.com/IPS-LMU/emuR</a>
</p>
</li>
<li> <p><a href="https://ips-lmu.github.io/The-EMU-SDMS-Manual/">https://ips-lmu.github.io/The-EMU-SDMS-Manual/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/IPS-LMU/emuR/issues">https://github.com/IPS-LMU/emuR/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create demo data including an emuDB called "ae" 
create_emuRdemoData(dir = tempdir())

# construct path to demo emuDB
path2ae = file.path(tempdir(), "emuR_demoData", "ae")

# load emuDB into current R session
ae = load_emuDB(path2ae)

# query loaded emuDB
lvowels = query(ae, "Phonetic = i: | u: | o:")

# extract labels from query result 
lvowels.labs = label(lvowels)

# list all ssffTrackDefinitions of emuDB
list_ssffTrackDefinitions(ae)

# get formant trackdata defined in ssffTrackDefinitions "fm" for query result
lvowels.fm = get_trackdata(ae, lvowels, "fm")

# extract track values at temporal midpoint of segments
lvowels.fmCut = dcut(lvowels.fm, .5, prop = TRUE)

# Plot the data as time signal and formant card
dplot(lvowels.fm[,1:2], lvowels.labs, normalise=TRUE, main = "Formants over vowel duration")
eplot(lvowels.fmCut[,1:2], lvowels.labs, dopoints=TRUE, 
      doellipse=FALSE, main = "F1/F2 of vowel midpoint", form=TRUE, 
      xlab = "F2 in Hz", ylab = "F1 in Hz")
      
      
# Plot of spectral data from 50% of aspiration duration
hs = query(ae,"Phonetic = H")
hs.labs = label(hs)
hs.dft = get_trackdata(ae, hs, "dft")
hs.dftCut = dcut(hs.dft, .5, prop=TRUE)
plot(hs.dftCut, hs.labs, main = "Spectral data of aspiration")


## End(Not run)

</code></pre>

<hr>
<h2 id='emuRsegs'>emuR segment list</h2><span id='topic+emuRsegs'></span><span id='topic+segment'></span><span id='topic+list'></span>

<h3>Description</h3>

<p>An emuR segment list is a list of segment descriptors. Each segment 
descriptor describes a sequence of annotation elements. The list is
usually a result of an emuDB query using function <code><a href="#topic+query">query</a></code>.
</p>


<h3>Format</h3>

<p>Attributed data.frame, one row per segment descriptor.
</p>
<p>Data frame columns are:
</p>
 
<ul>
<li><p> labels: sequenced labels of segment concatenated by '-&gt;'
</p>
</li>
<li><p> start: onset time in milliseconds
</p>
</li>
<li><p> end: offset time in milliseconds
</p>
</li>
<li><p> session: session name
</p>
</li>
<li><p> bundle: bundle name
</p>
</li>
<li><p> level: level name
</p>
</li>
<li><p> type: type of &quot;segment&quot; row: 'ITEM': symbolic item, 'EVENT': event item, 'SEGMENT': segment
</p>
</li></ul>

<p>Additional hidden columns:
</p>

<ul>
<li><p> utts: utterance name (for compatibility to <a href="#topic+emusegs">emusegs</a> class)
</p>
</li>
<li><p> db_uuid: UUID of emuDB
</p>
</li>
<li><p> startItemID: item ID of first element of sequence
</p>
</li>
<li><p> endItemID: item ID of last element of sequence
</p>
</li>
<li><p> sampleStart: start sample position
</p>
</li>
<li><p> sampleEnd: end sample position
</p>
</li>
<li><p> sampleRate: sample rate
</p>
</li></ul>

<p>Attributes:
</p>

<ul>
<li><p> database: name of emuDB
</p>
</li>
<li><p> query: Query string
</p>
</li>
<li><p> type: type ('segment' or 'event') (for compatibility to <a href="#topic+emusegs">emusegs</a> class)
</p>
</li></ul>



<h3>Details</h3>

<p>Each row shows the annotation label sequence, the start and end position 
in time, session and bundle names, level name and type.
Additionally the row contains the UUID of the emuDB, the ID's of start 
and end elements and the corresponding start and end position as sample 
count and the sample rate. These columns are not printed by default. 
The print method of emuRsegs hides them. To print all columns of a segment 
list object use the print method of <code><a href="base.html#topic+data.frame">data.frame</a></code>.
For example to print all columns of an emuRsegs segmentlist <code>sl</code> type:
<code>print.data.frame(sl)</code>
Though the segment descriptors have references to the annotations, the label 
and sample/time position information is not updated if any of them change. The 
values of the segment list may get invalid if the the database is modified.
A segment may consist only of one single element, in this case start and end ID are equal.
An emuR segment list is the default result of <code><a href="#topic+query">query</a></code> and can 
be used to get track data using <code><a href="#topic+get_trackdata">get_trackdata</a></code>.
The emuRsegs class inherits <a href="#topic+emusegs">emusegs</a> and hence <code><a href="base.html#topic+data.frame">data.frame</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+query">query</a></code>,<code><a href="#topic+get_trackdata">get_trackdata</a></code>,<a href="#topic+emusegs">emusegs</a>
</p>

<hr>
<h2 id='emuRtrackdata'>emuR track data object</h2><span id='topic+emuRtrackdata'></span>

<h3>Description</h3>

<p>A emuR track data object is the result of <code><a href="#topic+get_trackdata">get_trackdata</a></code> if the 
<code>resultType</code> parameter is set to <code>"emuRtrackdata"</code> or the result of 
an explicit call to <code><a href="#topic+create_emuRtrackdata">create_emuRtrackdata</a></code>. Compared to 
the <code><a href="#topic+trackdata">trackdata</a></code> object it is a sub-class of a
<code><a href="base.html#topic+data.frame">data.frame</a></code> which is meant to ease integration with other
packages for further processing. It can be viewed as an amalgamation of
a <code><a href="#topic+emuRsegs">emuRsegs</a></code> and a <code><a href="#topic+trackdata">trackdata</a></code> object as it
contains the information stored in both objects.
</p>


<h3>Format</h3>

<p>The <code><a href="base.html#topic+data.frame">data.frame</a></code> has the following columns:
</p>

<dl>
<dt>$sl_rowIdx</dt><dd><p>column to indicate <code><a href="#topic+emuRsegs">emuRsegs</a></code> row index that 
the value belongs to</p>
</dd>
<dt>$labels - $sampleRate</dt><dd><p>duplicated information of <code><a href="#topic+emuRsegs">emuRsegs</a></code> row entries</p>
</dd>
<dt>$times_rel</dt><dd><p>relative time stamps of sample values in milliseconds</p>
</dd>
<dt>$times_orig</dt><dd><p>absolute time stamps of sample values in milliseconds</p>
</dd>
<dt>$T1 - $TN</dt><dd><p>actual data values (e.g. formant values / F0 values / DFT values / ...)</p>
</dd>
</dl>

<p>Note that $labels - $sampleRate as well as $T1 - $TN (where the N in TN is to be read as the n-th T value) 
refer to multiple columns of the object.
</p>


<h3>Methods</h3>

<p>The following methods are implemented for emuRtrackdata objects: 
</p>
 
<dl>
<dt>cut</dt><dd><p>Function to extract a <code><a href="#topic+emuRtrackdata">emuRtrackdata</a></code> object from an 
emuRtrackdata at a single time point or between two times</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+get_trackdata">get_trackdata</a></code>, <code><a href="#topic+create_emuRtrackdata">create_emuRtrackdata</a></code>
</p>
<p>trackdata
</p>

<hr>
<h2 id='emusegs.database'>emusegs database</h2><span id='topic+emusegs.database'></span>

<h3>Description</h3>

<p>Returns the database attribute from a segmentlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emusegs.database(sl)
</code></pre>

<hr>
<h2 id='emusegs.query'>emusegs query</h2><span id='topic+emusegs.query'></span>

<h3>Description</h3>

<p>sends a emu query to EMU
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emusegs.query(sl)
</code></pre>

<hr>
<h2 id='emusegs.type'>segment list type</h2><span id='topic+emusegs.type'></span>

<h3>Description</h3>

<p>Gives SEGMENT or EVENT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emusegs.type(sl)
</code></pre>

<hr>
<h2 id='engassim'>Segment list of a sequence of syllable final n or N preceding k or g ,
isolated words single speaker, Australian English female from database
epgassim.</h2><span id='topic+engassim'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>segmentlist
</p>

<hr>
<h2 id='engassim.epg'>EPG-compressed trackdata from the segment list engassim</h2><span id='topic+engassim.epg'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>trackdata object
</p>

<hr>
<h2 id='engassim.l'>Vector of phonetic labels from the segment list engassim: nK = nk,ng , sK =
sk,sg</h2><span id='topic+engassim.l'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of phonetic labels
</p>

<hr>
<h2 id='engassim.w'>Vector of word labels from the segment list engassim.</h2><span id='topic+engassim.w'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of word labels
</p>

<hr>
<h2 id='epgai'>Electropalatographic contact indices</h2><span id='topic+epgai'></span><span id='topic+epgci'></span><span id='topic+epgdi'></span>

<h3>Description</h3>

<p>epgai(), epgci(), epgdi() return the anteriority index, the centrality
index, the dorsopalatal index respectively as a trackdata object or a
vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epgai(epgdata, weights = c(1, 9, 81, 729, 4921))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epgai_+3A_epgdata">epgdata</code></td>
<td>
<p>An eight-columned EPG-compressed trackdata object, or an
eight columned matrix of EPG-compressed trackdata, or a 3D palatographic
array that is the output of palate()</p>
</td></tr>
<tr><td><code id="epgai_+3A_weights">weights</code></td>
<td>
<p>A vector of five values that are applied to EPG rows 1-5
respectively in epgai(). A vector of four values that are applied to
columns 1 and 8, to columns 2 and 7, columns 3 and 6, columns 4 and 5
respectively. Defaults to the values given in Recasens &amp; Pallares (2001).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are exact implementations of the formulae for calculating the EPG
anteriority, EPG centrality, and EPG dorsopalatal indices as described in
Recasens &amp; Pallares (2001).
</p>


<h3>Value</h3>

<p>These functions return a trackdata object if they are applied to an
eight-columned EPG-compressed trackdata object, otherwise a one-columned
matrix.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>References</h3>

<p>GIBBON, F. AND NICOLAIDIS, K. (1999). Palatography.  In W.J.
Hardcastle &amp; N. Hewlett (eds). Coarticulation.  (pp. 229-245). Cambridge
University Press: Cambridge.
</p>
<p>RECASENS, D. &amp; PALLARES, M. (2001) Coarticulation, assimilation and
blending in Catalan consonant clusters. Journal of Phonetics, 29, 273-301.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epgcog">epgcog</a></code> <code><a href="#topic+epggs">epggs</a></code> <code><a href="#topic+palate">palate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  Anteriority index: trackdata
ai &lt;- epgai(coutts.epg)
#  Dorsopalatal index, one-columned matrix
di &lt;- epgdi(dcut(coutts.epg, 0.5, prop=TRUE))
# Next to examples: Centrality  index, one-columed matrix
ci &lt;- epgci(palate(coutts.epg))
ci &lt;- epgci(palate(dcut(coutts.epg, 0.5, prop=TRUE)))


</code></pre>

<hr>
<h2 id='epgcog'>Electropalatographic centre of gravity</h2><span id='topic+epgcog'></span>

<h3>Description</h3>

<p>Calculate the centre of gravity in palatographic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epgcog(
  epgdata,
  weights = seq(7.5, 0.5, by = -1),
  rows = 1:8,
  columns = 1:8,
  row1 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epgcog_+3A_epgdata">epgdata</code></td>
<td>
<p>An eight-columned EPG-compressed trackdata object, or an
eight columned matrix of EPG-compressed trackdata, or a 3D palatographic
array that is the output of palate()</p>
</td></tr>
<tr><td><code id="epgcog_+3A_weights">weights</code></td>
<td>
<p>A vector of 8 values that are applied to EPG rows 1-8
respectively. Defaults to 7.5, 7.0, 6.5...0.5.</p>
</td></tr>
<tr><td><code id="epgcog_+3A_rows">rows</code></td>
<td>
<p>Calculate EPG-COG over selected row number(s). rows = 5:8,
columns = 3:6 is an implementation of posterior centre of gravity, as
defined by Gibbon &amp; Nicolaidis (1999,p. 239). See examples below.</p>
</td></tr>
<tr><td><code id="epgcog_+3A_columns">columns</code></td>
<td>
<p>Calculate EPG-COG over selected column number(s).</p>
</td></tr>
<tr><td><code id="epgcog_+3A_row1">row1</code></td>
<td>
<p>an optional single valued numeric vector to allow a separate
weighting of the electrodes in row1. For example, if row1=4/3, then all the
electrodes in row1 are multiplied by that value, before EPG-COG is
calculated. Defaults to NULL (no weighting).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The centre of gravity is a key function in palatographic research and gives
an value per palate that is indicative of the overall location of contacts
along the anterior-posterior dimension. The formula is an implementation of
the ones discussed in Hardcastle et al. (1991), Gibbon et al (1993), and
Gibbon &amp; Nicolaidis (1999).
</p>


<h3>Value</h3>

<p>These functions return a trackdata object if they are applied to an
eight-columned EPG-compressed trackdata object, otherwise a one-columned
matrix.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>References</h3>

<p>GIBBON, F., HARDCASTLE, W. and NICOLAIDIS, K. (1993) Temporal
and spatial aspects of lingual coarticulation in /kl/ sequences: a
cross-linguistic investigation. Language &amp; Speech, 36, 26t1-277.
</p>
<p>GIBBON, F. AND NICOLAIDIS, K. (1999). Palatography.  In W.J. Hardcastle &amp;
N. Hewlett (eds). Coarticulation.  (pp. 229-245). Cambridge University
Press: Cambridge.
</p>
<p>HARDCASTLE, W, GIBBON, F. and NICOLAIDIS, K. (1991) EPG data reduction
methods and their implications for studies of lingual coarticulation.
Journal of Phonetics, 19, 251-266.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epgai">epgai</a></code> <code><a href="#topic+epgsum">epgsum</a></code> <code><a href="#topic+palate">palate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  COG: trackdata
cog &lt;- epgcog(coutts.epg)
#  cog, one-columned matrix
cog &lt;- epgcog(dcut(coutts.epg, 0.5, prop=TRUE))
# posterior cog for Fig. 10.5, p. 239 in Gibbon &amp; Nicolaidis (1999)
r = array(0, c(8, 8, 2))
r[6,c(1, 8),1] &lt;- 1
r[7,c(1, 2, 7, 8), 1] &lt;- 1
r[8, ,1] &lt;- 1
r[4, c(1, 2, 8), 2] &lt;- 1
r[5, c(1, 2, 7, 8), 2] &lt;- 1
r[6, c(1, 2, 3, 7, 8), 2] &lt;- 1
r[7:8, , 2] = 1
class(r) &lt;- "EPG"
epgcog(r, rows=5:8, columns=3:6)

</code></pre>

<hr>
<h2 id='epggs'>Plot a grey-scale image of palatographic data.</h2><span id='topic+epggs'></span>

<h3>Description</h3>

<p>The function plots a grey-scale image of palatographic data such that the
greyness in cell r, c is in proportion to the frequency of contacts in
cells of row r and columns c of all palatograms in the object passed to
this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epggs(
  epgdata,
  gscale = 100,
  gridlines = TRUE,
  gridcol = "gray",
  gridlty = 1,
  axes = TRUE,
  xlab = "",
  ylab = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epggs_+3A_epgdata">epgdata</code></td>
<td>
<p>An eight-columned EPG-compressed trackdata object, or an
eight columned matrix of EPG-compressed trackdata, or a 3D palatographic
array that is the output of palate()</p>
</td></tr>
<tr><td><code id="epggs_+3A_gscale">gscale</code></td>
<td>
<p>a single valued numeric vector that defines the granularity
of the greyscale. Defaults to 100.</p>
</td></tr>
<tr><td><code id="epggs_+3A_gridlines">gridlines</code></td>
<td>
<p>if TRUE (default) grid lines over the palatographic image are
drawn are drawn.</p>
</td></tr>
<tr><td><code id="epggs_+3A_gridcol">gridcol</code></td>
<td>
<p>color of grid</p>
</td></tr>
<tr><td><code id="epggs_+3A_gridlty">gridlty</code></td>
<td>
<p>A single-valued numeric vector that defines the linetype for
plotting the grid.</p>
</td></tr>
<tr><td><code id="epggs_+3A_axes">axes</code></td>
<td>
<p>TRUE for show axes, FALSE for no axes</p>
</td></tr>
<tr><td><code id="epggs_+3A_xlab">xlab</code></td>
<td>
<p>A character vector for the x-axis label.</p>
</td></tr>
<tr><td><code id="epggs_+3A_ylab">ylab</code></td>
<td>
<p>A character vector for the y-axis label.</p>
</td></tr>
<tr><td><code id="epggs_+3A_...">...</code></td>
<td>
<p>graphical parameters can be given as arguments to 'epggs'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots a grey-scale image of up to 62 values arranged over an 8
x 8 grid with columns 1 and 8 unfilled for row 1.  If cell row r column c
is contacted for all palatograms in the object that is passed to this
function, the corresponding cell is black; if none of of the cells in row r
column c are contacted, then the cell is white (unfilled).
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epgai">epgai</a></code> <code><a href="#topic+epgcog">epgcog</a></code> <code><a href="#topic+epgplot">epgplot</a></code>
<code><a href="#topic+palate">palate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# greyscale image across the first two segments 'just relax'
# with title
epggs(coutts.epg[1:2,], main="just relax")

# as above but with dotted gridlines in blue
epggs(coutts.epg[1:2,], main="just relax", gridlty=2, gridcol="blue")

# as the first example, but with greyscale set to 2
epggs(coutts.epg[1:2,], 2, main="just relax")

# get palatograms for "S" from the polhom.epg database
temp = polhom.l == "S"
# greyscale image of all "S" segments at their temporal midpoint
epggs(dcut(polhom.epg[temp,], 0.5, prop=TRUE))

# greyscale image of all "S" segments from their onset to offset
epggs(polhom.epg[temp,])

# the same but derived from palates
p &lt;- palate(polhom.epg[temp,])
epggs(p)

</code></pre>

<hr>
<h2 id='epgplot'>Plot palatographic data</h2><span id='topic+epgplot'></span>

<h3>Description</h3>

<p>Function to plot palatograms from EPG compressed objects or from a
3D-palatographic array that is output from palate().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epgplot(
  epgdata,
  select = NULL,
  numbering = "times",
  gridlines = TRUE,
  mfrow = NULL,
  col = 1,
  mar = c(0.8, 0.1, 0.8, 0.1),
  xlim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epgplot_+3A_epgdata">epgdata</code></td>
<td>
<p>An eight-columned EPG-compressed trackdata object, or an
eight columned matrix of EPG-compressed trackdata, or a 3D palatographic
array that is the output of palate()</p>
</td></tr>
<tr><td><code id="epgplot_+3A_select">select</code></td>
<td>
<p>A vector of times. Palatograms are plotted at these times
only. Note: this argument should only be used if epgdata is temporally
contiguous, i.e. the entire trackdata object contains palatograms at
successive multiple times of the EPG sampling frequency. (as in
coutts.epg$ftime). Defaults to NULL, in which case palatograms are plotted
for all times available in epgdata.</p>
</td></tr>
<tr><td><code id="epgplot_+3A_numbering">numbering</code></td>
<td>
<p>Either &quot;times&quot; (default), or logical TRUE, or a character
vector of the same length as the number of segments in epgdata.  In the
default case, the times at which the palatograms occur are printed above
the palatograms. If logical TRUE, then the palatograms are numbered 1, 2, ...
number of segments and this value is printed above the palatograms. If a
character vector, then this must be the same length as the number of
segments in epgdata.</p>
</td></tr>
<tr><td><code id="epgplot_+3A_gridlines">gridlines</code></td>
<td>
<p>if TRUE (default) grid lines over the palatogram are drawn.</p>
</td></tr>
<tr><td><code id="epgplot_+3A_mfrow">mfrow</code></td>
<td>
<p>By default, the function tries to work out a sensible number
of rows and columns for plotting the palatograms. Otherwise, this can be
user-specified, in which case mfrow is a vector of two integer numeric
values.</p>
</td></tr>
<tr><td><code id="epgplot_+3A_col">col</code></td>
<td>
<p>specify a colour for plotting the filled EPG cells.</p>
</td></tr>
<tr><td><code id="epgplot_+3A_mar">mar</code></td>
<td>
<p>A numerical vector of the form 'c(bottom, left, top, right)'
which gives the number of lines of margin to be specified on the four sides
of the plot. The default in this function is c(0.8, 0.1, 0.8, 0.1). (The
default in the R plot() function is c(5, 4, 4, 2) + 0.1.</p>
</td></tr>
<tr><td><code id="epgplot_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector of two time values over which the epgdata
should be plotted.  Note: this argument should only be used if epgdata is
temporally contiguous, i.e. the entire trackdata object contains
palatograms at successive multiple times of the EPG sampling frequency. (as
in coutts.epg$ftime). Defaults to NULL (plot all time values).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots 62 values arranged over an 8 x 8 grid with columns 1 and
8 unfilled for row 1.  When there is a contact (1), the corresponding
rectangle of the grid is filled otherwise the rectangle is empty.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epgai">epgai</a></code> <code><a href="#topic+epgcog">epgcog</a></code> <code><a href="#topic+epggs">epggs</a></code>
<code><a href="#topic+palate">palate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
epgplot(polhom.epg[10,])

# as above but between times 1295 ms and 1330 ms
epgplot(polhom.epg[10,], xlim=c(1295, 1330))

# the same as above, but the data is first
# converted to a 3D palatographic array
p &lt;- palate(polhom.epg[10,])
epgplot(p, xlim=c(1295, 1330))

# plot palatograms 2 and 8
epgplot(p[,,c(2, 8)])

# as above but
# no gridlines, different colour, numbering rather than times
epgplot(p[,,c(2, 8)], gridlines=FALSE, col="pink", numbering=TRUE)

# as above but with a user-specified title

epgplot(p[,,c(2, 8)], gridlines=FALSE, col="pink", numbering=c("s1", "s2"))

# plot the palatograms in the second
# segment of coutts.epg that are closest in time
# to 16377 ms and 16633 ms
epgplot(coutts.epg[2,], c(16377, 16633))


</code></pre>

<hr>
<h2 id='epgsum'>Sum contacts in palatograms.</h2><span id='topic+epgsum'></span>

<h3>Description</h3>

<p>The function calculates EPG contact profiles, i.e. sums active or inactive
electrodes optionally by row and/or column in palatographic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epgsum(
  epgdata,
  profile = c(1, 3),
  inactive = FALSE,
  rows = 1:8,
  columns = 1:8,
  trackname = "EPG-sum"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epgsum_+3A_epgdata">epgdata</code></td>
<td>
<p>An eight-columned EPG-compressed trackdata object, or an
eight columned matrix of EPG-compressed trackdata, or a 3D palatographic
array that is the output of palate()</p>
</td></tr>
<tr><td><code id="epgsum_+3A_profile">profile</code></td>
<td>
<p>A numeric vector of one or two values. The options are as
follows. c(1,3) and c(1) sum the contacts by row, but the latter outputs
the summation in the rows. c(2,3) and c(2) sum the contacts by column, but
the latter outputs the summation in the columns. (see also rows and columns
arguments and the examples below for further details).</p>
</td></tr>
<tr><td><code id="epgsum_+3A_inactive">inactive</code></td>
<td>
<p>a single element logical vector. If FALSE (the default), then
the active electrodes (i.e, 1s) are summed, otherwise the inactive
electrodes (i.e., 0s) are summed.</p>
</td></tr>
<tr><td><code id="epgsum_+3A_rows">rows</code></td>
<td>
<p>vector of rows to sum</p>
</td></tr>
<tr><td><code id="epgsum_+3A_columns">columns</code></td>
<td>
<p>vector of columns to sum</p>
</td></tr>
<tr><td><code id="epgsum_+3A_trackname">trackname</code></td>
<td>
<p>single element character vector of the name of the track
(defaults to &quot;EPG-sum&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contact profiles are standard tools in electropalatographic analysis. See
e.g., Byrd (1996) for details.
</p>


<h3>Value</h3>

<p>These functions return a trackdata object if they are applied to an
eight-columned EPG-compressed trackdata object, otherwise a one-columned
matrix.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>References</h3>

<p>BYRD, D. (1996). Influences on articulatory timing in consonant
sequences. Journal of Phonetics, 24, 209-244.
</p>
<p>GIBBON, F. AND NICOLAIDIS, K. (1999). Palatography.  In W.J. Hardcastle &amp;
N. Hewlett (eds). Coarticulation.  (pp. 229-245). Cambridge University
Press: Cambridge.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epgai">epgai</a></code> <code><a href="#topic+epgcog">epgcog</a></code> <code><a href="#topic+epggs">epggs</a></code>
<code><a href="#topic+palate">palate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Trackdata object of the sum of contacts in the 1st segment of polhom.epg
epgsum(polhom.epg[1,])
# as above, but the summation is in rows 1-3 only.
epgsum(polhom.epg[1,], rows=c(1:3))
# as epgsum(polhom.epg[1,]), except sum the inactive electrodes in columns 3-6.
epgsum(polhom.epg[1,], columns=3:6, inactive=TRUE)
# Obtain compressed EPG-trackdata object for the 1st four segments of polhom.epg
# at the temporal midpoint
mid &lt;- dcut(polhom.epg[1:4,], .5, prop=TRUE)
# sum of contacts in these four palatograms.
epgsum(mid)
# gives the same result as the previous command.
p &lt;- palate(mid)
# sum the contacts in the palatograms.
epgsum(p)
# as above, but show the separate row summmations. 
epgsum(p, 1)
# as above, but show the separate column summmations. 
epgsum(p, 2)
# sum of the contacts in rows 1-4 showing the separate row summations.
epgsum(p, 1, rows=1:4)
# sum of the contacts in rows 1-4 showing the separate column summations.
epgsum(p, 2, rows=1:4)
# sum of the contacts in columns 3-6  showing the separate row summations.
epgsum(p, 1, columns=3:6)
# sum of the contacts in columns 3-6  showing the separate column summations.
epgsum(p, 2, columns=3:6)


</code></pre>

<hr>
<h2 id='eplot'>Plot ellipses for two-dimensional data (DEPRECATED see below)</h2><span id='topic+eplot'></span>

<h3>Description</h3>

<p>The function plots ellipses for different categories from two-dimensional
data. DEPRECATED as this function does not play well with with the new 
resultType = &quot;tibble&quot; of <code>get_trackdata()</code>. See <a href="https://ips-lmu.github.io/The-EMU-SDMS-Manual/recipe-plottingSnippets.html">https://ips-lmu.github.io/The-EMU-SDMS-Manual/recipe-plottingSnippets.html</a>
for an alternative plotting routines using ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eplot(
  x,
  labs,
  chars,
  formant = FALSE,
  scaling = "linear",
  prob = 0.95,
  nsdev = NULL,
  dopoints = FALSE,
  doellipse = TRUE,
  centroid = FALSE,
  axes = TRUE,
  xlim,
  ylim,
  col = TRUE,
  lty = FALSE,
  lwd = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eplot_+3A_x">x</code></td>
<td>
<p>A two-columned matrix of data</p>
</td></tr>
<tr><td><code id="eplot_+3A_labs">labs</code></td>
<td>
<p>An optional vector of labels, parallel to 'data'</p>
</td></tr>
<tr><td><code id="eplot_+3A_chars">chars</code></td>
<td>
<p>An optional vector of labels, parallel to 'data'. If this
argument is specified these labels will be plotted rather than the labels
in 'labs'.</p>
</td></tr>
<tr><td><code id="eplot_+3A_formant">formant</code></td>
<td>
<p>If TRUE) then the data is negated and the axes are switched
so that, for formant data, the plot is made with decreasing F2 on the
x-axis and decreasing F1 on the y-axis.</p>
</td></tr>
<tr><td><code id="eplot_+3A_scaling">scaling</code></td>
<td>
<p>Either &quot;mel&quot; or &quot;bark&quot; for mel or bark scaling of the data</p>
</td></tr>
<tr><td><code id="eplot_+3A_prob">prob</code></td>
<td>
<p>A single numeric vector greater than zero and less than 1
representing the confidence interval of the ellipse contours. Defaults to
0.95</p>
</td></tr>
<tr><td><code id="eplot_+3A_nsdev">nsdev</code></td>
<td>
<p>Defines the length of the major and minor axes of the ellipses
in terms of the standard deviation of the data and overrides the prob
argument.</p>
</td></tr>
<tr><td><code id="eplot_+3A_dopoints">dopoints</code></td>
<td>
<p>If TRUE) character labels (from 'labs' or 'chars') are
plotted for each data point</p>
</td></tr>
<tr><td><code id="eplot_+3A_doellipse">doellipse</code></td>
<td>
<p>If TRUE, ellipses are drawn on the plot. If FALSE, no
ellipses are drawn and, if 'dopoints' is also FALSE, 'centroids' is set to
TRUE</p>
</td></tr>
<tr><td><code id="eplot_+3A_centroid">centroid</code></td>
<td>
<p>One label for each ellipse is drawn</p>
</td></tr>
<tr><td><code id="eplot_+3A_axes">axes</code></td>
<td>
<p>If TRUE axes are drawn on the plot.</p>
</td></tr>
<tr><td><code id="eplot_+3A_xlim">xlim</code></td>
<td>
<p>A vector of two numeric values giving the range of the x-axis.</p>
</td></tr>
<tr><td><code id="eplot_+3A_ylim">ylim</code></td>
<td>
<p>A vector of two numeric values giving the range of the y-axis.</p>
</td></tr>
<tr><td><code id="eplot_+3A_col">col</code></td>
<td>
<p>If colour is TRUE) the ellipses and labels will be plotted in
different colours</p>
</td></tr>
<tr><td><code id="eplot_+3A_lty">lty</code></td>
<td>
<p>If linetype is TRUE) the ellipses will be plotted with different
linetypes.  This is useful for plots that will be printed.</p>
</td></tr>
<tr><td><code id="eplot_+3A_lwd">lwd</code></td>
<td>
<p>A code passed to the lwd argument in plotting functions. 'lwd'
can be either a single element numeric vector, or its length must be equal
to the number of unique types in labs. For example, if lwd=3 and if labs =
c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;), then the output is c(3, 3, 3, 3). Alternatively, if
lwd = c(2,3,1), then the output is c(2, 3, 2, 1) for the same example. The
default is NULL in which case all lines are drawn with lwd=1</p>
</td></tr>
<tr><td><code id="eplot_+3A_...">...</code></td>
<td>
<p>graphical options <a href="graphics.html#topic+par">par</a></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan Harrington, Steve Cassidy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dcut">dcut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

   data(vowlax)
   data &lt;- cbind(vowlax.df$F1,vowlax.df$F2)
   phonetic = vowlax.l
   word = vowlax.word

   eplot(data, phonetic)
    
  
   eplot(data, phonetic, form=TRUE, main="F1 x F2 plane", centroid=TRUE)
   eplot(data, phonetic, form=TRUE, main="F1 x F2 plane", dopoints=TRUE)
   eplot(data, phonetic, form=TRUE, main="F1 x F2 plane in Bark", 
         dopoints=TRUE, scaling="bark")
   eplot(data, phonetic, form=TRUE, main="F1 x F2 plane in Bark b/w with linetype", 
         col=FALSE, lty=TRUE, dopoints=TRUE, scaling="bark") 
   eplot(data, phonetic, form=TRUE, main="F1 x F2 plane", 
         doellipse=FALSE, dopoints=TRUE)
   eplot(data, phonetic, form=TRUE, dopoints=TRUE, 
         prob=0.5, main="F1 x F2 plane, 50% confidence intervals")
   eplot(data, phonetic, form=TRUE, dopoints=TRUE, 
         nsdev=2, main="F1 x F2 plane, 2 standard deviations")
   

   temp &lt;- phonetic %in% c("a", "O")
   eplot(data[temp,], phonetic[temp], form=TRUE,  main="F1 x F2 [A] and [O] only", centroid=TRUE)
   

   temp &lt;- phonetic=="O"
   eplot(data[temp,], phonetic[temp], word[temp], form=TRUE, 
         dopoints=TRUE, main="[O] only showing word labels")  
      
   



</code></pre>

<hr>
<h2 id='euclidean'>Find the inter-euclidean distance for a data matrix</h2><span id='topic+euclidean'></span><span id='topic+euclidean.metric'></span>

<h3>Description</h3>

<p>Finds the inter-euclidean distance for a data matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidean(data, m = 1, n = ncol(data))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euclidean_+3A_data">data</code></td>
<td>
<p>A vector or matrix of numerical data.</p>
</td></tr>
<tr><td><code id="euclidean_+3A_m">m</code></td>
<td>
<p>The first column of data to be used in the distance calculation.</p>
</td></tr>
<tr><td><code id="euclidean_+3A_n">n</code></td>
<td>
<p>The last column of data to be used in the distance calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calculates the euclidean distance between successive rows of the
matrix based on columns m:n.
</p>


<h3>See Also</h3>

<p>steady
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  euclidean(cbind(c(1,2,3,4), c(2,3,2,2)))
</code></pre>

<hr>
<h2 id='expand_labels'>Label each data sample</h2><span id='topic+expand_labels'></span>

<h3>Description</h3>

<p>Labels each data sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_labels(indvals, labs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_labels_+3A_indvals">indvals</code></td>
<td>
<p>Index component of a trackdata object as returned by
<code>frames</code>, or <code>track</code>.</p>
</td></tr>
<tr><td><code id="expand_labels_+3A_labs">labs</code></td>
<td>
<p>A label vector parallel to <code>indvals</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of labels, one for each row in the data matrix
that corresponds to <code>indvals</code>.
</p>


<h3>See Also</h3>

<p>frames, track
</p>

<hr>
<h2 id='export_BPFCollection'>Exports an emuDB into a BAS Partitur File (BPF) Collection</h2><span id='topic+export_BPFCollection'></span>

<h3>Description</h3>

<p>This function exports an emuDB into the BAS Partitur File format, with one BPF file per bundle.
The user must pass a list of matching label names and BPF keys. 
<strong>Important:</strong> The BPF format does not support explicit hierarchies with more than three
levels. Hence, you will probably lose information when exporting complex hierarchies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_BPFCollection(
  handle,
  targetDir,
  extractLevels,
  refLevel = NULL,
  verbose = TRUE,
  newLevels = NULL,
  newLevelClasses = NULL,
  copyAudio = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_BPFCollection_+3A_handle">handle</code></td>
<td>
<p>handle to the emuDB</p>
</td></tr>
<tr><td><code id="export_BPFCollection_+3A_targetdir">targetDir</code></td>
<td>
<p>directory where the BPF collection should be saved</p>
</td></tr>
<tr><td><code id="export_BPFCollection_+3A_extractlevels">extractLevels</code></td>
<td>
<p>list containing the names of labels (not levels!) that should be extracted, and their
matching BPF keys, e.g. extractLevels = list(SampleRate=&quot;SAM&quot;, Text=&quot;ORT&quot;, Phonemes=&quot;SAP&quot;)</p>
</td></tr>
<tr><td><code id="export_BPFCollection_+3A_reflevel">refLevel</code></td>
<td>
<p>optional name of level (not label!) used as reference for symbolic links. If NULL (the default), a link-less BPF collection is created.</p>
</td></tr>
<tr><td><code id="export_BPFCollection_+3A_verbose">verbose</code></td>
<td>
<p>display infos, warnings and show progress bar</p>
</td></tr>
<tr><td><code id="export_BPFCollection_+3A_newlevels">newLevels</code></td>
<td>
<p>optional vector containing names of levels in the BPF collection that are not part of the standard 
BPF levels. See <a href="http://www.bas.uni-muenchen.de/forschung/Bas/BasFormatseng.html#Partitur_tiersdef">http://www.bas.uni-muenchen.de/forschung/Bas/BasFormatseng.html#Partitur_tiersdef</a> for details on 
standard BPF levels.</p>
</td></tr>
<tr><td><code id="export_BPFCollection_+3A_newlevelclasses">newLevelClasses</code></td>
<td>
<p>optional vector containing the classes of levels in the newLevels vector as integers. 
Must have the same length and order as newLevels.</p>
</td></tr>
<tr><td><code id="export_BPFCollection_+3A_copyaudio">copyAudio</code></td>
<td>
<p>if true, audio files are copied to the new BPF collection</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>export_TextGridCollection
</p>

<hr>
<h2 id='export_seglistToTxtCollection'>Exports a segment list to txt collection</h2><span id='topic+export_seglistToTxtCollection'></span>

<h3>Description</h3>

<p>Extract the media file (usually .wav file) snippets that correspond to 
the segments of a segment list (see result of a <code><a href="#topic+query">query</a></code>) and 
save them to separate files and write the corresponding labels into a .txt file. Further,
the segmentlist is also stored to the target directory (as a .csv file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_seglistToTxtCollection(emuDBhandle, seglist, targetDir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_seglistToTxtCollection_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="export_seglistToTxtCollection_+3A_seglist">seglist</code></td>
<td>
<p><code>tibble</code>, <code><a href="#topic+emuRsegs">emuRsegs</a></code> or 
<code><a href="#topic+emusegs">emusegs</a></code> object obtained by <code><a href="#topic+query">query</a></code>ing a loaded emuDB</p>
</td></tr>
<tr><td><code id="export_seglistToTxtCollection_+3A_targetdir">targetDir</code></td>
<td>
<p>target directory to store</p>
</td></tr>
</table>

<hr>
<h2 id='export_TextGridCollection'>Export annotations of emuDB to TextGrid collection</h2><span id='topic+export_TextGridCollection'></span>

<h3>Description</h3>

<p>Exports the annotations of an emuDB to a TextGrid collection (.TextGrid and .wav file pairs).
To avoid naming conflicts and not to loose the session information, the session structure of 
the database is kept in place (i.e. the TextGrid collection will have sub-folders that are named
as the sessions were). Due to the more complex annotation structure modeling capabilities of 
the EMU-SDMS system, this export routine has to make several compromises on export which 
can lead to information loss. So use with caution and at own risk as reimporting the exported
data will mean that not all information can be recreated!
The main compromises are:
</p>

<ul>
<li><p> If a MANY_TO_MANY relationship between two levels is present and 
two items from the parent level are linked to a single item on the child level, the 
concatenated using the '-&gt;' symbol. An example would be: the annotation items containing the labels 'd' and 'b' of the 
parent items are merged into a single annotation item and their labels are 
Phoneme level are linked to 'db' on the Phonetic level. The generated Phoneme tier then has a segment with the 
start and end times of the 'db' item and contains the labels 'db' (see for example the 
bundle 0000_ses/msajc010_bndl of the ae_emuDB).
</p>
</li>
<li><p> As annotations can contain gaps (e.g. incomplete hierarchies or orphaned items) and do not have to start at
time 0 and be the length of the audio file this export routine pads these gaps with empty segments.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>export_TextGridCollection(
  emuDBhandle,
  targetDir,
  sessionPattern = ".*",
  bundlePattern = ".*",
  attributeDefinitionNames = NULL,
  timeRefSegmentLevel = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_TextGridCollection_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle object (see <a href="#topic+load_emuDB">load_emuDB</a>)</p>
</td></tr>
<tr><td><code id="export_TextGridCollection_+3A_targetdir">targetDir</code></td>
<td>
<p>directory where the TextGrid collection should be saved</p>
</td></tr>
<tr><td><code id="export_TextGridCollection_+3A_sessionpattern">sessionPattern</code></td>
<td>
<p>A regular expression pattern matching session names to be exported from the database</p>
</td></tr>
<tr><td><code id="export_TextGridCollection_+3A_bundlepattern">bundlePattern</code></td>
<td>
<p>A regular expression pattern matching bundle names to be exported from the database</p>
</td></tr>
<tr><td><code id="export_TextGridCollection_+3A_attributedefinitionnames">attributeDefinitionNames</code></td>
<td>
<p>list of names of attributeDefinitions that are to be 
exported as tiers. If set to NULL (the default) all attribute definitions will be exported as separate tiers.</p>
</td></tr>
<tr><td><code id="export_TextGridCollection_+3A_timerefsegmentlevel">timeRefSegmentLevel</code></td>
<td>
<p>parameter passed into <a href="#topic+query">query</a> function. (set time segment level from which to derive time 
information. It is only necessary to set this parameter if more than one child 
level contains time information and the queried parent level is of type ITEM.)</p>
</td></tr>
<tr><td><code id="export_TextGridCollection_+3A_verbose">verbose</code></td>
<td>
<p>Show progress bars and further information</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+load_emuDB">load_emuDB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

## Export all levels
export_TextGridCollection(ae, "/path/2/targetDir")


## End(Not run)

</code></pre>

<hr>
<h2 id='fapply'>Function that applies a function to an EMU spectral object</h2><span id='topic+fapply'></span>

<h3>Description</h3>

<p>Applies a function to an EMU spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fapply(specdata, fun, ..., power = FALSE, powcoeffs = c(10, 10))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fapply_+3A_specdata">specdata</code></td>
<td>
<p>A matrix or trackdata object of class spectral</p>
</td></tr>
<tr><td><code id="fapply_+3A_fun">fun</code></td>
<td>
<p>A function to be applied.</p>
</td></tr>
<tr><td><code id="fapply_+3A_...">...</code></td>
<td>
<p>Optional arguments to fun</p>
</td></tr>
<tr><td><code id="fapply_+3A_power">power</code></td>
<td>
<p>A single element logical vector. If TRUE, convert specdata to
power values i.e. apply the function to a * specdata
<code class="reqn">\mbox{\textasciicircum}</code>b or a * specdata$data
<code class="reqn">\mbox{\textasciicircum}</code>b where a and b powcoeffs defined below.</p>
</td></tr>
<tr><td><code id="fapply_+3A_powcoeffs">powcoeffs</code></td>
<td>
<p>A 2 element numeric vector for converting dB values to
power values. Defaults to a = 10 and b = 10. See <code>power</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>fapply performs a similar operation to apply except that it is specifically
designed for handling EMU spectral objects.
</p>


<h3>Value</h3>

<p>If the output has the same dimensions has the input, then an object
of the same dimensionality and class is returned. Otherwise it may be a
vector or matrix depending on the function that is applied.  ...
</p>


<h3>Warning </h3>

<p>The function can be very slow if applied to a large
trackdata object. In this case, it may be faster to use a for-loop with the
desired function around $data
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+apply">apply</a></code> <code><a href="#topic+by.trackdata">by.trackdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# mean value per spectrum, input is a spectral matrix
m &lt;- fapply(vowlax.dft.5, sapply, FUN=mean)
# as above but after converting dB to powers before
# applying the function
m &lt;- fapply(vowlax.dft.5, sapply, FUN=mean, power=TRUE)
# spectral range
r &lt;- fapply(vowlax.dft.5, range)
# spectral moments applied to a trackdata object
# m is a four-dimensional trackdata object
m &lt;- fapply(fric.dft, moments)
# 1st 3 DCT coefficients calculated in a spectral matrix
# d is a 3-columned matrix
d &lt;- fapply(vowlax.dft.5, dct, 3)
# dct-smooth with 10 coefficients. d2 is spectral matrix
d2 &lt;- fapply(vowlax.dft.5, dct, 10, TRUE)
# dct-smooth a trackdata object with 10 coefficients
d3 &lt;- fapply(fric.dft[1:4,], dct, 10, TRUE)


</code></pre>

<hr>
<h2 id='frames'>frames</h2><span id='topic+frames'></span>

<h3>Description</h3>

<p>Get frames from trackdata objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frames(trackdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frames_+3A_trackdata">trackdata</code></td>
<td>
<p>an object of class trackdata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frames from the input object.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trackdata">trackdata</a></code>
</p>

<hr>
<h2 id='frames.time'>Find the time and position of a data element.</h2><span id='topic+frames.time'></span>

<h3>Description</h3>

<p>Finds the time and position of a data element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frames.time(dataset, datanum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frames.time_+3A_dataset">dataset</code></td>
<td>
<p>A dataset returned by <code>track</code> or <code>frames</code>.</p>
</td></tr>
<tr><td><code id="frames.time_+3A_datanum">datanum</code></td>
<td>
<p>An integer, an index into the <code>data</code> component of
<code>dataset</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dataset returned from <code>track</code> or <code>frames</code> consists of a
matrix of data (the <code>data</code> component) and two index components
(<code>index</code> and <code>ftime</code>). The data for all segments is concatenated
together in <code>$data</code>.  This function can be used to find out which
segment a particular row of <code>$data</code> corresponds to.
</p>


<h3>Value</h3>

<p>The segment number which contains the element <code>datanum</code> of
<code>dataset$data</code>.
</p>


<h3>See Also</h3>

<p>track, frames
</p>

<hr>
<h2 id='freqtoint'>Function to find the column number corresponding to frequencies of a
spectral object</h2><span id='topic+freqtoint'></span>

<h3>Description</h3>

<p>Find the column number corresponding to frequencies of a spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqtoint(trackdata, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqtoint_+3A_trackdata">trackdata</code></td>
<td>
<p>A spectral object</p>
</td></tr>
<tr><td><code id="freqtoint_+3A_j">j</code></td>
<td>
<p>A vector of frequencies</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in conjunction with object oriented programming of
EMU spectral objects. It should not in general be called from inside a
function. Its principal use is to determine the column number(s)
corresponding to frequencies for spectral trackdata objects or spectral
matrices or the element number for spectral vectors.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
freqtoint(fric.dft,1000:2000)
# all frequencies except 1000-2000
freqtoint(vowlax.dft.5, -(1000:2000))
# all frequencies except 1000 Hz
freqtoint(e.dft, -1000)
# the d.c. offset - i.e. column 1
freqtoint(vowlax.dft.5, 0)
# all freqs except the d.c. offset - i.e. not column 1
freqtoint(vowlax.dft.5, -1)




</code></pre>

<hr>
<h2 id='fric'>Segment list of word-medial s or z one male speaker of Standard North
German, read speech from database kielread.</h2><span id='topic+fric'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>segmentlist
</p>

<hr>
<h2 id='fric.dft'>Spectral trackdata object from the segment list fric.</h2><span id='topic+fric.dft'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>trackdata object
</p>

<hr>
<h2 id='fric.l'>Vector of labels from the segment list fric</h2><span id='topic+fric.l'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of labels
</p>

<hr>
<h2 id='fric.w'>Vector of word labels from the segment list fric.</h2><span id='topic+fric.w'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of word labels
</p>

<hr>
<h2 id='gerst.sub'>gerst sub</h2><span id='topic+gerst.sub'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gerst.sub(data)
</code></pre>

<hr>
<h2 id='get_trackdata'>Get trackdata from loaded emuDB</h2><span id='topic+get_trackdata'></span><span id='topic+emu.track'></span>

<h3>Description</h3>

<p>Extract trackdata information from a loaded emuDB that 
corresponds to the entries in a segment list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trackdata(
  emuDBhandle,
  seglist = NULL,
  ssffTrackName = NULL,
  cut = NULL,
  npoints = NULL,
  onTheFlyFunctionName = NULL,
  onTheFlyParams = NULL,
  onTheFlyOptLogFilePath = NULL,
  onTheFlyFunction = NULL,
  resultType = "tibble",
  consistentOutputType = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_trackdata_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="get_trackdata_+3A_seglist">seglist</code></td>
<td>
<p><code>tibble</code>, <code><a href="#topic+emuRsegs">emuRsegs</a></code> or <code><a href="#topic+emusegs">emusegs</a></code> 
object obtained by <code><a href="#topic+query">query</a></code>ing a loaded emuDB</p>
</td></tr>
<tr><td><code id="get_trackdata_+3A_ssfftrackname">ssffTrackName</code></td>
<td>
<p>The name of track that one wishes to extract (see 
<code><a href="#topic+list_ssffTrackDefinitions">list_ssffTrackDefinitions</a></code> for the defined ssffTracks of the 
emuDB). If the parameter <code>onTheFlyFunctionName</code> is set, then 
this corresponds to the column name af the AsspDataObj (see
<code>wrassp::wrasspOutputInfos[[onTheFlyFunctionName]]$tracks</code> and 
<code><a href="wrassp.html#topic+wrasspOutputInfos">wrasspOutputInfos</a></code> - NOTE: <code>library(wrassp)</code> might be 
necessary to access the <code>wrasspOutputInfos</code> object without the <code>wrassp::</code> prefix). 
If the parameter <code>onTheFlyFunctionName</code> is set and this one isn't, then per default
the first track listed in the <code>wrassp::wrasspOutputInfos</code> is chosen 
(<code>wrassp::wrasspOutputInfos[[onTheFlyFunctionName]]$tracks[1]</code>).
</p>
<p><code>get_trackdata</code> has so called constant track names that are always available 
for every emuDB. The constant track names are:
</p>

<ul>
<li><p>&quot;MEDIAFILE_SAMPLES&quot;: refers to the audio sample values specified 
by the &quot;mediafileExtension&quot; entry of the DBconfig.json
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_trackdata_+3A_cut">cut</code></td>
<td>
<p>An optional cut time for segment data, ranges between 
0 and 1, a value of 0.5 will extract data only at the segment midpoint.</p>
</td></tr>
<tr><td><code id="get_trackdata_+3A_npoints">npoints</code></td>
<td>
<p>An optional number of points to retrieve for each segment or event. 
For segments this requires the <code>cut</code> parameter to be set; if this is the 
case, then data is extracted around the resulting cut time. 
For events data is extracted around the event time. If npoints is an odd number, the 
samples are centered around the cut-time-sample; if not, they are skewed to the
right by one sample.</p>
</td></tr>
<tr><td><code id="get_trackdata_+3A_ontheflyfunctionname">onTheFlyFunctionName</code></td>
<td>
<p>Name of wrassp function that will perform the on-the-fly 
calculation (see <code>?wrassp</code> for a list of all the signal processing functions wrassp provides)</p>
</td></tr>
<tr><td><code id="get_trackdata_+3A_ontheflyparams">onTheFlyParams</code></td>
<td>
<p>A <code>pairlist</code> of parameters that will be given to the function 
passed in by the <code>onTheFlyFunctionName</code> parameter. This list can easily be 
generated by applying the <code>formals</code> function to the on-the-fly function name and then setting the according 
parameter one wishes to change.</p>
</td></tr>
<tr><td><code id="get_trackdata_+3A_ontheflyoptlogfilepath">onTheFlyOptLogFilePath</code></td>
<td>
<p>Path to optional log file for on-the-fly function</p>
</td></tr>
<tr><td><code id="get_trackdata_+3A_ontheflyfunction">onTheFlyFunction</code></td>
<td>
<p>pass in a function pointer. This function will be called with the path to the
current media file. It is required that the function returns a tibble/data.frame like object that contains
a column called <code>frame_time</code> that specifies the time point of each row. <code>get_trackdata</code> will then
extract the rows belonging to the current segment. This allows users to code their own function to be used with
<code>get_trackdata</code> and allows for most data formats to be used within an emuDB.</p>
</td></tr>
<tr><td><code id="get_trackdata_+3A_resulttype">resultType</code></td>
<td>
<p>Specify class of returned object. Either <code>"emuRtrackdata"</code>, 
<code>"trackdata"</code> or <code>"tibble"</code> == the default  (see <code><a href="#topic+trackdata">trackdata</a></code>, <code><a href="#topic+emuRtrackdata">emuRtrackdata</a></code> 
and <code><a href="dplyr.html#topic+tibble">tibble</a></code> for details about these objects).</p>
</td></tr>
<tr><td><code id="get_trackdata_+3A_consistentoutputtype">consistentOutputType</code></td>
<td>
<p>Prevent converting the output object to a <code>data.frame</code> 
depending on the <code>npoint</code> and <code>cut</code> arguments (only applies to output 
type &quot;trackdata&quot;). Set to <code>FALSE</code> if the following legacy <code>emu.track</code> output 
conversion behaviour is desired: If the <code>cut</code> parameter is not set (the default) an 
object of type <code><a href="#topic+trackdata">trackdata</a></code> is returned. If <code>cut</code> is set and <code>npoints</code> 
is not, or the seglist is of type event and npoints is not set, a <code><a href="base.html#topic+data.frame">data.frame</a></code> is 
returned (see the <code>consistentOutputType</code> to change this behaviour).</p>
</td></tr>
<tr><td><code id="get_trackdata_+3A_verbose">verbose</code></td>
<td>
<p>Show progress bars and further information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function utilizes the wrassp package for signal processing and 
SSFF/audio file handling. It reads time relevant data from a given 
segment list (<code><a href="#topic+emuRsegs">emuRsegs</a></code> or <code><a href="#topic+emusegs">emusegs</a></code>), extracts the 
specified trackdata and places it into a 
trackdata object (analogous to the deprecated <code>emu.track</code>). This function
replaces the deprecated <code>emu.track</code> function. Note that an warning is issued
if the bundles in the <code><a href="#topic+emuRsegs">emuRsegs</a></code> or <code><a href="#topic+emusegs">emusegs</a></code> object 
have in-homogeneous sampling rates as this could lead to inconsistent/erroneous
<code><a href="#topic+trackdata">trackdata</a></code>, <code><a href="#topic+emuRtrackdata">emuRtrackdata</a></code> or <code><a href="dplyr.html#topic+tibble">tibble</a></code> result objects. For 
more information on the structural elements of an emuDB 
see the signal data extraction chapter of the EMU-SDMS manual 
(<a href="https://ips-lmu.github.io/The-EMU-SDMS-Manual/chap-sigDataExtr.html">https://ips-lmu.github.io/The-EMU-SDMS-Manual/chap-sigDataExtr.html</a>).
</p>


<h3>Value</h3>

<p>object of type specified with <code>resultType</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+formals">formals</a></code>, <code><a href="wrassp.html#topic+wrasspOutputInfos">wrasspOutputInfos</a></code>, 
<code><a href="#topic+trackdata">trackdata</a></code>, <code><a href="#topic+emuRtrackdata">emuRtrackdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

# query loaded "ae" emuDB for all "i:" segments of the "Phonetic" level
sl = query(emuDBhandle = ae, 
           query = "Phonetic == i:")

# get the corresponding formant trackdata
td = get_trackdata(emuDBhandle = ae, 
                   seglist = sl, 
                   ssffTrackName = "fm")

# get the corresponding F0 trackdata
# as there is no F0 ssffTrack defined in the "ae" emuDB we will 
# calculate the necessary values on-the-fly
td = get_trackdata(emuDBhandle = ae, 
                   seglist = sl, 
                   onTheFlyFunctionName = "ksvF0")
                   

## End(Not run)

</code></pre>

<hr>
<h2 id='get.time.element'>Get data for a given time</h2><span id='topic+get.time.element'></span>

<h3>Description</h3>

<p>Gets data for a given time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.time.element(timeval, dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.time.element_+3A_timeval">timeval</code></td>
<td>
<p>A time in milliseconds</p>
</td></tr>
<tr><td><code id="get.time.element_+3A_dataset">dataset</code></td>
<td>
<p>A trackdata object as returned by <code>track</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The element number of <code>trackdata$data</code> corresponding to
<code>time</code>
</p>


<h3>See Also</h3>

<p>track, frames
</p>

<hr>
<h2 id='get.trackkeywrd'>get trackkeywrd</h2><span id='topic+get.trackkeywrd'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.trackkeywrd(fname)
</code></pre>

<hr>
<h2 id='import_mediaFiles'>Import media files to emuDB</h2><span id='topic+import_mediaFiles'></span>

<h3>Description</h3>

<p>Import new recordings (media files) to emuDB and create bundles.
Looks for files with the defined mediafile extension of the emuDB 
(see <code>mediaFileExtension</code> in vignette <code>emuDB</code>) in <code>dir</code>
or in sub-directories thereof (interpreted as sessions), for each mediafile
create a bundle directory
named as the basename of the mediafile in the specified session, and copies 
the mediafile into the bundle. If not already present, adds 'OSCI' and 
'SPEC' perspectives to the emuDB config file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_mediaFiles(emuDBhandle, dir, targetSessionName = "0000", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_mediaFiles_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="import_mediaFiles_+3A_dir">dir</code></td>
<td>
<p>directory containing mediafiles or session directories</p>
</td></tr>
<tr><td><code id="import_mediaFiles_+3A_targetsessionname">targetSessionName</code></td>
<td>
<p>name of session in which to create the new bundles</p>
</td></tr>
<tr><td><code id="import_mediaFiles_+3A_verbose">verbose</code></td>
<td>
<p>display infos &amp; show progress bar</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Add mediafiles from directory

 import_mediaFiles(myEmuDB,dir="/data/mymedia/")


## End(Not run)
</code></pre>

<hr>
<h2 id='is.seglist'>is seglist</h2><span id='topic+is.seglist'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.seglist(object)
</code></pre>

<hr>
<h2 id='is.spectral'>Function to test whether the object is of class &quot;spectral&quot;</h2><span id='topic+is.spectral'></span>

<h3>Description</h3>

<p>Returns TRUE or FALSE depending on whether the object is of class &quot;spectral&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.spectral(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.spectral_+3A_dat">dat</code></td>
<td>
<p>An R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single element logical vector: TRUE or FALSE
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.spectral">as.spectral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

is.spectral(vowlax.dft.5)
is.spectral(fric.dft)
is.spectral(fric.dft$data)
is.spectral(vowlax.dft.5[1,])
is.spectral(fric.dft[1,1])



</code></pre>

<hr>
<h2 id='is.trackdata'>Test whether an object is an Emu trackdata object</h2><span id='topic+is.trackdata'></span>

<h3>Description</h3>

<p>Test whether an object is an Emu trackdata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.trackdata(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.trackdata_+3A_object">object</code></td>
<td>
<p>A data object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if the argument is a trackdata object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_trackdata">get_trackdata</a></code>
</p>

<hr>
<h2 id='isol'>Segment list of vowels in a d d context isolated word speech, one male
speaker of Australian English from database isolated.</h2><span id='topic+isol'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>segmentlist
</p>

<hr>
<h2 id='isol.fdat'>Trackdata of formants from the segment list isol</h2><span id='topic+isol.fdat'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>trackdata object
</p>

<hr>
<h2 id='isol.l'>Vector of vowel phoneme labels from the segment list isol</h2><span id='topic+isol.l'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of vowel phoneme labels
</p>

<hr>
<h2 id='label'>Get labels / utterances from segment list</h2><span id='topic+label'></span><span id='topic+label.emusegs'></span><span id='topic+utt.emusegs'></span><span id='topic+utt'></span>

<h3>Description</h3>

<p>label: extracts the labels from the segment list.  utt: extracts the
utterances from the segment list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label(segs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label_+3A_segs">segs</code></td>
<td>
<p>segment list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>label / utterance vector
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+segmentlist">segmentlist</a> <a href="stats.html#topic+start">start</a> <a href="stats.html#topic+end">end</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   data(dip)
   #dip is a segment list - first ten segments only
   dip[1:10,]
   

   #extract labels from the segment list
   dips.labs = label(dip)
   dips.labs 
   

</code></pre>

<hr>
<h2 id='label_convert'>convert label</h2><span id='topic+label_convert'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_convert(segs.or.labels, match, replace)
</code></pre>

<hr>
<h2 id='label_num'>num label</h2><span id='topic+label_num'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_num(labs)
</code></pre>


<h3>Details</h3>

<p>depricated function of the legacy EMU system
still available for backward compatibility
</p>

<hr>
<h2 id='linear'>Perform linear time normalisation on trackdata.</h2><span id='topic+linear'></span>

<h3>Description</h3>

<p>Performs linear time normalisation on trackdata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear(dataset, n = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_+3A_dataset">dataset</code></td>
<td>
<p>A trackdata object as returned by <code>track</code>.</p>
</td></tr>
<tr><td><code id="linear_+3A_n">n</code></td>
<td>
<p>The number of points (samples) required for each segment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data for each segment is normalised using the <code>approx</code> function.
</p>


<h3>Value</h3>

<p>A new trackdata object where the data for each segment has the same
number (<code>n</code>) of samples.
</p>


<h3>See Also</h3>

<p>approx
</p>

<hr>
<h2 id='linear.av'>linear av</h2><span id='topic+linear.av'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear.av(dataset, labs)
</code></pre>

<hr>
<h2 id='list_bundles'>List bundles of emuDB</h2><span id='topic+list_bundles'></span>

<h3>Description</h3>

<p>List all bundles of emuDB or of particular session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_bundles(
  emuDBhandle,
  session = NULL,
  sessionPattern = ".*",
  bundlePattern = ".*"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_bundles_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="list_bundles_+3A_session">session</code></td>
<td>
<p>optional session (depricated!)</p>
</td></tr>
<tr><td><code id="list_bundles_+3A_sessionpattern">sessionPattern</code></td>
<td>
<p>A regular expression pattern matching session names to 
be searched for in the database. Note: &quot;_ses$&quot; is appended to this RegEx automatically</p>
</td></tr>
<tr><td><code id="list_bundles_+3A_bundlepattern">bundlePattern</code></td>
<td>
<p>A regular expression pattern matching bundle names to 
be searched for in the database. Note: &quot;_bndl$&quot; is appended to this RegEx automatically</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame object with columns session and name of bundles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB
# (see ?load_emuDB for more information)

# list bundles of session "0000" of ae emuDB
list_bundles(emuDBhandle = ae,
             session = "0000")


## End(Not run)

</code></pre>

<hr>
<h2 id='list_files'>List files of emuDB</h2><span id='topic+list_files'></span>

<h3>Description</h3>

<p>List files belonging to emuDB. For 
more information on the structural elements of an emuDB 
see <code>vignette{emuDB}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_files(
  emuDBhandle,
  fileExtension = ".*",
  sessionPattern = ".*",
  bundlePattern = ".*"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_files_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="list_files_+3A_fileextension">fileExtension</code></td>
<td>
<p>file extension of files</p>
</td></tr>
<tr><td><code id="list_files_+3A_sessionpattern">sessionPattern</code></td>
<td>
<p>A (RegEx) pattern matching sessions to be searched from the database</p>
</td></tr>
<tr><td><code id="list_files_+3A_bundlepattern">bundlePattern</code></td>
<td>
<p>A (RegEx) pattern matching bundles to be searched from the database</p>
</td></tr>
</table>


<h3>Value</h3>

<p>file paths as character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB
# (see ?load_emuDB for more information)

# list all files of ae emuDB
list_files(emuDBhandle = ae)

# list all files of ae emuDB in bundles ending with '3'
list_files(emuDBhandle = ae, bundlePattern=".*3$") 


## End(Not run)

</code></pre>

<hr>
<h2 id='list_sampleRates'>List sample rates of media and annotation (_annot.json) files</h2><span id='topic+list_sampleRates'></span>

<h3>Description</h3>

<p>List sample rates of media and annotation (_annot.json) files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_sampleRates(emuDBhandle, sessionPattern = ".*", bundlePattern = ".*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_sampleRates_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle object (see <a href="#topic+load_emuDB">load_emuDB</a>)</p>
</td></tr>
<tr><td><code id="list_sampleRates_+3A_sessionpattern">sessionPattern</code></td>
<td>
<p>A regular expression pattern matching session names to be searched from the database</p>
</td></tr>
<tr><td><code id="list_sampleRates_+3A_bundlepattern">bundlePattern</code></td>
<td>
<p>A regular expression pattern matching bundle names to be searched from the database</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with the columns 
</p>

<ul>
<li><p> session
</p>
</li>
<li><p> bundle
</p>
</li>
<li><p> sample_rate_annot_json
</p>
</li>
<li><p> sample_rate_media_file
</p>
</li></ul>

<p><code>session</code>, <code>b</code>
</p>

<hr>
<h2 id='list_sessions'>List sessions of emuDB</h2><span id='topic+list_sessions'></span>

<h3>Description</h3>

<p>List session names of emuDB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_sessions(emuDBhandle, sessionPattern = ".*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_sessions_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="list_sessions_+3A_sessionpattern">sessionPattern</code></td>
<td>
<p>A regular expression pattern matching session names to 
be searched for in the database. Note: &quot;_ses$&quot; is appended to this RegEx automatically</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame object with session names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB
# (see ?load_emuDB for more information)

# list all sessions of ae emuDB
list_sessions(emuDBhandle = ae)


## End(Not run)

</code></pre>

<hr>
<h2 id='load_emuDB'>Load emuDB</h2><span id='topic+load_emuDB'></span>

<h3>Description</h3>

<p>Function loads emuDB into its cached representation and makes it accessible from within the 
current R session by returning a emuDBhandle object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_emuDB(
  databaseDir,
  inMemoryCache = FALSE,
  connection = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_emuDB_+3A_databasedir">databaseDir</code></td>
<td>
<p>directory of the emuDB</p>
</td></tr>
<tr><td><code id="load_emuDB_+3A_inmemorycache">inMemoryCache</code></td>
<td>
<p>cache the loaded DB in memory</p>
</td></tr>
<tr><td><code id="load_emuDB_+3A_connection">connection</code></td>
<td>
<p>pass in DBI connection to SQL database if you want to override the default which is to 
use an SQLite database either in memory (<code>inMemoryCache = TRUE</code>) or in the emuDB folder. This is intended
for expert use only!</p>
</td></tr>
<tr><td><code id="load_emuDB_+3A_verbose">verbose</code></td>
<td>
<p>be verbose</p>
</td></tr>
<tr><td><code id="load_emuDB_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to access an emuDB from R it is necessary to load the annotation and configuration 
files to an emuR internal database format. The function expects a emuDB file structure in directory 
<code>databaseDir</code>. The emuDB configuration file is loaded first. On success the function iterates 
through session and bundle directories and loads found annotation files. The parameter <code>inMemoryCache</code> 
determines where the internal database is stored: If <code>FALSE</code> a database cache file in <code>databaseDir</code> 
is used. When the database is loaded for the first time the function will create a new cache file and store 
the data to it. On subsequent loading of the same database the cache is only updated if files have changed, 
therefore the loading is then much faster. For this to work the user needs write permissions to 
<code>databaseDir</code> and the cache file. The database is loaded into a volatile in-memory database if 
<code>inMemoryCache</code> is set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>emuDB handle object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load database ae in directory /homes/mylogin/EMUnew/ae 
## assuming an existing emuDB structure in this directory

ae = load_emuDB("/homes/mylogin/EMU/ae")

## Load database ae from demo data

# create demo data in temporary directory
create_emuRdemoData(dir = tempdir())
# build base path to demo emuDB
demoDatabaseDir = file.path(tempdir(), "emuR_demoData", "ae_emuDB")

# load demo emuDB
ae = load_emuDB(demoDatabaseDir)


## End(Not run)
</code></pre>

<hr>
<h2 id='lob.sub'>lob sub</h2><span id='topic+lob.sub'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lob.sub(data)
</code></pre>

<hr>
<h2 id='locus'>Calculate locus equations for two-dimensional data</h2><span id='topic+locus'></span>

<h3>Description</h3>

<p>The function plots a locus equation and returns associated statistical
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locus(
  target,
  onset,
  labels.vow = NULL,
  yxline = TRUE,
  plotgraph = TRUE,
  axes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locus_+3A_target">target</code></td>
<td>
<p>a numerical vector typically of F2 values at the vowel target</p>
</td></tr>
<tr><td><code id="locus_+3A_onset">onset</code></td>
<td>
<p>a numerical vector typically of the same length as target of
F2 values at the vowel onset</p>
</td></tr>
<tr><td><code id="locus_+3A_labels.vow">labels.vow</code></td>
<td>
<p>an optionally character vector for plotting labels at the
points (target, onset) of the same length as target</p>
</td></tr>
<tr><td><code id="locus_+3A_yxline">yxline</code></td>
<td>
<p>optionally plot the line target = onset.  Defaults to True.</p>
</td></tr>
<tr><td><code id="locus_+3A_plotgraph">plotgraph</code></td>
<td>
<p>a logical vector for specifying whether the data should be
plotted. Defaults to True.</p>
</td></tr>
<tr><td><code id="locus_+3A_axes">axes</code></td>
<td>
<p>A logical vector indicating whether the axes should be plotted</p>
</td></tr>
<tr><td><code id="locus_+3A_...">...</code></td>
<td>
<p>graphical options <a href="graphics.html#topic+par">par</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A locus equation is a straight line regression fitted with lm() in which
the F2- values typically at the vowel onset are regressed on those of the
target. The slope can be used to give an indication of target-on-onset
coarticulatory influences.
</p>
<p>The best estimate of the locus frequency is where the locus equation
bisects the line target = onset.
</p>


<h3>Value</h3>

<p>A list containing regression diagnostics of the function lm() that
can be accessed with summary() and the estimated locus frequency in
$locus. A plot of values in the onset x target plane with superimposed
locus equation and line onset=target.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # calculate an F2-locus equation for initial [d] 
# preceding lax vowels produced by female speaker "68".
# the onset is taken at the vowel onset; the
# vowel target is taken at the vowel's temporal midpoint.

# identify initial "d" of speaker "68"
temp &lt;- vowlax.left == "d" &amp; vowlax.spkr == "68"
# get the F2 value at the vowel's temporal midpoint
targ &lt;- dcut(vowlax.fdat[temp,2], .5, prop=TRUE)
# F2 value at the vowel's acoustic onset.
on &lt;- dcut(vowlax.fdat[temp,2], 0, prop=TRUE)

# locus equation plot
result &lt;- locus(targ, on, vowlax.l[temp])
# statistical diagnostics of the regression line (locus equation)
summary(result)
# intercept and slope
result$coeff
# best estimate of the locus frequency, i.e. the
# point of bisection of on = TRUEarg with the regression line
result$locus


</code></pre>

<hr>
<h2 id='mahal'>Classify using Mahalanobis distance</h2><span id='topic+mahal'></span>

<h3>Description</h3>

<p>Classifies using Mahalanobis distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahal(data, train)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahal_+3A_data">data</code></td>
<td>
<p>A vector or matrix of data</p>
</td></tr>
<tr><td><code id="mahal_+3A_train">train</code></td>
<td>
<p>A Gaussian model generated by <code>train</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>model</code> argument contains the mean and inverse covariance matrix
(or standard deviation if the data is one-dimensional) for each class in
the training set as well as the class labels.  This function calculates the
Mahalanobis distance of each row of <code>data</code> from each class mean and
assigns the label of the closest mean to that row.  The result is a vector
of labels corresponding to the rows of <code>data</code>.
</p>
<p>The Mahalanobis distance between a data point and a class is the Euclidean
distance between the point and the class mean divided by the covariance
matrix for the class.  This means that classes with large covariances will
attract data points from a larger area than those with small covariances.
</p>


<h3>Value</h3>

<p>A label vector with one element per row of <code>data</code>
</p>


<h3>References</h3>

<p>O'Shaughnessy, D. Speech Communication (Addison-Wesley:
Reading, MA. 1987)
</p>


<h3>See Also</h3>

<p>train
</p>

<hr>
<h2 id='mahal.dist'>Calculate mahalanobis distances</h2><span id='topic+mahal.dist'></span>

<h3>Description</h3>

<p>Calculates mahalanobis distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahal.dist(data, train, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahal.dist_+3A_data">data</code></td>
<td>
<p>A matrix of numerical data points.</p>
</td></tr>
<tr><td><code id="mahal.dist_+3A_train">train</code></td>
<td>
<p>A gaussian model as returned by the <code>train</code> function.</p>
</td></tr>
<tr><td><code id="mahal.dist_+3A_labels">labels</code></td>
<td>
<p>A vector of labels..</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>train</code> function finds the centroids and covariance matrices for a
set of data and corresponding labels: one per unique label.  This function
can be used to find the mahalanobis distance of every data point in a
dataset to each of the class centroids.  The columns of the resulting
matrix are marked with the label of the centroid to which they refer.  The
function <code>mahal</code> should be used if you want to find the closest
centroid to each data point.
</p>


<h3>Value</h3>

<p>A matrix of distances with one column for every class (label) in
the gaussian model.
</p>


<h3>See Also</h3>

<p>train, mahal, bayes.lab, bayes.dist
</p>

<hr>
<h2 id='mahalanobis.metric'>mahalanobis metric</h2><span id='topic+mahalanobis.metric'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahalanobis.metric(data, mean, invcov)
</code></pre>

<hr>
<h2 id='make.emuRsegs'>Make emuDB segment list</h2><span id='topic+make.emuRsegs'></span>

<h3>Description</h3>

<p>Make emuDB segment list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.emuRsegs(dbName, seglist, query, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.emuRsegs_+3A_dbname">dbName</code></td>
<td>
<p>name of emuDB</p>
</td></tr>
<tr><td><code id="make.emuRsegs_+3A_seglist">seglist</code></td>
<td>
<p>segment list data.frame</p>
</td></tr>
<tr><td><code id="make.emuRsegs_+3A_query">query</code></td>
<td>
<p>query string</p>
</td></tr>
<tr><td><code id="make.emuRsegs_+3A_type">type</code></td>
<td>
<p>type of list elements</p>
</td></tr>
</table>

<hr>
<h2 id='make.seglist'>Make an Emu segment list from the various components</h2><span id='topic+make.seglist'></span>

<h3>Description</h3>

<p>This is the appropriate way to make an Emu segment list and ensure that it
has all of the required components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.seglist(labels, start, end, utts, query, type, database)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.seglist_+3A_labels">labels</code></td>
<td>
<p>A character vector of labels for each segment</p>
</td></tr>
<tr><td><code id="make.seglist_+3A_start">start</code></td>
<td>
<p>A vector of start times</p>
</td></tr>
<tr><td><code id="make.seglist_+3A_end">end</code></td>
<td>
<p>A vector of end times</p>
</td></tr>
<tr><td><code id="make.seglist_+3A_utts">utts</code></td>
<td>
<p>A character vector of utterance names</p>
</td></tr>
<tr><td><code id="make.seglist_+3A_query">query</code></td>
<td>
<p>A query string</p>
</td></tr>
<tr><td><code id="make.seglist_+3A_type">type</code></td>
<td>
<p><code>segment</code> or <code>event</code></p>
</td></tr>
<tr><td><code id="make.seglist_+3A_database">database</code></td>
<td>
<p>The database name associated with the segment list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An Emu segment list is the result of a query to a speech database (see
<code><a href="#topic+query">query</a></code>) and has one row per matching segment or event from
the query. Each row lists the label, start and end times (in milliseconds)
and utterance name for the segment.  This information is used by
<code><a href="#topic+get_trackdata">get_trackdata</a></code> and other functions to extract data corresponding
to these segments.
</p>
<p>In order to ensure the proper format for segment lists and to ensure
against future changes to the format, <code>make.seglist</code> should be used
whenever you wish to create a segment list.  Another function,
<code><a href="#topic+modify.seglist">modify.seglist</a></code> can be used to change some part of an existing
segment list. The functions <code><a href="#topic+label.emusegs">label.emusegs</a></code>,
<code><a href="#topic+start.emusegs">start.emusegs</a></code>, <code><a href="#topic+end.emusegs">end.emusegs</a></code> and
<code><a href="#topic+utt.emusegs">utt.emusegs</a></code> can be used to access the different columns of
the segment list.
</p>


<h3>Value</h3>

<p>An Emu segment list.
</p>


<h3>Author(s)</h3>

<p>Steve Cassidy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modify.seglist">modify.seglist</a></code>, <code><a href="#topic+label.emusegs">label.emusegs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

   l &lt;- c("A", "B", "C")
   s &lt;- 1:3
   e &lt;- 2:4
   u &lt;- c("u1", "u1", "u1")
   segs &lt;- make.seglist(l, s, e, u, "Fake Query", "segment", "fake")
   segs
   ## summary gives an overview of the data in the segment list
   summary(segs)
   

   # The following should be TRUE
   label(segs) == l
   dur(segs) == s
   end(segs) == e
   utt(segs) == u
   emusegs.database(segs) == "fake"
   emusegs.type(segs) == "segment"
   emusegs.query(segs) == "Fake Query"

   # segment durations should all be 1
   dur(segs) == c(1,1,1)


</code></pre>

<hr>
<h2 id='makelab'>Write out ESPS-style label files</h2><span id='topic+makelab'></span>

<h3>Description</h3>

<p>Writes out separate ESPS-label files for each utterance to a specified
directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makelab(vectimes, uttname, dir, extn = "xlab", labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makelab_+3A_vectimes">vectimes</code></td>
<td>
<p>a vector of times</p>
</td></tr>
<tr><td><code id="makelab_+3A_uttname">uttname</code></td>
<td>
<p>a character vector of the same length as vectimes giving the
utterance name associated with each element of vectimes</p>
</td></tr>
<tr><td><code id="makelab_+3A_dir">dir</code></td>
<td>
<p>a character specifying the directory</p>
</td></tr>
<tr><td><code id="makelab_+3A_extn">extn</code></td>
<td>
<p>a character specifying the extension of the resulting files.
Defaults to xlab</p>
</td></tr>
<tr><td><code id="makelab_+3A_labels">labels</code></td>
<td>
<p>either a single character vector or a character vector the
same length as vectimes.  Defaults to &quot;T&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ESPS-style label files are written out to the directory of the
user's choice. One ESPS-label file is created for each utterance containing
all time values for that utterance.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   #first two segments (for the whole example) of segmentlist vowlax 
   vowlax[1:2,]

   #format track of vowlax
   vowlax.fdat[1:2,]

   #Formant values of the midpoint of the segment
   vowlax.fdat.5 = dcut(vowlax.fdat,0.5,prop=TRUE)

   #the time marks of the midpoint of the segment
   times = vowlax.fdat.5[1:2,1]
   times

   #utterance names to the segments
   utts = utt(vowlax[1:2,])
   utts 

   #the path to save the label files to "." is the RHOME Directory
   path = "."

   #write the label files to path
   ## Not run: makelab(times, utts, path, labels="T")

   #the first two segments are from the same utterance,
   #thus one label file was created in the R_HOME directory

</code></pre>

<hr>
<h2 id='matscan'>Read matrix data from a file</h2><span id='topic+matscan'></span>

<h3>Description</h3>

<p>Reads matrix data from a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matscan(file, num.cols = utils::count.fields(file)[1], what = 0, sk = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matscan_+3A_file">file</code></td>
<td>
<p>A filename.</p>
</td></tr>
<tr><td><code id="matscan_+3A_num.cols">num.cols</code></td>
<td>
<p>The number of columns of data in the file.</p>
</td></tr>
<tr><td><code id="matscan_+3A_what">what</code></td>
<td>
<p>A template for the data elements in the file, it should be a
number for numeric data (the default) or a string for string data. Note
that an Splus matrix can only hold one type of data (string or numeric),
for mixed types use data tables and the <code>read.table</code> function.</p>
</td></tr>
<tr><td><code id="matscan_+3A_sk">sk</code></td>
<td>
<p>The number of leading lines of the file to skip.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been partially superseded by the introduction of data
frames and the read.table function.  It is still useful however for reading
data into Splus matrix objects.
</p>


<h3>Value</h3>

<p>A matrix corresponding to the data in <code>file</code>.
</p>


<h3>See Also</h3>

<p>read.table
</p>

<hr>
<h2 id='mel'>Convert Hz to the mel scale</h2><span id='topic+mel'></span><span id='topic+mel.trackdata'></span><span id='topic+mel.spectral'></span>

<h3>Description</h3>

<p>The calculation is done using the formulae mel = 1/log(2) * (log(1 +
(Hz/1000))) * 1000 where Hz is the frequency in Hz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mel(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mel_+3A_a">a</code></td>
<td>
<p>A vector or matrix of data or a spectral object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'data' is a spectral object, then the frequencies are changed so that
they are proportional to the mel scale and such that the mel intervals
between frequencies are constant between the lowest and highest
frequencies. More specifically, suppose that a spectral object has
frequencies at 0, 1000, 2000, 3000, 4000 Hz. Then the corresponding
frequencies extend in mel between 0 and 2321.928 mel (=4000 Hz in mels) in
four equal intervals, and linear interpolation is used with the 'approx'
function to obtain the dB values at those frequencies.
</p>


<h3>Value</h3>

<p>A vector or matrix or spectral object of the same length and
dimensions as data.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>References</h3>

<p>Traunmueller, H. (1990) &quot;Analytical expressions for the
tonotopic sensory scale&quot; J. Acoust. Soc. Am. 88: 97-100.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bark">bark</a></code>, <code><a href="#topic+plot.spectral">plot.spectral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 #convert Hertz values to mel

 vec &lt;- c(500, 1500, 2500)
 vec
 mel(vec)

        
        # convert Hertz values to mel 

        mel(vec)
        

        # convert the $data values in a trackdata object to mel
        # create a new track data object

        t1 &lt;- dip.fdat
        t1[1]
        
        # convert Hertz to mel

        t1$data &lt;- mel(t1$data)
        t1[1]

# warp the frequency axis of a spectral object such
# that it is proportional to the mel scale.

w = mel(e.dft)
oldpar = par(mfrow=c(1,2))
plot(w, type="l")


# The values of w are at equal mel intervals. Compare
# with

plot(e.dft, freq=mel(trackfreq(e.dft)))

# the latter has a greater concentration of values
# in a higher frequency range.

par(oldpar)

</code></pre>

<hr>
<h2 id='mel.default'>mel default</h2><span id='topic+mel.default'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
mel(a)
</code></pre>

<hr>
<h2 id='modify.seglist'>Modify one of the components of an Emu segment list</h2><span id='topic+modify.seglist'></span>

<h3>Description</h3>

<p>This function can be used to modify one of the parts of an Emu segment list
while leaving the other parts unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify.seglist(
  segs,
  labels = label.emusegs(segs),
  start = start.emusegs(segs),
  end = end.emusegs(segs),
  utts = utt.emusegs(segs),
  query = emusegs.query(segs),
  type = emusegs.type(segs),
  database = emusegs.database(segs)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify.seglist_+3A_segs">segs</code></td>
<td>
<p>A segment list to modify, a modified copy is returned</p>
</td></tr>
<tr><td><code id="modify.seglist_+3A_labels">labels</code></td>
<td>
<p>A new label vector</p>
</td></tr>
<tr><td><code id="modify.seglist_+3A_start">start</code></td>
<td>
<p>A new start time vector</p>
</td></tr>
<tr><td><code id="modify.seglist_+3A_end">end</code></td>
<td>
<p>A new end time vector</p>
</td></tr>
<tr><td><code id="modify.seglist_+3A_utts">utts</code></td>
<td>
<p>A new vector of utterance labels</p>
</td></tr>
<tr><td><code id="modify.seglist_+3A_query">query</code></td>
<td>
<p>A new query string to associate with the segment list</p>
</td></tr>
<tr><td><code id="modify.seglist_+3A_type">type</code></td>
<td>
<p>A new type string</p>
</td></tr>
<tr><td><code id="modify.seglist_+3A_database">database</code></td>
<td>
<p>A new database name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An Emu segment list has a number of components and is stored as an R object
of class <code>emusegs</code>.  This function can be used to modify a segment
list while retaining all of the proper structures.
</p>
<p>Any new vectors passed to the function must have the same length as the
segment list itself for this call to succeed.
</p>
<p>All arguments are optional and default to not modifying the segment list if
not supplied.
</p>
<p>The original segment list is not modified, instead, a modified copy is
returned.
</p>


<h3>Value</h3>

<p>An Emu segment list.
</p>


<h3>Author(s)</h3>

<p>Steve Cassidy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+query">query</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vowlax)
segs = vowlax
# extend the start times by 10ms
newsegs &lt;- modify.seglist( segs, start=start(segs)+10 )

# change the associated database name
# this will affect where emu.track looks to find data
newsegs &lt;-  modify.seglist( segs, database="notdemo" )


</code></pre>

<hr>
<h2 id='moments'>Function to calculate statistical moments</h2><span id='topic+moments'></span>

<h3>Description</h3>

<p>The function calculates the first 4 moments, i.e. the mean, variance, skew,
kurtosis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moments(count, x, minval = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moments_+3A_count">count</code></td>
<td>
<p>A vector of the observed instances per class</p>
</td></tr>
<tr><td><code id="moments_+3A_x">x</code></td>
<td>
<p>A vector of the same length as count defining the class. If
missing, and if count is of class spectral, then x is equal to
trackfreq(count). If x is missing and is not of class spectral, then x
default to 0:(length(count)-1)</p>
</td></tr>
<tr><td><code id="moments_+3A_minval">minval</code></td>
<td>
<p>If TRUE, subtract min(count) from count so that the minimum
value of count is zero. This is principally used in calculating spectral
moments where count is in decibels, and more generally if count contains
negative values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The units of the first moment are the same as x, the units of the second
moment are x<code class="reqn">\mbox{\textasciicircum}</code>2, and the third and fourth
moments are dimensionless.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>References</h3>

<p>Snedecor, G &amp; Cochran, W. 'Statistical Methods' Iowa State
Press. Wuensch,K., 2005
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# first four moments of a vector
mom &lt;- moments(bridge[,2])
# the above is the same as moments(bridge[,2], 0:12)
# first four moments of a spectral vector with the dB values
# reset so that the minimum dB value is 0. The d.c. offset is also
# excluded in the calculation
mom &lt;- moments(e.dft[-1], minval=TRUE)
# the temporal skew of F1 for the 10th segment. Use
m &lt;- moments(vowlax.fdat[10,1]$data)[3]


</code></pre>

<hr>
<h2 id='mu.colour'>Function for specifying color, linetype, and line-widths in EMU plotting
functions.</h2><span id='topic+mu.colour'></span>

<h3>Description</h3>

<p>The function specifies color, linetype and linewidths in EMU plotting
functions as is used mostly in calls from within plot.trackdata,
plot.spectral, eplot, and dplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu.colour(labs, col = TRUE, linetype = FALSE, lwd = NULL, pch = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mu.colour_+3A_labs">labs</code></td>
<td>
<p>A vector of character labels</p>
</td></tr>
<tr><td><code id="mu.colour_+3A_col">col</code></td>
<td>
<p>A code passed to the 'col' argument in plotting functions. There
are four possibilities. Either logical, a character vector, or a numeric
vector.  In the first case, if TRUE, then a different numeric code is given
for each unique label type. For example, if labs is c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;),
then the output is c(1, 2, 1, 3). If FALSE, then for this example, the output
is c(1, 1, 1, 1). In the second case, the character vector can be either a
single element specifying a character, or there can be as many elements as
there are unique colors. Thus if col = &quot;red&quot;, then for the example c(&quot;a&quot;,
&quot;b&quot;, &quot;a&quot;, &quot;c&quot;), the output is c(&quot;red&quot;, &quot;red&quot;, &quot;red&quot;, &quot;red&quot;). Alternatively,
since there are three unique labels for this example, then the user could
specify col = c(&quot;green&quot;, &quot;red&quot;, &quot;blue&quot;) and the output is c(&quot;green&quot;, &quot;red&quot;,
&quot;green&quot;, &quot;blue&quot;) if labs is c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;).  In the third case,
'col'. can be either a single element numeric vector, or its length must be
equal to the number of unique types in labs.  For example, if col=3 and if
labs = c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;), then the output is c(3, 3, 3, 3).
Alternatively, if col = c(2,3,1), then the output is c(2, 3, 2, 1) for the
same example. Finally, col can be specified as a character or numeric
vector that is the same length as labs, allowing the user to choose the
color in which each line should be drawn.  The default is col = TRUE.</p>
</td></tr>
<tr><td><code id="mu.colour_+3A_linetype">linetype</code></td>
<td>
<p>A code specifying linetypes, i.e. the values passed to lty
in plotting functions.There are 2 possibilities.  Either logical, a
character vector, or a numeric vector.  In the first case, if TRUE, then a
different numeric code is given for each unique label type. For example, if
labs is c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;), then the output is c(1, 2, 1, 3). If FALSE, then
for this example, the output is c(1, 1, 1, 1).  In the second case,
'linetype' can be either a single element numeric vector, or its length
must be equal to the number of unique types in labs.  For example, if
linetype=3 and if labs = c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;), then the output is c(3, 3,
3, 3). Alternatively, if linetype = c(2,3,1), then the output is c(2, 3, 2,
1) for the same example. Finally, linetype can be specified as a numeric
vector that is the same length as labs, allowing the user to choose the
linetype in which each line should be drawn.  The default is linetype=FALSE</p>
</td></tr>
<tr><td><code id="mu.colour_+3A_lwd">lwd</code></td>
<td>
<p>A code passed to the lwd argument in plotting functions.  'lwd'
can be either a single element numeric vector, or its length must be equal
to the number of unique types in labs.  For example, if lwd=3 and if labs =
c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;), then the output is c(3, 3, 3, 3). Alternatively, if
lwd = c(2,3,1), then the output is c(2, 3, 2, 1) for the same example. The
default is NULL in which case all lines are drawn with lwd=1</p>
</td></tr>
<tr><td><code id="mu.colour_+3A_pch">pch</code></td>
<td>
<p>A code passed to the pch argument in plotting functions.
Functions in the same way as lwd above</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters are also supplied for use with the function 'legend'
</p>


<h3>Value</h3>

<p>If it is a LISTRUE, use </p>
<table>
<tr><td><code>colour</code></td>
<td>
<p>A code for the color'</p>
</td></tr>
<tr><td><code>linetype</code></td>
<td>
<p>A code for the linetype</p>
</td></tr> <tr><td><code>lwd</code></td>
<td>
<p>A code for the line
width</p>
</td></tr> <tr><td><code>legend</code></td>
<td>
<p>A list consisting of $legend$lab, $legend$lty and
$legend$lwd that specify the parameters for the 'legend' function.
</p>
<p>...  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steve Cassidy, modified by Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.trackdata">plot.trackdata</a></code> <code><a href="#topic+dplot">dplot</a></code>
<code><a href="#topic+eplot">eplot</a></code> <code><a href="#topic+plot.spectral">plot.spectral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# examples will be given using the above functions
# b/w but with different linetypes
eplot(vowlax.fdat.5[,1:2], vowlax.l, col=FALSE, lty=TRUE)

# user-defined colors
eplot(vowlax.fdat.5[,1:2], vowlax.l, col=c("green", "blue", "red", "orange"))

# spectral plot, user-defined colors, the last one is dotted
# and with a line-thickness of 2
plot(vowlax.dft.5[1:20,], vowlax.l[1:20], 
col=c("green", "blue", "red", "orange"), 
fun=mean, lty=c(1, 1, 1, 2), lwd=c(1, 1, 1, 2))

# similar but using dplot()
dplot(vowlax.fdat[1:20,2], vowlax.l, 
col=c("green", "blue", "red", "orange"), 
lwd=c(1, 1, 1, 2), lty=c(1, 1, 1, 2))

# the default except plot everything with a dotted line and plotting symbol 4
dplot(vowlax.fdat[,2], vowlax.l, average=TRUE, lty=2, pch=4, type="b", xlim=c(40, 60))

# the default except plot everything with a dotted line and
# with double line thickness
eplot(vowlax.fdat.5[,1:2], vowlax.l, lty=2, lwd=2)

</code></pre>

<hr>
<h2 id='mu.colour.get'>get a EMU color</h2><span id='topic+mu.colour.get'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu.colour.get(col.lty, label)
</code></pre>

<hr>
<h2 id='mu.legend'>make a EMU legend</h2><span id='topic+mu.legend'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu.legend(legn, xlim, ylim)
</code></pre>

<hr>
<h2 id='mu.linetype.get'>mu linetype get</h2><span id='topic+mu.linetype.get'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu.linetype.get(col.lty, label)
</code></pre>

<hr>
<h2 id='muclass'>Find common elements in vectors</h2><span id='topic+muclass'></span>

<h3>Description</h3>

<p>Finds common elements in vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muclass(labels, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muclass_+3A_labels">labels</code></td>
<td>
<p>A vector of labels.</p>
</td></tr>
<tr><td><code id="muclass_+3A_class">class</code></td>
<td>
<p>A label or vector of labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector which is TRUE for each element in <code>labels</code> which
matches <code>class</code> or an element of <code>class</code>.
</p>


<h3>See Also</h3>

<p>match
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
muclass(c("a", "b", "c"), c("a", "c"))
#[1] TRUE FALSE TRUE

</code></pre>

<hr>
<h2 id='nearey.sub'>nearey sub</h2><span id='topic+nearey.sub'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearey.sub(data)
</code></pre>

<hr>
<h2 id='norm'>Normalise speech data</h2><span id='topic+norm'></span>

<h3>Description</h3>

<p>Normalises speech data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm(data, speakerlabs, type = "gerst", rescale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_+3A_data">data</code></td>
<td>
<p>A matrix of data. Can be either an n-columned matrix or a
trackdata object as returned by <code>track</code>.</p>
</td></tr>
<tr><td><code id="norm_+3A_speakerlabs">speakerlabs</code></td>
<td>
<p>A parallel vector of speaker labels.</p>
</td></tr>
<tr><td><code id="norm_+3A_type">type</code></td>
<td>
<p>The type of extrinsic normalisation to be performed on data.
type can be <code>"nearey"</code>, <code>"cen"</code>, <code>"lob"</code>, <code>"gerst"</code>
(default), for normalisation according to Nearey, centroid method, Lobanov,
or Gerstman.</p>
</td></tr>
<tr><td><code id="norm_+3A_rescale">rescale</code></td>
<td>
<p>Currently only works for Lobanov normalisation. The
normalised values are multiplied by the standard deviation and then the
mean is added, where the standard deviation and mean are across all
original speakers' unnormalised data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Types of normalisation: <code>"nearey"</code>, Nearey : Find the log of each data
element and subtract from each the mean of the logarithmic data.
<code>"cen"</code>, centroid: Find the mean of the data column and subtract it
from each data element in that column.  <code>"lob"</code>, Lobanov: Find the
mean and standard deviation of the data. Subtract the mean from each data
element and divide each result by the standard deviation.  &quot;gerst&quot;,
Gerstman: Subtract from the data the minimum formant value then divide by
the formant range.
</p>


<h3>Value</h3>

<p>Normalised values of data are returned, having the same structure as
data.
</p>


<h3>See Also</h3>

<p>track
</p>

<hr>
<h2 id='normalize_length'>Normalize length of segments contained in a <code>data.frame</code> like object returned by <code><a href="#topic+get_trackdata">get_trackdata</a></code></h2><span id='topic+normalize_length'></span>

<h3>Description</h3>

<p>Normalize length of segments contained in a <code>data.frame</code> like object returned by <code><a href="#topic+get_trackdata">get_trackdata</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_length(x, colNames = NULL, N = 21)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_length_+3A_x">x</code></td>
<td>
<p>data.frame like object that was generated by <code><a href="#topic+get_trackdata">get_trackdata</a></code> with 
the resultType set to either <code>emuRtrackdata</code> or <code>tibble</code></p>
</td></tr>
<tr><td><code id="normalize_length_+3A_colnames">colNames</code></td>
<td>
<p>character vector containing names of columns to normalize. If not set all 
data columns are normalized (T1-TN as well as other numeric columns).</p>
</td></tr>
<tr><td><code id="normalize_length_+3A_n">N</code></td>
<td>
<p>specify length of normalized segments (each segment in resulting
object will consist of <code>N</code> rows).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame like object containing the length normalized segments
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emuRtrackdata">emuRtrackdata</a> <a href="#topic+emuRsegs">emuRsegs</a></code>
</p>

<hr>
<h2 id='outliers'>outliers</h2><span id='topic+outliers'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outliers(data, labels, threshold)
</code></pre>

<hr>
<h2 id='palate'>Obtain a three-dimensional palatographic array</h2><span id='topic+palate'></span>

<h3>Description</h3>

<p>Function to calculate a three-dimensional palatographic array from.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palate(epgdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palate_+3A_epgdata">epgdata</code></td>
<td>
<p>An eight-columned EPG-compressed trackdata object or an
eight columned matrix of EPG-compressed trackdata.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An EPG compressed trackdata object that is output from the Reading system
contains eight columns of data and each row value when converted to binary
numbers (after adding 1) gives the corresponding EPG contact patterns. This
function does the conversion to binary values.
</p>


<h3>Value</h3>

<p>An array of three dimensions of 8 rows x 8 columns x n segments
where n is the number of segments in the trackdata object or matrix. The
rows and columns are given dimension names, the dimension names of the
third dimension contains the times at which the palatograms occur.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epgcog">epgcog</a></code> <code><a href="#topic+epggs">epggs</a></code> <code><a href="#topic+epgai">epgai</a></code>
<code><a href="#topic+epgplot">epgplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# convert an EPG-compressed trackdata object to palatograms
p &lt;- palate(coutts.epg)

# convert an EPG-compressed matrix to palatograms
p &lt;- palate(dcut(coutts.epg, 0, prop=TRUE))


</code></pre>

<hr>
<h2 id='perform'>Performance (hit rate) of a confusion matrix</h2><span id='topic+perform'></span>

<h3>Description</h3>

<p>Performs (hit rate) of a confusion matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perform(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perform_+3A_data">data</code></td>
<td>
<p>A confusion matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calculates the accuracy (total score) of the confusion matrix,
returning percentage of correct, and incorrect matches.
</p>


<h3>See Also</h3>

<p>confusion
</p>

<hr>
<h2 id='plafit'>Calculate the coefficients of a parabola</h2><span id='topic+plafit'></span>

<h3>Description</h3>

<p>Fit a second ordered polynomial to a vector of values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plafit(wav, fit = FALSE, n = 101)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plafit_+3A_wav">wav</code></td>
<td>
<p>a vector or single column matrix of numeric values to which the
2nd order polynomial is to be fitted.</p>
</td></tr>
<tr><td><code id="plafit_+3A_fit">fit</code></td>
<td>
<p>if FALSE, return the coefficients of the polynomial; if TRUE, the
values of the polynomial are returned to the same length as the vector wav.</p>
</td></tr>
<tr><td><code id="plafit_+3A_n">n</code></td>
<td>
<p>in fitting the polynomial, linear time normalisation is first
applied to the input vector wav to 101 points. The polynomial is fitted
under the assumption that these points extend linearly in time between t =
-1 and t = 1 with t = 0 occurring at the temporal midpoint.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits a parabola (2nd order polynomial) following the method of
van Bergem, Speech Communication, 14, 1994, 143-162. The algorithm fixes
the parabola at the onset, midpoint, and offset of the vector i.e. such
htat the fitted parabola and original vector have the same values at these
points.
</p>


<h3>Value</h3>

<p>The function returns the coefficients of c0, c1, c2 in the parabola
y = c0 + c1t + c2t<code class="reqn">\mbox{\textasciicircum}</code>2 where t extends between
-1 and 1. The function can also be used to derive the values of the
parabola as a function of time from the coefficients.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dct">dct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fit a polynomial to a segment of fundamental frequency data
plafit(vowlax.fund[1,]$data)

# return the fitted values of the polynomial
plafit(vowlax.fund[1,]$data, fit=TRUE)


</code></pre>

<hr>
<h2 id='plot.spectral'>Plot spectra from EMU spectral objects</h2><span id='topic+plot.spectral'></span>

<h3>Description</h3>

<p>The function plots spectrum of any EMU spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectral'
plot(
  x,
  labs,
  ylim,
  xlim,
  col,
  lty,
  lwd,
  fun,
  freq,
  type = "l",
  power = FALSE,
  powcoeffs = c(10, 10),
  dbnorm = FALSE,
  dbcoeffs = c(0, 0),
  legend = TRUE,
  axes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.spectral_+3A_x">x</code></td>
<td>
<p>An EMU object of class 'spectral'</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_labs">labs</code></td>
<td>
<p>An optional vector character labels. Must be the same length as
specdata</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_ylim">ylim</code></td>
<td>
<p>A two-element numeric vector for the y-axis range (see 'par')</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_xlim">xlim</code></td>
<td>
<p>A two-element numeric vector for the x-axis range (see 'par')</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_col">col</code></td>
<td>
<p>Specify a color - see 'mu.colour')</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_lty">lty</code></td>
<td>
<p>Specify a linetype - see 'mu.colour'</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_lwd">lwd</code></td>
<td>
<p>Specify line thickness - see 'mu.colour'</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_fun">fun</code></td>
<td>
<p>An R function name e.g., mean, var, sum, etc. The function is
applied separately to each category type specified in labs</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_freq">freq</code></td>
<td>
<p>A numeric vector the same length as the number of columns in
specdata specifying the frequencies at which the spectral data is to be
plotted. If not supplied, defaults to trackfreq(specdata)</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_type">type</code></td>
<td>
<p>A single element character vector for the linetype</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_power">power</code></td>
<td>
<p>Logical. If TRUE, then specdata (or specdata$data if specdata is
a trackdata object, is converted to a *
specdata<code class="reqn">\mbox{\textasciicircum}</code>b, where a and b have the values
given in powcoeffs. This operation is applied before b</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_powcoeffs">powcoeffs</code></td>
<td>
<p>A two-element numeric vector. Defaults to c(10, 10)</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_dbnorm">dbnorm</code></td>
<td>
<p>Logical. If TRUE, apply dB-level normalization per spectrum as
defined by dbcoeffs below. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_dbcoeffs">dbcoeffs</code></td>
<td>
<p>A two element numeric vector (x, y). The spectra are
normalised in such a way that the values of each spectrum at a frequency of
y are set to a dB level of x. For example, to normalise the spectrum to 10
dB at 2000 Hz, set dbnorm to TRUE and dbcoeffs to c(2000, 10)</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_legend">legend</code></td>
<td>
<p>Parameters for defining the legend. See 'mu.legend' for
further details</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_axes">axes</code></td>
<td>
<p>A logical vector indicating whether the axes should be plotted</p>
</td></tr>
<tr><td><code id="plot.spectral_+3A_...">...</code></td>
<td>
<p>Further graphical parameters may be supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is implemented when a spectral trackdata object is called
with the 'plot' function.
</p>


<h3>Note</h3>

<p>To plot spectral data from a spectral trackdata object, then call the
function explicitly with 'plot/spectral' rather than with just 'plot'
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot">plot</a></code> <code><a href="#topic+plot.trackdata">plot.trackdata</a></code>
<code><a href="#topic+as.spectral">as.spectral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

plot(vowlax.dft.5[1,])

# with label types
plot(vowlax.dft.5[1:20,], vowlax.l[1:20])

# As above but averaged after converting to power ratios.
plot(vowlax.dft.5[1:20,], vowlax.l[1:20], fun=mean, power=TRUE)

# All the spectra of one segment in a trackdata object
plot(fric.dft[1,])


## End(Not run)

</code></pre>

<hr>
<h2 id='plot.trackdata'>Produces time-series plots from trackdata</h2><span id='topic+plot.trackdata'></span>

<h3>Description</h3>

<p>The function produces a plot as a function of time for a single segment or
multiple plots as a function of time for several segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackdata'
plot(
  x,
  timestart = NULL,
  xlim = NULL,
  ylim = NULL,
  labels = NULL,
  col = TRUE,
  lty = FALSE,
  type = "p",
  pch = NULL,
  contig = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.trackdata_+3A_x">x</code></td>
<td>
<p>A trackdata object.</p>
</td></tr>
<tr><td><code id="plot.trackdata_+3A_timestart">timestart</code></td>
<td>
<p>A single valued numeric vector for setting the time at
which the trackdata should start. Defaults to NULL which means that the
start time is taken from start(trackdata), i.e. the time at which the
trackdata object starts.</p>
</td></tr>
<tr><td><code id="plot.trackdata_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector of two values for specifying the time interval
over which the trackdata is to be plotted. Defaults to NULL which means
that the trackdata object is plotted between between the start time of the
first segment and the end time of the last segment.</p>
</td></tr>
<tr><td><code id="plot.trackdata_+3A_ylim">ylim</code></td>
<td>
<p>Specify a yaxis range.</p>
</td></tr>
<tr><td><code id="plot.trackdata_+3A_labels">labels</code></td>
<td>
<p>A character vector the same length as the number of segments
in the trackdata object. Each label is plotted at side = 3 on the plotted
at the temporal midpoint of each segment in the trackdata object. Defaults
to NULL (plot no labels). Labels will only be plotted if xlim=NULL.</p>
</td></tr>
<tr><td><code id="plot.trackdata_+3A_col">col</code></td>
<td>
<p>A single element logical vector. Defaults to TRUE to plot each
label type in a different colour</p>
</td></tr>
<tr><td><code id="plot.trackdata_+3A_lty">lty</code></td>
<td>
<p>A single element logical vector. Defaults to FALSE.  If TRUE, plot
each label type in a different linetype</p>
</td></tr>
<tr><td><code id="plot.trackdata_+3A_type">type</code></td>
<td>
<p>Specify the type of plot. See <a href="graphics.html#topic+plot">plot</a> for the various
possibilities</p>
</td></tr>
<tr><td><code id="plot.trackdata_+3A_pch">pch</code></td>
<td>
<p>The symbol types to be used for plotting. Should be specified as
a numeric vector of the same length as there are unique label classes</p>
</td></tr>
<tr><td><code id="plot.trackdata_+3A_contig">contig</code></td>
<td>
<p>A single valued logical vector TRUE or FALSE. If TRUE, then all the
segments of the trackdata object are assumed to be temporally contiguous,
i.e. the boundaries of the segments are abutting in time and the start time
of segment[j,] is the end time of segment[j-1,]. In this case, all the
segments of the trackdata object are plotted on the same plot as a function
of time. An example of a contiguous trackdata object is coutts.sam. contig
= FALSE is when a trackdata object is non-contiguous e.g. all &quot;i:&quot; vowels
in a database. An example of a non-contiguous trackdata object is
vowlax.fdat. If contig=FALSE then each segment of the trackdata object is
plotted separately.</p>
</td></tr>
<tr><td><code id="plot.trackdata_+3A_...">...</code></td>
<td>
<p>the same graphical parameters can be supplied to this function
as for plot e.g type=&quot;l&quot;, lty=2 etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots a single segment of trackdata as a function of time. If
the segment contains multiple tracks, then these will be overlaid. If there
are several temporally non-contiguous segments in the trackdata object,
each segment is plotted in a different panel by specifying contig=FALSE. This
function is not suitable for overlaying trackdata from more than one
segments on the same plot as a function of time: for this use dplot().
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="#topic+dplot">dplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# a single segment of trackdata (F1) plotted as a function of time.
plot(vowlax.fdat[1,1])

# as above, but limits are set for the time axis.
plot(vowlax.fdat[1,1], xlim=c(880, 920))

# the the start-time of the x-axis is set to 0 ms, plot F1 and F3, lineplot
plot(vowlax.fdat[1,c(1,3)],  timestart=0, type="l")


# plot F1-F4, same colour, same plotting symbol, between 900 
# and 920 ms, type is line and points plot, different linetype per track, no box
plot(vowlax.fdat[1,], col="blue", pch=20, xlim=c(900, 920), type="b", lty=TRUE, bty="n")


# F1 and F2 of six vowels with labels, separate windows
oldpar = par(mfrow=c(2,3))
plot(vowlax.fdat[1:6,1:2], contig=FALSE, labels=vowlax.l[1:6], ylab="F1 and F2", 
xlab="Time (ms)", type="b", ylim=c(300, 2400))

# As above, timestart set to zero, colour set to blue, different plotting
# symbols for the two tracks
plot(vowlax.fdat[1:6,1:2], contig=FALSE, labels=vowlax.l[1:6], ylab="F1 and F2", 
xlab="Time (ms)", type="b", col="blue", pch=c(1,2),  ylim=c(300, 2400), timestart=0)

# RMS energy for the utterance 'just relax said Coutts'
 plot(coutts.rms, type="l")
# as above a different colour
 plot(coutts.rms, type="l", col="pink")
# as above, linetype 2, double line thickness, no box, times reset to 0 ms
 plot(coutts.rms, type="l", col="pink", lty=2, lwd=2, bty="n", timestart=0)
# as above but plotted as non-contiguous segments, i.e one segment per panel
 par(mfrow=c(2,3))
 plot(coutts.rms, type="l", col="pink", lty=2, lwd=2, bty="n", timestart=0, contig=FALSE)
# plot with labels
 labels = label(coutts)
par(mfrow=c(1,1))
 plot(coutts.rms, labels=labels, type="l", bty="n")
# as above, double line-thickness, green, line type 3, no box, 
# time start 0 ms with x and y axis labels
 plot(coutts.rms, labels=labels, type="l", lwd=2, 
      col="green", lty=3,  bty="n", timestart=0, xlab="Time (ms)", ylab="Amplitude")
# as above with a different plotting symbol for the points
par(mfrow=c(2,3))
 plot(coutts.rms, labels=labels, type="b", lwd=2, col="green", 
      timestart=0, bty="n", contig=FALSE, pch=20)
 
par(oldpar)

</code></pre>

<hr>
<h2 id='polhom'>Segment list of four Polish homorganic fricatives from database epgpolish.</h2><span id='topic+polhom'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>segmentlist
</p>

<hr>
<h2 id='polhom.epg'>EPG-compressed trackdata from the segment list polhom</h2><span id='topic+polhom.epg'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>trackdata object
</p>

<hr>
<h2 id='polhom.l'>Vector of phonetic labels from the segment list polhom</h2><span id='topic+polhom.l'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of phonetic labels
</p>

<hr>
<h2 id='polygonplot'>polygonplot</h2><span id='topic+polygonplot'></span>

<h3>Description</h3>

<p>plots a polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygonplot(
  data,
  labels,
  order,
  formant = TRUE,
  axes = TRUE,
  xlab = "",
  ylab = "",
  main = "",
  xlim,
  ylim
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygonplot_+3A_data">data</code></td>
<td>
<p>data matrix</p>
</td></tr>
<tr><td><code id="polygonplot_+3A_labels">labels</code></td>
<td>
<p>labels</p>
</td></tr>
<tr><td><code id="polygonplot_+3A_order">order</code></td>
<td>
<p>order</p>
</td></tr>
<tr><td><code id="polygonplot_+3A_formant">formant</code></td>
<td>
<p>formant TRUE or FALSE transposes the axes</p>
</td></tr>
<tr><td><code id="polygonplot_+3A_axes">axes</code></td>
<td>
<p>axes</p>
</td></tr>
<tr><td><code id="polygonplot_+3A_xlab">xlab</code></td>
<td>
<p>xlab</p>
</td></tr>
<tr><td><code id="polygonplot_+3A_ylab">ylab</code></td>
<td>
<p>ylab</p>
</td></tr>
<tr><td><code id="polygonplot_+3A_main">main</code></td>
<td>
<p>main</p>
</td></tr>
<tr><td><code id="polygonplot_+3A_xlim">xlim</code></td>
<td>
<p>xlim</p>
</td></tr>
<tr><td><code id="polygonplot_+3A_ylim">ylim</code></td>
<td>
<p>ylim</p>
</td></tr>
</table>

<hr>
<h2 id='print.emuRsegs'>Print emuRsegs segment list</h2><span id='topic+print.emuRsegs'></span>

<h3>Description</h3>

<p>Print emuRsegs segment list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emuRsegs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.emuRsegs_+3A_x">x</code></td>
<td>
<p>object to print</p>
</td></tr>
<tr><td><code id="print.emuRsegs_+3A_...">...</code></td>
<td>
<p>additional params</p>
</td></tr>
</table>

<hr>
<h2 id='print.emuRtrackdata'>Print emuRtrackdata object</h2><span id='topic+print.emuRtrackdata'></span>

<h3>Description</h3>

<p>Print emuRtrackdata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emuRtrackdata'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.emuRtrackdata_+3A_x">x</code></td>
<td>
<p>object to print</p>
</td></tr>
<tr><td><code id="print.emuRtrackdata_+3A_...">...</code></td>
<td>
<p>additional params</p>
</td></tr>
</table>

<hr>
<h2 id='print.emusegs'>print emusegs</h2><span id='topic+print.emusegs'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emusegs'
print(x, ...)
</code></pre>

<hr>
<h2 id='print.trackdata'>print trackdata</h2><span id='topic+print.trackdata'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackdata'
print(x, ...)
</code></pre>

<hr>
<h2 id='query'>Query emuDB</h2><span id='topic+query'></span>

<h3>Description</h3>

<p>Function to query annotation items/structures in an emuDB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query(
  emuDBhandle,
  query,
  sessionPattern = ".*",
  bundlePattern = ".*",
  queryLang = "EQL2",
  timeRefSegmentLevel = NULL,
  resultType = "tibble",
  calcTimes = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle object (see <a href="#topic+load_emuDB">load_emuDB</a>)</p>
</td></tr>
<tr><td><code id="query_+3A_query">query</code></td>
<td>
<p>string (see vignette <a href="https://ips-lmu.github.io/The-EMU-SDMS-Manual/chap-querysys.html">https://ips-lmu.github.io/The-EMU-SDMS-Manual/chap-querysys.html</a>)</p>
</td></tr>
<tr><td><code id="query_+3A_sessionpattern">sessionPattern</code></td>
<td>
<p>A regular expression pattern matching session names to 
be searched from the database</p>
</td></tr>
<tr><td><code id="query_+3A_bundlepattern">bundlePattern</code></td>
<td>
<p>A regular expression pattern matching bundle names to be 
searched from the database</p>
</td></tr>
<tr><td><code id="query_+3A_querylang">queryLang</code></td>
<td>
<p>query language used for evaluating the query string</p>
</td></tr>
<tr><td><code id="query_+3A_timerefsegmentlevel">timeRefSegmentLevel</code></td>
<td>
<p>set time segment level from which to derive time 
information. It is only necessary to set this parameter if more than one child 
level contains time information and the queried parent level is of type ITEM.</p>
</td></tr>
<tr><td><code id="query_+3A_resulttype">resultType</code></td>
<td>
<p>type (class name) of result (either 'tibble', 'emuRsegs' or 
'emusegs' (use 'emusegs' for legacy compatablility only))</p>
</td></tr>
<tr><td><code id="query_+3A_calctimes">calcTimes</code></td>
<td>
<p>calculate times for resulting segments (results in 
<code>NA</code> values for start and end times in emuseg/emuRsegs). As it can be 
very computationally expensive to 
calculate the times for large nested hierarchies, it can be turned off via this 
parameter.</p>
</td></tr>
<tr><td><code id="query_+3A_verbose">verbose</code></td>
<td>
<p>be verbose. Set this to <code>TRUE</code> if you wish to choose which 
path to traverse on intersecting hierarchies. If set to <code>FALSE</code> (the default) 
all paths will be traversed (= legacy EMU behavior).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evaluates a query string of query language queryLang on an 
emuDB referenced by <code>emuDBhandle</code> and returns a segment list of the desired type resultType.  
For details of the query language please refer to the EMU-SDMS manual's query 
system chapter (<a href="https://ips-lmu.github.io/The-EMU-SDMS-Manual/chap-querysys.html">https://ips-lmu.github.io/The-EMU-SDMS-Manual/chap-querysys.html</a>).
This function extracts a list of segments which meet the conditions given by the query string. 
A segment can consist of one (e.g. 's') or more (e.g. 's-&gt;t') items from 
the specified emuDB level. Segment objects (type 'SEGMENT') contain the label 
string and the start and end time information of the segment (in ms). 
The <code>tibble</code> return type (now the defaults) objects additionally contain 
sample position of start and end item. 
Time information of symbolic elements (type 'ITEM') are derived from linked SEGMENT 
levels if available. If multiple linked SEGMENT levels exist, you can specify the 
level with the <code>timeRefSegmentLevel</code> argument. If time and sample values cannot be 
derived they will be set to <code><a href="base.html#topic+NA">NA</a></code>. <a href="dplyr.html#topic+tibble">tibble</a>s will 
be ordered by the columns UUID, session, bundle and sequence index (seq_idx). 
Legacy <a href="#topic+emusegs">emusegs</a> lists are ordered by the columns utts and start.
The query may be limited to session and/or bundle names specified by regular 
expression pattern strings (see <a href="base.html#topic+regex">regex</a>) in parameters <code>sessionPattern</code> 
respectively <code>bundlePattern</code>.
</p>


<h3>Value</h3>

<p>result set object of class resultType (default: <a href="dplyr.html#topic+tibble">tibble</a>, 
compatible to legacy types <a href="#topic+emuRsegs">emuRsegs</a> and <a href="#topic+emusegs">emusegs</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load_emuDB">load_emuDB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

## Query database ae with EQL query "[Phonetic=t -&gt; Phonetic=s]":
## 'Find all sequences /ts/ on the level named Phonetics'.
## and store result seglist in variable segListTs

seglistTs = query(ae, "[Phonetic == t -&gt; Phonetic == s]")

## Query database ae with EQL query "[Syllable == S ^ Phoneme == t]":
## 'Find all items 't' on the level named Phoneme that are dominated by 
## items 'S' in level Syllable.'
## Return legacy Emu result type 'emusegs'

query(ae, "[Syllable == S ^ Phoneme == t]", resultType = "emusegs")

## Query 'p' items on the level named Phoneme from bundles whose 
## bundle names start with 'msajc07' 
## and whose session names start with '00'
## (Note that here the query uses the operator '=' (meaning '==') 
## which is kept for backwards compatibilty to EQL1.)  

query(ae, "Phoneme = p", bundlePattern = "msajc05.*", sessionPattern = "00.*")


## End(Not run)

</code></pre>

<hr>
<h2 id='rad'>Function to convert between Hertz and Radians</h2><span id='topic+rad'></span>

<h3>Description</h3>

<p>convert between Hertz and Radians
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rad(vec, samfreq = 20000, hz = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rad_+3A_vec">vec</code></td>
<td>
<p>A numerical vector of frequencies in Hz or radians</p>
</td></tr>
<tr><td><code id="rad_+3A_samfreq">samfreq</code></td>
<td>
<p>A single element numerical vector of the sampling frequency.
Defaults to 20000 Hz</p>
</td></tr>
<tr><td><code id="rad_+3A_hz">hz</code></td>
<td>
<p>Logical. If TRUE, convert from Hz to radians otherwise from radians
to hz</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+help">help</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 4000 Hz in radians at a sampling frequency of 8000 Hz
rad(4000, 8000)
# pi/2 and pi/4  radians in Hz at a sampling frequency of 10000 Hz
rad(c(pi/2, pi/4), 10000, FALSE)


</code></pre>

<hr>
<h2 id='radians'>Converts degrees to radians</h2><span id='topic+radians'></span>

<h3>Description</h3>

<p>Converts degrees to radians
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radians(degrees)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radians_+3A_degrees">degrees</code></td>
<td>
<p>Angular measurement for conversion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 360 degrees or 2 * PI radians in one full rotation.
</p>


<h3>Value</h3>

<p>Angular measurement in radians.
</p>

<hr>
<h2 id='randomise.segs'>Randomise or Reverse items in a segment list</h2><span id='topic+randomise.segs'></span>

<h3>Description</h3>

<p>Randomises or Reverses items in a segment list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomise.segs(segs, rand = TRUE, bwd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomise.segs_+3A_segs">segs</code></td>
<td>
<p>An Emu segment list.</p>
</td></tr>
<tr><td><code id="randomise.segs_+3A_rand">rand</code></td>
<td>
<p>If TRUE, randomise the order of the segment lists (default).</p>
</td></tr>
<tr><td><code id="randomise.segs_+3A_bwd">bwd</code></td>
<td>
<p>If TRUE, reverse the order of the segment list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A segment list containing the original elements in random or
reversed order. This is useful if the segment list is to be used as the
source for a set of stimuli in a perception experiment.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+query">query</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vowlax)
## assumes a database called demo is available on your system and that
## the Emu system is installed. 

# all Phonetic vowels in the database
segs &lt;- vowlax

# randomise the segment list
rsegs &lt;- randomise.segs( segs )


</code></pre>

<hr>
<h2 id='rbind.trackdata'>A method of the generic function rbind for objects of class trackdata</h2><span id='topic+rbind.trackdata'></span><span id='topic+rbind'></span>

<h3>Description</h3>

<p>Different track data objects from one segment list are bound by combining
the $data columns of the track data object by rows.  Track data objects
are created by <code><a href="#topic+get_trackdata">get_trackdata</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackdata'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.trackdata_+3A_...">...</code></td>
<td>
<p>track data objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All track data objects have to be track data of the same segment list.
Thus $index and $ftime values have to be identically for all track data
objects.  The number of columns of the track data objects must match. Thus
a track data object of more than one formant and single columned F0 track
data object can not be rbind()ed.
</p>


<h3>Value</h3>

<p>A track data object with the same $index and $ftime values of the
source track data objects and with $data that includes all columns of
$data of the source track data objects.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbind">rbind</a></code> <code><a href="#topic+cbind.trackdata">cbind.trackdata</a></code>
<code><a href="#topic+trackdata">trackdata</a></code> <code><a href="#topic+get_trackdata">get_trackdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   data(vowlax)
   
   #segment list vowlax - first segment only 
   vowlax[1,]
   
   #F0 track data object for vowlax - first segment only 
   vowlax.fund[1]
   
   #rms track data object for vowlax - first segment only 
   vowlax.rms[1]
   
   #now combine both track data objects
   fund.rms.lax = rbind(vowlax.fund[1:10,], vowlax.rms[1:10,])
 
   #the combined track data object
   #The first ten rows in $data keep vowlax.fund data, the 11th to last row keeps vowlax.rms data 
   fund.rms.lax
   


</code></pre>

<hr>
<h2 id='read_bundleList'>read bundleList</h2><span id='topic+read_bundleList'></span>

<h3>Description</h3>

<p>read bundleList JSON file in emuDB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_bundleList(emuDBhandle, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_bundleList_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle object (see <a href="#topic+load_emuDB">load_emuDB</a>)</p>
</td></tr>
<tr><td><code id="read_bundleList_+3A_name">name</code></td>
<td>
<p>name of bundleList (excluding the _bundleList.json suffix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read bundleList JSON file in emuDB that is stored in
the databases root dir sub-dir <code>bundleLists/</code>
</p>


<h3>Value</h3>

<p>tibble with the columns <code>session</code>, <code>name</code>, 
<code>comment</code>, <code>finishedEditing</code>
</p>

<hr>
<h2 id='read.emusegs'>Create an Emu segment list from a file</h2><span id='topic+read.emusegs'></span>

<h3>Description</h3>

<p>Create an Emu segment list from a file saved by the Emu query tools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.emusegs(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.emusegs_+3A_file">file</code></td>
<td>
<p>The name of the file to read</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reads segment lists created by programs external to R/Splus and stored in
text files on disk.
</p>


<h3>Value</h3>

<p>An Emu segment list.
</p>


<h3>Author(s)</h3>

<p>Steve Cassidy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+query">query</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create a segment list file and write it out
# seglist.txt &lt;- "database:demo"\
# query:Phonetic=vowel\
# type:segment\
#\
# @:	3059.65	3343.65	msdjc001\
# e:	5958.55	6244.55	msdjc002\
# @u	8984.75	9288.75	msdjc003\
# A	11880.8	12184.8	msdjc004\
# E	17188.3	17366.4	msdjc005\
# ei	20315.2	20655.2	msdjc006"

## Not run: cat(seglist.txt, file="seglist.txt")

# now read it back as a segment list
## Not run: segs &lt;- read.emusegs("seglist.txt")
## Not run: segs
## and clean up
## Not run: unlink("seglist.txt")


</code></pre>

<hr>
<h2 id='rename_bundles'>Rename bundles in emuDB</h2><span id='topic+rename_bundles'></span>

<h3>Description</h3>

<p>Rename bundles of emuDB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_bundles(emuDBhandle, bundles)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_bundles_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="rename_bundles_+3A_bundles">bundles</code></td>
<td>
<p>data.frame like object with the columns
</p>

<ul>
<li> <p><code>session</code>: name of sessions containing bundle
</p>
</li>
<li> <p><code>name</code>: name of bundle
</p>
</li>
<li> <p><code>name_new</code>: new name given to bundle
</p>
</li></ul>

<p>It is worth noting that <code>session</code> and <code>name</code> are the columns returned by 
<code><a href="#topic+list_bundles">list_bundles</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB
# (see ?load_emuDB for more information)

# list bundles of session "0000" of ae emuDB
bundles = list_bundles(emuDBhandle = ae,
                       session = "0000")

# append "XXX" to bundle names and rename
bundles$name_new = paste0(bundles$name, "XXX")
rename_bundles(emuDBhandle, bundles)

## End(Not run)

</code></pre>

<hr>
<h2 id='rename_emuDB'>Rename emuDB</h2><span id='topic+rename_emuDB'></span>

<h3>Description</h3>

<p>Rename a emuDB. This effectively renames the folder of a 
emuDB the _DBconfig.json file as well as the &quot;name&quot; entry in the _DBconfig.json
file and the _emuDBcache.sqlite file if available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_emuDB(databaseDir, newName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_emuDB_+3A_databasedir">databaseDir</code></td>
<td>
<p>directory of the emuDB</p>
</td></tr>
<tr><td><code id="rename_emuDB_+3A_newname">newName</code></td>
<td>
<p>new name of emuDB</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB
# (see ?load_emuDB for more information)

# rename ae emuDB to "aeNew"
rename_emuDB(databaseDir = "/path/2/ae_emuDB", newName = "aeNew")


## End(Not run)

</code></pre>

<hr>
<h2 id='replace_itemLabels'>Replace item labels</h2><span id='topic+replace_itemLabels'></span>

<h3>Description</h3>

<p>Replace the labels of all annotation items, or more specifically 
of attribute definitions belonging to annotation items, in an emuDB that 
match the provided <code>origLabels</code> character vector which the 
corresponding labels provided by the <code>newLabels</code> character vector. 
The indices of the label vectors provided are used to match the labels
(i.e. <code>origLabels[i]</code> will be replaced by <code>newLabels[i]</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_itemLabels(
  emuDBhandle,
  attributeDefinitionName,
  origLabels,
  newLabels,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_itemLabels_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle object (see <a href="#topic+load_emuDB">load_emuDB</a>)</p>
</td></tr>
<tr><td><code id="replace_itemLabels_+3A_attributedefinitionname">attributeDefinitionName</code></td>
<td>
<p>name of a attributeDefinition of a emuDB 
where the labels are to be replaced</p>
</td></tr>
<tr><td><code id="replace_itemLabels_+3A_origlabels">origLabels</code></td>
<td>
<p>character vector containing labels that are to be replaced</p>
</td></tr>
<tr><td><code id="replace_itemLabels_+3A_newlabels">newLabels</code></td>
<td>
<p>character vector containing labels that are to replaced 
the labels of <code>origLabels</code>. This vector has to be of equal length 
to the <code>origLabels</code> vector.</p>
</td></tr>
<tr><td><code id="replace_itemLabels_+3A_verbose">verbose</code></td>
<td>
<p>Show progress bars and further information</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+load_emuDB">load_emuDB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

# replace all "I" and "p" labels with "I_replaced" and "p_replaced"
replace_itemLabels(ae, attributeDefinitionName = "Phonetic", 
                       origLabels = c("I", "p"), 
                       newLabels = c("I_replaced", "p_replaced"))


## End(Not run)

</code></pre>

<hr>
<h2 id='requery_hier'>Requery hierarchical context of a segment list in an emuDB</h2><span id='topic+requery_hier'></span>

<h3>Description</h3>

<p>Function to requery the hierarchical context of a segment list queried from an emuDB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requery_hier(
  emuDBhandle,
  seglist,
  level,
  collapse = TRUE,
  resultType = "tibble",
  calcTimes = TRUE,
  timeRefSegmentLevel = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requery_hier_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="requery_hier_+3A_seglist">seglist</code></td>
<td>
<p>segment list to requery on (type: <a href="#topic+emuRsegs">emuRsegs</a>)</p>
</td></tr>
<tr><td><code id="requery_hier_+3A_level">level</code></td>
<td>
<p>character string: name of target level</p>
</td></tr>
<tr><td><code id="requery_hier_+3A_collapse">collapse</code></td>
<td>
<p>collapse the found items in the requested level to a sequence (concatenated with -&gt;). 
If set to <code>FALSE</code> separate items as new entries in the emuRsegs object are returned.</p>
</td></tr>
<tr><td><code id="requery_hier_+3A_resulttype">resultType</code></td>
<td>
<p>type of result (either 'tibble' == default or 'emuRsegs')</p>
</td></tr>
<tr><td><code id="requery_hier_+3A_calctimes">calcTimes</code></td>
<td>
<p>calculate times for resulting segments (results in <code>NA</code> values for start and end 
times in emuseg/emuRsegs). As it can be very computationally expensive to 
calculate the times for large nested hierarchies, it can be turned off via this boolean parameter.</p>
</td></tr>
<tr><td><code id="requery_hier_+3A_timerefsegmentlevel">timeRefSegmentLevel</code></td>
<td>
<p>set time segment level from which to derive time information. It is only 
necessary to set this parameter if more than one child level contains time information and the queried 
parent level is of type ITEM.</p>
</td></tr>
<tr><td><code id="requery_hier_+3A_verbose">verbose</code></td>
<td>
<p>be verbose. Set this to <code>TRUE</code> if you wish to choose which path to traverse on intersecting 
hierarchies. If set to <code>FALSE</code> (the default) all paths will be traversed (= legacy EMU behaviour).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A segment is defined as a single item or a chain of items from the respective level, e.g. 
if a level in a bundle instance has labels 'a', 'b' and 'c' in that order, 'a' or 'a-&gt;b' or 'a-&gt;b-&gt;c' 
are all valid segments, 'a-&gt;c' is not. For each segment of the input segment list <code>seglist</code> 
the function checks the start and end item for hierarchically linked items in the given target 
level, and based on them constructs segments in the target level. As the start item in the resulting 
segment the item with the lowest sequence index is chosen; for the end item that with the highest 
sequence index. If the parameter <code>collapse</code> is set to <code>TRUE</code> (the default), it is guaranteed 
that result and input segment list have the same length (for each input 
segment one or multiple segments on the target level was found). If multiple linked segments where found
they are collapsed into a sequence of segments ('a-&gt;b-&gt;c') and if no linked items where found an NA row 
is inserted.
</p>


<h3>Value</h3>

<p>result set object of class <a href="#topic+emuRsegs">emuRsegs</a> or <a href="dplyr.html#topic+tibble">tibble</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+query">query</a></code> <code><a href="#topic+requery_seq">requery_seq</a></code> <code><a href="#topic+emuRsegs">emuRsegs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

## Downward requery: find 'Phoneme' sequences of all words 'beautiful' (of level 'Text')
## Note that the resulting segments consists of phoneme sequences and have therefore 
## the same length as the word segments.

sl1 = query(ae, "Text == beautiful")
requery_hier(ae, sl1, level = "Phoneme")

## Upward requery: find all word segments that dominate a 'p' on level 'Phoneme'
## Note that the resulting segments are larger than the input segments,
## because they contain the complete words.

sl1 = query(ae, "Phonetic == p")
requery_hier(ae, sl1, level = 'Text')

## Why is there a 'p' the word 'emphazised'? Requery the whole words back down to 'Phoneme' level:

requery_hier(ae, sl1, level = 'Phoneme')

## ... because of 'stop epenthesis' a 'p' is inserted between 'm' and 'f'

## Combined requery: last phonemes of all words beginning with 'an'.
## Note that we use a regular expression 'an.*' (EQL operator '=~') in the query.

sl1=query(ae, "Text =~ an.*")
requery_seq(ae, requery_hier(ae, sl1, level = 'Phoneme'), offsetRef = 'END')


## End(Not run)
</code></pre>

<hr>
<h2 id='requery_seq'>Requery sequential context of segment list in an emuDB</h2><span id='topic+requery_seq'></span>

<h3>Description</h3>

<p>Function to requery sequential context of a segment list queried 
from an emuDB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requery_seq(
  emuDBhandle,
  seglist,
  offset = 0,
  offsetRef = "START",
  length = 1,
  ignoreOutOfBounds = FALSE,
  resultType = "tibble",
  calcTimes = TRUE,
  timeRefSegmentLevel = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requery_seq_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="requery_seq_+3A_seglist">seglist</code></td>
<td>
<p>segment list to requery on (type: 'tibble' or 'emuRsegs')</p>
</td></tr>
<tr><td><code id="requery_seq_+3A_offset">offset</code></td>
<td>
<p>start item offset in sequence (default is 0, meaning the start 
or end item of the input segment)</p>
</td></tr>
<tr><td><code id="requery_seq_+3A_offsetref">offsetRef</code></td>
<td>
<p>reference item for offset: 'START' for first and 'END' 
for last item of segment</p>
</td></tr>
<tr><td><code id="requery_seq_+3A_length">length</code></td>
<td>
<p>item length of segments in the returned segment list</p>
</td></tr>
<tr><td><code id="requery_seq_+3A_ignoreoutofbounds">ignoreOutOfBounds</code></td>
<td>
<p>ignore result segments that are out of bundle bounds</p>
</td></tr>
<tr><td><code id="requery_seq_+3A_resulttype">resultType</code></td>
<td>
<p>type of result (either 'tibble' == default, 'emuRsegs')</p>
</td></tr>
<tr><td><code id="requery_seq_+3A_calctimes">calcTimes</code></td>
<td>
<p>calculate times for resulting segments (results in <code>NA</code> 
values for start and end times in emuseg/emuRsegs). As it can be very 
computationally expensive to calculate the times for large nested hierarchies, 
it can be turned off via this boolean parameter.</p>
</td></tr>
<tr><td><code id="requery_seq_+3A_timerefsegmentlevel">timeRefSegmentLevel</code></td>
<td>
<p>set time segment level from which to derive time 
information. It is only necessary to set this parameter if more than one 
child level contains time information and the queried parent level is of type ITEM.</p>
</td></tr>
<tr><td><code id="requery_seq_+3A_verbose">verbose</code></td>
<td>
<p>be verbose. Set this to <code>TRUE</code> if you wish to choose which 
path to traverse on intersecting hierarchies. If set to <code>FALSE</code> (the 
default) all paths will be traversed (= legacy EMU behaviour).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Builds a new segment list on the same hierarchical level 
and the same length as the segment list given in <code>seglist</code>. The 
resulting segments usually have different start position and length (in 
terms of items of the respective level) controlled by the <code>offset</code>,
<code>offsetRef</code> and <code>length</code> parameters.
A segment here is defined as a single item or a chain of items from the 
respective level, e.g. if a level in a bundle instance has labels 'a', 'b' 
and 'c' in that order, 'a' or 'a-&gt;b' oder 'a-&gt;b-&gt;c' are all valid segments, 
but not 'a-&gt;c'.
<code>offsetRef</code> determines if the position offset is referenced to the 
start or the end item of the segments in the input list <code>seglist</code>; 
parameter <code>offset</code> determines the offset of the resulting item start 
position to this reference item; parameter <code>length</code> sets the item 
length of the result segments. If the requested segments are out of bundle 
item boundaries and parameter <code>ignoreOutOfBounds</code> is <code>FALSE</code> 
(the default), an error is generated. To get residual resulting segments 
that lie within the bounds the <code>ignoreOutOfBounds</code> parameter can be 
set to <code>TRUE</code>. The returned segment list is usually of the same 
length and order as the input <code>seglist</code>; if <code>ignoreOutOfBounds=FALSE</code>, 
the resulting segment list may be out of sync.
</p>


<h3>Value</h3>

<p>result set object of class <a href="#topic+emuRsegs">emuRsegs</a> or <a href="dplyr.html#topic+tibble">tibble</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+query">query</a></code> <code><a href="#topic+requery_hier">requery_hier</a></code> <code><a href="#topic+emuRsegs">emuRsegs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

## Requery previous item of 'p' on level 'Phonetic'
sl1 = query(ae, "Phonetic == p")

requery_seq(ae, sl1, offset = -1)

## Requery context (adding previuos and following elements) 
## of 'p' on phonetic level

requery_seq(ae, sl1, offset = -1, length = 3)

## Requery previous item of n-&gt;t sequence
sl2 = query(ae, "[Phoneme == n -&gt; Phoneme == t]")

requery_seq(ae, sl2, offset = -1)

## Requery last item within n-&gt;t sequence

requery_seq(ae, sl2, offsetRef = 'END')

## Requery following item after n-&gt;t sequence

requery_seq(ae, sl2, offset = 1, offsetRef = 'END')

## Requery context (previous and following items) of n-&gt;t sequence

requery_seq(ae, sl2, offset = -1, length = 4)

## Requery next word contexts (sequence includes target word)

sl3 = query(ae, "Text == to")
requery_seq(ae, sl3, length = 2)

## Requery following two word contexts, ignoring segment 
## sequences that are out of bundle end bounds 
requery_seq(ae, sl3, length = 3, ignoreOutOfBounds = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='resample_annots'>Resample annotations (<code>_annot.json</code>) files of emuDB</h2><span id='topic+resample_annots'></span>

<h3>Description</h3>

<p>Resample all annotations (<code>_annot.json</code>) files of emuDB to a specified 
sample rate. It is up to the user to ensure that the samplerates of 
the annot.json files match those of the <code>.wav</code> files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_annots(emuDBhandle, newSampleRate, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_annots_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle object (see <a href="#topic+load_emuDB">load_emuDB</a>)</p>
</td></tr>
<tr><td><code id="resample_annots_+3A_newsamplerate">newSampleRate</code></td>
<td>
<p>target sample rate</p>
</td></tr>
<tr><td><code id="resample_annots_+3A_verbose">verbose</code></td>
<td>
<p>show progress bars and further information</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

# resample
resample_annots(ae, newSampleRate = 16000)


## End(Not run)
</code></pre>

<hr>
<h2 id='rescale.gerst'>rescale gerst</h2><span id='topic+rescale.gerst'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale.gerst(data, mind, ranged)
</code></pre>

<hr>
<h2 id='rescale.lob'>rescale lob</h2><span id='topic+rescale.lob'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale.lob(data, mvals, sdvals)
</code></pre>

<hr>
<h2 id='rescale.nearey'>rescale nearey</h2><span id='topic+rescale.nearey'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale.nearey(data, neardata)
</code></pre>

<hr>
<h2 id='runBASwebservice_all'>Runs several BAS webservices, starting from an orthographic transcription</h2><span id='topic+runBASwebservice_all'></span>

<h3>Description</h3>

<p>This function calls the BAS webservices G2P, MAUS, Pho2Syl, MINNI and (if necessary) Chunker.
Starting from an orthographic transcription, it derives a tokenized orthographical word tier
using the G2P tool. It also derives canonical pronunciations (in SAMPA) for the words.
If at least one audio file is longer than 60 seconds, the function then calls the Chunker webservice
to presegment the recordings. Subsequently, the webservice MAUS is called to derive a phonetic
segmentation. A second, rough segmentation is created by running the phoneme decoder MINNI.
Finally, syllabification is performed by calling Pho2Syl. <strong>This function requires an internet connection.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runBASwebservice_all(
  handle,
  transcriptionAttributeDefinitionName,
  language,
  orthoAttributeDefinitionName = "ORT",
  canoAttributeDefinitionName = "KAN",
  mausAttributeDefinitionName = "MAU",
  minniAttributeDefinitionName = "MINNI",
  sylAttributeDefinitionName = "MAS",
  canoSylAttributeDefinitionName = "KAS",
  chunkAttributeDefinitionName = "TRN",
  runMINNI = TRUE,
  patience = 0,
  resume = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runBASwebservice_all_+3A_handle">handle</code></td>
<td>
<p>emuDB handle</p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_transcriptionattributedefinitionname">transcriptionAttributeDefinitionName</code></td>
<td>
<p>name of the attribute (not level!) containing an orthographic transcription.</p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_language">language</code></td>
<td>
<p>language(s) to be used. If you pass a single string (e.g. &quot;deu-DE&quot;), this language will be used for all bundles.
Alternatively, you can select the language for every bundle individually. To do so, you must pass a data frame with the columns
session, bundle, language. This data frame must contain one row for every bundle in your emuDB.
Up-to-date lists of the languages accepted by all webservices can be found here:
<a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a></p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_orthoattributedefinitionname">orthoAttributeDefinitionName</code></td>
<td>
<p>attribute name for orthographic words</p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_canoattributedefinitionname">canoAttributeDefinitionName</code></td>
<td>
<p>attribute name for canonical pronunciations of words</p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_mausattributedefinitionname">mausAttributeDefinitionName</code></td>
<td>
<p>attribute name for the MAUS segmentation</p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_minniattributedefinitionname">minniAttributeDefinitionName</code></td>
<td>
<p>attribute name for the MINNI segmentation</p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_sylattributedefinitionname">sylAttributeDefinitionName</code></td>
<td>
<p>attribute name for syllable segmentation</p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_canosylattributedefinitionname">canoSylAttributeDefinitionName</code></td>
<td>
<p>attribute name for syllabified canonical pronunciations of words</p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_chunkattributedefinitionname">chunkAttributeDefinitionName</code></td>
<td>
<p>attribute name for the chunk segmentation.
Please note that the chunk segmentation will only be generated if your emuDB contains
audio files beyond the one minute mark.</p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_runminni">runMINNI</code></td>
<td>
<p>if set to <code>TRUE</code> (the default) the MINNI service is also run. As the MINNI service contains
less languages than the others it can be useful to turn this off.</p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_patience">patience</code></td>
<td>
<p>If a web service call fails, it is repeated a further n times, with n being the value of patience.
Must be set to a value between 0 and 3.</p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_resume">resume</code></td>
<td>
<p>If a previous call to this function has failed (and you think you have fixed the issue
that caused the error), you can set resume=TRUE to recover any progress made up to that point. This
will only work if your R temporary directory has not been deleted or emptied in the meantime.</p>
</td></tr>
<tr><td><code id="runBASwebservice_all_+3A_verbose">verbose</code></td>
<td>
<p>Display progress bars and other information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All necessary level, attribute and link definitions are created in the process.
Note that this function will run all BAS webservices with default parameters, with four exceptions:
</p>

<ul>
<li><p>Chunker: force=rescue
</p>
</li>
<li><p>G2P: embed=maus
</p>
</li>
<li><p>Pho2Syl: wsync=yes
</p>
</li>
<li><p>MAUS: USETRN=[true if Chunker was called or transcription is a segment tier, false otherwise]
</p>
</li></ul>

<p>If you wish to change parameters, you must use the individual runBASwebservices functions. This will also allow
you to carry out manual corrections in between the steps, or to use different languages for different webservices.
</p>


<h3>See Also</h3>

<p>Other BAS webservice functions: 
<code><a href="#topic+runBASwebservice_chunker">runBASwebservice_chunker</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForPronunciation">runBASwebservice_g2pForPronunciation</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForTokenization">runBASwebservice_g2pForTokenization</a>()</code>,
<code><a href="#topic+runBASwebservice_maus">runBASwebservice_maus</a>()</code>,
<code><a href="#topic+runBASwebservice_minni">runBASwebservice_minni</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylCanonical">runBASwebservice_pho2sylCanonical</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylSegmental">runBASwebservice_pho2sylSegmental</a>()</code>
</p>

<hr>
<h2 id='runBASwebservice_chunker'>Creates a chunk segmentation using the webservice Chunker.</h2><span id='topic+runBASwebservice_chunker'></span>

<h3>Description</h3>

<p>When audio input files are longer than approximately 10 minutes, alignment-based segmentation
tools such as MAUS will take a long time to run. In these cases, the Chunker pre-segments
the input into more digestible &quot;chunks&quot;. As input, it requires a word tier with canonical
pronunciation attributes (which can be derived by <a href="#topic+runBASwebservice_g2pForPronunciation">runBASwebservice_g2pForPronunciation</a>).
The resulting chunk level can be passed as input to <a href="#topic+runBASwebservice_maus">runBASwebservice_maus</a>.
<strong>This function requires an internet connection.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runBASwebservice_chunker(
  handle,
  canoAttributeDefinitionName,
  language,
  chunkAttributeDefinitionName = "TRN",
  rootLevel = NULL,
  orthoAttributeDefinitionName = NULL,
  params = list(force = "rescue"),
  perspective = "default",
  patience = 0,
  resume = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runBASwebservice_chunker_+3A_handle">handle</code></td>
<td>
<p>emuDB handle</p>
</td></tr>
<tr><td><code id="runBASwebservice_chunker_+3A_canoattributedefinitionname">canoAttributeDefinitionName</code></td>
<td>
<p>name of the attribute (not level!) containing a canonical pronunciation of the words.</p>
</td></tr>
<tr><td><code id="runBASwebservice_chunker_+3A_language">language</code></td>
<td>
<p>language(s) to be used. If you pass a single string (e.g. &quot;deu-DE&quot;), this language will be used for all bundles.
Alternatively, you can select the language for every bundle individually. To do so, you must pass a data frame with the columns
session, bundle, language. This data frame must contain one row for every bundle in your emuDB.
Up-to-date lists of the languages accepted by all webservices can be found here:
<a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a></p>
</td></tr>
<tr><td><code id="runBASwebservice_chunker_+3A_chunkattributedefinitionname">chunkAttributeDefinitionName</code></td>
<td>
<p>attribute name for the chunk segmentation</p>
</td></tr>
<tr><td><code id="runBASwebservice_chunker_+3A_rootlevel">rootLevel</code></td>
<td>
<p>if provided, the new level will be linked to the root level</p>
</td></tr>
<tr><td><code id="runBASwebservice_chunker_+3A_orthoattributedefinitionname">orthoAttributeDefinitionName</code></td>
<td>
<p>if provided, chunk attributes will contain orthographic instead of SAMPA strings.
Must be paired with the canonical pronunciation attributes in canoAttributeDefinitionName.</p>
</td></tr>
<tr><td><code id="runBASwebservice_chunker_+3A_params">params</code></td>
<td>
<p>named list of parameters to be passed on to the webservice. It is your own responsibility to
ensure that these parameters are compatible with the webservice API
(see <a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a>).
Some options accepted by the API (e.g. output format) cannot be set when calling a webservice from within emuR,
and will be overridden. If file parameters are used please wrap the file path in <code>httr::upload_file("/path/2/file/rules.nrul")</code>.</p>
</td></tr>
<tr><td><code id="runBASwebservice_chunker_+3A_perspective">perspective</code></td>
<td>
<p>the webApp perspective that the new level will be added to.
If NULL, the new level is not added to any perspectives.</p>
</td></tr>
<tr><td><code id="runBASwebservice_chunker_+3A_patience">patience</code></td>
<td>
<p>If a web service call fails, it is repeated a further n times, with n being the value of patience.
Must be set to a value between 0 and 3.</p>
</td></tr>
<tr><td><code id="runBASwebservice_chunker_+3A_resume">resume</code></td>
<td>
<p>If a previous call to this function has failed (and you think you have fixed the issue
that caused the error), you can set resume=TRUE to recover any progress made up to that point. This
will only work if your R temporary directory has not been deleted or emptied in the meantime.</p>
</td></tr>
<tr><td><code id="runBASwebservice_chunker_+3A_verbose">verbose</code></td>
<td>
<p>Display progress bars and other information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note that the chunker output is <strong>not</strong> a semantically meaningful sentence
or turn segmentation, meaning that it cannot be used for analyses of sentence durations and the like.
By default, the chunker is called in force rescue mode. This means that the chunker is first run
in its normal mode, and switches to forced chunking mode only when it fails to find chunks that
are short enough for processing by MAUS. To disable the force mode completely, call this function with
params=list(force=&quot;false&quot;). To skip the normal chunking mode and go directly into forced chunking
mode, use params=list(force=&quot;true&quot;).
</p>


<h3>See Also</h3>

<p>Other BAS webservice functions: 
<code><a href="#topic+runBASwebservice_all">runBASwebservice_all</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForPronunciation">runBASwebservice_g2pForPronunciation</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForTokenization">runBASwebservice_g2pForTokenization</a>()</code>,
<code><a href="#topic+runBASwebservice_maus">runBASwebservice_maus</a>()</code>,
<code><a href="#topic+runBASwebservice_minni">runBASwebservice_minni</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylCanonical">runBASwebservice_pho2sylCanonical</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylSegmental">runBASwebservice_pho2sylSegmental</a>()</code>
</p>

<hr>
<h2 id='runBASwebservice_g2pForPronunciation'>Creates canonical pronunciation attributes for a tier of tokenized orthographical words.</h2><span id='topic+runBASwebservice_g2pForPronunciation'></span>

<h3>Description</h3>

<p>This function calls the G2P webservice to add canonical pronunciation attributes in SAMPA (default)
or IPA to a tier of tokenized orthographical words. It is usually called after tokenization
with <a href="#topic+runBASwebservice_g2pForTokenization">runBASwebservice_g2pForTokenization</a>. Its output can be used as input to
<a href="#topic+runBASwebservice_maus">runBASwebservice_maus</a> or <a href="#topic+runBASwebservice_chunker">runBASwebservice_chunker</a>.
<strong>This function requires an internet connection.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runBASwebservice_g2pForPronunciation(
  handle,
  orthoAttributeDefinitionName,
  language,
  canoAttributeDefinitionName = "KAN",
  params = list(embed = "maus"),
  patience = 0,
  resume = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runBASwebservice_g2pForPronunciation_+3A_handle">handle</code></td>
<td>
<p>emuDB handle</p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForPronunciation_+3A_orthoattributedefinitionname">orthoAttributeDefinitionName</code></td>
<td>
<p>name of a attribute (not level!) containing orthographic words.</p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForPronunciation_+3A_language">language</code></td>
<td>
<p>language(s) to be used. If you pass a single string (e.g. &quot;deu-DE&quot;), this language will be used for all bundles.
Alternatively, you can select the language for every bundle individually. To do so, you must pass a data frame with the columns
session, bundle, language. This data frame must contain one row for every bundle in your emuDB.
Up-to-date lists of the languages accepted by all webservices can be found here:
<a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a></p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForPronunciation_+3A_canoattributedefinitionname">canoAttributeDefinitionName</code></td>
<td>
<p>attribute name for canonical pronunciations of words</p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForPronunciation_+3A_params">params</code></td>
<td>
<p>named list of parameters to be passed on to the webservice. It is your own responsibility to
ensure that these parameters are compatible with the webservice API
(see <a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a>).
Some options accepted by the API (e.g. output format) cannot be set when calling a webservice from within emuR,
and will be overridden. If file parameters are used please wrap the file path in <code>httr::upload_file("/path/2/file/rules.nrul")</code>.</p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForPronunciation_+3A_patience">patience</code></td>
<td>
<p>If a web service call fails, it is repeated a further n times, with n being the value of patience.
Must be set to a value between 0 and 3.</p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForPronunciation_+3A_resume">resume</code></td>
<td>
<p>If a previous call to this function has failed (and you think you have fixed the issue
that caused the error), you can set resume=TRUE to recover any progress made up to that point. This
will only work if your R temporary directory has not been deleted or emptied in the meantime.</p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForPronunciation_+3A_verbose">verbose</code></td>
<td>
<p>Display progress bars and other information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, G2P is called in MAUS embed mode. This is important if you intend to use MAUS
afterwards. To disable MAUS embed mode, call this function with params=list(embed=&quot;no&quot;).
To derive IPA symbols, add outsym=&quot;ipa&quot; to the parameter list.
</p>


<h3>See Also</h3>

<p>Other BAS webservice functions: 
<code><a href="#topic+runBASwebservice_all">runBASwebservice_all</a>()</code>,
<code><a href="#topic+runBASwebservice_chunker">runBASwebservice_chunker</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForTokenization">runBASwebservice_g2pForTokenization</a>()</code>,
<code><a href="#topic+runBASwebservice_maus">runBASwebservice_maus</a>()</code>,
<code><a href="#topic+runBASwebservice_minni">runBASwebservice_minni</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylCanonical">runBASwebservice_pho2sylCanonical</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylSegmental">runBASwebservice_pho2sylSegmental</a>()</code>
</p>

<hr>
<h2 id='runBASwebservice_g2pForTokenization'>Tokenizes an orthographic transcription.</h2><span id='topic+runBASwebservice_g2pForTokenization'></span>

<h3>Description</h3>

<p>This function calls the webservice G2P to break up a transcription into tokens, or words.
In addition to tokenization, G2P performs normalization of numbers and other special words.
A call to this function is usually followed by a call to <a href="#topic+runBASwebservice_g2pForPronunciation">runBASwebservice_g2pForPronunciation</a>.
<strong>This function requires an internet connection.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runBASwebservice_g2pForTokenization(
  handle,
  transcriptionAttributeDefinitionName,
  language,
  orthoAttributeDefinitionName = "ORT",
  params = list(),
  patience = 0,
  resume = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runBASwebservice_g2pForTokenization_+3A_handle">handle</code></td>
<td>
<p>emuDB handle</p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForTokenization_+3A_transcriptionattributedefinitionname">transcriptionAttributeDefinitionName</code></td>
<td>
<p>name of the attribute (not level!) containing an orthographic transcription.</p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForTokenization_+3A_language">language</code></td>
<td>
<p>language(s) to be used. If you pass a single string (e.g. &quot;deu-DE&quot;), this language will be used for all bundles.
Alternatively, you can select the language for every bundle individually. To do so, you must pass a data frame with the columns
session, bundle, language. This data frame must contain one row for every bundle in your emuDB.
Up-to-date lists of the languages accepted by all webservices can be found here:
<a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a></p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForTokenization_+3A_orthoattributedefinitionname">orthoAttributeDefinitionName</code></td>
<td>
<p>attribute name for orthographic words</p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForTokenization_+3A_params">params</code></td>
<td>
<p>named list of parameters to be passed on to the webservice. It is your own responsibility to
ensure that these parameters are compatible with the webservice API
(see <a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a>).
Some options accepted by the API (e.g. output format) cannot be set when calling a webservice from within emuR,
and will be overridden. If file parameters are used please wrap the file path in <code>httr::upload_file("/path/2/file/rules.nrul")</code>.</p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForTokenization_+3A_patience">patience</code></td>
<td>
<p>If a web service call fails, it is repeated a further n times, with n being the value of patience.
Must be set to a value between 0 and 3.</p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForTokenization_+3A_resume">resume</code></td>
<td>
<p>If a previous call to this function has failed (and you think you have fixed the issue
that caused the error), you can set resume=TRUE to recover any progress made up to that point. This
will only work if your R temporary directory has not been deleted or emptied in the meantime.</p>
</td></tr>
<tr><td><code id="runBASwebservice_g2pForTokenization_+3A_verbose">verbose</code></td>
<td>
<p>Display progress bars and other information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All necessary level, link and attribute definitions are created in the process.
</p>


<h3>See Also</h3>

<p>Other BAS webservice functions: 
<code><a href="#topic+runBASwebservice_all">runBASwebservice_all</a>()</code>,
<code><a href="#topic+runBASwebservice_chunker">runBASwebservice_chunker</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForPronunciation">runBASwebservice_g2pForPronunciation</a>()</code>,
<code><a href="#topic+runBASwebservice_maus">runBASwebservice_maus</a>()</code>,
<code><a href="#topic+runBASwebservice_minni">runBASwebservice_minni</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylCanonical">runBASwebservice_pho2sylCanonical</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylSegmental">runBASwebservice_pho2sylSegmental</a>()</code>
</p>

<hr>
<h2 id='runBASwebservice_maus'>Runs MAUS webservice to create a phonetic segmentation</h2><span id='topic+runBASwebservice_maus'></span>

<h3>Description</h3>

<p>This function calls the BAS webservice MAUS to generate a phonemic segmentation.
It requires a word-tokenized tier with a SAMPA pronunciation, which can be generated
by the function <a href="#topic+runBASwebservice_g2pForPronunciation">runBASwebservice_g2pForPronunciation</a>.
<strong>This function requires an internet connection.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runBASwebservice_maus(
  handle,
  canoAttributeDefinitionName,
  language,
  mausAttributeDefinitionName = "MAU",
  chunkLevel = NULL,
  turnChunkLevelIntoItemLevel = TRUE,
  params = NULL,
  perspective = "default",
  patience = 0,
  resume = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runBASwebservice_maus_+3A_handle">handle</code></td>
<td>
<p>emuDB handle</p>
</td></tr>
<tr><td><code id="runBASwebservice_maus_+3A_canoattributedefinitionname">canoAttributeDefinitionName</code></td>
<td>
<p>name of the attribute (not level!) containing the SAMPA word pronunciations.
If this attribute resides on a segment level, the segment time information is used as a presegmentation.
If it is an item level, no assumption is made about the temporal position of segments.</p>
</td></tr>
<tr><td><code id="runBASwebservice_maus_+3A_language">language</code></td>
<td>
<p>language(s) to be used. If you pass a single string (e.g. &quot;deu-DE&quot;), this language will be used for all bundles.
Alternatively, you can select the language for every bundle individually. To do so, you must pass a data frame with the columns
session, bundle, language. This data frame must contain one row for every bundle in your emuDB.
Up-to-date lists of the languages accepted by all webservices can be found here:
<a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a></p>
</td></tr>
<tr><td><code id="runBASwebservice_maus_+3A_mausattributedefinitionname">mausAttributeDefinitionName</code></td>
<td>
<p>attribute name for the MAUS segmentation</p>
</td></tr>
<tr><td><code id="runBASwebservice_maus_+3A_chunklevel">chunkLevel</code></td>
<td>
<p>if you have a chunk segmentation level, you can provide it to improve the speed and accuracy
of MAUS. The chunk segmentation level must be a segment level, and it must link to the level of canoAttributeDefinitionName.</p>
</td></tr>
<tr><td><code id="runBASwebservice_maus_+3A_turnchunklevelintoitemlevel">turnChunkLevelIntoItemLevel</code></td>
<td>
<p>if TRUE, and if a chunk level is provided, the chunk level is converted into an ITEM level after segmentation</p>
</td></tr>
<tr><td><code id="runBASwebservice_maus_+3A_params">params</code></td>
<td>
<p>named list of parameters to be passed on to the webservice. It is your own responsibility to
ensure that these parameters are compatible with the webservice API
(see <a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a>).
Some options accepted by the API (e.g. output format) cannot be set when calling a webservice from within emuR,
and will be overridden. If file parameters are used please wrap the file path in <code>httr::upload_file("/path/2/file/rules.nrul")</code>.</p>
</td></tr>
<tr><td><code id="runBASwebservice_maus_+3A_perspective">perspective</code></td>
<td>
<p>the webApp perspective that the new level will be added to.
If NULL, the new level is not added to any perspectives.</p>
</td></tr>
<tr><td><code id="runBASwebservice_maus_+3A_patience">patience</code></td>
<td>
<p>If a web service call fails, it is repeated a further n times, with n being the value of patience.
Must be set to a value between 0 and 3.</p>
</td></tr>
<tr><td><code id="runBASwebservice_maus_+3A_resume">resume</code></td>
<td>
<p>If a previous call to this function has failed (and you think you have fixed the issue
that caused the error), you can set resume=TRUE to recover any progress made up to that point. This
will only work if your R temporary directory has not been deleted or emptied in the meantime.</p>
</td></tr>
<tr><td><code id="runBASwebservice_maus_+3A_verbose">verbose</code></td>
<td>
<p>Display progress bars and other information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All necessary level, link and attribute definitions are created in the process.
</p>


<h3>See Also</h3>

<p>Other BAS webservice functions: 
<code><a href="#topic+runBASwebservice_all">runBASwebservice_all</a>()</code>,
<code><a href="#topic+runBASwebservice_chunker">runBASwebservice_chunker</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForPronunciation">runBASwebservice_g2pForPronunciation</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForTokenization">runBASwebservice_g2pForTokenization</a>()</code>,
<code><a href="#topic+runBASwebservice_minni">runBASwebservice_minni</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylCanonical">runBASwebservice_pho2sylCanonical</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylSegmental">runBASwebservice_pho2sylSegmental</a>()</code>
</p>

<hr>
<h2 id='runBASwebservice_minni'>Creates a rough phonetic segmentation by running the phoneme decoder webservice MINNI.</h2><span id='topic+runBASwebservice_minni'></span>

<h3>Description</h3>

<p>The MINNI phoneme decoder performs phoneme-based decoding on the signal without input from
the transcription. Therefore, labelling quality is usually worse than that obtained from
MAUS (<a href="#topic+runBASwebservice_maus">runBASwebservice_maus</a>). Contrary to MAUS however, there is no need for a
pre-existing transcription.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runBASwebservice_minni(
  handle,
  language,
  minniAttributeDefinitionName = "MINNI",
  rootLevel = NULL,
  params = list(),
  perspective = "default",
  patience = 0,
  resume = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runBASwebservice_minni_+3A_handle">handle</code></td>
<td>
<p>emuDB handle</p>
</td></tr>
<tr><td><code id="runBASwebservice_minni_+3A_language">language</code></td>
<td>
<p>language(s) to be used. If you pass a single string (e.g. &quot;deu-DE&quot;), this language will be used for all bundles.
Alternatively, you can select the language for every bundle individually. To do so, you must pass a data frame with the columns
session, bundle, language. This data frame must contain one row for every bundle in your emuDB.
Up-to-date lists of the languages accepted by all webservices can be found here:
<a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a></p>
</td></tr>
<tr><td><code id="runBASwebservice_minni_+3A_minniattributedefinitionname">minniAttributeDefinitionName</code></td>
<td>
<p>attribute name for the MINNI segmentation</p>
</td></tr>
<tr><td><code id="runBASwebservice_minni_+3A_rootlevel">rootLevel</code></td>
<td>
<p>if provided, the new level will be linked to the root level</p>
</td></tr>
<tr><td><code id="runBASwebservice_minni_+3A_params">params</code></td>
<td>
<p>named list of parameters to be passed on to the webservice. It is your own responsibility to
ensure that these parameters are compatible with the webservice API
(see <a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a>).
Some options accepted by the API (e.g. output format) cannot be set when calling a webservice from within emuR,
and will be overridden. If file parameters are used please wrap the file path in <code>httr::upload_file("/path/2/file/rules.nrul")</code>.</p>
</td></tr>
<tr><td><code id="runBASwebservice_minni_+3A_perspective">perspective</code></td>
<td>
<p>the webApp perspective that the new level will be added to.
If NULL, the new level is not added to any perspectives.</p>
</td></tr>
<tr><td><code id="runBASwebservice_minni_+3A_patience">patience</code></td>
<td>
<p>If a web service call fails, it is repeated a further n times, with n being the value of patience.
Must be set to a value between 0 and 3.</p>
</td></tr>
<tr><td><code id="runBASwebservice_minni_+3A_resume">resume</code></td>
<td>
<p>If a previous call to this function has failed (and you think you have fixed the issue
that caused the error), you can set resume=TRUE to recover any progress made up to that point. This
will only work if your R temporary directory has not been deleted or emptied in the meantime.</p>
</td></tr>
<tr><td><code id="runBASwebservice_minni_+3A_verbose">verbose</code></td>
<td>
<p>Display progress bars and other information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All necessary level, link and attribute definitions are created in the process.
</p>


<h3>See Also</h3>

<p>Other BAS webservice functions: 
<code><a href="#topic+runBASwebservice_all">runBASwebservice_all</a>()</code>,
<code><a href="#topic+runBASwebservice_chunker">runBASwebservice_chunker</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForPronunciation">runBASwebservice_g2pForPronunciation</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForTokenization">runBASwebservice_g2pForTokenization</a>()</code>,
<code><a href="#topic+runBASwebservice_maus">runBASwebservice_maus</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylCanonical">runBASwebservice_pho2sylCanonical</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylSegmental">runBASwebservice_pho2sylSegmental</a>()</code>
</p>

<hr>
<h2 id='runBASwebservice_pho2sylCanonical'>Adds syllabified word labels to a word level that already contains canonical pronunciations.</h2><span id='topic+runBASwebservice_pho2sylCanonical'></span>

<h3>Description</h3>

<p>This function calls the webservice Pho2Syl to add syllabified canonical pronunciation labels
to a word level that already contains unsyllabified canonical pronunciation labels (as can be
derived using <a href="#topic+runBASwebservice_g2pForPronunciation">runBASwebservice_g2pForPronunciation</a>). <strong>This function requires an internet
connection.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runBASwebservice_pho2sylCanonical(
  handle,
  canoAttributeDefinitionName,
  language,
  canoSylAttributeDefinitionName = "KAS",
  params = list(),
  patience = 0,
  resume = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runBASwebservice_pho2sylCanonical_+3A_handle">handle</code></td>
<td>
<p>emuDB handle</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylCanonical_+3A_canoattributedefinitionname">canoAttributeDefinitionName</code></td>
<td>
<p>name of the attribute (not level!) containing a canonical pronunciation of the words.</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylCanonical_+3A_language">language</code></td>
<td>
<p>language(s) to be used. If you pass a single string (e.g. &quot;deu-DE&quot;), this language will be used for all bundles.
Alternatively, you can select the language for every bundle individually. To do so, you must pass a data frame with the columns
session, bundle, language. This data frame must contain one row for every bundle in your emuDB.
Up-to-date lists of the languages accepted by all webservices can be found here:
<a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a></p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylCanonical_+3A_canosylattributedefinitionname">canoSylAttributeDefinitionName</code></td>
<td>
<p>attribute name for syllabified canonical pronunciations of words</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylCanonical_+3A_params">params</code></td>
<td>
<p>named list of parameters to be passed on to the webservice. It is your own responsibility to
ensure that these parameters are compatible with the webservice API
(see <a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a>).
Some options accepted by the API (e.g. output format) cannot be set when calling a webservice from within emuR,
and will be overridden. If file parameters are used please wrap the file path in <code>httr::upload_file("/path/2/file/rules.nrul")</code>.</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylCanonical_+3A_patience">patience</code></td>
<td>
<p>If a web service call fails, it is repeated a further n times, with n being the value of patience.
Must be set to a value between 0 and 3.</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylCanonical_+3A_resume">resume</code></td>
<td>
<p>If a previous call to this function has failed (and you think you have fixed the issue
that caused the error), you can set resume=TRUE to recover any progress made up to that point. This
will only work if your R temporary directory has not been deleted or emptied in the meantime.</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylCanonical_+3A_verbose">verbose</code></td>
<td>
<p>Display progress bars and other information</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other BAS webservice functions: 
<code><a href="#topic+runBASwebservice_all">runBASwebservice_all</a>()</code>,
<code><a href="#topic+runBASwebservice_chunker">runBASwebservice_chunker</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForPronunciation">runBASwebservice_g2pForPronunciation</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForTokenization">runBASwebservice_g2pForTokenization</a>()</code>,
<code><a href="#topic+runBASwebservice_maus">runBASwebservice_maus</a>()</code>,
<code><a href="#topic+runBASwebservice_minni">runBASwebservice_minni</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylSegmental">runBASwebservice_pho2sylSegmental</a>()</code>
</p>

<hr>
<h2 id='runBASwebservice_pho2sylSegmental'>Creates a syllable segmentation on the basis of a phonetic segmentation.</h2><span id='topic+runBASwebservice_pho2sylSegmental'></span>

<h3>Description</h3>

<p>This function calls the BAS webservice Pho2Syl to create a syllable segmentation on the basis
of a phonetic segmentation (created by, for example, <a href="#topic+runBASwebservice_maus">runBASwebservice_maus</a>).
You can provide the level of your word segmentation, or of any other hierarchically
dominant segmentation, via the superLevel parameter. This way, the new syllable
items can be linked up into the pre-existing hierarchy. If you do not provide
this input, the syllables will only be linked down to the segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runBASwebservice_pho2sylSegmental(
  handle,
  segmentAttributeDefinitionName,
  language,
  superLevel = NULL,
  sylAttributeDefinitionName = "MAS",
  params = list(wsync = "yes"),
  perspective = "default",
  patience = 0,
  resume = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runBASwebservice_pho2sylSegmental_+3A_handle">handle</code></td>
<td>
<p>emuDB handle</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylSegmental_+3A_segmentattributedefinitionname">segmentAttributeDefinitionName</code></td>
<td>
<p>name of the attribute (not level!) containing a phonetic segmentation.</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylSegmental_+3A_language">language</code></td>
<td>
<p>language(s) to be used. If you pass a single string (e.g. &quot;deu-DE&quot;), this language will be used for all bundles.
Alternatively, you can select the language for every bundle individually. To do so, you must pass a data frame with the columns
session, bundle, language. This data frame must contain one row for every bundle in your emuDB.
Up-to-date lists of the languages accepted by all webservices can be found here:
<a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a></p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylSegmental_+3A_superlevel">superLevel</code></td>
<td>
<p>name of the segments' parent level (typically the word level).
If set to NULL, the syllable level cannot be linked up.</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylSegmental_+3A_sylattributedefinitionname">sylAttributeDefinitionName</code></td>
<td>
<p>attribute name for syllable segmentation</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylSegmental_+3A_params">params</code></td>
<td>
<p>named list of parameters to be passed on to the webservice. It is your own responsibility to
ensure that these parameters are compatible with the webservice API
(see <a href="https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help">https://clarin.phonetik.uni-muenchen.de/BASWebServices/services/help</a>).
Some options accepted by the API (e.g. output format) cannot be set when calling a webservice from within emuR,
and will be overridden. If file parameters are used please wrap the file path in <code>httr::upload_file("/path/2/file/rules.nrul")</code>.</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylSegmental_+3A_perspective">perspective</code></td>
<td>
<p>the webApp perspective that the new level will be added to.
If NULL, the new level is not added to any perspectives.</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylSegmental_+3A_patience">patience</code></td>
<td>
<p>If a web service call fails, it is repeated a further n times, with n being the value of patience.
Must be set to a value between 0 and 3.</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylSegmental_+3A_resume">resume</code></td>
<td>
<p>If a previous call to this function has failed (and you think you have fixed the issue
that caused the error), you can set resume=TRUE to recover any progress made up to that point. This
will only work if your R temporary directory has not been deleted or emptied in the meantime.</p>
</td></tr>
<tr><td><code id="runBASwebservice_pho2sylSegmental_+3A_verbose">verbose</code></td>
<td>
<p>Display progress bars and other information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All necessary level, link and parameter definitions are created in the process.
By default, Pho2Syl is run in word synchronized mode. To override this, call this function
with the parameter params=list(wsync=&quot;no&quot;).
</p>


<h3>See Also</h3>

<p>Other BAS webservice functions: 
<code><a href="#topic+runBASwebservice_all">runBASwebservice_all</a>()</code>,
<code><a href="#topic+runBASwebservice_chunker">runBASwebservice_chunker</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForPronunciation">runBASwebservice_g2pForPronunciation</a>()</code>,
<code><a href="#topic+runBASwebservice_g2pForTokenization">runBASwebservice_g2pForTokenization</a>()</code>,
<code><a href="#topic+runBASwebservice_maus">runBASwebservice_maus</a>()</code>,
<code><a href="#topic+runBASwebservice_minni">runBASwebservice_minni</a>()</code>,
<code><a href="#topic+runBASwebservice_pho2sylCanonical">runBASwebservice_pho2sylCanonical</a>()</code>
</p>

<hr>
<h2 id='segmentlist'>Segment list</h2><span id='topic+segmentlist'></span><span id='topic+emusegs'></span>

<h3>Description</h3>

<p>A segment list is the result type of legacy Emu query.
</p>


<h3>Format</h3>

<p>multi-columned matrix one row per segment 
</p>
 
<ul>
<li><p> columnlabel 
</p>
</li>
<li><p> columnsegment onset time 
</p>
</li>
<li><p> columnsegment offset time 
</p>
</li>
<li><p> columnutterance name 
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+query">query</a></code>, <code><a href="#topic+demo.vowels">demo.vowels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   data(demo.vowels)
   
   #demo.vowels is a segment list
   demo.vowels

</code></pre>

<hr>
<h2 id='serve'>Serve EMU database to EMU-webApp</h2><span id='topic+serve'></span>

<h3>Description</h3>

<p>Serves emuDB media files, SSFF tracks and annotations for 
EMU-webApp browser GUI <a href="http://ips-lmu.github.io/EMU-webApp/">http://ips-lmu.github.io/EMU-webApp/</a>
</p>
<p>Instructions:
</p>
<p>Start and connect (this should happen automatically):
</p>

<ul>
<li><p> Call this function to start the server.
</p>
</li>
<li><p> Start a suitable HTML5 capable Web-Browser (Google Chrome, Firefox,...).
</p>
</li>
<li><p> Navigate to the EMU-Webapp URL: <a href="http://ips-lmu.github.io/EMU-webApp/">http://ips-lmu.github.io/EMU-webApp/</a>.
</p>
</li>
<li><p> Press the 'Connect' button in the EMU-webApp and connect with default URL.
</p>
</li>
<li><p> EMU-webApp loads the bundle list and the first 
bundles media file, SSFF tracks and annotations.
</p>
</li></ul>

<p>Disconnect and stop:
</p>

<ul>
<li><p> Disconnect and stop the server with the 'Clear' button of 
the webapp or the reload button of your browser.
</p>
</li>
<li><p> The server can also be stopped by 
calling <code><a href="httpuv.html#topic+stopAllServers">stopAllServers</a></code> of the <a href="httpuv.html#topic+httpuv">httpuv</a> package
</p>
</li></ul>

<p>Hints:
</p>

<ul>
<li><p> To serve only a subset of sessions or bundles use 
the parameters <code>sessionPattern</code> and/or <code>bundlePattern</code>.
</p>
</li>
<li><p> Use the <code>seglist</code> parameter to pass in a segment list
which was generated using the <code>query</code> function. This will
allow quick navigation to those segments.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>serve(
  emuDBhandle,
  sessionPattern = ".*",
  bundlePattern = ".*",
  seglist = NULL,
  bundleListName = NULL,
  host = "127.0.0.1",
  port = 17890,
  autoOpenURL = "https://ips-lmu.github.io/EMU-webApp/?autoConnect=true",
  browser = getOption("browser"),
  useViewer = TRUE,
  debug = FALSE,
  debugLevel = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serve_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="serve_+3A_sessionpattern">sessionPattern</code></td>
<td>
<p>A regular expression pattern matching session names to be served</p>
</td></tr>
<tr><td><code id="serve_+3A_bundlepattern">bundlePattern</code></td>
<td>
<p>A regular expression pattern matching bundle names to be served</p>
</td></tr>
<tr><td><code id="serve_+3A_seglist">seglist</code></td>
<td>
<p>segment list to use for times anchors and session + bundle restriction (type: <a href="#topic+emuRsegs">emuRsegs</a>)</p>
</td></tr>
<tr><td><code id="serve_+3A_bundlelistname">bundleListName</code></td>
<td>
<p>name of bundleList stored in emuDB/bundleLists subdir to send to EMU-webApp</p>
</td></tr>
<tr><td><code id="serve_+3A_host">host</code></td>
<td>
<p>host IP to listen to (default: 127.0.0.1  (localhost))</p>
</td></tr>
<tr><td><code id="serve_+3A_port">port</code></td>
<td>
<p>the port number to listen on (default: 17890)</p>
</td></tr>
<tr><td><code id="serve_+3A_autoopenurl">autoOpenURL</code></td>
<td>
<p>URL passed to <code><a href="utils.html#topic+browseURL">browseURL</a></code> function. If NULL or an empty string are passed in
<code><a href="utils.html#topic+browseURL">browseURL</a></code> will not be invoked.</p>
</td></tr>
<tr><td><code id="serve_+3A_browser">browser</code></td>
<td>
<p>argument passed on to <code>browser</code> argument of <code><a href="utils.html#topic+browseURL">browseURL</a></code> (see 
it's documentation for details )</p>
</td></tr>
<tr><td><code id="serve_+3A_useviewer">useViewer</code></td>
<td>
<p>Use the viewer provided by <code>getOption("viewer")</code> (the viewer pane when using RStudio) 
and host a local version of the EMU-webApp in it. This will clone the current 
EMU-webApp build (<a href="https://github.com/IPS-LMU/EMU-webApp/tree/gh-pages/">https://github.com/IPS-LMU/EMU-webApp/tree/gh-pages/</a>) into the directory provided by 
<code><a href="base.html#topic+tempdir">tempdir</a></code> and serve this local version. A clone will 
only be performed if no <code>file.path(tempdir(), "EMU-webApp")</code> directory is present. An alternative
directory can be also set: <code>options(emuR.emuWebApp.dir="path/to/EMU-webApp")</code> (use if offline functionality is required).</p>
</td></tr>
<tr><td><code id="serve_+3A_debug">debug</code></td>
<td>
<p>TRUE to enable debugging (default: no debugging messages)</p>
</td></tr>
<tr><td><code id="serve_+3A_debuglevel">debugLevel</code></td>
<td>
<p>integer higher values generate more detailed debug output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function opens a HTTP/websocket and waits in a loop for browser requests. 
Parameter host determines the IP address(es) of hosts allowed to connect to the 
server. By default the server only listens to localhost. If you want to allow 
connection from any host set the host parameter to <code>0.0.0.0</code>. Please note 
that this might be an safety issue! The <code>port</code> parameter determines the port 
the server listens on. The <code>host</code> and <code>port</code> parameters are intended 
only for expert users. When started the R console will be blocked. On successful 
connection the server sends the session and bundle list of the database referenced 
by name by parameter <code>dbName</code> or by UUID parameter <code>dbUUID</code>.
The Web application requests bundle data for viewing or editing. If a bundle 
is modified with the EMU-webApp and the save button is pressed the server modifies 
the internal database and saves the changes to disk.
Communication between server and EMU webApp is defined by EMU-webApp-websocket-protocol 
version 0.0.2 (<a href="https://ips-lmu.github.io/The-EMU-SDMS-Manual/app-chap-wsProtocol.html">https://ips-lmu.github.io/The-EMU-SDMS-Manual/app-chap-wsProtocol.html</a>).
</p>


<h3>Value</h3>

<p>TRUE (invisible) if the server was started
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
## Load EMU database 'myDb' and serve it to the EMU-webApp (opens default HTTP/websocket port 17890)

myDb = load_emuDB("/path/to/myDb")
serve(myDb)

## End(Not run)

</code></pre>

<hr>
<h2 id='SetGetlevelCanvasesOrder'>Set / Get level canvases order of emuDB</h2><span id='topic+SetGetlevelCanvasesOrder'></span><span id='topic+set_levelCanvasesOrder'></span><span id='topic+get_levelCanvasesOrder'></span>

<h3>Description</h3>

<p>Set / Get which levels of an emuDB to display as level canvases (in a 
given perspective of the EMU-webApp),
and in what order. Level canvases refer to levels of 
the type &quot;SEGMENT&quot; or &quot;EVENT&quot; that are displayed by the EMU-webApp. Levels 
of type &quot;ITEM&quot; can always be displayed using the hierarchy view of the
web application but can not be displayed as level canvases.
For more information on the structural elements of an emuDB 
see <code>vignette{emuDB}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_levelCanvasesOrder(emuDBhandle, perspectiveName, order)

get_levelCanvasesOrder(emuDBhandle, perspectiveName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SetGetlevelCanvasesOrder_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="SetGetlevelCanvasesOrder_+3A_perspectivename">perspectiveName</code></td>
<td>
<p>name of perspective</p>
</td></tr>
<tr><td><code id="SetGetlevelCanvasesOrder_+3A_order">order</code></td>
<td>
<p>character vector containing names of levelDefinitions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

# get level canvases order of ae emuDB
order = get_levelCanvasesOrder(emuDBhandle = ae,
                               perspectiveName = "default")

# reverse the level canvases order of ae emuDB
set_levelCanvasesOrder(emuDBhandle = ae,
                       perspectiveName = "default",
                       order = rev(order))
                       
# get level canvases order of ae emuDB                       
get_levelCanvasesOrder(emuDBhandle = ae,
                       perspectiveName = "default")

## End(Not run)

</code></pre>

<hr>
<h2 id='SetGetRemoveLegalLabels'>Set / Get / Remove legal labels of attributeDefinition of emuDB</h2><span id='topic+SetGetRemoveLegalLabels'></span><span id='topic+set_legalLabels'></span><span id='topic+get_legalLabels'></span><span id='topic+remove_legalLabels'></span>

<h3>Description</h3>

<p>Set / Get / Remove legal labels of a specific attributeDefinition of a emuDB. 
The legal labels are a character vector of strings
that specifies the labels that are legal (i.e. allowed / valid) for the given attribute. 
As the EMU-webApp won't allow the annotator to enter any labels that are not 
specified in this array, this is a simple way of assuring that a level 
has a consistent label set. For more information 
on the structural elements of an emuDB see <code>vignette(emuDB)</code>.
Note that defining legal labels for an attributeDefinition does not imply that the 
existing labels are checked for being 'legal' in the emuDB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_legalLabels(emuDBhandle, levelName, attributeDefinitionName, legalLabels)

get_legalLabels(emuDBhandle, levelName, attributeDefinitionName)

remove_legalLabels(emuDBhandle, levelName, attributeDefinitionName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SetGetRemoveLegalLabels_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="SetGetRemoveLegalLabels_+3A_levelname">levelName</code></td>
<td>
<p>name of level</p>
</td></tr>
<tr><td><code id="SetGetRemoveLegalLabels_+3A_attributedefinitionname">attributeDefinitionName</code></td>
<td>
<p>name of attributeDefinition (can be and often is the level name)</p>
</td></tr>
<tr><td><code id="SetGetRemoveLegalLabels_+3A_legallabels">legalLabels</code></td>
<td>
<p>character vector of labels</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

legalPhoneticLabels = c("V", "m", "N", "s", "t", "H", "@:", "f", "r", 
                        "E", "n", "z", "S", "i:", "w", "@", "k", "I", "d", 
                        "db", "j", "u:", "dH", "l", "ai", "O", "D", "o:", "v")

# set legal labels of the 
# default "Phonetic" attributeDefinition of
# the "Phonetic" level of ae emuDB
set_legalLabels(emuDBhandle = ae, 
                levelName = "Phonetic",
                attributeDefinitionName = "Phonetic",
                legalLabels = legalPhoneticLabels)

# get legal labels of the 
# default "Phonetic" attributeDefinition of
# the "Phonetic" level of ae emuDB
get_legalLabels(emuDBhandle = ae, 
                levelName = "Phonetic", 
                attributeDefinitionName = "Phonetic")
                

# remove legal labels of the 
# default "Phonetic" attributeDefinition of
# the "Phonetic" level of ae emuDB
remove_legalLabels(emuDBhandle = ae, 
                   levelName = "Phonetic", 
                   attributeDefinitionName = "Phonetic")
                

## End(Not run)

</code></pre>

<hr>
<h2 id='SetGetSignalCanvasesOrder'>Set / Get signalCanvasesOrder of / to / from emuDB</h2><span id='topic+SetGetSignalCanvasesOrder'></span><span id='topic+set_signalCanvasesOrder'></span><span id='topic+get_signalCanvasesOrder'></span>

<h3>Description</h3>

<p>Set / Get signalCanvasesOrder array that specifies which signals are 
displayed in the according perspective by the EMU-webApp. An entry in this character vector 
refers to either the name of an ssffTrackDefinition or a predefined string: <code>"OSCI"</code> which 
represents the oscillogram or <code>"SPEC"</code> which represents the 
spectrogram. For more information on the structural elements of an emuDB 
see <code>vignette{emuDB}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_signalCanvasesOrder(emuDBhandle, perspectiveName, order)

get_signalCanvasesOrder(emuDBhandle, perspectiveName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SetGetSignalCanvasesOrder_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="SetGetSignalCanvasesOrder_+3A_perspectivename">perspectiveName</code></td>
<td>
<p>name of perspective</p>
</td></tr>
<tr><td><code id="SetGetSignalCanvasesOrder_+3A_order">order</code></td>
<td>
<p>character vector containing names of ssffTrackDefinitions or &quot;OSCI&quot; / &quot;SPEC&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################
# prerequisite: loaded ae emuDB 
# (see ?load_emuDB for more information)

# get signal canvas order of the "default"
# perspective of the ae emuDB
get_signalCanvasesOrder(emuDBhandle = ae, 
                        perspectiveName = "default")
                        

## End(Not run)

</code></pre>

<hr>
<h2 id='shift'>Function to shift the elements of a vector.</h2><span id='topic+shift'></span>

<h3>Description</h3>

<p>The function makes use of the function 'filter' to delay or advance a
signal by k points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift(x, delta = 1, circular = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="shift_+3A_delta">delta</code></td>
<td>
<p>A single element numeric vector. Defines the number of points
by which the signal should be shifted.</p>
</td></tr>
<tr><td><code id="shift_+3A_circular">circular</code></td>
<td>
<p>Logical. If TRUE, the signal is wrapped around itself so that
if delta = 1, x[n] becomes x[1]. Otherwise, if delta is positive, the same
number of zeros are prepended to the signal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function makes use of the function 'filter' for linear filtering to
carry out the shifting.
</p>


<h3>Value</h3>

<p>The signal shifted by a certain number of points.  ...
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p>filter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vec = 1:10
shift(vec, 2)
shift(vec, -2)
shift(vec, 2, circular=FALSE)



</code></pre>

<hr>
<h2 id='Slope.test'>Slope Test</h2><span id='topic+Slope.test'></span>

<h3>Description</h3>

<p>Tests whether the difference between two or more regression lines is
significant
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Slope.test(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slope.test_+3A_...">...</code></td>
<td>
<p>this function takes any number of two column matrices. The
first column is the y-data (in the case of locus equations, this is the
vowel onset) and the second column is the x-data (in the case of locus
equations, vowel target).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value consists of the following components:
</p>
<table>
<tr><td><code>separate</code></td>
<td>
<p> slope, intercept, r-squared, F-ratio, &quot;d(egrees of)
f(reedom)&quot; and &quot;prob(ability that) line fits data&quot; for the separate data
matrices entered. </p>
</td></tr> <tr><td><code>combined</code></td>
<td>
<p> F-ratio, &quot;d(egrees of) f(reedom)&quot;, and
&quot;Probability of them being DIFFERENT&quot; for the slope and for the intercept
of the combined data.  </p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p> the combined x-data for all the
matrices.  </p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p> the combined y-data for all the matrices.  </p>
</td></tr>
<tr><td><code>mat</code></td>
<td>
<p> the category vectors for the combined data (consists of 1, 0
and -1).  </p>
</td></tr> <tr><td><code>numrows</code></td>
<td>
<p> the number of rows in each matrix.  </p>
</td></tr>
<tr><td><code>numcats</code></td>
<td>
<p> the sum number of matrices entered.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>see E. Pedhazur, Multiple Regression in Behavioral Research
p.436-450, 496-507.
</p>


<h3>See Also</h3>

<p>lm(), summary.lm(), pf()
</p>

<hr>
<h2 id='sort.emuRsegs'>Sort emuRsegs segment list by session, bundle and sample_start</h2><span id='topic+sort.emuRsegs'></span>

<h3>Description</h3>

<p>Sort emuRsegs segment list by session, bundle and sample_start
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emuRsegs'
sort(x, decreasing, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort.emuRsegs_+3A_x">x</code></td>
<td>
<p>object to sort</p>
</td></tr>
<tr><td><code id="sort.emuRsegs_+3A_decreasing">decreasing</code></td>
<td>
<p>NOT IMPLEMENTED!</p>
</td></tr>
<tr><td><code id="sort.emuRsegs_+3A_...">...</code></td>
<td>
<p>additional params</p>
</td></tr>
</table>

<hr>
<h2 id='sortmatrix'>Sort matrix by label</h2><span id='topic+sortmatrix'></span>

<h3>Description</h3>

<p>Sorts matrix by label
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortmatrix(mat, labs = dimnames(mat)[[2]])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortmatrix_+3A_mat">mat</code></td>
<td>
<p>A mu+ segment matrix.</p>
</td></tr>
<tr><td><code id="sortmatrix_+3A_labs">labs</code></td>
<td>
<p>A label vector which has the same number of columns as
<code>mat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a sorted matrix by label, created from <code>mat</code>.
</p>


<h3>See Also</h3>

<p>label, phon
</p>

<hr>
<h2 id='splitstring'>Split a string into words.</h2><span id='topic+splitstring'></span>

<h3>Description</h3>

<p>Splits a string into words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitstring(str, char)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitstring_+3A_str">str</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="splitstring_+3A_char">char</code></td>
<td>
<p>A character to split on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of strings.  The original <code>str</code> is split at ever
occurrence of <code>char</code> to generate a vector of strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
splitstring("/home/recog/steve/foo", "/")
#[1] "home" "recog" "steve" "foo"

</code></pre>

<hr>
<h2 id='start.emusegs'>Start and end times for EMU segment lists and trackdata objects</h2><span id='topic+start.emusegs'></span><span id='topic+end.emusegs'></span><span id='topic+start.trackdata'></span><span id='topic+end.trackdata'></span>

<h3>Description</h3>

<p>Obtain start and end times for EMU segment lists and trackdata objects
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="start.emusegs_+3A_x">x</code></td>
<td>
<p>a segment list or a trackdata object</p>
</td></tr>
<tr><td><code id="start.emusegs_+3A_...">...</code></td>
<td>
<p>due to the generic only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns the start and/or end times of either a segment list or
a trackdata object. The former refers to the boundary times of segments,
the latter the start and end times at which the tracks from segments occur.
start.emusegs and end.emusegs give exactly the same output as start and end
respectively.
</p>


<h3>Value</h3>

<p>A vector of times.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tracktimes">tracktimes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# start time of a segment list
start(polhom)
# duration of a segment list
end(polhom) - start(polhom)
# duration from start time of segment list
# and start time of parallel EPG trackdata
start(polhom) - start(polhom.epg)


</code></pre>

<hr>
<h2 id='summary.emuDBhandle'>Print summary of loaded EMU database (emuDB).</h2><span id='topic+summary.emuDBhandle'></span>

<h3>Description</h3>

<p>Gives an overview of an EMU database.
Prints database name, UUID, base directory path, session and bundle 
count and informations about signal track, annotation level, attribute and link definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emuDBhandle'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.emuDBhandle_+3A_object">object</code></td>
<td>
<p>emuDBhandle as returned by <code><a href="#topic+load_emuDB">load_emuDB</a></code></p>
</td></tr>
<tr><td><code id="summary.emuDBhandle_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.emusegs'>summary emusegs</h2><span id='topic+summary.emusegs'></span>

<h3>Description</h3>

<p>summarizes data in emu segment lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emusegs'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.emusegs_+3A_object">object</code></td>
<td>
<p>the segmentlist</p>
</td></tr>
<tr><td><code id="summary.emusegs_+3A_...">...</code></td>
<td>
<p>nothing special</p>
</td></tr>
</table>

<hr>
<h2 id='summary.trackdata'>summary trackdata</h2><span id='topic+summary.trackdata'></span>

<h3>Description</h3>

<p>summarizes trackdata objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trackdata'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.trackdata_+3A_object">object</code></td>
<td>
<p>track data object</p>
</td></tr>
<tr><td><code id="summary.trackdata_+3A_...">...</code></td>
<td>
<p>see summary</p>
</td></tr>
</table>

<hr>
<h2 id='track.gradinfo'>Calculate gradient summary information for trackdata</h2><span id='topic+track.gradinfo'></span>

<h3>Description</h3>

<p>Calculates a number of summary measures for a trackdata object: duration,
start and end data points, delta values and slope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track.gradinfo(trackdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track.gradinfo_+3A_trackdata">trackdata</code></td>
<td>
<p>An Emu trackdata object as returned by
<code><a href="#topic+get_trackdata">get_trackdata</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>track.gradinfo</code> calculates a number of summary measure for the
segments within a trackdata object.  These are useful for data such as
kinematic measures where segments might correspond to articulatory
movements etc.
</p>
<p>Measures returned are: duration, start and end data values (ie. the first
and last rows of data for each segment), delta (the difference between the
first and last rows of data) and slope (delta divided by the duration).
</p>


<h3>Value</h3>

<p>A data frame with one row per segment and columns:
</p>
<table>
<tr><td><code>duration</code></td>
<td>
<p>Segment</p>
</td></tr> <tr><td><code>startN</code></td>
<td>
<p>The starting value for each segment
(start1 is the starting value for the first column) </p>
</td></tr> <tr><td><code>endN</code></td>
<td>
<p>The
ending value for each segment </p>
</td></tr> <tr><td><code>deltaN</code></td>
<td>
<p>The delta value for each
segment</p>
</td></tr> <tr><td><code>slopeN</code></td>
<td>
<p>The slope value for each segment</p>
</td></tr>
</table>
<p>Since the result is a data frame, the columns can be referred to by name
(<code>result$duration</code>) or as matrix columns (<code>result[,1]</code>).
</p>


<h3>Author(s)</h3>

<p>Steve Cassidy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_trackdata">get_trackdata</a></code>, <code><a href="#topic+dapply">dapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vowlax)
segs = vowlax
## fm has 4 columns
data.fm &lt;-vowlax.fdat
## F0 has one
data.F0 &lt;- vowlax.fund
## info.fm will have duration, 4xstart, 4xend, 4xdelta, 4xslope
info.fm &lt;- track.gradinfo(data.fm)
## this should be true
ncol(info.fm) == 1+4+4+4+4

## info.F0 will have one of each
info.F0 &lt;- track.gradinfo(data.F0)
## this should be true
ncol(info.F0) == 1+1+1+1+1

## plot the durations vs delta of the first formant
plot(info.F0$duration, info.fm$delta1, type="n", xlab="Duration", ylab="Delta")
text(info.fm$duration, info.fm$delta1, labels=label(segs))

## extract just the delta values from the formant info
## You need to eyeball the data to work out which columns to select
delta.fm &lt;- info.fm[,10:13]

</code></pre>

<hr>
<h2 id='track.gradinfo.sub'>track gradinfo sub</h2><span id='topic+track.gradinfo.sub'></span>

<h3>Description</h3>

<p>see function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track.gradinfo.sub(data, ftime)
</code></pre>

<hr>
<h2 id='trackdata'>Track data object</h2><span id='topic+trackdata'></span><span id='topic+Math.trackdata'></span><span id='topic+Math2.trackdata'></span><span id='topic+Ops.trackdata'></span><span id='topic+Summary.trackdata'></span>

<h3>Description</h3>

<p>A track data object is the result of get_trackdata().
</p>


<h3>Format</h3>

 <dl>
<dt>$index</dt><dd><p>a two columned matrix, each row keeps the
first and last index of the $data rows that belong to one segment</p>
</dd>
<dt>$ftime</dt><dd><p>a two columned matrix, each row keeps the times marks of one
segment</p>
</dd> <dt>$data</dt><dd><p>a multi-columned matrix with the real track values
for each segment</p>
</dd> </dl>



<h3>Methods</h3>

<p>The following generic methods are implemented for
trackdata objects.  </p>
 <dl>
<dt>list(&quot;Arith&quot;)</dt><dd><p><code>"+"</code>, <code>"-"</code>,
<code>"*"</code>, <code>"^"</code>, <code>"%%"</code>, <code>"%/%"</code>, <code>"/"</code></p>
</dd>
<dt>list(&quot;Compare&quot;)</dt><dd><p><code>"=="</code>, <code>"&gt;"</code>, <code>"&lt;"</code>, <code>"!="</code>,
<code>"&lt;="</code>, <code>"&gt;="</code></p>
</dd> <dt>list(&quot;Logic&quot;)</dt><dd><p><code>"&amp;"</code>, <code>"|"</code>.  </p>
</dd>
<dt>list(&quot;Ops&quot;)</dt><dd><p><code>"Arith"</code>, <code>"Compare"</code>, <code>"Logic"</code></p>
</dd>
<dt>list(&quot;Math&quot;)</dt><dd><p><code>"abs"</code>, <code>"sign"</code>, <code>"sqrt"</code>,
<code>"ceiling"</code>, <code>"floor"</code>, <code>"trunc"</code>, X <code>"cummax"</code>,
<code>"cummin"</code>, <code>"cumprod"</code>, <code>"cumsum"</code>, <code>"log"</code>,
<code>"log10"</code>, <code>"log2"</code>, <code>"log1p"</code>, <code>"acos"</code>,
<code>"acosh"</code>, <code>"asin"</code>, <code>"asinh"</code>, <code>"atan"</code>,
<code>"atanh"</code>, <code>"exp"</code>, <code>"expm1"</code>, <code>"cos"</code>, <code>"cosh"</code>,
<code>"sin"</code>, <code>"sinh"</code>, <code>"tan"</code>, <code>"tanh"</code>, <code>"gamma"</code>,
<code>"lgamma"</code>, <code>"digamma"</code>, <code>"trigamma"</code> </p>
</dd>
<dt>list(&quot;Math2&quot;)</dt><dd><p><code>"round"</code>, <code>"signif"</code></p>
</dd>
<dt>list(&quot;Summary&quot;)</dt><dd><p><code>"max"</code>, <code>"min"</code>, <code>"range"</code>,
<code>"prod"</code>, <code>"sum"</code>, <code>"any"</code>, <code>"all"</code></p>
</dd> </dl>



<h3>Note</h3>

<p>The entire data track is retrieved for each segment in the segment
list. The amount of data returned will depend on the sample rate and number
of columns in the track requested.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_trackdata">get_trackdata</a></code>, <code><a href="#topic+demo.vowels.fm">demo.vowels.fm</a></code>
<code><a href="#topic+demo.all.rms">demo.all.rms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   data(demo.vowels.fm)
   data(demo.vowels)
   
   #Formant track data for the first segment of the segment list demo.vowels
   demo.vowels.fm[1]
  

</code></pre>

<hr>
<h2 id='trackfreq'>function to find the frequencies of a spectral object</h2><span id='topic+trackfreq'></span>

<h3>Description</h3>

<p>Find the frequencies of a spectral object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trackfreq(specdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trackfreq_+3A_specdata">specdata</code></td>
<td>
<p>A spectral object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the frequencies at which the columns of a spectral
matrix occur.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
trackfreq(vowlax.dft.5)
# Frequency components between 1000 and 2000 Hz
trackfreq(vowlax.dft.5[,1000:2000])
# All frequency components of a trackdata object except the d.c. offset
trackfreq(fric.dft[,-1])
# All frequency components except the d.c. offset
# and except frequencies above 5000 Hz
trackfreq(fric.dft[,-c(1, 5000:20000)])
# Note the following syntax if the spectral object is a vector
# Frequencies 1000-3000 Hz
trackfreq(e.dft[1000:3000])



</code></pre>

<hr>
<h2 id='tracktimes'>Get the track times from EMU trackdata objects</h2><span id='topic+tracktimes'></span>

<h3>Description</h3>

<p>The function obtains the times at which track values occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracktimes(trackdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tracktimes_+3A_trackdata">trackdata</code></td>
<td>
<p>An EMU trackdata object, or a matrix of track values
obtained at a single time point using dcut()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every $data value in a trackdata object is associated with a time at which
it occurs in the utterance. This function returns those times.
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start.trackdata">start.trackdata</a></code> <code><a href="#topic+end.trackdata">end.trackdata</a></code>
<code><a href="#topic+start.emusegs">start.emusegs</a></code> <code><a href="#topic+end.emusegs">end.emusegs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# track time values for a trackdata object
times &lt;- tracktimes(vowlax.fdat)
# track time values for a matrix of trackdata values
# at  the temporal midpoint
tracktimes(dcut(vowlax.fdat[1:3,], 0.5, prop=TRUE))

</code></pre>

<hr>
<h2 id='train'>Train a Gaussian Model</h2><span id='topic+train'></span>

<h3>Description</h3>

<p>Trains a Gaussian Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train(x, lab = rep("x", nrow(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_+3A_x">x</code></td>
<td>
<p>A data vector or matrix.</p>
</td></tr>
<tr><td><code id="train_+3A_lab">lab</code></td>
<td>
<p>A vector of labels parallel to <code>x</code>. If missing, all data is
assumed to be from the same class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to train a gaussian model on a data set. The result
can be passed to either the <code>mahal</code> or <code>bayes.lab</code> functions to
classify either the training set (<code>x</code>) or a test set with the same
number of dimensions.  Train simply finds the mean and inverse covariance
matrix/standard deviation for the data corresponding to each unique label
in labs.
</p>


<h3>Value</h3>

<p>A structure with the following components:
</p>
<table>
<tr><td><code>label</code></td>
<td>
<p> The unique labels in <code>lab</code>. </p>
</td></tr> <tr><td><code>means</code></td>
<td>
<p> The means
for each dimension per unique label.  </p>
</td></tr> <tr><td><code>cov</code></td>
<td>
<p> The combined covariance
matrixes for each unique label. The matrixes are joined with <code>rbind</code>.
If the input data is one-dimensional, this is just the standard deviation
of the data.  </p>
</td></tr> <tr><td><code>invcov</code></td>
<td>
<p> The combined inverse covariance matrixes for
each unique label. The matrixes are joined with <code>rbind</code>.  If the input
data is one-dimensional, this is just the reciprocal of the standard
deviation of the data. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p>mahal, bayes.lab, mahalplot, bayes.plot
</p>

<hr>
<h2 id='trapply'>A method of the generic function by for objects of class 'trackdata'</h2><span id='topic+trapply'></span>

<h3>Description</h3>

<p>A given function 'FUN' is applied to the data corresponding to each segment
of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trapply(trackdata, fun, ..., simplify = FALSE, returntrack = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trapply_+3A_trackdata">trackdata</code></td>
<td>
<p>a track data object</p>
</td></tr>
<tr><td><code id="trapply_+3A_fun">fun</code></td>
<td>
<p>a function that is applied to each segment</p>
</td></tr>
<tr><td><code id="trapply_+3A_...">...</code></td>
<td>
<p>arguments of the function fun</p>
</td></tr>
<tr><td><code id="trapply_+3A_simplify">simplify</code></td>
<td>
<p>simplify = TRUE , output is a matrix; simplify = FALSE a
list is returned</p>
</td></tr>
<tr><td><code id="trapply_+3A_returntrack">returntrack</code></td>
<td>
<p>returntrack = FALSE , return a trackdata object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>trapply() applies a function iteratively to each segment of a trackdata
object without the need for using a for-loop. It can be used to calculate,
for example, the mean value of the data values of each segment separately.
Any function that can be applied sensibly to trackdata[j]$data where j is
a segment number can be used as the fun argument to trapply(). It is also
possible to write your own function and use trapply() to apply it
separately to each segment. Care needs to be taken in using trapply() in
the following two ways. Firstly, the argument simplify=TRUE should only be set
if it can be guaranteed that a vector of the same length or matrix of the
same number of rows as the number of segments in the trackdata object is
returned. For example, simplify=TRUE can be used in calculating the mean per
segment of a trackdata object, because there will only be one value (the
mean) per segment. However, simplify should be set to FALSE in calculating the
range because here two values are returned per segment. Similarly use
simplify=FALSE n smoothing the data in which the number of values returned per
segment is different.  Secondly, trapply() only applies a function to a
single parameter; the function can be used to apply to a function to
multi-parameter trackdata such as F1-F4, but then the function needs to be
put inside apply() - see examples below.
</p>


<h3>Value</h3>

<p>list or vector or matrix
</p>


<h3>Author(s)</h3>

<p>Jonathan Harrington
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+apply">apply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# mean f0 one value per segment
m = trapply(vowlax.fund, mean, simplify=TRUE)
# mean F1 - F4
m = trapply(vowlax.fdat, apply, 2, mean, simplify=TRUE)
# make a logical vector of any segments that have an F1 value
# between their start time and end time greater than n Hz
pfun &lt;- function(x, n=1000) any(x &gt; n)
# greater than 1100 Hz
temp = trapply(vowlax.fdat[,1], pfun, 1100, simplify=TRUE)
# get the F2-range per segment
r = trapply(vowlax.fdat[,2], range)
# F2-range of 20th segment
r[[20]]
# DCT-smooth F2 with 10 coeffs
# get the first 4 DCT coefficients
f2.dct = trapply(vowlax.fdat[,2], dct, 3, simplify=TRUE)
# dct-smooth F2 with the first 5 DCT coeffs
f2sm = trapply(vowlax.fdat[,2], dct, 4, TRUE,  returntrack=TRUE)
# Make new F2 trackdata such that each segment has
# F2 divided by its F2 range
pfun &lt;- function(x) x/(diff(abs(range(x))))
newf2 = trapply(vowlax.fdat[,2], pfun, returntrack=TRUE)

</code></pre>

<hr>
<h2 id='update_itemsInLevel'>Update items programmatically</h2><span id='topic+update_itemsInLevel'></span>

<h3>Description</h3>

<p>Update annotation items programmatically. You have to pass in a
data frame, called <code>itemsToUpdate</code>, describing the new state of the items.
The required columns are described below.
</p>
<p>This function belongs to emuRs CRUD family of functions, which let the user
manipulate items programmatically:
</p>

<ul>
<li><p> Create items (<a href="#topic+create_itemsInLevel">create_itemsInLevel</a>)
</p>
</li>
<li><p> Read items (<a href="#topic+query">query</a>)
</p>
</li>
<li><p> Update items (<a href="#topic+update_itemsInLevel">update_itemsInLevel</a>)
</p>
</li>
<li><p> Delete items (<a href="#topic+delete_itemsInLevel">delete_itemsInLevel</a>))
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>update_itemsInLevel(
  emuDBhandle,
  itemsToUpdate,
  rewriteAllAnnots = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_itemsInLevel_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle as returned by <a href="#topic+load_emuDB">load_emuDB</a></p>
</td></tr>
<tr><td><code id="update_itemsInLevel_+3A_itemstoupdate">itemsToUpdate</code></td>
<td>
<p>A data frame with the columns:
</p>

<ul>
<li> <p><code>session</code> (character)
</p>
</li>
<li> <p><code>bundle</code> (character)
</p>
</li>
<li> <p><code>level</code> (character)
</p>
</li>
<li> <p><code>start_item_seq_idx</code> (character)
</p>
</li>
<li> <p><code>attribute</code> (character)
</p>
</li>
<li> <p><code>labels</code> (character)
</p>
</li></ul>
</td></tr>
<tr><td><code id="update_itemsInLevel_+3A_rewriteallannots">rewriteAllAnnots</code></td>
<td>
<p>should changes be written to file system (_annot.json
files) (intended for expert use only)</p>
</td></tr>
<tr><td><code id="update_itemsInLevel_+3A_verbose">verbose</code></td>
<td>
<p>if set to <code>TRUE</code>, more status messages are printed</p>
</td></tr>
</table>

<hr>
<h2 id='vowlax'>Segment list of four lax vowels, read speech, one male and one female
speaker of Standard North German from database kielread.</h2><span id='topic+vowlax'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>segmentlist
</p>

<hr>
<h2 id='vowlax.df'>Data frame of various parameters and labels from the segment list vowlax</h2><span id='topic+vowlax.df'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>dataframe
</p>

<hr>
<h2 id='vowlax.dft.5'>Spectral matrix centred at the temporal midpoint of the vowels from the
segment list vowlax.</h2><span id='topic+vowlax.dft.5'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>spectral matrix
</p>

<hr>
<h2 id='vowlax.fdat'>Trackdata of formants from the segment list vowlax</h2><span id='topic+vowlax.fdat'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>trackdata object
</p>

<hr>
<h2 id='vowlax.fdat.5'>Matrix of formant data extracted at the temporal midpoint from the segment
list vowlax.</h2><span id='topic+vowlax.fdat.5'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>matrix of formant data
</p>

<hr>
<h2 id='vowlax.fund'>Trackdata of fundamental frequency from the segment list vowlax</h2><span id='topic+vowlax.fund'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>trackdata object
</p>

<hr>
<h2 id='vowlax.fund.5'>Vector of fundamental frequency extracted at the temporal midpoint from the
segment list vowlax.</h2><span id='topic+vowlax.fund.5'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of fundamental frequency
</p>

<hr>
<h2 id='vowlax.l'>Vector of phoneme labels from the segment list vowlax</h2><span id='topic+vowlax.l'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of phoneme labels
</p>

<hr>
<h2 id='vowlax.left'>Vector of labels preceding the vowels from the segment list vowlax</h2><span id='topic+vowlax.left'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of phoneme labels
</p>

<hr>
<h2 id='vowlax.right'>Vector of labels following the vowels from the segment list vowlax</h2><span id='topic+vowlax.right'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of phoneme labels
</p>

<hr>
<h2 id='vowlax.rms'>Trackdata of RMS energy from the segment list vowlax</h2><span id='topic+vowlax.rms'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>trackdata object
</p>

<hr>
<h2 id='vowlax.rms.5'>Vector of RMS energy values at the temporal midpoint extracted at the
temporal midpoint from the segment list vowlax</h2><span id='topic+vowlax.rms.5'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of RMS energy values
</p>

<hr>
<h2 id='vowlax.spkr'>Vector of speaker labels from the segment list vowlax.</h2><span id='topic+vowlax.spkr'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of speaker labels
</p>

<hr>
<h2 id='vowlax.word'>Vector of word labels from the segment list vowlax.</h2><span id='topic+vowlax.word'></span>

<h3>Description</h3>

<p>An EMU dataset
</p>


<h3>Format</h3>

<p>vector of word labels
</p>

<hr>
<h2 id='wordlax.l'>Vector of word labels from segment list wordlax</h2><span id='topic+wordlax.l'></span>

<h3>Description</h3>

<p>For wordlax (see data(vowlax))
</p>


<h3>Format</h3>

<p>vector of word labels
</p>

<hr>
<h2 id='write_bundleList'>write bundleList</h2><span id='topic+write_bundleList'></span>

<h3>Description</h3>

<p>write bundleList JSON file to emuDB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_bundleList(
  emuDBhandle,
  name,
  bundleList,
  seglist,
  updateDBconfig = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_bundleList_+3A_emudbhandle">emuDBhandle</code></td>
<td>
<p>emuDB handle object (see <a href="#topic+load_emuDB">load_emuDB</a>)</p>
</td></tr>
<tr><td><code id="write_bundleList_+3A_name">name</code></td>
<td>
<p>name of bundleList (excluding the _bundleList.json suffix)</p>
</td></tr>
<tr><td><code id="write_bundleList_+3A_bundlelist">bundleList</code></td>
<td>
<p>tibble/data.frame with the columns <code>session</code>, <code>name</code>, 
<code>comment</code> (optional), <code>finishedEditing</code> (optional). Use <a href="#topic+list_bundles">list_bundles</a></p>
</td></tr>
<tr><td><code id="write_bundleList_+3A_seglist">seglist</code></td>
<td>
<p>segment list returned by <a href="#topic+query">query</a> function. If set the 
<code>bundleList</code> parameter will be ignored and a bundleList will be created by
collapsing the segments as timeAnchors into the <code>_bundleList.json</code></p>
</td></tr>
<tr><td><code id="write_bundleList_+3A_updatedbconfig">updateDBconfig</code></td>
<td>
<p>if set to TRUE (the default) DBconfig will be updated 
with the fields</p>
</td></tr>
<tr><td><code id="write_bundleList_+3A_verbose">verbose</code></td>
<td>
<p>be verbose
</p>

<ul>
<li> <p><code>"bundleComments": true</code>
</p>
</li>
<li> <p><code>"bundleFinishedEditing": true</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Write bundleList JSON file to emuDB sub-dir <code>bundleLists/</code>
</p>

<hr>
<h2 id='write.emusegs'>Write an Emu segment list to a file</h2><span id='topic+write.emusegs'></span>

<h3>Description</h3>

<p>Writes an Emu segment list to a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.emusegs(seglist, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.emusegs_+3A_seglist">seglist</code></td>
<td>
<p>An Emu segment list</p>
</td></tr>
<tr><td><code id="write.emusegs_+3A_file">file</code></td>
<td>
<p>The name of a file to write the segment list into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Side Effects</h3>

<p>The segment list is written to a file in the
standard format, suitable for input to <code>gettrack</code> or other Emu utility
programs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+query">query</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   data(dip)
   #dip a segment list - first 10 segments only
   dip[1:10,]
   ## Not run: write.emusegs(dip, "write.emusegs.example.txt")
   
   #The file write.emusegs.example.txt would have been written to R_HOME
   ## Not run: unlink("write.emusegs.example.txt")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
