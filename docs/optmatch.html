<!DOCTYPE html><html lang="en"><head><title>Help for package optmatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {optmatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+2B+2CInfinitySparseMatrix+2CInfinitySparseMatrix-method'><p>Element-wise addition</p></a></li>
<li><a href='#antiExactMatch'><p>Specify a matching problem where units in a common factor cannot be matched.</p></a></li>
<li><a href='#as.InfinitySparseMatrix'><p>Convert an object to InfinitySparseMatrix</p></a></li>
<li><a href='#as.list.BlockedInfinitySparseMatrix'><p>Splits a BlockedInfinitySparseMatrix into a list of</p>
InfinitySparseMatrices</a></li>
<li><a href='#BlockedInfinitySparseMatrix-class'><p>Blocked Infinity Sparse Matrix</p></a></li>
<li><a href='#c+2CSubProbInfo-method'><p>Combine objects</p></a></li>
<li><a href='#c.optmatch'><p>Combine Optmatch objects</p></a></li>
<li><a href='#caliper'><p>Prepare matching distances suitable for matching within calipers.</p></a></li>
<li><a href='#caliperSize'><p>(Internal) Determines how many other units fall within a caliper distance</p></a></li>
<li><a href='#caliperUpperBound'><p>(Internal) Returns a reasonable upper bound on the arcs remaining after placing a caliper.</p></a></li>
<li><a href='#cbind.InfinitySparseMatrix'><p>Combine InfinitySparseMatrices or</p>
BlockedInfinitySparseMatrices by row or column</a></li>
<li><a href='#compare_optmatch'><p>Compares the equality of optmatch objects, ignoring attributes and group names.</p></a></li>
<li><a href='#dbind'><p>Diagonally bind together subgroup-specific distances</p></a></li>
<li><a href='#dimnames+2CInfinitySparseMatrix-method'><p>Get and set dimnames for InfinitySparseMatrix objects</p></a></li>
<li><a href='#distUnion'><p>Combine multiple distance specifications into a single distance specification.</p></a></li>
<li><a href='#edgelist'><p>Create EdgeList object</p></a></li>
<li><a href='#effectiveSampleSize'><p>Compute the effective sample size of a match.</p></a></li>
<li><a href='#evaluate_primal'><p>Compute value of primal problem given flows and arc costs</p></a></li>
<li><a href='#exactMatch'><p>Generate an exact matching set of subproblems.</p></a></li>
<li><a href='#fill.NAs'><p>Create missingness indicator variables and non-informatively fill in missing values</p></a></li>
<li><a href='#findSubproblems'><p>List subproblems of a distance</p></a></li>
<li><a href='#fmla2treatedblocking'><p>(Internal) A helper function to turn formulas into treatment and blocking variables</p></a></li>
<li><a href='#fullmatch'><p>Optimal full matching</p></a></li>
<li><a href='#getMaxProblemSize'><p>What is the maximum allowed problem size?</p></a></li>
<li><a href='#hash_dist'><p>(Internal) Hashing functions for various distance objects</p>
#</a></li>
<li><a href='#InfinitySparseMatrix-class'><p>Objects for sparse matching problems.</p></a></li>
<li><a href='#LEMON'><p>(Internal) Helper function for accessing algorithms in LEMON solver</p></a></li>
<li><a href='#makeOptmatch'><p>(Internal) Create <code>optmatch</code> objects, the result of matching.</p></a></li>
<li><a href='#match_on'><p>Create treated to control distances for matching problems</p></a></li>
<li><a href='#match_on_szn_scale'><p>pooled dispersion for a numeric variable</p></a></li>
<li><a href='#matched'><p>Identification of units placed into matched sets</p></a></li>
<li><a href='#matched.distances'><p>Determine distances between matched units</p></a></li>
<li><a href='#maxCaliper'><p>Find the maximum caliper width that will create a feasible problem.</p></a></li>
<li><a href='#maxControlsCap'><p>Set thinning and thickening caps for full matching</p></a></li>
<li><a href='#mdist'><p>(Deprecated, in favor of <code>match_on</code>) Create</p>
matching distances</a></li>
<li><a href='#minExactMatch'><p>Find the minimal exact match factors that will be feasible for a</p>
given maximum problem size.</a></li>
<li><a href='#missing_x_msg'><p>(Internal) If the x argument does not exist for</p>
match_on, fullmatch, or pairmatch, use this function
to print a helpful message.</a></li>
<li><a href='#model.frame.svyglm'><p>This method quells a warning when <code>optmatch::scores()</code></p>
is applied to a svyglm object.</a></li>
<li><a href='#nuclearplants'><p>Nuclear Power Station Construction Data</p></a></li>
<li><a href='#num_eligible_matches'><p>Returns the number of eligible matches for the distance.</p></a></li>
<li><a href='#optmatch'><p>Optmatch Class</p></a></li>
<li><a href='#optmatch_restrictions'><p>optmatch_restrictions</p></a></li>
<li><a href='#optmatch_same_distance'><p>Checks if two distances are equivalent. <code>x</code> and <code>y</code> can be</p>
distances (<code>InfinitySparseMatrix</code>, <code>BlockedInfinitySparseMatrix</code>,
or <code>DenseMatrix</code>), or they can be <code>optmatch</code> objects.</a></li>
<li><a href='#optmatch-defunct'><p>Functions deprecated or removed from optmatch</p></a></li>
<li><a href='#pairmatch'><p>Optimal 1:1 and 1:k matching</p></a></li>
<li><a href='#plantdist'><p>Dissimilarities of Some U.S. Nuclear Plants</p></a></li>
<li><a href='#predict.CBPS'><p>(Internal) Predict for CBPS objects</p></a></li>
<li><a href='#print.optmatch'><p>Printing <code>optmatch</code> objects.</p></a></li>
<li><a href='#revise_ArcInfo_nodelabels'><p>Reset implicit node labels of an ArcInfo object</p></a></li>
<li><a href='#scoreCaliper'><p>(Internal) Helper function to create an InfinitySparseMatrix from a set of</p>
scores, a treatment indicator, and a caliper width.</a></li>
<li><a href='#scores'><p>Extract scores (propensity, prognostic,...) from a fitted model</p></a></li>
<li><a href='#setFeasibilityConstants'><p>(Internal) Sets up the default values for maximum feasible problems</p></a></li>
<li><a href='#setMaxProblemSize'><p>Set the maximum problem size</p></a></li>
<li><a href='#setTryRecovery'><p>(Internal) Sets up option to try recovery in <code>fullmatch</code>.</p></a></li>
<li><a href='#show+2CBlockedInfinitySparseMatrix-method'><p>Displays a BlockedInfinitySparseMatrix</p></a></li>
<li><a href='#show+2CInfinitySparseMatrix-method'><p>Displays an InfinitySparseMatrix</p></a></li>
<li><a href='#sort.InfinitySparseMatrix'><p>Sort the internal structure of an InfinitySparseMatrix.</p></a></li>
<li><a href='#standardization_scale'><p>pooled dispersion for a numeric variable</p></a></li>
<li><a href='#strata'><p>Identify Stratafication Variables</p></a></li>
<li><a href='#stratumStructure'><p>Return structure of matched sets</p></a></li>
<li><a href='#subdim'><p>Returns the dimension of each valid subproblem</p></a></li>
<li><a href='#subproblemSuccess'><p>(Internal) Report successful subproblems.</p></a></li>
<li><a href='#subset.InfinitySparseMatrix'><p>Subsetting for InfinitySparseMatrices</p></a></li>
<li><a href='#summary.ism'><p>Summarize a distance matrix</p></a></li>
<li><a href='#update.optmatch'><p>Performs an update on an <code>optmatch</code> object.</p></a></li>
<li><a href='#validDistanceSpecification'><p>(Internal) Validate that objects are valid distance specifications.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.10.8</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Optimal Matching</td>
</tr>
<tr>
<td>Description:</td>
<td>Distance based bipartite matching using minimum cost flow, oriented
    to matching of treatment and control groups in observational studies ('Hansen'
    and 'Klopfer' 2006 &lt;<a href="https://doi.org/10.1198%2F106186006X137047">doi:10.1198/106186006X137047</a>&gt;). Routines are provided to
    generate distances from generalised linear models (propensity score
    matching), formulas giving variables on which to limit matched distances,
    stratified or exact matching directives, or calipers, alone or in
    combination.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, dplyr, stats, tibble, methods, graphics, rlemon</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RItools, boot, biglm, survey, testthat (&ge; 0.11.0), roxygen2,
brglm, arm, knitr, rmarkdown, markdown, pander, xtable,
rrelaxiv, magrittr</td>
</tr>
<tr>
<td>Enhances:</td>
<td>CBPS, haven</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>License_is_FOSS:</td>
<td>yes</td>
</tr>
<tr>
<td>License_restricts_use:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://optmat.ch">http://optmat.ch</a>, <a href="https://github.com/markmfredrickson/optmatch">https://github.com/markmfredrickson/optmatch</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/markmfredrickson/optmatch/issues">https://github.com/markmfredrickson/optmatch/issues</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://errickson.net/rrelaxiv">https://errickson.net/rrelaxiv</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'DenseMatrix.R' 'InfinitySparseMatrix.R' 'MCFSolutions.R'
'Ops.optmatch.dlist.R' 'Optmatch-package.R' 'RcppExports.R'
'abs.optmatch.dlist.R' 'boxplotMethods.R' 'caliper.R'
'complementarySlackness.R' 'data.R' 'deprecated.R'
'distUnion.R' 'edgelist.R' 'exactMatch.R' 'feasible.R'
'fill.NAs.R' 'fmatch.R' 'fullmatch.R' 'makedist.R' 'match_on.R'
'matched.R' 'matched.distances.R' 'matchfailed.R'
'max.controls.cap.R' 'mdist.R' 'min.controls.cap.R'
'optmatchS3.R' 'pairmatch.R' 'print.optmatch.R'
'print.optmatch.dlist.R' 'scores.R' 'solve_reg_fm_prob.R'
'solver.R' 'strata.R' 'stratumStructure.R' 'summary.ism.R'
'summary.optmatch.R' 'utilities.R' 'zzz.R'
'zzzDistanceSpecification.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-18 18:18:56 UTC; josh</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben Hansen [aut],
  Mark Fredrickson [aut],
  Josh Errickson [cre, aut],
  Josh Buckner [aut],
  Adam Rauh [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Josh Errickson &lt;jerrick@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-19 06:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2B+2CInfinitySparseMatrix+2CInfinitySparseMatrix-method'>Element-wise addition</h2><span id='topic++2B+2CInfinitySparseMatrix+2CInfinitySparseMatrix-method'></span><span id='topic+-+2CInfinitySparseMatrix+2CInfinitySparseMatrix-method'></span><span id='topic++2A+2CInfinitySparseMatrix+2CInfinitySparseMatrix-method'></span><span id='topic++2F+2CInfinitySparseMatrix+2CInfinitySparseMatrix-method'></span>

<h3>Description</h3>

<p><code>e1 + e2</code> returns the element-wise sum of
two InfinitySparseMatrix objects.
If either element is inf then
the resulting element will be inf.
</p>
<p><code>e1 - e2</code> returns the element-wise subtraction of
two InfinitySparseMatrix objects.
If either element is inf then
the resulting element will be inf.
</p>
<p><code>e1 * e2</code> returns the element-wise multiplication of
two InfinitySparseMatrix objects.
If either element is inf then
the resulting element will be inf.
</p>
<p><code>e1 / e2</code> returns the element-wise division of
two InfinitySparseMatrix objects.
If either element is inf then
the resulting element will be inf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InfinitySparseMatrix,InfinitySparseMatrix'
e1 + e2

## S4 method for signature 'InfinitySparseMatrix,InfinitySparseMatrix'
e1 - e2

## S4 method for signature 'InfinitySparseMatrix,InfinitySparseMatrix'
e1 * e2

## S4 method for signature 'InfinitySparseMatrix,InfinitySparseMatrix'
e1 / e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B2B+2B2CInfinitySparseMatrix+2B2CInfinitySparseMatrix-method_+3A_e1">e1</code></td>
<td>
<p>an InfinitySparseMatrix object</p>
</td></tr>
<tr><td><code id="+2B2B+2B2CInfinitySparseMatrix+2B2CInfinitySparseMatrix-method_+3A_e2">e2</code></td>
<td>
<p>an InfinitySparseMatrix object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an InfinitySparseMatrix object representing
the element-wise sum of the two ISM objects
</p>

<hr>
<h2 id='antiExactMatch'>Specify a matching problem where units in a common factor cannot be matched.</h2><span id='topic+antiExactMatch'></span>

<h3>Description</h3>

<p>This function builds a distance specification where treated units
are infinitely far away from control units that share the same
level of a given factor variable. This can be useful for ensuring
that matched groups come from qualitatively different groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antiExactMatch(x, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="antiExactMatch_+3A_x">x</code></td>
<td>
<p>A factor across which matches should be allowed.</p>
</td></tr>
<tr><td><code id="antiExactMatch_+3A_z">z</code></td>
<td>
<p>A logical or binary vector the same length as <code>x</code>
indicating treatment and control for each unit in the study.
TRUE or 1 represents a treatment unit, FALSE of 0 represents
a control unit. NA units are excluded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+exactMatch">exactMatch</a></code> function provides a way of specifying
a matching problem where only units within a factor level may be
matched. This function provides the reverse scenario: a matching
problem in which only units across factor levels are permitted to
match. Like <code><a href="#topic+exactMatch">exactMatch</a></code>, the results of this function will
most often be used as a <code>within</code> argument to
<code><a href="#topic+match_on">match_on</a></code> or another distance specification creation
function to limit the scope of the final distance specification
(i.e., disallowing any match between units with the same value on
the factor variable <code>x</code>).
</p>


<h3>Value</h3>

<p>A distance specification that encodes the across factor level constraint.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exactMatch">exactMatch</a></code>, <code><a href="#topic+match_on">match_on</a></code>, <code><a href="#topic+caliper">caliper</a></code>, <code><a href="#topic+fullmatch">fullmatch</a></code>, <code><a href="#topic+pairmatch">pairmatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)

# force entries to be within the same factor:
em &lt;- fullmatch(exactMatch(pr ~ pt, data = nuclearplants), data = nuclearplants)
table(nuclearplants$pt, em)

# force treated and control units to have different values of `pt`:
z &lt;- nuclearplants$pr
names(z) &lt;- rownames(nuclearplants)
aem &lt;- fullmatch(antiExactMatch(nuclearplants$pt, z), data = nuclearplants)
table(nuclearplants$pt, aem)
</code></pre>

<hr>
<h2 id='as.InfinitySparseMatrix'>Convert an object to InfinitySparseMatrix</h2><span id='topic+as.InfinitySparseMatrix'></span>

<h3>Description</h3>

<p>Convert an object to InfinitySparseMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.InfinitySparseMatrix(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.InfinitySparseMatrix_+3A_x">x</code></td>
<td>
<p>An object which can be coerced into InfinitySparseMatrix, typically a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An InfinitySparseMatrix
</p>

<hr>
<h2 id='as.list.BlockedInfinitySparseMatrix'>Splits a BlockedInfinitySparseMatrix into a list of
InfinitySparseMatrices</h2><span id='topic+as.list.BlockedInfinitySparseMatrix'></span>

<h3>Description</h3>

<p>Splits a BlockedInfinitySparseMatrix into a list of
InfinitySparseMatrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BlockedInfinitySparseMatrix'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.list.BlockedInfinitySparseMatrix_+3A_x">x</code></td>
<td>
<p>a BlockedInfinitySparseMatrix</p>
</td></tr>
<tr><td><code id="as.list.BlockedInfinitySparseMatrix_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of InfinitySparseMatrices
</p>

<hr>
<h2 id='BlockedInfinitySparseMatrix-class'>Blocked Infinity Sparse Matrix</h2><span id='topic+BlockedInfinitySparseMatrix-class'></span>

<h3>Description</h3>

<p>Blocked Infinity Sparse Matrices are similar to Infinity Sparse Matrices, but they also keep track of the groups of units via an additional slot, <code>groups</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>groups</code></dt><dd><p>factor vector containing groups, with unit names as labels, when possible</p>
</dd>
<dt><code>colnames</code></dt><dd><p>vector containing names for all control units. This will either be a character vector or NULL if units have no names</p>
</dd>
<dt><code>rownames</code></dt><dd><p>vector containing names for all treated units. This will either be a character vector or NULL if units have no names</p>
</dd>
<dt><code>cols</code></dt><dd><p>vector of integers corresponding to control units</p>
</dd>
<dt><code>rows</code></dt><dd><p>vector of integers corresponding to treated units</p>
</dd>
<dt><code>dimension</code></dt><dd><p>integer vector containing the number of treated and control units, in that order</p>
</dd>
<dt><code>call</code></dt><dd><p>function call used to create the <code>InfinitySparseMatrix</code></p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Mark M. Fredrickson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_on">match_on</a></code>, <code><a href="#topic+exactMatch">exactMatch</a></code>, <code><a href="#topic+fullmatch">fullmatch</a></code>,  <code><a href="#topic+InfinitySparseMatrix-class">InfinitySparseMatrix-class</a></code>
</p>

<hr>
<h2 id='c+2CSubProbInfo-method'>Combine objects</h2><span id='topic+c+2CSubProbInfo-method'></span><span id='topic+c+2CNodeInfo-method'></span><span id='topic+c+2CArcInfo-method'></span><span id='topic+c+2CMCFSolutions-method'></span><span id='topic+c+2CFullmatchMCFSolutions-method'></span>

<h3>Description</h3>

<p>Combine objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SubProbInfo'
c(x, ...)

## S4 method for signature 'NodeInfo'
c(x, ...)

## S4 method for signature 'ArcInfo'
c(x, ...)

## S4 method for signature 'MCFSolutions'
c(x, ...)

## S4 method for signature 'FullmatchMCFSolutions'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c+2B2CSubProbInfo-method_+3A_x">x</code></td>
<td>
<p>object of particular class</p>
</td></tr>
<tr><td><code id="c+2B2CSubProbInfo-method_+3A_...">...</code></td>
<td>
<p>Various objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Combined objects
</p>

<hr>
<h2 id='c.optmatch'>Combine Optmatch objects</h2><span id='topic+c.optmatch'></span>

<h3>Description</h3>

<p>Combine Optmatch objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optmatch'
c(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.optmatch_+3A_...">...</code></td>
<td>
<p>Optmatch objects to be concatenated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A combined Optmatch object
</p>

<hr>
<h2 id='caliper'>Prepare matching distances suitable for matching within calipers.</h2><span id='topic+caliper'></span><span id='topic+caliper+2CInfinitySparseMatrix-method'></span><span id='topic+caliper+2Cmatrix-method'></span><span id='topic+caliper+2Coptmatch.dlist-method'></span>

<h3>Description</h3>

<p>Encodes calipers, or maximum allowable distances within which to
match. The result of a call to <code>caliper</code> is itself a distance specification between
treated and control units that can be used with
<code>pairmatch()</code> or <code>fullmatch()</code>. Calipers can also be combined with
other distance specifications for richer matching problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caliper(x, width, exclude = c(), compare = `&lt;=`, values = FALSE)

## S4 method for signature 'InfinitySparseMatrix'
caliper(x, width, exclude = c(), compare = `&lt;=`, values = FALSE)

## S4 method for signature 'matrix'
caliper(x, width, exclude = c(), compare = `&lt;=`, values = FALSE)

## S4 method for signature 'optmatch.dlist'
caliper(x, width, exclude = c(), compare = `&lt;=`, values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caliper_+3A_x">x</code></td>
<td>
<p>A distance specification created with <code><a href="#topic+match_on">match_on</a></code> or similar.</p>
</td></tr>
<tr><td><code id="caliper_+3A_width">width</code></td>
<td>
<p>The width of the caliper: how wide of a margin to
allow in matches. Be careful in setting the width. Vector valued
arguments will be recycled for each of the finite entries in
<code>x</code> (and no order is guaranteed for <code>x</code> for some types of
distance objects).</p>
</td></tr>
<tr><td><code id="caliper_+3A_exclude">exclude</code></td>
<td>
<p>(Optional) A character vector of observations (corresponding to row and column names) to exclude from the caliper.</p>
</td></tr>
<tr><td><code id="caliper_+3A_compare">compare</code></td>
<td>
<p>A function that decides that whether two
observations are with the caliper. The default is
<code>`&lt;=`</code>. <code>`&lt;`</code> is a common alternative.</p>
</td></tr>
<tr><td><code id="caliper_+3A_values">values</code></td>
<td>
<p>Should the returned object be made of all zeros
(<code>values = FALSE</code>, the default) or should the object include
the values of the original object (<code>values = TRUE</code>)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>caliper</code> is a generic function with methods for any of the allowed distance
specifications: user created matrices, the results of <code><a href="#topic+match_on">match_on</a></code>, the results
of <code><a href="#topic+exactMatch">exactMatch</a></code>, or combinations (using <code>`+`</code>) of these objects.
</p>
<p><code>width</code> provides the size of the caliper, the allowable distance for
matching. If the distance between a treated and control pair is less than or
equal to this distance, it is allowed kept; otherwise, the pair is discarded
from future matching. The default comparison of &quot;equal or less than can&quot; be
changed to any other comparison function using the <code>comparison</code>
argument.
</p>
<p>It is important to understand that <code>width</code> argument is defined on the
scale of these distances. For univariate distances such as propensity scores,
it is common to specify calipers in standard deviations. If a caliper of
this nature is desired, you must either find the standard deviation directly
or use the <code><a href="#topic+match_on">match_on</a></code> function with its <code>caliper</code> argument.
Since <code>match_on</code> has access to the underlying univariate scores, for
example for the GLM method, it can determine the caliper width in standard
deviations.
</p>
<p>If you wish to exclude specific units from the caliper requirements, pass the names of
these units in the <code>exclude</code> argument. These units will be allowed to match any other
unit.
</p>


<h3>Value</h3>

<p>A matrix like object that is suitable to be given
as <code>distance</code> argument to <code><a href="#topic+fullmatch">fullmatch</a></code> or
<code><a href="#topic+pairmatch">pairmatch</a></code>. The caliper will be only zeros and <code>Inf</code> values,
indicating a possible match or no possible match, respectively.
</p>
<p>You can combine the results of <code>caliper</code> with other distances using the
<code>`+`</code> operator. See the examples for usage.
</p>


<h3>Author(s)</h3>

<p>Mark M. Fredrickson and Ben B. Hansen
</p>


<h3>References</h3>

<p>P.~R. Rosenbaum and D.~B. Rubin (1985),
&lsquo;Constructing a control group using multivariate matched sampling
methods that incorporate the propensity score&rsquo;,
<em>The American Statistician</em>, <b>39</b> 33&ndash;38.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exactMatch">exactMatch</a></code>, <code><a href="#topic+match_on">match_on</a></code>, <code><a href="#topic+fullmatch">fullmatch</a></code>, <code><a href="#topic+pairmatch">pairmatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)


### Caliper of 100 MWe on plant capacity
caliper(match_on(pr~cap, data=nuclearplants, method="euclidean"), width=100)

### Caliper of 1/2 a pooled SD of plant capacity
caliper(match_on(pr~cap, data=nuclearplants), width=.5)

### Caliper  of .2 pooled SDs in the propensity score
ppty &lt;- glm(pr ~ . - (pr + cost), family = binomial(), data = nuclearplants)
ppty.dist &lt;- match_on(ppty)

pptycaliper &lt;- caliper(ppty.dist, width = .2)

### caliper on the Mahalanobis distance
caliper(match_on(pr ~ t1 + t2, data = nuclearplants), width = 3)

### Combining a Mahalanobis distance matching with a caliper
### of 1 pooled SD in the propensity score:
mhd.pptyc &lt;- caliper(ppty.dist, width = 1) +
          match_on(pr ~ t1 + t2, data = nuclearplants)
pairmatch(mhd.pptyc, data = nuclearplants)

### Excluding observations from caliper requirements:
caliper(match_on(pr ~ t1 + t2, data = nuclearplants), width = 3, exclude = c("A", "f"))

### Returning values directly (equal up to the the attributes)
all(abs((caliper(ppty.dist, 1) + ppty.dist) -
        caliper(ppty.dist, 1, values = TRUE)) &lt; .Machine$Double.eps)
</code></pre>

<hr>
<h2 id='caliperSize'>(Internal) Determines how many other units fall within a caliper distance</h2><span id='topic+caliperSize'></span>

<h3>Description</h3>

<p>The matching functions <code><a href="#topic+fullmatch">fullmatch</a></code> and <code><a href="#topic+pairmatch">pairmatch</a></code>
have a maximum problem size, based on the number of comparisons between treated
and control units. For a completely dense problem, in which every treated units
is compared to every control unit there are <code>length(treated) *
length(control)</code> comparisons. A caliper restricts which comparisons are valid,
disallowing matches of treated and control pairs that are too far apart. A
caliper can significantly decrease the size of a matching problem. The
<code>caliperSize</code> function reports exactly who many valid treated-control
comparisons remain after applying a caliper of the given width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caliperSize(scores, z, width, structure = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caliperSize_+3A_scores">scores</code></td>
<td>
<p>A numeric vector of scores providing 1-D position of units</p>
</td></tr>
<tr><td><code id="caliperSize_+3A_z">z</code></td>
<td>
<p>Treatment indicator vector</p>
</td></tr>
<tr><td><code id="caliperSize_+3A_width">width</code></td>
<td>
<p>Width of caliper, must be positive</p>
</td></tr>
<tr><td><code id="caliperSize_+3A_structure">structure</code></td>
<td>
<p>Grouping factor to use in computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric Total number of pairwise distances remaining after the caliper is placed.
</p>

<hr>
<h2 id='caliperUpperBound'>(Internal) Returns a reasonable upper bound on the arcs remaining after placing a caliper.</h2><span id='topic+caliperUpperBound'></span>

<h3>Description</h3>

<p>(Internal) Returns a reasonable upper bound on the arcs remaining after placing a caliper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caliperUpperBound(scores, z, width, structure = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caliperUpperBound_+3A_scores">scores</code></td>
<td>
<p>A numeric vector of scores providing 1-D position of units</p>
</td></tr>
<tr><td><code id="caliperUpperBound_+3A_z">z</code></td>
<td>
<p>Treatment indicator vector</p>
</td></tr>
<tr><td><code id="caliperUpperBound_+3A_width">width</code></td>
<td>
<p>Width of caliper, must be positive.</p>
</td></tr>
<tr><td><code id="caliperUpperBound_+3A_structure">structure</code></td>
<td>
<p>Optional factor variable that groups the scores, as would
be used by <code><a href="#topic+exactMatch">exactMatch</a></code>. Including structure allows for wider
calipers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric Total number of pairwise distances remaining after the caliper is placed.
</p>

<hr>
<h2 id='cbind.InfinitySparseMatrix'>Combine InfinitySparseMatrices or
BlockedInfinitySparseMatrices by row or column</h2><span id='topic+cbind.InfinitySparseMatrix'></span><span id='topic+rbind.InfinitySparseMatrix'></span><span id='topic+cbind.BlockedInfinitySparseMatrix'></span><span id='topic+rbind.BlockedInfinitySparseMatrix'></span>

<h3>Description</h3>

<p>This matches the syntax and semantics of
cbind and rbind for matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'InfinitySparseMatrix'
cbind(x, y, ...)

## S3 method for class 'InfinitySparseMatrix'
rbind(x, y, ...)

## S3 method for class 'BlockedInfinitySparseMatrix'
cbind(x, y, ...)

## S3 method for class 'BlockedInfinitySparseMatrix'
rbind(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbind.InfinitySparseMatrix_+3A_x">x</code></td>
<td>
<p>An InfinitySparseMatrix or BlockedInfinitySparseMatrix,
agreeing with <code>y</code> in the appropriate dimension.</p>
</td></tr>
<tr><td><code id="cbind.InfinitySparseMatrix_+3A_y">y</code></td>
<td>
<p>An InfinitySparseMatrix or BlockedInfinitySparseMatrix,
agreeing with <code>x</code> in the appropriate dimension.</p>
</td></tr>
<tr><td><code id="cbind.InfinitySparseMatrix_+3A_...">...</code></td>
<td>
<p>Other arguments ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A combined InfinitySparseMatrix or BlockedInfinitySparseMatrix
</p>


<h3>Author(s)</h3>

<p>Mark Fredrickson
</p>

<hr>
<h2 id='compare_optmatch'>Compares the equality of optmatch objects, ignoring attributes and group names.</h2><span id='topic+compare_optmatch'></span>

<h3>Description</h3>

<p>This checks the equality of two optmatch objects. The only bits that matter are unit names
and the grouping. Other bits such as attributes, group names, order, etc are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_optmatch(o1, o2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_optmatch_+3A_o1">o1</code></td>
<td>
<p>First optmatch object.</p>
</td></tr>
<tr><td><code id="compare_optmatch_+3A_o2">o2</code></td>
<td>
<p>Second optmatch object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of the units can differ on any unmatched units, e.g., units whose value in the optmatch
object is <code>NA</code>. If matched objects have differing names, this is automatically <code>FALSE</code>.
</p>
<p>Note this ignores the names of the subgroups. So four members in subgroups either
<code>c("a", "a", "b", "b")</code> or <code>c("b", "b", "a", "a")</code> would be identical to this call.
</p>


<h3>Value</h3>

<p>TRUE if the two matches have the same memberships.
</p>

<hr>
<h2 id='dbind'>Diagonally bind together subgroup-specific distances</h2><span id='topic+dbind'></span>

<h3>Description</h3>

<p>This function generates a single block-diagonal distance matrix given
several distance matrices defined on subgroups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbind(..., force_unique_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbind_+3A_...">...</code></td>
<td>
<p>Any number of distance objects which can be converted to
<code>InfinitySparseMatrix</code>, such as class <code>matrix</code>,
<code>DenseMatrix</code>, <code>InfinitySparseMatrix</code>, or
<code>BlockedInfinitySparseMatrix</code>, or <code>list</code>s containing distance
objects.</p>
</td></tr>
<tr><td><code id="dbind_+3A_force_unique_names">force_unique_names</code></td>
<td>
<p>Default <code>FALSE</code>. When row or column names are
not unique among all distances, if <code>FALSE</code>, throw a warning and
rename all rows and columns to ensure unique names. If <code>TRUE</code>, error
on non-unique names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When you've generated several distances matrices on subgroups in your
analysis, you may wish to combine them into a single block-diagonal distance
matrix. The <code>dbind</code> function facilitates this.
</p>
<p>Any <code>BlockedInfinitySparseMatrix</code> include in <code>...</code> will be broken
into individual <code>InfinitySparseMatrix</code> before being joined back
together. For example, if <code>b</code> is a <code>BlockedInfinitySparseMatrix</code>
with 2 subgroups and <code>m</code> is a distance without subgroups, then
<code>dbind(b, m)</code> will be a <code>BlockedInfinitySparseMatrix</code> with 3
subgroups.
</p>
<p>If there are any shared names (either row or column) among all distances
passed in, by default all matrices will be renamed to ensure unique names by
appending &quot;X.&quot; to each distance, where &quot;X&quot; is ascending lower case letters
(&quot;a.&quot;, &quot;b.&quot;, etc). Setting the <code>force_unique_names</code> argument to
<code>TRUE</code> errors on this instead.
</p>
<p>If the matrices need to be renamed and there are more than 26 separate
matrices, after the first 26 single &quot;X.&quot; prefixs, they will continue as
&quot;YX.&quot;, e.g &quot;aa.&quot;, &quot;ab.&quot;, &quot;ac.&quot;. If more than 676 separate matrices, the
prefix wil continue to &quot;ZYX.&quot;, e.g. &quot;aaa.&quot;, &quot;aab.&quot;, &quot;aac.&quot;. This scheme
supports up to 18,278 unique matrices.
</p>
<p>Note that you do <strong>not</strong> have to combine subgroup distances into a
single blocked distance using this function to ultimately obtain a single
matching set. Instead, take a look at the vignette
<code>vignette("matching-within-subgroups", package = "optmatch")</code> for
details on combining multiple matches.
</p>


<h3>Value</h3>

<p>A <code>BlockedInfinitySparseMatrix</code> containing a block-diagonal
distance matrix. If only a single distance is passed to <code>dbind</code> and
it is not already a <code>BlockedInfinitySparseMatrix</code>, the result will be
an <code>InfinitySparseMatrix</code> instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)
m1 &lt;- match_on(pr ~ cost, data = subset(nuclearplants, pt == 0),
               caliper = 1)
m2 &lt;- match_on(pr ~ cost, data = subset(nuclearplants, pt == 1),
               caliper = 1.3)
blocked &lt;- dbind(m1, m2)

dists &lt;- list(m1, m2)

blocked2 &lt;- dbind(dists)
identical(blocked, blocked2)
</code></pre>

<hr>
<h2 id='dimnames+2CInfinitySparseMatrix-method'>Get and set dimnames for InfinitySparseMatrix objects</h2><span id='topic+dimnames+2CInfinitySparseMatrix-method'></span><span id='topic+dimnames+3C-+2CInfinitySparseMatrix+2Clist-method'></span><span id='topic+dimnames+3C-+2CInfinitySparseMatrix+2CNULL-method'></span>

<h3>Description</h3>

<p>InfinitySparseMatrix objects represent sparse matching problems
with treated units as rows of a matrix and controls units as
the columns of the matrix. The names of the units can be retrieved
and set using these methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InfinitySparseMatrix'
dimnames(x)

## S4 replacement method for signature 'InfinitySparseMatrix,list'
dimnames(x) &lt;- value

## S4 replacement method for signature 'InfinitySparseMatrix,NULL'
dimnames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dimnames+2B2CInfinitySparseMatrix-method_+3A_x">x</code></td>
<td>
<p>An InfinitySparseMatrix object.</p>
</td></tr>
<tr><td><code id="dimnames+2B2CInfinitySparseMatrix-method_+3A_value">value</code></td>
<td>
<p>A list with two entries: the treated names and control names, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with treated and control names.
</p>

<hr>
<h2 id='distUnion'>Combine multiple distance specifications into a single distance specification.</h2><span id='topic+distUnion'></span>

<h3>Description</h3>

<p>Creates a new distance specification from the union of two or more
distance specifications. The constituent distances specifications
may have overlapping treated and control units (identified by the
<code>rownames</code> and <code>colnames</code> respectively).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distUnion(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distUnion_+3A_...">...</code></td>
<td>
<p>The distance specifications (as created with with
<code><a href="#topic+match_on">match_on</a></code>, <code><a href="#topic+exactMatch">exactMatch</a></code>, or other distance
creation function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For combining multiple distance specifications with common
controls, but different treated units, <code><a href="base.html#topic+rbind">rbind</a></code> provides
a way to combine the different objects. Likewise,
<code><a href="base.html#topic+cbind">cbind</a></code> provides a way to combine distance
specifications over common treated units, but different control
units.
</p>
<p><code>distUnion</code> can combine distance units that have common
treated and control units into a coherent single distance
object. If there are duplicate treated-control entries in multiple
input distances, the first entry will be used.
</p>


<h3>Value</h3>

<p>An InfinitySparseMatrix object with all treated and control
units from the arguments combined. Duplicate entries are resolved
in favor of the earliest argument (e.g., <code>distUnion(A, B)</code>
will favor entries in <code>A</code> over entries in <code>B</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_on">match_on</a></code>, <code><a href="#topic+exactMatch">exactMatch</a></code>,
<code><a href="#topic+fullmatch">fullmatch</a></code>, <code><a href="#topic+pairmatch">pairmatch</a></code>,
<code><a href="base.html#topic+cbind">cbind</a></code>, <code><a href="base.html#topic+rbind">rbind</a></code>
</p>

<hr>
<h2 id='edgelist'>Create EdgeList object</h2><span id='topic+edgelist'></span>

<h3>Description</h3>

<p>If y is a named character vector, then the names should
correspond to whatever in x would otherwise (i.e. if y were NULL)
translate to the levels set of the nodes-representing columns, while
the values themselves give the new levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelist(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edgelist_+3A_x">x</code></td>
<td>
<p>object to convert to edgelist</p>
</td></tr>
<tr><td><code id="edgelist_+3A_y">y</code></td>
<td>
<p>named character vector giving levels for nodes-representing columns, or NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>EdgeList
</p>


<h3>Author(s)</h3>

<p>Ben Hansen
</p>

<hr>
<h2 id='effectiveSampleSize'>Compute the effective sample size of a match.</h2><span id='topic+effectiveSampleSize'></span><span id='topic+effectiveSampleSize.factor'></span><span id='topic+effectiveSampleSize.default'></span><span id='topic+effectiveSampleSize.table'></span>

<h3>Description</h3>

<p>The effective sample size is the sum of the harmonic means of the number
units in treatment and control for each matched group. For k matched pairs,
the effective sample size is k. As matched groups become more unbalanced, the
effective sample size decreases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effectiveSampleSize(x, z = NULL)

## S3 method for class 'factor'
effectiveSampleSize(x, z = NULL)

## Default S3 method:
effectiveSampleSize(x, z = NULL)

## S3 method for class 'table'
effectiveSampleSize(x, z = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="effectiveSampleSize_+3A_x">x</code></td>
<td>
<p>An <code>optmatch</code> object, the result of
<code><a href="#topic+fullmatch">fullmatch</a></code> or <code><a href="#topic+pairmatch">pairmatch</a></code>.</p>
</td></tr>
<tr><td><code id="effectiveSampleSize_+3A_z">z</code></td>
<td>
<p>A treatment indicator, a vector the same length as <code>match</code>.
This is only required if the <code>match</code> object does not contain the
contrast.group' attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The equivalent number of pairs in this match.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.optmatch">summary.optmatch</a></code>, <code><a href="#topic+stratumStructure">stratumStructure</a></code>
</p>

<hr>
<h2 id='evaluate_primal'>Compute value of primal problem given flows and arc costs</h2><span id='topic+evaluate_primal'></span>

<h3>Description</h3>

<p>Compute value of primal problem given flows and arc costs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_primal(distances, solution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_primal_+3A_distances">distances</code></td>
<td>
<p>An InfinitySparseMatrix giving distances</p>
</td></tr>
<tr><td><code id="evaluate_primal_+3A_solution">solution</code></td>
<td>
<p>A MCFSolutions object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the primal problem, i.e. sum of
products of <code>distances</code> with flow along arcs in <code>solution</code>
</p>


<h3>Author(s)</h3>

<p>Hansen
</p>

<hr>
<h2 id='exactMatch'>Generate an exact matching set of subproblems.</h2><span id='topic+exactMatch'></span><span id='topic+exactMatch+2Cvector-method'></span><span id='topic+exactMatch+2Cformula-method'></span>

<h3>Description</h3>

<p>An exact match is one based on a factor. Within a level, all
observations are allowed to be matched. An exact match can be
combined with another distance matrix to create a set of matching
subproblems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exactMatch(x, ...)

## S4 method for signature 'vector'
exactMatch(x, treatment)

## S4 method for signature 'formula'
exactMatch(x, data = NULL, subset = NULL, na.action = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exactMatch_+3A_x">x</code></td>
<td>
<p>A factor vector or a formula, used to select method.</p>
</td></tr>
<tr><td><code id="exactMatch_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
<tr><td><code id="exactMatch_+3A_treatment">treatment</code></td>
<td>
<p>A logical or binary vector the same length as <code>x</code>
indicating treatment and control for each unit in the study.
TRUE or 1 represents a treatment unit, FALSE or 0 represents
a control unit. NA units are excluded.</p>
</td></tr>
<tr><td><code id="exactMatch_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> that contains the
variables used in the formula <code>x</code>.</p>
</td></tr>
<tr><td><code id="exactMatch_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of
observations to be used</p>
</td></tr>
<tr><td><code id="exactMatch_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen when
the data contain <code>NA</code>s</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>exactMatch</code> creates a block diagonal matrix of 0s and
<code>Inf</code>s. The pairs with 0 entries are within the same level of
the factor and legitimate matches.  <code>Inf</code> indicates units in
different levels. <code>exactMatch</code> replaces the
<code>structure.fmla</code> argument to several functions in previous
versions of optmatch.  For the <code>factor</code> method, the two
vectors <code>x</code> and <code>treatment</code> must be the same length. The
vector <code>x</code> is interpreted as indicating the grouping factors
for the data, and the vector <code>treatment</code> indicates whether a
unit is in the treatment or control groups.  At least one of these
two vectors must have names.  For the <code>formula</code> method, the
<code>data</code> argument may be omitted, in which case the method
attempts to find the variables in the environment from which the
function was called. This behavior, and the arguments <code>subset</code>
and <code>na.action</code>, mimics the behavior of <code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Value</h3>

<p>A matrix like object, which is suitable to be given as
<code>distance</code> argument to <code><a href="#topic+fullmatch">fullmatch</a></code> or
<code><a href="#topic+pairmatch">pairmatch</a></code>. The exact match will be only zeros and
<code>Inf</code> values, indicating a possible match or no possible
match, respectively. It can be added to a another distance matrix
to create a subclassed matching problem.
</p>


<h3>Author(s)</h3>

<p>Mark M. Fredrickson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+caliper">caliper</a></code>, <code><a href="#topic+antiExactMatch">antiExactMatch</a></code>,
<code><a href="#topic+match_on">match_on</a></code>, <code><a href="#topic+fullmatch">fullmatch</a></code>,
<code><a href="#topic+pairmatch">pairmatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nuclearplants)

### First generate a standard propensity score
ppty &lt;- glm(pr~.-(pr+cost), family = binomial(), data = nuclearplants)
ppty.distances &lt;- match_on(ppty)

### Only allow matches within the partial turn key plants
pt.em &lt;- exactMatch(pr ~ pt, data = nuclearplants)
as.matrix(pt.em)

### Blunt matches:
match.pt.em &lt;- fullmatch(pt.em)
print(match.pt.em, grouped = TRUE)

### Combine the propensity scores with the subclasses:
match.ppty.em &lt;- fullmatch(ppty.distances + pt.em)
print(match.ppty.em, grouped = TRUE)

</code></pre>

<hr>
<h2 id='fill.NAs'>Create missingness indicator variables and non-informatively fill in missing values</h2><span id='topic+fill.NAs'></span>

<h3>Description</h3>

<p>Given a <code>data.frame</code> or <code>formula</code> and data,
<code>fill.NAs()</code> returns an expanded data frame, including a new
missingness flag for each variable with missing values and
replacing each missing entry with a value representing a reasonable
default for missing values in its column.  Functions in the formula
are supported, with transformations happening before <code>NA</code>
replacement.  The expanded data frame is useful for propensity
modeling and balance checking when there are covariates with
missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill.NAs(x, data = NULL, all.covs = FALSE, contrasts.arg = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill.NAs_+3A_x">x</code></td>
<td>
<p>Can be either a data frame (in which case the data
argument should be <code>NULL</code>) or a formula (in which case data
must be a data.frame)</p>
</td></tr>
<tr><td><code id="fill.NAs_+3A_data">data</code></td>
<td>
<p>If x is a formula, this must be a data.frame. Otherwise
it will be ignored.</p>
</td></tr>
<tr><td><code id="fill.NAs_+3A_all.covs">all.covs</code></td>
<td>
<p>Should the response variable be imputed? For
formula <code>x</code>, this is the variable on the left hand side. For
<code>data.frame</code> <code>x</code>, the response is considered the first
column.</p>
</td></tr>
<tr><td><code id="fill.NAs_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>(from <code>model.matrix</code>) A list, whose
entries are values (numeric matrices or character strings naming
functions) to be used as replacement values for the
<code><a href="stats.html#topic+contrasts">contrasts</a></code> replacement function and whose names are
the names of columns of <code>data</code> containing
<code><a href="base.html#topic+factor">factor</a></code>s.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fill.NAs</code> prepares data for use in a model or matching
procedure by filling in missing values with minimally invasive
substitutes. Fill-in is performed column-wise, with each column
being treated individually. For each column that is missing, a new
column is created of the form &ldquo;ColumnName.NA&rdquo; with
indicators for each observation that is missing a value for
&ldquo;ColumnName&rdquo;.  Rosenbaum and Rubin (1984, Sec. 2.4 and
Appendix B) discuss propensity score models using this data
structure.
</p>
<p>The replacement value used to fill in a missing value is simple
mean replacement. For transformations of variables, e.g. <code>y ~
x1 * x2</code>, the transformation occurs first. The transformation
column will be <code>NA</code> if any of the base columns are
<code>NA</code>. Fill-in occurs next, replacing all missing values with
the observed column mean. This includes transformation columns.
</p>
<p>Data can be passed to <code>fill.NAs</code> in two ways. First, you can
simply pass a <code>data.frame</code> object and <code>fill.NAs</code> will
fill every column. Alternatively, you can pass a <code>formula</code> and
a <code>data.frame</code>. Fill-in will only be applied to columns
specifically used in the formula. Prior to fill-in, any functions
in the formula will be expanded. If any arguments to the functions
are <code>NA</code>, the function value will also be <code>NA</code> and
subject to fill-in.
</p>
<p>By default, <code>fill.NAs</code> does not impute the response
variable. This is to encourage more sophisticated imputation
schemes when the response is a treatment indicator in a matching
problem. This behavior can be overridden by setting <code>all.covs
= TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with all <code>NA</code> values replaced with
mean values and additional indicator columns for each column
including missing values. Suitable for directly passing to
<code><a href="stats.html#topic+lm">lm</a></code> or other model building functions to build
propensity scores.
</p>


<h3>Author(s)</h3>

<p>Mark M. Fredrickson and Jake Bowers
</p>


<h3>References</h3>

<p>Rosenbaum, Paul R. and Rubin, Donald B. (1984) &lsquo;Reducing
Bias in Observational Studies using Subclassification on the
Propensity Score,&rsquo; <em>Journal of the American Statistical
Association</em>, <b>79</b>, 516 &ndash; 524.
</p>
<p>Von Hipple, Paul T. (2009) &lsquo;How to impute interactions,
squares, and other transformed variables,&rsquo; <em>Sociological
Methodology</em>, <b>39</b>(1), 265 &ndash; 291.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_on">match_on</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)
### Extract some representative covariates:
np.missing &lt;- nuclearplants[c('t1', 't2', 'ne', 'ct', 'cum.n')]

 ### create some missingness in the covariates
 n &lt;- dim(np.missing)[1]
 k &lt;- dim(np.missing)[2]

 for (i in 1:n) {
   missing &lt;- rbinom(1, prob = .1, size = k)
   if (missing &gt; 0) {
     np.missing[i, sample(k, missing)] &lt;- NA
   }
 }

### Restore outcome and treatment variables:
np.missing &lt;- data.frame(nuclearplants[c('cost', 'pr')], np.missing)

### Fit a propensity score but with missing covariate data flagged
### and filled in, as in Rosenbaum and Rubin (1984, Appendix):
np.filled &lt;- fill.NAs(pr ~ t1 * t2, np.missing)
# Look at np.filled to establish what missingness flags were created
head(np.filled)
(np.glm &lt;- glm(pr ~ ., family=binomial, data=np.filled))
(glm(pr ~ t1 + t2 + `t1:t2` + t1.NA + t2.NA,
                family=binomial, data=np.filled))
# In a non-interactive session, the following may help, as long as
# the formula passed to `fill.NAs` (plus any missingness flags) is
# the desired formula for the glm.
(glm(formula(terms(np.filled)), family=binomial, data=np.filled))

### produce a matrix of propensity distances based on the propensity model
### with fill-in and flagging. Then perform pair matching on it:
pairmatch(match_on(np.glm, data=np.filled), data=np.filled)

## fill NAs without using treatment contrasts by making a list of contrasts for
## each factor ## following hints from https://stackoverflow.com/a/4569239/161808

np.missing$t1F&lt;-factor(np.missing$t1)
cov.factors &lt;- sapply(np.missing[,c("t1F","t2")],is.factor)
cov.contrasts &lt;- lapply(
  np.missing[,names(cov.factors)[cov.factors],drop=FALSE],
  contrasts, contrasts = FALSE)

## make a data frame filling the missing covariate values, but without
## excluding any levels of any factors
np.noNA2&lt;-fill.NAs(pr~t1F+t2,data=np.missing,contrasts.arg=cov.contrasts)

</code></pre>

<hr>
<h2 id='findSubproblems'>List subproblems of a distance</h2><span id='topic+findSubproblems'></span>

<h3>Description</h3>

<p>Get all the subproblems from a distance specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findSubproblems(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findSubproblems_+3A_d">d</code></td>
<td>
<p>a distance specification</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of distance specifications
</p>


<h3>Author(s)</h3>

<p>Mark M. Fredrickson
</p>

<hr>
<h2 id='fmla2treatedblocking'>(Internal) A helper function to turn formulas into treatment and blocking variables</h2><span id='topic+fmla2treatedblocking'></span>

<h3>Description</h3>

<p>Given a function and any of the arguments normally passed to model.frame,
this function will return a data.frame with two columns: a treatment indicator
and a blocking factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmla2treatedblocking(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmla2treatedblocking_+3A_x">x</code></td>
<td>
<p>A formula</p>
</td></tr>
<tr><td><code id="fmla2treatedblocking_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to model.frame (e.g. <code>data</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing two columns: <code>Z</code> is a treatment indicator,
<code>B</code> is a blocking factor
</p>

<hr>
<h2 id='fullmatch'>Optimal full matching</h2><span id='topic+fullmatch'></span><span id='topic+full'></span>

<h3>Description</h3>

<p>Given two groups, such as a treatment and a control group, and a method of
creating a treatment-by-control discrepancy matrix indicating desirability and
permissibility of potential matches (or optionally an already created such
discrepancy matrix), create optimal full matches of members of the groups.
Optionally, incorporate restrictions on matched sets' ratios of treatment to
control units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fullmatch(
  x,
  min.controls = 0,
  max.controls = Inf,
  omit.fraction = NULL,
  mean.controls = NULL,
  tol = 0.001,
  data = NULL,
  solver = "",
  ...
)

full(
  x,
  min.controls = 0,
  max.controls = Inf,
  omit.fraction = NULL,
  mean.controls = NULL,
  tol = 0.001,
  data = NULL,
  solver = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fullmatch_+3A_x">x</code></td>
<td>
<p>Any valid input to <code>match_on</code>. <code>fullmatch</code> will use
<code>x</code> and any optional arguments to generate a distance before performing
the matching.
</p>
<p>If <code>x</code> is a numeric vector, there must also be passed a vector <code>z</code>
indicating grouping. Both vectors must be named.
</p>
<p>Alternatively, a precomputed distance may be entered. A matrix of
non-negative discrepancies, each indicating the permissibility and
desirability of matching the unit corresponding to its row (a 'treatment') to
the unit corresponding to its column (a 'control'); or, better, a distance
specification as produced by <code><a href="#topic+match_on">match_on</a></code>.</p>
</td></tr>
<tr><td><code id="fullmatch_+3A_min.controls">min.controls</code></td>
<td>
<p>The minimum ratio of controls to treatments that is to
be permitted within a matched set: should be non-negative and finite.  If
<code>min.controls</code> is not a whole number, the reciprocal of a whole number,
or zero, then it is rounded <em>down</em> to the nearest whole number or
reciprocal of a whole number.
</p>
<p>When matching within subclasses (such as those created by
<code><a href="#topic+exactMatch">exactMatch</a></code>), <code>min.controls</code> may be a named numeric vector
separately specifying the minimum permissible ratio of controls to treatments
for each subclass.  The names of this vector should include names of all
subproblems <code>distance</code>.</p>
</td></tr>
<tr><td><code id="fullmatch_+3A_max.controls">max.controls</code></td>
<td>
<p>The maximum ratio of controls to treatments that is
to be permitted within a matched set: should be positive and numeric.
If <code>max.controls</code> is not a whole number, the reciprocal of a
whole number, or <code>Inf</code>, then it is rounded <em>up</em> to the
nearest whole number or reciprocal of a whole number.
</p>
<p>When matching within subclasses (such as those created by
<code><a href="#topic+exactMatch">exactMatch</a></code>), <code>max.controls</code> may be a named numeric vector
separately specifying the maximum permissible ratio of controls to treatments
in each subclass.</p>
</td></tr>
<tr><td><code id="fullmatch_+3A_omit.fraction">omit.fraction</code></td>
<td>
<p>Optionally, specify what fraction of controls or treated
subjects are to be rejected.  If <code>omit.fraction</code> is a positive fraction
less than one, then <code>fullmatch</code> leaves up to that fraction of the control
reservoir unmatched.  If <code>omit.fraction</code> is a negative number greater
than -1, then <code>fullmatch</code> leaves up to |<code>omit.fraction</code>| of the
treated group unmatched.  Positive values are only accepted if
<code>max.controls</code> &gt;= 1; negative values, only if <code>min.controls</code> &lt;= 1.
If neither <code>omit.fraction</code> or <code>mean.controls</code> are specified, then
only those treated and control subjects without permissible matches among the
control and treated subjects, respectively, are omitted.
</p>
<p>When matching within subclasses (such as those created by
<code><a href="#topic+exactMatch">exactMatch</a></code>), <code>omit.fraction</code> specifies the fraction of
controls to be rejected in each subproblem, a parameter that can be made to
differ by subclass by setting <code>omit.fraction</code> equal to a named numeric
vector of fractions.
</p>
<p>At most one of <code>mean.controls</code> and <code>omit.fraction</code> can be non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fullmatch_+3A_mean.controls">mean.controls</code></td>
<td>
<p>Optionally, specify the average number of controls per
treatment to be matched. Must be no less than than <code>min.controls</code> and no
greater than the either <code>max.controls</code> or the ratio of total number of
controls versus total number of treated. Some controls will likely not be
matched to ensure meeting this value. If neither <code>omit.fraction</code> or
<code>mean.controls</code> are specified, then only those treated and control
subjects without permissible matches among the control and treated subjects,
respectively, are omitted.
</p>
<p>When matching within subclasses (such as those created by
<code><a href="#topic+exactMatch">exactMatch</a></code>), <code>mean.controls</code> specifies the average number of
controls per treatment per subproblem, a parameter that can be made to
differ by subclass by setting <code>mean.controls</code> equal to a named numeric
vector.
</p>
<p>At most one of <code>mean.controls</code> and <code>omit.fraction</code> can be non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fullmatch_+3A_tol">tol</code></td>
<td>
<p>Because of internal rounding, <code>fullmatch</code> may
solve a slightly different matching problem than the one
specified, in which the match generated by
<code>fullmatch</code> may not coincide with an optimal solution of
the specified problem.  <code>tol</code> times the number of subjects
to be matched specifies the extent to
which <code>fullmatch</code>'s output is permitted to differ from an
optimal solution to the original problem, as measured by the
sum of discrepancies for all treatments and controls placed
into the same matched sets.</p>
</td></tr>
<tr><td><code id="fullmatch_+3A_data">data</code></td>
<td>
<p>Optional <code>data.frame</code> or <code>vector</code> to use to get order
of the final matching factor. If a <code>data.frame</code>, the <code>rownames</code>
are used. If a vector, the <code>names</code> are first tried, otherwise the contents
is considered to be a character vector of names. Useful to pass if you want to
combine a match (using, e.g., <code>cbind</code>) with the data that were used to
generate it (for example, in a propensity score matching).</p>
</td></tr>
<tr><td><code id="fullmatch_+3A_solver">solver</code></td>
<td>
<p>Choose which solver to use. Currently implemented are RELAX-IV
and LEMON. Default of <code>""</code>, a blank string, will use RELAX-IV if the
<strong>rrelaxiv</strong> package is installed, otherwise will use LEMON.
</p>
<p>To explicitly use RELAX-IV, pass string &quot;RELAX-IV&quot;.
</p>
<p>To use LEMON, pass string &quot;LEMON&quot;. Optionally, to specify which algorithm
LEMON will use, pass the function <a href="#topic+LEMON">LEMON</a> with argument for the
algorithm name, &quot;CycleCancelling&quot;, &quot;CapacityScaling&quot;, &quot;CostScaling&quot;, and
&quot;NetworkSimplex&quot;. See this site for details on their differences:
<a href="https://lemon.cs.elte.hu/pub/doc/latest/a00606.html">https://lemon.cs.elte.hu/pub/doc/latest/a00606.html</a>. CycleCancelling is
the default.
</p>
<p>The CycleCancelling algorithm seems to produce results most closely
resembling those of optmatch versions prior to 1.0. We have observed the
other LEMON algorithms to produce different results when the
<code>mean.controls</code> is unspecified, or specified in such a way as to produce
an infeasible matching problem. When using a LEMON algorithm other than
CycleCancelling, we recommend setting the <code>fullmatch_try_recovery</code>
option to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fullmatch_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code>match_on</code> (e.g. <code>within</code>)
or to specific methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If passing an already created discrepancy matrix, finite entries indicate
permissible matches, with smaller discrepancies indicating more desirable
matches.  The matrix must have row and column names.
</p>
<p>If it is desirable to create the discrepancies matrix beforehand (for example,
if planning on running several different matching schemes), consider using
<code><a href="#topic+match_on">match_on</a></code> to generate the distances. This generic function has
several useful methods for handling propensity score models, computing
Mahalanobis distances (and other arbitrary distances), and using user supplied
functions. These distances can also be combined with those generated by
<code><a href="#topic+exactMatch">exactMatch</a></code> and <code><a href="#topic+caliper">caliper</a></code> to create very nuanced
matching specifications.
</p>
<p>The value of <code>tol</code> can have a substantial effect on computation time;
with smaller values, computation takes longer.  Not every tolerance can be
met, and how small a tolerance is too small varies with the machine and with
the details of the problem.  If <code>fullmatch</code> can't guarantee that the
tolerance is as small as the given value of argument <code>tol</code>, then
matching proceeds but a warning is issued.
</p>
<p>By default, <code>fullmatch</code> will attempt, if the given constraints are
infeasible, to find a feasible problem using the same constraints.  This
will almost surely involve using a more restrictive <code>omit.fraction</code> or
<code>mean.controls</code>. (This will never automatically omit treatment units.)
Note that this does not guarantee that the returned match has the least
possible number of omitted subjects, it only gives a match that is feasible
within the given constraints. It may often be possible to loosen the
<code>omit.fraction</code> or <code>mean.controls</code> constraint and still find a
feasible match. The auto recovery is controlled by
<code>options("fullmatch_try_recovery")</code>.
</p>
<p>In full matching problems permitting many-one matches (<code>min.controls</code>
less than 1), the number of controls contributing to matches can exceed
what was requested by setting a value of <code>mean.controls</code> or
<code>omit.fraction</code>.  I.e., in this setting <code>mean.controls</code> sets
the minimum ratio of number of controls to number of treatments placed
into matched sets.
</p>
<p>If the program detects that (what it thinks is) a large problem,
a warning is issued. Unless you have an older computer, there's a good
chance that you can handle larger problems (at the cost of increased
computation time). To check the large problem threshold, use
<code><a href="#topic+getMaxProblemSize">getMaxProblemSize</a></code>; to re-set it, use
<code><a href="#topic+setMaxProblemSize">setMaxProblemSize</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+optmatch">optmatch</a></code> object (<code>factor</code>) indicating matched groups.
</p>


<h3>References</h3>

<p>Hansen, B.B. and Klopfer, S.O. (2006), &lsquo; Optimal full matching and related designs via network flows&rsquo;,
<em>Journal of Computational and Graphical Statistics</em>, <b>15</b>, 609&ndash;627.
</p>
<p>Hansen, B.B. (2004), &lsquo;Full Matching in an Observational Study
of Coaching for the SAT&rsquo;, <em>Journal of the American
Statistical Association</em>, <b>99</b>, 609&ndash;618.
</p>
<p>Rosenbaum, P. (1991), &lsquo;A Characterization of Optimal Designs for Observational
Studies&rsquo;, <em>Journal of the Royal Statistical Society, Series B</em>,
<b>53</b>, 597&ndash;610.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)
### Full matching on a Mahalanobis distance.
( fm1 &lt;- fullmatch(pr ~ t1 + t2, data = nuclearplants) )
summary(fm1)

### Full matching with restrictions.
( fm2 &lt;- fullmatch(pr ~ t1 + t2, min.controls = .5, max.controls = 4, data = nuclearplants) )
summary(fm2)

### Full matching to half of available controls.
( fm3 &lt;- fullmatch(pr ~ t1 + t2, omit.fraction = .5, data = nuclearplants) )
summary(fm3)

### Full matching attempts recovery when the initial restrictions are infeasible.
### Limiting max.controls = 1 allows use of only 10 of 22 controls.
( fm4 &lt;- fullmatch(pr ~ t1 + t2, max.controls = 1, data=nuclearplants) )
summary(fm4)
### To recover restrictions
optmatch_restrictions(fm4)

### Full matching within a propensity score caliper.
ppty &lt;- glm(pr ~ . - (pr + cost), family = binomial(), data = nuclearplants)
### Note that units without counterparts within the caliper are automatically dropped.
### For more complicated models, create a distance matrix and pass it to fullmatch.
mhd &lt;- match_on(pr ~ t1 + t2, data = nuclearplants) + caliper(match_on(ppty), width = 1)
( fm5 &lt;- fullmatch(mhd, data = nuclearplants) )
summary(fm5)

### Propensity balance assessment. Requires RItools package.
if (require(RItools)) summary(fm5,ppty)

### The order of the names in the match factor is the same
### as the nuclearplants data.frame since we used the data argument
### when calling fullmatch. The order would be unspecified otherwise.
cbind(nuclearplants, matches = fm5)

### Match in subgroups only. There are a few ways to specify this.
m1 &lt;- fullmatch(pr ~ t1 + t2, data=nuclearplants,
                within=exactMatch(pr ~ pt, data=nuclearplants))
m2 &lt;- fullmatch(pr ~ t1 + t2 + strata(pt), data=nuclearplants)
### Matching on propensity scores within matching in subgroups only:
m3 &lt;- fullmatch(glm(pr ~ t1 + t2, data=nuclearplants, family=binomial),
                data=nuclearplants,
                within=exactMatch(pr ~ pt, data=nuclearplants))
m4 &lt;- fullmatch(glm(pr ~ t1 + t2 + pt, data=nuclearplants,
                    family=binomial),
                data=nuclearplants,
                within=exactMatch(pr ~ pt, data=nuclearplants))
m5 &lt;- fullmatch(glm(pr ~ t1 + t2 + strata(pt), data=nuclearplants,
                    family=binomial), data=nuclearplants)
# Including `strata(foo)` inside a glm uses `foo` in the model as
# well, so here m4 and m5 are equivalent. m3 differs in that it does
# not include `pt` in the glm.
</code></pre>

<hr>
<h2 id='getMaxProblemSize'>What is the maximum allowed problem size?</h2><span id='topic+getMaxProblemSize'></span>

<h3>Description</h3>

<p>To prevent users from starting excessively large matching problems, the
maximum problem size is limited by <code>options("optmatch_max_problem_size")</code>.
This function a quick helper to assist fetching this value as a scalar. If the
option isn't set, the function falls back to the default value, hard coded in
the <code>optmatch</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMaxProblemSize()
</code></pre>


<h3>Value</h3>

<p>logical
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">options</a></code>, <code><a href="#topic+setMaxProblemSize">setMaxProblemSize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>optmatch:::getMaxProblemSize() &gt; 1 &amp; optmatch:::getMaxProblemSize() &lt; 1e100
</code></pre>

<hr>
<h2 id='hash_dist'>(Internal) Hashing functions for various distance objects
#</h2><span id='topic+hash_dist'></span><span id='topic+hash_dist.DenseMatrix'></span><span id='topic+hash_dist.matrix'></span><span id='topic+hash_dist.InfinitySparseMatrix'></span><span id='topic+hash_dist.BlockedInfinitySparseMatrix'></span><span id='topic+hash_dist.optmatch.dlist'></span>

<h3>Description</h3>

<p>(Internal) Hashing functions for various distance objects
#
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hash_dist(dist)

## S3 method for class 'DenseMatrix'
hash_dist(dist)

## S3 method for class 'matrix'
hash_dist(dist)

## S3 method for class 'InfinitySparseMatrix'
hash_dist(dist)

## S3 method for class 'BlockedInfinitySparseMatrix'
hash_dist(dist)

## S3 method for class 'optmatch.dlist'
hash_dist(dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hash_dist_+3A_dist">dist</code></td>
<td>
<p>Distance object to hash. Must be one of
<code>InfinitySparseMatrix</code>, <code>BlockedInfinitySparseMatrix</code>,
<code>DenseMatrix</code>, <code>matrix</code>, or <code>distmatch.dlist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hash on the distance object with a null <code>call</code>
</p>

<hr>
<h2 id='InfinitySparseMatrix-class'>Objects for sparse matching problems.</h2><span id='topic+InfinitySparseMatrix-class'></span>

<h3>Description</h3>

<p><code>InfinitySparseMatrix</code> is a special class of distance specifications. Finite entries
indicate possible matches, while infinite or NA entries indicated non-allowed
matches. This data type can be more space efficient for sparse matching
problems.
Usually, users will create distance specification using <code><a href="#topic+match_on">match_on</a></code>, <code><a href="#topic+caliper">caliper</a></code>, or
<code><a href="#topic+exactMatch">exactMatch</a></code>. The ordering of units in an <code>InfinitySparseMatrix</code> is not guaranteed to be maintained after subsetting and/or other operations are performed.
</p>


<h3>Slots</h3>


<dl>
<dt><code>colnames</code></dt><dd><p>vector containing names for all control units. This will either be a character vector or NULL if units have no names</p>
</dd>
<dt><code>rownames</code></dt><dd><p>vector containing names for all treated units. This will either be a character vector or NULL if units have no names</p>
</dd>
<dt><code>cols</code></dt><dd><p>vector of integers corresponding to control units</p>
</dd>
<dt><code>rows</code></dt><dd><p>vector of integers corresponding to treated units</p>
</dd>
<dt><code>dimension</code></dt><dd><p>integer vector containing the number of treated and control units, in that order</p>
</dd>
<dt><code>call</code></dt><dd><p>function call used to create the <code>InfinitySparseMatrix</code></p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Mark M. Fredrickson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_on">match_on</a></code>, <code><a href="#topic+caliper">caliper</a></code>, <code><a href="#topic+exactMatch">exactMatch</a></code>, <code><a href="#topic+fullmatch">fullmatch</a></code>,  <code><a href="#topic+pairmatch">pairmatch</a></code>
</p>

<hr>
<h2 id='LEMON'>(Internal) Helper function for accessing algorithms in LEMON solver</h2><span id='topic+LEMON'></span>

<h3>Description</h3>

<p>(Internal) Helper function for accessing algorithms in LEMON solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LEMON(algorithm = "CycleCancelling")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LEMON_+3A_algorithm">algorithm</code></td>
<td>
<p>LEMON algorithm to use. Choices are &quot;CycleCancelling&quot;,
&quot;CapacityScaling&quot;, &quot;CostScaling&quot;, &quot;NetworkSimplex&quot;. Default is
&quot;CycleCancelling&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String of the form &quot;LEMON.&lt;algorithm&gt;&quot;
</p>

<hr>
<h2 id='makeOptmatch'>(Internal) Create <code>optmatch</code> objects, the result of matching.</h2><span id='topic+makeOptmatch'></span>

<h3>Description</h3>

<p>This internal function is used to create the final output of the matching
functions (<code><a href="#topic+fullmatch">fullmatch</a></code> and <code><a href="#topic+pairmatch">pairmatch</a></code>). The
<code>optmatch</code> object descends from a <code>factor</code>, but contains additional
information relating to the quality of the match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeOptmatch(distance, solutions, call, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeOptmatch_+3A_distance">distance</code></td>
<td>
<p>A <code>DistanceSpecificaton</code> object used to create the
match.</p>
</td></tr>
<tr><td><code id="makeOptmatch_+3A_solutions">solutions</code></td>
<td>
<p>A list of the results of the matching, one <code>list(cells,maxErr)</code> object per subproblem.</p>
</td></tr>
<tr><td><code id="makeOptmatch_+3A_call">call</code></td>
<td>
<p>The call to <code>fullmatch</code> or <code>pairmatch</code> to be displayed later.</p>
</td></tr>
<tr><td><code id="makeOptmatch_+3A_data">data</code></td>
<td>
<p>An object from which <code>names</code> or <code>row.names</code> will
provide the order of the items in the match. If no names are attached to this object, the contents will be used as names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>optmatch</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.optmatch">summary.optmatch</a></code>
</p>

<hr>
<h2 id='match_on'>Create treated to control distances for matching problems</h2><span id='topic+match_on'></span><span id='topic+match_on.glm'></span><span id='topic+match_on.bigglm'></span><span id='topic+match_on.formula'></span><span id='topic+match_on.function'></span><span id='topic+match_on.numeric'></span><span id='topic+match_on.InfinitySparseMatrix'></span><span id='topic+match_on.matrix'></span>

<h3>Description</h3>

<p>A function with which to produce matching distances, for instance Mahalanobis
distances, propensity score discrepancies or calipers, or combinations
thereof, for <code><a href="#topic+pairmatch">pairmatch</a></code> or <code><a href="#topic+fullmatch">fullmatch</a></code> to
subsequently &ldquo;match on&rdquo;.  Conceptually, the result of a call
<code>match_on</code> is a treatment-by-control matrix of distances.  Because these
matrices can grow quite large, in practice <code>match_on</code> produces either an
ordinary dense matrix or a special sparse matrix structure (that can make use
of caliper and exact matching constraints to reduce storage requirements).
Methods are supplied for these sparse structures,
<code>InfinitySparseMatrix</code>es, so that they can be manipulated and modified
in much the same way as dense matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_on(x, within = NULL, caliper = NULL, exclude = NULL, data = NULL, ...)

## S3 method for class 'glm'
match_on(
  x,
  within = NULL,
  caliper = NULL,
  exclude = NULL,
  data = NULL,
  standardization.scale = NULL,
  ...
)

## S3 method for class 'bigglm'
match_on(
  x,
  within = NULL,
  caliper = NULL,
  exclude = NULL,
  data = NULL,
  standardization.scale = NULL,
  ...
)

## S3 method for class 'formula'
match_on(
  x,
  within = NULL,
  caliper = NULL,
  exclude = NULL,
  data = NULL,
  subset = NULL,
  method = "mahalanobis",
  ...
)

## S3 method for class ''function''
match_on(
  x,
  within = NULL,
  caliper = NULL,
  exclude = NULL,
  data = NULL,
  z = NULL,
  ...
)

## S3 method for class 'numeric'
match_on(x, within = NULL, caliper = NULL, exclude = NULL, data = NULL, z, ...)

## S3 method for class 'InfinitySparseMatrix'
match_on(x, within = NULL, caliper = NULL, exclude = NULL, data = NULL, ...)

## S3 method for class 'matrix'
match_on(x, within = NULL, caliper = NULL, exclude = NULL, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_on_+3A_x">x</code></td>
<td>
<p>A model formula, fitted glm or other object implicitly specifying a distance; see blurbs on specific methods in Details.</p>
</td></tr>
<tr><td><code id="match_on_+3A_within">within</code></td>
<td>
<p>A valid distance specification, such as the result of
<code><a href="#topic+exactMatch">exactMatch</a></code> or <code><a href="#topic+caliper">caliper</a></code>. Finite entries indicate
which distances to create. Including this argument can significantly speed
up computation for sparse matching problems. Specify this filter either via
<code>within</code> or via <code>strata</code> elements of a formula; mixing these
methods will fail.</p>
</td></tr>
<tr><td><code id="match_on_+3A_caliper">caliper</code></td>
<td>
<p>The width of a caliper to use to exclude treated-control pairs
with values greater than the width. For some methods, there may be a speed
advantage to passing a width rather than using the <code><a href="#topic+caliper">caliper</a></code>
function on an existing distance specification.</p>
</td></tr>
<tr><td><code id="match_on_+3A_exclude">exclude</code></td>
<td>
<p>A list of units (treated or control) to exclude from the
<code>caliper</code> argument (if supplied).</p>
</td></tr>
<tr><td><code id="match_on_+3A_data">data</code></td>
<td>
<p>An optional data frame.</p>
</td></tr>
<tr><td><code id="match_on_+3A_...">...</code></td>
<td>
<p>Other arguments for methods.</p>
</td></tr>
<tr><td><code id="match_on_+3A_standardization.scale">standardization.scale</code></td>
<td>
<p>Function for rescaling of <code>scores(x)</code>, or
<code>NULL</code>; defaults to <code>mad</code>. (See Details.)</p>
</td></tr>
<tr><td><code id="match_on_+3A_subset">subset</code></td>
<td>
<p>A subset of the data to use in creating the distance
specification.</p>
</td></tr>
<tr><td><code id="match_on_+3A_method">method</code></td>
<td>
<p>A string indicating which method to use in computing the
distances from the data.  The current possibilities are
<code>"mahalanobis", "euclidean"</code> or <code>"rank_mahalanobis"</code>.</p>
</td></tr>
<tr><td><code id="match_on_+3A_z">z</code></td>
<td>
<p>A logical or binary vector indicating treatment and control for each
unit in the study. TRUE or 1 represents a treatment unit, FALSE of 0 represents
a control unit. Any unit with NA treatment status will be excluded from the
distance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>match_on</code> is generic. There are several supplied methods, all providing
the same basic output: a matrix (or similar) object with treated units on the
rows and control units on the columns. Each cell [i,j] then indicates the
distance from a treated unit i to control unit j. Entries that are <code>Inf</code>
are said to be unmatchable. Such units are guaranteed to never be in a
matched set. For problems with many <code>Inf</code> entries, so called sparse
matching problems, <code>match_on</code> uses a special data type that is more
space efficient than a standard R <code>matrix</code>.  When problems are not
sparse (i.e. dense), <code>match_on</code> uses the standard <code>matrix</code> type.
</p>
<p><code>match_on</code> methods differ on the types of arguments they take, making
the function a one-stop location of many different ways of specifying
matches: using functions, formulas, models, and even simple scores. Many of
the methods require additional arguments, detailed below. All methods take a
<code>within</code> argument, a distance specification made using
<code><a href="#topic+exactMatch">exactMatch</a></code> or <code><a href="#topic+caliper">caliper</a></code> (or some additive
combination of these or other distance creating functions). All
<code>match_on</code> methods will use the finite entries in the <code>within</code>
argument as a guide for producing the new distance. Any entry that is
<code>Inf</code> in <code>within</code> will be <code>Inf</code> in the distance matrix
returned by <code>match_on</code>. This argument can reduce the processing time
needed to compute sparse distance matrices.
</p>
<p>Details for each particular first type of argument follow:
</p>
<p><b>First argument (<code>x</code>): <code>glm</code>.</b> The model is assumed to be
a fitted propensity score model. From this it extracts distances on the
<em>linear</em> propensity score: fitted values of the linear predictor, the
link function applied to the estimated conditional probabilities, as opposed
to the estimated conditional probabilities themselves (Rosenbaum &amp; Rubin,
1985).  For example, a logistic model (<code>glm</code> with
<code>family=binomial()</code>) has the logit function as its link, so from such
models <code>match_on</code> computes distances in terms of logits of the
estimated conditional probabilities, i.e. the estimated log odds.
</p>
<p>Optionally these distances are also rescaled. The default is to rescale, by
the reciprocal of an outlier-resistant variant of the pooled s.d. of
propensity scores; see <code><a href="#topic+standardization_scale">standardization_scale</a></code>.  (The
<code>standardization.scale</code> argument of this function can be used to
change how this dispersion is calculated, e.g. to calculate an ordinary not
an outlier-resistant s.d.; it will be passed down
to <code>standardization_scale</code> as its <code>standardizer</code> argument.)
To skip rescaling, set argument <code>standardization.scale</code> to 1.
The overall result records
absolute differences between treated and control units on linear, possibly
rescaled, propensity scores.
</p>
<p>In addition, one can impose a caliper in terms of these distances by
providing a scalar as a <code>caliper</code> argument, forbidding matches between
treatment and control units differing in the calculated propensity score by
more than the specified caliper.  For example, Rosenbaum and Rubin's (1985)
caliper of one-fifth of a pooled propensity score s.d. would be imposed by
specifying <code>caliper=.2</code>, in tandem either with the default rescaling
or, to follow their example even more closely, with the additional
specification <code>standardization.scale=sd</code>. Propensity calipers are
beneficial computationally as well as statistically, for reasons indicated
in the below discussion of the <code>numeric</code> method.
</p>
<p>One can also specify exactMatching criteria by using <code>strata(foo)</code> inside
the formula to build the <code>glm</code>. For example, passing
<code>glm(y ~ x + strata(s))</code> to <code>match_on</code> is equivalent to passing
<code>within=exactMatch(y ~ strata(s))</code>. Note that when combining with
the <code>caliper</code> argument, the standard deviation used for the caliper will be
computed across all strata, not within each strata.
</p>
<p>If data used to fit the glm have missing values in the left-hand side
(dependent) variable, these observations are omitted from the output of
match_on.  If there are observations with missing values in right hand
side (independent) variables, then a re-fit of the model after imputing
these variables using a simple scheme and adding indicator variables of
missingness will be attempted, via the <code><a href="#topic+scores">scores</a></code> function.
</p>
<p><b>First argument (<code>x</code>): <code>bigglm</code>.</b> This method works
analogously to the <code>glm</code> method, but with <code>bigglm</code> objects,
created by the <code>bigglm</code> function from package &lsquo;biglm&rsquo;, which
can handle bigger data sets than the ordinary glm function can.
</p>
<p><b>First argument (<code>x</code>): <code>formula</code>.</b> The formula must have
<code>Z</code>, the treatment indicator (<code>Z=0</code> indicates control group,
<code>Z=1</code> indicates treatment group), on the left hand side, and any
variables to compute a distance on on the right hand side. E.g. <code>Z ~ X1
  + X2</code>. The Mahalanobis distance is calculated as the square root of d'Cd,
where d is the vector of X-differences on a pair of observations and C is an
inverse (generalized inverse) of the pooled covariance of Xes. (The pooling
is of the covariance of X within the subset defined by <code>Z==0</code> and
within the complement of that subset. This is similar to a Euclidean
distance calculated after reexpressing the Xes in standard units, such that
the reexpressed variables all have pooled SDs of 1; except that it addresses
redundancies among the variables by scaling down variables contributions in
proportion to their correlations with other included variables.)
</p>
<p>Euclidean distance is also available, via <code>method="euclidean"</code>, and
ranked, Mahalanobis distance, via <code>method="rank_mahalanobis"</code>.
</p>
<p>The treatment indicator <code>Z</code> as noted above must either be numeric
(1 representing treated units and 0 control units) or logical
(<code>TRUE</code> for treated, <code>FALSE</code> for controls). (Earlier versions of
the software accepted factor variables and other types of numeric variable; you
may have to update existing scripts to get them to run.)
</p>
<p>As an alternative to specifying a <code>within</code> argument, when <code>x</code> is
a formula, the <code>strata</code> command can be used inside the formula to specify
exact matching. For example, rather than using <code>within=exactMatch(y ~
  z, data=data)</code>, you may update your formula as <code>y ~ x + strata(z)</code>. Do
not use both methods (<code>within</code> and <code>strata</code> simultaneously. Note
that when combining with the <code>caliper</code> argument, the standard
deviation used for the caliper will be computed across all strata, not
separately by stratum.
</p>
<p>A unit with NA treatment status (<code>Z</code>) is ignored and will not be included in the distance output.
Missing values in variables on the right hand side of the formula are handled as follows. By default
<code>match_on</code> will (1) create a matrix of distances between observations which
have only valid values for **all** covariates and then (2) append matrices of Inf values
for distances between observations either of which has a missing values on any of the right-hand-side variables.
(I.e., observations with missing values are retained in the output, but
matches involving them are forbidden.)
</p>
<p><b>First argument (<code>x</code>): <code>function</code>.</b> The passed function
must take arguments: <code>index</code>, <code>data</code>, and <code>z</code>. The
<code>data</code> and <code>z</code> arguments will be the same as those passed directly
to <code>match_on</code>. The <code>index</code> argument is a matrix of two columns,
representing the pairs of treated and control units that are valid
comparisons (given any <code>within</code> arguments). The first column is the row
name or id of the treated unit in the <code>data</code> object. The second column
is the id for the control unit, again in the <code>data</code> object. For each of
these pairs, the function should return the distance between the treated
unit and control unit.  This may sound complicated, but is simple to
use. For example, a function that returned the absolute difference between
two units using a vector of data would be <code> f &lt;- function(index, data,
  z) { abs(data[index[,1]] - data[index[,2]]) } </code>.  (Note: This simple case is
precisely handled by the <code>numeric</code> method.)
</p>
<p><b>First argument (<code>x</code>): <code>numeric</code>.</b> This returns
absolute differences between treated and control units' values of <code>x</code>.
If a caliper is specified, pairings with <code>x</code>-differences greater than
it are forbidden.  Conceptually, those distances are set to <code>Inf</code>;
computationally, if either of <code>caliper</code> and <code>within</code> has been
specified then only information about permissible pairings will be stored,
so the forbidden pairings are simply omitted. Providing a <code>caliper</code>
argument here, as opposed to omitting it and afterward applying the
<code><a href="#topic+caliper">caliper</a></code> function, reduces storage requirements and may
otherwise improve performance, particularly in larger problems.
</p>
<p>For the numeric method, <code>x</code> must have names. If <code>z</code> is named
it must have the same names as <code>x</code>, though it allows for a different
ordering of names. <code>x</code>'s name ordering is considered canonical.
</p>
<p><b>First argument (<code>x</code>): <code>matrix</code> or <code>InfinitySparseMatrix</code>.</b> These just return their
arguments as these objects are already valid distance specifications.
</p>


<h3>Value</h3>

<p>A distance specification (a matrix or similar object) which is
suitable to be given as the <code>distance</code> argument to
<code><a href="#topic+fullmatch">fullmatch</a></code> or <code><a href="#topic+pairmatch">pairmatch</a></code>.
</p>


<h3>References</h3>

<p>P.~R. Rosenbaum and D.~B. Rubin (1985), &lsquo;Constructing a
control group using multivariate matched sampling methods that incorporate
the propensity score&rsquo;, <em>The American Statistician</em>, <b>39</b> 33&ndash;38.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fullmatch">fullmatch</a></code>, <code><a href="#topic+pairmatch">pairmatch</a></code>,
<code><a href="#topic+exactMatch">exactMatch</a></code>, <code><a href="#topic+caliper">caliper</a></code>
</p>
<p><code><a href="#topic+scores">scores</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)
match_on.examples &lt;- list()
### Propensity score distances.
### Recommended approach:
(aGlm &lt;- glm(pr~.-(pr+cost), family=binomial(), data=nuclearplants))
match_on.examples$ps1 &lt;- match_on(aGlm)
### A second approach: first extract propensity scores, then separately
### create a distance from them.  (Useful when importing propensity
### scores from an external program.)
plantsPS &lt;- predict(aGlm)
match_on.examples$ps2 &lt;- match_on(pr~plantsPS, data=nuclearplants)
### Full matching on the propensity score.
fm1 &lt;- fullmatch(match_on.examples$ps1, data = nuclearplants)
fm2 &lt;- fullmatch(match_on.examples$ps2, data = nuclearplants)
### Because match_on.glm uses robust estimates of spread,
### the results differ in detail -- but they are close enough
### to yield similar optimal matches.
all(fm1 == fm2) # The same

### Mahalanobis distance:
match_on.examples$mh1 &lt;- match_on(pr ~ t1 + t2, data = nuclearplants)

### Absolute differences on a scalar:
tmp &lt;- nuclearplants$t1
names(tmp) &lt;- rownames(nuclearplants)

(absdist &lt;- match_on(tmp, z = nuclearplants$pr,
                  within = exactMatch(pr ~ pt, nuclearplants)))

### Pair matching on the variable `t1`:
pairmatch(absdist, data = nuclearplants)


### Propensity score matching within subgroups:
match_on.examples$ps3 &lt;- match_on(aGlm, exactMatch(pr ~ pt, nuclearplants))
fullmatch(match_on.examples$ps3, data = nuclearplants)

### Propensity score matching with a propensity score caliper:
match_on.examples$pscal &lt;- match_on.examples$ps1 + caliper(match_on.examples$ps1, 1)
fullmatch(match_on.examples$pscal, data = nuclearplants) # Note that the caliper excludes some units

### A Mahalanobis distance for matching within subgroups:
match_on.examples$mh2 &lt;- match_on(pr ~ t1 + t2 , data = nuclearplants,
                            within = exactMatch(pr ~ pt, nuclearplants))

### Mahalanobis matching within subgroups, with a propensity score
### caliper:
fullmatch(match_on.examples$mh2 + caliper(match_on.examples$ps3, 1), data = nuclearplants)

### Alternative methods to matching without groups (exact matching)
m1 &lt;- match_on(pr ~ t1 + t2, data=nuclearplants, within=exactMatch(pr ~ pt, nuclearplants))
m2 &lt;- match_on(pr ~ t1 + t2 + strata(pt), data=nuclearplants)
# m1 and m2 are identical

m3 &lt;- match_on(glm(pr ~ t1 + t2 + cost, data=nuclearplants,
                   family=binomial),
               data=nuclearplants,
               within=exactMatch(pr ~ pt, data=nuclearplants))
m4 &lt;- match_on(glm(pr ~ t1 + t2 + cost + pt, data=nuclearplants,
                   family=binomial),
               data=nuclearplants,
               within=exactMatch(pr ~ pt, data=nuclearplants))
m5 &lt;- match_on(glm(pr ~ t1 + t2 + cost + strata(pt), data=nuclearplants,
                   family=binomial), data=nuclearplants)
# Including `strata(foo)` inside a glm uses `foo` in the model as
# well, so here m4 and m5 are equivalent. m3 differs in that it does
# not include `pt` in the glm.
</code></pre>

<hr>
<h2 id='match_on_szn_scale'>pooled dispersion for a numeric variable</h2><span id='topic+match_on_szn_scale'></span>

<h3>Description</h3>

<p>Pooled Dispersion for a Numeric Variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_on_szn_scale(x, trtgrp, standardizer = mad)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_on_szn_scale_+3A_x">x</code></td>
<td>
<p>numeric variable</p>
</td></tr>
<tr><td><code id="match_on_szn_scale_+3A_trtgrp">trtgrp</code></td>
<td>
<p>logical or numeric. If numeric, coerced to logical via <code>!</code></p>
</td></tr>
<tr><td><code id="match_on_szn_scale_+3A_standardizer">standardizer</code></td>
<td>
<p>function or numeric of length 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dispersion as pooled across a treatment and a control group. By default,
the measure of dispersion calculated within each group is not the
ordinary standard deviation but rather the robust alternative
provided by <code>stats::mad</code>.
</p>


<h3>Value</h3>

<p>numeric of length 1
</p>

<hr>
<h2 id='matched'>Identification of units placed into matched sets</h2><span id='topic+matched'></span><span id='topic+unmatched'></span><span id='topic+matchfailed'></span>

<h3>Description</h3>

<p>Given a bipartite matching (object of class <code>optmatch</code>),
create a logical vector of the same length indicating which units
were and were not placed into matched sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matched(x)

unmatched()

matchfailed(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matched_+3A_x">x</code></td>
<td>
<p>Vector of class <code>optmatch</code> (especially as generated
by a call to <code>fullmatch</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>matched</code> and <code>unmatched</code> indicate which elements of
<code>x</code> do and do not belong to matched sets, as indicated by
their character representations in <code>x</code>.
</p>
<p>When <code>fullmatch</code> has been presented with an inconsistent
combination of constraints and discrepancies between potential
matches, so that there exists no matching (i) with finite total
discrepancy within matched sets that (ii) respects the given
constraints, then the matching problem is said to be infeasible.
<code>TRUE</code>s in the output of <code>matchfailed</code> indicate that
this has occurred.
</p>


<h3>Value</h3>

<p>A logical vector (without names).
</p>


<h3>Note</h3>

<p>To understand the output of <code>matchfailed</code> element-wise,
note that <code>fullmatch</code> handles a matching problem in three
steps.  First, if <code>fullmatch</code> has been directed to match
within subclasses, then it divides its matching problem into a
subproblem for each subclass.  Second, <code>fullmatch</code> removes
from each subproblem those individual units that lack
permissible potential matches (i.e. potential matches from which
they are separated by a finite discrepancy).  Such &quot;isolated&quot;
units are flagged in such a way as to be indicated by
<code>unmatched</code>, but not by <code>matchfailed</code>.  Third,
<code>fullmatch</code> presents each subproblem, with isolated
elements removed, to an optimal matching routine.  If such a
reduced subproblem is found at this stage to be infeasible, then
each unit contributing to it is so flagged as to be indicated by
<code>matchfailed</code>.
</p>


<h3>Author(s)</h3>

<p>Ben Hansen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fullmatch">fullmatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(plantdist)

mxpl.fm0 &lt;- fullmatch(plantdist) # A feasible matching problem
c(sum(matched(mxpl.fm0)), sum(unmatched(mxpl.fm0)))
sum(matchfailed(mxpl.fm0))
mxpl.fm1 &lt;- fullmatch(plantdist, # An infeasible problem
                      max.controls=3, min.controls=3)
c(sum(matched(mxpl.fm1)), sum(unmatched(mxpl.fm1)))
sum(matchfailed(mxpl.fm1))

mxpl.si &lt;- factor(c('a', 'a', 'c', rep('d',4), 'b', 'c', 'c', rep('d', 16)))
names(mxpl.si) &lt;- LETTERS[1:26]
mxpl.exactmatch &lt;- exactMatch(mxpl.si, c(rep(1, 7), rep(0, 26 - 7)))
# Subclass a contains two treated units but no controls;
# subclass b contains only a control unit;
# subclass c contains one treated and two control units;
# subclass d contains the remaining twenty units.
# only valid subproblems will be used

mcl &lt;- c(1, Inf)

mxpl.fm2 &lt;- fullmatch(plantdist + mxpl.exactmatch,
                      max.controls=mcl)
sum(matched(mxpl.fm2))

table(unmatched(mxpl.fm2), matchfailed(mxpl.fm2))

mxpl.fm2[matchfailed(mxpl.fm2)]

mxpl.fm2[unmatched(mxpl.fm2) &amp;   # isolated units return as
         !matchfailed(mxpl.fm2)] # unmatched but not matchfailed

</code></pre>

<hr>
<h2 id='matched.distances'>Determine distances between matched units</h2><span id='topic+matched.distances'></span>

<h3>Description</h3>

<p>From a match (as produced by <code>pairmatch</code> or <code>fullmatch</code>)
and a distance, extract the distances of matched units from their
matched counterparts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matched.distances(matchobj, distance, preserve.unit.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matched.distances_+3A_matchobj">matchobj</code></td>
<td>
<p>Value of a call to <code>pairmatch</code> or
<code>fullmatch</code>.</p>
</td></tr>
<tr><td><code id="matched.distances_+3A_distance">distance</code></td>
<td>
<p>Either a distance matrix or the value of a call to
or <code>match_on</code>.</p>
</td></tr>
<tr><td><code id="matched.distances_+3A_preserve.unit.names">preserve.unit.names</code></td>
<td>
<p>Logical.  If TRUE, for each matched set
<code>matched.distances</code> returns the submatrix of the distance
matrix corresponding to it; if FALSE, a vector containing the
distances in that submatrix is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From a match (as produced by <code>pairmatch</code> or <code>fullmatch</code>)
and a distance, extract the distances of matched units from their
matched counterparts.
</p>


<h3>Value</h3>

<p>A list of numeric vectors (or matrices) of distances, one
for each matched set.  Note that a matched set with 1 treatment
and k controls, or with k treatments and 1 control, has k, not
k+1, distances.
</p>


<h3>Author(s)</h3>

<p>Ben B. Hansen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(plantdist)
plantsfm &lt;- fullmatch(plantdist)
(plantsfm.d &lt;- matched.distances(plantsfm,plantdist,pres=TRUE))
unlist(lapply(plantsfm.d, max))
mean(unlist(plantsfm.d))
</code></pre>

<hr>
<h2 id='maxCaliper'>Find the maximum caliper width that will create a feasible problem.</h2><span id='topic+maxCaliper'></span>

<h3>Description</h3>

<p>Larger calipers permit more possible matches between treated and control
groups, which can be better for creating matches with larger effective sample
sizes. The downside is that wide calipers may make the matching problem too big
for processor or memory constraints. <code>maxCaliper</code> attempts to find a
caliper value, for a given vector of scores and a treatment indicator, that
will be possible given the maximum problem size constraints imposed by
<code><a href="#topic+fullmatch">fullmatch</a></code> and <code><a href="#topic+pairmatch">pairmatch</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxCaliper(scores, z, widths, structure = NULL, exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxCaliper_+3A_scores">scores</code></td>
<td>
<p>A numeric vector of scores providing 1-D position of units</p>
</td></tr>
<tr><td><code id="maxCaliper_+3A_z">z</code></td>
<td>
<p>Treatment indicator vector</p>
</td></tr>
<tr><td><code id="maxCaliper_+3A_widths">widths</code></td>
<td>
<p>A vector of caliper widths to try, will be sorted largest to smallest.</p>
</td></tr>
<tr><td><code id="maxCaliper_+3A_structure">structure</code></td>
<td>
<p>Optional factor variable that groups the scores, as would
be used by <code><a href="#topic+exactMatch">exactMatch</a></code>. Including structure allows for wider
calipers.</p>
</td></tr>
<tr><td><code id="maxCaliper_+3A_exact">exact</code></td>
<td>
<p>A logical indicating if the exact problem size should be
computed (<code>exact = TRUE</code>) or if a more computationally efficient upper
bound should be used instead (<code>exact = FALSE</code>). The upper bound may lead
to narrower calipers, even if wider calipers would have sufficed using the
exact method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric The value of the largest caliper that creates a feasible
problem. If no such caliper exists in <code>widths</code>, an error will be
generated.
</p>

<hr>
<h2 id='maxControlsCap'>Set thinning and thickening caps for full matching</h2><span id='topic+maxControlsCap'></span><span id='topic+minControlsCap'></span>

<h3>Description</h3>

<p>Functions to find the largest value of min.controls, or the
smallest value of max.controls, for which a full matching problem
is feasible.  These are determined by constraints embedded in the
matching problem's distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxControlsCap(distance, min.controls = NULL, solver = "")

minControlsCap(distance, max.controls = NULL, solver = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxControlsCap_+3A_distance">distance</code></td>
<td>
<p>Either a matrix of non-negative, numeric
discrepancies, or a list of such matrices. (See
<code><a href="#topic+fullmatch">fullmatch</a></code> for details.)</p>
</td></tr>
<tr><td><code id="maxControlsCap_+3A_min.controls">min.controls</code></td>
<td>
<p>Optionally, set limits on the minimum number
of controls per matched set.  (Only makes sense for
<code>maxControlsCap</code>.)</p>
</td></tr>
<tr><td><code id="maxControlsCap_+3A_solver">solver</code></td>
<td>
<p>Choose which solver to use. See <code>help(fullmatch)</code>
for details.</p>
</td></tr>
<tr><td><code id="maxControlsCap_+3A_max.controls">max.controls</code></td>
<td>
<p>Optionally, set limits on the maximum number
of controls per matched set.  (Only makes sense for
<code>minControlsCap</code>.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by repeated application of full matching, so on
large problems it can be time-consuming.
</p>


<h3>Value</h3>

<p>For <code>minControlsCap</code>,
<code>strictest.feasible.min.controls</code> and
<code>given.max.controls</code>. For <code>maxControlsCap</code>,
<code>given.min.controls</code> and
<code>strictest.feasible.max.controls</code>.
</p>
<table role = "presentation">
<tr><td><code>strictest.feasible.min.controls</code></td>
<td>
<p>The largest values of the
<code><a href="#topic+fullmatch">fullmatch</a></code> argument <code>min.controls</code> that yield
a full match;</p>
</td></tr>
<tr><td><code>given.max.controls</code></td>
<td>
<p> The <code>max.controls</code> argument
given to <code>minControlsCap</code> or, if none was given, a vector
of <code>Inf</code>s. </p>
</td></tr>
<tr><td><code>given.min.controls</code></td>
<td>
<p> The <code>min.controls</code> argument
given to <code>maxControlsCap</code> or, if none was given, a vector
of <code>0</code>s; </p>
</td></tr>
<tr><td><code>strictest.feasible.max.controls</code></td>
<td>
<p>The smallest values of
the <code><a href="#topic+fullmatch">fullmatch</a></code> argument <code>max.controls</code> that
yield a full match.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Essentially this is just a line search.  I've done several
things to speed it up, but not everything that might be done.
At present, not very thoroughly tested either: you might check
the final results to make sure that <code><a href="#topic+fullmatch">fullmatch</a></code>
works with the values of <code>min.controls</code> (or
<code>max.controls</code>) suggested by these functions, and that it
ceases to work if you increase (decrease) those values.
Comments appreciated.
</p>


<h3>Author(s)</h3>

<p>Ben B. Hansen
</p>


<h3>References</h3>

<p>Hansen, B.B. and S. Olsen Klopfer (2006),
&lsquo;Optimal full matching and related designs via network
flows&rsquo;, <em>Journal of Computational and Graphical Statistics</em>
<b>15</b>, 609&ndash;627.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fullmatch">fullmatch</a></code>
</p>

<hr>
<h2 id='mdist'>(Deprecated, in favor of <code><a href="#topic+match_on">match_on</a></code>) Create
matching distances</h2><span id='topic+mdist'></span><span id='topic+mdist.optmatch.dlist'></span><span id='topic+mdist.function'></span><span id='topic+mdist.formula'></span><span id='topic+mdist.glm'></span><span id='topic+mdist.bigglm'></span><span id='topic+mdist.numeric'></span>

<h3>Description</h3>

<p>Deprecated in favor of <code><a href="#topic+match_on">match_on</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdist(x, structure.fmla = NULL, ...)

## S3 method for class 'optmatch.dlist'
mdist(x, structure.fmla = NULL, ...)

## S3 method for class ''function''
mdist(x, structure.fmla = NULL, data = NULL, ...)

## S3 method for class 'formula'
mdist(x, structure.fmla = NULL, data = NULL, subset = NULL, ...)

## S3 method for class 'glm'
mdist(x, structure.fmla = NULL, standardization.scale = mad, ...)

## S3 method for class 'bigglm'
mdist(x, structure.fmla = NULL, data = NULL, standardization.scale = mad, ...)

## S3 method for class 'numeric'
mdist(x, structure.fmla = NULL, trtgrp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdist_+3A_x">x</code></td>
<td>
<p>The object to use as the basis for forming the mdist.
Methods exist for formulas, functions, and generalized linear
models.</p>
</td></tr>
<tr><td><code id="mdist_+3A_structure.fmla">structure.fmla</code></td>
<td>
<p>A formula denoting the treatment variable on
the left hand side and an optional grouping expression on the
right hand side. For example, <code>z ~ 1</code> indicates no
grouping. <code>z ~ s</code> subsets the data only computing distances
within the subsets formed by <code>s</code>. See method notes, below,
for additional formula options.</p>
</td></tr>
<tr><td><code id="mdist_+3A_...">...</code></td>
<td>
<p>Additional method arguments. Most methods require a
'data' argument.</p>
</td></tr>
<tr><td><code id="mdist_+3A_data">data</code></td>
<td>
<p>Data where the variables references in <code>x</code> live.</p>
</td></tr>
<tr><td><code id="mdist_+3A_subset">subset</code></td>
<td>
<p>If non-<code>NULL</code>, the subset of <code>data</code> to be used.</p>
</td></tr>
<tr><td><code id="mdist_+3A_standardization.scale">standardization.scale</code></td>
<td>
<p>A function to scale the distances; by
default uses <code>mad</code>.</p>
</td></tr>
<tr><td><code id="mdist_+3A_trtgrp">trtgrp</code></td>
<td>
<p>Dummy variable for treatment group membership.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mdist</code> method provides three ways to construct a
matching distance (i.e., a distance matrix or suitably organized
list of such matrices): guided by a function, by a fitted model,
or by a formula.  The class of the first argument given to
<code>mdist</code> determines which of these methods is invoked.
</p>
<p>The <code>mdist.function</code> method takes a function of two
arguments. When called, this function will receive the treatment
observations as the first argument and the control observations as
the second argument. As an example, the following computes the raw
differences between values of <code>t1</code> for treatment units (here,
nuclear plants with <code>pr==1</code>) and controls (here, plants with
<code>pr==0</code>), returning the result as a distance matrix:
</p>
<p><code>sdiffs &lt;- function(treatments, controls) {
     abs(outer(treatments$t1, controls$t1, `-`))
   }
 </code>
</p>
<p>The <code>mdist.function</code> method does similar things as the
earlier optmatch function <code>makedist</code>, although the interface
is a bit different.
</p>
<p>The <code>mdist.formula</code> method computes the squared Mahalanobis
distance between observations, with the right-hand side of the
formula determining which variables contribute to the Mahalanobis
distance. If matching is to be done within strata, the
stratification can be communicated using either the
<code>structure.fmla</code> argument (e.g. <code>~ grp</code>) or as part of
the main formula (e.g. <code>z ~ x1 + x2 | grp</code>).
</p>
<p>An <code>mdist.glm</code> method takes an argument of class <code>glm</code>
as first argument.  It assumes that this object is a fitted
propensity model, extracting distances on the linear propensity
score (logits of the estimated conditional probabilities) and, by
default, rescaling the distances by the reciprocal of the pooled
s.d. of treatment- and control-group propensity scores.  (The
scaling uses <code>mad</code>, for resistance to outliers, by default;
this can be changed to the actual s.d., or rescaling can be
skipped entirely, by setting argument
<code>standardization.scale</code> to <code>sd</code> or <code>NULL</code>,
respectively.)  A <code>mdist.bigglm</code> method works analogously
with <code>bigglm</code> objects, created by the <code>bigglm</code> function
from package &lsquo;biglm&rsquo;, which can handle bigger data sets
than the ordinary glm function can.  In contrast with
<code>mdist.glm</code> it requires additional <code>data</code> and
<code>structure.fmla</code> arguments.  (If you have enough data to
have to use <code>bigglm</code>, then you'll probably have to subgroup
before matching to avoid memory problems. So you'll have to use
the <code>structure.fmla</code> argument anyway.)
</p>


<h3>Value</h3>

<p>Object of class <code>optmatch.dlist</code>, which is suitable
to be given as <code>distance</code> argument to
<code><a href="#topic+fullmatch">fullmatch</a></code> or <code><a href="#topic+pairmatch">pairmatch</a></code>.
</p>


<h3>Author(s)</h3>

<p>Mark M. Fredrickson
</p>


<h3>References</h3>

<p>P.~R. Rosenbaum and D.~B. Rubin (1985),
&lsquo;Constructing a control group using multivariate matched
sampling methods that incorporate the propensity score&rsquo;,
<em>The American Statistician</em>, <b>39</b> 33&ndash;38.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fullmatch">fullmatch</a></code>, <code><a href="#topic+pairmatch">pairmatch</a></code>,
<code><a href="#topic+match_on">match_on</a></code>
</p>

<hr>
<h2 id='minExactMatch'>Find the minimal exact match factors that will be feasible for a
given maximum problem size.</h2><span id='topic+minExactMatch'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+exactMatch">exactMatch</a></code> function creates a smaller matching problem by
stratifying observations into smaller groups. For a problem that is larger
than maximum allowed size, <code>minExactMatch</code> provides a way to find the
smallest exact matching problem that will allow for matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minExactMatch(x, scores = NULL, width = NULL, maxarcs = 1e+07, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minExactMatch_+3A_x">x</code></td>
<td>
<p>The object for dispatching.</p>
</td></tr>
<tr><td><code id="minExactMatch_+3A_scores">scores</code></td>
<td>
<p>Optional vector of scores that will be checked against a caliper width.</p>
</td></tr>
<tr><td><code id="minExactMatch_+3A_width">width</code></td>
<td>
<p>Optional width of a caliper to place on the scores.</p>
</td></tr>
<tr><td><code id="minExactMatch_+3A_maxarcs">maxarcs</code></td>
<td>
<p>The maximum problem size to attempt to fit.</p>
</td></tr>
<tr><td><code id="minExactMatch_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> is a formula of the form <code>Z ~ X1 + X2</code>, where
<code>Z</code> is indicates treatment or control status, and <code>X1</code> and <code>X2</code> are variables
can be converted to factors. Any additional arguments are passed to <code><a href="stats.html#topic+model.frame">model.frame</a></code>
(e.g., a <code>data</code> argument containing <code>Z</code>, <code>X1</code>, and <code>X2</code>).
</p>
<p>The the arguments <code>scores</code> and <code>width</code> must be passed together.
The function will apply the caliper implied by the scores and the width while
also adding in blocking factors.
</p>


<h3>Value</h3>

<p>A factor grouping units, suitable for <code><a href="#topic+exactMatch">exactMatch</a></code>.
</p>

<hr>
<h2 id='missing_x_msg'>(Internal) If the x argument does not exist for
match_on, fullmatch, or pairmatch, use this function
to print a helpful message.</h2><span id='topic+missing_x_msg'></span>

<h3>Description</h3>

<p>(Internal) If the x argument does not exist for
match_on, fullmatch, or pairmatch, use this function
to print a helpful message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_x_msg(x_str, data_str, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missing_x_msg_+3A_x_str">x_str</code></td>
<td>
<p>x as a string of code, usually deparse(substitute(x))</p>
</td></tr>
<tr><td><code id="missing_x_msg_+3A_data_str">data_str</code></td>
<td>
<p>data arg as string of code</p>
</td></tr>
<tr><td><code id="missing_x_msg_+3A_...">...</code></td>
<td>
<p>will look for 'z = &lt;stuff&gt;' in the extra args of caller</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string a helpful error message
</p>


<h3>Author(s)</h3>

<p>Josh Buckner
</p>

<hr>
<h2 id='model.frame.svyglm'>This method quells a warning when <code>optmatch::scores()</code>
is applied to a svyglm object.</h2><span id='topic+model.frame.svyglm'></span>

<h3>Description</h3>

<p>This method quells a warning when <code>optmatch::scores()</code>
is applied to a svyglm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svyglm'
model.frame(formula, ...)
</code></pre>

<hr>
<h2 id='nuclearplants'>Nuclear Power Station Construction Data</h2><span id='topic+nuclearplants'></span>

<h3>Description</h3>

<p>The data relate to the construction of 32 light water reactor (LWR)
plants constructed in the U.S.A in the late 1960's and early
1970's.  The data was collected with the aim of predicting the cost
of construction of further LWR plants.  6 of the power plants had
partial turnkey guarantees and it is possible that, for these
plants, some manufacturers' subsidies may be hidden in the quoted
capital costs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nuclearplants
</code></pre>


<h3>Format</h3>

<p>A data frame with 32 rows and 11 columns
</p>

<ul>
<li><p> cost: The capital cost of construction in millions of
dollars adjusted to 1976 base.
</p>
</li>
<li><p> date: The date on which the construction permit was issued.
The data are measured in years since January 1 1990 to the
nearest month.
</p>
</li>
<li><p> t1: The time between application for and issue of the
construction permit.
</p>
</li>
<li><p> t2: The time between issue of operating license and
construction permit.
</p>
</li>
<li><p> cap: The net capacity of the power plant (MWe).
</p>
</li>
<li><p> pr: A binary variable where <code>1</code> indicates the prior
existence of a LWR plant at the same site.
</p>
</li>
<li><p> ne: A binary variable where <code>1</code> indicates that the
plant was constructed in the north-east region of the U.S.A.
</p>
</li>
<li><p> ct: A binary variable where <code>1</code> indicates the use of a
cooling tower in the plant.
</p>
</li>
<li><p> bw: A binary variable where <code>1</code> indicates that the
nuclear steam supply system was manufactured by Babcock-Wilcox.
</p>
</li>
<li><p> cum.n: The cumulative number of power plants constructed by
each architect-engineer.
</p>
</li>
<li><p> pt: A binary variable where <code>1</code> indicates those plants
with partial turnkey guarantees.
</p>
</li></ul>



<h3>Source</h3>

<p>The data were obtained from the <code>boot</code> package, for
which they were in turn taken from Cox and Snell (1981). Although
the data themselves are the same as those in the <code>nuclear</code>
data frame in the <code>boot</code> package, the row names of the data
frame have been changed.  (The new row names were selected to
ease certain demonstrations in <code>optmatch</code>.)
</p>
<p>This documentation page is also adapted from the <code>boot</code>
package, written by Angelo Canty and ported to R by Brian Ripley.
</p>


<h3>References</h3>

<p>Cox, D.R. and Snell, E.J. (1981) <em>Applied Statistics:
Principles and Examples</em>. Chapman and Hall.
</p>

<hr>
<h2 id='num_eligible_matches'>Returns the number of eligible matches for the distance.</h2><span id='topic+num_eligible_matches'></span><span id='topic+num_eligible_matches.optmatch.dlist'></span><span id='topic+num_eligible_matches.matrix'></span><span id='topic+num_eligible_matches.InfinitySparseMatrix'></span><span id='topic+num_eligible_matches.BlockedInfinitySparseMatrix'></span>

<h3>Description</h3>

<p>This will return a list of the number of finite entries in a distance
matrix. If the distance has no subgroups, it will be a list of length 1. If
the distance has subgroups (i.e. <code>x</code> is an
<code>BlockedInfinitySparseMatrix</code>, it will be a named list.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_eligible_matches(x)

## S3 method for class 'optmatch.dlist'
num_eligible_matches(x)

## S3 method for class 'matrix'
num_eligible_matches(x)

## S3 method for class 'InfinitySparseMatrix'
num_eligible_matches(x)

## S3 method for class 'BlockedInfinitySparseMatrix'
num_eligible_matches(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="num_eligible_matches_+3A_x">x</code></td>
<td>
<p>Any distance object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list counting the number of eligible matches in the distance.
</p>

<hr>
<h2 id='optmatch'>Optmatch Class</h2><span id='topic+optmatch'></span><span id='topic+optmatch-class'></span><span id='topic+summary.optmatch'></span>

<h3>Description</h3>

<p>The <code>optmatch</code> class describes the results of an optimal full matching
(using either <code><a href="#topic+fullmatch">fullmatch</a></code> or <code><a href="#topic+pairmatch">pairmatch</a></code>). For the
most part, these objects can be treated as <code>factors</code>.
</p>
<p>The summary function quantifies <code>optmatch</code> objects on the effective sample
size, the distribution of distances between matched units, and how well the
match reduces average differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optmatch'
summary(
  object,
  propensity.model = NULL,
  ...,
  min.controls = 0.2,
  max.controls = 5,
  quantiles = c(0, 0.5, 0.95, 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optmatch_+3A_object">object</code></td>
<td>
<p>The <code>optmatch</code> object to summarize.</p>
</td></tr>
<tr><td><code id="optmatch_+3A_propensity.model">propensity.model</code></td>
<td>
<p>An optional propensity model (the result of
a call to <code>glm</code>) to use when summarizing the match. If the
<span class="pkg">RItools</span> package is installed, an additional chi-squared test will
be performed on the average differences between treated and
control units on each variable used in the model. See the
<code>xBalance</code> function in the <span class="pkg">RItools</span> package for more
details.</p>
</td></tr>
<tr><td><code id="optmatch_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>xBalance</code> when
also passing a propensity model.</p>
</td></tr>
<tr><td><code id="optmatch_+3A_min.controls">min.controls</code></td>
<td>
<p>To minimize the the display of a groups with
many treated and few controls, all groups with more than 5
treated units will be summarized as &ldquo;5+&rdquo;. This is the
reciprocal of the default value (1/5 = 0.2). Lower this value to
see more groups.</p>
</td></tr>
<tr><td><code id="optmatch_+3A_max.controls">max.controls</code></td>
<td>
<p>Like <code>min.controls</code> sets maximum group
sized displayed with respect to the number of controls. Raise
this value to see more groups.</p>
</td></tr>
<tr><td><code id="optmatch_+3A_quantiles">quantiles</code></td>
<td>
<p>A points in the ECDF at which the distances
between units will be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>optmatch</code> objects descend from <code>factor</code>.
Elements of this vector correspond to members of the treatment and control
groups in reference to which the matching problem was posed, and are named
accordingly; the names are taken from the row and column names of
<code>distance</code>.  Each element of the vector is either <code>NA</code>, indicating
unavailability of any suitable matches for that element, or the
concatenation of: (i) a character abbreviation of the name of the subclass
(as encoded using <code><a href="#topic+exactMatch">exactMatch</a></code>) (ii) the string <code>.</code>; and
(iii) a non-negative integer.  In this last place, positive whole numbers
indicate placement of the unit into a matched set and <code>NA</code> indicates
that all or part of the matching problem given to <code>fullmatch</code> was found
to be infeasible.  The functions <code><a href="#topic+matched">matched</a></code>,
<code><a href="#topic+unmatched">unmatched</a></code>, and <code><a href="#topic+matchfailed">matchfailed</a></code> distinguish these
scenarios.
</p>
<p>Secondarily, <code>fullmatch</code> returns various data about the matching
process and its result, stored as attributes of the named vector which is
its primary output.  In particular, the <code>exceedances</code> attribute gives
upper bounds, not necessarily sharp, for the amount by which the sum of
distances between matched units in the result of <code>fullmatch</code> exceeds
the least possible sum of distances between matched units in a feasible
solution to the matching problem given to <code>fullmatch</code>.  (Such a bound
is also printed by <code>print.optmatch</code> and <code>summary.optmatch</code>.)
</p>


<h3>Value</h3>

<p><code>optmatch.summary</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.optmatch">print.optmatch</a></code>
</p>

<hr>
<h2 id='optmatch_restrictions'>optmatch_restrictions</h2><span id='topic+optmatch_restrictions'></span>

<h3>Description</h3>

<p>Returns the restrictions which were used to generate the match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optmatch_restrictions(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optmatch_restrictions_+3A_obj">obj</code></td>
<td>
<p>An optmatch object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mean.controls</code> was explicitly specified in the creation of the
optmatch object, it is returned; otherwise <code>omit.fraction</code> is given.
</p>
<p>Note that if the matching algorithm attempted to recover from initial
infeasible restrictions, the output from this function may not be the same as
the original function call.
</p>


<h3>Value</h3>

<p>A list of <code>min.controls</code>, <code>max.controls</code> and either
<code>omit.fraction</code> or <code>mean.controls</code>.
</p>

<hr>
<h2 id='optmatch_same_distance'>Checks if two distances are equivalent. <code>x</code> and <code>y</code> can be
distances (<code>InfinitySparseMatrix</code>, <code>BlockedInfinitySparseMatrix</code>,
or <code>DenseMatrix</code>), or they can be <code>optmatch</code> objects.</h2><span id='topic+optmatch_same_distance'></span>

<h3>Description</h3>

<p>To save space, <code>optmatch</code> objects merely store a hash of the distance
matrix instead of the original object. Any distance objects are hashed before
comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optmatch_same_distance(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optmatch_same_distance_+3A_x">x</code></td>
<td>
<p>A distances (<code>InfinitySparseMatrix</code>,
<code>BlockedInfinitySparseMatrix</code>, or <code>DenseMatrix</code>), or
<code>optmatch</code> object.</p>
</td></tr>
<tr><td><code id="optmatch_same_distance_+3A_y">y</code></td>
<td>
<p>A distances (<code>InfinitySparseMatrix</code>,
<code>BlockedInfinitySparseMatrix</code>, or <code>DenseMatrix</code>), or
<code>optmatch</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the distance is hashed with its <code>call</code> set to <code>NULL</code>.
(This avoids issues where, for example, <code>match_on(Z~X, data=d,
caliper=NULL)</code> and <code>match_on(Z~X, data=d)</code> produce identical matches but
have differing <code>call</code>s.)
</p>


<h3>Value</h3>

<p>Boolean whether the two distance specifications are identical.
</p>

<hr>
<h2 id='optmatch-defunct'>Functions deprecated or removed from optmatch</h2><span id='topic+optmatch-defunct'></span><span id='topic+pscore.dist'></span><span id='topic+mahal.dist'></span>

<h3>Description</h3>

<p>Over the course of time, several functions in optmatch have been removed in
favor of new interfaces and functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pscore.dist(...)

mahal.dist(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optmatch-defunct_+3A_...">...</code></td>
<td>
<p>All arguments ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mdist">mdist</a></code>, <code><a href="#topic+match_on">match_on</a></code>
</p>

<hr>
<h2 id='pairmatch'>Optimal 1:1 and 1:k matching</h2><span id='topic+pairmatch'></span><span id='topic+pair'></span>

<h3>Description</h3>

<p>Given a treatment group, a larger control reservoir, and a method for creating
discrepancies between each treatment and control unit (or optionally an
already created such discrepancy matrix), finds a pairing of treatment units
to controls that minimizes the sum of discrepancies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairmatch(x, controls = 1, data = NULL, remove.unmatchables = FALSE, ...)

pair(x, controls = 1, data = NULL, remove.unmatchables = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairmatch_+3A_x">x</code></td>
<td>
<p>Any valid input to <code>match_on</code>. If <code>x</code> is a numeric vector,
there must also be passed a vector <code>z</code> indicating grouping. Both vectors
must be named.
</p>
<p>Alternatively, a precomputed distance may be entered.</p>
</td></tr>
<tr><td><code id="pairmatch_+3A_controls">controls</code></td>
<td>
<p>The number of controls to be matched to each treatment</p>
</td></tr>
<tr><td><code id="pairmatch_+3A_data">data</code></td>
<td>
<p>Optional data set.</p>
</td></tr>
<tr><td><code id="pairmatch_+3A_remove.unmatchables">remove.unmatchables</code></td>
<td>
<p>Should treatment group members for which there are
no eligible controls be removed prior to matching?</p>
</td></tr>
<tr><td><code id="pairmatch_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="#topic+match_on">match_on</a></code>
(e.g. <code>within</code>)) or to <code><a href="#topic+fullmatch">fullmatch</a></code> (e.g. <code>tol</code>).
It is an error to pass <code>min.controls</code>,
<code>max.controls</code>, <code>mean.controls</code> or <code>omit.fraction</code> as
<code>pairmatch</code> must set these values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper to <code><a href="#topic+fullmatch">fullmatch</a></code>; see its documentation for more
information, especially on additional arguments to pass, additional discussion
of valid input for parameter <code>x</code>, and feasibility recovery.
</p>
<p>If <code>remove.unmatchables</code> is <code>FALSE</code>, then if there are unmatchable
treated units then the matching as a whole will fail and no units will be
matched.  If <code>TRUE</code>, then this unit will be removed and the function will
attempt to match each of the other treatment units.  As of version 0.9-8,
if there are fewer matchable treated units than matchable controls then
<code>pairmatch</code> will attempt to place each into a matched pair each of the
matchable controls and a strict subset of the matchable treated units.
(Previously matching would have failed for subclasses of this structure.)
</p>
<p>Matching can still fail,
even with <code>remove.unmatchables</code> set to <code>TRUE</code>,
if there is too much competition for certain controls; if you
find yourself in that situation you should consider full matching, which
necessarily finds a match for everyone with an eligible match somewhere.
</p>
<p>The units of the <code>optmatch</code> object returned correspond to members of the
treatment and control groups in reference to which the matching problem was
posed, and are named accordingly; the names are taken from the row and column
names of <code>distance</code> (with possible additions from the optional
<code>data</code> argument).  Each element of the vector is the concatenation of:
(i) a character abbreviation of <code>subclass.indices</code>, if that argument was
given, or the string '<code>m</code>' if it was not; (ii) the string <code>.</code>; and
(iii) a non-negative integer. Unmatched units have <code>NA</code> entries.
Secondarily, <code>fullmatch</code> returns various data about the matching process
and its result, stored as attributes of the named vector which is its primary
output.  In particular, the <code>exceedances</code> attribute gives upper bounds,
not necessarily sharp, for the amount by which the sum of distances between
matched units in the result of <code>fullmatch</code> exceeds the least possible sum
of distances between matched units in a feasible solution to the matching
problem given to <code>fullmatch</code>.  (Such a bound is also printed by
<code>print.optmatch</code> and by <code>summary.optmatch</code>.)
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+optmatch">optmatch</a></code> object (<code>factor</code>) indicating matched groups.
</p>


<h3>References</h3>

<p>Hansen, B.B. and Klopfer, S.O. (2006), &lsquo;Optimal full matching
and related designs via network flows&rsquo;, <em>Journal of Computational
and Graphical Statistics</em>, <b>15</b>, 609&ndash;627.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matched">matched</a></code>, <code><a href="#topic+caliper">caliper</a></code>, <code><a href="#topic+fullmatch">fullmatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)

### Pair matching on a Mahalanobis distance
( pm1 &lt;- pairmatch(pr ~ t1 + t2, data = nuclearplants) )
summary(pm1)

### Pair matching within a propensity score caliper.
ppty &lt;- glm(pr ~ . - (pr + cost), family = binomial(), data = nuclearplants)
### For more complicated models, create a distance matrix and pass it to fullmatch.
mhd &lt;- match_on(pr ~ t1 + t2, data = nuclearplants) + caliper(match_on(ppty), 2)
( pm2 &lt;- pairmatch(mhd, data = nuclearplants) )
summary(pm2)

### Propensity balance assessment. Requires RItools package.
if(require(RItools)) summary(pm2, ppty)

### 1:2 matched triples
( tm &lt;- pairmatch(pr ~ t1 + t2, controls = 2, data = nuclearplants) )
summary(tm)

### Creating a data frame with the matched sets attached.
### match_on(), caliper() and the like cooperate with pairmatch()
### to make sure observations are in the proper order:
all.equal(names(tm), row.names(nuclearplants))
### So our data frame including the matched sets is just
cbind(nuclearplants, matches=tm)

### In contrast, if your matching distance is an ordinary matrix
### (as earlier versions of optmatch required), you'll
### have to align it by observation name with your data set.
cbind(nuclearplants, matches = tm[row.names(nuclearplants)])


### Match in subgroups only. There are a few ways to specify this.
m1 &lt;- pairmatch(pr ~ t1 + t2, data=nuclearplants,
                within=exactMatch(pr ~ pt, data=nuclearplants))
m2 &lt;- pairmatch(pr ~ t1 + t2 + strata(pt), data=nuclearplants)
### Matching on propensity scores within matching in subgroups only:
m3 &lt;- pairmatch(glm(pr ~ t1 + t2, data=nuclearplants, family=binomial),
                data=nuclearplants,
                within=exactMatch(pr ~ pt, data=nuclearplants))
m4 &lt;- pairmatch(glm(pr ~ t1 + t2 + pt, data=nuclearplants,
                    family=binomial),
                data=nuclearplants,
                within=exactMatch(pr ~ pt, data=nuclearplants))
m5 &lt;- pairmatch(glm(pr ~ t1 + t2 + strata(pt), data=nuclearplants,
                    family=binomial), data=nuclearplants)
# Including `strata(foo)` inside a glm uses `foo` in the model as
# well, so here m4 and m5 are equivalent. m3 differs in that it does
# not include `pt` in the glm.
</code></pre>

<hr>
<h2 id='plantdist'>Dissimilarities of Some U.S. Nuclear Plants</h2><span id='topic+plantdist'></span>

<h3>Description</h3>

<p>This matrix gives discrepancies between light water nuclear power
plants of two types, seven built on the site of an existing plant
and 19 built on new sites.  The discrepancies summarize differences
in two covariates that are predictive of the cost of building a
plant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plantdist
</code></pre>


<h3>Format</h3>

<p>A matrix with 7 rows and 19 columns
</p>


<h3>Source</h3>

<p>The data appear in Cox, D.R. and Snell, E.J. (1981),
<em>Applied Statistics: Principles and Examples</em>, p.82 (Chapman
and Hall), and are due to W.E. Mooz.
</p>


<h3>References</h3>

<p>Rosenbaum, P.R. (2002), <em>Observational Studies</em>,
Second Edition, p.307 (Springer).
</p>

<hr>
<h2 id='predict.CBPS'>(Internal) Predict for CBPS objects</h2><span id='topic+predict.CBPS'></span>

<h3>Description</h3>

<p>The CBPS package fits &lsquo;covariate balancing propensity score&rsquo; for use in propensity score
weighting.  In the binary treatment case they can also be used for matching.  This method helps to 
implement that process in a manner consistent with use of propensity scores elsewhere in optmatch; see
<code><a href="#topic+scores">scores</a></code> documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBPS'
predict(object, newdata = NULL, type = c("link", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.CBPS_+3A_object">object</code></td>
<td>
<p>A CBPS object</p>
</td></tr>
<tr><td><code id="predict.CBPS_+3A_newdata">newdata</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="predict.CBPS_+3A_type">type</code></td>
<td>
<p>Return inverse logits of fitted values (the default) or fitted values themselves</p>
</td></tr>
<tr><td><code id="predict.CBPS_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Inverse logit of the fitted values.
</p>

<hr>
<h2 id='print.optmatch'>Printing <code>optmatch</code> objects.</h2><span id='topic+print.optmatch'></span>

<h3>Description</h3>

<p>Printing <code>optmatch</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optmatch'
print(x, quote = FALSE, grouped = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.optmatch_+3A_x">x</code></td>
<td>
<p>The <code>optmatch</code> object, as returned by
<code><a href="#topic+fullmatch">fullmatch</a></code> or <code><a href="#topic+pairmatch">pairmatch</a></code>.</p>
</td></tr>
<tr><td><code id="print.optmatch_+3A_quote">quote</code></td>
<td>
<p>A boolean indicating if the matched group names should
be quoted or not (default is not to quote).</p>
</td></tr>
<tr><td><code id="print.optmatch_+3A_grouped">grouped</code></td>
<td>
<p>A logical indicating if the object should printed in
the style of a named <code>factor</code> object (<code>grouped = TRUE</code>)
or as a table of group names and members.</p>
</td></tr>
<tr><td><code id="print.optmatch_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fullmatch">fullmatch</a></code>, <code><a href="#topic+pairmatch">pairmatch</a></code>,
<code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+summary.optmatch">summary.optmatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)
fm &lt;- fullmatch(pr ~ t1 + t2, data = nuclearplants)

print(fm)
print(fm, grouped = TRUE)
</code></pre>

<hr>
<h2 id='revise_ArcInfo_nodelabels'>Reset implicit node labels of an ArcInfo object</h2><span id='topic+revise_ArcInfo_nodelabels'></span>

<h3>Description</h3>

<p>Reset implicit node labels of an ArcInfo object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revise_ArcInfo_nodelabels(x, new, old_positions = 1L:length(new))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="revise_ArcInfo_nodelabels_+3A_x">x</code></td>
<td>
<p>an ArcInfo object</p>
</td></tr>
<tr><td><code id="revise_ArcInfo_nodelabels_+3A_new">new</code></td>
<td>
<p>character; the new node labels (level sets for factors encoding arc start or end nodes)</p>
</td></tr>
<tr><td><code id="revise_ArcInfo_nodelabels_+3A_old_positions">old_positions</code></td>
<td>
<p>integer; positions for old levels with new levels vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ArcInfo object with new levels
</p>


<h3>Author(s)</h3>

<p>Ben Hansen
</p>

<hr>
<h2 id='scoreCaliper'>(Internal) Helper function to create an InfinitySparseMatrix from a set of
scores, a treatment indicator, and a caliper width.</h2><span id='topic+scoreCaliper'></span>

<h3>Description</h3>

<p>(Internal) Helper function to create an InfinitySparseMatrix from a set of
scores, a treatment indicator, and a caliper width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreCaliper(x, z, caliper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoreCaliper_+3A_x">x</code></td>
<td>
<p>The scores, a vector indicating the 1-D location of each
unit.</p>
</td></tr>
<tr><td><code id="scoreCaliper_+3A_z">z</code></td>
<td>
<p>The treatment assignment vector (same length as <code>x</code>)</p>
</td></tr>
<tr><td><code id="scoreCaliper_+3A_caliper">caliper</code></td>
<td>
<p>The width of the caliper with respect to the scores
<code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>InfinitySparseMatrix</code> object, suitable to be
passed to <code><a href="#topic+match_on">match_on</a></code> as an <code>within</code> argument.
</p>

<hr>
<h2 id='scores'>Extract scores (propensity, prognostic,...) from a fitted model</h2><span id='topic+scores'></span>

<h3>Description</h3>

<p>This is a wrapper for <code>predict</code>, adapted for use in matching.  Given a
fitted model but no explicit <code>newdata</code> to &lsquo;predict&rsquo; from, it
constructs its own <code>newdata</code> in a manner that's generally better suited
for matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scores_+3A_object">object</code></td>
<td>
<p>fitted model object determining scores to be generated.</p>
</td></tr>
<tr><td><code id="scores_+3A_newdata">newdata</code></td>
<td>
<p>(optional) data frame containing variables with which scores
are produced.</p>
</td></tr>
<tr><td><code id="scores_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>predict</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Like <code>predict</code>, its default predictions from a <code>glm</code> are on
the scale of the linear predictor, not the scale of the response; see
Rosenbaum \ Rubin (1985).  (This default can
be overridden by specifying <code>type="response"</code>.)
In contrast to <code>predict</code>, if <code>scores</code> isn't given an explicit
<code>newdata</code> argument then it attempts to reconstruct one from the context
in which it is called, rather than from its first argument.  For example, if
it's called within the <code>formula</code> argument of a call to <code>glm</code>, its
<code>newdata</code> is the same data frame that <code>glm</code> evaluates that formula
in, as opposed to the model frame associated with <code>object</code>.  See
Examples.
</p>
<p>The handling of missing independent variables also differs from that of
<code>predict</code> in two ways. First, if the data used to generate <code>object</code>
has <code>NA</code> values, they're mean-imputed using
<code><a href="#topic+fill.NAs">fill.NAs</a></code>. Secondly, if <code>newdata</code> (either the explicit
argument, or the implicit data generated from <code>object</code>) has <code>NA</code>
values, they're likewise mean-imputed using <code><a href="#topic+fill.NAs">fill.NAs</a></code>.  Also,
missingness flags are added to the formula of <code>object</code>, which is then
re-fit, using <code><a href="#topic+fill.NAs">fill.NAs</a></code>, prior to calling <code>predict</code>.
</p>
<p>If <code>newdata</code> is specified and contains no missing data, <code>scores</code>
returns the same value as <code>predict</code>.
</p>


<h3>Value</h3>

<p>See individual <code>predict</code> functions.
</p>


<h3>Author(s)</h3>

<p>Josh Errickson
</p>


<h3>References</h3>

<p>P.~R. Rosenbaum and D.~B. Rubin (1985), &lsquo;Constructing a
control group using multivariate matched sampling methods that incorporate
the propensity score&rsquo;, <em>The American Statistician</em>, <b>39</b> 33&ndash;38.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)
pg &lt;- lm(cost~., data=nuclearplants, subset=(pr==0))
# The following two lines produce identical results.
ps1 &lt;- glm(pr~cap+date+t1+bw+predict(pg, newdata=nuclearplants),
           data=nuclearplants)
ps2 &lt;- glm(pr~cap+date+t1+bw+scores(pg), data=nuclearplants)
</code></pre>

<hr>
<h2 id='setFeasibilityConstants'>(Internal) Sets up the default values for maximum feasible problems</h2><span id='topic+setFeasibilityConstants'></span>

<h3>Description</h3>

<p>(Internal) Sets up the default values for maximum feasible problems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFeasibilityConstants()
</code></pre>

<hr>
<h2 id='setMaxProblemSize'>Set the maximum problem size</h2><span id='topic+setMaxProblemSize'></span>

<h3>Description</h3>

<p>Helper function to ease setting the largest problem size to be
accepted by <code>pairmatch</code> or <code>fullmatch</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMaxProblemSize(size = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setMaxProblemSize_+3A_size">size</code></td>
<td>
<p>Positive integer, or <code>Inf</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function sets the optmatch_max_problem_size global option. The
option ships with the option pre-set to a value that's relatively small,
smaller than what most modern computers can handle.  Invoking this
function with no argument
re-sets the optmatch_max_problem_size option to <code>Inf</code>, effectively
disabling checks on problem size.  Unless you're working with an older
computer, it probably makes sense for most users to do this, at least
until they determine what problem sizes are too large for their machines.
(You'll know that when your R crashes, or simply takes too long for
your taste.)
</p>
<p>To determine the size of a problem without subproblems, i.e. exact
matching categories, use <code><a href="#topic+match_on">match_on</a></code> to set up and store
the problem distance, then apply <code>length</code> to the result. If
there were exact matching constraints imposed during the creation
of the distance, then you'll want to look at the largest size of a
subproblem.  Apply <code><a href="#topic+findSubproblems">findSubproblems</a></code> to your distance,
creating a list, say <code>dlist</code>, of your distances; then do
<code>sapply(dlist, length)</code> to determine the sizes of the subproblems.
</p>


<h3>Author(s)</h3>

<p>Ben B. Hansen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMaxProblemSize">getMaxProblemSize</a></code>
</p>

<hr>
<h2 id='setTryRecovery'>(Internal) Sets up option to try recovery in <code>fullmatch</code>.</h2><span id='topic+setTryRecovery'></span>

<h3>Description</h3>

<p>(Internal) Sets up option to try recovery in <code>fullmatch</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTryRecovery()
</code></pre>

<hr>
<h2 id='show+2CBlockedInfinitySparseMatrix-method'>Displays a BlockedInfinitySparseMatrix</h2><span id='topic+show+2CBlockedInfinitySparseMatrix-method'></span>

<h3>Description</h3>

<p>Displays each block of the BlockedInfinitySparseMatrix separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BlockedInfinitySparseMatrix'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2CBlockedInfinitySparseMatrix-method_+3A_object">object</code></td>
<td>
<p>An BlockedInfinitySparseMatrix to print.</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CInfinitySparseMatrix-method'>Displays an InfinitySparseMatrix</h2><span id='topic+show+2CInfinitySparseMatrix-method'></span>

<h3>Description</h3>

<p>Specifically, displays an InfinitySparseMatrix by converting it to
a matrix first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InfinitySparseMatrix'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2CInfinitySparseMatrix-method_+3A_object">object</code></td>
<td>
<p>An InfinitySparseMatrix to print.</p>
</td></tr>
</table>

<hr>
<h2 id='sort.InfinitySparseMatrix'>Sort the internal structure of an InfinitySparseMatrix.</h2><span id='topic+sort.InfinitySparseMatrix'></span><span id='topic+sort.BlockedInfinitySparseMatrix'></span>

<h3>Description</h3>

<p>Internally, an <code>InfinitySparseMatrix</code> (Blocked or non) comprises of
vectors of values, row positions, and column positions. The ordering of
these vectors is not enforced. This function sorts the internal structure,
leaving the external structure unchanged (e.g. <code>as.matrix(ism)</code> and
<code>as.matrix(sort(ism))</code> will look identical despite sorting.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'InfinitySparseMatrix'
sort(x, decreasing = FALSE, ..., byCol = FALSE)

## S3 method for class 'BlockedInfinitySparseMatrix'
sort(x, decreasing = FALSE, ..., byCol = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort.InfinitySparseMatrix_+3A_x">x</code></td>
<td>
<p>An <code>InfinitySparseMatrix</code> or
<code>BlockedInfinitySparseMatrix</code>.</p>
</td></tr>
<tr><td><code id="sort.InfinitySparseMatrix_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical. Should the sort be increasing or decreasing?
Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sort.InfinitySparseMatrix_+3A_...">...</code></td>
<td>
<p>Additional arguments ignored.</p>
</td></tr>
<tr><td><code id="sort.InfinitySparseMatrix_+3A_bycol">byCol</code></td>
<td>
<p>Logical. Defaults to <code>FALSE</code>, so the returned ISM is
row-dominant. <code>TRUE</code> returns a column-dominant ISM.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the <code>InfinitySparseMatrix</code> is row-dominant, meaning the row
positions are sorted first, then column positions are sorted within each
row. Use argument <code>byCol</code> to change this.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> which is sorted according to
<code>byCol</code>.
</p>

<hr>
<h2 id='standardization_scale'>pooled dispersion for a numeric variable</h2><span id='topic+standardization_scale'></span>

<h3>Description</h3>

<p>Dispersion as pooled across a treatment and a control group. By default,
the measure of dispersion calculated within each group is not the
ordinary standard deviation as in <code>stats::sd</code> but rather the robust alternative
encoded in <code>stats::mad</code>.  The dispersion measurements are combined
by squaring, averaging with weights proportional to one minus the sizes of
the groups and then taking square roots.  Used in <code><a href="#topic+match_on.glm">match_on.glm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardization_scale(x, trtgrp, standardizer = NULL, svydesign_ = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardization_scale_+3A_x">x</code></td>
<td>
<p>numeric variable</p>
</td></tr>
<tr><td><code id="standardization_scale_+3A_trtgrp">trtgrp</code></td>
<td>
<p>logical or numeric. If numeric, coerced to logical via <code>!</code></p>
</td></tr>
<tr><td><code id="standardization_scale_+3A_standardizer">standardizer</code></td>
<td>
<p>function, <code>NULL</code> or numeric of length 1</p>
</td></tr>
<tr><td><code id="standardization_scale_+3A_svydesign_">svydesign_</code></td>
<td>
<p>ordinarily <code>NULL</code>, but may also be a
<code>survey.design2</code>; see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A non-NULL <code>svydesign_</code> parameter indicates that the dispersion
calculations are to be made respecting the weighting scheme implicit in
that <code>survey.design2</code> object. If <code>standardizer</code> is <code>NULL</code>,
one gets a calculation in the style of <code>stats::mad</code> but with weights,
performed by <code>optmatch:::svy_sd</code>; for a pooling of weighted standard
deviations, one would pass a non-<code>NULL</code> <code>svydesign_</code> parameter along
with <code>standardizer=optmatch:::svy_sd</code>.
(More generally, the provided <code>standardizer</code>
function should accept as a sole argument a <code>survey.design2</code> object,
with <code>nrows(svydesign_$variables)</code> equal to the lengths of <code>x</code> and
<code>trtgrp</code>.  This object is expected to carry a numeric variable &lsquo;<code>x</code>&rsquo;,
and the <code>standardizer</code> function is to return the dispersion of this variable.)
</p>


<h3>Value</h3>

<p>numeric of length 1
</p>

<hr>
<h2 id='strata'>Identify Stratafication Variables</h2><span id='topic+strata'></span>

<h3>Description</h3>

<p>This is a special function used only in identifying the strata variables
when defining an <code>exactMatch</code> during a call to <code>fullmatch</code>,
<code>pairmatch</code>, or <code>match_on</code>. It should not be called externally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strata_+3A_...">...</code></td>
<td>
<p>any number of variables of the same length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the variables with appropriate labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)
fullmatch(pr ~ cost + strata(pt), data = nuclearplants)
</code></pre>

<hr>
<h2 id='stratumStructure'>Return structure of matched sets</h2><span id='topic+stratumStructure'></span><span id='topic+stratumStructure.optmatch'></span><span id='topic+stratumStructure.default'></span><span id='topic+print.stratumStructure'></span>

<h3>Description</h3>

<p>Tabulate treatment:control ratios occurring in matched sets, and
the frequency of their occurrence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratumStructure(stratum, trtgrp = NULL, min.controls = 0, max.controls = Inf)

## S3 method for class 'optmatch'
stratumStructure(stratum, trtgrp, min.controls = 0, max.controls = Inf)

## Default S3 method:
stratumStructure(stratum, trtgrp, min.controls = 0, max.controls = Inf)

## S3 method for class 'stratumStructure'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stratumStructure_+3A_stratum">stratum</code></td>
<td>
<p>Matched strata, as returned by
<code><a href="#topic+fullmatch">fullmatch</a></code> or <code><a href="#topic+pairmatch">pairmatch</a></code></p>
</td></tr>
<tr><td><code id="stratumStructure_+3A_trtgrp">trtgrp</code></td>
<td>
<p>Dummy variable for treatment group membership.  (Not
required if <code>stratum</code> is an optmatch object, as returned by
<code><a href="#topic+fullmatch">fullmatch</a></code> or <code><a href="#topic+pairmatch">pairmatch</a></code>.)</p>
</td></tr>
<tr><td><code id="stratumStructure_+3A_min.controls">min.controls</code></td>
<td>
<p>For display, the number of treatment group
members per stratum will be truncated at the reciprocal of
<code>min.controls</code>.</p>
</td></tr>
<tr><td><code id="stratumStructure_+3A_max.controls">max.controls</code></td>
<td>
<p>For display, the number of control group
members will be truncated at <code>max.controls</code>.</p>
</td></tr>
<tr><td><code id="stratumStructure_+3A_x">x</code></td>
<td>
<p>stratumStructure object to be printed.</p>
</td></tr>
<tr><td><code id="stratumStructure_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table showing frequency of occurrence of those
treatment:control ratios that occur.
</p>
<p>The &lsquo;effective sample size&rsquo; of the stratification, in
matched pairs.  Given as an attribute of the table, named
&lsquo;<code>comparable.num.matched.pairs</code>&rsquo;; see Note.
</p>


<h3>Note</h3>

<p>For comparing treatment and control groups both of size 10,
say, a stratification consisting of two strata, one with 9
treatments and 1 control, has a smaller &lsquo;effective sample
size&rsquo;, intuitively, than a stratification into 10 matched pairs,
despite the fact that both contain 20 subjects in
total. <code>stratumStructure</code> first summarizes this aspect of
the structure of the stratification it is given, then goes on to
identify one number as the stratification's effective sample
size.  The &lsquo;<code>comparable.num.matched.pairs</code>&rsquo;
attribute returned by <code>stratumStructure</code> is the sum of
harmonic means of the sizes of the treatment and control
subgroups of each stratum, a general way of calibrating such
differences as well as differences in the number of subjects
contained in a stratification.  For example, by this metric the
9:1, 1:9 stratification is comparable to 3.6 matched pairs.
</p>
<p>Why should effective sample size be calculated this way?  The
phrase &lsquo;effective sample size&rsquo; suggests the observations
are taken to be similar in information content.  Modeling them
as random variables, this suggests that they be assumed to have
the same variance, <code class="reqn">\sigma</code>, conditional on what
stratum they reside in.  If that is the case, and if also
treatment and control observations differ in expectation by a
constant that is the same for each stratum, then it can be shown
that the optimum weights with which to combine treatment-control
contrasts across strata, <code class="reqn">s</code>, are proportional to the
stratum-wise harmonic means of treatment and control counts,
<code class="reqn">h_s = [(n_{ts}^{-1} + n_{cs}^{-1})/2]^{-1}</code> (Kalton, 1968).  The thus-weighted
average of contrasts then has variance <code class="reqn">2\sigma/\sum_s
  h_s</code>. This motivates the use of <code class="reqn">\sum_s
  h_s</code> as a measure of effective sample size (Hansen, 2011).
Somewhat different motivations of the same calculation appear 
in Hansen (2004) and in Hansen and Bowers (2008).  Since for a
matched pair <code class="reqn">s</code>, <code class="reqn">h_s=1</code>, <code class="reqn">\sum_s
  h_s</code> can be thought of as the number of matched pairs
needed to attain comparable precision.
</p>


<h3>Author(s)</h3>

<p>Ben B. Hansen
</p>


<h3>References</h3>

<p>Kalton, G. (1968), &lsquo;Standardization: A
technique to control for extraneous variables&rsquo;, <em>Applied
Statistics</em>, <b>17</b>, 118&ndash;136.
</p>
<p>Hansen, B.B. (2004), &lsquo;Full Matching in an Observational
Study of Coaching for the SAT&rsquo;, <em>Journal of the American
Statistical Association</em>, <b>99</b>, 609&ndash;618.
</p>
<p>Hansen B.B. and Bowers, J. (2008), &lsquo;Covariate balance in
simple, stratified and clustered comparative studies&rsquo;,
<em>Statistical Science</em>, <b>23</b> (2), 219&ndash;236.
</p>
<p>Hansen, B.B. (2011), &lsquo;Propensity score matching to extract
latent experiments from nonexperimental data: A case study&rsquo;.
Ch. 9 of <em>Looking Backwards: Proceedings from a Conference
in Honor of Paul W. Holland</em>, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matched">matched</a></code>, <code><a href="#topic+fullmatch">fullmatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(plantdist)
plantsfm &lt;- fullmatch(plantdist) # A full match with unrestricted
                                 # treatment-control balance
plantsfm1 &lt;- fullmatch(plantdist,min.controls=2, max.controls=3)
stratumStructure(plantsfm)
stratumStructure(plantsfm1)
stratumStructure(plantsfm, max.controls=4)

</code></pre>

<hr>
<h2 id='subdim'>Returns the dimension of each valid subproblem</h2><span id='topic+subdim'></span><span id='topic+subdim.InfinitySparseMatrix'></span><span id='topic+subdim.matrix'></span><span id='topic+subdim.BlockedInfinitySparseMatrix'></span><span id='topic+subdim.optmatch.dlist'></span>

<h3>Description</h3>

<p>Returns a list containing the dimensions of all valid subproblems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subdim(x)

## S3 method for class 'InfinitySparseMatrix'
subdim(x)

## S3 method for class 'matrix'
subdim(x)

## S3 method for class 'BlockedInfinitySparseMatrix'
subdim(x)

## S3 method for class 'optmatch.dlist'
subdim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subdim_+3A_x">x</code></td>
<td>
<p>A distance specification to get the sub-dimensions of.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame listing the dimensions of each valid subproblem. Any subproblems with 0 controls
or 0 treatments will be ignored. The names of the entries in the list will be the names of the
subproblems, if they exist.  There will be two rows, named &quot;treatments&quot; and &quot;controls&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>em &lt;- exactMatch(pr ~ pt, data=nuclearplants)
m1 &lt;- fullmatch(pr ~ t1 + t2, within=em, data=nuclearplants)
stratumStructure(m1)
(subdims_em &lt;- subdim(em))
m2 &lt;- fullmatch(pr ~ t1 + t2, within=em, data=nuclearplants,
                mean.controls=pmin(1.5, subdims_em["controls",] / subdims_em["treatments",])
                )
stratumStructure(m2)
                
</code></pre>

<hr>
<h2 id='subproblemSuccess'>(Internal) Report successful subproblems.</h2><span id='topic+subproblemSuccess'></span>

<h3>Description</h3>

<p><code><a href="#topic+fullmatch">fullmatch</a></code> can break up a large matching problem into smaller
subproblems (for example, using strata defined by <code><a href="#topic+exactMatch">exactMatch</a></code>).
This function lists the subproblems in a match and list whether at least on
treated unit was matched in subproblem. Subproblems that have no matched
treated units are said to have &quot;failed.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subproblemSuccess(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subproblemSuccess_+3A_x">x</code></td>
<td>
<p>The result of <code><a href="#topic+fullmatch">fullmatch</a></code> or <code><a href="#topic+pairmatch">pairmatch</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named logical vector indicating either success or failure for each subproblem.
</p>

<hr>
<h2 id='subset.InfinitySparseMatrix'>Subsetting for InfinitySparseMatrices</h2><span id='topic+subset.InfinitySparseMatrix'></span><span id='topic++5B+2CInfinitySparseMatrix-method'></span><span id='topic++5B+3C-+2CInfinitySparseMatrix-method'></span>

<h3>Description</h3>

<p>This matches the syntax and semantics of
subset for matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'InfinitySparseMatrix'
subset(x, subset, select, ...)

## S4 method for signature 'InfinitySparseMatrix'
x[i, j = NULL, ..., drop = TRUE]

## S4 replacement method for signature 'InfinitySparseMatrix'
x[i, j] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.InfinitySparseMatrix_+3A_x">x</code></td>
<td>
<p>InfinitySparseMatrix to be subset or bound.</p>
</td></tr>
<tr><td><code id="subset.InfinitySparseMatrix_+3A_subset">subset</code></td>
<td>
<p>Logical expression indicating rows to keep.</p>
</td></tr>
<tr><td><code id="subset.InfinitySparseMatrix_+3A_select">select</code></td>
<td>
<p>Logical expression indicating columns to keep.</p>
</td></tr>
<tr><td><code id="subset.InfinitySparseMatrix_+3A_...">...</code></td>
<td>
<p>Other arguments are ignored.</p>
</td></tr>
<tr><td><code id="subset.InfinitySparseMatrix_+3A_i">i</code></td>
<td>
<p>Row indices.</p>
</td></tr>
<tr><td><code id="subset.InfinitySparseMatrix_+3A_j">j</code></td>
<td>
<p>Col indices.</p>
</td></tr>
<tr><td><code id="subset.InfinitySparseMatrix_+3A_drop">drop</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="subset.InfinitySparseMatrix_+3A_value">value</code></td>
<td>
<p>replacement values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An InfinitySparseMatrix with only the selected elements.
</p>


<h3>Author(s)</h3>

<p>Mark Fredrickson
</p>

<hr>
<h2 id='summary.ism'>Summarize a distance matrix</h2><span id='topic+summary.ism'></span><span id='topic+summary.InfinitySparseMatrix'></span><span id='topic+summary.BlockedInfinitySparseMatrix'></span><span id='topic+summary.DenseMatrix'></span>

<h3>Description</h3>

<p>Given a distance matrix, return information above it, including
dimension, sparsity information, unmatchable members, summary of
finite distances, and, in the case of
<code>BlockedInfinitySparseMatrix</code>, block structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'InfinitySparseMatrix'
summary(object, ..., distanceSummary = TRUE)

## S3 method for class 'BlockedInfinitySparseMatrix'
summary(
  object,
  ...,
  distanceSummary = TRUE,
  printAllBlocks = FALSE,
  blockStructure = TRUE
)

## S3 method for class 'DenseMatrix'
summary(object, ..., distanceSummary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ism_+3A_object">object</code></td>
<td>
<p>A <code>InfinitySparseMatrix</code>,
<code>BlockedInfinitySparseMatrix</code> or <code>DenseMatrix</code>.</p>
</td></tr>
<tr><td><code id="summary.ism_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="summary.ism_+3A_distancesummary">distanceSummary</code></td>
<td>
<p>Default <code>TRUE</code>. Should a summary of
minimum distance per treatment member be calculated? May be slow
on larger data sets.</p>
</td></tr>
<tr><td><code id="summary.ism_+3A_printallblocks">printAllBlocks</code></td>
<td>
<p>If <code>object</code> is a
<code>BlockedInfinitySparseMatrix</code>, should summaries of all
blocks be printed alongside the overall summary? Default
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.ism_+3A_blockstructure">blockStructure</code></td>
<td>
<p>If <code>object</code> is a
<code>BlockedInfinitySparseMatrix</code> and <code>printAllBlocks</code> is
false, print a quick summary of each individual block. Default
<code>TRUE</code>. If the number of blocks is high, consider
suppressing this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output consists of several pieces.
</p>

<ul>
<li><p> Membership: Indicates the dimension of the distance.
</p>
</li>
<li><p> Total (in)eligible potential matches: A measure of the sparsity of
the distance. Eligible matches have a finite distance between treatment and
control members; they could be matched. Ineligible matches have <code>Inf</code>
distance and can not be matched. A higher number of ineligible matches can
speed up matching, but runs the risk of less optimal overall matching
results.
</p>
</li>
<li><p> Unmatchable treatment/control members: If any observations have no
eligible matches (e.g. their distance to every potential match is
<code>Inf</code>) they are listed here. See Value below for details of how to
access lists of matchable and unmatchable treatment and control members.
</p>
</li>
<li><p> Summary of minimum matchable distance per treatment member: To assist
with choosing a caliper, this is a numeric summary of the smallest distance
per matchable treatment member. If you provide a caliper that is less than
the maximum value, at least one treatment member will become unmatchable.
</p>
</li>
<li><p> Block structure: For <code>BlockedInfinitySparseMatrix</code>, a quick
summary of the structure of each individual block. (The above will all be
across all blocks.) This may indicate which blocks, if any, are problematic.
</p>
</li></ul>



<h3>Value</h3>

<p>A named <code>list</code>. The summary for an
<code>InfinitySparseMatrix</code> or <code>DenseMatrix</code> contains the
following:
</p>
<table role = "presentation">
<tr><td><code>total:</code></td>
<td>
<p>Contains the total number of treatment and control members, as well as eligible and ineligible matches.</p>
</td></tr>
<tr><td><code>matchable:</code></td>
<td>
<p>The names of all treatment and control members with at least one eligible match.</p>
</td></tr>
<tr><td><code>unmatchable:</code></td>
<td>
<p>The names of all treatment and control members with no eligible matches.</p>
</td></tr>
<tr><td><code>distances:</code></td>
<td>
<p>The summary of minimum matchable distances, if <code>distanceSummary</code> is <code>TRUE</code>.</p>
</td></tr>
</table>
<p>For <code>BlockedInfinitySparseMatrix</code>, the named <code>list</code>
instead of contains one entry per block, named after each block
(i.e. the value of the blocking variable) as well as a block
named 'overall' which contains the summary ignoring blocks. Each
of these entries contains a <code>list</code> with entries 'total',
'matchable', 'unmatchable' and 'distances', as described above.
</p>

<hr>
<h2 id='update.optmatch'>Performs an update on an <code>optmatch</code> object.</h2><span id='topic+update.optmatch'></span>

<h3>Description</h3>

<p>NB: THIS CODE IS CURRENTLY VERY MUCH ALPHA AND SOMEWHAT UNTESTED, ESPECIALLY CALLING <code>update</code> ON AN
OPTMATCH OBJECT CREATED WITHOUT AN EXPLICIT DISTANCE ARGUMENT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optmatch'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.optmatch_+3A_object">object</code></td>
<td>
<p><code>Optmatch</code> object to update.</p>
</td></tr>
<tr><td><code id="update.optmatch_+3A_...">...</code></td>
<td>
<p>Additional arguments to the call, or arguments with changed values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that passing <code>data</code> again is strongly recommended. A warning will be printed if the hash of the data used to generate the
<code>optmatch</code> object differs from the hash of the new <code>data</code>.
</p>
<p>To obtain an updated call without performing the actual update, pass an additional <code>evaluate = FALSE</code> argument.
</p>


<h3>Value</h3>

<p>An updated <code>optmatch</code> object.
</p>

<hr>
<h2 id='validDistanceSpecification'>(Internal) Validate that objects are valid distance specifications.</h2><span id='topic+validDistanceSpecification'></span>

<h3>Description</h3>

<p>The functions <code><a href="#topic+fullmatch">fullmatch</a></code> and <code><a href="#topic+pairmatch">pairmatch</a></code>
create optimal matches of treated and control units given a
matrix (or similar representation) of distances between treated and
control units. These distance specifications must implement certain
generic functions. This function checks that all necessary methods
exist and the object can be used to specify distances in a way that
the matching functions can use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validDistanceSpecification(distance, stopOnProblem = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validDistanceSpecification_+3A_distance">distance</code></td>
<td>
<p>The object to test.</p>
</td></tr>
<tr><td><code id="validDistanceSpecification_+3A_stoponproblem">stopOnProblem</code></td>
<td>
<p>If <code>TRUE</code> (default) the function will
raise an error for invalid objects. Otherwise, it returns a
logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
