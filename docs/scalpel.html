<!DOCTYPE html><html><head><title>Help for package scalpel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scalpel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#getNeuronStatus'><p>Read in the manual classifications of neurons from SCALPEL.</p></a></li>
<li><a href='#getScalpel'><p>Read in results from SCALPEL.</p></a></li>
<li><a href='#getScalpelStep0'><p>Read in results from Step 0 of SCALPEL.</p></a></li>
<li><a href='#getScalpelStep1'><p>Read in results from Step 1 of SCALPEL.</p></a></li>
<li><a href='#getScalpelStep2'><p>Read in results from Step 2 of SCALPEL.</p></a></li>
<li><a href='#getScalpelStep3'><p>Read in results from Step 3 of SCALPEL.</p></a></li>
<li><a href='#getY'><p>Read in Y matrix for SCALPEL.</p></a></li>
<li><a href='#plotBrightest'><p>Plot the most active frames for a given neuron.</p></a></li>
<li><a href='#plotCandidateFrame'><p>Plot preliminary dictionary element from Step 1 of SCALPEL and its corresponding frame.</p></a></li>
<li><a href='#plotCluster'><p>Plot a summary of a given cluster from Step 2 of SCALPEL.</p></a></li>
<li><a href='#plotFrame'><p>Plot a frame of the video.</p></a></li>
<li><a href='#plotResults'><p>Plot both the spatial and temporal components from Step 3 of SCALPEL.</p></a></li>
<li><a href='#plotResultsAllLambda'><p>Plot both the spatial and temporal components for the sequence of lambda values from Step 3 of SCALPEL.</p></a></li>
<li><a href='#plotSpatial'><p>Plot spatial components from Steps 2 or 3 of SCALPEL.</p></a></li>
<li><a href='#plotTemporal'><p>Plot temporal components from Step 3 of SCALPEL.</p></a></li>
<li><a href='#plotThresholdedFrame'><p>Plot a frame of the video with shading.</p></a></li>
<li><a href='#plotVideoVariance'><p>Plot a summary of the fluorescence in the video.</p></a></li>
<li><a href='#reviewNeurons'><p>Manually classify the identified neurons from SCALPEL.</p></a></li>
<li><a href='#reviewNeuronsInteractive'><p>Manually classify the identified neurons from SCALPEL.</p></a></li>
<li><a href='#reviewNeuronsMoreFrames'><p>Save additional frames for manually classifying the identified neurons from SCALPEL.</p></a></li>
<li><a href='#reviewOverlappingNeurons'><p>Save additional frames for overlapping neurons from SCALPEL.</p></a></li>
<li><a href='#scalpel'><p>Perform entire SCALPEL pipeline.</p></a></li>
<li><a href='#scalpel-package'><p>scalpel: A package for processing calcium imaging data.</p></a></li>
<li><a href='#scalpelStep0'><p>Perform Step 0 of SCALPEL.</p></a></li>
<li><a href='#scalpelStep1'><p>Perform Step 1 of SCALPEL.</p></a></li>
<li><a href='#scalpelStep2'><p>Perform Step 2 of SCALPEL.</p></a></li>
<li><a href='#scalpelStep3'><p>Perform Step 3 of SCALPEL.</p></a></li>
<li><a href='#summary'><p>Summarize results from SCALPEL pipeline.</p></a></li>
<li><a href='#updateNeurons'><p>Update the classifications of neurons from SCALPEL.</p></a></li>
<li><a href='#updateNeuronsInteractive'><p>Update the classifications of specified neurons from SCALPEL.</p></a></li>
<li><a href='#updateThreshold'><p>Review and update the chosen threshold for image segmentation in Step 1 of SCALPEL.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Processes Calcium Imaging Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Ashley Petersen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ashley Petersen &lt;ashleyjpete@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Identifies the locations of neurons, and estimates their calcium concentrations over time using the SCALPEL method proposed in Petersen, Ashley; Simon, Noah; Witten, Daniela. SCALPEL: Extracting neurons from calcium imaging data. Ann. Appl. Stat. 12 (2018), no. 4, 2430&ndash;2456. &lt;<a href="https://doi.org/10.1214%2F18-AOAS1159">doi:10.1214/18-AOAS1159</a>&gt;. <a href="https://projecteuclid.org/euclid.aoas/1542078051">https://projecteuclid.org/euclid.aoas/1542078051</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td>www.ajpete.com/software</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, R.matlab, protoclust, igraph, gam</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-03 02:36:42 UTC; ashleypetersen</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-03 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='getNeuronStatus'>Read in the manual classifications of neurons from SCALPEL.</h2><span id='topic+getNeuronStatus'></span>

<h3>Description</h3>

<p>This function allows the user to read in the manual classifications of neurons, based on the classifying done using
<code><a href="#topic+reviewNeurons">reviewNeurons</a></code> or <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNeuronStatus(scalpelOutput, neuronSet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNeuronStatus_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="getNeuronStatus_+3A_neuronset">neuronSet</code></td>
<td>
<p>The set of neurons that should be reviewed:
use <code>"A"</code> for those resulting from <code><a href="#topic+scalpelStep2">scalpelStep2</a></code> and saved as <code>scalpelOutput$A</code>, or use <code>"Afilter"</code> for those resulting from
<code><a href="#topic+scalpelStep3">scalpelStep3</a></code> and saved as <code>scalpelOutput$Afilter</code>. This argument is ignored if the class of <code>scalpelOutput</code> is <code>scalpelStep2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length equal to the number of columns in <code>scalpelOutput$A</code> if <code>neuronSet="A"</code> or <code>scalpelOutput$Afilter</code> if <code>neuronSet="Afilter"</code>.
The elements give the manual classifications of the neurons. The possible classifications are: <code>"yes"</code> if
a neuron is to be kept, <code>"no"</code> if a neuron is to be discarded, <code>"unsure"</code> if a neuron needs to be reviewed further, and
<code>NA</code> if a neuron has not yet been classified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reviewNeurons">reviewNeurons</a></code>, <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "updateNeurons" function

getNeuronStatus(scalpelOutput = scalpelOutput, neuronSet = "Afilter")

## End(Not run)
</code></pre>

<hr>
<h2 id='getScalpel'>Read in results from SCALPEL.</h2><span id='topic+getScalpel'></span>

<h3>Description</h3>

<p>This step allows the user to retrieve the object of class <code>scalpel</code> for results from a previous session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScalpel(
  outputFolder,
  version = NULL,
  cutoff = 0.18,
  omega = 0.2,
  lambdaMethod = "trainval",
  lambda = NULL,
  minClusterSize = 1,
  alpha = 0.9,
  removeBorder = FALSE,
  excludeReps = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getScalpel_+3A_outputfolder">outputFolder</code></td>
<td>
<p>The existing directory where the results that the user wishes to use are saved.</p>
</td></tr>
<tr><td><code id="getScalpel_+3A_version">version</code></td>
<td>
<p>The 5-digit folder ID for the results that the user wishes to load. If NULL, automatically chooses
the only version in outputFolder and if more than one version exists, returns an error.</p>
</td></tr>
<tr><td><code id="getScalpel_+3A_cutoff">cutoff</code></td>
<td>
<p>A value in [0,1] indicating the dendrogram cutpoint used. The default value is 0.18.</p>
</td></tr>
<tr><td><code id="getScalpel_+3A_omega">omega</code></td>
<td>
<p>A value in [0,1] indicating the dissimilarity metric weight used for clustering. The default value is 0.2.</p>
</td></tr>
<tr><td><code id="getScalpel_+3A_lambdamethod">lambdaMethod</code></td>
<td>
<p>How lambda was chosen: either <code>"trainval"</code> (default), <code>"distn"</code>, or <code>"user"</code>.</p>
</td></tr>
<tr><td><code id="getScalpel_+3A_lambda">lambda</code></td>
<td>
<p>The value of lambda used to fit the sparse group lasso. If NULL, automatically chooses
the only lambda in directory and if more than one lambda exists, returns an error.</p>
</td></tr>
<tr><td><code id="getScalpel_+3A_minclustersize">minClusterSize</code></td>
<td>
<p>The minimum number of preliminary dictionary elements that a cluster must have contained to have been included
in the sparse group lasso. The default value is 1.</p>
</td></tr>
<tr><td><code id="getScalpel_+3A_alpha">alpha</code></td>
<td>
<p>The value of alpha used to fit the sparse group lasso. The default value is 0.9.</p>
</td></tr>
<tr><td><code id="getScalpel_+3A_removeborder">removeBorder</code></td>
<td>
<p>A logical scalar indicating whether the dictionary elements that contained pixels in the 10-pixel
border of the video were removed prior to fitting the sparse group lasso. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getScalpel_+3A_excludereps">excludeReps</code></td>
<td>
<p>A vector giving the indices of which dictionary elements were excluded.
The default value is <code>NULL</code> meaning no dictionary elements were manually excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>scalpel</code>, which can be used to rerun SCALPEL Steps 1-3 with new parameters using <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, and <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>
or can be used with any of the plotting functions: <code><a href="#topic+plotFrame">plotFrame</a></code>, <code><a href="#topic+plotThresholdedFrame">plotThresholdedFrame</a></code>, <code><a href="#topic+plotVideoVariance">plotVideoVariance</a></code>, <code><a href="#topic+plotCandidateFrame">plotCandidateFrame</a></code>,
<code><a href="#topic+plotCluster">plotCluster</a></code>, <code><a href="#topic+plotResults">plotResults</a></code>, <code><a href="#topic+plotResultsAllLambda">plotResultsAllLambda</a></code>, <code><a href="#topic+plotSpatial">plotSpatial</a></code>,
<code><a href="#topic+plotTemporal">plotTemporal</a></code>, and <code><a href="#topic+plotBrightest">plotBrightest</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpel">scalpel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function
#folder where results were saved
outputFolder = "scalpelResults"

#read previous results in
#simplest example with default parameters:
out = getScalpel(outputFolder = outputFolder)
#note: if Step 1 has been run more than once, will need to specify 'version'

#example with optional parameters:
#need to enter if non-default options were used
out = getScalpel(outputFolder = outputFolder, omega = 0.2, cutoff = 0.18,
                alpha = 0.9, minClusterSize = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='getScalpelStep0'>Read in results from Step 0 of SCALPEL.</h2><span id='topic+getScalpelStep0'></span>

<h3>Description</h3>

<p>This step allows the user to retrieve the object of class <code>scalpelStep0</code> for results from a previous session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScalpelStep0(outputFolder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getScalpelStep0_+3A_outputfolder">outputFolder</code></td>
<td>
<p>The existing directory where the results that the user wishes to use are saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>scalpelStep0</code>, which can be used to run SCALPEL Step 1 using <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>
or can be used with the plotting functions <code><a href="#topic+plotFrame">plotFrame</a></code>, <code><a href="#topic+plotThresholdedFrame">plotThresholdedFrame</a></code>, and <code><a href="#topic+plotVideoVariance">plotVideoVariance</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function
#folder where results were saved
outputFolder = "scalpelResults"

#read previous results in
out = getScalpelStep0(outputFolder = outputFolder)

## End(Not run)
</code></pre>

<hr>
<h2 id='getScalpelStep1'>Read in results from Step 1 of SCALPEL.</h2><span id='topic+getScalpelStep1'></span>

<h3>Description</h3>

<p>This step allows the user to retrieve the object of class <code>scalpelStep1</code> for results from a previous session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScalpelStep1(outputFolder, version = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getScalpelStep1_+3A_outputfolder">outputFolder</code></td>
<td>
<p>The existing directory where the results that the user wishes to use are saved.</p>
</td></tr>
<tr><td><code id="getScalpelStep1_+3A_version">version</code></td>
<td>
<p>The 5-digit folder ID for the results that the user wishes to load. If NULL, automatically chooses
the only version in outputFolder and if more than one version exists, returns an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>scalpelStep1</code>, which can be used to run SCALPEL Step 2 using <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>
or can be used with the plotting function <code><a href="#topic+plotCandidateFrame">plotCandidateFrame</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function
#folder where results were saved
outputFolder = "scalpelResults"

#read previous results in
out = getScalpelStep1(outputFolder = outputFolder)
#note: if Step 1 has been run more than once, will need to specify 'version'

## End(Not run)

</code></pre>

<hr>
<h2 id='getScalpelStep2'>Read in results from Step 2 of SCALPEL.</h2><span id='topic+getScalpelStep2'></span>

<h3>Description</h3>

<p>This step allows the user to retrieve the object of class <code>scalpelStep2</code> for results from a previous session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScalpelStep2(outputFolder, version = NULL, cutoff = 0.18, omega = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getScalpelStep2_+3A_outputfolder">outputFolder</code></td>
<td>
<p>The existing directory where the results that the user wishes to use are saved.</p>
</td></tr>
<tr><td><code id="getScalpelStep2_+3A_version">version</code></td>
<td>
<p>The 5-digit folder ID for the results that the user wishes to load. If NULL, automatically chooses
the only version in outputFolder and if more than one version exists, returns an error.</p>
</td></tr>
<tr><td><code id="getScalpelStep2_+3A_cutoff">cutoff</code></td>
<td>
<p>A value in [0,1] indicating the dendrogram cutpoint used. The default value is 0.18.</p>
</td></tr>
<tr><td><code id="getScalpelStep2_+3A_omega">omega</code></td>
<td>
<p>A value in [0,1] indicating the dissimilarity metric weight used for clustering. The default value is 0.2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>scalpelStep2</code>, which can be used to run SCALPEL Step 3 using <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>
or can be used with the plotting functions <code><a href="#topic+plotCluster">plotCluster</a></code> and <code><a href="#topic+plotSpatial">plotSpatial</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function
#folder where results were saved
outputFolder = "scalpelResults"

#read previous results in
#simplest example with default parameters:
out = getScalpelStep2(outputFolder = outputFolder)
#note: if Step 1 has been run more than once, will need to specify 'version'

#example with optional parameters:
#need to enter if non-default options were used
out = getScalpelStep2(outputFolder = outputFolder, omega = 0.2, cutoff = 0.18)

## End(Not run)
</code></pre>

<hr>
<h2 id='getScalpelStep3'>Read in results from Step 3 of SCALPEL.</h2><span id='topic+getScalpelStep3'></span>

<h3>Description</h3>

<p>This step allows the user to retrieve the object of class <code>scalpelStep3</code> for results from a previous session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScalpelStep3(
  outputFolder,
  version = NULL,
  cutoff = 0.18,
  omega = 0.2,
  lambdaMethod = "trainval",
  minClusterSize = 1,
  alpha = 0.9,
  lambda = NULL,
  removeBorder = FALSE,
  excludeReps = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getScalpelStep3_+3A_outputfolder">outputFolder</code></td>
<td>
<p>The existing directory where the results that the user wishes to use are saved.</p>
</td></tr>
<tr><td><code id="getScalpelStep3_+3A_version">version</code></td>
<td>
<p>The 5-digit folder ID for the results that the user wishes to load. If NULL, automatically chooses
the only version in outputFolder and if more than one version exists, returns an error.</p>
</td></tr>
<tr><td><code id="getScalpelStep3_+3A_cutoff">cutoff</code></td>
<td>
<p>A value in [0,1] indicating the dendrogram cutpoint used. The default value is 0.18.</p>
</td></tr>
<tr><td><code id="getScalpelStep3_+3A_omega">omega</code></td>
<td>
<p>A value in [0,1] indicating the dissimilarity metric weight used for clustering. The default value is 0.2.</p>
</td></tr>
<tr><td><code id="getScalpelStep3_+3A_lambdamethod">lambdaMethod</code></td>
<td>
<p>How lambda was chosen: either <code>"trainval"</code> (default), <code>"distn"</code>, or <code>"user"</code>.</p>
</td></tr>
<tr><td><code id="getScalpelStep3_+3A_minclustersize">minClusterSize</code></td>
<td>
<p>The minimum number of preliminary dictionary elements that a cluster must have contained to have been included
in the sparse group lasso. The default value is 1.</p>
</td></tr>
<tr><td><code id="getScalpelStep3_+3A_alpha">alpha</code></td>
<td>
<p>The value of alpha used to fit the sparse group lasso. The default value is 0.9.</p>
</td></tr>
<tr><td><code id="getScalpelStep3_+3A_lambda">lambda</code></td>
<td>
<p>The value of lambda used to fit the sparse group lasso. If NULL, automatically chooses
the only lambda in directory and if more than one lambda exists, returns an error.</p>
</td></tr>
<tr><td><code id="getScalpelStep3_+3A_removeborder">removeBorder</code></td>
<td>
<p>A logical scalar indicating whether the dictionary elements that contained pixels in the 10-pixel
border of the video were removed prior to fitting the sparse group lasso. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getScalpelStep3_+3A_excludereps">excludeReps</code></td>
<td>
<p>A vector giving the indices of which dictionary elements were excluded.
The default value is <code>NULL</code> meaning no dictionary elements were manually excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>scalpelStep3</code>, which can be used with the plotting functions
<code><a href="#topic+plotResults">plotResults</a></code>, <code><a href="#topic+plotResultsAllLambda">plotResultsAllLambda</a></code>, <code><a href="#topic+plotSpatial">plotSpatial</a></code>, <code><a href="#topic+plotTemporal">plotTemporal</a></code>, and <code><a href="#topic+plotBrightest">plotBrightest</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep3">scalpelStep3</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function
#folder where results were saved
outputFolder = "scalpelResults"

#read previous results in
#simplest example with default parameters:
out = getScalpelStep3(outputFolder = outputFolder)
#note: if Step 1 has been run more than once, will need to specify 'version'

#example with optional parameters:
#need to enter if non-default options were used
out = getScalpelStep3(outputFolder = outputFolder, omega = 0.2, cutoff = 0.18,
                     alpha = 0.9, minClusterSize = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='getY'>Read in Y matrix for SCALPEL.</h2><span id='topic+getY'></span>

<h3>Description</h3>

<p>This step allows the user to read in Y, the matrix of raw or processed video data, to use with several plotting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getY(scalpelOutput, videoType = "processed", part = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getY_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="getY_+3A_videotype">videoType</code></td>
<td>
<p>Specify whether to read in the processed data from Step 0 (default; <code>videoType="processed"</code>) or raw data (<code>videoType="raw"</code>).</p>
</td></tr>
<tr><td><code id="getY_+3A_part">part</code></td>
<td>
<p>The part of the video to read in, if it is split across multiple files. The default is NULL, which means that all parts will be read in and combined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>scalpelY</code> that can be provided as the <code>Y</code> argument in <code><a href="#topic+plotFrame">plotFrame</a></code>,
<code><a href="#topic+plotVideoVariance">plotVideoVariance</a></code>, <code><a href="#topic+plotBrightest">plotBrightest</a></code>, <code><a href="#topic+plotThresholdedFrame">plotThresholdedFrame</a></code>, and <code><a href="#topic+plotCandidateFrame">plotCandidateFrame</a></code>.
If would like to call these functions many times, this avoids reading the video into memory repeatedly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function
#read in the raw data
rawY = getY(scalpelOutput = scalpelOutput, videoType = "raw")
#read in the processed data from Step 0
processedY = getY(scalpelOutput = scalpelOutput, videoType = "processed")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotBrightest'>Plot the most active frames for a given neuron.</h2><span id='topic+plotBrightest'></span>

<h3>Description</h3>

<p>For a given neuron, we plot the frames with the highest estimated fluorescence, which
results from fitting the sparse group lasso in Step 3 of SCALPEL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBrightest(
  scalpelOutput,
  AfilterIndex,
  videoType = "processed",
  neuronsToOutline = "all",
  brightIndex = 1,
  shrinkLargest = FALSE,
  shrinkCutoff = NULL,
  title = NULL,
  Y = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBrightest_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code> or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="plotBrightest_+3A_afilterindex">AfilterIndex</code></td>
<td>
<p>Scalar giving the neuron for which to plot the brightest frames. The index refers to which column
of <code>scalpelOutput$Afilter</code> is of interest.</p>
</td></tr>
<tr><td><code id="plotBrightest_+3A_videotype">videoType</code></td>
<td>
<p>Specify whether to plot the processed data from Step 0 (default; <code>videoType="processed"</code>) or raw data (<code>videoType="raw"</code>).
This is ignored if <code>Y</code> is provided.</p>
</td></tr>
<tr><td><code id="plotBrightest_+3A_neuronstooutline">neuronsToOutline</code></td>
<td>
<p>Specify whether to plot outlines of all neurons (default; <code>neuronsToOutline="all"</code>),
only the outline for <code>neuron</code> (<code>neuronsToOutline="main"</code>), outlines of only the neurons kept
using a previous call to <code><a href="#topic+reviewNeurons">reviewNeurons</a></code> or <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code> (<code>neuronsToOutline="kept"</code>),
or none (<code>neuronsToOutline="none"</code>).</p>
</td></tr>
<tr><td><code id="plotBrightest_+3A_brightindex">brightIndex</code></td>
<td>
<p>Scalar giving which of the ordered brightest frames to plot. The default is 1, i.e., the brightest frame.</p>
</td></tr>
<tr><td><code id="plotBrightest_+3A_shrinklargest">shrinkLargest</code></td>
<td>
<p>Logical value indicating whether the values above <code>shrinkCutoff</code> should be shrunk when plotting. Shrinking these values
allows us to better visualize the areas with the largest fluorescence.</p>
</td></tr>
<tr><td><code id="plotBrightest_+3A_shrinkcutoff">shrinkCutoff</code></td>
<td>
<p>The value above which pixel values will be shrunk. By default, this will be chosen as
<code>min(scalpelOutput$thresholdVec)</code>.</p>
</td></tr>
<tr><td><code id="plotBrightest_+3A_title">title</code></td>
<td>
<p>Label for the title. The default is frame number.</p>
</td></tr>
<tr><td><code id="plotBrightest_+3A_y">Y</code></td>
<td>
<p>An object of class <code>scalpelY</code>, which results from running the <code><a href="#topic+getY">getY</a></code> function. When not specified, <code>Y</code>
is automatically read in, but specifying <code>Y</code> is recommended when the user
would like to call this function many times, as this avoids reading the video into memory repeatedly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function
#simplest example with default parameters:
plotBrightest(scalpelOutput = scalpelOutput, AfilterIndex = 2)

#example with optional parameters:
#only outline neuron corresponding to frame, plot 5th brightest with raw data
plotBrightest(scalpelOutput = scalpelOutput, AfilterIndex = 2, videoType = "raw",
             neuronsToOutline = "main", brightIndex = 5)

#same plot but if you have video data read in already
#using 'getY' function, you can provide it
rawY = getY(scalpelOutput = scalpelOutput, videoType = "raw")
plotBrightest(scalpelOutput = scalpelOutput, AfilterIndex = 2, Y = rawY,
             neuronsToOutline = "main", brightIndex = 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotCandidateFrame'>Plot preliminary dictionary element from Step 1 of SCALPEL and its corresponding frame.</h2><span id='topic+plotCandidateFrame'></span>

<h3>Description</h3>

<p>We plot the specified preliminary dictionary element, along with the frame of Y from which the component was derived in Step 1 of SCALPEL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCandidateFrame(
  scalpelOutput,
  AzeroIndex = NULL,
  AIndex = NULL,
  AfilterIndex = NULL,
  member = NULL,
  videoType = "processed",
  shrinkLargest = FALSE,
  shrinkCutoff = NULL,
  Y = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCandidateFrame_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="plotCandidateFrame_+3A_azeroindex">AzeroIndex</code></td>
<td>
<p>The preliminary dictionary element of interest. The index refers to the column of <code>scalpelOutput$Azero</code>.
Specify only one of the following: <code>AzeroIndex</code>, <code>AIndex</code>, or <code>AfilterIndex</code>.</p>
</td></tr>
<tr><td><code id="plotCandidateFrame_+3A_aindex">AIndex</code></td>
<td>
<p>The dictionary element (i.e., cluster) of interest. The index refers to the column of <code>scalpelOutput$A</code>.
Note that the class of <code>scalpelOutput</code> must be <code>scalpel</code>, <code>scalpelStep2</code>, or <code>scalpelStep3</code> if specifying <code>AIndex</code>, and <code>member</code> must also be specified.
Specify only one of the following: <code>AzeroIndex</code>, <code>AIndex</code>, or <code>AfilterIndex</code>.</p>
</td></tr>
<tr><td><code id="plotCandidateFrame_+3A_afilterindex">AfilterIndex</code></td>
<td>
<p>The sparse group lasso component of interest. The index refers to the column of <code>scalpelOutput$Afilter</code>.
Note that the
class of <code>scalpelOutput</code> must be <code>scalpel</code> or <code>scalpelStep3</code> if specifying <code>AfilterIndex</code>, and <code>member</code> must also be specified.
Specify only one of the following: <code>AzeroIndex</code>, <code>AIndex</code>, or <code>AfilterIndex</code>.</p>
</td></tr>
<tr><td><code id="plotCandidateFrame_+3A_member">member</code></td>
<td>
<p>Which member of the cluster corresponding to <code>AIndex</code> or <code>AfilterIndex</code> to plot. Ignored if <code>AzeroIndex</code> is specified.</p>
</td></tr>
<tr><td><code id="plotCandidateFrame_+3A_videotype">videoType</code></td>
<td>
<p>Specify whether to plot the processed data from Step 0 (default; <code>videoType="processed"</code>) or raw data (<code>videoType="raw"</code>).
This is ignored if <code>Y</code> is provided.</p>
</td></tr>
<tr><td><code id="plotCandidateFrame_+3A_shrinklargest">shrinkLargest</code></td>
<td>
<p>Logical value indicating whether the values above <code>shrinkCutoff</code> should be shrunk when plotting. Shrinking these values
allows us to better visualize the areas with the largest fluorescence.</p>
</td></tr>
<tr><td><code id="plotCandidateFrame_+3A_shrinkcutoff">shrinkCutoff</code></td>
<td>
<p>The value above which pixel values will be shrunk. By default, this will be chosen as
<code>min(scalpelOutput$thresholdVec)</code>.</p>
</td></tr>
<tr><td><code id="plotCandidateFrame_+3A_y">Y</code></td>
<td>
<p>An object of class <code>scalpelY</code>, which results from running the <code><a href="#topic+getY">getY</a></code> function. When not specified, <code>Y</code>
is automatically read in, but specifying <code>Y</code> is recommended when the user
would like to call this function many times, as this avoids reading the video into memory repeatedly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function
#simplest example with default parameters:
plotCandidateFrame(scalpelOutput = scalpelOutput, AzeroIndex = 10)

#example with optional parameters:
#plot raw data instead of processed
plotCandidateFrame(scalpelOutput = scalpelOutput, AzeroIndex = 10, videoType = "raw")

#same plot but if you have video data read in already
#using 'getY' function, you can provide it
rawY = getY(scalpelOutput = scalpelOutput, videoType = "raw")
plotCandidateFrame(scalpelOutput = scalpelOutput, AzeroIndex = 10, Y = rawY)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotCluster'>Plot a summary of a given cluster from Step 2 of SCALPEL.</h2><span id='topic+plotCluster'></span>

<h3>Description</h3>

<p>We plot the preliminary dictionary elements that correspond to a given dictionary element, derived during Step 2 of SCALPEL, or a
given component included in the sparse group lasso of Step 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCluster(
  scalpelOutput,
  AIndex = NULL,
  AfilterIndex = NULL,
  pctTransp = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCluster_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="plotCluster_+3A_aindex">AIndex</code></td>
<td>
<p>The dictionary element (i.e., cluster) of interest. The index refers to the column of <code>scalpelOutput$A</code>, which is part
of the output from <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>. Specify <code>AIndex</code> or <code>AfilterIndex</code>, not both.</p>
</td></tr>
<tr><td><code id="plotCluster_+3A_afilterindex">AfilterIndex</code></td>
<td>
<p>The refined dictionary element of interest. The index refers to the column of <code>scalpelOutput$Afilter</code>, which is part
of the output from <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>. Note that the
class of <code>scalpelOutput</code> must be <code>scalpel</code> or <code>scalpelStep3</code> if specifying <code>AfilterIndex</code>. Specify <code>AIndex</code> or <code>AfilterIndex</code>, not both.</p>
</td></tr>
<tr><td><code id="plotCluster_+3A_pcttransp">pctTransp</code></td>
<td>
<p>The percent transparency (in [0,1]) for the colors used to plot the preliminary dictionary elements. The default value is 0.01.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The left plot shows the dictionary element of interest in orange, with the other dictionary elements
shown in blue. The middle plot shows all of the preliminary dictionary elements corresponding to the
dictionary element plotted transparently. The right plot shows the dictionary element in orange, along with
the union of all of the preliminary dictionary elements in gray. Note that the plots in the middle and on the right are
zoomed-in, compared to the plot on the left that shows the entire field of view for the video.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function
#plots the cluster for the 2nd dictionary element (i.e., scalpelOutput$A[,2])
plotCluster(scalpelOutput = scalpelOutput, AIndex = 2)
#plots the cluster for the 2nd component included in SGL (i.e., scalpelOutput$Afilter[,2])
plotCluster(scalpelOutput = scalpelOutput, AfilterIndex = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotFrame'>Plot a frame of the video.</h2><span id='topic+plotFrame'></span>

<h3>Description</h3>

<p>We plot a specified frame of the raw video that we began with in Step 0 of SCALPEL,
or the processed video that results from Step 0 of SCALPEL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFrame(
  scalpelOutput,
  frame,
  videoType = "processed",
  shrinkLargest = FALSE,
  shrinkCutoff = NULL,
  title = NULL,
  col = grDevices::grey(seq(0, 1, length = 256)),
  addToPlot = FALSE,
  Y = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFrame_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="plotFrame_+3A_frame">frame</code></td>
<td>
<p>The frame to plot.</p>
</td></tr>
<tr><td><code id="plotFrame_+3A_videotype">videoType</code></td>
<td>
<p>Specify whether to plot the processed data from Step 0 (default; <code>videoType="processed"</code>) or raw data (<code>videoType="raw"</code>).
This is ignored if <code>Y</code> is provided.</p>
</td></tr>
<tr><td><code id="plotFrame_+3A_shrinklargest">shrinkLargest</code></td>
<td>
<p>Logical value indicating whether the values above <code>shrinkCutoff</code> should be shrunk when plotting. Shrinking these values
allows us to better visualize the areas with the largest fluorescence.</p>
</td></tr>
<tr><td><code id="plotFrame_+3A_shrinkcutoff">shrinkCutoff</code></td>
<td>
<p>The value above which pixel values will be shrunk. By default, this will be chosen as
<code>scalpelOutput$lowThreshold</code> if <code>class(scalpelOutput)=="scalpelStep0"</code> or <code>min(scalpelOutput$thresholdVec)</code> otherwise.</p>
</td></tr>
<tr><td><code id="plotFrame_+3A_title">title</code></td>
<td>
<p>Label for the title. By default, it is the frame number.</p>
</td></tr>
<tr><td><code id="plotFrame_+3A_col">col</code></td>
<td>
<p>Vector of colors to use, which by default is grayscale.</p>
</td></tr>
<tr><td><code id="plotFrame_+3A_addtoplot">addToPlot</code></td>
<td>
<p>Logical value indicating whether to add to the current plot.</p>
</td></tr>
<tr><td><code id="plotFrame_+3A_y">Y</code></td>
<td>
<p>An object of class <code>scalpelY</code>, which results from running the <code><a href="#topic+getY">getY</a></code> function. When not specified, <code>Y</code>
is automatically read in, but specifying <code>Y</code> is recommended when the user
would like to call this function many times, as this avoids reading the video into memory repeatedly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function

#simplest example with default parameters:
plotFrame(scalpelOutput = scalpelOutput, frame = 100)

#example with optional parameters:
#plot raw data instead of processed
plotFrame(scalpelOutput = scalpelOutput, frame = 100, videoType = "raw")

#same plot but if you have video data read in already
#using 'getY' function, you can provide it
rawY = getY(scalpelOutput = scalpelOutput, videoType = "raw")
plotFrame(scalpelOutput = scalpelOutput, frame = 100, Y = rawY)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotResults'>Plot both the spatial and temporal components from Step 3 of SCALPEL.</h2><span id='topic+plotResults'></span>

<h3>Description</h3>

<p>We plot the temporal components, displaying the estimated fluorescence over time for each spatial component, along with a map of the spatial components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotResults(
  scalpelOutput,
  neuronsToDisplay = NULL,
  colVec = NULL,
  titleA = "",
  titleZ = "",
  ylabZ = "",
  fileName = NULL,
  pctTransp = 0.7,
  number = TRUE,
  border = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotResults_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code> or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="plotResults_+3A_neuronstodisplay">neuronsToDisplay</code></td>
<td>
<p>Vector giving which neurons' spatial and temporal components to plot. The indices refer to which columns
of <code>scalpelOutput$Afilter</code> to plot. By default, all components are plotted. Users may also specify <code>"kept"</code>,
which will exclude all dictionary elements discarded using a previous call to <code><a href="#topic+reviewNeurons">reviewNeurons</a></code> or <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code>.</p>
</td></tr>
<tr><td><code id="plotResults_+3A_colvec">colVec</code></td>
<td>
<p>Vector of colors to use, which are chosen automatically if the default value of NULL is used.</p>
</td></tr>
<tr><td><code id="plotResults_+3A_titlea">titleA</code></td>
<td>
<p>Label for the title of the spatial components plot.</p>
</td></tr>
<tr><td><code id="plotResults_+3A_titlez">titleZ</code></td>
<td>
<p>Label for the title of the temporal components plot.</p>
</td></tr>
<tr><td><code id="plotResults_+3A_ylabz">ylabZ</code></td>
<td>
<p>Label for the y-axis of the temporal components plot.</p>
</td></tr>
<tr><td><code id="plotResults_+3A_filename">fileName</code></td>
<td>
<p>If provided, the plot will be saved to the specified location.</p>
</td></tr>
<tr><td><code id="plotResults_+3A_pcttransp">pctTransp</code></td>
<td>
<p>The percent transparency (in [0,1]) for the colors used to plot the neurons. The default value is 0.7.</p>
</td></tr>
<tr><td><code id="plotResults_+3A_number">number</code></td>
<td>
<p>Logical value indicating whether the neurons should be numbered.</p>
</td></tr>
<tr><td><code id="plotResults_+3A_border">border</code></td>
<td>
<p>Logical value indicating whether only the borders of the neurons should be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>lambdaIndex</code> is <code>NULL</code>, each temporal component is scaled by its largest value. If
<code>lambdaIndex</code> is specified, each temporal component is scaled by its largest value across all of the lambda values.
Temporal components that were zeroed out in the sparse group lasso are omitted from the plot, and their corresponding
spatial components are shown in gray.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep3">scalpelStep3</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+plotSpatial">plotSpatial</a></code>, <code><a href="#topic+plotTemporal">plotTemporal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function

#simplest example with default parameters:
plotResults(scalpelOutput = scalpelOutput)

#example with optional parameters:
#plot only two of the neurons, do not number neurons, draw the outlines of the neurons
plotResults(scalpelOutput = scalpelOutput, neuronsToDisplay = c(1,2),
           number = FALSE, border = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotResultsAllLambda'>Plot both the spatial and temporal components for the sequence of lambda values from Step 3 of SCALPEL.</h2><span id='topic+plotResultsAllLambda'></span>

<h3>Description</h3>

<p>We plot the temporal components, displaying the estimated fluorescence over time for each spatial component, along with a map of the spatial components for a whole sequence of lambda values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotResultsAllLambda(
  scalpelOutput,
  neuronsToDisplay = NULL,
  colVec = NULL,
  titleA = "",
  ylabZ = "",
  fileName = NULL,
  pctTransp = 0.7,
  number = TRUE,
  border = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotResultsAllLambda_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code> or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="plotResultsAllLambda_+3A_neuronstodisplay">neuronsToDisplay</code></td>
<td>
<p>Vector giving which neurons' spatial and temporal components to plot. The indices refer to which columns
of <code>scalpelOutput$Afilter</code> to plot. By default, all components are plotted. Users may also specify <code>"kept"</code>,
which will exclude all dictionary elements discarded using a previous call to <code><a href="#topic+reviewNeurons">reviewNeurons</a></code> or <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code>.</p>
</td></tr>
<tr><td><code id="plotResultsAllLambda_+3A_colvec">colVec</code></td>
<td>
<p>Vector of colors to use, which are chosen automatically if the default value of NULL is used.</p>
</td></tr>
<tr><td><code id="plotResultsAllLambda_+3A_titlea">titleA</code></td>
<td>
<p>Label for the title of the spatial components plot.</p>
</td></tr>
<tr><td><code id="plotResultsAllLambda_+3A_ylabz">ylabZ</code></td>
<td>
<p>Label for the y-axis of the temporal components plot.</p>
</td></tr>
<tr><td><code id="plotResultsAllLambda_+3A_filename">fileName</code></td>
<td>
<p>If provided, the plot will be saved to the specified location.</p>
</td></tr>
<tr><td><code id="plotResultsAllLambda_+3A_pcttransp">pctTransp</code></td>
<td>
<p>The percent transparency (in [0,1]) for the colors used to plot the neurons. The default value is 0.7.</p>
</td></tr>
<tr><td><code id="plotResultsAllLambda_+3A_number">number</code></td>
<td>
<p>Logical value indicating whether the neurons should be numbered.</p>
</td></tr>
<tr><td><code id="plotResultsAllLambda_+3A_border">border</code></td>
<td>
<p>Logical value indicating whether only the borders of the neurons should be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Temporal components that were zeroed out in the sparse group lasso and their corresponding spatial components
are shown in gray for both plots.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep3">scalpelStep3</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+plotSpatial">plotSpatial</a></code>, <code><a href="#topic+plotTemporal">plotTemporal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function

#simplest example with default parameters:
plotResultsAllLambda(scalpelOutput = scalpelOutput)

#example with optional parameters:
#plot only two of the neurons, do not number neurons, draw the outlines of the neurons
plotResultsAllLambda(scalpelOutput = scalpelOutput, neuronsToDisplay = c(1,2),
                    number = FALSE, border = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotSpatial'>Plot spatial components from Steps 2 or 3 of SCALPEL.</h2><span id='topic+plotSpatial'></span>

<h3>Description</h3>

<p>We plot the dictionary elements obtained from Step 2 of SCALPEL, or the filtered dictionary elements from Step 3 of SCALPEL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSpatial(
  scalpelOutput = NULL,
  neuronSet = "",
  neuronsToDisplay = NULL,
  colVec = NULL,
  title = "",
  fileName = NULL,
  pctTransp = 0.7,
  number = TRUE,
  addToPlot = FALSE,
  border = FALSE,
  zoom = FALSE,
  A = NULL,
  videoHeight = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSpatial_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of these SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_neuronset">neuronSet</code></td>
<td>
<p>Which set of neurons should be plotted:
use <code>"A"</code> for the dictionary elements resulting from <code><a href="#topic+scalpelStep2">scalpelStep2</a></code> and saved as <code>scalpelOutput$A</code>,
or use <code>"Afilter"</code> for the filtered dictionary elements resulting from <code><a href="#topic+scalpelStep3">scalpelStep3</a></code> and saved as <code>scalpelOutput$Afilter</code>.</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_neuronstodisplay">neuronsToDisplay</code></td>
<td>
<p>Vector giving which neurons' spatial components to plot. The indices refer to which columns to plot
of <code>scalpelOutput$Afilter</code> (if <code>neuronSet="Afilter"</code>), or <code>scalpelOutput$A</code> (if <code>neuronSet="A"</code>). By default, all components are plotted.
Users may also specify <code>"kept"</code>, which will exclude all dictionary elements discarded using a previous call to <code><a href="#topic+reviewNeurons">reviewNeurons</a></code> or <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code>.</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_colvec">colVec</code></td>
<td>
<p>Vector of colors to use, which are chosen automatically if the default value of NULL is used.</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_title">title</code></td>
<td>
<p>Label for the title.</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_filename">fileName</code></td>
<td>
<p>If provided, the plot will be saved to the specified location.</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_pcttransp">pctTransp</code></td>
<td>
<p>The percent transparency (in [0,1]) for the colors used to plot the neurons. The default value is 0.7.</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_number">number</code></td>
<td>
<p>Logical value indicating whether the neurons should be numbered.</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_addtoplot">addToPlot</code></td>
<td>
<p>Logical value indicating whether these neurons should be plotted to an existing plot.</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_border">border</code></td>
<td>
<p>Logical value indicating whether only the borders of the neurons should be plotted.</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_zoom">zoom</code></td>
<td>
<p>Logical value indicating whether the plot should be zoomed in to exclude any area not containing neurons.</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_a">A</code></td>
<td>
<p>Optional advanced user argument: A matrix containing the spatial components to plot, where the ith column of <code>A</code>
is a vector of 1's and 0's, indicating whether each pixel is contained in the ith spatial component. By default,
this argument is ignored and the dictionary elements saved in <code>scalpelOutput$A</code> or <code>scalpelOutput$Afilter</code> are plotted. If <code>A</code> is provided,
<code>scalpelOutput</code> will be ignored and <code>neuronsToDisplay</code> will refer to the columns of <code>A</code>.</p>
</td></tr>
<tr><td><code id="plotSpatial_+3A_videoheight">videoHeight</code></td>
<td>
<p>The height of the video (in pixels). This only needs to be specified if the user is plotting <code>A</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>neuronSet="Afilter"</code>, spatial components corresponding to temporal components that were zeroed out in the sparse group lasso are plotted in gray, unless <code>colVec</code> is specified by the user.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+plotResults">plotResults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function

#simplest example with default parameters:
plotSpatial(scalpelOutput = scalpelOutput, neuronSet = "Afilter")

#example with optional parameters:
#plot only two of the neurons, add a title, do not number neurons,
#and draw the outlines of the neurons
plotSpatial(scalpelOutput = scalpelOutput, neuronsToDisplay = c(1,2), neuronSet = "Afilter",
           title = "First two neurons", number = FALSE, border = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotTemporal'>Plot temporal components from Step 3 of SCALPEL.</h2><span id='topic+plotTemporal'></span>

<h3>Description</h3>

<p>We plot the temporal components, displaying the estimated fluorescence over time for each spatial component,
which result from running Step 3 of SCALPEL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTemporal(
  scalpelOutput,
  neuronsToDisplay = NULL,
  colVec = NULL,
  ylab = "",
  title = "",
  fileName = NULL,
  lambdaIndex = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTemporal_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of these SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code> or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="plotTemporal_+3A_neuronstodisplay">neuronsToDisplay</code></td>
<td>
<p>Vector giving which neurons' temporal components to plot. The indices refer to which rows
of <code>scalpelOutput$Zhat</code> to plot. By default, all components are plotted. Users may also specify <code>"kept"</code>,
which will exclude all dictionary elements discarded using a previous call to <code><a href="#topic+reviewNeurons">reviewNeurons</a></code> or <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code>.</p>
</td></tr>
<tr><td><code id="plotTemporal_+3A_colvec">colVec</code></td>
<td>
<p>Vector of colors to use, which are chosen automatically if the default value of NULL is used.</p>
</td></tr>
<tr><td><code id="plotTemporal_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="plotTemporal_+3A_title">title</code></td>
<td>
<p>Label for the title.</p>
</td></tr>
<tr><td><code id="plotTemporal_+3A_filename">fileName</code></td>
<td>
<p>If provided, the plot will be saved to the specified location.</p>
</td></tr>
<tr><td><code id="plotTemporal_+3A_lambdaindex">lambdaIndex</code></td>
<td>
<p>Optional advanced user argument: Index of lambda value for which results will be plotted. Default is
to use lambda value of <code>scalpelOutput$lambda</code> but specifying this will use the lambda value of <code>scalpelOutput$lambdaSeq[lambdaIndex]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>lambdaIndex</code> is <code>NULL</code>, each temporal component is scaled by its largest value. If
<code>lambdaIndex</code> is specified, each temporal component is scaled by its largest value across all of the lambda values.
Temporal components that were zeroed out in the sparse group lasso are omitted from the plot.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep3">scalpelStep3</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+plotResults">plotResults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function

#simplest example with default parameters:
plotTemporal(scalpelOutput = scalpelOutput)

#example with optional parameters:
#plot only two of the neurons and add a title
plotTemporal(scalpelOutput = scalpelOutput, neuronsToDisplay = c(1,2),
             title = "First two neurons")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotThresholdedFrame'>Plot a frame of the video with shading.</h2><span id='topic+plotThresholdedFrame'></span>

<h3>Description</h3>

<p>We plot a specified frame of the processed video, which results from Step 0 of SCALPEL,
with shading to indicate values above a specified threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotThresholdedFrame(
  scalpelOutput,
  frame,
  threshold,
  shrinkLargest = FALSE,
  shrinkCutoff = NULL,
  title = NULL,
  col = "yellow",
  Y = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotThresholdedFrame_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="plotThresholdedFrame_+3A_frame">frame</code></td>
<td>
<p>The frame to plot.</p>
</td></tr>
<tr><td><code id="plotThresholdedFrame_+3A_threshold">threshold</code></td>
<td>
<p>Value above which pixels will be shaded.</p>
</td></tr>
<tr><td><code id="plotThresholdedFrame_+3A_shrinklargest">shrinkLargest</code></td>
<td>
<p>Logical value indicating whether the values above <code>shrinkCutoff</code> should be shrunk when plotting. Shrinking these values
allows us to better visualize the areas with the largest fluorescence.</p>
</td></tr>
<tr><td><code id="plotThresholdedFrame_+3A_shrinkcutoff">shrinkCutoff</code></td>
<td>
<p>The value above which pixel values will be shrunk. By default, this will be chosen as
<code>scalpelOutput$lowThreshold</code> if <code>class(scalpelOutput)=="scalpelStep0"</code> or <code>min(scalpelOutput$thresholdVec)</code> otherwise.</p>
</td></tr>
<tr><td><code id="plotThresholdedFrame_+3A_title">title</code></td>
<td>
<p>Label for the title. By default, it gives the threshold value.</p>
</td></tr>
<tr><td><code id="plotThresholdedFrame_+3A_col">col</code></td>
<td>
<p>Color of shading to use, which is yellow by default.</p>
</td></tr>
<tr><td><code id="plotThresholdedFrame_+3A_y">Y</code></td>
<td>
<p>An object of class <code>scalpelY</code>, which results from running the <code><a href="#topic+getY">getY</a></code> function. When not specified, <code>Y</code>
is automatically read in, but specifying <code>Y</code> is recommended when the user
would like to call this function many times, as this avoids reading the video into memory repeatedly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function

#simplest example with default parameters:
plotThresholdedFrame(scalpelOutput = scalpelOutput, frame = 100,
                    threshold = scalpelOutput$thresholdVec[1])

#example with optional parameters:
#change shading to purple and add a title
plotThresholdedFrame(scalpelOutput = scalpelOutput, frame = 100, col = "purple",
                   threshold = scalpelOutput$thresholdVec[2])

#if you have video data read in already using 'getY' function, you can provide it
processedY = getY(scalpelOutput = scalpelOutput, videoType = "processed")
plotThresholdedFrame(scalpelOutput = scalpelOutput, frame = 100,
                    threshold = scalpelOutput$thresholdVec[1], Y = processedY)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotVideoVariance'>Plot a summary of the fluorescence in the video.</h2><span id='topic+plotVideoVariance'></span>

<h3>Description</h3>

<p>We plot a heat map of the variance of each pixel across the frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVideoVariance(
  scalpelOutput,
  neuronSet = "",
  videoType = "processed",
  neuronsToOutline = "all",
  shrinkLargest = FALSE,
  shrinkQuantile = 0.95,
  title = "",
  Y = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVideoVariance_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="plotVideoVariance_+3A_neuronset">neuronSet</code></td>
<td>
<p>This argument is ignored unless the class of <code>scalpelOutput</code> is <code>scalpel</code> or <code>scalpelStep3</code>, and <code>neuronsToOutline</code> is not <code>"none"</code>. It gives which set of neurons should be plotted:
use <code>"A"</code> for those resulting from <code><a href="#topic+scalpelStep2">scalpelStep2</a></code> and saved as <code>scalpelOutput$A</code>, or use <code>"Afilter"</code> for those resulting from
<code><a href="#topic+scalpelStep3">scalpelStep3</a></code> and saved as <code>scalpelOutput$Afilter</code>.</p>
</td></tr>
<tr><td><code id="plotVideoVariance_+3A_videotype">videoType</code></td>
<td>
<p>Specify whether to plot the processed data from Step 0 (default; <code>videoType="processed"</code>) or raw data (<code>videoType="raw"</code>).
This is ignored if <code>Y</code> is provided.</p>
</td></tr>
<tr><td><code id="plotVideoVariance_+3A_neuronstooutline">neuronsToOutline</code></td>
<td>
<p>Specify whether to plot outlines of all neurons (default; <code>neuronsToOutline="all"</code>),
none of the neurons (<code>neuronsToOutline="none"</code>), or outlines of only the neurons kept
using a previous call to <code><a href="#topic+reviewNeurons">reviewNeurons</a></code> or <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code> (<code>neuronsToOutline="kept"</code>).
If <code>scalpelOutput</code> is not of the class <code>scalpel</code>, <code>scalpelStep2</code>, or <code>scalpelStep3</code>, this argument is ignored.</p>
</td></tr>
<tr><td><code id="plotVideoVariance_+3A_shrinklargest">shrinkLargest</code></td>
<td>
<p>Logical value indicating whether the values above <code>shrinkQuantile</code> should be shrunk when plotting. Shrinking these values
allows us to better visualize the areas with the highest variance fluorescence.</p>
</td></tr>
<tr><td><code id="plotVideoVariance_+3A_shrinkquantile">shrinkQuantile</code></td>
<td>
<p>The quantile value above which pixel values will be shrunk. By default, this is the 95th quantile.</p>
</td></tr>
<tr><td><code id="plotVideoVariance_+3A_title">title</code></td>
<td>
<p>Label for the title.</p>
</td></tr>
<tr><td><code id="plotVideoVariance_+3A_y">Y</code></td>
<td>
<p>An object of class <code>scalpelY</code>, which results from running the <code><a href="#topic+getY">getY</a></code> function. When not specified, <code>Y</code>
is automatically read in, but specifying <code>Y</code> is recommended when the user
would like to call this function many times, as this avoids reading the video into memory repeatedly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpel">scalpel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function

#simplest example with default parameters:
plotVideoVariance(scalpelOutput = scalpelOutput, neuronSet = "Afilter")

#example with optional parameters:
#previous showed summary of processed data,
#can instead show raw data, not outline the neurons found, and add a title
plotVideoVariance(scalpelOutput = scalpelOutput, videoType = "raw",
                 neuronsToOutline = "none", title = "Raw Data")

#if you have video data read in already using 'getY' function, you can provide it
rawY = getY(scalpelOutput = scalpelOutput, videoType = "raw")
plotVideoVariance(scalpelOutput = scalpelOutput, neuronSet = "Afilter", Y = rawY)

## End(Not run)
</code></pre>

<hr>
<h2 id='reviewNeurons'>Manually classify the identified neurons from SCALPEL.</h2><span id='topic+reviewNeurons'></span>

<h3>Description</h3>

<p>We save plots that will be used to review the set of identified neurons that result from either Step 2 or 3 of SCALPEL in order to manually classify them according
to whether they appear to be real neurons or not. To do this, the plot of the frame from which the dictionary element was derived is saved.
The user can then sort these saved plot into folders indicating whether the neuron is real or not, or indicate that additional frames are needed to make the classification, in which
case the <code><a href="#topic+reviewNeuronsMoreFrames">reviewNeuronsMoreFrames</a></code> function can subsequently be used. After finishing this sorting process, <code><a href="#topic+updateNeurons">updateNeurons</a></code> should be called.
A similar manual classification can be done interactively using <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reviewNeurons(
  scalpelOutput,
  neuronSet,
  keepClusterSize = NULL,
  discardZeroedOut = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reviewNeurons_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="reviewNeurons_+3A_neuronset">neuronSet</code></td>
<td>
<p>The set of neurons that should be reviewed:
use <code>"A"</code> for those resulting from <code><a href="#topic+scalpelStep2">scalpelStep2</a></code> and saved as <code>scalpelOutput$A</code>, or use <code>"Afilter"</code> for those resulting from
<code><a href="#topic+scalpelStep3">scalpelStep3</a></code> and saved as <code>scalpelOutput$Afilter</code>. This argument is ignored if the class of <code>scalpelOutput</code> is <code>scalpelStep2</code>.</p>
</td></tr>
<tr><td><code id="reviewNeurons_+3A_keepclustersize">keepClusterSize</code></td>
<td>
<p>Neurons corresponding to clusters with at least <code>keepClusterSize</code> members will be automatically classified as real neurons.
The default value is <code>NULL</code>, which means that none of the neurons will be automatically kept based on cluster size.</p>
</td></tr>
<tr><td><code id="reviewNeurons_+3A_discardzeroedout">discardZeroedOut</code></td>
<td>
<p>Logical value indicating whether neurons zeroed out in the sparse group lasso problem should automatically be discarded. This argument
is ignored when <code>neuronSet</code> is <code>"A"</code>, and has a default value of <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots are saved for each of the neurons under consideration in a certain folder. Also within that folder,
there will be folders called 'keep', 'discard', and 'unsure'. After running this function, the plots for each of the neurons
should be moved into the appropriate folder. After completing this sorting, call <code><a href="#topic+updateNeurons">updateNeurons</a></code> in order to
update the classification of the neurons. Any plots that are missing or that remain in the original folder will be classified as not having been sorted yet.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p>After sorting the plots saved by this function, the user should call <code><a href="#topic+updateNeurons">updateNeurons</a></code>.
For other functions useful in the classification process, see <code><a href="#topic+reviewNeuronsMoreFrames">reviewNeuronsMoreFrames</a></code> and
<code><a href="#topic+reviewOverlappingNeurons">reviewOverlappingNeurons</a></code>. Once classification is finished,
the argument <code>neuronsToOutline="kept"</code> can be used with <code><a href="#topic+plotBrightest">plotBrightest</a></code> and <code><a href="#topic+plotVideoVariance">plotVideoVariance</a></code>,
and the argument <code>neuronsToDisplay="kept"</code> can be used with <code><a href="#topic+plotResults">plotResults</a></code>, <code><a href="#topic+plotResultsAllLambda">plotResultsAllLambda</a></code>,
<code><a href="#topic+plotTemporal">plotTemporal</a></code>, and <code><a href="#topic+plotSpatial">plotSpatial</a></code>. Finally, the argument <code>excludeReps="discarded"</code> allows
the discarded dictionary elements to be excluded from the sparse group lasso model when running <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function

#we review the set of spatial components from Step 3,
#which are contained in scalpelOutput$Afilter
reviewNeurons(scalpelOutput = scalpelOutput, neuronSet = "Afilter")

## End(Not run)
</code></pre>

<hr>
<h2 id='reviewNeuronsInteractive'>Manually classify the identified neurons from SCALPEL.</h2><span id='topic+reviewNeuronsInteractive'></span>

<h3>Description</h3>

<p>We interactively review the set of identified neurons that result from either Step 2 or 3 of SCALPEL in order to manually classify them according
to whether they appear to be real neurons or not. To do this, the frame from which the dictionary element was derived is plotted.
The user can manually classify the neuron as real or not, or indicate that additional frames are needed to make the classification, in which
case the <code><a href="#topic+reviewNeuronsMoreFrames">reviewNeuronsMoreFrames</a></code> function can subsequently be used. A similar manual classification can be done non-interactively using <code><a href="#topic+reviewNeurons">reviewNeurons</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reviewNeuronsInteractive(scalpelOutput, neuronSet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reviewNeuronsInteractive_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="reviewNeuronsInteractive_+3A_neuronset">neuronSet</code></td>
<td>
<p>The set of neurons that should be reviewed:
use <code>"A"</code> for those resulting from <code><a href="#topic+scalpelStep2">scalpelStep2</a></code> and saved as <code>scalpelOutput$A</code>, or use <code>"Afilter"</code> for those resulting from
<code><a href="#topic+scalpelStep3">scalpelStep3</a></code> and saved as <code>scalpelOutput$Afilter</code>. This argument is ignored if the class of <code>scalpelOutput</code> is <code>scalpelStep2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p>For other functions useful in the classification process, see <code><a href="#topic+reviewNeuronsMoreFrames">reviewNeuronsMoreFrames</a></code>,
<code><a href="#topic+reviewOverlappingNeurons">reviewOverlappingNeurons</a></code>, and <code><a href="#topic+updateNeuronsInteractive">updateNeuronsInteractive</a></code>. Once classification is finished,
the argument <code>neuronsToOutline="kept"</code> can be used with <code><a href="#topic+plotBrightest">plotBrightest</a></code> and <code><a href="#topic+plotVideoVariance">plotVideoVariance</a></code>,
and the argument <code>neuronsToDisplay="kept"</code> can be used with <code><a href="#topic+plotResults">plotResults</a></code>, <code><a href="#topic+plotResultsAllLambda">plotResultsAllLambda</a></code>,
<code><a href="#topic+plotTemporal">plotTemporal</a></code>, and <code><a href="#topic+plotSpatial">plotSpatial</a></code>. Finally, the argument <code>excludeReps="discarded"</code> allows
the discarded dictionary elements to be excluded from the sparse group lasso model when running <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function

#we review the set of spatial components from Step 2,
#which are contained in scalpelOutput$A
reviewNeuronsInteractive(scalpelOutput = scalpelOutput, neuronSet = "A")
#enter "Y" for the first neuron and then "Q"
#entering "Q" allows us to finish manually classifying later using the same command
#this time there are fewer left to review
reviewNeuronsInteractive(scalpelOutput = scalpelOutput, neuronSet = "A")
#enter "N" for the first and "?" for the second this time
#note that once a neuron is classified as "N", it disappears from the plot

## End(Not run)
</code></pre>

<hr>
<h2 id='reviewNeuronsMoreFrames'>Save additional frames for manually classifying the identified neurons from SCALPEL.</h2><span id='topic+reviewNeuronsMoreFrames'></span>

<h3>Description</h3>

<p>We use this function after running <code><a href="#topic+reviewNeurons">reviewNeurons</a></code> or <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code> to plot additional frames for neurons whose classification was
unclear from the single frame plotted. The additional frames are saved, and the classification
for the neurons can then be updated using <code><a href="#topic+updateNeurons">updateNeurons</a></code> or <code><a href="#topic+updateNeuronsInteractive">updateNeuronsInteractive</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reviewNeuronsMoreFrames(scalpelOutput, neuronSet, numFrames = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reviewNeuronsMoreFrames_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="reviewNeuronsMoreFrames_+3A_neuronset">neuronSet</code></td>
<td>
<p>The set of neurons that should be reviewed:
use <code>"A"</code> for those resulting from <code><a href="#topic+scalpelStep2">scalpelStep2</a></code> and saved as <code>scalpelOutput$A</code>, or use <code>"Afilter"</code> for those resulting from
<code><a href="#topic+scalpelStep3">scalpelStep3</a></code> and saved as <code>scalpelOutput$Afilter</code>. This argument is ignored if the class of <code>scalpelOutput</code> is <code>scalpelStep2</code>.</p>
</td></tr>
<tr><td><code id="reviewNeuronsMoreFrames_+3A_numframes">numFrames</code></td>
<td>
<p>The maximum number of frames that should be saved for each neuron being considered. Each neuron has a number of frames
equal to the number of members in that neuron's cluster that can be plotted. All frames will be saved when the total number of available frames for the neuron
is less than <code>numFrames</code>. The default value is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reviewNeurons">reviewNeurons</a></code>, <code><a href="#topic+updateNeurons">updateNeurons</a></code>, <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code>, <code><a href="#topic+updateNeuronsInteractive">updateNeuronsInteractive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "reviewNeuronsInteractive" function

#we save frames for the neurons previously classified
#as "?" using the "reviewNeuronsInteractive" function
reviewNeuronsMoreFrames(scalpelOutput = scalpelOutput, neuronSet = "A")

## End(Not run)
</code></pre>

<hr>
<h2 id='reviewOverlappingNeurons'>Save additional frames for overlapping neurons from SCALPEL.</h2><span id='topic+reviewOverlappingNeurons'></span>

<h3>Description</h3>

<p>We use this function after running <code><a href="#topic+reviewNeurons">reviewNeurons</a></code> or <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code> to plot additional frames for neurons that overlap with others.
These frames are saved, and the classification for the neurons can then be updated using <code><a href="#topic+updateNeurons">updateNeurons</a></code> or <code><a href="#topic+updateNeuronsInteractive">updateNeuronsInteractive</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reviewOverlappingNeurons(scalpelOutput, neuronSet, numFrames = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reviewOverlappingNeurons_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="reviewOverlappingNeurons_+3A_neuronset">neuronSet</code></td>
<td>
<p>The set of neurons that should be reviewed:
use <code>"A"</code> for those resulting from <code><a href="#topic+scalpelStep2">scalpelStep2</a></code> and saved as <code>scalpelOutput$A</code>, or use <code>"Afilter"</code> for those resulting from
<code><a href="#topic+scalpelStep3">scalpelStep3</a></code> and saved as <code>scalpelOutput$Afilter</code>. This argument is ignored if the class of <code>scalpelOutput</code> is <code>scalpelStep2</code>.</p>
</td></tr>
<tr><td><code id="reviewOverlappingNeurons_+3A_numframes">numFrames</code></td>
<td>
<p>The maximum number of frames that should be saved for each neuron being considered. Each neuron has a number of frames
equal to the number of members in that neuron's cluster that can be plotted. All frames will be saved when the total number of available frames for the neuron
is less than <code>numFrames</code>. The default value is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reviewNeurons">reviewNeurons</a></code>, <code><a href="#topic+updateNeurons">updateNeurons</a></code>, <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code>, <code><a href="#topic+updateNeuronsInteractive">updateNeuronsInteractive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "reviewNeuronsInteractive" function

reviewOverlappingNeurons(scalpelOutput = scalpelOutput, neuronSet = "A")

## End(Not run)
</code></pre>

<hr>
<h2 id='scalpel'>Perform entire SCALPEL pipeline.</h2><span id='topic+scalpel'></span>

<h3>Description</h3>

<p>Segmentation, Clustering, and Lasso Penalties (SCALPEL) is a method for neuronal calcium imaging
data that identifies the locations of neurons, and estimates their calcium concentrations over time.
The pipeline involves several steps, each of which is described briefly in its corresponding
function. See <code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>,
<code><a href="#topic+scalpelStep3">scalpelStep3</a></code> for more details.
Full details for the SCALPEL method are provided in Petersen, A., Simon, N., and Witten, D. (Forthcoming).
SCALPEL: Extracting Neurons from Calcium Imaging Data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalpel(
  outputFolder,
  rawDataFolder,
  videoHeight,
  minClusterSize = 1,
  lambdaMethod = "trainval",
  lambda = NULL,
  cutoff = 0.18,
  omega = 0.2,
  fileType = "R",
  processSeparately = TRUE,
  minSize = 25,
  maxSize = 500,
  maxWidth = 30,
  maxHeight = 30,
  removeBorder = FALSE,
  alpha = 0.9,
  thresholdVec = NULL,
  maxSizeToCluster = 3000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalpel_+3A_outputfolder">outputFolder</code></td>
<td>
<p>Step 0 parameter: The existing directory where the results should be saved.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_rawdatafolder">rawDataFolder</code></td>
<td>
<p>Step 0 parameter: The directory where the raw data version of Y is saved. The data should be a
PxT matrix, where P is the total number of pixels per image frame and T
the number of frames of the video, for which the (i,j)th element contains the
fluorescence of the ith pixel in the jth frame. To create Y, you should
vectorize each 2-dimensional image frame by concatenating the columns of the image frame.  If the data is
saved in a single file, it should be named &quot;Y_1.mat&quot;, &quot;Y_1.rds&quot;, &quot;Y_1.txt&quot;, or &quot;Y_1.txt.gz&quot; (depending on <code>fileType</code>),
and if the data is split over multiple files, they should be split into chunks of the columns
and named consecutively (&quot;Y_1.mat&quot;, &quot;Y_2.mat&quot;, etc.; &quot;Y_1.rds&quot;, &quot;Y_2.rds&quot;, etc.; &quot;Y_1.txt&quot;, &quot;Y_2.txt&quot;, etc.; or &quot;Y_1.txt.gz&quot;, &quot;Y_2.txt.gz&quot;, etc.).</p>
</td></tr>
<tr><td><code id="scalpel_+3A_videoheight">videoHeight</code></td>
<td>
<p>Step 0 parameter: The height of the video (in pixels).</p>
</td></tr>
<tr><td><code id="scalpel_+3A_minclustersize">minClusterSize</code></td>
<td>
<p>Step 3 parameter: The minimum number of preliminary dictionary elements that a cluster must contain in order to be included
in the sparse group lasso.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_lambdamethod">lambdaMethod</code></td>
<td>
<p>Step 3 parameter: A description of how lambda should be chosen: either <code>"trainval"</code> (default),
<code>"distn"</code>, or <code>"user"</code>. A value of <code>"trainval"</code> means lambda will be chosen using a training/validation
set approach. A value of <code>"distn"</code> means lambda will be chosen as the negative of the 0.1% quantile
of elements of active pixels (i.e., those contained in at least one dictionary element) of Y.
Using <code>"distn"</code> is computationally faster than <code>"trainval"</code>. Alternatively with <code>"user"</code>,
the value of lambda can be directly specified using <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_lambda">lambda</code></td>
<td>
<p>Step 3 parameter: The value of lambda to use when fitting the sparse group lasso. By default, the value is automatically
chosen using the approach specified by <code>lambdaMethod</code>. If a value is provided for <code>lambda</code>, then <code>lambdaMethod</code>
will be ignored.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_cutoff">cutoff</code></td>
<td>
<p>Step 2 parameter: A value in [0,1] indicating where to cut the dendrogram that results from hierarchical clustering
of the preliminary dictionary elements. The default value is 0.18.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_omega">omega</code></td>
<td>
<p>Step 2 parameter: A value in [0,1] indicating how to weight spatial vs. temporal information in the dissimilarity metric
used for clustering. If <code>omega=1</code>, only spatial information is used. The default value is 0.2.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_filetype">fileType</code></td>
<td>
<p>Step 0 parameter: Indicates whether raw data is an .rds (default value; <code>fileType="R"</code>), .mat (<code>fileType="matlab"</code>),
.txt (<code>fileType="text"</code>), or .txt.gz (<code>fileType="zippedText"</code>) file. Any text files should not have row or column names.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_processseparately">processSeparately</code></td>
<td>
<p>Step 0 parameter: Logical scalar giving whether the multiple raw data files should be
processed individually, versus all at once. Processing the files separately may be preferable for larger videos.
Default value is <code>TRUE</code>; this argument is ignored if the raw data is saved in a single file.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_minsize">minSize</code>, <code id="scalpel_+3A_maxsize">maxSize</code></td>
<td>
<p>Step 1 parameter: The minimum and maximum size, respectively, for a preliminary dictionary element with default values
of 25 and 500, respectively.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_maxwidth">maxWidth</code>, <code id="scalpel_+3A_maxheight">maxHeight</code></td>
<td>
<p>Step 1 parameter: The maximum width and height, respectively, for a preliminary dictionary element with default values of 30.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_removeborder">removeBorder</code></td>
<td>
<p>Step 3 parameter: A logical scalar indicating whether the dictionary elements containing pixels in the 10-pixel
border of the video should be removed prior to fitting the sparse group lasso. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_alpha">alpha</code></td>
<td>
<p>Step 3 parameter: The value of alpha to use when fitting the sparse group lasso. The default value is 0.9.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_thresholdvec">thresholdVec</code></td>
<td>
<p>Optional advanced user argument: Step 1 parameter: A vector with the desired thresholds to use for image segmentation. If not specified, the default is to
use the negative of the minimum of the processed Y data, the negative of the 0.1% quantile of the processed Y data, and the mean of these. If there were multiple raw data
files that were processed separately, these values are calculated on only the first part of data, and then these thresholds are used for the remaining parts.</p>
</td></tr>
<tr><td><code id="scalpel_+3A_maxsizetocluster">maxSizeToCluster</code></td>
<td>
<p>Optional advanced user argument: Step 2 parameter: The maximum number of preliminary dictionary elements to cluster at once. We attempt to cluster each
overlapping set of preliminary dictionary elements, but if one of these sets is very large (e.g., &gt;10,000), memory issues may
result. Thus we perform a two-stage clustering in which we first cluster together random sets of size
approximately equaling <code>maxSizeToCluster</code> and then cluster together the representatives from the first stage.
Finally, we recalculate the representatives using all of the preliminary dictionary elements in the final clusters. The default value is 3000.
If <code>maxSizeToCluster</code> is set to <code>NULL</code>, single-stage clustering is done, regardless of the size of the overlapping sets.
Memory issues may result when using this option to force single-stage clustering if the size of
the largest overlapping set of preliminary dictionary elements is very large (e.g., &gt;10,000).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several files containing data from the pipeline, as well as summaries of each step,
are saved in various subdirectories of &quot;outputFolder&quot;.
</p>


<h3>Value</h3>

<p>An object of class <code>scalpel</code>, which can be summarized using <code><a href="#topic+summary">summary</a></code>, used to rerun SCALPEL Steps 1-3 with new parameters using <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, and <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>,
or can be used with any of the plotting functions: <code><a href="#topic+plotFrame">plotFrame</a></code>, <code><a href="#topic+plotThresholdedFrame">plotThresholdedFrame</a></code>, <code><a href="#topic+plotVideoVariance">plotVideoVariance</a></code>, <code><a href="#topic+plotCandidateFrame">plotCandidateFrame</a></code>,
<code><a href="#topic+plotCluster">plotCluster</a></code>, <code><a href="#topic+plotResults">plotResults</a></code>, <code><a href="#topic+plotResultsAllLambda">plotResultsAllLambda</a></code>, <code><a href="#topic+plotSpatial">plotSpatial</a></code>,
<code><a href="#topic+plotTemporal">plotTemporal</a></code>, and <code><a href="#topic+plotBrightest">plotBrightest</a></code>.
The individual elements are described in detail in the documentation for the corresponding step: <code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, and <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.
</p>


<h3>See Also</h3>

<p>The individual steps in the pipeline can be run using the <code><a href="#topic+scalpelStep0">scalpelStep0</a></code>,
<code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, and <code><a href="#topic+scalpelStep3">scalpelStep3</a></code> functions.
Results can be summarized using <code><a href="#topic+summary">summary</a></code>, loaded at a later time using <code><a href="#topic+getScalpel">getScalpel</a></code>, and plotted using <code><a href="#topic+plotResults">plotResults</a></code>,
<code><a href="#topic+plotSpatial">plotSpatial</a></code>, <code><a href="#topic+plotTemporal">plotTemporal</a></code>, <code><a href="#topic+plotCluster">plotCluster</a></code>, <code><a href="#topic+plotVideoVariance">plotVideoVariance</a></code>,
<code><a href="#topic+plotFrame">plotFrame</a></code>, <code><a href="#topic+plotThresholdedFrame">plotThresholdedFrame</a></code>, <code><a href="#topic+plotCandidateFrame">plotCandidateFrame</a></code>, and <code><a href="#topic+plotBrightest">plotBrightest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#existing folder to save results (update this to an existing folder on your computer)
outputFolder = "scalpelResults"
#location on computer of raw data in R package to use
rawDataFolder = gsub("Y_1.rds", "", system.file("extdata", "Y_1.rds", package = "scalpel"))
#video height of raw data in R package
videoHeight = 30
#run SCALPEL pipeline
scalpelOutput = scalpel(outputFolder = outputFolder, rawDataFolder = rawDataFolder,
                       videoHeight = videoHeight)
#summarize each step
summary(scalpelOutput, step = 0)
summary(scalpelOutput, step = 1)
summary(scalpelOutput, step = 2)
summary(scalpelOutput, step = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='scalpel-package'>scalpel: A package for processing calcium imaging data.</h2><span id='topic+scalpel-package'></span>

<h3>Description</h3>

<p>This package is called scalpel for &quot;Segmentation, Clustering, and Lasso Penalties&quot;,
which is a method for processing neuronal calcium imaging data that identifies the locations of
neurons, and estimates their calcium concentrations over time.
The main function is <code><a href="#topic+scalpel">scalpel</a></code>, which runs the entire SCALPEL pipeline.
The pipeline involves several steps, each of which is described briefly in its corresponding
function. See <code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>,
<code><a href="#topic+scalpelStep3">scalpelStep3</a></code> for more details. Results can be summarized using <code><a href="#topic+summary">summary</a></code>
and the main plotting function is <code><a href="#topic+plotResults">plotResults</a></code>, which displays the estimated spatial and temporal components.
Full details for the SCALPEL method are provided in Petersen, Ashley; Simon, Noah; Witten, Daniela. 
SCALPEL: Extracting neurons from calcium imaging data. Ann. Appl. Stat. 12 (2018), no. 4, 2430&ndash;2456. 
doi:10.1214/18-AOAS1159. https://projecteuclid.org/euclid.aoas/1542078051
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

 #general example illustrating some of the main functions
 #see the vignette for additional direction on using all of the functions
 #and the help pages for the specific functions for details on using each function

 #existing folder to save results (update this to an existing folder on your computer)
 outputFolder = "scalpelResults"
 #location on computer of raw data in R package to use
 rawDataFolder = gsub("Y_1.rds", "", system.file("extdata", "Y_1.rds", package = "scalpel"))
 #video height of raw data in R package
 videoHeight = 30
 #run SCALPEL pipeline
 scalpelOutput = scalpel(outputFolder = outputFolder, rawDataFolder = rawDataFolder,
                         videoHeight = videoHeight)
 #summarize each step
 summary(scalpelOutput, step = 0)
 summary(scalpelOutput, step = 1)
 summary(scalpelOutput, step = 2)
 summary(scalpelOutput, step = 3)

 #plot the spatial and temporal components
 plotResults(scalpelOutput = scalpelOutput)
 #plot a summary of the video with the found neurons outlined
 plotVideoVariance(scalpelOutput = scalpelOutput, neuronSet = "Afilter")
 #plot the frames with the most fluorescence for each found neuron
 plotBrightest(scalpelOutput = scalpelOutput, AfilterIndex = 1)
 plotBrightest(scalpelOutput = scalpelOutput, AfilterIndex = 2)
 plotBrightest(scalpelOutput = scalpelOutput, AfilterIndex = 3)

 #if you want to use results from a previous session,
 #use "getScalpel" to read in previous results
 scalpelOutputCopy = getScalpel(outputFolder = outputFolder)


## End(Not run)

</code></pre>

<hr>
<h2 id='scalpelStep0'>Perform Step 0 of SCALPEL.</h2><span id='topic+scalpelStep0'></span>

<h3>Description</h3>

<p>This step involves data pre-processing. We read in the raw data version of Y and perform standard pre-processing
techniques in order to smooth the data both temporally and spatially, remove the bleaching effect,
and calculate a standardized fluorescence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalpelStep0(
  outputFolder,
  rawDataFolder,
  videoHeight,
  fileType = "R",
  processSeparately = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalpelStep0_+3A_outputfolder">outputFolder</code></td>
<td>
<p>The existing directory where the results should be saved.</p>
</td></tr>
<tr><td><code id="scalpelStep0_+3A_rawdatafolder">rawDataFolder</code></td>
<td>
<p>The directory where the raw data version of Y is saved. The data should be a
PxT matrix, where P is the total number of pixels per image frame and T
the number of frames of the video, for which the (i,j)th element contains the
fluorescence of the ith pixel in the jth frame. To create Y, you should
vectorize each 2-dimensional image frame by concatenating the columns of the image frame.  If the data is
saved in a single file, it should be named &quot;Y_1.mat&quot;, &quot;Y_1.rds&quot;, &quot;Y_1.txt&quot;, or &quot;Y_1.txt.gz&quot; (depending on <code>fileType</code>),
and if the data is split over multiple files, they should be split into chunks of the columns
and named consecutively (&quot;Y_1.mat&quot;, &quot;Y_2.mat&quot;, etc.; &quot;Y_1.rds&quot;, &quot;Y_2.rds&quot;, etc.; &quot;Y_1.txt&quot;, &quot;Y_2.txt&quot;, etc.; or &quot;Y_1.txt.gz&quot;, &quot;Y_2.txt.gz&quot;, etc.).</p>
</td></tr>
<tr><td><code id="scalpelStep0_+3A_videoheight">videoHeight</code></td>
<td>
<p>The height of the video (in pixels).</p>
</td></tr>
<tr><td><code id="scalpelStep0_+3A_filetype">fileType</code></td>
<td>
<p>Indicates whether raw data is an .rds (default value; <code>fileType="R"</code>), .mat (<code>fileType="matlab"</code>), .txt (<code>fileType="text"</code>), or
.txt.gz (<code>fileType="zippedText"</code>) file. Any text files should not have row or column names.</p>
</td></tr>
<tr><td><code id="scalpelStep0_+3A_processseparately">processSeparately</code></td>
<td>
<p>Logical scalar giving whether the multiple raw data files should be
processed individually, versus all at once. Processing the files separately may be preferable for larger videos.
The default value is <code>TRUE</code>; this argument is ignored if the raw data is saved in a single file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several files containing data from this step and a summary of the step are saved in &quot;outputFolder&quot;.
</p>


<h3>Value</h3>

<p>An object of class <code>scalpelStep0</code>, which can be summarized using <code><a href="#topic+summary">summary</a></code>, used to run SCALPEL Step 1 using <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>,
or can be used with the plotting functions <code><a href="#topic+plotFrame">plotFrame</a></code>, <code><a href="#topic+plotThresholdedFrame">plotThresholdedFrame</a></code>, and <code><a href="#topic+plotVideoVariance">plotVideoVariance</a></code>.
</p>

<ul>
<li><p><code>minRaw, maxRaw, minDeltaf, maxDeltaf</code>: Minimum and maximum values for the raw and processed videos.
</p>
</li>
<li><p><code>partsRaw, partsDeltaf</code>: Vectors indicating the indices of the raw and processed data files, respectively.
</p>
</li>
<li><p><code>nFramesRaw, nFramesDeltaf</code>: The number of frames in each part of the raw and processed data.
</p>
</li>
<li><p><code>lowThreshold, highThreshold</code>: The default lowest and highest threshold values for image segmentation that may be used in Step 1.
</p>
</li>
<li><p>Other elements: As specified by the user.
</p>
</li></ul>



<h3>See Also</h3>

<p>The entire SCALPEL pipeline can be implemented using the <code><a href="#topic+scalpel">scalpel</a></code> function. The
other steps in the pipeline can be run using the <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, <code><a href="#topic+scalpelStep3">scalpelStep3</a></code> functions.
Results from this step can be summarized using <code><a href="#topic+summary">summary</a></code>, loaded at a later time using <code><a href="#topic+getScalpelStep0">getScalpelStep0</a></code>, and plotted using
<code><a href="#topic+plotFrame">plotFrame</a></code>, <code><a href="#topic+plotThresholdedFrame">plotThresholdedFrame</a></code>, and <code><a href="#topic+plotVideoVariance">plotVideoVariance</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#existing folder to save results (update this to an existing folder on your computer)
outputFolder = "scalpelResultsStepByStep"
#location on computer of raw data in R package to use
rawDataFolder = gsub("Y_1.rds", "", system.file("extdata", "Y_1.rds", package = "scalpel"))
#video height of raw data in R package
videoHeight = 30
#run Step 0 of SCALPEL
Step0Out = scalpelStep0(outputFolder = outputFolder,
                       rawDataFolder = rawDataFolder, videoHeight = videoHeight)
summary(Step0Out)

## End(Not run)
</code></pre>

<hr>
<h2 id='scalpelStep1'>Perform Step 1 of SCALPEL.</h2><span id='topic+scalpelStep1'></span>

<h3>Description</h3>

<p>This step involves constructing a spatial component dictionary. We apply a simple image segmentation
procedure to each frame of the video in order to derive a dictionary of preliminary dictionary elements.
Ideally, this dictionary is a superset of the true spatial components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalpelStep1(
  step0Output,
  minSize = 25,
  maxSize = 500,
  maxWidth = 30,
  maxHeight = 30,
  thresholdVec = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalpelStep1_+3A_step0output">step0Output</code></td>
<td>
<p>An object of class <code>scalpel</code> or <code>scalpelStep0</code>, which result from running the
<code><a href="#topic+scalpel">scalpel</a></code> or <code><a href="#topic+scalpelStep0">scalpelStep0</a></code> functions, respectively.</p>
</td></tr>
<tr><td><code id="scalpelStep1_+3A_minsize">minSize</code>, <code id="scalpelStep1_+3A_maxsize">maxSize</code></td>
<td>
<p>The minimum and maximum size, respectively, for a preliminary dictionary element with default values
of 25 and 500, respectively.</p>
</td></tr>
<tr><td><code id="scalpelStep1_+3A_maxwidth">maxWidth</code>, <code id="scalpelStep1_+3A_maxheight">maxHeight</code></td>
<td>
<p>The maximum width and height, respectively, for a preliminary dictionary element with default values of 30.</p>
</td></tr>
<tr><td><code id="scalpelStep1_+3A_thresholdvec">thresholdVec</code></td>
<td>
<p>Optional advanced user argument: A vector with the desired thresholds to use for image segmentation. If not specified, the default is to
use the negative of the minimum of the processed Y data (i.e., <code>step0Output$highThreshold</code>), the negative of the 0.1% quantile of the processed Y data
(i.e., <code>step0Output$lowThreshold</code>), and the mean of these. These automatically chosen thresholds can also be updated using <code><a href="#topic+updateThreshold">updateThreshold</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several files containing data from this step and a summary of the step are saved in
&quot;outputFolder/Step1_version&quot; where <code>version</code> is a 5-digit unique identifier that is automatically generated.
</p>


<h3>Value</h3>

<p>An object of class <code>scalpelStep1</code>, which can be summarized using <code><a href="#topic+summary">summary</a></code>, used to run SCALPEL Step 2 using <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>,
or can be used with the plotting function <code><a href="#topic+plotCandidateFrame">plotCandidateFrame</a></code>.
</p>

<ul>
<li><p><code>Azero</code>: A matrix containing the preliminary dictionary elements, where the ith column of <code>Azero</code>
is a vector of 1's and 0's, indicating whether each pixel is contained in the ith preliminary dictionary element.
</p>
</li>
<li><p><code>AzeroFrames</code>: A vector whose ith element gives the video frame from which the preliminary dictionary element
in the ith column of <code>Azero</code> was derived.
</p>
</li>
<li><p><code>AzeroThreshold</code>: A vector whose ith element gives the threshold used to obtain the preliminary dictionary element
in the ith column of <code>Azero</code>.
</p>
</li>
<li><p><code>pixelsUse</code>: A vector with the pixels (i.e., indices of the rows of <code>Azero</code>) that are contained in at
least one preliminary dictionary element.
</p>
</li>
<li><p><code>version</code>: A 5-digit unique identifier for the output folder name that is automatically generated in this step.
</p>
</li>
<li><p>Other elements: As specified by the user or returned from a previous step.
</p>
</li></ul>



<h3>See Also</h3>

<p>The entire SCALPEL pipeline can be implemented using the <code><a href="#topic+scalpel">scalpel</a></code> function. The
other steps in the pipeline can be run using the <code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, <code><a href="#topic+scalpelStep3">scalpelStep3</a></code> functions.
Results from this step can be summarized using <code><a href="#topic+summary">summary</a></code>, loaded at a later time using <code><a href="#topic+getScalpelStep1">getScalpelStep1</a></code>, and plotted
using <code><a href="#topic+plotCandidateFrame">plotCandidateFrame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpelStep0" function

#run Step 1 of SCALPEL
Step1Out = scalpelStep1(step0Output = Step0Out)
summary(Step1Out)

## End(Not run)
</code></pre>

<hr>
<h2 id='scalpelStep2'>Perform Step 2 of SCALPEL.</h2><span id='topic+scalpelStep2'></span>

<h3>Description</h3>

<p>This step involves refinement of the spatial component dictionary from Step 1. We eliminate redundancy
in the spatial component dictionary by clustering together preliminary dictionary elements that represent
the same neuron, based on spatial and temporal information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalpelStep2(step1Output, cutoff = 0.18, omega = 0.2, maxSizeToCluster = 3000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalpelStep2_+3A_step1output">step1Output</code></td>
<td>
<p>An object of class <code>scalpel</code> or <code>scalpelStep1</code>, which result from running the
<code><a href="#topic+scalpel">scalpel</a></code> or <code><a href="#topic+scalpelStep1">scalpelStep1</a></code> functions, respectively.</p>
</td></tr>
<tr><td><code id="scalpelStep2_+3A_cutoff">cutoff</code></td>
<td>
<p>A value in [0,1] indicating where to cut the dendrogram that results from hierarchical clustering
of the preliminary dictionary elements. The default value is 0.18.</p>
</td></tr>
<tr><td><code id="scalpelStep2_+3A_omega">omega</code></td>
<td>
<p>A value in [0,1] indicating how to weight spatial vs. temporal information in the dissimilarity metric
used for clustering. If <code>omega=1</code>, only spatial information is used. The default value is 0.2.</p>
</td></tr>
<tr><td><code id="scalpelStep2_+3A_maxsizetocluster">maxSizeToCluster</code></td>
<td>
<p>Optional advanced user argument: The maximum number of preliminary dictionary elements to cluster at once. We attempt to cluster each
overlapping set of preliminary dictionary elements, but if one of these sets is very large (e.g., &gt;10,000), memory issues may
result. Thus we perform a two-stage clustering in which we first cluster together random sets of size
approximately equaling <code>maxSizeToCluster</code> and then cluster together the representatives from the first stage.
Finally, we recalculate the representatives using all of the preliminary dictionary elements in the final clusters. The default value is 3000.
If <code>maxSizeToCluster</code> is set to <code>NULL</code>, single-stage clustering is done, regardless of the size of the overlapping sets.
Memory issues may result when using this option to force single-stage clustering if the size of
the largest overlapping set of preliminary dictionary elements is very large (e.g., &gt;10,000).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several files containing data from this step and a summary of the step are saved in the folder
&quot;outputFolder/Step1_version/Step2_omega_omega_cutoff_cutoff&quot; where <code>version</code> is a 5-digit unique
identifier that is automatically generated in Step 1 and <code>omega</code> and <code>cutoff</code> are the user-supplied parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>scalpelStep2</code>, which can be summarized using <code><a href="#topic+summary">summary</a></code>, used to run SCALPEL Step 3 using <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>,
or can be used with the plotting functions <code><a href="#topic+plotCluster">plotCluster</a></code> and <code><a href="#topic+plotSpatial">plotSpatial</a></code>.
</p>

<ul>
<li><p><code>A</code>: A matrix containing the dictionary elements, where the ith column of <code>A</code>
is a vector of 1's and 0's, indicating whether each pixel is contained in the ith dictionary element.
</p>
</li>
<li><p><code>repComps</code>: A vector where the ith element indicates which preliminary dictionary element is the ith representive
component. That is, <code>A[,i]=step1Output$Azero[,repComps[i]]</code>.
</p>
</li>
<li><p><code>clusterID</code>: A vector whose ith element indicates which of the dictionary elements in <code>A</code> is the
representative for the ith preliminary dictionary element.
</p>
</li>
<li><p><code>overlapSetID</code>: A vector indicating which preliminary dictionary elements overlap, with the ith element
giving the group index for the ith preliminary dictionary element.
</p>
</li>
<li><p><code>treeList</code>: A list of length <code>max(overlapSetID)</code> with the ith element containing an object of class <code>protoclust</code> corresponding
to prototype clustering for the preliminary dictionary elements with <code>overlapSetID=i</code>. If two-stage clustering was done for a
particular set, then the element will be <code>NULL</code>.
</p>
</li>
<li><p>Other elements: As specified by the user or returned from a previous step.
</p>
</li></ul>



<h3>See Also</h3>

<p>The entire SCALPEL pipeline can be implemented using the <code><a href="#topic+scalpel">scalpel</a></code> function. The
other steps in the pipeline can be run using the <code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep3">scalpelStep3</a></code> functions.
Results from this step can be summarized using <code><a href="#topic+summary">summary</a></code>, loaded at a later time using <code><a href="#topic+getScalpelStep2">getScalpelStep2</a></code>, and plotted using
<code><a href="#topic+plotCluster">plotCluster</a></code> and <code><a href="#topic+plotSpatial">plotSpatial</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpelStep1" function

#run Step 2 of SCALPEL
Step2Out = scalpelStep2(step1Output = Step1Out)
summary(Step2Out)

## End(Not run)
</code></pre>

<hr>
<h2 id='scalpelStep3'>Perform Step 3 of SCALPEL.</h2><span id='topic+scalpelStep3'></span>

<h3>Description</h3>

<p>This step involves spatial component selection and temporal component estimation. We estimate the temporal
components corresponding to the dictionary elements from Step 2 by solving a sparse group lasso problem
with a non-negativity constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalpelStep3(
  step2Output,
  lambdaMethod = "trainval",
  lambda = NULL,
  minClusterSize = 1,
  alpha = 0.9,
  removeBorder = FALSE,
  excludeReps = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalpelStep3_+3A_step2output">step2Output</code></td>
<td>
<p>An object of class <code>scalpel</code> or <code>scalpelStep2</code>, which result from running the
<code><a href="#topic+scalpel">scalpel</a></code> or <code><a href="#topic+scalpelStep2">scalpelStep2</a></code> functions, respectively.</p>
</td></tr>
<tr><td><code id="scalpelStep3_+3A_lambdamethod">lambdaMethod</code></td>
<td>
<p>A description of how lambda should be chosen: either <code>"trainval"</code> (default),
<code>"distn"</code>, or <code>"user"</code>. A value of <code>"trainval"</code> means lambda will be chosen using a training/validation
set approach. A value of <code>"distn"</code> means lambda will be chosen as the negative of the 0.1% quantile
of elements of active pixels (i.e., those contained in at least one dictionary element) of Y.
Using <code>"distn"</code> is computationally faster than <code>"trainval"</code>. Alternatively with <code>"user"</code>,
the value of lambda can be directly specified using <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="scalpelStep3_+3A_lambda">lambda</code></td>
<td>
<p>The value of lambda to use when fitting the sparse group lasso. By default, the value is automatically
chosen using the approach specified by <code>lambdaMethod</code>. If a value is provided for <code>lambda</code>, then <code>lambdaMethod</code>
will be ignored.</p>
</td></tr>
<tr><td><code id="scalpelStep3_+3A_minclustersize">minClusterSize</code></td>
<td>
<p>The minimum number of preliminary dictionary elements that a cluster must contain in order to be included
in the sparse group lasso. The default value is 1 (i.e., all possible dictionary elements are included).</p>
</td></tr>
<tr><td><code id="scalpelStep3_+3A_alpha">alpha</code></td>
<td>
<p>The value of alpha to use when fitting the sparse group lasso. The default value is 0.9.</p>
</td></tr>
<tr><td><code id="scalpelStep3_+3A_removeborder">removeBorder</code></td>
<td>
<p>A logical scalar indicating whether the dictionary elements containing pixels in the 10-pixel
border of the video should be removed prior to fitting the sparse group lasso. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scalpelStep3_+3A_excludereps">excludeReps</code></td>
<td>
<p>A vector giving the indices of which dictionary elements to exclude, where the indices refer
to the columns of <code>step2Output$A</code>. The default value is <code>NULL</code> and no dictionary elements are excluded.
Users may also specify <code>"discarded"</code>, which will exclude all dictionary elements discarded
using a previous call to <code><a href="#topic+reviewNeurons">reviewNeurons</a></code> or <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To solve the sparse group lasso problem in this step, we minimize the following over <code>Z</code> with all non-negative elements:
</p>
<p><code>0.5*sum((Y - AfilterTilde %*% Z)^2) + lambda*alpha*sum(Z)</code> <br />
<code> + lambda*(1-alpha)*sum(sqrt(rowSums(Z^2)))</code>
</p>
<p>where <code>AfilterTilde</code> is a scaled version of <code>Afilter</code>.
</p>
<p>Several files containing data from this step and a summary of the step are saved in the folder
&quot;outputFolder/Step1_version/Step2_omega_omega_cutoff_cutoff/Step3_lambdaMethod_lambdaMethod_
minClusterSize_minClusterSize_alpha_alpha_removeBorder_removeBorder&quot; where <code>version</code> is a 5-digit unique
identifier that is automatically generated in Step 1, <code>omega</code> and <code>cutoff</code> are the user-supplied parameters
from Step 2, and <code>lambdaMethod</code>, <code>minClusterSize</code>, <code>alpha</code>, and <code>removeBorder</code> are
the user-supplied parameters from this step. If dictionary elements were manually excluded using <code>excludeReps</code>,
this is appended to the folder name.
</p>


<h3>Value</h3>

<p>An object of class <code>scalpelStep3</code>, which can be summarized using <code><a href="#topic+summary">summary</a></code> and used with the plotting functions
<code><a href="#topic+plotResults">plotResults</a></code>, <code><a href="#topic+plotResultsAllLambda">plotResultsAllLambda</a></code>, <code><a href="#topic+plotSpatial">plotSpatial</a></code>, <code><a href="#topic+plotTemporal">plotTemporal</a></code>, and <code><a href="#topic+plotBrightest">plotBrightest</a></code>.
</p>

<ul>
<li><p><code>Afilter</code>: A matrix containing the filtered dictionary elements, where the ith column of <code>Afilter</code>
is a vector of 1's and 0's, indicating whether each pixel is contained in the ith filtered dictionary element.
Note that <code>Afilter</code> is equivalent to <code>A</code> after removing the components excluded due to being on the border
(if <code>removeBorder=TRUE</code>) or having fewer preliminary dictionary elements in their cluster than <code>minClusterSize</code>.
</p>
</li>
<li><p><code>Zhat</code>: A matrix containing the estimated temporal components, where the ith row of <code>Zhat</code>
is the estimated calcium trace corresponding to the ith spatial component (i.e., the ith column of <code>Afilter</code>).
</p>
</li>
<li><p><code>lambda</code>: The value of lambda used in fitting the sparse group lasso.
</p>
</li>
<li><p><code>ZhatList</code>: A list of matrices containing the estimated temporal components for alternative values of <code>lambda</code>
specified in <code>lambdaSeq</code>. These can be plotted using <code><a href="#topic+plotResultsAllLambda">plotResultsAllLambda</a></code>.
</p>
</li>
<li><p><code>lambdaSeq</code>: A vector with length equaling the length of <code>ZhatList</code>, where the ith element indicates the value of lambda
corresponding to the temporal components in <code>ZhatList[[i]]</code>.
</p>
</li>
<li><p><code>clustersUse</code>: A vector with length equaling the number of columns of <code>Afilter</code>, where the ith element indicates which column of
<code>step2Output$A</code> the ith column of <code>Afilter</code> equals.
</p>
</li>
<li><p>Other elements: As specified by the user or returned from a previous step.
</p>
</li></ul>



<h3>See Also</h3>

<p>The entire SCALPEL pipeline can be implemented using the <code><a href="#topic+scalpel">scalpel</a></code> function. The
other steps in the pipeline can be run using the <code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code> functions.
Results from this step can be summarized using <code><a href="#topic+summary">summary</a></code>, loaded at a later time using <code><a href="#topic+getScalpelStep3">getScalpelStep3</a></code>, and plotted using
<code><a href="#topic+plotSpatial">plotSpatial</a></code>, <code><a href="#topic+plotTemporal">plotTemporal</a></code>, <code><a href="#topic+plotResults">plotResults</a></code>, and <code><a href="#topic+plotBrightest">plotBrightest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpelStep2" function

#run Step 3 of SCALPEL
Step3Out = scalpelStep3(step2Output = Step2Out)
summary(Step3Out)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary'>Summarize results from SCALPEL pipeline.</h2><span id='topic+summary'></span><span id='topic+summary.scalpelStep0'></span><span id='topic+summary.scalpelStep1'></span><span id='topic+summary.scalpelStep2'></span><span id='topic+summary.scalpelStep3'></span><span id='topic+summary.scalpel'></span>

<h3>Description</h3>

<p>Prints the parameters used and a summary of results for a specified step of SCALPEL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scalpelStep0'
summary(object, ...)

## S3 method for class 'scalpelStep1'
summary(object, ...)

## S3 method for class 'scalpelStep2'
summary(object, ...)

## S3 method for class 'scalpelStep3'
summary(object, ...)

## S3 method for class 'scalpel'
summary(object, step, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep0">scalpelStep0</a></code>, <code><a href="#topic+scalpelStep1">scalpelStep1</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed, which are ignored in this function.</p>
</td></tr>
<tr><td><code id="summary_+3A_step">step</code></td>
<td>
<p>The SCALPEL step (0, 1, 2, or 3) that you wish to summarize. This is only needed if summarizing an object of class <code>scalpel</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the examples for the "scalpelStep0" and "scalpel" functions
summary(Step0Out)
 #summarize each step
 summary(scalpelOutput, step = 0)
 summary(scalpelOutput, step = 1)
 summary(scalpelOutput, step = 2)
 summary(scalpelOutput, step = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='updateNeurons'>Update the classifications of neurons from SCALPEL.</h2><span id='topic+updateNeurons'></span>

<h3>Description</h3>

<p>This function allows the user to update the classifications of neurons, based on manual sorting of
plots saved as a result of running <code><a href="#topic+reviewNeurons">reviewNeurons</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateNeurons(scalpelOutput, neuronSet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateNeurons_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="updateNeurons_+3A_neuronset">neuronSet</code></td>
<td>
<p>The set of neurons that should be reviewed:
use <code>"A"</code> for those resulting from <code><a href="#topic+scalpelStep2">scalpelStep2</a></code> and saved as <code>scalpelOutput$A</code>, or use <code>"Afilter"</code> for those resulting from
<code><a href="#topic+scalpelStep3">scalpelStep3</a></code> and saved as <code>scalpelOutput$Afilter</code>. This argument is ignored if the class of <code>scalpelOutput</code> is <code>scalpelStep2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reviewNeurons">reviewNeurons</a></code>, <code><a href="#topic+reviewNeuronsMoreFrames">reviewNeuronsMoreFrames</a></code>, <code><a href="#topic+reviewOverlappingNeurons">reviewOverlappingNeurons</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "reviewNeurons" function

updateNeurons(scalpelOutput = scalpelOutput, neuronSet = "Afilter")

## End(Not run)
</code></pre>

<hr>
<h2 id='updateNeuronsInteractive'>Update the classifications of specified neurons from SCALPEL.</h2><span id='topic+updateNeuronsInteractive'></span>

<h3>Description</h3>

<p>This function allows the user to update the classifications of neurons, which
were reviewed previously using <code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code>. Typically, this function
is used after running <code><a href="#topic+reviewNeuronsMoreFrames">reviewNeuronsMoreFrames</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateNeuronsInteractive(scalpelOutput, neuronSet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateNeuronsInteractive_+3A_scalpeloutput">scalpelOutput</code></td>
<td>
<p>An object returned by one of the SCALPEL functions:
<code><a href="#topic+scalpel">scalpel</a></code>, <code><a href="#topic+scalpelStep2">scalpelStep2</a></code>, or <code><a href="#topic+scalpelStep3">scalpelStep3</a></code>.</p>
</td></tr>
<tr><td><code id="updateNeuronsInteractive_+3A_neuronset">neuronSet</code></td>
<td>
<p>The set of neurons that should be reviewed:
use <code>"A"</code> for those resulting from <code><a href="#topic+scalpelStep2">scalpelStep2</a></code> and saved as <code>scalpelOutput$A</code>, or use <code>"Afilter"</code> for those resulting from
<code><a href="#topic+scalpelStep3">scalpelStep3</a></code> and saved as <code>scalpelOutput$Afilter</code>. This argument is ignored if the class of <code>scalpelOutput</code> is <code>scalpelStep2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reviewNeuronsInteractive">reviewNeuronsInteractive</a></code>, <code><a href="#topic+reviewNeuronsMoreFrames">reviewNeuronsMoreFrames</a></code>, <code><a href="#topic+reviewOverlappingNeurons">reviewOverlappingNeurons</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "reviewNeuronsInteractive" function

updateNeuronsInteractive(scalpelOutput = scalpelOutput, neuronSet = "A")
#you will be prompted for the changes you wish to make

## End(Not run)
</code></pre>

<hr>
<h2 id='updateThreshold'>Review and update the chosen threshold for image segmentation in Step 1 of SCALPEL.</h2><span id='topic+updateThreshold'></span>

<h3>Description</h3>

<p>We plot random frames from the video processed in Step 0 of SCALPEL with shading to indicate the
smallest of the automatically chosen thresholds that will be used to perform image segmentation in
Step 1 of SCALPEL. The user is given the option to try out different thresholds and if desired, update
the threshold to use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateThreshold(step0Output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateThreshold_+3A_step0output">step0Output</code></td>
<td>
<p>An object of class <code>scalpel</code> or <code>scalpelStep0</code>, which result from running the
<code><a href="#topic+scalpel">scalpel</a></code> or <code><a href="#topic+scalpelStep0">scalpelStep0</a></code> functions, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object identical to <code>step0Output</code>, except it may (depending on the user's decision) have <code>lowThreshold</code> updated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalpelStep0">scalpelStep0</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### many of the functions in this package are interconnected so the
### easiest way to learn to use the package is by working through the vignette,
### which is available at ajpete.com/software

#assumes you have run the example for the "scalpel" function

#update the smallest threshold used for image segmentation in Step 1
scalpelOutput = updateThreshold(step0Output = scalpelOutput)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
