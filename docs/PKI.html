<!DOCTYPE html><html><head><title>Help for package PKI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PKI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ASN1'>
<p>Functions for handling ASN.1 format (typically DER)</p></a></li>
<li><a href='#BIGNUMint'>
<p>Functions for BIGNUM representation of arbitrarily precise integers</p></a></li>
<li><a href='#oid'>
<p>OBJECT IDENTIFIER Functions</p></a></li>
<li><a href='#PKI.crypt'>
<p>PKI encryption/decryption functions</p></a></li>
<li><a href='#PKI.digest'>
<p>Compute digest sum based on SHA1, SHA256 or MD5 hash functions</p></a></li>
<li><a href='#PKI.info'>
<p>Retrieve PKI back-end information</p></a></li>
<li><a href='#PKI.random'>
<p>Generate cryptographically strong pseudo-random bytes.</p></a></li>
<li><a href='#PKI.sign'>
<p>PKI: sign content or verify a signature</p></a></li>
<li><a href='#PKI.sign.tar'>
<p>Functions for signing and verification of tar files</p></a></li>
<li><a href='#raw2hex'>
<p>Convert raw vector to string hex representation</p></a></li>
<li><a href='#RSA'>
<p>PKI functions handling RSA keys</p></a></li>
<li><a href='#X509'>
<p>Public Key Instraftructure (X509) functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Public Key Infrastucture for R Based on the X.509 Standard</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Urbanek &lt;Simon.Urbanek@r-project.org&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Urbanek &lt;Simon.Urbanek@r-project.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.9.0), base64enc</td>
</tr>
<tr>
<td>Enhances:</td>
<td>gmp</td>
</tr>
<tr>
<td>Description:</td>
<td>Public Key Infrastucture functions such as verifying certificates, RSA encription and signing which can be used to build PKI infrastructure and perform cryptographic tasks.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.rforge.net/PKI">http://www.rforge.net/PKI</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>OpenSSL library and headers (openssl-dev or
similar)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-27 21:31:15 UTC; rforge</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-28 07:32:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ASN1'>
Functions for handling ASN.1 format (typically DER)
</h2><span id='topic+ASN1'></span><span id='topic+ASN1.decode'></span><span id='topic+ASN1.encode'></span><span id='topic+ASN1.item'></span><span id='topic+ASN1.type'></span>

<h3>Description</h3>

<p><code>ASN1.decode</code> decodes <code>ASN.1</code> binary format into
raw format chunks tagged with class types.
</p>
<p><code>ASN1.encode</code> converts structured objects into
<code>ASN.1</code> binary format.
</p>
<p><code>ASN1.item</code> creates an item - basic object in
structures that can be encoded using <code>ASN1.encode</code>.
</p>
<p><code>ASN1.type</code> extracts the class type from an
<code>ASN.1</code> item
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASN1.decode(what)
ASN1.encode(what)
ASN1.item(what, type)
ASN1.type(what)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ASN1_+3A_what">what</code></td>
<td>
<p>object to decode/encode/query</p>
</td></tr>
<tr><td><code id="ASN1_+3A_type">type</code></td>
<td>
<p>class type of the item (integer value)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a suite of low-level tools to deal with ASN.1 (Abstract Syntax
Notation One) binary formats DER, BER and CER. The tools were written
specifically to handle the various DER-encoded key structures so it
provides only a subset of the ASN.1 specification. They are used
internally by the <code>PKI</code> poackage.
</p>
<p><code>ASN1.decode</code> decodes the binary representation (as raw vector)
into individual items. Sequences are convered into lists, all other
objects are retained in their binary form and tagged with the integer
class type - which can be obtained using <code>ASN1.type</code> function.
</p>
<p><code>ASN1.encode</code> expects item (or a list of items) either created
using <code>ASN1.decode</code> or <code>ASN1.item</code> and converts them into
<code>DER</code> binary format.
</p>
<p>The result of <code>ASN1.encode(ASN1.decode(x))</code> will be <code>x</code> if
<code>x</code> was in <code>DER</code> format.
</p>


<h3>Value</h3>

<p><code>ASN1.decode</code> returns either one item or a list.
</p>
<p><code>ASN1.encode</code> returns a raw vector in DER format.
</p>
<p><code>ASN1.type</code> returns an integer class type
</p>
<p><code>ASN1.item</code> returns an ASN.1 item object
</p>


<h3>Note</h3>

<p><code>ASN1.encode</code> uses a fixed buffer for encoding which currently
limits the total size of the resulting structure to 1MB.
</p>
<p>Only definite length forms are supported. The validity of individual
items is not checked.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a small key
key &lt;- PKI.genRSAkey(bits = 512L)

# extract private and public parts in DER format
prv &lt;- PKI.save.key(key, format="DER")
pub &lt;- PKI.save.key(key, private=FALSE, format="DER")

# parse the public key
x &lt;- ASN1.decode(pub)
x
# the second element is the actual key
# as a bit string that's itself in DER
# two integers - modulus and exponent
# Note that this is in fact the pure PKCS#1 key format
ASN1.decode(x[[2]])

# encoding it back should yield the same representation since it is DER
stopifnot(identical(ASN1.encode(x), as.raw(pub)))

</code></pre>

<hr>
<h2 id='BIGNUMint'>
Functions for BIGNUM representation of arbitrarily precise integers
</h2><span id='topic+BIGNUMint'></span><span id='topic+as.BIGNUMint'></span>

<h3>Description</h3>

<p><code>as.BIGNUMint</code> encodes integer in BIGNUM format as raw vector as
used by ASN.1 format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.BIGNUMint(what, scalar = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIGNUMint_+3A_what">what</code></td>
<td>
<p>representation of an integer or a vector
thereof. Currently supported formats include <code>"bigz"</code> objects
from the <code>"gmp"</code> package, integers and reals.
</p>
</td></tr>
<tr><td><code id="BIGNUMint_+3A_scalar">scalar</code></td>
<td>
<p>if <code>TRUE</code> then the input is expected to be scalar
and only the first element will be used (zero-length vectors raise
an error). Otherwise the result will be a list of all converted
elements.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BIGNUM representation as used in ASN.1 is a big-endian encoding of
variable length stored in a raw vector. Negative numbers are stored in
two-complement's encoding, but are currently unsupported by
<code>as.BIGNUMint</code>.
</p>


<h3>Value</h3>

<p>Raw vector in BIGNUM integer representation.
</p>


<h3>Note</h3>

<p>Unless the input is of class <code>"bigz"</code> then 32-bit platforms only
support integers up to 32-bit, 64-bit platforms up to 53-bit (when
real vectors are used).
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.BIGNUMint(65537)
</code></pre>

<hr>
<h2 id='oid'>
OBJECT IDENTIFIER Functions
</h2><span id='topic+oid'></span><span id='topic+as.oid'></span><span id='topic+as.oid.default'></span><span id='topic+as.oid.integer'></span><span id='topic+as.character.oid'></span><span id='topic+as.integer.oid'></span><span id='topic+is.oid'></span><span id='topic+Ops.oid'></span><span id='topic+print.oid'></span>

<h3>Description</h3>

<p>Object Identifiers (OIDs) are entities defined by international
standards (ITU-T, ISO, IEC) used to identify objects. In the PKI
context they are used for example to identify encyrption algorithms.
Each root (first integer - see below) denotes the standards body
governing the allocations.
</p>
<p>OIDs consist of a hierarchy of integers with each component having a
meaning in the hierarchy. For example, the OID of the DER encoding is
defined in the ITU-T X.680 standard as
<code>joint-iso-itu-t(2) asn1(1) ber-derived(2) distinguished-encoding(1)</code>
where the text before each integer describes its meaning in that
context and the integer is the encoding of that meaning. So the OID
itself would be in character form <code>"2.1.2.1"</code> (also called the dot
notation introduced by IETF) and in R integer form
<code>c(2, 1, 2, 1)</code>. Internally, OIDs are represented in their ASN.1
encoding as raw vectors which is the way they are typically used
in files or communication payload.
</p>
<p>The following functions are used to operate on OIDs.
</p>
<p><code>oid</code> creates an OID.
</p>
<p>Coercion methods <code>as.integer</code> and <code>as.character</code> convert the
OID into its numeric and textural form respectively. <code>as.oid</code> is
a generic for convering objects into OIDs and is implemented for at
least the above cases.
</p>
<p><code>is.oid</code> returns <code>TRUE</code> if the object is an OID.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oid(x)

as.oid(x, ...) 
## Default S3 method:
as.oid(x, ...)
is.oid(x) 

## S3 method for class 'oid'
Ops(e1, e2) 
## S3 method for class 'oid'
print(x, ...) 

## S3 method for class 'oid'
as.character(x, ...) 
## S3 method for class 'oid'
as.integer(x, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oid_+3A_x">x</code></td>
<td>
<p>object to covert/create/check</p>
</td></tr>
<tr><td><code id="oid_+3A_e1">e1</code></td>
<td>
<p>left-hand side argument for binary operators</p>
</td></tr>
<tr><td><code id="oid_+3A_e2">e2</code></td>
<td>
<p>right-hand side arguemnt for binary operators</p>
</td></tr>
<tr><td><code id="oid_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only allowed oparators on OIDs are <code>==</code> and <code>!=</code> which
return <code>TRUE</code> or <code>FALSE</code>.
</p>
<p>The <code>oid(x)</code> constructor (and also the <code>as.oid</code> default
method) support following types: scalar string (expected to be in
dot-notation), integer vector, numeric vector (it is coerced to integer
vector implicitly), raw vector (must be ASN.1 encoding of the OID).
</p>
<p>The S3 class of OID objects is <code>"oid"</code>. It consists of a raw
vector repesenting the ASN.1 encoded OID (without the type
specifier). An additional attribute <code>"type"</code> is set to <code>6L</code>
for compatiblity with <code><a href="#topic+ASN1.encode">ASN1.encode</a></code>.  
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ASN1.encode">ASN1.encode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## RSA algorithm OID:
## iso(1) member-body(2) us(840) rsadsi(113549)
## pkcs(1) pkcs-1(1) rsaEncryption(1)
o &lt;- oid("1.2.840.113549.1.1.1")
as.raw(o)
as.integer(o)
as.character(o)
as.oid(as.integer(o)) == o
is.oid(o)
(a &lt;- ASN1.encode(o))
as.oid(ASN1.decode(a)) == o
</code></pre>

<hr>
<h2 id='PKI.crypt'>
PKI encryption/decryption functions
</h2><span id='topic+PKI.crypt'></span><span id='topic+PKI.encrypt'></span><span id='topic+PKI.decrypt'></span>

<h3>Description</h3>

<p><code>PKI.encrypt</code> encrypts a raw vector
</p>
<p><code>PKI.decrypt</code> decrypts a raw vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKI.encrypt(what, key, cipher = NULL, iv = NULL)
PKI.decrypt(what, key, cipher = NULL, iv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PKI.crypt_+3A_what">what</code></td>
<td>
<p>raw vector to encrypt/decrypt. It must not exceed the key
size minus padding</p>
</td></tr>
<tr><td><code id="PKI.crypt_+3A_key">key</code></td>
<td>
<p>key to use for encryption/decryption</p>
</td></tr>
<tr><td><code id="PKI.crypt_+3A_cipher">cipher</code></td>
<td>
<p>cipher to use for encryption/decryption</p>
</td></tr>
<tr><td><code id="PKI.crypt_+3A_iv">iv</code></td>
<td>
<p>initialization vector for ciphers that use it (e.g.,
CBC). <code>NULL</code> corresponds to all-zeroes IV, otherwise must be
either a string or a raw vector with sufficiently many bytes to
match the IV length for the cipher.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raw vector (encrypted/decrypted)
</p>


<h3>Note</h3>

<p>The cipher is optional for key objects that already contain the
cipher information such as RSA keys (in fact it is ignored in that
case).
</p>
<p>Supported symmetric ciphers are AES-128, AES-256 and BF
(blowfish). Each cipher can be used in CBC (default), ECB or OFB
modes which are specified as suffix, so <code>"aes256ofb"</code> would
specify AES-256 in OFB mode. Case and non-alphanumeric characters are
ignored, so the same could be specified as <code>"AES-256-OFB"</code>.
PKCS padding is used to fill up to the block size. Analogously, PKCS
padding is expected when decoding.
</p>
<p>Note that the payload for RSA encryption should be very small since
it must fit into the key size including padding. For example, 1024-bit
key can only encrypt 87 bytes, while 2048-bit key can encrypt 215
bytes. Therefore a typical use is to use RSA to transfer a symmeric
key to the peer and subsequently use symmetric ciphers like AES for
encryption of larger amounts of data.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PKI.genRSAkey">PKI.genRSAkey</a></code>, <code><a href="#topic+PKI.pubkey">PKI.pubkey</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  key &lt;- PKI.genRSAkey(2048)
  x &lt;- charToRaw("Hello, world!")
  e &lt;- PKI.encrypt(x, key)
  y &lt;- PKI.decrypt(e, key)
  stopifnot(identical(x, y))
  print(rawToChar(y))

  ## AES symmetric - use SHA256 to support arbitrarily long key strings
  key &lt;- PKI.digest(charToRaw("hello"), "SHA256")
  ae &lt;- PKI.encrypt(x, key, "aes256")
  ae
  ad &lt;- PKI.decrypt(ae, key, "aes256")
  stopifnot(identical(x, ad))
</code></pre>

<hr>
<h2 id='PKI.digest'>
Compute digest sum based on SHA1, SHA256 or MD5 hash functions
</h2><span id='topic+PKI.digest'></span>

<h3>Description</h3>

<p><code>PKI.digest</code> computes digsest sum based on the hash function
specified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKI.digest(what, hash = c("SHA1", "SHA256", "MD5"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PKI.digest_+3A_what">what</code></td>
<td>
<p>raw vector of bytes to digest</p>
</td></tr>
<tr><td><code id="PKI.digest_+3A_hash">hash</code></td>
<td>
<p>type of the hash function. Note that &quot;MD5&quot; should
<em>not</em> be used for cryptographic purposes as it is not secure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raw vector containg the hash
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PKI.sign">PKI.sign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  PKI.digest(as.raw(1:10))
</code></pre>

<hr>
<h2 id='PKI.info'>
Retrieve PKI back-end information
</h2><span id='topic+PKI.info'></span>

<h3>Description</h3>

<p><code>PKI.info</code> returns information about the engine which is
providing the PKI functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKI.info()
</code></pre>


<h3>Value</h3>

<p>Named list:
</p>
<table>
<tr><td><code>engine</code></td>
<td>
<p>string, name of the engine, currently either
<code>"openssl"</code> or <code>"libressl"</code></p>
</td></tr>
<tr><td><code>version</code></td>
<td>
<p>numeric, version of the engine as a real number in the
form <code>major.minor</code></p>
</td></tr>
<tr><td><code>description</code></td>
<td>
<p>string, description of the engine, its version and
any futher information that the engine may provide</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function should be treated as informational only. The return
value is subject to change, mainly we may extend it to possibly supply
information on available ciphers etc.
</p>
<p>Older versions of OpenSSL did not provide functional API to retrieve
version inforation, so versions &lt; 1.1 may not reflect the true version,
but rather the values from the headers at compile time which may not
be the same as the loaded library at run-time.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(PKI.info())
</code></pre>

<hr>
<h2 id='PKI.random'>
Generate cryptographically strong pseudo-random bytes.
</h2><span id='topic+PKI.random'></span>

<h3>Description</h3>

<p><code>PKI.random</code> generates <code>n</code> cryptographically strong
pseudo-random bytes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKI.random(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PKI.random_+3A_n">n</code></td>
<td>
<p>non-negative integer, number of bytes to generate</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PKI.random</code> is the preferred way to generate cryptographically
strong random content that can be used as keys, seeds etc. Not to be
confused with random number generators in R, it is entirely separate
for cryptographics purposes.
</p>


<h3>Value</h3>

<p>Raw vector of <code>n</code> cryptographically strong pseudo-random bytes.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  PKI.random(10)
</code></pre>

<hr>
<h2 id='PKI.sign'>
PKI: sign content or verify a signature
</h2><span id='topic+PKI.sign'></span><span id='topic+PKI.verify'></span>

<h3>Description</h3>

<p><code>PKI.sign</code> signs content using RSA with the specified hash function
</p>
<p><code>PKI.verify</code> verifies a signature of RSA-signed content
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKI.sign(what, key, hash = c("SHA1", "SHA256", "MD5"), digest)
PKI.verify(what, signature, key, hash = c("SHA1", "SHA256", "MD5"), digest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PKI.sign_+3A_what">what</code></td>
<td>
<p>raw vector: content to sign</p>
</td></tr>
<tr><td><code id="PKI.sign_+3A_key">key</code></td>
<td>
<p>RSA private key to use for signing; RSA public key or
certificate to use for verification.</p>
</td></tr>
<tr><td><code id="PKI.sign_+3A_hash">hash</code></td>
<td>
<p>hash function to use. &quot;MD5&quot; should not be used unless
absolutely needed for compatibility as it is less secure.</p>
</td></tr>
<tr><td><code id="PKI.sign_+3A_digest">digest</code></td>
<td>
<p>raw vector: it is possible to supply the digest of
the content directly instead of specifying <code>what</code>.</p>
</td></tr>
<tr><td><code id="PKI.sign_+3A_signature">signature</code></td>
<td>
<p>raw vector: signature</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects are signed by computing a hash function digest (typically
using <code>SHA1</code> hash function) and then signing the digest with a
RSA key. Verification is done by computing the digest and then
comparing the signature to the digest. Private key is needed for
signing whereas public key is needed for verification.
</p>
<p>Both functions call <code><a href="#topic+PKI.digest">PKI.digest</a></code> on <code>what</code> if
<code>digest</code> is not specified.
</p>


<h3>Value</h3>

<p><code>PKI.sign</code> signature (raw vector)
</p>
<p><code>PKI.verify</code> logical: <code>TRUE</code> if the digest and signature
match, <code>FALSE</code> otherwise
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PKI.pubkey">PKI.pubkey</a></code>, <code><a href="#topic+PKI.genRSAkey">PKI.genRSAkey</a></code>,
<code><a href="#topic+PKI.digest">PKI.digest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  key &lt;- PKI.genRSAkey(2048)
  x &lt;- charToRaw("My message to sign")
  sig &lt;- PKI.sign(x, key)
  stopifnot(PKI.verify(x, sig, key))
</code></pre>

<hr>
<h2 id='PKI.sign.tar'>
Functions for signing and verification of tar files
</h2><span id='topic+PKI.sign.tar'></span><span id='topic+PKI.verify.tar'></span>

<h3>Description</h3>

<p><code>PKI.sign.tar</code> appends a signature to a tar file
</p>
<p><code>PKI.verify.tar</code> verifies the signature in a tar file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKI.sign.tar(tarfile, key, certificate, output = tarfile)
PKI.verify.tar(tarfile, key, silent = FALSE, enforce.cert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PKI.sign.tar_+3A_tarfile">tarfile</code></td>
<td>
<p>string, file name of the file to sign</p>
</td></tr>
<tr><td><code id="PKI.sign.tar_+3A_key">key</code></td>
<td>
<p><code>PKI.sign.tar</code>: private key to use for signing;
<code>PKI.verify.tar</code>: optional, public key to use for verification</p>
</td></tr>
<tr><td><code id="PKI.sign.tar_+3A_certificate">certificate</code></td>
<td>
<p>optional, certificate to embed in the signature
with the public key matching <code>key</code>. If not present the
signature will only contain the public key.</p>
</td></tr>
<tr><td><code id="PKI.sign.tar_+3A_output">output</code></td>
<td>
<p>file name, connection or raw vector determining how to
store the signed tar file</p>
</td></tr>
<tr><td><code id="PKI.sign.tar_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> then no warning are generatod, otherwise
a warning is issues for failed verification describing the reason
for failure</p>
</td></tr>
<tr><td><code id="PKI.sign.tar_+3A_enforce.cert">enforce.cert</code></td>
<td>
<p>if <code>TRUE</code> then a certificate is required in
the signature. It can be also set to a valid certificate in which
case the public key of the certificate in the signature must also
match the public key in the supplied certificate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PKI.tar.sign</code> adds extra entry <code>.signature</code> with the
signature based on the contents of the <code>tarfile</code>. Note that
any existing signatures are retained. <code>key</code> is a mandatory
private key used to sign the content. <code>certificate</code> is optional
but if present, it will be embedded in the signature.
</p>
<p>The <code>tarfile</code> can be in compressed form (gzip, bzip2 or xz) in
which case it is decompressed internally before the signature is
applied. If <code>output</code> is a file name then the same compression is
applied to the output, otherwise the output is uncompressed.
</p>
<p><code>PKI.verify.tar</code> retrieves the last <code>.signature</code> entry from
the tar file (if <code>tarfile</code> is a file name then the same
compression auto-detection is applied as above) and
verifies the signature against either the supplied (public) <code>key</code>
or against the key or certificate stored in the signature. The result
is <code>TRUE</code> or <code>FALSE</code> except when <code>enforce.cert</code> is
set. In that case the result is the certificate contained in the
signature if the validation succeeded (and thus it can be further
verified against a chain of trust), otherwise <code>FALSE</code>.
</p>


<h3>Note</h3>

<p>The signature format is ASN.1 DER encoded as follows:
</p>
<p><code>SEQ(signature BITSTRING, subjectPublicKeyInfo, Certificate[opt])</code>
</p>
<p>The <code>subjectPublicKeyInfo</code> can be <code>NULL</code> in which case the
certificate must be present (in X.509 DER format).
</p>
<p>The signature is appended as tar entry named
<code>.signature</code>. However, terminating blocks are not removed from
the file, so the signature is placed after the EOF blocks and thus
doesn't affect extraction.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>

<hr>
<h2 id='raw2hex'>
Convert raw vector to string hex representation
</h2><span id='topic+raw2hex'></span>

<h3>Description</h3>

<p><code>raw2hex</code> convers a raw vector into hexadecimal representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw2hex(what, sep, upper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw2hex_+3A_what">what</code></td>
<td>
<p>raw vector</p>
</td></tr>
<tr><td><code id="raw2hex_+3A_sep">sep</code></td>
<td>
<p>optional separator string</p>
</td></tr>
<tr><td><code id="raw2hex_+3A_upper">upper</code></td>
<td>
<p>logical, if <code>TRUE</code> then upper case letters are used,
otherwise any letters will be lower case.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>sep</code> is omitted or <code>NULL</code> then the resulting character
vector will have as many elements as the raw vector. Otherwise the
elements are concatenated using the specified separator into one
character string. This is much more efficient than using
<code>paste(raw2hex(x), collapse=sep)</code>, but has the same effect.
</p>


<h3>Value</h3>

<p>Character vector with the hexadecimal representation of the raw vector.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raw2hex(PKI.digest(raw(), "SHA1"), "")
raw2hex(PKI.digest(raw(), "MD5"), ":")

## this is jsut a performance comparison and a test that
## raw2hex can handle long strings
x &lt;- as.raw(runif(1e5) * 255.9)
system.time(h1 &lt;- raw2hex(x, " "))
system.time(h2 &lt;- paste(raw2hex(x), collapse=" "))
stopifnot(identical(h1, h2))
</code></pre>

<hr>
<h2 id='RSA'>
PKI functions handling RSA keys 
</h2><span id='topic+RSA'></span><span id='topic+PKI.genRSAkey'></span><span id='topic+PKI.load.key'></span><span id='topic+PKI.save.key'></span><span id='topic+PKI.mkRSApubkey'></span><span id='topic+PKI.load.OpenSSH.pubkey'></span>

<h3>Description</h3>

<p><code>PKI.load.key</code> loads an RSA key in PKCS#1/8 PEM or DER format.
</p>
<p><code>PKI.save.key</code> creates a PEM or DER representation of a RSA key.
</p>
<p><code>PKI.genRSAkey</code> generates RSA public/private key pair.
</p>
<p><code>PKI.mkRSApubkey</code> creates a RSA public key with the supplied
modulus and exponent.
</p>
<p><code>PKI.load.OpenSSH.pubkey</code> loads public key in OpenSSH format
(as used in <code>.ssh/authorized_keys</code> file)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKI.load.key(what, format = c("PEM", "DER"), private, file, password="")
PKI.save.key(key, format = c("PEM", "DER"), private, target)
PKI.genRSAkey(bits = 2048L)
PKI.mkRSApubkey(modulus, exponent=65537L, format = c("DER", "PEM", "key"))
PKI.load.OpenSSH.pubkey(what, first=TRUE, format = c("DER", "PEM", "key"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RSA_+3A_what">what</code></td>
<td>
<p>string, raw vector or connection to load the key from</p>
</td></tr>
<tr><td><code id="RSA_+3A_key">key</code></td>
<td>
<p>RSA key object</p>
</td></tr>
<tr><td><code id="RSA_+3A_format">format</code></td>
<td>
<p>format - PEM is ASCII (essentially base64-encoded DER
with header/footer), DER is binary and key means an acutal key object</p>
</td></tr>
<tr><td><code id="RSA_+3A_private">private</code></td>
<td>
<p>logical, whether to use the private key (<code>TRUE</code>),
public key (<code>FALSE</code>) or whichever is available (<code>NA</code> or missing).</p>
</td></tr>
<tr><td><code id="RSA_+3A_file">file</code></td>
<td>
<p>filename to load the key from - <code>what</code> and
<code>file</code> are mutually exclusive</p>
</td></tr>
<tr><td><code id="RSA_+3A_password">password</code></td>
<td>
<p>string, used only if <code>what</code> is an encrypted private
key as the password to decrypt the key</p>
</td></tr>
<tr><td><code id="RSA_+3A_target">target</code></td>
<td>
<p>optional connection or a file name to store the result
in. If missing, the result is just returned form the function as
either a character vector (PEM) or a raw vector (DER).</p>
</td></tr>
<tr><td><code id="RSA_+3A_bits">bits</code></td>
<td>
<p>size of the generated key in bits. Must be <code>2 ^ n</code>
with integer <code>n &gt; 8</code>.</p>
</td></tr>
<tr><td><code id="RSA_+3A_modulus">modulus</code></td>
<td>
<p>modulus either as a raw vector (see
<code><a href="#topic+as.BIGNUMint">as.BIGNUMint</a></code>) or <code>bigz</code> object (from <code>gmp</code>
package) or an integer.</p>
</td></tr>
<tr><td><code id="RSA_+3A_exponent">exponent</code></td>
<td>
<p>exponent either as a raw vector (see
<code><a href="#topic+as.BIGNUMint">as.BIGNUMint</a></code>) or <code>bigz</code> object (from <code>gmp</code>
package) or an integer.</p>
</td></tr>
<tr><td><code id="RSA_+3A_first">first</code></td>
<td>
<p>logical, if <code>TRUE</code> only the first key will be used,
otherwise the result is a list of keys.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PKI.load.key</code>: private or public key object
</p>
<p><code>PKI.save.key</code>: raw vector (DER format) or character vector (PEM
format).
</p>
<p><code>PKI.genRSAkey</code>: private + public key object
</p>
<p><code>PKI.mkRSApubkey</code>, <code>PKI.load.OpenSSH.pubkey</code>: raw vector
(DER format) or character vector (PEM format) or a <code>"public.key"</code>
object.
</p>


<h3>Note</h3>

<p>The output format for private keys in PEM is PKCS#1, but for public
keys it is X.509 SubjectPublicKeyInfo (certificate public key). This
is consistent with OpenSSL RSA command line tool which uses the same
convention.
</p>
<p><code>PKI.load.key</code> can auto-detect the contained format based on
the header if 'PEM' format is used. In that case it supports PKCS#1
(naked RSA key), PKCS#8 (wrapped key with identifier - for public
keys X.509 SubjectPublicKeyInfo) and encrypted private key in
PKCS#8 (password must be passed to decrypt). 'DER' format provides no
way to define the type so 'private' cannot be 'NA' and only the
default format (PKCS#1 for private keys and X.509
SubjectPublicKeyInfo for public keys) is supported.
</p>
<p>The OpenSSH format is one line beginning with <code>"ssh-rsa "</code>.
SSH2 PEM public keys (rfc4716) are supported in <code>PKI.load.key</code>
and the binary payload is the same as the OpenSSH, only with
different wrapping.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PKI.encrypt">PKI.encrypt</a></code>, <code><a href="#topic+PKI.decrypt">PKI.decrypt</a></code>, <code><a href="#topic+PKI.pubkey">PKI.pubkey</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate 2048-bit RSA key
key &lt;- PKI.genRSAkey(bits = 2048L)

# extract private and public parts as PEM
priv.pem &lt;- PKI.save.key(key)
pub.pem &lt;- PKI.save.key(key, private=FALSE)
# load back the public key separately
pub.k &lt;- PKI.load.key(pub.pem)

# encrypt with the public key
x &lt;- PKI.encrypt(charToRaw("Hello, world!"), pub.k)
# decrypt with private key
rawToChar(PKI.decrypt(x, key))

# compute SHA1 hash (fingerprint) of the public key
PKI.digest(PKI.save.key(key, "DER", private=FALSE))

# convert OpenSSH public key to PEM format
# (the example is split into multiple lines just
#  so it is readable in the documentation, in reality you can
#  simply use the full line from is_rsa.pub without gsub)
PKI.load.OpenSSH.pubkey(gsub("\n","",
  "ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEAuvOXqfZ3pJeWeqyQOIXZwmg
M1RBqPUmVx3XgntpA+YtOZjKfuoJSpg3LhBuI/wXx8L2QZXNFibvX4qX2qoYsb
Hvkz2uonA3F7HRhCR/BJURR5nT135znVqALZo328v86HDsVWYR2/JzY1X8GI2R
2iKUMGXF0hVuRphdwLB735CU= foo@mycomputer"), format="PEM")
</code></pre>

<hr>
<h2 id='X509'>
Public Key Instraftructure (X509) functions
</h2><span id='topic+X509'></span><span id='topic+PKI.load.cert'></span><span id='topic+PKI.verifyCA'></span><span id='topic+PKI.pubkey'></span><span id='topic+PKI.get.subject'></span><span id='topic+PKI.get.cert.info'></span>

<h3>Description</h3>

<p><code>PKI.load.cert</code> creates a certificate object from a string,
connection or file.
</p>
<p><code>PKI.verifyCA</code> verifies a certificate against a given chain of
trust.
</p>
<p><code>PKI.pubkey</code> extracts public key from a certificate.  
</p>
<p><code>PKI.get.subject</code> extracts the subject name from the certificate.
</p>
<p><code>PKI.get.cert.info</code> decodes information from the certificate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKI.load.cert(what, format = c("PEM", "DER"), file)
PKI.verifyCA(certificate, ca, default = FALSE, partial = FALSE)
PKI.pubkey(certificate)
PKI.get.subject(certificate)
PKI.get.cert.info(certificate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="X509_+3A_what">what</code></td>
<td>
<p>string, raw vector or connection to load the certificate
from</p>
</td></tr>
<tr><td><code id="X509_+3A_format">format</code></td>
<td>
<p>format used to encode the certificate</p>
</td></tr>
<tr><td><code id="X509_+3A_file">file</code></td>
<td>
<p>filename to load the certificate from - <code>what</code> and
<code>file</code> are mutually exclusive</p>
</td></tr>
<tr><td><code id="X509_+3A_certificate">certificate</code></td>
<td>
<p>a certificate object (as returned by
<code>PKI.load.cert</code>)</p>
</td></tr>
<tr><td><code id="X509_+3A_ca">ca</code></td>
<td>
<p>a certificate object of the Certificate Authority (CA) or a
list of such objects if a chain of certificates is involved</p>
</td></tr>
<tr><td><code id="X509_+3A_default">default</code></td>
<td>
<p>logical, if <code>TRUE</code> then root CAs known to OpenSSL
will be added to the trust store. In that case <code>ca</code> can also
be <code>NULL</code> if the certificate is directly signed by the root
CA (very uncommon).</p>
</td></tr>
<tr><td><code id="X509_+3A_partial">partial</code></td>
<td>
<p>logical, if <code>TRUE</code> then the CAs listed in
<code>ca</code> are trusted even if they are neither root nor self-signed
CAs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PKI.verifyCA</code> is used to verify the validity of a certificate
by following a chain of trust. In the most simple case the
certificate was issued by a certificate authority (CA) directly,
which has a self-signed certificate. This is typically the case when
you (or your organization) have created your own CA for internal use.
In that case you only need to supply that CA's certificate to
<code>ca</code> and that's it. It is also possible that your self-signed
CA issued an intermediate certificate - if that is the case then pass
a list of both certificates (order doesn't matter) to <code>ca</code>.
</p>
<p>Another use case is that you have a certificate which has been issued
by publicly trusted CA - this is commonly the case with SSL
certificates used by web servers. In that case, the chain doesn't
end with an internal self-signed certificate, but instead it will
end with a publicly known root CA. OpenSSL manages a list of such
trusted CAs and you can check against them with
<code>default=TRUE</code>. However, in most cases your certificate won't
be issued directly by a root CA, but by an intermetiate authority so
you have to pass the intermediate certificate(s) in the <code>ca</code>
argument.
</p>
<p>Finally, it is sometimes possible that the default list of trusted
certificates does not include the root CA that you need. If that is
the case, and you still want to trust that chain, you can set
<code>partial=TRUE</code> and then <code>PKI.verifyCA</code> will trust the
certificates provided in <code>ca</code> unconditinally, even if they
don't lead to a trusted root or are not self-signed. Note, however,
that this is the least secure option and you should only use it if
the certificates are supplied by you and not the user. If you want
to support user-supplied intermediate certificates then you can use
<code>PKI.verifyCA</code> first to verify the integrity of the
user-supplied chain with <code>partial=TRUE</code> and then verify just
the intermediate certificate against your trusted certificate. That
way you won't trust the intermediate certificate inadvertently.
</p>


<h3>Value</h3>

<p><code>PKI.load.cert</code>: a certificate object
</p>
<p><code>PKI.verifyCA</code>: <code>TRUE</code> is the certificate can be trusted,
<code>FALSE</code> otherwise
</p>
<p><code>PKI.pubkey</code>: public key object
</p>
<p><code>PKI.get.subject</code>: string containing the subject information in
one-line RFC2253 format but in UTF8 encoding instead of MBS escapes.
NOTE: this is experimantal, we may choose to parse the contents and
return it in native R form as a named vector instead.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  (ca &lt;- PKI.load.cert(file=system.file("certs", "RForge-ca.crt", package="PKI")))
  (my.cert &lt;- PKI.load.cert(readLines(system.file("certs", "demo.crt", package="PKI"))))
  PKI.verifyCA(my.cert, ca)
  PKI.pubkey(my.cert)
  PKI.get.subject(my.cert)
  PKI.get.cert.info(my.cert)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
