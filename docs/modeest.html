<!DOCTYPE html><html lang="en"><head><title>Help for package modeest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {modeest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#modeest'>
<p>Mode Estimation</p></a></li>
<li><a href='#asselin'><p>The Asselin de Beauville mode estimator</p></a></li>
<li><a href='#distrMode'><p>Mode of some continuous and discrete distributions</p></a></li>
<li><a href='#grenander'><p>The Grenander mode estimator</p></a></li>
<li><a href='#hrm'><p>Bickel's half-range mode estimator</p></a></li>
<li><a href='#hsm'><p>Half sample mode estimator</p></a></li>
<li><a href='#lientz'><p>The empirical Lientz function and the Lientz mode estimator</p></a></li>
<li><a href='#meanshift'><p>The Meanshift mode estimator</p></a></li>
<li><a href='#mlv'><p>Estimation of the Mode(s) or Most Likely Value(s)</p></a></li>
<li><a href='#naive'><p>The Chernoff or 'naive' mode estimator</p></a></li>
<li><a href='#parzen'><p>Parzen's Kernel mode estimator</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#skewness'><p>Skewness</p></a></li>
<li><a href='#tsybakov'><p>The Tsybakov mode estimator</p></a></li>
<li><a href='#venter'><p>The Venter / Dalenius / LMS mode estimator</p></a></li>
<li><a href='#vieu'><p>Vieu's mode estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mode Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides estimators of the mode of univariate
    data or univariate distributions. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>fBasics, stable, stabledist, stats, statip (&ge; 0.2.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>evd, knitr, mvtnorm, testthat, VGAM</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/paulponcet/modeest">https://github.com/paulponcet/modeest</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paulponcet/modeest/issues">https://github.com/paulponcet/modeest/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-11-18 14:32:35 UTC; YL1101</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Poncet [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Poncet &lt;paulponcet@yahoo.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-11-18 15:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='modeest'>
Mode Estimation 
</h2><span id='topic+modeest-package'></span><span id='topic+modeest'></span>

<h3>Description</h3>

<p>This package provides estimators of the mode of univariate 
unimodal (and sometimes multimodal) data, and values of the modes of usual probability distributions. 
</p>
<p>For a complete list of functions, use <code>library(help = "modeest")</code> or <code>help.start()</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Parzen E. (1962).
On estimation of a probability density function and mode.
<em>Ann. Math. Stat.</em>, <b>33</b>(3):1065-1076. 
</p>
</li>
<li><p> Chernoff H. (1964).
Estimation of the mode.
<em>Ann. Inst. Statist. Math.</em>, <b>16</b>:31-41.
</p>
</li>
<li><p> Huber P.J. (1964).
Robust estimation of a location parameter.
<em>Ann. Math. Statist.</em>, <b>35</b>:73-101.
</p>
</li>
<li><p> Dalenius T. (1965).
The Mode - A Negleted Statistical Parameter.
<em>J. Royal Statist. Soc. A</em>, <b>128</b>:110-117.
</p>
</li>
<li><p> Grenander U. (1965).
Some direct estimates of the mode.
<em>Ann. Math. Statist.</em>, <b>36</b>:131-138.
</p>
</li>
<li><p> Venter J.H. (1967).
On estimation of the mode.
<em>Ann. Math. Statist.</em>, <b>38</b>(5):1446-1455.
</p>
</li>
<li><p> Lientz B.P. (1969).
On estimating points of local maxima and minima of density functions.
<em>Nonparametric Techniques in Statistical Inference (ed. M.L. Puri, Cambridge University Press)</em>, p.275-282.
</p>
</li>
<li><p> Lientz B.P. (1970).
Results on nonparametric modal intervals.
<em>SIAM J. Appl. Math.</em>, <b>19</b>:356-366.
</p>
</li>
<li><p> Wegman E.J. (1971).
A note on the estimation of the mode.
<em>Ann. Math. Statist.</em>, <b>42</b>(6):1909-1915.
</p>
</li>
<li><p> Yamato H. (1971). 
Sequential estimation of a continuous probability density function and mode.
<em>Bull. Math. Statist.</em>, <b>14</b>:1-12.
</p>
</li>
<li><p> Ekblom H. (1972).
A Monte Carlo investigation of mode estimators in small samples.
<em>Applied Statistics</em>, <b>21</b>:177-184.
</p>
</li>
<li><p> Lientz B.P. (1972).
Properties of modal intervals.
<em>SIAM J. Appl. Math.</em>, <b>23</b>:1-5.
</p>
</li>
<li><p> Konakov V.D. (1973).
On the asymptotic normality of the mode of multidimensional distributions.
<em>Theory Probab. Appl.</em>, <b>18</b>:794-803.
</p>
</li>
<li><p> Robertson T. and Cryer J.D. (1974).
An iterative procedure for estimating the mode.
<em>J. Amer. Statist. Assoc.</em>, <b>69</b>(348):1012-1016.
</p>
</li>
<li><p> Kim B.K. and Van Ryzin J. (1975).
Uniform consistency of a histogram density estimator and modal estimation.
<em>Commun. Statist.</em>, <b>4</b>:303-315.
</p>
</li>
<li><p> Sager T.W. (1975).
Consistency in nonparametric estimation of the mode.
<em>Ann. Statist.</em>, <b>3</b>(3):698-706.
</p>
</li>
<li><p> Stone C.J. (1975).
Adaptive maximum likelihood estimators of a location parameter.
<em>Ann. Statist.</em>, <b>3</b>:267-284.
</p>
</li>
<li><p> Mizoguchi R. and Shimura M. (1976).
Nonparametric Learning Without a Teacher Based on Mode Estimation.
<em>IEEE Transactions on Computers</em>, <b>C25</b>(11):1109-1117.
</p>
</li>
<li><p> Adriano K.N., Gentle J.E. and Sposito V.A. (1977).
On the asymptotic bias of Grenander's mode estimator.
<em>Commun. Statist.-Theor. Meth. A</em>, <b>6</b>:773-776.
</p>
</li>
<li><p> Asselin de Beauville J.-P. (1978).
Estimation non parametrique de la densite et du mode, exemple de la distribution Gamma.
<em>Revue de Statistique Appliquee</em>, <b>26</b>(3):47-70.
</p>
</li>
<li><p> Sager T.W. (1978).
Estimation of a multivariate mode.
<em>Ann. Statist.</em>, <b>6</b>:802-812.
</p>
</li>
<li><p> Devroye L. (1979).
Recursive estimation of the mode of a multivariate density.
<em>Canadian J. Statist.</em>, <b>7</b>(2):159-167.
</p>
</li>
<li><p> Sager T.W. (1979).
An iterative procedure for estimating a multivariate mode and isopleth.
<em>J. Amer. Statist. Assoc.</em>, <b>74</b>(366):329-339.
</p>
</li>
<li><p> Eddy W.F. (1980).
Optimum kernel estimators of the mode.
<em>Ann. Statist.</em>, <b>8</b>(4):870-882.
</p>
</li>
<li><p> Eddy W.F. (1982).
The Asymptotic Distributions of Kernel Estimators of the Mode.
<em>Z. Wahrsch. Verw. Gebiete</em>, <b>59</b>:279-290.
</p>
</li>
<li><p> Hall P. (1982).
Asymptotic Theory of Grenander's Mode Estimator.
<em>Z. Wahrsch. Verw. Gebiete</em>, <b>60</b>:315-334.
</p>
</li>
<li><p> Sager T.W. (1983).
Estimating modes and isopleths.
<em>Commun. Statist.-Theor. Meth.</em>, <b>12</b>(5):529-557.
</p>
</li>
<li><p> Hartigan J.A. and Hartigan P.M. (1985).
The Dip Test of Unimodality.
<em>Ann. Statist.</em>, <b>13</b>:70-84.
</p>
</li>
<li><p> Hartigan P.M. (1985).
Computation of the Dip Statistic to Test for Unimodality.
<em>Appl. Statist. (JRSS C)</em>, <b>34</b>:320-325.
</p>
</li>
<li><p> Romano J.P. (1988).
On weak convergence and optimality of kernel density estimates of the mode.
<em>Ann. Statist.</em>, <b>16</b>(2):629-647.
</p>
</li>
<li><p> Tsybakov A. (1990).
Recursive estimation of the mode of a multivariate distribution.
<em>Probl. Inf. Transm.</em>, <b>26</b>:31-37.
</p>
</li>
<li><p> Hyndman R.J. (1996).
Computing and graphing highest density regions.
<em>Amer. Statist.</em>, <b>50</b>(2):120-126.
</p>
</li>
<li><p> Vieu P. (1996).
A note on density mode estimation.
<em>Statistics \&amp; Probability Letters</em>, <b>26</b>:297&ndash;307.
</p>
</li>
<li><p> Leclerc J. (1997).
Comportement limite fort de deux estimateurs du mode : le shorth et l'estimateur naif.
<em>C. R. Acad. Sci. Paris, Serie I</em>, <b>325</b>(11):1207-1210.
</p>








</li>
<li><p> Leclerc J. (2000).
Strong limiting behavior of two estimates of the mode: the shorth and the naive estimator.
<em>Statistics and Decisions</em>, <b>18</b>(4).
</p>




</li>
<li><p> Shoung J.M. and Zhang C.H. (2001).
Least squares estimators of the mode of a unimodal regression function.
<em>Ann. Statist.</em>, <b>29</b>(3):648-665.
</p>
</li>
<li><p> Bickel D.R. (2002).
Robust estimators of the mode and skewness of continuous data.
<em>Computational Statistics and Data Analysis</em>, <b>39</b>:153-163.
</p>
</li>
<li><p> Abraham C., Biau G. and Cadre B. (2003).
Simple Estimation of the Mode of a Multivariate Density.
<em>Canad. J. Statist.</em>, <b>31</b>(1):23-34.
</p>
</li>
<li><p> Bickel D.R. (2003).
Robust and efficient estimation of the mode of continuous data: The mode as a viable measure of central tendency.
<em>J. Statist. Comput. Simul.</em>, <b>73</b>:899-912.
</p>
</li>
<li><p> Djeddour K., Mokkadem A. et Pelletier M. (2003).
Sur l'estimation recursive du mode et de la valeur modale d'une densite de probabilite.
<em>Technical report 105</em>.
</p>
</li>
<li><p> Djeddour K., Mokkadem A. et Pelletier M. (2003).
Application du principe de moyennisation a l'estimation recursive du mode et de la valeur modale d'une densite de probabilite.
<em>Technical report 106</em>.
</p>
</li>
<li><p> Hedges S.B. and Shah P. (2003).
Comparison of mode estimation methods and application in molecular clock analysis.
<em>BMC Bioinformatics</em>, <b>4</b>:31-41.
</p>




</li>
<li><p> Herrmann E. and Ziegler K. (2004).
Rates of consistency for nonparametric estimation of the mode in absence of smoothness assumptions.
<em>Statistics and Probability Letters</em>, <b>68</b>:359-368.
</p>
</li>
<li><p> Abraham C., Biau G. and Cadre B. (2004).
On the Asymptotic Properties of a Simple Estimate of the Mode.
<em>ESAIM Probab. Stat.</em>, <b>8</b>:1-11.
</p>
</li>
<li><p> Mokkadem A. and Pelletier M. (2005).
Adaptive Estimation of the Mode of a Multivariate Density.
<em>J. Nonparametr. Statist.</em>, <b>17</b>(1):83-105.
</p>
</li>
<li><p> Bickel D.R. and Fruehwirth R. (2006).
On a Fast, Robust Estimator of the Mode: Comparisons to Other Robust Estimators with Applications.
<em>Computational Statistics and Data Analysis</em>, <b>50</b>(12):3500-3530.
</p>
</li></ul>



<h3>See Also</h3>

 <p><code><a href="#topic+mlv">mlv</a></code> for general mode estimation. 
</p>

<hr>
<h2 id='asselin'>The Asselin de Beauville mode estimator</h2><span id='topic+asselin'></span><span id='topic+Asselin'></span>

<h3>Description</h3>

<p>This mode estimator is based on the algorithm 
described in Asselin de Beauville (1978).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asselin(x, bw = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asselin_+3A_x">x</code></td>
<td>
<p>numeric. Vector of observations.</p>
</td></tr>
<tr><td><code id="asselin_+3A_bw">bw</code></td>
<td>
<p>numeric. A number in <code>(0, 1]</code>. 
If <code>bw = 1</code>, the selected 'modal chain' may be too long.</p>
</td></tr>
<tr><td><code id="asselin_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the <code><a href="stats.html#topic+quantile">quantile</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value is returned, the mode estimate.
</p>


<h3>Note</h3>

<p>The user may call <code>asselin</code> through 
<code>mlv(x, method = "asselin", ...)</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Asselin de Beauville J.-P. (1978). 
Estimation non parametrique de la densite et du mode, 
exemple de la distribution Gamma. 
<em>Revue de Statistique Appliquee</em>, <b>26</b>(3):47-70.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a></code> for general mode estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbeta(1000, shape1 = 2, shape2 = 5)

## True mode:
betaMode(shape1 = 2, shape2 = 5)

## Estimation:
asselin(x, bw = 1)
asselin(x, bw = 1/2)
mlv(x, method = "asselin")

</code></pre>

<hr>
<h2 id='distrMode'>Mode of some continuous and discrete distributions</h2><span id='topic+distrMode'></span><span id='topic+betaMode'></span><span id='topic+cauchyMode'></span><span id='topic+chisqMode'></span><span id='topic+dagumMode'></span><span id='topic+expMode'></span><span id='topic+fMode'></span><span id='topic+fiskMode'></span><span id='topic+frechetMode'></span><span id='topic+gammaMode'></span><span id='topic+normMode'></span><span id='topic+gevMode'></span><span id='topic+ghMode'></span><span id='topic+ghtMode'></span><span id='topic+gldMode'></span><span id='topic+gompertzMode'></span><span id='topic+gpdMode'></span><span id='topic+gumbelMode'></span><span id='topic+hypMode'></span><span id='topic+koenkerMode'></span><span id='topic+kumarMode'></span><span id='topic+laplaceMode'></span><span id='topic+logisMode'></span><span id='topic+lnormMode'></span><span id='topic+lomaxMode'></span><span id='topic+maxwellMode'></span><span id='topic+mvnormMode'></span><span id='topic+nakaMode'></span><span id='topic+nigMode'></span><span id='topic+paralogisticMode'></span><span id='topic+paretoMode'></span><span id='topic+rayleighMode'></span><span id='topic+stableMode'></span><span id='topic+stableMode2'></span><span id='topic+tMode'></span><span id='topic+unifMode'></span><span id='topic+weibullMode'></span><span id='topic+yulesMode'></span><span id='topic+bernMode'></span><span id='topic+binomMode'></span><span id='topic+geomMode'></span><span id='topic+hyperMode'></span><span id='topic+nbinomMode'></span><span id='topic+poisMode'></span>

<h3>Description</h3>

<p>These functions return the mode of the main probability 
distributions implemented in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distrMode(x, ...)

betaMode(shape1, shape2, ncp = 0)

cauchyMode(location = 0, ...)

chisqMode(df, ncp = 0)

dagumMode(scale = 1, shape1.a, shape2.p)

expMode(...)

fMode(df1, df2)

fiskMode(scale = 1, shape1.a)

frechetMode(location = 0, scale = 1, shape = 1, ...)

gammaMode(shape, rate = 1, scale = 1/rate)

normMode(mean = 0, ...)

gevMode(location = 0, scale = 1, shape = 0, ...)

ghMode(alpha = 1, beta = 0, delta = 1, mu = 0, lambda = -1/2)

ghtMode(beta = 0.1, delta = 1, mu = 0, nu = 10)

gldMode(lambda1 = 0, lambda2 = -1, lambda3 = -1/8, lambda4 = -1/8)

gompertzMode(scale = 1, shape)

gpdMode(location = 0, scale = 1, shape = 0)

gumbelMode(location = 0, ...)

hypMode(alpha = 1, beta = 0, delta = 1, mu = 0, pm = c(1, 2, 3, 4))

koenkerMode(location = 0, ...)

kumarMode(shape1, shape2)

laplaceMode(location = 0, ...)

logisMode(location = 0, ...)

lnormMode(meanlog = 0, sdlog = 1)

lomaxMode(...)

maxwellMode(rate)

mvnormMode(mean, ...)

nakaMode(scale = 1, shape)

nigMode(alpha = 1, beta = 0, delta = 1, mu = 0)

paralogisticMode(scale = 1, shape1.a)

paretoMode(scale = 1, ...)

rayleighMode(scale = 1)

stableMode(alpha, beta, gamma = 1, delta = 0, pm = 0, ...)

stableMode2(loc, disp, skew, tail)

tMode(df, ncp)

unifMode(min = 0, max = 1)

weibullMode(shape, scale = 1)

yulesMode(...)

bernMode(prob)

binomMode(size, prob)

geomMode(...)

hyperMode(m, n, k, ...)

nbinomMode(size, prob, mu)

poisMode(lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distrMode_+3A_x">x</code></td>
<td>
<p>character. The name of the distribution to consider.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_shape1">shape1</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_location">location</code></td>
<td>
<p>location and scale parameters.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_df">df</code></td>
<td>
<p>degrees of freedom (non-negative, but can be non-integer).</p>
</td></tr>
<tr><td><code id="distrMode_+3A_scale">scale</code></td>
<td>
<p>location and scale parameters.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_shape1.a">shape1.a</code></td>
<td>
<p>shape parameters.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_shape2.p">shape2.p</code></td>
<td>
<p>shape parameters.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_df1">df1</code></td>
<td>
<p>degrees of freedom.  <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom.  <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_shape">shape</code></td>
<td>
<p>the location parameter <code class="reqn">a</code>,
scale parameter <code class="reqn">b</code>, and shape parameter <code class="reqn">s</code>.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_rate">rate</code></td>
<td>
<p>vector of rates.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_alpha">alpha</code></td>
<td>

<p>shape parameter <code>alpha</code>;
skewness parameter <code>beta</code>, <code>abs(beta)</code> is in the 
range (0, alpha);
scale parameter <code>delta</code>, <code>delta</code> must be zero or 
positive; 
location parameter <code>mu</code>, by default 0.
These is the meaning of the parameters in the first 
parameterization <code>pm=1</code> which is the default 
parameterization selection.
In the second parameterization, <code>pm=2</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>zeta</code> and <code>rho</code>.
In the third parameterization, <code>pm=3</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>xi</code> and <code>chi</code>.
In the fourth parameterization, <code>pm=4</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>a.bar</code> and <code>b.bar</code>.
</p>
</td></tr>
<tr><td><code id="distrMode_+3A_beta">beta</code></td>
<td>

<p>shape parameter <code>alpha</code>;
skewness parameter <code>beta</code>, <code>abs(beta)</code> is in the 
range (0, alpha);
scale parameter <code>delta</code>, <code>delta</code> must be zero or 
positive; 
location parameter <code>mu</code>, by default 0.
These is the meaning of the parameters in the first 
parameterization <code>pm=1</code> which is the default 
parameterization selection.
In the second parameterization, <code>pm=2</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>zeta</code> and <code>rho</code>.
In the third parameterization, <code>pm=3</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>xi</code> and <code>chi</code>.
In the fourth parameterization, <code>pm=4</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>a.bar</code> and <code>b.bar</code>.
</p>
</td></tr>
<tr><td><code id="distrMode_+3A_delta">delta</code></td>
<td>

<p>shape parameter <code>alpha</code>;
skewness parameter <code>beta</code>, <code>abs(beta)</code> is in the 
range (0, alpha);
scale parameter <code>delta</code>, <code>delta</code> must be zero or 
positive; 
location parameter <code>mu</code>, by default 0.
These is the meaning of the parameters in the first 
parameterization <code>pm=1</code> which is the default 
parameterization selection.
In the second parameterization, <code>pm=2</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>zeta</code> and <code>rho</code>.
In the third parameterization, <code>pm=3</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>xi</code> and <code>chi</code>.
In the fourth parameterization, <code>pm=4</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>a.bar</code> and <code>b.bar</code>.
</p>
</td></tr>
<tr><td><code id="distrMode_+3A_mu">mu</code></td>
<td>

<p>shape parameter <code>alpha</code>;
skewness parameter <code>beta</code>, <code>abs(beta)</code> is in the 
range (0, alpha);
scale parameter <code>delta</code>, <code>delta</code> must be zero or 
positive; 
location parameter <code>mu</code>, by default 0.
These is the meaning of the parameters in the first 
parameterization <code>pm=1</code> which is the default 
parameterization selection.
In the second parameterization, <code>pm=2</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>zeta</code> and <code>rho</code>.
In the third parameterization, <code>pm=3</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>xi</code> and <code>chi</code>.
In the fourth parameterization, <code>pm=4</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>a.bar</code> and <code>b.bar</code>.
</p>
</td></tr>
<tr><td><code id="distrMode_+3A_lambda">lambda</code></td>
<td>

<p>shape parameter <code>alpha</code>;
skewness parameter <code>beta</code>, <code>abs(beta)</code> is in the 
range (0, alpha);
scale parameter <code>delta</code>, <code>delta</code> must be zero or 
positive; 
location parameter <code>mu</code>, by default 0.
These is the meaning of the parameters in the first 
parameterization <code>pm=1</code> which is the default 
parameterization selection.
In the second parameterization, <code>pm=2</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>zeta</code> and <code>rho</code>.
In the third parameterization, <code>pm=3</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>xi</code> and <code>chi</code>.
In the fourth parameterization, <code>pm=4</code> <code>alpha</code>
and <code>beta</code> take the meaning of the shape parameters
(usually named) <code>a.bar</code> and <code>b.bar</code>.
</p>
</td></tr>
<tr><td><code id="distrMode_+3A_nu">nu</code></td>
<td>

<p>a numeric value, the number of degrees of freedom.
Note, <code>alpha</code> takes the limit of <code>abs(beta)</code>, 
and <code>lambda=-nu/2</code>.
</p>
</td></tr>
<tr><td><code id="distrMode_+3A_lambda1">lambda1</code></td>
<td>

<p>are numeric values where
<code>lambda1</code> is the location parameter,
<code>lambda2</code> is the location parameter,
<code>lambda3</code> is the first shape parameter, and
<code>lambda4</code> is the second shape parameter.
</p>
</td></tr>
<tr><td><code id="distrMode_+3A_lambda2">lambda2</code></td>
<td>

<p>are numeric values where
<code>lambda1</code> is the location parameter,
<code>lambda2</code> is the location parameter,
<code>lambda3</code> is the first shape parameter, and
<code>lambda4</code> is the second shape parameter.
</p>
</td></tr>
<tr><td><code id="distrMode_+3A_lambda3">lambda3</code></td>
<td>

<p>are numeric values where
<code>lambda1</code> is the location parameter,
<code>lambda2</code> is the location parameter,
<code>lambda3</code> is the first shape parameter, and
<code>lambda4</code> is the second shape parameter.
</p>
</td></tr>
<tr><td><code id="distrMode_+3A_lambda4">lambda4</code></td>
<td>

<p>are numeric values where
<code>lambda1</code> is the location parameter,
<code>lambda2</code> is the location parameter,
<code>lambda3</code> is the first shape parameter, and
<code>lambda4</code> is the second shape parameter.
</p>
</td></tr>
<tr><td><code id="distrMode_+3A_pm">pm</code></td>
<td>

<p>an integer value between <code>1</code> and <code>4</code> for the 
selection of the parameterization. The default takes the
first parameterization.       
</p>
</td></tr>
<tr><td><code id="distrMode_+3A_meanlog">meanlog</code></td>
<td>
<p>mean and standard deviation of the distribution
on the log scale with default values of <code>0</code> and <code>1</code> respectively.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_sdlog">sdlog</code></td>
<td>
<p>mean and standard deviation of the distribution
on the log scale with default values of <code>0</code> and <code>1</code> respectively.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_gamma">gamma</code></td>
<td>

<p>value of the index parameter <code>alpha</code> in the interval= <code class="reqn">(0, 2]</code>;
skewness parameter <code>beta</code>, in the range <code class="reqn">[-1, 1]</code>;
scale parameter <code>gamma</code>; and location (or &lsquo;shift&rsquo;)
parameter <code>delta</code>.
</p>
</td></tr>
<tr><td><code id="distrMode_+3A_loc">loc</code></td>
<td>
<p>vector of (real) location parameters.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_disp">disp</code></td>
<td>
<p>vector of (positive) dispersion parameters.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_skew">skew</code></td>
<td>
<p>vector of skewness parameters (in [-1,1]).</p>
</td></tr>
<tr><td><code id="distrMode_+3A_tail">tail</code></td>
<td>
<p>vector of parameters (in [1,2]) related to the tail thickness.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_min">min</code></td>
<td>
<p>lower and upper limits of the distribution.  Must be finite.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_max">max</code></td>
<td>
<p>lower and upper limits of the distribution.  Must be finite.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_prob">prob</code></td>
<td>
<p>Probability of success on each trial.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_size">size</code></td>
<td>
<p>number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="distrMode_+3A_m">m</code></td>
<td>
<p>the number of white balls in the urn.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="distrMode_+3A_k">k</code></td>
<td>
<p>the number of balls drawn from the urn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value is returned, the (true) mode of the distribution.
</p>


<h3>Note</h3>

<p>Some functions like <code>normMode</code> or <code>cauchyMode</code>, which relate 
to symmetric distributions, are trivial, but are implemented for the sake of 
exhaustivity.
</p>


<h3>Author(s)</h3>

<p><code><a href="fBasics.html#topic+ghMode">ghMode</a></code> and <code><a href="fBasics.html#topic+ghtMode">ghtMode</a></code> are from 
package <span class="pkg">fBasics</span>; 
<code><a href="fBasics.html#topic+hypMode">hypMode</a></code> was written by David Scott; 
<code><a href="fBasics.html#topic+gldMode">gldMode</a></code>, <code><a href="fBasics.html#topic+nigMode">nigMode</a></code> and 
<code><a href="stabledist.html#topic+stableMode">stableMode</a></code> were written by Diethelm Wuertz.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a></code> for the estimation of the mode; 
the documentation of the related distributions 
<code><a href="stats.html#topic+Beta">Beta</a></code>, <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Beta distribution
curve(dbeta(x, shape1 = 2, shape2 = 3.1), 
      xlim = c(0,1), ylab = "Beta density")
M &lt;- betaMode(shape1 = 2, shape2 = 3.1)
abline(v = M, col = 2)
mlv("beta", shape1 = 2, shape2 = 3.1)

## Lognormal distribution
curve(stats::dlnorm(x, meanlog = 3, sdlog = 1.1), 
      xlim = c(0, 10), ylab = "Lognormal density")
M &lt;- lnormMode(meanlog = 3, sdlog = 1.1)
abline(v = M, col = 2)
mlv("lnorm", meanlog = 3, sdlog = 1.1)

curve(VGAM::dpareto(x, scale = 1, shape = 1), xlim = c(0, 10))
abline(v = paretoMode(scale = 1), col = 2)

## Poisson distribution
poisMode(lambda = 6)
poisMode(lambda = 6.1)
mlv("poisson", lambda = 6.1)

</code></pre>

<hr>
<h2 id='grenander'>The Grenander mode estimator</h2><span id='topic+grenander'></span><span id='topic+Grenander'></span>

<h3>Description</h3>

<p>This function computes the Grenander mode estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grenander(x, bw = NULL, k, p, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grenander_+3A_x">x</code></td>
<td>
<p>numeric. Vector of observations.</p>
</td></tr>
<tr><td><code id="grenander_+3A_bw">bw</code></td>
<td>
<p>numeric. The bandwidth to be used. Should belong to (0, 1].</p>
</td></tr>
<tr><td><code id="grenander_+3A_k">k</code></td>
<td>
<p>numeric. Paramater 'k' in Grenander's mode estimate, see below.</p>
</td></tr>
<tr><td><code id="grenander_+3A_p">p</code></td>
<td>
<p>numeric. Paramater 'p' in Grenander's mode estimate, see below. 
If <code>p = Inf</code>, the function <code><a href="#topic+venter">venter</a></code> is used.</p>
</td></tr>
<tr><td><code id="grenander_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+venter">venter</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Grenander estimate is defined by 
</p>
<p style="text-align: center;"><code class="reqn"> \frac{ \sum_{j=1}^{n-k} \frac{(x_{j+k} + x_{j})}{2(x_{j+k} - x_{j})^p} }
{ \sum_{j=1}^{n-k} \frac{1}{(x_{j+k} - x_{j})^p} } </code>
</p>
 
<p>If <code class="reqn">p</code> tends to infinity, this estimate tends to the Venter mode estimate; 
this justifies to call <code><a href="#topic+venter">venter</a></code> if <code>p = Inf</code>. 
</p>
<p>The user should either give the bandwidth <code>bw</code> or the argument <code>k</code>, 
<code>k</code> being taken equal to <code>ceiling(bw*n) - 1</code> if missing.
</p>


<h3>Value</h3>

<p>A numeric value is returned, the mode estimate. 
If <code>p = Inf</code>, the <code><a href="#topic+venter">venter</a></code> mode estimator is returned.
</p>


<h3>Note</h3>

<p>The user may call <code>grenander</code> through 
<code>mlv(x, method = "grenander", bw, k, p, ...)</code>.
</p>


<h3>Author(s)</h3>

<p>D.R. Bickel for the original code, 
P. Poncet for the slight modifications introduced.
</p>


<h3>References</h3>


<ul>
<li><p> Grenander U. (1965). 
Some direct estimates of the mode. 
<em>Ann. Math. Statist.</em>, <b>36</b>:131-138.
</p>
</li>
<li><p> Dalenius T. (1965). 
The Mode - A Negleted Statistical Parameter. 
<em>J. Royal Statist. Soc. A</em>, <em>128</em>:110-117. 
</p>
</li>
<li><p> Adriano K.N., Gentle J.E. and Sposito V.A. (1977). 
On the asymptotic bias of Grenander's mode estimator. 
<em>Commun. Statist.-Theor. Meth. A</em>, <b>6</b>:773-776. 
</p>
</li>
<li><p> Hall P. (1982). 
Asymptotic Theory of Grenander's Mode Estimator. 
<em>Z. Wahrsch. Verw. Gebiete</em>, <b>60</b>:315-334.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a></code> for general mode estimation; 
<code><a href="#topic+venter">venter</a></code> for the Venter mode estimate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unimodal distribution
x &lt;- rnorm(1000, mean = 23, sd = 0.5) 

## True mode
normMode(mean = 23, sd = 0.5) # (!)

## Parameter 'k'
k &lt;- 5

## Many values of parameter 'p'
ps &lt;- seq(0.1, 4, 0.01)

## Estimate of the mode with these parameters
M &lt;- sapply(ps, function(p) grenander(x, p = p, k = k))

## Distribution obtained
plot(density(M), xlim = c(22.5, 23.5))

</code></pre>

<hr>
<h2 id='hrm'>Bickel's half-range mode estimator</h2><span id='topic+hrm'></span><span id='topic+HRM'></span>

<h3>Description</h3>

<p>SINCE THIS FUNCTION USED TO DEPEND ON THE BIOCONDUCTOR PACKAGE 'GENEFILTER', 
IT IS CURRENTLY DEFUNCT.
</p>
<p>This function computes Bickel's half range mode estimator 
described in Bickel (2002). It is a wrapper around the function 
<code>half.range.mode</code> from package <span class="pkg">genefilter</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrm(x, bw = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hrm_+3A_x">x</code></td>
<td>
<p>numeric. Vector of observations.</p>
</td></tr>
<tr><td><code id="hrm_+3A_bw">bw</code></td>
<td>
<p>numeric. The bandwidth to be used. Should belong to (0, 1]. 
This gives the fraction of the observations to consider at 
each step of the iterative algorithm.</p>
</td></tr>
<tr><td><code id="hrm_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mode estimator is computed by iteratively identifying 
densest half ranges. A densest half range is an interval 
whose width equals half the current range, and which 
contains the maximal number of observations. 
The subset of observations falling in the selected 
densest half range is then used to compute a new range, 
and the procedure is iterated.
</p>


<h3>Value</h3>

<p>A numeric value is returned, the mode estimate.
</p>


<h3>Note</h3>

<p>The user may call <code>hrm</code> through 
<code>mlv(x, method = "hrm", bw, ...)</code>.
</p>


<h3>Author(s)</h3>

<p>The C and R code are due to Richard Bourgon <a href="mailto:bourgon@stat.berkeley.edu">bourgon@stat.berkeley.edu</a>, 
see package <span class="pkg">genefilter</span>. The algorithm is described in Bickel (2002).
</p>


<h3>References</h3>


<ul>
<li><p> Bickel D.R. (2002). 
Robust estimators of the mode and skewness of continuous data. 
<em>Computational Statistics and Data Analysis</em>, <b>39</b>:153-163.
</p>
</li>
<li><p> Hedges S.B. and Shah P. (2003). 
Comparison of mode estimation methods and application in molecular clock analysis. 
<em>BMC Bioinformatics</em>, <b>4</b>:31-41.
</p>
</li>
<li><p> Bickel D.R. and Fruehwirth R. (2006). 
On a Fast, Robust Estimator of the Mode: 
Comparisons to Other Robust Estimators with Applications. 
<em>Computational Statistics and Data Analysis</em>, <b>50</b>(12):3500-3530. 
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a>()</code> for general mode estimation; 
<code><a href="#topic+hsm">hsm</a>()</code> for the half sample mode;  
<code><a href="#topic+venter">venter</a>()</code> for the Venter mode estimate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Unimodal distribution 
x &lt;- rgamma(1000, shape = 31.9)
## True mode
gammaMode(shape = 31.9)

## Estimate of the mode
hrm(x, bw = 0.4)
mlv(x, method = "hrm", bw = 0.4)

## End(Not run)

</code></pre>

<hr>
<h2 id='hsm'>Half sample mode estimator</h2><span id='topic+hsm'></span><span id='topic+HSM'></span>

<h3>Description</h3>

<p>This function computes the Robertson-Cryer mode estimator 
described in Robertson and Cryer (1974), 
also called half sample mode (if <code>bw = 1/2</code>) 
or fraction sample mode (for some other <code>bw</code>) by Bickel (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsm(x, bw = NULL, k, tie.action = "mean", tie.limit = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hsm_+3A_x">x</code></td>
<td>
<p>numeric. Vector of observations.</p>
</td></tr>
<tr><td><code id="hsm_+3A_bw">bw</code></td>
<td>
<p>numeric or function. 
The bandwidth to be used. Should belong to (0, 1].</p>
</td></tr>
<tr><td><code id="hsm_+3A_k">k</code></td>
<td>
<p>numeric. See 'Details'.</p>
</td></tr>
<tr><td><code id="hsm_+3A_tie.action">tie.action</code></td>
<td>
<p>character. The action to take if a tie is encountered.</p>
</td></tr>
<tr><td><code id="hsm_+3A_tie.limit">tie.limit</code></td>
<td>
<p>numeric. A limit deciding whether or not a warning 
is given when a tie is encountered.</p>
</td></tr>
<tr><td><code id="hsm_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The modal interval, i.e. the shortest interval among 
intervals containing <code>k+1</code> observations, is computed 
iteratively, until only one value is found, the mode estimate. 
At each step <code class="reqn">i</code>, one takes <code>k = ceiling(bw*n) - 1</code>, 
where <code>n</code> is the length of the modal interval computed 
at step <code class="reqn">i-</code><code>1</code>. 
If <code>bw</code> is of class <code>"function"</code>, 
then <code>k = ceiling(bw(n)) - 1</code> instead.
</p>


<h3>Value</h3>

<p>A numeric value is returned, the mode estimate.
</p>


<h3>Note</h3>

<p>The user may call <code>hsm</code> through 
<code>mlv(x, method = "hsm", ...)</code>.
</p>


<h3>Author(s)</h3>

<p>D.R. Bickel for the original code, 
P. Poncet for the slight modifications introduced.
</p>


<h3>References</h3>

 
<ul>
<li><p> Robertson T. and Cryer J.D. (1974). 
An iterative procedure for estimating the mode. 
<em>J. Amer. Statist. Assoc.</em>, <b>69</b>(348):1012-1016.
</p>
</li>
<li><p> Bickel D.R. and Fruehwirth R. (2006). 
On a Fast, Robust Estimator of the Mode: Comparisons to 
Other Robust Estimators with Applications. 
<em>Computational Statistics and Data Analysis</em>, <b>50</b>(12):3500-3530.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a></code> for general mode estimation; 
<code><a href="#topic+venter">venter</a></code> for the Venter mode estimate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unimodal distribution
x &lt;- rweibull(10000, shape = 3, scale = 0.9)

## True mode
weibullMode(shape = 3, scale = 0.9)

## Estimate of the mode
bandwidth &lt;- function(n, alpha) {1/n^alpha}
hsm(x, bw = bandwidth, alpha = 2)
mlv(x, method = "hsm", bw = bandwidth, alpha = 2)

</code></pre>

<hr>
<h2 id='lientz'>The empirical Lientz function and the Lientz mode estimator</h2><span id='topic+lientz'></span><span id='topic+Lientz'></span><span id='topic+plot.lientz'></span><span id='topic+print.lientz'></span><span id='topic+mlv.lientz'></span>

<h3>Description</h3>

<p>The Lientz mode estimator is nothing but the value minimizing the empirical 
Lientz function. A 'plot' and a 'print' methods are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lientz(x, bw = NULL)

## S3 method for class 'lientz'
plot(x, zoom = FALSE, ...)

## S3 method for class 'lientz'
print(x, digits = NULL, ...)

## S3 method for class 'lientz'
mlv(x, bw = NULL, abc = FALSE, par = shorth(x), optim.method = "BFGS", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lientz_+3A_x">x</code></td>
<td>
<p>numeric (vector of observations) or an object of class <code>"lientz"</code>.</p>
</td></tr>
<tr><td><code id="lientz_+3A_bw">bw</code></td>
<td>
<p>numeric. The smoothing bandwidth to be used. 
Should belong to (0, 1). Parameter 'beta' in Lientz (1970) function.</p>
</td></tr>
<tr><td><code id="lientz_+3A_zoom">zoom</code></td>
<td>
<p>logical. If <code>TRUE</code>, one can zoom on the graph created.</p>
</td></tr>
<tr><td><code id="lientz_+3A_...">...</code></td>
<td>
<p>if <code>abc = FALSE</code>, further arguments to be passed to 
<code><a href="stats.html#topic+optim">optim</a></code>, or further arguments to be passed to 
<code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="lientz_+3A_digits">digits</code></td>
<td>
<p>numeric. Number of digits to be printed.</p>
</td></tr>
<tr><td><code id="lientz_+3A_abc">abc</code></td>
<td>
<p>logical. If <code>FALSE</code> (the default), the Lientz empirical function 
is minimised using <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="lientz_+3A_par">par</code></td>
<td>
<p>numeric. The initial value used in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="lientz_+3A_optim.method">optim.method</code></td>
<td>
<p>character. If <code>abc = FALSE</code>, the method used in 
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lientz function is the smallest non-negative quantity <code class="reqn">S(x,\beta)</code>, 
where <code class="reqn">\beta</code> = <code>bw</code>, such that 
</p>
<p style="text-align: center;"><code class="reqn">F(x+S(x,\beta)) - F(x-S(x,\beta)) \geq \beta.</code>
</p>
 
<p>Lientz (1970) provided a way to estimate <code class="reqn">S(x,\beta)</code>; this estimate 
is what we call the empirical Lientz function.
</p>


<h3>Value</h3>

<p><code>lientz</code> returns an object of class <code>c("lientz", "function")</code>; 
this is a function with additional attributes:
</p>

<ul>
<li><p>x the <code>x</code> argument
</p>
</li>
<li><p>bw the <code>bw</code> argument 
</p>
</li>
<li><p>call the call which produced the result 
</p>
</li></ul>

<p><code>mlv.lientz</code> returns a numeric value, the mode estimate. 
If <code>abc = TRUE</code>, the <code>x</code> value minimizing the Lientz empirical 
function is returned. Otherwise, the <code><a href="stats.html#topic+optim">optim</a></code> method is 
used to perform minimization, and the attributes: 'value', 'counts', 
'convergence' and 'message', coming from the <code><a href="stats.html#topic+optim">optim</a></code> 
method, are added to the result.
</p>


<h3>Note</h3>

<p>The user may call <code>mlv.lientz</code> through 
<code>mlv(x, method = "lientz", ...)</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Lientz B.P. (1969).
On estimating points of local maxima and minima of density functions.
<em>Nonparametric Techniques in Statistical Inference (ed. M.L. Puri, Cambridge University Press</em>, p.275-282.
</p>
</li>
<li><p> Lientz B.P. (1970).
Results on nonparametric modal intervals.
<em>SIAM J. Appl. Math.</em>, <b>19</b>:356-366.
</p>
</li>
<li><p> Lientz B.P. (1972).
Properties of modal intervals.
<em>SIAM J. Appl. Math.</em>, <b>23</b>:1-5.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a></code> for general mode estimation; 
<code><a href="#topic+shorth">shorth</a></code> for the shorth estimate of the mode
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unimodal distribution
x &lt;- rbeta(1000,23,4)

## True mode
betaMode(23, 4)

## Lientz object
f &lt;- lientz(x, 0.2)
print(f)
plot(f)

## Estimate of the mode
mlv(f)              # optim(shorth(x), fn = f)
mlv(f, abc = TRUE)  # x[which.min(f(x))]
mlv(x, method = "lientz", bw = 0.2)

# Bimodal distribution
x &lt;- c(rnorm(1000,5,1), rnorm(1500, 22, 3))
f &lt;- lientz(x, 0.1)
plot(f)

</code></pre>

<hr>
<h2 id='meanshift'>The Meanshift mode estimator</h2><span id='topic+meanshift'></span>

<h3>Description</h3>

<p>The Meanshift mode estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanshift(
  x,
  bw = NULL,
  kernel = "gaussian",
  par = shorth(x),
  iter = 1000,
  tolerance = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meanshift_+3A_x">x</code></td>
<td>
<p>numeric. Vector of observations.</p>
</td></tr>
<tr><td><code id="meanshift_+3A_bw">bw</code></td>
<td>
<p>numeric. The smoothing bandwidth to be used.</p>
</td></tr>
<tr><td><code id="meanshift_+3A_kernel">kernel</code></td>
<td>
<p>character. The kernel to be used. Available kernels are 
<code>"biweight"</code>, <code>"cosine"</code>, <code>"eddy"</code>, 
<code>"epanechnikov"</code>, <code>"gaussian"</code>, <code>"optcosine"</code>, 
<code>"rectangular"</code>, <code>"triangular"</code>, <code>"uniform"</code>. 
See <code><a href="stats.html#topic+density">density</a></code> for more details on some of these kernels.</p>
</td></tr>
<tr><td><code id="meanshift_+3A_par">par</code></td>
<td>
<p>numeric. The initial value used in the meanshift algorithm.</p>
</td></tr>
<tr><td><code id="meanshift_+3A_iter">iter</code></td>
<td>
<p>numeric. Maximal number of iterations.</p>
</td></tr>
<tr><td><code id="meanshift_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric. Stopping criteria.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>meanshift</code> returns a numeric value, the mode estimate, 
with an attribute <code>"iterations"</code>. 
The number of iterations can be less than <code>iter</code> 
if the stopping criteria specified by <code>eps</code> is reached.
</p>


<h3>Note</h3>

<p>The user should preferentially call <code>meanshift</code> through 
<code>mlv(x, method = "meanshift", ...)</code>.
</p>


<h3>References</h3>

 
<ul>
<li><p> Fukunaga, K. and Hostetler, L. (1975).  
The estimation of the gradient of a density function, 
with applications in pattern recognition. 
<em>IEEE Transactions on Information Theory</em>, <b>21</b>(1):32&ndash;40. 
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a></code>, <code><a href="#topic+tsybakov">tsybakov</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unimodal distribution
x &lt;- rweibull(100, shape = 12, scale = 0.8)

## True mode
weibullMode(shape = 12, scale = 0.8)

## Estimate of the mode
mlv(x, method = "meanshift", par = mean(x))

</code></pre>

<hr>
<h2 id='mlv'>Estimation of the Mode(s) or Most Likely Value(s)</h2><span id='topic+mlv'></span><span id='topic+mlv.character'></span><span id='topic+mlv.factor'></span><span id='topic+mlv.logical'></span><span id='topic+mlv.integer'></span><span id='topic+mlv.default'></span><span id='topic+mlv1'></span>

<h3>Description</h3>

<p><code>mlv</code> is a generic function for estimating the mode of a univariate distribution. 
Different estimates (or methods) are provided: 
</p>

<ul>
<li> <p><code><a href="#topic+mfv">mfv</a></code>, which returns the most frequent value(s) in a given numerical vector, 
</p>
</li>
<li><p> the <code><a href="#topic+Lientz">Lientz</a></code> mode estimator, which is the value minimizing the Lientz function estimate, 
</p>
</li>
<li><p> the Chernoff mode estimator, also called <code><a href="#topic+naive">naive</a></code> mode estimator, 
which is defined as the center of the interval of given length containing the most observations, 
</p>
</li>
<li><p> the <code><a href="#topic+Venter">Venter</a></code> mode estimator, including the <code><a href="#topic+shorth">shorth</a></code>, i.e. the midpoint of the modal interval, 
</p>
</li>
<li><p> the <code><a href="#topic+Grenander">Grenander</a></code> mode estimator, 
</p>
</li>
<li><p> the half sample mode (<code><a href="#topic+HSM">HSM</a></code>) and the half range mode (<code><a href="#topic+HRM">HRM</a></code>), which are iterative versions of the Venter mode estimator, 
</p>
</li>
<li> <p><code><a href="#topic+Parzen">Parzen</a></code>'s kernel mode estimator, which is the value maximizing the kernel density estimate, 
</p>
</li>
<li><p> the <code><a href="#topic+Tsybakov">Tsybakov</a></code> mode estimator, based on a gradient-like recursive algorithm, 
</p>
</li>
<li><p> the <code><a href="#topic+Asselin">Asselin</a></code> de Beauville mode estimator, based on a algorithm detecting chains and holes in the sample, 
</p>
</li>
<li><p> the <code><a href="#topic+Vieu">Vieu</a></code> mode estimator, 
</p>
</li>
<li><p> the <code><a href="#topic+meanshift">meanshift</a></code> mode estimator. 
</p>
</li></ul>

<p><code>mlv</code> can also be used to compute the mode of a given distribution, with <code>mlv.character</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlv(x, ...)

## S3 method for class 'character'
mlv(x, na.rm = FALSE, ...)

## S3 method for class 'factor'
mlv(x, na.rm = FALSE, ...)

## S3 method for class 'logical'
mlv(x, na.rm = FALSE, ...)

## S3 method for class 'integer'
mlv(x, na.rm = FALSE, ...)

## Default S3 method:
mlv(x, bw = NULL, method, na.rm = FALSE, ...)

mlv1(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlv_+3A_x">x</code></td>
<td>
<p>numeric (vector of observations), or an object of class <code>"factor"</code>, <code>"integer"</code>, etc.</p>
</td></tr>
<tr><td><code id="mlv_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the function called for computation.</p>
</td></tr>
<tr><td><code id="mlv_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="mlv_+3A_bw">bw</code></td>
<td>
<p>numeric. The bandwidth to be used. 
This may have different meanings regarding the <code>method</code> used.</p>
</td></tr>
<tr><td><code id="mlv_+3A_method">method</code></td>
<td>
<p>character. One of the methods available for computing the mode estimate. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the default method of <code>mlv</code>, available methods are <code>"lientz"</code>, 
<code>"naive"</code>, <code>"venter"</code>, 
<code>"grenander"</code>, <code>"hsm"</code>, <code>"parzen"</code>, 
<code>"tsybakov"</code>, <code>"asselin"</code>, and <code>"meanshift"</code>. 
See the description above and the associated links. 
</p>
<p>If <code>x</code> is of class <code>"character"</code> (with length &gt; 1), 
<code>"factor"</code>, or <code>"integer"</code>, then the most frequent value found in 
<code>x</code> is returned using <code><a href="statip.html#topic+mfv">mfv</a></code> from package 
<span class="pkg">statip</span>. 
</p>
<p>If <code>x</code> is of class <code>"character"</code> (with length 1), 
<code>x</code> should be one of <code>"beta"</code>, <code>"cauchy"</code>, <code>"gev"</code>, etc. 
i.e. a character for which a function <code>*Mode</code> exists 
(for instance <code>betaMode</code>, <code>cauchyMode</code>, etc.). 
See <code><a href="#topic+distrMode">distrMode</a></code> for the available functions. 
The mode of the corresponding distribution is returned. 
</p>
<p>If <code>x</code> is of class <code>mlv.lientz</code>, see <code><a href="#topic+Lientz">Lientz</a></code> 
for more details.
</p>


<h3>Value</h3>

<p>A vector of the same type as <code>x</code>. 
Be aware that the length of this vector can be <code>&gt; 1</code>.
</p>


<h3>References</h3>

<p>See the references on mode estimation on the <code><a href="#topic+modeest-package">modeest-package</a></code>'s page.
</p>


<h3>See Also</h3>

<p><code><a href="statip.html#topic+mfv">mfv</a></code>, 
<code><a href="#topic+parzen">parzen</a></code>, 
<code><a href="#topic+venter">venter</a></code>, 
<code><a href="#topic+meanshift">meanshift</a></code>,
<code><a href="#topic+grenander">grenander</a></code>, 
<code><a href="#topic+hsm">hsm</a></code>, 
<code><a href="#topic+lientz">lientz</a></code>, 
<code><a href="#topic+naive">naive</a></code>, 
<code><a href="#topic+tsybakov">tsybakov</a></code>, 
<code><a href="#topic+skewness">skewness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unimodal distribution
x &lt;- rbeta(1000,23,4)

## True mode
betaMode(23, 4)
# or
mlv("beta", shape1 = 23, shape2 = 4)

## Be aware of this behaviour: 
mlv("norm") # returns 0, the mode of the standard normal distribution
mlv("normal") # returns 0 again, since "normal" is matched with "norm"
mlv("abnormal") # returns "abnormal", since the input vector "abrnormal" 
# is not recognized as a distribution name, hence is taken as a character 
# vector from which the most frequent value is requested. 

## Estimate of the mode
mlv(x, method = "lientz", bw = 0.2)
mlv(x, method = "naive", bw = 1/3)
mlv(x, method = "venter", type = "shorth")
mlv(x, method = "grenander", p = 4)
mlv(x, method = "hsm")
mlv(x, method = "parzen", kernel = "gaussian")
mlv(x, method = "tsybakov", kernel = "gaussian")
mlv(x, method = "asselin", bw = 2/3)
mlv(x, method = "vieu")
mlv(x, method = "meanshift")

</code></pre>

<hr>
<h2 id='naive'>The Chernoff or 'naive' mode estimator</h2><span id='topic+naive'></span><span id='topic+Chernoff'></span><span id='topic+chernoff'></span>

<h3>Description</h3>

<p>This estimator, also called the *naive* mode estimator, is defined as the 
center of the interval of given length containing the most observations. 
It is identical to Parzen's kernel mode estimator, when the kernel is chosen 
to be the uniform kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naive(x, bw = 1/2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="naive_+3A_x">x</code></td>
<td>
<p>numeric. Vector of observations.</p>
</td></tr>
<tr><td><code id="naive_+3A_bw">bw</code></td>
<td>
<p>numeric. The smoothing bandwidth to be used. Should belong to (0, 1). See below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector is returned, the mode estimate, 
which is the center of the interval of length <code>2*bw</code> 
containing the most observations.
</p>


<h3>Note</h3>

<p>The user may call <code>naive</code> through 
<code>mlv(x, method = "naive", bw)</code>.
</p>


<h3>References</h3>

 
<ul>
<li><p> Chernoff H. (1964). 
Estimation of the mode. 
<em>Ann. Inst. Statist. Math.</em>, <b>16</b>:31-41.
</p>
</li>
<li><p> Leclerc J. (1997). 
Comportement limite fort de deux estimateurs du mode : 
le shorth et l'estimateur naif. 
<em>C. R. Acad. Sci. Paris, Serie I</em>, <b>325</b>(11):1207-1210.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a></code> for general mode estimation; 
<code><a href="#topic+parzen">parzen</a></code> for Parzen's kernel mode estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unimodal distribution
x &lt;- rf(10000, df1 = 40, df2 = 30)

## True mode
fMode(df1 = 40, df2 = 30)

## Estimate of the mode
mean(naive(x, bw = 1/4))
mlv(x, method = "naive", bw = 1/4)

</code></pre>

<hr>
<h2 id='parzen'>Parzen's Kernel mode estimator</h2><span id='topic+parzen'></span><span id='topic+Parzen'></span>

<h3>Description</h3>

<p>Parzen's kernel mode estimator is the value 
maximizing the kernel density estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parzen(
  x,
  bw = NULL,
  kernel = "gaussian",
  abc = FALSE,
  tolerance = .Machine$double.eps^0.25,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parzen_+3A_x">x</code></td>
<td>
<p>numeric. Vector of observations.</p>
</td></tr>
<tr><td><code id="parzen_+3A_bw">bw</code></td>
<td>
<p>numeric. The smoothing bandwidth to be used.</p>
</td></tr>
<tr><td><code id="parzen_+3A_kernel">kernel</code></td>
<td>
<p>character. The kernel to be used. For available kernels see 
<code><a href="statip.html#topic+densityfun">densityfun</a></code> in package <span class="pkg">statip</span>.</p>
</td></tr>
<tr><td><code id="parzen_+3A_abc">abc</code></td>
<td>
<p>logical. If <code>FALSE</code> (the default), the kernel density estimate 
is maximised using <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="parzen_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric. Desired accuracy in the <code><a href="stats.html#topic+optimize">optimize</a></code> function.</p>
</td></tr>
<tr><td><code id="parzen_+3A_...">...</code></td>
<td>
<p>If <code>abc = FALSE</code>, further arguments to be passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>kernel = "uniform"</code>, the <code><a href="#topic+naive">naive</a></code> mode estimate is returned.
</p>


<h3>Value</h3>

<p><code>parzen</code> returns a numeric value, the mode estimate. 
If <code>abc = TRUE</code>, the <code>x</code> value maximizing the density 
estimate is returned. Otherwise, the <code><a href="stats.html#topic+optim">optim</a></code> 
method is used to perform maximization, and the attributes: 
'value', 'counts', 'convergence' and 'message', coming from 
the <code><a href="stats.html#topic+optim">optim</a></code> method, are added to the result.
</p>


<h3>Note</h3>

<p>The user may call <code>parzen</code> through 
<code>mlv(x, method = "kernel", ...)</code> or <code>mlv(x, method = "parzen", ...)</code>. 
</p>
<p>Presently, <code>parzen</code> is quite slow.
</p>


<h3>References</h3>

 
<ul>
<li><p> Parzen E. (1962). 
On estimation of a probability density function and mode. 
<em>Ann. Math. Stat.</em>, <b>33</b>(3):1065&ndash;1076. 
</p>
</li>
<li><p> Konakov V.D. (1973). 
On the asymptotic normality of the mode of multidimensional distributions. 
<em>Theory Probab. Appl.</em>, <b>18</b>:794-803. 
</p>
</li>
<li><p> Eddy W.F. (1980). 
Optimum kernel estimators of the mode. 
<em>Ann. Statist.</em>, <b>8</b>(4):870-882.
</p>
</li>
<li><p> Eddy W.F. (1982). 
The Asymptotic Distributions of Kernel Estimators of the Mode. 
<em>Z. Wahrsch. Verw. Gebiete</em>, <b>59</b>:279-290. 
</p>
</li>
<li><p> Romano J.P. (1988). 
On weak convergence and optimality of kernel density estimates of the mode. 
<em>Ann. Statist.</em>, <b>16</b>(2):629-647. 
</p>
</li>
<li><p> Abraham C., Biau G. and Cadre B. (2003). 
Simple Estimation of the Mode of a Multivariate Density. 
<em>Canad. J. Statist.</em>, <b>31</b>(1):23-34. 
</p>
</li>
<li><p> Abraham C., Biau G. and Cadre B. (2004). 
On the Asymptotic Properties of a Simple Estimate of the Mode. 
<em>ESAIM Probab. Stat.</em>, <b>8</b>:1-11. 
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a></code>, <code><a href="#topic+naive">naive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unimodal distribution 
x &lt;- rlnorm(10000, meanlog = 3.4, sdlog = 0.2) 

## True mode 
lnormMode(meanlog = 3.4, sdlog = 0.2) 

## Estimate of the mode 
mlv(x, method = "kernel", kernel = "gaussian", bw = 0.3, par = shorth(x)) 

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+mfv'></span><span id='topic+mfv1'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>statip</dt><dd><p><code><a href="statip.html#topic+mfv">mfv</a></code>, <code><a href="statip.html#topic+mfv1">mfv1</a></code></p>
</dd>
</dl>

<hr>
<h2 id='skewness'>Skewness</h2><span id='topic+skewness'></span>

<h3>Description</h3>

<p>This function encodes different methods 
to calculate the skewness from a vector of 
observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewness(x, na.rm = FALSE, method = c("moment", "fisher", "bickel"), M, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skewness_+3A_x">x</code></td>
<td>
<p>numeric. Vector of observations.</p>
</td></tr>
<tr><td><code id="skewness_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="skewness_+3A_method">method</code></td>
<td>
<p>character. Specifies the method of computation. 
These are either <code>"moment"</code>, <code>"fisher"</code> or <code>"bickel"</code>. 
The <code>"moment"</code> method is based on the definition of 
skewness for distributions; this form should 
be used when resampling (bootstrap or jackknife). The 
<code>"fisher"</code> method corresponds to the usual &quot;unbiased&quot; 
definition of sample variance, although in the case of skewness 
exact unbiasedness is not possible.</p>
</td></tr>
<tr><td><code id="skewness_+3A_m">M</code></td>
<td>
<p>numeric. (An estimate of) the mode of the observations <code>x</code>. 
Default value is <code><a href="#topic+shorth">shorth</a>(x)</code>.</p>
</td></tr>
<tr><td><code id="skewness_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>skewness</code> returns a numeric value. 
An attribute reports the method used.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz and contributors for the original <code>skewness</code> function 
from package <span class="pkg">fBasics</span>.
</p>


<h3>References</h3>


<ul>
<li><p> Bickel D.R. (2002).
Robust estimators of the mode and skewness of continuous data.
<em>Computational Statistics and Data Analysis</em>, <b>39</b>:153-163.
</p>
</li>
<li><p> Bickel D.R. et Fruehwirth R. (2006).
On a Fast, Robust Estimator of the Mode: Comparisons to Other Robust Estimators with Applications.
<em>Computational Statistics and Data Analysis</em>, <b>50</b>(12):3500-3530.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a></code> for general mode estimation; 
<code><a href="#topic+shorth">shorth</a></code> for the shorth estimate of the mode
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Skewness = 0
x &lt;- rnorm(1000)
skewness(x, method = "bickel", M = shorth(x))

## Skewness &gt; 0 (left skewed case)
x &lt;- rbeta(1000, 2, 5)
skewness(x, method = "bickel", M = betaMode(2, 5))

## Skewness &lt; 0 (right skewed case)
x &lt;- rbeta(1000, 7, 2)
skewness(x, method = "bickel", M = hsm(x, bw = 1/3))

</code></pre>

<hr>
<h2 id='tsybakov'>The Tsybakov mode estimator</h2><span id='topic+tsybakov'></span><span id='topic+Tsybakov'></span>

<h3>Description</h3>

<p>This mode estimator is based on a gradient-like recursive algorithm, 
more adapted for online estimation. 
It includes the Mizoguchi-Shimura (1976) mode estimator, 
based on the window training procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsybakov(
  x,
  bw = NULL,
  a,
  alpha = 0.9,
  kernel = "triangular",
  dmp = TRUE,
  par = shorth(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsybakov_+3A_x">x</code></td>
<td>
<p>numeric. Vector of observations.</p>
</td></tr>
<tr><td><code id="tsybakov_+3A_bw">bw</code></td>
<td>
<p>numeric. Vector of length <code>length(x)</code> 
giving the sequence of smoothing bandwidths to be used.</p>
</td></tr>
<tr><td><code id="tsybakov_+3A_a">a</code></td>
<td>
<p>numeric. Vector of length <code>length(x)</code> used in the 
gradient algorithm</p>
</td></tr>
<tr><td><code id="tsybakov_+3A_alpha">alpha</code></td>
<td>
<p>numeric. An alternative way of specifying <code>a</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="tsybakov_+3A_kernel">kernel</code></td>
<td>
<p>character. The kernel to be used. Available kernels are 
<code>"biweight"</code>, <code>"cosine"</code>, <code>"eddy"</code>, 
<code>"epanechnikov"</code>, <code>"gaussian"</code>, <code>"optcosine"</code>, 
<code>"rectangular"</code>, <code>"triangular"</code>, <code>"uniform"</code>. 
See <code><a href="stats.html#topic+density">density</a></code> for more details on some 
of these kernels.</p>
</td></tr>
<tr><td><code id="tsybakov_+3A_dmp">dmp</code></td>
<td>
<p>logical. If <code>TRUE</code>, Djeddour et al. 
version of the estimate is used.</p>
</td></tr>
<tr><td><code id="tsybakov_+3A_par">par</code></td>
<td>
<p>numeric. Initial value in the gradient algorithm. 
Default value is <code><a href="#topic+shorth">shorth</a>(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>bw</code> or <code>a</code> is missing, a default 
value advised by Djeddour et al (2003) is used: 
<code>bw = (1:length(x))^(-1/7)</code> and <code>a = (1:length(x))^(-alpha)</code>. 
(with <code>alpha = 0.9</code> if <code>alpha</code> is missing).
</p>


<h3>Value</h3>

<p>A numeric value is returned, the mode estimate.
</p>


<h3>Warning</h3>

<p>The Tsybakov mode estimate as it is presently 
computed does not work very well. 
The reasons of this inefficiency should be further investigated.
</p>


<h3>Note</h3>

<p>The user may call <code>tsybakov</code> through 
<code>mlv(x, method = "tsybakov", ...)</code>.
</p>


<h3>References</h3>

 
<ul>
<li><p> Mizoguchi R. and Shimura M. (1976).
Nonparametric Learning Without a Teacher Based on Mode Estimation.
<em>IEEE Transactions on Computers</em>, <b>C25</b>(11):1109-1117.
</p>
</li>
<li><p> Tsybakov A. (1990).
Recursive estimation of the mode of a multivariate distribution.
<em>Probl. Inf. Transm.</em>, <b>26</b>:31-37.
</p>
</li>
<li><p> Djeddour K., Mokkadem A. et Pelletier M. (2003).
Sur l'estimation recursive du mode et de la valeur modale d'une densite de 
probabilite.
<em>Technical report 105</em>.
</p>
</li>
<li><p> Djeddour K., Mokkadem A. et Pelletier M. (2003).
Application du principe de moyennisation a l'estimation recursive du mode 
et de la valeur modale d'une densite de probabilite.
<em>Technical report 106</em>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a></code> for general mode estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbeta(1000, shape1 = 2, shape2 = 5)

## True mode:
betaMode(shape1 = 2, shape2 = 5)

## Estimation:
tsybakov(x, kernel = "triangular")
tsybakov(x, kernel = "gaussian", alpha = 0.99)
mlv(x, method = "tsybakov", kernel = "gaussian", alpha = 0.99)

</code></pre>

<hr>
<h2 id='venter'>The Venter / Dalenius / LMS mode estimator</h2><span id='topic+venter'></span><span id='topic+Venter'></span><span id='topic+shorth'></span>

<h3>Description</h3>

<p>This function computes the Venter mode estimator, also called the Dalenius, 
or LMS (Least Median Square) mode estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>venter(
  x,
  bw = NULL,
  k,
  iter = 1,
  type = 1,
  tie.action = "mean",
  tie.limit = 0.05,
  warn = FALSE
)

shorth(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="venter_+3A_x">x</code></td>
<td>
<p>numeric. Vector of observations.</p>
</td></tr>
<tr><td><code id="venter_+3A_bw">bw</code></td>
<td>
<p>numeric. The bandwidth to be used. Should belong to (0, 1]. See 'Details'.</p>
</td></tr>
<tr><td><code id="venter_+3A_k">k</code></td>
<td>
<p>numeric. See 'Details'.</p>
</td></tr>
<tr><td><code id="venter_+3A_iter">iter</code></td>
<td>
<p>numeric. Number of iterations.</p>
</td></tr>
<tr><td><code id="venter_+3A_type">type</code></td>
<td>
<p>numeric or character. The type of Venter estimate to be computed. See 'Details'.</p>
</td></tr>
<tr><td><code id="venter_+3A_tie.action">tie.action</code></td>
<td>
<p>character. The action to take if a tie is encountered.</p>
</td></tr>
<tr><td><code id="venter_+3A_tie.limit">tie.limit</code></td>
<td>
<p>numeric. A limit deciding whether or not a warning is given when a tie is 
encountered.</p>
</td></tr>
<tr><td><code id="venter_+3A_warn">warn</code></td>
<td>
<p>logical. If <code>TRUE</code>, a warning is thrown when a tie is encountered.</p>
</td></tr>
<tr><td><code id="venter_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The modal interval, i.e. the shortest interval among intervals containing 
<code>k+1</code> observations, is first computed. (In dimension &gt; 1, this question 
is known as a 'k-enclosing problem'.)
The user should either give the bandwidth <code>bw</code> or the argument <code>k</code>, 
<code>k</code> being taken equal to <code>ceiling(bw*n) - 1</code> if missing, so 
<code>bw</code> can be seen as the fraction of the observations to be considered 
for the shortest interval. 
</p>
<p>If <code>type = 1</code>, the midpoint of the modal interval is returned.
If <code>type = 2</code>, the <code>floor((k+1)/2)</code>th element of the modal 
interval is returned.
If <code>type = 3</code> or <code>type = "dalenius"</code>, the median of the modal 
interval is returned.
If <code>type = 4</code> or <code>type = "shorth"</code>, the mean of the modal interval 
is returned.
If <code>type = 5</code> or <code>type = "ekblom"</code>, Ekblom's 
<code class="reqn">L_{-\infty}</code> estimate is returned, see Ekblom (1972). 
If <code>type = 6</code> or <code>type = "hsm"</code>, the half sample mode (hsm) is 
computed, see <code><a href="#topic+hsm">hsm</a></code>.
</p>


<h3>Value</h3>

<p>A numeric value is returned, the mode estimate.
</p>


<h3>Note</h3>

<p>The user may call <code>venter</code> through 
<code>mlv(x, method = "venter", ...)</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Dalenius T. (1965). 
The Mode - A Negleted Statistical Parameter. 
<em>J. Royal Statist. Soc. A</em>, <em>128</em>:110-117.
</p>
</li>
<li><p> Venter J.H. (1967). 
On estimation of the mode. 
<em>Ann. Math. Statist.</em>, <b>38</b>(5):1446-1455. 
</p>
</li>
<li><p> Ekblom H. (1972). 
A Monte Carlo investigation of mode estimators in small samples. 
<em>Applied Statistics</em>, <b>21</b>:177-184.
</p>
</li>
<li><p> Leclerc J. (1997). 
Comportement limite fort de deux estimateurs du mode : le shorth et l'estimateur naif. 
<em>C. R. Acad. Sci. Paris, Serie I</em>, <b>325</b>(11):1207-1210.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a></code> for general mode estimation, 
<code><a href="#topic+hsm">hsm</a></code> for the half sample mode.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(evd)

# Unimodal distribution
x &lt;- rgev(1000, loc = 23, scale = 1.5, shape = 0)

## True mode
gevMode(loc = 23, scale = 1.5, shape = 0)

## Estimate of the mode
venter(x, bw = 1/3)
mlv(x, method = "venter", bw = 1/3)

</code></pre>

<hr>
<h2 id='vieu'>Vieu's mode estimator</h2><span id='topic+vieu'></span><span id='topic+Vieu'></span>

<h3>Description</h3>

<p>Vieu's mode estimator is the value at which the kernel density derivative 
estimate is null.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vieu(x, bw = NULL, kernel = "gaussian", abc = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vieu_+3A_x">x</code></td>
<td>
<p>numeric. Vector of observations.</p>
</td></tr>
<tr><td><code id="vieu_+3A_bw">bw</code></td>
<td>
<p>numeric. The smoothing bandwidth to be used.</p>
</td></tr>
<tr><td><code id="vieu_+3A_kernel">kernel</code></td>
<td>
<p>character. The kernel to be used. Available kernels are <code>"biweight"</code>, 
<code>"cosine"</code>, <code>"eddy"</code>, <code>"epanechnikov"</code>, <code>"gaussian"</code>, 
<code>"optcosine"</code>, <code>"rectangular"</code>, <code>"triangular"</code>, 
<code>"uniform"</code>. See <code><a href="stats.html#topic+density">density</a></code> for more details on some 
of these kernels.</p>
</td></tr>
<tr><td><code id="vieu_+3A_abc">abc</code></td>
<td>
<p>logical. If <code>FALSE</code> (the default), the root of the density derivate 
estimate is searched with <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="vieu_+3A_...">...</code></td>
<td>
<p>If <code>abc = FALSE</code>, further arguments to be passed to 
<code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vieu</code> returns a numeric value, the mode estimate. If <code>abc = TRUE</code>, 
the <code>x</code> value at which the density derivative estimate is null is 
returned. Otherwise, the <code><a href="stats.html#topic+uniroot">uniroot</a></code> method is used.
</p>


<h3>Note</h3>

<p>The user may call <code>vieu</code> through 
<code>mlv(x, method = "vieu", ...)</code>. 
</p>
<p>Presently, <code>vieu</code> is quite slow.
</p>


<h3>References</h3>

 
<ul>
<li><p> Vieu P. (1996). A note on density mode estimation. 
<em>Statistics \&amp; Probability Letters</em>, <b>26</b>:297&ndash;307.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mlv">mlv</a></code>, <code><a href="#topic+parzen">parzen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unimodal distribution
x &lt;- rlnorm(10000, meanlog = 3.4, sdlog = 0.2)

## True mode
lnormMode(meanlog = 3.4, sdlog = 0.2)

## Estimate of the mode
mlv(x, method = "vieu", kernel = "gaussian")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
