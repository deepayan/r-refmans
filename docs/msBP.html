<!DOCTYPE html><html><head><title>Help for package msBP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {msBP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#galaxy'><p>Galaxy velocities</p></a></li>
<li><a href='#msBP-package'>
<p>Bayesian nonparametric density estimation via Multiscale Bernstein Polynomials (msBP)</p></a></li>
<li><a href='#msBP.compute.prob'>
<p>Compute binary tree of probabilities</p></a></li>
<li><a href='#msBP.Gibbs'>
<p>Gibbs sampling for density estimation for msBP model</p></a></li>
<li><a href='#msBP.internal'>
<p>Internal msBP functions</p></a></li>
<li><a href='#msBP.nrvTrees'>
<p>Nesting of the sample through the tree</p></a></li>
<li><a href='#msBP.pdf'>
<p>Random probability density function and random cumulative distribution function from a msBP</p></a></li>
<li><a href='#msBP.postCluster'>
<p>Posterior cluster allocation</p></a></li>
<li><a href='#msBP.rsample'>
<p>Random numbers from a random msBP densty</p></a></li>
<li><a href='#msBP.rtree'>
<p>Random msBP tree</p></a></li>
<li><a href='#msBP.test'>
<p>Multiscale testing of group differences</p></a></li>
<li><a href='#msBP.tree'>
<p>Creating an <code>msBPTree</code></p></a></li>
<li><a href='#tree2vec'>
<p>Conversions between tree and vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiscale Bernstein Polynomials for Densities</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Antonio Canale</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antonio Canale &lt;antonio.canale@unipd.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs Bayesian nonparametric multiscale density estimation and multiscale testing of group differences with multiscale Bernstein polynomials (msBP) mixtures as in Canale and Dunson (2016).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 16:42:47 UTC; tony</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-23 00:00:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='galaxy'>Galaxy velocities</h2><span id='topic+galaxy'></span>

<h3>Description</h3>

<p>Dataset with the velocities of the 82 galaxies reported by Roeder (1990)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(galaxy)</code></pre>


<h3>Format</h3>

<p>A data frame with 82 observations and a single variable reporting the speed of galaxies (km/second)</p>


<h3>Source</h3>

<p>Roeder, K. (1990) Density estimation with confidence sets exemplified by 
superclusters and voids in the galaxies, Journal of the American Statistical
Association, 85: 617-624.
</p>


<h3>References</h3>

<p>Escobar, M.D. and West, M. (1995) Bayesian Density Estimation and Inference 
Using Mixtures. Journal of the American Statistical Association, 90: 577-588.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(galaxy)
str(galaxy)
</code></pre>

<hr>
<h2 id='msBP-package'>
Bayesian nonparametric density estimation via Multiscale Bernstein Polynomials (msBP)
</h2><span id='topic+msBP-package'></span><span id='topic+msBP'></span>

<h3>Description</h3>

<p>Performs Bayesian nonparametric multiscale density estimation and multiscale testing of group differences with multiscale Bernstein polynomials (msBP) mixtures as in Canale and Dunson (2016).
</p>


<h3>Author(s)</h3>

<p>Antonio Canale &lt;antonio.canale@unipd.it&gt;
</p>


<h3>References</h3>

<p>Canale, A. and Dunson, D. B. (2016), &quot;Multiscale Bernstein polynomials for densities&quot;, Statistica Sinica, 26(3), 1175-1195.
</p>
<p>Canale, A. (2017), &quot;msBP: An R Package to Perform Bayesian Nonparametric Inference Using Multiscale Bernstein Polynomials Mixtures&quot;. Journal of Statistical Software, 78(6), 1-19. 
</p>

<hr>
<h2 id='msBP.compute.prob'>
Compute binary tree of probabilities
</h2><span id='topic+msBP.compute.prob'></span>

<h3>Description</h3>

<p>Compute the binary tree of probabilities using the multiscale stick-breaking process of Canale and Dunson (2016). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msBP.compute.prob(msBPtree, root = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msBP.compute.prob_+3A_msbptree">msBPtree</code></td>
<td>

<p>An object of the class msBPTree
</p>
</td></tr>
<tr><td><code id="msBP.compute.prob_+3A_root">root</code></td>
<td>
<p>logical. if the root needs to be considered (default) or it should be cut (fixing <code class="reqn">S_{01} = 0</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute a binary tree of weights. The general weights for node <code class="reqn">h</code> of scale <code class="reqn">s</code>, is
</p>
<p style="text-align: center;"><code class="reqn"> \pi_{s,h} = S_{s,h} \prod_{r&lt;s} (1-S_{r,g_{shr}}) T_{shr}</code>
</p>

<p>where <code class="reqn">g_{shr} = \lceil h/2^{s-r} \rceil</code> and <code class="reqn">T_{shr} = R_{r,g_{shr}}</code> if <code class="reqn">(r+1,g_{shr+1})</code> is the right daughter of node <code class="reqn">(r,g_{shr})</code>, or <code class="reqn">T_{shr} = 1-R_{r,g_{shr}}</code> if <code class="reqn">(r+1,g_{shr+1})</code> is the left daughter of <code class="reqn">(r,g_{shr})</code>.  
An object of the msBPTree class is basically a list containing two objects of the class <code>binaryTree</code>: the <code class="reqn">S</code> tree (representing the stoping probabilities) and the <code class="reqn">R</code> tree (representing the proceed-right probabilities).
</p>


<h3>Value</h3>

<p>An object of the class <code>msbpTree</code>.
</p>


<h3>References</h3>

<p>Canale, A. and Dunson, D. B. (2016), &quot;Multiscale Bernstein polynomials for densities&quot;, Statistica Sinica, 26(3), 1175-1195.
</p>
<p>Canale, A. (2017), &quot;msBP: An R Package to Perform Bayesian Nonparametric Inference Using Multiscale Bernstein Polynomials Mixtures&quot;. Journal of Statistical Software, 78(6), 1-19. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msBP.rtree">msBP.rtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;-structure(list( T = list(1/8,c(1/3,1/3), c(1/4,1/4,1/4,1/4), 
	rep(1,8)), max.s=3), class  = "binaryTree")
R &lt;-structure(list( T = list(1/2,c(1/2,1/2), c(1/4,1/2,1/2,1/2), 
	rep(1,8)), max.s=3), class  = "binaryTree")
RS &lt;-structure(list(S = S, R = R), class  = "msbpTree")
probabilities &lt;- msBP.compute.prob(RS)
</code></pre>

<hr>
<h2 id='msBP.Gibbs'>
Gibbs sampling for density estimation for msBP model
</h2><span id='topic+msBP.Gibbs'></span>

<h3>Description</h3>

<p>Gibbs sampling for Markov Chain Motecarlo sampling from the posterior distribution of an msBP model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msBP.Gibbs(x, a, b, g0 = "normal", g0par=c(0,1), mcmc, 
	grid = list(n.points=40, low=0.001, upp=0.999), state=NULL, hyper, 
	printing=0, maxScale=5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msBP.Gibbs_+3A_x">x</code></td>
<td>

<p>the observed sample
</p>
</td></tr>
<tr><td><code id="msBP.Gibbs_+3A_a">a</code></td>
<td>

<p>scalar a parameter
</p>
</td></tr>
<tr><td><code id="msBP.Gibbs_+3A_b">b</code></td>
<td>

<p>scalar b parameter
</p>
</td></tr>
<tr><td><code id="msBP.Gibbs_+3A_g0">g0</code></td>
<td>

<p>prior guess for the density of <code>x</code>. Currently only &quot;normal&quot;, &quot;unif&quot;, &quot;gamma&quot;, and &quot;empirical&quot; are supported. From version 1.1 random paramters are also allowed (only with <code>g0="normal"</code>).
</p>
</td></tr>
<tr><td><code id="msBP.Gibbs_+3A_g0par">g0par</code></td>
<td>

<p>additional scalar parameters for <code>g0</code>. If &quot;normal&quot; corresponds to mean and standard deviation, if &quot;uniform&quot; to upper and lower bounds, if &quot;gamma&quot; to shape and rate parameters. If &quot;empirical&quot; this value is not used. From version 1.1 random paramters are also allowed (only with <code>g0="normal"</code>). 
</p>
</td></tr>
<tr><td><code id="msBP.Gibbs_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters. It must include the
following integers: <code>nb</code> giving the number of burn-in iterations, <code>nrep</code> giving
the total number of iterations (including <code>nb</code>), and <code>ndisplay</code> giving
the multiple of iterations to be displayed on screen while the <code>C++</code> routine is running (a message will be printed every <code>ndisplay</code> iterations).</p>
</td></tr>
<tr><td><code id="msBP.Gibbs_+3A_grid">grid</code></td>
<td>

<p>a list giving the parameters for plotting the posterior mean density over a finite grid. It must include the following values: <code>low</code> and <code>upp</code> giving the lower and upper bound respectively of the grid and <code>n.points</code>, an integer giving the number of points of the grid</p>
</td></tr>
<tr><td><code id="msBP.Gibbs_+3A_state">state</code></td>
<td>
<p>a list giving the current value of the parameters. This list is used if the current analysis is the continuation of a
previous analysis or if we want to start the MCMC algorithm from some particular value of the parameters.</p>
</td></tr>
<tr><td><code id="msBP.Gibbs_+3A_hyper">hyper</code></td>
<td>
<p>a list containing the values of the hyperparameters for <code>a</code> and <code>b</code> or for the parameters of the prior guess (only if <code>g0="normal"</code>) . It must contains <code>hyperprior</code>, a list of three logical values determining if hyperpriors for <code>a</code>, <code>b</code> and <code>g0</code> are used (TRUE) or if <code>a</code>, <code>b</code>, or <code>g0</code> are fixed (FALSE), and <code>hyperpar</code> a list containing the hyperparameters for the hyperprior distributions: <code>beta</code>, <code>gamma</code>, <code>delta</code>, <code>lambda</code>, <code>mu0</code>, <code>kappa0</code>, <code>alpha0</code>, and <code>beta0</code>. See details. <code>gridB</code> is a grid of values for which the prior (and posterior) for <code>b</code> is evaluated with a Griddy Gibbs approach (Ritter and Tanner, 1992). See details.</p>
</td></tr>
<tr><td><code id="msBP.Gibbs_+3A_printing">printing</code></td>
<td>
<p>Vector of integers if the internal C++ function need to print what is doing</p>
</td></tr>
<tr><td><code id="msBP.Gibbs_+3A_maxscale">maxScale</code></td>
<td>
<p>maximum scale of the binary trees.</p>
</td></tr>
<tr><td><code id="msBP.Gibbs_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before calling the proper C++ subrouting the function center the sample on an initial guess for the density of the data. If <code>g0 = 'empirical'</code> the data are transformed so that the expctation of the msBP prior is centered on the kernel density estimate of <code>x</code>.
</p>
<p>The algorithm consists of two primary steps: (i) allocate each observation 
to a multiscale cluster, conditionally on the values of the weights (see also <code>msBP.postCluster</code>); 
(ii) update the weights, conditionally on the cluster allocations. 
All the procedure is written in C++ and additional R scripts are used to pre- and post-process the data and the output.
</p>
<p>If <code>hyper$hyperpriors$a</code> or <code>hyper$hyperpriors$b</code> is true, additional hyperpriors for <code>a</code> and <code>b</code> are assumed. Specifically the algorithm implements <code class="reqn">a \sim Ga(\beta,\gamma)</code> and  <code class="reqn">b \sim Ga(\delta, \lambda)</code>. 
For the former parameter the full conditional posterior distribution is available in closed form, i.e.
</p>
<p style="text-align: center;"><code class="reqn"> a | -  \sim Ga\left(\beta + 2^{s'+1} - 1, \gamma - \sum_{s=0}^{s'} \sum_{h=1}^{2^s} \log(1-S_{s,h}) \right),</code>
</p>

<p>while for the latter its full conditional posterior is proportional to 
</p>
<p style="text-align: center;"><code class="reqn">
	\frac{b^{\delta-1}}{B(b,b)^{2^{s+1}-1}} \exp \left\{b \left(
	\sum_{s=0}^{s'} \sum_{h=1}^{2^s} \log\{R_{s,h} (1 - R_{s,h} )\} - \lambda\right) \right\},
</code>
</p>

<p>where <code class="reqn">s'</code> is the maximum occupied scale and <code class="reqn">B(p, q)</code> is the Beta function. To sample
from the latter distribution, a griddy Gibbs approach over the grid defined by <code>hyper$hyperpar$gridB</code> is used. See Ritter and Tanner (1992).
From Version 1.1, if <code>hyper$hyperpriors$base=TRUE</code> and <code>g0="normal"</code> additional hyperpriors for the parameter of the centering normal density are assumed. Specifically the model is
</p>
<p style="text-align: center;"><code class="reqn">
	y = \Phi(x; \mu, \sigma^2)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
	(\mu, \sigma^2) \sim N(\mu; \mu_0, \kappa_0\sigma^2)\mbox{I-Ga}(\sigma^2; \alpha_0, \beta_0)
</code>
</p>

<p>and an addtional step simulating the values of <code class="reqn">\mu</code> and <code class="reqn">\sigma^2</code> from their conditional posterior distribution is added to the Gibbs sampler of Canale and Dunson (2016). Specifically, a Metropolis-Hastings step with proposal equal to the prior is implemented.
</p>


<h3>Value</h3>

<p>A list containing 


</p>
<table>
<tr><td><code>density</code></td>
<td>
<p>A list containing <code>postMeanDens</code>, the posterior mean density estimate evaluated over <code>xDens</code> and <code>postLowDens</code> and <code>postUppDens</code>, the lower and upper pointwise 95% credible bands,</p>
</td></tr>
<tr><td><code>mcmc</code></td>
<td>
<p>A list containing the MCMC chains: <code>dens</code> is a matrix (<code>nrep</code>-<code>nb</code>) times <code>n.grid</code>, <code>a</code> and <code>b</code> are the vectors with the MCMC chains for the two parameters (if <code>hyperprior</code> was TRUE), <code>scale</code> is a matix where each column is a MCMC chain of the total mass for each scale, <code>R</code> and <code>S</code>, are matrices where each column in the <code>tree2vec</code> form of the corresponding trees, <code>weights</code> is a matrix where each column is the <code>tree2vec</code> form of the corresponding tree of weights, <code>s</code> and <code>h</code> are matrices where each column is the MCMC chain for the node labels for a subject.</p>
</td></tr>
<tr><td><code>postmean</code></td>
<td>
<p>A list containing posterior means over the MCMC samples of <code>a</code>, <code>b</code>, and of all binary trees</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>A list containing the LPML, mean and median of the log CPO.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Canale, A. and Dunson, D. B. (2016), &quot;Multiscale Bernstein polynomials for densities&quot;, Statistica Sinica, 26(3), 1175-1195.
</p>
<p>Canale, A. (2017), &quot;msBP: An R Package to Perform Bayesian Nonparametric Inference Using Multiscale Bernstein Polynomials Mixtures&quot;. Journal of Statistical Software, 78(6), 1-19. 
</p>
<p>Ritter C., Tanner M. (1992). &quot;Facilitating the Gibbs Sampler: the Gibbs Stopper and the Griddy-Gibbs Sampler.&quot; Journal of the American Statistical Association, 87, 861-868.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msBP.postCluster">msBP.postCluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(galaxy)
galaxy &lt;- data.frame(galaxy)
speeds &lt;- galaxy$speed/1000
set.seed(1)
#with fixed g0 and random a, b
fit.msbp.1 &lt;- msBP.Gibbs(speeds, a = 10, b = 5, g0 = "empirical", 
	mcmc=list(nrep = 10000, nb = 5000, ndisplay = 1000), 
	hyper=list(hyperprior=list(a = TRUE, b = TRUE, g0 = FALSE), 
	hyperpar=list(beta=5,gamma = 1,delta = 1,lambda = 1)), 
	printing = 0, maxS = 7, grid = list(n.points = 150, low = 5, upp = 38))

#with random a, b and hyperparameters of g0
fit.msbp.2 &lt;- msBP.Gibbs(speeds, a = 10, b=5, g0 = "normal", 
	mcmc=list(nrep = 10000, nb = 5000, ndisplay = 1000), 
	hyper=list(hyperprior = list(a = TRUE, b = TRUE, g0 = TRUE), 
  hyperpar = list(beta = 50, gamma = 5, delta = 10, lambda = 1,
	gridB = seq(0, 20, length = 30),
	mu0 = 21, kappa0 = 0.1, alpha0 = 1, beta0 = 20)), 
	printing = 0, maxS = 7, grid = list(n.points = 150, lo w= 5, upp = 38))	

hist(speeds, prob=TRUE,br=10, ylim=c(0,0.23), main="", col='grey')
points(fit.msbp.1$density$postMeanDens~fit.msbp.1$density$xDens, ty='l', lwd=2)
points(fit.msbp.1$density$postUppDens~fit.msbp.1$density$xDens, ty='l',lty=2, lwd=2)
points(fit.msbp.1$density$postLowDens~fit.msbp.1$density$xDens, ty='l',lty=2, lwd=2)

hist(speeds, prob=TRUE,br=10, ylim=c(0,0.23), main="", col='grey')
points(fit.msbp.2$density$postMeanDens~fit.msbp.2$density$xDens, ty='l', lwd=2)
points(fit.msbp.2$density$postUppDens~fit.msbp.2$density$xDens, ty='l',lty=2, lwd=2)
points(fit.msbp.2$density$postLowDens~fit.msbp.2$density$xDens, ty='l',lty=2, lwd=2)


## End(Not run)
</code></pre>

<hr>
<h2 id='msBP.internal'>
Internal msBP functions
</h2><span id='topic+msBP.clus2prob'></span><span id='topic+msBP.leaf.allocation'></span><span id='topic+msBP.marginalBeta'></span><span id='topic+msBP.nesting'></span><span id='topic+msBP.nrvTree'></span><span id='topic+msBP.posteriorH0'></span><span id='topic+msBP.LPML'></span>

<h3>Description</h3>

<p>Internal msBP functions
</p>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='msBP.nrvTrees'>
Nesting of the sample through the tree
</h2><span id='topic+msBP.nrvTrees'></span>

<h3>Description</h3>

<p>Compute the path of each subject in the binary tree of weights and returns 3 tree: the <code>n</code> tree, the <code>r</code> tree, and the <code>v</code> tree (see values</p>


<h3>Usage</h3>

<pre><code class='language-R'>msBP.nrvTrees(sh, maxS = max(sh[,1]))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msBP.nrvTrees_+3A_sh">sh</code></td>
<td>

<p>A matrix with 2 columns and a number of rows equal to the sample size denoting the scale and node labels of each unit
</p>
</td></tr>
<tr><td><code id="msBP.nrvTrees_+3A_maxs">maxS</code></td>
<td>

<p>Upper bound for the scale
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing tree objects of the class <code>binaryTree</code>.  <code>n</code> is the tree containing at each node the number of subjects allocated to that node, <code>r</code> is the tree containing at each node the number of subjects that went right at that node, and  <code>v</code> is the tree containing at each node the number of subjects that passed through that node.</p>


<h3>References</h3>

<p>Canale, A. and Dunson, D. B. (2016), &quot;Multiscale Bernstein polynomials for densities&quot;, Statistica Sinica, 26(3), 1175-1195.
</p>
<p>Canale, A. (2017), &quot;msBP: An R Package to Perform Bayesian Nonparametric Inference Using Multiscale Bernstein Polynomials Mixtures&quot;. Journal of Statistical Software, 78(6), 1-19. </p>


<h3>Examples</h3>

<pre><code class='language-R'>sh &lt;- cbind(c(2,2,2,3,3,3,3,3,3,3), c(1,2,2,1,2,3,4,5,6,7))
nrv.trees &lt;- msBP.nrvTrees(sh)
plot(nrv.trees$n)
</code></pre>

<hr>
<h2 id='msBP.pdf'>
Random probability density function and random cumulative distribution function from a msBP
</h2><span id='topic+msBP.pdf'></span><span id='topic+msBP.cdf'></span>

<h3>Description</h3>

<p>Compute the density and the cumulative distribution functions of a random density drawn from an msBP(a,b) process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msBP.pdf(weights, n.points, y)
msBP.cdf(weights, n.points, log, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msBP.pdf_+3A_weights">weights</code></td>
<td>

<p>An object of the class binaryTree containing probability weights
</p>
</td></tr>
<tr><td><code id="msBP.pdf_+3A_n.points">n.points</code></td>
<td>

<p>Length of the grid over (0,1) in which calculate the value of the random density
</p>
</td></tr>
<tr><td><code id="msBP.pdf_+3A_log">log</code></td>
<td>

<p>Logical. TRUE for computing the log-cdf
</p>
</td></tr>  
<tr><td><code id="msBP.pdf_+3A_y">y</code></td>
<td>

<p>Vector of values in which the random density is evaluated. If used, <code>n.points</code> is not considered.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of size <code>n.points</code> or <code>length(y)</code>
</p>


<h3>References</h3>

<p>Canale, A. and Dunson, D. B. (2016), &quot;Multiscale Bernstein polynomials for densities&quot;, Statistica Sinica, 26(3), 1175-1195.
</p>
<p>Canale, A. (2017), &quot;msBP: An R Package to Perform Bayesian Nonparametric Inference Using Multiscale Bernstein Polynomials Mixtures&quot;. Journal of Statistical Software, 78(6), 1-19. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msBP.rtree">msBP.rtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prob &lt;-structure(list( T = list(0.15, c(0.05,0.05), c(0.05,0.2,0.1,0.1), 
		c(0,0,0.3,0,0,0,0,0) ), max.s=3), class  = "binaryTree")
density &lt;- msBP.pdf(prob, 100)
probability &lt;- msBP.cdf(prob, 100)
par(mfrow=c(1,2))
plot(density$dens~density$y, ty='l', main = "pdf")
plot(probability$prob~density$y, ty='l', main = "cdf")
</code></pre>

<hr>
<h2 id='msBP.postCluster'>
Posterior cluster allocation
</h2><span id='topic+msBP.postCluster'></span>

<h3>Description</h3>

<p>Perform the posterior multiscale cluster allocation conditionally on a tree of weights. See Algorithm 1 in Canale and Dunson (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msBP.postCluster(y, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msBP.postCluster_+3A_y">y</code></td>
<td>

<p>the sample of individials to be allocated to binary tree structure</p>
</td></tr>
<tr><td><code id="msBP.postCluster_+3A_weights">weights</code></td>
<td>

<p>the binary tree of weights (summing to one). An object of the class msBPTree
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>conditionally on the weights contained in <code>weights</code>, each subject in <code>y</code> is allocated to a multiscale cluster using Algorithm 1 of Canale and Dunson (2016). It relies on a multiscale modification of the slice sampler of Kalli et al. (2011). 
</p>


<h3>Value</h3>

<p>a matrix with <code>length(y)</code> row and two columns, denoting the scale and node within the scale, respectively.
</p>


<h3>References</h3>

<p>Canale, A. and Dunson, D. B. (2016), &quot;Multiscale Bernstein polynomials for densities&quot;, Statistica Sinica, 26(3), 1175-1195.
</p>
<p>Canale, A. (2017), &quot;msBP: An R Package to Perform Bayesian Nonparametric Inference Using Multiscale Bernstein Polynomials Mixtures&quot;. Journal of Statistical Software, 78(6), 1-19. 
</p>
<p>Kalli, M., Griffin, J., and Walker, S. (2011), &quot;Slice sampling mixture models,&quot; Statistics and Computing, 21, 93-105.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msBP.Gibbs">msBP.Gibbs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
y &lt;- rbeta(30, 5, 1)
weights &lt;-structure(list( 
	T = list(0, c(0,0.10), c(0.0,0,0.3,0.6)), max.s=2), 
	class  = 'binaryTree')
sh &lt;- msBP.postCluster(y, weights)
clus.size &lt;- msBP.nrvTrees(sh)$n
plot(clus.size)
</code></pre>

<hr>
<h2 id='msBP.rsample'>
Random numbers from a random msBP densty 
</h2><span id='topic+msBP.rsample'></span>

<h3>Description</h3>

<p>Random numbers generation from a random density drawn from a msBP process. </p>


<h3>Usage</h3>

<pre><code class='language-R'>msBP.rsample(n, msBPtree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msBP.rsample_+3A_n">n</code></td>
<td>

<p>Size of the sample to be generated
</p>
</td></tr>
<tr><td><code id="msBP.rsample_+3A_msbptree">msBPtree</code></td>
<td>

<p>An object of the class msBPtree
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the random sample
</p>


<h3>References</h3>

<p>Canale, A. and Dunson, D. B. (2016), &quot;Multiscale Bernstein polynomials for densities&quot;, Statistica Sinica, 26(3), 1175-1195.
</p>
<p>Canale, A. (2017), &quot;msBP: An R Package to Perform Bayesian Nonparametric Inference Using Multiscale Bernstein Polynomials Mixtures&quot;. Journal of Statistical Software, 78(6), 1-19. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msBP.rtree">msBP.rtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rand.tree &lt;- msBP.rtree(50,2, 4)
rand.samp &lt;- msBP.rsample(50, rand.tree)
hist(rand.samp, prob=TRUE)
prob &lt;- msBP.compute.prob(rand.tree)
density &lt;- msBP.pdf(prob, 100)
points(density$dens~density$y, ty='l', col=4)
</code></pre>

<hr>
<h2 id='msBP.rtree'>
Random msBP tree
</h2><span id='topic+msBP.rtree'></span>

<h3>Description</h3>

<p>Draw a random tree from the msBP process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msBP.rtree(a, b, max.s = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msBP.rtree_+3A_a">a</code></td>
<td>

<p>Scalar parameter
</p>
</td></tr>
<tr><td><code id="msBP.rtree_+3A_b">b</code></td>
<td>

<p>Scalar parameter
</p>
</td></tr>
<tr><td><code id="msBP.rtree_+3A_max.s">max.s</code></td>
<td>

<p>Maximum depth of the random trees
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>msBPTree</code>
</p>


<h3>References</h3>

<p>Canale, A. and Dunson, D. B. (2016), &quot;Multiscale Bernstein polynomials for densities&quot;, Statistica Sinica, 26(3), 1175-1195.
</p>
<p>Canale, A. (2017), &quot;msBP: An R Package to Perform Bayesian Nonparametric Inference Using Multiscale Bernstein Polynomials Mixtures&quot;. Journal of Statistical Software, 78(6), 1-19. </p>


<h3>See Also</h3>

<p><code><a href="#topic+msBP.rsample">msBP.rsample</a></code>, <code><a href="#topic+msBP.compute.prob">msBP.compute.prob</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>msBP.rtree(2, 2, 4)
</code></pre>

<hr>
<h2 id='msBP.test'>
Multiscale testing of group differences</h2><span id='topic+msBP.test'></span>

<h3>Description</h3>

<p>Performs multiscale hypothesis testing of difference in the distribution of two groups using msBP prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msBP.test(y, a, b, group, priorH0 = 0.5,
		mcmc, maxScale = 5, plot.it = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msBP.test_+3A_y">y</code></td>
<td>
<p>The pooled sample of observations</p>
</td></tr>
<tr><td><code id="msBP.test_+3A_a">a</code>, <code id="msBP.test_+3A_b">b</code></td>
<td>
<p>Parameters of the msBP prior</p>
</td></tr>
<tr><td><code id="msBP.test_+3A_group">group</code></td>
<td>
<p>Vector of size <code>length(y)</code> with 0 and 1 denoting the group membership.</p>
</td></tr>
<tr><td><code id="msBP.test_+3A_priorh0">priorH0</code></td>
<td>
<p>Prior gues for the probability of H0</p>
</td></tr>
<tr><td><code id="msBP.test_+3A_mcmc">mcmc</code></td>
<td>
<p>a list giving the MCMC parameters. It must include the
following integers: <code>nb</code> giving the number of burn-in iterations, <code>nrep</code> giving
the total number of iterations (including <code>nb</code>)., and <code>ndisplay</code> giving
the multiple of iterations to be displayed on screen while the MCMC is running (a message will be printed every <code>ndisplay</code> iterations).</p>
</td></tr> 
<tr><td><code id="msBP.test_+3A_maxscale">maxScale</code></td>
<td>
<p>maximum scale of the binary trees.</p>
</td></tr>
<tr><td><code id="msBP.test_+3A_plot.it">plot.it</code></td>
<td>
<p>logical. If TRUE a plot of the posterior mean probability of H0 is produced</p>
</td></tr>
<tr><td><code id="msBP.test_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>Ps</code></td>
<td>
<p>a matrix with <code>maxScale</code> rows and <code>mcmc$nrep</code> columns with the MCMC draws of posterior probabilities of H0 for each scale</p>
</td></tr>
<tr><td><code>Ps</code></td>
<td>
<p>the posterior mean probabilities of H0 for each scale.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Canale, A. and Dunson, D. B. (2016), &quot;Multiscale Bernstein polynomials for densities&quot;, Statistica Sinica, 26(3), 1175-1195.
</p>
<p>Canale, A. (2017), &quot;msBP: An R Package to Perform Bayesian Nonparametric Inference Using Multiscale Bernstein Polynomials Mixtures&quot;. Journal of Statistical Software, 78(6), 1-19. </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
y &lt;- runif(100)
g &lt;- c(rep(0,50), rep(1,50))
mcmc &lt;- list(nrep = 5000, nb = 1000, ndisplay = 500)
## Not run: 
test.res &lt;- msBP.test(y, 5, 1, g, mcmc=mcmc, plot.it = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='msBP.tree'>
Creating an <code>msBPTree</code>
</h2><span id='topic+msBP.tree'></span>

<h3>Description</h3>

<p>Create an object of the class <code>msBPTree</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msBP.tree(max.s = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msBP.tree_+3A_max.s">max.s</code></td>
<td>

<p>Maximum depth of the binary tree
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of the class  <code>msbpTree</code> is a list of 5 elements that represent a draw from a msBP(a,b) prior as introduced by Canale and Dunson (2016). The first two elements are the trees of the stopping and descending-to-the-right probabilities, respectively. Both are object of the class <code>binaryTree</code>. The third and fourth argument are the hyperparameters of the msBP prior, namely <code>a</code> and <code>b</code>. The last value is an integer with the maximum depth of both the trees.</p>


<h3>Value</h3>

<p>An object of the class <code>msBPTree</code> with zero at all nodes and <code>a=b=NULL</code>.
</p>


<h3>References</h3>

<p>Canale, A. and Dunson, D. B. (2016), &quot;Multiscale Bernstein polynomials for densities&quot;, Statistica Sinica, 26(3), 1175-1195.
</p>
<p>Canale, A. (2017), &quot;msBP: An R Package to Perform Bayesian Nonparametric Inference Using Multiscale Bernstein Polynomials Mixtures&quot;. Journal of Statistical Software, 78(6), 1-19. 
</p>


<h3>See Also</h3>

<p><code>msBP.rtree</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- msBP.tree(2)
</code></pre>

<hr>
<h2 id='tree2vec'>
Conversions between tree and vector
</h2><span id='topic+tree2vec'></span><span id='topic+vec2tree'></span>

<h3>Description</h3>

<p>Convert a binary tree object into a vector and _vice versa_
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree2vec(tree)
vec2tree(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree2vec_+3A_tree">tree</code></td>
<td>

<p>An object of the class binaryTree 
</p>
</td></tr>
<tr><td><code id="tree2vec_+3A_vec">vec</code></td>
<td>
<p>A vector of numbers. It must have size 2^s - 1, with s an integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of the class binaryTree is a binary tree containing at each node a value. 
</p>


<h3>Value</h3>

<p>A vector of size <code class="reqn">2^{D+1}-1</code>, where <code class="reqn">D</code> is the depth of the binary tree, or a binary tree with depth <code class="reqn">\log_2(</code><code>length(vec) + 1</code><code class="reqn">)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- vec2tree(1:(2^5 - 1))
vector &lt;- tree2vec(tree)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
