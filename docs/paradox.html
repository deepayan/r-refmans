<!DOCTYPE html><html><head><title>Help for package paradox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {paradox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#paradox-package'><p>paradox: Define and Work with Parameter Spaces for Complex Algorithms</p></a></li>
<li><a href='#assert_param_set'><p>Assertions for Params and ParamSets</p></a></li>
<li><a href='#condition_test'><p>Dependency Condition</p></a></li>
<li><a href='#default_values'><p>Extract Parameter Default Values</p></a></li>
<li><a href='#Design'><p>Design of Configurations</p></a></li>
<li><a href='#Domain'><p>Domain: Parameter Range without an Id</p></a></li>
<li><a href='#domain_check'><p>Check Value Validity</p></a></li>
<li><a href='#domain_is_bounded'><p>Whether a Given Domain is Bounded</p></a></li>
<li><a href='#domain_is_categ'><p>Whether a Given Domain is Categorical</p></a></li>
<li><a href='#domain_is_number'><p>Whether a Given Domain is Numeric</p></a></li>
<li><a href='#domain_nlevels'><p>The Number of Levels of a Given Domain</p></a></li>
<li><a href='#domain_qunif'><p>Transform a Numeric Value to a Sample</p></a></li>
<li><a href='#domain_sanitize'><p>Map to Acceptable Value</p></a></li>
<li><a href='#generate_design_grid'><p>Generate a Grid Design</p></a></li>
<li><a href='#generate_design_lhs'><p>Generate a Space-Filling LHS Design</p></a></li>
<li><a href='#generate_design_random'><p>Generate a Random Design</p></a></li>
<li><a href='#generate_design_sobol'><p>Generate a Space-Filling Sobol Sequence Design</p></a></li>
<li><a href='#NO_DEF'><p>Extra data type for &quot;no default value&quot;</p></a></li>
<li><a href='#ParamSet'><p>ParamSet</p></a></li>
<li><a href='#ParamSetCollection'><p>ParamSetCollection</p></a></li>
<li><a href='#ps'><p>Construct a ParamSet using Short Forms</p></a></li>
<li><a href='#ps_replicate'><p>Create a ParamSet by Repeating a Given ParamSet</p></a></li>
<li><a href='#ps_union'><p>Create a ParamSet from a list of ParamSets</p></a></li>
<li><a href='#psc'><p>Create a ParamSet Collection</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#Sampler'><p>Sampler Class</p></a></li>
<li><a href='#Sampler1D'><p>Sampler1D Class</p></a></li>
<li><a href='#Sampler1DCateg'><p>Sampler1DCateg Class</p></a></li>
<li><a href='#Sampler1DNormal'><p>Sampler1DNormal Class</p></a></li>
<li><a href='#Sampler1DRfun'><p>Sampler1DRfun Class</p></a></li>
<li><a href='#Sampler1DUnif'><p>Sampler1DUnif Class</p></a></li>
<li><a href='#SamplerHierarchical'><p>SamplerHierarchical Class</p></a></li>
<li><a href='#SamplerJointIndep'><p>SamplerJointIndep Class</p></a></li>
<li><a href='#SamplerUnif'><p>SamplerUnif Class</p></a></li>
<li><a href='#to_tune'><p>Indicate that a Parameter Value should be Tuned</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Define and Work with Parameter Spaces for Complex Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Define parameter spaces, constraints and
    dependencies for arbitrary algorithms, to program on such spaces. Also
    includes statistical designs and random samplers. Objects are
    implemented as 'R6' classes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://paradox.mlr-org.com">https://paradox.mlr-org.com</a>, <a href="https://github.com/mlr-org/paradox">https://github.com/mlr-org/paradox</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlr-org/paradox/issues">https://github.com/mlr-org/paradox/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>backports, checkmate, data.table, methods, mlr3misc (&ge;
0.9.4), R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, mlr3learners, e1071, knitr, lhs, spacefillr,
testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Condition.R' 'Design.R' 'Domain.R' 'Domain_methods.R'
'NoDefault.R' 'ParamDbl.R' 'ParamFct.R' 'ParamInt.R'
'ParamLgl.R' 'ParamSet.R' 'ParamSetCollection.R' 'ParamUty.R'
'Sampler.R' 'Sampler1D.R' 'SamplerHierarchical.R'
'SamplerJointIndep.R' 'SamplerUnif.R' 'asserts.R'
'default_values.R' 'generate_design_grid.R'
'generate_design_lhs.R' 'generate_design_random.R'
'generate_design_sobol.R' 'helper.R' 'ps.R' 'ps_replicate.R'
'ps_union.R' 'reexports.R' 'to_tune.R' 'zzz.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-09 11:25:23 UTC; user</td>
</tr>
<tr>
<td>Author:</td>
<td>Michel Lang <a href="https://orcid.org/0000-0001-9754-0393"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Bernd Bischl <a href="https://orcid.org/0000-0001-6002-6980"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jakob Richter <a href="https://orcid.org/0000-0003-4481-5554"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Xudong Sun <a href="https://orcid.org/0000-0003-3269-2307"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Martin Binder [aut, cre],
  Marc Becker <a href="https://orcid.org/0000-0002-8115-0400"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Binder &lt;mlr.developer@mb706.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-09 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='paradox-package'>paradox: Define and Work with Parameter Spaces for Complex Algorithms</h2><span id='topic+paradox'></span><span id='topic+paradox-package'></span>

<h3>Description</h3>

<p>Define parameter spaces, constraints and dependencies for arbitrary algorithms, to program on such spaces. Also includes statistical designs and random samplers. Objects are implemented as 'R6' classes.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin Binder <a href="mailto:mlr.developer@mb706.com">mlr.developer@mb706.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Michel Lang <a href="mailto:michellang@gmail.com">michellang@gmail.com</a> (<a href="https://orcid.org/0000-0001-9754-0393">ORCID</a>)
</p>
</li>
<li><p> Bernd Bischl <a href="mailto:bernd_bischl@gmx.net">bernd_bischl@gmx.net</a> (<a href="https://orcid.org/0000-0001-6002-6980">ORCID</a>)
</p>
</li>
<li><p> Jakob Richter <a href="mailto:jakob1richter@gmail.com">jakob1richter@gmail.com</a> (<a href="https://orcid.org/0000-0003-4481-5554">ORCID</a>)
</p>
</li>
<li><p> Xudong Sun <a href="mailto:smilesun.east@gmail.com">smilesun.east@gmail.com</a> (<a href="https://orcid.org/0000-0003-3269-2307">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Marc Becker <a href="mailto:marcbecker@posteo.de">marcbecker@posteo.de</a> (<a href="https://orcid.org/0000-0002-8115-0400">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://paradox.mlr-org.com">https://paradox.mlr-org.com</a>
</p>
</li>
<li> <p><a href="https://github.com/mlr-org/paradox">https://github.com/mlr-org/paradox</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlr-org/paradox/issues">https://github.com/mlr-org/paradox/issues</a>
</p>
</li></ul>


<hr>
<h2 id='assert_param_set'>Assertions for Params and ParamSets</h2><span id='topic+assert_param_set'></span>

<h3>Description</h3>

<p>Assertions for Params and ParamSets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_param_set(
  param_set,
  cl = NULL,
  no_untyped = FALSE,
  must_bounded = FALSE,
  no_deps = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_param_set_+3A_param_set">param_set</code></td>
<td>
<p>(<code><a href="#topic+ParamSet">ParamSet</a></code>).</p>
</td></tr>
<tr><td><code id="assert_param_set_+3A_cl">cl</code></td>
<td>
<p>(<code>character()</code>)<br />
Allowed subclasses.</p>
</td></tr>
<tr><td><code id="assert_param_set_+3A_no_untyped">no_untyped</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Are untyped <code><a href="#topic+Domain">Domain</a></code>s allowed?</p>
</td></tr>
<tr><td><code id="assert_param_set_+3A_must_bounded">must_bounded</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Only bounded <code><a href="#topic+Domain">Domain</a></code>s allowed?</p>
</td></tr>
<tr><td><code id="assert_param_set_+3A_no_deps">no_deps</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Are dependencies allowed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The checked object, invisibly.
</p>

<hr>
<h2 id='condition_test'>Dependency Condition</h2><span id='topic+condition_test'></span><span id='topic+condition_as_string'></span><span id='topic+Condition'></span><span id='topic+CondEqual'></span><span id='topic+CondAnyOf'></span>

<h3>Description</h3>

<p>Condition object, to specify the condition in a dependency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition_test(cond, x)

condition_as_string(cond, lhs_chr = "x")

Condition(rhs, condition_format_string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condition_test_+3A_cond">cond</code></td>
<td>
<p>(<code>Condition</code>)<br />
<code>Condition</code> to use</p>
</td></tr>
<tr><td><code id="condition_test_+3A_x">x</code></td>
<td>
<p>(<code>any</code>)<br />
Value to test</p>
</td></tr>
<tr><td><code id="condition_test_+3A_lhs_chr">lhs_chr</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Symbolic representation to use for <code style="white-space: pre;">&#8288;&lt;lhs&gt;&#8288;</code> in the returned string.</p>
</td></tr>
<tr><td><code id="condition_test_+3A_rhs">rhs</code></td>
<td>
<p>(<code>any</code>)<br />
Right-hand-side of the condition.</p>
</td></tr>
<tr><td><code id="condition_test_+3A_condition_format_string">condition_format_string</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Format-string for representing the condition when pretty-printing
in <code><a href="#topic+condition_as_string">condition_as_string()</a></code>.
Should contain two <code style="white-space: pre;">&#8288;%s&#8288;</code>, as it is used in an <code>sprintf()</code>-call with
two further string values.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>condition_test()</code>: Used internally. Tests whether a value satisfies a given condition.
Vectorizes when <code>x</code> is atomic.
</p>
</li>
<li> <p><code>condition_as_string()</code>: Used internally. Returns a string that represents the condition for pretty
printing, in the form <code>"&lt;lhs&gt; &lt;relation&gt; &lt;rhs&gt;"</code>, e.g. <code>"x == 3"</code> or
<code>"param %in% {1, 2, 10}"</code>.
</p>
</li></ul>


<h3>Currently implemented simple conditions</h3>


<ul>
<li> <p><code>CondEqual(rhs)</code> <br />
Value must be equal to <code>rhs</code>.
</p>
</li>
<li> <p><code>CondAnyOf(rhs)</code> <br />
Value must be any value of <code>rhs</code>.
</p>
</li></ul>


<hr>
<h2 id='default_values'>Extract Parameter Default Values</h2><span id='topic+default_values'></span><span id='topic+default_values.ParamSet'></span>

<h3>Description</h3>

<p>Extract parameter default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_values(x, ...)

## S3 method for class 'ParamSet'
default_values(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_values_+3A_x">x</code></td>
<td>
<p>(<code>any</code>)<br />
Object to extract default values from.</p>
</td></tr>
<tr><td><code id="default_values_+3A_...">...</code></td>
<td>
<p>(any)<br />
Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list()</code>.
</p>

<hr>
<h2 id='Design'>Design of Configurations</h2><span id='topic+Design'></span>

<h3>Description</h3>

<p>A lightweight wrapper around a <a href="#topic+ParamSet">ParamSet</a> and a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>, where the
latter is a design of configurations produced from the former - e.g.,
by calling a <code><a href="#topic+generate_design_grid">generate_design_grid()</a></code> or by sampling.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>param_set</code></dt><dd><p>(<a href="#topic+ParamSet">ParamSet</a>).</p>
</dd>
<dt><code>data</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Stored <code>data</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Design-new"><code>Design$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Design-format"><code>Design$format()</code></a>
</p>
</li>
<li> <p><a href="#method-Design-print"><code>Design$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Design-transpose"><code>Design$transpose()</code></a>
</p>
</li>
<li> <p><a href="#method-Design-clone"><code>Design$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Design-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Design$new(param_set, data, remove_dupl)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<a href="#topic+ParamSet">ParamSet</a>).</p>
</dd>
<dt><code>data</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Stored <code>data</code>.</p>
</dd>
<dt><code>remove_dupl</code></dt><dd><p>(<code>logical(1)</code>)<br />
Remove duplicates?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Design-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>Design$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Design-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Design$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Design-transpose"></a>



<h4>Method <code>transpose()</code></h4>

<p>Converts <code>data</code> into a list of lists of row-configurations,
possibly removes <code>NA</code> entries of inactive parameter values due to unsatisfied dependencies,
and possibly calls the <code>trafo</code> function of the <a href="#topic+ParamSet">ParamSet</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Design$transpose(filter_na = TRUE, trafo = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filter_na</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should <code>NA</code> entries of inactive parameter values due to unsatisfied
dependencies be removed?</p>
</dd>
<dt><code>trafo</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should the <code>trafo</code> function of the <a href="#topic+ParamSet">ParamSet</a> be called?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Design-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Design$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Domain'>Domain: Parameter Range without an Id</h2><span id='topic+Domain'></span><span id='topic+p_dbl'></span><span id='topic+p_fct'></span><span id='topic+p_int'></span><span id='topic+p_lgl'></span><span id='topic+p_uty'></span>

<h3>Description</h3>

<p>A <code>Domain</code> object is a representation of a single dimension of a <code><a href="#topic+ParamSet">ParamSet</a></code>. <code>Domain</code> objects are used to construct
<code><a href="#topic+ParamSet">ParamSet</a></code>s, either through the <code><a href="#topic+ps">ps()</a></code> short form, through the <code><a href="#topic+ParamSet">ParamSet</a></code> constructor itself,
or through the <code><a href="#topic+ParamSet">ParamSet</a></code><code style="white-space: pre;">&#8288;$search_space()&#8288;</code> mechanism (see
<code><a href="#topic+to_tune">to_tune()</a></code>).
For each of the basic parameter classes (<code>"ParamInt"</code>, <code>"ParamDbl"</code>, <code>"ParamLgl"</code>, <code>"ParamFct"</code>, and <code>"ParamUty"</code>) there is a function constructing a <code>Domain</code> object
(<code>p_int()</code>, <code>p_dbl()</code>, <code>p_lgl()</code>, <code>p_fct()</code>, <code>p_uty()</code>). They each have fitting construction arguments that control their
bounds and behavior.
</p>
<p><code>Domain</code> objects are representations of parameter ranges and are intermediate objects to be used in short form
constructions in <code><a href="#topic+to_tune">to_tune()</a></code> and <code><a href="#topic+ps">ps()</a></code>. Because of their nature, they should not be modified by the user, once constructed.
The <code>Domain</code> object's internals are subject to change and should not be relied upon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_dbl(
  lower = -Inf,
  upper = Inf,
  special_vals = list(),
  default = NO_DEF,
  tags = character(),
  tolerance = sqrt(.Machine$double.eps),
  depends = NULL,
  trafo = NULL,
  logscale = FALSE,
  init,
  aggr = NULL,
  in_tune_fn = NULL,
  disable_in_tune = NULL
)

p_fct(
  levels,
  special_vals = list(),
  default = NO_DEF,
  tags = character(),
  depends = NULL,
  trafo = NULL,
  init,
  aggr = NULL,
  in_tune_fn = NULL,
  disable_in_tune = NULL
)

p_int(
  lower = -Inf,
  upper = Inf,
  special_vals = list(),
  default = NO_DEF,
  tags = character(),
  tolerance = sqrt(.Machine$double.eps),
  depends = NULL,
  trafo = NULL,
  logscale = FALSE,
  init,
  aggr = NULL,
  in_tune_fn = NULL,
  disable_in_tune = NULL
)

p_lgl(
  special_vals = list(),
  default = NO_DEF,
  tags = character(),
  depends = NULL,
  trafo = NULL,
  init,
  aggr = NULL,
  in_tune_fn = NULL,
  disable_in_tune = NULL
)

p_uty(
  custom_check = NULL,
  special_vals = list(),
  default = NO_DEF,
  tags = character(),
  depends = NULL,
  trafo = NULL,
  repr = substitute(default),
  init,
  aggr = NULL,
  in_tune_fn = NULL,
  disable_in_tune = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Domain_+3A_lower">lower</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Lower bound, can be <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="Domain_+3A_upper">upper</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Upper bound can be <code>+Inf</code>.</p>
</td></tr>
<tr><td><code id="Domain_+3A_special_vals">special_vals</code></td>
<td>
<p>(<code>list()</code>)<br />
Arbitrary special values this parameter is allowed to take, to make it
feasible. This allows extending the domain of the parameter. Note that
these values are only used in feasibility checks, neither in generating
designs nor sampling.</p>
</td></tr>
<tr><td><code id="Domain_+3A_default">default</code></td>
<td>
<p>(<code>any</code>)<br />
Default value. Can be from the domain of the parameter or an element of
<code>special_vals</code>. Has value <a href="#topic+NO_DEF">NO_DEF</a> if no default exists. <code>NULL</code> can be a
valid default.
The value has no effect on <code>ParamSet$values</code> or the behavior of
<code>ParamSet$check()</code>, <code style="white-space: pre;">&#8288;$test()&#8288;</code> or <code style="white-space: pre;">&#8288;$assert()&#8288;</code>.
The <code>default</code> is intended to be used for documentation purposes.
'</p>
</td></tr>
<tr><td><code id="Domain_+3A_tags">tags</code></td>
<td>
<p>(<code>character()</code>)<br />
Arbitrary tags to group and subset parameters. Some tags serve a special
purpose:<br />
</p>

<ul>
<li> <p><code>"required"</code> implies that the parameters has to be given when setting
<code>values</code> in <a href="#topic+ParamSet">ParamSet</a>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Domain_+3A_tolerance">tolerance</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Initializes the <code style="white-space: pre;">&#8288;$tolerance&#8288;</code> field that determines the</p>
</td></tr>
<tr><td><code id="Domain_+3A_depends">depends</code></td>
<td>
<p>(<code>call</code> | <code>expression</code>)<br />
An expression indicating a requirement for the parameter that will be constructed from this. Can be given as an
expression (using <code>quote()</code>), or the expression can be entered directly and will be parsed using NSE (see
examples). The expression may be of the form <code style="white-space: pre;">&#8288;&lt;Param&gt; == &lt;value&gt;&#8288;</code> or <code style="white-space: pre;">&#8288;&lt;Param&gt; %in% &lt;values&gt;&#8288;</code>, which will result in
dependencies according to <code style="white-space: pre;">&#8288;ParamSet$add_dep(on = "&lt;Param&gt;", cond = CondEqual(&lt;value&gt;))&#8288;</code> or
<code style="white-space: pre;">&#8288;ParamSet$add_dep(on = "&lt;Param&gt;", cond = CondAnyOf(&lt;values&gt;))&#8288;</code>, respectively (see <code><a href="#topic+CondEqual">CondEqual</a></code>,
<code><a href="#topic+CondAnyOf">CondAnyOf</a></code>). The expression may also contain multiple conditions separated by <code>&amp;&amp;</code>.</p>
</td></tr>
<tr><td><code id="Domain_+3A_trafo">trafo</code></td>
<td>
<p>(<code>function</code>)<br />
Single argument function performing the transformation of a parameter. When the <code>Domain</code> is used to construct a
<code><a href="#topic+ParamSet">ParamSet</a></code>, this transformation will be applied to the corresponding parameter as part of the <code style="white-space: pre;">&#8288;$trafo&#8288;</code> function.<br />
Note that the trafo is <em>not</em> inherited by <code><a href="#topic+TuneToken">TuneToken</a></code>s! Defining a parameter
with e.g. <code>p_dbl(..., trafo = ...)</code> will <em>not</em> automatically give the <code>to_tune()</code> assigned to it a transformation.
<code>trafo</code> only makes sense for <code><a href="#topic+ParamSet">ParamSet</a></code>s that get used as search spaces for optimization or tuning, it is not useful when
defining domains or hyperparameter ranges of learning algorithms, because these do not use trafos.</p>
</td></tr>
<tr><td><code id="Domain_+3A_logscale">logscale</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Put numeric domains on a log scale. Default <code>FALSE</code>. Log-scale <code>Domain</code>s represent parameter ranges where lower and upper bounds
are logarithmized, and where a <code>trafo</code> is added that exponentiates sampled values to the original scale. This is
<em>not</em> the same as setting <code>trafo = exp</code>, because <code>logscale = TRUE</code> will handle parameter bounds internally:
a <code>p_dbl(1, 10, logscale = TRUE)</code> results in a parameter that has lower bound <code>0</code>, upper bound <code>log(10)</code>,
and uses <code>exp</code> transformation on these. Therefore, the given bounds represent the bounds <em>after</em> the transformation.
(see examples).<br />
<code>p_int()</code> with <code>logscale = TRUE</code> results in a continuous parameter similar to <code>p_dbl()</code>, not an integer-valued parameter, with bounds <code>log(max(lower, 0.5))</code> ...
<code>log(upper + 1)</code> and a trafo similar to &quot;<code>as.integer(exp(x))</code>&quot; (with additional bounds correction). The lower bound
is lifted to <code>0.5</code> if <code>lower</code> 0 to handle the <code>lower == 0</code> case. The upper bound is increased to <code>log(upper + 1)</code>
because the trafo would otherwise almost never generate a value of <code>upper</code>.<br />
When <code>logscale</code> is <code>TRUE</code>, then upper bounds may be infinite, but lower bounds should be greater than 0 for <code>p_dbl()</code>
or greater or equal 0 for <code>p_int()</code>.<br />
Note that &quot;logscale&quot; is <em>not</em> inherited by <code><a href="#topic+TuneToken">TuneToken</a></code>s! Defining a parameter
with <code style="white-space: pre;">&#8288;p_dbl(... logscale = TRUE)&#8288;</code> will <em>not</em> automatically give the <code>to_tune()</code> assigned to it log-scale. <code>logscale</code>
only makes sense for <code><a href="#topic+ParamSet">ParamSet</a></code>s that get used as search spaces for optimization or tuning, it is not useful when
defining domains or hyperparameter ranges of learning algorithms, because these do not use trafos.<br />
<code>logscale</code> happens on a natural (<code style="white-space: pre;">&#8288;e == 2.718282...&#8288;</code>) basis. Be aware that using a different base (<code>log10()</code>/<code style="white-space: pre;">&#8288;10^&#8288;</code>,
<code>log2()</code>/<code style="white-space: pre;">&#8288;2^&#8288;</code>) is completely equivalent and does not change the values being sampled after transformation.</p>
</td></tr>
<tr><td><code id="Domain_+3A_init">init</code></td>
<td>
<p>(<code>any</code>)<br />
Initial value. When this is given, then the corresponding entry in <code>ParamSet$values</code> is initialized with this
value upon construction.</p>
</td></tr>
<tr><td><code id="Domain_+3A_aggr">aggr</code></td>
<td>
<p>(<code>function</code>)<br />
Default aggregation function for a parameter. Can only be given for parameters tagged with <code>"internal_tuning"</code>.
Function with one argument, which is a list of parameter values and that returns the aggregated parameter value.</p>
</td></tr>
<tr><td><code id="Domain_+3A_in_tune_fn">in_tune_fn</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function(domain, param_vals)&#8288;</code>)<br />
Function that converters a <code>Domain</code> object into a parameter value.
Can only be given for parameters tagged with <code>"internal_tuning"</code>.
This function should also assert that the parameters required to enable internal tuning for the given <code>domain</code> are
set in <code>param_vals</code> (such as <code>early_stopping_rounds</code> for <code>XGBoost</code>).</p>
</td></tr>
<tr><td><code id="Domain_+3A_disable_in_tune">disable_in_tune</code></td>
<td>
<p>(named <code>list()</code>)<br />
The parameter values that need to be set in the <code>ParamSet</code> to disable the internal tuning for the parameter.
For <code>XGBoost</code> this would e.g. be <code>list(early_stopping_rounds = NULL)</code>.</p>
</td></tr>
<tr><td><code id="Domain_+3A_levels">levels</code></td>
<td>
<p>(<code>character</code> | <code>atomic</code> | <code>list</code>)<br />
Allowed categorical values of the parameter. If this is not a <code>character</code>, then a <code>trafo</code> is generated that
converts the names (if not given: <code>as.character()</code> of the values) of the <code>levels</code> argument to the values.
This trafo is then performed <em>before</em> the function given as the <code>trafo</code> argument.</p>
</td></tr>
<tr><td><code id="Domain_+3A_custom_check">custom_check</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Custom function to check the feasibility.
Function which checks the input.
Must return 'TRUE' if the input is valid and a <code>character(1)</code> with the error message otherwise.
This function should <em>not</em> throw an error.
Defaults to <code>NULL</code>, which means that no check is performed.</p>
</td></tr>
<tr><td><code id="Domain_+3A_repr">repr</code></td>
<td>
<p>(<code>language</code>)<br />
Symbol to use to represent the value given in <code>default</code>.
The <code>deparse()</code> of this object is used when printing the domain, in some cases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although the <code>levels</code> values of a constructed <code>p_fct()</code> will always be <code>character</code>-valued, the <code>p_fct</code> function admits
a <code>levels</code> argument that goes beyond this:
Besides a <code>character</code> vector, any atomic vector or list (optionally named) may be given. (If the value is a list
that is not named, the names are inferred using <code>as.character()</code> on the values.) The resulting <code>Domain</code> will
correspond to a range of values given by the names of the <code>levels</code> argument with a <code>trafo</code> that maps the <code>character</code>
names to the arbitrary values of the <code>levels</code> argument.
</p>


<h3>Value</h3>

<p>A <code>Domain</code> object.
</p>


<h3>See Also</h3>

<p>Other ParamSet construction helpers: 
<code><a href="#topic+ps">ps</a>()</code>,
<code><a href="#topic+to_tune">to_tune</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params = ps(
  unbounded_integer = p_int(),
  bounded_double = p_dbl(0, 10),
  half_bounded_integer = p_dbl(1),
  half_bounded_double = p_dbl(upper = 1),
  double_with_trafo = p_dbl(-1, 1, trafo = exp),
  extra_double = p_dbl(0, 1, special_vals = list("xxx"), tags = "tagged"),
  factor_param = p_fct(c("a", "b", "c")),
  factor_param_with_implicit_trafo = p_fct(list(a = 1, b = 2, c = list()))
)
print(params)

params$trafo(list(
  bounded_double = 1,
  double_with_trafo = 1,
  factor_param = "c",
  factor_param_with_implicit_trafo = "c"
))

# logscale:
params = ps(x = p_dbl(1, 100, logscale = TRUE))

# The ParamSet has bounds log(1) .. log(100):
print(params)

# When generating a equidistant grid, it is equidistant within log values
grid = generate_design_grid(params, 3)
print(grid)

# But the values are on a log scale with desired bounds after trafo
print(grid$transpose())

# Integer parameters with logscale are `p_dbl()`s pre-trafo
params = ps(x = p_int(0, 10, logscale = TRUE))
print(params)

grid = generate_design_grid(params, 4)
print(grid)

# ... but get transformed to integers.
print(grid$transpose())


# internal tuning

param_set = ps(
  iters = p_int(0, Inf, tags = "internal_tuning", aggr = function(x) round(mean(unlist(x))),
    in_tune_fn = function(domain, param_vals) {
      stopifnot(domain$lower &lt;= 1)
      stopifnot(param_vals$early_stopping == TRUE)
      domain$upper
    },
    disable_in_tune = list(early_stopping = FALSE)),
  early_stopping = p_lgl()
)
param_set$set_values(
  iters = to_tune(upper = 100, internal = TRUE),
  early_stopping = TRUE
)
param_set$convert_internal_search_space(param_set$search_space())
param_set$aggr_internal_tuned_values(
  list(iters = list(1, 2, 3))
)

param_set$disable_internal_tuning("iters")
param_set$values$early_stopping
</code></pre>

<hr>
<h2 id='domain_check'>Check Value Validity</h2><span id='topic+domain_check'></span><span id='topic+domain_assert'></span><span id='topic+domain_test'></span>

<h3>Description</h3>

<p><span class="pkg">checkmate</span>-like check-function. Check whether a list of values is feasible in the domain.
A value is feasible if it is of the same <code>storage_type</code>, inside of the bounds or element of
<code>special_vals</code>. <code>TuneToken</code>s are generally <em>not</em> accepted, so they should be filtered out
before the call, if present.
</p>
<p><code>domain_check</code> will return <code>TRUE</code> for accepted values, a <code>character(1)</code> error message otherwise.
</p>
<p><code>domain_test</code> will return <code>TRUE</code> for accepted values, <code>FALSE</code> otherwise.
</p>
<p><code>domain_assert</code> will return the <code>param</code> argument silently for accepted values, and throw an error message otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain_check(param, values, internal = FALSE)

domain_assert(
  param,
  values,
  internal = FALSE,
  .var.name = checkmate::vname(param),
  add = NULL
)

domain_test(param, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain_check_+3A_param">param</code></td>
<td>
<p>(<code>Domain</code>).</p>
</td></tr>
<tr><td><code id="domain_check_+3A_values">values</code></td>
<td>
<p>(<code>any</code>).</p>
</td></tr>
<tr><td><code id="domain_check_+3A_internal">internal</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
When set, function arguments are not checked for plausibility and <code>special_values</code> are not respected.
This is an optimization for internal purposes and should not be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If successful <code>TRUE</code>, if not a string with the error message.
</p>

<hr>
<h2 id='domain_is_bounded'>Whether a Given Domain is Bounded</h2><span id='topic+domain_is_bounded'></span>

<h3>Description</h3>

<p>This should generally be <code>TRUE</code> when <code>lower</code> and <code>upper</code> are given and finite, or when the <code>nlevels</code> is finite, and <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain_is_bounded(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain_is_bounded_+3A_param">param</code></td>
<td>
<p>(<code>Domain</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code>.
</p>

<hr>
<h2 id='domain_is_categ'>Whether a Given Domain is Categorical</h2><span id='topic+domain_is_categ'></span>

<h3>Description</h3>

<p>This should generally be <code>TRUE</code> for categorical <code><a href="#topic+Domain">Domain</a></code>s, such as <code><a href="#topic+p_fct">p_fct()</a></code> or <code><a href="#topic+p_lgl">p_lgl()</a></code>, and <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain_is_categ(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain_is_categ_+3A_param">param</code></td>
<td>
<p>(<code>Domain</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code>.
</p>

<hr>
<h2 id='domain_is_number'>Whether a Given Domain is Numeric</h2><span id='topic+domain_is_number'></span>

<h3>Description</h3>

<p>This should generally be <code>TRUE</code> for discrete or continuous numeric <code><a href="#topic+Domain">Domain</a></code>s, and <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain_is_number(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain_is_number_+3A_param">param</code></td>
<td>
<p>(<code>Domain</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code>.
</p>

<hr>
<h2 id='domain_nlevels'>The Number of Levels of a Given Domain</h2><span id='topic+domain_nlevels'></span>

<h3>Description</h3>

<p>This should be the number of discrete possible levels for discrete type <code><a href="#topic+Domain">Domain</a></code>s such as <code><a href="#topic+p_int">p_int()</a></code> or <code><a href="#topic+p_fct">p_fct()</a></code>, and
<code>Inf</code> for continuous or untyped parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain_nlevels(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain_nlevels_+3A_param">param</code></td>
<td>
<p>(<code>Domain</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>.
</p>

<hr>
<h2 id='domain_qunif'>Transform a Numeric Value to a Sample</h2><span id='topic+domain_qunif'></span>

<h3>Description</h3>

<p>Return a valid sample from the given <code><a href="#topic+Domain">Domain</a></code>, given a value from the interval <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain_qunif(param, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain_qunif_+3A_param">param</code></td>
<td>
<p>(<code>Domain</code>).</p>
</td></tr>
<tr><td><code id="domain_qunif_+3A_x">x</code></td>
<td>
<p><code>numeric</code> between 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>any</code> &ndash; format depending on the <code>Domain</code>.
</p>

<hr>
<h2 id='domain_sanitize'>Map to Acceptable Value</h2><span id='topic+domain_sanitize'></span>

<h3>Description</h3>

<p>Map values that are close enough to the given <code><a href="#topic+Domain">Domain</a></code> to values that are truly acceptable.
</p>
<p>This is used to map <code>numeric()</code> values that are close to but outside the acceptable interval to the interval bounds.
It is also used to convert integer-valued <code>numeric</code> values to <code>integer</code> values for <code><a href="#topic+p_int">p_int()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain_sanitize(param, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain_sanitize_+3A_param">param</code></td>
<td>
<p>(<code>Domain</code>).</p>
</td></tr>
<tr><td><code id="domain_sanitize_+3A_values">values</code></td>
<td>
<p>(<code>any</code>) &ndash; format depending on the <code>Domain</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>any</code> &ndash; format depending on the <code>Domain</code>.
</p>

<hr>
<h2 id='generate_design_grid'>Generate a Grid Design</h2><span id='topic+generate_design_grid'></span>

<h3>Description</h3>

<p>Generate a grid with a specified resolution in the parameter space.
The resolution for categorical parameters is ignored, these parameters
always produce a grid over all their valid levels.
For number params the endpoints of the params are always included in the grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_design_grid(param_set, resolution = NULL, param_resolutions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_design_grid_+3A_param_set">param_set</code></td>
<td>
<p>(<code><a href="#topic+ParamSet">ParamSet</a></code>).</p>
</td></tr>
<tr><td><code id="generate_design_grid_+3A_resolution">resolution</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Global resolution for all parameters.</p>
</td></tr>
<tr><td><code id="generate_design_grid_+3A_param_resolutions">param_resolutions</code></td>
<td>
<p>(named <code>integer()</code>)<br />
Resolution per <code><a href="#topic+Domain">Domain</a></code>, named by parameter ID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Design">Design</a></code>.
</p>


<h3>See Also</h3>

<p>Other generate_design: 
<code><a href="#topic+generate_design_lhs">generate_design_lhs</a>()</code>,
<code><a href="#topic+generate_design_random">generate_design_random</a>()</code>,
<code><a href="#topic+generate_design_sobol">generate_design_sobol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pset = ps(
  ratio = p_dbl(lower = 0, upper = 1),
  letters = p_fct(levels = letters[1:3])
)
generate_design_grid(pset, 10)
</code></pre>

<hr>
<h2 id='generate_design_lhs'>Generate a Space-Filling LHS Design</h2><span id='topic+generate_design_lhs'></span>

<h3>Description</h3>

<p>Generate a space-filling design using Latin hypercube sampling. Dependent
parameters whose constraints are unsatisfied generate <code>NA</code> entries in
their respective columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_design_lhs(param_set, n, lhs_fun = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_design_lhs_+3A_param_set">param_set</code></td>
<td>
<p>(<code><a href="#topic+ParamSet">ParamSet</a></code>).</p>
</td></tr>
<tr><td><code id="generate_design_lhs_+3A_n">n</code></td>
<td>
<p>(<code>integer(1)</code>) <br />
Number of points to sample.</p>
</td></tr>
<tr><td><code id="generate_design_lhs_+3A_lhs_fun">lhs_fun</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function(n, k)&#8288;</code>)<br />
Function to use to generate a LHS sample, with n samples and k values per param.
LHS functions are implemented in package <span class="pkg">lhs</span>, default is to use <code><a href="lhs.html#topic+maximinLHS">lhs::maximinLHS()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Design">Design</a></code>.
</p>


<h3>See Also</h3>

<p>Other generate_design: 
<code><a href="#topic+generate_design_grid">generate_design_grid</a>()</code>,
<code><a href="#topic+generate_design_random">generate_design_random</a>()</code>,
<code><a href="#topic+generate_design_sobol">generate_design_sobol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pset = ps(
  ratio = p_dbl(lower = 0, upper = 1),
  letters = p_fct(levels = letters[1:3])
)

if (requireNamespace("lhs", quietly = TRUE)) {
  generate_design_lhs(pset, 10)
}
</code></pre>

<hr>
<h2 id='generate_design_random'>Generate a Random Design</h2><span id='topic+generate_design_random'></span>

<h3>Description</h3>

<p>Generates a design with randomly drawn points.
Internally uses <code><a href="#topic+SamplerUnif">SamplerUnif</a></code>, hence, also works for <a href="#topic+ParamSet">ParamSet</a>s with dependencies.
If dependencies do not hold, values are set to <code>NA</code> in the resulting data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_design_random(param_set, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_design_random_+3A_param_set">param_set</code></td>
<td>
<p>(<code><a href="#topic+ParamSet">ParamSet</a></code>).</p>
</td></tr>
<tr><td><code id="generate_design_random_+3A_n">n</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Number of points to draw randomly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Design">Design</a></code>.
</p>


<h3>See Also</h3>

<p>Other generate_design: 
<code><a href="#topic+generate_design_grid">generate_design_grid</a>()</code>,
<code><a href="#topic+generate_design_lhs">generate_design_lhs</a>()</code>,
<code><a href="#topic+generate_design_sobol">generate_design_sobol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pset = ps(
  ratio = p_dbl(lower = 0, upper = 1),
  letters = p_fct(levels = letters[1:3])
)
generate_design_random(pset, 10)
</code></pre>

<hr>
<h2 id='generate_design_sobol'>Generate a Space-Filling Sobol Sequence Design</h2><span id='topic+generate_design_sobol'></span>

<h3>Description</h3>

<p>Generate a space-filling design using a Sobol sequence. Dependent
parameters whose constraints are unsatisfied generate <code>NA</code> entries in
their respective columns.
</p>
<p>Uses <a href="spacefillr.html#topic+generate_sobol_set">spacefillr::generate_sobol_set</a>.
</p>
<p>Note that non determinism is achieved by sampling the seed argument via
<code>sample(.Machine$integer.max, size = 1L)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_design_sobol(param_set, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_design_sobol_+3A_param_set">param_set</code></td>
<td>
<p>(<code><a href="#topic+ParamSet">ParamSet</a></code>).</p>
</td></tr>
<tr><td><code id="generate_design_sobol_+3A_n">n</code></td>
<td>
<p>(<code>integer(1)</code>) <br />
Number of points to sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Design">Design</a></code>.
</p>


<h3>See Also</h3>

<p>Other generate_design: 
<code><a href="#topic+generate_design_grid">generate_design_grid</a>()</code>,
<code><a href="#topic+generate_design_lhs">generate_design_lhs</a>()</code>,
<code><a href="#topic+generate_design_random">generate_design_random</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pset = ps(
  ratio = p_dbl(lower = 0, upper = 1),
  letters = p_fct(levels = letters[1:3])
)

if (requireNamespace("spacefillr", quietly = TRUE)) {
  generate_design_sobol(pset, 10)
}
</code></pre>

<hr>
<h2 id='NO_DEF'>Extra data type for &quot;no default value&quot;</h2><span id='topic+NO_DEF'></span><span id='topic+NoDefault'></span><span id='topic+is_nodefault'></span>

<h3>Description</h3>

<p>Special new data type for no-default.
Not often needed by the end-user, mainly internal.
</p>

<ul>
<li> <p><code>NO_DEF</code>: Singleton object for type, used in <code><a href="#topic+Domain">Domain</a></code> when no default is given.
</p>
</li>
<li> <p><code>is_nodefault()</code>: Is an object the 'no default' object?
</p>
</li></ul>


<hr>
<h2 id='ParamSet'>ParamSet</h2><span id='topic+ParamSet'></span>

<h3>Description</h3>

<p>An object representing the space of possible parametrizations of a function or another object.
<code>ParamSet</code>s are used on the side of objects being parameterized, where they function as a configuration space determining the set of possible configurations accepted by these objects.
They can also be used to specify search spaces for optimization, indicating the set of legal configurations to try out.
It is often convenient to generate search spaces from configuration spaces, which can be done using the <code style="white-space: pre;">&#8288;$search_space()&#8288;</code> method in combination with <code>to_tune()</code> / <code><a href="#topic+TuneToken">TuneToken</a></code> objects.
</p>
<p>Individual dimensions of a <code>ParamSet</code> are specified by <code><a href="#topic+Domain">Domain</a></code> objects, created as <code><a href="#topic+p_dbl">p_dbl()</a></code>, <code><a href="#topic+p_lgl">p_lgl()</a></code> etc.
The field <code style="white-space: pre;">&#8288;$values&#8288;</code> can be used to store an active configuration or to partially fix
some parameters to constant values &ndash; the precise effect can be determined by the object being parameterized.
</p>
<p>Constructing a <code>ParamSet</code> can be done using <code>ParamSet$new()</code> in combination with a named list of <code><a href="#topic+Domain">Domain</a></code> objects.
This route is recommended when the set of dimensions (i.e. the members of this named list) is dynamically created, such as when the number of parameters is variable.
<code>ParamSet</code>s can also be created using the <code><a href="#topic+ps">ps()</a></code> shorthand, which is the recommended way when the set of parameters is fixed.
In practice, the majority of cases where a <code>ParamSet</code> is created, the <code><a href="#topic+ps">ps()</a></code> should be used.
</p>


<h3>S3 methods and type converters</h3>


<ul>
<li> <p><code>as.data.table()</code><br />
<code>ParamSet</code> -&gt; <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code><br />
Compact representation as datatable. Col types are:<br />
</p>

<ul>
<li><p> id: character
</p>
</li>
<li><p> class: character
</p>
</li>
<li><p> lower, upper: numeric
</p>
</li>
<li><p> levels: list col, with NULL elements
</p>
</li>
<li><p> nlevels: integer valued numeric
</p>
</li>
<li><p> is_bounded: logical
</p>
</li>
<li><p> special_vals: list col of list
</p>
</li>
<li><p> default: list col
</p>
</li>
<li><p> storage_type: character
</p>
</li>
<li><p> tags: list col of character vectors
</p>
</li></ul>

</li></ul>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>assert_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Should values be checked for validity during assigment to active binding <code style="white-space: pre;">&#8288;$values&#8288;</code>?
Default is <code>TRUE</code>, only switch this off if you know what you are doing.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>data</code></dt><dd><p>(<code>data.table</code>) <code>data.table</code> representation of the <code>ParamSet</code>.</p>
</dd>
<dt><code>values</code></dt><dd><p>(named <code>list()</code>)<br />
Currently set / fixed parameter values.
Settable, and feasibility of values will be checked when you set them.
You do not have to set values for all parameters, but only for a subset.
When you set values, all previously set values will be unset / removed.</p>
</dd>
<dt><code>tags</code></dt><dd><p>(named <code>list()</code> of <code>character()</code>)<br />
Can be used to group and subset parameters.
Named with parameter IDs.</p>
</dd>
<dt><code>params</code></dt><dd><p>(named <code>list()</code>)<br />
<code>data.table</code> representing the combined <code><a href="#topic+Domain">Domain</a></code> objects used to construct the <code><a href="#topic+ParamSet">ParamSet</a></code>.
Used for internal purpuses.
Its use by external code is deprecated.</p>
</dd>
<dt><code>domains</code></dt><dd><p>(named <code>list</code> of <code><a href="#topic+Domain">Domain</a></code>)
List of <code><a href="#topic+Domain">Domain</a></code> objects that could be used to initialize this <code>ParamSet</code>.</p>
</dd>
<dt><code>extra_trafo</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function(x, param_set)&#8288;</code>)<br />
Transformation function. Settable.
User has to pass a <code style="white-space: pre;">&#8288;function(x)&#8288;</code>, of the form<br />
(named <code>list()</code>, <a href="#topic+ParamSet">ParamSet</a>) -&gt; named <code>list()</code>.<br />
The function is responsible to transform a feasible configuration into another encoding,
before potentially evaluating the configuration with the target algorithm.
For the output, not many things have to hold.
It needs to have unique names, and the target algorithm has to accept the configuration.
For convenience, the self-paramset is also passed in, if you need some info from it (e.g. tags).
Is NULL by default, and you can set it to NULL to switch the transformation off.</p>
</dd>
<dt><code>constraint</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function(x)&#8288;</code>)<br />
Constraint function. Settable.
This function must evaluate a named <code>list()</code> of values and determine whether it satisfies
constraints, returning a scalar <code>logical(1)</code> value.</p>
</dd>
<dt><code>deps</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Table has cols <code>id</code> (<code>character(1)</code>) and <code>on</code> (<code>character(1)</code>) and <code>cond</code> (<a href="#topic+Condition">Condition</a>).
Lists all (direct) dependency parents of a param, through parameter IDs.
Internally created by a call to <code>add_dep</code>.
Settable, if you want to remove dependencies or perform other changes.</p>
</dd>
<dt><code>length</code></dt><dd><p>(<code>integer(1)</code>)<br /> Number of contained parameters.</p>
</dd>
<dt><code>is_empty</code></dt><dd><p>(<code>logical(1)</code>)<br /> Is the <code>ParamSet</code> empty? Named with parameter IDs.</p>
</dd>
<dt><code>has_trafo</code></dt><dd><p>(<code>logical(1)</code>)<br /> Whether a <code>trafo</code> function is present, in parameters or in <code>extra_trafo</code>.</p>
</dd>
<dt><code>has_extra_trafo</code></dt><dd><p>(<code>logical(1)</code>)<br /> Whether <code>extra_trafo</code> is set.</p>
</dd>
<dt><code>has_deps</code></dt><dd><p>(<code>logical(1)</code>)<br /> Whether the parameter dependencies are present</p>
</dd>
<dt><code>has_constraint</code></dt><dd><p>(<code>logical(1)</code>)<br /> Whether parameter constraint is set.</p>
</dd>
<dt><code>all_numeric</code></dt><dd><p>(<code>logical(1)</code>)<br /> Is <code>TRUE</code> if all parameters are <code><a href="#topic+p_dbl">p_dbl()</a></code> or <code><a href="#topic+p_int">p_int()</a></code>.</p>
</dd>
<dt><code>all_categorical</code></dt><dd><p>(<code>logical(1)</code>)<br /> Is <code>TRUE</code> if all parameters are <code><a href="#topic+p_fct">p_fct()</a></code> and <code><a href="#topic+p_lgl">p_lgl()</a></code>.</p>
</dd>
<dt><code>all_bounded</code></dt><dd><p>(<code>logical(1)</code>)<br /> Is <code>TRUE</code> if all parameters are bounded.</p>
</dd>
<dt><code>class</code></dt><dd><p>(named <code>character()</code>)<br /> Classes of contained parameters. Named with parameter IDs.</p>
</dd>
<dt><code>lower</code></dt><dd><p>(named <code>double()</code>)<br /> Lower bounds of numeric parameters (<code>NA</code> for non-numerics). Named with parameter IDs.</p>
</dd>
<dt><code>upper</code></dt><dd><p>(named <code>double()</code>)<br /> Upper bounds of numeric parameters (<code>NA</code> for non-numerics). Named with parameter IDs.</p>
</dd>
<dt><code>levels</code></dt><dd><p>(named <code>list()</code> of <code>character</code>)<br /> Allowed levels of categorical parameters (<code>NULL</code> for non-categoricals).
Named with parameter IDs.</p>
</dd>
<dt><code>storage_type</code></dt><dd><p>(<code>character()</code>)<br /> Data types of parameters when stored in tables. Named with parameter IDs.</p>
</dd>
<dt><code>special_vals</code></dt><dd><p>(named <code>list()</code> of <code>list()</code>)<br /> Special values for all parameters. Named with parameter IDs.</p>
</dd>
<dt><code>default</code></dt><dd><p>(named <code>list()</code>)<br /> Default values of all parameters. If no default exists, element is not present.
Named with parameter IDs.</p>
</dd>
<dt><code>has_trafo_param</code></dt><dd><p>(<code>logical()</code>)<br /> Whether <code>trafo</code> is set for any parameter.</p>
</dd>
<dt><code>is_logscale</code></dt><dd><p>(<code>logical()</code>)<br /> Whether <code>trafo</code> was set to <code>logscale</code> during construction.<br />
Note that this only refers to the <code>logscale</code> flag set during construction, e.g. <code>p_dbl(logscale = TRUE)</code>.
If the parameter was set to logscale manually, e.g. through <code>p_dbl(trafo = exp)</code>,
this <code>is_logscale</code> will be <code>FALSE</code>.</p>
</dd>
<dt><code>nlevels</code></dt><dd><p>(named <code>integer()</code>)<br /> Number of distinct levels of parameters. <code>Inf</code> for double parameters or unbounded integer parameters.
Named with param IDs.</p>
</dd>
<dt><code>is_number</code></dt><dd><p>(named <code>logical()</code>)<br /> Whether parameter is <code><a href="#topic+p_dbl">p_dbl()</a></code> or <code><a href="#topic+p_int">p_int()</a></code>. Named with parameter IDs.</p>
</dd>
<dt><code>is_categ</code></dt><dd><p>(named <code>logical()</code>)<br /> Whether parameter is <code><a href="#topic+p_fct">p_fct()</a></code> or <code><a href="#topic+p_lgl">p_lgl()</a></code>. Named with parameter IDs.</p>
</dd>
<dt><code>is_bounded</code></dt><dd><p>(named <code>logical()</code>)<br /> Whether parameters have finite bounds. Named with parameter IDs.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ParamSet-new"><code>ParamSet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-ids"><code>ParamSet$ids()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-get_values"><code>ParamSet$get_values()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-set_values"><code>ParamSet$set_values()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-trafo"><code>ParamSet$trafo()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-aggr_internal_tuned_values"><code>ParamSet$aggr_internal_tuned_values()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-disable_internal_tuning"><code>ParamSet$disable_internal_tuning()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-convert_internal_search_space"><code>ParamSet$convert_internal_search_space()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-test_constraint"><code>ParamSet$test_constraint()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-test_constraint_dt"><code>ParamSet$test_constraint_dt()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-check"><code>ParamSet$check()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-check_dependencies"><code>ParamSet$check_dependencies()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-test"><code>ParamSet$test()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-assert"><code>ParamSet$assert()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-check_dt"><code>ParamSet$check_dt()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-test_dt"><code>ParamSet$test_dt()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-assert_dt"><code>ParamSet$assert_dt()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-qunif"><code>ParamSet$qunif()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-get_domain"><code>ParamSet$get_domain()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-subset"><code>ParamSet$subset()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-subspaces"><code>ParamSet$subspaces()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-flatten"><code>ParamSet$flatten()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-search_space"><code>ParamSet$search_space()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-add_dep"><code>ParamSet$add_dep()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-format"><code>ParamSet$format()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-print"><code>ParamSet$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSet-clone"><code>ParamSet$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ParamSet-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$new(params = named_list(), allow_dangling_dependencies = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>(named <code>list()</code>)<br />
List of <code><a href="#topic+Domain">Domain</a></code>, named with their respective ID.</p>
</dd>
<dt><code>allow_dangling_dependencies</code></dt><dd><p>(<code>character(1)</code>)<br />
Whether dependencies depending on parameters that are not present should be allowed. A parameter <code>x</code> having
<code>depends = y == 0</code> if <code>y</code> is not present would usually throw an error, but if dangling
dependencies are allowed, the dependency is added regardless. This is mainly for internal
use.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ParamSet-ids"></a>



<h4>Method <code>ids()</code></h4>

<p>Retrieves IDs of contained parameters based on some filter criteria
selections, <code>NULL</code> means no restriction.
Only returns IDs of parameters that satisfy all conditions.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$ids(class = NULL, tags = NULL, any_tags = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>(<code>character()</code>)<br />
Typically a subset of <code>"ParamDbl"</code>, <code>"ParamInt"</code>, <code>"ParamFct"</code>, <code>"ParamLgl"</code>, <code>"ParamUty"</code>.
Other classes are possible if implemented by 3rd party packages.
Return only IDs of dimensions with the given class.</p>
</dd>
<dt><code>tags</code></dt><dd><p>(<code>character()</code>).
Return only IDs of dimensions that have <em>all</em> tags given in this argument.</p>
</dd>
<dt><code>any_tags</code></dt><dd><p>(<code>character()</code>).
Return only IDs of dimensions that have at least one of the tags given in this argument.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>character()</code>.
</p>


<hr>
<a id="method-ParamSet-get_values"></a>



<h4>Method <code>get_values()</code></h4>

<p>Retrieves parameter values based on some selections, <code>NULL</code> means no
restriction and is equivalent to <code style="white-space: pre;">&#8288;$values&#8288;</code>.
Only returns values of parameters that satisfy all conditions.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$get_values(
  class = NULL,
  tags = NULL,
  any_tags = NULL,
  type = "with_token",
  check_required = TRUE,
  remove_dependencies = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class</code></dt><dd><p>(<code>character()</code>). See <code style="white-space: pre;">&#8288;$ids()&#8288;</code>.</p>
</dd>
<dt><code>tags</code></dt><dd><p>(<code>character()</code>). See <code style="white-space: pre;">&#8288;$ids()&#8288;</code>.</p>
</dd>
<dt><code>any_tags</code></dt><dd><p>(<code>character()</code>). See <code style="white-space: pre;">&#8288;$ids()&#8288;</code>.</p>
</dd>
<dt><code>type</code></dt><dd><p>(<code>character(1)</code>)<br />
Return values <code>"with_token"</code> (i.e. all values),</p>
</dd>
<dt><code>check_required</code></dt><dd><p>(<code>logical(1)</code>)<br />
Check if all required parameters are set?</p>
</dd>
<dt><code>remove_dependencies</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, set values with dependencies that are not fulfilled to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Named <code>list()</code>.
</p>


<hr>
<a id="method-ParamSet-set_values"></a>



<h4>Method <code>set_values()</code></h4>

<p>Allows to to modify (and overwrite) or replace the parameter values.
Per default already set values are being kept unless new values are being provided.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$set_values(..., .values = list(), .insert = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(any)<br />
Named parameter values.</p>
</dd>
<dt><code>.values</code></dt><dd><p>(named <code>list()</code>)<br />
Named list with parameter values. Names must not already appear in <code>...</code>.</p>
</dd>
<dt><code>.insert</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to insert the values (old values are being kept, if not overwritten), or to
replace all values. Default is TRUE.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ParamSet-trafo"></a>



<h4>Method <code>trafo()</code></h4>

<p>Perform transformation specified by the <code>trafo</code> of <code><a href="#topic+Domain">Domain</a></code> objects, as well as the <code style="white-space: pre;">&#8288;$extra_trafo&#8288;</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$trafo(x, param_set = self)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>(named <code>list()</code> | <code>data.frame</code>)<br />
The value(s) to be transformed.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code>ParamSet</code>)<br />
Passed to <code>extra_trafo()</code>. Note that the <code>extra_trafo</code> of <code>self</code> is used, not the <code>extra_trafo</code> of the
<code>ParamSet</code> given in the <code>param_set</code> argument.
In almost all cases, the default <code>param_set = self</code> should be used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ParamSet-aggr_internal_tuned_values"></a>



<h4>Method <code>aggr_internal_tuned_values()</code></h4>

<p>Aggregate parameter values according to their aggregation rules.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$aggr_internal_tuned_values(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>(named <code>list()</code> of <code>list()</code>s)<br />
The value(s) to be aggregated. Names are parameter values.
The aggregation function is selected based on the parameter.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(named <code>list()</code>)
</p>


<hr>
<a id="method-ParamSet-disable_internal_tuning"></a>



<h4>Method <code>disable_internal_tuning()</code></h4>

<p>Set the parameter values so that internal tuning for the selected parameters is disabled.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$disable_internal_tuning(ids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ids</code></dt><dd><p>(<code>character()</code>)<br />
The ids of the parameters for which to disable internal tuning.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>Self</code>
</p>


<hr>
<a id="method-ParamSet-convert_internal_search_space"></a>



<h4>Method <code>convert_internal_search_space()</code></h4>

<p>Convert all parameters from the search space to parameter values using the transformation given by
<code>in_tune_fn</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$convert_internal_search_space(search_space)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>search_space</code></dt><dd><p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
The internal search space.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(named <code>list()</code>)
</p>


<hr>
<a id="method-ParamSet-test_constraint"></a>



<h4>Method <code>test_constraint()</code></h4>

<p><span class="pkg">checkmate</span>-like test-function. Takes a named list.
Return <code>FALSE</code> if the given <code style="white-space: pre;">&#8288;$constraint&#8288;</code> is not satisfied, <code>TRUE</code> otherwise.
Note this is different from satisfying the bounds or types given by the <code>ParamSet</code> itself:
If <code>x</code> does not satisfy these, an error will be thrown, given that <code>assert_value</code> is <code>TRUE</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$test_constraint(x, assert_value = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>(named <code>list()</code>)<br />
The value to test.</p>
</dd>
<dt><code>assert_value</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to verify that <code>x</code> satisfies the bounds and types given by this <code>ParamSet</code>.
Should be <code>TRUE</code> unless this was already checked before.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>: Whether <code>x</code> satisfies the <code style="white-space: pre;">&#8288;$constraint&#8288;</code>.
</p>


<hr>
<a id="method-ParamSet-test_constraint_dt"></a>



<h4>Method <code>test_constraint_dt()</code></h4>

<p><span class="pkg">checkmate</span>-like test-function. Takes a <code><a href="data.table.html#topic+data.table">data.table</a></code>.
For each row, return <code>FALSE</code> if the given <code style="white-space: pre;">&#8288;$constraint&#8288;</code> is not satisfied, <code>TRUE</code> otherwise.
Note this is different from satisfying the bounds or types given by the <code>ParamSet</code> itself:
If <code>x</code> does not satisfy these, an error will be thrown, given that <code>assert_value</code> is <code>TRUE</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$test_constraint_dt(x, assert_value = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>(<code>data.table</code>)<br />
The values to test.</p>
</dd>
<dt><code>assert_value</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to verify that <code>x</code> satisfies the bounds and types given by this <code>ParamSet</code>.
Should be <code>TRUE</code> unless this was already checked before.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical</code>: For each row in <code>x</code>, whether it satisfies the <code style="white-space: pre;">&#8288;$constraint&#8288;</code>.
</p>


<hr>
<a id="method-ParamSet-check"></a>



<h4>Method <code>check()</code></h4>

<p><span class="pkg">checkmate</span>-like check-function. Takes a named list.
A point x is feasible, if it configures a subset of params,
all individual param constraints are satisfied and all dependencies are satisfied.
Params for which dependencies are not satisfied should not be part of <code>x</code>.
Constraints and dependencies are not checked when <code>check_strict</code> is <code>FALSE</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$check(xs, check_strict = TRUE, sanitize = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xs</code></dt><dd><p>(named <code>list()</code>).</p>
</dd>
<dt><code>check_strict</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to check that constraints and dependencies are satisfied.</p>
</dd>
<dt><code>sanitize</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to move values that are slightly outside bounds to valid values.
These values are accepted independent of <code>sanitize</code> (depending on the
<code>tolerance</code> arguments of <code>p_dbl()</code> and <code>p_int()</code>) . If <code>sanitize</code>
is <code>TRUE</code>, the additional effect is that, should checks pass, the
sanitized values of <code>xs</code> are added to the result as attribute <code>"sanitized"</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If successful <code>TRUE</code>, if not a string with an error message.
</p>


<hr>
<a id="method-ParamSet-check_dependencies"></a>



<h4>Method <code>check_dependencies()</code></h4>

<p><span class="pkg">checkmate</span>-like check-function. Takes a named list.
Checks that all individual param dependencies are satisfied.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$check_dependencies(xs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xs</code></dt><dd><p>(named <code>list()</code>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If successful <code>TRUE</code>, if not a string with an error message.
</p>


<hr>
<a id="method-ParamSet-test"></a>



<h4>Method <code>test()</code></h4>

<p><span class="pkg">checkmate</span>-like test-function. Takes a named list.
A point x is feasible, if it configures a subset of params,
all individual param constraints are satisfied and all dependencies are satisfied.
Params for which dependencies are not satisfied should not be part of <code>x</code>.
Constraints and dependencies are not checked when <code>check_strict</code> is <code>FALSE</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$test(xs, check_strict = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xs</code></dt><dd><p>(named <code>list()</code>).</p>
</dd>
<dt><code>check_strict</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to check that constraints and dependencies are satisfied.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If successful <code>TRUE</code>, if not <code>FALSE</code>.
</p>


<hr>
<a id="method-ParamSet-assert"></a>



<h4>Method <code>assert()</code></h4>

<p><span class="pkg">checkmate</span>-like assert-function. Takes a named list.
A point x is feasible, if it configures a subset of params,
all individual param constraints are satisfied and all dependencies are satisfied.
Params for which dependencies are not satisfied should not be part of <code>x</code>.
Constraints and dependencies are not checked when <code>check_strict</code> is <code>FALSE</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$assert(
  xs,
  check_strict = TRUE,
  .var.name = vname(xs),
  sanitize = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xs</code></dt><dd><p>(named <code>list()</code>).</p>
</dd>
<dt><code>check_strict</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to check that constraints and dependencies are satisfied.</p>
</dd>
<dt><code>.var.name</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the checked object to print in error messages.<br />
Defaults to the heuristic implemented in <a href="checkmate.html#topic+vname">vname</a>.</p>
</dd>
<dt><code>sanitize</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to move values that are slightly outside bounds to valid values.
These values are accepted independent of <code>sanitize</code> (depending on the
<code>tolerance</code> arguments of <code>p_dbl()</code> and <code>p_int()</code>) . If <code>sanitize</code>
is <code>TRUE</code>, the additional effect is that <code>xs</code> is converted to within bounds.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If successful <code>xs</code> invisibly, if not an error message.
</p>


<hr>
<a id="method-ParamSet-check_dt"></a>



<h4>Method <code>check_dt()</code></h4>

<p><span class="pkg">checkmate</span>-like check-function. Takes a <a href="data.table.html#topic+data.table">data.table::data.table</a>
where rows are points and columns are parameters.
A point x is feasible, if it configures a subset of params,
all individual param constraints are satisfied and all dependencies are satisfied.
Params for which dependencies are not satisfied should not be part of <code>x</code>.
Constraints and dependencies are not checked when <code>check_strict</code> is <code>FALSE</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$check_dt(xdt, check_strict = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a> | <code>data.frame()</code>).</p>
</dd>
<dt><code>check_strict</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to check that constraints and dependencies are satisfied.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If successful <code>TRUE</code>, if not a string with the error message.
</p>


<hr>
<a id="method-ParamSet-test_dt"></a>



<h4>Method <code>test_dt()</code></h4>

<p><span class="pkg">checkmate</span>-like test-function (s. <code style="white-space: pre;">&#8288;$check_dt()&#8288;</code>).
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$test_dt(xdt, check_strict = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>).</p>
</dd>
<dt><code>check_strict</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to check that constraints and dependencies are satisfied.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If successful <code>TRUE</code>, if not <code>FALSE</code>.
</p>


<hr>
<a id="method-ParamSet-assert_dt"></a>



<h4>Method <code>assert_dt()</code></h4>

<p><span class="pkg">checkmate</span>-like assert-function (s. <code style="white-space: pre;">&#8288;$check_dt()&#8288;</code>).
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$assert_dt(xdt, check_strict = TRUE, .var.name = vname(xdt))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>).</p>
</dd>
<dt><code>check_strict</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to check that constraints and dependencies are satisfied.</p>
</dd>
<dt><code>.var.name</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the checked object to print in error messages.<br />
Defaults to the heuristic implemented in <a href="checkmate.html#topic+vname">vname</a>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If successful <code>xs</code> invisibly, if not, an error is generated.
</p>


<hr>
<a id="method-ParamSet-qunif"></a>



<h4>Method <code>qunif()</code></h4>

<p>Map a <code>matrix</code> or <code>data.frame</code> of values between 0 and 1 to proportional values inside the feasible intervals of individual parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$qunif(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>(<code>matrix</code> | <code>data.frame</code>)<br />
Values to map. Column names must be a subset of the names of parameters.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.table</code>.
</p>


<hr>
<a id="method-ParamSet-get_domain"></a>



<h4>Method <code>get_domain()</code></h4>

<p>get the <code><a href="#topic+Domain">Domain</a></code> object that could be used to create a given parameter.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$get_domain(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="#topic+Domain">Domain</a></code>.
</p>


<hr>
<a id="method-ParamSet-subset"></a>



<h4>Method <code>subset()</code></h4>

<p>Create a new <code>ParamSet</code> restricted to the passed IDs.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$subset(
  ids,
  allow_dangling_dependencies = FALSE,
  keep_constraint = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ids</code></dt><dd><p>(<code>character()</code>).</p>
</dd>
<dt><code>allow_dangling_dependencies</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to allow subsets that cut across parameter dependencies.
Dependencies that point to dropped parameters are kept (but will be &quot;dangling&quot;, i.e. their <code>"on"</code> will not be present).</p>
</dd>
<dt><code>keep_constraint</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to keep the <code style="white-space: pre;">&#8288;$constraint&#8288;</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>ParamSet</code>.
</p>


<hr>
<a id="method-ParamSet-subspaces"></a>



<h4>Method <code>subspaces()</code></h4>

<p>Create new one-dimensional <code>ParamSet</code>s for each dimension.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$subspaces(ids = private$.params$id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ids</code></dt><dd><p>(<code>character()</code>)<br />
IDs for which to create <code>ParamSet</code>s. Defaults to all IDs.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>named <code>list()</code> of <code>ParamSet</code>.
</p>


<hr>
<a id="method-ParamSet-flatten"></a>



<h4>Method <code>flatten()</code></h4>

<p>Create a <code>ParamSet</code> from this object, even if this object itself is not
a <code>ParamSet</code> but e.g. a <code><a href="#topic+ParamSetCollection">ParamSetCollection</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$flatten()</pre></div>


<hr>
<a id="method-ParamSet-search_space"></a>



<h4>Method <code>search_space()</code></h4>

<p>Construct a <code><a href="#topic+ParamSet">ParamSet</a></code> to tune over. Constructed from <code><a href="#topic+TuneToken">TuneToken</a></code> in <code style="white-space: pre;">&#8288;$values&#8288;</code>, see <code><a href="#topic+to_tune">to_tune()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$search_space(values = self$values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>values</code></dt><dd><p>(<code style="white-space: pre;">&#8288;named list&#8288;</code>): optional named list of <code><a href="#topic+TuneToken">TuneToken</a></code> objects to convert, in place of <code style="white-space: pre;">&#8288;$values&#8288;</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ParamSet-add_dep"></a>



<h4>Method <code>add_dep()</code></h4>

<p>Adds a dependency to this set, so that param <code>id</code> now depends on param <code>on</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$add_dep(id, on, cond, allow_dangling_dependencies = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>).</p>
</dd>
<dt><code>on</code></dt><dd><p>(<code>character(1)</code>).</p>
</dd>
<dt><code>cond</code></dt><dd><p>(<a href="#topic+Condition">Condition</a>).</p>
</dd>
<dt><code>allow_dangling_dependencies</code></dt><dd><p>(<code>logical(1)</code>): Whether to allow dependencies on parameters that are not present.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ParamSet-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$format()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ParamSet-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$print(
  ...,
  hide_cols = c("levels", "is_bounded", "special_vals", "tags", "storage_type")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
<dt><code>hide_cols</code></dt><dd><p>(<code>character()</code>)<br />
Which fields should not be printed? Default is <code>"levels"</code>,
<code>"is_bounded"</code>, <code>"special_vals"</code>, <code>"tags"</code>, and <code>"storage_type"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ParamSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>pset = ParamSet$new(
  params = list(
    d = p_dbl(lower = -5, upper = 5, default = 0, trafo = function(x) 2^x),
    f = p_fct(levels = letters[1:3])
  )
)

# alternative, recommended way of construction in this case since the
# parameter list is not dynamic:
pset = ps(
  d = p_dbl(lower = -5, upper = 5, default = 0, trafo = function(x) 2^x),
  f = p_fct(levels = letters[1:3])
)

pset$check(list(d = 2.1, f = "a"))

pset$check(list(d = 2.1, f = "d"))
</code></pre>

<hr>
<h2 id='ParamSetCollection'>ParamSetCollection</h2><span id='topic+ParamSetCollection'></span>

<h3>Description</h3>

<p>A collection of multiple <code><a href="#topic+ParamSet">ParamSet</a></code> objects.
</p>

<ul>
<li><p> The collection is basically a light-weight wrapper / container around references to multiple sets.
</p>
</li>
<li><p> In order to ensure unique param names, every param in the collection is referred to with
&quot;&lt;set_id&gt;.&lt;param_id&gt;&quot;, where <code style="white-space: pre;">&#8288;&lt;set_id&gt;&#8288;</code> is the name of the entry a given <code><a href="#topic+ParamSet">ParamSet</a></code> in the named list given during construction.
Parameters from <code><a href="#topic+ParamSet">ParamSet</a></code> with empty (i.e. <code>""</code>) <code>set_id</code> are referenced
directly. Multiple <code><a href="#topic+ParamSet">ParamSet</a></code>s with <code>set_id</code> <code>""</code> can be combined, but their parameter names
may not overlap to avoid name clashes.
</p>
</li>
<li><p> When you either ask for 'values' or set them, the operation is delegated to the individual,
contained <code><a href="#topic+ParamSet">ParamSet</a></code> references. The collection itself does not maintain a <code>values</code> state.
This also implies that if you directly change <code>values</code> in one of the referenced sets,
this change is reflected in the collection.
</p>
</li>
<li><p> Dependencies: It is possible to currently handle dependencies
</p>

<ul>
<li><p> regarding parameters inside of the same set - in this case simply
add the dependency to the set, best before adding the set to the collection
</p>
</li>
<li><p> across sets, where a param from one set depends on the state
of a param from another set - in this case add call <code>add_dep</code> on the collection.
</p>
</li></ul>

<p>If you call <code>deps</code> on the collection, you are returned a complete table of dependencies, from sets and across sets.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="#topic+ParamSet">paradox::ParamSet</a></code> -&gt; <code>ParamSetCollection</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>deps</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>)<br />
Table has cols <code>id</code> (<code>character(1)</code>) and <code>on</code> (<code>character(1)</code>) and <code>cond</code> (<a href="#topic+Condition">Condition</a>).
Lists all (direct) dependency parents of a param, through parameter IDs.
Internally created by a call to <code>add_dep</code>.
Settable, if you want to remove dependencies or perform other changes.</p>
</dd>
<dt><code>extra_trafo</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function(x, param_set)&#8288;</code>)<br />
Transformation function. Settable.
User has to pass a <code style="white-space: pre;">&#8288;function(x)&#8288;</code>, of the form<br />
(named <code>list()</code>, <a href="#topic+ParamSet">ParamSet</a>) -&gt; named <code>list()</code>.<br />
The function is responsible to transform a feasible configuration into another encoding,
before potentially evaluating the configuration with the target algorithm.
For the output, not many things have to hold.
It needs to have unique names, and the target algorithm has to accept the configuration.
For convenience, the self-paramset is also passed in, if you need some info from it (e.g. tags).
Is NULL by default, and you can set it to NULL to switch the transformation off.</p>
</dd>
<dt><code>constraint</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function(x)&#8288;</code>)<br />
Constraint function. Settable.
This function must evaluate a named <code>list()</code> of values and determine whether it satisfies
constraints, returning a scalar <code>logical(1)</code> value.</p>
</dd>
<dt><code>sets</code></dt><dd><p>(named <code>list()</code>)<br />
Read-only <code>list</code> of of <code><a href="#topic+ParamSet">ParamSet</a></code>s contained in this <code>ParamSetCollection</code>.
This field provides direct references to the <code><a href="#topic+ParamSet">ParamSet</a></code> objects.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ParamSetCollection-new"><code>ParamSetCollection$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSetCollection-add"><code>ParamSetCollection$add()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSetCollection-disable_internal_tuning"><code>ParamSetCollection$disable_internal_tuning()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSetCollection-convert_internal_search_space"><code>ParamSetCollection$convert_internal_search_space()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSetCollection-flatten"><code>ParamSetCollection$flatten()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSetCollection-clone"><code>ParamSetCollection$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="add_dep"><a href='../../paradox/html/ParamSet.html#method-ParamSet-add_dep'><code>paradox::ParamSet$add_dep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="aggr_internal_tuned_values"><a href='../../paradox/html/ParamSet.html#method-ParamSet-aggr_internal_tuned_values'><code>paradox::ParamSet$aggr_internal_tuned_values()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="assert"><a href='../../paradox/html/ParamSet.html#method-ParamSet-assert'><code>paradox::ParamSet$assert()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="assert_dt"><a href='../../paradox/html/ParamSet.html#method-ParamSet-assert_dt'><code>paradox::ParamSet$assert_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="check"><a href='../../paradox/html/ParamSet.html#method-ParamSet-check'><code>paradox::ParamSet$check()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="check_dependencies"><a href='../../paradox/html/ParamSet.html#method-ParamSet-check_dependencies'><code>paradox::ParamSet$check_dependencies()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="check_dt"><a href='../../paradox/html/ParamSet.html#method-ParamSet-check_dt'><code>paradox::ParamSet$check_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="format"><a href='../../paradox/html/ParamSet.html#method-ParamSet-format'><code>paradox::ParamSet$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="get_domain"><a href='../../paradox/html/ParamSet.html#method-ParamSet-get_domain'><code>paradox::ParamSet$get_domain()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="get_values"><a href='../../paradox/html/ParamSet.html#method-ParamSet-get_values'><code>paradox::ParamSet$get_values()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="ids"><a href='../../paradox/html/ParamSet.html#method-ParamSet-ids'><code>paradox::ParamSet$ids()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="print"><a href='../../paradox/html/ParamSet.html#method-ParamSet-print'><code>paradox::ParamSet$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="qunif"><a href='../../paradox/html/ParamSet.html#method-ParamSet-qunif'><code>paradox::ParamSet$qunif()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="search_space"><a href='../../paradox/html/ParamSet.html#method-ParamSet-search_space'><code>paradox::ParamSet$search_space()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="set_values"><a href='../../paradox/html/ParamSet.html#method-ParamSet-set_values'><code>paradox::ParamSet$set_values()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="subset"><a href='../../paradox/html/ParamSet.html#method-ParamSet-subset'><code>paradox::ParamSet$subset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="subspaces"><a href='../../paradox/html/ParamSet.html#method-ParamSet-subspaces'><code>paradox::ParamSet$subspaces()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="test"><a href='../../paradox/html/ParamSet.html#method-ParamSet-test'><code>paradox::ParamSet$test()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="test_constraint"><a href='../../paradox/html/ParamSet.html#method-ParamSet-test_constraint'><code>paradox::ParamSet$test_constraint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="test_constraint_dt"><a href='../../paradox/html/ParamSet.html#method-ParamSet-test_constraint_dt'><code>paradox::ParamSet$test_constraint_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="test_dt"><a href='../../paradox/html/ParamSet.html#method-ParamSet-test_dt'><code>paradox::ParamSet$test_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="trafo"><a href='../../paradox/html/ParamSet.html#method-ParamSet-trafo'><code>paradox::ParamSet$trafo()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ParamSetCollection-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSetCollection$new(sets, tag_sets = FALSE, tag_params = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sets</code></dt><dd><p>(named <code>list()</code> of <a href="#topic+ParamSet">ParamSet</a>)<br />
ParamSet objects are not cloned.
Names are used as &quot;set_id&quot; for the naming scheme of delegated parameters.</p>
</dd>
<dt><code>tag_sets</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to add tags of the form <code>"set_&lt;set_id&gt;"</code> to each parameter originating from a given <code>ParamSet</code> given with name <code style="white-space: pre;">&#8288;&lt;set_id&gt;&#8288;</code>.</p>
</dd>
<dt><code>tag_params</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to add tags of the form <code>"param_&lt;param_id&gt;"</code> to each parameter with original ID <code style="white-space: pre;">&#8288;&lt;param_id&gt;&#8288;</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ParamSetCollection-add"></a>



<h4>Method <code>add()</code></h4>

<p>Adds a <code><a href="#topic+ParamSet">ParamSet</a></code> to this collection.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSetCollection$add(p, n = "", tag_sets = FALSE, tag_params = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p</code></dt><dd><p>(<a href="#topic+ParamSet">ParamSet</a>).</p>
</dd>
<dt><code>n</code></dt><dd><p>(<code>character(1)</code>)<br />
Name to use. Default <code>""</code>.</p>
</dd>
<dt><code>tag_sets</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to add tags of the form <code>"set_&lt;n&gt;"</code> to the newly added parameters.</p>
</dd>
<dt><code>tag_params</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to add tags of the form <code>"param_&lt;param_id&gt;"</code> to each parameter with original ID <code style="white-space: pre;">&#8288;&lt;param_id&gt;&#8288;</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ParamSetCollection-disable_internal_tuning"></a>



<h4>Method <code>disable_internal_tuning()</code></h4>

<p>Set the parameter values so that internal tuning for the selected parameters is disabled.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSetCollection$disable_internal_tuning(ids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ids</code></dt><dd><p>(<code>character()</code>)<br />
The ids of the parameters for which to disable internal tuning.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>Self</code>
</p>


<hr>
<a id="method-ParamSetCollection-convert_internal_search_space"></a>



<h4>Method <code>convert_internal_search_space()</code></h4>

<p>Convert all parameters from the search space to parameter values using the transformation given by
<code>in_tune_fn</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSetCollection$convert_internal_search_space(search_space)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>search_space</code></dt><dd><p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
The internal search space.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(named <code>list()</code>)
</p>


<hr>
<a id="method-ParamSetCollection-flatten"></a>



<h4>Method <code>flatten()</code></h4>

<p>Create a <code>ParamSet</code> from this <code>ParamSetCollection</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSetCollection$flatten()</pre></div>


<hr>
<a id="method-ParamSetCollection-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSetCollection$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ps'>Construct a ParamSet using Short Forms</h2><span id='topic+ps'></span>

<h3>Description</h3>

<p>The <code>ps()</code> short form constructor uses <code><a href="#topic+Domain">Domain</a></code> objects (<code>p_dbl</code>, <code>p_fct</code>, ...) to construct <code><a href="#topic+ParamSet">ParamSet</a></code>s in a
succinct and readable way.
</p>
<p>For more specifics also see the documentation of <code><a href="#topic+Domain">Domain</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps(
  ...,
  .extra_trafo = NULL,
  .constraint = NULL,
  .allow_dangling_dependencies = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ps_+3A_...">...</code></td>
<td>
<p>(<code><a href="#topic+Domain">Domain</a></code>)<br />
Named arguments of <code><a href="#topic+Domain">Domain</a></code> objects. The <code><a href="#topic+ParamSet">ParamSet</a></code> will be constructed of the given <code><a href="#topic+Domain">Domain</a></code>s,
The names of the arguments will be used as <code style="white-space: pre;">&#8288;$id()&#8288;</code> in the resulting <code><a href="#topic+ParamSet">ParamSet</a></code>.</p>
</td></tr>
<tr><td><code id="ps_+3A_.extra_trafo">.extra_trafo</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function(x, param_set)&#8288;</code>)<br />
Transformation to set the resulting <code><a href="#topic+ParamSet">ParamSet</a></code>'s <code style="white-space: pre;">&#8288;$trafo&#8288;</code> value to. This is in addition to any <code>trafo</code> of
<code><a href="#topic+Domain">Domain</a></code> objects given in <code>...</code>, and will be run <em>after</em> transformations of individual parameters were performed.</p>
</td></tr>
<tr><td><code id="ps_+3A_.constraint">.constraint</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function(x)&#8288;</code>)<br />
Constraint function.
When given, this function must evaluate a named <code>list()</code> of values and determine whether it satisfies
constraints, returning a scalar <code>logical(1)</code> value.</p>
</td></tr>
<tr><td><code id="ps_+3A_.allow_dangling_dependencies">.allow_dangling_dependencies</code></td>
<td>
<p>(<code>logical</code>)<br />
Whether dependencies depending on parameters that are not present should be allowed. A parameter <code>x</code> having
<code>depends = y == 0</code> if <code>y</code> is not present in the <code>ps()</code> call would usually throw an error, but if dangling
dependencies are allowed, the dependency is added regardless. This is usually a bad idea and mainly for internal
use. Dependencies between <code><a href="#topic+ParamSet">ParamSet</a></code>s when using <code><a href="#topic+to_tune">to_tune()</a></code> can be realized using this.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+ParamSet">ParamSet</a></code> object.
</p>


<h3>See Also</h3>

<p>Other ParamSet construction helpers: 
<code><a href="#topic+Domain">Domain</a>()</code>,
<code><a href="#topic+to_tune">to_tune</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pars = ps(
  a = p_int(0, 10),
  b = p_int(upper = 20),
  c = p_dbl(),
  e = p_fct(letters[1:3]),
  f = p_uty(custom_check = checkmate::check_function)
)
print(pars)

pars = ps(
  a = p_dbl(0, 1, trafo = exp),
  b = p_dbl(0, 1, trafo = exp),
  .extra_trafo = function(x, ps) {
    x$c &lt;- x$a + x$b
    x
  }
)

# See how the addition happens after exp()ing:
pars$trafo(list(a = 0, b = 0))

pars$values = list(
  a = to_tune(ps(x = p_int(0, 1),
    .extra_trafo = function(x, param_set) list(a = x$x)
  )),
  # make 'y' depend on 'x', but they are defined in different ParamSets
  # Therefore we need to allow dangling dependencies here.
  b = to_tune(ps(y = p_int(0, 1, depends = x == 1),
    .extra_trafo = function(x, param_set) list(b = x$y),
    .allow_dangling_dependencies = TRUE
  ))
)

pars$search_space()
</code></pre>

<hr>
<h2 id='ps_replicate'>Create a ParamSet by Repeating a Given ParamSet</h2><span id='topic+ps_replicate'></span>

<h3>Description</h3>

<p>Repeat a <code><a href="#topic+ParamSet">ParamSet</a></code> a given number of times and thus create a larger <code><a href="#topic+ParamSet">ParamSet</a></code>.
By default, the resulting parameters are prefixed with the string <code style="white-space: pre;">&#8288;"repX.", where &#8288;</code>X<code style="white-space: pre;">&#8288;counts up from 1. It is also possible to tag parameters by their original name and by their prefix, making grouped retrieval e.g. using&#8288;</code>$get_values()' easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps_replicate(
  set,
  times = length(prefixes),
  prefixes = sprintf("rep%s", seq_len(times)),
  tag_sets = FALSE,
  tag_params = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ps_replicate_+3A_set">set</code></td>
<td>
<p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
<code><a href="#topic+ParamSet">ParamSet</a></code> to use as template.</p>
</td></tr>
<tr><td><code id="ps_replicate_+3A_times">times</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Number of times to repeat <code>set</code>.
Should not be given if <code>prefixes</code> is provided.</p>
</td></tr>
<tr><td><code id="ps_replicate_+3A_prefixes">prefixes</code></td>
<td>
<p>(<code>character</code>)<br />
A <code>character</code> vector indicating the prefixes to use for each repetition of <code>set</code>.
If this is given, <code>times</code> is inferred from <code>length(prefixes)</code> and should not be given separately.
If <code>times</code> is given, this defaults to <code>"repX"</code>, with <code>X</code> counting up from 1.</p>
</td></tr>
<tr><td><code id="ps_replicate_+3A_tag_sets">tag_sets</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to add a tag of the form <code>"set_&lt;prefixes[[i]]&gt;"</code> to each parameter in the result, indicating the repetition each parameter belongs to.</p>
</td></tr>
<tr><td><code id="ps_replicate_+3A_tag_params">tag_params</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to add a tag of the form <code>"param_&lt;id&gt;"</code> to each parameter in the result, indicating the original parameter ID inside <code>set</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>pset = ps(
  i = p_int(),
  z = p_lgl()
)

ps_replicate(pset, 3)

ps_replicate(pset, prefixes = c("first", "last"))

pset$values = list(i = 1, z = FALSE)

psr = ps_replicate(pset, 2, tag_sets = TRUE, tag_params = TRUE)

# observe the effect of tag_sets, tag_params:
psr$tags

# note that values are repeated as well
psr$values

psr$set_values(rep1.i = 10, rep2.z = TRUE)
psr$values

# use `any_tags` to get subset of values.
# `any_tags = ` is preferable to `tags = `, since parameters
# could also have other tags. `tags = ` would require the
# selected params to have the given tags exclusively.

# get all values associated with the original parameter `i`
psr$get_values(any_tags = "param_i")

# get all values associated with the first repetition "rep1"
psr$get_values(any_tags = "set_rep1")
</code></pre>

<hr>
<h2 id='ps_union'>Create a ParamSet from a list of ParamSets</h2><span id='topic+ps_union'></span>

<h3>Description</h3>

<p>This emulates <code>ParamSetCollection$new(sets)</code>, except that the result is a flat <code><a href="#topic+ParamSet">ParamSet</a></code>, not a <code><a href="#topic+ParamSetCollection">ParamSetCollection</a></code>.
The resulting object is decoupled from the input <code><a href="#topic+ParamSet">ParamSet</a></code> objects: Unlike <code><a href="#topic+ParamSetCollection">ParamSetCollection</a></code>, changing <code style="white-space: pre;">&#8288;$values&#8288;</code> of
the resulting object will not change the input <code><a href="#topic+ParamSet">ParamSet</a></code> <code style="white-space: pre;">&#8288;$values&#8288;</code> by reference.
</p>
<p>This emulates <code>ParamSetCollection$new(sets)</code>, which in particular means that the resulting <code><a href="#topic+ParamSet">ParamSet</a></code> has all the <code><a href="#topic+Domain">Domain</a></code>s
from the input <code>sets</code>, but some <code style="white-space: pre;">&#8288;$id&#8288;</code>s are changed: If the <code><a href="#topic+ParamSet">ParamSet</a></code> is given in <code>sets</code> with a name, then the <code><a href="#topic+Domain">Domain</a></code>s will
have their <code style="white-space: pre;">&#8288;&lt;id&gt;&#8288;</code> changed to <code style="white-space: pre;">&#8288;&lt;name in "sets"&gt;.&lt;id&gt;&#8288;</code>. This is also reflected in deps.
</p>
<p>The <code>c()</code> operator, applied to <code><a href="#topic+ParamSet">ParamSet</a></code>s, is a synony for <code>ps_union()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps_union(sets, tag_sets = FALSE, tag_params = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ps_union_+3A_sets">sets</code></td>
<td>
<p>(<code>list</code> of <code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
This may be a named list, in which case non-empty names are prefixed to parameters in the corresponding <code><a href="#topic+ParamSet">ParamSet</a></code>.</p>
</td></tr>
<tr><td><code id="ps_union_+3A_tag_sets">tag_sets</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to add tags of the form <code>"set_&lt;set_id&gt;"</code> to each parameter originating from a given <code>ParamSet</code> given with name <code style="white-space: pre;">&#8288;&lt;name in "sets"&gt;&#8288;</code>.</p>
</td></tr>
<tr><td><code id="ps_union_+3A_tag_params">tag_params</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to add tags of the form <code>"param_&lt;param_id&gt;"</code> to each parameter with original ID <code style="white-space: pre;">&#8288;&lt;param_id&gt;&#8288;</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ps1 = ps(x = p_dbl())
ps1$values = list(x = 1)

ps2 = ps(y = p_lgl())

pu = ps_union(list(ps1, ps2))
# same as:
pu = c(ps1, ps2)

pu

pu$values

pu$values$x = 2
pu$values

# p1 is unchanged:
ps1$values

# Prefixes automatically created for named elements.
# This allows repeating components.
pu2 = c(one = ps1, two = ps1, ps2)
pu2

pu2$values

</code></pre>

<hr>
<h2 id='psc'>Create a ParamSet Collection</h2><span id='topic+psc'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+ParamSetCollection">ParamSetCollection</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psc(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psc_+3A_...">...</code></td>
<td>
<p>(any)<br />
The <code><a href="#topic+ParamSet">ParamSet</a></code>s from which to create the collection.</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+as.data.table'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>data.table</dt><dd><p><code><a href="data.table.html#topic+as.data.table">as.data.table</a></code></p>
</dd>
</dl>

<hr>
<h2 id='Sampler'>Sampler Class</h2><span id='topic+Sampler'></span>

<h3>Description</h3>

<p>This is the abstract base class for sampling objects like <a href="#topic+Sampler1D">Sampler1D</a>, <a href="#topic+SamplerHierarchical">SamplerHierarchical</a> or <a href="#topic+SamplerJointIndep">SamplerJointIndep</a>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
Domain / support of the distribution we want to sample from.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Sampler-new"><code>Sampler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Sampler-sample"><code>Sampler$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-Sampler-format"><code>Sampler$format()</code></a>
</p>
</li>
<li> <p><a href="#method-Sampler-print"><code>Sampler$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Sampler-clone"><code>Sampler$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Sampler-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>
<p>Note that this object is typically constructed via derived classes,
e.g., <a href="#topic+Sampler1D">Sampler1D</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler$new(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
The <code><a href="#topic+ParamSet">ParamSet</a></code> to associated with this <code>Sampler</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Sampler-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Sample <code>n</code> values from the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler$sample(n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>(<code>integer(1)</code>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="#topic+Design">Design</a></code>.
</p>


<hr>
<a id="method-Sampler-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Sampler-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Sampler-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Sampler: 
<code><a href="#topic+Sampler1D">Sampler1D</a></code>,
<code><a href="#topic+Sampler1DCateg">Sampler1DCateg</a></code>,
<code><a href="#topic+Sampler1DNormal">Sampler1DNormal</a></code>,
<code><a href="#topic+Sampler1DRfun">Sampler1DRfun</a></code>,
<code><a href="#topic+Sampler1DUnif">Sampler1DUnif</a></code>,
<code><a href="#topic+SamplerHierarchical">SamplerHierarchical</a></code>,
<code><a href="#topic+SamplerJointIndep">SamplerJointIndep</a></code>,
<code><a href="#topic+SamplerUnif">SamplerUnif</a></code>
</p>

<hr>
<h2 id='Sampler1D'>Sampler1D Class</h2><span id='topic+Sampler1D'></span>

<h3>Description</h3>

<p>1D sampler, abstract base class for Sampler like <a href="#topic+Sampler1DUnif">Sampler1DUnif</a>, <a href="#topic+Sampler1DRfun">Sampler1DRfun</a>,
<a href="#topic+Sampler1DCateg">Sampler1DCateg</a> and <a href="#topic+Sampler1DNormal">Sampler1DNormal</a>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Sampler">paradox::Sampler</a></code> -&gt; <code>Sampler1D</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>param</code></dt><dd><p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
Returns the one-dimensional <code><a href="#topic+ParamSet">ParamSet</a></code> that is sampled from.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Sampler1D-new"><code>Sampler1D$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Sampler1D-clone"><code>Sampler1D$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="format"><a href='../../paradox/html/Sampler.html#method-Sampler-format'><code>paradox::Sampler$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="print"><a href='../../paradox/html/Sampler.html#method-Sampler-print'><code>paradox::Sampler$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="sample"><a href='../../paradox/html/Sampler.html#method-Sampler-sample'><code>paradox::Sampler$sample()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Sampler1D-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>
<p>Note that this object is typically constructed via derived classes,
e.g., <code><a href="#topic+Sampler1DUnif">Sampler1DUnif</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler1D$new(param)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
Domain / support of the distribution we want to sample from.
Must be one-dimensional.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Sampler1D-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler1D$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Sampler: 
<code><a href="#topic+Sampler">Sampler</a></code>,
<code><a href="#topic+Sampler1DCateg">Sampler1DCateg</a></code>,
<code><a href="#topic+Sampler1DNormal">Sampler1DNormal</a></code>,
<code><a href="#topic+Sampler1DRfun">Sampler1DRfun</a></code>,
<code><a href="#topic+Sampler1DUnif">Sampler1DUnif</a></code>,
<code><a href="#topic+SamplerHierarchical">SamplerHierarchical</a></code>,
<code><a href="#topic+SamplerJointIndep">SamplerJointIndep</a></code>,
<code><a href="#topic+SamplerUnif">SamplerUnif</a></code>
</p>

<hr>
<h2 id='Sampler1DCateg'>Sampler1DCateg Class</h2><span id='topic+Sampler1DCateg'></span>

<h3>Description</h3>

<p>Sampling from a discrete distribution, for a <code><a href="#topic+ParamSet">ParamSet</a></code> containing a single <code><a href="#topic+p_fct">p_fct()</a></code> or <code><a href="#topic+p_lgl">p_lgl()</a></code>.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Sampler">paradox::Sampler</a></code> -&gt; <code><a href="#topic+Sampler1D">paradox::Sampler1D</a></code> -&gt; <code>Sampler1DCateg</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>prob</code></dt><dd><p>(<code>numeric()</code> | NULL)<br />
Numeric vector of <code>param$nlevels</code> probabilities.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Sampler1DCateg-new"><code>Sampler1DCateg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Sampler1DCateg-clone"><code>Sampler1DCateg$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="format"><a href='../../paradox/html/Sampler.html#method-Sampler-format'><code>paradox::Sampler$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="print"><a href='../../paradox/html/Sampler.html#method-Sampler-print'><code>paradox::Sampler$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="sample"><a href='../../paradox/html/Sampler.html#method-Sampler-sample'><code>paradox::Sampler$sample()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Sampler1DCateg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler1DCateg$new(param, prob = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
Domain / support of the distribution we want to sample from.
Must be one-dimensional.</p>
</dd>
<dt><code>prob</code></dt><dd><p>(<code>numeric()</code> | NULL)<br />
Numeric vector of <code>param$nlevels</code> probabilities, which is uniform by default.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Sampler1DCateg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler1DCateg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Sampler: 
<code><a href="#topic+Sampler">Sampler</a></code>,
<code><a href="#topic+Sampler1D">Sampler1D</a></code>,
<code><a href="#topic+Sampler1DNormal">Sampler1DNormal</a></code>,
<code><a href="#topic+Sampler1DRfun">Sampler1DRfun</a></code>,
<code><a href="#topic+Sampler1DUnif">Sampler1DUnif</a></code>,
<code><a href="#topic+SamplerHierarchical">SamplerHierarchical</a></code>,
<code><a href="#topic+SamplerJointIndep">SamplerJointIndep</a></code>,
<code><a href="#topic+SamplerUnif">SamplerUnif</a></code>
</p>

<hr>
<h2 id='Sampler1DNormal'>Sampler1DNormal Class</h2><span id='topic+Sampler1DNormal'></span>

<h3>Description</h3>

<p>Normal sampling (potentially truncated) for <code><a href="#topic+p_dbl">p_dbl()</a></code>.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Sampler">paradox::Sampler</a></code> -&gt; <code><a href="#topic+Sampler1D">paradox::Sampler1D</a></code> -&gt; <code><a href="#topic+Sampler1DRfun">paradox::Sampler1DRfun</a></code> -&gt; <code>Sampler1DNormal</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>mean</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Mean parameter of the normal distribution.</p>
</dd>
<dt><code>sd</code></dt><dd><p>(<code>numeric(1)</code>)<br />
SD parameter of the normal distribution.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Sampler1DNormal-new"><code>Sampler1DNormal$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Sampler1DNormal-clone"><code>Sampler1DNormal$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="format"><a href='../../paradox/html/Sampler.html#method-Sampler-format'><code>paradox::Sampler$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="print"><a href='../../paradox/html/Sampler.html#method-Sampler-print'><code>paradox::Sampler$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="sample"><a href='../../paradox/html/Sampler.html#method-Sampler-sample'><code>paradox::Sampler$sample()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Sampler1DNormal-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler1DNormal$new(param, mean = NULL, sd = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
Domain / support of the distribution we want to sample from.
Must be one-dimensional.</p>
</dd>
<dt><code>mean</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Mean parameter of the normal distribution.
Default is <code style="white-space: pre;">&#8288;mean(c(param$lower, param$upper)&#8288;</code>.</p>
</dd>
<dt><code>sd</code></dt><dd><p>(<code>numeric(1)</code>)<br />
SD parameter of the normal distribution.
Default is <code>(param$upper - param$lower)/4</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Sampler1DNormal-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler1DNormal$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Sampler: 
<code><a href="#topic+Sampler">Sampler</a></code>,
<code><a href="#topic+Sampler1D">Sampler1D</a></code>,
<code><a href="#topic+Sampler1DCateg">Sampler1DCateg</a></code>,
<code><a href="#topic+Sampler1DRfun">Sampler1DRfun</a></code>,
<code><a href="#topic+Sampler1DUnif">Sampler1DUnif</a></code>,
<code><a href="#topic+SamplerHierarchical">SamplerHierarchical</a></code>,
<code><a href="#topic+SamplerJointIndep">SamplerJointIndep</a></code>,
<code><a href="#topic+SamplerUnif">SamplerUnif</a></code>
</p>

<hr>
<h2 id='Sampler1DRfun'>Sampler1DRfun Class</h2><span id='topic+Sampler1DRfun'></span>

<h3>Description</h3>

<p>Arbitrary sampling from 1D RNG functions from R.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Sampler">paradox::Sampler</a></code> -&gt; <code><a href="#topic+Sampler1D">paradox::Sampler1D</a></code> -&gt; <code>Sampler1DRfun</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>rfun</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Random number generator function.</p>
</dd>
<dt><code>trunc</code></dt><dd><p>(<code>logical(1)</code>)<br />
<code>TRUE</code> enables naive rejection sampling, so we stay inside of [lower, upper].</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Sampler1DRfun-new"><code>Sampler1DRfun$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Sampler1DRfun-clone"><code>Sampler1DRfun$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="format"><a href='../../paradox/html/Sampler.html#method-Sampler-format'><code>paradox::Sampler$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="print"><a href='../../paradox/html/Sampler.html#method-Sampler-print'><code>paradox::Sampler$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="sample"><a href='../../paradox/html/Sampler.html#method-Sampler-sample'><code>paradox::Sampler$sample()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Sampler1DRfun-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler1DRfun$new(param, rfun, trunc = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
Domain / support of the distribution we want to sample from.
Must be one-dimensional.</p>
</dd>
<dt><code>rfun</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Random number generator function, e.g. <code>rexp</code> to sample from exponential distribution.</p>
</dd>
<dt><code>trunc</code></dt><dd><p>(<code>logical(1)</code>)<br />
<code>TRUE</code> enables naive rejection sampling, so we stay inside of [lower, upper].</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Sampler1DRfun-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler1DRfun$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Sampler: 
<code><a href="#topic+Sampler">Sampler</a></code>,
<code><a href="#topic+Sampler1D">Sampler1D</a></code>,
<code><a href="#topic+Sampler1DCateg">Sampler1DCateg</a></code>,
<code><a href="#topic+Sampler1DNormal">Sampler1DNormal</a></code>,
<code><a href="#topic+Sampler1DUnif">Sampler1DUnif</a></code>,
<code><a href="#topic+SamplerHierarchical">SamplerHierarchical</a></code>,
<code><a href="#topic+SamplerJointIndep">SamplerJointIndep</a></code>,
<code><a href="#topic+SamplerUnif">SamplerUnif</a></code>
</p>

<hr>
<h2 id='Sampler1DUnif'>Sampler1DUnif Class</h2><span id='topic+Sampler1DUnif'></span>

<h3>Description</h3>

<p>Uniform random sampler for arbitrary (bounded) parameters.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Sampler">paradox::Sampler</a></code> -&gt; <code><a href="#topic+Sampler1D">paradox::Sampler1D</a></code> -&gt; <code>Sampler1DUnif</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Sampler1DUnif-new"><code>Sampler1DUnif$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Sampler1DUnif-clone"><code>Sampler1DUnif$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="format"><a href='../../paradox/html/Sampler.html#method-Sampler-format'><code>paradox::Sampler$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="print"><a href='../../paradox/html/Sampler.html#method-Sampler-print'><code>paradox::Sampler$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="sample"><a href='../../paradox/html/Sampler.html#method-Sampler-sample'><code>paradox::Sampler$sample()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Sampler1DUnif-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler1DUnif$new(param)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param</code></dt><dd><p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
Domain / support of the distribution we want to sample from.
Must be one-dimensional.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Sampler1DUnif-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sampler1DUnif$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Sampler: 
<code><a href="#topic+Sampler">Sampler</a></code>,
<code><a href="#topic+Sampler1D">Sampler1D</a></code>,
<code><a href="#topic+Sampler1DCateg">Sampler1DCateg</a></code>,
<code><a href="#topic+Sampler1DNormal">Sampler1DNormal</a></code>,
<code><a href="#topic+Sampler1DRfun">Sampler1DRfun</a></code>,
<code><a href="#topic+SamplerHierarchical">SamplerHierarchical</a></code>,
<code><a href="#topic+SamplerJointIndep">SamplerJointIndep</a></code>,
<code><a href="#topic+SamplerUnif">SamplerUnif</a></code>
</p>

<hr>
<h2 id='SamplerHierarchical'>SamplerHierarchical Class</h2><span id='topic+SamplerHierarchical'></span>

<h3>Description</h3>

<p>Hierarchical sampling for arbitrary param sets with dependencies, where the user specifies 1D samplers per param.
Dependencies are topologically sorted, parameters are then sampled in topological order,
and if dependencies do not hold, values are set to <code>NA</code> in the resulting <code>data.table</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Sampler">paradox::Sampler</a></code> -&gt; <code>SamplerHierarchical</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>samplers</code></dt><dd><p>(<code>list()</code>)<br />
List of <code><a href="#topic+Sampler1D">Sampler1D</a></code> objects that gives a Sampler for each dimension in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SamplerHierarchical-new"><code>SamplerHierarchical$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SamplerHierarchical-clone"><code>SamplerHierarchical$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="format"><a href='../../paradox/html/Sampler.html#method-Sampler-format'><code>paradox::Sampler$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="print"><a href='../../paradox/html/Sampler.html#method-Sampler-print'><code>paradox::Sampler$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="sample"><a href='../../paradox/html/Sampler.html#method-Sampler-sample'><code>paradox::Sampler$sample()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SamplerHierarchical-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>SamplerHierarchical$new(param_set, samplers)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
The <code><a href="#topic+ParamSet">ParamSet</a></code> to associated with this <code>SamplerHierarchical</code>.</p>
</dd>
<dt><code>samplers</code></dt><dd><p>(<code>list()</code>)<br />
List of <code><a href="#topic+Sampler1D">Sampler1D</a></code> objects that gives a Sampler for each dimension in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SamplerHierarchical-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SamplerHierarchical$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Sampler: 
<code><a href="#topic+Sampler">Sampler</a></code>,
<code><a href="#topic+Sampler1D">Sampler1D</a></code>,
<code><a href="#topic+Sampler1DCateg">Sampler1DCateg</a></code>,
<code><a href="#topic+Sampler1DNormal">Sampler1DNormal</a></code>,
<code><a href="#topic+Sampler1DRfun">Sampler1DRfun</a></code>,
<code><a href="#topic+Sampler1DUnif">Sampler1DUnif</a></code>,
<code><a href="#topic+SamplerJointIndep">SamplerJointIndep</a></code>,
<code><a href="#topic+SamplerUnif">SamplerUnif</a></code>
</p>

<hr>
<h2 id='SamplerJointIndep'>SamplerJointIndep Class</h2><span id='topic+SamplerJointIndep'></span>

<h3>Description</h3>

<p>Create joint, independent sampler out of multiple other samplers.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Sampler">paradox::Sampler</a></code> -&gt; <code>SamplerJointIndep</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>samplers</code></dt><dd><p>(<code>list()</code>)<br />
List of <code><a href="#topic+Sampler">Sampler</a></code> objects.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SamplerJointIndep-new"><code>SamplerJointIndep$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SamplerJointIndep-clone"><code>SamplerJointIndep$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="format"><a href='../../paradox/html/Sampler.html#method-Sampler-format'><code>paradox::Sampler$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="print"><a href='../../paradox/html/Sampler.html#method-Sampler-print'><code>paradox::Sampler$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="sample"><a href='../../paradox/html/Sampler.html#method-Sampler-sample'><code>paradox::Sampler$sample()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SamplerJointIndep-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>SamplerJointIndep$new(samplers)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>samplers</code></dt><dd><p>(<code>list()</code>)<br />
List of <code><a href="#topic+Sampler">Sampler</a></code> objects.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SamplerJointIndep-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SamplerJointIndep$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Sampler: 
<code><a href="#topic+Sampler">Sampler</a></code>,
<code><a href="#topic+Sampler1D">Sampler1D</a></code>,
<code><a href="#topic+Sampler1DCateg">Sampler1DCateg</a></code>,
<code><a href="#topic+Sampler1DNormal">Sampler1DNormal</a></code>,
<code><a href="#topic+Sampler1DRfun">Sampler1DRfun</a></code>,
<code><a href="#topic+Sampler1DUnif">Sampler1DUnif</a></code>,
<code><a href="#topic+SamplerHierarchical">SamplerHierarchical</a></code>,
<code><a href="#topic+SamplerUnif">SamplerUnif</a></code>
</p>

<hr>
<h2 id='SamplerUnif'>SamplerUnif Class</h2><span id='topic+SamplerUnif'></span>

<h3>Description</h3>

<p>Uniform random sampling for an arbitrary (bounded) <a href="#topic+ParamSet">ParamSet</a>.
Constructs 1 uniform sampler per parameter, then passes them to <a href="#topic+SamplerHierarchical">SamplerHierarchical</a>.
Hence, also works for <a href="#topic+ParamSet">ParamSet</a>s sets with dependencies.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Sampler">paradox::Sampler</a></code> -&gt; <code><a href="#topic+SamplerHierarchical">paradox::SamplerHierarchical</a></code> -&gt; <code>SamplerUnif</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SamplerUnif-new"><code>SamplerUnif$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SamplerUnif-clone"><code>SamplerUnif$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="format"><a href='../../paradox/html/Sampler.html#method-Sampler-format'><code>paradox::Sampler$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="print"><a href='../../paradox/html/Sampler.html#method-Sampler-print'><code>paradox::Sampler$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="sample"><a href='../../paradox/html/Sampler.html#method-Sampler-sample'><code>paradox::Sampler$sample()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SamplerUnif-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>SamplerUnif$new(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="#topic+ParamSet">ParamSet</a></code>)<br />
The <code><a href="#topic+ParamSet">ParamSet</a></code> to associated with this <code>SamplerUnif</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SamplerUnif-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SamplerUnif$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Sampler: 
<code><a href="#topic+Sampler">Sampler</a></code>,
<code><a href="#topic+Sampler1D">Sampler1D</a></code>,
<code><a href="#topic+Sampler1DCateg">Sampler1DCateg</a></code>,
<code><a href="#topic+Sampler1DNormal">Sampler1DNormal</a></code>,
<code><a href="#topic+Sampler1DRfun">Sampler1DRfun</a></code>,
<code><a href="#topic+Sampler1DUnif">Sampler1DUnif</a></code>,
<code><a href="#topic+SamplerHierarchical">SamplerHierarchical</a></code>,
<code><a href="#topic+SamplerJointIndep">SamplerJointIndep</a></code>
</p>

<hr>
<h2 id='to_tune'>Indicate that a Parameter Value should be Tuned</h2><span id='topic+to_tune'></span><span id='topic+TuneToken'></span>

<h3>Description</h3>

<p><code>to_tune()</code> creates a <code>TuneToken</code> object which can be assigned to the <code style="white-space: pre;">&#8288;$values&#8288;</code> slot of a <code><a href="#topic+ParamSet">ParamSet</a></code> as an
alternative to a concrete value. This indicates that the value is not given directly but should be tuned using
<a href="https://CRAN.R-project.org/package=bbotk"><span class="pkg">bbotk</span></a> or <a href="https://CRAN.R-project.org/package=mlr3tuning"><span class="pkg">mlr3tuning</span></a>. If the thus parameterized object
is invoked directly, without being wrapped by or given to a tuner, it will give an error.
</p>
<p>The tuning range <code><a href="#topic+ParamSet">ParamSet</a></code> that is constructed from the <code>TuneToken</code> values in a <code><a href="#topic+ParamSet">ParamSet</a></code>'s <code style="white-space: pre;">&#8288;$values&#8288;</code> slot
can be accessed through the <code>ParamSet$search_space()</code> method. This is done automatically by tuners if no tuning range
is given, but it is also possible to access the <code style="white-space: pre;">&#8288;$search_space()&#8288;</code> method, modify it further, and give the modified
<code><a href="#topic+ParamSet">ParamSet</a></code> to a tuning function (or do anything else with it, nobody is judging you).
</p>
<p>A <code>TuneToken</code> represents the range over which the parameter whose <code style="white-space: pre;">&#8288;$values&#8288;</code> slot it occupies should be tuned over. It
can be constructed via the <code>to_tune()</code> function in one of several ways:
</p>

<ul>
<li> <p><strong><code>to_tune()</code></strong>: Indicates a parameter should be tuned over its entire range. Only applies to finite parameters
(i.e. discrete or bounded numeric parameters)
</p>
</li>
<li> <p><strong><code>to_tune(lower, upper, logscale)</code></strong>: Indicates a numeric parameter should be tuned in the inclusive interval spanning
<code>lower</code> to <code>upper</code>, possibly on a log scale if <code>logscale</code> is se to <code>TRUE</code>. All parameters are optional, and the
parameter's own lower / upper bounds are used without log scale, by default. Depending on the parameter,
integer (if it is a <code><a href="#topic+p_int">p_int()</a></code>) or real values (if it is a <code><a href="#topic+p_dbl">p_dbl()</a></code>) are used.<br />
<code>lower</code>, <code>upper</code>, and <code>logscale</code> can be given by position, except when only one of them is given, in which case
it must be named to disambiguate from the following cases.<br />
When <code>logscale</code> is <code>TRUE</code>, then a <code>trafo</code> is generated automatically that transforms to the given bounds. The
bounds are log()'d pre-trafo (see examples). See the <code>logscale</code> argument of <code><a href="#topic+Domain">Domain</a></code> functions for more info.<br />
Note that &quot;logscale&quot; is <em>not</em> inherited from the <code><a href="#topic+Domain">Domain</a></code> that the <code>TuneToken</code> belongs to! Defining a parameter
with <code style="white-space: pre;">&#8288;p_dbl(... logscale = TRUE)&#8288;</code> will <em>not</em> automatically give the <code>to_tune()</code> assigned to it log-scale.
</p>
</li>
<li> <p><strong><code>to_tune(levels)</code></strong>: Indicates a parameter should be tuned through the given discrete values. <code>levels</code> can be any
named or unnamed atomic vector or list (although in the unnamed case it must be possible to construct a
corresponding <code>character</code> vector with distinct values using <code>as.character</code>).
</p>
</li>
<li> <p><strong><code style="white-space: pre;">&#8288;to_tune(&lt;Domain&gt;)&#8288;</code></strong>: The given <code><a href="#topic+Domain">Domain</a></code> object (constructed e.g. with <code><a href="#topic+p_int">p_int()</a></code> or <code><a href="#topic+p_fct">p_fct()</a></code>) indicates
the range which should be tuned over. The supplied <code>trafo</code> function is used for parameter transformation.
</p>
</li>
<li> <p><strong><code style="white-space: pre;">&#8288;to_tune(&lt;ParamSet&gt;)&#8288;</code></strong>: The given <code><a href="#topic+ParamSet">ParamSet</a></code> is used to tune over a single dimension. This is useful for cases
where a single evaluation-time parameter value (e.g. <code><a href="#topic+p_uty">p_uty()</a></code>) is constructed from multiple tuner-visible
parameters (which may not be <code><a href="#topic+p_uty">p_uty()</a></code>). If not one-dimensional, the supplied <code><a href="#topic+ParamSet">ParamSet</a></code> should always contain a <code style="white-space: pre;">&#8288;$extra_trafo&#8288;</code> function,
which must then always return a <code>list</code> with a single entry.
</p>
</li></ul>

<p>The <code>TuneToken</code> object's internals are subject to change and should not be relied upon. <code>TuneToken</code> objects should
only be constructed via <code>to_tune()</code>, and should only be used by giving them to <code style="white-space: pre;">&#8288;$values&#8288;</code> of a <code><a href="#topic+ParamSet">ParamSet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_tune(..., internal = !is.null(aggr), aggr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_tune_+3A_...">...</code></td>
<td>
<p>if given, restricts the range to be tuning over, as described above.</p>
</td></tr>
<tr><td><code id="to_tune_+3A_internal">internal</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to create an <code>InternalTuneToken</code>.
This is only available for parameters tagged with <code>"internal_tuning"</code>.</p>
</td></tr>
<tr><td><code id="to_tune_+3A_aggr">aggr</code></td>
<td>
<p>(<code>function</code>)<br />
Function with one argument, which is a list of parameter values and returns a single aggregated value (e.g. the mean).
This specifies how multiple parameter values are aggregated to form a single value in the context of internal tuning.
If none specified, the default aggregation function of the parameter will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>TuneToken</code> object.
</p>


<h3>See Also</h3>

<p>Other ParamSet construction helpers: 
<code><a href="#topic+Domain">Domain</a>()</code>,
<code><a href="#topic+ps">ps</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params = ps(
  int = p_int(0, 10),
  int_unbounded = p_int(),
  dbl = p_dbl(0, 10),
  dbl_unbounded = p_dbl(),
  dbl_bounded_below = p_dbl(lower = 1),
  fct = p_fct(c("a", "b", "c")),
  uty1 = p_uty(),
  uty2 = p_uty(),
  uty3 = p_uty(),
  uty4 = p_uty(),
  uty5 = p_uty()
)

params$values = list(

  # tune over entire range of `int`, 0..10:
  int = to_tune(),

  # tune over 2..7:
  int_unbounded = to_tune(2, 7),

  # tune on a log scale in range 1..10;
  # recognize upper bound of 10 automatically, but restrict lower bound to 1:
  dbl = to_tune(lower = 1, logscale = TRUE),
  ## This is equivalent to the following:
  # dbl = to_tune(p_dbl(log(1), log(10), trafo = exp)),

  # nothing keeps us from tuning a dbl over integer values
  dbl_unbounded = to_tune(p_int(1, 10)),

  # tune over values "a" and "b" only
  fct = to_tune(c("a", "b")),

  # tune over integers 2..8.
  # ParamUty needs type information in form of p_xxx() in to_tune.
  uty1 = to_tune(p_int(2, 8)),

  # tune uty2 like a factor, trying 1, 10, and 100:
  uty2 = to_tune(c(1, 10, 100)),

  # tune uty3 like a factor. The factor levels are the names of the list
  # ("exp", "square"), but the trafo will generate the values from the list.
  # This way you can tune an objective that has function-valued inputs.
  uty3 = to_tune(list(exp = exp, square = function(x) x^2)),

  # tune through multiple parameters. When doing this, the ParamSet in tune()
  # must have the trafo that generates a list with one element and the right
  # name:
  uty4 = to_tune(ps(
    base = p_dbl(0, 1),
    exp = p_int(0, 3),
    .extra_trafo = function(x, param_set) {
      list(uty4 = x$base ^ x$exp)
    }
  )),

  # not all values need to be tuned!
  uty5 = 100
)

print(params$values)

print(params$search_space())

# Change `$values` directly and generate new `$search_space()` to play around
params$values$uty3 = 8
params$values$uty2 = to_tune(c(2, 4, 8))

print(params$search_space())

# Notice how `logscale` applies `log()` to lower and upper bound pre-trafo:
params = ps(x = p_dbl())

params$values$x = to_tune(1, 100, logscale = TRUE)

print(params$search_space())

grid = generate_design_grid(params$search_space(), 3)

# The grid is equidistant within log-bounds pre-trafo:
print(grid)

# But the values are on a log scale scale with desired bounds after trafo:
print(grid$transpose())

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
