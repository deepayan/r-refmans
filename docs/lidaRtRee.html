<!DOCTYPE html><html><head><title>Help for package lidaRtRee</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lidaRtRee}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aa_las_chablais3'><p>Load las_chablais3</p></a></li>
<li><a href='#aba_build_model'><p>Calibrates and validates area-based models</p></a></li>
<li><a href='#aba_combine_strata'><p>Combines a list of ABA models into a single ABA model object</p></a></li>
<li><a href='#aba_inference'><p>computes inference from area-based model and predicted values</p></a></li>
<li><a href='#aba_metrics'><p>Function for area-based metrics computation</p></a></li>
<li><a href='#aba_plot'><p>Plots observed VS values predicted in leave one out cross validation of an</p>
<code>aba_build_model</code></a></li>
<li><a href='#aba_predict'><p>Mapping of ABA prediction models</p></a></li>
<li><a href='#add_vegetation_indices'><p>Add vegetation indices on a IRC image</p></a></li>
<li><a href='#boxcox_itr'><p>Inverse Box-Cox transformation</p></a></li>
<li><a href='#boxcox_itr_bias_cor'><p>Inverse Box-Cox transformation with bias correction</p></a></li>
<li><a href='#boxcox_tr'><p>Box-Cox Transformation</p></a></li>
<li><a href='#chm_chablais3'><p>Canopy height model (Chablais 3 plot)</p></a></li>
<li><a href='#cimg2Raster'><p>Cimg to SpatRaster conversion</p></a></li>
<li><a href='#circle2Raster'><p>Raster corresponding to circle extent</p></a></li>
<li><a href='#clean_raster'><p>Applies thresholds and mask to a raster object</p></a></li>
<li><a href='#clouds_metrics'><p>Computes metrics on list of point clouds</p></a></li>
<li><a href='#clouds_tree_metrics'><p>Computes metrics on trees detected in list of point clouds.</p></a></li>
<li><a href='#convert_raster'><p>Raster format conversion</p></a></li>
<li><a href='#coregistration'><p>Tree inventory and canopy height model coregistration</p></a></li>
<li><a href='#create_disk'><p>Disk-shaped matrix mask</p></a></li>
<li><a href='#dem_filtering'><p>Image pre-processing (non-linear filtering and Gaussian smoothing)</p></a></li>
<li><a href='#edge_detection'><p>Edge detection in gap image</p></a></li>
<li><a href='#ellipses4Crown'><p>Create elliptical polygons from centres and extensions in four directions</p></a></li>
<li><a href='#gap_detection'><p>Gap detection in a Canopy Height Model</p></a></li>
<li><a href='#height_regression'><p>Regression of detected heights VS reference heights</p></a></li>
<li><a href='#hist_detection'><p>Histogram of detection</p></a></li>
<li><a href='#hist_stack'><p>Stacked histogram</p></a></li>
<li><a href='#las_chablais3'><p>las data in France (Chablais 3 plot)</p></a></li>
<li><a href='#lma_check'><p>Checks linear model assumptions of a multiple regression model</p></a></li>
<li><a href='#maxima_detection'><p>Local maxima extraction on image</p></a></li>
<li><a href='#maxima_selection'><p>Image maxima selection based on values and neighborhood of local maxima</p></a></li>
<li><a href='#plot_matched'><p>Plot of matched pairs of detected and reference trees</p></a></li>
<li><a href='#plot_tree_inventory'><p>Displays a map of tree inventory data</p></a></li>
<li><a href='#pointList2poly'><p>Convert a list of points into spatial polygons object</p></a></li>
<li><a href='#points2DSM'><p>Digital Surface Model</p></a></li>
<li><a href='#points2DTM'><p>Digital Terrain Model</p></a></li>
<li><a href='#polar2Projected'><p>Polar to cartesian coordinates conversion</p></a></li>
<li><a href='#quatre_montagnes'><p>Field plot inventory in the Quatre Montagnes area (France)</p></a></li>
<li><a href='#raster_chull_mask'><p>Raster mask of convex hull</p></a></li>
<li><a href='#raster_local_max'><p>Statistics of raster local maximum</p></a></li>
<li><a href='#raster_metrics'><p>Computes metrics by aggregating a raster at lower resolution or summarizing</p>
attributes based on XY locations</a></li>
<li><a href='#raster_xy_mask'><p>Raster mask by union of buffers around xy positions</p></a></li>
<li><a href='#raster_zonal_stats'><p>Image statistic in segment</p></a></li>
<li><a href='#raster2Cimg'><p>SpatRaster to Cimg conversion</p></a></li>
<li><a href='#rasters_moving_cor'><p>Correlation between rasters for different XY translations</p></a></li>
<li><a href='#rasters2Cor'><p>Correlation between two rasters</p></a></li>
<li><a href='#seg_adjust'><p>Modification of segments based on values</p></a></li>
<li><a href='#segmentation'><p>Image segmentation by seed-based watershed algorithm</p></a></li>
<li><a href='#species_color'><p>Table of species names, abreviations and display colors</p></a></li>
<li><a href='#std_tree_metrics'><p>Computation of tree metrics</p></a></li>
<li><a href='#terrain_points_metrics'><p>Computation of terrain metrics</p></a></li>
<li><a href='#tree_detection'><p>Tree detection</p></a></li>
<li><a href='#tree_extraction'><p>Tree extraction</p></a></li>
<li><a href='#tree_inventory_chablais3'><p>Tree inventory data in France (Chablais 3 plot, July 2010)</p></a></li>
<li><a href='#tree_matching'><p>3D matching of detected tree top positions with reference positions</p></a></li>
<li><a href='#tree_segmentation'><p>Preprocessing and segmentation of raster image for tree identification</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>4.0.5</td>
</tr>
<tr>
<td>Title:</td>
<td>Forest Analysis with Airborne Laser Scanning (LiDAR) Data</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-05</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for forest analysis using airborne laser scanning (LiDAR remote sensing) data: 
    tree detection (method 1 in Eysn et al. (2015) &lt;<a href="https://doi.org/10.3390%2Ff6051721">doi:10.3390/f6051721</a>&gt;) and segmentation; 
    forest parameters estimation and mapping with the area-based approach. It includes complementary steps for forest mapping: 
    co-registration of field plots with LiDAR data (Monnet and Mermin (2014) &lt;<a href="https://doi.org/10.3390%2Ff5092307">doi:10.3390/f5092307</a>&gt;); 
    extraction of both physical (gaps, edges, trees) and statistical features from LiDAR data useful 
    for e.g. habitat suitability modeling (Glad et al. (2020) &lt;<a href="https://doi.org/10.1002%2Frse2.117">doi:10.1002/rse2.117</a>&gt;) and forest maturity mapping (Fuhr et al. (2022) &lt;<a href="https://doi.org/10.1002%2Frse2.274">doi:10.1002/rse2.274</a>&gt;); 
    model calibration with ground reference, and maps export. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.irstea.fr/jean-matthieu.monnet/lidaRtRee">https://gitlab.irstea.fr/jean-matthieu.monnet/lidaRtRee</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.irstea.fr/jean-matthieu.monnet/lidaRtRee/-/issues">https://gitlab.irstea.fr/jean-matthieu.monnet/lidaRtRee/-/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, methods, grDevices, terra, sf, imager, leaps,
gvlma, car, reldist, lidR (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>stars, raster</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-06 09:25:58 UTC; jean-matthieu_monnet</td>
</tr>
<tr>
<td>Author:</td>
<td>Jean-Matthieu Monnet
    <a href="https://orcid.org/0000-0002-9948-9891"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Pascal Obst√©tar <a href="https://orcid.org/0000-0002-2811-7548"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jean-Matthieu Monnet &lt;jean-matthieu.monnet@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-07 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aa_las_chablais3'>Load las_chablais3</h2><span id='topic+aa_las_chablais3'></span>

<h3>Description</h3>

<p>Loads the external data: Airborne laser scanning data over the
Chablais 3 plot, acquired in 2009 by Sintegra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aa_las_chablais3()
</code></pre>


<h3>Value</h3>

<p>An object of class <code><a href="lidR.html#topic+LAS">LAS</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+las_chablais3">las_chablais3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>las_chablais3 &lt;- aa_las_chablais3()
</code></pre>

<hr>
<h2 id='aba_build_model'>Calibrates and validates area-based models</h2><span id='topic+aba_build_model'></span>

<h3>Description</h3>

<p>The function can first apply a Box-Cox transformation to the dependent variable,
in order to normalize its distribution, or a log transformation to the whole
dataset. Then it uses <code><a href="leaps.html#topic+regsubsets">regsubsets</a></code> to find the 20 linear
regressions with the best adjusted-R2 among combinations of at most <code>nmax</code>
independent variables. Each model can then be tested regarding the following
linear model assumptions are checked:
</p>

<ul>
<li><p> tests performed by <code><a href="gvlma.html#topic+gvlma">gvlma</a></code>
</p>
</li>
<li><p> the variance inflation factor is below 5 (models with two or more
independent variables)
</p>
</li>
<li><p> no partial p.value of variables in the model is below 0.05
</p>
</li></ul>

<p>The model with the highest adjusted-R2 among those fulfilling the required
conditions is selected. A leave-one-out cross validation (LOO CV) is performed
by fitting the model coefficients using all observations except one and applying
the resulting model to predict the value for the remaining observation. In
case a transformation was performed beforehand, a bias correction is applied.
LOO CV statistics are then computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aba_build_model(
  variable,
  predictors,
  transform = "none",
  nmax = 3,
  test = c("partial_p", "vif", "gvlma"),
  xy = NULL,
  threshold = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aba_build_model_+3A_variable">variable</code></td>
<td>
<p>vector. dependent variable values</p>
</td></tr>
<tr><td><code id="aba_build_model_+3A_predictors">predictors</code></td>
<td>
<p>data.frame. independent variables (columns: metrics,
lines: observations). Row names are used for the output predicted values</p>
</td></tr>
<tr><td><code id="aba_build_model_+3A_transform">transform</code></td>
<td>
<p>string. transformation to be applied to data (<code>"none"</code>,
<code>"boxcox"</code>: Box-Cox transformation applied only to the dependent variable,
<code>"log"</code>: log transformation applied to both dependent and independent
variables)</p>
</td></tr>
<tr><td><code id="aba_build_model_+3A_nmax">nmax</code></td>
<td>
<p>numeric. maximum number of independent variables in the model</p>
</td></tr>
<tr><td><code id="aba_build_model_+3A_test">test</code></td>
<td>
<p>vector. which tests should be satisfied by the models, one to
three in <code>"partial_p"</code>, <code>"vif"</code>, <code>"gvlma"</code></p>
</td></tr>
<tr><td><code id="aba_build_model_+3A_xy">xy</code></td>
<td>
<p>data.frame or matrix of easting and northing coordinates of
observations: not used in the function but exported in the result for use in
further inference functions</p>
</td></tr>
<tr><td><code id="aba_build_model_+3A_threshold">threshold</code></td>
<td>
<p>vector of length two. minimum and maximum values of threshold
to apply to predicted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three elements
</p>

<ul>
<li> <p><code>model</code>: list with one regression model (output from
<code><a href="stats.html#topic+lm">lm</a></code>),
</p>
</li>
<li> <p><code>stats</code>: model statistics (root mean square error estimated in
leave-one-out cross validation, coefficient of variation of rmse, p-value of
wilcoxon test of observed and predicted values, p-value of t-test of observed
and predicted values, p-value of anova of observed and predicted values,
correlation of observed and predicted values, R2 of observed and predicted
values, variance of regression residuals)
</p>
</li>
<li> <p><code>values</code>: data.frame with observed and values predicted in
cross-validation.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+aba_combine_strata">aba_combine_strata</a></code> for combining models calibrated
on different strata, <code><a href="#topic+aba_plot">aba_plot</a></code> for plotting model
cross-validation results, <code><a href="leaps.html#topic+regsubsets">regsubsets</a></code> for variable selection,
<code><a href="#topic+lma_check">lma_check</a></code> for linear model assumptions check,
<code><a href="#topic+boxcox_itr_bias_cor">boxcox_itr_bias_cor</a></code> for reverse Box-Cox transformation with bias
correction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(quatre_montagnes)
# build ABA model for basal area, with all metrics as predictors
model_aba &lt;- aba_build_model(quatre_montagnes$G_m2_ha, quatre_montagnes[, 9:76],
  transform = "boxcox", nmax = 3
)
# summary of regression model
summary(model_aba$model)
# validation statistics
model_aba$stats
# observed and predicted values
summary(model_aba$values)

# plot field values VS predictions in cross-validation
aba_plot(model_aba, main = "Basal area")
</code></pre>

<hr>
<h2 id='aba_combine_strata'>Combines a list of ABA models into a single ABA model object</h2><span id='topic+aba_combine_strata'></span>

<h3>Description</h3>

<p>Combines a list of models (obtained with <code><a href="#topic+aba_build_model">aba_build_model</a></code>) into a
single object. Typically used to merge stratum-specific models into one object.
Validation statistics are computed for the combined strata, making it easier
to compare prediction performance with an unstratified model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aba_combine_strata(model.list, plotsId = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aba_combine_strata_+3A_model.list">model.list</code></td>
<td>
<p>list. stratum-specific models returned by
<code><a href="#topic+aba_build_model">aba_build_model</a></code></p>
</td></tr>
<tr><td><code id="aba_combine_strata_+3A_plotsid">plotsId</code></td>
<td>
<p>vector. &quot;plotsId&quot; for ordering row names in the &quot;values&quot; element
of the output list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three elements
</p>

<ul>
<li> <p><code>model</code>: a list of regression models corresponding to each stratum
(output from <code><a href="stats.html#topic+lm">lm</a></code>),
</p>
</li>
<li> <p><code>stats</code>: model statistics of each stratum-specific model (as in
<code><a href="#topic+aba_build_model">aba_build_model</a></code>) plus one line corresponding to statistics for all
strata (COMBINED)
</p>
</li>
<li> <p><code>values</code>: data.frame with observed and values predicted in
cross-validation, and information on which stratum it belongs to.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+aba_build_model">aba_build_model</a></code> for calibrated ABA model,
<code><a href="#topic+aba_plot">aba_plot</a></code> for plotting model cross-validation results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load Quatre Montagnes dataset
data(quatre_montagnes)
# initialize list of models
model_aba_stratified &lt;- list()
# calibrate basal area prediction model for each stratum
for (i in levels(quatre_montagnes$stratum))
{
  subsample &lt;- which(quatre_montagnes$stratum == i)
  model_aba_stratified[[i]] &lt;-
    aba_build_model(quatre_montagnes[subsample, "G_m2_ha"],
      quatre_montagnes[subsample, 9:76],
      transform = "boxcox", nmax = 4,
      xy = quatre_montagnes[subsample, c("X", "Y")]
    )
}
# combine models in single object
model_aba_stratified &lt;- aba_combine_strata(
  model_aba_stratified,
  quatre_montagnes$plotId
)
# display content of output list
model_aba_stratified$model
model_aba_stratified$stats
summary(model_aba_stratified$values)

# plot field values VS predictions in cross-validation
aba_plot(model_aba_stratified)
</code></pre>

<hr>
<h2 id='aba_inference'>computes inference from area-based model and predicted values</h2><span id='topic+aba_inference'></span>

<h3>Description</h3>

<p>computes inference from area-based model and predicted values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aba_inference(
  aba_model,
  r_predictions,
  type = c("SRS", "ED", "D", "STR", "SYNT"),
  r_mask = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aba_inference_+3A_aba_model">aba_model</code></td>
<td>
<p>a model returned by <code><a href="#topic+aba_build_model">aba_build_model</a></code> or
<code><a href="#topic+aba_combine_strata">aba_combine_strata</a></code></p>
</td></tr>
<tr><td><code id="aba_inference_+3A_r_predictions">r_predictions</code></td>
<td>
<p>raster of predicted values</p>
</td></tr>
<tr><td><code id="aba_inference_+3A_type">type</code></td>
<td>
<p>string vector specifying which estimators should be computed
(one or several in &quot;SRS&quot;, &quot;ED&quot;, &quot;D&quot;, &quot;STR&quot;, &quot;SYNT&quot;)</p>
</td></tr>
<tr><td><code id="aba_inference_+3A_r_mask">r_mask</code></td>
<td>
<p>raster to mask region of interest (NA values), may contain
post-stratification categories (should be integer, positive values)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with estimation of parameter value and standard deviation
of estimation for all required estimators.
</p>

<hr>
<h2 id='aba_metrics'>Function for area-based metrics computation</h2><span id='topic+aba_metrics'></span><span id='topic+.aba_metrics'></span>

<h3>Description</h3>

<p>Predefined function usable in <code><a href="lidR.html#topic+cloud_metrics">cloud_metrics</a></code> or
<code><a href="#topic+clouds_metrics">clouds_metrics</a></code>. Applies a minimum height threshold to the point
cloud and computes the following metrics:
</p>

<ol>
<li><p> for all points: total number <code>ntot</code>, percentage of points above
minimum height <code>p_hmin</code>, percentage of points in height bins
<code>H.propZ1_Z2</code>,
</p>
</li>
<li><p> for first return points: percentage above minimum height
<code>p_1st_hmin</code>,
</p>
</li>
<li><p> for all points above minimum height: height metrics returned by
<code><a href="lidR.html#topic+stdmetrics_z">stdmetrics_z</a></code> and intensity metrics returned by
<code><a href="lidR.html#topic+stdmetrics_i">stdmetrics_i</a></code>
</p>
</li>
<li><p> for first returns above minimum height: <code>mCH</code> and <code>sdCH</code> as
proposed by Bouvier et al.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>aba_metrics(z, i, rn, c, hmin = 2, breaksH = NULL)

.aba_metrics
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aba_metrics_+3A_z">z</code>, <code id="aba_metrics_+3A_i">i</code>, <code id="aba_metrics_+3A_rn">rn</code>, <code id="aba_metrics_+3A_c">c</code></td>
<td>
<p>Height, Intensity, ReturnNumber and Classification</p>
</td></tr>
<tr><td><code id="aba_metrics_+3A_hmin">hmin</code></td>
<td>
<p>numeric. height threshold for low points removal before metrics
computation</p>
</td></tr>
<tr><td><code id="aba_metrics_+3A_breaksh">breaksH</code></td>
<td>
<p>vector. breaks for height histogram proportion computation</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>formula</code> of length 2.
</p>


<h3>References</h3>

<p>Bouvier et al. 2015. Generalizing predictive models of forest
inventory attributes using an area-based approach with airborne LiDAR data.
Remote Sensing of Environment 156, pp. 322-334. <a href="https://doi.org/10.1016/j.rse.2014.10.004">doi:10.1016/j.rse.2014.10.004</a>
</p>


<h3>See Also</h3>

<p><code><a href="lidR.html#topic+cloud_metrics">cloud_metrics</a></code>, <code><a href="lidR.html#topic+stdmetrics">stdmetrics</a></code>,
<code><a href="#topic+clouds_metrics">clouds_metrics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load LAS file
LASfile &lt;- system.file("extdata", "las_chablais3.laz", package="lidaRtRee")
las_chablais3 &lt;- lidR::readLAS(LASfile)

# extract two point clouds from LAS object
llas &lt;- lidR::clip_circle(las_chablais3,
                          c(974350, 974390),
                          c(6581680, 6581680), 10)
# normalize point clouds
llas &lt;- lapply(llas, function(x) {
  lidR::normalize_height(x, lidR::tin())
})
# computes metrics 
m &lt;- clouds_metrics(llas, ~ aba_metrics(
 Z, Intensity, ReturnNumber, Classification, 2
))
head(m[,1:5])
</code></pre>

<hr>
<h2 id='aba_plot'>Plots observed VS values predicted in leave one out cross validation of an
<code><a href="#topic+aba_build_model">aba_build_model</a></code></h2><span id='topic+aba_plot'></span>

<h3>Description</h3>

<p>Plots observed VS values predicted in leave one out cross validation of an
<code><a href="#topic+aba_build_model">aba_build_model</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aba_plot(aba_model, disp_text = F, col = NULL, add_legend = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aba_plot_+3A_aba_model">aba_model</code></td>
<td>
<p>list. as returned by <code><a href="#topic+aba_build_model">aba_build_model</a></code></p>
</td></tr>
<tr><td><code id="aba_plot_+3A_disp_text">disp_text</code></td>
<td>
<p>boolean. indicates if points should be labeled with id</p>
</td></tr>
<tr><td><code id="aba_plot_+3A_col">col</code></td>
<td>
<p>color to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>, default is
black for single models, depends on stratum in stratified models</p>
</td></tr>
<tr><td><code id="aba_plot_+3A_add_legend">add_legend</code></td>
<td>
<p>list. parameters to be passed to <code><a href="graphics.html#topic+legend">legend</a></code>. In case of a stratified model, legend is automatically set up.</p>
</td></tr>
<tr><td><code id="aba_plot_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>,
<code>xlab</code> and <code>ylab</code> are automatically added</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load Quatre Montagnes dataset
data(quatre_montagnes)
# build ABA model for basal area, with all metrics as predictors
model_aba &lt;- aba_build_model(quatre_montagnes$G_m2_ha, quatre_montagnes[, 9:76],
  transform = "boxcox", nmax = 3
)

# plot field values VS predictions in cross-validation
aba_plot(model_aba, main = "Basal area")
</code></pre>

<hr>
<h2 id='aba_predict'>Mapping of ABA prediction models</h2><span id='topic+aba_predict'></span>

<h3>Description</h3>

<p>Applies calibrated area-based prediction models output of
<code><a href="#topic+aba_build_model">aba_build_model</a></code> to a raster of metrics to obtain a raster of
predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aba_predict(
  model_aba,
  metrics_map,
  stratum = NULL,
  add_error = FALSE,
  pkg = "terra"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aba_predict_+3A_model_aba">model_aba</code></td>
<td>
<p>model returned by <code><a href="#topic+aba_build_model">aba_build_model</a></code> or
<code><a href="#topic+aba_combine_strata">aba_combine_strata</a></code></p>
</td></tr>
<tr><td><code id="aba_predict_+3A_metrics_map">metrics_map</code></td>
<td>
<p>raster. metrics returned e.g by
<code><a href="lidR.html#topic+pixel_metrics">pixel_metrics</a></code></p>
</td></tr>
<tr><td><code id="aba_predict_+3A_stratum">stratum</code></td>
<td>
<p>string. indicates which layer of metrics.map contains the
<code>stratum</code> in case of a stratified <code>aba.model</code>. The layer should have a RAT
including a column with the same name (see <code><a href="terra.html#topic+is.factor">is.factor</a></code>).</p>
</td></tr>
<tr><td><code id="aba_predict_+3A_add_error">add_error</code></td>
<td>
<p>boolean. indicates whether errors sampled from a normal distribution
N(0, sigma(residuals)) should be added to fitted values; implemented only for
<code>log</code> transformation case</p>
</td></tr>
<tr><td><code id="aba_predict_+3A_pkg">pkg</code></td>
<td>
<p>raster output format. Use pkg = &quot;terra|raster|stars&quot; to get an output in SpatRaster, RasterLayer
or stars format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a raster of predictions obtained by applying the model <code>aba_build_model</code>
to the observations in <code>metrics_map</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+aba_build_model">aba_build_model</a> for model fitting and <a href="#topic+aba_combine_strata">aba_combine_strata</a>
for combining stratified models, <a href="#topic+clean_raster">clean_raster</a> for applying spatial mask
and value thresholds to a raster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(quatre_montagnes)
# build model
model_aba &lt;- aba_build_model(quatre_montagnes$G_m2_ha, quatre_montagnes[, 9:76],
  transform = "boxcox"
)
# build example raster to apply model
quatre_montagnes$X &lt;- rep(1:8, 12)
quatre_montagnes$Y &lt;- rep(1:12, each = 8)
metrics_map &lt;- terra::rast(quatre_montagnes[, c(2, 3, 9:76)], type = "xyz")
predict_map &lt;- aba_predict(model_aba, metrics_map)

# plot map
terra::plot(predict_map, main = "predictions")
</code></pre>

<hr>
<h2 id='add_vegetation_indices'>Add vegetation indices on a IRC image</h2><span id='topic+add_vegetation_indices'></span>

<h3>Description</h3>

<p>Computes vegetation indices from the Red, Green and Infra-Red bands of an IRC
image and adds them as additional bands or columns. Acronyms are listed on
<a href="https://www.l3harrisgeospatial.com/docs/broadbandgreenness.html">https://www.l3harrisgeospatial.com/docs/broadbandgreenness.html</a>. If the 
Blue band is also present, additional indices are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_vegetation_indices(r, all = FALSE, scale = 255)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_vegetation_indices_+3A_r">r</code></td>
<td>
<p>raster or data.frame. Should contain bands or columns with
names nir, r, g (and b)</p>
</td></tr>
<tr><td><code id="add_vegetation_indices_+3A_all">all</code></td>
<td>
<p>boolean. indicates whether all indices should be computed;
default:FALSE, only grvi, sr and ndvi are calculated</p>
</td></tr>
<tr><td><code id="add_vegetation_indices_+3A_scale">scale</code></td>
<td>
<p>numeric. values in bands are scaled from range [0, scale] to [0, 1]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a raster or data.frame with added bands or columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(nir = c(110, 150, 20),
r = c(25, 50, 30),
g = c(10, 60, 10),
b = c(20, 60, 0))
add_vegetation_indices(df, all = TRUE)
</code></pre>

<hr>
<h2 id='boxcox_itr'>Inverse Box-Cox transformation</h2><span id='topic+boxcox_itr'></span>

<h3>Description</h3>

<p>Inverse Box-Cox transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcox_itr(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcox_itr_+3A_x">x</code></td>
<td>
<p>vector or raster values to be transformed</p>
</td></tr>
<tr><td><code id="boxcox_itr_+3A_lambda">lambda</code></td>
<td>
<p>numeric. parameter of Box-Cox transformation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or raster of transformed values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxcox_tr">boxcox_tr</a></code> Box-Cox transformation,
<code><a href="#topic+boxcox_itr_bias_cor">boxcox_itr_bias_cor</a></code> inverse Box-Cox transformation with bias
correction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
boxcox_itr(x, 0)
boxcox_itr(x, 0.5)
boxcox_itr(x, 2)
boxcox_itr(boxcox_tr(x, 2), 2)

# plot functions
curve(boxcox_itr(x, 0), 0, 3,
  col = "blue", main = "inverse Box Cox transf.",
  xlab = "x", ylab = "inverse Boxcox(x, lambda)"
)
curve(boxcox_itr(x, 1.5), 0, 3, col = "red", add = TRUE)
curve(boxcox_itr(x, 0.5), 0, 3, col = "black", add = TRUE)
curve(boxcox_itr(x, 1), 0, 3, col = "pink", add = TRUE)
legend("topleft",
  legend = c("lambda", 0, 0.5, 1, 1.5),
  col = c(NA, "blue", "black", "pink", "red"), lty = 1
)
</code></pre>

<hr>
<h2 id='boxcox_itr_bias_cor'>Inverse Box-Cox transformation with bias correction</h2><span id='topic+boxcox_itr_bias_cor'></span>

<h3>Description</h3>

<p>Inverse Box-Cox transform with bias correction as suggested by Pu &amp; Tiefelsdorf
(2015). Here 'varmod' is not the local prediction variance as suggested in
the paper but the model residuals variance. For variance computation,
uses 'n-p' instead of 'n-1', with 'p' the number of variables in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcox_itr_bias_cor(x, lambda, varmod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcox_itr_bias_cor_+3A_x">x</code></td>
<td>
<p>vector or raster values to be transformed</p>
</td></tr>
<tr><td><code id="boxcox_itr_bias_cor_+3A_lambda">lambda</code></td>
<td>
<p>numeric. parameter of Box-Cox transformation</p>
</td></tr>
<tr><td><code id="boxcox_itr_bias_cor_+3A_varmod">varmod</code></td>
<td>
<p>numeric. model residuals variance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or raster
</p>


<h3>References</h3>

<p>Xiaojun Pu and Michael Tiefelsdorf, 2015. A variance-stabilizing
transformation to mitigate biased variogram estimation in heterogeneous
surfaces with clustered samples. <a href="https://doi.org/10.1007/978-3-319-22786-3_24">doi:10.1007/978-3-319-22786-3_24</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxcox_tr">boxcox_tr</a></code> Box-Cox transformation,
<code><a href="#topic+boxcox_itr">boxcox_itr</a></code> inverse Box-Cox transformation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
boxcox_itr(x, 0.3)
boxcox_itr_bias_cor(x, 0.3, 0)
boxcox_itr_bias_cor(x, 0.3, 2)

# plot functions
curve(boxcox_itr(x, 0.3), 0, 3,
  col = "blue",
  main = "inverse Box Cox transf., lambda = 0.3",
  xlab = "x", ylab = "inverse Boxcox(x, lambda = 0.3)"
)
curve(boxcox_itr_bias_cor(x, 0.3, 1), 0, 3, col = "red", add = TRUE)
curve(boxcox_itr_bias_cor(x, 0.3, 2), 0, 3, col = "black", add = TRUE)
legend("topleft",
  legend = c(
    "residuals variance  = 2",
    "residuals variance  = 1", "residuals variance not accounted for"
  ),
  col = c("black", "red", "blue"), lty = 1
)
</code></pre>

<hr>
<h2 id='boxcox_tr'>Box-Cox Transformation</h2><span id='topic+boxcox_tr'></span>

<h3>Description</h3>

<p>Box-Cox Transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcox_tr(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcox_tr_+3A_x">x</code></td>
<td>
<p>vector or raster. values to be transformed</p>
</td></tr>
<tr><td><code id="boxcox_tr_+3A_lambda">lambda</code></td>
<td>
<p>numeric. parameter of Box-Cox transformation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or raster of transformed values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxcox_itr">boxcox_itr</a></code> inverse Box-Cox transformation,
<code><a href="#topic+boxcox_itr_bias_cor">boxcox_itr_bias_cor</a></code> inverse Box-Cox transformation with bias correction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
boxcox_tr(x, -2)
boxcox_tr(x, 0)
boxcox_tr(x, 0.5)
boxcox_tr(x, 2)

# plot functions
curve(boxcox_tr(x, 1.5), 1, 5,
  main = "Box Cox transform", xlab = "x",
  ylab = "Boxcox(x, lambda)", col = "red"
)
curve(boxcox_tr(x, -2), 1, 5, col = "green", add = TRUE)
curve(boxcox_tr(x, 0), 1, 5, col = "blue", add = TRUE)
curve(boxcox_tr(x, 0.5), 1, 5, col = "black", add = TRUE)
curve(boxcox_tr(x, 1), 1, 5, col = "pink", add = TRUE)
legend("topleft",
  legend = rev(c(-2, 0, 0.5, 1, 1.5, "lambda")),
  col = rev(c("green", "blue", "black", "pink", "red", NA)), lty = 1
)
</code></pre>

<hr>
<h2 id='chm_chablais3'>Canopy height model (Chablais 3 plot)</h2><span id='topic+chm_chablais3'></span>

<h3>Description</h3>

<p>Canopy height model computed from airborne laser scanning data acquired in July 2010.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chm_chablais3)
</code></pre>


<h3>Format</h3>

<p>A PackedSpatRaster object
</p>


<h3>References</h3>

<p>Monnet, J.-M. 2011. Using airborne laser scanning for mountain forests mapping: Support vector regression for stand parameters estimation and unsupervised training for treetop detection. Ph.D. thesis. University of Grenoble, France. pp. 21-22 &amp; 34 <a href="https://theses.hal.science/tel-00652698/document">https://theses.hal.science/tel-00652698/document</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)
terra::plot(chm_chablais3)
</code></pre>

<hr>
<h2 id='cimg2Raster'>Cimg to SpatRaster conversion</h2><span id='topic+cimg2Raster'></span>

<h3>Description</h3>

<p>converts a cimg object to a SpatRaster object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cimg2Raster(cimg, r = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cimg2Raster_+3A_cimg">cimg</code></td>
<td>
<p>raster object. raster of canopy height model, preferably filtered to avoid effect of holes on volume and surface computation</p>
</td></tr>
<tr><td><code id="cimg2Raster_+3A_r">r</code></td>
<td>
<p>SpatRaster object. defines the extent and projection of conversion result</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raster2Cimg">raster2Cimg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

# convert raster to cimg object
chm_cim &lt;- raster2Cimg(chm_chablais3)

# apply filtering
chm_cim_filt &lt;- dem_filtering(chm_cim,
  nl_filter = "Closing",
  nl_size = 3,
  sigma = 0
)$non_linear_image

# convert to SpatRaster
chm_filt &lt;- cimg2Raster(chm_cim_filt, chm_chablais3)

# plot SpatRaster
terra::plot(chm_chablais3)

# plot cimg object
plot(chm_cim)

# plot filtered cimg object
plot(chm_cim_filt)

# plot filtered SpatRaster
terra::plot(chm_filt)
</code></pre>

<hr>
<h2 id='circle2Raster'>Raster corresponding to circle extent</h2><span id='topic+circle2Raster'></span>

<h3>Description</h3>

<p>Creates an empty raster which extents corresponds to the circle specified by 
center coordinates, radius and optional buffer size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle2Raster(X, Y, radius, resolution = 0.5, buffer = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circle2Raster_+3A_x">X</code></td>
<td>
<p>numeric. easting coordinate of plot center in meters</p>
</td></tr>
<tr><td><code id="circle2Raster_+3A_y">Y</code></td>
<td>
<p>numeric. northing coordinate of plot center in meters</p>
</td></tr>
<tr><td><code id="circle2Raster_+3A_radius">radius</code></td>
<td>
<p>numeric. plot radius in meters</p>
</td></tr>
<tr><td><code id="circle2Raster_+3A_resolution">resolution</code></td>
<td>
<p>numeric. raster resolution in meters</p>
</td></tr>
<tr><td><code id="circle2Raster_+3A_buffer">buffer</code></td>
<td>
<p>numeric. buffer to be added to plot radius in meters</p>
</td></tr>
<tr><td><code id="circle2Raster_+3A_...">...</code></td>
<td>
<p>other parameters to pass to <code><a href="terra.html#topic+rast">rast</a></code> (e.g. crs)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circle2Raster(100, 100, 20, 1, 5)
</code></pre>

<hr>
<h2 id='clean_raster'>Applies thresholds and mask to a raster object</h2><span id='topic+clean_raster'></span>

<h3>Description</h3>

<p>Applies a lower and upper thresholds to the values of the input raster. If the
mask input is provided, first all NA values in the raster are set to 0, then
the raster in multiplied by the mask. Cells to be masked should therefore
have a NA value in the mask raster object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_raster(r, minmax = c(-Inf, +Inf), mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_raster_+3A_r">r</code></td>
<td>
<p>raster object. RasterLayer and SpatRaster are supported.</p>
</td></tr>
<tr><td><code id="clean_raster_+3A_minmax">minmax</code></td>
<td>
<p>vector of two numeric values. minimum and maximum thresholds to
apply to 'r' values</p>
</td></tr>
<tr><td><code id="clean_raster_+3A_mask">mask</code></td>
<td>
<p>raster object. mask to be applied (multiplication with input raster
'r')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a raster object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(quatre_montagnes)
# build model
model_aba &lt;- aba_build_model(quatre_montagnes$G_m2_ha, quatre_montagnes[, 9:76],
  transform = "boxcox"
)
# build example raster to apply model
quatre_montagnes$X &lt;- rep(1:8, 12)
quatre_montagnes$Y &lt;- rep(1:12, each = 8)
metrics_map &lt;- terra::rast(quatre_montagnes[, c(2, 3, 9:76)], type = "xyz")
predict_map &lt;- aba_predict(model_aba, metrics_map)
# create raster mask
mask &lt;- predict_map
# set values to 1 or NA
terra::values(mask) &lt;- rep(c(1, 1, NA), each = 32)
# apply thresholds and mask
predict_map_clean &lt;- clean_raster(predict_map, c(40, 70), mask)

# plot maps
terra::plot(predict_map, main = "Predictions")
terra::plot(mask, main = "Mask", legend = FALSE)
terra::plot(predict_map_clean, main = "Cleaned predictions")
</code></pre>

<hr>
<h2 id='clouds_metrics'>Computes metrics on list of point clouds</h2><span id='topic+clouds_metrics'></span>

<h3>Description</h3>

<p>Computes metrics for a list of <code><a href="lidR.html#topic+LAS">LAS</a></code> objects (should be
normalized point clouds). Calls the function <code><a href="lidR.html#topic+cloud_metrics">cloud_metrics</a></code>
on each element and then arranges the results in a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clouds_metrics(
  llasn,
  func = ~lidR::stdmetrics(X, Y, Z, Intensity, ReturnNumber, Classification, dz = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clouds_metrics_+3A_llasn">llasn</code></td>
<td>
<p>list of <code><a href="lidR.html#topic+LAS">LAS</a></code> objects</p>
</td></tr>
<tr><td><code id="clouds_metrics_+3A_func">func</code></td>
<td>
<p>function. function applied on each element to compute metrics,
default function is <code><a href="lidR.html#topic+stdmetrics">stdmetrics</a></code> from package <code>lidR</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with metrics in columns corresponding to LAS objects of
the list (lines)
</p>


<h3>See Also</h3>

<p><code><a href="lidR.html#topic+cloud_metrics">cloud_metrics</a></code>, <code><a href="lidR.html#topic+stdmetrics">stdmetrics</a></code>,
<code><a href="#topic+aba_metrics">aba_metrics</a></code>, <code><a href="lidR.html#topic+pixel_metrics">pixel_metrics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load LAS file
LASfile &lt;- system.file("extdata", "las_chablais3.laz", package="lidaRtRee")
las_chablais3 &lt;- lidR::readLAS(LASfile)
# set projection
lidR::projection(las_chablais3) &lt;- 2154

# extract four point clouds from LAS object
llas &lt;- list()
llas[["A"]] &lt;- lidR::clip_circle(las_chablais3, 974350, 6581680, 10)
llas[["B"]] &lt;- lidR::clip_circle(las_chablais3, 974390, 6581680, 10)
llas[["C"]] &lt;- lidR::clip_circle(las_chablais3, 974350, 6581640, 10)
# normalize point clouds
llas &lt;- lapply(llas, function(x) {
  lidR::normalize_height(x, lidR::tin())
})

# compute metrics
clouds_metrics(llas)

# compute metrics with user-defined function
# mean and standard deviation of first return points above 10 m
user_func &lt;- function(z, rn, hmin = 10) {
  # first return above hmin subset
  dummy &lt;- which(z &gt;= hmin &amp; rn == 1)
  return(list(
    mean.z = mean(z[dummy]),
    sd.z = stats::sd(z[z &gt; hmin])
  ))
}
clouds_metrics(llas, func = ~ user_func(Z, ReturnNumber, 10))
</code></pre>

<hr>
<h2 id='clouds_tree_metrics'>Computes metrics on trees detected in list of point clouds.</h2><span id='topic+clouds_tree_metrics'></span>

<h3>Description</h3>

<p>Extracts summary statistics on trees for each LAS object in a list:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clouds_tree_metrics(llasn, XY, plot_radius, res = 0.5, func, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clouds_tree_metrics_+3A_llasn">llasn</code></td>
<td>
<p>list of <code><a href="lidR.html#topic+LAS">LAS</a></code> objects</p>
</td></tr>
<tr><td><code id="clouds_tree_metrics_+3A_xy">XY</code></td>
<td>
<p>a data frame or matrix with XY coordinates of plot centers</p>
</td></tr>
<tr><td><code id="clouds_tree_metrics_+3A_plot_radius">plot_radius</code></td>
<td>
<p>numeric. plot radius in meters</p>
</td></tr>
<tr><td><code id="clouds_tree_metrics_+3A_res">res</code></td>
<td>
<p>numeric. resolution of canopy height model computed with 
<code><a href="#topic+points2DSM">points2DSM</a></code> before tree segmentation</p>
</td></tr>
<tr><td><code id="clouds_tree_metrics_+3A_func">func</code></td>
<td>
<p>a function to be applied to the attributes of extracted trees 
(return from internal call to <code><a href="#topic+tree_extraction">tree_extraction</a></code> function) to compute 
plot level metrics</p>
</td></tr>
<tr><td><code id="clouds_tree_metrics_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to <code><a href="#topic+tree_segmentation">tree_segmentation</a></code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>calls <code><a href="#topic+tree_segmentation">tree_segmentation</a></code> to segment trees and then 
<code><a href="#topic+tree_extraction">tree_extraction</a></code> to extract their features
</p>
</li>
<li><p>computes 'TreeCanopy_cover_in_plot' (proportion of surface of disk of interest 
which is covered by segmented trees), 'TreeCanopy_meanH_in_plot' (mean canopy 
height inside intersection of tree segments and disk of interest)
</p>
</li>
<li><p>removes detected trees located outside of the disk of interest defined 
by their centers and radius
</p>
</li>
<li><p>computes summary statistics of extracted tree features based on a 
user-defined function (default is <code><a href="#topic+std_tree_metrics">std_tree_metrics</a></code>)
</p>
</li></ul>



<h3>Value</h3>

<p>a data frame with tree metrics in columns corresponding to LAS objects 
of the list (lines)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree_segmentation">tree_segmentation</a></code>, <code><a href="#topic+tree_extraction">tree_extraction</a></code>, 
<code><a href="#topic+std_tree_metrics">std_tree_metrics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load LAS file
LASfile &lt;- system.file("extdata", "las_chablais3.laz", package="lidaRtRee")
las_chablais3 &lt;- lidR::readLAS(LASfile)

# extract two point clouds from LAS object
llas &lt;- lidR::clip_circle(las_chablais3,
                          c(974350, 974390),
                          c(6581680, 6581680), 10)
# normalize point clouds
llas &lt;- lapply(llas, function(x) {
  lidR::normalize_height(x, lidR::tin())
})

# compute metrics with user-defined function
# number of detected trees between 20 and 30 meters and their mean height
# restricted to disks of radius 8 m.
user_func &lt;- function(x) {
  dummy &lt;- x$h[which(x$h &gt; 20 &amp; x$h &lt; 30)]
  data.frame(Tree.between.20.30 = length(dummy), Tree.meanH = mean(dummy))
}
clouds_tree_metrics(llas,
  cbind(c(974350, 974390), c(6581680, 6581680)),
  8,
  res = 0.5, func = user_func
)
</code></pre>

<hr>
<h2 id='convert_raster'>Raster format conversion</h2><span id='topic+convert_raster'></span>

<h3>Description</h3>

<p>Function to convert between raster formats. Use pkg = &quot;terra|raster|stars&quot; to get an output in SpatRaster, RasterLayer
or stars format. Default is getOption(&quot;lidR.raster.default&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_raster(r, pkg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_raster_+3A_r">r</code></td>
<td>
<p>raster object or file name.</p>
</td></tr>
<tr><td><code id="convert_raster_+3A_pkg">pkg</code></td>
<td>
<p>package name. Use pkg = &quot;terra|
raster|stars&quot; to get an output in SpatRaster, RasterLayer or stars format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster object in the specified format
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load SpatRaster
data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)
# convert only if packages stars and raster are installed
# if (require("stars"))
# {
# to stars
# chm_stars &lt;- convert_raster(chm_chablais3, pkg = "stars")
# chm_stars
# }
if (require("raster"))
{
# to raster
chm_raster &lt;- convert_raster(chm_chablais3, pkg = "raster")
chm_raster
# back to terra
convert_raster(chm_raster, pkg = "terra")
}
</code></pre>

<hr>
<h2 id='coregistration'>Tree inventory and canopy height model coregistration</h2><span id='topic+coregistration'></span>

<h3>Description</h3>

<p>Computes the correlation between the canopy height model and a virtual canopy 
height model simulated from tree locations, for different translations of tree 
inventory positions, and outputs the translation corresponding to best 
estimated co-registration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coregistration(chm, trees, mask, buffer = 19, step = 0.5, dm = 2, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coregistration_+3A_chm">chm</code></td>
<td>
<p>raster. canopy height model</p>
</td></tr>
<tr><td><code id="coregistration_+3A_trees">trees</code></td>
<td>
<p>data.frame. the first two columns contain xy coordinates, and 
the third is the value to correlate to the chm (e.g. tree heights or diameters)</p>
</td></tr>
<tr><td><code id="coregistration_+3A_mask">mask</code></td>
<td>
<p>raster. raster mask of tree inventory area</p>
</td></tr>
<tr><td><code id="coregistration_+3A_buffer">buffer</code></td>
<td>
<p>numeric. radius of the circular buffer area of possible translations</p>
</td></tr>
<tr><td><code id="coregistration_+3A_step">step</code></td>
<td>
<p>numeric. increment step of translations within buffer area to 
compute correlation values, should be a multiple of raster resolution</p>
</td></tr>
<tr><td><code id="coregistration_+3A_dm">dm</code></td>
<td>
<p>numeric. minimum distance between two local maxima in meters</p>
</td></tr>
<tr><td><code id="coregistration_+3A_plot">plot</code></td>
<td>
<p>boolean. whether to display the results or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements : first the correlation SpatRaster returned by 
<code><a href="#topic+rasters_moving_cor">rasters_moving_cor</a></code>, second a data.frame returned by 
<code><a href="#topic+raster_local_max">raster_local_max</a></code>
</p>


<h3>References</h3>

<p>Monnet, J.-M. and Mermin, E. 2014. Cross-Correlation of Diameter 
Measures for the Co-Registration of Forest Inventory Plots with Airborne Laser 
Scanning Data. Forests 2014, 5(9), 2307-2326, <a href="https://doi.org/10.3390/f5092307">doi:10.3390/f5092307</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rasters_moving_cor">rasters_moving_cor</a></code>, <code><a href="#topic+raster_local_max">raster_local_max</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tree inventory
trees &lt;- data.frame(x = c(22.2, 18.3, 18.1), y = c(22.1, 22.7, 18.4), 
z = c(15, 10, 15))

# mask of inventory area
# empty raster with extent
tree_mask &lt;- circle2Raster(20, 20, 9, resolution = 1)
# fill binary mask
tree_mask &lt;- raster_xy_mask(rbind(c(20, 20), c(20, 20)), c(9, 9), tree_mask, 
binary = TRUE)

# simulate chm raster
chm &lt;- terra::rast(extent = c(0, 40, 0, 40), resolution = 1, crs = NA)
xy &lt;- terra::xyFromCell(chm, 1:(ncol(chm) * nrow(chm)))

# add Gaussian surfaces to simulate tree crowns
z1 &lt;- trees$z[1] * exp(-((xy[, 1] - trees$x[1])^2 + (xy[, 2] - trees$y[1])^2 / 2) * trees$z[1] / 50)
z2 &lt;- trees$z[2] * exp(-((xy[, 1] - trees$x[2])^2 + (xy[, 2] - trees$y[2])^2 / 2) * trees$z[2] / 50)
z3 &lt;- trees$z[3] * exp(-((xy[, 1] - trees$x[3])^2 + (xy[, 2] - trees$y[3])^2 / 2) * trees$z[3] / 50)
chm &lt;- terra::rast(cbind(xy, pmax(z1, z2, z3)), type = "xyz") #+rnorm(length(z1),0,1)))

# translate trees
trees$x &lt;- trees$x + 1
trees$y &lt;- trees$y + 2

coreg &lt;- coregistration(chm, trees, mask = tree_mask, buffer = 5, step = 1, dm = 1, plot = FALSE)
coreg$local_max[, c("dx1", "dy1")]

# plot raster
terra::plot(coreg$correlation_raster)
abline(h = 0, lty = 2)
abline(v = 0, lty = 2)
# add location of two local maxima
graphics::points(coreg$local_max[1, c("dx1", "dx2")],
  coreg$local_max[1, c("dy1", "dy2")],
  cex = c(1, 0.5), pch = 3, col = "red"
)
</code></pre>

<hr>
<h2 id='create_disk'>Disk-shaped matrix mask</h2><span id='topic+create_disk'></span>

<h3>Description</h3>

<p>Creates a matrix with TRUE values shaping a centered disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_disk(width = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_disk_+3A_width">width</code></td>
<td>
<p>numeric. disk width in pixels, should be an uneven number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with 1 for pixels inside the disk, 0 outside
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_disk(7)
</code></pre>

<hr>
<h2 id='dem_filtering'>Image pre-processing (non-linear filtering and Gaussian smoothing)</h2><span id='topic+dem_filtering'></span>

<h3>Description</h3>

<p>applies two filters to an image:
</p>

<ol>
<li><p> A non-linear filter: closing (<code><a href="imager.html#topic+mclosing">mclosing</a></code>) with disk 
kernel, or median (<code><a href="imager.html#topic+medianblur">medianblur</a></code>) with square kernel
</p>
</li>
<li><p> A 2D Gaussian smoother (The <code><a href="imager.html#topic+deriche">deriche</a></code> filter is 
applied on both dimensions). Value-dependent smoothing is possible
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>dem_filtering(
  dem,
  nl_filter = "Closing",
  nl_size = 5,
  sigma = 0.3,
  padding = TRUE,
  sigmap = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dem_filtering_+3A_dem">dem</code></td>
<td>
<p>cimg object (e.g. obtained with <code><a href="imager.html#topic+as.cimg">as.cimg</a></code>) or 
SpatRaster object (e.g. obtained with <code><a href="terra.html#topic+rast">rast</a></code>)</p>
</td></tr>
<tr><td><code id="dem_filtering_+3A_nl_filter">nl_filter</code></td>
<td>
<p>string. type of non-linear filter to apply: &quot;None&quot;, &quot;Closing&quot; 
or &quot;Median&quot;</p>
</td></tr>
<tr><td><code id="dem_filtering_+3A_nl_size">nl_size</code></td>
<td>
<p>numeric. kernel width in pixels for non-linear filtering</p>
</td></tr>
<tr><td><code id="dem_filtering_+3A_sigma">sigma</code></td>
<td>
<p>numeric or matrix. If a single number is provided, <code>sigma</code> is 
the standard deviation of the Gaussian filter, 0 corresponds to no 
smoothing. Unit is pixel in case <code>dem</code> is a cimg object, SpatRaster units 
otherwise. In case of a matrix, the first column corresponds to the standard 
deviation of the filter, and the second to thresholds for image values (e.g. 
a filter of standard deviation specified in line <code>i</code> is applied to pixels 
in image which values are between thresholds indicated in lines <code>i</code> and 
<code>i+1</code>). Threshold values should be ordered in increasing order.</p>
</td></tr>
<tr><td><code id="dem_filtering_+3A_padding">padding</code></td>
<td>
<p>boolean. Whether image should be padded by duplicating edge 
values before filtering to avoid border effects</p>
</td></tr>
<tr><td><code id="dem_filtering_+3A_sigmap">sigmap</code></td>
<td>
<p>deprecated (numeric or matrix). (old name for <code>sigma</code> parameter, 
retained for backward compatibility, overwrites <code>sigma</code> if provided, unit is 
pixel whatever the class of <code>dem</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two cimg objects or a SpatRaster object with image after non-linear 
filter and image after both filters
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxima_detection">maxima_detection</a></code>, filters of imager package: 
<code><a href="imager.html#topic+mclosing">mclosing</a></code>, <code><a href="imager.html#topic+medianblur">medianblur</a></code>, 
<code><a href="imager.html#topic+deriche">deriche</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

# filtering with median and Gaussian smoothing
im &lt;- dem_filtering(chm_chablais3, nl_filter = "Median", nl_size = 3, sigma = 0.8)

# filtering with median filter and value-dependent Gaussian smoothing
# (less smoothing for values between 0 and 15)
im2 &lt;- dem_filtering(chm_chablais3,
  nl_filter = "Median", nl_size = 3,
  sigma = cbind(c(0.2, 0.8), c(0, 15))
)

# plot original image
terra::plot(chm_chablais3, main = "Initial image")

# plot image after median filter
terra::plot(im$non_linear_image, main = "Median filter")

# plot image after median and Gaussian filters
terra::plot(im$smoothed_image, main = "Smoothed image")

# plot image after median and value-dependent Gaussian filters
terra::plot(im2$smoothed_image, main = "Value-dependent smoothing")
</code></pre>

<hr>
<h2 id='edge_detection'>Edge detection in gap image</h2><span id='topic+edge_detection'></span>

<h3>Description</h3>

<p>Performs edge detection on a gap image (e.g. output from function 
<code><a href="#topic+gap_detection">gap_detection</a></code>). The gap image is compared to a gap image which 
has undergone a dilation or erosion to identify edges of gaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_detection(gaps, inside = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_detection_+3A_gaps">gaps</code></td>
<td>
<p>SpatRaster object. gaps image where 1 represents gaps and 0 non-gaps 
areas</p>
</td></tr>
<tr><td><code id="edge_detection_+3A_inside">inside</code></td>
<td>
<p>boolean. defines where the edge is extracted: either inside the 
gaps (an erosion is applied to the gaps image) or outside (a dilation is applied)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster object where edges are labelled as 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gap_detection">gap_detection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

# fill NA values in canopy height model
chm_chablais3[is.na(chm_chablais3)] &lt;- 0

# gap detection with distance larger than canopy height / 2
gaps &lt;- gap_detection(chm_chablais3,
  ratio = 2, gap_max_height = 1, min_gap_surface = 10,
  gap_reconstruct = TRUE
)

# edge detection
edges_inside &lt;- edge_detection(!is.na(gaps$gap_id))
edges_outside &lt;- edge_detection(!is.na(gaps$gap_id), inside = FALSE)

# edge proportion
sum(terra::values(edges_inside)) / (nrow(edges_inside) * ncol(edges_inside))
sum(terra::values(edges_outside)) / (nrow(edges_outside) * ncol(edges_outside))

# plot original image
terra::plot(chm_chablais3, main = "Initial image")

# plot binary image of gaps
terra::plot(gaps$gap_id &gt; 0, main = "Gaps", col = "green", legend = FALSE)

# plot edges
terra::plot(edges_inside, main = "Edges (inside)", legend = FALSE)
terra::plot(edges_outside, main = "Edges (outside)", legend = FALSE)
</code></pre>

<hr>
<h2 id='ellipses4Crown'>Create elliptical polygons from centres and extensions in four directions</h2><span id='topic+ellipses4Crown'></span>

<h3>Description</h3>

<p>creates polygons from the union of four quarters of ellipses, specified by the
ellipse center, and maximum extension in two directions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipses4Crown(x, y, n, s, e, w, id = NULL, step = pi/12, angle.offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipses4Crown_+3A_x">x</code>, <code id="ellipses4Crown_+3A_y">y</code></td>
<td>
<p>vectors of numerics. Coordinates of ellipses centers</p>
</td></tr>
<tr><td><code id="ellipses4Crown_+3A_n">n</code>, <code id="ellipses4Crown_+3A_s">s</code>, <code id="ellipses4Crown_+3A_e">e</code>, <code id="ellipses4Crown_+3A_w">w</code></td>
<td>
<p>vectors of numerics. Coordinates of ellipses extention in the 
north, south, east and west directions</p>
</td></tr>
<tr><td><code id="ellipses4Crown_+3A_id">id</code></td>
<td>
<p>vector of strings. id of each polygon</p>
</td></tr>
<tr><td><code id="ellipses4Crown_+3A_step">step</code></td>
<td>
<p>numeric. Angular step for the modelling of ellipses</p>
</td></tr>
<tr><td><code id="ellipses4Crown_+3A_angle.offset">angle.offset</code></td>
<td>
<p>numeric. Angle offset to tilt ellipses, positive values 
rotates clockwise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data.frame containing the coordinates of polygons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pointList2poly">pointList2poly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute coordinates of ellipses
ellipses1 &lt;- ellipses4Crown(c(0, 10), c(0, 10), c(2, 2), c(3, 4), c(2.5, 3), c(2, 3),
  id = c("A", "B")
)
ellipses1[["A"]]
# tilted ellipse
ellipses2 &lt;- ellipses4Crown(c(0, 10), c(0, 10), c(2, 2), c(3, 4), c(2.5, 3), c(2, 3),
  angle.offset = pi / 6
)
ellipses2[[2]]

# draw ellipses in black, tilted ellipses in red
plot(ellipses1[[1]], type = "l", asp = 1, xlim = c(-5, 15), ylim = c(-5, 15))
lines(ellipses1[[2]])
lines(ellipses2[[1]], col = "red")
lines(ellipses2[[2]], col = "red")
</code></pre>

<hr>
<h2 id='gap_detection'>Gap detection in a Canopy Height Model</h2><span id='topic+gap_detection'></span>

<h3>Description</h3>

<p>Performs gaps detection on a canopy height model provided as object  of class 
<code><a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a></code>, or computed from the point cloud of 
objects of class <code><a href="lidR.html#topic+LAS-class">LAS-class</a></code> or 
<code><a href="lidR.html#topic+LAScatalog-class">LAScatalog-class</a></code>. Function <code><a href="#topic+dem_filtering">dem_filtering</a></code> 
is first applied to the canopy height model to remove artefacts. 
Gaps are then extracted based on several criteria:
</p>

<ol>
<li><p> Vegetation height must be smaller than a threshold
</p>
</li>
<li><p> Gap width must be large enough, depending on surrounding canopy height;
distance to surrounding vegetation is tested with morphological closings
</p>
</li>
<li><p> Gap must have a minimum surface
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>gap_detection(
  las,
  res = 1,
  ratio = 2,
  gap_max_height = 1,
  min_gap_surface = 25,
  max_gap_surface = +Inf,
  closing_height_bin = 1,
  nl_filter = "Median",
  nl_size = 3,
  gap_reconstruct = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gap_detection_+3A_las">las</code></td>
<td>
<p>An object of class <code><a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a></code>,
<code><a href="lidR.html#topic+LAS-class">LAS-class</a></code> or <code><a href="lidR.html#topic+LAScatalog-class">LAScatalog-class</a></code></p>
</td></tr>
<tr><td><code id="gap_detection_+3A_res">res</code></td>
<td>
<p>numeric. The size of a grid cell in point cloud coordinates units,
used to rasterize the point cloud. In case the <code>las</code> argument is a 
<code>SpatRaster</code> <code>res</code> is not used.</p>
</td></tr>
<tr><td><code id="gap_detection_+3A_ratio">ratio</code></td>
<td>
<p>numeric. maximum ratio between surrounding canopy height and gap
distance (a pixel belongs to the gap only if for any vegetation pixel around
it, the distance to the vegetation pixel is larger than pixel height/ratio).
If ratio is set to NULL, this criterion is not taken into account</p>
</td></tr>
<tr><td><code id="gap_detection_+3A_gap_max_height">gap_max_height</code></td>
<td>
<p>numeric. maximum canopy height to be considered as gap</p>
</td></tr>
<tr><td><code id="gap_detection_+3A_min_gap_surface">min_gap_surface</code></td>
<td>
<p>numeric. minimum gap surface</p>
</td></tr>
<tr><td><code id="gap_detection_+3A_max_gap_surface">max_gap_surface</code></td>
<td>
<p>numeric. maximum gap surface</p>
</td></tr>
<tr><td><code id="gap_detection_+3A_closing_height_bin">closing_height_bin</code></td>
<td>
<p>numeric. height bin width for morphological closing
of gaps to test ratio between canopy height and gap distance</p>
</td></tr>
<tr><td><code id="gap_detection_+3A_nl_filter">nl_filter</code></td>
<td>
<p>string. type of non-linear filter to apply to canopy height
model to remove artefacts, should be an option of <code><a href="#topic+dem_filtering">dem_filtering</a></code></p>
</td></tr>
<tr><td><code id="gap_detection_+3A_nl_size">nl_size</code></td>
<td>
<p>numeric. kernel width in pixel for non-linear filtering</p>
</td></tr>
<tr><td><code id="gap_detection_+3A_gap_reconstruct">gap_reconstruct</code></td>
<td>
<p>boolean. default behaviour is that areas that do not
fulfill the ratio criterion are removed from gaps. If set to TRUE, in case
some pixels of a gap fulfill the distance criterion, the connected pixels that
fulfill the height criterion are also integrated to it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatRaster</code> object with three layers: gap labels, gap surface 
and canopy height model after filter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dem_filtering">dem_filtering</a></code>, <code><a href="#topic+edge_detection">edge_detection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

# fill NA values in canopy height model
chm_chablais3[is.na(chm_chablais3)] &lt;- 0

# gap detection with distance larger than canopy height / 2
gaps &lt;- gap_detection(chm_chablais3, ratio = 2, gap_max_height = 1, 
min_gap_surface = 0)

# gap detection with distance larger than canopy height / 2
# and reconstruction of border areas
gaps1 &lt;- gap_detection(chm_chablais3,
  ratio = 2, gap_max_height = 1, min_gap_surface = 0,
  gap_reconstruct = TRUE
)

# gap detection without distance criterion
gaps2 &lt;- gap_detection(chm_chablais3, ratio = NULL, gap_max_height = 1, 
min_gap_surface = 0)

# gap id and corresponding surface for third detection parameters
table(terra::values(gaps2$gap_id)) * terra::res(gaps2$gap_id)[1]^2

# plot original image
terra::plot(chm_chablais3, main = "Initial image")

# plot binary image of gaps
terra::plot(gaps$gap_id &gt; 0, main = "Gaps", col = "green", legend = FALSE)
terra::plot(gaps1$gap_id &gt; 0, main = "Gaps, with reconstruction", col = "green", legend = FALSE)
terra::plot(gaps2$gap_id &gt; 0, main = "Gaps, no width criterion", col = "green", legend = FALSE)

# plot filtered CHM
terra::plot(gaps2$filled_chm, main = "Filtered CHM")
</code></pre>

<hr>
<h2 id='height_regression'>Regression of detected heights VS reference heights</h2><span id='topic+height_regression'></span>

<h3>Description</h3>

<p>Computes a linear regression model between the reference heights and the 
detected heights of matched pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>height_regression(lr, ld, matched, plot = TRUE, species = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="height_regression_+3A_lr">lr</code></td>
<td>
<p>data.frame or matrix. 3D coordinates (X Y Height) of reference 
positions</p>
</td></tr>
<tr><td><code id="height_regression_+3A_ld">ld</code></td>
<td>
<p>data.frame or matrix. 3D coordinates (X Y Height) of detected 
positions</p>
</td></tr>
<tr><td><code id="height_regression_+3A_matched">matched</code></td>
<td>
<p>data.frame. contains pair indices, typically returned by <code><a href="#topic+tree_matching">tree_matching</a></code></p>
</td></tr>
<tr><td><code id="height_regression_+3A_plot">plot</code></td>
<td>
<p>boolean. indicates whether results should be plotted</p>
</td></tr>
<tr><td><code id="height_regression_+3A_species">species</code></td>
<td>
<p>vector of strings. species for standardized color use by call 
to <code><a href="#topic+species_color">species_color</a></code></p>
</td></tr>
<tr><td><code id="height_regression_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, as in <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements. First one is the linear regression model, 
second one is a list with stats (root mean square error, bias and standard 
deviation of detected heights compared to reference heights).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree_matching">tree_matching</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create tree locations and heights
ref_trees &lt;- cbind(c(1, 4, 3, 4, 2), c(1, 1, 2, 3, 4), c(15, 18, 20, 10, 11))
def_trees &lt;- cbind(c(2, 2, 4, 4), c(1, 3, 4, 1), c(16, 19, 9, 15))

# tree matching
match1 &lt;- tree_matching(ref_trees, def_trees)

# height regression
reg &lt;- height_regression(ref_trees, def_trees, match1,
  species = c("ABAL", "ABAL", "FASY", "FASY", "ABAL"),
  asp = 1, xlim = c(0, 21), ylim = c(0, 21)
)
summary(reg$lm)
reg$stats
</code></pre>

<hr>
<h2 id='hist_detection'>Histogram of detection</h2><span id='topic+hist_detection'></span>

<h3>Description</h3>

<p>Displays the histogram of tree heights of three categories: true detections, omissions, and false detections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_detection(lr, ld, matched, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_detection_+3A_lr">lr</code></td>
<td>
<p>data.frame or matrix. 3D coordinates (X Y Height) of reference positions</p>
</td></tr>
<tr><td><code id="hist_detection_+3A_ld">ld</code></td>
<td>
<p>data.frame or matrix. 3D coordinates (X Y Height) of detected positions</p>
</td></tr>
<tr><td><code id="hist_detection_+3A_matched">matched</code></td>
<td>
<p>data.frame. contains pair indices, typically returned by <code><a href="#topic+tree_matching">tree_matching</a></code></p>
</td></tr>
<tr><td><code id="hist_detection_+3A_plot">plot</code></td>
<td>
<p>boolean. should the histogram be displayed or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three numerics: numbers of true detections, omissions and false detections
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree_matching">tree_matching</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create reference and detected trees
ref_trees &lt;- cbind(c(1, 4, 3, 4, 2), c(1, 1, 2, 3, 4), c(15, 18, 20, 10, 11))
def_trees &lt;- cbind(c(2, 2, 4, 4), c(1, 3, 4, 1), c(16, 19, 9, 15))
#
# tree matching with different buffer size
match1 &lt;- tree_matching(ref_trees, def_trees)
match2 &lt;- tree_matching(ref_trees, def_trees, delta_ground = 2, h_prec = 0)
#
# corresponding number of detections
hist_detection(ref_trees, def_trees, match1)
hist_detection(ref_trees, def_trees, match2)
</code></pre>

<hr>
<h2 id='hist_stack'>Stacked histogram</h2><span id='topic+hist_stack'></span>

<h3>Description</h3>

<p>Stacked histogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_stack(x, breaks, col = NULL, breaksFun = paste, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_stack_+3A_x">x</code></td>
<td>
<p>list of vectors. values for each category</p>
</td></tr>
<tr><td><code id="hist_stack_+3A_breaks">breaks</code></td>
<td>
<p>vector. breaks for histogram bins</p>
</td></tr>
<tr><td><code id="hist_stack_+3A_col">col</code></td>
<td>
<p>vector. colors for each category</p>
</td></tr>
<tr><td><code id="hist_stack_+3A_breaksfun">breaksFun</code></td>
<td>
<p>function for breaks display</p>
</td></tr>
<tr><td><code id="hist_stack_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, as in <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return
</p>

<hr>
<h2 id='las_chablais3'>las data in France (Chablais 3 plot)</h2><span id='topic+las_chablais3'></span>

<h3>Description</h3>

<p>Airborne laser scanning data over the Chablais 3 plot, acquired in 2009 by Sintegra, copyright INRAE
</p>


<h3>Format</h3>

<p>A compressed LAS file
</p>


<h3>Details</h3>

<p>Additional information about the data
</p>

<ul>
<li><p>Sensor: RIEGL LMS-Q560
</p>
</li>
<li><p>EPSG code of coordinates system: 2154
</p>
</li></ul>



<h3>Source</h3>

<p>Monnet J.-M. INRAE
</p>


<h3>References</h3>

<p>Monnet, J.-M. 2011. Using airborne laser scanning for mountain forests mapping: Support vector regression for stand parameters estimation and unsupervised training for treetop detection. Ph.D. thesis. University of Grenoble, France. pp. 21-22. <a href="https://theses.hal.science/tel-00652698/document">https://theses.hal.science/tel-00652698/document</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chm_chablais3">chm_chablais3</a></code>, <code><a href="#topic+tree_inventory_chablais3">tree_inventory_chablais3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LASfile &lt;- system.file("extdata", "las_chablais3.laz", package="lidaRtRee")
las_chablais3 &lt;- lidR::readLAS(LASfile)
# set projection information
lidR::projection(las_chablais3) &lt;- 2154
las_chablais3
</code></pre>

<hr>
<h2 id='lma_check'>Checks linear model assumptions of a multiple regression model</h2><span id='topic+lma_check'></span>

<h3>Description</h3>

<p>The performed tests are:
</p>

<ul>
<li><p> partial p.values calculated by <code><a href="stats.html#topic+lm">lm</a></code> are all below a given value
</p>
</li>
<li><p> tests implemented by <code><a href="gvlma.html#topic+gvlma">gvlma</a></code>
</p>
</li>
<li><p> variance inflation factors calculated by <code><a href="car.html#topic+vif">vif</a></code> are all below a given value
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>lma_check(formule, df, max.pvalue = 0.05, max.vif = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lma_check_+3A_formule">formule</code></td>
<td>
<p>formula. model to be evaluated</p>
</td></tr>
<tr><td><code id="lma_check_+3A_df">df</code></td>
<td>
<p>data.frame. data to evaluate the model</p>
</td></tr>
<tr><td><code id="lma_check_+3A_max.pvalue">max.pvalue</code></td>
<td>
<p>numeric. maximum p-value of variables included in the model</p>
</td></tr>
<tr><td><code id="lma_check_+3A_max.vif">max.vif</code></td>
<td>
<p>numeric. maximum variance inflation factor of variables included in the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one line data.frame with 5 columns.
</p>

<ul>
<li><p> a string: evaluated formula
</p>
</li>
<li><p> a numeric: the adjusted R squared of the model
</p>
</li>
<li><p> a boolean: do all variables in the model have a partial p-value &lt; <code>max.pvalue</code>
</p>
</li>
<li><p> a boolean: are all tests implemented by <code><a href="gvlma.html#topic+gvlma">gvlma</a></code> false
</p>
</li>
<li><p> a boolean: is the variance inflation factor computed with <code><a href="car.html#topic+vif">vif</a></code> of all variables &lt; <code>max.vif</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># load Quatre Montagnes dataset
data(quatre_montagnes)
# fit lm model
model &lt;- lm(G_m2_ha ~ zmax + zq95, data = quatre_montagnes)
lma_check(eval(model$call[[2]]), quatre_montagnes)
# trying with Box-Cox transformation of dependent variable
# and other independent variables
model &lt;- lm(boxcox_tr(G_m2_ha, -0.14) ~ Tree_meanH + Tree_density + zpcum7, data = quatre_montagnes)
lma_check(eval(model$call[[2]]), quatre_montagnes)
</code></pre>

<hr>
<h2 id='maxima_detection'>Local maxima extraction on image</h2><span id='topic+maxima_detection'></span>

<h3>Description</h3>

<p>Variable window size maxima detection is performed on the image to extract 
local maxima position and calculate the window size where they are global 
maxima. Gaussian white noise is added to the image to avoid adjacent maxima 
due to neighbor pixels with identical value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxima_detection(dem, dem.res = 1, max.width = 11, jitter = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxima_detection_+3A_dem">dem</code></td>
<td>
<p>cimg object (e.g. as created by <code><a href="imager.html#topic+cimg">cimg</a></code>) or 
SpatRaster object (e.g. obtained with <code><a href="terra.html#topic+rast">rast</a></code>)</p>
</td></tr>
<tr><td><code id="maxima_detection_+3A_dem.res">dem.res</code></td>
<td>
<p>numeric. image resolution, in case <code>dem</code> is a SpatRaster 
object, <code>dem.res</code> is extracted from the object by <code><a href="terra.html#topic+res">res</a></code></p>
</td></tr>
<tr><td><code id="maxima_detection_+3A_max.width">max.width</code></td>
<td>
<p>numeric. maximum kernel width to check for local maximum, in 
pixels if <code>dem</code> is a cimg, in SpatRaster units otherwise</p>
</td></tr>
<tr><td><code id="maxima_detection_+3A_jitter">jitter</code></td>
<td>
<p>boolean. indicates if noise should be added to image values to 
avoid adjacent maxima due to the adjacent pixels with equal values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cimg object / SpatRaster object which values correspond to the radius 
(n) in pixels / meters of the square window (width 2n+1) where the center pixel is global 
maximum (tested up to the <code>max.width</code> parameter)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dem_filtering">dem_filtering</a></code>, <code><a href="#topic+maxima_selection">maxima_selection</a></code>, 
<code><a href="#topic+tree_segmentation">tree_segmentation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

# maxima detection
maxi &lt;- maxima_detection(chm_chablais3)

# plot original image
terra::plot(chm_chablais3, main = "Initial image")

# plot maxima image
terra::plot(maxi, main = "Local maxima")
</code></pre>

<hr>
<h2 id='maxima_selection'>Image maxima selection based on values and neighborhood of local maxima</h2><span id='topic+maxima_selection'></span>

<h3>Description</h3>

<p>In a maxima image (output of <code><a href="#topic+maxima_detection">maxima_detection</a></code>), sets values to 
zero for pixels which:
</p>

<ol>
<li><p> values in the initial image (from which maxima were detected) are below 
a threshold
</p>
</li>
<li><p> values in the maxima image (corresponding to the radius of the 
neighborhood where they are global maxima) are below a threshold depending on 
the initial image value.
</p>
</li></ol>

<p>Make sure that the <code>max.width</code> parameter in <code><a href="#topic+maxima_detection">maxima_detection</a></code>
is consistent with the selection parameters (e.g. do not select with 
<code>dmin = 7</code> if values were only tested up to <code>max.width</code> the default 
value which is approx. 5.5 m).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxima_selection(maxi, dem_nl, hmin = 5, dmin = 0, dprop = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxima_selection_+3A_maxi">maxi</code></td>
<td>
<p>cimg object or SpatRaster object. image with local maxima 
(typically output from <code><a href="#topic+maxima_detection">maxima_detection</a></code>, image values correspond 
to neighborhood radius on which pixels are global maxima in the initial image)</p>
</td></tr>
<tr><td><code id="maxima_selection_+3A_dem_nl">dem_nl</code></td>
<td>
<p>cimg object or SpatRaster object. initial image from which maxima were detected</p>
</td></tr>
<tr><td><code id="maxima_selection_+3A_hmin">hmin</code></td>
<td>
<p>numeric. minimum value in initial image for a maximum to be selected</p>
</td></tr>
<tr><td><code id="maxima_selection_+3A_dmin">dmin</code></td>
<td>
<p>numeric. intercept term for selection of maxima depending on 
neighborhood radius: <code>maxi &gt;= dmin + dem_nl * dprop</code></p>
</td></tr>
<tr><td><code id="maxima_selection_+3A_dprop">dprop</code></td>
<td>
<p>numeric. proportional term for selection of maxima depending on 
neighborhood radius: <code>maxi &gt;= dmin + dem_nl * dprop</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cimg object or SpatRaster object which values are the radius (n) 
in meter of the square window (width 2n+1) where the center pixel is global 
maximum and which fulfill the selection criteria
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxima_detection">maxima_detection</a></code>, <code><a href="#topic+tree_segmentation">tree_segmentation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

# maxima detection
maxi &lt;- maxima_detection(chm_chablais3)

# several maxima selection settings
selected_maxi_hmin &lt;- maxima_selection(maxi, chm_chablais3, hmin = 15)
selected_maxi_dm &lt;- maxima_selection(maxi, chm_chablais3, dmin = 2.5)
selected_maxi &lt;- maxima_selection(maxi, chm_chablais3, dmin = 1, dprop = 0.1)

# corresponding count number of remaining maxima
table(terra::values(maxi))
table(terra::values(selected_maxi_hmin))
table(terra::values(selected_maxi_dm))
table(terra::values(selected_maxi))

# plot original image
terra::plot(chm_chablais3, main = "Initial image")

# plot maxima images, original and first case
terra::plot(maxi, main = "Local maxima")
terra::plot(selected_maxi, main = "Selected maxima")
</code></pre>

<hr>
<h2 id='plot_matched'>Plot of matched pairs of detected and reference trees</h2><span id='topic+plot_matched'></span>

<h3>Description</h3>

<p>Plot of matched pairs of detected and reference trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_matched(lr, ld, matched, chm = NULL, plot_border = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_matched_+3A_lr">lr</code></td>
<td>
<p>data.frame or matrix. 3D coordinates (X Y Height) of reference 
positions</p>
</td></tr>
<tr><td><code id="plot_matched_+3A_ld">ld</code></td>
<td>
<p>data.frame or matrix. 3D coordinates (X Y Height) of detected 
positions</p>
</td></tr>
<tr><td><code id="plot_matched_+3A_matched">matched</code></td>
<td>
<p>data.frame. contains pair indices, typically returned by <code><a href="#topic+tree_matching">tree_matching</a></code></p>
</td></tr>
<tr><td><code id="plot_matched_+3A_chm">chm</code></td>
<td>
<p>raster object. raster for background display</p>
</td></tr>
<tr><td><code id="plot_matched_+3A_plot_border">plot_border</code></td>
<td>
<p>sf or SpatVector object. plot boundaries for display</p>
</td></tr>
<tr><td><code id="plot_matched_+3A_...">...</code></td>
<td>
<p>Additional arguments to be used by <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree_matching">tree_matching</a></code>, <code><a href="#topic+hist_detection">hist_detection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create reference and detected trees
ref_trees &lt;- cbind(c(1, 4, 3, 4, 2), c(1, 1.5, 2, 3, 4), c(15, 18, 20, 10, 11))
def_trees &lt;- cbind(c(2, 2, 4, 4), c(1, 3, 4, 1), c(16, 19, 9, 15))
#
# compute matching
match1 &lt;- tree_matching(ref_trees, def_trees)
match2 &lt;- tree_matching(ref_trees, def_trees, delta_ground = 2, h_prec = 0)

# 2D display of matching results
plot_matched(ref_trees, def_trees, match1, xlab = "X", ylab = "Y")
plot_matched(ref_trees, def_trees, match2, xlab = "X", ylab = "Y")
</code></pre>

<hr>
<h2 id='plot_tree_inventory'>Displays a map of tree inventory data</h2><span id='topic+plot_tree_inventory'></span>

<h3>Description</h3>

<p>displays tree inventory data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tree_inventory(xy, height = NULL, diam = NULL, species = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_tree_inventory_+3A_xy">xy</code></td>
<td>
<p>data.frame with X, Y coordinates of tree
centers in two columns</p>
</td></tr>
<tr><td><code id="plot_tree_inventory_+3A_height">height</code></td>
<td>
<p>vector.  tree heights in meters</p>
</td></tr>
<tr><td><code id="plot_tree_inventory_+3A_diam">diam</code></td>
<td>
<p>vector. tree diameters in centimeters</p>
</td></tr>
<tr><td><code id="plot_tree_inventory_+3A_species">species</code></td>
<td>
<p>vector. species abbreviation as in <code><a href="#topic+species_color">species_color</a></code> 
for display with corresponding color</p>
</td></tr>
<tr><td><code id="plot_tree_inventory_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, as in <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return
</p>


<h3>See Also</h3>

<p><code><a href="#topic+species_color">species_color</a></code> for a table of species and associated colors
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load tree inventory data from plot Chablais 3
data("tree_inventory_chablais3")

# display tree inventory
plot_tree_inventory(tree_inventory_chablais3[, c("x", "y")],
  diam = tree_inventory_chablais3$d, col = "red",
  pch = tree_inventory_chablais3$e,
  xlab = "X", ylab = "Y"
)

# display tree inventory with CHM background
data("chm_chablais3")
chm_chablais3 &lt;- terra::rast(chm_chablais3)
terra::plot(chm_chablais3, col = gray(seq(0, 1, 1 / 255)))
plot_tree_inventory(tree_inventory_chablais3[, c("x", "y")],
  height = tree_inventory_chablais3$h,
  species = tree_inventory_chablais3$s,
  add = TRUE
)
</code></pre>

<hr>
<h2 id='pointList2poly'>Convert a list of points into spatial polygons object</h2><span id='topic+pointList2poly'></span>

<h3>Description</h3>

<p>Converts a list of points specifying polygons into a spatial object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointList2poly(points_list, df = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointList2poly_+3A_points_list">points_list</code></td>
<td>
<p>list of data frames of xy coordinates. In each data.frame 
the last row must be the same as the first row</p>
</td></tr>
<tr><td><code id="pointList2poly_+3A_df">df</code></td>
<td>
<p>data.frame. Optional data.frame to be associated to polygons</p>
</td></tr>
<tr><td><code id="pointList2poly_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="sf.html#topic+st_sfc">st_sfc</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a simple feature collection with POLYGON geometry.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ellipses4Crown">ellipses4Crown</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute coordinates of polygons
ellipses &lt;- ellipses4Crown(c(0, 10), c(0, 10), c(2, 2), c(3, 4), c(2.5, 3), c(2, 3),
  id = c("A", "B")
)
# Convert to sf object
ellipses1 &lt;- pointList2poly(ellipses)
ellipses1
# Convert to sf object with user-defined data.frame
ellipses2 &lt;- pointList2poly(ellipses, df = data.frame(info = 1:2))

# draw ellipses
plot(ellipses2, col = ellipses2$info)
</code></pre>

<hr>
<h2 id='points2DSM'>Digital Surface Model</h2><span id='topic+points2DSM'></span>

<h3>Description</h3>

<p>Creates a Digital Surface Model from a LAS object. From version 4.0.0 relies on <code><a href="lidR.html#topic+rasterize_canopy">rasterize_canopy</a></code>.
Maintained for backward compatibility but a direct call to this function 
should be preferred. Raster extent is specified by the coordinates of lower
left and upper right corners. Default extent covers
the full range of points, and aligns on multiple values of the resolution.
Cell value is the maximum height of points contained in the cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2DSM(.las, res = 1, xmin, xmax, ymin, ymax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points2DSM_+3A_.las">.las</code></td>
<td>
<p><code><a href="lidR.html#topic+LAS">LAS</a></code> object or XYZ matrix/data.frame</p>
</td></tr>
<tr><td><code id="points2DSM_+3A_res">res</code></td>
<td>
<p>numeric. raster resolution</p>
</td></tr>
<tr><td><code id="points2DSM_+3A_xmin">xmin</code></td>
<td>
<p>numeric. lower left corner easting coordinate for output raster.</p>
</td></tr>
<tr><td><code id="points2DSM_+3A_xmax">xmax</code></td>
<td>
<p>numeric. upper right corner easting coordinate for output raster.</p>
</td></tr>
<tr><td><code id="points2DSM_+3A_ymin">ymin</code></td>
<td>
<p>numeric. lower left corner northing coordinate for output raster.</p>
</td></tr>
<tr><td><code id="points2DSM_+3A_ymax">ymax</code></td>
<td>
<p>numeric. upper right corner northing coordinate for output raster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+points2DTM">points2DTM</a></code> for Digital Terrain Model computation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load LAS file
LASfile &lt;- system.file("extdata", "las_chablais3.laz", package="lidaRtRee")
las_chablais3 &lt;- lidR::readLAS(LASfile)
# set projection
lidR::projection(las_chablais3) &lt;- 2154

# create a digital surface model with first-return points, resolution 0.5 m
dsm &lt;- points2DSM(lidR::filter_first(las_chablais3), res = 0.5)

# display raster
terra::plot(dsm)
</code></pre>

<hr>
<h2 id='points2DTM'>Digital Terrain Model</h2><span id='topic+points2DTM'></span>

<h3>Description</h3>

<p>Creates a Digital Terrain Model from LAS object or XYZ data. Raster extent is
specified by the coordinates of lower left and upper right corners. Default 
extent covers the full range of points, and aligns on multiple values of the 
resolution. Cell value is compute as the bilinear interpolation at the cell 
center form an Delaunay triangulation. Relies on <code><a href="lidR.html#topic+rasterize_terrain">rasterize_terrain</a></code> 
with algorithm <code><a href="lidR.html#topic+tin">tin</a></code>. In case a LAS object is provided, only 
points classified as ground or water (2 or 9) will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2DTM(.las, res = 1, xmin, xmax, ymin, ymax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points2DTM_+3A_.las">.las</code></td>
<td>
<p><code><a href="lidR.html#topic+LAS">LAS</a></code> object or XYZ matrix/data.frame containing 
only ground points</p>
</td></tr>
<tr><td><code id="points2DTM_+3A_res">res</code></td>
<td>
<p>numeric. raster resolution</p>
</td></tr>
<tr><td><code id="points2DTM_+3A_xmin">xmin</code></td>
<td>
<p>numeric. lower left corner easting coordinate for output raster.</p>
</td></tr>
<tr><td><code id="points2DTM_+3A_xmax">xmax</code></td>
<td>
<p>numeric. upper right corner easting coordinate for output raster.</p>
</td></tr>
<tr><td><code id="points2DTM_+3A_ymin">ymin</code></td>
<td>
<p>numeric. lower left corner northing coordinate for output raster.</p>
</td></tr>
<tr><td><code id="points2DTM_+3A_ymax">ymax</code></td>
<td>
<p>numeric. upper right corner northing coordinate for output raster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+points2DSM">points2DSM</a></code> for Digital Surface Model computation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load LAS file
LASfile &lt;- system.file("extdata", "las_chablais3.laz", package="lidaRtRee")
las_chablais3 &lt;- lidR::readLAS(LASfile)
# set projection
lidR::projection(las_chablais3) &lt;- 2154

# create digital terrain model with points classified as ground
dtm &lt;- points2DTM(las_chablais3)

# display raster
terra::plot(dtm)
</code></pre>

<hr>
<h2 id='polar2Projected'>Polar to cartesian coordinates conversion</h2><span id='topic+polar2Projected'></span>

<h3>Description</h3>

<p>Computes projected coordinates (Easting, Northing, Altitude) from polar 
coordinates (Azimuth, Slope, Distance) and center position (Easting, Northing, 
Altitude). Magnetic declination and meridian convergence are optional parameters. 
In case distance is measured to the border of objects (e.g. trees), the diameter 
can be added to compute the coordinates of object center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polar2Projected(
  x,
  y,
  z = 0,
  azimuth,
  dist,
  slope = 0,
  declination = 0,
  convergence = 0,
  diameter = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polar2Projected_+3A_x">x</code></td>
<td>
<p>vector. easting coordinates of centers in meter</p>
</td></tr>
<tr><td><code id="polar2Projected_+3A_y">y</code></td>
<td>
<p>vector. northing coordinates of centers in meter</p>
</td></tr>
<tr><td><code id="polar2Projected_+3A_z">z</code></td>
<td>
<p>vector. altitudes of centers in meters</p>
</td></tr>
<tr><td><code id="polar2Projected_+3A_azimuth">azimuth</code></td>
<td>
<p>vector. azimuth values from centers in radian</p>
</td></tr>
<tr><td><code id="polar2Projected_+3A_dist">dist</code></td>
<td>
<p>vector. distances between centers and objects in meter</p>
</td></tr>
<tr><td><code id="polar2Projected_+3A_slope">slope</code></td>
<td>
<p>vector. slope values from centers in radian</p>
</td></tr>
<tr><td><code id="polar2Projected_+3A_declination">declination</code></td>
<td>
<p>vector. magnetic declination values in radian</p>
</td></tr>
<tr><td><code id="polar2Projected_+3A_convergence">convergence</code></td>
<td>
<p>vector. meridian convergence values in radian</p>
</td></tr>
<tr><td><code id="polar2Projected_+3A_diameter">diameter</code></td>
<td>
<p>vector. diameters in meter (e.g. in case a radius should be 
added to the distance)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with easting, northing and altitude coordinates, and 
horizontal distance from centers to objects centers
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_tree_inventory">plot_tree_inventory</a></code> for tree inventory display
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data.frame of trees with polar coordinates and diameters
trees &lt;- data.frame(
  x = rep(c(0, 10), each = 2),
  y = rep(c(0, 10), each = 2),
  z = rep(c(0, 2), each = 2),
  azimuth = rep(c(0, pi / 3)),
  dist = rep(c(2, 4)),
  slope = rep(c(0, pi / 6)),
  diameter.cm = c(15, 20, 25, 30)
)
trees

# compute projected coordinates
polar2Projected(trees$x, trees$y, trees$z, trees$azimuth, trees$dist,
  trees$slope,
  declination = 0.03, convergence = 0.02, trees$diameter.cm / 100
)
</code></pre>

<hr>
<h2 id='quatre_montagnes'>Field plot inventory in the Quatre Montagnes area (France)</h2><span id='topic+quatre_montagnes'></span>

<h3>Description</h3>

<p>Dataset of forest parameters measured in the field on 96 circular plots of 15 m radius. Metrics derived from airborne laser scanning (ALS) point clouds have also been extracted and calculated for those plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(quatre_montagnes)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 76 columns:
</p>

<ol>
<li> <p><code>plotId</code> id of field plot
</p>
</li>
<li> <p><code>X</code> easting coordinate (epsg: 2154)
</p>
</li>
<li> <p><code>Y</code> northing coordinate (epsg: 2154)
</p>
</li>
<li> <p><code>clusterId</code> id of cluster, plots were inventoried in groups of 4
</p>
</li>
<li> <p><code>G_m2_ha</code> basal area in m2 per ha
</p>
</li>
<li> <p><code>N_ha</code> number of trees per ha
</p>
</li>
<li> <p><code>D_mean_cm</code> mean tree diameter at breast height (1.3 m) in cm
</p>
</li>
<li> <p><code>stratum</code> forest ownership (public or private)
</p>
</li>
<li> <p><code>[, 9:60]</code> point cloud metrics computed from ALS, see <code><a href="#topic+aba_metrics">aba_metrics</a></code>
</p>
</li>
<li> <p><code>[, 61:73]</code> metrics derived from tree segmentation in ALS data, see <code><a href="#topic+std_tree_metrics">std_tree_metrics</a></code>
</p>
</li>
<li> <p><code>[, 74:76]</code> terrain statistics, see <code><a href="#topic+terrain_points_metrics">terrain_points_metrics</a></code>
</p>
</li></ol>



<h3>References</h3>

<p>Monnet, J.-M. 2021. Tutorial on modeling forest parameters with ALS data. ABA data preparation <a href="https://gitlab.irstea.fr/jean-matthieu.monnet/lidartree_tutorials/-/wikis/ABA-data-preparation">https://gitlab.irstea.fr/jean-matthieu.monnet/lidartree_tutorials/-/wikis/ABA-data-preparation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(quatre_montagnes)
summary(quatre_montagnes)
</code></pre>

<hr>
<h2 id='raster_chull_mask'>Raster mask of convex hull</h2><span id='topic+raster_chull_mask'></span>

<h3>Description</h3>

<p>creates raster mask corresponding to the convex hull of xy positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_chull_mask(xy, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_chull_mask_+3A_xy">xy</code></td>
<td>
<p>2 columns matrix or data.frame. xy positions</p>
</td></tr>
<tr><td><code id="raster_chull_mask_+3A_r">r</code></td>
<td>
<p>raster object. target raster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatRaster with 0 or 1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raster_xy_mask">raster_xy_mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create raster
r &lt;- terra::rast(extent = c(0, 40, 0, 40), resolution = 1, crs = "epsg:2154")


# xy positions
xy &lt;- data.frame(
  x = c(10, 20, 31.25, 15),
  y = c(10, 20, 31.25, 25)
)
# compute mask
mask1 &lt;- raster_chull_mask(xy, r)

# display binary raster
terra::plot(mask1)
graphics::points(xy)
</code></pre>

<hr>
<h2 id='raster_local_max'>Statistics of raster local maximum</h2><span id='topic+raster_local_max'></span>

<h3>Description</h3>

<p>identifies global maximum and second global maximum from raster (e.g. output 
from <code><a href="#topic+rasters_moving_cor">rasters_moving_cor</a></code>), and computes related statistics. Local 
maxima can be excluded based on a minimum distance <code>dm</code> to nearest local 
maximum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_local_max(r, dm = 2, med1 = 1, med2 = 2, quanta = 0.75, quantb = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_local_max_+3A_r">r</code></td>
<td>
<p>SpatRaster. typically output of <code><a href="#topic+rasters_moving_cor">rasters_moving_cor</a></code></p>
</td></tr>
<tr><td><code id="raster_local_max_+3A_dm">dm</code></td>
<td>
<p>numeric. minimum distance between two local maxima in meters</p>
</td></tr>
<tr><td><code id="raster_local_max_+3A_med1">med1</code></td>
<td>
<p>numeric. window radius to compute median value around the maximum 
position (default: 1m)</p>
</td></tr>
<tr><td><code id="raster_local_max_+3A_med2">med2</code></td>
<td>
<p>numeric. window radius #2 to compute median value around the 
maximum position (default: 2m)</p>
</td></tr>
<tr><td><code id="raster_local_max_+3A_quanta">quanta</code></td>
<td>
<p>numeric. quantile value to compute for raster values (default: 
3rd quartile)</p>
</td></tr>
<tr><td><code id="raster_local_max_+3A_quantb">quantb</code></td>
<td>
<p>numeric. quantile #2 value to compute for raster values 
(default: median)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with value of maximum, position of maximum, position of 
second maximum, ratio of max value to 2nd max, ratio of max value to median 
of neighborhood (size1 and size 2), ratio of max value to raster quantiles 1 
and 2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rasters_moving_cor">rasters_moving_cor</a></code>, <code><a href="#topic+coregistration">coregistration</a></code> for 
application to the coregistration of tree inventory data with canopy height 
models
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create raster
r_b &lt;- terra::rast(xmin = 0, xmax = 40, ymin =0 , ymax = 40,
resolution = 1, crs = NA)
xy &lt;- terra::xyFromCell(r_b, 1:(nrow(r_b) * ncol(r_b)))

# add Gaussian surfaces
z1 &lt;- 1.5 * exp(-((xy[, 1] - 22)^2 + (xy[, 2] - 22)^2 / 2) / 5)
z2 &lt;- exp(-((xy[, 1] - 20)^2 + (xy[, 2] - 22)^2 / 2) / 3)
z3 &lt;- 1.5 * exp(-((xy[, 1] - 17)^2 + (xy[, 2] - 17)^2 / 2) / 5)
r_b &lt;- terra::rast(cbind(xy, z1 + z2 + z3), type = "xyz")

# create small raster
r_s &lt;- terra::crop(r_b, terra::ext(c(15, 25, 15, 25)))
# offset raster by (-2, -2)
terra::ext(r_s) &lt;- c(13, 23, 13, 23)

rr &lt;- rasters_moving_cor(r_b, r_s, buffer = 6, step = 1)
loc_max &lt;- raster_local_max(rr)
loc_max

# plot raster
terra::plot(rr)
# add location of two local maxima
graphics::points(loc_max[1, c("dx1", "dx2")], loc_max[1, c("dy1", "dy2")],
  cex = c(1, 0.5), pch = 3
)
</code></pre>

<hr>
<h2 id='raster_metrics'>Computes metrics by aggregating a raster at lower resolution or summarizing
attributes based on XY locations</h2><span id='topic+raster_metrics'></span>

<h3>Description</h3>

<p>Computes statistics by aggregating a raster at lower resolution. Aggregation
groups are larger cells, new values are computed by applying a user-specified
function to original cells contained in the larger cells. Results are provided
as a data.frame with the XY coordinates of the larger cells, or as SpatRaster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_metrics(
  r,
  res = 20,
  fun = function(x) {
     data.frame(mean = mean(x[, 3]), sd = stats::sd(x[, 3]))
 },
  output = "raster"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_metrics_+3A_r">r</code></td>
<td>
<p>SpatRaster object, data.frame with xy coordinates in two first columns, or POINT <code><a href="sf.html#topic+sf">sf</a></code> spatial object</p>
</td></tr>
<tr><td><code id="raster_metrics_+3A_res">res</code></td>
<td>
<p>numeric. Resolution of the aggregation raster, should be a multiple
of r resolution if a raster is provided</p>
</td></tr>
<tr><td><code id="raster_metrics_+3A_fun">fun</code></td>
<td>
<p>function. Function to compute metrics in each aggregated cell from
the values contained in the initial raster (use x$layer to access raster
values) / data.frame (use x$colum_name to access values)</p>
</td></tr>
<tr><td><code id="raster_metrics_+3A_output">output</code></td>
<td>
<p>string. indicates the class of output object &quot;raster&quot; for a SpatRaster or &quot;data.frame&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the XY center coordinates of the aggregated cells,
and the values computed with the user-specified function, or a SpatRaster object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

# raster metrics from raster
metrics1 &lt;- raster_metrics(chm_chablais3, res = 10)
metrics1

# raster metrics from data.frame
n &lt;- 1000
df &lt;- data.frame(
  x = runif(n, 0, 100), y = runif(n, 0, 100), z1 = runif(n, 0, 1),
  z2 = runif(n, 10, 20)
)
# compute raster metrics
metrics2 &lt;- raster_metrics(df,
  res = 10,
  fun = function(x) {
    data.frame(max.z = max(x$z1), max.sum = max(x$z1 + x$z2))
  },
  output = "data.frame"
)
summary(metrics2)

# display raster metrics
terra::plot(metrics1)
# display data.frame metrics
terra::plot(terra::rast(metrics2, type = "xyz"))
</code></pre>

<hr>
<h2 id='raster_xy_mask'>Raster mask by union of buffers around xy positions</h2><span id='topic+raster_xy_mask'></span>

<h3>Description</h3>

<p>creates a raster mask by union of circular buffers around xy positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_xy_mask(xy, buff, r, binary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_xy_mask_+3A_xy">xy</code></td>
<td>
<p>2 columns matrix or data.frame. xy positions</p>
</td></tr>
<tr><td><code id="raster_xy_mask_+3A_buff">buff</code></td>
<td>
<p>vector.  buffers to apply to the xy positions</p>
</td></tr>
<tr><td><code id="raster_xy_mask_+3A_r">r</code></td>
<td>
<p>raster object. target raster</p>
</td></tr>
<tr><td><code id="raster_xy_mask_+3A_binary">binary</code></td>
<td>
<p>boolean. should the output mask be boolean (TRUE) or greyscale 
(FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a raster object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raster_chull_mask">raster_chull_mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create raster
r &lt;- terra::rast(xmin=0, xmax = 40, ymin = 0, ymax = 40, resolution = 1, crs= NA )

# xy positions
xy &lt;- data.frame(
  x = c(10, 20, 31.25, 15),
  y = c(10, 20, 31.25, 25)
)
# compute mask
mask1 &lt;- raster_xy_mask(xy, c(5, 8, 5, 5), r)
mask2 &lt;- raster_xy_mask(xy, c(5, 8, 5, 5), r, binary = FALSE)

# display binary raster
terra::plot(mask1)
graphics::points(xy)

# display distance raster
terra::plot(mask2)
graphics::points(xy)
</code></pre>

<hr>
<h2 id='raster_zonal_stats'>Image statistic in segment</h2><span id='topic+raster_zonal_stats'></span>

<h3>Description</h3>

<p>compute zonal statistic of an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_zonal_stats(segms, dem_nl, fun = max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_zonal_stats_+3A_segms">segms</code></td>
<td>
<p>cimg or SpatRaster object. image with segments id (e.g. from 
<code><a href="#topic+segmentation">segmentation</a></code>)</p>
</td></tr>
<tr><td><code id="raster_zonal_stats_+3A_dem_nl">dem_nl</code></td>
<td>
<p>cimg or SpatRaster object. image to compute statistic from</p>
</td></tr>
<tr><td><code id="raster_zonal_stats_+3A_fun">fun</code></td>
<td>
<p>function to compute statistics from values in each segment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cimg object or raster object with values of the statistic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+segmentation">segmentation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

# median filter
chm_chablais3 &lt;- dem_filtering(chm_chablais3,
  nl_filter = "Median", nl_size = 3,
  sigma = 0
)$non_linear_image

# maxima detection
maxi &lt;- maxima_detection(chm_chablais3)

# segmentation
seg_maxi &lt;- segmentation(maxi, chm_chablais3)

# compute image of maximum value in each segment
max_in_segment &lt;- raster_zonal_stats(seg_maxi, chm_chablais3)

# plot original image
terra::plot(chm_chablais3, main = "Median filter")

# plot segments and image of max value inside segments
seg_maxi[seg_maxi == 0] &lt;- NA
terra::plot(seg_maxi %% 8, main = "Segments", col = rainbow(8))
terra::plot(max_in_segment, main = "Max value in segment")
</code></pre>

<hr>
<h2 id='raster2Cimg'>SpatRaster to Cimg conversion</h2><span id='topic+raster2Cimg'></span>

<h3>Description</h3>

<p>converts a SpatRaster object to cimg object. NA values in raster are replaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster2Cimg(r, NA_replace = 0, maxpixels = 1e+10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster2Cimg_+3A_r">r</code></td>
<td>
<p>SpatRaster object. raster of canopy height model, preferably 
filtered to avoid effect of holes on volume and surface computation</p>
</td></tr>
<tr><td><code id="raster2Cimg_+3A_na_replace">NA_replace</code></td>
<td>
<p>numeric. value to replace NA values with.</p>
</td></tr>
<tr><td><code id="raster2Cimg_+3A_maxpixels">maxpixels</code></td>
<td>
<p>numeric. maximum number of pixels to be converted to cimg 
(argument passed to <code><a href="imager.html#topic+as.cimg">as.cimg</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cimg object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cimg2Raster">cimg2Raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

chm_cim &lt;- raster2Cimg(chm_chablais3)
chm_cim
summary(chm_cim)

# plot SpatRaster
terra::plot(chm_chablais3)

# plot cimg object
plot(chm_cim)
</code></pre>

<hr>
<h2 id='rasters_moving_cor'>Correlation between rasters for different XY translations</h2><span id='topic+rasters_moving_cor'></span>

<h3>Description</h3>

<p>computes correlation between two rasters for different XY translations. The 
correlation values are computed on the extent of the smallest raster using 
<code><a href="#topic+rasters2Cor">rasters2Cor</a></code>, after applying an optional mask, and for each 
translation within a buffer area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasters_moving_cor(raster_b, raster_s, mask = NULL, buffer = 19, step = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasters_moving_cor_+3A_raster_b">raster_b</code></td>
<td>
<p>SpatRaster. raster to correlate with largest extent</p>
</td></tr>
<tr><td><code id="rasters_moving_cor_+3A_raster_s">raster_s</code></td>
<td>
<p>SpatRaster. raster to correlate with smallest extent</p>
</td></tr>
<tr><td><code id="rasters_moving_cor_+3A_mask">mask</code></td>
<td>
<p>SpatRaster. mask of area to correlate, applied to small raster</p>
</td></tr>
<tr><td><code id="rasters_moving_cor_+3A_buffer">buffer</code></td>
<td>
<p>numeric. radius of the circular buffer area for possible 
translations</p>
</td></tr>
<tr><td><code id="rasters_moving_cor_+3A_step">step</code></td>
<td>
<p>numeric. increment step of translations within buffer area to 
compute correlation values, should be a multiple of raster resolution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster. Raster value at coordinates x,y correspond to the correlation 
between the large raster and the small raster when small raster center has 
been translated of (x,y)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+raster_local_max">raster_local_max</a></code> to extract local maximum of resulting 
correlation raster, <code><a href="#topic+rasters2Cor">rasters2Cor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create raster
r_b &lt;- terra::rast(xmin = 0, xmax = 40, ymin =0 , ymax = 40,
resolution = 1, crs = NA)
xy &lt;- terra::xyFromCell(r_b, 1:(nrow(r_b) * ncol(r_b)))

# add Gaussian surfaces
z1 &lt;- 1.5 * exp(-((xy[, 1] - 22)^2 + (xy[, 2] - 22)^2 / 2) / 5)
z2 &lt;- exp(-((xy[, 1] - 20)^2 + (xy[, 2] - 22)^2 / 2) / 3)
z3 &lt;- 1.5 * exp(-((xy[, 1] - 17)^2 + (xy[, 2] - 17)^2 / 2) / 5)
r_b &lt;- terra::rast(cbind(xy, z1 + z2 + z3), type = "xyz")

# create small raster
r_s &lt;- terra::crop(r_b, terra::ext(c(15, 25, 15, 25)))
# offset raster by (-2, -2)
terra::ext(r_s) &lt;- c(13, 23, 13, 23)

# compute correlations for translations inside buffer
rr &lt;- rasters_moving_cor(r_b, r_s, buffer = 6, step = 1)
rr

# display large raster
terra::plot(r_b, main = "Large raster")
# display small raster
terra::plot(r_s, main = "Small raster")
# display correlation
terra::plot(rr,
  xlab = "X translation", ylab = "Y translation",
  main = "Correlation between rasters"
)
</code></pre>

<hr>
<h2 id='rasters2Cor'>Correlation between two rasters</h2><span id='topic+rasters2Cor'></span>

<h3>Description</h3>

<p>computes correlation between two rasters, based on the extent of the smallest 
one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasters2Cor(raster_b, raster_s, mask = NULL, small.SC = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasters2Cor_+3A_raster_b">raster_b</code></td>
<td>
<p>SpatRaster. raster to correlate with largest extent</p>
</td></tr>
<tr><td><code id="rasters2Cor_+3A_raster_s">raster_s</code></td>
<td>
<p>SpatRaster. raster to correlate with smallest extent</p>
</td></tr>
<tr><td><code id="rasters2Cor_+3A_mask">mask</code></td>
<td>
<p>SpatRaster. mask of area to correlate</p>
</td></tr>
<tr><td><code id="rasters2Cor_+3A_small.sc">small.SC</code></td>
<td>
<p>boolean. is the small raster already standardized and 
centered ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rasters_moving_cor">rasters_moving_cor</a></code> to compute correlation between rasters
for different translations
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create raster
r_b &lt;- terra::rast(xmin = 0, xmax = 40, ymin =0 , ymax = 40,
resolution = 1, crs = NA)
xy &lt;- terra::xyFromCell(r_b, 1:(nrow(r_b) * ncol(r_b)))

# add Gaussian surface and noise
z &lt;- 3 * exp(-((xy[, 1] - 20)^2 + (xy[, 2] - 20)^2 / 2) / 6)
r_b &lt;- terra::rast(cbind(xy, z), type = "xyz")

# create circular mask of radius 5
z_mask &lt;- (xy[, 1] - 20)^2 + (xy[, 2] - 20)^2 &lt; 5^2
r_mask &lt;- terra::rast(cbind(xy, z_mask), type = "xyz")

# create small raster of size 20
r_s &lt;- terra::crop(r_b, terra::ext(c(10, 30, 10, 30)))

# add noise to small raster
terra::values(r_s) &lt;- terra::values(r_s) + rnorm(ncol(r_s) * nrow(r_s), 0, 0.5)
r_mask &lt;- terra::crop(r_mask, terra::ext(c(10, 30, 10, 30)))

# compute correlation on masked area where signal to noise ratio is lower
rasters2Cor(r_b, r_s, r_mask, small.SC = FALSE)

# compute correlation for whole small raster
rasters2Cor(r_b, r_s, small.SC = FALSE)

# display large raster
terra::plot(r_b, main = "Large raster")
# display small raster
terra::plot(r_s, main = "Small raster")
# display mask
terra::plot(r_mask, main = "Computation mask")
</code></pre>

<hr>
<h2 id='seg_adjust'>Modification of segments based on values</h2><span id='topic+seg_adjust'></span>

<h3>Description</h3>

<p>in a segmented image, removes from segments the pixels which values in a 
reference image is below a certain percentage of the highest value inside the 
segment. Removed pixels are attributed 0 value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg_adjust(dem_w, dem_wh, dem_nl, prop = 0.3, min.value = 2, min.maxvalue = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seg_adjust_+3A_dem_w">dem_w</code></td>
<td>
<p>cimg or SpatRaster object. image with segments id, without 0 
values</p>
</td></tr>
<tr><td><code id="seg_adjust_+3A_dem_wh">dem_wh</code></td>
<td>
<p>cimg or SpatRaster object. image with max value inside segment</p>
</td></tr>
<tr><td><code id="seg_adjust_+3A_dem_nl">dem_nl</code></td>
<td>
<p>cimg or SpatRaster object. image with initial values</p>
</td></tr>
<tr><td><code id="seg_adjust_+3A_prop">prop</code></td>
<td>
<p>numeric. proportional threshold for removal of pixels which initial 
values are lower than the max height of the segment (<code>dem_nl &lt; prop x dem_wh</code>)</p>
</td></tr>
<tr><td><code id="seg_adjust_+3A_min.value">min.value</code></td>
<td>
<p>numeric. threshold for removel of pixels which initial values 
are lower (<code>dem_nl &lt; min.value</code>)</p>
</td></tr>
<tr><td><code id="seg_adjust_+3A_min.maxvalue">min.maxvalue</code></td>
<td>
<p>numeric. threshold for complete removal of segments which 
maximum value height is smaller to the threshold (<code>dem_wh &lt; min.maxvalue</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cimg or SpatRaster object: image with modified segments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxima_detection">maxima_detection</a></code>, <code><a href="#topic+maxima_selection">maxima_selection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

# median filter
chm_chablais3 &lt;- dem_filtering(chm_chablais3,
  nl_filter = "Median", nl_size = 3,
  sigma = 0
)$non_linear_image

# maxima detection and selection
maxi &lt;- maxima_detection(chm_chablais3)
selected_maxi &lt;- maxima_selection(maxi, chm_chablais3, dm = 1, dprop = 0.1)

# segmentation
seg_selected_maxi &lt;- segmentation(selected_maxi, chm_chablais3)

# max value in segments
max_in_segment &lt;- raster_zonal_stats(seg_selected_maxi , chm_chablais3)

# segmentation modification
seg_modif1 &lt;- seg_adjust(seg_selected_maxi , max_in_segment,
  chm_chablais3,
  prop = 0.5
)
seg_modif2 &lt;- seg_adjust(seg_selected_maxi , max_in_segment,
  chm_chablais3,
  prop = 0, min.value = 5, min.maxvalue = 10
)

# plot initial segmented image
# seg_selected_maxi[seg_selected_maxi == 0] &lt;- NA
terra::plot(seg_selected_maxi %% 8, main = "Initial segments", col = rainbow(8))
# seg_modif1[seg_modif1 == 0] &lt;- NA
terra::plot(seg_modif1 %% 8, main = "Modified segments 1", col = rainbow(8))
seg_modif2[seg_modif2 == 0] &lt;- NA
terra::plot(seg_modif2 %% 8, main = "Modified segments 2", col = rainbow(8))
</code></pre>

<hr>
<h2 id='segmentation'>Image segmentation by seed-based watershed algorithm</h2><span id='topic+segmentation'></span>

<h3>Description</h3>

<p>performs a seed-based watershed segmentation (wrapper for <code><a href="imager.html#topic+watershed">watershed</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentation(maxi, dem_nl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentation_+3A_maxi">maxi</code></td>
<td>
<p>cimg or SpatRaster object. image with seed points (e.g. from 
<code><a href="#topic+maxima_detection">maxima_detection</a></code> or <code><a href="#topic+maxima_selection">maxima_selection</a></code>)</p>
</td></tr>
<tr><td><code id="segmentation_+3A_dem_nl">dem_nl</code></td>
<td>
<p>cimg or SpatRaster object. image for seed propagation 
(typically initial image used for maxima detection).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cimg object or SpatRaster object with segments id
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxima_detection">maxima_detection</a></code>, <code><a href="#topic+maxima_selection">maxima_selection</a></code>, 
<code><a href="#topic+seg_adjust">seg_adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

# median filter
chm_chablais3 &lt;- dem_filtering(chm_chablais3,
  nl_filter = "Median", nl_size = 3,
  sigma = 0
)$non_linear_image

# maxima detection
maxi &lt;- maxima_detection(chm_chablais3)

# maxima selection
selected_maxi &lt;- maxima_selection(maxi, chm_chablais3, dm = 1, dprop = 0.1)

# segmentation
seg_maxi &lt;- segmentation(maxi, chm_chablais3)
seg_selected_maxi &lt;- segmentation(selected_maxi, chm_chablais3)

# plot original image
terra::plot(chm_chablais3, main = "Median filter")

# plot segmented image
# replace segment with id 0 (not a tree) with NA
seg_maxi[seg_maxi == 0] &lt;- NA
terra::plot(seg_maxi %% 8, main = "Segments, no maxima selection", 
col = rainbow(8))
seg_selected_maxi [seg_selected_maxi == 0] &lt;- NA
terra::plot(seg_selected_maxi %% 8, main = "Segments, maxima selection", 
col = rainbow(8))
</code></pre>

<hr>
<h2 id='species_color'>Table of species names, abreviations and display colors</h2><span id='topic+species_color'></span>

<h3>Description</h3>

<p>table for species names, abreviations and type (coniferous/broadleaf), and 
display color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_color()
</code></pre>


<h3>Value</h3>

<p>A data frame with species name, color, coniferous (C) / broadleaf (B) 
type, and name abreviation GESP of GEnus and SPecies
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_tree_inventory">plot_tree_inventory</a></code> for tree inventory display
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load table
tab.species &lt;- species_color()
head(tab.species)
summary(tab.species)
</code></pre>

<hr>
<h2 id='std_tree_metrics'>Computation of tree metrics</h2><span id='topic+std_tree_metrics'></span>

<h3>Description</h3>

<p>This function computes summary statistics from a data.frame containing 
tree-level information as returned by <code><a href="#topic+tree_extraction">tree_extraction</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std_tree_metrics(x, area_ha = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="std_tree_metrics_+3A_x">x</code></td>
<td>
<p>data.frame containing the following columns for each line (segmented tree): 
<code>h</code> (height), <code>s</code> (crown surface), <code>v</code> (crown volume), typically 
returned by <code><a href="#topic+tree_extraction">tree_extraction</a></code>. <code>sp</code> (crown surface inside region 
of interest) and <code>vp</code> (crown volume in region of interest) are not used 
in this function.</p>
</td></tr>
<tr><td><code id="std_tree_metrics_+3A_area_ha">area_ha</code></td>
<td>
<p>numeric. area of region of interest in ha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with one line containing the following tree metrics:
</p>

<ol>
<li> <p><code>Tree_meanH</code>: mean height of detected tree apices (m)
</p>
</li>
<li> <p><code>Tree_sdH</code>: standard deviation of heights of detected tree apices (m)
</p>
</li>
<li> <p><code>Tree_giniH</code>: Gini index of heights of detected tree apices
</p>
</li>
<li> <p><code>Tree_density</code>: density of detected tree apices (/ha)
</p>
</li>
<li> <p><code>TreeInf10_density</code>: density of detected trees apices with h&lt;=10 (/ha)
</p>
</li>
<li> <p><code>TreeSup10_density</code>: density of detected trees apices with h&gt;10 (/ha)
</p>
</li>
<li> <p><code>TreeSup20_density</code>: density of detected trees apices with h&gt;20 (/ha)
</p>
</li>
<li> <p><code>TreeSup30_density</code>: density of detected trees apices with h&gt;30 (/ha)
</p>
</li>
<li> <p><code>Tree_meanCrownSurface</code>: mean crown surface of detected trees
</p>
</li>
<li> <p><code>Tree_meanCrownVolume</code>: mean volume of detected trees
</p>
</li>
<li> <p><code>TreeCanopy_meanH</code>: mean height of union of crowns of detected trees
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+tree_extraction">tree_extraction</a></code>, <code><a href="#topic+clouds_tree_metrics">clouds_tree_metrics</a></code>, <code><a href="#topic+raster_metrics">raster_metrics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample 50 height values
h &lt;- runif(50, 5, 40)
# simulate tree data.frame
trees &lt;- data.frame(h = h, s = h, sp = h * 0.95, v = h * h * 0.6, vp = h * h * 0.55)
std_tree_metrics(trees, area_ha = 0.1)
</code></pre>

<hr>
<h2 id='terrain_points_metrics'>Computation of terrain metrics</h2><span id='topic+terrain_points_metrics'></span>

<h3>Description</h3>

<p>This function computes topographic variables from a point cloud
</p>

<ul>
<li><p>exposition
</p>
</li>
<li><p>altitude
</p>
</li>
<li><p>slope.
</p>
</li></ul>

<p>Values are computed after fitting a plane to the points. It supposes a 
homogeneous sampling of the plot by points. Points can be cropped on disk if 
center and radius are provided. In case a centre is provided, the altitude 
is computed by bilinear interpolation at the center location 
(<code><a href="lidR.html#topic+rasterize_terrain">rasterize_terrain</a></code> with <code><a href="lidR.html#topic+tin">tin</a></code> algorithm), 
otherwise it is the mean of the points altitude range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terrain_points_metrics(p, centre = NULL, r = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terrain_points_metrics_+3A_p">p</code></td>
<td>
<p>matrix, data.frame or <code><a href="lidR.html#topic+LAS">LAS</a></code> object with ground point 
coordinates (X, Y, Z). In case of an object which is not LAS, the object is first 
converted.</p>
</td></tr>
<tr><td><code id="terrain_points_metrics_+3A_centre">centre</code></td>
<td>
<p>vector. x y coordinates of center to extract points inside a disc</p>
</td></tr>
<tr><td><code id="terrain_points_metrics_+3A_r">r</code></td>
<td>
<p>numeric. radius of disc</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with altitude, exposition (gr), slope (gr) and adjR2 of 
plane fitting
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample points
XYZ &lt;- data.frame(x = runif(200, -10, 10), y = runif(200, -10, 10))
XYZ$z &lt;- 350 + 0.3 * XYZ$x + 0.1 * XYZ$y + rnorm(200, mean = 0, sd = 0.5)
# compute terrain statistics
terrain_points_metrics(XYZ)
terrain_points_metrics(XYZ, centre = c(5, 5), r = 5)
# with a LAS object
LASfile &lt;- system.file("extdata", "las_chablais3.laz", package="lidaRtRee")
las_chablais3 &lt;- lidR::readLAS(LASfile)
terrain_points &lt;- lidR::filter_ground(las_chablais3)
terrain_points_metrics(terrain_points)
terrain_points_metrics(terrain_points, centre = c(974360, 6581650), r = 10)
</code></pre>

<hr>
<h2 id='tree_detection'>Tree detection</h2><span id='topic+tree_detection'></span>

<h3>Description</h3>

<p>Performs tree detection by applying the functions <code><a href="#topic+tree_segmentation">tree_segmentation</a></code>
and <code><a href="#topic+tree_extraction">tree_extraction</a></code> to objects of class <code><a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a></code>,
<code><a href="lidR.html#topic+LAS-class">LAS-class</a></code> or <code><a href="lidR.html#topic+LAScatalog-class">LAScatalog-class</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_detection(las, res = 1, ROI = NULL, normalize = FALSE, crown = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_detection_+3A_las">las</code></td>
<td>
<p>An object of class <code><a href="terra.html#topic+SpatRaster-class">SpatRaster-class</a></code>,
<code><a href="lidR.html#topic+LAS-class">LAS-class</a></code> or <code><a href="lidR.html#topic+LAScatalog-class">LAScatalog-class</a></code></p>
</td></tr>
<tr><td><code id="tree_detection_+3A_res">res</code></td>
<td>
<p>numeric. The size of a grid cell in point cloud coordinates units,
used to rasterize the point cloud. In case the <code>las</code> argument is a <code>SpatRaster</code>
<code>res</code> is not used.</p>
</td></tr>
<tr><td><code id="tree_detection_+3A_roi">ROI</code></td>
<td>
<p>spatial polygons in sf/sfc format, in the same CRS as argument <code>las</code>. geometric object that defines the
region where tree detection has to be performed. In case the input is of class
<code><a href="lidR.html#topic+LAScatalog-class">LAScatalog-class</a></code>, the chunk buffer set with 
<code><a href="lidR.html#topic+engine_options">engine_options</a></code> is applied to the point cloud to prevent 
border effects, but only treetops lying within the <code>ROI</code> are returned.</p>
</td></tr>
<tr><td><code id="tree_detection_+3A_normalize">normalize</code></td>
<td>
<p>boolean. Should the point cloud be normalized before detection
(not applicable if <code>las</code> argument is a <code>SpatRaster</code>) ?</p>
</td></tr>
<tr><td><code id="tree_detection_+3A_crown">crown</code></td>
<td>
<p>Parameter passed to <code><a href="#topic+tree_extraction">tree_extraction</a></code></p>
</td></tr>
<tr><td><code id="tree_detection_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="#topic+tree_segmentation">tree_segmentation</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sf collection of POINTs with 7 fields: tree id, local maximum stats
(height, dominance radius), segment stats (surface and volume), coordinates 
(x and y). In case argument <code>crown</code> is <code>TRUE</code>, a <code>crown</code> field 
containing the WKT geometry of the 2D crown is also present.
</p>


<h3>References</h3>

<p>Monnet, J.-M. 2011. Using airborne laser scanning for mountain 
forests mapping: Support vector regression for stand parameters estimation 
and unsupervised training for treetop detection. Ph.D. thesis. University of 
Grenoble, France. Section 6.2 
<a href="https://theses.hal.science/tel-00652698/document">https://theses.hal.science/tel-00652698/document</a>
</p>
<p>Monnet, J.-M., Mermin, E., Chanussot, J., Berger, F. 2010. Tree top detection 
using local maxima filtering: a parameter sensitivity analysis. Silvilaser 2010, 
the 10th International Conference on LiDAR Applications for Assessing Forest 
Ecosystems, September 14-17, Freiburg, Germany, 9 p. 
<a href="https://hal.science/hal-00523245/document">https://hal.science/hal-00523245/document</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree_segmentation">tree_segmentation</a></code>, <code><a href="#topic+tree_extraction">tree_extraction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load canopy height model
data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)
# create polygon of region of interest
ROI &lt;- sf::st_polygon(list(cbind(
 c(974360, 974360, 974380, 974380, 974360),
 c(6581640, 6581680, 6581680, 6581640, 6581640)
)))
# convert to sfc and set projection
ROI = sf::st_sfc(ROI)
sf::st_crs(ROI) &lt;- terra::crs(chm_chablais3)
#
# tree detection
trees &lt;- tree_detection(chm_chablais3)
# plot results
# canopy height model background
terra::plot(chm_chablais3)
# detected trees
plot(trees["h"], add = TRUE, cex = trees$h/20, col = "black")
#
# tree detection in ROI and minimum tree height set to 10
trees_ROI &lt;- tree_detection(chm_chablais3, ROI = ROI, hmin = 10, crown = TRUE)
# create polygons from WKT field
trees_ROI_crowns &lt;- sf::st_as_sf(sf::st_drop_geometry(trees_ROI), wkt = "crown")
# plot results
# canopy height model background 
terra::plot(chm_chablais3)
# detected trees
plot(trees_ROI["h"], add = TRUE, cex = trees_ROI$h/20, col = "black")
# corresponding crowns
plot(sf::st_geometry(trees_ROI_crowns), add = TRUE, border = "black", col = NA)
# add ROI
plot(ROI, add = TRUE, border = "red", col = NA)
</code></pre>

<hr>
<h2 id='tree_extraction'>Tree extraction</h2><span id='topic+tree_extraction'></span>

<h3>Description</h3>

<p>creates a data.frame with segment id, height and coordinates of maxima, surface and volume, computed from three images: 
initial, local maxima and segmented, obtained with <code><a href="#topic+tree_segmentation">tree_segmentation</a></code>. The 2D polygon associated to each crown 
can be added as a WKT field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_extraction(
  r_dem_nl,
  r_maxi = NULL,
  r_dem_w = NULL,
  r_mask = NULL,
  crown = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_extraction_+3A_r_dem_nl">r_dem_nl</code></td>
<td>
<p>SpatRaster object. Output raster of <code><a href="#topic+tree_segmentation">tree_segmentation</a></code>. Otherwise a raster of canopy height model,
preferably filtered to avoid effect of holes on volume and surface computation can be provided. In this case arguments 'r_maxi', 'r_dem_w' 
have to be provided</p>
</td></tr>
<tr><td><code id="tree_extraction_+3A_r_maxi">r_maxi</code></td>
<td>
<p>SpatRaster object. raster with positive values at local maxima (in case 'r_dem_nl' does not contain it)</p>
</td></tr>
<tr><td><code id="tree_extraction_+3A_r_dem_w">r_dem_w</code></td>
<td>
<p>SpatRaster object. segmented raster  (in case 'r_dem_nl' does not contain it)</p>
</td></tr>
<tr><td><code id="tree_extraction_+3A_r_mask">r_mask</code></td>
<td>
<p>SpatRaster object. only segments which maxima are inside the mask are extracted. Values should be NA outside the mask, 1 inside.</p>
</td></tr>
<tr><td><code id="tree_extraction_+3A_crown">crown</code></td>
<td>
<p>boolean. Should the 2D crown geometry be added in wkt format 
to the output data.frame ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sf</code> collection of POINTs with 7 fields: tree id, local maximum stats
(height, dominance radius), segment stats (surface and volume), coordinates 
(x and y). In case argument 'crown' is 'TRUE', a 'crown' field 
containing the WKT geometry of the 2D crown is also present. Coordinates are 
written with one decimal to the right of the order of magnitude of 
the SpatRaster resolution (e.g. if resolution is 1/3 then 2 decimals are written).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree_segmentation">tree_segmentation</a></code>, <code><a href="#topic+tree_detection">tree_detection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

# tree segmentation
segments &lt;- tree_segmentation(chm_chablais3)

# tree extraction
trees &lt;- tree_extraction(segments, crown = TRUE)
# create crown polygons from WKT field
trees_crowns &lt;- sf::st_as_sf(sf::st_drop_geometry(trees), wkt = "crown")

# summary of trees without wkt field
summary(trees[, -which(names(trees) == "crown")])

# plot initial image
terra::plot(chm_chablais3, main = "CHM and extracted trees")

# add treetop positions
plot(trees["h"], add = TRUE, cex = trees$h/20, col = "black")
# add crowns
plot(sf::st_geometry(trees_crowns), add = TRUE, border = "black", col = NA)

# plot segments
terra::plot(segments$segments_id, main = "Segments")
# add crowns
plot(sf::st_geometry(trees_crowns), add = TRUE, border = "black", col = NA)

</code></pre>

<hr>
<h2 id='tree_inventory_chablais3'>Tree inventory data in France (Chablais 3 plot, July 2010)</h2><span id='topic+tree_inventory_chablais3'></span>

<h3>Description</h3>

<p>All trees with diameter at breast height &gt;= 7.5 cm are inventoried on a 50m x 50m plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tree_inventory_chablais3)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with columns:
</p>

<ol>
<li> <p><code>x</code> easting coordinate (epsg: 2154)
</p>
</li>
<li> <p><code>y</code> northing coordinate (epsg: 2154)
</p>
</li>
<li> <p><code>d</code> dbh (cm)
</p>
</li>
<li> <p><code>h</code> tree height (m)
</p>
</li>
<li> <p><code>n</code> tree number
</p>
</li>
<li> <p><code>s</code> species abreviated as GESP (GEnus SPecies)
</p>
</li>
<li> <p><code>e</code> appearance (0: missing or lying, 1: normal, 2: broken treetop, 3: dead with branches, 4: snag)
</p>
</li>
<li> <p><code>t</code> tilted (0: no, 1: yes)
</p>
</li></ol>



<h3>References</h3>

<p>Monnet, J.-M. 2011. Using airborne laser scanning for mountain forests mapping: Support vector regression for stand parameters estimation and unsupervised training for treetop detection. Ph.D. thesis. University of Grenoble, France. pp. 21-22 &amp; 34 <a href="https://theses.hal.science/tel-00652698/document">https://theses.hal.science/tel-00652698/document</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tree_inventory_chablais3)
summary(tree_inventory_chablais3)
# display tree inventory
plot_tree_inventory(tree_inventory_chablais3[, c("x", "y")],
  diam = tree_inventory_chablais3$d, col = "red",
  pch = tree_inventory_chablais3$e,
  xlab = "X", ylab = "Y"
)
</code></pre>

<hr>
<h2 id='tree_matching'>3D matching of detected tree top positions with reference positions</h2><span id='topic+tree_matching'></span>

<h3>Description</h3>

<p>First computes a matching index for each potential pair associating a detected
with a reference tree. This index is the 3D distance between detected and
reference points, divided by a maximum matching distance set by user-defined
parameters. Pairs with the lowest index are then iteratively associated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_matching(lr, ld, delta_ground = 2.1, h_prec = 0.14, stat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_matching_+3A_lr">lr</code></td>
<td>
<p>data.frame or matrix. 3D coordinates (X Y Height) of reference positions</p>
</td></tr>
<tr><td><code id="tree_matching_+3A_ld">ld</code></td>
<td>
<p>data.frame or matrix. 3D coordinates (X Y Height) of detected positions</p>
</td></tr>
<tr><td><code id="tree_matching_+3A_delta_ground">delta_ground</code></td>
<td>
<p>numeric. buffer around trunk position : absolute value</p>
</td></tr>
<tr><td><code id="tree_matching_+3A_h_prec">h_prec</code></td>
<td>
<p>numeric. buffer around apex position : proportion of reference
tree height</p>
</td></tr>
<tr><td><code id="tree_matching_+3A_stat">stat</code></td>
<td>
<p>boolean. should matching stats be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with matched pairs (row of reference positions in first
column, and row of detected positions in second column) and corresponding 3D
distances
</p>


<h3>References</h3>

<p>Monnet, J.-M. 2011. Using airborne laser scanning for mountain
forests mapping: Support vector regression for stand parameters estimation
and unsupervised training for treetop detection. Ph.D. thesis. University of
Grenoble, France. pp. 53-55 <a href="https://theses.hal.science/tel-00652698/document">https://theses.hal.science/tel-00652698/document</a>
</p>
<p>Monnet, J.-M., Mermin, E., Chanussot, J., Berger, F. 2010. Tree top detection
using local maxima filtering: a parameter sensitivity analysis. Silvilaser 2010,
the 10th International Conference on LiDAR Applications for Assessing Forest
Ecosystems, September 14-17, Freiburg, Germany, 9 p. <a href="https://hal.science/hal-00523245/document">https://hal.science/hal-00523245/document</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_matched">plot_matched</a></code>, <code><a href="#topic+hist_detection">hist_detection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create reference and detected trees
ref_trees &lt;- cbind(c(1, 4, 3, 4, 2), c(1, 1, 2, 3, 4), c(15, 18, 20, 10, 11))
def_trees &lt;- cbind(c(2, 2, 4, 4), c(1, 3, 4, 1), c(16, 19, 9, 15))
#
# match trees
match1 &lt;- tree_matching(ref_trees, def_trees)
match2 &lt;- tree_matching(ref_trees, def_trees, delta_ground = 2, h_prec = 0)
match1
match2

# 2D display of matching result
plot_matched(ref_trees, def_trees, match1, xlab = "X", ylab = "Y")
plot_matched(ref_trees, def_trees, match2, xlab = "X", ylab = "Y")
</code></pre>

<hr>
<h2 id='tree_segmentation'>Preprocessing and segmentation of raster image for tree identification</h2><span id='topic+tree_segmentation'></span>

<h3>Description</h3>

<p>global function for preprocessing (filtering), maxima detection and selection, 
segmentation and segmentation adjustment of a raster image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_segmentation(dem, dtm = NULL, crown_prop = NULL, crown_hmin = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_segmentation_+3A_dem">dem</code></td>
<td>
<p>raster object or string indicating location of raster file 
(typically a canopy height model or a digital surface model; in the latter 
case the dtm parameter should be provided)</p>
</td></tr>
<tr><td><code id="tree_segmentation_+3A_dtm">dtm</code></td>
<td>
<p>raster object or string indicating location of raster file with 
the terrain model. If provided, the maxima extraction and watershed segmentation 
are performed on the dem (this avoids the deformation of crown because of the 
normalisation with terrain), but maxima selection and segment adjustment are 
performed on 'dem-dtm' because the selection criteria are based on the height to terrain.</p>
</td></tr>
<tr><td><code id="tree_segmentation_+3A_crown_prop">crown_prop</code></td>
<td>
<p>(deprecated) numeric. (overrides <code>prop</code> parameter 
passed to <code><a href="#topic+seg_adjust">seg_adjust</a></code>, for backward compatibility)</p>
</td></tr>
<tr><td><code id="tree_segmentation_+3A_crown_hmin">crown_hmin</code></td>
<td>
<p>(deprecated) numeric. (overrides <code>min.value</code> parameter 
passed to <code><a href="#topic+seg_adjust">seg_adjust</a></code>, for backward compatibility)</p>
</td></tr>
<tr><td><code id="tree_segmentation_+3A_...">...</code></td>
<td>
<p>arguments passed to functions <code><a href="#topic+dem_filtering">dem_filtering</a></code>
(e.g. <code>nl_filter</code>, <code>nl_size</code>, <code>sigma</code>), 
<code><a href="#topic+maxima_detection">maxima_detection</a></code>, <code><a href="#topic+maxima_selection">maxima_selection</a></code>, 
<code><a href="#topic+maxima_selection">maxima_selection</a></code> (<code>dmin</code>: treetop minimum distance to next
higher pixel in meters, <code>dprop</code>: number defining the treetop minimum 
distance as proportion of its height to next higher pixel, <code>hmin</code>: 
minimum treetop height), <code><a href="#topic+seg_adjust">seg_adjust</a></code> (<code>prop</code>: minimum 
height of tree crown base as proportion of treetop height, <code>min.value</code>: 
minimum crown base height)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster with 4 layers: selected local maxima (values = 
distance to higher pixel), segments, non-linear preprocessed dem, smoothed 
preprocessed dem
</p>


<h3>References</h3>

<p>Monnet, J.-M. 2011. Using airborne laser scanning for mountain 
forests mapping: Support vector regression for stand parameters estimation 
and unsupervised training for treetop detection. Ph.D. thesis. University of 
Grenoble, France. Section 6.2 
<a href="https://theses.hal.science/tel-00652698/document">https://theses.hal.science/tel-00652698/document</a>
</p>
<p>Monnet, J.-M., Mermin, E., Chanussot, J., Berger, F. 2010. Tree top detection 
using local maxima filtering: a parameter sensitivity analysis. Silvilaser 2010, 
the 10th International Conference on LiDAR Applications for Assessing Forest 
Ecosystems, September 14-17, Freiburg, Germany, 9 p. 
<a href="https://hal.science/hal-00523245/document">https://hal.science/hal-00523245/document</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dem_filtering">dem_filtering</a></code>, <code><a href="#topic+maxima_detection">maxima_detection</a></code>, 
<code><a href="#topic+maxima_selection">maxima_selection</a></code>, <code><a href="#topic+segmentation">segmentation</a></code>, 
<code><a href="#topic+seg_adjust">seg_adjust</a></code>, <code><a href="#topic+tree_extraction">tree_extraction</a></code>,
<code><a href="#topic+tree_detection">tree_detection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chm_chablais3)
chm_chablais3 &lt;- terra::rast(chm_chablais3)

# tree segmentation
segments &lt;- tree_segmentation(chm_chablais3)
segments2 &lt;- tree_segmentation(chm_chablais3,
  nl_filter = "Median", nl_size = 3,
  sigma = cbind(c(0.2, 0.8), c(0, 15)), dmin = 0, dprop = 0, hmin = 10, 
  crown_prop = 0.5, crown_hmin = 5
)

# plot initial image segments
terra::plot(chm_chablais3, main = "Initial image")
terra::plot(segments$smoothed_dem, main = "Filtered image")
terra::plot(segments$local_maxima, main = "Local maxima")
#
# replace segment with id 0 (not a tree) with NA
segments$segments_id[segments$segments_id == 0] &lt;- NA
terra::plot(segments$segments_id %% 8, main = "Segments", col = rainbow(8))
#
# plot segmentation with other parameters
segments2$segments_id[segments2$segments_id == 0] &lt;- NA
terra::plot(segments2$segments_id %% 8, main = "Segments2", col = rainbow(8))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
