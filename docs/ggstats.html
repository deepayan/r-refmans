<!DOCTYPE html><html lang="en-US"><head><title>Help for package ggstats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggstats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggstats-package'><p>ggstats: Extension to 'ggplot2' for Plotting Stats</p></a></li>
<li><a href='#augment_chisq_add_phi'><p>Augment a chi-squared test and compute phi coefficients</p></a></li>
<li><a href='#geom_connector'><p>Connect bars / points</p></a></li>
<li><a href='#geom_diverging'><p>Geometries for diverging bar plots</p></a></li>
<li><a href='#geom_prop_bar'><p>Convenient geometries for proportion bar plots</p></a></li>
<li><a href='#geom_stripped_rows'><p>Alternating Background Color</p></a></li>
<li><a href='#ggcascade'><p>Cascade plot</p></a></li>
<li><a href='#ggcoef_model'><p>Plot model coefficients</p></a></li>
<li><a href='#ggcoef_multicomponents'><p>Deprecated functions</p></a></li>
<li><a href='#gglikert'><p>Plotting Likert-type items</p></a></li>
<li><a href='#ggsurvey'><p>Easy ggplot2 with survey objects</p></a></li>
<li><a href='#hex_bw'><p>Identify a suitable font color (black or white) given a background HEX color</p></a></li>
<li><a href='#label_number_abs'><p>Label absolute values</p></a></li>
<li><a href='#pal_extender'><p>Extend a discrete colour palette</p></a></li>
<li><a href='#position_likert'><p>Stack objects on top of each another and center them around 0</p></a></li>
<li><a href='#round_any'><p>Round to multiple of any number.</p></a></li>
<li><a href='#scale_fill_likert'><p>Colour scale for Likert-type plots</p></a></li>
<li><a href='#signif_stars'><p>Significance Stars</p></a></li>
<li><a href='#stat_cross'><p>Compute cross-tabulation statistics</p></a></li>
<li><a href='#stat_prop'><p>Compute proportions according to custom denominator</p></a></li>
<li><a href='#stat_weighted_mean'><p>Compute weighted y mean</p></a></li>
<li><a href='#symmetric_limits'><p>Symmetric limits</p></a></li>
<li><a href='#weighted.median'><p>Weighted Median and Quantiles</p></a></li>
<li><a href='#weighted.sum'><p>Weighted Sum</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extension to 'ggplot2' for Plotting Stats</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides new statistics, new geometries and new positions for 
    'ggplot2' and a suite of functions to facilitate the creation of 
    statistical plots.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://larmarange.github.io/ggstats/">https://larmarange.github.io/ggstats/</a>,
<a href="https://github.com/larmarange/ggstats">https://github.com/larmarange/ggstats</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/larmarange/ggstats/issues">https://github.com/larmarange/ggstats/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, forcats, ggplot2 (&ge; 3.4.0), lifecycle, patchwork,
purrr, rlang, scales, stats, stringr, utils, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>betareg, broom, broom.helpers (&ge; 1.20.0), emmeans, glue,
gtsummary, knitr, labelled (&ge; 2.11.0), reshape, rmarkdown,
nnet, parameters, pscl, testthat (&ge; 3.0.0), spelling, survey,
survival, vdiffr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-10 10:35:16 UTC; josep</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph Larmarange <a href="https://orcid.org/0000-0001-7097-700X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joseph Larmarange &lt;joseph@larmarange.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-10 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggstats-package'>ggstats: Extension to 'ggplot2' for Plotting Stats</h2><span id='topic+ggstats'></span><span id='topic+ggstats-package'></span>

<h3>Description</h3>

<p>Provides new statistics, new geometries and new positions for 'ggplot2' and a suite of functions to facilitate the creation of statistical plots.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joseph Larmarange <a href="mailto:joseph@larmarange.net">joseph@larmarange.net</a> (<a href="https://orcid.org/0000-0001-7097-700X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://larmarange.github.io/ggstats/">https://larmarange.github.io/ggstats/</a>
</p>
</li>
<li> <p><a href="https://github.com/larmarange/ggstats">https://github.com/larmarange/ggstats</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/larmarange/ggstats/issues">https://github.com/larmarange/ggstats/issues</a>
</p>
</li></ul>


<hr>
<h2 id='augment_chisq_add_phi'>Augment a chi-squared test and compute phi coefficients</h2><span id='topic+augment_chisq_add_phi'></span>

<h3>Description</h3>

<p>Augment a chi-squared test and compute phi coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augment_chisq_add_phi(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augment_chisq_add_phi_+3A_x">x</code></td>
<td>
<p>a chi-squared test as returned by <code><a href="stats.html#topic+chisq.test">stats::chisq.test()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Phi coefficients are a measurement of the degree of association
between two binary variables.
</p>

<ul>
<li><p> A value between -1.0 to -0.7 indicates a strong negative association.
</p>
</li>
<li><p> A value between -0.7 to -0.3 indicates a weak negative association.
</p>
</li>
<li><p> A value between -0.3 to +0.3 indicates a little or no association.
</p>
</li>
<li><p> A value between +0.3 to +0.7 indicates a weak positive association.
</p>
</li>
<li><p> A value between +0.7 to +1.0 indicates a strong positive association.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tibble</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stat_cross">stat_cross()</a></code>, <code>GDAtools::phi.table()</code> or <code>psych::phi()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- xtabs(Freq ~ Sex + Class, data = as.data.frame(Titanic))
augment_chisq_add_phi(chisq.test(tab))
</code></pre>

<hr>
<h2 id='geom_connector'>Connect bars / points</h2><span id='topic+geom_connector'></span><span id='topic+geom_bar_connector'></span><span id='topic+GeomConnector'></span>

<h3>Description</h3>

<p><code>geom_connector()</code> is a variation of <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_step()</a></code>.
Its variant <code>geom_bar_connector()</code> is particularly adapted to
connect bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_connector(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  width = 0.1,
  continuous = FALSE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_bar_connector(
  mapping = NULL,
  data = NULL,
  stat = "prop",
  position = "stack",
  width = 0.9,
  continuous = FALSE,
  add_baseline = TRUE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_connector_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_connector_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_connector_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_connector_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_connector_+3A_width">width</code></td>
<td>
<p>Bar width (see examples).</p>
</td></tr>
<tr><td><code id="geom_connector_+3A_continuous">continuous</code></td>
<td>
<p>Should connect segments be continuous?</p>
</td></tr>
<tr><td><code id="geom_connector_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_connector_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_connector_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_connector_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_connector_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_connector_+3A_add_baseline">add_baseline</code></td>
<td>
<p>Add connectors at baseline?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

# geom_bar_connector() -----------

ggplot(diamonds) +
  aes(x = clarity, fill = cut) +
  geom_bar(width = .5) +
  geom_bar_connector(width = .5, linewidth = .25) +
  theme_minimal() +
  theme(legend.position = "bottom")


ggplot(diamonds) +
  aes(x = clarity, fill = cut) +
  geom_bar(width = .5) +
  geom_bar_connector(
    width = .5,
    continuous = TRUE,
    colour = "red",
    linetype = "dotted",
    add_baseline = FALSE,
   ) +
  theme(legend.position = "bottom")

ggplot(diamonds) +
  aes(x = clarity, fill = cut) +
  geom_bar(width = .5, position = "fill") +
  geom_bar_connector(width = .5, position = "fill") +
  theme(legend.position = "bottom")

ggplot(diamonds) +
  aes(x = clarity, fill = cut) +
  geom_bar(width = .5, position = "diverging") +
  geom_bar_connector(width = .5, position = "diverging", linewidth = .25) +
  theme(legend.position = "bottom")

# geom_connector() -----------

ggplot(mtcars) +
aes(x = wt, y = mpg, colour = factor(cyl)) +
  geom_connector() +
  geom_point()

ggplot(mtcars) +
  aes(x = wt, y = mpg, colour = factor(cyl)) +
  geom_connector(continuous = TRUE) +
  geom_point()

ggplot(mtcars) +
  aes(x = wt, y = mpg, colour = factor(cyl)) +
  geom_connector(continuous = TRUE, width = .3) +
  geom_point()

ggplot(mtcars) +
  aes(x = wt, y = mpg, colour = factor(cyl)) +
  geom_connector(width = 0) +
  geom_point()

ggplot(mtcars) +
  aes(x = wt, y = mpg, colour = factor(cyl)) +
  geom_connector(width = Inf) +
  geom_point()

ggplot(mtcars) +
  aes(x = wt, y = mpg, colour = factor(cyl)) +
  geom_connector(width = Inf, continuous = TRUE) +
  geom_point()

</code></pre>

<hr>
<h2 id='geom_diverging'>Geometries for diverging bar plots</h2><span id='topic+geom_diverging'></span><span id='topic+geom_likert'></span><span id='topic+geom_pyramid'></span><span id='topic+geom_diverging_text'></span><span id='topic+geom_likert_text'></span><span id='topic+geom_pyramid_text'></span>

<h3>Description</h3>

<p>These geometries are variations of <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code> and
<code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text()</a></code> but provides different set of default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_diverging(
  mapping = NULL,
  data = NULL,
  position = "diverging",
  ...,
  complete = "fill",
  default_by = "total"
)

geom_likert(
  mapping = NULL,
  data = NULL,
  position = "likert",
  ...,
  complete = "fill",
  default_by = "x"
)

geom_pyramid(
  mapping = NULL,
  data = NULL,
  position = "diverging",
  ...,
  complete = NULL,
  default_by = "total"
)

geom_diverging_text(
  mapping = ggplot2::aes(!!!auto_contrast),
  data = NULL,
  position = position_diverging(0.5),
  ...,
  complete = "fill",
  default_by = "total"
)

geom_likert_text(
  mapping = ggplot2::aes(!!!auto_contrast),
  data = NULL,
  position = position_likert(0.5),
  ...,
  complete = "fill",
  default_by = "x"
)

geom_pyramid_text(
  mapping = ggplot2::aes(!!!auto_contrast),
  data = NULL,
  position = position_diverging(0.5),
  ...,
  complete = NULL,
  default_by = "total"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_diverging_+3A_mapping">mapping</code></td>
<td>
<p>Optional set of aesthetic mappings.</p>
</td></tr>
<tr><td><code id="geom_diverging_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layers.</p>
</td></tr>
<tr><td><code id="geom_diverging_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer.</p>
</td></tr>
<tr><td><code id="geom_diverging_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code></p>
</td></tr>
<tr><td><code id="geom_diverging_+3A_complete">complete</code></td>
<td>
<p>An aesthetic for those unobserved values should be completed,
see <code><a href="#topic+stat_prop">stat_prop()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_diverging_+3A_default_by">default_by</code></td>
<td>
<p>Name of an aesthetic determining denominators by default,
see <code><a href="#topic+stat_prop">stat_prop()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>geom_diverging()</code> is designed for stacked diverging bar plots, using
<code><a href="#topic+position_diverging">position_diverging()</a></code>.
</p>
</li>
<li> <p><code>geom_likert()</code> is designed for Likert-type items. Using
<code><a href="#topic+position_likert">position_likert()</a></code> (each bar sums to 100%).
</p>
</li>
<li> <p><code>geom_pyramid()</code> is similar to <code>geom_diverging()</code> but uses
proportions of the total instead of counts.
</p>
</li></ul>

<p>To add labels on the bar plots, simply use <code>geom_diverging_text()</code>,
<code>geom_likert_text()</code>, or <code>geom_pyramid_text()</code>.
</p>
<p>All these geometries relies on <code><a href="#topic+stat_prop">stat_prop()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot(diamonds) +
  aes(x = clarity, fill = cut) +
  geom_diverging()

ggplot(diamonds) +
  aes(x = clarity, fill = cut) +
  geom_diverging(position = position_diverging(cutoff = 4))

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_likert() +
  geom_likert_text()

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_likert() +
  geom_likert_text(
    aes(
      label = label_percent_abs(accuracy = 1, hide_below = .10)(
        after_stat(prop)
      ),
      colour = after_scale(hex_bw(.data$fill))
    )
  )

d &lt;- Titanic |&gt; as.data.frame()

ggplot(d) +
  aes(y = Class, fill = Sex, weight = Freq) +
  geom_diverging() +
  geom_diverging_text()

ggplot(d) +
  aes(y = Class, fill = Sex, weight = Freq) +
  geom_pyramid() +
  geom_pyramid_text()
</code></pre>

<hr>
<h2 id='geom_prop_bar'>Convenient geometries for proportion bar plots</h2><span id='topic+geom_prop_bar'></span><span id='topic+geom_prop_text'></span><span id='topic+geom_prop_connector'></span>

<h3>Description</h3>

<p><code>geom_prop_bar()</code>, <code>geom_prop_text()</code> and <code>geom_prop_connector()</code> are
variations of <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code>, <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text()</a></code> and
<code><a href="#topic+geom_bar_connector">geom_bar_connector()</a></code> using <code><a href="#topic+stat_prop">stat_prop()</a></code>, with custom default aesthetics:
<code>after_stat(prop)</code> for <strong>x</strong> or <strong>y</strong>, and
<code>scales::percent(after_stat(prop))</code> for <strong>label</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_prop_bar(
  mapping = NULL,
  data = NULL,
  position = "stack",
  ...,
  width = 0.9,
  complete = NULL,
  default_by = "x"
)

geom_prop_text(
  mapping = ggplot2::aes(!!!auto_contrast),
  data = NULL,
  position = ggplot2::position_stack(0.5),
  ...,
  complete = NULL,
  default_by = "x"
)

geom_prop_connector(
  mapping = NULL,
  data = NULL,
  position = "stack",
  ...,
  width = 0.9,
  complete = "fill",
  default_by = "x"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_prop_bar_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_prop_bar_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_prop_bar_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_prop_bar_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code>,
<code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text()</a></code> or <code><a href="#topic+geom_bar_connector">geom_bar_connector()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_prop_bar_+3A_width">width</code></td>
<td>
<p>Bar width (<code>0.9</code> by default).</p>
</td></tr>
<tr><td><code id="geom_prop_bar_+3A_complete">complete</code></td>
<td>
<p>Name (character) of an aesthetic for those statistics should
be completed for unobserved values (see example).</p>
</td></tr>
<tr><td><code id="geom_prop_bar_+3A_default_by">default_by</code></td>
<td>
<p>If the <strong>by</strong> aesthetic is not available, name of another
aesthetic that will be used to determine the denominators (e.g. <code>"fill"</code>),
or <code>NULL</code> or <code>"total"</code> to compute proportions of the total. To be noted,
<code>default_by = "x"</code> works both for vertical and horizontal bars.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+geom_bar_connector">geom_bar_connector()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
d &lt;- as.data.frame(Titanic)
ggplot(d) +
  aes(x = Class, fill = Survived, weight = Freq) +
  geom_prop_bar() +
  geom_prop_text() +
  geom_prop_connector()

ggplot(d) +
  aes(y = Class, fill = Survived, weight = Freq) +
  geom_prop_bar(width = .5) +
  geom_prop_text() +
  geom_prop_connector(width = .5, linetype = "dotted")

ggplot(d) +
  aes(
    x = Class,
    fill = Survived,
    weight = Freq,
    y = after_stat(count),
    label = after_stat(count)
  ) +
  geom_prop_bar() +
  geom_prop_text() +
  geom_prop_connector()
</code></pre>

<hr>
<h2 id='geom_stripped_rows'>Alternating Background Color</h2><span id='topic+geom_stripped_rows'></span><span id='topic+geom_stripped_cols'></span>

<h3>Description</h3>

<p>Add alternating background color along the y-axis. The geom takes default
aesthetics <code>odd</code> and <code>even</code> that receive color codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_stripped_rows(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  show.legend = NA,
  inherit.aes = TRUE,
  xfrom = -Inf,
  xto = Inf,
  width = 1,
  nudge_y = 0
)

geom_stripped_cols(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  show.legend = NA,
  inherit.aes = TRUE,
  yfrom = -Inf,
  yto = Inf,
  width = 1,
  nudge_x = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_stripped_rows_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_xfrom">xfrom</code>, <code id="geom_stripped_rows_+3A_xto">xto</code></td>
<td>
<p>limitation of the strips along the x-axis</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_width">width</code></td>
<td>
<p>width of the strips</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_yfrom">yfrom</code>, <code id="geom_stripped_rows_+3A_yto">yto</code></td>
<td>
<p>limitation of the strips along the y-axis</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_nudge_x">nudge_x</code>, <code id="geom_stripped_rows_+3A_nudge_y">nudge_y</code></td>
<td>
<p>horizontal or vertical adjustment to nudge strips by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot with the added geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(tips, package = "reshape")

library(ggplot2)
p &lt;- ggplot(tips) +
  aes(x = time, y = day) +
  geom_count() +
  theme_light()

p
p + geom_stripped_rows()
p + geom_stripped_cols()
p + geom_stripped_rows() + geom_stripped_cols()


p &lt;- ggplot(tips) +
  aes(x = total_bill, y = day) +
  geom_count() +
  theme_light()
p
p + geom_stripped_rows()
p + geom_stripped_rows() + scale_y_discrete(expand = expansion(0, 0.5))
p + geom_stripped_rows(xfrom = 10, xto = 35)
p + geom_stripped_rows(odd = "blue", even = "yellow")
p + geom_stripped_rows(odd = "blue", even = "yellow", alpha = .1)
p + geom_stripped_rows(odd = "#00FF0022", even = "#FF000022")

p + geom_stripped_cols()
p + geom_stripped_cols(width = 10)
p + geom_stripped_cols(width = 10, nudge_x = 5)


</code></pre>

<hr>
<h2 id='ggcascade'>Cascade plot</h2><span id='topic+ggcascade'></span><span id='topic+compute_cascade'></span><span id='topic+plot_cascade'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggcascade(
  .data,
  ...,
  .weights = NULL,
  .by = NULL,
  .nrow = NULL,
  .ncol = NULL,
  .add_n = TRUE,
  .text_size = 4,
  .arrows = TRUE
)

compute_cascade(.data, ..., .weights = NULL, .by = NULL)

plot_cascade(
  .data,
  .by = NULL,
  .nrow = NULL,
  .ncol = NULL,
  .add_n = TRUE,
  .text_size = 4,
  .arrows = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggcascade_+3A_.data">.data</code></td>
<td>
<p>A data frame, or data frame extension (e.g. a tibble). For
<code>plot_cascade()</code>, the variable displayed on the x-axis should be named
<code>"x"</code> and the number of observations should be named <code>"n"</code>, like the
tibble returned by <code>compute_cascade()</code>.</p>
</td></tr>
<tr><td><code id="ggcascade_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs of
conditions defining the different statuses to be plotted (see examples).</p>
</td></tr>
<tr><td><code id="ggcascade_+3A_.weights">.weights</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optional weights.
Should select only one variable.</p>
</td></tr>
<tr><td><code id="ggcascade_+3A_.by">.by</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; A variable or a set
of variables to group by the computation of the cascade, and to generate
facets. To select several variables, use <code><a href="dplyr.html#topic+pick">dplyr::pick()</a></code> (see examples).</p>
</td></tr>
<tr><td><code id="ggcascade_+3A_.nrow">.nrow</code>, <code id="ggcascade_+3A_.ncol">.ncol</code></td>
<td>
<p>Number of rows and columns, for faceted plots.</p>
</td></tr>
<tr><td><code id="ggcascade_+3A_.add_n">.add_n</code></td>
<td>
<p>Display the number of observations?</p>
</td></tr>
<tr><td><code id="ggcascade_+3A_.text_size">.text_size</code></td>
<td>
<p>Size of the labels, passed to <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text()</a></code>.</p>
</td></tr>
<tr><td><code id="ggcascade_+3A_.arrows">.arrows</code></td>
<td>
<p>Display arrows between statuses?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggcascade()</code> calls <code>compute_cascade()</code> to generate a data set passed
to <code>plot_cascade()</code>. Use <code>compute_cascade()</code> and <code>plot_cascade()</code> for
more controls.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot or a <code>tibble</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot2::diamonds |&gt;
  ggcascade(
    all = TRUE,
    big = carat &gt; .5,
    "big &amp; ideal" = carat &gt; .5 &amp; cut == "Ideal"
  )

ggplot2::mpg |&gt;
  ggcascade(
    all = TRUE,
    recent = year &gt; 2000,
    "recent &amp; economic" = year &gt; 2000 &amp; displ &lt; 3,
    .by = cyl,
    .ncol = 3,
    .arrows = FALSE,
    .text_size = 3
  )

ggplot2::mpg |&gt;
  ggcascade(
    all = TRUE,
    recent = year &gt; 2000,
    "recent &amp; economic" = year &gt; 2000 &amp; displ &lt; 3,
    .by = pick(cyl, drv),
    .add_n = FALSE,
    .text_size = 2
  )
</code></pre>

<hr>
<h2 id='ggcoef_model'>Plot model coefficients</h2><span id='topic+ggcoef_model'></span><span id='topic+ggcoef_table'></span><span id='topic+ggcoef_dodged'></span><span id='topic+ggcoef_faceted'></span><span id='topic+ggcoef_compare'></span><span id='topic+ggcoef_plot'></span>

<h3>Description</h3>

<p><code>ggcoef_model()</code>, <code>ggcoef_table()</code>, <code>ggcoef_dodged()</code>,
<code>ggcoef_faceted()</code> and <code>ggcoef_compare()</code>
use <code><a href="broom.helpers.html#topic+tidy_plus_plus">broom.helpers::tidy_plus_plus()</a></code>
to obtain a <code>tibble</code> of the model coefficients,
apply additional data transformation and then pass the
produced <code>tibble</code> to <code>ggcoef_plot()</code> to generate the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggcoef_model(
  model,
  tidy_fun = broom.helpers::tidy_with_broom_or_parameters,
  tidy_args = NULL,
  conf.int = TRUE,
  conf.level = 0.95,
  exponentiate = FALSE,
  variable_labels = NULL,
  term_labels = NULL,
  interaction_sep = " * ",
  categorical_terms_pattern = "{level}",
  add_reference_rows = TRUE,
  no_reference_row = NULL,
  intercept = FALSE,
  include = dplyr::everything(),
  group_by = broom.helpers::auto_group_by(),
  group_labels = NULL,
  add_pairwise_contrasts = FALSE,
  pairwise_variables = broom.helpers::all_categorical(),
  keep_model_terms = FALSE,
  pairwise_reverse = TRUE,
  emmeans_args = list(),
  significance = 1 - conf.level,
  significance_labels = NULL,
  show_p_values = TRUE,
  signif_stars = TRUE,
  return_data = FALSE,
  ...
)

ggcoef_table(
  model,
  tidy_fun = broom.helpers::tidy_with_broom_or_parameters,
  tidy_args = NULL,
  conf.int = TRUE,
  conf.level = 0.95,
  exponentiate = FALSE,
  variable_labels = NULL,
  term_labels = NULL,
  interaction_sep = " * ",
  categorical_terms_pattern = "{level}",
  add_reference_rows = TRUE,
  no_reference_row = NULL,
  intercept = FALSE,
  include = dplyr::everything(),
  group_by = broom.helpers::auto_group_by(),
  group_labels = NULL,
  add_pairwise_contrasts = FALSE,
  pairwise_variables = broom.helpers::all_categorical(),
  keep_model_terms = FALSE,
  pairwise_reverse = TRUE,
  emmeans_args = list(),
  significance = 1 - conf.level,
  significance_labels = NULL,
  show_p_values = FALSE,
  signif_stars = FALSE,
  table_stat = c("estimate", "ci", "p.value"),
  table_header = NULL,
  table_text_size = 3,
  table_stat_label = NULL,
  ci_pattern = "{conf.low}, {conf.high}",
  table_witdhs = c(3, 2),
  ...
)

ggcoef_dodged(
  model,
  tidy_fun = broom.helpers::tidy_with_broom_or_parameters,
  tidy_args = NULL,
  conf.int = TRUE,
  conf.level = 0.95,
  exponentiate = FALSE,
  variable_labels = NULL,
  term_labels = NULL,
  interaction_sep = " * ",
  categorical_terms_pattern = "{level}",
  add_reference_rows = TRUE,
  no_reference_row = NULL,
  intercept = FALSE,
  include = dplyr::everything(),
  group_by = broom.helpers::auto_group_by(),
  group_labels = NULL,
  significance = 1 - conf.level,
  significance_labels = NULL,
  return_data = FALSE,
  ...
)

ggcoef_faceted(
  model,
  tidy_fun = broom.helpers::tidy_with_broom_or_parameters,
  tidy_args = NULL,
  conf.int = TRUE,
  conf.level = 0.95,
  exponentiate = FALSE,
  variable_labels = NULL,
  term_labels = NULL,
  interaction_sep = " * ",
  categorical_terms_pattern = "{level}",
  add_reference_rows = TRUE,
  no_reference_row = NULL,
  intercept = FALSE,
  include = dplyr::everything(),
  group_by = broom.helpers::auto_group_by(),
  group_labels = NULL,
  significance = 1 - conf.level,
  significance_labels = NULL,
  return_data = FALSE,
  ...
)

ggcoef_compare(
  models,
  type = c("dodged", "faceted"),
  tidy_fun = broom.helpers::tidy_with_broom_or_parameters,
  tidy_args = NULL,
  conf.int = TRUE,
  conf.level = 0.95,
  exponentiate = FALSE,
  variable_labels = NULL,
  term_labels = NULL,
  interaction_sep = " * ",
  categorical_terms_pattern = "{level}",
  add_reference_rows = TRUE,
  no_reference_row = NULL,
  intercept = FALSE,
  include = dplyr::everything(),
  add_pairwise_contrasts = FALSE,
  pairwise_variables = broom.helpers::all_categorical(),
  keep_model_terms = FALSE,
  pairwise_reverse = TRUE,
  emmeans_args = list(),
  significance = 1 - conf.level,
  significance_labels = NULL,
  return_data = FALSE,
  ...
)

ggcoef_plot(
  data,
  x = "estimate",
  y = "label",
  exponentiate = FALSE,
  y_labeller = NULL,
  point_size = 2,
  point_stroke = 2,
  point_fill = "white",
  colour = NULL,
  colour_guide = TRUE,
  colour_lab = "",
  colour_labels = ggplot2::waiver(),
  shape = "significance",
  shape_values = c(16, 21),
  shape_guide = TRUE,
  shape_lab = "",
  errorbar = TRUE,
  errorbar_height = 0.1,
  errorbar_coloured = FALSE,
  stripped_rows = TRUE,
  strips_odd = "#11111111",
  strips_even = "#00000000",
  vline = TRUE,
  vline_colour = "grey50",
  dodged = FALSE,
  dodged_width = 0.8,
  facet_row = "var_label",
  facet_col = NULL,
  facet_labeller = "label_value",
  plot_title = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggcoef_model_+3A_model">model</code></td>
<td>
<p>a regression model object</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_tidy_fun">tidy_fun</code></td>
<td>
<p>(<code>function</code>)<br />
Option to specify a custom tidier function.</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_tidy_args">tidy_args</code></td>
<td>
<p>Additional arguments passed to
<code><a href="broom.helpers.html#topic+tidy_plus_plus">broom.helpers::tidy_plus_plus()</a></code> and to <code>tidy_fun</code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_conf.int">conf.int</code></td>
<td>
<p>(<code>logical</code>)<br />
Should confidence intervals be computed? (see <code><a href="broom.html#topic+reexports">broom::tidy()</a></code>)</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level to use for the confidence
interval if <code>conf.int = TRUE</code>; must be strictly greater than 0
and less than 1; defaults to 0.95, which corresponds to a 95
percent confidence interval</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_exponentiate">exponentiate</code></td>
<td>
<p>if <code>TRUE</code> a logarithmic scale will
be used for x-axis</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_variable_labels">variable_labels</code></td>
<td>
<p>(<code><a href="gtsummary.html#topic+syntax">formula-list-selector</a></code>)<br />
A named list or a named vector of custom variable labels.</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_term_labels">term_labels</code></td>
<td>
<p>(<code>list</code> or <code>vector</code>)<br />
A named list or a named vector of custom term labels.</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_interaction_sep">interaction_sep</code></td>
<td>
<p>(<code>string</code>)<br />
Separator for interaction terms.</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_categorical_terms_pattern">categorical_terms_pattern</code></td>
<td>
<p>(<code><a href="glue.html#topic+glue">glue pattern</a></code>)<br />
A <a href="glue.html#topic+glue">glue pattern</a> for labels of categorical terms with treatment
or sum contrasts (see <code><a href="broom.helpers.html#topic+model_list_terms_levels">model_list_terms_levels()</a></code>).</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_add_reference_rows">add_reference_rows</code></td>
<td>
<p>(<code>logical</code>)<br />
Should reference rows be added?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_no_reference_row">no_reference_row</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
Variables for those no reference row should be added,
when <code>add_reference_rows = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_intercept">intercept</code></td>
<td>
<p>(<code>logical</code>)<br />
Should the intercept(s) be included?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_include">include</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
Variables to include. Default is <code>everything()</code>.
See also <code><a href="broom.helpers.html#topic+all_continuous">all_continuous()</a></code>, <code><a href="broom.helpers.html#topic+all_categorical">all_categorical()</a></code>, <code><a href="broom.helpers.html#topic+all_dichotomous">all_dichotomous()</a></code>
and <code><a href="broom.helpers.html#topic+all_interaction">all_interaction()</a></code>.</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_group_by">group_by</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
One or several variables to group by. Default is <code>auto_group_by()</code>.
Use <code>NULL</code> to force ungrouping.</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_group_labels">group_labels</code></td>
<td>
<p>(<code>string</code>)<br />
An optional named vector of custom term labels.</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_add_pairwise_contrasts">add_pairwise_contrasts</code></td>
<td>
<p>(<code>logical</code>)<br />
Apply <code><a href="broom.helpers.html#topic+tidy_add_pairwise_contrasts">tidy_add_pairwise_contrasts()</a></code>?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_pairwise_variables">pairwise_variables</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
Variables to add pairwise contrasts.</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_keep_model_terms">keep_model_terms</code></td>
<td>
<p>(<code>logical</code>)<br />
Keep original model terms for variables where
pairwise contrasts are added? (default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_pairwise_reverse">pairwise_reverse</code></td>
<td>
<p>(<code>logical</code>)<br />
Determines whether to use <code>"pairwise"</code> (if <code>TRUE</code>)
or <code>"revpairwise"</code> (if <code>FALSE</code>), see <code><a href="emmeans.html#topic+contrast">emmeans::contrast()</a></code>.</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_emmeans_args">emmeans_args</code></td>
<td>
<p>(<code>list</code>)<br />
List of additional parameter to pass to
<code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code> when computing pairwise contrasts.</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_significance">significance</code></td>
<td>
<p>level (between 0 and 1) below which a
coefficient is consider to be significantly different from 0
(or 1 if <code>exponentiate = TRUE</code>), <code>NULL</code> for not highlighting
such coefficients</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_significance_labels">significance_labels</code></td>
<td>
<p>optional vector with custom labels
for significance variable</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_show_p_values">show_p_values</code></td>
<td>
<p>if <code>TRUE</code>, add p-value to labels</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_signif_stars">signif_stars</code></td>
<td>
<p>if <code>TRUE</code>, add significant stars to labels</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_return_data">return_data</code></td>
<td>
<p>if <code>TRUE</code>, will return the data.frame used
for plotting instead of the plot</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="#topic+ggcoef_plot">ggcoef_plot()</a></code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_table_stat">table_stat</code></td>
<td>
<p>statistics to display in the table, use any column name
returned by the tidier or <code>"ci"</code> for confidence intervals formatted
according to <code>ci_pattern</code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_table_header">table_header</code></td>
<td>
<p>optional custom headers for the table</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_table_text_size">table_text_size</code></td>
<td>
<p>text size for the table</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_table_stat_label">table_stat_label</code></td>
<td>
<p>optional named list of labeller functions for the
displayed statistic (see examples)</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_ci_pattern">ci_pattern</code></td>
<td>
<p>glue pattern for confidence intervals in the table</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_table_witdhs">table_witdhs</code></td>
<td>
<p>relative widths of the forest plot and the coefficients
table</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_models">models</code></td>
<td>
<p>named list of models</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_type">type</code></td>
<td>
<p>a dodged plot, a faceted plot or multiple table plots?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_data">data</code></td>
<td>
<p>a data frame containing data to be plotted,
typically the output of <code>ggcoef_model()</code>, <code>ggcoef_compare()</code>
or <code>ggcoef_multinom()</code> with the option <code>return_data = TRUE</code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_x">x</code>, <code id="ggcoef_model_+3A_y">y</code></td>
<td>
<p>variables mapped to x and y axis</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_y_labeller">y_labeller</code></td>
<td>
<p>optional function to be applied on y labels (see examples)</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_point_size">point_size</code></td>
<td>
<p>size of the points</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_point_stroke">point_stroke</code></td>
<td>
<p>thickness of the points</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_point_fill">point_fill</code></td>
<td>
<p>fill colour for the points</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_colour">colour</code></td>
<td>
<p>optional variable name to be mapped to
colour aesthetic</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_colour_guide">colour_guide</code></td>
<td>
<p>should colour guide be displayed
in the legend?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_colour_lab">colour_lab</code></td>
<td>
<p>label of the colour aesthetic in the legend</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_colour_labels">colour_labels</code></td>
<td>
<p>labels argument passed to
<code><a href="ggplot2.html#topic+scale_colour_discrete">ggplot2::scale_colour_discrete()</a></code> and
<code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_shape">shape</code></td>
<td>
<p>optional variable name to be mapped to the
shape aesthetic</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_shape_values">shape_values</code></td>
<td>
<p>values of the different shapes to use in
<code><a href="ggplot2.html#topic+scale_manual">ggplot2::scale_shape_manual()</a></code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_shape_guide">shape_guide</code></td>
<td>
<p>should shape guide be displayed in the legend?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_shape_lab">shape_lab</code></td>
<td>
<p>label of the shape aesthetic in the legend</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_errorbar">errorbar</code></td>
<td>
<p>should error bars be plotted?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_errorbar_height">errorbar_height</code></td>
<td>
<p>height of error bars</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_errorbar_coloured">errorbar_coloured</code></td>
<td>
<p>should error bars be colored as the points?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_stripped_rows">stripped_rows</code></td>
<td>
<p>should stripped rows be displayed in the background?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_strips_odd">strips_odd</code></td>
<td>
<p>color of the odd rows</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_strips_even">strips_even</code></td>
<td>
<p>color of the even rows</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_vline">vline</code></td>
<td>
<p>should a vertical line be drawn at 0 (or 1 if
<code>exponentiate = TRUE</code>)?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_vline_colour">vline_colour</code></td>
<td>
<p>colour of vertical line</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_dodged">dodged</code></td>
<td>
<p>should points be dodged (according to the colour aesthetic)?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_dodged_width">dodged_width</code></td>
<td>
<p>width value for <code><a href="ggplot2.html#topic+position_dodge">ggplot2::position_dodge()</a></code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_facet_row">facet_row</code></td>
<td>
<p>variable name to be used for row facets</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_facet_col">facet_col</code></td>
<td>
<p>optional variable name to be used for column facets</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_facet_labeller">facet_labeller</code></td>
<td>
<p>labeller function to be used for labeling facets;
if labels are too long, you can use <code><a href="ggplot2.html#topic+labellers">ggplot2::label_wrap_gen()</a></code> (see
examples), more information in the documentation of <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_plot_title">plot_title</code></td>
<td>
<p>an optional plot title</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more control, you can use the argument <code>return_data = TRUE</code> to
get the produced <code>tibble</code>, apply any transformation of your own and
then pass your customized <code>tibble</code> to <code>ggcoef_plot()</code>.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot or a <code>tibble</code> if <code>return_data = TRUE</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>ggcoef_table()</code>: a variation of <code><a href="#topic+ggcoef_model">ggcoef_model()</a></code> adding a table
with estimates, confidence intervals and p-values
</p>
</li>
<li> <p><code>ggcoef_dodged()</code>: a dodged variation of <code><a href="#topic+ggcoef_model">ggcoef_model()</a></code> for
multi groups models
</p>
</li>
<li> <p><code>ggcoef_faceted()</code>: a faceted variation of <code><a href="#topic+ggcoef_model">ggcoef_model()</a></code> for
multi groups models
</p>
</li>
<li> <p><code>ggcoef_compare()</code>: designed for displaying several models on the same
plot.
</p>
</li>
<li> <p><code>ggcoef_plot()</code>: plot a tidy <code>tibble</code> of coefficients
</p>
</li></ul>


<h3>See Also</h3>

<p><code>vignette("ggcoef_model")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(Sepal.Length ~ Sepal.Width + Species, data = iris)
ggcoef_model(mod)

ggcoef_table(mod)



ggcoef_table(mod, table_stat = c("estimate", "ci"))

ggcoef_table(
  mod,
  table_stat_label = list(
    estimate = scales::label_number(.001)
  )
)

ggcoef_table(mod, table_text_size = 5, table_witdhs = c(1, 1))

# a logistic regression example
d_titanic &lt;- as.data.frame(Titanic)
d_titanic$Survived &lt;- factor(d_titanic$Survived, c("No", "Yes"))
mod_titanic &lt;- glm(
  Survived ~ Sex * Age + Class,
  weights = Freq,
  data = d_titanic,
  family = binomial
)

# use 'exponentiate = TRUE' to get the Odds Ratio
ggcoef_model(mod_titanic, exponentiate = TRUE)

ggcoef_table(mod_titanic, exponentiate = TRUE)

# display intercepts
ggcoef_model(mod_titanic, exponentiate = TRUE, intercept = TRUE)

# customize terms labels
ggcoef_model(
  mod_titanic,
  exponentiate = TRUE,
  show_p_values = FALSE,
  signif_stars = FALSE,
  add_reference_rows = FALSE,
  categorical_terms_pattern = "{level} (ref: {reference_level})",
  interaction_sep = " x ",
  y_labeller = scales::label_wrap(15)
)

# display only a subset of terms
ggcoef_model(mod_titanic, exponentiate = TRUE, include = c("Age", "Class"))

# do not change points' shape based on significance
ggcoef_model(mod_titanic, exponentiate = TRUE, significance = NULL)

# a black and white version
ggcoef_model(
  mod_titanic,
  exponentiate = TRUE,
  colour = NULL, stripped_rows = FALSE
)

# show dichotomous terms on one row
ggcoef_model(
  mod_titanic,
  exponentiate = TRUE,
  no_reference_row = broom.helpers::all_dichotomous(),
  categorical_terms_pattern =
    "{ifelse(dichotomous, paste0(level, ' / ', reference_level), level)}",
  show_p_values = FALSE
)




data(tips, package = "reshape")
mod_simple &lt;- lm(tip ~ day + time + total_bill, data = tips)
ggcoef_model(mod_simple)

# custom variable labels
# you can use the labelled package to define variable labels
# before computing model
if (requireNamespace("labelled")) {
  tips_labelled &lt;- tips |&gt;
    labelled::set_variable_labels(
      day = "Day of the week",
      time = "Lunch or Dinner",
      total_bill = "Bill's total"
    )
  mod_labelled &lt;- lm(tip ~ day + time + total_bill, data = tips_labelled)
  ggcoef_model(mod_labelled)
}

# you can provide custom variable labels with 'variable_labels'
ggcoef_model(
  mod_simple,
  variable_labels = c(
    day = "Week day",
    time = "Time (lunch or dinner ?)",
    total_bill = "Total of the bill"
  )
)
# if labels are too long, you can use 'facet_labeller' to wrap them
ggcoef_model(
  mod_simple,
  variable_labels = c(
    day = "Week day",
    time = "Time (lunch or dinner ?)",
    total_bill = "Total of the bill"
  ),
  facet_labeller = ggplot2::label_wrap_gen(10)
)

# do not display variable facets but add colour guide
ggcoef_model(mod_simple, facet_row = NULL, colour_guide = TRUE)

# works also with with polynomial terms
mod_poly &lt;- lm(
  tip ~ poly(total_bill, 3) + day,
  data = tips,
)
ggcoef_model(mod_poly)

# or with different type of contrasts
# for sum contrasts, the value of the reference term is computed
if (requireNamespace("emmeans")) {
  mod2 &lt;- lm(
    tip ~ day + time + sex,
    data = tips,
    contrasts = list(time = contr.sum, day = contr.treatment(4, base = 3))
  )
  ggcoef_model(mod2)
}





# multinomial model
mod &lt;- nnet::multinom(grade ~ stage + trt + age, data = gtsummary::trial)
ggcoef_model(mod, exponentiate = TRUE)
ggcoef_table(mod, group_labels = c(II = "Stage 2 vs. 1"))
ggcoef_dodged(mod, exponentiate = TRUE)
ggcoef_faceted(mod, exponentiate = TRUE)




library(pscl)
data("bioChemists", package = "pscl")
mod &lt;- zeroinfl(art ~ fem * mar | fem + mar, data = bioChemists)
ggcoef_model(mod)
ggcoef_table(mod)
ggcoef_dodged(mod)
ggcoef_faceted(
  mod,
  group_labels = c(conditional = "Count", zero_inflated = "Zero-inflated")
)

mod2 &lt;- zeroinfl(art ~ fem + mar | 1, data = bioChemists)
ggcoef_table(mod2)
ggcoef_table(mod2, intercept = TRUE)



# Use ggcoef_compare() for comparing several models on the same plot
mod1 &lt;- lm(Fertility ~ ., data = swiss)
mod2 &lt;- step(mod1, trace = 0)
mod3 &lt;- lm(Fertility ~ Agriculture + Education * Catholic, data = swiss)
models &lt;- list(
  "Full model" = mod1,
  "Simplified model" = mod2,
  "With interaction" = mod3
)

ggcoef_compare(models)
ggcoef_compare(models, type = "faceted")

# you can reverse the vertical position of the point by using a negative
# value for dodged_width (but it will produce some warnings)
ggcoef_compare(models, dodged_width = -.9)

</code></pre>

<hr>
<h2 id='ggcoef_multicomponents'>Deprecated functions</h2><span id='topic+ggcoef_multicomponents'></span><span id='topic+ggcoef_multinom'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggcoef_multicomponents(
  model,
  type = c("dodged", "faceted", "table"),
  component_col = "component",
  component_label = NULL,
  tidy_fun = broom.helpers::tidy_with_broom_or_parameters,
  tidy_args = NULL,
  conf.int = TRUE,
  conf.level = 0.95,
  exponentiate = FALSE,
  variable_labels = NULL,
  term_labels = NULL,
  interaction_sep = " * ",
  categorical_terms_pattern = "{level}",
  add_reference_rows = TRUE,
  no_reference_row = NULL,
  intercept = FALSE,
  include = dplyr::everything(),
  significance = 1 - conf.level,
  significance_labels = NULL,
  return_data = FALSE,
  table_stat = c("estimate", "ci", "p.value"),
  table_header = NULL,
  table_text_size = 3,
  table_stat_label = NULL,
  ci_pattern = "{conf.low}, {conf.high}",
  table_witdhs = c(3, 2),
  ...
)

ggcoef_multinom(
  model,
  type = c("dodged", "faceted", "table"),
  y.level_label = NULL,
  tidy_fun = broom.helpers::tidy_with_broom_or_parameters,
  tidy_args = NULL,
  conf.int = TRUE,
  conf.level = 0.95,
  exponentiate = FALSE,
  variable_labels = NULL,
  term_labels = NULL,
  interaction_sep = " * ",
  categorical_terms_pattern = "{level}",
  add_reference_rows = TRUE,
  no_reference_row = NULL,
  intercept = FALSE,
  include = dplyr::everything(),
  significance = 1 - conf.level,
  significance_labels = NULL,
  return_data = FALSE,
  table_stat = c("estimate", "ci", "p.value"),
  table_header = NULL,
  table_text_size = 3,
  table_stat_label = NULL,
  ci_pattern = "{conf.low}, {conf.high}",
  table_witdhs = c(3, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggcoef_multicomponents_+3A_model">model</code></td>
<td>
<p>a regression model object</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_type">type</code></td>
<td>
<p>a dodged plot, a faceted plot or multiple table plots?</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_component_col">component_col</code></td>
<td>
<p>name of the component column</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_component_label">component_label</code></td>
<td>
<p>an optional named vector for labeling components</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_tidy_fun">tidy_fun</code></td>
<td>
<p>(<code>function</code>)<br />
Option to specify a custom tidier function.</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_tidy_args">tidy_args</code></td>
<td>
<p>Additional arguments passed to
<code><a href="broom.helpers.html#topic+tidy_plus_plus">broom.helpers::tidy_plus_plus()</a></code> and to <code>tidy_fun</code></p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_conf.int">conf.int</code></td>
<td>
<p>(<code>logical</code>)<br />
Should confidence intervals be computed? (see <code><a href="broom.html#topic+reexports">broom::tidy()</a></code>)</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level to use for the confidence
interval if <code>conf.int = TRUE</code>; must be strictly greater than 0
and less than 1; defaults to 0.95, which corresponds to a 95
percent confidence interval</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_exponentiate">exponentiate</code></td>
<td>
<p>if <code>TRUE</code> a logarithmic scale will
be used for x-axis</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_variable_labels">variable_labels</code></td>
<td>
<p>(<code><a href="gtsummary.html#topic+syntax">formula-list-selector</a></code>)<br />
A named list or a named vector of custom variable labels.</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_term_labels">term_labels</code></td>
<td>
<p>(<code>list</code> or <code>vector</code>)<br />
A named list or a named vector of custom term labels.</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_interaction_sep">interaction_sep</code></td>
<td>
<p>(<code>string</code>)<br />
Separator for interaction terms.</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_categorical_terms_pattern">categorical_terms_pattern</code></td>
<td>
<p>(<code><a href="glue.html#topic+glue">glue pattern</a></code>)<br />
A <a href="glue.html#topic+glue">glue pattern</a> for labels of categorical terms with treatment
or sum contrasts (see <code><a href="broom.helpers.html#topic+model_list_terms_levels">model_list_terms_levels()</a></code>).</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_add_reference_rows">add_reference_rows</code></td>
<td>
<p>(<code>logical</code>)<br />
Should reference rows be added?</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_no_reference_row">no_reference_row</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
Variables for those no reference row should be added,
when <code>add_reference_rows = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_intercept">intercept</code></td>
<td>
<p>(<code>logical</code>)<br />
Should the intercept(s) be included?</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_include">include</code></td>
<td>
<p>(<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>)<br />
Variables to include. Default is <code>everything()</code>.
See also <code><a href="broom.helpers.html#topic+all_continuous">all_continuous()</a></code>, <code><a href="broom.helpers.html#topic+all_categorical">all_categorical()</a></code>, <code><a href="broom.helpers.html#topic+all_dichotomous">all_dichotomous()</a></code>
and <code><a href="broom.helpers.html#topic+all_interaction">all_interaction()</a></code>.</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_significance">significance</code></td>
<td>
<p>level (between 0 and 1) below which a
coefficient is consider to be significantly different from 0
(or 1 if <code>exponentiate = TRUE</code>), <code>NULL</code> for not highlighting
such coefficients</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_significance_labels">significance_labels</code></td>
<td>
<p>optional vector with custom labels
for significance variable</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_return_data">return_data</code></td>
<td>
<p>if <code>TRUE</code>, will return the data.frame used
for plotting instead of the plot</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_table_stat">table_stat</code></td>
<td>
<p>statistics to display in the table, use any column name
returned by the tidier or <code>"ci"</code> for confidence intervals formatted
according to <code>ci_pattern</code></p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_table_header">table_header</code></td>
<td>
<p>optional custom headers for the table</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_table_text_size">table_text_size</code></td>
<td>
<p>text size for the table</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_table_stat_label">table_stat_label</code></td>
<td>
<p>optional named list of labeller functions for the
displayed statistic (see examples)</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_ci_pattern">ci_pattern</code></td>
<td>
<p>glue pattern for confidence intervals in the table</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_table_witdhs">table_witdhs</code></td>
<td>
<p>relative widths of the forest plot and the coefficients
table</p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="#topic+ggcoef_plot">ggcoef_plot()</a></code></p>
</td></tr>
<tr><td><code id="ggcoef_multicomponents_+3A_y.level_label">y.level_label</code></td>
<td>
<p>an optional named vector for labeling <code>y.level</code>
(see examples)</p>
</td></tr>
</table>

<hr>
<h2 id='gglikert'>Plotting Likert-type items</h2><span id='topic+gglikert'></span><span id='topic+gglikert_data'></span><span id='topic+gglikert_stacked'></span>

<h3>Description</h3>

<p>Combines several factor variables using the same list of ordered levels
(e.g. Likert-type scales) into a unique data frame and generates a centered
bar plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gglikert(
  data,
  include = dplyr::everything(),
  weights = NULL,
  y = ".question",
  variable_labels = NULL,
  sort = c("none", "ascending", "descending"),
  sort_method = c("prop", "prop_lower", "mean", "median"),
  sort_prop_include_center = totals_include_center,
  factor_to_sort = ".question",
  exclude_fill_values = NULL,
  cutoff = NULL,
  data_fun = NULL,
  add_labels = TRUE,
  labels_size = 3.5,
  labels_color = "auto",
  labels_accuracy = 1,
  labels_hide_below = 0.05,
  add_totals = TRUE,
  totals_size = labels_size,
  totals_color = "black",
  totals_accuracy = labels_accuracy,
  totals_fontface = "bold",
  totals_include_center = FALSE,
  totals_hjust = 0.1,
  y_reverse = TRUE,
  y_label_wrap = 50,
  reverse_likert = FALSE,
  width = 0.9,
  facet_rows = NULL,
  facet_cols = NULL,
  facet_label_wrap = 50,
  symmetric = FALSE
)

gglikert_data(
  data,
  include = dplyr::everything(),
  weights = NULL,
  variable_labels = NULL,
  sort = c("none", "ascending", "descending"),
  sort_method = c("prop", "prop_lower", "mean", "median"),
  sort_prop_include_center = TRUE,
  factor_to_sort = ".question",
  exclude_fill_values = NULL,
  cutoff = NULL,
  data_fun = NULL
)

gglikert_stacked(
  data,
  include = dplyr::everything(),
  weights = NULL,
  y = ".question",
  variable_labels = NULL,
  sort = c("none", "ascending", "descending"),
  sort_method = c("prop", "prop_lower", "mean", "median"),
  sort_prop_include_center = FALSE,
  factor_to_sort = ".question",
  data_fun = NULL,
  add_labels = TRUE,
  labels_size = 3.5,
  labels_color = "auto",
  labels_accuracy = 1,
  labels_hide_below = 0.05,
  add_median_line = FALSE,
  y_reverse = TRUE,
  y_label_wrap = 50,
  reverse_fill = TRUE,
  width = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gglikert_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="gglikert_+3A_include">include</code></td>
<td>
<p>variables to include, accepts <a href="dplyr.html#topic+select">tidy-select</a>
syntax</p>
</td></tr>
<tr><td><code id="gglikert_+3A_weights">weights</code></td>
<td>
<p>optional variable name of a weighting variable,
accepts <a href="dplyr.html#topic+select">tidy-select</a> syntax</p>
</td></tr>
<tr><td><code id="gglikert_+3A_y">y</code></td>
<td>
<p>name of the variable to be plotted on <code>y</code> axis (relevant when
<code>.question</code> is mapped to &quot;facets, see examples),
accepts <a href="dplyr.html#topic+select">tidy-select</a> syntax</p>
</td></tr>
<tr><td><code id="gglikert_+3A_variable_labels">variable_labels</code></td>
<td>
<p>a named list or a named vector of custom variable
labels</p>
</td></tr>
<tr><td><code id="gglikert_+3A_sort">sort</code></td>
<td>
<p>should the factor defined by <code>factor_to_sort</code> be sorted according
to the answers (see <code>sort_method</code>)? One of &quot;none&quot; (default), &quot;ascending&quot; or
&quot;descending&quot;</p>
</td></tr>
<tr><td><code id="gglikert_+3A_sort_method">sort_method</code></td>
<td>
<p>method used to sort the variables: <code>"prop"</code> sort according
to the proportion of answers higher than the centered level, <code>"prop_lower"</code>
according to the proportion lower than the centered level,  <code>"mean"</code>
considers answer as a score and sort according to the mean score, <code>"median"</code>
used the median and the majority judgment rule for tie-breaking.</p>
</td></tr>
<tr><td><code id="gglikert_+3A_sort_prop_include_center">sort_prop_include_center</code></td>
<td>
<p>when sorting with <code>"prop"</code> and if the number
of levels is uneven, should half of the central level be taken into account
to compute the proportion?</p>
</td></tr>
<tr><td><code id="gglikert_+3A_factor_to_sort">factor_to_sort</code></td>
<td>
<p>name of the factor column to sort if <code>sort</code> is not
equal to <code>"none"</code>; by default the list of questions passed to <code>include</code>;
should be one factor column of the tibble returned by <code>gglikert_data()</code>;
accepts <a href="dplyr.html#topic+select">tidy-select</a> syntax</p>
</td></tr>
<tr><td><code id="gglikert_+3A_exclude_fill_values">exclude_fill_values</code></td>
<td>
<p>Vector of values that should not be displayed
(but still taken into account for computing proportions),
see <code><a href="#topic+position_likert">position_likert()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_cutoff">cutoff</code></td>
<td>
<p>number of categories to be displayed negatively (i.e. on the
left of the x axis or the bottom of the y axis), could be a decimal value:
<code>2</code> to display negatively the two first categories, <code>2.5</code> to display
negatively the two first categories and half of the third, <code>2.2</code> to display
negatively the two first categories and a fifth of the third (see examples).
By default (<code>NULL</code>), it will be equal to the number of categories divided
by 2, i.e. it will be centered.</p>
</td></tr>
<tr><td><code id="gglikert_+3A_data_fun">data_fun</code></td>
<td>
<p>for advanced usage, custom function to be applied to the
generated dataset at the end of <code>gglikert_data()</code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_add_labels">add_labels</code></td>
<td>
<p>should percentage labels be added to the plot?</p>
</td></tr>
<tr><td><code id="gglikert_+3A_labels_size">labels_size</code></td>
<td>
<p>size of the percentage labels</p>
</td></tr>
<tr><td><code id="gglikert_+3A_labels_color">labels_color</code></td>
<td>
<p>color of the percentage labels (<code>"auto"</code> to use
<code>hex_bw()</code> to determine a font color based on background color)</p>
</td></tr>
<tr><td><code id="gglikert_+3A_labels_accuracy">labels_accuracy</code></td>
<td>
<p>accuracy of the percentages, see
<code><a href="scales.html#topic+label_percent">scales::label_percent()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_labels_hide_below">labels_hide_below</code></td>
<td>
<p>if provided, values below will be masked, see
<code><a href="#topic+label_percent_abs">label_percent_abs()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_add_totals">add_totals</code></td>
<td>
<p>should the total proportions of negative and positive
answers be added to plot? <strong>This option is not compatible with facets!</strong></p>
</td></tr>
<tr><td><code id="gglikert_+3A_totals_size">totals_size</code></td>
<td>
<p>size of the total proportions</p>
</td></tr>
<tr><td><code id="gglikert_+3A_totals_color">totals_color</code></td>
<td>
<p>color of the total proportions</p>
</td></tr>
<tr><td><code id="gglikert_+3A_totals_accuracy">totals_accuracy</code></td>
<td>
<p>accuracy of the total proportions, see
<code><a href="scales.html#topic+label_percent">scales::label_percent()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_totals_fontface">totals_fontface</code></td>
<td>
<p>font face of the total proportions</p>
</td></tr>
<tr><td><code id="gglikert_+3A_totals_include_center">totals_include_center</code></td>
<td>
<p>if the number of levels is uneven, should half
of the center level be added to the total proportions?</p>
</td></tr>
<tr><td><code id="gglikert_+3A_totals_hjust">totals_hjust</code></td>
<td>
<p>horizontal adjustment of totals labels on the x axis</p>
</td></tr>
<tr><td><code id="gglikert_+3A_y_reverse">y_reverse</code></td>
<td>
<p>should the y axis be reversed?</p>
</td></tr>
<tr><td><code id="gglikert_+3A_y_label_wrap">y_label_wrap</code></td>
<td>
<p>number of characters per line for y axis labels, see
<code><a href="scales.html#topic+label_wrap">scales::label_wrap()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_reverse_likert">reverse_likert</code></td>
<td>
<p>if <code>TRUE</code>, will reverse the default stacking order,
see <code><a href="#topic+position_likert">position_likert()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_width">width</code></td>
<td>
<p>bar width, see <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_facet_rows">facet_rows</code>, <code id="gglikert_+3A_facet_cols">facet_cols</code></td>
<td>
<p>A set of variables or expressions quoted by
<code><a href="ggplot2.html#topic+vars">ggplot2::vars()</a></code> and defining faceting groups on the rows or columns
dimension (see examples)</p>
</td></tr>
<tr><td><code id="gglikert_+3A_facet_label_wrap">facet_label_wrap</code></td>
<td>
<p>number of characters per line for facet labels, see
<code><a href="ggplot2.html#topic+labellers">ggplot2::label_wrap_gen()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_symmetric">symmetric</code></td>
<td>
<p>should the x-axis be symmetric?</p>
</td></tr>
<tr><td><code id="gglikert_+3A_add_median_line">add_median_line</code></td>
<td>
<p>add a vertical line at 50%?</p>
</td></tr>
<tr><td><code id="gglikert_+3A_reverse_fill">reverse_fill</code></td>
<td>
<p>if <code>TRUE</code>, will reverse the default stacking order,
see <code><a href="ggplot2.html#topic+position_stack">ggplot2::position_fill()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>You could use <code>gglikert_data()</code> to just produce the dataset to be plotted.
</p>
<p>If variable labels have been defined (see <code><a href="labelled.html#topic+var_label">labelled::var_label()</a></code>), they will
be considered. You can also pass custom variables labels with the
<code>variable_labels</code> argument.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot or a <code>tibble</code>.
</p>


<h3>See Also</h3>

<p><code>vignette("gglikert")</code>, <code><a href="#topic+position_likert">position_likert()</a></code>, <code><a href="#topic+stat_prop">stat_prop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(dplyr)

likert_levels &lt;- c(
  "Strongly disagree",
  "Disagree",
  "Neither agree nor disagree",
  "Agree",
  "Strongly agree"
)
set.seed(42)
df &lt;-
  tibble(
    q1 = sample(likert_levels, 150, replace = TRUE),
    q2 = sample(likert_levels, 150, replace = TRUE, prob = 5:1),
    q3 = sample(likert_levels, 150, replace = TRUE, prob = 1:5),
    q4 = sample(likert_levels, 150, replace = TRUE, prob = 1:5),
    q5 = sample(c(likert_levels, NA), 150, replace = TRUE),
    q6 = sample(likert_levels, 150, replace = TRUE, prob = c(1, 0, 1, 1, 0))
  ) |&gt;
  mutate(across(everything(), ~ factor(.x, levels = likert_levels)))

gglikert(df)

gglikert(df, include = q1:3) +
  scale_fill_likert(pal = scales::brewer_pal(palette = "PRGn"))

gglikert(df, sort = "ascending")


gglikert(df, sort = "ascending", sort_prop_include_center = TRUE)

gglikert(df, sort = "ascending", sort_method = "mean")

gglikert(df, reverse_likert = TRUE)

gglikert(df, add_totals = FALSE, add_labels = FALSE)

gglikert(
  df,
  totals_include_center = TRUE,
  totals_hjust = .25,
  totals_size = 4.5,
  totals_fontface = "italic",
  totals_accuracy = .01,
  labels_accuracy = 1,
  labels_size = 2.5,
  labels_hide_below = .25
)

gglikert(df, exclude_fill_values = "Neither agree nor disagree")

if (require("labelled")) {
  df |&gt;
    set_variable_labels(
      q1 = "First question",
      q2 = "Second question"
    ) |&gt;
    gglikert(
      variable_labels = c(
        q4 = "a custom label",
        q6 = "a very very very very very very very very very very long label"
      ),
      y_label_wrap = 25
    )
}

# Facets
df_group &lt;- df
df_group$group &lt;- sample(c("A", "B"), 150, replace = TRUE)

gglikert(df_group, q1:q6, facet_rows = vars(group))

gglikert(df_group, q1:q6, facet_cols = vars(group))

gglikert(df_group, q1:q6, y = "group", facet_rows = vars(.question))

# Custom function to be applied on data
f &lt;- function(d) {
  d$.question &lt;- forcats::fct_relevel(d$.question, "q5", "q2")
  d
}
gglikert(df, include = q1:q6, data_fun = f)

# Custom center
gglikert(df, cutoff = 2)

gglikert(df, cutoff = 1)

gglikert(df, cutoff = 1, symmetric = TRUE)


gglikert_stacked(df, q1:q6)

gglikert_stacked(df, q1:q6, add_median_line = TRUE, sort = "asc")


gglikert_stacked(df_group, q1:q6, y = "group", add_median_line = TRUE) +
  facet_grid(rows = vars(.question))

</code></pre>

<hr>
<h2 id='ggsurvey'>Easy ggplot2 with survey objects</h2><span id='topic+ggsurvey'></span>

<h3>Description</h3>

<p>A function to facilitate <code>ggplot2</code> graphs using a survey object.
It will initiate a ggplot and map survey weights to the
corresponding aesthetic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggsurvey(design = NULL, mapping = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggsurvey_+3A_design">design</code></td>
<td>
<p>A survey design object, usually created with
<code><a href="survey.html#topic+svydesign">survey::svydesign()</a></code></p>
</td></tr>
<tr><td><code id="ggsurvey_+3A_mapping">mapping</code></td>
<td>
<p>Default list of aesthetic mappings to use for plot,
to be created with <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>.</p>
</td></tr>
<tr><td><code id="ggsurvey_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Graphs will be correct as long as only weights are required
to compute the graph. However, statistic or geometry requiring
correct variance computation (like <code><a href="ggplot2.html#topic+geom_smooth">ggplot2::geom_smooth()</a></code>) will
be statistically incorrect.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(api, package = "survey")
dstrat &lt;- survey::svydesign(
  id = ~1, strata = ~stype,
  weights = ~pw, data = apistrat,
  fpc = ~fpc
)
ggsurvey(dstrat) +
  ggplot2::aes(x = cnum, y = dnum) +
  ggplot2::geom_count()

d &lt;- as.data.frame(Titanic)
dw &lt;- survey::svydesign(ids = ~1, weights = ~Freq, data = d)
ggsurvey(dw) +
  ggplot2::aes(x = Class, fill = Survived) +
  ggplot2::geom_bar(position = "fill")

</code></pre>

<hr>
<h2 id='hex_bw'>Identify a suitable font color (black or white) given a background HEX color</h2><span id='topic+hex_bw'></span><span id='topic+hex_bw_threshold'></span><span id='topic+auto_contrast'></span>

<h3>Description</h3>

<p>You could use <code>auto_contrast</code> as a shortcut of
<code>aes(colour = after_scale(hex_bw(.data$fill)))</code>. You should use <code style="white-space: pre;">&#8288;!!!&#8288;</code> to
inject it within <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code> (see examples).
</p>
<p><code>hex_bw_threshold()</code> is a variation of <code>hex_bw()</code>. For <code>values</code> below
<code>threshold</code>, black (<code>"#000000"</code>) will always be returned, regardless of
<code>hex_code</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hex_bw(hex_code)

hex_bw_threshold(hex_code, values, threshold)

auto_contrast
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hex_bw_+3A_hex_code">hex_code</code></td>
<td>
<p>Background color in hex-format.</p>
</td></tr>
<tr><td><code id="hex_bw_+3A_values">values</code></td>
<td>
<p>Values to be compared.</p>
</td></tr>
<tr><td><code id="hex_bw_+3A_threshold">threshold</code></td>
<td>
<p>Threshold.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>uneval</code> of length 1.
</p>


<h3>Value</h3>

<p>Either black or white, in hex-format
</p>


<h3>Source</h3>

<p>Adapted from <code>saros</code> for <code>hex_code()</code> and from
<a href="https://github.com/teunbrand/ggplot_tricks?tab=readme-ov-file#text-contrast">https://github.com/teunbrand/ggplot_tricks?tab=readme-ov-file#text-contrast</a>
for <code>auto_contrast</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hex_bw("#0dadfd")

library(ggplot2)
ggplot(diamonds) +
  aes(x = cut, fill = color, label = after_stat(count)) +
  geom_bar() +
  geom_text(
    mapping = aes(color = after_scale(hex_bw(.data$fill))),
    position = position_stack(.5),
    stat = "count",
    size = 2
  )

ggplot(diamonds) +
  aes(x = cut, fill = color, label = after_stat(count)) +
  geom_bar() +
  geom_text(
    mapping = auto_contrast,
    position = position_stack(.5),
    stat = "count",
    size = 2
  )

ggplot(diamonds) +
  aes(x = cut, fill = color, label = after_stat(count), !!!auto_contrast) +
  geom_bar() +
  geom_text(
    mapping = auto_contrast,
    position = position_stack(.5),
    stat = "count",
    size = 2
  )
</code></pre>

<hr>
<h2 id='label_number_abs'>Label absolute values</h2><span id='topic+label_number_abs'></span><span id='topic+label_percent_abs'></span>

<h3>Description</h3>

<p>Label absolute values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_number_abs(..., hide_below = NULL)

label_percent_abs(..., hide_below = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_number_abs_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="scales.html#topic+label_number">scales::label_number()</a></code> or
<code><a href="scales.html#topic+label_percent">scales::label_percent()</a></code></p>
</td></tr>
<tr><td><code id="label_number_abs_+3A_hide_below">hide_below</code></td>
<td>
<p>if provided, values below <code>hide_below</code> will be masked
(i.e. an empty string <code>""</code> will be returned)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;labelling&quot; function, , i.e. a function that takes a vector and
returns a character vector of same length giving a label for each input
value.
</p>


<h3>See Also</h3>

<p><code><a href="scales.html#topic+label_number">scales::label_number()</a></code>, <code><a href="scales.html#topic+label_percent">scales::label_percent()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(-0.2, -.05, 0, .07, .25, .66)

scales::label_number()(x)
label_number_abs()(x)

scales::label_percent()(x)
label_percent_abs()(x)
label_percent_abs(hide_below = .1)(x)
</code></pre>

<hr>
<h2 id='pal_extender'>Extend a discrete colour palette</h2><span id='topic+pal_extender'></span><span id='topic+scale_fill_extended'></span><span id='topic+scale_colour_extended'></span>

<h3>Description</h3>

<p>If the palette returns less colours than requested, the list of colours
will be expanded using <code><a href="scales.html#topic+pal_gradient_n">scales::pal_gradient_n()</a></code>. To be used with a
sequential or diverging palette. Not relevant for qualitative palettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pal_extender(pal = scales::brewer_pal(palette = "BrBG"))

scale_fill_extended(
  name = waiver(),
  ...,
  pal = scales::brewer_pal(palette = "BrBG"),
  aesthetics = "fill"
)

scale_colour_extended(
  name = waiver(),
  ...,
  pal = scales::brewer_pal(palette = "BrBG"),
  aesthetics = "colour"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pal_extender_+3A_pal">pal</code></td>
<td>
<p>A palette function, such as returned by <a href="scales.html#topic+pal_brewer">scales::brewer_pal</a>,
taking a number of colours as entry and returning a list of colours.</p>
</td></tr>
<tr><td><code id="pal_extender_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title.
If <code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be omitted.</p>
</td></tr>
<tr><td><code id="pal_extender_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code>discrete_scale()</code> to control name,
limits, breaks, labels and so forth.</p>
</td></tr>
<tr><td><code id="pal_extender_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing
the name(s) of the aesthetic(s) that this scale works with. This can be
useful, for example, to apply colour settings to the colour and fill
aesthetics at the same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A palette function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pal &lt;- scales::pal_brewer(palette = "PiYG")
scales::show_col(pal(16))
scales::show_col(pal_extender(pal)(16))
</code></pre>

<hr>
<h2 id='position_likert'>Stack objects on top of each another and center them around 0</h2><span id='topic+position_likert'></span><span id='topic+position_diverging'></span><span id='topic+PositionLikert'></span><span id='topic+PositionDiverging'></span>

<h3>Description</h3>

<p><code>position_diverging()</code> stacks bars on top of each other and
center them around zero (the same number of categories are displayed on
each side).
<code>position_likert()</code> uses proportions instead of counts. This type of
presentation is commonly used to display Likert-type scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_likert(
  vjust = 1,
  reverse = FALSE,
  exclude_fill_values = NULL,
  cutoff = NULL
)

position_diverging(
  vjust = 1,
  reverse = FALSE,
  exclude_fill_values = NULL,
  cutoff = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="position_likert_+3A_vjust">vjust</code></td>
<td>
<p>Vertical adjustment for geoms that have a position
(like points or lines), not a dimension (like bars or areas). Set to
<code>0</code> to align with the bottom, <code>0.5</code> for the middle,
and <code>1</code> (the default) for the top.</p>
</td></tr>
<tr><td><code id="position_likert_+3A_reverse">reverse</code></td>
<td>
<p>If <code>TRUE</code>, will reverse the default stacking order.
This is useful if you're rotating both the plot and legend.</p>
</td></tr>
<tr><td><code id="position_likert_+3A_exclude_fill_values">exclude_fill_values</code></td>
<td>
<p>Vector of values from the variable associated with
the <code>fill</code> aesthetic that should not be displayed (but still taken into
account for computing proportions)</p>
</td></tr>
<tr><td><code id="position_likert_+3A_cutoff">cutoff</code></td>
<td>
<p>number of categories to be displayed negatively (i.e. on the
left of the x axis or the bottom of the y axis), could be a decimal value:
<code>2</code> to display negatively the two first categories, <code>2.5</code> to display
negatively the two first categories and half of the third, <code>2.2</code> to display
negatively the two first categories and a fifth of the third (see examples).
By default (<code>NULL</code>), it will be equal to the number of categories divided
by 2, i.e. it will be centered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to use <code>position_likert()</code> with <code>stat_prop()</code>
and its <code>complete</code> argument (see examples).
</p>


<h3>See Also</h3>

<p>See <code><a href="ggplot2.html#topic+position_stack">ggplot2::position_stack()</a></code> and <code><a href="ggplot2.html#topic+position_stack">ggplot2::position_fill()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "fill") +
  scale_x_continuous(label = scales::label_percent()) +
  xlab("proportion")

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "likert") +
  scale_x_continuous(label = label_percent_abs()) +
  scale_fill_likert() +
  xlab("proportion")

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "stack") +
  scale_fill_likert(pal = scales::brewer_pal(palette = "PiYG"))

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "diverging") +
  scale_x_continuous(label = label_number_abs()) +
  scale_fill_likert()


# Reverse order -------------------------------------------------------------

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = position_likert(reverse = TRUE)) +
  scale_x_continuous(label = label_percent_abs()) +
  scale_fill_likert() +
  xlab("proportion")

# Custom center -------------------------------------------------------------

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = position_likert(cutoff = 1)) +
  scale_x_continuous(label = label_percent_abs()) +
  scale_fill_likert(cutoff = 1) +
  xlab("proportion")

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = position_likert(cutoff = 3.75)) +
  scale_x_continuous(label = label_percent_abs()) +
  scale_fill_likert(cutoff = 3.75) +
  xlab("proportion")

# Missing items -------------------------------------------------------------
# example with a level not being observed for a specific value of y
d &lt;- diamonds
d &lt;- d[!(d$cut == "Premium" &amp; d$clarity == "I1"), ]
d &lt;- d[!(d$cut %in% c("Fair", "Good") &amp; d$clarity == "SI2"), ]

# by default, the two lowest bar are not properly centered
ggplot(d) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "likert") +
  scale_fill_likert()

# use stat_prop() with `complete = "fill"` to fix it
ggplot(d) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "likert", stat = "prop", complete = "fill") +
  scale_fill_likert()

# Add labels ----------------------------------------------------------------

custom_label &lt;- function(x) {
  p &lt;- scales::percent(x, accuracy = 1)
  p[x &lt; .075] &lt;- ""
  p
}

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "likert") +
  geom_text(
    aes(by = clarity, label = custom_label(after_stat(prop))),
    stat = "prop",
    position = position_likert(vjust = .5)
  ) +
  scale_x_continuous(label = label_percent_abs()) +
  scale_fill_likert() +
  xlab("proportion")

# Do not display specific fill values ---------------------------------------
# (but taken into account to compute proportions)

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = position_likert(exclude_fill_values = "Very Good")) +
  scale_x_continuous(label = label_percent_abs()) +
  scale_fill_likert() +
  xlab("proportion")

</code></pre>

<hr>
<h2 id='round_any'>Round to multiple of any number.</h2><span id='topic+round_any'></span>

<h3>Description</h3>

<p>Round to multiple of any number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_any(x, accuracy, f = round)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="round_any_+3A_x">x</code></td>
<td>
<p>numeric or date-time (POSIXct) vector to round</p>
</td></tr>
<tr><td><code id="round_any_+3A_accuracy">accuracy</code></td>
<td>
<p>number to round to; for POSIXct objects, a number of seconds</p>
</td></tr>
<tr><td><code id="round_any_+3A_f">f</code></td>
<td>
<p>rounding function: <code><a href="base.html#topic+floor">floor</a></code>, <code><a href="base.html#topic+ceiling">ceiling</a></code> or
<code><a href="base.html#topic+round">round</a></code></p>
</td></tr>
</table>


<h3>Source</h3>

<p>adapted from <code>plyr</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>round_any(1.865, accuracy = .25)
</code></pre>

<hr>
<h2 id='scale_fill_likert'>Colour scale for Likert-type plots</h2><span id='topic+scale_fill_likert'></span><span id='topic+likert_pal'></span>

<h3>Description</h3>

<p>This scale is similar to other diverging discrete colour scales, but allows
to change the &quot;center&quot; of the scale using <code>cutoff</code> argument, as used by
<code><a href="#topic+position_likert">position_likert()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_likert(
  name = waiver(),
  ...,
  pal = scales::brewer_pal(palette = "BrBG"),
  cutoff = NULL,
  aesthetics = "fill"
)

likert_pal(pal = scales::brewer_pal(palette = "BrBG"), cutoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_fill_likert_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title.
If <code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be omitted.</p>
</td></tr>
<tr><td><code id="scale_fill_likert_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code>discrete_scale()</code> to control name,
limits, breaks, labels and so forth.</p>
</td></tr>
<tr><td><code id="scale_fill_likert_+3A_pal">pal</code></td>
<td>
<p>A palette function taking a number of colours as entry and
returning a list of colours (see examples), ideally a diverging palette</p>
</td></tr>
<tr><td><code id="scale_fill_likert_+3A_cutoff">cutoff</code></td>
<td>
<p>Number of categories displayed negatively (see
<code><a href="#topic+position_likert">position_likert()</a></code>) and therefore changing the center of the colour scale
(see examples).</p>
</td></tr>
<tr><td><code id="scale_fill_likert_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing
the name(s) of the aesthetic(s) that this scale works with. This can be
useful, for example, to apply colour settings to the colour and fill
aesthetics at the same time, via <code>aesthetics = c("colour", "fill")</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "likert") +
  scale_x_continuous(label = label_percent_abs()) +
  xlab("proportion")

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "likert") +
  scale_x_continuous(label = label_percent_abs()) +
  xlab("proportion") +
  scale_fill_likert()

 ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = position_likert(cutoff = 1)) +
  scale_x_continuous(label = label_percent_abs()) +
  xlab("proportion") +
  scale_fill_likert(cutoff = 1)
</code></pre>

<hr>
<h2 id='signif_stars'>Significance Stars</h2><span id='topic+signif_stars'></span>

<h3>Description</h3>

<p>Calculate significance stars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signif_stars(x, three = 0.001, two = 0.01, one = 0.05, point = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signif_stars_+3A_x">x</code></td>
<td>
<p>numeric values that will be compared to the <code>point</code>,
<code>one</code>, <code>two</code>, and <code>three</code> values</p>
</td></tr>
<tr><td><code id="signif_stars_+3A_three">three</code></td>
<td>
<p>threshold below which to display three stars</p>
</td></tr>
<tr><td><code id="signif_stars_+3A_two">two</code></td>
<td>
<p>threshold below which to display two stars</p>
</td></tr>
<tr><td><code id="signif_stars_+3A_one">one</code></td>
<td>
<p>threshold below which to display one star</p>
</td></tr>
<tr><td><code id="signif_stars_+3A_point">point</code></td>
<td>
<p>threshold below which to display one point
(<code>NULL</code> to deactivate)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector containing the appropriate number of
stars for each <code>x</code> value.
</p>


<h3>Author(s)</h3>

<p>Joseph Larmarange
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0.5, 0.1, 0.05, 0.01, 0.001)
signif_stars(x)
signif_stars(x, one = .15, point = NULL)
</code></pre>

<hr>
<h2 id='stat_cross'>Compute cross-tabulation statistics</h2><span id='topic+stat_cross'></span><span id='topic+StatCross'></span>

<h3>Description</h3>

<p>Computes statistics of a 2-dimensional matrix using <a href="broom.html#topic+augment.htest">broom::augment.htest</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_cross(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE,
  keep.zero.cells = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_cross_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_geom">geom</code></td>
<td>
<p>Override the default connection with
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_cross_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_cross_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, the default, missing values are
removed with a warning.
If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_keep.zero.cells">keep.zero.cells</code></td>
<td>
<p>If <code>TRUE</code>, cells with no observations are kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot with the added statistic.
</p>


<h3>Aesthetics</h3>

<p><code>stat_cross()</code> requires the <strong>x</strong> and the <strong>y</strong> aesthetics.
</p>


<h3>Computed variables</h3>


<dl>
<dt>observed</dt><dd><p>number of observations in x,y</p>
</dd>
<dt>prop</dt><dd><p>proportion of total</p>
</dd>
<dt>row.prop</dt><dd><p>row proportion</p>
</dd>
<dt>col.prop</dt><dd><p>column proportion</p>
</dd>
<dt>expected</dt><dd><p>expected count under the null hypothesis</p>
</dd>
<dt>resid</dt><dd><p>Pearson's residual</p>
</dd>
<dt>std.resid</dt><dd><p>standardized residual</p>
</dd>
<dt>row.observed</dt><dd><p>total number of observations within row</p>
</dd>
<dt>col.observed</dt><dd><p>total number of observations within column</p>
</dd>
<dt>total.observed</dt><dd><p>total number of observations within the table</p>
</dd>
<dt>phi</dt><dd><p>phi coefficients, see <code><a href="#topic+augment_chisq_add_phi">augment_chisq_add_phi()</a></code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code>vignette("stat_cross")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
d &lt;- as.data.frame(Titanic)

# plot number of observations
ggplot(d) +
  aes(x = Class, y = Survived, weight = Freq, size = after_stat(observed)) +
  stat_cross() +
  scale_size_area(max_size = 20)

# custom shape and fill colour based on chi-squared residuals
ggplot(d) +
  aes(
    x = Class, y = Survived, weight = Freq,
    size = after_stat(observed), fill = after_stat(std.resid)
  ) +
  stat_cross(shape = 22) +
  scale_fill_steps2(breaks = c(-3, -2, 2, 3), show.limits = TRUE) +
  scale_size_area(max_size = 20)


# custom shape and fill colour based on phi coeffients
ggplot(d) +
  aes(
    x = Class, y = Survived, weight = Freq,
    size = after_stat(observed), fill = after_stat(phi)
  ) +
  stat_cross(shape = 22) +
  scale_fill_steps2(show.limits = TRUE) +
  scale_size_area(max_size = 20)


# plotting the number of observations as a table
ggplot(d) +
  aes(
    x = Class, y = Survived, weight = Freq, label = after_stat(observed)
  ) +
  geom_text(stat = "cross")

# Row proportions with standardized residuals
ggplot(d) +
  aes(
    x = Class, y = Survived, weight = Freq,
    label = scales::percent(after_stat(row.prop)),
    size = NULL, fill = after_stat(std.resid)
  ) +
  stat_cross(shape = 22, size = 30) +
  geom_text(stat = "cross") +
  scale_fill_steps2(breaks = c(-3, -2, 2, 3), show.limits = TRUE) +
  facet_grid(Sex ~ .) +
  labs(fill = "Standardized residuals") +
  theme_minimal()

</code></pre>

<hr>
<h2 id='stat_prop'>Compute proportions according to custom denominator</h2><span id='topic+stat_prop'></span><span id='topic+StatProp'></span>

<h3>Description</h3>

<p><code>stat_prop()</code> is a variation of <code><a href="ggplot2.html#topic+geom_bar">ggplot2::stat_count()</a></code> allowing to
compute custom proportions according to the <strong>by</strong> aesthetic defining
the denominator (i.e. all proportions for a same value of <strong>by</strong> will
sum to 1). If the <strong>by</strong> aesthetic is not specified, denominators will be
determined according to the <code>default_by</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_prop(
  mapping = NULL,
  data = NULL,
  geom = "bar",
  position = "fill",
  ...,
  width = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  complete = NULL,
  default_by = "total"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_prop_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_geom">geom</code></td>
<td>
<p>Override the default connection with <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_prop_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_prop_+3A_width">width</code></td>
<td>
<p>Bar width. By default, set to 90% of the <code><a href="ggplot2.html#topic+resolution">resolution()</a></code> of the
data.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_complete">complete</code></td>
<td>
<p>Name (character) of an aesthetic for those statistics should
be completed for unobserved values (see example).</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_default_by">default_by</code></td>
<td>
<p>If the <strong>by</strong> aesthetic is not available, name of another
aesthetic that will be used to determine the denominators (e.g. <code>"fill"</code>),
or <code>NULL</code> or <code>"total"</code> to compute proportions of the total. To be noted,
<code>default_by = "x"</code> works both for vertical and horizontal bars.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot with the added statistic.
</p>


<h3>Aesthetics</h3>

<p><code>stat_prop()</code> understands the following aesthetics
(required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x <em>or</em> y</strong>
</p>
</li>
<li><p> by
</p>
</li>
<li><p> weight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt><code>after_stat(count)</code></dt><dd><p>number of points in bin</p>
</dd>
<dt><code>after_stat(denominator)</code></dt><dd><p>denominator for the proportions</p>
</dd>
<dt><code>after_stat(prop)</code></dt><dd><p>computed proportion, i.e.
<code>after_stat(count)</code>/<code>after_stat(denominator)</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code>vignette("stat_prop")</code>, <code><a href="ggplot2.html#topic+geom_bar">ggplot2::stat_count()</a></code>. For an alternative
approach, see
<a href="https://github.com/tidyverse/ggplot2/issues/5505#issuecomment-1791324008">https://github.com/tidyverse/ggplot2/issues/5505#issuecomment-1791324008</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
d &lt;- as.data.frame(Titanic)

p &lt;- ggplot(d) +
  aes(x = Class, fill = Survived, weight = Freq, by = Class) +
  geom_bar(position = "fill") +
  geom_text(stat = "prop", position = position_fill(.5))
p
p + facet_grid(~Sex)

ggplot(d) +
  aes(x = Class, fill = Survived, weight = Freq) +
  geom_bar(position = "dodge") +
  geom_text(
    aes(by = Survived),
    stat = "prop",
    position = position_dodge(0.9), vjust = "bottom"
  )

if (requireNamespace("scales")) {
  ggplot(d) +
    aes(x = Class, fill = Survived, weight = Freq, by = 1) +
    geom_bar() +
    geom_text(
      aes(label = scales::percent(after_stat(prop), accuracy = 1)),
      stat = "prop",
      position = position_stack(.5)
    )
}

# displaying unobserved levels with complete
d &lt;- diamonds |&gt;
  dplyr::filter(!(cut == "Ideal" &amp; clarity == "I1")) |&gt;
  dplyr::filter(!(cut == "Very Good" &amp; clarity == "VS2")) |&gt;
  dplyr::filter(!(cut == "Premium" &amp; clarity == "IF"))
p &lt;- ggplot(d) +
  aes(x = clarity, fill = cut, by = clarity) +
  geom_bar(position = "fill")
p + geom_text(stat = "prop", position = position_fill(.5))
p + geom_text(stat = "prop", position = position_fill(.5), complete = "fill")

</code></pre>

<hr>
<h2 id='stat_weighted_mean'>Compute weighted y mean</h2><span id='topic+stat_weighted_mean'></span><span id='topic+StatWeightedMean'></span>

<h3>Description</h3>

<p>This statistic will compute the mean of <strong>y</strong> aesthetic for
each unique value of <strong>x</strong>, taking into account <strong>weight</strong>
aesthetic if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_weighted_mean(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_weighted_mean_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_geom">geom</code></td>
<td>
<p>Override the default connection with <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot with the added statistic.
</p>


<h3>Computed variables</h3>


<dl>
<dt>y</dt><dd><p>weighted y (numerator / denominator)</p>
</dd>
<dt>numerator</dt><dd><p>numerator</p>
</dd>
<dt>denominator</dt><dd><p>denominator</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code>vignette("stat_weighted_mean")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ggplot2)

data(tips, package = "reshape")

ggplot(tips) +
  aes(x = day, y = total_bill) +
  geom_point()

ggplot(tips) +
  aes(x = day, y = total_bill) +
  stat_weighted_mean()


ggplot(tips) +
  aes(x = day, y = total_bill, group = 1) +
  stat_weighted_mean(geom = "line")

ggplot(tips) +
  aes(x = day, y = total_bill, colour = sex, group = sex) +
  stat_weighted_mean(geom = "line")

ggplot(tips) +
  aes(x = day, y = total_bill, fill = sex) +
  stat_weighted_mean(geom = "bar", position = "dodge")

# computing a proportion on the fly
if (requireNamespace("scales")) {
  ggplot(tips) +
    aes(x = day, y = as.integer(smoker == "Yes"), fill = sex) +
    stat_weighted_mean(geom = "bar", position = "dodge") +
    scale_y_continuous(labels = scales::percent)
}

library(ggplot2)

# taking into account some weights
if (requireNamespace("scales")) {
  d &lt;- as.data.frame(Titanic)
  ggplot(d) +
    aes(
      x = Class, y = as.integer(Survived == "Yes"),
      weight = Freq, fill = Sex
    ) +
    geom_bar(stat = "weighted_mean", position = "dodge") +
    scale_y_continuous(labels = scales::percent) +
    labs(y = "Survived")
}
</code></pre>

<hr>
<h2 id='symmetric_limits'>Symmetric limits</h2><span id='topic+symmetric_limits'></span>

<h3>Description</h3>

<p>Expand scale limits to make them symmetric around zero.
Can be passed as argument to parameter <code>limits</code> of continuous scales from
packages <code>{ggplot2}</code> or <code>{scales}</code>. Can be also used to obtain an enclosing
symmetric range for numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetric_limits(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symmetric_limits_+3A_x">x</code></td>
<td>
<p>a vector of numeric values, possibly a range, from which to compute
enclosing range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length two with the new limits, which are always
such that the absolute value of upper and lower limits is the same.
</p>


<h3>Source</h3>

<p>Adapted from the homonym function in <code>{ggpmisc}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

ggplot(iris) +
  aes(x = Sepal.Length - 5, y = Sepal.Width - 3, colour = Species) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_point()

last_plot() +
  scale_x_continuous(limits = symmetric_limits) +
  scale_y_continuous(limits = symmetric_limits)
</code></pre>

<hr>
<h2 id='weighted.median'>Weighted Median and Quantiles</h2><span id='topic+weighted.median'></span><span id='topic+weighted.quantile'></span>

<h3>Description</h3>

<p>Compute the median or quantiles a set of numbers which have weights
associated with them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.median(x, w, na.rm = TRUE, type = 2)

weighted.quantile(x, w, probs = seq(0, 1, 0.25), na.rm = TRUE, type = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted.median_+3A_x">x</code></td>
<td>
<p>a numeric vector of values</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_w">w</code></td>
<td>
<p>a numeric vector of weights</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether to ignore <code>NA</code> values</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_type">type</code></td>
<td>
<p>Integer specifying the rule for calculating the median or
quantile, corresponding to the rules available for <code>stats:quantile()</code>.
The only valid choices are type=1, 2 or 4. See Details.</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_probs">probs</code></td>
<td>
<p>probabilities for which the quantiles should be computed, a
numeric vector of values between 0 and 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>i</code>th observation <code>x[i]</code> is treated as having a weight proportional to
<code>w[i]</code>.
</p>
<p>The weighted median is a value <code>m</code> such that the total weight of data less
than or equal to <code>m</code> is equal to half the total weight. More generally, the
weighted quantile with probability <code>p</code> is a value <code>q</code> such that the total
weight of data less than or equal to <code>q</code> is equal to <code>p</code> times the total
weight.
</p>
<p>If there is no such value, then
</p>

<ul>
<li><p> if <code>type = 1</code>, the next largest value is returned (this is the
right-continuous inverse of the left-continuous cumulative distribution
function);
</p>
</li>
<li><p> if <code>type = 2</code>, the average of the two surrounding values is returned
(the average of the right-continuous and left-continuous inverses);
</p>
</li>
<li><p> if <code>type = 4</code>, linear interpolation is performed.
</p>
</li></ul>

<p>Note that the default rule for <code>weighted.median()</code> is <code>type = 2</code>, consistent
with the traditional definition of the median, while the default for
<code>weighted.quantile()</code> is <code>type = 4</code>.
</p>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Source</h3>

<p>These functions are adapted from their homonyms developed by Adrian
Baddeley in the <code>spatstat</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:20
w &lt;- runif(20)
weighted.median(x, w)
weighted.quantile(x, w)
</code></pre>

<hr>
<h2 id='weighted.sum'>Weighted Sum</h2><span id='topic+weighted.sum'></span>

<h3>Description</h3>

<p>Weighted Sum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.sum(x, w, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted.sum_+3A_x">x</code></td>
<td>
<p>a numeric vector of values</p>
</td></tr>
<tr><td><code id="weighted.sum_+3A_w">w</code></td>
<td>
<p>a numeric vector of weights</p>
</td></tr>
<tr><td><code id="weighted.sum_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether to ignore <code>NA</code> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:20
w &lt;- runif(20)
weighted.sum(x, w)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
