<!DOCTYPE html><html><head><title>Help for package ggstats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggstats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggstats-package'><p>ggstats: Extension to 'ggplot2' for Plotting Stats</p></a></li>
<li><a href='#augment_chisq_add_phi'><p>Augment a chi-squared test and compute phi coefficients</p></a></li>
<li><a href='#geom_stripped_rows'><p>Alternating Background Color</p></a></li>
<li><a href='#ggcoef_model'><p>Plot model coefficients</p></a></li>
<li><a href='#gglikert'><p>Plotting Likert-type items</p></a></li>
<li><a href='#ggsurvey'><p>Easy ggplot2 with survey objects</p></a></li>
<li><a href='#hex_bw'><p>Identify a suitable font color (black or white) given a background HEX color</p></a></li>
<li><a href='#label_number_abs'><p>Label absolute values</p></a></li>
<li><a href='#position_likert'><p>Stack objects on top of each another and center them around 0</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#round_any'><p>Round to multiple of any number.</p></a></li>
<li><a href='#signif_stars'><p>Significance Stars</p></a></li>
<li><a href='#stat_cross'><p>Compute cross-tabulation statistics</p></a></li>
<li><a href='#stat_prop'><p>Compute proportions according to custom denominator</p></a></li>
<li><a href='#stat_weighted_mean'><p>Compute weighted y mean</p></a></li>
<li><a href='#weighted.median'><p>Weighted Median and Quantiles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extension to 'ggplot2' for Plotting Stats</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides new statistics, new geometries and new positions for 
    'ggplot2' and a suite of functions to facilitate the creation of 
    statistical plots.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://larmarange.github.io/ggstats/">https://larmarange.github.io/ggstats/</a>,
<a href="https://github.com/larmarange/ggstats">https://github.com/larmarange/ggstats</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/larmarange/ggstats/issues">https://github.com/larmarange/ggstats/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>broom.helpers (&ge; 1.14.0), cli, dplyr, forcats, ggplot2 (&ge;
3.4.0), lifecycle, magrittr, patchwork, purrr, rlang, scales,
stats, stringr, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>betareg, broom, emmeans, glue, knitr, labelled (&ge; 2.11.0),
reshape, rmarkdown, nnet, parameters, pscl, testthat (&ge;
3.0.0), spelling, survey, survival, vdiffr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-05 12:38:33 UTC; josep</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph Larmarange <a href="https://orcid.org/0000-0001-7097-700X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joseph Larmarange &lt;joseph@larmarange.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-05 15:42:59 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggstats-package'>ggstats: Extension to 'ggplot2' for Plotting Stats</h2><span id='topic+ggstats'></span><span id='topic+ggstats-package'></span>

<h3>Description</h3>

<p>Provides new statistics, new geometries and new positions for 'ggplot2' and a suite of functions to facilitate the creation of statistical plots.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joseph Larmarange <a href="mailto:joseph@larmarange.net">joseph@larmarange.net</a> (<a href="https://orcid.org/0000-0001-7097-700X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://larmarange.github.io/ggstats/">https://larmarange.github.io/ggstats/</a>
</p>
</li>
<li> <p><a href="https://github.com/larmarange/ggstats">https://github.com/larmarange/ggstats</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/larmarange/ggstats/issues">https://github.com/larmarange/ggstats/issues</a>
</p>
</li></ul>


<hr>
<h2 id='augment_chisq_add_phi'>Augment a chi-squared test and compute phi coefficients</h2><span id='topic+augment_chisq_add_phi'></span>

<h3>Description</h3>

<p>Augment a chi-squared test and compute phi coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augment_chisq_add_phi(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment_chisq_add_phi_+3A_x">x</code></td>
<td>
<p>a chi-squared test as returned by <code><a href="stats.html#topic+chisq.test">stats::chisq.test()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Phi coefficients are a measurement of the degree of association
between two binary variables.
</p>

<ul>
<li><p> A value between -1.0 to -0.7 indicates a strong negative association.
</p>
</li>
<li><p> A value between -0.7 to -0.3 indicates a weak negative association.
</p>
</li>
<li><p> A value between -0.3 to +0.3 indicates a little or no association.
</p>
</li>
<li><p> A value between +0.3 to +0.7 indicates a weak positive association.
</p>
</li>
<li><p> A value between +0.7 to +1.0 indicates a strong positive association.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tibble</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stat_cross">stat_cross()</a></code>, <code>GDAtools::phi.table()</code> or <code>psych::phi()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tab &lt;- xtabs(Freq ~ Sex + Class, data = as.data.frame(Titanic))
augment_chisq_add_phi(chisq.test(tab))
</code></pre>

<hr>
<h2 id='geom_stripped_rows'>Alternating Background Color</h2><span id='topic+geom_stripped_rows'></span><span id='topic+geom_stripped_cols'></span>

<h3>Description</h3>

<p>Add alternating background color along the y-axis. The geom takes default
aesthetics <code>odd</code> and <code>even</code> that receive color codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_stripped_rows(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  show.legend = NA,
  inherit.aes = TRUE,
  xfrom = -Inf,
  xto = Inf,
  width = 1,
  nudge_y = 0
)

geom_stripped_cols(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  show.legend = NA,
  inherit.aes = TRUE,
  yfrom = -Inf,
  yto = Inf,
  width = 1,
  nudge_x = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_stripped_rows_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_xfrom">xfrom</code>, <code id="geom_stripped_rows_+3A_xto">xto</code></td>
<td>
<p>limitation of the strips along the x-axis</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_width">width</code></td>
<td>
<p>width of the strips</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_yfrom">yfrom</code>, <code id="geom_stripped_rows_+3A_yto">yto</code></td>
<td>
<p>limitation of the strips along the y-axis</p>
</td></tr>
<tr><td><code id="geom_stripped_rows_+3A_nudge_x">nudge_x</code>, <code id="geom_stripped_rows_+3A_nudge_y">nudge_y</code></td>
<td>
<p>horizontal or vertical adjustment to nudge strips by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot with the added geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(tips, package = "reshape")

library(ggplot2)
p &lt;- ggplot(tips) +
  aes(x = time, y = day) +
  geom_count() +
  theme_light()

p
p + geom_stripped_rows()
p + geom_stripped_cols()
p + geom_stripped_rows() + geom_stripped_cols()


p &lt;- ggplot(tips) +
  aes(x = total_bill, y = day) +
  geom_count() +
  theme_light()
p
p + geom_stripped_rows()
p + geom_stripped_rows() + scale_y_discrete(expand = expansion(0, 0.5))
p + geom_stripped_rows(xfrom = 10, xto = 35)
p + geom_stripped_rows(odd = "blue", even = "yellow")
p + geom_stripped_rows(odd = "blue", even = "yellow", alpha = .1)
p + geom_stripped_rows(odd = "#00FF0022", even = "#FF000022")

p + geom_stripped_cols()
p + geom_stripped_cols(width = 10)
p + geom_stripped_cols(width = 10, nudge_x = 5)


</code></pre>

<hr>
<h2 id='ggcoef_model'>Plot model coefficients</h2><span id='topic+ggcoef_model'></span><span id='topic+ggcoef_table'></span><span id='topic+ggcoef_compare'></span><span id='topic+ggcoef_multinom'></span><span id='topic+ggcoef_multicomponents'></span><span id='topic+ggcoef_plot'></span>

<h3>Description</h3>

<p><code>ggcoef_model()</code>, <code>ggcoef_table()</code>, <code>ggcoef_multinom()</code>,
<code>ggcoef_multicomponents()</code> and <code>ggcoef_compare()</code>
use <code><a href="broom.helpers.html#topic+tidy_plus_plus">broom.helpers::tidy_plus_plus()</a></code>
to obtain a <code>tibble</code> of the model coefficients,
apply additional data transformation and then pass the
produced <code>tibble</code> to <code>ggcoef_plot()</code> to generate the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggcoef_model(
  model,
  tidy_fun = broom.helpers::tidy_with_broom_or_parameters,
  tidy_args = NULL,
  conf.int = TRUE,
  conf.level = 0.95,
  exponentiate = FALSE,
  variable_labels = NULL,
  term_labels = NULL,
  interaction_sep = " * ",
  categorical_terms_pattern = "{level}",
  add_reference_rows = TRUE,
  no_reference_row = NULL,
  intercept = FALSE,
  include = dplyr::everything(),
  add_pairwise_contrasts = FALSE,
  pairwise_variables = broom.helpers::all_categorical(),
  keep_model_terms = FALSE,
  pairwise_reverse = TRUE,
  emmeans_args = list(),
  significance = 1 - conf.level,
  significance_labels = NULL,
  show_p_values = TRUE,
  signif_stars = TRUE,
  return_data = FALSE,
  ...
)

ggcoef_table(
  model,
  tidy_fun = broom.helpers::tidy_with_broom_or_parameters,
  tidy_args = NULL,
  conf.int = TRUE,
  conf.level = 0.95,
  exponentiate = FALSE,
  variable_labels = NULL,
  term_labels = NULL,
  interaction_sep = " * ",
  categorical_terms_pattern = "{level}",
  add_reference_rows = TRUE,
  no_reference_row = NULL,
  intercept = FALSE,
  include = dplyr::everything(),
  add_pairwise_contrasts = FALSE,
  pairwise_variables = broom.helpers::all_categorical(),
  keep_model_terms = FALSE,
  pairwise_reverse = TRUE,
  emmeans_args = list(),
  significance = 1 - conf.level,
  significance_labels = NULL,
  show_p_values = FALSE,
  signif_stars = FALSE,
  table_stat = c("estimate", "ci", "p.value"),
  table_header = NULL,
  table_text_size = 3,
  table_stat_label = NULL,
  ci_pattern = "{conf.low}, {conf.high}",
  table_witdhs = c(3, 2),
  plot_title = NULL,
  ...
)

ggcoef_compare(
  models,
  type = c("dodged", "faceted"),
  tidy_fun = broom.helpers::tidy_with_broom_or_parameters,
  tidy_args = NULL,
  conf.int = TRUE,
  conf.level = 0.95,
  exponentiate = FALSE,
  variable_labels = NULL,
  term_labels = NULL,
  interaction_sep = " * ",
  categorical_terms_pattern = "{level}",
  add_reference_rows = TRUE,
  no_reference_row = NULL,
  intercept = FALSE,
  include = dplyr::everything(),
  add_pairwise_contrasts = FALSE,
  pairwise_variables = broom.helpers::all_categorical(),
  keep_model_terms = FALSE,
  pairwise_reverse = TRUE,
  emmeans_args = list(),
  significance = 1 - conf.level,
  significance_labels = NULL,
  return_data = FALSE,
  ...
)

ggcoef_multinom(
  model,
  type = c("dodged", "faceted", "table"),
  y.level_label = NULL,
  tidy_fun = broom.helpers::tidy_with_broom_or_parameters,
  tidy_args = NULL,
  conf.int = TRUE,
  conf.level = 0.95,
  exponentiate = FALSE,
  variable_labels = NULL,
  term_labels = NULL,
  interaction_sep = " * ",
  categorical_terms_pattern = "{level}",
  add_reference_rows = TRUE,
  no_reference_row = NULL,
  intercept = FALSE,
  include = dplyr::everything(),
  significance = 1 - conf.level,
  significance_labels = NULL,
  return_data = FALSE,
  table_stat = c("estimate", "ci", "p.value"),
  table_header = NULL,
  table_text_size = 3,
  table_stat_label = NULL,
  ci_pattern = "{conf.low}, {conf.high}",
  table_witdhs = c(3, 2),
  ...
)

ggcoef_multicomponents(
  model,
  type = c("dodged", "faceted", "table"),
  component_col = "component",
  component_label = NULL,
  tidy_fun = broom.helpers::tidy_with_broom_or_parameters,
  tidy_args = NULL,
  conf.int = TRUE,
  conf.level = 0.95,
  exponentiate = FALSE,
  variable_labels = NULL,
  term_labels = NULL,
  interaction_sep = " * ",
  categorical_terms_pattern = "{level}",
  add_reference_rows = TRUE,
  no_reference_row = NULL,
  intercept = FALSE,
  include = dplyr::everything(),
  significance = 1 - conf.level,
  significance_labels = NULL,
  return_data = FALSE,
  table_stat = c("estimate", "ci", "p.value"),
  table_header = NULL,
  table_text_size = 3,
  table_stat_label = NULL,
  ci_pattern = "{conf.low}, {conf.high}",
  table_witdhs = c(3, 2),
  ...
)

ggcoef_plot(
  data,
  x = "estimate",
  y = "label",
  exponentiate = FALSE,
  point_size = 2,
  point_stroke = 2,
  point_fill = "white",
  colour = NULL,
  colour_guide = TRUE,
  colour_lab = "",
  colour_labels = ggplot2::waiver(),
  shape = "significance",
  shape_values = c(16, 21),
  shape_guide = TRUE,
  shape_lab = "",
  errorbar = TRUE,
  errorbar_height = 0.1,
  errorbar_coloured = FALSE,
  stripped_rows = TRUE,
  strips_odd = "#11111111",
  strips_even = "#00000000",
  vline = TRUE,
  vline_colour = "grey50",
  dodged = FALSE,
  dodged_width = 0.8,
  facet_row = "var_label",
  facet_col = NULL,
  facet_labeller = "label_value"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggcoef_model_+3A_model">model</code></td>
<td>
<p>a regression model object</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_tidy_fun">tidy_fun</code></td>
<td>
<p>option to specify a custom tidier function</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_tidy_args">tidy_args</code></td>
<td>
<p>Additional arguments passed to
<code><a href="broom.helpers.html#topic+tidy_plus_plus">broom.helpers::tidy_plus_plus()</a></code> and to <code>tidy_fun</code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_conf.int">conf.int</code></td>
<td>
<p>should confidence intervals be computed? (see <code><a href="broom.html#topic+reexports">broom::tidy()</a></code>)</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level to use for the confidence
interval if <code>conf.int = TRUE</code>; must be strictly greater than 0
and less than 1; defaults to 0.95, which corresponds to a 95
percent confidence interval</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_exponentiate">exponentiate</code></td>
<td>
<p>if <code>TRUE</code> a logarithmic scale will
be used for x-axis</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_variable_labels">variable_labels</code></td>
<td>
<p>a named list or a named vector of custom variable labels</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_term_labels">term_labels</code></td>
<td>
<p>a named list or a named vector of custom term labels</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_interaction_sep">interaction_sep</code></td>
<td>
<p>separator for interaction terms</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_categorical_terms_pattern">categorical_terms_pattern</code></td>
<td>
<p>a <a href="glue.html#topic+glue">glue pattern</a> for
labels of categorical terms with treatment or sum contrasts
(see <code><a href="broom.helpers.html#topic+model_list_terms_levels">model_list_terms_levels()</a></code>)</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_add_reference_rows">add_reference_rows</code></td>
<td>
<p>should reference rows be added?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_no_reference_row">no_reference_row</code></td>
<td>
<p>variables (accepts <a href="dplyr.html#topic+select">tidyselect</a> notation)
for those no reference row should be added, when <code>add_reference_rows = TRUE</code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_intercept">intercept</code></td>
<td>
<p>should the intercept(s) be included?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_include">include</code></td>
<td>
<p>variables to include. Accepts <a href="dplyr.html#topic+select">tidyselect</a>
syntax. Use <code>-</code> to remove a variable. Default is <code>everything()</code>.
See also <code><a href="broom.helpers.html#topic+all_continuous">all_continuous()</a></code>, <code><a href="broom.helpers.html#topic+all_categorical">all_categorical()</a></code>, <code><a href="broom.helpers.html#topic+all_dichotomous">all_dichotomous()</a></code>
and <code><a href="broom.helpers.html#topic+all_interaction">all_interaction()</a></code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_add_pairwise_contrasts">add_pairwise_contrasts</code></td>
<td>
<p>apply <code><a href="broom.helpers.html#topic+tidy_add_pairwise_contrasts">tidy_add_pairwise_contrasts()</a></code>?
<a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_pairwise_variables">pairwise_variables</code></td>
<td>
<p>variables to add pairwise contrasts
(accepts <a href="dplyr.html#topic+select">tidyselect</a> notation)</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_keep_model_terms">keep_model_terms</code></td>
<td>
<p>keep original model terms for variables where
pairwise contrasts are added? (default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_pairwise_reverse">pairwise_reverse</code></td>
<td>
<p>determines whether to use <code>"pairwise"</code> (if <code>TRUE</code>)
or <code>"revpairwise"</code> (if <code>FALSE</code>), see <code><a href="emmeans.html#topic+contrast">emmeans::contrast()</a></code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_emmeans_args">emmeans_args</code></td>
<td>
<p>list of additional parameter to pass to
<code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code> when computing pairwise contrasts</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_significance">significance</code></td>
<td>
<p>level (between 0 and 1) below which a
coefficient is consider to be significantly different from 0
(or 1 if <code>exponentiate = TRUE</code>), <code>NULL</code> for not highlighting
such coefficients</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_significance_labels">significance_labels</code></td>
<td>
<p>optional vector with custom labels
for significance variable</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_show_p_values">show_p_values</code></td>
<td>
<p>if <code>TRUE</code>, add p-value to labels</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_signif_stars">signif_stars</code></td>
<td>
<p>if <code>TRUE</code>, add significant stars to labels</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_return_data">return_data</code></td>
<td>
<p>if <code>TRUE</code>, will return the data.frame used
for plotting instead of the plot</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="#topic+ggcoef_plot">ggcoef_plot()</a></code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_table_stat">table_stat</code></td>
<td>
<p>statistics to display in the table, use any column name
returned by the tidier or <code>"ci"</code> for confidence intervals formatted
according to <code>ci_pattern</code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_table_header">table_header</code></td>
<td>
<p>optional custom headers for the table</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_table_text_size">table_text_size</code></td>
<td>
<p>text size for the table</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_table_stat_label">table_stat_label</code></td>
<td>
<p>optional named list of labeller functions for the
displayed statistic (see examples)</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_ci_pattern">ci_pattern</code></td>
<td>
<p>glue pattern for confidence intervals in the table</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_table_witdhs">table_witdhs</code></td>
<td>
<p>relative widths of the forest plot and the coefficients
table</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_plot_title">plot_title</code></td>
<td>
<p>an optional plot title</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_models">models</code></td>
<td>
<p>named list of models</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_type">type</code></td>
<td>
<p>a dodged plot, a faceted plot or multiple table plots?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_y.level_label">y.level_label</code></td>
<td>
<p>an optional named vector for labeling <code>y.level</code>
(see examples)</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_component_col">component_col</code></td>
<td>
<p>name of the component column</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_component_label">component_label</code></td>
<td>
<p>an optional named vector for labeling components</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_data">data</code></td>
<td>
<p>a data frame containing data to be plotted,
typically the output of <code>ggcoef_model()</code>, <code>ggcoef_compare()</code>
or <code>ggcoef_multinom()</code> with the option <code>return_data = TRUE</code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_x">x</code>, <code id="ggcoef_model_+3A_y">y</code></td>
<td>
<p>variables mapped to x and y axis</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_point_size">point_size</code></td>
<td>
<p>size of the points</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_point_stroke">point_stroke</code></td>
<td>
<p>thickness of the points</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_point_fill">point_fill</code></td>
<td>
<p>fill colour for the points</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_colour">colour</code></td>
<td>
<p>optional variable name to be mapped to
colour aesthetic</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_colour_guide">colour_guide</code></td>
<td>
<p>should colour guide be displayed
in the legend?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_colour_lab">colour_lab</code></td>
<td>
<p>label of the colour aesthetic in the legend</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_colour_labels">colour_labels</code></td>
<td>
<p>labels argument passed to
<code><a href="ggplot2.html#topic+scale_colour_discrete">ggplot2::scale_colour_discrete()</a></code> and
<code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_shape">shape</code></td>
<td>
<p>optional variable name to be mapped to the
shape aesthetic</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_shape_values">shape_values</code></td>
<td>
<p>values of the different shapes to use in
<code><a href="ggplot2.html#topic+scale_manual">ggplot2::scale_shape_manual()</a></code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_shape_guide">shape_guide</code></td>
<td>
<p>should shape guide be displayed in the legend?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_shape_lab">shape_lab</code></td>
<td>
<p>label of the shape aesthetic in the legend</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_errorbar">errorbar</code></td>
<td>
<p>should error bars be plotted?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_errorbar_height">errorbar_height</code></td>
<td>
<p>height of error bars</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_errorbar_coloured">errorbar_coloured</code></td>
<td>
<p>should error bars be colored as the points?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_stripped_rows">stripped_rows</code></td>
<td>
<p>should stripped rows be displayed in the background?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_strips_odd">strips_odd</code></td>
<td>
<p>color of the odd rows</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_strips_even">strips_even</code></td>
<td>
<p>color of the even rows</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_vline">vline</code></td>
<td>
<p>should a vertical line be drawn at 0 (or 1 if
<code>exponentiate = TRUE</code>)?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_vline_colour">vline_colour</code></td>
<td>
<p>colour of vertical line</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_dodged">dodged</code></td>
<td>
<p>should points be dodged (according to the colour aesthetic)?</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_dodged_width">dodged_width</code></td>
<td>
<p>width value for <code><a href="ggplot2.html#topic+position_dodge">ggplot2::position_dodge()</a></code></p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_facet_row">facet_row</code></td>
<td>
<p>variable name to be used for row facets</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_facet_col">facet_col</code></td>
<td>
<p>optional variable name to be used for column facets</p>
</td></tr>
<tr><td><code id="ggcoef_model_+3A_facet_labeller">facet_labeller</code></td>
<td>
<p>labeller function to be used for labeling facets;
if labels are too long, you can use <code><a href="ggplot2.html#topic+labellers">ggplot2::label_wrap_gen()</a></code> (see
examples), more information in the documentation of <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more control, you can use the argument <code>return_data = TRUE</code> to
get the produced <code>tibble</code>, apply any transformation of your own and
then pass your customized <code>tibble</code> to <code>ggcoef_plot()</code>.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot or a <code>tibble</code> if <code>return_data = TRUE</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>ggcoef_table()</code>: a variation of <code><a href="#topic+ggcoef_model">ggcoef_model()</a></code> adding a table
with estimates, confidence intervals and p-values
</p>
</li>
<li> <p><code>ggcoef_compare()</code>: designed for displaying several models on the same
plot.
</p>
</li>
<li> <p><code>ggcoef_multinom()</code>: a variation of <code><a href="#topic+ggcoef_model">ggcoef_model()</a></code> adapted to
multinomial logistic regressions performed with <code><a href="nnet.html#topic+multinom">nnet::multinom()</a></code>.
</p>
</li>
<li> <p><code>ggcoef_multicomponents()</code>: a variation of <code><a href="#topic+ggcoef_model">ggcoef_model()</a></code> adapted to
multi-component models such as zero-inflated models or beta regressions.
<code><a href="#topic+ggcoef_multicomponents">ggcoef_multicomponents()</a></code> has been tested with <code>pscl::zeroinfl()</code>,
<code>pscl::hurdle()</code> and <code>betareg::betareg()</code>
</p>
</li>
<li> <p><code>ggcoef_plot()</code>: plot a tidy <code>tibble</code> of coefficients
</p>
</li></ul>


<h3>See Also</h3>

<p><code>vignette("ggcoef_model")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(Sepal.Length ~ Sepal.Width + Species, data = iris)
ggcoef_model(mod)

ggcoef_table(mod)



ggcoef_table(mod, table_stat = c("estimate", "ci"))

ggcoef_table(
  mod,
  table_stat_label = list(
    estimate = scales::label_number(.001)
  )
)

ggcoef_table(mod, table_text_size = 5, table_witdhs = c(1, 1))

# a logistic regression example
d_titanic &lt;- as.data.frame(Titanic)
d_titanic$Survived &lt;- factor(d_titanic$Survived, c("No", "Yes"))
mod_titanic &lt;- glm(
  Survived ~ Sex * Age + Class,
  weights = Freq,
  data = d_titanic,
  family = binomial
)

# use 'exponentiate = TRUE' to get the Odds Ratio
ggcoef_model(mod_titanic, exponentiate = TRUE)

ggcoef_table(mod_titanic, exponentiate = TRUE)

# display intercepts
ggcoef_model(mod_titanic, exponentiate = TRUE, intercept = TRUE)

# customize terms labels
ggcoef_model(
  mod_titanic,
  exponentiate = TRUE,
  show_p_values = FALSE,
  signif_stars = FALSE,
  add_reference_rows = FALSE,
  categorical_terms_pattern = "{level} (ref: {reference_level})",
  interaction_sep = " x "
) +
  ggplot2::scale_y_discrete(labels = scales::label_wrap(15))

# display only a subset of terms
ggcoef_model(mod_titanic, exponentiate = TRUE, include = c("Age", "Class"))

# do not change points' shape based on significance
ggcoef_model(mod_titanic, exponentiate = TRUE, significance = NULL)

# a black and white version
ggcoef_model(
  mod_titanic,
  exponentiate = TRUE,
  colour = NULL, stripped_rows = FALSE
)

# show dichotomous terms on one row
ggcoef_model(
  mod_titanic,
  exponentiate = TRUE,
  no_reference_row = broom.helpers::all_dichotomous(),
  categorical_terms_pattern =
    "{ifelse(dichotomous, paste0(level, ' / ', reference_level), level)}",
  show_p_values = FALSE
)




data(tips, package = "reshape")
mod_simple &lt;- lm(tip ~ day + time + total_bill, data = tips)
ggcoef_model(mod_simple)

# custom variable labels
# you can use the labelled package to define variable labels
# before computing model
if (requireNamespace("labelled")) {
  tips_labelled &lt;- tips %&gt;%
    labelled::set_variable_labels(
      day = "Day of the week",
      time = "Lunch or Dinner",
      total_bill = "Bill's total"
    )
  mod_labelled &lt;- lm(tip ~ day + time + total_bill, data = tips_labelled)
  ggcoef_model(mod_labelled)
}

# you can provide custom variable labels with 'variable_labels'
ggcoef_model(
  mod_simple,
  variable_labels = c(
    day = "Week day",
    time = "Time (lunch or dinner ?)",
    total_bill = "Total of the bill"
  )
)
# if labels are too long, you can use 'facet_labeller' to wrap them
ggcoef_model(
  mod_simple,
  variable_labels = c(
    day = "Week day",
    time = "Time (lunch or dinner ?)",
    total_bill = "Total of the bill"
  ),
  facet_labeller = ggplot2::label_wrap_gen(10)
)

# do not display variable facets but add colour guide
ggcoef_model(mod_simple, facet_row = NULL, colour_guide = TRUE)

# works also with with polynomial terms
mod_poly &lt;- lm(
  tip ~ poly(total_bill, 3) + day,
  data = tips,
)
ggcoef_model(mod_poly)

# or with different type of contrasts
# for sum contrasts, the value of the reference term is computed
if (requireNamespace("emmeans")) {
  mod2 &lt;- lm(
    tip ~ day + time + sex,
    data = tips,
    contrasts = list(time = contr.sum, day = contr.treatment(4, base = 3))
  )
  ggcoef_model(mod2)
}



# Use ggcoef_compare() for comparing several models on the same plot
mod1 &lt;- lm(Fertility ~ ., data = swiss)
mod2 &lt;- step(mod1, trace = 0)
mod3 &lt;- lm(Fertility ~ Agriculture + Education * Catholic, data = swiss)
models &lt;- list(
  "Full model" = mod1,
  "Simplified model" = mod2,
  "With interaction" = mod3
)

ggcoef_compare(models)
ggcoef_compare(models, type = "faceted")

# you can reverse the vertical position of the point by using a negative
# value for dodged_width (but it will produce some warnings)
ggcoef_compare(models, dodged_width = -.9)




# specific function for nnet::multinom models
mod &lt;- nnet::multinom(Species ~ ., data = iris)
ggcoef_multinom(mod, exponentiate = TRUE)
ggcoef_multinom(mod, type = "faceted")
ggcoef_multinom(
  mod,
  type = "faceted",
  y.level_label = c("versicolor" = "versicolor\n(ref: setosa)")
)




library(pscl)
data("bioChemists", package = "pscl")
mod &lt;- zeroinfl(art ~ fem * mar | fem + mar, data = bioChemists)
ggcoef_multicomponents(mod)

ggcoef_multicomponents(mod, type = "f")

ggcoef_multicomponents(mod, type = "t")

ggcoef_multicomponents(
  mod,
  type = "t",
  component_label = c(conditional = "Count", zero_inflated = "Zero-inflated")
)

mod2 &lt;- zeroinfl(art ~ fem + mar | 1, data = bioChemists)
ggcoef_multicomponents(mod2, type = "t")


</code></pre>

<hr>
<h2 id='gglikert'>Plotting Likert-type items</h2><span id='topic+gglikert'></span><span id='topic+gglikert_data'></span><span id='topic+gglikert_stacked'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gglikert(
  data,
  include = dplyr::everything(),
  weights = NULL,
  y = ".question",
  variable_labels = NULL,
  sort = c("none", "ascending", "descending"),
  sort_method = c("prop", "mean", "median"),
  sort_prop_include_center = totals_include_center,
  factor_to_sort = ".question",
  exclude_fill_values = NULL,
  data_fun = NULL,
  add_labels = TRUE,
  labels_size = 3.5,
  labels_color = "auto",
  labels_accuracy = 1,
  labels_hide_below = 0.05,
  add_totals = TRUE,
  totals_size = labels_size,
  totals_color = "black",
  totals_accuracy = labels_accuracy,
  totals_fontface = "bold",
  totals_include_center = FALSE,
  totals_hjust = 0.1,
  y_reverse = TRUE,
  y_label_wrap = 50,
  reverse_likert = FALSE,
  width = 0.9,
  facet_rows = NULL,
  facet_cols = NULL,
  facet_label_wrap = 50
)

gglikert_data(
  data,
  include = dplyr::everything(),
  weights = NULL,
  variable_labels = NULL,
  sort = c("none", "ascending", "descending"),
  sort_method = c("prop", "mean", "median"),
  sort_prop_include_center = TRUE,
  factor_to_sort = ".question",
  exclude_fill_values = NULL,
  data_fun = NULL
)

gglikert_stacked(
  data,
  include = dplyr::everything(),
  weights = NULL,
  y = ".question",
  variable_labels = NULL,
  sort = c("none", "ascending", "descending"),
  sort_method = c("prop", "mean", "median"),
  sort_prop_include_center = FALSE,
  factor_to_sort = ".question",
  data_fun = NULL,
  add_labels = TRUE,
  labels_size = 3.5,
  labels_color = "auto",
  labels_accuracy = 1,
  labels_hide_below = 0.05,
  add_median_line = FALSE,
  y_reverse = TRUE,
  y_label_wrap = 50,
  reverse_fill = TRUE,
  width = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gglikert_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="gglikert_+3A_include">include</code></td>
<td>
<p>variables to include, accepts <a href="dplyr.html#topic+select">tidy-select</a>
syntax</p>
</td></tr>
<tr><td><code id="gglikert_+3A_weights">weights</code></td>
<td>
<p>optional variable name of a weighting variable,
accepts <a href="dplyr.html#topic+select">tidy-select</a> syntax</p>
</td></tr>
<tr><td><code id="gglikert_+3A_y">y</code></td>
<td>
<p>name of the variable to be plotted on <code>y</code> axis (relevant when
<code>.question</code> is mapped to &quot;facets, see examples),
accepts <a href="dplyr.html#topic+select">tidy-select</a> syntax</p>
</td></tr>
<tr><td><code id="gglikert_+3A_variable_labels">variable_labels</code></td>
<td>
<p>a named list or a named vector of custom variable
labels</p>
</td></tr>
<tr><td><code id="gglikert_+3A_sort">sort</code></td>
<td>
<p>should the factor defined by <code>factor_to_sort</code> be sorted according
to the answers (see <code>sort_method</code>)? One of &quot;none&quot; (default), &quot;ascending&quot; or
&quot;descending&quot;</p>
</td></tr>
<tr><td><code id="gglikert_+3A_sort_method">sort_method</code></td>
<td>
<p>method used to sort the variables: <code>"prop"</code> sort according
to the proportion of answers higher than the centered level, <code>"mean"</code>
considers answer as a score and sort according to the mean score, <code>"median"</code>
used the median and the majority judgment rule for tie-breaking.</p>
</td></tr>
<tr><td><code id="gglikert_+3A_sort_prop_include_center">sort_prop_include_center</code></td>
<td>
<p>when sorting with <code>"prop"</code> and if the number
of levels is uneven, should half of the central level be taken into account
to compute the proportion?</p>
</td></tr>
<tr><td><code id="gglikert_+3A_factor_to_sort">factor_to_sort</code></td>
<td>
<p>name of the factor column to sort if <code>sort</code> is not
equal to <code>"none"</code>; by default the list of questions passed to <code>include</code>;
should be one factor column of the tibble returned by <code>gglikert_data()</code>;
accepts <a href="dplyr.html#topic+select">tidy-select</a> syntax</p>
</td></tr>
<tr><td><code id="gglikert_+3A_exclude_fill_values">exclude_fill_values</code></td>
<td>
<p>Vector of values that should not be displayed
(but still taken into account for computing proportions),
see <code><a href="#topic+position_likert">position_likert()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_data_fun">data_fun</code></td>
<td>
<p>for advanced usage, custom function to be applied to the
generated dataset at the end of <code>gglikert_data()</code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_add_labels">add_labels</code></td>
<td>
<p>should percentage labels be added to the plot?</p>
</td></tr>
<tr><td><code id="gglikert_+3A_labels_size">labels_size</code></td>
<td>
<p>size of the percentage labels</p>
</td></tr>
<tr><td><code id="gglikert_+3A_labels_color">labels_color</code></td>
<td>
<p>color of the percentage labels (<code>"auto"</code> to use
<code>hex_bw()</code> to determine a font color based on background color)</p>
</td></tr>
<tr><td><code id="gglikert_+3A_labels_accuracy">labels_accuracy</code></td>
<td>
<p>accuracy of the percentages, see
<code><a href="scales.html#topic+label_percent">scales::label_percent()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_labels_hide_below">labels_hide_below</code></td>
<td>
<p>if provided, values below will be masked, see
<code><a href="#topic+label_percent_abs">label_percent_abs()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_add_totals">add_totals</code></td>
<td>
<p>should the total proportions of negative and positive
answers be added to plot? <strong>This option is not compatible with facets!</strong></p>
</td></tr>
<tr><td><code id="gglikert_+3A_totals_size">totals_size</code></td>
<td>
<p>size of the total proportions</p>
</td></tr>
<tr><td><code id="gglikert_+3A_totals_color">totals_color</code></td>
<td>
<p>color of the total proportions</p>
</td></tr>
<tr><td><code id="gglikert_+3A_totals_accuracy">totals_accuracy</code></td>
<td>
<p>accuracy of the total proportions, see
<code><a href="scales.html#topic+label_percent">scales::label_percent()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_totals_fontface">totals_fontface</code></td>
<td>
<p>font face of the total proportions</p>
</td></tr>
<tr><td><code id="gglikert_+3A_totals_include_center">totals_include_center</code></td>
<td>
<p>if the number of levels is uneven, should half
of the center level be added to the total proportions?</p>
</td></tr>
<tr><td><code id="gglikert_+3A_totals_hjust">totals_hjust</code></td>
<td>
<p>horizontal adjustment of totals labels on the x axis</p>
</td></tr>
<tr><td><code id="gglikert_+3A_y_reverse">y_reverse</code></td>
<td>
<p>should the y axis be reversed?</p>
</td></tr>
<tr><td><code id="gglikert_+3A_y_label_wrap">y_label_wrap</code></td>
<td>
<p>number of characters per line for y axis labels, see
<code><a href="scales.html#topic+label_wrap">scales::label_wrap()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_reverse_likert">reverse_likert</code></td>
<td>
<p>if <code>TRUE</code>, will reverse the default stacking order,
see <code><a href="#topic+position_likert">position_likert()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_width">width</code></td>
<td>
<p>bar width, see <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_facet_rows">facet_rows</code>, <code id="gglikert_+3A_facet_cols">facet_cols</code></td>
<td>
<p>A set of variables or expressions quoted by
<code><a href="ggplot2.html#topic+vars">ggplot2::vars()</a></code> and defining faceting groups on the rows or columns
dimension (see examples)</p>
</td></tr>
<tr><td><code id="gglikert_+3A_facet_label_wrap">facet_label_wrap</code></td>
<td>
<p>number of characters per line for facet labels, see
<code><a href="ggplot2.html#topic+labellers">ggplot2::label_wrap_gen()</a></code></p>
</td></tr>
<tr><td><code id="gglikert_+3A_add_median_line">add_median_line</code></td>
<td>
<p>add a vertical line at 50%?</p>
</td></tr>
<tr><td><code id="gglikert_+3A_reverse_fill">reverse_fill</code></td>
<td>
<p>if <code>TRUE</code>, will reverse the default stacking order,
see <code><a href="ggplot2.html#topic+position_stack">ggplot2::position_fill()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Combines several factor variables using the same list of ordered levels
(e.g. Likert-type scales) into a unique data frame and generates a centered
bar plot.
</p>
<p>You could use <code>gglikert_data()</code> to just produce the dataset to be plotted.
</p>
<p>If variable labels have been defined (see <code><a href="labelled.html#topic+var_label">labelled::var_label()</a></code>), they will
be considered. You can also pass custom variables labels with the
<code>variable_labels</code> argument.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot or a <code>tibble</code>.
</p>


<h3>See Also</h3>

<p><code>vignette("gglikert")</code>, <code><a href="#topic+position_likert">position_likert()</a></code>, <code><a href="#topic+stat_prop">stat_prop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(dplyr)

likert_levels &lt;- c(
  "Strongly disagree",
  "Disagree",
  "Neither agree nor disagree",
  "Agree",
  "Strongly agree"
)
set.seed(42)
df &lt;-
  tibble(
    q1 = sample(likert_levels, 150, replace = TRUE),
    q2 = sample(likert_levels, 150, replace = TRUE, prob = 5:1),
    q3 = sample(likert_levels, 150, replace = TRUE, prob = 1:5),
    q4 = sample(likert_levels, 150, replace = TRUE, prob = 1:5),
    q5 = sample(c(likert_levels, NA), 150, replace = TRUE),
    q6 = sample(likert_levels, 150, replace = TRUE, prob = c(1, 0, 1, 1, 0))
  ) %&gt;%
  mutate(across(everything(), ~ factor(.x, levels = likert_levels)))

gglikert(df)

gglikert(df, include = q1:3)

gglikert(df, sort = "ascending")


gglikert(df, sort = "ascending", sort_prop_include_center = TRUE)

gglikert(df, sort = "ascending", sort_method = "mean")

gglikert(df, reverse_likert = TRUE)

gglikert(df, add_totals = FALSE, add_labels = FALSE)

gglikert(
  df,
  totals_include_center = TRUE,
  totals_hjust = .25,
  totals_size = 4.5,
  totals_fontface = "italic",
  totals_accuracy = .01,
  labels_accuracy = 1,
  labels_size = 2.5,
  labels_hide_below = .25
)

gglikert(df, exclude_fill_values = "Neither agree nor disagree")

if (require("labelled")) {
  df %&gt;%
    set_variable_labels(
      q1 = "First question",
      q2 = "Second question"
    ) %&gt;%
    gglikert(
      variable_labels = c(
        q4 = "a custom label",
        q6 = "a very very very very very very very very very very long label"
      ),
      y_label_wrap = 25
    )
}

# Facets
df_group &lt;- df
df_group$group &lt;- sample(c("A", "B"), 150, replace = TRUE)

gglikert(df_group, q1:q6, facet_rows = vars(group))

gglikert(df_group, q1:q6, facet_cols = vars(group))

gglikert(df_group, q1:q6, y = "group", facet_rows = vars(.question))

# Custom function to be applied on data
f &lt;- function(d) {
  d$.question &lt;- forcats::fct_relevel(d$.question, "q5", "q2")
  d
}
gglikert(df, include = q1:q6, data_fun = f)

gglikert_stacked(df, q1:q6)

gglikert_stacked(df, q1:q6, add_median_line = TRUE, sort = "asc")


gglikert_stacked(df_group, q1:q6, y = "group", add_median_line = TRUE) +
  facet_grid(rows = vars(.question))

</code></pre>

<hr>
<h2 id='ggsurvey'>Easy ggplot2 with survey objects</h2><span id='topic+ggsurvey'></span>

<h3>Description</h3>

<p>A function to facilitate <code>ggplot2</code> graphs using a survey object.
It will initiate a ggplot and map survey weights to the
corresponding aesthetic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggsurvey(design = NULL, mapping = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggsurvey_+3A_design">design</code></td>
<td>
<p>A survey design object, usually created with
<code><a href="survey.html#topic+svydesign">survey::svydesign()</a></code></p>
</td></tr>
<tr><td><code id="ggsurvey_+3A_mapping">mapping</code></td>
<td>
<p>Default list of aesthetic mappings to use for plot,
to be created with <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>.</p>
</td></tr>
<tr><td><code id="ggsurvey_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Graphs will be correct as long as only weights are required
to compute the graph. However, statistic or geometry requiring
correct variance computation (like <code><a href="ggplot2.html#topic+geom_smooth">ggplot2::geom_smooth()</a></code>) will
be statistically incorrect.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(api, package = "survey")
dstrat &lt;- survey::svydesign(
  id = ~1, strata = ~stype,
  weights = ~pw, data = apistrat,
  fpc = ~fpc
)
ggsurvey(dstrat) +
  ggplot2::aes(x = cnum, y = dnum) +
  ggplot2::geom_count()

d &lt;- as.data.frame(Titanic)
dw &lt;- survey::svydesign(ids = ~1, weights = ~Freq, data = d)
ggsurvey(dw) +
  ggplot2::aes(x = Class, fill = Survived) +
  ggplot2::geom_bar(position = "fill")

</code></pre>

<hr>
<h2 id='hex_bw'>Identify a suitable font color (black or white) given a background HEX color</h2><span id='topic+hex_bw'></span>

<h3>Description</h3>

<p>Identify a suitable font color (black or white) given a background HEX color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hex_bw(hex_code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hex_bw_+3A_hex_code">hex_code</code></td>
<td>
<p>Background color in hex-format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either black or white, in hex-format
</p>


<h3>Source</h3>

<p>Adapted from <code>saros</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hex_bw("#0dadfd")
</code></pre>

<hr>
<h2 id='label_number_abs'>Label absolute values</h2><span id='topic+label_number_abs'></span><span id='topic+label_percent_abs'></span>

<h3>Description</h3>

<p>Label absolute values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_number_abs(..., hide_below = NULL)

label_percent_abs(..., hide_below = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label_number_abs_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="scales.html#topic+label_number">scales::label_number()</a></code> or
<code><a href="scales.html#topic+label_percent">scales::label_percent()</a></code></p>
</td></tr>
<tr><td><code id="label_number_abs_+3A_hide_below">hide_below</code></td>
<td>
<p>if provided, values below <code>hide_below</code> will be masked
(i.e. an empty string <code>""</code> will be returned)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;labelling&quot; function, , i.e. a function that takes a vector and
returns a character vector of same length giving a label for each input
value.
</p>


<h3>See Also</h3>

<p><code><a href="scales.html#topic+label_number">scales::label_number()</a></code>, <code><a href="scales.html#topic+label_percent">scales::label_percent()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(-0.2, -.05, 0, .07, .25, .66)

scales::label_number()(x)
label_number_abs()(x)

scales::label_percent()(x)
label_percent_abs()(x)
label_percent_abs(hide_below = .1)(x)
</code></pre>

<hr>
<h2 id='position_likert'>Stack objects on top of each another and center them around 0</h2><span id='topic+position_likert'></span><span id='topic+position_likert_count'></span><span id='topic+PositionLikert'></span><span id='topic+PositionLikertCount'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_likert(vjust = 1, reverse = FALSE, exclude_fill_values = NULL)

position_likert_count(vjust = 1, reverse = FALSE, exclude_fill_values = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_likert_+3A_vjust">vjust</code></td>
<td>
<p>Vertical adjustment for geoms that have a position
(like points or lines), not a dimension (like bars or areas). Set to
<code>0</code> to align with the bottom, <code>0.5</code> for the middle,
and <code>1</code> (the default) for the top.</p>
</td></tr>
<tr><td><code id="position_likert_+3A_reverse">reverse</code></td>
<td>
<p>If <code>TRUE</code>, will reverse the default stacking order.
This is useful if you're rotating both the plot and legend.</p>
</td></tr>
<tr><td><code id="position_likert_+3A_exclude_fill_values">exclude_fill_values</code></td>
<td>
<p>Vector of values from the variable associated with
the <code>fill</code> aesthetic that should not be displayed (but still taken into
account for computing proportions)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>position_likert()</code> stacks proportion bars on top of each other and
center them around zero (the same number of modalities are displayed on
each side). This type of presentation is commonly used to display
Likert-type scales.
<code>position_likert_count()</code> uses counts instead of proportions.
</p>
<p>It is recommended to use <code>position_likert()</code> with <code>stat_prop()</code>
and its <code>complete</code> argument (see examples).
</p>


<h3>See Also</h3>

<p>See <code><a href="ggplot2.html#topic+position_stack">ggplot2::position_stack()</a></code> and <code><a href="ggplot2.html#topic+position_stack">ggplot2::position_fill()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "fill") +
  scale_x_continuous(label = scales::label_percent()) +
  scale_fill_brewer(palette = "PiYG") +
  xlab("proportion")

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "likert") +
  scale_x_continuous(label = label_percent_abs()) +
  scale_fill_brewer(palette = "PiYG") +
  xlab("proportion")

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "stack") +
  scale_fill_brewer(palette = "PiYG")

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "likert_count") +
  scale_x_continuous(label = label_number_abs()) +
  scale_fill_brewer(palette = "PiYG")


# Reverse order -------------------------------------------------------------

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = position_likert(reverse = TRUE)) +
  scale_x_continuous(label = label_percent_abs()) +
  scale_fill_brewer(palette = "PiYG", direction = -1) +
  xlab("proportion")

# Missing items -------------------------------------------------------------
# example with a level not being observed for a specific value of y
d &lt;- diamonds
d &lt;- d[!(d$cut == "Premium" &amp; d$clarity == "I1"), ]
d &lt;- d[!(d$cut %in% c("Fair", "Good") &amp; d$clarity == "SI2"), ]

# by default, the two lowest bar are not properly centered
ggplot(d) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "likert") +
  scale_fill_brewer(palette = "PiYG")

# use stat_prop() with `complete = "fill"` to fix it
ggplot(d) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "likert", stat = "prop", complete = "fill") +
  scale_fill_brewer(palette = "PiYG")

# Add labels ----------------------------------------------------------------

custom_label &lt;- function(x) {
  p &lt;- scales::percent(x, accuracy = 1)
  p[x &lt; .075] &lt;- ""
  p
}

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = "likert") +
  geom_text(
    aes(by = clarity, label = custom_label(after_stat(prop))),
    stat = "prop",
    position = position_likert(vjust = .5)
  ) +
  scale_x_continuous(label = label_percent_abs()) +
  scale_fill_brewer(palette = "PiYG", direction = -1) +
  xlab("proportion")

# Do not display specific fill values ---------------------------------------
# (but taken into account to compute proportions)

ggplot(diamonds) +
  aes(y = clarity, fill = cut) +
  geom_bar(position = position_likert(exclude_fill_values = "Very Good")) +
  scale_x_continuous(label = label_percent_abs()) +
  scale_fill_brewer(palette = "PiYG") +
  xlab("proportion")

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='round_any'>Round to multiple of any number.</h2><span id='topic+round_any'></span>

<h3>Description</h3>

<p>Round to multiple of any number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_any(x, accuracy, f = round)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_any_+3A_x">x</code></td>
<td>
<p>numeric or date-time (POSIXct) vector to round</p>
</td></tr>
<tr><td><code id="round_any_+3A_accuracy">accuracy</code></td>
<td>
<p>number to round to; for POSIXct objects, a number of seconds</p>
</td></tr>
<tr><td><code id="round_any_+3A_f">f</code></td>
<td>
<p>rounding function: <code><a href="base.html#topic+floor">floor</a></code>, <code><a href="base.html#topic+ceiling">ceiling</a></code> or
<code><a href="base.html#topic+round">round</a></code></p>
</td></tr>
</table>


<h3>Source</h3>

<p>adapted from <code>plyr</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>round_any(1.865, accuracy = .25)
</code></pre>

<hr>
<h2 id='signif_stars'>Significance Stars</h2><span id='topic+signif_stars'></span>

<h3>Description</h3>

<p>Calculate significance stars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signif_stars(x, three = 0.001, two = 0.01, one = 0.05, point = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signif_stars_+3A_x">x</code></td>
<td>
<p>numeric values that will be compared to the <code>point</code>,
<code>one</code>, <code>two</code>, and <code>three</code> values</p>
</td></tr>
<tr><td><code id="signif_stars_+3A_three">three</code></td>
<td>
<p>threshold below which to display three stars</p>
</td></tr>
<tr><td><code id="signif_stars_+3A_two">two</code></td>
<td>
<p>threshold below which to display two stars</p>
</td></tr>
<tr><td><code id="signif_stars_+3A_one">one</code></td>
<td>
<p>threshold below which to display one star</p>
</td></tr>
<tr><td><code id="signif_stars_+3A_point">point</code></td>
<td>
<p>threshold below which to display one point
(<code>NULL</code> to deactivate)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector containing the appropriate number of
stars for each <code>x</code> value.
</p>


<h3>Author(s)</h3>

<p>Joseph Larmarange
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0.5, 0.1, 0.05, 0.01, 0.001)
signif_stars(x)
signif_stars(x, one = .15, point = NULL)
</code></pre>

<hr>
<h2 id='stat_cross'>Compute cross-tabulation statistics</h2><span id='topic+stat_cross'></span><span id='topic+StatCross'></span>

<h3>Description</h3>

<p>Computes statistics of a 2-dimensional matrix using <a href="broom.html#topic+augment.htest">broom::augment.htest</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_cross(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE,
  keep.zero.cells = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_cross_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_geom">geom</code></td>
<td>
<p>Override the default connection with
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, the default, missing values are
removed with a warning.
If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_cross_+3A_keep.zero.cells">keep.zero.cells</code></td>
<td>
<p>If <code>TRUE</code>, cells with no observations are kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot with the added statistic.
</p>


<h3>Aesthetics</h3>

<p><code>stat_cross()</code> requires the <strong>x</strong> and the <strong>y</strong> aesthetics.
</p>


<h3>Computed variables</h3>


<dl>
<dt>observed</dt><dd><p>number of observations in x,y</p>
</dd>
<dt>prop</dt><dd><p>proportion of total</p>
</dd>
<dt>row.prop</dt><dd><p>row proportion</p>
</dd>
<dt>col.prop</dt><dd><p>column proportion</p>
</dd>
<dt>expected</dt><dd><p>expected count under the null hypothesis</p>
</dd>
<dt>resid</dt><dd><p>Pearson's residual</p>
</dd>
<dt>std.resid</dt><dd><p>standardized residual</p>
</dd>
<dt>row.observed</dt><dd><p>total number of observations within row</p>
</dd>
<dt>col.observed</dt><dd><p>total number of observations within column</p>
</dd>
<dt>total.observed</dt><dd><p>total number of observations within the table</p>
</dd>
<dt>phi</dt><dd><p>phi coefficients, see <code><a href="#topic+augment_chisq_add_phi">augment_chisq_add_phi()</a></code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code>vignette("stat_cross")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
d &lt;- as.data.frame(Titanic)

# plot number of observations
ggplot(d) +
  aes(x = Class, y = Survived, weight = Freq, size = after_stat(observed)) +
  stat_cross() +
  scale_size_area(max_size = 20)

# custom shape and fill colour based on chi-squared residuals
ggplot(d) +
  aes(
    x = Class, y = Survived, weight = Freq,
    size = after_stat(observed), fill = after_stat(std.resid)
  ) +
  stat_cross(shape = 22) +
  scale_fill_steps2(breaks = c(-3, -2, 2, 3), show.limits = TRUE) +
  scale_size_area(max_size = 20)


# custom shape and fill colour based on phi coeffients
ggplot(d) +
  aes(
    x = Class, y = Survived, weight = Freq,
    size = after_stat(observed), fill = after_stat(phi)
  ) +
  stat_cross(shape = 22) +
  scale_fill_steps2(show.limits = TRUE) +
  scale_size_area(max_size = 20)


# plotting the number of observations as a table
ggplot(d) +
  aes(
    x = Class, y = Survived, weight = Freq, label = after_stat(observed)
  ) +
  geom_text(stat = "cross")

# Row proportions with standardized residuals
ggplot(d) +
  aes(
    x = Class, y = Survived, weight = Freq,
    label = scales::percent(after_stat(row.prop)),
    size = NULL, fill = after_stat(std.resid)
  ) +
  stat_cross(shape = 22, size = 30) +
  geom_text(stat = "cross") +
  scale_fill_steps2(breaks = c(-3, -2, 2, 3), show.limits = TRUE) +
  facet_grid(Sex ~ .) +
  labs(fill = "Standardized residuals") +
  theme_minimal()

</code></pre>

<hr>
<h2 id='stat_prop'>Compute proportions according to custom denominator</h2><span id='topic+stat_prop'></span><span id='topic+StatProp'></span>

<h3>Description</h3>

<p><code>stat_prop()</code> is a variation of <code><a href="ggplot2.html#topic+geom_bar">ggplot2::stat_count()</a></code> allowing to
compute custom proportions according to the <strong>by</strong> aesthetic defining
the denominator (i.e. all proportions for a same value of <strong>by</strong> will
sum to 1). The <strong>by</strong> aesthetic should be a factor. If <strong>by</strong> is not
specified, proportions of the total will be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_prop(
  mapping = NULL,
  data = NULL,
  geom = "bar",
  position = "fill",
  ...,
  width = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  complete = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_prop_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_geom">geom</code></td>
<td>
<p>Override the default connection with <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_width">width</code></td>
<td>
<p>Bar width. By default, set to 90% of the <code><a href="ggplot2.html#topic+resolution">resolution()</a></code> of the
data.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_prop_+3A_complete">complete</code></td>
<td>
<p>Name (character) of an aesthetic for those statistics should
be completed for unobserved values (see example)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot with the added statistic.
</p>


<h3>Aesthetics</h3>

<p><code>stat_prop()</code> understands the following aesthetics
(required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x <em>or</em> y</strong>
</p>
</li>
<li><p> by (this aesthetic should be a <strong>factor</strong>)
</p>
</li>
<li><p> group
</p>
</li>
<li><p> weight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>count</dt><dd><p>number of points in bin</p>
</dd>
<dt>prop</dt><dd><p>computed proportion</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code>vignette("stat_prop")</code>, <code><a href="ggplot2.html#topic+geom_bar">ggplot2::stat_count()</a></code>. For an alternative
approach, see
<a href="https://github.com/tidyverse/ggplot2/issues/5505#issuecomment-1791324008">https://github.com/tidyverse/ggplot2/issues/5505#issuecomment-1791324008</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
d &lt;- as.data.frame(Titanic)

p &lt;- ggplot(d) +
  aes(x = Class, fill = Survived, weight = Freq, by = Class) +
  geom_bar(position = "fill") +
  geom_text(stat = "prop", position = position_fill(.5))
p
p + facet_grid(~Sex)

ggplot(d) +
  aes(x = Class, fill = Survived, weight = Freq) +
  geom_bar(position = "dodge") +
  geom_text(
    aes(by = Survived),
    stat = "prop",
    position = position_dodge(0.9), vjust = "bottom"
  )

if (requireNamespace("scales")) {
  ggplot(d) +
    aes(x = Class, fill = Survived, weight = Freq, by = 1) +
    geom_bar() +
    geom_text(
      aes(label = scales::percent(after_stat(prop), accuracy = 1)),
      stat = "prop",
      position = position_stack(.5)
    )
}

# displaying unobserved levels with complete
d &lt;- diamonds %&gt;%
  dplyr::filter(!(cut == "Ideal" &amp; clarity == "I1")) %&gt;%
  dplyr::filter(!(cut == "Very Good" &amp; clarity == "VS2")) %&gt;%
  dplyr::filter(!(cut == "Premium" &amp; clarity == "IF"))
p &lt;- ggplot(d) +
  aes(x = clarity, fill = cut, by = clarity) +
  geom_bar(position = "fill")
p + geom_text(stat = "prop", position = position_fill(.5))
p + geom_text(stat = "prop", position = position_fill(.5), complete = "fill")

</code></pre>

<hr>
<h2 id='stat_weighted_mean'>Compute weighted y mean</h2><span id='topic+stat_weighted_mean'></span><span id='topic+StatWeightedMean'></span>

<h3>Description</h3>

<p>This statistic will compute the mean of <strong>y</strong> aesthetic for
each unique value of <strong>x</strong>, taking into account <strong>weight</strong>
aesthetic if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_weighted_mean(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_weighted_mean_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_geom">geom</code></td>
<td>
<p>Override the default connection with <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_weighted_mean_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot with the added statistic.
</p>


<h3>Computed variables</h3>


<dl>
<dt>y</dt><dd><p>weighted y (numerator / denominator)</p>
</dd>
<dt>numerator</dt><dd><p>numerator</p>
</dd>
<dt>denominator</dt><dd><p>denominator</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code>vignette("stat_weighted_mean")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ggplot2)

data(tips, package = "reshape")

ggplot(tips) +
  aes(x = day, y = total_bill) +
  geom_point()

ggplot(tips) +
  aes(x = day, y = total_bill) +
  stat_weighted_mean()


ggplot(tips) +
  aes(x = day, y = total_bill, group = 1) +
  stat_weighted_mean(geom = "line")

ggplot(tips) +
  aes(x = day, y = total_bill, colour = sex, group = sex) +
  stat_weighted_mean(geom = "line")

ggplot(tips) +
  aes(x = day, y = total_bill, fill = sex) +
  stat_weighted_mean(geom = "bar", position = "dodge")

# computing a proportion on the fly
if (requireNamespace("scales")) {
  ggplot(tips) +
    aes(x = day, y = as.integer(smoker == "Yes"), fill = sex) +
    stat_weighted_mean(geom = "bar", position = "dodge") +
    scale_y_continuous(labels = scales::percent)
}

library(ggplot2)

# taking into account some weights
if (requireNamespace("scales")) {
  d &lt;- as.data.frame(Titanic)
  ggplot(d) +
    aes(
      x = Class, y = as.integer(Survived == "Yes"),
      weight = Freq, fill = Sex
    ) +
    geom_bar(stat = "weighted_mean", position = "dodge") +
    scale_y_continuous(labels = scales::percent) +
    labs(y = "Survived")
}
</code></pre>

<hr>
<h2 id='weighted.median'>Weighted Median and Quantiles</h2><span id='topic+weighted.median'></span><span id='topic+weighted.quantile'></span>

<h3>Description</h3>

<p>Compute the median or quantiles a set of numbers which have weights
associated with them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.median(x, w, na.rm = TRUE, type = 2)

weighted.quantile(x, w, probs = seq(0, 1, 0.25), na.rm = TRUE, type = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.median_+3A_x">x</code></td>
<td>
<p>a numeric vector of values</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_w">w</code></td>
<td>
<p>a numeric vector of weights</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether to ignore <code>NA</code> values</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_type">type</code></td>
<td>
<p>Integer specifying the rule for calculating the median or
quantile, corresponding to the rules available for <code>stats:quantile()</code>.
The only valid choices are type=1, 2 or 4. See Details.</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_probs">probs</code></td>
<td>
<p>probabilities for which the quantiles should be computed, a
numeric vector of values between 0 and 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>i</code>th observation <code>x[i]</code> is treated as having a weight proportional to
<code>w[i]</code>.
</p>
<p>The weighted median is a value <code>m</code> such that the total weight of data less
than or equal to <code>m</code> is equal to half the total weight. More generally, the
weighted quantile with probability <code>p</code> is a value <code>q</code> such that the total
weight of data less than or equal to <code>q</code> is equal to <code>p</code> times the total
weight.
</p>
<p>If there is no such value, then
</p>

<ul>
<li><p> if <code>type = 1</code>, the next largest value is returned (this is the
right-continuous inverse of the left-continuous cumulative distribution
function);
</p>
</li>
<li><p> if <code>type = 2</code>, the average of the two surrounding values is returned
(the average of the right-continuous and left-continuous inverses);
</p>
</li>
<li><p> if <code>type = 4</code>, linear interpolation is performed.
</p>
</li></ul>

<p>Note that the default rule for <code>weighted.median()</code> is <code>type = 2</code>, consistent
with the traditional definition of the median, while the default for
<code>weighted.quantile()</code> is <code>type = 4</code>.
</p>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Source</h3>

<p>These functions are adapted from their homonyms developed by Adrian
Baddeley in the <code>spatstat</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:20
w &lt;- runif(20)
weighted.median(x, w)
weighted.quantile(x, w)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
