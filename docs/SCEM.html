<!DOCTYPE html><html><head><title>Help for package SCEM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<script type="text/javascript" src="mathjax-config.js"></script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SCEM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#armenia'>
<p>Armenia dataset</p></a></li>
<li><a href='#calculateRSS'><p>Residual sum of squares (RSS) for all time series in a group.</p></a></li>
<li><a href='#convertParameters'><p>Parameter estimates from a nonlinear lest squares (NLS) fit.</p></a></li>
<li><a href='#EBIC'><p>Bayesian Information Criterion (BIC) for a partition.</p></a></li>
<li><a href='#EstTrend'><p>Estimates the trend function for a time series.</p></a></li>
<li><a href='#iteration'><p>Iteration step for the Splitting-Coalescence-Estimation Method (SCEM).</p></a></li>
<li><a href='#kernel'><p>Epanechnikov kernel</p></a></li>
<li><a href='#makeFits'><p>Prepare results for cosine model fit.</p></a></li>
<li><a href='#makeFits_initial'><p>Prepare results for cosine model fit with given initialization for two parameters.</p></a></li>
<li><a href='#makeFits_OLS'><p>Prepare results for cosine model fit with proposed initialization.</p></a></li>
<li><a href='#SCalgo'><p>Splitting-Coalescence (SC) algorithm.</p></a></li>
<li><a href='#SCEM'><p>Splitting-Coalescence-Estimation Method (SCEM) for archaeological time series.</p></a></li>
<li><a href='#sine_initial'><p>Cosine model fitting with given initialization for two parameters.</p></a></li>
<li><a href='#sine_OLS'><p>Cosine model fitting with proposed initialization.</p></a></li>
<li><a href='#sineFit'><p>Cosine model fitting</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Splitting-Coalescence-Estimation Method</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kyung Serk Cho &lt;kyslf1994@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>We introduce improved methods for statistically assessing birth seasonality and intra-annual variation. The first method we propose is a new idea that uses a nonparametric clustering procedure to group individuals with similar time series data and estimate birth seasonality based on the clusters. One can use the function SCEM() to implement this method. The second method estimates input parameters for use with a previously-developed parametric approach (Tornero et al., 2013). The relevant code for this approach is makeFits_OLS(), while makeFits_initial() is the code to implement the same method but with given initial conditions for two parameters. The latter can be used to show the disadvantage of the existing approach. One can use the function makeFits() to generate parametric birth seasonality estimates using either initialization. Detailed description can be found here: Chazin Hannah, Soudeep Deb, Joshua Falk, and Arun Srinivasan. (2019) "New Statistical Approaches to Intra-Individual Isotopic Analysis and Modeling Birth Seasonality in Studies of Herd Animals." &lt;<a href="https://doi.org/10.1111%2Farcm.12432">doi:10.1111/arcm.12432</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kserkcho/SCEM">https://github.com/kserkcho/SCEM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kserkcho/SCEM/issues">https://github.com/kserkcho/SCEM/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>devtools, stats, mathjaxr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-01 14:26:07 UTC; kyungcho</td>
</tr>
<tr>
<td>Author:</td>
<td>Hannah Chazin [aut],
  Soudeep Deb [aut],
  Joshua Falk [aut],
  Arun Srinivasan [aut],
  Kyung Serk Cho [cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-02 07:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='armenia'>
Armenia dataset
</h2><span id='topic+armenia'></span>

<h3>Description</h3>

<p>Archaeological faunal remains (24 sheep second molars) from Late Bronze Age (1500–1100 BCE) sites in the Tsaghkahovit Plain, Armenia
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("armenia")</code></pre>


<h3>Format</h3>

<p>A data frame with 223 observations on the following 4 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Subsample</code></dt><dd><p>a factor with levels <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code></p>
</dd>
<dt><code>distance</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>oxygen</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>H. Chazin, S. Deb, J Falk and A. SRINIVASAN
</p>


<h3>References</h3>

<p>Chazin, Hannah, Soudeep Deb, Joshua Falk, and Arun Srinivasan. 2019. “New Statistical Approaches to Intra-Individual Isotopic Analysis and Modeling Birth Seasonality in Studies of Herd Animals.” Archaeometry 61 (2): 478–93
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(armenia)
</code></pre>

<hr>
<h2 id='calculateRSS'>Residual sum of squares (RSS) for all time series in a group.</h2><span id='topic+calculateRSS'></span>

<h3>Description</h3>

<p>SCEM uses the residual sum of squares for each group to give a sense of the error in estimation. It is defined by:
</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
\[RSS(S_q) = \sum_{k \in S_q} \sum_{i = 1}^{n_k} ||y_{k,i} - \hat{\mu}_{S_q} \left(\frac{i}{n_k}\right) - \hat{c}_{k}||^2\]
<p>(See Chazin et al. 2019, Supplemental Materials 1).
</p>
<p>The trend function for each individual time series is estimated non-parametrically
by the local linear estimate (as discussed in Fan and Gijbels (1996)). Then, the common trend
function for the group is estimated by taking the average over the group. Next, the shift functions
are estimated as the differences from the individual trend functions and finally, the residual sum
of squares are calculated  using the original values, the common trend functions and the shifts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateRSS(paths, S, bandwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateRSS_+3A_paths">paths</code></td>
<td>
<p>A list of data frames, where each frame contains the data for one individual. Every
data frame should have two columns with names 'distance' and 'oxygen'.</p>
</td></tr>
<tr><td><code id="calculateRSS_+3A_s">S</code></td>
<td>
<p>A vector of integers showing which individuals are considered in the group.</p>
</td></tr>
<tr><td><code id="calculateRSS_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Denotes the order of the bandwidth that should be used in the estimation process.
bandwidth = k will mean that the bandwidth is n^k.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length equal to the group-size, so that each element is the RSS for the
corresponding individual in the group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>armenia_split = split(armenia,f = armenia$ID)
band = -0.33
p = length(armenia_split)
calculateRSS(armenia_split,1:p,band)
</code></pre>

<hr>
<h2 id='convertParameters'>Parameter estimates from a nonlinear lest squares (NLS) fit.</h2><span id='topic+convertParameters'></span>

<h3>Description</h3>

<p>This function converts the estimated parameters from the non-linear least squares (NLS) model fit to the appropriate parameter space corresponding to the cosine model proposed by Balasse et al (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertParameters(curve)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertParameters_+3A_curve">curve</code></td>
<td>
<p>A fitted model object from nls function. The fitted model should have the following
parameter estimates - amplitude, intercept, frequency, phase.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>amplitude</code></td>
<td>
<p>estimated amplitude</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>estimated intercept</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>delay of the data</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>period of the data</p>
</td></tr>
<tr><td><code>birth</code></td>
<td>
<p>birth seasonality estimate</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>armenia_split = split(armenia,f = armenia$ID)
curve = sineFit(armenia_split[[1]],method = "OLS")
convertParameters(curve)
</code></pre>

<hr>
<h2 id='EBIC'>Bayesian Information Criterion (BIC) for a partition.</h2><span id='topic+EBIC'></span>

<h3>Description</h3>

<p>This function calculates an extended version of BIC, which is computed using a particular weighted average of the total residual sum of squares and the number of clusters.
</p>
<p>SCEM uses the following equation for the BIC of each partition:
</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
\[BIC(P) = (np)\log \left\lbrace\frac{RSS(P)}{np}\right\rbrace + |P|(B_{n}^{-1}-1) \log(nB_{n}),\]
<p>where \(RSS(P) = \sum_{q=1}^{Q} RSS(S_q)\).
</p>
<p>The sample size of each individual time series (i.e. the number of observations) is denoted by <i>n</i>, but in dealing with archaeological data, not all the time series in a data set will have the same number of observations.
</p>
<p>In order to have a reasonable representative value for the sample size, we have chosen to use the natural arithmetic mean \(n=(n_1+\dots+n_p)/p\).
</p>
<p>\((B_{n}^{-1}-1)\log(nB_{n})\) is the tuning parameter that places the penalty on the number of clusters (also note that the term \(nB_{n}\)).
Using a different tuning parameter \(\gamma_{n}\) in place of \((B_{n}^{-1}-1)\log(nB_{n})\) allows stronger or weaker penalties on the number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EBIC(paths, partition, bandwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EBIC_+3A_paths">paths</code></td>
<td>
<p>A list of data frames, where each frame contains the data for one individual. Every
data frame should have two columns with names 'distance' and 'oxygen'.</p>
</td></tr>
<tr><td><code id="EBIC_+3A_partition">partition</code></td>
<td>
<p>A list of vectors. Each element in the list is a vector of integers, corresponding
to individuals considered in one group.</p>
</td></tr>
<tr><td><code id="EBIC_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Denotes the order of the bandwidth that should be used in the estimation process.
bandwidth = k will mean that the bandwidth is n^k.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the extended BIC function for the partition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>armenia_split = split(armenia,f = armenia$ID)
band = -0.33
p = length(armenia_split)
EBIC(armenia_split,1:p,band)
</code></pre>

<hr>
<h2 id='EstTrend'>Estimates the trend function for a time series.</h2><span id='topic+EstTrend'></span>

<h3>Description</h3>

<p>The trend function for each individual time series is estimated non-parametrically
by the local linear estimate (as discussed in Fan and Gijbels (1996)). Detailed description can
be found in Chazin et al. 2019, Supplemental Materials 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstTrend(y, time, bandwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstTrend_+3A_y">y</code></td>
<td>
<p>A vector of time series observations.</p>
</td></tr>
<tr><td><code id="EstTrend_+3A_time">time</code></td>
<td>
<p>A vector of time points where the value of the trend needs to be estimated.</p>
</td></tr>
<tr><td><code id="EstTrend_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Denotes the order of the bandwidth that should be used in the estimation process.
bandwidth = k will mean that the bandwidth is n^k.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of estimated values for the trend function at the given time-points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> armenia_split = split(armenia,f = armenia$ID)
 band = -0.33
 z = armenia_split[[1]]$oxygen
 n = length(z)
 ndx = (1:n)/n
 EstTrend(z,ndx,band)
</code></pre>

<hr>
<h2 id='iteration'>Iteration step for the Splitting-Coalescence-Estimation Method (SCEM).</h2><span id='topic+iteration'></span>

<h3>Description</h3>

<p>This function performs the iteration step. Detailed description can be found in Chazin et al. 2019, Supplemental Materials 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iteration(paths, U, bandwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iteration_+3A_paths">paths</code></td>
<td>
<p>A list of data frames, where each frame contains the data for one individual. Every
data frame should have two columns with names 'distance' and 'oxygen'.</p>
</td></tr>
<tr><td><code id="iteration_+3A_u">U</code></td>
<td>
<p>A list of vectors. Each element in the list is a vector of integers, corresponding
to individuals considered in one group.</p>
</td></tr>
<tr><td><code id="iteration_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Denotes the order of the bandwidth that should be used in the estimation process.
bandwidth = k will mean that the bandwidth is n^k.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>S1</code></td>
<td>
<p>A set of individuals who are in the cluster</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>A set of individuals to be used in the next iteration.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
armenia_split = split(armenia,f = armenia$ID)
band = -0.33
p = length(armenia_split)
iteration(armenia_split,1:p,band)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel'>Epanechnikov kernel</h2><span id='topic+kernel'></span>

<h3>Description</h3>

<p>Calculates the value of the Epanechnikov kernel function for any vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_+3A_v">v</code></td>
<td>
<p>A vector of real numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the calculated kernel values for the input vector.
</p>


<h3>References</h3>

<p>Epanechnikov, V. A. (1969). Non-parametric estimation of a multivariate probability density. Theory of Probability and its Applications, 14(1), 153-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = runif(10)
kernel(x)

</code></pre>

<hr>
<h2 id='makeFits'>Prepare results for cosine model fit.</h2><span id='topic+makeFits'></span>

<h3>Description</h3>

<p>This function performs the nonlinear least squares (NLS) regression method for the cosine model. It fits the NLS method as required, and then computes different quantities for the birth seasonality estimates corresponding to different individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFits(
  paths,
  amplitude = NULL,
  intercept = NULL,
  method = c("OLS", "initial")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFits_+3A_paths">paths</code></td>
<td>
<p>A list of data frames, where each frame contains the data for one individual. Every
data frame should have two columns with names 'distance' and 'oxygen'.</p>
</td></tr>
<tr><td><code id="makeFits_+3A_amplitude">amplitude</code></td>
<td>
<p>Initial value for the amplitude parameter for the <code>method="initial"</code> method.</p>
</td></tr>
<tr><td><code id="makeFits_+3A_intercept">intercept</code></td>
<td>
<p>Initial value for the intercept parameter for the <code>method="initial"</code> method.</p>
</td></tr>
<tr><td><code id="makeFits_+3A_method">method</code></td>
<td>
<p>A character string giving the initialization for the nonlinear least squares regression. This must be either <code>method="initial"</code> or <code>method="OLS"</code>. Default is <code>method="OLS"</code> method. <code>method="initial"</code> performs the nonlinear least squares (NLS) regression method for the cosine model without initializing parameter selections. It begins with the given initial values for amplitude and intercept. <code>method="OLS"</code> uses the least squares estimates (see Chazin et al. 2019) as the initial parameter selection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following components:
</p>
<table>
<tr><td><code>amplitude</code></td>
<td>
<p>estimated amplitude</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>estimated intercept</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>delay of the data</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>period of the data</p>
</td></tr>
<tr><td><code>birth</code></td>
<td>
<p>birth seasonality estimate</p>
</td></tr>
<tr><td><code>predictedMin</code></td>
<td>
<p>predicted minimum for the oxygen isotope variable</p>
</td></tr>
<tr><td><code>predictedMax</code></td>
<td>
<p>predicted maximum for the oxygen isotope variable</p>
</td></tr>
<tr><td><code>observedMin</code></td>
<td>
<p>observed minimum for the oxygen isotope variable</p>
</td></tr>
<tr><td><code>observedMax</code></td>
<td>
<p>observed minimum for the oxygen isotope variable</p>
</td></tr>
<tr><td><code>MSE</code></td>
<td>
<p>mean squared error corresponding to the model fit for every individual</p>
</td></tr>
<tr><td><code>Pearson</code></td>
<td>
<p>Pearson's R^2 corresponding to the model fit for every individual</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>armenia_split = split(armenia,f = armenia$ID)
amp = seq(1,10,by=0.5)
int = seq(-25,0,by=0.5)
makeFits(armenia_split,amp[1],int[1],method = "initial")
makeFits(armenia_split, method = "OLS")
</code></pre>

<hr>
<h2 id='makeFits_initial'>Prepare results for cosine model fit with given initialization for two parameters.</h2><span id='topic+makeFits_initial'></span>

<h3>Description</h3>

<p>Performs the nonlinear least squares (NLS) regression method for the cosine
model, with the given initial values for amplitude and intercept. It fits the NLS method
as required, and then computes different quantities for the birth seasonality estimates
corresponding to different individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFits_initial(paths, amplitude, intercept)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFits_initial_+3A_paths">paths</code></td>
<td>
<p>A list of data frames, where each frame contains the data for one individual. Every
data frame should have two columns with names 'distance' and 'oxygen'.</p>
</td></tr>
<tr><td><code id="makeFits_initial_+3A_amplitude">amplitude</code></td>
<td>
<p>Initial value for the amplitude parameter.</p>
</td></tr>
<tr><td><code id="makeFits_initial_+3A_intercept">intercept</code></td>
<td>
<p>Initial value for the intercept parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following components:
</p>
<table>
<tr><td><code>amplitude</code></td>
<td>
<p>estimated amplitude</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>estimated intercept</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>delay of the data</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>period of the data</p>
</td></tr>
<tr><td><code>birth</code></td>
<td>
<p>birth seasonality estimate</p>
</td></tr>
<tr><td><code>predictedMin</code></td>
<td>
<p>predicted minimum for the oxygen isotope variable</p>
</td></tr>
<tr><td><code>predictedMax</code></td>
<td>
<p>predicted maximum for the oxygen isotope variable</p>
</td></tr>
<tr><td><code>observedMin</code></td>
<td>
<p>observed minimum for the oxygen isotope variable</p>
</td></tr>
<tr><td><code>observedMax</code></td>
<td>
<p>observed minimum for the oxygen isotope variable</p>
</td></tr>
<tr><td><code>MSE</code></td>
<td>
<p>mean squared error corresponding to the model fit for every individual</p>
</td></tr>
<tr><td><code>Pearson</code></td>
<td>
<p>Pearson's R^2 corresponding to the model fit for every individual</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>armenia_split = split(armenia,f = armenia$ID)
amp = seq(1,10,by=0.5)
int = seq(-25,0,by=0.5)
makeFits_initial(armenia_split,amp[1],int[1])
</code></pre>

<hr>
<h2 id='makeFits_OLS'>Prepare results for cosine model fit with proposed initialization.</h2><span id='topic+makeFits_OLS'></span>

<h3>Description</h3>

<p>Performs the nonlinear least squares (NLS) regression method for the cosine
model, with the proposed initialization for all the parameters. It fits the NLS method
as required, and then computes different quantities for the birth seasonality estimates
corresponding to different individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFits_OLS(paths)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFits_OLS_+3A_paths">paths</code></td>
<td>
<p>A list of data frames, where each frame contains the data for one individual. Every
data frame should have two columns with names 'distance' and 'oxygen'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following components:
</p>
<table>
<tr><td><code>amplitude</code></td>
<td>
<p>estimated amplitude</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>estimated intercept</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>delay of the data</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>period of the data</p>
</td></tr>
<tr><td><code>birth</code></td>
<td>
<p>birth seasonality estimate</p>
</td></tr>
<tr><td><code>predictedMin</code></td>
<td>
<p>predicted minimum for the oxygen isotope variable</p>
</td></tr>
<tr><td><code>predictedMax</code></td>
<td>
<p>predicted maximum for the oxygen isotope variable</p>
</td></tr>
<tr><td><code>observedMin</code></td>
<td>
<p>observed minimum for the oxygen isotope variable</p>
</td></tr>
<tr><td><code>observedMax</code></td>
<td>
<p>observed minimum for the oxygen isotope variable</p>
</td></tr>
<tr><td><code>MSE</code></td>
<td>
<p>mean squared error corresponding to the model fit for every individual</p>
</td></tr>
<tr><td><code>Pearson</code></td>
<td>
<p>Pearson's R^2 corresponding to the model fit for every individual</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>armenia_split = split(armenia,f = armenia$ID)
makeFits_OLS(armenia_split)
</code></pre>

<hr>
<h2 id='SCalgo'>Splitting-Coalescence (SC) algorithm.</h2><span id='topic+SCalgo'></span>

<h3>Description</h3>

<p>This function performs the iterative clustering algorithm on the archaeological time series data. Detailed description can be found in Chazin et al. 2019, Supplemental Materials 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCalgo(paths, bandwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCalgo_+3A_paths">paths</code></td>
<td>
<p>A list of data frames, where each frame contains the data for one individual. There
should be two columns with names 'distance' and 'oxygen'.</p>
</td></tr>
<tr><td><code id="SCalgo_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Denotes the order of the bandwidth that should be used in the splitting-coalescence
(SC) clustering algorithm. A value k will mean that the bandwidth used in the algorithm is n^k.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors where each vector gives the indexes of the individuals to be assigned
in the same cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
armenia_split = split(armenia,f = armenia$ID)
band = -0.33
results = SCalgo(armenia_split,bandwidth = band)

## End(Not run)
</code></pre>

<hr>
<h2 id='SCEM'>Splitting-Coalescence-Estimation Method (SCEM) for archaeological time series.</h2><span id='topic+SCEM'></span>

<h3>Description</h3>

<p>This function performs the clustering algorithm SCEM on the bivariate time series data –
where one series is the distance from the cementum-enamel junction, and the other series is the value of
the oxygen-18 isotope at that distance. It returns the class assignments and birth seasonality estimates
for all the individuals.
</p>
<p>The SCEM assumes that the oxygen isotope values <i>(z(t))</i> can be expressed as a function of <i>x(t)</i>,
the natural logarithm of the distance from the CEJ for each of the incremental samples, scaled down by
the period (<i>X</i>, the length of the tooth crown). In other words,
</p>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
\[z(t) = f(x(t)/X) + e(t)\]
<p>where the form of <i>f</i> is unknown and <i>e(t)</i> is an error process.
Also, following our definition, it assumes that the value of <i>x(t)/X</i> that maximizes <i>z(t)</i> is the estimated birth seasonality.
</p>
<p>Birth seasonality is estimated using the combined data from all individuals in a single cluster,
but birth seasonality estimates for individuals in a cluster are based on individual estimates of the length of the tooth crown (\(X_{k}\)).
</p>
<p>For a detailed description of the algorithm, please see Chazin et al. 2019, Supplemental Materials 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCEM(paths, bandwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCEM_+3A_paths">paths</code></td>
<td>
<p>A list of data frames, where each frame contains the data for one individual. There
should be two columns with names 'distance' and 'oxygen'.</p>
</td></tr>
<tr><td><code id="SCEM_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Denotes the order of the bandwidth that should be used in the splitting-coalescence
(SC) clustering algorithm. A value k will mean that the bandwidth used in the algorithm is n^k.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>results</code></td>
<td>
<p>A data frame that has the individual information (ID, species, number of observations in the time series), cluster assignment, estimated period, delay and the birth seasonality estimate for every individual.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>The groups formed by the clustering algorithm</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chazin, Hannah, Soudeep Deb, Joshua Falk, and Arun Srinivasan. 2019. “New Statistical Approaches to Intra-Individual Isotopic Analysis and Modeling Birth Seasonality in Studies of Herd Animals.” Archaeometry 61 (2): 478–93.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
armenia_split = split(armenia,f = armenia$ID)
results = SCEM(armenia_split,bandwidth = -0.33)

## End(Not run)
</code></pre>

<hr>
<h2 id='sine_initial'>Cosine model fitting with given initialization for two parameters.</h2><span id='topic+sine_initial'></span>

<h3>Description</h3>

<p>Performs the updated nonlinear least squares (NLS) regression method for the cosine
model proposed by Balasse et al. The method calculates with the proposed initial values for ampliitude and intercept,
and then fits the NLS method as required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sine_initial(data, amplitude, intercept)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sine_initial_+3A_data">data</code></td>
<td>
<p>A data frame that contains the data for one individual. There should be two columns
with names 'distance' and 'oxygen'.</p>
</td></tr>
<tr><td><code id="sine_initial_+3A_amplitude">amplitude</code></td>
<td>
<p>Initial value for the amplitude parameter.</p>
</td></tr>
<tr><td><code id="sine_initial_+3A_intercept">intercept</code></td>
<td>
<p>Initial value for the intercept parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted model object from the nls function in R:
</p>
<table>
<tr><td><code>m</code></td>
<td>
<p>an 'nlsModel' object incorporating the model.</p>
</td></tr>
<tr><td><code>convInfo</code></td>
<td>
<p>a list with convergence information</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the expression that was passed to 'nls' as the data argument. The actual data values are present in the environment of the 'm' component.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call with several components, notably 'algorithm'</p>
</td></tr>
<tr><td><code>dataClasses</code></td>
<td>
<p>the '&quot;dataClasses&quot;' attribute (if any) of the '&quot;terms&quot;' attribute of the model frame.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the control 'list' used</p>
</td></tr>
</table>


<h3>References</h3>

<p>Florent Baty, Christian Ritz, Sandrine Charles, Martin Brutsche, Jean-Pierre Flandrois, Marie-Laure Delignette-Muller (2015). A Toolbox for Nonlinear Regression in R: The Package nlstools. Journal of Statistical Software, 66(5), 1-21. URL http://www.jstatsoft.org/v66/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>armenia_split = split(armenia,f = armenia$ID)
amp = seq(1,10,by=0.5)
int = seq(-25,0,by=0.5)
sine_initial(armenia_split[[2]],amp[3],int[4])
</code></pre>

<hr>
<h2 id='sine_OLS'>Cosine model fitting with proposed initialization.</h2><span id='topic+sine_OLS'></span>

<h3>Description</h3>

<p>Performs the updated nonlinear least squares (NLS) regression method for the cosine
model (see Chazin et al. 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sine_OLS(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sine_OLS_+3A_data">data</code></td>
<td>
<p>A data frame that contains the data for one individual. There should be two columns
with names 'distance' and 'oxygen'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted model object from the nls function in R:
</p>
<table>
<tr><td><code>m</code></td>
<td>
<p>an 'nlsModel' object incorporating the model.</p>
</td></tr>
<tr><td><code>convInfo</code></td>
<td>
<p>a list with convergence information</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the expression that was passed to 'nls' as the data argument. The actual data values are present in the environment of the 'm' component.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call with several components, notably 'algorithm'</p>
</td></tr>
<tr><td><code>dataClasses</code></td>
<td>
<p>the '&quot;dataClasses&quot;' attribute (if any) of the '&quot;terms&quot;' attribute of the model frame.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the control 'list' used</p>
</td></tr>
</table>


<h3>References</h3>

<p>Florent Baty, Christian Ritz, Sandrine Charles, Martin Brutsche, Jean-Pierre Flandrois, Marie-Laure Delignette-Muller (2015). A Toolbox for Nonlinear Regression in R: The Package nlstools. Journal of Statistical Software, 66(5), 1-21. URL http://www.jstatsoft.org/v66/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>armenia_split = split(armenia,f = armenia$ID)
sine_OLS(armenia_split[[1]])
</code></pre>

<hr>
<h2 id='sineFit'>Cosine model fitting</h2><span id='topic+sineFit'></span>

<h3>Description</h3>

<p>This function performs the updated nonlinear least squares (NLS) regression method for the cosine model (see Chazin et al. 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sineFit(data, amplitude = NULL, intercept = NULL, method = c("OLS", "initial"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sineFit_+3A_data">data</code></td>
<td>
<p>A data frame that contains the data for one individual. There should be two columns
with names 'distance' and 'oxygen'.</p>
</td></tr>
<tr><td><code id="sineFit_+3A_amplitude">amplitude</code></td>
<td>
<p>Initial value for the amplitude parameter for the <code>method="initial"</code> method.</p>
</td></tr>
<tr><td><code id="sineFit_+3A_intercept">intercept</code></td>
<td>
<p>Initial value for the intercept parameter for the <code>method="initial"</code> method.</p>
</td></tr>
<tr><td><code id="sineFit_+3A_method">method</code></td>
<td>
<p>A character string giving the initialization for the nonlinear least squares regression. This must be either <code>method="initial"</code> or <code>method="OLS"</code>. Default is <code>method="OLS"</code> method. <code>method="initial"</code> performs the nonlinear least squares (NLS) regression method for the cosine model without initializing parameter selections. It begins with the given initial values for amplitude and intercept. <code>method="OLS"</code> uses the least squares estimates (see Chazin et al. 2019) as the initial parameter selection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted model object from the nls function in R:
</p>
<table>
<tr><td><code>m</code></td>
<td>
<p>an 'nlsModel' object incorporating the model.</p>
</td></tr>
<tr><td><code>convInfo</code></td>
<td>
<p>a list with convergence information</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the expression that was passed to 'nls' as the data argument. The actual data values are present in the environment of the 'm' component.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call with several components, notably 'algorithm'</p>
</td></tr>
<tr><td><code>dataClasses</code></td>
<td>
<p>the '&quot;dataClasses&quot;' attribute (if any) of the '&quot;terms&quot;' attribute of the model frame.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the control 'list' used</p>
</td></tr>
</table>


<h3>References</h3>

<p>Florent Baty, Christian Ritz, Sandrine Charles, Martin Brutsche, Jean-Pierre Flandrois, Marie-Laure Delignette-Muller (2015). A Toolbox for Nonlinear Regression in R: The Package nlstools. Journal of Statistical Software, 66(5), 1-21. URL http://www.jstatsoft.org/v66/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>armenia_split = split(armenia,f = armenia$ID)
amp = seq(1,10,by=0.5)
int = seq(-25,0,by=0.5)
sineFit(armenia_split[[2]],amp[3],int[4],method = "initial")
sineFit(armenia_split[[1]],method = "OLS")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
