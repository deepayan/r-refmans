<!DOCTYPE html><html><head><title>Help for package imager</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {imager}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#imager'><p>imager: an R library for image processing, based on CImg</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#+25inr+25'><p>Check that value is in a range</p></a></li>
<li><a href='#add.colour'><p>Add colour channels to a grayscale image or pixel set</p></a></li>
<li><a href='#as.cimg'><p>Convert to cimg object</p></a></li>
<li><a href='#as.cimg.array'><p>Turn an numeric array into a cimg object</p></a></li>
<li><a href='#as.cimg.data.frame'><p>Create an image from a data.frame</p></a></li>
<li><a href='#as.cimg.function'><p>Create an image by sampling a function</p></a></li>
<li><a href='#as.cimg.im'><p>Convert an image in spatstat format to an image in cimg format</p></a></li>
<li><a href='#as.cimg.raster'><p>Convert a raster object to a cimg object</p></a></li>
<li><a href='#as.data.frame.cimg'><p>Convert a pixel image to a data.frame</p></a></li>
<li><a href='#as.data.frame.imlist'><p>Convert image list to data.frame</p></a></li>
<li><a href='#as.data.frame.pixset'><p>Methods to convert pixsets to various objects</p></a></li>
<li><a href='#as.igraph.cimg'><p>Form a graph from an image</p></a></li>
<li><a href='#as.igraph.pixset'><p>Form an adjacency graph from a pixset</p></a></li>
<li><a href='#as.imlist.list'><p>Convert various objects to image lists</p></a></li>
<li><a href='#as.pixset'><p>Methods to convert various objects to pixsets</p></a></li>
<li><a href='#as.raster.cimg'><p>Convert a cimg object to a raster object for plotting</p></a></li>
<li><a href='#at'><p>Return or set pixel value at coordinates</p></a></li>
<li><a href='#autocrop'><p>Autocrop image region</p></a></li>
<li><a href='#bbox'><p>Compute the bounding box of a pixset</p></a></li>
<li><a href='#blur_anisotropic'><p>Blur image anisotropically, in an edge-preserving way.</p></a></li>
<li><a href='#boats'><p>Photograph of sailing boats from Kodak set</p></a></li>
<li><a href='#boundary'><p>Find the boundary of a shape in a pixel set</p></a></li>
<li><a href='#boxblur'><p>Blur image with a box filter (square window)</p></a></li>
<li><a href='#boxblur_xy'><p>Blur image with a box filter.</p></a></li>
<li><a href='#bucketfill'><p>Bucket fill</p></a></li>
<li><a href='#cannyEdges'><p>Canny edge detector</p></a></li>
<li><a href='#capture.plot'><p>Capture the current R plot device as a cimg image</p></a></li>
<li><a href='#center.stencil'><p>Center stencil at a location</p></a></li>
<li><a href='#channels'><p>Split a colour image into a list of separate channels</p></a></li>
<li><a href='#ci'><p>Concatenation for image lists</p></a></li>
<li><a href='#cimg'><p>Create a cimg object</p></a></li>
<li><a href='#cimg.dimensions'><p>Image dimensions</p></a></li>
<li><a href='#cimg.extract'><p>Various shortcuts for extracting colour channels, frames, etc</p></a></li>
<li><a href='#cimg.openmp'><p>Control CImg's parallelisation</p></a></li>
<li><a href='#cimg2im'><p>Convert cimg to spatstat im object</p></a></li>
<li><a href='#circles'><p>Add circles to plot</p></a></li>
<li><a href='#clean'><p>Clean up and fill in pixel sets (morphological opening and closing)</p></a></li>
<li><a href='#colorise'><p>Fill in a colour in an area given by a pixset</p></a></li>
<li><a href='#common_pixsets'><p>Various useful pixsets</p></a></li>
<li><a href='#contours'><p>Return contours of image/pixset</p></a></li>
<li><a href='#coord.index'><p>Coordinates from pixel index</p></a></li>
<li><a href='#correlate'><p>Correlation/convolution of image by filter</p></a></li>
<li><a href='#crop.borders'><p>Crop the outer margins of an image</p></a></li>
<li><a href='#deriche'><p>Apply recursive Deriche filter.</p></a></li>
<li><a href='#diffusion_tensors'><p>Compute field of diffusion tensors for edge-preserving smoothing.</p></a></li>
<li><a href='#displacement'><p>Estimate displacement field between two images.</p></a></li>
<li><a href='#display'><p>Display object using CImg library</p></a></li>
<li><a href='#display.cimg'><p>Display image using CImg library</p></a></li>
<li><a href='#display.list'><p>Display image list using CImg library</p></a></li>
<li><a href='#distance_transform'><p>Compute Euclidean distance function to a specified value.</p></a></li>
<li><a href='#draw_circle'><p>Draw circle on image</p></a></li>
<li><a href='#draw_rect'><p>Draw rectangle on image</p></a></li>
<li><a href='#draw_text'><p>Draw text on an image</p></a></li>
<li><a href='#erode'><p>Erode/dilate image by a structuring element.</p></a></li>
<li><a href='#extract_patches'><p>Extract image patches and return a list</p></a></li>
<li><a href='#FFT'><p>Compute the Discrete Fourier Transform of an image</p></a></li>
<li><a href='#flatten.alpha'><p>Flatten alpha channel</p></a></li>
<li><a href='#frames'><p>Split a video into separate frames</p></a></li>
<li><a href='#get_gradient'><p>Compute image gradient.</p></a></li>
<li><a href='#get_hessian'><p>Return image hessian.</p></a></li>
<li><a href='#get.locations'><p>Return coordinates of subset of pixels</p></a></li>
<li><a href='#get.stencil'><p>Return pixel values in a neighbourhood defined by a stencil</p></a></li>
<li><a href='#grab'><p>Select image regions interactively</p></a></li>
<li><a href='#grayscale'><p>Convert an RGB image to grayscale</p></a></li>
<li><a href='#grow'><p>Grow/shrink a pixel set</p></a></li>
<li><a href='#gsdim'><p>Grayscale dimensions of image</p></a></li>
<li><a href='#haar'><p>Compute Haar multiscale wavelet transform.</p></a></li>
<li><a href='#highlight'><p>Highlight pixel set on image</p></a></li>
<li><a href='#hough_circle'><p>Circle detection using Hough transform</p></a></li>
<li><a href='#hough_line'><p>Hough transform for lines</p></a></li>
<li><a href='#idply'><p>Split an image along axis, map function, return a data.frame</p></a></li>
<li><a href='#iiply'><p>Split an image, apply function, recombine the results as an image</p></a></li>
<li><a href='#ilply'><p>Split an image along axis, apply function, return a list</p></a></li>
<li><a href='#im_split'><p>Split an image along a certain axis (producing a list)</p></a></li>
<li><a href='#imager.combine'><p>Combining images</p></a></li>
<li><a href='#imager.replace'><p>Replace part of an image with another</p></a></li>
<li><a href='#imager.subset'><p>Array subset operator for cimg objects</p></a></li>
<li><a href='#imappend'><p>Combine a list of images into a single image</p></a></li>
<li><a href='#imchange'><p>Modify parts of an image</p></a></li>
<li><a href='#imcoord'><p>Coordinates as images</p></a></li>
<li><a href='#imdirac'><p>Generates a &quot;dirac&quot; image, i.e. with all values set to 0 except one.</p></a></li>
<li><a href='#imdraw'><p>Draw image on another image</p></a></li>
<li><a href='#imeval'><p>Evaluation in an image context</p></a></li>
<li><a href='#imfill'><p>Create an image of custom size by filling in repeated values</p></a></li>
<li><a href='#imgradient'><p>Compute image gradient</p></a></li>
<li><a href='#imhessian'><p>Compute image hessian.</p></a></li>
<li><a href='#iminfo'><p>Return information on image file</p></a></li>
<li><a href='#imlap'><p>Compute image Laplacian</p></a></li>
<li><a href='#imlist'><p>Image list</p></a></li>
<li><a href='#imnoise'><p>Generate (Gaussian) white-noise image</p></a></li>
<li><a href='#implot'><p>Plot objects on image using base graphics</p></a></li>
<li><a href='#imrep'><p>Replicate images</p></a></li>
<li><a href='#imrotate'><p>Rotate an image along the XY plane.</p></a></li>
<li><a href='#imsharpen'><p>Sharpen image.</p></a></li>
<li><a href='#imshift'><p>Shift image content.</p></a></li>
<li><a href='#imsplit'><p>Split an image along a certain axis (producing a list)</p></a></li>
<li><a href='#imsub'><p>Select part of an image</p></a></li>
<li><a href='#imwarp'><p>Image warping</p></a></li>
<li><a href='#index.coord'><p>Linear index in internal vector from pixel coordinates</p></a></li>
<li><a href='#inpaint'><p>Fill-in NA values in an image</p></a></li>
<li><a href='#interact'><p>Build simple interactive interfaces using imager</p></a></li>
<li><a href='#interp'><p>Interpolate image values</p></a></li>
<li><a href='#is.cimg'><p>Checks that an object is a cimg object</p></a></li>
<li><a href='#is.imlist'><p>Check that an object is an imlist object</p></a></li>
<li><a href='#is.pixset'><p>Check that an object is a pixset object</p></a></li>
<li><a href='#isoblur'><p>Blur image isotropically.</p></a></li>
<li><a href='#label'><p>Label connected components.</p></a></li>
<li><a href='#liply'><p>Apply function to each element of a list, then combine the result as an image by appending along specified axis</p></a></li>
<li><a href='#load.dir'><p>Load all images in a directory</p></a></li>
<li><a href='#load.example'><p>Load example image</p></a></li>
<li><a href='#load.image'><p>Load image from file or URL</p></a></li>
<li><a href='#load.video'><p>Load a video using ffmpeg</p></a></li>
<li><a href='#magick'><p>Convert a magick image to a cimg image or image list and vice versa</p></a></li>
<li><a href='#make.video'><p>Make/save a video using ffmpeg</p></a></li>
<li><a href='#map_il'><p>Type-stable map for use with the purrr package</p></a></li>
<li><a href='#medianblur'><p>Blur image with the median filter.</p>
</p>
<p>In a window of size n x n centered at pixel (x,y), compute median pixel value over the window. Optionally, ignore values that are too far from the value at current pixel.</p></a></li>
<li><a href='#mirror'><p>Mirror image content along specified axis</p></a></li>
<li><a href='#mutate_plyr'><p>Mutate a data frame by adding new or replacing existing columns.</p></a></li>
<li><a href='#nfline'><p>Plot a line, Hesse normal form parameterisation</p></a></li>
<li><a href='#pad'><p>Pad image with n pixels along specified axis</p></a></li>
<li><a href='#patch_summary_cimg'><p>Extract a numerical summary from image patches, using CImg's mini-language</p>
Experimental feature.</a></li>
<li><a href='#patchstat'><p>Return image patch summary</p></a></li>
<li><a href='#periodic.part'><p>Compute the periodic part of an image, using the periodic/smooth decomposition of Moisan (2011)</p></a></li>
<li><a href='#permute_axes'><p>Permute image axes</p></a></li>
<li><a href='#pixel.grid'><p>Return the pixel grid for an image</p></a></li>
<li><a href='#pixset'><p>Pixel sets (pixsets)</p></a></li>
<li><a href='#play'><p>Play a video</p></a></li>
<li><a href='#plot.cimg'><p>Display an image using base graphics</p></a></li>
<li><a href='#plot.imlist'><p>Plot an image list</p></a></li>
<li><a href='#px.flood'><p>Select a region of homogeneous colour</p></a></li>
<li><a href='#px.na'><p>A pixset for NA values</p></a></li>
<li><a href='#px.remove_outer'><p>Remove all connected regions that touch image boundaries</p></a></li>
<li><a href='#RasterPackage'><p>Convert a RasterLayer/RasterBrick to a cimg image/image list</p></a></li>
<li><a href='#renorm'><p>Renormalise image</p></a></li>
<li><a href='#resize'><p>Resize image</p></a></li>
<li><a href='#resize_doubleXY'><p>Resize image uniformly</p></a></li>
<li><a href='#RGBtoHSL'><p>Colour space conversions in imager</p></a></li>
<li><a href='#rm.alpha'><p>Remove alpha channel and store as attribute</p></a></li>
<li><a href='#rotate_xy'><p>Rotate image by an arbitrary angle, around a center point.</p></a></li>
<li><a href='#save.image'><p>Save image</p></a></li>
<li><a href='#split_connected'><p>Split pixset into connected components</p></a></li>
<li><a href='#squeeze'><p>Remove empty dimensions from an array</p></a></li>
<li><a href='#stencil.cross'><p>A cross-shaped stencil</p></a></li>
<li><a href='#threshold'><p>Threshold grayscale image</p></a></li>
<li><a href='#vanvliet'><p>Young-Van Vliet recursive Gaussian filter.</p></a></li>
<li><a href='#warp'><p>Warp image</p></a></li>
<li><a href='#watershed'><p>Compute watershed transform.</p></a></li>
<li><a href='#where'><p>Return locations in pixel set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Image Processing Library Based on 'CImg'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast image processing for images in up to 4 dimensions (two spatial
    dimensions, one time/depth dimension, one colour dimension). Provides most
    traditional image processing tools (filtering, morphology, transformations,
    etc.) as well as various functions for easily analysing image data using R. The
    package wraps 'CImg', <a href="http://cimg.eu">http://cimg.eu</a>, a simple, modern C++ library for image
    processing.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), methods, stringr, png, jpeg, readbitmap,
grDevices, purrr, downloader, igraph</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), magrittr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://asgr.github.io/imager/">https://asgr.github.io/imager/</a>, <a href="https://github.com/asgr/imager/">https://github.com/asgr/imager/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/asgr/imager/issues">https://github.com/asgr/imager/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>fftw3, libtiff, X11</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2, dplyr, scales, testthat, raster,
spatstat.geom, magick, Cairo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-13 01:58:43 UTC; aaron</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Barthelme [aut],
  David Tschumperle [ctb],
  Jan Wijffels [ctb],
  Haz Edine Assemlal [ctb],
  Shota Ochi [ctb],
  Aaron Robotham [cre],
  Rodrigo Tobar [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aaron Robotham &lt;aaron.robotham@uwa.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-13 09:03:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='imager'>imager: an R library for image processing, based on CImg</h2><span id='topic+imager'></span><span id='topic+imager-package'></span>

<h3>Description</h3>

<p>CImg by David Tschumperle is a C++ library for image processing. It provides most common functions for image manipulation and filtering, as well as some advanced algorithms. imager makes these functions accessible from R and adds many utilities for accessing and working with image data from R.
You should install ImageMagick if you want support for image formats beyond PNG and JPEG, and ffmpeg if you need to work with videos (in which case you probably also want to take a look at experimental package imagerstreams on github).
Package documentation is available at http://asgr.github.io/imager/.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aaron Robotham <a href="mailto:aaron.robotham@uwa.edu.au">aaron.robotham@uwa.edu.au</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Simon Barthelme <a href="mailto:simon.barthelme@gipsa-lab.fr">simon.barthelme@gipsa-lab.fr</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> David Tschumperle [contributor]
</p>
</li>
<li><p> Jan Wijffels [contributor]
</p>
</li>
<li><p> Haz Edine Assemlal [contributor]
</p>
</li>
<li><p> Shota Ochi <a href="mailto:shotaochi1990@gmail.com">shotaochi1990@gmail.com</a> [contributor]
</p>
</li>
<li><p> Rodrigo Tobar [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://asgr.github.io/imager/">https://asgr.github.io/imager/</a>
</p>
</li>
<li> <p><a href="https://github.com/asgr/imager/">https://github.com/asgr/imager/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/asgr/imager/issues">https://github.com/asgr/imager/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='+25inr+25'>Check that value is in a range</h2><span id='topic++25inr+25'></span>

<h3>Description</h3>

<p>A shortcut for x &gt;= a | x &lt;= b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %inr% range
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25inr+2B25_+3A_x">x</code></td>
<td>
<p>numeric values</p>
</td></tr>
<tr><td><code id="+2B25inr+2B25_+3A_range">range</code></td>
<td>
<p>a vector of length two, of the form c(a,b)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of logicals
1:10 
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>

<hr>
<h2 id='add.colour'>Add colour channels to a grayscale image or pixel set</h2><span id='topic+add.colour'></span><span id='topic+add.color'></span>

<h3>Description</h3>

<p>Add colour channels to a grayscale image or pixel set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.colour(im, simple = TRUE)

add.color(im, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.colour_+3A_im">im</code></td>
<td>
<p>a grayscale image</p>
</td></tr>
<tr><td><code id="add.colour_+3A_simple">simple</code></td>
<td>
<p>if TRUE just stack three copies of the grayscale image, if FALSE treat the image as the L channel in an HSL representation. Default TRUE. For pixel sets this option makes no sense and is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image of class cimg
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>add.color()</code>: Alias for add.colour
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grayscale(boats) #No more colour channels
add.colour(grayscale(boats)) #Image has depth = 3 (but contains only grays)
</code></pre>

<hr>
<h2 id='as.cimg'>Convert to cimg object</h2><span id='topic+as.cimg'></span><span id='topic+as.cimg.numeric'></span><span id='topic+as.cimg.logical'></span><span id='topic+as.cimg.double'></span><span id='topic+as.cimg.cimg'></span><span id='topic+as.cimg.vector'></span><span id='topic+as.cimg.matrix'></span>

<h3>Description</h3>

<p>Imager implements various converters that turn your data into cimg objects. If you convert from a vector (which only has a length, and no dimension), either specify dimensions explicitly or some guesswork will be involved. See examples for clarifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.cimg(obj, ...)

## S3 method for class 'numeric'
as.cimg(obj, ...)

## S3 method for class 'logical'
as.cimg(obj, ...)

## S3 method for class 'double'
as.cimg(obj, ...)

## S3 method for class 'cimg'
as.cimg(obj, ...)

## S3 method for class 'vector'
as.cimg(obj, x = NA, y = NA, z = NA, cc = NA, dim = NULL, ...)

## S3 method for class 'matrix'
as.cimg(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.cimg_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="as.cimg_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="as.cimg_+3A_x">x</code></td>
<td>
<p>width</p>
</td></tr>
<tr><td><code id="as.cimg_+3A_y">y</code></td>
<td>
<p>height</p>
</td></tr>
<tr><td><code id="as.cimg_+3A_z">z</code></td>
<td>
<p>depth</p>
</td></tr>
<tr><td><code id="as.cimg_+3A_cc">cc</code></td>
<td>
<p>spectrum</p>
</td></tr>
<tr><td><code id="as.cimg_+3A_dim">dim</code></td>
<td>
<p>a vector of dimensions (optional, use instead of xyzcc)</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.cimg(numeric)</code>: convert numeric
</p>
</li>
<li> <p><code>as.cimg(logical)</code>: convert logical
</p>
</li>
<li> <p><code>as.cimg(double)</code>: convert double
</p>
</li>
<li> <p><code>as.cimg(cimg)</code>: return object
</p>
</li>
<li> <p><code>as.cimg(vector)</code>: convert vector
</p>
</li>
<li> <p><code>as.cimg(matrix)</code>: Convert to matrix
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>as.cimg.array, as.cimg.function, as.cimg.data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.cimg(1:100,x=10,y=10) #10x10, grayscale image
as.cimg(rep(1:100,3),x=10,y=10,cc=3) #10x10 RGB
as.cimg(1:100,dim=c(10,10,1,1))
as.cimg(1:100) #Guesses dimensions, warning is issued
as.cimg(rep(1:100,3)) #Guesses dimensions, warning is issued
</code></pre>

<hr>
<h2 id='as.cimg.array'>Turn an numeric array into a cimg object</h2><span id='topic+as.cimg.array'></span>

<h3>Description</h3>

<p>If the array has two dimensions, we assume it's a grayscale image. If it has three dimensions we assume it's a video, unless the third dimension has a depth of 3, in which case we assume it's a colour image,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
as.cimg(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.cimg.array_+3A_obj">obj</code></td>
<td>
<p>an array</p>
</td></tr>
<tr><td><code id="as.cimg.array_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
as.cimg(array(1:9,c(3,3)))
as.cimg(array(1,c(10,10,3))) #Guesses colour image
as.cimg(array(1:9,c(10,10,4))) #Guesses video
</code></pre>

<hr>
<h2 id='as.cimg.data.frame'>Create an image from a data.frame</h2><span id='topic+as.cimg.data.frame'></span>

<h3>Description</h3>

<p>This function is meant to be just like as.cimg.data.frame, but in reverse. Each line in the data frame must correspond to a pixel. For example, the data fame can be of the form (x,y,value) or (x,y,z,value), or (x,y,z,cc,value). The coordinates must be valid image coordinates (i.e., positive integers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
as.cimg(obj, v.name = "value", dims, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.cimg.data.frame_+3A_obj">obj</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="as.cimg.data.frame_+3A_v.name">v.name</code></td>
<td>
<p>name of the variable to extract pixel values from (default &quot;value&quot;)</p>
</td></tr>
<tr><td><code id="as.cimg.data.frame_+3A_dims">dims</code></td>
<td>
<p>a vector of length 4 corresponding to image dimensions. If missing, a guess will be made.</p>
</td></tr>
<tr><td><code id="as.cimg.data.frame_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class cimg
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create a data.frame with columns x,y and value
df &lt;- expand.grid(x=1:10,y=1:10) %&gt;% dplyr::mutate(value=x*y)
#Convert to cimg object (2D, grayscale image of size 10*10
as.cimg(df,dims=c(10,10,1,1)) %&gt;% plot
</code></pre>

<hr>
<h2 id='as.cimg.function'>Create an image by sampling a function</h2><span id='topic+as.cimg.function'></span>

<h3>Description</h3>

<p>Similar to as.im.function from the spatstat package, but simpler. Creates a grid of pixel coordinates x=1:width,y=1:height and (optional) z=1:depth, and evaluates the input function at these values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
as.cimg(
  obj,
  width,
  height,
  depth = 1,
  spectrum = 1,
  standardise = FALSE,
  dim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.cimg.function_+3A_obj">obj</code></td>
<td>
<p>a function with arguments (x,y), or (x,y,cc), or (x,y,z), etc. Must be vectorised; see examples.</p>
</td></tr>
<tr><td><code id="as.cimg.function_+3A_width">width</code></td>
<td>
<p>width of the image (in pixels)</p>
</td></tr>
<tr><td><code id="as.cimg.function_+3A_height">height</code></td>
<td>
<p>height of the image (in pixels)</p>
</td></tr>
<tr><td><code id="as.cimg.function_+3A_depth">depth</code></td>
<td>
<p>depth of the image (in pixels). Default 1.</p>
</td></tr>
<tr><td><code id="as.cimg.function_+3A_spectrum">spectrum</code></td>
<td>
<p>number of colour channels. Defaut 1.</p>
</td></tr>
<tr><td><code id="as.cimg.function_+3A_standardise">standardise</code></td>
<td>
<p>coordinates are scaled and centered (see doc for pixel.grid)</p>
</td></tr>
<tr><td><code id="as.cimg.function_+3A_dim">dim</code></td>
<td>
<p>a vector of image dimensions (can be used instead of width, height, etc.)</p>
</td></tr>
<tr><td><code id="as.cimg.function_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class cimg
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im = as.cimg(function(x,y) cos(sin(x*y/100)),100,100)
plot(im)
#The following is just a rectangle at the center of the image 
im = as.cimg(function(x,y) (abs(x) &lt; .1)*(abs(y) &lt; .1) ,100,100,standardise=TRUE)
plot(im)
#Since coordinates are standardised the rectangle scales with the size of the image
im = as.cimg(function(x,y) (abs(x) &lt; .1)*(abs(y) &lt; .1) ,200,200,standardise=TRUE)
plot(im)
#A Gaussian mask around the center
im = as.cimg(function(x,y) dnorm(x,sd=.1)*dnorm(y,sd=.3) ,dim=dim(boats),standardise=TRUE)
im = im/max(im)

plot(im*boats)
#A Gaussian mask for just the red channel
fun = function(x,y,cc) ifelse(cc==1,dnorm(x,sd=.1)*dnorm(y,sd=.3),0)
im = as.cimg(fun,dim=dim(boats),standardise=TRUE)
plot(im*boats)

</code></pre>

<hr>
<h2 id='as.cimg.im'>Convert an image in spatstat format to an image in cimg format</h2><span id='topic+as.cimg.im'></span>

<h3>Description</h3>

<p>Convert an image in spatstat format to an image in cimg format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im'
as.cimg(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.cimg.im_+3A_obj">obj</code></td>
<td>
<p>a spatstat image</p>
</td></tr>
<tr><td><code id="as.cimg.im_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cimg image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>

<hr>
<h2 id='as.cimg.raster'>Convert a raster object to a cimg object</h2><span id='topic+as.cimg.raster'></span>

<h3>Description</h3>

<p>R's native object for representing images is a &quot;raster&quot;. This function converts raster objects to cimg objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'raster'
as.cimg(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.cimg.raster_+3A_obj">obj</code></td>
<td>
<p>a raster object</p>
</td></tr>
<tr><td><code id="as.cimg.raster_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cimg object
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rst &lt;- as.raster(matrix((1:4)/4,2,2))
as.cimg(rst) %&gt;% plot(int=FALSE)
all.equal(rst,as.raster(as.cimg(rst)))

</code></pre>

<hr>
<h2 id='as.data.frame.cimg'>Convert a pixel image to a data.frame</h2><span id='topic+as.data.frame.cimg'></span>

<h3>Description</h3>

<p>This function combines the output of pixel.grid with the actual values (stored in $value)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cimg'
as.data.frame(x, ..., wide = c(FALSE, "c", "d"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.cimg_+3A_x">x</code></td>
<td>
<p>an image of class cimg</p>
</td></tr>
<tr><td><code id="as.data.frame.cimg_+3A_...">...</code></td>
<td>
<p>arguments passed to pixel.grid</p>
</td></tr>
<tr><td><code id="as.data.frame.cimg_+3A_wide">wide</code></td>
<td>
<p>if &quot;c&quot; or &quot;d&quot; return a data.frame that is wide along colour or depth (for example with rgb values along columns). The default is FALSE, with each pixel forming a separate entry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#First five pixels
as.data.frame(boats) %&gt;% head(5)
#Wide format along colour axis
as.data.frame(boats,wide="c") %&gt;% head(5)
</code></pre>

<hr>
<h2 id='as.data.frame.imlist'>Convert image list to data.frame</h2><span id='topic+as.data.frame.imlist'></span>

<h3>Description</h3>

<p>Convert image list to data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imlist'
as.data.frame(x, ..., index = "im")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.imlist_+3A_x">x</code></td>
<td>
<p>an image list (an imlist object)</p>
</td></tr>
<tr><td><code id="as.data.frame.imlist_+3A_...">...</code></td>
<td>
<p>Passed on to as.data.frame.cimg</p>
</td></tr>
<tr><td><code id="as.data.frame.imlist_+3A_index">index</code></td>
<td>
<p>Name of the column containing the index (or name) of the image in the list. Default: &quot;im&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Transform the image gradient into a data.frame
gr &lt;- imgradient(boats,"xy") %&gt;% setNames(c("dx","dy")) %&gt;% as.data.frame
str(gr)
</code></pre>

<hr>
<h2 id='as.data.frame.pixset'>Methods to convert pixsets to various objects</h2><span id='topic+as.data.frame.pixset'></span><span id='topic+convert_pixset'></span>

<h3>Description</h3>

<p>Methods to convert pixsets to various objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pixset'
as.data.frame(x, ..., drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.pixset_+3A_x">x</code></td>
<td>
<p>pixset to convert</p>
</td></tr>
<tr><td><code id="as.data.frame.pixset_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as.data.frame.pixset_+3A_drop">drop</code></td>
<td>
<p>drop flat dimensions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>where
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

px &lt;- boats &gt; 250
#Convert to array of logicals
as.logical(px) %&gt;% dim
#Convert to data.frame: gives all pixel locations in the set
as.data.frame(px) %&gt;% head
#Drop flat dimensions
as.data.frame(px,drop=TRUE) %&gt;% head
</code></pre>

<hr>
<h2 id='as.igraph.cimg'>Form a graph from an image</h2><span id='topic+as.igraph.cimg'></span>

<h3>Description</h3>

<p>In this graph representation, every pixel is a vertex connected to its neighbours.
The image values along edges are stored as graph attributes (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cimg'
as.igraph(x, mask = px.all(channel(im, 1)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.igraph.cimg_+3A_x">x</code></td>
<td>
<p>an image (must be 2D, 3D not implemented yet)</p>
</td></tr>
<tr><td><code id="as.igraph.cimg_+3A_mask">mask</code></td>
<td>
<p>optional: a pixset. if provided, pixels are only connected if they are both in the pixset.</p>
</td></tr>
<tr><td><code id="as.igraph.cimg_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a graph (igraph format) with attributes value.from, value.to and dist
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>as.igraph.pixset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)
im &lt;- imfill(5,5)
G &lt;- as.igraph(im)
plot(G)
#Shortest-path distance from pixel 1 to all other pixels
d &lt;- igraph::distances(G,1) %&gt;% as.vector
as.cimg(d,dim=gsdim(im)) %&gt;% plot(interpolate=FALSE)
#Notice that moving along the diagonal has the same cost
#as moving along the cardinal directions, whereas the Euclidean distance
#is actually sqrt(2) and not 1. 
#Modify weight attribute, to change the way distance is computed
igraph::E(G)$weight &lt;- G$dist
d2 &lt;- igraph::distances(G,1) %&gt;% as.vector
as.cimg(d2,dim=gsdim(im)) %&gt;% plot(interpolate=FALSE)
#More interesting example
im &lt;- grayscale(boats)
G &lt;- as.igraph(im)
#value.from holds the value of the source pixel, value.to the sink's
#set w_ij = (|v_i - v_j|)/d_ij
igraph::E(G)$weight &lt;- (abs(G$value.from - G$value.to))/G$dist
igraph::distances(G,5000) %&gt;% as.vector %&gt;%
    as.cimg(dim=gsdim(im)) %&gt;% plot
</code></pre>

<hr>
<h2 id='as.igraph.pixset'>Form an adjacency graph from a pixset</h2><span id='topic+as.igraph.pixset'></span>

<h3>Description</h3>

<p>Return a graph where nodes are pixels, and two nodes are connected if and only if both nodes are in the pixset, and the pixels are adjacent. Optionnally, add weights corresponding to distance (either 1 or sqrt(2), depending on the orientation of the edge).
The graph is represented as an igraph &quot;graph&quot; object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pixset'
as.igraph(x, weighted = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.igraph.pixset_+3A_x">x</code></td>
<td>
<p>a pixset</p>
</td></tr>
<tr><td><code id="as.igraph.pixset_+3A_weighted">weighted</code></td>
<td>
<p>add weight for distance (default TRUE)</p>
</td></tr>
<tr><td><code id="as.igraph.pixset_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an igraph &quot;graph&quot; object
</p>


<h3>See Also</h3>

<p>as.igraph.cimg
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)
#Simple 3x3 lattice
px &lt;- px.all(imfill(3,3))
as.igraph(px) %&gt;% plot
#Disconnect central pixel
px[5] &lt;- FALSE
as.igraph(px) %&gt;% plot
#Form graph from thresholded image
im &lt;- load.example("coins")
px &lt;- threshold(im) %&gt;% fill(5)
G &lt;- as.igraph(px)
#Label connected components
v &lt;- (igraph::clusters(G)$membership)
as.cimg(v,dim=dim(px)) %&gt;% plot
#Find a path across the image that avoids all
#the coins
G &lt;- as.igraph(!px)
start &lt;- index.coord(im,data.frame(x=1,y=100))
end &lt;- index.coord(im,data.frame(x=384,y=300))
sp &lt;- igraph::shortest_paths(G,start,end,output="vpath")
path &lt;- sp$vpath[[1]] %&gt;% as.integer %&gt;% coord.index(im,.)
</code></pre>

<hr>
<h2 id='as.imlist.list'>Convert various objects to image lists</h2><span id='topic+as.imlist.list'></span><span id='topic+as.imlist'></span><span id='topic+as.imlist.imlist'></span><span id='topic+as.imlist.cimg'></span>

<h3>Description</h3>

<p>Convert various objects to image lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
as.imlist(obj, ...)

as.imlist(obj, ...)

## S3 method for class 'imlist'
as.imlist(obj, ...)

## S3 method for class 'cimg'
as.imlist(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.imlist.list_+3A_obj">obj</code></td>
<td>
<p>an image list</p>
</td></tr>
<tr><td><code id="as.imlist.list_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.imlist(list)</code>: convert from list
</p>
</li>
<li> <p><code>as.imlist(imlist)</code>: Convert from imlist (identity)
</p>
</li>
<li> <p><code>as.imlist(cimg)</code>: Convert from image
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
list(a=boats,b=boats*2) %&gt;% as.imlist
</code></pre>

<hr>
<h2 id='as.pixset'>Methods to convert various objects to pixsets</h2><span id='topic+as.pixset'></span><span id='topic+as.pixset.cimg'></span><span id='topic+as.cimg.pixset'></span>

<h3>Description</h3>

<p>Methods to convert various objects to pixsets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.pixset(x, ...)

## S3 method for class 'cimg'
as.pixset(x, ...)

## S3 method for class 'pixset'
as.cimg(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.pixset_+3A_x">x</code></td>
<td>
<p>object to convert to pixset</p>
</td></tr>
<tr><td><code id="as.pixset_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as.pixset_+3A_obj">obj</code></td>
<td>
<p>pixset to convert</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.pixset(cimg)</code>: convert cimg to pixset
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>as.cimg(pixset)</code>: convert pixset to cimg
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
#When converting an image to a pixset, the default is to include all pixels with non-zero value 
as.pixset(boats)
#The above is equivalent to:
boats!=0

</code></pre>

<hr>
<h2 id='as.raster.cimg'>Convert a cimg object to a raster object for plotting</h2><span id='topic+as.raster.cimg'></span>

<h3>Description</h3>

<p>raster objects are used by R's base graphics for plotting. R wants hexadecimal RGB values for plotting, e.g. gray(0) yields #000000, meaning black. If you want to control precisely how numerical values are turned into colours for plotting, you need to specify a colour scale using the colourscale argument (see examples). Otherwise the default is &quot;gray&quot; for grayscale images, &quot;rgb&quot; for colour. These expect values in [0..1], so the default is to rescale the data to [0..1]. If you wish to over-ride that behaviour, set rescale=FALSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cimg'
as.raster(
  x,
  frames,
  rescale = TRUE,
  colourscale = NULL,
  colorscale = NULL,
  col.na = rgb(0, 0, 0, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.raster.cimg_+3A_x">x</code></td>
<td>
<p>an image (of class cimg)</p>
</td></tr>
<tr><td><code id="as.raster.cimg_+3A_frames">frames</code></td>
<td>
<p>which frames to extract (in case depth &gt; 1)</p>
</td></tr>
<tr><td><code id="as.raster.cimg_+3A_rescale">rescale</code></td>
<td>
<p>rescale so that pixel values are in [0,1]? (subtract min and divide by range). default TRUE</p>
</td></tr>
<tr><td><code id="as.raster.cimg_+3A_colourscale">colourscale</code></td>
<td>
<p>a function that returns RGB values in hexadecimal</p>
</td></tr>
<tr><td><code id="as.raster.cimg_+3A_colorscale">colorscale</code></td>
<td>
<p>same as above in American spelling</p>
</td></tr>
<tr><td><code id="as.raster.cimg_+3A_col.na">col.na</code></td>
<td>
<p>which colour to use for NA values, as R rgb code. The default is &quot;rgb(0,0,0,0)&quot;, which corresponds to a fully transparent colour.</p>
</td></tr>
<tr><td><code id="as.raster.cimg_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a raster object
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>plot.cimg, rasterImage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#A raster is a simple array of RGB values
as.raster(boats) %&gt;% str
#By default as.raster rescales input values, so that:
all.equal(as.raster(boats),as.raster(boats/2)) #TRUE
#Setting rescale to FALSE changes that
as.raster(boats,rescale=FALSE) %&gt;% plot
as.raster(boats/2,rescale=FALSE) %&gt;% plot
#For grayscale images, a colourmap should take a single value and
#return  an RGB code
#Example: mapping grayscale value to saturation
cscale &lt;- function(v) hsv(.5,v,1)
grayscale(boats) %&gt;% as.raster(colourscale=cscale) %&gt;% plot
</code></pre>

<hr>
<h2 id='at'>Return or set pixel value at coordinates</h2><span id='topic+at'></span><span id='topic+at+3C-'></span><span id='topic+color.at'></span><span id='topic+color.at+3C-'></span>

<h3>Description</h3>

<p>Return or set pixel value at coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>at(im, x, y, z = 1, cc = 1)

at(im, x, y, z = 1, cc = 1) &lt;- value

color.at(im, x, y, z = 1)

color.at(im, x, y, z = 1) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="at_+3A_im">im</code></td>
<td>
<p>an image (cimg object)</p>
</td></tr>
<tr><td><code id="at_+3A_x">x</code></td>
<td>
<p>x coordinate (vector)</p>
</td></tr>
<tr><td><code id="at_+3A_y">y</code></td>
<td>
<p>y coordinate (vector)</p>
</td></tr>
<tr><td><code id="at_+3A_z">z</code></td>
<td>
<p>z coordinate (vector, default 1)</p>
</td></tr>
<tr><td><code id="at_+3A_cc">cc</code></td>
<td>
<p>colour coordinate (vector, default 1)</p>
</td></tr>
<tr><td><code id="at_+3A_value">value</code></td>
<td>
<p>replacement</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pixel values
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>at(im, x, y, z = 1, cc = 1) &lt;- value</code>: set value of pixel at a location
</p>
</li>
<li> <p><code>color.at()</code>: return value of all colour channels at a location
</p>
</li>
<li> <p><code>color.at(im, x, y, z = 1) &lt;- value</code>: set value of all colour channels at a location
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- as.cimg(function(x,y) x+y,50,50)
at(im,10,1)
at(im,10:12,1)
at(im,10:12,1:3)
at(im,1,2) &lt;- 10
at(im,1,2)

color.at(boats,x=10,y=10)

im &lt;- boats
color.at(im,x=10,y=10) &lt;- c(255,0,0)
#There should now be a red dot
imsub(im, x %inr% c(1,100), y %inr% c(1,100)) %&gt;% plot
</code></pre>

<hr>
<h2 id='autocrop'>Autocrop image region</h2><span id='topic+autocrop'></span>

<h3>Description</h3>

<p>Autocrop image region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocrop(im, color = color.at(im, 1, 1), axes = "zyx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocrop_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="autocrop_+3A_color">color</code></td>
<td>
<p>Colour used for the crop. If missing, the colour is taken from the top-left pixel. Can also be a colour name (e.g. &quot;red&quot;, or &quot;black&quot;)</p>
</td></tr>
<tr><td><code id="autocrop_+3A_axes">axes</code></td>
<td>
<p>Axes used for the crop.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Add pointless padding
padded &lt;- pad(boats,30,"xy")
plot(padded)
#Remove padding
autocrop(padded) %&gt;% plot
#You can specify the colour if needs be
autocrop(padded,"black") %&gt;% plot
#autocrop has a zero-tolerance policy: if a pixel value is slightly different from the one you gave
#the pixel won't get cropped. A fix is to do a bucket fill first
padded &lt;- isoblur(padded,10)
autocrop(padded) %&gt;% plot
padded2 &lt;- bucketfill(padded,1,1,col=c(0,0,0),sigma=.1)
autocrop(padded2) %&gt;% plot

</code></pre>

<hr>
<h2 id='bbox'>Compute the bounding box of a pixset</h2><span id='topic+bbox'></span><span id='topic+crop.bbox'></span>

<h3>Description</h3>

<p>This function returns the bounding box of a pixset as another pixset. If the image has more than one frame, a bounding cube is returned.
If the image has several colour channels, the bounding box is computed separately in each channel.
crop.bbox crops an image using the bounding box of a pixset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbox(px)

crop.bbox(im, px)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox_+3A_px">px</code></td>
<td>
<p>a pixset</p>
</td></tr>
<tr><td><code id="bbox_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pixset object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>crop.bbox()</code>: crop image using the bounding box of pixset px
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- grayscale(boats)
px &lt;- im &gt; .85
plot(im)
highlight(bbox(px))
highlight(px,col="green")
crop.bbox(im,px) %&gt;% plot
</code></pre>

<hr>
<h2 id='blur_anisotropic'>Blur image anisotropically, in an edge-preserving way.</h2><span id='topic+blur_anisotropic'></span>

<h3>Description</h3>

<p>Standard blurring removes noise from images, but tends to smooth away edges in the process. This anisotropic filter preserves edges better.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blur_anisotropic(
  im,
  amplitude,
  sharpness = 0.7,
  anisotropy = 0.6,
  alpha = 0.6,
  sigma = 1.1,
  dl = 0.8,
  da = 30,
  gauss_prec = 2,
  interpolation_type = 0L,
  fast_approx = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blur_anisotropic_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="blur_anisotropic_+3A_amplitude">amplitude</code></td>
<td>
<p>Amplitude of the smoothing.</p>
</td></tr>
<tr><td><code id="blur_anisotropic_+3A_sharpness">sharpness</code></td>
<td>
<p>Sharpness.</p>
</td></tr>
<tr><td><code id="blur_anisotropic_+3A_anisotropy">anisotropy</code></td>
<td>
<p>Anisotropy.</p>
</td></tr>
<tr><td><code id="blur_anisotropic_+3A_alpha">alpha</code></td>
<td>
<p>Standard deviation of the gradient blur.</p>
</td></tr>
<tr><td><code id="blur_anisotropic_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the structure tensor blur.</p>
</td></tr>
<tr><td><code id="blur_anisotropic_+3A_dl">dl</code></td>
<td>
<p>Spatial discretization.</p>
</td></tr>
<tr><td><code id="blur_anisotropic_+3A_da">da</code></td>
<td>
<p>Angular discretization.</p>
</td></tr>
<tr><td><code id="blur_anisotropic_+3A_gauss_prec">gauss_prec</code></td>
<td>
<p>Precision of the diffusion process.</p>
</td></tr>
<tr><td><code id="blur_anisotropic_+3A_interpolation_type">interpolation_type</code></td>
<td>
<p>Interpolation scheme.
Can be 0=nearest-neighbor | 1=linear | 2=Runge-Kutta</p>
</td></tr>
<tr><td><code id="blur_anisotropic_+3A_fast_approx">fast_approx</code></td>
<td>
<p>If true, use fast approximation (default TRUE)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- load.image(system.file('extdata/Leonardo_Birds.jpg',package='imager'))
im.noisy &lt;- (im + 80*rnorm(prod(dim(im)))) 
blur_anisotropic(im.noisy,ampl=1e4,sharp=1) %&gt;% plot
</code></pre>

<hr>
<h2 id='boats'>Photograph of sailing boats from Kodak set</h2><span id='topic+boats'></span>

<h3>Description</h3>

<p>This photograph was downloaded from http://r0k.us/graphics/kodak/kodim09.html. Its size was reduced by half to speed up loading and save space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boats
</code></pre>


<h3>Format</h3>

<p>an image of class cimg
</p>


<h3>Source</h3>

<p>http://r0k.us/graphics/kodak/kodim09.html
</p>

<hr>
<h2 id='boundary'>Find the boundary of a shape in a pixel set</h2><span id='topic+boundary'></span>

<h3>Description</h3>

<p>Find the boundary of a shape in a pixel set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundary(px, depth = 1, high_connexity = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundary_+3A_px">px</code></td>
<td>
<p>pixel set</p>
</td></tr>
<tr><td><code id="boundary_+3A_depth">depth</code></td>
<td>
<p>boundary depth (default 1)</p>
</td></tr>
<tr><td><code id="boundary_+3A_high_connexity">high_connexity</code></td>
<td>
<p>if FALSE, use 4-point neighbourhood. If TRUE, use 8-point.  (default FALSE)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
px.diamond(10,30,30) %&gt;% boundary %&gt;% plot
px.square(10,30,30) %&gt;% boundary %&gt;% plot
px.square(10,30,30) %&gt;% boundary(depth=3) %&gt;% plot
px &lt;- (px.square(10,30,30) | px.circle(12,30,30))
boundary(px,high=TRUE) %&gt;% plot(int=TRUE,main="8-point neighbourhood")
boundary(px,high=TRUE) %&gt;% plot(int=FALSE,main="4-point neighbourhood")
</code></pre>

<hr>
<h2 id='boxblur'>Blur image with a box filter (square window)</h2><span id='topic+boxblur'></span>

<h3>Description</h3>

<p>Blur image with a box filter (square window)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxblur(im, boxsize, neumann = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxblur_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="boxblur_+3A_boxsize">boxsize</code></td>
<td>
<p>Size of the box window (can be subpixel).</p>
</td></tr>
<tr><td><code id="boxblur_+3A_neumann">neumann</code></td>
<td>
<p>If true, use Neumann boundary conditions, Dirichlet otherwise  (default true, Neumann)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>deriche(), vanvliet().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
boxblur(boats,5) %&gt;% plot(main="Dirichlet boundary")
boxblur(boats,5,TRUE) %&gt;% plot(main="Neumann boundary")
</code></pre>

<hr>
<h2 id='boxblur_xy'>Blur image with a box filter.</h2><span id='topic+boxblur_xy'></span>

<h3>Description</h3>

<p>This is a recursive algorithm, not depending on the values of the box kernel size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxblur_xy(im, sx, sy, neumann = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxblur_xy_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="boxblur_xy_+3A_sx">sx</code></td>
<td>
<p>Size of the box window, along the X-axis.</p>
</td></tr>
<tr><td><code id="boxblur_xy_+3A_sy">sy</code></td>
<td>
<p>Size of the box window, along the Y-axis.</p>
</td></tr>
<tr><td><code id="boxblur_xy_+3A_neumann">neumann</code></td>
<td>
<p>If true, use Neumann boundary conditions, Dirichlet otherwise  (default true, Neumann)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>blur().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
boxblur_xy(boats,20,5) %&gt;% plot(main="Anisotropic blur")
</code></pre>

<hr>
<h2 id='bucketfill'>Bucket fill</h2><span id='topic+bucketfill'></span>

<h3>Description</h3>

<p>Bucket fill
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bucketfill(
  im,
  x,
  y,
  z = 1,
  color,
  opacity = 1,
  sigma = 0,
  high_connexity = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bucketfill_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="bucketfill_+3A_x">x</code></td>
<td>
<p>X-coordinate of the starting point of the region to fill.</p>
</td></tr>
<tr><td><code id="bucketfill_+3A_y">y</code></td>
<td>
<p>Y-coordinate of the starting point of the region to fill.</p>
</td></tr>
<tr><td><code id="bucketfill_+3A_z">z</code></td>
<td>
<p>Z-coordinate of the starting point of the region to fill.</p>
</td></tr>
<tr><td><code id="bucketfill_+3A_color">color</code></td>
<td>
<p>a vector of values (of length spectrum(im)), or a colour name (e.g. &quot;red&quot;). If missing, use the colour at location (x,y,z).</p>
</td></tr>
<tr><td><code id="bucketfill_+3A_opacity">opacity</code></td>
<td>
<p>opacity. If the opacity is below 1, paint with transparency.</p>
</td></tr>
<tr><td><code id="bucketfill_+3A_sigma">sigma</code></td>
<td>
<p>Tolerance for neighborhood values: spread to neighbours if difference is less than sigma (for grayscale). If there are several channels, the sum of squared differences is used: if it below sigma^2, the colour spreads.</p>
</td></tr>
<tr><td><code id="bucketfill_+3A_high_connexity">high_connexity</code></td>
<td>
<p>Use 8-connexity (only for 2d images, default FALSE).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>px.flood
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Change the colour of a sail 
boats.new &lt;- bucketfill(boats,x=169,y=179,color="pink",sigma=.2) 
layout(t(1:2))
plot(boats,main="Original")
plot(boats.new,main="New sails")

#More spreading, lower opacity, colour specified as vector
ugly &lt;- bucketfill(boats,x=169,y=179,color=c(0,1,0),sigma=.6,opacity=.5)
plot(ugly)
</code></pre>

<hr>
<h2 id='cannyEdges'>Canny edge detector</h2><span id='topic+cannyEdges'></span>

<h3>Description</h3>

<p>If the threshold parameters are missing, they are determined automatically using a k-means heuristic. Use the alpha parameter  to adjust the automatic thresholds up or down
The thresholds are returned as attributes.
The edge detection is based on a smoothed image gradient with a degree of smoothing set by the sigma parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cannyEdges(im, t1, t2, alpha = 1, sigma = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cannyEdges_+3A_im">im</code></td>
<td>
<p>input image</p>
</td></tr>
<tr><td><code id="cannyEdges_+3A_t1">t1</code></td>
<td>
<p>threshold for weak edges (if missing, both thresholds are determined automatically)</p>
</td></tr>
<tr><td><code id="cannyEdges_+3A_t2">t2</code></td>
<td>
<p>threshold for strong edges</p>
</td></tr>
<tr><td><code id="cannyEdges_+3A_alpha">alpha</code></td>
<td>
<p>threshold adjusment factor (default 1)</p>
</td></tr>
<tr><td><code id="cannyEdges_+3A_sigma">sigma</code></td>
<td>
<p>smoothing</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cannyEdges(boats) %&gt;% plot
#Make thresholds less strict
cannyEdges(boats,alpha=.4) %&gt;% plot
#Make thresholds more strict
cannyEdges(boats,alpha=1.4) %&gt;% plot
</code></pre>

<hr>
<h2 id='capture.plot'>Capture the current R plot device as a cimg image</h2><span id='topic+capture.plot'></span>

<h3>Description</h3>

<p>Capture the current R plot device as a cimg image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture.plot()
</code></pre>


<h3>Value</h3>

<p>a cimg image corresponding to the contents of the current plotting window
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##interactive only:
##plot(1:10)
###Make a plot of the plot
##capture.plot() %&gt;% plot 
</code></pre>

<hr>
<h2 id='center.stencil'>Center stencil at a location</h2><span id='topic+center.stencil'></span>

<h3>Description</h3>

<p>Center stencil at a location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center.stencil(stencil, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center.stencil_+3A_stencil">stencil</code></td>
<td>
<p>a stencil (data.frame with coordinates dx,dy,dz,dc)</p>
</td></tr>
<tr><td><code id="center.stencil_+3A_...">...</code></td>
<td>
<p>centering locations (e.g. x=4,y=2)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
stencil &lt;- data.frame(dx=seq(-2,2,1),dy=seq(-2,2,1))
center.stencil(stencil,x=10,y=20)
</code></pre>

<hr>
<h2 id='channels'>Split a colour image into a list of separate channels</h2><span id='topic+channels'></span>

<h3>Description</h3>

<p>Split a colour image into a list of separate channels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>channels(im, index, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="channels_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="channels_+3A_index">index</code></td>
<td>
<p>which channels to extract (default all)</p>
</td></tr>
<tr><td><code id="channels_+3A_drop">drop</code></td>
<td>
<p>if TRUE drop extra dimensions, returning normal arrays and not cimg objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of channels
</p>


<h3>See Also</h3>

<p>frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
channels(boats)
channels(boats,1:2)
channels(boats,1:2,drop=TRUE) %&gt;% str #A list of 2D arrays
</code></pre>

<hr>
<h2 id='ci'>Concatenation for image lists</h2><span id='topic+ci'></span>

<h3>Description</h3>

<p>Allows you to concatenate image lists together, or images with image lists.
Doesn't quite work like R's &quot;c&quot; primitive: image lists are always *flat*, not nested, meaning each element of an image list is an image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_+3A_...">...</code></td>
<td>
<p>objects to concatenate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image list
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

l1 &lt;- imlist(boats,grayscale(boats))
l2 &lt;- imgradient(boats,"xy")
ci(l1,l2) #List + list
ci(l1,imfill(3,3)) #List + image
ci(imfill(3,3),l1,l2) #Three elements, etc.
</code></pre>

<hr>
<h2 id='cimg'>Create a cimg object</h2><span id='topic+cimg'></span>

<h3>Description</h3>

<p>cimg is a class for storing image or video/hyperspectral data.  It is designed to provide easy interaction with the CImg library, but in order to use it you need to be aware of how CImg wants its image data stored. 
Images have up to 4 dimensions, labelled x,y,z,c. x and y are the usual spatial dimensions, z is a depth dimension (which would correspond to time in a movie), and c is a colour dimension. Images are stored linearly in that order, starting from the top-left pixel and going along *rows* (scanline order).
A colour image is just three R,G,B channels in succession. A sequence of N images is encoded as R1,R2,....,RN,G1,...,GN,B1,...,BN where R_i is the red channel of frame i.
The number of pixels along the x,y,z, and c axes is called (in that order), width, height, depth and spectrum. 
NB: Logical and integer values are automatically converted to type double. NAs are not supported by CImg, so you should manage them on the R end of things.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cimg(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cimg_+3A_x">X</code></td>
<td>
<p>a four-dimensional numeric array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class cimg
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cimg(array(1,c(10,10,5,3)))
</code></pre>

<hr>
<h2 id='cimg.dimensions'>Image dimensions</h2><span id='topic+cimg.dimensions'></span><span id='topic+width'></span><span id='topic+height'></span><span id='topic+spectrum'></span><span id='topic+depth'></span><span id='topic+nPix'></span>

<h3>Description</h3>

<p>Image dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>width(im)

height(im)

spectrum(im)

depth(im)

nPix(im)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cimg.dimensions_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>width()</code>: Width of the image (in pixels)
</p>
</li>
<li> <p><code>height()</code>: Height of the image (in pixels)
</p>
</li>
<li> <p><code>spectrum()</code>: Number of colour channels
</p>
</li>
<li> <p><code>depth()</code>: Depth of the image/number of frames in a video
</p>
</li>
<li> <p><code>nPix()</code>: Total number of pixels (prod(dim(im)))
</p>
</li></ul>

<hr>
<h2 id='cimg.extract'>Various shortcuts for extracting colour channels, frames, etc</h2><span id='topic+cimg.extract'></span><span id='topic+frame'></span><span id='topic+imcol'></span><span id='topic+imrow'></span><span id='topic+channel'></span><span id='topic+R'></span><span id='topic+G'></span><span id='topic+B'></span>

<h3>Description</h3>

<p>Various shortcuts for extracting colour channels, frames, etc
</p>
<p>Extract one frame out of a 4D image/video
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frame(im, index)

imcol(im, x)

imrow(im, y)

channel(im, ind)

R(im)

G(im)

B(im)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cimg.extract_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="cimg.extract_+3A_index">index</code></td>
<td>
<p>frame index</p>
</td></tr>
<tr><td><code id="cimg.extract_+3A_x">x</code></td>
<td>
<p>x coordinate of the row</p>
</td></tr>
<tr><td><code id="cimg.extract_+3A_y">y</code></td>
<td>
<p>y coordinate of the row</p>
</td></tr>
<tr><td><code id="cimg.extract_+3A_ind">ind</code></td>
<td>
<p>channel index</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>frame()</code>: Extract frame
</p>
</li>
<li> <p><code>imcol()</code>: Extract a particular column from an image
</p>
</li>
<li> <p><code>imrow()</code>: Extract a particular row from an image
</p>
</li>
<li> <p><code>channel()</code>: Extract an image channel
</p>
</li>
<li> <p><code>R()</code>: Extract red channel
</p>
</li>
<li> <p><code>G()</code>: Extract green channel
</p>
</li>
<li> <p><code>B()</code>: Extract blue channel
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Extract the red channel from the boats image, then the first row, plot
rw &lt;- R(boats) %&gt;% imrow(10)
plot(rw,type="l",xlab="x",ylab="Pixel value")
#Note that R(boats) returns an image
R(boats)
#while imrow returns a vector or a list
R(boats) %&gt;% imrow(1) %&gt;% str
imrow(boats,1) %&gt;% str

</code></pre>

<hr>
<h2 id='cimg.openmp'>Control CImg's parallelisation</h2><span id='topic+cimg.openmp'></span><span id='topic+cimg.use.openmp'></span><span id='topic+cimg.limit.openmp'></span>

<h3>Description</h3>

<p>On supported architectures CImg can parallelise many operations using OpenMP (e.g. <code><a href="#topic+imager.combine">imager.combine</a></code>). Use this function to turn parallelisation on or off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cimg.use.openmp(mode = "adaptive", nthreads = 1, verbose = FALSE)

cimg.limit.openmp()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cimg.openmp_+3A_mode">mode</code></td>
<td>
<p>Either &quot;adaptive&quot;,&quot;always&quot; or &quot;none&quot;. The default is adaptive (parallelisation for large images only).</p>
</td></tr>
<tr><td><code id="cimg.openmp_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of OpenMP threads that imager should use. The default is 1. Set to 0 to get no more than 2, based on OpenMP environment variables.</p>
</td></tr>
<tr><td><code id="cimg.openmp_+3A_verbose">verbose</code></td>
<td>
<p>Whether to output information about the threads being set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You need to be careful that <span class="option">nthreads</span> is not higher than the value in the system environment variable OMP_THREAD_LIMIT (this can be checked with Sys.getenv('OMP_THREAD_LIMIT')). The OMP_THREAD_LIMIT thread limit usually needs to be correctly set before launching R, so using Sys.setenv once a session has started is not certain to work.
</p>


<h3>Value</h3>

<p>NULL (function is used for side effects)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cimg.limit.openmp()</code>: Limit OpenMP thread count to no more than 2, based on OpenMP environment variables.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cimg.use.openmp("never") #turn off parallelisation
</code></pre>

<hr>
<h2 id='cimg2im'>Convert cimg to spatstat im object</h2><span id='topic+cimg2im'></span>

<h3>Description</h3>

<p>The spatstat library uses a different format for images, which have class &quot;im&quot;. This utility converts a cimg object to an im object. spatstat im objects are limited to 2D grayscale images, so if the image has depth or spectrum &gt; 1 a list is returned for the separate frames or channels (or both, in which case a list of lists is returned, with frames at the higher level and channels at the lower one).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cimg2im(img, W = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cimg2im_+3A_img">img</code></td>
<td>
<p>an image of class cimg</p>
</td></tr>
<tr><td><code id="cimg2im_+3A_w">W</code></td>
<td>
<p>a spatial window (see spatstat doc). Default NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class im, or a list of objects of class im, or a list of lists of objects of class im
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>im, as.im
</p>

<hr>
<h2 id='circles'>Add circles to plot</h2><span id='topic+circles'></span>

<h3>Description</h3>

<p>Base R has a function for plotting circles called &quot;symbols&quot;. Unfortunately, the size of the circles is inconsistent across devices. This function plots circles whose radius is specified in used coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circles(x, y, radius, bg = NULL, fg = "white", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circles_+3A_x">x</code></td>
<td>
<p>centers (x coordinate)</p>
</td></tr>
<tr><td><code id="circles_+3A_y">y</code></td>
<td>
<p>centers (y coordinate)</p>
</td></tr>
<tr><td><code id="circles_+3A_radius">radius</code></td>
<td>
<p>radius (in user coordinates)</p>
</td></tr>
<tr><td><code id="circles_+3A_bg">bg</code></td>
<td>
<p>background colour</p>
</td></tr>
<tr><td><code id="circles_+3A_fg">fg</code></td>
<td>
<p>foreground colour</p>
</td></tr>
<tr><td><code id="circles_+3A_...">...</code></td>
<td>
<p>passed to polygon, e.g. lwd</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none, used for side effect
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>hough_circle
</p>

<hr>
<h2 id='clean'>Clean up and fill in pixel sets (morphological opening and closing)</h2><span id='topic+clean'></span><span id='topic+fill'></span>

<h3>Description</h3>

<p>Cleaning up a pixel set here means removing small isolated elements (speckle). Filling in means removing holes.
Cleaning up can be achieved by shrinking the set (removing speckle), followed by growing it back up. Filling in can be achieved by growing the set (removing holes), and shrinking it again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean(px, ...)

fill(px, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_+3A_px">px</code></td>
<td>
<p>a pixset</p>
</td></tr>
<tr><td><code id="clean_+3A_...">...</code></td>
<td>
<p>parameters that define the structuring element to use, passed on to &quot;grow&quot; and &quot;shrink&quot;</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>fill()</code>: Fill in holes using morphological closing
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- load.example("birds") %&gt;% grayscale
sub &lt;- imsub(-im,y&gt; 380) %&gt;% threshold("85%")
plot(sub)
#Turn into a pixel set
px &lt;- sub==1
layout(t(1:2))
plot(px,main="Before clean-up")
clean(px,3) %&gt;% plot(main="After clean-up")
#Now fill in the holes
px &lt;- clean(px,3)
plot(px,main="Before filling-in")
fill(px,28) %&gt;% plot(main="After filling-in")
</code></pre>

<hr>
<h2 id='colorise'>Fill in a colour in an area given by a pixset</h2><span id='topic+colorise'></span>

<h3>Description</h3>

<p>Paint all pixels in pixset px with the same colour
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorise(im, px, col, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorise_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="colorise_+3A_px">px</code></td>
<td>
<p>either a pixset or a formula, as in imeval.</p>
</td></tr>
<tr><td><code id="colorise_+3A_col">col</code></td>
<td>
<p>colour to fill in. either a vector of numeric values or a string (e.g. &quot;red&quot;)</p>
</td></tr>
<tr><td><code id="colorise_+3A_alpha">alpha</code></td>
<td>
<p>transparency (default 1, no transparency)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- load.example("coins")
colorise(im,Xc(im) &lt; 50,"blue") %&gt;% plot
#Same thing with the formula interface
colorise(im,~ x &lt; 50,"blue") %&gt;% plot
#Add transparency
colorise(im,~ x &lt; 50,"blue",alpha=.5) %&gt;% plot
#Highlight pixels with low luminance values
colorise(im,~ . &lt; 0.3,"blue",alpha=.2) %&gt;% plot
</code></pre>

<hr>
<h2 id='common_pixsets'>Various useful pixsets</h2><span id='topic+common_pixsets'></span><span id='topic+px.circle'></span><span id='topic+px.diamond'></span><span id='topic+px.square'></span><span id='topic+px.left'></span><span id='topic+px.top'></span><span id='topic+px.bottom'></span><span id='topic+px.right'></span><span id='topic+px.borders'></span><span id='topic+px.all'></span><span id='topic+px.none'></span>

<h3>Description</h3>

<p>These functions define some commonly used pixsets.
px.left gives the left-most pixels of an image, px.right the right-most, etc.
px.circle returns an (approximately) circular pixset of radius r, embedded in an image of width x and height y
Mathematically speaking, the set of all pixels whose L2 distance to the center equals r or less.
px.diamond is similar but returns a diamond (L1 distance less than r)
px.square is also similar but returns a square (Linf distance less than r)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>px.circle(r, x = 2 * r + 1, y = 2 * r + 1)

px.diamond(r, x = 2 * r + 1, y = 2 * r + 1)

px.square(r, x = 2 * r + 1, y = 2 * r + 1)

px.left(im, n = 1)

px.top(im, n = 1)

px.bottom(im, n = 1)

px.right(im, n = 1)

px.borders(im, n = 1)

px.all(im)

px.none(im)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="common_pixsets_+3A_r">r</code></td>
<td>
<p>radius (in pixels)</p>
</td></tr>
<tr><td><code id="common_pixsets_+3A_x">x</code></td>
<td>
<p>width (default 2*r+1)</p>
</td></tr>
<tr><td><code id="common_pixsets_+3A_y">y</code></td>
<td>
<p>height (default 2*r+1)</p>
</td></tr>
<tr><td><code id="common_pixsets_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="common_pixsets_+3A_n">n</code></td>
<td>
<p>number of pixels to include</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pixset
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>px.circle()</code>: A circular-shaped pixset
</p>
</li>
<li> <p><code>px.diamond()</code>: A diamond-shaped pixset
</p>
</li>
<li> <p><code>px.square()</code>: A square-shaped pixset
</p>
</li>
<li> <p><code>px.left()</code>: n left-most pixels (left-hand border)
</p>
</li>
<li> <p><code>px.top()</code>: n top-most pixels
</p>
</li>
<li> <p><code>px.bottom()</code>: n bottom-most pixels
</p>
</li>
<li> <p><code>px.right()</code>: n right-most pixels
</p>
</li>
<li> <p><code>px.borders()</code>: image borders (to depth n)
</p>
</li>
<li> <p><code>px.all()</code>: all pixels in image
</p>
</li>
<li> <p><code>px.none()</code>: no pixel in image
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
px.circle(20,350,350) %&gt;% plot(interp=FALSE)
px.circle(3) %&gt;% plot(interp=FALSE)
r &lt;- 5
layout(t(1:3))
plot(px.circle(r,20,20))
plot(px.square(r,20,20))
plot(px.diamond(r,20,20))
#These pixsets are useful as structuring elements
px &lt;- grayscale(boats) &gt; .8
grow(px,px.circle(5)) %&gt;% plot
#The following functions select pixels on the left, right, bottom, top of the image
im &lt;- imfill(10,10)
px.left(im,3) %&gt;% plot(int=FALSE)
px.right(im,1) %&gt;% plot(int=FALSE)
px.top(im,4) %&gt;% plot(int=FALSE)
px.bottom(im,2) %&gt;% plot(int=FALSE)
#All of the above
px.borders(im,1) %&gt;% plot(int=FALSE)
</code></pre>

<hr>
<h2 id='contours'>Return contours of image/pixset</h2><span id='topic+contours'></span>

<h3>Description</h3>

<p>This is just a light interface over contourLines. See help for contourLines for details.
If the image has more than one colour channel, return a list with the contour lines in each channel.
Does not work on 3D images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contours(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contours_+3A_x">x</code></td>
<td>
<p>an image or pixset</p>
</td></tr>
<tr><td><code id="contours_+3A_nlevels">nlevels</code></td>
<td>
<p>number of contour levels. For pixsets this can only equal two.</p>
</td></tr>
<tr><td><code id="contours_+3A_...">...</code></td>
<td>
<p>extra parameters passed to contourLines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of contours
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>highlight
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
boats.gs &lt;- grayscale(boats)
ct &lt;- contours(boats.gs,nlevels=3)
plot(boats.gs)
#Add contour lines
purrr::walk(ct,function(v) lines(v$x,v$y,col="red"))
#Contours of a pixel set
px &lt;- boats.gs &gt; .8
plot(boats.gs)
ct &lt;- contours(px)
#Highlight pixset
purrr::walk(ct,function(v) lines(v$x,v$y,col="red"))
</code></pre>

<hr>
<h2 id='coord.index'>Coordinates from pixel index</h2><span id='topic+coord.index'></span>

<h3>Description</h3>

<p>Compute (x,y,z,cc) coordinates from linear pixel index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord.index(im, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord.index_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="coord.index_+3A_index">index</code></td>
<td>
<p>a vector of indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of coordinate values
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>index.coord for the reverse operation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cind &lt;- coord.index(boats,33)
#Returns (x,y,z,c) coordinates of the 33rd pixel in the array
cind
all.equal(boats[33],with(cind,at(boats,x,y,z,cc)))
all.equal(33,index.coord(boats,cind))
</code></pre>

<hr>
<h2 id='correlate'>Correlation/convolution of image by filter</h2><span id='topic+correlate'></span><span id='topic+convolve'></span>

<h3>Description</h3>

<p>The correlation of image im by filter flt is defined as:
<code class="reqn">res(x,y,z) = sum_{i,j,k} im(x + i,y + j,z + k)*flt(i,j,k).</code>
The convolution of an image img by filter flt is defined to be:
<code class="reqn">res(x,y,z) = sum_{i,j,k} img(x-i,y-j,z-k)*flt(i,j,k)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlate(im, filter, dirichlet = TRUE, normalise = FALSE)

convolve(im, filter, dirichlet = TRUE, normalise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlate_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="correlate_+3A_filter">filter</code></td>
<td>
<p>the correlation kernel.</p>
</td></tr>
<tr><td><code id="correlate_+3A_dirichlet">dirichlet</code></td>
<td>
<p>boundary condition. Dirichlet if true, Neumann if false (default TRUE, Dirichlet)</p>
</td></tr>
<tr><td><code id="correlate_+3A_normalise">normalise</code></td>
<td>
<p>compute a normalised correlation (ie. local cosine similarity)</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>convolve()</code>: convolve image with filter
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
#Edge filter
filter &lt;- as.cimg(function(x,y) sign(x-5),10,10) 
layout(t(1:2))
#Convolution vs. correlation 
correlate(boats,filter) %&gt;% plot(main="Correlation")
convolve(boats,filter) %&gt;% plot(main="Convolution")
</code></pre>

<hr>
<h2 id='crop.borders'>Crop the outer margins of an image</h2><span id='topic+crop.borders'></span>

<h3>Description</h3>

<p>This function crops pixels on each side of an image. This function is a kind of inverse (centred) padding, and is useful e.g. when you want to get only the valid part of a convolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop.borders(im, nx = 0, ny = 0, nz = 0, nPix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop.borders_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="crop.borders_+3A_nx">nx</code></td>
<td>
<p>number of pixels to crop along horizontal axis</p>
</td></tr>
<tr><td><code id="crop.borders_+3A_ny">ny</code></td>
<td>
<p>number of pixels to crop along vertical axis</p>
</td></tr>
<tr><td><code id="crop.borders_+3A_nz">nz</code></td>
<td>
<p>number of pixels to crop along depth axis</p>
</td></tr>
<tr><td><code id="crop.borders_+3A_npix">nPix</code></td>
<td>
<p>optional: crop the same number of pixels along all dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#These two versions are equivalent
imfill(10,10) %&gt;% crop.borders(nx=1,ny=1)
imfill(10,10) %&gt;% crop.borders(nPix=1)

#Filter, keep valid part
correlate(boats,imfill(3,3)) %&gt;% crop.borders(nPix=2)
</code></pre>

<hr>
<h2 id='deriche'>Apply recursive Deriche filter.</h2><span id='topic+deriche'></span>

<h3>Description</h3>

<p>The Deriche filter is a fast approximation to a Gaussian filter (order = 0), or Gaussian derivatives (order = 1 or 2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriche(im, sigma, order = 0L, axis = "x", neumann = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriche_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="deriche_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the filter.</p>
</td></tr>
<tr><td><code id="deriche_+3A_order">order</code></td>
<td>
<p>Order of the filter. 0 for a smoothing filter, 1 for first-derivative, 2 for second.</p>
</td></tr>
<tr><td><code id="deriche_+3A_axis">axis</code></td>
<td>
<p>Axis along which the filter is computed ( 'x' , 'y', 'z' or 'c').</p>
</td></tr>
<tr><td><code id="deriche_+3A_neumann">neumann</code></td>
<td>
<p>If true, use Neumann boundary conditions (default false, Dirichlet)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
deriche(boats,sigma=2,order=0) %&gt;% plot("Zeroth-order Deriche along x")
deriche(boats,sigma=2,order=1) %&gt;% plot("First-order Deriche along x")
deriche(boats,sigma=2,order=1) %&gt;% plot("Second-order Deriche along x")
deriche(boats,sigma=2,order=1,axis="y") %&gt;% plot("Second-order Deriche along y")
</code></pre>

<hr>
<h2 id='diffusion_tensors'>Compute field of diffusion tensors for edge-preserving smoothing.</h2><span id='topic+diffusion_tensors'></span>

<h3>Description</h3>

<p>Compute field of diffusion tensors for edge-preserving smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffusion_tensors(
  im,
  sharpness = 0.7,
  anisotropy = 0.6,
  alpha = 0.6,
  sigma = 1.1,
  is_sqrt = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffusion_tensors_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="diffusion_tensors_+3A_sharpness">sharpness</code></td>
<td>
<p>Sharpness</p>
</td></tr>
<tr><td><code id="diffusion_tensors_+3A_anisotropy">anisotropy</code></td>
<td>
<p>Anisotropy</p>
</td></tr>
<tr><td><code id="diffusion_tensors_+3A_alpha">alpha</code></td>
<td>
<p>Standard deviation of the gradient blur.</p>
</td></tr>
<tr><td><code id="diffusion_tensors_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the structure tensor blur.</p>
</td></tr>
<tr><td><code id="diffusion_tensors_+3A_is_sqrt">is_sqrt</code></td>
<td>
<p>Tells if the square root of the tensor field is computed instead.</p>
</td></tr>
</table>

<hr>
<h2 id='displacement'>Estimate displacement field between two images.</h2><span id='topic+displacement'></span>

<h3>Description</h3>

<p>Estimate displacement field between two images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displacement(
  sourceIm,
  destIm,
  smoothness = 0.1,
  precision = 5,
  nb_scales = 0L,
  iteration_max = 10000L,
  is_backward = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="displacement_+3A_sourceim">sourceIm</code></td>
<td>
<p>Reference image.</p>
</td></tr>
<tr><td><code id="displacement_+3A_destim">destIm</code></td>
<td>
<p>Reference image.</p>
</td></tr>
<tr><td><code id="displacement_+3A_smoothness">smoothness</code></td>
<td>
<p>Smoothness of estimated displacement field.</p>
</td></tr>
<tr><td><code id="displacement_+3A_precision">precision</code></td>
<td>
<p>Precision required for algorithm convergence.</p>
</td></tr>
<tr><td><code id="displacement_+3A_nb_scales">nb_scales</code></td>
<td>
<p>Number of scales used to estimate the displacement field.</p>
</td></tr>
<tr><td><code id="displacement_+3A_iteration_max">iteration_max</code></td>
<td>
<p>Maximum number of iterations allowed for one scale.</p>
</td></tr>
<tr><td><code id="displacement_+3A_is_backward">is_backward</code></td>
<td>
<p>If false, match I2(X + U(X)) = I1(X), else match I2(X) = I1(X - U(X)).</p>
</td></tr>
</table>

<hr>
<h2 id='display'>Display object using CImg library</h2><span id='topic+display'></span>

<h3>Description</h3>

<p>CImg has its own functions for fast, interactive image plotting. Use this if you get frustrated with slow rendering in RStudio. Note that you need X11 library to use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_+3A_x">x</code></td>
<td>
<p>an image or a list of images</p>
</td></tr>
<tr><td><code id="display_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>display.cimg, display.imlist
</p>

<hr>
<h2 id='display.cimg'>Display image using CImg library</h2><span id='topic+display.cimg'></span>

<h3>Description</h3>

<p>Press escape or close the window to exit. Note that you need X11 library to use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cimg'
display(x, ..., rescale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.cimg_+3A_x">x</code></td>
<td>
<p>an image (cimg object)</p>
</td></tr>
<tr><td><code id="display.cimg_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="display.cimg_+3A_rescale">rescale</code></td>
<td>
<p>if true pixel values are rescaled to [0-1] (default TRUE)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
##Not run: interactive only 
##display(boats,TRUE) #Normalisation on 
##display(boats/2,TRUE) #Normalisation on, so same as above
##display(boats,FALSE) #Normalisation off
##display(boats/2,FALSE) #Normalisation off, so different from above
</code></pre>

<hr>
<h2 id='display.list'>Display image list using CImg library</h2><span id='topic+display.list'></span>

<h3>Description</h3>

<p>Click on individual images to zoom in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
display(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.list_+3A_x">x</code></td>
<td>
<p>a list of cimg objects</p>
</td></tr>
<tr><td><code id="display.list_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
##Not run: interactive only 
## imgradient(boats,"xy") %&gt;% display
</code></pre>

<hr>
<h2 id='distance_transform'>Compute Euclidean distance function to a specified value.</h2><span id='topic+distance_transform'></span>

<h3>Description</h3>

<p>The distance transform implementation has been submitted by A. Meijster, and implements
the article 'W.H. Hesselink, A. Meijster, J.B.T.M. Roerdink,
&quot;A general algorithm for computing distance transforms in linear time.&quot;,
In: Mathematical Morphology and its Applications to Image and Signal Processing,
J. Goutsias, L. Vincent, and D.S. Bloomberg (eds.), Kluwer, 2000, pp. 331-340.'
The submitted code has then been modified to fit CImg coding style and constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_transform(im, value, metric = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_transform_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="distance_transform_+3A_value">value</code></td>
<td>
<p>Reference value.</p>
</td></tr>
<tr><td><code id="distance_transform_+3A_metric">metric</code></td>
<td>
<p>Type of metric. Can be 0=Chebyshev | 1=Manhattan | 2=Euclidean | 3=Squared-euclidean.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
imd &lt;- function(x,y) imdirac(c(100,100,1,1),x,y)
#Image is three white dots
im &lt;- imd(20,20)+imd(40,40)+imd(80,80)
plot(im)
#How far are we from the nearest white dot? 
distance_transform(im,1) %&gt;% plot
</code></pre>

<hr>
<h2 id='draw_circle'>Draw circle on image</h2><span id='topic+draw_circle'></span>

<h3>Description</h3>

<p>Add circle or circles to an image. Like other native CImg drawing functions, this is meant to be basic but fast. Use implot for flexible drawing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_circle(im, x, y, radius, color = "white", opacity = 1, filled = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_circle_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="draw_circle_+3A_x">x</code></td>
<td>
<p>x coordinates</p>
</td></tr>
<tr><td><code id="draw_circle_+3A_y">y</code></td>
<td>
<p>y coordinates</p>
</td></tr>
<tr><td><code id="draw_circle_+3A_radius">radius</code></td>
<td>
<p>radius (either a single value or a vector of length equal to length(x))</p>
</td></tr>
<tr><td><code id="draw_circle_+3A_color">color</code></td>
<td>
<p>either a string (&quot;red&quot;), a character vector of length equal to x, or a matrix of dimension length(x) times spectrum(im)</p>
</td></tr>
<tr><td><code id="draw_circle_+3A_opacity">opacity</code></td>
<td>
<p>scalar or vector of length equal to length(x). 0: transparent 1: opaque.</p>
</td></tr>
<tr><td><code id="draw_circle_+3A_filled">filled</code></td>
<td>
<p>fill circle (default TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>implot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
draw_circle(boats,c(50,100),c(150,200),30,"darkgreen") %&gt;% plot
draw_circle(boats,125,60,radius=30,col=c(0,1,0),opacity=.2,filled=TRUE) %&gt;% plot
</code></pre>

<hr>
<h2 id='draw_rect'>Draw rectangle on image</h2><span id='topic+draw_rect'></span>

<h3>Description</h3>

<p>Add a rectangle to an image. Like other native CImg drawing functions, this is meant to be basic but fast. Use implot for flexible drawing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_rect(im, x0, y0, x1, y1, color = "white", opacity = 1, filled = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_rect_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="draw_rect_+3A_x0">x0</code></td>
<td>
<p>x coordinate of the bottom-left corner</p>
</td></tr>
<tr><td><code id="draw_rect_+3A_y0">y0</code></td>
<td>
<p>y coordinate  of the bottom-left corner</p>
</td></tr>
<tr><td><code id="draw_rect_+3A_x1">x1</code></td>
<td>
<p>x coordinate of the top-right corner</p>
</td></tr>
<tr><td><code id="draw_rect_+3A_y1">y1</code></td>
<td>
<p>y coordinate  of the top-right corner</p>
</td></tr>
<tr><td><code id="draw_rect_+3A_color">color</code></td>
<td>
<p>either a vector, or a string (e.g. &quot;blue&quot;)</p>
</td></tr>
<tr><td><code id="draw_rect_+3A_opacity">opacity</code></td>
<td>
<p>0: transparent 1: opaque.</p>
</td></tr>
<tr><td><code id="draw_rect_+3A_filled">filled</code></td>
<td>
<p>fill rectangle (default TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>implot,draw_circle
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
draw_rect(boats,1,1,50,50,"darkgreen") %&gt;% plot
</code></pre>

<hr>
<h2 id='draw_text'>Draw text on an image</h2><span id='topic+draw_text'></span>

<h3>Description</h3>

<p>Like other native CImg drawing functions, this is meant to be basic but fast. Use implot for flexible drawing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_text(im, x, y, text, color, opacity = 1, fsize = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_text_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="draw_text_+3A_x">x</code></td>
<td>
<p>x coord.</p>
</td></tr>
<tr><td><code id="draw_text_+3A_y">y</code></td>
<td>
<p>y coord.</p>
</td></tr>
<tr><td><code id="draw_text_+3A_text">text</code></td>
<td>
<p>text to draw (a string)</p>
</td></tr>
<tr><td><code id="draw_text_+3A_color">color</code></td>
<td>
<p>either a vector or a string (e.g. &quot;red&quot;)</p>
</td></tr>
<tr><td><code id="draw_text_+3A_opacity">opacity</code></td>
<td>
<p>0: transparent 1: opaque.</p>
</td></tr>
<tr><td><code id="draw_text_+3A_fsize">fsize</code></td>
<td>
<p>font size (in pix., default 20)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>implot,draw_circle,draw_rect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
draw_text(boats,100,100,"Some text",col="black") %&gt;% plot
</code></pre>

<hr>
<h2 id='erode'>Erode/dilate image by a structuring element.</h2><span id='topic+erode'></span><span id='topic+erode_rect'></span><span id='topic+erode_square'></span><span id='topic+dilate'></span><span id='topic+dilate_rect'></span><span id='topic+dilate_square'></span><span id='topic+mopening'></span><span id='topic+mopening_square'></span><span id='topic+mclosing_square'></span><span id='topic+mclosing'></span>

<h3>Description</h3>

<p>Erode/dilate image by a structuring element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erode(im, mask, boundary_conditions = TRUE, real_mode = FALSE)

erode_rect(im, sx, sy, sz = 1L)

erode_square(im, size)

dilate(im, mask, boundary_conditions = TRUE, real_mode = FALSE)

dilate_rect(im, sx, sy, sz = 1L)

dilate_square(im, size)

mopening(im, mask, boundary_conditions = TRUE, real_mode = FALSE)

mopening_square(im, size)

mclosing_square(im, size)

mclosing(im, mask, boundary_conditions = TRUE, real_mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erode_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="erode_+3A_mask">mask</code></td>
<td>
<p>Structuring element.</p>
</td></tr>
<tr><td><code id="erode_+3A_boundary_conditions">boundary_conditions</code></td>
<td>
<p>Boundary conditions. If FALSE, pixels beyond image boundaries are considered to be 0, if TRUE one. Default: TRUE.</p>
</td></tr>
<tr><td><code id="erode_+3A_real_mode">real_mode</code></td>
<td>
<p>If TRUE, perform erosion as defined on the reals. If FALSE, perform binary erosion (default FALSE).</p>
</td></tr>
<tr><td><code id="erode_+3A_sx">sx</code></td>
<td>
<p>Width of the structuring element.</p>
</td></tr>
<tr><td><code id="erode_+3A_sy">sy</code></td>
<td>
<p>Height of the structuring element.</p>
</td></tr>
<tr><td><code id="erode_+3A_sz">sz</code></td>
<td>
<p>Depth of the structuring element.</p>
</td></tr>
<tr><td><code id="erode_+3A_size">size</code></td>
<td>
<p>size of the structuring element.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>erode_rect()</code>: Erode image by a rectangular structuring element of specified size.
</p>
</li>
<li> <p><code>erode_square()</code>: Erode image by a square structuring element of specified size.
</p>
</li>
<li> <p><code>dilate()</code>: Dilate image by a structuring element.
</p>
</li>
<li> <p><code>dilate_rect()</code>: Dilate image by a rectangular structuring element of specified size
</p>
</li>
<li> <p><code>dilate_square()</code>: Dilate image by a square structuring element of specified size
</p>
</li>
<li> <p><code>mopening()</code>: Morphological opening (erosion followed by dilation)
</p>
</li>
<li> <p><code>mopening_square()</code>: Morphological opening by a square element (erosion followed by dilation)
</p>
</li>
<li> <p><code>mclosing_square()</code>: Morphological closing by a square element (dilation followed by erosion)
</p>
</li>
<li> <p><code>mclosing()</code>: Morphological closing (dilation followed by erosion)
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
fname &lt;- system.file('extdata/Leonardo_Birds.jpg',package='imager')
im &lt;- load.image(fname) %&gt;% grayscale
outline &lt;- threshold(-im,"95%")
plot(outline)
mask &lt;- imfill(5,10,val=1) #Rectangular mask
plot(erode(outline,mask))
plot(erode_rect(outline,5,10)) #Same thing
plot(erode_square(outline,5)) 
plot(dilate(outline,mask))
plot(dilate_rect(outline,5,10))
plot(dilate_square(outline,5)) 
</code></pre>

<hr>
<h2 id='extract_patches'>Extract image patches and return a list</h2><span id='topic+extract_patches'></span><span id='topic+extract_patches3D'></span>

<h3>Description</h3>

<p>Patches are rectangular (cubic) image regions centered at cx,cy (cz) with width wx and height wy (opt. depth wz)
WARNINGS: 
- values outside of the image region are subject to boundary conditions. The default is to set them to 0 (Dirichlet), other boundary conditions are listed below. 
- widths and heights should be odd integers (they're rounded up otherwise).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_patches(im, cx, cy, wx, wy, boundary_conditions = 0L)

extract_patches3D(im, cx, cy, cz, wx, wy, wz, boundary_conditions = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_patches_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="extract_patches_+3A_cx">cx</code></td>
<td>
<p>vector of x coordinates for patch centers</p>
</td></tr>
<tr><td><code id="extract_patches_+3A_cy">cy</code></td>
<td>
<p>vector of y coordinates for patch centers</p>
</td></tr>
<tr><td><code id="extract_patches_+3A_wx">wx</code></td>
<td>
<p>vector of patch widths (or single value)</p>
</td></tr>
<tr><td><code id="extract_patches_+3A_wy">wy</code></td>
<td>
<p>vector of patch heights (or single value)</p>
</td></tr>
<tr><td><code id="extract_patches_+3A_boundary_conditions">boundary_conditions</code></td>
<td>
<p>integer. Can be 0 (Dirichlet, default), 1 (Neumann) 2 (Periodic) 3 (mirror).</p>
</td></tr>
<tr><td><code id="extract_patches_+3A_cz">cz</code></td>
<td>
<p>vector of z coordinates for patch centers</p>
</td></tr>
<tr><td><code id="extract_patches_+3A_wz">wz</code></td>
<td>
<p>vector of coordinates for patch depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of image patches (cimg objects)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>extract_patches3D()</code>: Extract 3D patches
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
#2 patches of size 5x5 located at (10,10) and (10,20)
extract_patches(boats,c(10,10),c(10,20),5,5)
</code></pre>

<hr>
<h2 id='FFT'>Compute the Discrete Fourier Transform of an image</h2><span id='topic+FFT'></span>

<h3>Description</h3>

<p>This function is equivalent to R's builtin fft, up to normalisation (R's version is unnormalised, this one is). It calls CImg's implementation.
Important note: FFT will compute a multidimensional Fast Fourier Transform, using as many dimensions as you have in the image, meaning that if you have a colour video, it will perform a 4D FFT. If you want to compute separate FFTs across channels, use imsplit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FFT(im.real, im.imag, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FFT_+3A_im.real">im.real</code></td>
<td>
<p>The real part of the input (an image)</p>
</td></tr>
<tr><td><code id="FFT_+3A_im.imag">im.imag</code></td>
<td>
<p>The imaginary part (also an image. If missing, assume the signal is real).</p>
</td></tr>
<tr><td><code id="FFT_+3A_inverse">inverse</code></td>
<td>
<p>If true compute the inverse FFT (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components &quot;real&quot; (an image) and &quot;imag&quot; (an image), corresponding to the real and imaginary parts of the transform
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

im &lt;- as.cimg(function(x,y) sin(x/5)+cos(x/4)*sin(y/2),128,128)
ff &lt;- FFT(im)
plot(ff$real,main="Real part of the transform")
plot(ff$imag,main="Imaginary part of the transform")
sqrt(ff$real^2+ff$imag^2) %&gt;% plot(main="Power spectrum")
#Check that we do get our image back
check &lt;- FFT(ff$real,ff$imag,inverse=TRUE)$real #Should be the same as original
mean((check-im)^2)

</code></pre>

<hr>
<h2 id='flatten.alpha'>Flatten alpha channel</h2><span id='topic+flatten.alpha'></span>

<h3>Description</h3>

<p>Flatten alpha channel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten.alpha(im, bg = "white")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten.alpha_+3A_im">im</code></td>
<td>
<p>an image (with 4 RGBA colour channels)</p>
</td></tr>
<tr><td><code id="flatten.alpha_+3A_bg">bg</code></td>
<td>
<p>background: either an RGB image, or a vector of colour values, or a string (e.g. &quot;blue&quot;). Default: white background.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a blended image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>rm.alpha
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Add alpha channel
alpha &lt;- Xc(grayscale(boats))/width(boats)
boats.a &lt;- imlist(boats,alpha) %&gt;% imappend("c")
flatten.alpha(boats.a) %&gt;% plot
flatten.alpha(boats.a,"darkgreen") %&gt;% plot
</code></pre>

<hr>
<h2 id='frames'>Split a video into separate frames</h2><span id='topic+frames'></span>

<h3>Description</h3>

<p>Split a video into separate frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frames(im, index, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frames_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="frames_+3A_index">index</code></td>
<td>
<p>which channels to extract (default all)</p>
</td></tr>
<tr><td><code id="frames_+3A_drop">drop</code></td>
<td>
<p>if TRUE drop extra dimensions, returning normal arrays and not cimg objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of frames
</p>


<h3>See Also</h3>

<p>channels
</p>

<hr>
<h2 id='get_gradient'>Compute image gradient.</h2><span id='topic+get_gradient'></span>

<h3>Description</h3>

<p>Compute image gradient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_gradient(im, axes = "", scheme = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_gradient_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="get_gradient_+3A_axes">axes</code></td>
<td>
<p>Axes considered for the gradient computation, as a C-string (e.g &quot;xy&quot;).</p>
</td></tr>
<tr><td><code id="get_gradient_+3A_scheme">scheme</code></td>
<td>
<p>= Numerical scheme used for the gradient computation:
1 = Backward finite differences
0 = Centered finite differences
1 = Forward finite differences
2 = Using Sobel masks
3 = Using rotation invariant masks
4 = Using Deriche recursive filter.
5 = Using Van Vliet recursive filter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of images (corresponding to the different directions)
</p>


<h3>See Also</h3>

<p>imgradient
</p>

<hr>
<h2 id='get_hessian'>Return image hessian.</h2><span id='topic+get_hessian'></span>

<h3>Description</h3>

<p>Return image hessian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hessian(im, axes = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_hessian_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="get_hessian_+3A_axes">axes</code></td>
<td>
<p>Axes considered for the hessian computation, as a character string (e.g &quot;xy&quot;).</p>
</td></tr>
</table>

<hr>
<h2 id='get.locations'>Return coordinates of subset of pixels</h2><span id='topic+get.locations'></span>

<h3>Description</h3>

<p>Typical use case: you want the coordinates of all pixels with a value above a certain threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.locations(im, condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.locations_+3A_im">im</code></td>
<td>
<p>the image</p>
</td></tr>
<tr><td><code id="get.locations_+3A_condition">condition</code></td>
<td>
<p>a function that takes scalars and returns logicals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coordinates of all pixels such that condition(pixel) == TRUE
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- as.cimg(function(x,y) x+y,10,10)
get.locations(im,function(v) v &lt; 4)
get.locations(im,function(v) v^2 + 3*v - 2 &lt; 30)

</code></pre>

<hr>
<h2 id='get.stencil'>Return pixel values in a neighbourhood defined by a stencil</h2><span id='topic+get.stencil'></span>

<h3>Description</h3>

<p>A stencil defines a neighbourhood in an image (for example, the four nearest neighbours in a 2d image). This function centers the stencil at a certain pixel and returns the values of the neighbourhing pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.stencil(im, stencil, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.stencil_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="get.stencil_+3A_stencil">stencil</code></td>
<td>
<p>a data.frame with values dx,dy,[dz],[dcc] defining the neighbourhood</p>
</td></tr>
<tr><td><code id="get.stencil_+3A_...">...</code></td>
<td>
<p>where to center, e.g. x = 100,y = 10,z=3,cc=1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pixel values in neighbourhood
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#The following stencil defines a neighbourhood that
#includes the next pixel to the left (delta_x = -1) and the next pixel to the right (delta_x = 1)
stencil &lt;- data.frame(dx=c(-1,1),dy=c(0,0))
im &lt;- as.cimg(function(x,y) x+y,w=100,h=100)
get.stencil(im,stencil,x=50,y=50)

#A larger neighbourhood that includes pixels upwards and
#downwards of center (delta_y = -1 and +1)
stencil &lt;- stencil.cross()
im &lt;- as.cimg(function(x,y) x,w=100,h=100)
get.stencil(im,stencil,x=5,y=50)
</code></pre>

<hr>
<h2 id='grab'>Select image regions interactively</h2><span id='topic+grab'></span><span id='topic+grabLine'></span><span id='topic+grabRect'></span><span id='topic+grabPoint'></span>

<h3>Description</h3>

<p>These functions let you select a shape in an image (a point, a line, or a rectangle)
They either return the coordinates of the shape (default), or the contents.
In case of lines contents are interpolated. Note that grabLine does not support the &quot;pixset&quot; return type. 
Note that you need X11 library to use these functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabLine(im, output = "coord")

grabRect(im, output = "coord")

grabPoint(im, output = "coord")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grab_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="grab_+3A_output">output</code></td>
<td>
<p>one of &quot;im&quot;,&quot;pixset&quot;,&quot;coord&quot;,&quot;value&quot;. Default &quot;coord&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of the output parameter. Either a vector of coordinates (output = &quot;coord&quot;), an image (output = &quot;im&quot;), a pixset (output = &quot;pixset&quot;), or a vector of values (output = &quot;value&quot;). grabLine and grabPoint support the &quot;value&quot; output mode and not the &quot;im&quot; output.
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>display
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Not run: interactive only 
##grabRect(boats)
##grabRect(boats,TRUE)
</code></pre>

<hr>
<h2 id='grayscale'>Convert an RGB image to grayscale</h2><span id='topic+grayscale'></span>

<h3>Description</h3>

<p>This function converts from RGB images to grayscale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grayscale(im, method = "Luma", drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grayscale_+3A_im">im</code></td>
<td>
<p>an RGB image</p>
</td></tr>
<tr><td><code id="grayscale_+3A_method">method</code></td>
<td>
<p>either &quot;Luma&quot;, in which case a linear approximation to luminance is used, or &quot;XYZ&quot;, in which case the image is assumed to be in sRGB color space and CIE luminance is used.</p>
</td></tr>
<tr><td><code id="grayscale_+3A_drop">drop</code></td>
<td>
<p>if TRUE returns an image with a single channel, otherwise keep the three channels (default TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a grayscale image (spectrum == 1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grayscale(boats) %&gt;% plot
#In many pictures, the difference between Luma and XYZ conversion is subtle 
grayscale(boats,method="XYZ") %&gt;% plot
grayscale(boats,method="XYZ",drop=FALSE) %&gt;% dim
</code></pre>

<hr>
<h2 id='grow'>Grow/shrink a pixel set</h2><span id='topic+grow'></span><span id='topic+shrink'></span>

<h3>Description</h3>

<p>Grow/shrink a pixel set through morphological dilation/erosion. The default is to use square or rectangular structuring elements, but an arbitrary structuring element can be given as input. 
A structuring element is a pattern to be moved over the image: for example a 3x3 square. In &quot;shrink&quot; mode, a element of the pixset is retained only if and only the structuring element fits entirely within the pixset. In &quot;grow&quot; mode, the structuring element acts like a neighbourhood: all pixels that are in the original pixset *or* in the neighbourhood defined by the structuring element belong the new pixset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow(px, x, y = x, z = x, boundary = TRUE)

shrink(px, x, y = x, z = x, boundary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_+3A_px">px</code></td>
<td>
<p>a pixset</p>
</td></tr>
<tr><td><code id="grow_+3A_x">x</code></td>
<td>
<p>either an integer value, or an image/pixel set.</p>
</td></tr>
<tr><td><code id="grow_+3A_y">y</code></td>
<td>
<p>width of the rectangular structuring element (if x is an integer value)</p>
</td></tr>
<tr><td><code id="grow_+3A_z">z</code></td>
<td>
<p>depth of the rectangular structuring element (if x is an integer value)</p>
</td></tr>
<tr><td><code id="grow_+3A_boundary">boundary</code></td>
<td>
<p>are pixels beyond the boundary considered to have value TRUE or FALSE (default TRUE)</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>shrink()</code>: shrink pixset using erosion
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
#A pixel set:
a &lt;- grayscale(boats) &gt; .8
plot(a)
#Grow by a 8x8 square
grow(a,8) %&gt;% plot
#Grow by a 8x2 rectangle
grow(a,8,2) %&gt;% plot
#Custom structuring element
el &lt;- matrix(1,2,2) %&gt;% as.cimg
all.equal(grow(a,el),grow(a,2))
#Circular structuring element
px.circle(5) %&gt;% grow(a,.) %&gt;% plot

#Sometimes boundary conditions matter
im &lt;- imfill(10,10)
px &lt;- px.all(im)
shrink(px,3,bound=TRUE) %&gt;% plot(main="Boundary conditions: TRUE")
shrink(px,3,bound=FALSE) %&gt;% plot(main="Boundary conditions: FALSE")
</code></pre>

<hr>
<h2 id='gsdim'>Grayscale dimensions of image</h2><span id='topic+gsdim'></span>

<h3>Description</h3>

<p>Shortcut, returns the dimensions of an image if it had only one colour channel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsdim(im)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsdim_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns c(dim(im)[1:3],1)
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
imnoise(dim=gsdim(boats))
</code></pre>

<hr>
<h2 id='haar'>Compute Haar multiscale wavelet transform.</h2><span id='topic+haar'></span>

<h3>Description</h3>

<p>Compute Haar multiscale wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haar(im, inverse = FALSE, nb_scales = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haar_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="haar_+3A_inverse">inverse</code></td>
<td>
<p>Compute inverse transform (default FALSE)</p>
</td></tr>
<tr><td><code id="haar_+3A_nb_scales">nb_scales</code></td>
<td>
<p>Number of scales used for the transform.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Image compression: set small Haar coefficients to 0
hr &lt;- haar(boats,nb=3) 
mask.low &lt;- threshold(abs(hr),"75%")
mask.high &lt;- threshold(abs(hr),"95%")
haar(hr*mask.low,inverse=TRUE,nb=3) %&gt;% plot(main="75% compression")
haar(hr*mask.high,inverse=TRUE,nb=3) %&gt;% plot(main="95% compression")
</code></pre>

<hr>
<h2 id='highlight'>Highlight pixel set on image</h2><span id='topic+highlight'></span>

<h3>Description</h3>

<p>Overlay an image plot with the contours of a pixel set. Note that this function doesn't do the image plotting, just the highlighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlight(px, col = "red", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="highlight_+3A_px">px</code></td>
<td>
<p>a pixel set</p>
</td></tr>
<tr><td><code id="highlight_+3A_col">col</code></td>
<td>
<p>color of the contours</p>
</td></tr>
<tr><td><code id="highlight_+3A_...">...</code></td>
<td>
<p>passed to the &quot;lines&quot; function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>colorise, another way of highlighting stuff
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Select similar pixels around point (180,200)
px &lt;- px.flood(boats,180,200,sigma=.08)
plot(boats)
#Highlight selected set
highlight(px)
px.flood(boats,18,50,sigma=.08) %&gt;% highlight(col="white",lwd=3)
</code></pre>

<hr>
<h2 id='hough_circle'>Circle detection using Hough transform</h2><span id='topic+hough_circle'></span>

<h3>Description</h3>

<p>Detects circles of known radius in a pixset. The output is an image where the pixel value at (x,y) represents the amount of evidence for the presence of a circle of radius r at position (x,y). 
NB: in the current implementation, does not detect circles centred outside the limits of the pixset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hough_circle(px, radius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hough_circle_+3A_px">px</code></td>
<td>
<p>a pixset (e.g., the output of a Canny detector)</p>
</td></tr>
<tr><td><code id="hough_circle_+3A_radius">radius</code></td>
<td>
<p>radius of circle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a histogram of Hough scores, with the same dimension as the original image.
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- load.example('coins')
px &lt;- cannyEdges(im)
#Find circles of radius 20
hc &lt;- hough_circle(px,20)
plot(hc)
#Clean up, run non-maxima suppression
nms &lt;- function(im,sigma) { im[dilate_square(im,sigma) != im] &lt;- 0; im}
hc.clean &lt;- isoblur(hc,3) %&gt;% nms(50)
#Top ten matches
df &lt;- as.data.frame(hc.clean) %&gt;%
dplyr::arrange(desc(value)) %&gt;% head(10)
with(df,circles(x,y,20,fg="red",lwd=3))
</code></pre>

<hr>
<h2 id='hough_line'>Hough transform for lines</h2><span id='topic+hough_line'></span>

<h3>Description</h3>

<p>Two algorithms are used, depending on the input: if the input is a pixset then the classical Hough transform is used. If the input is an image, then a faster gradient-based heuristic is used. 
The method returns either an image (the votes), or a data.frame. In both cases the parameterisation used is the Hesse normal form (theta,rho), where a line is represented as the set of values such that cos(theta)*x + sin(theta)*y = rho. Here theta is an angle and rho is a distance.
The image form returns a histogram of scores in (rho,theta) space, where good candidates for lines have high scores. The data.frame form may be more convenient for further processing in R: each line represents a pair (rho,theta) along with its score. 
If the 'shift' argument is true, then the image is assumed to start at x=1,y=1 (more convenient for plotting in R). If false, the image begins at x=0,y=0 and in both cases the origin is at the top left.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hough_line(im, ntheta = 100, data.frame = FALSE, shift = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hough_line_+3A_im">im</code></td>
<td>
<p>an image or pixset</p>
</td></tr>
<tr><td><code id="hough_line_+3A_ntheta">ntheta</code></td>
<td>
<p>number of bins along theta (default 100)</p>
</td></tr>
<tr><td><code id="hough_line_+3A_data.frame">data.frame</code></td>
<td>
<p>return a data.frame? (default FALSE)</p>
</td></tr>
<tr><td><code id="hough_line_+3A_shift">shift</code></td>
<td>
<p>if TRUE, image is considered to begin at (x=1,y=1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either an image or a data.frame
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Find the lines along the boundary of a square
px &lt;- px.square(30,80,80) %&gt;% boundary
plot(px)
#Hough transform
hough_line(px,ntheta=200) %&gt;% plot

df &lt;- hough_line(px,ntheta=800,data.frame=TRUE)
#Plot lines with the highest score
plot(px)
with(subset(df,score &gt; quantile(score,.9995)),nfline(theta,rho,col="red"))

plot(boats)
df &lt;- hough_line(boats,ntheta=800,data=TRUE)
</code></pre>

<hr>
<h2 id='idply'>Split an image along axis, map function, return a data.frame</h2><span id='topic+idply'></span>

<h3>Description</h3>

<p>Shorthand for imsplit followed by purrr::map_df
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idply(im, axis, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idply_+3A_im">im</code></td>
<td>
<p>image</p>
</td></tr>
<tr><td><code id="idply_+3A_axis">axis</code></td>
<td>
<p>axis for the split (e.g &quot;c&quot;)</p>
</td></tr>
<tr><td><code id="idply_+3A_fun">fun</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="idply_+3A_...">...</code></td>
<td>
<p>extra arguments to function fun</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
idply(boats,"c",mean) #mean luminance per colour channel
</code></pre>

<hr>
<h2 id='iiply'>Split an image, apply function, recombine the results as an image</h2><span id='topic+iiply'></span>

<h3>Description</h3>

<p>This is just imsplit followed by purrr::map followed by imappend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iiply(im, axis, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iiply_+3A_im">im</code></td>
<td>
<p>image</p>
</td></tr>
<tr><td><code id="iiply_+3A_axis">axis</code></td>
<td>
<p>axis for the split (e.g &quot;c&quot;)</p>
</td></tr>
<tr><td><code id="iiply_+3A_fun">fun</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="iiply_+3A_...">...</code></td>
<td>
<p>extra arguments to function fun</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
##' #Normalise colour channels separately, recombine
iiply(boats,"c",function(v) (v-mean(v))/sd(v)) %&gt;% plot 

</code></pre>

<hr>
<h2 id='ilply'>Split an image along axis, apply function, return a list</h2><span id='topic+ilply'></span>

<h3>Description</h3>

<p>Shorthand for imsplit followed by purrr::map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ilply(im, axis, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ilply_+3A_im">im</code></td>
<td>
<p>image</p>
</td></tr>
<tr><td><code id="ilply_+3A_axis">axis</code></td>
<td>
<p>axis for the split (e.g &quot;c&quot;)</p>
</td></tr>
<tr><td><code id="ilply_+3A_fun">fun</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="ilply_+3A_...">...</code></td>
<td>
<p>extra arguments for function fun</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
parrots &lt;- load.example("parrots")
ilply(parrots,"c",mean) #mean luminance per colour channel
</code></pre>

<hr>
<h2 id='im_split'>Split an image along a certain axis (producing a list)</h2><span id='topic+im_split'></span>

<h3>Description</h3>

<p>Split an image along a certain axis (producing a list)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>im_split(im, axis, nb = -1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="im_split_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="im_split_+3A_axis">axis</code></td>
<td>
<p>the axis along which to split (for example 'c')</p>
</td></tr>
<tr><td><code id="im_split_+3A_nb">nb</code></td>
<td>
<p>number of objects to split into. 
if nb=-1 (the default) the maximum number of splits is used ie. split(im,&quot;c&quot;) produces a list containing all individual colour channels</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>imappend (the reverse operation)
</p>

<hr>
<h2 id='imager.combine'>Combining images</h2><span id='topic+imager.combine'></span><span id='topic+add'></span><span id='topic+wsum'></span><span id='topic+average'></span><span id='topic+mult'></span><span id='topic+parmax'></span><span id='topic+parmax.abs'></span><span id='topic+parmin.abs'></span><span id='topic+parmin'></span><span id='topic+enorm'></span><span id='topic+parmed'></span><span id='topic+parquan'></span><span id='topic+parvar'></span><span id='topic+parsd'></span><span id='topic+parall'></span><span id='topic+parany'></span><span id='topic+equal'></span><span id='topic+which.parmax'></span><span id='topic+which.parmin'></span><span id='topic+parsort'></span><span id='topic+parorder'></span><span id='topic+parrank'></span>

<h3>Description</h3>

<p>These functions take a list of images and combine them by adding, multiplying, taking the parallel min or max, etc.
The max. in absolute value of (x1,x2) is defined as x1 if (|x1| &gt; |x2|), x2 otherwise. It's useful for example in getting the most extreme value while keeping the sign. 
&quot;parsort&quot;,&quot;parrank&quot; and &quot;parorder&quot; aren't really reductions because they return a list of the same size. They perform a pixel-wise sort (resp. order and rank) across the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add(x, na.rm = FALSE)

wsum(x, w, na.rm = FALSE)

average(x, na.rm = FALSE)

mult(x, na.rm = FALSE)

parmax(x, na.rm = FALSE)

parmax.abs(x)

parmin.abs(x)

parmin(x, na.rm = FALSE)

enorm(x)

parmed(x, na.rm = FALSE)

parquan(x, prob = 0.5, na.rm = FALSE)

parvar(x, na.rm = FALSE)

parsd(x, na.rm = FALSE)

parall(x)

parany(x)

equal(x)

which.parmax(x)

which.parmin(x)

parsort(x, increasing = TRUE)

parorder(x, increasing = TRUE)

parrank(x, increasing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imager.combine_+3A_x">x</code></td>
<td>
<p>a list of images</p>
</td></tr>
<tr><td><code id="imager.combine_+3A_na.rm">na.rm</code></td>
<td>
<p>ignore NAs (default FALSE)</p>
</td></tr>
<tr><td><code id="imager.combine_+3A_w">w</code></td>
<td>
<p>weights (must be the same length as the list)</p>
</td></tr>
<tr><td><code id="imager.combine_+3A_prob">prob</code></td>
<td>
<p>probability level for parquan, default of 0.5 returns the median</p>
</td></tr>
<tr><td><code id="imager.combine_+3A_increasing">increasing</code></td>
<td>
<p>if TRUE, sort in increasing order (default TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>parvar returns an unbiased estimate of the variance (as in the base var function). parsd returns the square root of parvar. parquan returns the specified quantile, and defines this in the same manner as the default R quantile function (type = 7). Using parmed and parquan with quan = 0.5 will return the same result, but parmed will be slightly faster (but only a few percent).
</p>
<p>To correctly use multiple threads users should set <span class="option">nthreads</span> in <code><a href="#topic+cimg.use.openmp">cimg.use.openmp</a></code>. You also need to be careful that this is not higher than the value in the system environment variable OMP_THREAD_LIMIT (this can be checked with Sys.getenv('OMP_THREAD_LIMIT')). The OMP_THREAD_LIMIT thread limit usually needs to be correctly set before launching R, so using Sys.setenv once a session has started is not certain to work.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>add()</code>: Add images
</p>
</li>
<li> <p><code>wsum()</code>: Weighted sum of images
</p>
</li>
<li> <p><code>average()</code>: Average images
</p>
</li>
<li> <p><code>mult()</code>: Multiply images (pointwise)
</p>
</li>
<li> <p><code>parmax()</code>: Parallel max over images
</p>
</li>
<li> <p><code>parmax.abs()</code>: Parallel max in absolute value over images,
</p>
</li>
<li> <p><code>parmin.abs()</code>: Parallel min in absolute value over images,
</p>
</li>
<li> <p><code>parmin()</code>: Parallel min over images
</p>
</li>
<li> <p><code>enorm()</code>: Euclidean norm (i.e. sqrt(A^2 + B^2 + ...))
</p>
</li>
<li> <p><code>parmed()</code>: Parallel Median over images
</p>
</li>
<li> <p><code>parquan()</code>: Parallel Quantile over images
</p>
</li>
<li> <p><code>parvar()</code>: Variance
</p>
</li>
<li> <p><code>parsd()</code>: Std. deviation
</p>
</li>
<li> <p><code>parall()</code>: Parallel all (for pixsets)
</p>
</li>
<li> <p><code>parany()</code>: Parallel any (for pixsets)
</p>
</li>
<li> <p><code>equal()</code>: Test equality
</p>
</li>
<li> <p><code>which.parmax()</code>: index of parallel maxima
</p>
</li>
<li> <p><code>which.parmin()</code>: index of parallel minima
</p>
</li>
<li> <p><code>parsort()</code>: pixel-wise sort
</p>
</li>
<li> <p><code>parorder()</code>: pixel-wise order
</p>
</li>
<li> <p><code>parrank()</code>: pixel-wise rank
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>imsplit,Reduce
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im1 &lt;- as.cimg(function(x,y) x,50,50)
im2 &lt;- as.cimg(function(x,y) y,50,50)
im3 &lt;- as.cimg(function(x,y) cos(x/10),50,50)
l &lt;- imlist(im1,im2,im3)
add(l) %&gt;% plot #Add the images
average(l) %&gt;% plot #Average the images
mult(l) %&gt;% plot #Multiply
wsum(l,c(.1,8,.1)) %&gt;% plot #Weighted sum
parmax(l) %&gt;% plot #Parallel max
parmin(l) %&gt;% plot #Parallel min
parmed(l) %&gt;% plot #Parallel median
parsd(l) %&gt;% plot #Parallel std. dev
#parsort can also be used to produce parallel max. and min
(parsort(l)[[1]]) %&gt;% plot("Parallel min")
(parsort(l)[[length(l)]]) %&gt;% plot("Parallel max")
#Resize boats so the next examples run faster
im &lt;- imresize(boats,.5)
#Edge detection (Euclidean norm of gradient)
imgradient(im,"xy") %&gt;% enorm %&gt;% plot
#Pseudo-artistic effects
l &lt;- map_il(seq(1,35,5),~ boxblur(im,.))
parmin(l) %&gt;% plot
average(l) %&gt;% plot
mult(l) %&gt;% plot
#At each pixel, which colour channel has the maximum value?
imsplit(im,"c") %&gt;% which.parmax %&gt;% table
#Same thing using parorder (ties are broken differently)!!!
imsplit(im,"c") %&gt;% { parorder(.)[[length(.)]] } %&gt;% table
</code></pre>

<hr>
<h2 id='imager.replace'>Replace part of an image with another</h2><span id='topic+imager.replace'></span><span id='topic+channel+3C-'></span><span id='topic+R+3C-'></span><span id='topic+G+3C-'></span><span id='topic+B+3C-'></span><span id='topic+frame+3C-'></span>

<h3>Description</h3>

<p>These replacement functions let you modify part of an image (for example, only the red channel).
Note that cimg objects can also be treated as regular arrays and modified using the usual [] operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>channel(x, ind) &lt;- value

R(x) &lt;- value

G(x) &lt;- value

B(x) &lt;- value

frame(x, ind) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imager.replace_+3A_x">x</code></td>
<td>
<p>an image to be modified</p>
</td></tr>
<tr><td><code id="imager.replace_+3A_ind">ind</code></td>
<td>
<p>an index</p>
</td></tr>
<tr><td><code id="imager.replace_+3A_value">value</code></td>
<td>
<p>the image to insert</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>channel(x, ind) &lt;- value</code>: Replace image channel
</p>
</li>
<li> <p><code>R(x) &lt;- value</code>: Replace red channel
</p>
</li>
<li> <p><code>G(x) &lt;- value</code>: Replace green channel
</p>
</li>
<li> <p><code>B(x) &lt;- value</code>: Replace blue channel
</p>
</li>
<li> <p><code>frame(x, ind) &lt;- value</code>: Replace image frame
</p>
</li></ul>


<h3>See Also</h3>

<p>imdraw
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
boats.cp &lt;- boats
#Set the green channel in the boats image to 0
G(boats.cp) &lt;- 0
#Same thing, more verbose
channel(boats.cp,2) &lt;- 0
#Replace the red channel with noise
R(boats.cp) &lt;- imnoise(width(boats),height(boats))
#A new image with 5 frames
tmp &lt;- imfill(10,10,5)
#Fill the third frame with noise
frame(tmp,3) &lt;- imnoise(10,10)
</code></pre>

<hr>
<h2 id='imager.subset'>Array subset operator for cimg objects</h2><span id='topic+imager.subset'></span>

<h3>Description</h3>

<p>Internally cimg objects are 4D arrays (stored in x,y,z,c mode) but often one doesn't need all dimensions. This is the case for instance when working on grayscale images, which use only two. The array subset operator works like the regular array [] operator, but it won't force you to use all dimensions.
There are easier ways of accessing image data, for example imsub, channels, R, G, B, and the like.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="imager.subset_+3A_x">x</code></td>
<td>
<p>an image (cimg object)</p>
</td></tr>
<tr><td><code id="imager.subset_+3A_drop">drop</code></td>
<td>
<p>if true return an array, otherwise return an image object (default FALSE)</p>
</td></tr>
<tr><td><code id="imager.subset_+3A_...">...</code></td>
<td>
<p>subsetting arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>imsub, which provides a more convenient interface, autocrop, imdraw
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- imfill(4,4)
dim(im) #4 dimensional, but the last two ones are singletons
im[,1,,] &lt;- 1:4 #Assignment the standard way
im[,1] &lt;- 1:4 #Shortcut
as.matrix(im)
im[1:2,]
dim(boats)
#Arguments will be recycled, as in normal array operations
boats[1:2,1:3,] &lt;- imnoise(2,3) #The same noise array is replicated over the three channels
</code></pre>

<hr>
<h2 id='imappend'>Combine a list of images into a single image</h2><span id='topic+imappend'></span>

<h3>Description</h3>

<p>All images will be concatenated along the x,y,z, or c axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imappend(imlist, axis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imappend_+3A_imlist">imlist</code></td>
<td>
<p>a list of images (all elements must be of class cimg)</p>
</td></tr>
<tr><td><code id="imappend_+3A_axis">axis</code></td>
<td>
<p>the axis along which to concatenate (for example 'c')</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>imsplit (the reverse operation)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
imappend(list(boats,boats),"x") %&gt;% plot
imappend(list(boats,boats),"y") %&gt;% plot
purrr::map(1:3, ~imnoise(100,100)) %&gt;% imappend("c") %&gt;% plot
boats.gs &lt;- grayscale(boats)
purrr::map(seq(1,5,l=3),function(v) isoblur(boats.gs,v)) %&gt;% imappend("c") %&gt;% plot
#imappend also works on pixsets
imsplit(boats &gt; .5,"c") %&gt;% imappend("x") %&gt;% plot
</code></pre>

<hr>
<h2 id='imchange'>Modify parts of an image</h2><span id='topic+imchange'></span>

<h3>Description</h3>

<p>A shortcut for modifying parts of an image, using imeval syntax. See doc for imeval first. As part of a pipe, avoids the creating of intermediate variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imchange(obj, where, fo, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imchange_+3A_obj">obj</code></td>
<td>
<p>an image or imlist</p>
</td></tr>
<tr><td><code id="imchange_+3A_where">where</code></td>
<td>
<p>where to modify. a pixset, or a formula (in imeval syntax) that evaluates to a pixset.</p>
</td></tr>
<tr><td><code id="imchange_+3A_fo">fo</code></td>
<td>
<p>a formula (in imeval syntax) used to modify the image part</p>
</td></tr>
<tr><td><code id="imchange_+3A_env">env</code></td>
<td>
<p>evulation environment (see imeval)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>imeval
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Set border to 0:
imchange(boats,px.borders(boats,10),~ 0) %&gt;% plot
#Eq. to
im &lt;- boats
im[px.borders(im,10)] &lt;- 0
#Using formula syntax
imchange(boats,~ px.borders(.,10),~ 0)
#Replace with grayscale ramp
imchange(boats,~ px.borders(.,10),~ xs) %&gt;% plot
#Kill red channel in image
imchange(boats,~ c==1,~ 0) %&gt;% plot
#Shit hue by an amount depending on eccentricity
load.example("parrots") %&gt;%
  RGBtoHSL %&gt;%
  imchange(~ c==1,~ .+80*exp(-(rho/550)^2) ) %&gt;%
  HSLtoRGB %&gt;%
  plot

</code></pre>

<hr>
<h2 id='imcoord'>Coordinates as images</h2><span id='topic+imcoord'></span><span id='topic+Xc'></span><span id='topic+Yc'></span><span id='topic+Zc'></span><span id='topic+Cc'></span>

<h3>Description</h3>

<p>These functions return pixel coordinates for an image, as an image. All is made clear in the examples (hopefully)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xc(im)

Yc(im)

Zc(im)

Cc(im)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imcoord_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>another image of the same size, containing pixel coordinates
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Xc()</code>: X coordinates
</p>
</li>
<li> <p><code>Yc()</code>: Y coordinates
</p>
</li>
<li> <p><code>Zc()</code>: Z coordinates
</p>
</li>
<li> <p><code>Cc()</code>: C coordinates
</p>
</li></ul>


<h3>See Also</h3>

<p>as.cimg.function, pixel.grid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- imfill(5,5) #An image
Xc(im) #An image of the same size, containing the x coordinates of each pixel
Xc(im) %&gt;% imrow(1)
Yc(im) %&gt;% imrow(3) #y is constant along rows
Yc(im) %&gt;% imcol(1)
#Mask bits of the boats image:
plot(boats*(Xc(boats) &lt; 100))
plot(boats*(dnorm(Xc(boats),m=100,sd=30))) #Gaussian window
</code></pre>

<hr>
<h2 id='imdirac'>Generates a &quot;dirac&quot; image, i.e. with all values set to 0 except one.</h2><span id='topic+imdirac'></span>

<h3>Description</h3>

<p>This small utility is useful to examine the impulse response of a filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imdirac(dims, x, y, z = 1, cc = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imdirac_+3A_dims">dims</code></td>
<td>
<p>a vector of image dimensions, or an image whose dimensions will be used. If dims has length &lt; 4 some guesswork will be used (see examples and ?as.cimg.array)</p>
</td></tr>
<tr><td><code id="imdirac_+3A_x">x</code></td>
<td>
<p>where to put the dirac (x coordinate)</p>
</td></tr>
<tr><td><code id="imdirac_+3A_y">y</code></td>
<td>
<p>y coordinate</p>
</td></tr>
<tr><td><code id="imdirac_+3A_z">z</code></td>
<td>
<p>z coordinate (default 1)</p>
</td></tr>
<tr><td><code id="imdirac_+3A_cc">cc</code></td>
<td>
<p>colour coordinate (default 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Explicit settings of all dimensions
imdirac(c(50,50,1,1),20,20)
imdirac(c(50,50),20,20) #Implicit
imdirac(c(50,50,3),20,20,cc=2) #RGB
imdirac(c(50,50,7),20,20,z=2) #50x50 video with 7 frames
#Impulse response of the blur filter
imdirac(c(50,50),20,20) %&gt;% isoblur(sigma=2)  %&gt;% plot
#Impulse response of the first-order Deriche filter
imdirac(c(50,50),20,20) %&gt;% deriche(sigma=2,order=1,axis="x")  %&gt;% plot
##NOT RUN, interactive only
##Impulse response of the blur filter in space-time
##resp &lt;- imdirac(c(50,50,100),x=25,y=25,z=50)  %&gt;%  isoblur(16)
###Normalise to 0...255 and play as video
##renorm(resp) %&gt;% play(normalise=FALSE)
</code></pre>

<hr>
<h2 id='imdraw'>Draw image on another image</h2><span id='topic+imdraw'></span>

<h3>Description</h3>

<p>Draw image on another image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imdraw(im, sprite, x = 1, y = 1, z = 1, opacity = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imdraw_+3A_im">im</code></td>
<td>
<p>background image</p>
</td></tr>
<tr><td><code id="imdraw_+3A_sprite">sprite</code></td>
<td>
<p>sprite to draw on background image</p>
</td></tr>
<tr><td><code id="imdraw_+3A_x">x</code></td>
<td>
<p>location</p>
</td></tr>
<tr><td><code id="imdraw_+3A_y">y</code></td>
<td>
<p>location</p>
</td></tr>
<tr><td><code id="imdraw_+3A_z">z</code></td>
<td>
<p>location</p>
</td></tr>
<tr><td><code id="imdraw_+3A_opacity">opacity</code></td>
<td>
<p>transparency level (default 1)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>imager.combine, for different ways of combining images
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- load.example("parrots")
boats.small &lt;- imresize(boats,.5)
#I'm aware the result is somewhat ugly
imdraw(im,boats.small,x=400,y=10,opacity=.7) %&gt;% plot
</code></pre>

<hr>
<h2 id='imeval'>Evaluation in an image context</h2><span id='topic+imeval'></span><span id='topic+imdo'></span>

<h3>Description</h3>

<p>imeval does for images what &quot;with&quot; does for data.frames, namely contextual evaluation. It provides various shortcuts for pixel-wise operations.
imdo runs imeval, and reshapes the output as an image of the same dimensions as the input (useful for functions that return vectors).
imeval takes inspiration from purrr::map in using formulas for defining anonymous functions using the &quot;.&quot; argument.
Usage is made clear (hopefully) in the examples.
The old version of imeval used CImg's internal math parser, but has been retired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imeval(obj, ..., env = parent.frame())

imdo(obj, form)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imeval_+3A_obj">obj</code></td>
<td>
<p>an image, pixset or imlist</p>
</td></tr>
<tr><td><code id="imeval_+3A_...">...</code></td>
<td>
<p>one or more formula objects, defining anonymous functions that will be evaluated with the image as first argument (with extra contextual variables added to the evaluation context)</p>
</td></tr>
<tr><td><code id="imeval_+3A_env">env</code></td>
<td>
<p>additional variables (defaults to the calling environment)</p>
</td></tr>
<tr><td><code id="imeval_+3A_form">form</code></td>
<td>
<p>a single formula</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>imdo()</code>: run imeval and reshape
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>imchange, which modifies specific parts of an image
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Computing mean absolute deviation
imeval(boats, ~ mean(abs(.-median(.))))
##Equivalent to:
mean(abs(boats-median(boats)))
##Two statistics
imeval(boats,mad=  ~ mean(abs(.-median(.))),sd=  ~ sd(.))
##imeval can precompute certain quantities, like the x or y coord. of each pixel
imeval(boats,~ x) %&gt;% plot
##same as Xc(boats) %&gt;% plot
## Other predefined quantities:
##w is width, h is height
imeval(boats,~ x/w) %&gt;% range
##It defines certain transformed coordinate systems:
##Scaled x,y,z
## xs=x/w
## ys=y/h
##Select upper-left quadrant (returns a pixset)
imeval(boats,~ xs&lt;.5 &amp; ys &lt; .5) %&gt;% plot
##Fade effect
imeval(boats,~ xs*.) %&gt;% plot
## xc and yc are another set of transformed coordinates
## where xc=0,yc=0 is the image center
imeval(boats,~ (abs(xc)/w)*.) %&gt;% plot

##rho, theta: circular coordinates. rho is distance to center (in pix.), theta angle
##Gaussian mask with sd 10 pix.
blank &lt;- imfill(30,30)
imeval(blank,~ dnorm(rho,sd=w/3)) %&gt;% plot(int=FALSE)
imeval(blank,~ theta) %&gt;% plot
##imeval is made for interactive use, meaning it
##accesses the environment it got called from, e.g. this works: 
f &lt;- function()
{
  im1 &lt;- imfill(3,3,val=1)
   im2 &lt;- imfill(3,3,val=3)

  imeval(im1,~ .+im2)
}
f()
##imeval accepts lists as well 
map_il(1:3, ~ isoblur(boats,.)) %&gt;%
   imeval(~ xs*.) %&gt;%
   plot

##imeval is useful for defining pixsets:
##here, all central pixels that have value under the median
grayscale(boats) %&gt;%
    imeval(~ (. &gt; median(.)) &amp; rho &lt; 150) %&gt;%
    plot
##other abbreviations are defined:
##s for imshift, b for isoblur, rot for imrotate.
##e.g.
imeval(boats, ~ .*s(.,3)) %&gt;% plot


#The rank function outputs a vector
grayscale(boats) %&gt;% rank %&gt;% class
#Auto-reshape into an image
grayscale(boats)  %&gt;% imdo(~ rank(.)) %&gt;% plot
#Note that the above performs histogram normalisation

#Also works on lists
imsplit(boats,"c") %&gt;% imdo( ~ rank(.)) %&gt;% imappend("c") %&gt;% plot
</code></pre>

<hr>
<h2 id='imfill'>Create an image of custom size by filling in repeated values</h2><span id='topic+imfill'></span>

<h3>Description</h3>

<p>This is a convenience function for quickly creating blank images, or images filled with a specific colour. See examples.
If val is a logical value, creates a pixset instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imfill(x = 1, y = 1, z = 1, val = 0, dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imfill_+3A_x">x</code></td>
<td>
<p>width (default 1)</p>
</td></tr>
<tr><td><code id="imfill_+3A_y">y</code></td>
<td>
<p>height (default 1)</p>
</td></tr>
<tr><td><code id="imfill_+3A_z">z</code></td>
<td>
<p>depth (default 1)</p>
</td></tr>
<tr><td><code id="imfill_+3A_val">val</code></td>
<td>
<p>fill-in values. Either a single value (for grayscale), or RGB values for colour, or a character string for a colour (e.g. &quot;blue&quot;)</p>
</td></tr>
<tr><td><code id="imfill_+3A_dim">dim</code></td>
<td>
<p>dimension vector (optional, alternative to specifying x,y,z)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image object (class cimg)
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

imfill(20,20) %&gt;% plot #Blank image of size 20x20
imfill(20,20,val=c(1,0,0)) %&gt;% plot #All red image
imfill(20,20,val="red") %&gt;% plot #Same, using R colour name
imfill(3,3,val=FALSE) #Pixset
imfill(dim=dim(boats)) #Blank image of the same size as the boats image
</code></pre>

<hr>
<h2 id='imgradient'>Compute image gradient</h2><span id='topic+imgradient'></span>

<h3>Description</h3>

<p>Light interface for get_gradient. Refer to get_gradient for details on the computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imgradient(im, axes = "xy", scheme = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imgradient_+3A_im">im</code></td>
<td>
<p>an image of class cimg</p>
</td></tr>
<tr><td><code id="imgradient_+3A_axes">axes</code></td>
<td>
<p>direction along which to compute the gradient. Either a single character (e.g. &quot;x&quot;), or multiple characters (e.g. &quot;xyz&quot;). Default: &quot;xy&quot;</p>
</td></tr>
<tr><td><code id="imgradient_+3A_scheme">scheme</code></td>
<td>
<p>numerical scheme (default '3', rotation invariant)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image or a list of images, depending on the value of &quot;axes&quot;
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grayscale(boats) %&gt;% imgradient("x") %&gt;% plot
imgradient(boats,"xy") #Returns a list
</code></pre>

<hr>
<h2 id='imhessian'>Compute image hessian.</h2><span id='topic+imhessian'></span>

<h3>Description</h3>

<p>Compute image hessian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imhessian(im, axes = c("xx", "xy", "yy"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imhessian_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="imhessian_+3A_axes">axes</code></td>
<td>
<p>Axes considered for the hessian computation, as a character string (e.g &quot;xy&quot; corresponds to d/(dx*dy)). Can be a list of axes. Default: xx,xy,yy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image, or a list of images
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
imhessian(boats,"xy") %&gt;% plot(main="Second-derivative, d/(dx*dy)")
</code></pre>

<hr>
<h2 id='iminfo'>Return information on image file</h2><span id='topic+iminfo'></span>

<h3>Description</h3>

<p>This function calls ImageMagick's &quot;identify&quot; utility on an image file to get some information. You need ImageMagick on your path for this to work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iminfo(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iminfo_+3A_fname">fname</code></td>
<td>
<p>path to a file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with fields name, format, width (pix.), height (pix.), size (bytes)
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
someFiles &lt;- dir("*.png") #Find all PNGs in directory
iminfo(someFiles[1])
#Get info on all files, as a data frame
info &lt;- purrr::map_df(someFiles,function(v) iminfo(v) %&gt;% as.data.frame)

## End(Not run)
</code></pre>

<hr>
<h2 id='imlap'>Compute image Laplacian</h2><span id='topic+imlap'></span>

<h3>Description</h3>

<p>The Laplacian is the sum of second derivatives, approximated here using finite differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imlap(im)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imlap_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
imlap(boats) %&gt;% plot
</code></pre>

<hr>
<h2 id='imlist'>Image list</h2><span id='topic+imlist'></span>

<h3>Description</h3>

<p>An imlist object is simply a list of images (of class cimg). For convenience, some generic functions are defined that wouldn't work on plain lists, like plot, display and as.data.frame
DEPRECATION NOTE: in v0.30 of imager, the original behaviour of the &quot;imlist&quot; function was to take a list and turn it into an image list. This behaviour has now been changed to make &quot;imlist&quot; be more like &quot;list&quot;. If you wish to turn a list into an image list, use as.imlist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imlist(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imlist_+3A_...">...</code></td>
<td>
<p>images to be included in the image list</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>plot.imlist, display.imlist, as.data.frame.imlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
imlist(a=imfill(3,3),b=imfill(10,10)) 
imsplit(boats,"x",6) 
imsplit(boats,"x",6) %&gt;% plot
</code></pre>

<hr>
<h2 id='imnoise'>Generate (Gaussian) white-noise image</h2><span id='topic+imnoise'></span>

<h3>Description</h3>

<p>A white-noise image is an image where all pixel values are drawn IID from a certain distribution. Here they are drawn from a Gaussian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imnoise(x = 1, y = 1, z = 1, cc = 1, mean = 0, sd = 1, dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imnoise_+3A_x">x</code></td>
<td>
<p>width</p>
</td></tr>
<tr><td><code id="imnoise_+3A_y">y</code></td>
<td>
<p>height</p>
</td></tr>
<tr><td><code id="imnoise_+3A_z">z</code></td>
<td>
<p>depth</p>
</td></tr>
<tr><td><code id="imnoise_+3A_cc">cc</code></td>
<td>
<p>spectrum</p>
</td></tr>
<tr><td><code id="imnoise_+3A_mean">mean</code></td>
<td>
<p>mean pixel value (default 0)</p>
</td></tr>
<tr><td><code id="imnoise_+3A_sd">sd</code></td>
<td>
<p>std. deviation of pixel values (default 1)</p>
</td></tr>
<tr><td><code id="imnoise_+3A_dim">dim</code></td>
<td>
<p>dimension vector (optional, alternative to specifying x,y,z,cc)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cimg object
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
imnoise(100,100,cc=3) %&gt;% plot(main="White noise in RGB")
imnoise(100,100,cc=3) %&gt;% isoblur(5) %&gt;% plot(main="Filtered (non-white) noise")
imnoise(dim=dim(boats)) #Noise image of the same size as the boats image
</code></pre>

<hr>
<h2 id='implot'>Plot objects on image using base graphics</h2><span id='topic+implot'></span>

<h3>Description</h3>

<p>This function lets you use an image as a canvas for base graphics, meaning you can use R functions like &quot;text&quot; and &quot;points&quot; to plot things on an image.
The function takes as argument an image and an expression, executes the expression with the image as canvas, and outputs the result as an image (of the same size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>implot(im, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="implot_+3A_im">im</code></td>
<td>
<p>an image (class cimg)</p>
</td></tr>
<tr><td><code id="implot_+3A_expr">expr</code></td>
<td>
<p>an expression (graphics code to execute)</p>
</td></tr>
<tr><td><code id="implot_+3A_...">...</code></td>
<td>
<p>passed on to plot.cimg, to control the initial rendering of the image (for example the colorscale)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>plot, capture.plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
b.new &lt;- implot(boats,text(150,50,"Boats!!!",cex=3))
plot(b.new)
#Draw a line on a white background
bg &lt;- imfill(150,150,val=1)
implot(bg,lines(c(50,50),c(50,100),col="red",lwd=4))%&gt;%plot
#You can change the rendering of the initial image
im &lt;- grayscale(boats)
draw.fun &lt;- function() text(150,50,"Boats!!!",cex=3)
out &lt;- implot(im,draw.fun(),colorscale=function(v) rgb(0,v,v),rescale=FALSE)
plot(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='imrep'>Replicate images</h2><span id='topic+imrep'></span>

<h3>Description</h3>

<p>Kinda like rep, for images. Copy image n times and (optionally), append.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imrep(x, n = 1, axis = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imrep_+3A_x">x</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="imrep_+3A_n">n</code></td>
<td>
<p>number of replications</p>
</td></tr>
<tr><td><code id="imrep_+3A_axis">axis</code></td>
<td>
<p>axis to append along (one of NULL, &quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;c&quot;). Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either an image or an image list
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Result is a list
imrep(boats,3) %&gt;% plot
#Result is an image 
imrep(boats,3,"x") %&gt;% plot
#Make an animation by repeating each frame 10x
#map_il(1:5,~ isoblur(boats,.) %&gt;% imrep(10,"z")) %&gt;%
#                       imappend("z") %&gt;% play
</code></pre>

<hr>
<h2 id='imrotate'>Rotate an image along the XY plane.</h2><span id='topic+imrotate'></span>

<h3>Description</h3>

<p>If cx and cy aren't given, the default is to centre the rotation in the middle of the image. When cx and cy are given, the algorithm used is different, and does not change the size of the image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imrotate(im, angle, cx, cy, interpolation = 1L, boundary = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imrotate_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="imrotate_+3A_angle">angle</code></td>
<td>
<p>Rotation angle, in degrees.</p>
</td></tr>
<tr><td><code id="imrotate_+3A_cx">cx</code></td>
<td>
<p>Center of rotation along x (default, image centre)</p>
</td></tr>
<tr><td><code id="imrotate_+3A_cy">cy</code></td>
<td>
<p>Center of rotation along y (default, image centre)</p>
</td></tr>
<tr><td><code id="imrotate_+3A_interpolation">interpolation</code></td>
<td>
<p>Type of interpolation. One of 0=nearest,1=linear,2=cubic.</p>
</td></tr>
<tr><td><code id="imrotate_+3A_boundary">boundary</code></td>
<td>
<p>Boundary conditions. One of 0=dirichlet, 1=neumann, 2=periodic</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>imwarp, for flexible image warping, which includes rotations as a special case
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
imrotate(boats,30) %&gt;% plot
#Shift centre to (20,20)
imrotate(boats,30,cx=20,cy=20) %&gt;% plot 
</code></pre>

<hr>
<h2 id='imsharpen'>Sharpen image.</h2><span id='topic+imsharpen'></span>

<h3>Description</h3>

<p>The default sharpening filter is inverse diffusion. The &quot;shock filter&quot; is a non-linear diffusion that has better edge-preserving properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imsharpen(im, amplitude, type = "diffusion", edge = 1, alpha = 0, sigma = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imsharpen_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="imsharpen_+3A_amplitude">amplitude</code></td>
<td>
<p>Sharpening amplitude (positive scalar, 0: no filtering).</p>
</td></tr>
<tr><td><code id="imsharpen_+3A_type">type</code></td>
<td>
<p>Filtering type. &quot;diffusion&quot; (default) or &quot;shock&quot;</p>
</td></tr>
<tr><td><code id="imsharpen_+3A_edge">edge</code></td>
<td>
<p>Edge threshold (shock filters only, positive scalar, default 1).</p>
</td></tr>
<tr><td><code id="imsharpen_+3A_alpha">alpha</code></td>
<td>
<p>Window size for initial blur (shock filters only, positive scalar, default 0).</p>
</td></tr>
<tr><td><code id="imsharpen_+3A_sigma">sigma</code></td>
<td>
<p>Window size for diffusion tensor blur (shock filters only, positive scalar, default 0).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
layout(t(1:2))
plot(boats,main="Original")
imsharpen(boats,150)  %&gt;% plot(main="Sharpened")
</code></pre>

<hr>
<h2 id='imshift'>Shift image content.</h2><span id='topic+imshift'></span>

<h3>Description</h3>

<p>Shift image content.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imshift(
  im,
  delta_x = 0L,
  delta_y = 0L,
  delta_z = 0L,
  delta_c = 0L,
  boundary_conditions = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imshift_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="imshift_+3A_delta_x">delta_x</code></td>
<td>
<p>Amount of displacement along the X-axis.</p>
</td></tr>
<tr><td><code id="imshift_+3A_delta_y">delta_y</code></td>
<td>
<p>Amount of displacement along the Y-axis.</p>
</td></tr>
<tr><td><code id="imshift_+3A_delta_z">delta_z</code></td>
<td>
<p>Amount of displacement along the Z-axis.</p>
</td></tr>
<tr><td><code id="imshift_+3A_delta_c">delta_c</code></td>
<td>
<p>Amount of displacement along the C-axis.</p>
</td></tr>
<tr><td><code id="imshift_+3A_boundary_conditions">boundary_conditions</code></td>
<td>
<p>can be:
- 0: Zero border condition (Dirichlet).
- 1: Nearest neighbors (Neumann).
- 2: Repeat Pattern (Fourier style).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
imshift(boats,10,50) %&gt;% plot
</code></pre>

<hr>
<h2 id='imsplit'>Split an image along a certain axis (producing a list)</h2><span id='topic+imsplit'></span>

<h3>Description</h3>

<p>Use this if you need to process colour channels separately, or frames separately, or rows separately, etc. You can also use it to chop up an image into blocks.
Returns an &quot;imlist&quot; object, which is essentially a souped-up list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imsplit(im, axis, nb = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imsplit_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="imsplit_+3A_axis">axis</code></td>
<td>
<p>the axis along which to split (for example 'c')</p>
</td></tr>
<tr><td><code id="imsplit_+3A_nb">nb</code></td>
<td>
<p>number of objects to split into. 
if nb=-1 (the default) the maximum number of splits is used, i.e. split(im,&quot;c&quot;) produces a list containing all individual colour channels.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>imappend (the reverse operation)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- as.cimg(function(x,y,z) x+y+z,10,10,5)
imsplit(im,"z") #Split along the z axis into a list with 5 elements
imsplit(im,"z",2) #Split along the z axis into two groups
imsplit(boats,"x",-200) %&gt;% plot #Blocks of 200 pix. along x
imsplit(im,"z",2) %&gt;% imappend("z") #Split and reshape into a single image
#You can also split pixsets
imsplit(boats &gt; .5,"c") %&gt;% plot
</code></pre>

<hr>
<h2 id='imsub'>Select part of an image</h2><span id='topic+imsub'></span><span id='topic+subim'></span>

<h3>Description</h3>

<p>imsub selects an image part based on coordinates: it allows you to select a subset of rows, columns, frames etc. Refer to the examples to see how it works
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imsub(im, ...)

subim(im, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imsub_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="imsub_+3A_...">...</code></td>
<td>
<p>various conditions defining a rectangular image region</p>
</td></tr>
</table>


<h3>Details</h3>

<p>subim is an alias defined for backward-compatibility.
</p>


<h3>Value</h3>

<p>an image with some parts cut out
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>subim()</code>: alias for imsub
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
parrots &lt;- load.example("parrots")
imsub(parrots,x &lt; 30) #Only the first 30 columns
imsub(parrots,y &lt; 30) #Only the first 30 rows
imsub(parrots,x &lt; 30,y &lt; 30) #First 30 columns and rows
imsub(parrots, sqrt(x) &gt; 8) #Can use arbitrary expressions
imsub(parrots,x &gt; height/2,y &gt; width/2)  #height and width are defined based on the image
#Using the %inr% operator, which is like %in% but for a numerical range
all.equal(imsub(parrots,x %inr% c(1,10)),
  imsub(parrots,x &gt;= 1,x &lt;= 10))
imsub(parrots,cc==1) #Colour axis is "cc" not "c" here because "c" is an important R function
##Not run
##imsub(parrots,x+y==1)
##can't have expressions involving interactions between variables (domain might not be square)
</code></pre>

<hr>
<h2 id='imwarp'>Image warping</h2><span id='topic+imwarp'></span>

<h3>Description</h3>

<p>Image warping consists in remapping pixels, ie. you define a function
M(x,y,z) -&gt; (x',y',z')
that displaces pixel content from (x,y,z) to (x',y',z').
Actual implementations rely on either the forward transformation M, or the backward (inverse) transformation M^-1.
In CImg the forward implementation will go through all source (x,y,z) pixels and &quot;paint&quot; the corresponding pixel at (x',y',z'). This will result in unpainted pixels in the output if M is expansive (for example in the case of a scaling M(x,y,z) = 5*(x,y,z)).
The backward implementation will go through every pixel in the destination image and look for ancestors in the source, meaning that every pixel will be painted.
There are two ways of specifying the map: absolute or relative coordinates. In absolute coordinates you specify M or M^-1 directly. In relative coordinates you specify an offset function D:
M(x,y) = (x,y) + D(x,y) (forward)
M^-1(x,y) = (x,y) - D(x,y) (backward)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imwarp(
  im,
  map,
  direction = "forward",
  coordinates = "absolute",
  boundary = "dirichlet",
  interpolation = "linear"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imwarp_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="imwarp_+3A_map">map</code></td>
<td>
<p>a function that takes (x,y) or (x,y,z) as arguments and returns a named list with members (x,y) or (x,y,z)</p>
</td></tr>
<tr><td><code id="imwarp_+3A_direction">direction</code></td>
<td>
<p>&quot;forward&quot; or &quot;backward&quot; (default &quot;forward&quot;)</p>
</td></tr>
<tr><td><code id="imwarp_+3A_coordinates">coordinates</code></td>
<td>
<p>&quot;absolute&quot; or &quot;relative&quot; (default &quot;relative&quot;)</p>
</td></tr>
<tr><td><code id="imwarp_+3A_boundary">boundary</code></td>
<td>
<p>boundary conditions: &quot;dirichlet&quot;, &quot;neumann&quot;, &quot;periodic&quot;. Default &quot;dirichlet&quot;</p>
</td></tr>
<tr><td><code id="imwarp_+3A_interpolation">interpolation</code></td>
<td>
<p>&quot;nearest&quot;, &quot;linear&quot;, &quot;cubic&quot; (default &quot;linear&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that 3D warps are possible as well.
The mapping should be specified via the &quot;map&quot; argument, see examples.
</p>


<h3>Value</h3>

<p>a warped image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>warp for direct access to the CImg function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- load.example("parrots")
#Shift image
map.shift &lt;- function(x,y) list(x=x+10,y=y+30)
imwarp(im,map=map.shift) %&gt;% plot
#Shift image (backward transform)
imwarp(im,map=map.shift,dir="backward") %&gt;% plot

#Shift using relative coordinates
map.rel &lt;- function(x,y) list(x=10+0*x,y=30+0*y)
imwarp(im,map=map.rel,coordinates="relative") %&gt;% plot

#Scaling
map.scaling &lt;- function(x,y) list(x=1.5*x,y=1.5*y)
imwarp(im,map=map.scaling) %&gt;% plot #Note the holes
map.scaling.inv &lt;- function(x,y) list(x=x/1.5,y=y/1.5)
imwarp(im,map=map.scaling.inv,dir="backward") %&gt;% plot #No holes

#Bending
map.bend.rel &lt;- function(x,y) list(x=50*sin(y/10),y=0*y)
imwarp(im,map=map.bend.rel,coord="relative",dir="backward") %&gt;% plot #No holes
</code></pre>

<hr>
<h2 id='index.coord'>Linear index in internal vector from pixel coordinates</h2><span id='topic+index.coord'></span>

<h3>Description</h3>

<p>Pixels are stored linearly in (x,y,z,c) order. This function computes the vector index of a pixel given its coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.coord(im, coords, outside = "stop")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index.coord_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="index.coord_+3A_coords">coords</code></td>
<td>
<p>a data.frame with values x,y,z (optional), c (optional)</p>
</td></tr>
<tr><td><code id="index.coord_+3A_outside">outside</code></td>
<td>
<p>what to do if some coordinates are outside the image: &quot;stop&quot; issues error, &quot;NA&quot; replaces invalid coordinates with NAs. Default: &quot;stop&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of indices (NA if the indices are invalid)
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>coord.index, the reverse operation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- as.cimg(function(x,y) x+y,100,100)
px &lt;- index.coord(im,data.frame(x=c(3,3),y=c(1,2)))
im[px] #Values should be 3+1=4, 3+2=5
</code></pre>

<hr>
<h2 id='inpaint'>Fill-in NA values in an image</h2><span id='topic+inpaint'></span>

<h3>Description</h3>

<p>Fill in NA values (inpainting) using a Gaussian filter, i.e. replace missing pixel values with a weighted average of the neighbours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inpaint(im, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpaint_+3A_im">im</code></td>
<td>
<p>input image</p>
</td></tr>
<tr><td><code id="inpaint_+3A_sigma">sigma</code></td>
<td>
<p>std. deviation of the Gaussian (size of neighbourhood)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image with missing values filled-in.
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- boats
im[sample(nPix(im),1e4)] &lt;- NA
inpaint(im,1) %&gt;% imlist(im,.) %&gt;%
   setNames(c("before","after")) %&gt;% plot(layout="row")
</code></pre>

<hr>
<h2 id='interact'>Build simple interactive interfaces using imager</h2><span id='topic+interact'></span>

<h3>Description</h3>

<p>To explore the effect of certain image manipulations, filter settings, etc., it's useful to have a basic interaction mechanism. You can use shiny for that, but imager provides a lightweight alternative. The user writes a function that gets called every time a user event happens (a click, a keypress, etc.). The role of the function is to process the event and output an image, which will then be displayed.
You can exit the interface at any time by pressing Esc.
See examples for more.
This feature is experimental!!!
Note that you need X11 library to use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interact(fun, title = "", init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interact_+3A_fun">fun</code></td>
<td>
<p>a function that takes a single argument (a list of user events) and returns an image to be plotted. The image won't be rescaled before plotting, so make sure RGB values are in [0,1].</p>
</td></tr>
<tr><td><code id="interact_+3A_title">title</code></td>
<td>
<p>a title for the window (default &quot;&quot;, none)</p>
</td></tr>
<tr><td><code id="interact_+3A_init">init</code></td>
<td>
<p>initial image to display (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image, specifically the last image displayed
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Implement a basic image gallery:
#press "right" and "left" to view each image in a list
gallery &lt;- function(iml)
{
    ind &lt;- 1
    f &lt;- function(state)
   {
        if (state$key=="arrowleft")
        {
            ind &lt;&lt;- max(ind-1,1)
        }
        if (state$key=="arrowright")
        {
            ind &lt;&lt;- min(ind+1,length(iml))
        }
        iml[[ind]]
    }
    interact(f)
}
##Not run (interactive only)
##map_il(1:10,~ isoblur(boats,.)) %&gt;% gallery
</code></pre>

<hr>
<h2 id='interp'>Interpolate image values</h2><span id='topic+interp'></span>

<h3>Description</h3>

<p>This function provides 2D and 3D (linear or cubic) interpolation for pixel values.
Locations need to be provided as a data.frame with variables x,y,z, and c (the last two are optional).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp(im, locations, cubic = FALSE, extrapolate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interp_+3A_im">im</code></td>
<td>
<p>the image (class cimg)</p>
</td></tr>
<tr><td><code id="interp_+3A_locations">locations</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="interp_+3A_cubic">cubic</code></td>
<td>
<p>if TRUE, use cubic interpolation. If FALSE, use linear (default FALSE)</p>
</td></tr>
<tr><td><code id="interp_+3A_extrapolate">extrapolate</code></td>
<td>
<p>allow extrapolation (to values outside the image)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

loc &lt;- data.frame(x=runif(10,1,width(boats)),y=runif(10,1,height(boats))) #Ten random locations
interp(boats,loc)
</code></pre>

<hr>
<h2 id='is.cimg'>Checks that an object is a cimg object</h2><span id='topic+is.cimg'></span>

<h3>Description</h3>

<p>Checks that an object is a cimg object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.cimg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.cimg_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='is.imlist'>Check that an object is an imlist object</h2><span id='topic+is.imlist'></span>

<h3>Description</h3>

<p>Check that an object is an imlist object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.imlist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.imlist_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='is.pixset'>Check that an object is a pixset object</h2><span id='topic+is.pixset'></span>

<h3>Description</h3>

<p>Check that an object is a pixset object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.pixset(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.pixset_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='isoblur'>Blur image isotropically.</h2><span id='topic+isoblur'></span>

<h3>Description</h3>

<p>Blur image isotropically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isoblur(im, sigma, neumann = TRUE, gaussian = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isoblur_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="isoblur_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the blur (positive)</p>
</td></tr>
<tr><td><code id="isoblur_+3A_neumann">neumann</code></td>
<td>
<p>If true, use Neumann boundary conditions, Dirichlet otherwise  (default true, Neumann)</p>
</td></tr>
<tr><td><code id="isoblur_+3A_gaussian">gaussian</code></td>
<td>
<p>Use a Gaussian filter (actually van Vliet-Young). Default: 0th-order Deriche filter.</p>
</td></tr>
<tr><td><code id="isoblur_+3A_na.rm">na.rm</code></td>
<td>
<p>if TRUE, ignore NA values. Default FALSE, in which case the whole image is NA if one of the values is NA (following the definition of the Gaussian filter)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>deriche,vanvliet,inpaint,medianblur
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
isoblur(boats,3) %&gt;% plot(main="Isotropic blur, sigma=3")
isoblur(boats,10) %&gt;% plot(main="Isotropic blur, sigma=10")
</code></pre>

<hr>
<h2 id='label'>Label connected components.</h2><span id='topic+label'></span>

<h3>Description</h3>

<p>The algorithm of connected components computation has been primarily done
by A. Meijster, according to the publication:
'W.H. Hesselink, A. Meijster, C. Bron, &quot;Concurrent Determination of Connected Components.&quot;,
In: Science of Computer Programming 41 (2001), pp. 173&ndash;194'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label(im, high_connectivity = FALSE, tolerance = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="label_+3A_high_connectivity">high_connectivity</code></td>
<td>
<p>4(false)- or 8(true)-connectivity
in 2d case, and between 6(false)- or 26(true)-connectivity in 3d case. Default FALSE</p>
</td></tr>
<tr><td><code id="label_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance used to determine if two neighboring pixels belong to the same region.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
imname &lt;- system.file('extdata/parrots.png',package='imager')
im &lt;- load.image(imname) %&gt;% grayscale
#Thresholding yields different discrete regions of high intensity
regions &lt;- isoblur(im,10) %&gt;% threshold("97%") 
labels &lt;- label(regions)
layout(t(1:2))
plot(regions,"Regions")
plot(labels,"Labels")

</code></pre>

<hr>
<h2 id='liply'>Apply function to each element of a list, then combine the result as an image by appending along specified axis</h2><span id='topic+liply'></span>

<h3>Description</h3>

<p>This is just a shortcut for purrr::map followed by imappend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liply(lst, fun, axis, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="liply_+3A_lst">lst</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="liply_+3A_fun">fun</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="liply_+3A_axis">axis</code></td>
<td>
<p>which axis to append along (e.g. &quot;c&quot; for colour)</p>
</td></tr>
<tr><td><code id="liply_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to fun</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
build.im &lt;- function(size) as.cimg(function(x,y) (x+y)/size,size,size)
liply(c(10,50,100),build.im,"y") %&gt;% plot
</code></pre>

<hr>
<h2 id='load.dir'>Load all images in a directory</h2><span id='topic+load.dir'></span>

<h3>Description</h3>

<p>Load all images in a directory and return them as an image list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.dir(path, pattern = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.dir_+3A_path">path</code></td>
<td>
<p>directory to load from</p>
</td></tr>
<tr><td><code id="load.dir_+3A_pattern">pattern</code></td>
<td>
<p>optional: file pattern (ex. *jpg). Default NULL, in which case we look for file extensions png,jpeg,jpg,tif,bmp.</p>
</td></tr>
<tr><td><code id="load.dir_+3A_quiet">quiet</code></td>
<td>
<p>if TRUE, loading errors are quiet. If FALSE, they are displayed. Default FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image list
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- system.file(package="imager") %&gt;% paste0("/extdata")
load.dir(path)
</code></pre>

<hr>
<h2 id='load.example'>Load example image</h2><span id='topic+load.example'></span>

<h3>Description</h3>

<p>Imager ships with five test pictures and a video. Two (parrots and boats) come from the [Kodak set](http://r0k.us/graphics/kodak/). Another (birds) is a sketch of birds by Leonardo, from Wikimedia. The &quot;coins&quot; image comes from scikit-image. The Hubble Deep field (hubble) is from Wikimedia.
The test video (&quot;tennis&quot;) comes from [xiph.org](https://media.xiph.org/video/derf/)'s collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.example(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.example_+3A_name">name</code></td>
<td>
<p>name of the example</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load.example("hubble") %&gt;% plot
load.example("birds") %&gt;% plot
load.example("parrots") %&gt;% plot
</code></pre>

<hr>
<h2 id='load.image'>Load image from file or URL</h2><span id='topic+load.image'></span>

<h3>Description</h3>

<p>PNG, JPEG and BMP are supported via the readbitmap package. You'll need to install ImageMagick for other formats. If the path is actually a URL, it should start with http(s) or ftp(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.image(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.image_+3A_file">file</code></td>
<td>
<p>path to file or URL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'cimg'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Find path to example file from package
fpath &lt;- system.file('extdata/Leonardo_Birds.jpg',package='imager') 
im &lt;- load.image(fpath)
plot(im)
#Load the R logo directly from the CRAN webpage
#load.image("https://cran.r-project.org/Rlogo.jpg") %&gt;% plot
</code></pre>

<hr>
<h2 id='load.video'>Load a video using ffmpeg</h2><span id='topic+load.video'></span>

<h3>Description</h3>

<p>You need to have ffmpeg on your path for this to work. This function uses ffmpeg to split the video into individual frames, which are then loaded as images and recombined.
Videos are memory-intensive, and load.video performs a safety check before loading a video that would be larger than maxSize in memory (default 1GB)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.video(
  fname,
  maxSize = 1,
  skip.to = 0,
  frames = NULL,
  fps = NULL,
  extra.args = "",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.video_+3A_fname">fname</code></td>
<td>
<p>file to load</p>
</td></tr>
<tr><td><code id="load.video_+3A_maxsize">maxSize</code></td>
<td>
<p>max. allowed size in memory, in GB (default max 1GB).</p>
</td></tr>
<tr><td><code id="load.video_+3A_skip.to">skip.to</code></td>
<td>
<p>skip to a certain point in time (in sec., or &quot;hh:mm::ss&quot; format)</p>
</td></tr>
<tr><td><code id="load.video_+3A_frames">frames</code></td>
<td>
<p>number of frames to load (default NULL, all)</p>
</td></tr>
<tr><td><code id="load.video_+3A_fps">fps</code></td>
<td>
<p>frames per second (default NULL, determined automatically)</p>
</td></tr>
<tr><td><code id="load.video_+3A_extra.args">extra.args</code></td>
<td>
<p>extra arguments to be passed to ffmpeg (default &quot;&quot;, none)</p>
</td></tr>
<tr><td><code id="load.video_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, show ffmpeg output (default FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image with the extracted frames along the &quot;z&quot; coordinates
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>save.video, make.video
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fname &lt;- system.file('extdata/tennis_sif.mpeg',package='imager')
##Not run
## load.video(fname) %&gt;% play
## load.video(fname,fps=10) %&gt;% play
## load.video(fname,skip=2) %&gt;% play
</code></pre>

<hr>
<h2 id='magick'>Convert a magick image to a cimg image or image list and vice versa</h2><span id='topic+magick'></span><span id='topic+magick2imlist'></span><span id='topic+magick2cimg'></span><span id='topic+cimg2magick'></span>

<h3>Description</h3>

<p>The magick library package stores its data as &quot;magick-image&quot; object, which may in fact contain several images or an animation. These functions convert magick objects into imager objects or imager objects into magick objects. Note that cimg2magick function requires magick package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magick2imlist(obj, alpha = "rm", ...)

magick2cimg(obj, alpha = "rm", ...)

cimg2magick(im, rotate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magick_+3A_obj">obj</code></td>
<td>
<p>an object of class &quot;magick-image&quot;</p>
</td></tr>
<tr><td><code id="magick_+3A_alpha">alpha</code></td>
<td>
<p>what do to with the alpha channel (&quot;rm&quot;: remove and store as attribute, &quot;flatten&quot;: flatten, &quot;keep&quot;: keep). Default: &quot;rm&quot;</p>
</td></tr>
<tr><td><code id="magick_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="magick_+3A_im">im</code></td>
<td>
<p>an image of class cimg</p>
</td></tr>
<tr><td><code id="magick_+3A_rotate">rotate</code></td>
<td>
<p>determine if rotate image to adjust orientation of image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class cimg or imlist
</p>
<p>an object of class &quot;magick-image&quot;
</p>


<h3>Author(s)</h3>

<p>Jan Wijffels, Simon Barthelme
</p>
<p>Shota Ochi
</p>


<h3>See Also</h3>

<p>flatten.alpha, rm.alpha
</p>

<hr>
<h2 id='make.video'>Make/save a video using ffmpeg</h2><span id='topic+make.video'></span><span id='topic+save.video'></span>

<h3>Description</h3>

<p>You need to have ffmpeg on your path for this to work. This function uses ffmpeg to combine individual frames into a video.
save.video can be called directly with an image or image list as input. 
make.video takes as argument a directory that contains a sequence of images representing individual frames to be combined into a video.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.video(
  dname,
  fname,
  pattern = "image-%d.png",
  fps = 25,
  extra.args = "",
  verbose = FALSE
)

save.video(im, fname, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.video_+3A_dname">dname</code></td>
<td>
<p>name of a directory containing individual files</p>
</td></tr>
<tr><td><code id="make.video_+3A_fname">fname</code></td>
<td>
<p>name of the output file. The format is determined automatically from the name (example &quot;a.mpeg&quot; will have MPEG format)</p>
</td></tr>
<tr><td><code id="make.video_+3A_pattern">pattern</code></td>
<td>
<p>pattern of filename for frames (the default matches &quot;image-1.png&quot;, &quot;image-2.png&quot;, etc.. See ffmpeg documentation for more).</p>
</td></tr>
<tr><td><code id="make.video_+3A_fps">fps</code></td>
<td>
<p>frames per second (default 25)</p>
</td></tr>
<tr><td><code id="make.video_+3A_extra.args">extra.args</code></td>
<td>
<p>extra arguments to be passed to ffmpeg (default &quot;&quot;, none)</p>
</td></tr>
<tr><td><code id="make.video_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, show ffmpeg output (default FALSE)</p>
</td></tr>
<tr><td><code id="make.video_+3A_im">im</code></td>
<td>
<p>an image or image list</p>
</td></tr>
<tr><td><code id="make.video_+3A_...">...</code></td>
<td>
<p>extra arguments to save.video, passed on to make.video</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>save.video()</code>: Save a video using ffmpeg
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>load.video
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run
## iml &lt;- map_il(seq(0,20,l=60),~ isoblur(boats,.))
## f &lt;- tempfile(fileext=".avi")
## save.video(iml,f)
## load.video(f) %&gt;% play
## #Making a video from a directory
## dd &lt;- tempdir()
## for (i in 1:length(iml)) {
## png(sprintf("%s/image-%i.png",dd,i));
## plot(iml[[i]]); dev.off() }
## make.video(dd,f)
## load.video(f) %&gt;% play
</code></pre>

<hr>
<h2 id='map_il'>Type-stable map for use with the purrr package</h2><span id='topic+map_il'></span><span id='topic+map2_il'></span><span id='topic+pmap_il'></span>

<h3>Description</h3>

<p>Works like purrr::map, purrr::map_dbl and the like but ensures that the output is an image list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_il(...)

map2_il(...)

pmap_il(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_il_+3A_...">...</code></td>
<td>
<p>passed to map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image list
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>map2_il()</code>: Parallel map (two values)
</p>
</li>
<li> <p><code>pmap_il()</code>: Parallel map (multiple values)
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Returns a list
imsplit(boats,"x",2) %&gt;% purrr::map(~ isoblur(.,3))
#Returns an "imlist" object
imsplit(boats,"x",2) %&gt;% map_il(~ isoblur(.,3))
#Fails if function returns an object that's not an image
try(imsplit(boats,"x",2) %&gt;% map_il(~ . &gt; 2))
#Parallel maps
map2_il(1:3,101:103,~ imshift(boats,.x,.y))
pmap_il(list(x=1:3,y=4:6,z=7:9),function(x,y,z) imfill(x,y,z))
</code></pre>

<hr>
<h2 id='medianblur'>Blur image with the median filter.
In a window of size n x n centered at pixel (x,y), compute median pixel value over the window. Optionally, ignore values that are too far from the value at current pixel.</h2><span id='topic+medianblur'></span>

<h3>Description</h3>

<p>Blur image with the median filter.
</p>
<p>In a window of size n x n centered at pixel (x,y), compute median pixel value over the window. Optionally, ignore values that are too far from the value at current pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medianblur(im, n, threshold = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="medianblur_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="medianblur_+3A_n">n</code></td>
<td>
<p>Size of the median filter.</p>
</td></tr>
<tr><td><code id="medianblur_+3A_threshold">threshold</code></td>
<td>
<p>Threshold used to discard pixels too far from the current pixel value in the median computation. Can be used for edge-preserving smoothing. Default 0 (include all pixels in window).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>isoblur, boxblur
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
medianblur(boats,5) %&gt;% plot(main="Median blur, 5 pixels")
medianblur(boats,10) %&gt;% plot(main="Median blur, 10 pixels")
medianblur(boats,10,8) %&gt;% plot(main="Median blur, 10 pixels, threshold = 8")
</code></pre>

<hr>
<h2 id='mirror'>Mirror image content along specified axis</h2><span id='topic+mirror'></span>

<h3>Description</h3>

<p>Mirror image content along specified axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirror(im, axis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mirror_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="mirror_+3A_axis">axis</code></td>
<td>
<p>Mirror axis (&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;c&quot;)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
mirror(boats,"x") %&gt;% plot
mirror(boats,"y") %&gt;% plot
</code></pre>

<hr>
<h2 id='mutate_plyr'>Mutate a data frame by adding new or replacing existing columns.</h2><span id='topic+mutate_plyr'></span>

<h3>Description</h3>

<p>This function copied directly from plyr, and modified to use a different
name to avoid namespace collisions with dplyr/tidyverse functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_plyr(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_plyr_+3A_.data">.data</code></td>
<td>
<p>the data frame to transform</p>
</td></tr>
<tr><td><code id="mutate_plyr_+3A_...">...</code></td>
<td>
<p>named parameters giving definitions of new columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is very similar to <code><a href="base.html#topic+transform">transform</a></code> but it executes
the transformations iteratively so that later transformations can use the
columns created by earlier transformations.  Like transform, unnamed
components are silently dropped.
</p>
<p>Mutate seems to be considerably faster than transform for large data
frames.
</p>

<hr>
<h2 id='nfline'>Plot a line, Hesse normal form parameterisation</h2><span id='topic+nfline'></span>

<h3>Description</h3>

<p>This is a simple interface over abline meant to be used along with the Hough transform.  In the Hesse normal form (theta,rho), a line is represented as the set of values (x,y) such that cos(theta)*x + sin(theta)*y = rho. Here theta is an angle and rho is a distance.
See the documentation for hough_lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nfline(theta, rho, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nfline_+3A_theta">theta</code></td>
<td>
<p>angle (radians)</p>
</td></tr>
<tr><td><code id="nfline_+3A_rho">rho</code></td>
<td>
<p>distance</p>
</td></tr>
<tr><td><code id="nfline_+3A_col">col</code></td>
<td>
<p>colour</p>
</td></tr>
<tr><td><code id="nfline_+3A_...">...</code></td>
<td>
<p>other graphical parameters, passed along to abline</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Boring example, see ?hough_lines
plot(boats)
nfline(theta=0,rho=10,col="red")
</code></pre>

<hr>
<h2 id='pad'>Pad image with n pixels along specified axis</h2><span id='topic+pad'></span>

<h3>Description</h3>

<p>Pad image with n pixels along specified axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad(im, nPix, axes, pos = 0, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_+3A_im">im</code></td>
<td>
<p>the input image</p>
</td></tr>
<tr><td><code id="pad_+3A_npix">nPix</code></td>
<td>
<p>how many pixels to pad with</p>
</td></tr>
<tr><td><code id="pad_+3A_axes">axes</code></td>
<td>
<p>which axes to pad along</p>
</td></tr>
<tr><td><code id="pad_+3A_pos">pos</code></td>
<td>
<p>-1: prepend 0: center 1: append</p>
</td></tr>
<tr><td><code id="pad_+3A_val">val</code></td>
<td>
<p>colour of the padded pixels (default 0 in all channels). Can be a string for colour images, e.g. &quot;red&quot;, or &quot;black&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a padded image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pad(boats,20,"xy") %&gt;% plot
pad(boats,20,pos=-1,"xy") %&gt;% plot
pad(boats,20,pos=1,"xy") %&gt;% plot
pad(boats,20,pos=1,"xy",val="red") %&gt;% plot
</code></pre>

<hr>
<h2 id='patch_summary_cimg'>Extract a numerical summary from image patches, using CImg's mini-language
Experimental feature.</h2><span id='topic+patch_summary_cimg'></span>

<h3>Description</h3>

<p>Extract a numerical summary from image patches, using CImg's mini-language
Experimental feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patch_summary_cimg(im, expr, cx, cy, wx, wy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patch_summary_cimg_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="patch_summary_cimg_+3A_expr">expr</code></td>
<td>
<p>a CImg expression (as a string)</p>
</td></tr>
<tr><td><code id="patch_summary_cimg_+3A_cx">cx</code></td>
<td>
<p>vector of x coordinates for patch centers</p>
</td></tr>
<tr><td><code id="patch_summary_cimg_+3A_cy">cy</code></td>
<td>
<p>vector of y coordinates for patch centers</p>
</td></tr>
<tr><td><code id="patch_summary_cimg_+3A_wx">wx</code></td>
<td>
<p>vector of coordinates for patch width</p>
</td></tr>
<tr><td><code id="patch_summary_cimg_+3A_wy">wy</code></td>
<td>
<p>vector of coordinates for patch height</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Example: median filtering using patch_summary_cimg
#Center a patch at each pixel
im &lt;- grayscale(boats)
patches &lt;- pixel.grid(im)  %&gt;% dplyr::mutate(w=3,h=3)
#Extract patch summary
out &lt;- dplyr::mutate(patches,med=patch_summary_cimg(im,"ic",x,y,w,h))
as.cimg(out,v.name="med") %&gt;% plot
</code></pre>

<hr>
<h2 id='patchstat'>Return image patch summary</h2><span id='topic+patchstat'></span>

<h3>Description</h3>

<p>Patches are rectangular image regions centered at cx,cy with width wx and height wy. This function provides a fast way of extracting a statistic over image patches (for example, their mean).
Supported functions: sum,mean,min,max,median,var,sd, or any valid CImg expression.
WARNINGS:
- values outside of the image region are considered to be 0.
- widths and heights should be odd integers (they're rounded up otherwise).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patchstat(im, expr, cx, cy, wx, wy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patchstat_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="patchstat_+3A_expr">expr</code></td>
<td>
<p>statistic to extract. a string, either one of the usual statistics like &quot;mean&quot;,&quot;median&quot;, or a CImg expression.</p>
</td></tr>
<tr><td><code id="patchstat_+3A_cx">cx</code></td>
<td>
<p>vector of x coordinates for patch centers</p>
</td></tr>
<tr><td><code id="patchstat_+3A_cy">cy</code></td>
<td>
<p>vector of y coordinates for patch centers</p>
</td></tr>
<tr><td><code id="patchstat_+3A_wx">wx</code></td>
<td>
<p>vector of patch widths (or single value)</p>
</td></tr>
<tr><td><code id="patchstat_+3A_wy">wy</code></td>
<td>
<p>vector of patch heights (or single value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>See Also</h3>

<p>extract_patches
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- grayscale(boats)
#Mean of an image patch centered at (10,10) of size 3x3
patchstat(im,'mean',10,10,3,3)
#Mean of image patches centered at (10,10) and (20,4) of size 2x2
patchstat(im,'mean',c(10,20),c(10,4),5,5)
#Sample 10 random positions
ptch &lt;- pixel.grid(im) %&gt;% dplyr::sample_n(10)
#Compute median patch value
with(ptch,patchstat(im,'median',x,y,3,3))
</code></pre>

<hr>
<h2 id='periodic.part'>Compute the periodic part of an image, using the periodic/smooth decomposition of Moisan (2011)</h2><span id='topic+periodic.part'></span>

<h3>Description</h3>

<p>Moisan (2011) defines an additive image decomposition
im = periodic + smooth
where the periodic part shouldn't be too far from the original image. The periodic part can be used in frequency-domain analyses, to reduce the artifacts induced by non-periodicity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodic.part(im)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodic.part_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>References</h3>

<p>L. Moisan, Periodic plus Smooth Image Decomposition,J. Math. Imaging Vision, vol. 39:2, pp. 161-179, 2011
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- load.example("parrots") %&gt;% subim(x &lt;= 512)
layout(t(1:3))
plot(im,main="Original image")
periodic.part(im) %&gt;% plot(main="Periodic part")
#The smooth error is the difference between
#the original image and its periodic part
(im-periodic.part(im)) %&gt;% plot(main="Smooth part")

</code></pre>

<hr>
<h2 id='permute_axes'>Permute image axes</h2><span id='topic+permute_axes'></span>

<h3>Description</h3>

<p>By default images are stored in xyzc order. Use permute_axes to change that order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_axes(im, perm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_axes_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="permute_axes_+3A_perm">perm</code></td>
<td>
<p>a character string, e.g., &quot;zxyc&quot; to have the z-axis come first</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- array(0,c(10,30,40,3)) %&gt;% as.cimg
permute_axes(im,"zxyc")
</code></pre>

<hr>
<h2 id='pixel.grid'>Return the pixel grid for an image</h2><span id='topic+pixel.grid'></span>

<h3>Description</h3>

<p>The pixel grid for image im gives the (x,y,z,c) coordinates of each successive pixel as a data.frame. The c coordinate has been renamed 'cc' to avoid conflicts with R's c function.
NB: coordinates start at (x=1,y=1), corresponding to the top left corner of the image, unless standardise == TRUE, in which case we use the usual Cartesian coordinates with origin at the center of the image and scaled such that x varies between -.5 and .5, and a y arrow pointing up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixel.grid(im, standardise = FALSE, drop.unused = TRUE, dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pixel.grid_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="pixel.grid_+3A_standardise">standardise</code></td>
<td>
<p>If TRUE use a centered, scaled coordinate system. If FALSE use standard image coordinates (default FALSE)</p>
</td></tr>
<tr><td><code id="pixel.grid_+3A_drop.unused">drop.unused</code></td>
<td>
<p>if TRUE ignore empty dimensions, if FALSE include them anyway (default TRUE)</p>
</td></tr>
<tr><td><code id="pixel.grid_+3A_dim">dim</code></td>
<td>
<p>a vector of image dimensions (optional, may be used instead of &quot;im&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- as.cimg(array(0,c(10,10))) #A 10x10 image
pixel.grid(im) %&gt;% head
pixel.grid(dim=dim(im)) %&gt;% head #Same as above
pixel.grid(dim=c(10,10,3,2)) %&gt;% head 
pixel.grid(im,standardise=TRUE) %&gt;% head
pixel.grid(im,drop.unused=FALSE) %&gt;% head
</code></pre>

<hr>
<h2 id='pixset'>Pixel sets (pixsets)</h2><span id='topic+pixset'></span>

<h3>Description</h3>

<p>Pixel sets represent sets of pixels in images (ROIs, foreground, etc.). From an implementation point of view, they're just a thin layer over arrays of logical values, just like the cimg class is a layer over arrays of numeric values.
Pixsets can be turned back into logical arrays, but they come with a number of generic functions that should make your life easier.
They are created automatically whenever you run a test on an image (for example im &gt; 0 returns a pixset).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixset(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pixset_+3A_x">x</code></td>
<td>
<p>an array of logical values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#A test on an image returns a pixset
boats &gt; 250
#Pixsets can be combined using the usual Boolean operators
(boats &gt; 230) &amp; (Xc(boats) &lt; width(boats)/2)
#Subset an image using a pixset
boats[boats &gt; 250]
#Turn a pixset into an image
as.cimg(boats &gt; 250)
#Equivalently:
(boats &gt; 250) + 0
</code></pre>

<hr>
<h2 id='play'>Play a video</h2><span id='topic+play'></span>

<h3>Description</h3>

<p>A very basic video player. Press the space bar to pause and ESC to close. Note that you need X11 library to use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>play(vid, loop = FALSE, delay = 30L, normalise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="play_+3A_vid">vid</code></td>
<td>
<p>A cimg object, to be played as video</p>
</td></tr>
<tr><td><code id="play_+3A_loop">loop</code></td>
<td>
<p>loop the video (default false)</p>
</td></tr>
<tr><td><code id="play_+3A_delay">delay</code></td>
<td>
<p>delay between frames, in ms. Default 30.</p>
</td></tr>
<tr><td><code id="play_+3A_normalise">normalise</code></td>
<td>
<p>if true pixel values are rescaled to 0...255 (default TRUE). The normalisation is based on the *first frame*. If you don't want the default behaviour you can normalise by hand. Default TRUE.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.cimg'>Display an image using base graphics</h2><span id='topic+plot.cimg'></span>

<h3>Description</h3>

<p>If you want to control precisely how numerical values are turned into colours for plotting, you need to specify a colour scale using the colourscale argument (see examples). Otherwise the default is &quot;gray&quot; for grayscale images, &quot;rgb&quot; for colour. These expect values in [0..1], so the default is to rescale the data to [0..1]. If you wish to over-ride that behaviour, set rescale=FALSE.
See examples for an explanation.
If the image is one dimensional (i.e., a simple row or column image), then pixel values will be plotted as a line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cimg'
plot(
  x,
  frame,
  xlim = c(1, width(x)),
  ylim = c(height(x), 1),
  xlab = "x",
  ylab = "y",
  rescale = TRUE,
  colourscale = NULL,
  colorscale = NULL,
  interpolate = TRUE,
  axes = TRUE,
  main = "",
  xaxs = "i",
  yaxs = "i",
  asp = 1,
  col.na = rgb(0, 0, 0, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cimg_+3A_x">x</code></td>
<td>
<p>the image</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_frame">frame</code></td>
<td>
<p>which frame to display, if the image has depth &gt; 1</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_xlim">xlim</code></td>
<td>
<p>x plot limits (default: 1 to width)</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_ylim">ylim</code></td>
<td>
<p>y plot limits (default: 1 to height)</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_rescale">rescale</code></td>
<td>
<p>rescale pixel values so that their range is [0,1]</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_colourscale">colourscale</code>, <code id="plot.cimg_+3A_colorscale">colorscale</code></td>
<td>
<p>an optional colour scale (default is gray or rgb)</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_interpolate">interpolate</code></td>
<td>
<p>should the image be plotted with antialiasing (default TRUE)</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_axes">axes</code></td>
<td>
<p>Whether to draw axes (default TRUE)</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_main">main</code></td>
<td>
<p>Main title</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_xaxs">xaxs</code></td>
<td>
<p>The style of axis interval calculation to be used for the x-axis. See ?par</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_yaxs">yaxs</code></td>
<td>
<p>The style of axis interval calculation to be used for the y-axis. See ?par</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_asp">asp</code></td>
<td>
<p>aspect ratio. The default value (1) means that the aspect ratio of the image will be kept regardless of the dimensions of the plot. A numeric value other than one changes the aspect ratio, but it will be kept the same regardless of dimensions. Setting asp=&quot;varying&quot; means the aspect ratio will depend on plot dimensions (this used to be the default in versions of imager &lt; 0.40)</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_col.na">col.na</code></td>
<td>
<p>which colour to use for NA values, as R rgb code. The default is &quot;rgb(0,0,0,0)&quot;, which corresponds to a fully transparent colour.</p>
</td></tr>
<tr><td><code id="plot.cimg_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to plot.default (eg &quot;main&quot;)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>display, which is much faster, as.raster, which converts images to R raster objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(boats,main="Boats") 
plot(boats,axes=FALSE,xlab="",ylab="")

#Pixel values are rescaled to 0-1 by default, so that the following two plots are identical
plot(boats)
plot(boats/2,main="Rescaled")
#If you don't want that behaviour, you can set rescale to FALSE, but
#then you need to make sure values are in [0,1]
try(plot(boats,rescale=FALSE)) #Error!
try(plot(boats/255,rescale=FALSE)) #Works
#You can specify a colour scale if you don't want the default one.
#A colour scale is a function that takes pixels values and return an RGB code,
#like R's rgb function,e.g.
rgb(0,1,0)
#Let's switch colour channels
cscale &lt;- function(r,g,b) rgb(b,g,r)
plot(boats/255,rescale=FALSE,colourscale=cscale)
#Display slice of HSV colour space
im &lt;- imfill(255,255,val=1)
im &lt;- list(Xc(im)/255,Yc(im)/255,im) %&gt;% imappend("c")
plot(im,colourscale=hsv,rescale=FALSE,
     xlab="Hue",ylab="Saturation")
#In grayscale images, the colourscale function should take in a single value
#and return an RGB code
boats.gs &lt;- grayscale(boats)
#We use an interpolation function from package scales
cscale &lt;- scales::gradient_n_pal(c("red","purple","lightblue"),c(0,.5,1))
plot(boats.gs,rescale=FALSE,colourscale=cscale)
#Plot a one-dimensional image
imsub(boats,x==1) %&gt;% plot(main="Image values along first column")
#Plotting with and without anti-aliasing:
boats.small &lt;- imresize(boats,.3)
plot(boats.small,interp=TRUE)
plot(boats.small,interp=FALSE)
</code></pre>

<hr>
<h2 id='plot.imlist'>Plot an image list</h2><span id='topic+plot.imlist'></span>

<h3>Description</h3>

<p>Each image in the list will be plotted separately. The layout argument controls the overall layout of the plot window. The default layout is &quot;rect&quot;, which will fit all of your images into a rectangle that's as close to a square as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imlist'
plot(x, layout = "rect", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.imlist_+3A_x">x</code></td>
<td>
<p>an image list (of type imlist)</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_layout">layout</code></td>
<td>
<p>either a matrix (in the format defined by the layout command) or one of &quot;row&quot;,&quot;col&quot; or &quot;rect&quot;. Default: &quot;rect&quot;</p>
</td></tr>
<tr><td><code id="plot.imlist_+3A_...">...</code></td>
<td>
<p>other parameters, to be passed to the plot command</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
imsplit(boats,"c") #Returns an image list
imsplit(boats,"c") %&gt;% plot
imsplit(boats,"c") %&gt;% plot(layout="row")
imsplit(boats,"c") %&gt;% plot(layout="col")
imsplit(boats,"x",5) %&gt;% plot(layout="rect")
</code></pre>

<hr>
<h2 id='px.flood'>Select a region of homogeneous colour</h2><span id='topic+px.flood'></span>

<h3>Description</h3>

<p>Select pixels that are similar to a seed pixel. The underlying algorithm is the same as the bucket fill (AKA flood fill). Unlike with the bucket fill, the image isn't changed, the function simply returns a pixel set containing the selected pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>px.flood(im, x, y, z = 1, sigma = 0, high_connexity = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="px.flood_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="px.flood_+3A_x">x</code></td>
<td>
<p>X-coordinate of the starting point of the region to flood</p>
</td></tr>
<tr><td><code id="px.flood_+3A_y">y</code></td>
<td>
<p>Y-coordinate of the starting point of the region to flood</p>
</td></tr>
<tr><td><code id="px.flood_+3A_z">z</code></td>
<td>
<p>Z-coordinate of the starting point of the region to flood</p>
</td></tr>
<tr><td><code id="px.flood_+3A_sigma">sigma</code></td>
<td>
<p>Tolerance concerning neighborhood values.</p>
</td></tr>
<tr><td><code id="px.flood_+3A_high_connexity">high_connexity</code></td>
<td>
<p>Use 8-connexity (only for 2d images, default FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Old name: selectSimilar (deprecated)
</p>


<h3>See Also</h3>

<p>bucketfill
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Select part of a sail 
px &lt;- px.flood(boats,x=169,y=179,sigma=.2) 
plot(boats)
highlight(px)
</code></pre>

<hr>
<h2 id='px.na'>A pixset for NA values</h2><span id='topic+px.na'></span>

<h3>Description</h3>

<p>A pixset containing all NA pixels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>px.na(im)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="px.na_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pixset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- boats
im[1] &lt;- NA
px.na(im)
</code></pre>

<hr>
<h2 id='px.remove_outer'>Remove all connected regions that touch image boundaries</h2><span id='topic+px.remove_outer'></span>

<h3>Description</h3>

<p>All pixels that belong to a connected region in contact with image boundaries are set to FALSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>px.remove_outer(px)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="px.remove_outer_+3A_px">px</code></td>
<td>
<p>a pixset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pixset
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- draw_circle(imfill(100,100),c(0,50,100),c(50,50,50),radius=10,color=1)
plot(im)
as.pixset(im) %&gt;% px.remove_outer %&gt;% plot
</code></pre>

<hr>
<h2 id='RasterPackage'>Convert a RasterLayer/RasterBrick to a cimg image/image list</h2><span id='topic+RasterPackage'></span><span id='topic+as.cimg.RasterLayer'></span><span id='topic+as.imlist.RasterStackBrick'></span>

<h3>Description</h3>

<p>The raster library stores its data as &quot;RasterLayer&quot; and &quot;RasterBrick&quot; objects. The raster package can store its data  out-of-RAM, so in order not to load too much data the &quot;maxpixels&quot; argument sets a limit on how many pixels are loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RasterLayer'
as.cimg(obj, maxpixels = 1e+07, ...)

## S3 method for class 'RasterStackBrick'
as.imlist(obj, maxpixels = 1e+07, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RasterPackage_+3A_obj">obj</code></td>
<td>
<p>an object of class &quot;RasterLayer&quot;</p>
</td></tr>
<tr><td><code id="RasterPackage_+3A_maxpixels">maxpixels</code></td>
<td>
<p>max. number of pixels to load  (default 1e7)</p>
</td></tr>
<tr><td><code id="RasterPackage_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon Barthelme, adapted from the image method for RasterLayer by Robert J Hijmans
</p>

<hr>
<h2 id='renorm'>Renormalise image</h2><span id='topic+renorm'></span>

<h3>Description</h3>

<p>Pixel data is usually expressed on a 0...255 scale for displaying. This function performs a linear renormalisation to range min...max
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renorm(x, min = 0, max = 255)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renorm_+3A_x">x</code></td>
<td>
<p>numeric data</p>
</td></tr>
<tr><td><code id="renorm_+3A_min">min</code></td>
<td>
<p>min of the range</p>
</td></tr>
<tr><td><code id="renorm_+3A_max">max</code></td>
<td>
<p>max of the range</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
renorm(0:10)
renorm(-5:5) #Same as above
</code></pre>

<hr>
<h2 id='resize'>Resize image</h2><span id='topic+resize'></span>

<h3>Description</h3>

<p>If the dimension arguments are negative, they are interpreted as a proportion of the original image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resize(
  im,
  size_x = -100L,
  size_y = -100L,
  size_z = -100L,
  size_c = -100L,
  interpolation_type = 1L,
  boundary_conditions = 0L,
  centering_x = 0,
  centering_y = 0,
  centering_z = 0,
  centering_c = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resize_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="resize_+3A_size_x">size_x</code></td>
<td>
<p>Number of columns (new size along the X-axis).</p>
</td></tr>
<tr><td><code id="resize_+3A_size_y">size_y</code></td>
<td>
<p>Number of rows (new size along the Y-axis).</p>
</td></tr>
<tr><td><code id="resize_+3A_size_z">size_z</code></td>
<td>
<p>Number of slices (new size along the Z-axis).</p>
</td></tr>
<tr><td><code id="resize_+3A_size_c">size_c</code></td>
<td>
<p>Number of vector-channels (new size along the C-axis).</p>
</td></tr>
<tr><td><code id="resize_+3A_interpolation_type">interpolation_type</code></td>
<td>
<p>Method of interpolation:
-1 = no interpolation: raw memory resizing.
0 = no interpolation: additional space is filled according to  boundary_conditions.
1 = nearest-neighbor interpolation.
2 = moving average interpolation.
3 = linear interpolation.
4 = grid interpolation.
5 = cubic interpolation.
6 = lanczos interpolation.</p>
</td></tr>
<tr><td><code id="resize_+3A_boundary_conditions">boundary_conditions</code></td>
<td>
<p>Border condition type.</p>
</td></tr>
<tr><td><code id="resize_+3A_centering_x">centering_x</code></td>
<td>
<p>Set centering type (only if  interpolation_type=0).</p>
</td></tr>
<tr><td><code id="resize_+3A_centering_y">centering_y</code></td>
<td>
<p>Set centering type (only if  interpolation_type=0).</p>
</td></tr>
<tr><td><code id="resize_+3A_centering_z">centering_z</code></td>
<td>
<p>Set centering type (only if  interpolation_type=0).</p>
</td></tr>
<tr><td><code id="resize_+3A_centering_c">centering_c</code></td>
<td>
<p>Set centering type (only if  interpolation_type=0).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See imresize for an easier interface.
</p>

<hr>
<h2 id='resize_doubleXY'>Resize image uniformly</h2><span id='topic+resize_doubleXY'></span><span id='topic+resize_halfXY'></span><span id='topic+resize_tripleXY'></span><span id='topic+resize_uniform'></span><span id='topic+imresize'></span>

<h3>Description</h3>

<p>Resize image by a single scale factor. For non-uniform scaling and a wider range of options, see resize.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resize_doubleXY(im)

resize_halfXY(im)

resize_tripleXY(im)

imresize(im, scale = 1, interpolation = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resize_doubleXY_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="resize_doubleXY_+3A_scale">scale</code></td>
<td>
<p>a scale factor</p>
</td></tr>
<tr><td><code id="resize_doubleXY_+3A_interpolation">interpolation</code></td>
<td>
<p>interpolation method to use (see doc for resize). Default 3, linear. Set to 5 for cubic, 6 for Lanczos (higher quality).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>resize_doubleXY()</code>: Double size
</p>
</li>
<li> <p><code>resize_halfXY()</code>: Half size
</p>
</li>
<li> <p><code>resize_tripleXY()</code>: Triple size
</p>
</li>
<li> <p><code>imresize()</code>: resize by scale factor
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>References</h3>

<p>For double-scale, triple-scale, etc. uses an anisotropic scaling algorithm described in: <a href="http://www.scale2x.it/algorithm.html">http://www.scale2x.it/algorithm.html</a>. For half-scaling uses what the CImg doc describes as an &quot;optimised filter&quot;, see resize_halfXY in CImg.h.
</p>


<h3>See Also</h3>

<p>resize
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- load.example("parrots")
imresize(im,1/4) #Quarter size
map_il(2:4,~ imresize(im,1/.)) %&gt;% imappend("x") %&gt;% plot
</code></pre>

<hr>
<h2 id='RGBtoHSL'>Colour space conversions in imager</h2><span id='topic+RGBtoHSL'></span><span id='topic+RGBtoXYZ'></span><span id='topic+XYZtoRGB'></span><span id='topic+HSLtoRGB'></span><span id='topic+RGBtoHSV'></span><span id='topic+HSVtoRGB'></span><span id='topic+RGBtoHSI'></span><span id='topic+HSItoRGB'></span><span id='topic+RGBtosRGB'></span><span id='topic+sRGBtoRGB'></span><span id='topic+RGBtoYCbCr'></span><span id='topic+YCbCrtoRGB'></span><span id='topic+RGBtoYUV'></span><span id='topic+YUVtoRGB'></span><span id='topic+LabtoRGB'></span><span id='topic+RGBtoLab'></span><span id='topic+LabtoXYZ'></span><span id='topic+XYZtoLab'></span><span id='topic+LabtosRGB'></span><span id='topic+sRGBtoLab'></span><span id='topic+imager.colourspaces'></span>

<h3>Description</h3>

<p>All functions listed here assume the input image has three colour channels (spectrum(im) == 3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGBtoHSL(im)

RGBtoXYZ(im)

XYZtoRGB(im)

HSLtoRGB(im)

RGBtoHSV(im)

HSVtoRGB(im)

RGBtoHSI(im)

HSItoRGB(im)

RGBtosRGB(im)

sRGBtoRGB(im)

RGBtoYCbCr(im)

YCbCrtoRGB(im)

RGBtoYUV(im)

YUVtoRGB(im)

LabtoRGB(im)

RGBtoLab(im)

LabtoXYZ(im)

XYZtoLab(im)

LabtosRGB(im)

sRGBtoLab(im)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RGBtoHSL_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>RGBtoHSL()</code>: RGB to HSL conversion
</p>
</li>
<li> <p><code>RGBtoXYZ()</code>: CIE RGB to CIE XYZ (1931) conversion, D65 white point
</p>
</li>
<li> <p><code>XYZtoRGB()</code>: CIE XYZ to CIE RGB (1931) conversion, D65 white point
</p>
</li>
<li> <p><code>HSLtoRGB()</code>: HSL to RGB conversion
</p>
</li>
<li> <p><code>RGBtoHSV()</code>: RGB to HSV conversion
</p>
</li>
<li> <p><code>HSVtoRGB()</code>: HSV to RGB conversion
</p>
</li>
<li> <p><code>RGBtoHSI()</code>: RGB to HSI conversion
</p>
</li>
<li> <p><code>HSItoRGB()</code>: HSI to RGB conversion
</p>
</li>
<li> <p><code>RGBtosRGB()</code>: RGB to sRGB conversion
</p>
</li>
<li> <p><code>sRGBtoRGB()</code>: sRGB to RGB conversion
</p>
</li>
<li> <p><code>RGBtoYCbCr()</code>: RGB to YCbCr conversion
</p>
</li>
<li> <p><code>YCbCrtoRGB()</code>: YCbCr to RGB conversion
</p>
</li>
<li> <p><code>RGBtoYUV()</code>: RGB to YUV conversion
</p>
</li>
<li> <p><code>YUVtoRGB()</code>: YUV to RGB conversion
</p>
</li>
<li> <p><code>LabtoRGB()</code>: Lab to RGB (linear)
</p>
</li>
<li> <p><code>RGBtoLab()</code>: RGB (linear) to Lab
</p>
</li>
<li> <p><code>LabtoXYZ()</code>: Lab to XYZ
</p>
</li>
<li> <p><code>XYZtoLab()</code>: XYZ to Lab
</p>
</li>
<li> <p><code>LabtosRGB()</code>: Lab to sRGB
</p>
</li>
<li> <p><code>sRGBtoLab()</code>: sRGB to Lab
</p>
</li></ul>

<hr>
<h2 id='rm.alpha'>Remove alpha channel and store as attribute</h2><span id='topic+rm.alpha'></span>

<h3>Description</h3>

<p>Remove alpha channel and store as attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.alpha(im)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm.alpha_+3A_im">im</code></td>
<td>
<p>an image with 4 RGBA colour channels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image with only three RGB channels and the alpha channel as attribute
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>flatten.alpha
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#An image with 4 colour channels (RGBA)
im &lt;- imfill(2,2,val=c(0,0,0,0))
#Remove fourth channel
rm.alpha(im)
attr(rm.alpha(im),"alpha")
</code></pre>

<hr>
<h2 id='rotate_xy'>Rotate image by an arbitrary angle, around a center point.</h2><span id='topic+rotate_xy'></span>

<h3>Description</h3>

<p>Rotate image by an arbitrary angle, around a center point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_xy(im, angle, cx, cy, interpolation = 1L, boundary_conditions = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_xy_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="rotate_xy_+3A_angle">angle</code></td>
<td>
<p>Rotation angle, in degrees.</p>
</td></tr>
<tr><td><code id="rotate_xy_+3A_cx">cx</code></td>
<td>
<p>X-coordinate of the rotation center.</p>
</td></tr>
<tr><td><code id="rotate_xy_+3A_cy">cy</code></td>
<td>
<p>Y-coordinate of the rotation center.</p>
</td></tr>
<tr><td><code id="rotate_xy_+3A_interpolation">interpolation</code></td>
<td>
<p>Interpolation type. 0=nearest | 1=linear | 2=cubic</p>
</td></tr>
<tr><td><code id="rotate_xy_+3A_boundary_conditions">boundary_conditions</code></td>
<td>
<p>Boundary conditions. 0=dirichlet | 1=neumann | 2=periodic</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
rotate_xy(boats,30,200,400) %&gt;% plot
rotate_xy(boats,30,200,400,boundary=2) %&gt;% plot
</code></pre>

<hr>
<h2 id='save.image'>Save image</h2><span id='topic+save.image'></span>

<h3>Description</h3>

<p>You'll need ImageMagick for formats other than PNG and JPEG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.image(im, file, quality = 0.7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.image_+3A_im">im</code></td>
<td>
<p>an image (of class cimg)</p>
</td></tr>
<tr><td><code id="save.image_+3A_file">file</code></td>
<td>
<p>path to file. The format is determined by the file's name</p>
</td></tr>
<tr><td><code id="save.image_+3A_quality">quality</code></td>
<td>
<p>(JPEG only) default 0.7. Higher quality means less compression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p>save.video
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create temporary file
tmpF &lt;- tempfile(fileext=".png")
#Save boats image
save.image(boats,tmpF)
#Read back and display
load.image(tmpF) %&gt;% plot
</code></pre>

<hr>
<h2 id='split_connected'>Split pixset into connected components</h2><span id='topic+split_connected'></span>

<h3>Description</h3>

<p>Compute connected components (using &quot;label&quot;), then split into as many sets as there are components.
Useful for segmentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_connected(px, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_connected_+3A_px">px</code></td>
<td>
<p>a pixset</p>
</td></tr>
<tr><td><code id="split_connected_+3A_...">...</code></td>
<td>
<p>further arguments passed to label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of pixsets
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>label
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
px &lt;- isoblur(grayscale(boats),5) &gt; .75
plot(px)
spl &lt;- split_connected(px)
plot(spl[[1]])
px &lt;- isoblur(grayscale(boats),5) &gt; .75
plot(px)
spl &lt;- split_connected(px)
plot(spl[[1]])
</code></pre>

<hr>
<h2 id='squeeze'>Remove empty dimensions from an array</h2><span id='topic+squeeze'></span>

<h3>Description</h3>

<p>Works just like Matlab's squeeze function: if anything in dim(x) equals one the corresponding dimension is removed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>squeeze(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="squeeze_+3A_x">x</code></td>
<td>
<p>an array</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- array(1:9,c(3,1,3)) #3D array with one flat dimension
A %&gt;% squeeze #flat dimension removed
</code></pre>

<hr>
<h2 id='stencil.cross'>A cross-shaped stencil</h2><span id='topic+stencil.cross'></span>

<h3>Description</h3>

<p>Returns a stencil corresponding to all nearest-neighbours of a pixel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stencil.cross(z = FALSE, cc = FALSE, origin = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stencil.cross_+3A_z">z</code></td>
<td>
<p>include neighbours along the z axis</p>
</td></tr>
<tr><td><code id="stencil.cross_+3A_cc">cc</code></td>
<td>
<p>include neighbours along the cc axis</p>
</td></tr>
<tr><td><code id="stencil.cross_+3A_origin">origin</code></td>
<td>
<p>include center pixel (default false)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame defining a stencil
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>See Also</h3>

<p>get.stencil
</p>

<hr>
<h2 id='threshold'>Threshold grayscale image</h2><span id='topic+threshold'></span>

<h3>Description</h3>

<p>Thresholding corresponding to setting all values below a threshold to 0, all above to 1.
If you call threshold with thr=&quot;auto&quot; a threshold will be computed automatically using kmeans (ie., using a variant of Otsu's method).
This works well if the pixel values have a clear bimodal distribution. If you call threshold with a string argument of the form &quot;XX%&quot; (e.g., &quot;98%&quot;), the threshold will be set at percentile XX.
Computing quantiles or running kmeans is expensive for large images, so if approx == TRUE threshold will skip pixels if the total number of pixels is above 10,000. Note that thresholding a colour image will threshold all the colour channels jointly, which may not be the desired behaviour! Use iiply(im,&quot;c&quot;,threshold) to find optimal values for each channel separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold(im, thr = "auto", approx = TRUE, adjust = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_+3A_im">im</code></td>
<td>
<p>the image</p>
</td></tr>
<tr><td><code id="threshold_+3A_thr">thr</code></td>
<td>
<p>a threshold, either numeric, or &quot;auto&quot;, or a string for quantiles</p>
</td></tr>
<tr><td><code id="threshold_+3A_approx">approx</code></td>
<td>
<p>Skip pixels when computing quantiles in large images (default TRUE)</p>
</td></tr>
<tr><td><code id="threshold_+3A_adjust">adjust</code></td>
<td>
<p>use to adjust the automatic threshold: if the auto-threshold is at k, effective threshold will be at adjust*k (default 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pixset with the selected pixels
</p>


<h3>Author(s)</h3>

<p>Simon Barthelme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
im &lt;- load.example("birds")
im.g &lt;- grayscale(im)
threshold(im.g,"15%") %&gt;% plot
threshold(im.g,"auto") %&gt;% plot
threshold(im.g,.1) %&gt;% plot
#If auto-threshold is too high, adjust downwards or upwards
#using "adjust"
threshold(im,adjust=.5) %&gt;% plot
threshold(im,adjust=1.3) %&gt;% plot
</code></pre>

<hr>
<h2 id='vanvliet'>Young-Van Vliet recursive Gaussian filter.</h2><span id='topic+vanvliet'></span>

<h3>Description</h3>

<p>The Young-van Vliet filter is a fast approximation to a Gaussian filter (order = 0), or Gaussian derivatives (order = 1 or 2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vanvliet(im, sigma, order = 0L, axis = "x", neumann = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vanvliet_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="vanvliet_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of the Gaussian filter</p>
</td></tr>
<tr><td><code id="vanvliet_+3A_order">order</code></td>
<td>
<p>the order of the filter 0,1,2,3</p>
</td></tr>
<tr><td><code id="vanvliet_+3A_axis">axis</code></td>
<td>
<p>Axis along which the filter is computed. One of 'x', 'y', 'z', 'c'</p>
</td></tr>
<tr><td><code id="vanvliet_+3A_neumann">neumann</code></td>
<td>
<p>If true, use Neumann boundary conditions (default false, Dirichlet)</p>
</td></tr>
</table>


<h3>References</h3>

<p>From: I.T. Young, L.J. van Vliet, M. van Ginkel, Recursive Gabor filtering.
IEEE Trans. Sig. Proc., vol. 50, pp. 2799-2805, 2002.
(this is an improvement over Young-Van Vliet, Sig. Proc. 44, 1995)
</p>
<p>Boundary conditions (only for order 0) using Triggs matrix, from
B. Triggs and M. Sdika. Boundary conditions for Young-van Vliet
recursive filtering. IEEE Trans. Signal Processing,
vol. 54, pp. 2365-2367, 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vanvliet(boats,sigma=2,order=0) %&gt;% plot("Zeroth-order Young-van Vliet along x")
vanvliet(boats,sigma=2,order=1) %&gt;% plot("First-order Young-van Vliet along x")
vanvliet(boats,sigma=2,order=1) %&gt;% plot("Second-order Young-van Vliet along x")
vanvliet(boats,sigma=2,order=1,axis="y") %&gt;% plot("Second-order Young-van Vliet along y")
</code></pre>

<hr>
<h2 id='warp'>Warp image</h2><span id='topic+warp'></span>

<h3>Description</h3>

<p>Warp image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warp(im, warpfield, mode = 0L, interpolation = 1L, boundary_conditions = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warp_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="warp_+3A_warpfield">warpfield</code></td>
<td>
<p>Warping field. The (x,y,z) fields should be stacked along the colour coordinate.</p>
</td></tr>
<tr><td><code id="warp_+3A_mode">mode</code></td>
<td>
<p>Can be 0=backward-absolute | 1=backward-relative | 2=forward-absolute | 3=forward-relative</p>
</td></tr>
<tr><td><code id="warp_+3A_interpolation">interpolation</code></td>
<td>
<p>Can be 0=nearest | 1=linear | 2=cubic.</p>
</td></tr>
<tr><td><code id="warp_+3A_boundary_conditions">boundary_conditions</code></td>
<td>
<p>Boundary conditions. Can be 0=dirichlet | 1=neumann | 2=periodic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>imwarp for a user-friendly interface
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Shift image via warp
warp.x &lt;- imfill(width(boats),height(boats),val=5)
warp.y &lt;- imfill(width(boats),height(boats),val=20)
warpfield &lt;- list(warp.x,warp.y) %&gt;% imappend("c")
warp(boats,warpfield,mode=1) %&gt;% plot
</code></pre>

<hr>
<h2 id='watershed'>Compute watershed transform.</h2><span id='topic+watershed'></span>

<h3>Description</h3>

<p>The watershed transform is a label propagation algorithm. The value of non-zero pixels will get propagated to their zero-value neighbours. The propagation is controlled by a priority map. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>watershed(im, priority, fill_lines = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="watershed_+3A_im">im</code></td>
<td>
<p>an image</p>
</td></tr>
<tr><td><code id="watershed_+3A_priority">priority</code></td>
<td>
<p>Priority map.</p>
</td></tr>
<tr><td><code id="watershed_+3A_fill_lines">fill_lines</code></td>
<td>
<p>Sets if watershed lines must be filled or not.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#In our initial image we'll place three seeds 
#(non-zero pixels) at various locations, with values 1, 2 and 3. 
#We'll use the watershed algorithm to propagate these values
imd &lt;- function(x,y) imdirac(c(100,100,1,1),x,y)
im &lt;- imd(20,20)+2*imd(40,40)+3*imd(80,80)
layout(t(1:3))
plot(im,main="Seed image")
#Now we build an priority map: neighbours of our seeds 
#should get high priority. 
#We'll use a distance map for that
p &lt;- 1-distance_transform(sign(im),1) 
plot(p,main="Priority map")
watershed(im,p) %&gt;% plot(main="Watershed transform")
</code></pre>

<hr>
<h2 id='where'>Return locations in pixel set</h2><span id='topic+where'></span>

<h3>Description</h3>

<p>Return locations in pixel set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="where_+3A_x">x</code></td>
<td>
<p>a pixset</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#All pixel locations with value greater than .99
where(boats &gt; .99) 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
