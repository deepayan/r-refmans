<!DOCTYPE html><html><head><title>Help for package handwriter</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {handwriter}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#handwriter-package'><p>handwriter: Handwriting Analysis in R</p></a></li>
<li><a href='#about_variable'><p>About Varialbe</p></a></li>
<li><a href='#AddLetterImages'><p>Add Letter Images</p></a></li>
<li><a href='#addToFeatures'><p>addToFeatures</p></a></li>
<li><a href='#analyze_questioned_documents'><p>Analyze Questioned Documents</p></a></li>
<li><a href='#calculate_accuracy'><p>Calculate Accuracy</p></a></li>
<li><a href='#cleanBinaryImage'><p>cleanBinaryImage</p></a></li>
<li><a href='#csafe'><p>Cursive written word: csafe</p></a></li>
<li><a href='#drop_burnin'><p>Drop Burn-In</p></a></li>
<li><a href='#example_analysis'><p>Example of writership analysis</p></a></li>
<li><a href='#example_cluster_template'><p>Example cluster template</p></a></li>
<li><a href='#example_model'><p>Example of a hierarchical model</p></a></li>
<li><a href='#extractGraphs'><p>Extract Graphs</p></a></li>
<li><a href='#fit_model'><p>Fit Model</p></a></li>
<li><a href='#format_template_data'><p>Format Template Data</p></a></li>
<li><a href='#get_cluster_fill_counts'><p>get_cluster_fill_counts</p></a></li>
<li><a href='#get_clusters_batch'><p>get_clusters_batch</p></a></li>
<li><a href='#get_credible_intervals'><p>Get Credible Intervals</p></a></li>
<li><a href='#get_posterior_probabilities'><p>Get Posterior Probabilities</p></a></li>
<li><a href='#london'><p>Cursive written word: London</p></a></li>
<li><a href='#make_clustering_template'><p>Make Clustering Template</p></a></li>
<li><a href='#message'><p>Full page image of the handwritten London letter.</p></a></li>
<li><a href='#nature1'><p>Full page image of the 4th sample (nature) of handwriting from the first writer.</p></a></li>
<li><a href='#plot_cluster_fill_counts'><p>Plot Cluster Fill Counts</p></a></li>
<li><a href='#plot_cluster_fill_rates'><p>Plot Cluster Fill Rates</p></a></li>
<li><a href='#plot_credible_intervals'><p>Plot Credible Intervals</p></a></li>
<li><a href='#plot_posterior_probabilities'><p>Plot Posterior Probabilities</p></a></li>
<li><a href='#plot_trace'><p>Plot Trace</p></a></li>
<li><a href='#plotImage'><p>Plot Image</p></a></li>
<li><a href='#plotImageThinned'><p>Plot Thinned Image</p></a></li>
<li><a href='#plotLetter'><p>Plot Letter</p></a></li>
<li><a href='#plotLine'><p>Plot Line</p></a></li>
<li><a href='#plotNodes'><p>Plot Nodes</p></a></li>
<li><a href='#process_batch_dir'><p>Process Batch Directory</p></a></li>
<li><a href='#process_batch_list'><p>Process Batch List</p></a></li>
<li><a href='#processDocument'><p>Process Document</p></a></li>
<li><a href='#processHandwriting'><p>Process Handwriting by Component</p></a></li>
<li><a href='#read_and_process'><p>Read and Process</p></a></li>
<li><a href='#readPNGBinary'><p>Read PNG Binary</p></a></li>
<li><a href='#rgb2grayscale'><p>rgba2grayscale</p></a></li>
<li><a href='#rgba2rgb'><p>rgba2rgb</p></a></li>
<li><a href='#SaveAllLetterPlots'><p>Save All Letter Plots</p></a></li>
<li><a href='#thinImage'><p>thinImage</p></a></li>
<li><a href='#twoSent'><p>Two sentence printed example handwriting</p></a></li>
<li><a href='#whichToFill'><p>whichToFill</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Handwriting Analysis in R</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephanie Reinders &lt;srein@iastate.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform statistical writership analysis of scanned handwritten documents.
             Webpage provided at: <a href="https://github.com/CSAFE-ISU/handwriter">https://github.com/CSAFE-ISU/handwriter</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, dplyr, foreach, ggplot2, igraph, lpSolve, magick,
mc2d, png, purrr, Rcpp, reshape2, Rfast, rjags, stringr, tidyr,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), coda, withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CSAFE-ISU/handwriter">https://github.com/CSAFE-ISU/handwriter</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CSAFE-ISU/handwriter/issues">https://github.com/CSAFE-ISU/handwriter/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-14 23:48:01 UTC; stephanie</td>
</tr>
<tr>
<td>Author:</td>
<td>Iowa State University of Science and Technology on behalf of its Center
    for Statistics and Applications in Forensic Evidence [aut, cph,
    fnd],
  Nick Berry [aut],
  Stephanie Reinders [aut, cre],
  James Taylor [aut],
  Felix Baez-Santiago [ctb],
  Jon González [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-15 00:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='handwriter-package'>handwriter: Handwriting Analysis in R</h2><span id='topic+handwriter'></span><span id='topic+handwriter-package'></span>

<h3>Description</h3>

<p>Perform statistical writership analysis of scanned handwritten documents. Webpage provided at: <a href="https://github.com/CSAFE-ISU/handwriter">https://github.com/CSAFE-ISU/handwriter</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Stephanie Reinders <a href="mailto:srein@iastate.edu">srein@iastate.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Iowa State University of Science and Technology on behalf of its Center for Statistics and Applications in Forensic Evidence [copyright holder, funder]
</p>
</li>
<li><p> Nick Berry
</p>
</li>
<li><p> James Taylor
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Felix Baez-Santiago [contributor]
</p>
</li>
<li><p> Jon González [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/CSAFE-ISU/handwriter">https://github.com/CSAFE-ISU/handwriter</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/CSAFE-ISU/handwriter/issues">https://github.com/CSAFE-ISU/handwriter/issues</a>
</p>
</li></ul>


<hr>
<h2 id='about_variable'>About Varialbe</h2><span id='topic+about_variable'></span>

<h3>Description</h3>

<p><code>about_variable()</code> returns information about the model variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>about_variable(variable, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="about_variable_+3A_variable">variable</code></td>
<td>
<p>A variable in the fitted model output by <code><a href="#topic+fit_model">fit_model()</a></code></p>
</td></tr>
<tr><td><code id="about_variable_+3A_model">model</code></td>
<td>
<p>A fitted model created by <code><a href="#topic+fit_model">fit_model()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text that explains the variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>about_variable(
  variable = "mu[1,2]",
  model = example_model
)

</code></pre>

<hr>
<h2 id='AddLetterImages'>Add Letter Images</h2><span id='topic+AddLetterImages'></span>

<h3>Description</h3>

<p>Pulls out letterlist as its own object, and adds the image matrix as well
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddLetterImages(letterList, dims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddLetterImages_+3A_letterlist">letterList</code></td>
<td>
<p>Letter list from processHandwriting function</p>
</td></tr>
<tr><td><code id="AddLetterImages_+3A_dims">dims</code></td>
<td>
<p>Dimensions of the original document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>letterList with a new matrix <code>image</code> value for each sublist.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twoSent_document = list()
twoSent_document$image = twoSent
twoSent_document$thin = thinImage(twoSent_document$image)
twoSent_processList = processHandwriting(twoSent_document$thin, dim(twoSent_document$image))

dims = dim(twoSent_document$image)
withLetterImages = AddLetterImages(twoSent_processList$letterList, dims)

</code></pre>

<hr>
<h2 id='addToFeatures'>addToFeatures</h2><span id='topic+addToFeatures'></span>

<h3>Description</h3>

<p>addToFeatures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addToFeatures(FeatureSet, LetterList, vectorDims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addToFeatures_+3A_featureset">FeatureSet</code></td>
<td>
<p>The current list of features that have been calculated</p>
</td></tr>
<tr><td><code id="addToFeatures_+3A_letterlist">LetterList</code></td>
<td>
<p>List of all letters and their information</p>
</td></tr>
<tr><td><code id="addToFeatures_+3A_vectordims">vectorDims</code></td>
<td>
<p>Vectors with image Dims</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of current features calculated in FeatureSet as well as measures of compactness, loop count, and loop dimensions
</p>

<hr>
<h2 id='analyze_questioned_documents'>Analyze Questioned Documents</h2><span id='topic+analyze_questioned_documents'></span>

<h3>Description</h3>

<p><code>analyze_questioned_documents()</code> estimates the posterior probability of
writership for the questioned documents using Markov Chain Monte Carlo (MCMC) draws from a hierarchical
model created with <code><a href="#topic+fit_model">fit_model()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_questioned_documents(
  main_dir,
  questioned_docs,
  model,
  num_cores,
  writer_indices,
  doc_indices
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_questioned_documents_+3A_main_dir">main_dir</code></td>
<td>
<p>A directory that contains a cluster template created by <code><a href="#topic+make_clustering_template">make_clustering_template()</a></code></p>
</td></tr>
<tr><td><code id="analyze_questioned_documents_+3A_questioned_docs">questioned_docs</code></td>
<td>
<p>A directory containing questioned documents</p>
</td></tr>
<tr><td><code id="analyze_questioned_documents_+3A_model">model</code></td>
<td>
<p>A fitted model created by <code><a href="#topic+fit_model">fit_model()</a></code></p>
</td></tr>
<tr><td><code id="analyze_questioned_documents_+3A_num_cores">num_cores</code></td>
<td>
<p>An integer number of cores to use for parallel processing
with the <code>doParallel</code> package.</p>
</td></tr>
<tr><td><code id="analyze_questioned_documents_+3A_writer_indices">writer_indices</code></td>
<td>
<p>A vector of start and stop characters for writer IDs in file names</p>
</td></tr>
<tr><td><code id="analyze_questioned_documents_+3A_doc_indices">doc_indices</code></td>
<td>
<p>A vector of start and stop characters for document names in file names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of likelihoods, votes, and posterior probabilities of
writership for each questioned document.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
main_dir &lt;- "/path/to/main_dir"
questioned_docs &lt;- "/path/to/questioned_images"
analysis &lt;- analyze_questioned_documents(
  main_dir = main_dir,
  questioned_docs = questioned_docs,
  model = model,
  num_cores = 2,
  writer_indices = c(2, 5),
  doc_indices = c(7, 18)
)
analysis$posterior_probabilities

## End(Not run)

</code></pre>

<hr>
<h2 id='calculate_accuracy'>Calculate Accuracy</h2><span id='topic+calculate_accuracy'></span>

<h3>Description</h3>

<p>Fit a model with <code><a href="#topic+fit_model">fit_model()</a></code> and calculate posterior probabilities of
writership with <code><a href="#topic+analyze_questioned_documents">analyze_questioned_documents()</a></code> of a set of test documents
where the ground truth is known. Then use <code>calculate_accuracy()</code> to measure
the accuracy of the fitted model on the test documents. Accuracy is calculated as
the average posterior probability assigned to the true writer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_accuracy(analysis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_accuracy_+3A_analysis">analysis</code></td>
<td>
<p>Writership analysis output by
<code><a href="#topic+analyze_questioned_documents">analyze_questioned_documents</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The model's accuracy on the test set as a number
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calculate the accuracy for example analysis performed on test documents and a model with 1 chain
calculate_accuracy(example_analysis)

## Not run: 
main_dir &lt;- "/path/to/main_dir"
test_images_dir &lt;- "/path/to/test_images"
analysis &lt;- analyze_questioned_documents(
  main_dir = main_dir,
  questioned_docs = test_images_dir,
  model = model,
  num_cores = 2,
  writer_indices = c(2, 5),
  doc_indices = c(7, 18)
)
calculate_accuracy(analysis)

## End(Not run)

</code></pre>

<hr>
<h2 id='cleanBinaryImage'>cleanBinaryImage</h2><span id='topic+cleanBinaryImage'></span>

<h3>Description</h3>

<p>Removes alpha channel from png image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanBinaryImage(img)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanBinaryImage_+3A_img">img</code></td>
<td>
<p>A matrix of 1s and 0s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>png image with the alpha channel removed
</p>

<hr>
<h2 id='csafe'>Cursive written word: csafe</h2><span id='topic+csafe'></span>

<h3>Description</h3>

<p>Cursive written word: csafe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csafe
</code></pre>


<h3>Format</h3>

<p>Binary image matrix. 111 rows and 410 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>csafe_document &lt;- list()
csafe_document$image &lt;- csafe
plotImage(csafe_document)
csafe_document$thin &lt;- thinImage(csafe_document$image)
plotImageThinned(csafe_document)
csafe_processList &lt;- processHandwriting(csafe_document$thin, dim(csafe_document$image))
</code></pre>

<hr>
<h2 id='drop_burnin'>Drop Burn-In</h2><span id='topic+drop_burnin'></span>

<h3>Description</h3>

<p><code>drop_burnin()</code> removes the burn-in from the Markov Chain Monte Carlo (MCMC) draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_burnin(model, burn_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_burnin_+3A_model">model</code></td>
<td>
<p>A list of MCMC draws from a model fit with <code><a href="#topic+fit_model">fit_model()</a></code>.</p>
</td></tr>
<tr><td><code id="drop_burnin_+3A_burn_in">burn_in</code></td>
<td>
<p>An integer number of starting iterations to drop from each MCMC chain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames of MCMC draws with burn-in dropped.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- drop_burnin(model = example_model, burn_in = 25)
plot_trace(variable = "mu[1,2]", model = example_model)

</code></pre>

<hr>
<h2 id='example_analysis'>Example of writership analysis</h2><span id='topic+example_analysis'></span>

<h3>Description</h3>

<p>Example of writership analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_analysis
</code></pre>


<h3>Format</h3>

<p>The results of <code><a href="#topic+analyze_questioned_documents">analyze_questioned_documents()</a></code> stored in a named list with 5 items:
</p>

<dl>
<dt>graph_measurements</dt><dd><p>A data frame of that shows the writer, document name, cluster assignment,
slope, principle component rotation angle, and wrapped principle component rotation angle for each training graph in each
questioned documents.</p>
</dd>
<dt>cluster_fill_counts</dt><dd><p>A data frame of the cluster fill counts for each questioned document.</p>
</dd>
<dt>likelihoods</dt><dd><p>A list of data frames where each data frame
contains the likelihoods for a questioned document for each MCMC iteration.</p>
</dd>
<dt>votes</dt><dd><p>A list of vote tallies for each questioned document.</p>
</dd>
<dt>posterior_probabilites</dt><dd><p>A list of posterior probabilities of writership
for each questioned document and each known writer in the closed set used to train the
hierarchical model.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>plot_cluster_fill_counts(formatted_data = example_analysis)
plot_posterior_probabilities(analysis = example_analysis)

</code></pre>

<hr>
<h2 id='example_cluster_template'>Example cluster template</h2><span id='topic+example_cluster_template'></span>

<h3>Description</h3>

<p>An example cluster template created with <code><a href="#topic+make_clustering_template">make_clustering_template()</a></code>. The
cluster template was created from handwriting samples
&quot;w0016_s01_pLND_r01.png&quot;, &quot;w0080_s01_pLND_r01.png&quot;, &quot;w0124_s01_pLND_r01.png&quot;,
&quot;w0138_s01_pLND_r01.png&quot;, and &quot;w0299_s01_pLND_r01.png&quot; from the CSAFE Handwriting
Database. The template has K=5 clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_cluster_template
</code></pre>


<h3>Format</h3>

<p>A list containing a single cluster template created by
<code><a href="#topic+make_clustering_template">make_clustering_template()</a></code>. The cluster template was created by sorting
a random sample of 1000 graphs from 10 training documents into 10 clusters
with a K-means algorithm. The cluster template is a named list with 16
items:
</p>

<dl>
<dt>seed</dt><dd><p>An integer for the random number generator.</p>
</dd>
<dt>cluster</dt><dd><p>A vector of cluster assignments
for each graph used to create the cluster template.</p>
</dd>
<dt>centers</dt><dd><p>A list
of graphs used as the starting cluster centers for the K-means algorithm.</p>
</dd>
<dt>K</dt><dd><p>The number of clusters to build (10) with the K-means algorithm.</p>
</dd>
<dt>n</dt><dd><p>The number of training graphs to use (1000) in the K-means
algorithm.</p>
</dd>
<dt>docnames</dt><dd><p>A vector that lists the training document from which each graph originated.</p>
</dd>
<dt>writers</dt><dd><p>A vector that lists the writer of each graph.</p>
</dd>
<dt>iters</dt><dd><p>The maximum number of iterations for the K-means
algorithm (3).</p>
</dd>
<dt>changes</dt><dd><p>A vector of the number of graphs that
changed clusters on each iteration of the K-means algorithm.</p>
</dd>
<dt>outlierCutoff</dt><dd><p>A vector of the outlier cutoff values calculated on
each iteration of the K-means algorithm.</p>
</dd>
<dt>stop_reason</dt><dd><p>The reason the
K-means algorithm terminated.</p>
</dd>
<dt>wcd</dt><dd><p>A matrix of the within cluster
distances on each iteration of the K-means algorithm. More specifically,
the distance between each graph and the center of the cluster to which it
was assigned  on each iteration.</p>
</dd>
<dt>wcss</dt><dd><p>A vector of the
within-cluster sum of squares on each iteration of the K-means algorithm.</p>
</dd></dl>



<h3>Examples</h3>

<pre><code class='language-R'># view cluster fill counts for template training documents
template_data &lt;- format_template_data(example_cluster_template)
plot_cluster_fill_counts(template_data, facet = TRUE)

</code></pre>

<hr>
<h2 id='example_model'>Example of a hierarchical model</h2><span id='topic+example_model'></span>

<h3>Description</h3>

<p>Example of a hierarchical model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_model
</code></pre>


<h3>Format</h3>

<p>A hierarchical model created by <code><a href="#topic+fit_model">fit_model</a></code> with a single chain of 100 MCMC iterations. It is a named
list of 4 objects:
</p>

<dl>
<dt>graph_measurements</dt><dd><p>A data frame of model training data that shows the writer, document name, cluster assignment,
slope, principle component rotation angle, and wrapped principle component rotation angle for each training graph.</p>
</dd>
<dt>cluster_fill_counts</dt><dd><p>A data frame of the cluster fill counts for each model training document.</p>
</dd>
<dt>rjags_data</dt><dd><p>The model training information from <code>graph_measurements</code> and <code>cluster_fill_counts</code> formatted for RJAGS.</p>
</dd>
<dt>fitted_model</dt><dd><p>A model fit using the <code>rjags_data</code> and the RJAGS and coda packages. It is an MCMC list that contains a single
MCMC object.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># convert to a data frame and view all variable names
df &lt;- as.data.frame(coda::as.mcmc(example_model$fitted_model))
colnames(df)

# view a trace plot
plot_trace(variable = "mu[1,1]", model = example_model)

# drop the first 25 MCMC iterations for burn-in
model &lt;- drop_burnin(model = example_model, burn_in = 25)

## Not run: 
# analyze questioned documents
main_dir &lt;- /path/to/main_dir
questioned_docs &lt;- /path/to/questioned_documents_directory
analysis &lt;- analyze_questioned_documents(
   main_dir = main_dir,
   questioned_docs = questioned_docs
   model = example_model
   num_cores = 2
)
analysis$posterior_probabilities

## End(Not run)

</code></pre>

<hr>
<h2 id='extractGraphs'>Extract Graphs</h2><span id='topic+extractGraphs'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;superseded&quot;)'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractGraphs(source_folder = getwd(), save_folder = getwd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractGraphs_+3A_source_folder">source_folder</code></td>
<td>
<p>path to folder containing .png images</p>
</td></tr>
<tr><td><code id="extractGraphs_+3A_save_folder">save_folder</code></td>
<td>
<p>path to folder where graphs are saved to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Development on 'extractGraphs()' is complete. We recommend using 'process_batch_dir()' instead.
</p>
<p>Extracts graphs from .png images and saves each by their respective writer.
</p>


<h3>Value</h3>

<p>saves graphs in an rds file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sof = "path to folder containing .png images"
saf = "path to folder where graphs will be saved to"
extractGraphs(sof, saf)

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_model'>Fit Model</h2><span id='topic+fit_model'></span>

<h3>Description</h3>

<p><code>fit_model()</code> fits a Bayesian hierarchical model to the model training data
in <code>model_docs</code> and draws samples from the model as Markov Chain Monte
Carlo (MCMC) estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_model(
  main_dir,
  model_docs,
  num_iters,
  num_chains = 1,
  num_cores,
  writer_indices,
  doc_indices,
  a = 2,
  b = 0.25,
  c = 2,
  d = 2,
  e = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_model_+3A_main_dir">main_dir</code></td>
<td>
<p>A directory that contains a cluster template created by
<code><a href="#topic+make_clustering_template">make_clustering_template()</a></code></p>
</td></tr>
<tr><td><code id="fit_model_+3A_model_docs">model_docs</code></td>
<td>
<p>A directory containing model training documents</p>
</td></tr>
<tr><td><code id="fit_model_+3A_num_iters">num_iters</code></td>
<td>
<p>An integer number of iterations of MCMC.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_num_chains">num_chains</code></td>
<td>
<p>An integer number of chains to use.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_num_cores">num_cores</code></td>
<td>
<p>An integer number of cores to use for parallel processing
clustering assignments. The model fitting is not done in parallel.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_writer_indices">writer_indices</code></td>
<td>
<p>A vector of the start and stop character of the writer
ID in the model training file names. E.g., if the file names are
writer0195_doc1, writer0210_doc1, writer0033_doc1 then writer_indices is
'c(7,10)'.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_doc_indices">doc_indices</code></td>
<td>
<p>A vector of the start and stop character of the &quot;document
name&quot; in the model training file names. This is used to distinguish between
two documents written by the same writer. E.g., if the file names are
writer0195_doc1, writer0195_doc2, writer0033_doc1, writer0033_doc2 then
doc_indices are 'c(12,15)'.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_a">a</code></td>
<td>
<p>The shape parameter for the Gamma distribution in the hierarchical
model</p>
</td></tr>
<tr><td><code id="fit_model_+3A_b">b</code></td>
<td>
<p>The rate parameter for the Gamma distribution in the hierarchical
model</p>
</td></tr>
<tr><td><code id="fit_model_+3A_c">c</code></td>
<td>
<p>The first shape parameter for the Beta distribution in the
hierarchical model</p>
</td></tr>
<tr><td><code id="fit_model_+3A_d">d</code></td>
<td>
<p>The second shape parameter for the Beta distribution in the
hierarchical model</p>
</td></tr>
<tr><td><code id="fit_model_+3A_e">e</code></td>
<td>
<p>The scale parameter for the hyper prior for mu in the hierarchical
model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of training data used to fit the model and the fitted model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
main_dir &lt;- "/path/to/main_dir"
model_docs &lt;- "path/to/model_training_docs"
questioned_docs &lt;- "path/to/questioned_docs"

model &lt;- fit_model(
  main_dir = main_dir,
  model_docs = model_docs,
  num_iters = 100,
  num_chains = 1,
  num_cores = 2,
  writer_indices = c(2, 5),
  doc_indices = c(7, 18)
)

model &lt;- drop_burnin(model = model, burn_in = 25)

analysis &lt;- analyze_questioned_documents(
  main_dir = main_dir,
  questioned_docs = questioned_docs,
  model = model,
  num_cores = 2
)
analysis$posterior_probabilities

## End(Not run)

</code></pre>

<hr>
<h2 id='format_template_data'>Format Template Data</h2><span id='topic+format_template_data'></span>

<h3>Description</h3>

<p><code>format_template_data()</code> formats the template data for use with
<code><a href="#topic+plot_cluster_fill_counts">plot_cluster_fill_counts()</a></code>. The output is a list that contains a data frame
called <code>cluster_fill_counts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_template_data(template)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_template_data_+3A_template">template</code></td>
<td>
<p>A single cluster template created by
<code><a href="#topic+make_clustering_template">make_clustering_template()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List that contains the cluster fill counts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>template_data &lt;- format_template_data(template = example_cluster_template)
plot_cluster_fill_counts(formatted_data = template_data, facet = TRUE)

</code></pre>

<hr>
<h2 id='get_cluster_fill_counts'>get_cluster_fill_counts</h2><span id='topic+get_cluster_fill_counts'></span>

<h3>Description</h3>

<p><code>get_cluster_fill_counts()</code> creates a data frame that shows the number of
graphs in each cluster for each input document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cluster_fill_counts(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cluster_fill_counts_+3A_df">df</code></td>
<td>
<p>A data frame with columns <code>writer</code>, <code>doc</code>, and <code>cluster</code>. Each
row corresponding to a graph and lists the writer of that graph, the document
from which the graph was obtained, and the cluster to which that graph is assigned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of cluster fill counts for each document in the input data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>writer &lt;- c(rep(1, 20), rep(2, 20), rep(3, 20))
docname &lt;- c(rep('doc1',20), rep('doc2', 20), rep('doc3', 20))
doc &lt;- c(rep(1, 20), rep(2, 20), rep(3, 20))
cluster &lt;- sample(3, 60, replace=TRUE)
df &lt;- data.frame(docname, writer, doc, cluster)
get_cluster_fill_counts(df)

</code></pre>

<hr>
<h2 id='get_clusters_batch'>get_clusters_batch</h2><span id='topic+get_clusters_batch'></span>

<h3>Description</h3>

<p>get_clusters_batch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clusters_batch(
  template,
  input_dir,
  output_dir,
  writer_indices,
  doc_indices,
  num_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_clusters_batch_+3A_template">template</code></td>
<td>
<p>A cluster template created with <code><a href="#topic+make_clustering_template">make_clustering_template</a></code></p>
</td></tr>
<tr><td><code id="get_clusters_batch_+3A_input_dir">input_dir</code></td>
<td>
<p>A directory containing graphs created with <code><a href="#topic+process_batch_dir">process_batch_dir</a></code></p>
</td></tr>
<tr><td><code id="get_clusters_batch_+3A_output_dir">output_dir</code></td>
<td>
<p>Output directory for cluster assignments</p>
</td></tr>
<tr><td><code id="get_clusters_batch_+3A_writer_indices">writer_indices</code></td>
<td>
<p>Vector of start and end indices for the writer id in
the graph file names</p>
</td></tr>
<tr><td><code id="get_clusters_batch_+3A_doc_indices">doc_indices</code></td>
<td>
<p>Vector of start and end indices for the document id in the
graph file names</p>
</td></tr>
<tr><td><code id="get_clusters_batch_+3A_num_cores">num_cores</code></td>
<td>
<p>Integer number of cores to use for parallel processing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of cluster assignments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
template &lt;- readRDS('path/to/template.rds')
get_clusters_batch(template=template, input_dir='path/to/dir', output_dir='path/to/dir',
writer_indices=c(2,5), doc_indices=c(7,18), num_cores=1)

get_clusters_batch(template=template, input_dir='path/to/dir', output_dir='path/to/dir',
writer_indices=c(1,4), doc_indices=c(5,10), num_cores=5)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_credible_intervals'>Get Credible Intervals</h2><span id='topic+get_credible_intervals'></span>

<h3>Description</h3>

<p>In a model created with <code><a href="#topic+fit_model">fit_model()</a></code> the pi parameters are the estimate of
the true cluster fill count for a particular writer and cluster. The function
<code>get_credible_intervals()</code> calculates the credible intervals of the pi
parameters for each writer in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_credible_intervals(model, interval_min = 0.025, interval_max = 0.975)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_credible_intervals_+3A_model">model</code></td>
<td>
<p>A model output by <code><a href="#topic+fit_model">fit_model()</a></code></p>
</td></tr>
<tr><td><code id="get_credible_intervals_+3A_interval_min">interval_min</code></td>
<td>
<p>The lower bound for the credible interval. The number
must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="get_credible_intervals_+3A_interval_max">interval_max</code></td>
<td>
<p>The upper bound for the credible interval. The number
must be greater than <code>interval_min</code> and must be less than 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames. Each data frame lists the credible intervals for a single writer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_credible_intervals(model=example_model)
get_credible_intervals(model=example_model, interval_min=0.05, interval_max=0.95)

</code></pre>

<hr>
<h2 id='get_posterior_probabilities'>Get Posterior Probabilities</h2><span id='topic+get_posterior_probabilities'></span>

<h3>Description</h3>

<p>Get the posterior probabilities for questioned document analyzed with <code><a href="#topic+analyze_questioned_documents">analyze_questioned_documents()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_posterior_probabilities(analysis, questioned_doc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_posterior_probabilities_+3A_analysis">analysis</code></td>
<td>
<p>The output of <code><a href="#topic+analyze_questioned_documents">analyze_questioned_documents()</a></code>. If more than
one questioned document was analyzed with this function, then the data frame
analysis$posterior_probabilities lists the posterior probabilities for all
questioned documents. <code><a href="#topic+get_posterior_probabilities">get_posterior_probabilities()</a></code> creates a data frame of the
posterior probabilities for a single questioned document and sorts the known writers
from the most likely to least likely to have written the questioned document.</p>
</td></tr>
<tr><td><code id="get_posterior_probabilities_+3A_questioned_doc">questioned_doc</code></td>
<td>
<p>The filename of the questioned document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of posterior probabilities for the questioned document
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_posterior_probabilities(
  analysis = example_analysis,
  questioned_doc = "w0030_s03_pWOZ_r01"
)

</code></pre>

<hr>
<h2 id='london'>Cursive written word: London</h2><span id='topic+london'></span>

<h3>Description</h3>

<p>Cursive written word: London
</p>


<h3>Usage</h3>

<pre><code class='language-R'>london
</code></pre>


<h3>Format</h3>

<p>Binary image matrix. 148 rows and 481 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>london_document &lt;- list()
london_document$image &lt;- london
plotImage(london_document)
london_document$thin &lt;- thinImage(london_document$image)
plotImageThinned(london_document)
london_processList &lt;- processHandwriting(london_document$thin, dim(london_document$image))
</code></pre>

<hr>
<h2 id='make_clustering_template'>Make Clustering Template</h2><span id='topic+make_clustering_template'></span>

<h3>Description</h3>

<p><code>make_clustering_template()</code> applies a K-means clustering algorithm to the
input handwriting samples pre-processed with <code><a href="#topic+process_batch_dir">process_batch_dir()</a></code> and saved
in the input folder <code style="white-space: pre;">&#8288;main_dir &gt; data &gt; template_graphs&#8288;</code>. The K-means
algorithm sorts the graphs in the input handwriting samples into groups, or
<em>clusters</em>, of similar graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_clustering_template(
  main_dir,
  template_docs,
  writer_indices,
  centers_seed,
  K = 40,
  num_dist_cores = 1,
  max_iters = 25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_clustering_template_+3A_main_dir">main_dir</code></td>
<td>
<p>Main directory that will store template files</p>
</td></tr>
<tr><td><code id="make_clustering_template_+3A_template_docs">template_docs</code></td>
<td>
<p>A directory containing template training images</p>
</td></tr>
<tr><td><code id="make_clustering_template_+3A_writer_indices">writer_indices</code></td>
<td>
<p>A vector of the starting and ending location of the
writer ID in the file name.</p>
</td></tr>
<tr><td><code id="make_clustering_template_+3A_centers_seed">centers_seed</code></td>
<td>
<p>Integer seed for the random number generator when
selecting starting cluster centers.</p>
</td></tr>
<tr><td><code id="make_clustering_template_+3A_k">K</code></td>
<td>
<p>Integer number of clusters</p>
</td></tr>
<tr><td><code id="make_clustering_template_+3A_num_dist_cores">num_dist_cores</code></td>
<td>
<p>Integer number of cores to use for the distance
calculations in the K-means algorithm. Each iteration of the K-means
algorithm calculates the distance between each input graph and each cluster
center.</p>
</td></tr>
<tr><td><code id="make_clustering_template_+3A_max_iters">max_iters</code></td>
<td>
<p>Maximum number of iterations to allow the K-means algorithm
to run</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the cluster template
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
main_dir &lt;- "path/to/folder"
template_docs &lt;- "path/to/template_training_docs"
template_list &lt;- make_clustering_template(
  main_dir = main_dir,
  template_docs = template_docs,
  writer_indices = c(2, 5),
  K = 10,
  num_dist_cores = 2,
  max_iters = 25,
  centers_seed = 100,
)

## End(Not run)

</code></pre>

<hr>
<h2 id='message'>Full page image of the handwritten London letter.</h2><span id='topic+message'></span>

<h3>Description</h3>

<p>Full page image of the handwritten London letter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>message
</code></pre>


<h3>Format</h3>

<p>Binary image matrix. 1262 rows and 1162 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>message_document &lt;- list()
message_document$image &lt;- message
plotImage(message_document)

## Not run: 
message_document &lt;- list()
message_document$image &lt;- message
plotImage(message_document)
message_document$thin &lt;- thinImage(message_document$image)
plotImageThinned(message_document)
message_processList &lt;- processHandwriting(message_document$thin, dim(message_document$image))

## End(Not run)
</code></pre>

<hr>
<h2 id='nature1'>Full page image of the 4th sample (nature) of handwriting from the first writer.</h2><span id='topic+nature1'></span>

<h3>Description</h3>

<p>Full page image of the 4th sample (nature) of handwriting from the first writer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nature1
</code></pre>


<h3>Format</h3>

<p>Binary image matrix. 811 rows and 1590 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nature1_document &lt;- list()
nature1_document$image &lt;- nature1
plotImage(nature1_document)

## Not run: 
nature1_document &lt;- list()
nature1_document$image &lt;- nature1
plotImage(nature1_document)
nature1_document$thin &lt;- thinImage(nature1_document$image)
plotImageThinned(nature1_document)
nature1_processList &lt;- processHandwriting(nature1_document$thin, dim(nature1_document$image))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_cluster_fill_counts'>Plot Cluster Fill Counts</h2><span id='topic+plot_cluster_fill_counts'></span>

<h3>Description</h3>

<p>Plot the cluster fill counts for each document in <code>formatted_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cluster_fill_counts(formatted_data, facet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cluster_fill_counts_+3A_formatted_data">formatted_data</code></td>
<td>
<p>Data created by <code><a href="#topic+format_template_data">format_template_data()</a></code>,
<code><a href="#topic+fit_model">fit_model()</a></code>, or <code><a href="#topic+analyze_questioned_documents">analyze_questioned_documents()</a></code></p>
</td></tr>
<tr><td><code id="plot_cluster_fill_counts_+3A_facet">facet</code></td>
<td>
<p><code>TRUE</code> uses <code>facet_wrap</code> to create a subplot for each writer.
<code>FALSE</code> plots the data on a single plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot of cluster fill counts
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot cluster fill counts for template training documents
template_data &lt;- format_template_data(example_cluster_template)
plot_cluster_fill_counts(formatted_data = template_data, facet = TRUE)

# Plot cluster fill counts for model training documents
plot_cluster_fill_counts(formatted_data = example_model, facet = TRUE)

# Plot cluster fill counts for questioned documents
plot_cluster_fill_counts(formatted_data = example_analysis, facet = FALSE)

</code></pre>

<hr>
<h2 id='plot_cluster_fill_rates'>Plot Cluster Fill Rates</h2><span id='topic+plot_cluster_fill_rates'></span>

<h3>Description</h3>

<p>Plot the cluster fill rates for each document in <code>formatted_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cluster_fill_rates(formatted_data, facet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cluster_fill_rates_+3A_formatted_data">formatted_data</code></td>
<td>
<p>Data created by <code><a href="#topic+format_template_data">format_template_data()</a></code>,
<code><a href="#topic+fit_model">fit_model()</a></code>, or <code><a href="#topic+analyze_questioned_documents">analyze_questioned_documents()</a></code></p>
</td></tr>
<tr><td><code id="plot_cluster_fill_rates_+3A_facet">facet</code></td>
<td>
<p><code>TRUE</code> uses <code>facet_wrap</code> to create a subplot for each writer.
<code>FALSE</code> plots the data on a single plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot of cluster fill rates
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot cluster fill rates for template training documents
template_data &lt;- format_template_data(example_cluster_template)
plot_cluster_fill_rates(formatted_data = template_data, facet = TRUE)

# Plot cluster fill rates for model training documents
plot_cluster_fill_rates(formatted_data = example_model, facet = TRUE)

# Plot cluster fill rates for questioned documents
plot_cluster_fill_rates(formatted_data = example_analysis, facet = FALSE)

</code></pre>

<hr>
<h2 id='plot_credible_intervals'>Plot Credible Intervals</h2><span id='topic+plot_credible_intervals'></span>

<h3>Description</h3>

<p>Plot credible intervals for the model's pi parameters that estimate the true writer
cluster fill counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_credible_intervals(
  model,
  interval_min = 0.025,
  interval_max = 0.975,
  facet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_credible_intervals_+3A_model">model</code></td>
<td>
<p>A model created by <code><a href="#topic+fit_model">fit_model()</a></code></p>
</td></tr>
<tr><td><code id="plot_credible_intervals_+3A_interval_min">interval_min</code></td>
<td>
<p>The lower bound of the credible interval. It must be greater than zero and less than 1.</p>
</td></tr>
<tr><td><code id="plot_credible_intervals_+3A_interval_max">interval_max</code></td>
<td>
<p>The upper bound of the credible interval. It must be greater than the interval minimum and less than 1.</p>
</td></tr>
<tr><td><code id="plot_credible_intervals_+3A_facet">facet</code></td>
<td>
<p><code>TRUE</code> uses <code>facet_wrap</code> to create a subplot for each writer.
<code>FALSE</code> plots the data on a single plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot credible intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_credible_intervals(model = example_model)
plot_credible_intervals(model = example_model, facet = TRUE)

</code></pre>

<hr>
<h2 id='plot_posterior_probabilities'>Plot Posterior Probabilities</h2><span id='topic+plot_posterior_probabilities'></span>

<h3>Description</h3>

<p>Creates a tile plot of posterior probabilities of writership for each
questioned document and each known writer analyzed with
<code><a href="#topic+analyze_questioned_documents">analyze_questioned_documents()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_posterior_probabilities(analysis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_posterior_probabilities_+3A_analysis">analysis</code></td>
<td>
<p>A named list of analysis results from <code><a href="#topic+analyze_questioned_documents">analyze_questioned_documents()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tile plot of posterior probabilities of writership.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_posterior_probabilities(analysis = example_analysis)

</code></pre>

<hr>
<h2 id='plot_trace'>Plot Trace</h2><span id='topic+plot_trace'></span>

<h3>Description</h3>

<p>Create a trace plot for all chains for a single variable of a fitted model
created by <code><a href="#topic+fit_model">fit_model()</a></code>. If the model contains more than one chain, the
chains will be combined by pasting them together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_trace(variable, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_trace_+3A_variable">variable</code></td>
<td>
<p>The name of a variable in the model</p>
</td></tr>
<tr><td><code id="plot_trace_+3A_model">model</code></td>
<td>
<p>A model created by <code><a href="#topic+fit_model">fit_model()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trace plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_trace(model = example_model, variable = "pi[1,1]")
plot_trace(model = example_model, variable = "mu[2,3]")

</code></pre>

<hr>
<h2 id='plotImage'>Plot Image</h2><span id='topic+plotImage'></span>

<h3>Description</h3>

<p>This function plots a basic black and white image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotImage(doc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotImage_+3A_doc">doc</code></td>
<td>
<p>A document processed with <code><a href="#topic+processDocument">processDocument()</a></code> or a binary matrix (all entries are 0 or 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>csafe_document &lt;- list()
csafe_document$image &lt;- csafe
plotImage(csafe_document)

## Not run: 
document &lt;- processDocument('path/to/image.png')
plotImage(document)

## End(Not run)

</code></pre>

<hr>
<h2 id='plotImageThinned'>Plot Thinned Image</h2><span id='topic+plotImageThinned'></span>

<h3>Description</h3>

<p>This function returns a plot with the full image plotted in light gray and the thinned skeleton printed in black on top.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotImageThinned(doc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotImageThinned_+3A_doc">doc</code></td>
<td>
<p>A document processed with <code><a href="#topic+processHandwriting">processHandwriting()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>gpplot plot of thinned image
</p>


<h3>Examples</h3>

<pre><code class='language-R'>csafe_document &lt;- list()
csafe_document$image &lt;- csafe
csafe_document$thin &lt;- thinImage(csafe_document$image)
plotImageThinned(csafe_document)

</code></pre>

<hr>
<h2 id='plotLetter'>Plot Letter</h2><span id='topic+plotLetter'></span>

<h3>Description</h3>

<p>This function returns a plot of a single graph extracted from a document. It
uses the letterList parameter from the <code><a href="#topic+processHandwriting">processHandwriting()</a></code> or <code><a href="#topic+processDocument">processDocument()</a></code> function and
accepts a single value as <code>whichLetter</code>. Dims requires the dimensions of the
entire document, since this isn't contained in <code><a href="#topic+processHandwriting">processHandwriting()</a></code> or <code><a href="#topic+processDocument">processDocument()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLetter(
  doc,
  whichLetter,
  showPaths = TRUE,
  showCentroid = TRUE,
  showSlope = TRUE,
  showNodes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLetter_+3A_doc">doc</code></td>
<td>
<p>A document processed with <code><a href="#topic+processHandwriting">processHandwriting()</a></code> or <code><a href="#topic+processDocument">processDocument()</a></code></p>
</td></tr>
<tr><td><code id="plotLetter_+3A_whichletter">whichLetter</code></td>
<td>
<p>Single value in 1:length(letterList) denoting which letter
to plot.</p>
</td></tr>
<tr><td><code id="plotLetter_+3A_showpaths">showPaths</code></td>
<td>
<p>Whether the calculated paths on the letter should be shown
with numbers.</p>
</td></tr>
<tr><td><code id="plotLetter_+3A_showcentroid">showCentroid</code></td>
<td>
<p>Whether the centroid should be shown</p>
</td></tr>
<tr><td><code id="plotLetter_+3A_showslope">showSlope</code></td>
<td>
<p>Whether the slope should be shown</p>
</td></tr>
<tr><td><code id="plotLetter_+3A_shownodes">showNodes</code></td>
<td>
<p>Whether the nodes should be shown</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of single letter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twoSent_document = list()
twoSent_document$image = twoSent
twoSent_document$thin = thinImage(twoSent_document$image)
twoSent_document$process = processHandwriting(twoSent_document$thin, dim(twoSent_document$image))
plotLetter(twoSent_document, 1)
plotLetter(twoSent_document, 4, showPaths = FALSE)

</code></pre>

<hr>
<h2 id='plotLine'>Plot Line</h2><span id='topic+plotLine'></span>

<h3>Description</h3>

<p>This function returns a plot of a single line extracted from a document.
It uses the letterList parameter from the processHandwriting function and accepts a single value as whichLetter.
Dims requires the dimensions of the entire document, since this isn't contained in processHandwriting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLine(letterList, whichLine, dims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLine_+3A_letterlist">letterList</code></td>
<td>
<p>Letter list from processHandwriting function</p>
</td></tr>
<tr><td><code id="plotLine_+3A_whichline">whichLine</code></td>
<td>
<p>Single value denoting which line to plot - checked if too big inside function.</p>
</td></tr>
<tr><td><code id="plotLine_+3A_dims">dims</code></td>
<td>
<p>Dimensions of the original document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot of single line
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twoSent_document = list()
twoSent_document$image = twoSent
twoSent_document$thin = thinImage(twoSent_document$image)
twoSent_processList = processHandwriting(twoSent_document$thin, dim(twoSent_document$image))

dims = dim(twoSent_document$image)
plotLine(twoSent_processList$letterList, 1, dims)

</code></pre>

<hr>
<h2 id='plotNodes'>Plot Nodes</h2><span id='topic+plotNodes'></span>

<h3>Description</h3>

<p>This function returns a plot with the full image plotted in light gray and the skeleton printed in black, with red triangles over the vertices.
Also called from plotPath, which is a more useful function, in general.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNodes(doc, plot_break_pts = FALSE, nodeSize = 3, nodeColor = "red")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNodes_+3A_doc">doc</code></td>
<td>
<p>A document processed with <code><a href="#topic+processHandwriting">processHandwriting()</a></code></p>
</td></tr>
<tr><td><code id="plotNodes_+3A_plot_break_pts">plot_break_pts</code></td>
<td>
<p>Logical value as to whether to plot nodes or break points. plot_break_pts=FALSE plots nodes and plot_break_pts=TRUE plots break point.</p>
</td></tr>
<tr><td><code id="plotNodes_+3A_nodesize">nodeSize</code></td>
<td>
<p>Size of triangles printed. 3 by default. Move down to 2 or 1 for small text images.</p>
</td></tr>
<tr><td><code id="plotNodes_+3A_nodecolor">nodeColor</code></td>
<td>
<p>Which color the nodes should be</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of full and thinned image with vertices overlaid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>csafe_document &lt;- list()
csafe_document$image &lt;- csafe
csafe_document$thin &lt;- thinImage(csafe_document$image)
csafe_document$process &lt;- processHandwriting(csafe_document$thin, dim(csafe_document$image))
plotNodes(csafe_document)
plotNodes(csafe_document, nodeSize=6, nodeColor="black")

</code></pre>

<hr>
<h2 id='process_batch_dir'>Process Batch Directory</h2><span id='topic+process_batch_dir'></span>

<h3>Description</h3>

<p>Process a list of handwriting samples saved as PNG images in a directory:
(1) Load the image and convert it to black and white with <code><a href="#topic+readPNGBinary">readPNGBinary()</a></code>
(2) Thin the handwriting to one pixel in width with <code><a href="#topic+thinImage">thinImage()</a></code>
(3) Run <code><a href="#topic+processHandwriting">processHandwriting()</a></code> to split the handwriting into parts called <em>edges</em> and place <em>nodes</em> at the ends of
edges. Then combine edges into component shapes called <em>graphs</em>.
(4) Save the processed document in an RDS file.
(5) Optional. Return a list of the processed documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_batch_dir(input_dir, output_dir = ".", skip_docs_on_retry = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_batch_dir_+3A_input_dir">input_dir</code></td>
<td>
<p>Input directory that contains images</p>
</td></tr>
<tr><td><code id="process_batch_dir_+3A_output_dir">output_dir</code></td>
<td>
<p>A directory to save the processed images</p>
</td></tr>
<tr><td><code id="process_batch_dir_+3A_skip_docs_on_retry">skip_docs_on_retry</code></td>
<td>
<p>Logical whether to skip documents in input_dir that
caused errors on a previous run. The errors and document names are stored
in output_dir &gt; problems.txt. If this is the first run,
<code>process_batch_list</code> will attempt to process all documents in input_dir.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of processed documents
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
process_batch_list("path/to/input_dir", "path/to/output_dir")
docs &lt;- process_batch_list("path/to/input_dir", "path/to/output_dir")

## End(Not run)

</code></pre>

<hr>
<h2 id='process_batch_list'>Process Batch List</h2><span id='topic+process_batch_list'></span>

<h3>Description</h3>

<p>Process a list of handwriting samples saved as PNG images: (1) Load the image
and convert it to black and white with <code><a href="#topic+readPNGBinary">readPNGBinary()</a></code> (2) Thin the
handwriting to one pixel in width with <code><a href="#topic+thinImage">thinImage()</a></code> (3) Run
<code><a href="#topic+processHandwriting">processHandwriting()</a></code> to split the handwriting into parts called <em>edges</em>
and place <em>nodes</em> at the ends of edges. Then combine edges into component
shapes called <em>graphs</em>. (4) Save the processed document in an RDS file. (5)
Optional. Return a list of the processed documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_batch_list(images, output_dir, skip_docs_on_retry = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_batch_list_+3A_images">images</code></td>
<td>
<p>A vector of image file paths</p>
</td></tr>
<tr><td><code id="process_batch_list_+3A_output_dir">output_dir</code></td>
<td>
<p>A directory to save the processed images</p>
</td></tr>
<tr><td><code id="process_batch_list_+3A_skip_docs_on_retry">skip_docs_on_retry</code></td>
<td>
<p>Logical whether to skip documents in the images arguement that
caused errors on a previous run. The errors and document names are stored
in output_dir &gt; problems.txt. If this is the first run,
<code>process_batch_list</code> will attempt to process all documents in the images arguement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of processed documents
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
images &lt;- c('path/to/image1.png', 'path/to/image2.png', 'path/to/image3.png')
process_batch_list(images, "path/to/output_dir", FALSE)
docs &lt;- process_batch_list(images, "path/to/output_dir", TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='processDocument'>Process Document</h2><span id='topic+processDocument'></span>

<h3>Description</h3>

<p>Load a handwriting sample from a PNG image. Then binarize, thin, and split
the handwriting into graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processDocument(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processDocument_+3A_path">path</code></td>
<td>
<p>File path for handwriting document. The document must be in PNG
file format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The processed document as a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image_path &lt;- system.file("extdata", "phrase_example.png", package = "handwriter")
doc &lt;- processDocument(image_path)
plotImage(doc)
plotImageThinned(doc)
plotNodes(doc)

</code></pre>

<hr>
<h2 id='processHandwriting'>Process Handwriting by Component</h2><span id='topic+processHandwriting'></span>

<h3>Description</h3>

<p>The main driver of handwriting processing. Takes in an image of thinned
handwriting created with <code><a href="#topic+thinImage">thinImage()</a></code> and splits the the handwriting into
shapes called <em>graphs</em>. Instead of processing the entire document at once,
the thinned writing is separated into connected components and each component
is split into graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processHandwriting(img, dims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processHandwriting_+3A_img">img</code></td>
<td>
<p>Thinned binary image created with <code><a href="#topic+thinImage">thinImage()</a></code>.</p>
</td></tr>
<tr><td><code id="processHandwriting_+3A_dims">dims</code></td>
<td>
<p>Dimensions of thinned binary image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the processed image
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twoSent_document &lt;- list()
twoSent_document$image &lt;- twoSent
twoSent_document$thin &lt;- thinImage(twoSent_document$image)
twoSent_processList &lt;- processHandwriting(twoSent_document$thin, dim(twoSent_document$image))

</code></pre>

<hr>
<h2 id='read_and_process'>Read and Process</h2><span id='topic+read_and_process'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Development on <code>read_and_process()</code> is complete. We recommend using <code><a href="#topic+processDocument">processDocument()</a></code>.
<code>read_and_process(image_name, "document")</code> is equivalent to <code>processDocument(image_name)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_and_process(image_name, transform_output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_and_process_+3A_image_name">image_name</code></td>
<td>
<p>The file path to an image</p>
</td></tr>
<tr><td><code id="read_and_process_+3A_transform_output">transform_output</code></td>
<td>
<p>The type of transformation to perform on the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the processed image components
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use handwriting example from handwriter package
image_path &lt;- system.file("extdata", "phrase_example.png", package = "handwriter")
doc &lt;- read_and_process(image_path, "document")

</code></pre>

<hr>
<h2 id='readPNGBinary'>Read PNG Binary</h2><span id='topic+readPNGBinary'></span>

<h3>Description</h3>

<p>This function reads in and binarizes a PNG image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readPNGBinary(
  path,
  cutoffAdjust = 0,
  clean = TRUE,
  crop = TRUE,
  inversion = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readPNGBinary_+3A_path">path</code></td>
<td>
<p>File path for image.</p>
</td></tr>
<tr><td><code id="readPNGBinary_+3A_cutoffadjust">cutoffAdjust</code></td>
<td>
<p>Multiplicative adjustment to the K-means estimated binarization cutoff.</p>
</td></tr>
<tr><td><code id="readPNGBinary_+3A_clean">clean</code></td>
<td>
<p>Whether to fill in white pixels with 7 or 8 neighbors. This will help a lot when thinning &ndash; keeps from getting little white bubbles in text.</p>
</td></tr>
<tr><td><code id="readPNGBinary_+3A_crop">crop</code></td>
<td>
<p>Logical value dictating whether or not to crop the white out around the image. TRUE by default.</p>
</td></tr>
<tr><td><code id="readPNGBinary_+3A_inversion">inversion</code></td>
<td>
<p>Logical value dictating whether or not to flip each pixel of binarized image. Flipping happens after binarization. FALSE by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns image from path. 0 represents black, and 1 represents white by default.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image_path &lt;- system.file("extdata", "phrase_example.png", package = "handwriter")
csafe_document &lt;- list()
csafe_document$image = readPNGBinary(image_path)
plotImage(csafe_document)

</code></pre>

<hr>
<h2 id='rgb2grayscale'>rgba2grayscale</h2><span id='topic+rgb2grayscale'></span>

<h3>Description</h3>

<p>Changes RGB image to grayscale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgb2grayscale(img)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgb2grayscale_+3A_img">img</code></td>
<td>
<p>A 3D array with slices R, G, and B</p>
</td></tr>
</table>


<h3>Value</h3>

<p>img as a 3D array as grayscale
</p>

<hr>
<h2 id='rgba2rgb'>rgba2rgb</h2><span id='topic+rgba2rgb'></span>

<h3>Description</h3>

<p>Removes alpha channel from png image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgba2rgb(img)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgba2rgb_+3A_img">img</code></td>
<td>
<p>A 3-d array with slices R, G, B, and alpha.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>img as a 3D array with alpha channel removed
</p>

<hr>
<h2 id='SaveAllLetterPlots'>Save All Letter Plots</h2><span id='topic+SaveAllLetterPlots'></span>

<h3>Description</h3>

<p>This function returns a plot of a single graph extracted from a document. It
uses the letterList parameter from the <code><a href="#topic+processHandwriting">processHandwriting()</a></code> or
<code><a href="#topic+processDocument">processDocument()</a></code> function and accepts a single value as whichLetter.
Dims requires the dimensions of the entire document, since this isn't
contained in <code><a href="#topic+processHandwriting">processHandwriting()</a></code> or
<code><a href="#topic+processDocument">processDocument()</a></code>. Requires the <span class="pkg"><a href="magick.html#topic+magick">magick</a></span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SaveAllLetterPlots(letterList, filePaths, dims, bgTransparent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SaveAllLetterPlots_+3A_letterlist">letterList</code></td>
<td>
<p>Letter list from <code><a href="#topic+processHandwriting">processHandwriting()</a></code> or
<code><a href="#topic+processDocument">processDocument()</a></code> function</p>
</td></tr>
<tr><td><code id="SaveAllLetterPlots_+3A_filepaths">filePaths</code></td>
<td>
<p>Folder path to save images to</p>
</td></tr>
<tr><td><code id="SaveAllLetterPlots_+3A_dims">dims</code></td>
<td>
<p>Dimensions of original document</p>
</td></tr>
<tr><td><code id="SaveAllLetterPlots_+3A_bgtransparent">bgTransparent</code></td>
<td>
<p>Logical determines if the image is transparent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>See Also</h3>

<p><code><a href="magick.html#topic+image_transparent">image_transparent</a></code>
</p>
<p><code><a href="magick.html#topic+image_write">image_write</a></code>
</p>
<p><code><a href="magick.html#topic+image_read">image_read</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twoSent_document = list()
twoSent_document$image = twoSent
twoSent_document$thin = thinImage(twoSent_document$image)
twoSent_processList = processHandwriting(twoSent_document$thin, dim(twoSent_document$image))

dims = dim(twoSent_document$image)
## Not run: 
withLetterImages = AddLetterImages(twoSent_processList$letterList, "path/to/save", dims)

## End(Not run)

</code></pre>

<hr>
<h2 id='thinImage'>thinImage</h2><span id='topic+thinImage'></span>

<h3>Description</h3>

<p>This function returns a vector of locations for black pixels in the thinned image.
Thinning done using Zhang - Suen algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thinImage(img)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thinImage_+3A_img">img</code></td>
<td>
<p>A binary matrix of the text that is to be thinned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A thinned, one pixel wide, image.
</p>

<hr>
<h2 id='twoSent'>Two sentence printed example handwriting</h2><span id='topic+twoSent'></span>

<h3>Description</h3>

<p>Two sentence printed example handwriting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoSent
</code></pre>


<h3>Format</h3>

<p>Binary image matrix. 396 rows and 1947 columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twoSent_document &lt;- list()
twoSent_document$image &lt;- twoSent
plotImage(twoSent_document)

## Not run: 
twoSent_document &lt;- list()
twoSent_document$image &lt;- twoSent
plotImage(twoSent_document)
twoSent_document$thin &lt;- thinImage(twoSent_document$image)
plotImageThinned(twoSent_document)
twoSent_processList &lt;- processHandwriting(twoSent_document$thin, dim(twoSent_document$image))

## End(Not run)
</code></pre>

<hr>
<h2 id='whichToFill'>whichToFill</h2><span id='topic+whichToFill'></span>

<h3>Description</h3>

<p>Finds pixels in the plot that shouldn't be white and makes them black. 
Quick and helpful cleaning for before the thinning algorithm runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whichToFill(img)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whichToFill_+3A_img">img</code></td>
<td>
<p>A binary matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cleaned up image.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
