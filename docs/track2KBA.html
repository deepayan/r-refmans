<!DOCTYPE html><html><head><title>Help for package track2KBA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {track2KBA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boobies'><p>St. Helena Masked Boobies</p></a></li>
<li><a href='#estSpaceUse'><p>Estimate the space use of tracked animals using kernel utilization</p>
distribution</a></li>
<li><a href='#findScale'><p>Find an appropriate smoothing parameter</p></a></li>
<li><a href='#findSite'><p>Delineating sites of potential importance to conservation</p></a></li>
<li><a href='#formatFields'><p>Format tracking data</p></a></li>
<li><a href='#indEffectTest'><p>Test site fidelity</p></a></li>
<li><a href='#KDE_example'><p>Utilization distributions examples</p></a></li>
<li><a href='#mapKDE'><p>Make simple maps of Kernel Density Estimates</p></a></li>
<li><a href='#mapSite'><p>Make simple maps of aggregation and important sites</p></a></li>
<li><a href='#mapTrips'><p>Make simple maps of foraging trips</p></a></li>
<li><a href='#move2KBA'><p>Import Movebank data sets for track2KBA analysis</p></a></li>
<li><a href='#projectTracks'><p>Project tracking data</p></a></li>
<li><a href='#repAssess'><p>Assess sample representativeness</p></a></li>
<li><a href='#tripSplit'><p>Split tracking data into trips</p></a></li>
<li><a href='#tripSummary'><p>Summary of trip movements</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Identifying Important Areas from Animal Tracking Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/BirdLifeInternational/track2kba">https://github.com/BirdLifeInternational/track2kba</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for preparing and analyzing animal tracking data, 
    with the intention of identifying areas which are potentially important at 
    the population level and therefore of conservation interest. Areas identified 
    using this package may be checked against global or regionally-defined criteria,
    such as those set by the Key Biodiversity Area program. The method
    published herein is described in full in Beal et al. 2021 &lt;<a href="https://doi.org/10.1111%2F2041-210X.13713">doi:10.1111/2041-210X.13713</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/BirdLifeInternational/track2kba/issues">https://github.com/BirdLifeInternational/track2kba/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>adehabitatLT, doParallel, knitr, parallel, rmarkdown,
tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>adehabitatHR, dplyr, foreach, geosphere, ggplot2, lubridate,
magrittr, maps, Matching, methods, move, purrr, raster (&ge;
3.6-3), rlang, sf (&ge; 0.7-4), sp (&ge; 1.5-0), tidyr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-27 11:20:01 UTC; marti</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Beal <a href="https://orcid.org/0000-0003-1654-1410"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Steffen Oppel <a href="https://orcid.org/0000-0003-1654-1410"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Maria Dias <a href="https://orcid.org/0000-0002-7281-4391"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Mark Miller [ctb],
  Phillip Taylor [ctb],
  Virginia Morera-Pujol
    <a href="https://orcid.org/0000-0001-6500-5548"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Elizabeth Pearmain
    <a href="https://orcid.org/0000-0002-6600-1482"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Jonathan Handley <a href="https://orcid.org/0000-0001-6468-338X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ben Lascelles [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Beal &lt;martinbeal88@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-27 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='boobies'>St. Helena Masked Boobies</h2><span id='topic+boobies'></span>

<h3>Description</h3>

<p>A GPS tracking data set of Masked Boobies during incubation and chick-rearing
at St. Helena Island. Formatted following BirdLife International's Seabird 
Tracking Database standard <a href="http://www.seabirdtracking.org/">http://www.seabirdtracking.org/</a>. 
Data from Oppel et al. 2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boobies
</code></pre>


<h3>Format</h3>

<p>A data frame with 116355 obs. of  6 variables:
</p>

<dl>
<dt>track_id</dt><dd><p>Unique identifier code for each bird</p>
</dd>
<dt>date_gmt</dt><dd><p>Character vector representing date (Greenwich Mean Time)</p>
</dd>
<dt>time_gmt</dt><dd><p>Character vector representing time (Greenwich Mean Time)</p>
</dd>
<dt>longitude</dt><dd><p>Longitudinal position of bird</p>
</dd>
<dt>latitude</dt><dd><p>Latitudinal position of bird</p>
</dd>
<dt>lon_colony</dt><dd><p>Longitudinal position of breeding colony</p>
</dd>
<dt>lat_colony</dt><dd><p>Latitudinal position of breeding colony</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p><a href="https://link.springer.com/article/10.1007/s00265-015-1903-3">https://link.springer.com/article/10.1007/s00265-015-1903-3</a>
</p>

<hr>
<h2 id='estSpaceUse'>Estimate the space use of tracked animals using kernel utilization
distribution</h2><span id='topic+estSpaceUse'></span>

<h3>Description</h3>

<p><code>estSpaceUse</code> is a wrapper for <code><a href="adehabitatHR.html#topic+kernelUD">kernelUD</a></code> which estimates
the utilization distribution (UD) of multiple individuals or tracks in a
tracking dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estSpaceUse(tracks, scale, levelUD, res = NULL, polyOut = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estSpaceUse_+3A_tracks">tracks</code></td>
<td>
<p>SpatialPointsDataFrame. Must be projected into an equal-area
coordinate system. If not, first run <code><a href="#topic+projectTracks">projectTracks</a></code>.</p>
</td></tr>
<tr><td><code id="estSpaceUse_+3A_scale">scale</code></td>
<td>
<p>numeric (in kilometers). The smoothing parameter ('H') used in
the kernel density estimation, which defines the width of the normal
distribution around each location. The <code><a href="#topic+findScale">findScale</a></code> function can
assist in finding sensible scales.</p>
</td></tr>
<tr><td><code id="estSpaceUse_+3A_levelud">levelUD</code></td>
<td>
<p>numeric (percent). Specify which utilization distribution
contour at which to subset the polygon output. NOTE: This will only affect
the output if <code>polyOut=TRUE</code>.</p>
</td></tr>
<tr><td><code id="estSpaceUse_+3A_res">res</code></td>
<td>
<p>numeric (in square kilometers). Grid cell resolution
for kernel density estimation. Default is a grid of
500 cells, with spatial extent determined by the latitudinal and longitudinal
extent of the data.</p>
</td></tr>
<tr><td><code id="estSpaceUse_+3A_polyout">polyOut</code></td>
<td>
<p>logical scalar (TRUE/FALSE). If TRUE then output will include
a plot of individual UD polygons and a simple feature with kernel UD polygons
for the level of <code>levelUD</code>. NOTE: creating polygons of UD is both
computationally slow and prone to errors if the usage included in
<code>levelUD</code> extends beyond the specified grid. In this case
<code>estSpaceUse</code> will return only the <code>estUDm</code>object and issue a
warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A utilization distribution will be calculated for each unique 'ID'. The data
should be regularly sampled or interpolated (see adehabitatLT package for
functions to this end).
</p>
<p>If desired <code>res</code> results in memory-heavy grid (e.g. &gt;10,000 cells)
use <code>polyOut = FALSE</code> to speed things up.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>estUDm</code> which is essentially a list,
with each item representing the utilization distribution of a level of 'ID'.
Values in the output signify the usage probability per unit area for that
individual in each grid cell. This can be converted into a
SpatialPixelsDataFrame via the <code>adehabitatHR::estUDm2spixdf</code> function.
</p>
<p>If <code>polyOut=TRUE</code> the output will be a list with two components:
<em>'KDE.Surface'</em> is the <code>estUDm</code> object and <code>UDPolygons</code> is
polygon object of class <code>sf</code> (Simple Features) with the UD contour for
each individual at the specified <code>levelUD</code>.
</p>
<p>If <code>polyOut=TRUE</code> but the polygon delineation in
<code>adehabitatHR::getverticeshr</code> fails, output is an object of class
<code>estUDm</code> and a warning will be issued.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+formatFields">formatFields</a></code>, <code><a href="#topic+tripSplit">tripSplit</a></code>,
<code><a href="#topic+findScale">findScale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
library(sp)
library(magrittr)

## make some play data
dataGroup &lt;- data.frame(
  Longitude = c(1, 1.01, 1.02, 1.04, 1.05, 1.03, 1), 
    Latitude =  c(1, 1.01, 1.02, 1.03, 1.021, 1.01, 1),
      ID = rep("A", 7),
        DateTime = format(
            lubridate::ymd_hms("2021-01-01 00:00:00") + 
              lubridate::hours(0:6)
                )
                )
                
tracks &lt;- sf::st_as_sf(
   dataGroup, coords = c("Longitude", "Latitude"), 
   crs = 4326, agr = "constant") %&gt;% 
   sf::st_transform(crs = 32631) %&gt;% 
   sf::as_Spatial()

## estimate utilization distributions for each track
KDE &lt;- estSpaceUse(tracks, scale=10, levelUD = 50)

</code></pre>

<hr>
<h2 id='findScale'>Find an appropriate smoothing parameter</h2><span id='topic+findScale'></span>

<h3>Description</h3>

<p><code>findScale</code> takes a tracking data set and outputs a series of candidate
smoothing parameter values. Additionally, it compares the scale of movement
resolved by the sampling resolution of the data set, to a grid of desired
resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findScale(
  tracks,
  scaleARS = TRUE,
  res = NULL,
  sumTrips = NULL,
  scalesFPT = NULL,
  peakWidth = 1,
  peakMethod = "first"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findScale_+3A_tracks">tracks</code></td>
<td>
<p>SpatialPointsDataFrame. Must be projected into an equal-area
coordinate system; if not, first run <code><a href="#topic+projectTracks">projectTracks</a></code>.</p>
</td></tr>
<tr><td><code id="findScale_+3A_scalears">scaleARS</code></td>
<td>
<p>logical scalar (TRUE/FALSE). Do you want to calculate the
scale of area-restricted search using First Passage Time analysis? NOTE: does
not allow for duplicate date-time stamps.</p>
</td></tr>
<tr><td><code id="findScale_+3A_res">res</code></td>
<td>
<p>numeric. The desired grid cell resolution (square kilometers) for
subsequent kernel analysis (NOT performed in this function). If this is not
specified, the scale of movement is compared to a 500-cell grid, with spatial
extent determined by the latitudinal and longitudinal extent of the data.</p>
</td></tr>
<tr><td><code id="findScale_+3A_sumtrips">sumTrips</code></td>
<td>
<p>data.frame. Output of <code><a href="#topic+tripSummary">tripSummary</a></code> function. If
not specified, <code><a href="#topic+tripSummary">tripSummary</a></code> will be called within the function.</p>
</td></tr>
<tr><td><code id="findScale_+3A_scalesfpt">scalesFPT</code></td>
<td>
<p>numeric vector. Set of spatial scales at which to calculate
First Passage Time. If not specified, the distribution of between-point
distances will be used to derive a set.</p>
</td></tr>
<tr><td><code id="findScale_+3A_peakwidth">peakWidth</code></td>
<td>
<p>numeric. How many scale-steps either side of focal scale
used to identify a peak. Default is 1, whereby a peak is defined as any scale
at which the variance in log FPT increases from the previous scale, and
decreases for the following one.</p>
</td></tr>
<tr><td><code id="findScale_+3A_peakmethod">peakMethod</code></td>
<td>
<p>character. Which method should be used to select the focal
peak for each ID. Options are &quot;first&quot;, &quot;max&quot;, and &quot;steep&quot;. &quot;steep&quot; is a value
of scalesFPT at which the variance in log FPT changes most rapidly compared
to the surrounding scale(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to provide guidance regarding the two most
sensitive steps in the track2KBA analysis: specification of the (1) smoothing
parameter and the (2) grid cell size for kernel density estimation (KDE).
Specifically, the goal is to allow for exploration of the effect of these
parameters and their inter-relatedness, so that an informed decision may be
made regarding their specification in subsequent track2KBA steps.
</p>
<p>Kernel density estimation has been identified as particularly sensitive to
the specification of the smoothing parameter (AKA bandwidth, or 'H' value),
that is, the parameter that defines the width of the normal distribution
around each location. Many techniques for identifying 'optimal' smoothing
parameters have been proposed (see Gitzen, Millspaugh, and Kernohan for a
classic review; see Fleming and Calabreses 2017 for a later implementation)
and many of these techniques have their merits; however, in the track2KBA
implementation of KDE we have opted for simplicity.
</p>
<p>In the context of the track2KBA analysis, the smoothing parameter ought to
represent the relevant scale at which the animal interacts with the
environment. Therefore, when selecting a <em>Scale</em> value for subsequent
analysis, the user must take into account the movement ecology of the study
species. For species which use Area-Restricted Search (ARS) behavior when
foraging, First Passage Time analysis may be used to identify the scale of
interaction with the environment (Fauchald and Tveraa 2003), however not all
species use ARS when foraging and therefore different techniques must be
used.
</p>
<p>What minimum spatial scales are detectable by the data also depends on the
sampling resolution. Therefore, when applying First Passage Time analysis,
<code>findScale</code> sets the range of scales at which movements are analyzed
based on the distribution of forward, between-point displacements in the
data.
</p>
<p>The grid cell size also affects the output of kernel density-based space use
analyses. Therefore, by specifying the <em>res</em> parameter you can check
whether your desired grid cell size is reasonable, given the scale of
movement resolved by your data.
</p>


<h3>Value</h3>

<p>This function returns a one-row dataframe with the foraging range in
the first column (i.e. 'med_max_distance') calculated by
<code><a href="#topic+tripSummary">tripSummary</a></code>, and the median step length
(i.e. between point distance) for the data set. The subsequent columns
contain various candidate smoothing parameter ('h') values calculated in the
following ways:
</p>

<ol>
<li><p> 'mag' - log of the foraging range (i.e. median maximum trip distance)
</p>
</li>
<li><p> 'href' - reference bandwidth a simple, data-driven method which takes
into account the number of points, and the variance in X and Y directions.
</p>
<p><code class="reqn">sqrt((X + Y)* (n^(-1/6)))</code>; where X=Longitude/Easting,
Y=Latitude/Northing, and n=number of relocations
</p>
</li>
<li><p> 'scaleARS' - spatial scale of area-restricted Search behavior as
estimated using First Passage Time analysis
(see <code><a href="adehabitatLT.html#topic+fpt">fpt</a></code>)
</p>
</li></ol>

<p>If the scaleARS option is used, a diagnostic plot is shown which illustrates
the change in variance of log-FPT  values calculated at each FPT scale. Grey
vertical lines indicate the peaks identified for each individual using
peakMethod method chosen, and the red line is the median of these, and the
resulting scaleARS in the output table.
</p>
<p>All values are in kilometers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make some play data
dataGroup &lt;- data.frame(Longitude = c(1, 1.01, 1.02, 1.04, 1.05, 1),
  Latitude =  c(1, 1.01, 1.02, 1.03, 1.021, 1), 
  ID = rep("A", 6),
  DateTime = format(
   lubridate::ymd_hms("2021-01-01 00:00:00") + 
   lubridate::hours(0:5)
   )
 )
 colony &lt;- data.frame(
  Longitude = dataGroup$Longitude[1], Latitude = dataGroup$Latitude[1]
 )
 ## split data into trips
 trips &lt;- tripSplit(dataGroup, colony=colony,
  innerBuff = 1, returnBuff = 1, duration = 0.5, 
  rmNonTrip = TRUE
 )  
 ## summarize trip characteristics
 sumTrips &lt;- tripSummary(trips, colony)
 ## project tracks
 tracks_prj &lt;- projectTracks(
   trips,
   projType = "azim",
   custom = "TRUE"
 )
 ## calculate candidate smoothing parameter values
 h_vals &lt;- findScale(tracks_prj, sumTrips = sumTrips, scaleARS = FALSE)

</code></pre>

<hr>
<h2 id='findSite'>Delineating sites of potential importance to conservation</h2><span id='topic+findSite'></span>

<h3>Description</h3>

<p><code>findSite</code> uses the core areas (based on utilization distributions) of
individual animals to identify areas used regularly used by a significant
portion of the local source population (i.e. the tracked population).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findSite(KDE, represent, popSize = NULL, levelUD, thresh, polyOut = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findSite_+3A_kde">KDE</code></td>
<td>
<p>estUDm or SpatialPixels/GridDataFrame. If estUDm, as created by
<code><a href="#topic+estSpaceUse">estSpaceUse</a></code> or <code>adehabitatHR::kernelUD</code>, if Spatial*,
each column should correspond to the Utilization Distribution of a single
individual or track.</p>
</td></tr>
<tr><td><code id="findSite_+3A_represent">represent</code></td>
<td>
<p>Numeric (between 0-1). Output value provided by
<code><a href="#topic+repAssess">repAssess</a></code> which assesses how representative the tracking data
are for characterising the space use of the wider population.</p>
</td></tr>
<tr><td><code id="findSite_+3A_popsize">popSize</code></td>
<td>
<p>Numeric, the number of individuals breeding or residing at the
origin location from where animals were tracked, quantifying the population
that the tracking data represent. This number will be used to calculate how
many animals use the delineated areas of aggregation. If no value for
<code>popSize</code> is provided then output will be as the proportion of the
population.</p>
</td></tr>
<tr><td><code id="findSite_+3A_levelud">levelUD</code></td>
<td>
<p>Numeric (percentage). Specifies the quantile used for
delineating the core use (or home range) areas of individuals based on the
kernel density estimation (e.g core area=50, home range=95).</p>
</td></tr>
<tr><td><code id="findSite_+3A_thresh">thresh</code></td>
<td>
<p>Numeric (percentage). Threshold percentage of local source
population needed to be found using a location for it to be considered part
of a 'potentialSite'. Default is set based on degree of representativeness.</p>
</td></tr>
<tr><td><code id="findSite_+3A_polyout">polyOut</code></td>
<td>
<p>Logical. (Default TRUE) Should the output be a polygon dataset
(TRUE) or grid of animal densities (FALSE). See 'Value' below for more
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>findSite</code> estimates the proportion of the local source population using
an area based on the proportion of overlap among individual core areas and
the degree of representativeness as quantified by <code><a href="#topic+repAssess">repAssess</a></code>).
This value is then compared to a threshold of importance (i.e. a certain 
the population) to delineate areas as 'potentialSites'. Thresholds area
either set automatically set on the representativenss of the sample
(lower rep==higher threshold), or set manually by the user.
</p>
<p>The areas identified are sites of ecological relevance to the populations,
which may be significant for the wider region or entire species, which cane
be assessed using global (or regional) criteria, such as those of the Key
Biodiversity Area program.
</p>
<p>The KBA criteria for site assessment are published in the KBA standard, which
may be found here: <a href="http://www.keybiodiversityareas.org/">http://www.keybiodiversityareas.org/</a>.
</p>
<p>If grid used for estimating core areas (i.e. KDE) is very memory-heavy
(e.g. &gt;10,000 cells) use <code>polyOut = FALSE</code> to speed things up.
</p>


<h3>Value</h3>

<p>if <code>polyOut = TRUE</code> function returns an object of class
<code>sf</code> containing polygon data with three data columns:
Column <code>N_IND</code> indicates the number of tracked individuals whose core
use area (at <code>levelUD</code>) overlapped with this polygon.
</p>
<p>Column <code>N_animals</code> estimates the number of animals from the
represented population that predictably use the polygon area during the
tracked season. If no value for (at <code>popSize</code>) is provided, this
number is the proportion of the represented population using the area.
</p>
<p>Column <code>potentialSite</code> indicates whether the polygon can be considered
a potential Site (TRUE) or not (FALSE).
</p>
<p>if <code>polyOut = FALSE</code> function returns a gridded surface of class
SpatialPixelsDataFrame, with the same three aforementioned columns as cell
values.
</p>
<p>If <code>polyOut = TRUE</code> the user may choose to automatically produce a plot
of the result using <code>plot=TRUE</code>. The map produced displays the areas
which hold aggregations above a certain threshold proportion of the
population. If there are no areas displayed on the map, then either the
species doesn't aggregate, the Scale is too small to identify aggregations
in this species, or the tracked sample aren't representative enough to meet
the thresholds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KDE &lt;- track2KBA::KDE_example

## identify potential sites
pot_site &lt;- findSite(KDE, represent = 90, levelUD = 50)

</code></pre>

<hr>
<h2 id='formatFields'>Format tracking data</h2><span id='topic+formatFields'></span>

<h3>Description</h3>

<p><code>formatFields</code> formats the column names of a data frame so that they are
accepted by track2KBA functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatFields(
  dataGroup,
  formatBL = FALSE,
  fieldID,
  fieldLat,
  fieldLon,
  fieldDateTime = NULL,
  fieldDate = NULL,
  fieldTime = NULL,
  formatDT = NULL,
  cleanDF = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatFields_+3A_datagroup">dataGroup</code></td>
<td>
<p>data.frame or data.table.</p>
</td></tr>
<tr><td><code id="formatFields_+3A_formatbl">formatBL</code></td>
<td>
<p>logical. Is data set already in format of BirdLife Seabird
tracking database? If so, indicate <code>TRUE</code>. <code>fieldID</code> must still be
specified and other fields may be ignored.
arguments.</p>
</td></tr>
<tr><td><code id="formatFields_+3A_fieldid">fieldID</code></td>
<td>
<p>character. Unique identifier; e.g. for individuals or
dataGroup.</p>
</td></tr>
<tr><td><code id="formatFields_+3A_fieldlat">fieldLat</code></td>
<td>
<p>numeric. Name of column corresponding to the LATITUDINAL
positions.</p>
</td></tr>
<tr><td><code id="formatFields_+3A_fieldlon">fieldLon</code></td>
<td>
<p>numeric. Name of column corresponding to the LONGITUDINAL
positions.</p>
</td></tr>
<tr><td><code id="formatFields_+3A_fielddatetime">fieldDateTime</code></td>
<td>
<p>character. If existing, this is the name of the column
corresponding to the combined DATE &amp; TIME.</p>
</td></tr>
<tr><td><code id="formatFields_+3A_fielddate">fieldDate</code></td>
<td>
<p>character. Name of column corresponding to the DATE only.</p>
</td></tr>
<tr><td><code id="formatFields_+3A_fieldtime">fieldTime</code></td>
<td>
<p>character. Name of column corresponding to the TIME only.</p>
</td></tr>
<tr><td><code id="formatFields_+3A_formatdt">formatDT</code></td>
<td>
<p>character. What is the format of the data in your DateTime,
Date, and Time columns (e.g. &quot;ymd_HMS&quot;)? Specify the format following the
standard in <code><a href="lubridate.html#topic+parse_date_time">parse_date_time</a></code>.</p>
</td></tr>
<tr><td><code id="formatFields_+3A_cleandf">cleanDF</code></td>
<td>
<p>logical scalar (T/F). Should columns which are non-essential
for track2KBA analysis be removed from dataframe, or not? Removal will speed
analysis up a bit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data are already in format of BirdLife Seabird tracking database
(<a href="http://www.seabirdtracking.org/">http://www.seabirdtracking.org/</a>), use <code>formatBL = TRUE</code> and formatting
conversion will occur automatically. I.e., data have following columns:
&quot;latitude&quot;, &quot;latitude&quot;, &quot;date_gmt&quot;, &quot;time_gmt&quot;. You must still specify the
ID column as either the track or animal identifier.
</p>
<p>By matching up the names of your existing columns with those recognized by
track2KBA functions, <code>formatFields</code> re-formats the data frame, and
converts the date/date-time fields into a singe date-time field of class
POSIXct.
</p>
<p>If date-time is combined in a single column, please use <em>fieldDateTime</em>
instead of <em>fieldDate</em> and <em>fieldTime</em>.
</p>


<h3>Value</h3>

<p>Returns a data.frame, with 'ID', 'Latitude', 'Longitude', and
'DateTime' (class POSIXct) columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load example dataset
tracks_raw &lt;- track2KBA::boobies
## using data with user-custom format i.e. with separate Date and Time fields
tracks_formatted &lt;- formatFields(
  dataGroup = tracks_raw,
  fieldID   = "track_id",
  fieldLat  ="latitude",
  fieldLon  ="longitude",
  fieldDate ="date_gmt",
  fieldTime ="time_gmt"
  )
## using data with only single Date field
tracks_formatted &lt;- formatFields(
  dataGroup = tracks_raw,
  fieldID   = "track_id",
  fieldLat  ="latitude",
  fieldLon  ="longitude",
  fieldDate ="date_gmt",
  formatDT = "ymd"
  )
## Not run: 
## if data were downloaded from Seabird Tracking Database
tracks_formatted &lt;- formatFields(
  dataGroup=tracks_raw,
  formatBL,
  fieldID = "bird_id")
  
## End(Not run)
  
</code></pre>

<hr>
<h2 id='indEffectTest'>Test site fidelity</h2><span id='topic+indEffectTest'></span>

<h3>Description</h3>

<p><code>indEffectTest</code> tests whether the variance in overlap between space use 
areas within a group (e.g within individuals) is significant compared to 
between groups (e.g. between individuals).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indEffectTest(
  tracks,
  tripID,
  groupVar,
  plot = TRUE,
  method = c("HR", "PHR", "VI", "BA", "UDOI", "HD"),
  conditional = TRUE,
  levelUD = 50,
  scale,
  grid = 500,
  iterations = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indEffectTest_+3A_tracks">tracks</code></td>
<td>
<p>SpatialPointsDataFrame. Must be projected into an equal-area 
coordinate system. If not, first run <code><a href="#topic+projectTracks">projectTracks</a></code>.</p>
</td></tr>
<tr><td><code id="indEffectTest_+3A_tripid">tripID</code></td>
<td>
<p>character. Column in <em>tracks</em> corresponding to the within 
group ID (e.g. trip-individual combination)</p>
</td></tr>
<tr><td><code id="indEffectTest_+3A_groupvar">groupVar</code></td>
<td>
<p>character. Column in <em>tracks</em> corresponding to the 
between group ID (e.g. individual or track)</p>
</td></tr>
<tr><td><code id="indEffectTest_+3A_plot">plot</code></td>
<td>
<p>logical scalar (TRUE/FALSE). Do you want to output a boxplot of 
the result?</p>
</td></tr>
<tr><td><code id="indEffectTest_+3A_method">method</code></td>
<td>
<p>character. Which method of overlap estimation to use? See 
<code><a href="adehabitatHR.html#topic+kerneloverlap">kerneloverlap</a></code> for descriptions of each method.</p>
</td></tr>
<tr><td><code id="indEffectTest_+3A_conditional">conditional</code></td>
<td>
<p>logical scalar (T/F). If TRUE, the function sets to 0 the
pixels of the grid over which the UD is estimated, outside the home range of
the animal estimated at a level of probability equal to percent. Note that
this argument has no effect when meth=&quot;HR&quot; 
(from <code><a href="adehabitatHR.html#topic+kerneloverlap">kerneloverlap</a></code>).</p>
</td></tr>
<tr><td><code id="indEffectTest_+3A_levelud">levelUD</code></td>
<td>
<p>numeric. The desired contour level of the utilization 
distribution to be used in overlap estimation. NOTE: this is irrelevant if 
<em>conditional=FALSE</em>.</p>
</td></tr>
<tr><td><code id="indEffectTest_+3A_scale">scale</code></td>
<td>
<p>numeric (in kilometers). Smoothing ('H') parameter for 
kernel density estimation.</p>
</td></tr>
<tr><td><code id="indEffectTest_+3A_grid">grid</code></td>
<td>
<p>numeric or SpatialPixels. If numeric, specify the desired number 
of grid cells over which the utilization distributions will be esimated. 
A default grid of 500 cells is used.</p>
</td></tr>
<tr><td><code id="indEffectTest_+3A_iterations">iterations</code></td>
<td>
<p>numeric. Indicate the desired number of Kolmogorov-Smirnov 
iterations to run. 500 is an advisable minimum for statistical rigor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works by producing kernel density areas at a desired contour 
level (i.e. <em>UDLEv</em>) for each level of <em>tripID</em> and estimating the 
degree of overlap between all pairwise comparisons using the desired overlap 
<em>method</em>. Then, comparisons are split into 'within' and 'between' 
groups, determined by the grouping variable (i.e <em>groupVar</em>) argument.
</p>
<p>If <em>conditional=TRUE</em> then the overlap estimates will range from 0 to 
<em>levelUD</em> (unless <em>method=&quot;HR&quot;</em>).
</p>
<p>Then, the empirical distribution of each group is compared in a bootstrapped 
Kolmogorov-Smirnov test, to check whether differences in the distributions 
are significant. If so, it indicates that individuals within the 
<em>groupVar</em> reuse sites more than expected by chance.
</p>
<p>NOTE: Because <code>indEffectTest</code> relies on 
<code><a href="adehabitatHR.html#topic+kerneloverlap">kerneloverlap</a></code> to estimate overlap, it was not 
possible to implement a <em>res</em> argument as is done in other track2KBA 
functions. Therefore, it is advised to either leave the default of 500 cells,
or ascertain the number of cells in the grid of chosen <em>res</em> from the 
output of <a href="#topic+estSpaceUse">estSpaceUse</a>.
</p>


<h3>Value</h3>

<p><code>indEffectTest</code> returns a list containing three objects. In the 
first slot 'Overlap Matrix', the full matrix of overlap comparisons. In the '
Overlap' slot, a dataframe with a column identifying whether each overlap 
estimate corresponds to a within-group, or a between-group comparison. 
In the third slot 'Kolmogorov-Smirnov' is the test output of the 
Kolmogorov-Smirnov test, indicating the D parameter and significance 
estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tracks_raw &lt;- track2KBA::boobies
## format data
tracks_formatted &lt;- formatFields(
  dataGroup = tracks_raw,
  fieldID   = "track_id",
  fieldLat  ="latitude",
  fieldLon  ="longitude",
  fieldDate ="date_gmt",
  fieldTime ="time_gmt"
)

colony &lt;- data.frame(
  Longitude = tracks_formatted$Longitude[1], 
  Latitude = tracks_formatted$Latitude[1]
)
## Split into trips
Trips &lt;- tripSplit(tracks_formatted,
                   colony=colony,
                   innerBuff=2,
                   returnBuff=20,
                   duration=1,
                   nests = FALSE,
                   rmNonTrip = TRUE
)
## project dataset
tracks_prj &lt;- projectTracks(
  Trips,
  projType = "azim",
  custom = "TRUE"
)
## estimate fidelity of individuals across trips
result &lt;- indEffectTest(
  tracks_prj, 
  tripID = "tripID", 
  groupVar = "ID", 
  scale = 30
)

</code></pre>

<hr>
<h2 id='KDE_example'>Utilization distributions examples</h2><span id='topic+KDE_example'></span>

<h3>Description</h3>

<p>Four Utilization Distributions derived for four Masked Boobies
using track2KBA::estSpaceUse and a scale parameter of 30 km.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KDE_example
</code></pre>


<h3>Format</h3>

<p>An &quot;estUDm&quot; object:
</p>

<dl>
<dt>h</dt><dd><p>Smoothing parameter in meters</p>
</dd>
<dt>proj4string</dt><dd><p>Spatial projection</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='mapKDE'>Make simple maps of Kernel Density Estimates</h2><span id='topic+mapKDE'></span>

<h3>Description</h3>

<p><code>mapKDE</code> uses output from <code>estSpaceUse</code> to create maps illustrating
utilization distributions for each ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapKDE(KDE, colony = NULL, show = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapKDE_+3A_kde">KDE</code></td>
<td>
<p>Simple feature MULTIPOLYGON or estUDm object. Must be output of
<code><a href="#topic+estSpaceUse">estSpaceUse</a></code> function).</p>
</td></tr>
<tr><td><code id="mapKDE_+3A_colony">colony</code></td>
<td>
<p>data.frame. Optional.'Latitude' and 'Longitude' locations to
display reference point of, for example, a breeding or tagging site.</p>
</td></tr>
<tr><td><code id="mapKDE_+3A_show">show</code></td>
<td>
<p>logical. show plot, or just save it. Note, saving plot only works
for Simple Features input. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input is simple features polygons, these will be displayed for all IDs
on same map. If input estUDm utilization distribution surface, each ID level
gets its own facet displaying the full UD.
</p>


<h3>Value</h3>

<p>Returns a figure of either single map with all core ranges displayed
together, or a series of facetted maps, each of which shows a utilization
distribution corresponding to a level of ID in <em>KDE</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estSpaceUse">estSpaceUse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make some play data
dataGroup &lt;- data.frame(Longitude = c(1, 1.01, 1.02, 1.04, 1.05, 1.03, 1), 
                       Latitude =  c(1, 1.01, 1.02, 1.03, 1.021, 1.01, 1),
                       ID = rep("A", 7),
                       DateTime = format(
                         lubridate::ymd_hms("2021-01-01 00:00:00") + 
                         lubridate::hours(0:6)
                         )
)
## project tracks
tracks &lt;- projectTracks(dataGroup, projType = "azim", custom = TRUE)
## estimate utilization distributions for each track
KDE &lt;- estSpaceUse(tracks, scale=10, levelUD = 50)
## map it
mapKDE(KDE)

</code></pre>

<hr>
<h2 id='mapSite'>Make simple maps of aggregation and important sites</h2><span id='topic+mapSite'></span>

<h3>Description</h3>

<p><code>mapSite</code> uses output from <code>findSite</code> to create maps illustrating
density of animals in space, and borders of potentially important areas for
the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapSite(Site, colony = NULL, show = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapSite_+3A_site">Site</code></td>
<td>
<p>Simple feature MULTIPOLYGON object or SpatialPixelsDataFrame.
Must be output of <code><a href="#topic+findSite">findSite</a></code> function).</p>
</td></tr>
<tr><td><code id="mapSite_+3A_colony">colony</code></td>
<td>
<p>data.frame. Optional. Must contain columns named 'Latitude' and
'Longitude', with coordinate locations to display reference point of, for
example, a breeding or tagging site.</p>
</td></tr>
<tr><td><code id="mapSite_+3A_show">show</code></td>
<td>
<p>logical. show plot, or just save it. Note, saving plot only works
for Simple Features input. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input is simple features polygons (i.e. <code>polyOut = TRUE</code> in
<code>findSite</code>), areas which meet threshold of importance are displayed
(in red) on top of of the estimated density of animals in space. Black
borders are political and coastline borders.If there are no red borders areas
displayed on the map, then either the species doesn't aggregatee enough to
meet the threshold, or the tracked sample aren't representative enough to
identify significant aggregations.
</p>
<p>If input is SpatialPixelsDataFrame (i.e. <code>polyOut = FALSE</code> in
<code>findSite</code>), a simple density surface map is plotted.
</p>


<h3>Value</h3>

<p>Returns a figure of either single map with all core ranges displayed
together, or a series of facetted maps, each of which shows a utilization
distribution corresponding to a level of ID in <em>KDE</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estSpaceUse">estSpaceUse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KDE &lt;- track2KBA::KDE_example

## identify potential sites
pot_site &lt;- findSite(KDE, represent = 90, levelUD = 50)
## Map it
mapSite(pot_site)

</code></pre>

<hr>
<h2 id='mapTrips'>Make simple maps of foraging trips</h2><span id='topic+mapTrips'></span>

<h3>Description</h3>

<p><code>mapTrips</code> uses output from <code>tripSplit</code> to create maps illustrating
movements for each ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapTrips(trips, colony, IDs = NULL, colorBy = c("complete", "trip"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapTrips_+3A_trips">trips</code></td>
<td>
<p>SpatialPointsDataFrame. Must be output of
<code><a href="#topic+tripSplit">tripSplit</a></code> function).</p>
</td></tr>
<tr><td><code id="mapTrips_+3A_colony">colony</code></td>
<td>
<p>data.frame. Containing 'Latitude' and 'Longitude' fields
specifying the central location(s) from which trips begin. If more than one
location, each row should correspond to an appropriate location (Lat/Lon) for
each ID value in <em>trips</em>.</p>
</td></tr>
<tr><td><code id="mapTrips_+3A_ids">IDs</code></td>
<td>
<p>numeric vector. Sequence of numeric indices for the IDs you wish
to map. Max of 25.</p>
</td></tr>
<tr><td><code id="mapTrips_+3A_colorby">colorBy</code></td>
<td>
<p>character string. Either &quot;complete&quot; if trips are to be
coloured as complete or incomplete, or &quot;trip&quot; if trips are to be coloured by
trip ID.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function only works with the output of <code>tripSplit</code>.
</p>


<h3>Value</h3>

<p>Returns a figure of facetted maps, each of which corresponds to a
level of ID in <em>trips</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tripSplit">tripSplit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make some play data
dataGroup &lt;- data.frame(Longitude = rep(c(1:10, 10:1), 2), 
                        Latitude =  rep(c(1:10, 10:1), 2),
                        ID = c(rep("A", 20), rep("B", 20)),
                        DateTime = format(
                        lubridate::ymd_hms("2021-01-01 00:00:00") +
                        lubridate::hours(0:19))
)
colony &lt;- data.frame(
 Longitude = dataGroup$Longitude[1], Latitude = dataGroup$Latitude[1]
)
Trips &lt;- tripSplit(dataGroup,
                   colony=colony,
                   innerBuff=2,
                   returnBuff=20,
                   duration=1,
                   nests = FALSE,
                   rmNonTrip = TRUE
)
## Visualize trips
mapTrips(Trips, colony)                   # add colony location to each facet
mapTrips(Trips, colony, colorBy = "trip") # color trips by their order

</code></pre>

<hr>
<h2 id='move2KBA'>Import Movebank data sets for track2KBA analysis</h2><span id='topic+move2KBA'></span>

<h3>Description</h3>

<p><code>move2KBA</code> imports data from Movebank repository and re-formats them to
fit track2KBA functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move2KBA(movebankID = NULL, user = NULL, password = NULL, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="move2KBA_+3A_movebankid">movebankID</code></td>
<td>
<p>character or numeric. Character: full name of the study, as
stored on Movebank. Numeric: Movebank ID of the study. Both can be obtained
on the Study Details page on Movebank (<a href="https://www.movebank.org">https://www.movebank.org</a>) or with
<code><a href="move.html#topic+getMovebankID">getMovebankID</a></code>.</p>
</td></tr>
<tr><td><code id="move2KBA_+3A_user">user</code></td>
<td>
<p>Username associated with your Movebank account.</p>
</td></tr>
<tr><td><code id="move2KBA_+3A_password">password</code></td>
<td>
<p>password associated with your Movebank username.</p>
</td></tr>
<tr><td><code id="move2KBA_+3A_filename">filename</code></td>
<td>
<p>character. File path to .csv downloaded
from <a href="https://www.movebank.org">https://www.movebank.org</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function for functions in <code>move</code> package to import and
format tracking data from Movebank. It also attains study site location data
(lat/lons).
</p>


<h3>Value</h3>

<p>Returns a list object of length two, containing tracking data
(accessed using: <code>dataset$data</code>) and study site location information
(accessed using: <code>dataset$site</code>) .
</p>


<h3>See Also</h3>

<p><code><a href="move.html#topic+getMovebankData">getMovebankData</a></code> for data download,
<code><a href="move.html#topic+getMovebank">getMovebank</a></code> for study metadata,
<code><a href="move.html#topic+getMovebankID">getMovebankID</a></code> for getting study ID number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

dataset &lt;- move2KBA(movebankID=xxx, user="myusername", password="mypassword")

tracks &lt;- dataset$data  ## access tracking data
site   &lt;- dataset$site    ## access study site coordinates

## End(Not run)

</code></pre>

<hr>
<h2 id='projectTracks'>Project tracking data</h2><span id='topic+projectTracks'></span>

<h3>Description</h3>

<p><code>projectTracks</code> is a convenience function to project tracking data to a
an equal-area projection for use in kernel density analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectTracks(dataGroup, projType, custom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectTracks_+3A_datagroup">dataGroup</code></td>
<td>
<p>data.frame or SpatialPointsDataFrame. Tracking data, with
fields as named by <code><a href="#topic+formatFields">formatFields</a></code>. Must contain 'Latitude' and
'Longitude' columns.</p>
</td></tr>
<tr><td><code id="projectTracks_+3A_projtype">projType</code></td>
<td>
<p>character. Select type of equal-area projection to use. Two
options are are available: 'cylin' projects to a World Cylindrical Equal Area
projection, and 'azim' projects to a Lambert Azimuthal EA.</p>
</td></tr>
<tr><td><code id="projectTracks_+3A_custom">custom</code></td>
<td>
<p>logical (TRUE/FALSE). Choose whether projection will use
default centering parameters or whether to set projection center on centroid
of latitude and longitude in dataGroup.
</p>
<p>Input data can be tracks split into trips (i.e. output of
<code><a href="#topic+tripSplit">tripSplit</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data are transformed to either a World Cylindrical Equal Area, or a Lambert
equal-area projection. Cylindrical projections generally appear better for
data that are distributed more along one axis, while azimuthal appear better
for data that is distributed evenly within a radius. The most important thing
is that the data are in an equal-area projection for Kernel Density Analysis
(e.g. <code><a href="#topic+estSpaceUse">estSpaceUse</a></code>).
</p>
<p>If <code>custom=TRUE</code>, the projection will be centered on the data. This
is particularly preferable for data that cross the international dateline,
or near the poles. However, it is important to recognize that this projection
is specific to inpute dataset (i.e. <code>dataGroup</code>) so if
<code>projectTracks</code> is run again with even slightly different data, the
projections will differ, which may cause issues down the line if merging
spatial datasets again.
</p>
<p>NOTE that these projections may not be the most appropriate for your data and
it is almost certainly better to manually identify a projection appropriate
for your study region. Custom projections are centered on the centroid of
the tracking locations, which is biased for locations close to the poles. In
this case it would be better identify an appropriate polar projection for
your study are instead of relying on <code>projectTracks</code>. So it is not
strictly necessary for <code>projectTracks</code> to be used in track2KBA analysis,
what is important is that an equal-area projection of some kind is used when
constructing utilization distributions.
</p>


<h3>Value</h3>

<p>Returns a SpatialPointsDataFrame, which can be used for the following
functions: <code><a href="#topic+findScale">findScale</a></code>, <code><a href="#topic+estSpaceUse">estSpaceUse</a></code>,
<code><a href="#topic+indEffectTest">indEffectTest</a></code>, <code><a href="#topic+repAssess">repAssess</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tripSummary">tripSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dataGroup &lt;- data.frame(Longitude = c(1, 2, 3, 1), 
                 Latitude =  c(1, 1, 2, 1),
                 ID = rep("A", 4),
                 DateTime = format(
                   lubridate::ymd_hms("2021-01-01 00:00:00") + 
                   lubridate::hours(0:3)
                    )
                 )

## project tracks 
tracks_prj &lt;- projectTracks(
dataGroup, 
projType = "azim", 
custom = "TRUE"
)


</code></pre>

<hr>
<h2 id='repAssess'>Assess sample representativeness</h2><span id='topic+repAssess'></span>

<h3>Description</h3>

<p><code>repAssess</code> estimates the degree to which the space use of a tracked
sample of animals represents that of the larger population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repAssess(
  tracks,
  KDE = NULL,
  iteration = 1,
  levelUD,
  avgMethod = "mean",
  nCores = 1,
  bootTable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repAssess_+3A_tracks">tracks</code></td>
<td>
<p>SpatialPointsDataFrame of spatially projected animal
relocations. Must include 'ID' field.</p>
</td></tr>
<tr><td><code id="repAssess_+3A_kde">KDE</code></td>
<td>
<p>Kernel Density Estimates for individual animals. Several input
options: an estUDm, a SpatialPixels/GridDataFrame, or a RasterStack.
If estUDm, must be as created by <code><a href="#topic+estSpaceUse">estSpaceUse</a></code> or
<code>adehabitatHR::kernelUD</code>, if Spatial* each column should correspond to
the Utilization Distribution of a single individual or track. If a
RasterStack, each layer must be an individual UD.</p>
</td></tr>
<tr><td><code id="repAssess_+3A_iteration">iteration</code></td>
<td>
<p>numeric. Number of times to repeat sub-sampling procedure.
The higher the iterations, the more robust the result.</p>
</td></tr>
<tr><td><code id="repAssess_+3A_levelud">levelUD</code></td>
<td>
<p>numeric. Specify which contour of the utilization distribution
(<code>KDE</code>) you wish to filter to (e.g. core area=50, home range=95).</p>
</td></tr>
<tr><td><code id="repAssess_+3A_avgmethod">avgMethod</code></td>
<td>
<p>character. Choose whether to use the arithmetic or weighted
mean when combining individual IDs. Options are :'mean' arithmetic mean, or
'weighted', which weights each UD by the numner of points per level of ID.</p>
</td></tr>
<tr><td><code id="repAssess_+3A_ncores">nCores</code></td>
<td>
<p>numeric. The number of processing cores to use. For heavy
operations, the higher the faster. NOTE: CRAN sets a maximum at 2 cores. If
using the git-hub version of the package, this can be set to a maximum of one
fewer than the maximum cores in your computer.</p>
</td></tr>
<tr><td><code id="repAssess_+3A_boottable">bootTable</code></td>
<td>
<p>logical (TRUE/FALSE). If TRUE, output is a list, containing
in the first slot the representativeness results summarized in a table, and
in the second the full results of the iterated inclusion calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Representativeness is assessed by fitting statistical model to the
relationship between sample size and inclusion rate. Incusion rate is the
proportion of out-sample points included in in-sample space use areas.
</p>
<p>First, the set of IDs is iteratively sub-sampled, and in each iteration a set
of individual Utilization Distributions (UD, 'KDE' argument) are pooled and
the points of the un-selected (out-sample) IDs are overlaid on the 
area ('levelUD') of the UD. The proportion of these outsample points which
overlap the pooled UD area is known as the inclusion rate, and represents
an estimate of representativeness at each sample size. Then, a non-linear
function is fit to the relationship between the inclusion rate and sample
size (i.e. number of tracks/animals) in order to estimate the point at which
the relationship reaches an asymptote (i.e. no more information added per
new track). <code>repAssess</code> then estimates the representativeness of the
sample by dividing the inclusion rate estimated at the maximum sample size
minus 3 (for samples where n &lt; 20), 2 (for samples &lt; 50) or 1 (for sample
&gt;100) by this asymptote. The maximum sample size appearing in the plot
will be different than the true 'n' of the dataset in order to account for
the possible number of combinations of individuals, thereby ensuring a
robust result. The maximum sample size reflects the number of KDEs, so if
any ID has fewer than 5 points, this ID is omitted from the analysis.
Finally, using this relationship, minimum representative sample sizes
(70
</p>
<p><code><a href="#topic+repAssess">repAssess</a></code> accepts UDs calculated outside of <code>track2KBA</code>,
if they have been converted to class <code>RasterStack</code> or
<code>SpatialPixelsDataFrame</code>. However, one must make sure that the cell
values represent continuous probability densities (i.e. values &gt;=0 which
integrate to 1 over the raster) and not not discrete probability masses
(i.e. values &gt;=0 which sum to 1), nor home range quantiles (i.e. 0-1, or
0-100 representing 
</p>
<p>When setting <code>avgMethod</code> care must be taken. If the number of points
differ greatly among individuals and the UDs are calculated as classic
KDEs (e.g. from <code><a href="#topic+estSpaceUse">estSpaceUse</a></code>) then the weighted mean is likely
the optimal way to pool individual UDs. However, if any other method (for
example AKDE, auto-correlated KDE) was used to estimate UDs, then the
arithmetic mean is the safer option.
</p>
<p>NOTE: this function does not work with fewer than 4 IDs (tracks or
individual animals).
</p>


<h3>Value</h3>

<p>if <code>bootTable=FALSE</code> (the default) A single-row data.frame is
returned, with columns '<em>SampleSize</em>' signifying the sample size (i.e.,
number of KDEs)'<em>out</em>' signifying the percent representativeness of the
sample,'<em>type</em>' is the type  of asymptote value used to calculate the
'<em>out</em>' value, and '<em>asym</em>' is the asymptote value used.
If <code>bootTable=TRUE</code>, a list returned with above dataframe in first slot
and full iteration results in second slot.
</p>
<p>There are two potential values for '<em>type</em>':'asymptote' is
the ideal, where the asymptote value is calculated from the parameter
estimates of the successful nls model fit. 'inclusion' is used if the nls
fails to converge, or if the fit model is flipped and the asymptote value
is negative.  In these casess, the mean inclusion rate is taken for the
largest sample size.'Rep70' signifies the sample size which is ~70
representative, and 'Rep95' signifies the sample
size which approahces the asymptote.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
tracks_raw &lt;- track2KBA::boobies
## format data
tracks_formatted &lt;- formatFields(
  dataGroup = tracks_raw,
  fieldID   = "track_id",
  fieldLat  ="latitude",
  fieldLon  ="longitude",
  fieldDate ="date_gmt",
  fieldTime ="time_gmt"
)

## project dataset
tracks_prj &lt;- projectTracks(
  tracks_formatted,
  projType = "azim",
  custom = "TRUE"
)
KDE &lt;- track2KBA::KDE_example

result &lt;- repAssess(tracks_prj, KDE, levelUD = 50, iteration = 1)

</code></pre>

<hr>
<h2 id='tripSplit'>Split tracking data into trips</h2><span id='topic+tripSplit'></span><span id='topic+splitSingleID'></span>

<h3>Description</h3>

<p><code>tripSplit</code> employs <code>splitSingleID</code> to split data from multiple
individuals' into discrete trips made from centrally-located places.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tripSplit(
  dataGroup,
  colony,
  innerBuff = NULL,
  returnBuff = NULL,
  duration = NULL,
  gapLimit = NULL,
  nests = FALSE,
  rmNonTrip = FALSE,
  verbose = TRUE
)

splitSingleID(
  Track,
  colony,
  innerBuff = 15,
  returnBuff = 45,
  duration = 12,
  gapLimit = gapLimit,
  nests = FALSE,
  verbose = verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tripSplit_+3A_datagroup">dataGroup</code></td>
<td>
<p>data.frame. Must contain 'Latitude', 'Longitude', 'ID' and
'DateTime' columns (correct format may be assured using
<code><a href="#topic+formatFields">formatFields</a></code> function).</p>
</td></tr>
<tr><td><code id="tripSplit_+3A_colony">colony</code></td>
<td>
<p>data.frame. Containing 'Latitude' and 'Longitude' fields
specifying the central location(s) from which trips begin. If data are from
MoveBank this information may be extracted using the <code><a href="#topic+move2KBA">move2KBA</a></code>
function. If <em>nests</em>=TRUE, each row should correspond to an appropriate
location (Lat/Lon) for each ID value in <em>dataGroup</em>.</p>
</td></tr>
<tr><td><code id="tripSplit_+3A_innerbuff">innerBuff</code></td>
<td>
<p>numeric (in kilometers). Indicate the distance that an
animal must travel for the movement to be considered a trip. Note that this
is also the metric that determines whether two subsequent trips are split -
if your animal records locations &gt; <code>innerBuff</code> (km) from its place of
origin and no locations at the place of origin (e.g. for burrow-nesting
species) then subsequent trips may be lumped into a single trip. Increase
<code>innerBuff</code> to ensure correct splitting of trips.</p>
</td></tr>
<tr><td><code id="tripSplit_+3A_returnbuff">returnBuff</code></td>
<td>
<p>numeric (in kilometers). Indicate the proximity required
for a trip to be considered as returning. This is useful for identifying
incomplete trips (i.e. where storage/transmission failed during the trip).</p>
</td></tr>
<tr><td><code id="tripSplit_+3A_duration">duration</code></td>
<td>
<p>numeric (in hours). The period of time that the animals must
be at large for the movement to be considered a trip.</p>
</td></tr>
<tr><td><code id="tripSplit_+3A_gaplimit">gapLimit</code></td>
<td>
<p>numeric (in days). The period of time between points to be
considered too large to be a contiguous tracking event. Can be used to ensure
that deployments on the same animal in different years do not get combined
into extra long trips. Defaults to one year.</p>
</td></tr>
<tr><td><code id="tripSplit_+3A_nests">nests</code></td>
<td>
<p>logical scalar (TRUE/FALSE). Should the central place used in
trip-splitting be specific to each ID? If so, each place must be matched with
an 'ID' value in both <em>dataGroup</em> and <em>colony</em> objects.</p>
</td></tr>
<tr><td><code id="tripSplit_+3A_rmnontrip">rmNonTrip</code></td>
<td>
<p>logical scalar (TRUE/FALSE). Should periods not associated
with trips be filtered out? Note that this does not filter out the trip
start and end points which fall within innerBuff. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="tripSplit_+3A_verbose">verbose</code></td>
<td>
<p>logical scalar (TRUE/FALSE). Should the function print
messages when trips start outside the innerBuffer or doesn't return to the
'colony'? Default is TRUE.
<code>tripSummary</code>. Default is TRUE.</p>
</td></tr>
<tr><td><code id="tripSplit_+3A_track">Track</code></td>
<td>
<p>dataFrame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function splits central place foraging animal movement data into
individual trips away from a central location based on distance and time.
</p>
<p><code>nests=TRUE</code> may be used if it is desired, for example, to use specific
nest locations instead of one central location for all individuals/dataGroup.
</p>


<h3>Value</h3>

<p>Returns an un-projected (WGS84) SpatialPointsDataFrame, with the
field 'tripID' added to identify each unique trip-ID combination.
If rmNonTrip=TRUE, then output has been filtered of points deemed not
associated with trip movements.
</p>


<h3>See Also</h3>

<p><code>tripSummary</code>, <code>mapTrips</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make some play data
dataGroup &lt;- data.frame(Longitude = rep(c(1:10, 10:1), 2), 
                        Latitude =  rep(c(1:10, 10:1), 2),
                        ID = c(rep("A", 20), rep("B", 20)),
                        DateTime = format(
                        lubridate::ymd_hms("2021-01-01 00:00:00") +
                        lubridate::hours(0:19))
)
colony &lt;- data.frame(
 Longitude = dataGroup$Longitude[1], Latitude = dataGroup$Latitude[1]
)
## split tracks into trips
Trips &lt;- tripSplit(dataGroup,
                   colony=colony,
                   innerBuff=2,
                   returnBuff=20,
                   duration=1,
                   nests = FALSE,
                   rmNonTrip = TRUE
)
                   
</code></pre>

<hr>
<h2 id='tripSummary'>Summary of trip movements</h2><span id='topic+tripSummary'></span>

<h3>Description</h3>

<p><code>tripSummary</code> provides a simple summary of foraging trip distances,
durations, and directions performed by central place foraging animals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tripSummary(trips, colony = NULL, nests = FALSE, extraDist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tripSummary_+3A_trips">trips</code></td>
<td>
<p>SpatialPointsDataFrame, as produced by <code><a href="#topic+tripSplit">tripSplit</a></code>.</p>
</td></tr>
<tr><td><code id="tripSummary_+3A_colony">colony</code></td>
<td>
<p>data.frame with 'Latitude' and 'Longitude' columns specifying
the locations of the central place (e.g. breeding colony). If
<code>nests=TRUE</code>, <code>colony</code> should have a third column, 'ID'
with corresponding character values in the 'ID' field in <em>trips</em>.</p>
</td></tr>
<tr><td><code id="tripSummary_+3A_nests">nests</code></td>
<td>
<p>logical scalar (TRUE/FALSE). Were central place
(e.g. deployment) locations used in <code>tripSplit</code> specific to each unique
'ID'? If so, each place must be matched with an 'ID' value in both
<code>trips</code> and <code>colony</code> objects.</p>
</td></tr>
<tr><td><code id="tripSummary_+3A_extradist">extraDist</code></td>
<td>
<p>logical scalar (TRUE/FALSE). If TRUE, the distance between
the first and last points of each trip and the <code>colony</code> will be added to
the 'total_dist' (total distance travelled) for each trip.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>nests</em>=T may be used if it is desired, for example, to use specific
nest locations instead of one central location for all individuals/tracks.
</p>


<h3>Value</h3>

<p>Returns a tibble data.frame grouped by ID. Trip characteristics
included are trip duration (in hours), maximum distance and cumulative
distance travelled (in kilometers), direction (in degrees, measured from
origin to furthest point of track), start and end times as well as a unique
trip identifier ('tripID') for each trip performed by each individual in the
data set. Distances are calculated on a great circle.
</p>
<p>If the beginning of a track is starts out on a trip which is followed by only
one point within <em>InnerBuff</em>, this is considered an 'incomplete' trip
and will have an NA for duration. If an animal leaves on a trip but does not
return within the <em>ReturnBuff</em> this will be also classified an
'incomplete trip'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tripSplit">tripSplit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make some play data
dataGroup &lt;- data.frame(Longitude = rep(c(1:10, 10:1), 2), 
               Latitude =  rep(c(1:10, 10:1), 2),
               ID = c(rep("A", 20), rep("B", 20)),
               DateTime = format(
               lubridate::ymd_hms("2021-01-01 00:00:00") + 
               lubridate::hours(0:19))
)

colony &lt;- data.frame(
Longitude = dataGroup$Longitude[1], Latitude = dataGroup$Latitude[1]
)
## split tracks into trips
trips &lt;- tripSplit(dataGroup, colony=colony, 
                innerBuff = 1, 
                returnBuff = 1, 
                duration = 0.5,
                rmNonTrip = FALSE
)
## summarise trip characteristics
sumTrips &lt;- tripSummary(trips, colony)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
