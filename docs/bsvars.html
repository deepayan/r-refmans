<!DOCTYPE html><html><head><title>Help for package bsvars</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bsvars}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bsvars-package'><p>Bayesian Estimation of Structural Vector Autoregressive Models</p></a></li>
<li><a href='#compute_conditional_sd'><p>Computes posterior draws of structural shock conditional standard deviations</p></a></li>
<li><a href='#compute_conditional_sd.PosteriorBSVAR'><p>Computes posterior draws of structural shock conditional standard deviations</p></a></li>
<li><a href='#compute_conditional_sd.PosteriorBSVARMIX'><p>Computes posterior draws of structural shock conditional standard deviations</p></a></li>
<li><a href='#compute_conditional_sd.PosteriorBSVARMSH'><p>Computes posterior draws of structural shock conditional standard deviations</p></a></li>
<li><a href='#compute_conditional_sd.PosteriorBSVARSV'><p>Computes posterior draws of structural shock conditional standard deviations</p></a></li>
<li><a href='#compute_fitted_values'><p>Computes posterior draws from data predictive density</p></a></li>
<li><a href='#compute_fitted_values.PosteriorBSVAR'><p>Computes posterior draws from data predictive density</p></a></li>
<li><a href='#compute_fitted_values.PosteriorBSVARMIX'><p>Computes posterior draws from data predictive density</p></a></li>
<li><a href='#compute_fitted_values.PosteriorBSVARMSH'><p>Computes posterior draws from data predictive density</p></a></li>
<li><a href='#compute_fitted_values.PosteriorBSVARSV'><p>Computes posterior draws from data predictive density</p></a></li>
<li><a href='#compute_historical_decompositions'><p>Computes posterior draws of historical decompositions</p></a></li>
<li><a href='#compute_historical_decompositions.PosteriorBSVAR'><p>Computes posterior draws of historical decompositions</p></a></li>
<li><a href='#compute_historical_decompositions.PosteriorBSVARMIX'><p>Computes posterior draws of historical decompositions</p></a></li>
<li><a href='#compute_historical_decompositions.PosteriorBSVARMSH'><p>Computes posterior draws of historical decompositions</p></a></li>
<li><a href='#compute_historical_decompositions.PosteriorBSVARSV'><p>Computes posterior draws of historical decompositions</p></a></li>
<li><a href='#compute_impulse_responses'><p>Computes posterior draws of impulse responses</p></a></li>
<li><a href='#compute_impulse_responses.PosteriorBSVAR'><p>Computes posterior draws of impulse responses</p></a></li>
<li><a href='#compute_impulse_responses.PosteriorBSVARMIX'><p>Computes posterior draws of impulse responses</p></a></li>
<li><a href='#compute_impulse_responses.PosteriorBSVARMSH'><p>Computes posterior draws of impulse responses</p></a></li>
<li><a href='#compute_impulse_responses.PosteriorBSVARSV'><p>Computes posterior draws of impulse responses</p></a></li>
<li><a href='#compute_regime_probabilities'><p>Computes posterior draws of regime probabilities</p></a></li>
<li><a href='#compute_regime_probabilities.PosteriorBSVARMIX'><p>Computes posterior draws of regime probabilities</p></a></li>
<li><a href='#compute_regime_probabilities.PosteriorBSVARMSH'><p>Computes posterior draws of regime probabilities</p></a></li>
<li><a href='#compute_structural_shocks'><p>Computes posterior draws of structural shocks</p></a></li>
<li><a href='#compute_structural_shocks.PosteriorBSVAR'><p>Computes posterior draws of structural shocks</p></a></li>
<li><a href='#compute_structural_shocks.PosteriorBSVARMIX'><p>Computes posterior draws of structural shocks</p></a></li>
<li><a href='#compute_structural_shocks.PosteriorBSVARMSH'><p>Computes posterior draws of structural shocks</p></a></li>
<li><a href='#compute_structural_shocks.PosteriorBSVARSV'><p>Computes posterior draws of structural shocks</p></a></li>
<li><a href='#compute_variance_decompositions'><p>Computes posterior draws of the forecast error variance decomposition</p></a></li>
<li><a href='#compute_variance_decompositions.PosteriorBSVAR'><p>Computes posterior draws of the forecast error variance decomposition</p></a></li>
<li><a href='#compute_variance_decompositions.PosteriorBSVARMIX'><p>Computes posterior draws of the forecast error variance decomposition</p></a></li>
<li><a href='#compute_variance_decompositions.PosteriorBSVARMSH'><p>Computes posterior draws of the forecast error variance decomposition</p></a></li>
<li><a href='#compute_variance_decompositions.PosteriorBSVARSV'><p>Computes posterior draws of the forecast error variance decomposition</p></a></li>
<li><a href='#estimate'><p>Bayesian estimation of Structural Vector Autoregressions via Gibbs sampler</p></a></li>
<li><a href='#estimate.BSVAR'><p>Bayesian estimation of a homoskedastic Structural Vector Autoregression via Gibbs sampler</p></a></li>
<li><a href='#estimate.BSVARMIX'><p>Bayesian estimation of a Structural Vector Autoregression with shocks following</p>
a finite mixture of normal components via Gibbs sampler</a></li>
<li><a href='#estimate.BSVARMSH'><p>Bayesian estimation of a Structural Vector Autoregression with</p>
Markov-switching heteroskedasticity via Gibbs sampler</a></li>
<li><a href='#estimate.BSVARSV'><p>Bayesian estimation of a Structural Vector Autoregression with</p>
Stochastic Volatility heteroskedasticity via Gibbs sampler</a></li>
<li><a href='#estimate.PosteriorBSVAR'><p>Bayesian estimation of a homoskedastic Structural Vector Autoregression via Gibbs sampler</p></a></li>
<li><a href='#estimate.PosteriorBSVARMIX'><p>Bayesian estimation of a Structural Vector Autoregression with shocks following</p>
a finite mixture of normal components via Gibbs sampler</a></li>
<li><a href='#estimate.PosteriorBSVARMSH'><p>Bayesian estimation of a Structural Vector Autoregression with</p>
Markov-switching heteroskedasticity via Gibbs sampler</a></li>
<li><a href='#estimate.PosteriorBSVARSV'><p>Bayesian estimation of a Structural Vector Autoregression with</p>
Stochastic Volatility heteroskedasticity via Gibbs sampler</a></li>
<li><a href='#forecast'><p>Forecasting using Structural Vector Autoregression</p></a></li>
<li><a href='#forecast.PosteriorBSVAR'><p>Forecasting using Structural Vector Autoregression</p></a></li>
<li><a href='#forecast.PosteriorBSVARMIX'><p>Forecasting using Structural Vector Autoregression</p></a></li>
<li><a href='#forecast.PosteriorBSVARMSH'><p>Forecasting using Structural Vector Autoregression</p></a></li>
<li><a href='#forecast.PosteriorBSVARSV'><p>Forecasting using Structural Vector Autoregression</p></a></li>
<li><a href='#normalise_posterior'><p>Waggoner &amp; Zha (2003) row signs normalisation of the posterior draws for matrix <code class="reqn">B</code></p></a></li>
<li><a href='#plot_ribbon'><p>Plots the median and an interval between two specified percentiles</p>
for a sequence of <code>K</code> random variables</a></li>
<li><a href='#plot.Forecasts'><p>Plots fitted values of dependent variables</p></a></li>
<li><a href='#plot.PosteriorFEVD'><p>Plots forecast error variance decompositions</p></a></li>
<li><a href='#plot.PosteriorFitted'><p>Plots fitted values of dependent variables</p></a></li>
<li><a href='#plot.PosteriorHD'><p>Plots historical decompositions</p></a></li>
<li><a href='#plot.PosteriorIR'><p>Plots impulse responses</p></a></li>
<li><a href='#plot.PosteriorRegimePr'><p>Plots estimated regime probabilities</p></a></li>
<li><a href='#plot.PosteriorShocks'><p>Plots structural shocks</p></a></li>
<li><a href='#plot.PosteriorSigma'><p>Plots structural shocks' conditional standard deviations</p></a></li>
<li><a href='#specify_bsvar'><p>R6 Class representing the specification of the homoskedastic BSVAR model</p></a></li>
<li><a href='#specify_bsvar_mix'><p>R6 Class representing the specification of the BSVAR model with a zero-mean mixture of normals model for structural shocks.</p></a></li>
<li><a href='#specify_bsvar_msh'><p>R6 Class representing the specification of the BSVAR model with Markov Switching Heteroskedasticity.</p></a></li>
<li><a href='#specify_bsvar_sv'><p>R6 Class representing the specification of the BSVAR model with Stochastic Volatility heteroskedasticity.</p></a></li>
<li><a href='#specify_data_matrices'><p>R6 Class Representing DataMatricesBSVAR</p></a></li>
<li><a href='#specify_identification_bsvars'><p>R6 Class Representing IdentificationBSVARs</p></a></li>
<li><a href='#specify_posterior_bsvar'><p>R6 Class Representing PosteriorBSVAR</p></a></li>
<li><a href='#specify_posterior_bsvar_mix'><p>R6 Class Representing PosteriorBSVARMIX</p></a></li>
<li><a href='#specify_posterior_bsvar_msh'><p>R6 Class Representing PosteriorBSVARMSH</p></a></li>
<li><a href='#specify_posterior_bsvar_sv'><p>R6 Class Representing PosteriorBSVARSV</p></a></li>
<li><a href='#specify_prior_bsvar'><p>R6 Class Representing PriorBSVAR</p></a></li>
<li><a href='#specify_prior_bsvar_mix'><p>R6 Class Representing PriorBSVARMIX</p></a></li>
<li><a href='#specify_prior_bsvar_msh'><p>R6 Class Representing PriorBSVARMSH</p></a></li>
<li><a href='#specify_prior_bsvar_sv'><p>R6 Class Representing PriorBSVARSV</p></a></li>
<li><a href='#specify_starting_values_bsvar'><p>R6 Class Representing StartingValuesBSVAR</p></a></li>
<li><a href='#specify_starting_values_bsvar_mix'><p>R6 Class Representing StartingValuesBSVARMIX</p></a></li>
<li><a href='#specify_starting_values_bsvar_msh'><p>R6 Class Representing StartingValuesBSVARMSH</p></a></li>
<li><a href='#specify_starting_values_bsvar_sv'><p>R6 Class Representing StartingValuesBSVARSV</p></a></li>
<li><a href='#summary.Forecasts'><p>Provides posterior summary of Forecasts</p></a></li>
<li><a href='#summary.PosteriorBSVAR'><p>Provides posterior summary of homoskedastic Structural VAR estimation</p></a></li>
<li><a href='#summary.PosteriorBSVARMIX'><p>Provides posterior summary of non-normal Structural VAR estimation</p></a></li>
<li><a href='#summary.PosteriorBSVARMSH'><p>Provides posterior summary of heteroskedastic Structural VAR estimation</p></a></li>
<li><a href='#summary.PosteriorBSVARSV'><p>Provides posterior summary of heteroskedastic Structural VAR estimation</p></a></li>
<li><a href='#summary.PosteriorFEVD'><p>Provides posterior summary of forecast error variance decompositions</p></a></li>
<li><a href='#summary.PosteriorFitted'><p>Provides posterior summary of variables' fitted values</p></a></li>
<li><a href='#summary.PosteriorHD'><p>Provides posterior summary of historical decompositions</p></a></li>
<li><a href='#summary.PosteriorIR'><p>Provides posterior summary of impulse responses</p></a></li>
<li><a href='#summary.PosteriorRegimePr'><p>Provides posterior summary of regime probabilities</p></a></li>
<li><a href='#summary.PosteriorShocks'><p>Provides posterior summary of structural shocks</p></a></li>
<li><a href='#summary.PosteriorSigma'><p>Provides posterior summary of structural shocks' conditional standard</p>
deviations</a></li>
<li><a href='#summary.SDDRautoregression'><p>Provides summary of verifying hypotheses about autoregressive parameters</p></a></li>
<li><a href='#summary.SDDRvolatility'><p>Provides summary of verifying homoskedasticity</p></a></li>
<li><a href='#us_fiscal_ex'><p>A 3-variable system of exogenous variables for the US fiscal model for</p>
the period 1948 Q1 &ndash; 2024 Q1</a></li>
<li><a href='#us_fiscal_lsuw'><p>A 3-variable US fiscal system for the period 1948 Q1 &ndash; 2024 Q1</p></a></li>
<li><a href='#verify_autoregression'><p>Verifies hypotheses involving autoregressive parameters</p></a></li>
<li><a href='#verify_autoregression.PosteriorBSVAR'><p>Verifies hypotheses involving autoregressive parameters</p></a></li>
<li><a href='#verify_autoregression.PosteriorBSVARMIX'><p>Verifies hypotheses involving autoregressive parameters</p></a></li>
<li><a href='#verify_autoregression.PosteriorBSVARMSH'><p>Verifies hypotheses involving autoregressive parameters</p></a></li>
<li><a href='#verify_autoregression.PosteriorBSVARSV'><p>Verifies hypotheses involving autoregressive parameters</p></a></li>
<li><a href='#verify_volatility'><p>Verifies heteroskedasticity of structural shocks equation by equation</p></a></li>
<li><a href='#verify_volatility.PosteriorBSVAR'><p>Verifies heteroskedasticity of structural shocks equation by equation</p></a></li>
<li><a href='#verify_volatility.PosteriorBSVARMIX'><p>Verifies heteroskedasticity of structural shocks equation by equation</p></a></li>
<li><a href='#verify_volatility.PosteriorBSVARMSH'><p>Verifies heteroskedasticity of structural shocks equation by equation</p></a></li>
<li><a href='#verify_volatility.PosteriorBSVARSV'><p>Verifies heteroskedasticity of structural shocks equation by equation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Estimation of Structural Vector Autoregressive Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides fast and efficient procedures for Bayesian analysis of Structural Vector Autoregressions. This package estimates a wide range of models, including homo-, heteroskedastic, and non-normal specifications. Structural models can be identified by adjustable exclusion restrictions, time-varying volatility, or non-normality. They all include a flexible three-level equation-specific local-global hierarchical prior distribution for the estimated level of shrinkage for autoregressive and structural parameters. Additionally, the package facilitates predictive and structural analyses such as impulse responses, forecast error variance and historical decompositions, forecasting, verification of heteroskedasticity, non-normality, and hypotheses on autoregressive parameters, as well as analyses of structural shocks, volatilities, and fitted values. Beautiful plots, informative summary functions, and extensive documentation complement all this. The implemented techniques align closely with those presented in Lütkepohl, Shang, Uzeda, &amp; Woźniak (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>&gt;, Lütkepohl &amp; Woźniak (2020) &lt;<a href="https://doi.org/10.1016%2Fj.jedc.2020.103862">doi:10.1016/j.jedc.2020.103862</a>&gt;, and Song &amp; Woźniak (2021) &lt;<a href="https://doi.org/10.1093%2Facrefore%2F9780190625979.013.174">doi:10.1093/acrefore/9780190625979.013.174</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-26</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tomasz Woźniak &lt;wozniak.tom@pm.me&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.7), RcppProgress (&ge; 0.1), RcppTN, GIGrvg, R6,
stochvol</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress, RcppArmadillo, RcppTN</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bsvars.github.io/bsvars/">https://bsvars.github.io/bsvars/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bsvars/bsvars/issues">https://github.com/bsvars/bsvars/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-26 13:39:47 UTC; twozniak</td>
</tr>
<tr>
<td>Author:</td>
<td>Tomasz Woźniak <a href="https://orcid.org/0000-0003-2212-2378"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-28 06:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bsvars-package'>Bayesian Estimation of Structural Vector Autoregressive Models</h2><span id='topic+bsvars-package'></span><span id='topic+bsvars'></span>

<h3>Description</h3>

<p>Provides fast and efficient procedures for Bayesian analysis of 
Structural Vector Autoregressions. This package estimates a wide range of 
models, including homo-, heteroskedastic and non-normal specifications. 
Structural models can be identified by adjustable exclusion restrictions, 
time-varying volatility, or non-normality.
They all include a flexible three-level equation-specific local-global 
hierarchical prior distribution for the estimated level of shrinkage for 
autoregressive and structural parameters. Additionally, the package facilitates 
predictive and structural analyses such as impulse responses, forecast error 
variance and historical decompositions, forecasting, verification of 
heteroskedasticity and hypotheses on autoregressive parameters, and analyses 
of structural shocks, volatilities, and fitted values. Beautiful plots, 
informative summary functions, and extensive documentation complement all this. 
The implemented techniques align closely with those presented in 
Lütkepohl, Shang, Uzeda, &amp; Woźniak (2024) &lt;doi:10.48550/arXiv.2404.11057&gt;, 
Lütkepohl &amp; Woźniak (2020) &lt;doi:10.1016/j.jedc.2020.103862&gt;, 
Song &amp; Woźniak (2021) &lt;doi:10.1093/acrefore/9780190625979.013.174&gt;, and 
Woźniak &amp; Droumaguet (2015) &lt;doi:10.13140/RG.2.2.19492.55687&gt;.
</p>


<h3>Details</h3>

<p><strong>Models.</strong> All the SVAR models in this package are specified by two equations, including 
the reduced form equation:
</p>
<p style="text-align: center;"><code class="reqn">Y = AX + E</code>
</p>

<p>where <code class="reqn">Y</code> is an <code>NxT</code> matrix of dependent variables, 
<code class="reqn">X</code> is a <code>KxT</code> matrix of explanatory variables, 
<code class="reqn">E</code> is an <code>NxT</code> matrix of reduced form error terms, 
and <code class="reqn">A</code> is an <code>NxK</code> matrix of autoregressive slope coefficients and 
parameters on deterministic terms in <code class="reqn">X</code>.
</p>
<p>The structural equation is given by:
</p>
<p style="text-align: center;"><code class="reqn">BE = U</code>
</p>

<p>where <code class="reqn">U</code> is an <code>NxT</code> matrix of structural form error terms, and
<code class="reqn">B</code> is an <code>NxN</code> matrix of contemporaneous relationships.
</p>
<p>Finally, all of the models share the following assumptions regarding the structural
shocks <code>U</code>, namely, joint conditional normality given the past observations collected
in matrix <code>X</code>, and temporal and contemporaneous independence. The latter implies 
zero correlations and autocorrelations. 
</p>
<p>The various SVAR models estimated differ by the specification of structural shocks
variances. The different models include:
</p>

<ul>
<li><p> homoskedastic model with unit variances
</p>
</li>
<li><p> heteroskedastic model with stationary Markov switching in the variances
</p>
</li>
<li><p> heteroskedastic model with non-centred Stochastic Volatility process for variances
</p>
</li>
<li><p> heteroskedastic model with centred Stochastic Volatility process for variances
</p>
</li>
<li><p> non-normal model with a finite mixture of normal components and component-specific variances
</p>
</li>
<li><p> heteroskedastic model with sparse Markov switching in the variances where the number of heteroskedastic components is estimated
</p>
</li>
<li><p> non-normal model with a sparse mixture of normal components and component-specific variances where the number of heteroskedastic components is estimated
</p>
</li></ul>

<p><strong>Prior distributions.</strong> All the models feature a Minnesota prior for autoregressive 
parameters in matrix <code class="reqn">A</code> and a generalised-normal distribution for the structural 
matrix <code class="reqn">B</code>. Both of these distributions feature a 3-level equation-specific
local-global hierarchical prior that make the shrinkage estimation flexible improving
the model fit and its forecasting performance.
</p>
<p><strong>Estimation algorithm.</strong> The models are estimated using frontier numerical methods
making the Gibbs sampler fast and efficient. The sampler of the structural matrix 
follows Waggoner &amp; Zha (2003), whereas that 
for autoregressive parameters follows Chan, Koop, Yu (2022). 
The specification of Markov switching heteroskedasticity is inspired by 
Song &amp; Woźniak (2021), and that of 
Stochastic Volatility model by Kastner &amp; Frühwirth-Schnatter (2014).
The estimation algorithms for particular models are scrutinised in 
Lütkepohl, Shang, Uzeda, &amp; Woźniak (2024) and Woźniak &amp; Droumaguet (2024)
and some other inferential and identification problems are considered in 
Lütkepohl &amp; Woźniak (2020).
</p>


<h3>Note</h3>

<p>This package is currently in active development. Your comments,
suggestions and requests are warmly welcome!
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Chan, J.C.C., Koop, G, and Yu, X. (2024) Large Order-Invariant Bayesian VARs with Stochastic Volatility. <em>Journal of Business &amp; Economic Statistics</em>, <b>42</b>, <a href="https://doi.org/10.1080/07350015.2023.2252039">doi:10.1080/07350015.2023.2252039</a>.
</p>
<p>Kastner, G. and Frühwirth-Schnatter, S. (2014) Ancillarity-Sufficiency Interweaving Strategy (ASIS) for Boosting MCMC 
Estimation of Stochastic Volatility Models. <em>Computational Statistics &amp; Data Analysis</em>, <b>76</b>, 408&ndash;423, 
<a href="https://doi.org/10.1016/j.csda.2013.01.002">doi:10.1016/j.csda.2013.01.002</a>.
</p>
<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>
<p>Lütkepohl, H., and Woźniak, T., (2020) Bayesian Inference for Structural Vector Autoregressions Identified by Markov-Switching Heteroskedasticity. <em>Journal of Economic Dynamics and Control</em> <b>113</b>, 103862, <a href="https://doi.org/10.1016/j.jedc.2020.103862">doi:10.1016/j.jedc.2020.103862</a>.
</p>
<p>Song, Y., and Woźniak, T. (2021) Markov Switching Heteroskedasticity in Time Series Analysis. In: <em>Oxford Research Encyclopedia of Economics and Finance</em>. Oxford University Press, <a href="https://doi.org/10.1093/acrefore/9780190625979.013.174">doi:10.1093/acrefore/9780190625979.013.174</a>.
</p>
<p>Waggoner, D.F., and Zha, T., (2003) A Gibbs sampler for structural vector autoregressions. <em>Journal of Economic Dynamics and Control</em>, <b>28</b>, 349&ndash;366, <a href="https://doi.org/10.1016/S0165-1889%2802%2900168-9">doi:10.1016/S0165-1889(02)00168-9</a>.
</p>
<p>Woźniak, T., and Droumaguet, M., (2024) Bayesian Assessment of Identifying Restrictions for Heteroskedastic Structural VARs.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://bsvars.github.io/bsvars/">https://bsvars.github.io/bsvars/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bsvars/bsvars/issues">https://github.com/bsvars/bsvars/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)    # upload dependent variables
data(us_fiscal_ex)      # upload exogenous variables

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 4, exogenous = us_fiscal_ex)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute impulse responses 2 years ahead
irf           = compute_impulse_responses(posterior, horizon = 8)

# compute forecast error variance decomposition 2 years ahead
fevd           = compute_variance_decompositions(posterior, horizon = 8)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 4, exogenous = us_fiscal_ex) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_variance_decompositions(horizon = 8) -&gt; fevds

</code></pre>

<hr>
<h2 id='compute_conditional_sd'>Computes posterior draws of structural shock conditional standard deviations</h2><span id='topic+compute_conditional_sd'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models is 
transformed into a draw from the posterior distribution of the structural 
shock conditional standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_conditional_sd(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_conditional_sd_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome obtained by running the 
<code>estimate</code> function. The interpretation depends on the normalisation of 
the shocks using function <code>normalise_posterior()</code>. Verify if the default 
settings are appropriate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorSigma</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorSigma</code> containing <code>S</code> draws of the 
structural shock conditional standard deviations.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute structural shocks' conditional standard deviations
sigma          = compute_conditional_sd(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_conditional_sd() -&gt; csd

</code></pre>

<hr>
<h2 id='compute_conditional_sd.PosteriorBSVAR'>Computes posterior draws of structural shock conditional standard deviations</h2><span id='topic+compute_conditional_sd.PosteriorBSVAR'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models is 
transformed into a draw from the posterior distribution of the structural 
shock conditional standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVAR'
compute_conditional_sd(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_conditional_sd.PosteriorBSVAR_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVAR</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorSigma</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorSigma</code> containing <code>S</code> draws of the 
structural shock conditional standard deviations.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute structural shocks' conditional standard deviations
sigma          = compute_conditional_sd(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_conditional_sd() -&gt; csd

</code></pre>

<hr>
<h2 id='compute_conditional_sd.PosteriorBSVARMIX'>Computes posterior draws of structural shock conditional standard deviations</h2><span id='topic+compute_conditional_sd.PosteriorBSVARMIX'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models is 
transformed into a draw from the posterior distribution of the structural 
shock conditional standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMIX'
compute_conditional_sd(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_conditional_sd.PosteriorBSVARMIX_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMIX</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorSigma</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorSigma</code> containing <code>S</code> draws of the 
structural shock conditional standard deviations.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute structural shocks' conditional standard deviations
csd     = compute_conditional_sd(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_conditional_sd() -&gt; csd
  
</code></pre>

<hr>
<h2 id='compute_conditional_sd.PosteriorBSVARMSH'>Computes posterior draws of structural shock conditional standard deviations</h2><span id='topic+compute_conditional_sd.PosteriorBSVARMSH'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models is 
transformed into a draw from the posterior distribution of the structural 
shock conditional standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMSH'
compute_conditional_sd(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_conditional_sd.PosteriorBSVARMSH_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMSH</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorSigma</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorSigma</code> containing <code>S</code> draws of the 
structural shock conditional standard deviations.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute structural shocks' conditional standard deviations
csd     = compute_conditional_sd(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_conditional_sd() -&gt; csd
  
</code></pre>

<hr>
<h2 id='compute_conditional_sd.PosteriorBSVARSV'>Computes posterior draws of structural shock conditional standard deviations</h2><span id='topic+compute_conditional_sd.PosteriorBSVARSV'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models is 
transformed into a draw from the posterior distribution of the structural 
shock conditional standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSV'
compute_conditional_sd(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_conditional_sd.PosteriorBSVARSV_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSV</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorSigma</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorSigma</code> containing <code>S</code> draws of the 
structural shock conditional standard deviations.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute structural shocks' conditional standard deviations
csd     = compute_conditional_sd(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_conditional_sd() -&gt; csd
  
</code></pre>

<hr>
<h2 id='compute_fitted_values'>Computes posterior draws from data predictive density</h2><span id='topic+compute_fitted_values'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from 
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the data predictive density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_fitted_values(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_fitted_values_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome
obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorFitted</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorFitted</code> containing <code>S</code> draws from 
the data predictive density.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute draws from in-sample predictive density
fitted         = compute_fitted_values(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_fitted_values() -&gt; fitted

</code></pre>

<hr>
<h2 id='compute_fitted_values.PosteriorBSVAR'>Computes posterior draws from data predictive density</h2><span id='topic+compute_fitted_values.PosteriorBSVAR'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from 
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the data predictive density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVAR'
compute_fitted_values(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_fitted_values.PosteriorBSVAR_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVAR</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorFitted</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorFitted</code> containing <code>S</code> draws from 
the data predictive density.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute draws from in-sample predictive density
fitted         = compute_fitted_values(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_fitted_values() -&gt; fitted

</code></pre>

<hr>
<h2 id='compute_fitted_values.PosteriorBSVARMIX'>Computes posterior draws from data predictive density</h2><span id='topic+compute_fitted_values.PosteriorBSVARMIX'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from 
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the data predictive density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMIX'
compute_fitted_values(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_fitted_values.PosteriorBSVARMIX_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMIX</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorFitted</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorFitted</code> containing <code>S</code> draws from 
the data predictive density.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute draws from in-sample predictive density
csd     = compute_fitted_values(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_fitted_values() -&gt; csd
  
</code></pre>

<hr>
<h2 id='compute_fitted_values.PosteriorBSVARMSH'>Computes posterior draws from data predictive density</h2><span id='topic+compute_fitted_values.PosteriorBSVARMSH'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from 
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the data predictive density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMSH'
compute_fitted_values(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_fitted_values.PosteriorBSVARMSH_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMSH</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorFitted</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorFitted</code> containing <code>S</code> draws from 
the data predictive density.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute draws from in-sample predictive density
csd     = compute_fitted_values(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_fitted_values() -&gt; csd
  
</code></pre>

<hr>
<h2 id='compute_fitted_values.PosteriorBSVARSV'>Computes posterior draws from data predictive density</h2><span id='topic+compute_fitted_values.PosteriorBSVARSV'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from 
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the data predictive density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSV'
compute_fitted_values(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_fitted_values.PosteriorBSVARSV_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSV</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorFitted</code>, that is, an <code>NxTxS</code> 
array with attribute <code>PosteriorFitted</code> containing <code>S</code> draws from 
the data predictive density.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute draws from in-sample predictive density
csd     = compute_fitted_values(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_fitted_values() -&gt; csd
  
</code></pre>

<hr>
<h2 id='compute_historical_decompositions'>Computes posterior draws of historical decompositions</h2><span id='topic+compute_historical_decompositions'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the historical decompositions. 
IMPORTANT! The historical decompositions are interpreted correctly for 
covariance stationary data. Application to unit-root non-stationary data might
result in non-interpretable outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_historical_decompositions(posterior, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_historical_decompositions_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome obtained by running the <code>estimate</code> 
function. The interpretation depends on the normalisation of the shocks
using function <code>normalise_posterior()</code>. Verify if the default settings 
are appropriate.</p>
</td></tr>
<tr><td><code id="compute_historical_decompositions_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorHD</code>, that is, an <code>NxNxTxS</code> array 
with attribute <code>PosteriorHD</code> containing <code>S</code> draws of the historical 
decompositions.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(diff(us_fiscal_lsuw), p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute historical decompositions
hd            = compute_historical_decompositions(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
diff(us_fiscal_lsuw) |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_historical_decompositions() -&gt; hd

</code></pre>

<hr>
<h2 id='compute_historical_decompositions.PosteriorBSVAR'>Computes posterior draws of historical decompositions</h2><span id='topic+compute_historical_decompositions.PosteriorBSVAR'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the historical decompositions. 
IMPORTANT! The historical decompositions are interpreted correctly for 
covariance stationary data. Application to unit-root non-stationary data might
result in non-interpretable outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVAR'
compute_historical_decompositions(posterior, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_historical_decompositions.PosteriorBSVAR_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVAR</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_historical_decompositions.PosteriorBSVAR_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorHD</code>, that is, an <code>NxNxTxS</code> array 
with attribute <code>PosteriorHD</code> containing <code>S</code> draws of the historical 
decompositions.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(diff(us_fiscal_lsuw), p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute historical decompositions
hd            = compute_historical_decompositions(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
diff(us_fiscal_lsuw) |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_historical_decompositions() -&gt; hd
  
</code></pre>

<hr>
<h2 id='compute_historical_decompositions.PosteriorBSVARMIX'>Computes posterior draws of historical decompositions</h2><span id='topic+compute_historical_decompositions.PosteriorBSVARMIX'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the historical decompositions. 
IMPORTANT! The historical decompositions are interpreted correctly for 
covariance stationary data. Application to unit-root non-stationary data might
result in non-interpretable outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMIX'
compute_historical_decompositions(posterior, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_historical_decompositions.PosteriorBSVARMIX_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMIX</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_historical_decompositions.PosteriorBSVARMIX_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorHD</code>, that is, an <code>NxNxTxS</code> array 
with attribute <code>PosteriorHD</code> containing <code>S</code> draws of the historical 
decompositions.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute historical decompositions
hd             = compute_historical_decompositions(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_historical_decompositions() -&gt; hds
  
</code></pre>

<hr>
<h2 id='compute_historical_decompositions.PosteriorBSVARMSH'>Computes posterior draws of historical decompositions</h2><span id='topic+compute_historical_decompositions.PosteriorBSVARMSH'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the historical decompositions. 
IMPORTANT! The historical decompositions are interpreted correctly for 
covariance stationary data. Application to unit-root non-stationary data might
result in non-interpretable outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMSH'
compute_historical_decompositions(posterior, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_historical_decompositions.PosteriorBSVARMSH_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMSH</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_historical_decompositions.PosteriorBSVARMSH_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorHD</code>, that is, an <code>NxNxTxS</code> array 
with attribute <code>PosteriorHD</code> containing <code>S</code> draws of the historical 
decompositions.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute historical decompositions
hd             = compute_historical_decompositions(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_historical_decompositions() -&gt; hds
  
</code></pre>

<hr>
<h2 id='compute_historical_decompositions.PosteriorBSVARSV'>Computes posterior draws of historical decompositions</h2><span id='topic+compute_historical_decompositions.PosteriorBSVARSV'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the historical decompositions. 
IMPORTANT! The historical decompositions are interpreted correctly for 
covariance stationary data. Application to unit-root non-stationary data might
result in non-interpretable outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSV'
compute_historical_decompositions(posterior, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_historical_decompositions.PosteriorBSVARSV_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSV</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_historical_decompositions.PosteriorBSVARSV_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PosteriorHD</code>, that is, an <code>NxNxTxS</code> array 
with attribute <code>PosteriorHD</code> containing <code>S</code> draws of the historical 
decompositions.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 5)

# estimate the model
posterior      = estimate(burn_in, 5)

# compute historical decompositions
hd             = compute_historical_decompositions(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 5) |&gt; 
  estimate(S = 5) |&gt; 
  compute_historical_decompositions() -&gt; hds
  
</code></pre>

<hr>
<h2 id='compute_impulse_responses'>Computes posterior draws of impulse responses</h2><span id='topic+compute_impulse_responses'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from 
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the impulse responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_impulse_responses(posterior, horizon, standardise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_impulse_responses_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome obtained by running the <code>estimate</code> function. 
The interpretation depends on the normalisation of the shocks
using function <code>normalise_posterior()</code>. Verify if the default settings are appropriate.</p>
</td></tr>
<tr><td><code id="compute_impulse_responses_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer number denoting the forecast horizon for the impulse responses computations.</p>
</td></tr>
<tr><td><code id="compute_impulse_responses_+3A_standardise">standardise</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the impulse responses are standardised 
so that the variables' own shocks at horizon 0 are equal to 1. Otherwise, the parameter estimates 
determine this magnitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorIR, that is, an <code>NxNx(horizon+1)xS</code> array with attribute PosteriorIR 
containing <code>S</code> draws of the impulse responses.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute impulse responses 2 years ahead
irf           = compute_impulse_responses(posterior, horizon = 8)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_impulse_responses(horizon = 8) -&gt; ir

</code></pre>

<hr>
<h2 id='compute_impulse_responses.PosteriorBSVAR'>Computes posterior draws of impulse responses</h2><span id='topic+compute_impulse_responses.PosteriorBSVAR'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from 
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the impulse responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVAR'
compute_impulse_responses(posterior, horizon, standardise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_impulse_responses.PosteriorBSVAR_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVAR</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_impulse_responses.PosteriorBSVAR_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer number denoting the forecast horizon for the impulse responses computations.</p>
</td></tr>
<tr><td><code id="compute_impulse_responses.PosteriorBSVAR_+3A_standardise">standardise</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the impulse responses are standardised 
so that the variables' own shocks at horizon 0 are equal to 1. Otherwise, the parameter estimates 
determine this magnitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorIR, that is, an <code>NxNx(horizon+1)xS</code> array with attribute PosteriorIR 
containing <code>S</code> draws of the impulse responses.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute impulse responses 2 years ahead
irf           = compute_impulse_responses(posterior, horizon = 8)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_impulse_responses(horizon = 8) -&gt; ir

</code></pre>

<hr>
<h2 id='compute_impulse_responses.PosteriorBSVARMIX'>Computes posterior draws of impulse responses</h2><span id='topic+compute_impulse_responses.PosteriorBSVARMIX'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from 
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the impulse responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMIX'
compute_impulse_responses(posterior, horizon, standardise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_impulse_responses.PosteriorBSVARMIX_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMIX</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_impulse_responses.PosteriorBSVARMIX_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer number denoting the forecast horizon for the impulse responses computations.</p>
</td></tr>
<tr><td><code id="compute_impulse_responses.PosteriorBSVARMIX_+3A_standardise">standardise</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the impulse responses are standardised 
so that the variables' own shocks at horizon 0 are equal to 1. Otherwise, the parameter estimates 
determine this magnitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorIR, that is, an <code>NxNx(horizon+1)xS</code> array with attribute PosteriorIR 
containing <code>S</code> draws of the impulse responses.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute impulse responses
irfs            = compute_impulse_responses(posterior, 4)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_impulse_responses(horizon = 4) -&gt; irfs
  
</code></pre>

<hr>
<h2 id='compute_impulse_responses.PosteriorBSVARMSH'>Computes posterior draws of impulse responses</h2><span id='topic+compute_impulse_responses.PosteriorBSVARMSH'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from 
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the impulse responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMSH'
compute_impulse_responses(posterior, horizon, standardise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_impulse_responses.PosteriorBSVARMSH_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMSH</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_impulse_responses.PosteriorBSVARMSH_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer number denoting the forecast horizon for the impulse responses computations.</p>
</td></tr>
<tr><td><code id="compute_impulse_responses.PosteriorBSVARMSH_+3A_standardise">standardise</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the impulse responses are standardised 
so that the variables' own shocks at horizon 0 are equal to 1. Otherwise, the parameter estimates 
determine this magnitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorIR, that is, an <code>NxNx(horizon+1)xS</code> array with attribute PosteriorIR 
containing <code>S</code> draws of the impulse responses.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute impulse responses
irfs            = compute_impulse_responses(posterior, 4)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_impulse_responses(horizon = 4) -&gt; irfs
  
</code></pre>

<hr>
<h2 id='compute_impulse_responses.PosteriorBSVARSV'>Computes posterior draws of impulse responses</h2><span id='topic+compute_impulse_responses.PosteriorBSVARSV'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from 
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the impulse responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSV'
compute_impulse_responses(posterior, horizon, standardise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_impulse_responses.PosteriorBSVARSV_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSV</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_impulse_responses.PosteriorBSVARSV_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer number denoting the forecast horizon for the impulse responses computations.</p>
</td></tr>
<tr><td><code id="compute_impulse_responses.PosteriorBSVARSV_+3A_standardise">standardise</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the impulse responses are standardised 
so that the variables' own shocks at horizon 0 are equal to 1. Otherwise, the parameter estimates 
determine this magnitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorIR, that is, an <code>NxNx(horizon+1)xS</code> array with attribute PosteriorIR 
containing <code>S</code> draws of the impulse responses.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute impulse responses
irfs            = compute_impulse_responses(posterior, 4)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_impulse_responses(horizon = 4) -&gt; irfs
  
</code></pre>

<hr>
<h2 id='compute_regime_probabilities'>Computes posterior draws of regime probabilities</h2><span id='topic+compute_regime_probabilities'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of a model is transformed into
a draw from the posterior distribution of the regime probabilities. These represent either
the realisations of the regime indicators, when <code>type = "realized"</code>, filtered probabilities,
when <code>type = "filtered"</code>, forecasted regime probabilities, when <code>type = "forecasted"</code>,
or the smoothed probabilities, when <code>type = "smoothed"</code>, .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_regime_probabilities(
  posterior,
  type = c("realized", "filtered", "forecasted", "smoothed")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_regime_probabilities_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome of regime-dependent heteroskedastic models 
- an object of either of the classes: PosteriorBSVARMSH, or PosteriorBSVARMIX
obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_regime_probabilities_+3A_type">type</code></td>
<td>
<p>one of the values <code>"realized"</code>, <code>"filtered"</code>, <code>"forecasted"</code>, or <code>"smoothed"</code>
denoting the type of probabilities to be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorRegimePr, that is, an <code>MxTxS</code> array with attribute PosteriorRegimePr 
containing <code>S</code> draws of the regime probabilities.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Song, Y., and Woźniak, T., (2021) Markov Switching. <em>Oxford Research Encyclopedia of Economics and Finance</em>, Oxford University Press, <a href="https://doi.org/10.1093/acrefore/9780190625979.013.174">doi:10.1093/acrefore/9780190625979.013.174</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 2, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute the posterior draws of realized regime indicators
regimes        = compute_regime_probabilities(posterior)

# compute the posterior draws of filtered probabilities
filtered       = compute_regime_probabilities(posterior, "filtered")

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) -&gt; posterior
regimes        = compute_regime_probabilities(posterior)
filtered       = compute_regime_probabilities(posterior, "filtered")

</code></pre>

<hr>
<h2 id='compute_regime_probabilities.PosteriorBSVARMIX'>Computes posterior draws of regime probabilities</h2><span id='topic+compute_regime_probabilities.PosteriorBSVARMIX'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of a model is transformed into
a draw from the posterior distribution of the regime probabilities. These represent either
the realisations of the regime indicators, when <code>type = "realized"</code>, filtered probabilities,
when <code>type = "filtered"</code>, forecasted regime probabilities, when <code>type = "forecasted"</code>,
or the smoothed probabilities, when <code>type = "smoothed"</code>, .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMIX'
compute_regime_probabilities(
  posterior,
  type = c("realized", "filtered", "forecasted", "smoothed")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_regime_probabilities.PosteriorBSVARMIX_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMIX</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_regime_probabilities.PosteriorBSVARMIX_+3A_type">type</code></td>
<td>
<p>one of the values <code>"realized"</code>, <code>"filtered"</code>, <code>"forecasted"</code>, or <code>"smoothed"</code>
denoting the type of probabilities to be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorRegimePr, that is, an <code>MxTxS</code> array with attribute PosteriorRegimePr 
containing <code>S</code> draws of the regime probabilities.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Song, Y., and Woźniak, T., (2021) Markov Switching. <em>Oxford Research Encyclopedia of Economics and Finance</em>, Oxford University Press, <a href="https://doi.org/10.1093/acrefore/9780190625979.013.174">doi:10.1093/acrefore/9780190625979.013.174</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 2, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute the posterior draws of realized regime indicators
regimes        = compute_regime_probabilities(posterior)

# compute the posterior draws of filtered probabilities
filtered       = compute_regime_probabilities(posterior, "filtered")

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) -&gt; posterior
regimes        = compute_regime_probabilities(posterior)
filtered       = compute_regime_probabilities(posterior, "filtered")

</code></pre>

<hr>
<h2 id='compute_regime_probabilities.PosteriorBSVARMSH'>Computes posterior draws of regime probabilities</h2><span id='topic+compute_regime_probabilities.PosteriorBSVARMSH'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of a model is transformed into
a draw from the posterior distribution of the regime probabilities. These represent either
the realisations of the regime indicators, when <code>type = "realized"</code>, filtered probabilities,
when <code>type = "filtered"</code>, forecasted regime probabilities, when <code>type = "forecasted"</code>,
or the smoothed probabilities, when <code>type = "smoothed"</code>, .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMSH'
compute_regime_probabilities(
  posterior,
  type = c("realized", "filtered", "forecasted", "smoothed")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_regime_probabilities.PosteriorBSVARMSH_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMSH</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_regime_probabilities.PosteriorBSVARMSH_+3A_type">type</code></td>
<td>
<p>one of the values <code>"realized"</code>, <code>"filtered"</code>, <code>"forecasted"</code>, or <code>"smoothed"</code>
denoting the type of probabilities to be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorRegimePr, that is, an <code>MxTxS</code> array with attribute PosteriorRegimePr 
containing <code>S</code> draws of the regime probabilities.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Song, Y., and Woźniak, T., (2021) Markov Switching. <em>Oxford Research Encyclopedia of Economics and Finance</em>, Oxford University Press, <a href="https://doi.org/10.1093/acrefore/9780190625979.013.174">doi:10.1093/acrefore/9780190625979.013.174</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 2, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute the posterior draws of realized regime indicators
regimes        = compute_regime_probabilities(posterior)

# compute the posterior draws of filtered probabilities
filtered       = compute_regime_probabilities(posterior, "filtered")

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) -&gt; posterior
regimes        = compute_regime_probabilities(posterior)
filtered       = compute_regime_probabilities(posterior, "filtered")

</code></pre>

<hr>
<h2 id='compute_structural_shocks'>Computes posterior draws of structural shocks</h2><span id='topic+compute_structural_shocks'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the structural shocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_structural_shocks(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_structural_shocks_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome obtained by running the <code>estimate</code> function. 
The interpretation depends on the normalisation of the shocks
using function <code>normalise_posterior()</code>. Verify if the default settings are appropriate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorShocks, that is, an <code>NxTxS</code> array with attribute PosteriorShocks 
containing <code>S</code> draws of the structural shocks.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute structural shocks
shocks         = compute_structural_shocks(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_structural_shocks() -&gt; ss

</code></pre>

<hr>
<h2 id='compute_structural_shocks.PosteriorBSVAR'>Computes posterior draws of structural shocks</h2><span id='topic+compute_structural_shocks.PosteriorBSVAR'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the structural shocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVAR'
compute_structural_shocks(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_structural_shocks.PosteriorBSVAR_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVAR</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorShocks, that is, an <code>NxTxS</code> array with attribute PosteriorShocks 
containing <code>S</code> draws of the structural shocks.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute structural shocks
shocks         = compute_structural_shocks(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_structural_shocks() -&gt; ss

</code></pre>

<hr>
<h2 id='compute_structural_shocks.PosteriorBSVARMIX'>Computes posterior draws of structural shocks</h2><span id='topic+compute_structural_shocks.PosteriorBSVARMIX'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the structural shocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMIX'
compute_structural_shocks(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_structural_shocks.PosteriorBSVARMIX_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMIX</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorShocks, that is, an <code>NxTxS</code> array with attribute PosteriorShocks 
containing <code>S</code> draws of the structural shocks.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute structural shocks
shocks         = compute_structural_shocks(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_structural_shocks() -&gt; ss

</code></pre>

<hr>
<h2 id='compute_structural_shocks.PosteriorBSVARMSH'>Computes posterior draws of structural shocks</h2><span id='topic+compute_structural_shocks.PosteriorBSVARMSH'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the structural shocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMSH'
compute_structural_shocks(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_structural_shocks.PosteriorBSVARMSH_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMSH</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorShocks, that is, an <code>NxTxS</code> array with attribute PosteriorShocks 
containing <code>S</code> draws of the structural shocks.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute structural shocks
shocks         = compute_structural_shocks(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_structural_shocks() -&gt; ss
  
</code></pre>

<hr>
<h2 id='compute_structural_shocks.PosteriorBSVARSV'>Computes posterior draws of structural shocks</h2><span id='topic+compute_structural_shocks.PosteriorBSVARSV'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span> is transformed into
a draw from the posterior distribution of the structural shocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSV'
compute_structural_shocks(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_structural_shocks.PosteriorBSVARSV_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSV</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorShocks, that is, an <code>NxTxS</code> array with attribute PosteriorShocks 
containing <code>S</code> draws of the structural shocks.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute structural shocks
shocks         = compute_structural_shocks(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_structural_shocks() -&gt; ss

</code></pre>

<hr>
<h2 id='compute_variance_decompositions'>Computes posterior draws of the forecast error variance decomposition</h2><span id='topic+compute_variance_decompositions'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of models from
packages <span class="pkg">bsvars</span> or <span class="pkg">bsvarSIGNs</span>
is transformed into a draw from the posterior distribution of the forecast error variance decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_variance_decompositions(posterior, horizon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_variance_decompositions_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome obtained by running the <code>estimate</code> function. 
The interpretation depends on the normalisation of the shocks
using function <code>normalise_posterior()</code>. Verify if the default settings are appropriate.</p>
</td></tr>
<tr><td><code id="compute_variance_decompositions_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer number denoting the forecast horizon for the impulse responses computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorFEVD, that is, an <code>NxNx(horizon+1)xS</code> array with attribute PosteriorFEVD 
containing <code>S</code> draws of the forecast error variance decomposition.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_impulse_responses">compute_impulse_responses</a></code>, <code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute forecast error variance decomposition 2 years ahead
fevd           = compute_variance_decompositions(posterior, horizon = 8)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_variance_decompositions(horizon = 8) -&gt; fevd

</code></pre>

<hr>
<h2 id='compute_variance_decompositions.PosteriorBSVAR'>Computes posterior draws of the forecast error variance decomposition</h2><span id='topic+compute_variance_decompositions.PosteriorBSVAR'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of the model
is transformed into a draw from the posterior distribution of the forecast 
error variance decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVAR'
compute_variance_decompositions(posterior, horizon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_variance_decompositions.PosteriorBSVAR_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVAR</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_variance_decompositions.PosteriorBSVAR_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer number denoting the forecast horizon for the impulse responses computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorFEVD, that is, an <code>NxNx(horizon+1)xS</code> array with attribute PosteriorFEVD 
containing <code>S</code> draws of the forecast error variance decomposition.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_impulse_responses">compute_impulse_responses</a></code>, <code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute forecast error variance decomposition 2 years ahead
fevd           = compute_variance_decompositions(posterior, horizon = 8)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_variance_decompositions(horizon = 8) -&gt; fevd

</code></pre>

<hr>
<h2 id='compute_variance_decompositions.PosteriorBSVARMIX'>Computes posterior draws of the forecast error variance decomposition</h2><span id='topic+compute_variance_decompositions.PosteriorBSVARMIX'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of the model
is transformed into a draw from the posterior distribution of the forecast 
error variance decomposition. In this mixture model the forecast error 
variance decompositions are computed for the forecasts with the origin at the
last observation in sample data and using the conditional variance forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMIX'
compute_variance_decompositions(posterior, horizon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_variance_decompositions.PosteriorBSVARMIX_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMIX</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_variance_decompositions.PosteriorBSVARMIX_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer number denoting the forecast horizon for the impulse responses computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorFEVD, that is, an <code>NxNx(horizon+1)xS</code> array with attribute PosteriorFEVD 
containing <code>S</code> draws of the forecast error variance decomposition.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_impulse_responses">compute_impulse_responses</a></code>, <code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute forecast error variance decomposition 2 years ahead
fevd           = compute_variance_decompositions(posterior, horizon = 8)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_variance_decompositions(horizon = 8) -&gt; fevd

</code></pre>

<hr>
<h2 id='compute_variance_decompositions.PosteriorBSVARMSH'>Computes posterior draws of the forecast error variance decomposition</h2><span id='topic+compute_variance_decompositions.PosteriorBSVARMSH'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of the model
is transformed into a draw from the posterior distribution of the forecast 
error variance decomposition. In this heteroskedastic model the forecast error 
variance decompositions are computed for the forecasts with the origin at the
last observation in sample data and using the conditional variance forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMSH'
compute_variance_decompositions(posterior, horizon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_variance_decompositions.PosteriorBSVARMSH_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMSH</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_variance_decompositions.PosteriorBSVARMSH_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer number denoting the forecast horizon for the impulse responses computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorFEVD, that is, an <code>NxNx(horizon+1)xS</code> array with attribute PosteriorFEVD 
containing <code>S</code> draws of the forecast error variance decomposition.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_impulse_responses">compute_impulse_responses</a></code>, <code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute forecast error variance decomposition 2 years ahead
fevd           = compute_variance_decompositions(posterior, horizon = 8)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_variance_decompositions(horizon = 8) -&gt; fevd

</code></pre>

<hr>
<h2 id='compute_variance_decompositions.PosteriorBSVARSV'>Computes posterior draws of the forecast error variance decomposition</h2><span id='topic+compute_variance_decompositions.PosteriorBSVARSV'></span>

<h3>Description</h3>

<p>Each of the draws from the posterior estimation of the model
is transformed into a draw from the posterior distribution of the forecast 
error variance decomposition. In this heteroskedastic model the forecast error 
variance decompositions are computed for the forecasts with the origin at the
last observation in sample data and using the conditional variance forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSV'
compute_variance_decompositions(posterior, horizon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_variance_decompositions.PosteriorBSVARSV_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSV</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="compute_variance_decompositions.PosteriorBSVARSV_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer number denoting the forecast horizon for the impulse responses computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PosteriorFEVD, that is, an <code>NxNx(horizon+1)xS</code> array with attribute PosteriorFEVD 
containing <code>S</code> draws of the forecast error variance decomposition.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Kilian, L., &amp; Lütkepohl, H. (2017). Structural VAR Tools, Chapter 4, In: Structural vector autoregressive analysis. Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_impulse_responses">compute_impulse_responses</a></code>, <code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# compute forecast error variance decomposition 2 years ahead
fevd           = compute_variance_decompositions(posterior, horizon = 8)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  compute_variance_decompositions(horizon = 8) -&gt; fevd

</code></pre>

<hr>
<h2 id='estimate'>Bayesian estimation of Structural Vector Autoregressions via Gibbs sampler</h2><span id='topic+estimate'></span>

<h3>Description</h3>

<p>Estimates homo- or heteroskedastic SVAR models for packages <span class="pkg">bsvars</span>
and <span class="pkg">bsvarSIGNs</span>. The packages apply the Gibbs sampler proposed by Waggoner &amp; Zha (2003)
for the structural matrix <code class="reqn">B</code> and the equation-by-equation sampler by Chan, Koop, &amp; Yu (2024)
for the autoregressive slope parameters <code class="reqn">A</code>. Additionally, the parameter matrices <code class="reqn">A</code> and <code class="reqn">B</code>
follow a Minnesota prior and generalised-normal prior distributions respectively with the matrix-specific
3-level equation-specific local-global hierarchical prior for the shrinkage parameters. A variety of models
for conditional variances are possible including versions of Stochastic Volatility and Markov-switching heteroskedasticity.
Non-normal specifications include finite and sparse normal mixture model for the structural shocks.
The estimation algorithms for particular models are scrutinised in 
Lütkepohl, Shang, Uzeda, &amp; Woźniak (2024) and Woźniak &amp; Droumaguet (2024)
and some other inferential and identification problems are considered in 
Lütkepohl &amp; Woźniak (2020) and Song &amp; Woźniak (2021).
Models from package <span class="pkg">bsvars</span> implement identification via exclusion restrictions, 
heteroskedasticity and non-normality. Models from package <span class="pkg">bsvarSIGNs</span> implement
identification via sign and narrative restrictions.
See section <b>Details</b> and package <span class="pkg">bsvarSIGNs</span> documentation for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(specification, S, thin = 1, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_+3A_specification">specification</code></td>
<td>
<p>an object generated using one of the <code>specify_bsvar*</code> functions
or an object generated using the function <code>estimate</code>.
The latter type of input facilitates the continuation of the MCMC sampling starting from the last draw of the previous run.</p>
</td></tr>
<tr><td><code id="estimate_+3A_s">S</code></td>
<td>
<p>a positive integer, the number of posterior draws to be generated</p>
</td></tr>
<tr><td><code id="estimate_+3A_thin">thin</code></td>
<td>
<p>a positive integer, specifying the frequency of MCMC output thinning</p>
</td></tr>
<tr><td><code id="estimate_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The homoskedastic SVAR model is given by the reduced form equation:
</p>
<p style="text-align: center;"><code class="reqn">Y = AX + E</code>
</p>

<p>where <code class="reqn">Y</code> is an <code>NxT</code> matrix of dependent variables, <code class="reqn">X</code> is a <code>KxT</code> matrix of explanatory variables, 
<code class="reqn">E</code> is an <code>NxT</code> matrix of reduced form error terms, and <code class="reqn">A</code> is an <code>NxK</code> matrix of autoregressive slope coefficients and parameters on deterministic terms in <code class="reqn">X</code>.
</p>
<p>The structural equation is given by
</p>
<p style="text-align: center;"><code class="reqn">BE = U</code>
</p>

<p>where <code class="reqn">U</code> is an <code>NxT</code> matrix of structural form error terms, and
<code class="reqn">B</code> is an <code>NxN</code> matrix of contemporaneous relationships.
</p>
<p>The structural shocks, <code>U</code>, are temporally and contemporaneously independent and jointly normally distributed with zero mean and unit variances.
</p>
<p>The various SVAR models estimated differ by the specification of structural shocks
variances. Their specification depends on the <code>specify_bsvar*</code> function used. The different models include:
</p>

<ul>
<li><p> homoskedastic model with unit variances
</p>
</li>
<li><p> heteroskedastic model with stationary Markov switching in the variances
</p>
</li>
<li><p> heteroskedastic model with Stochastic Volatility process for variances
</p>
</li>
<li><p> non-normal model with a finite mixture of normal components and component-specific variances
</p>
</li>
<li><p> heteroskedastic model with sparse Markov switching in the variances where the number of heteroskedastic components is estimated
</p>
</li>
<li><p> non-normal model with a sparse mixture of normal components and component-specific variances where the number of heteroskedastic components is estimated
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class PosteriorBSVAR* containing the Bayesian estimation output and containing two elements:
</p>
<p><code>posterior</code> a list with a collection of <code>S</code> draws from the posterior distribution generated via Gibbs sampler containing many arrays and vectors whose selection depends on the model specification.
<code>last_draw</code> an object generated by one of the <code>specify_bsvar*</code> functions with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Chan, J.C.C., Koop, G, and Yu, X. (2024) Large Order-Invariant Bayesian VARs with Stochastic Volatility. <em>Journal of Business &amp; Economic Statistics</em>, <b>42</b>, <a href="https://doi.org/10.1080/07350015.2023.2252039">doi:10.1080/07350015.2023.2252039</a>.
</p>
<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>
<p>Lütkepohl, H., and Woźniak, T., (2020) Bayesian Inference for Structural Vector Autoregressions Identified by Markov-Switching Heteroskedasticity. <em>Journal of Economic Dynamics and Control</em> <b>113</b>, 103862, <a href="https://doi.org/10.1016/j.jedc.2020.103862">doi:10.1016/j.jedc.2020.103862</a>.
</p>
<p>Song, Y., and Woźniak, T. (2021) Markov Switching Heteroskedasticity in Time Series Analysis. In: <em>Oxford Research Encyclopedia of Economics and Finance</em>. Oxford University Press, <a href="https://doi.org/10.1093/acrefore/9780190625979.013.174">doi:10.1093/acrefore/9780190625979.013.174</a>.
</p>
<p>Waggoner, D.F., and Zha, T., (2003) A Gibbs sampler for structural vector autoregressions. <em>Journal of Economic Dynamics and Control</em>, <b>28</b>, 349&ndash;366, <a href="https://doi.org/10.1016/S0165-1889%2802%2900168-9">doi:10.1016/S0165-1889(02)00168-9</a>.
</p>
<p>Woźniak, T., and Droumaguet, M., (2024) Bayesian Assessment of Identifying Restrictions for Heteroskedastic Structural VARs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_bsvar">specify_bsvar</a></code>, <code><a href="#topic+specify_bsvar_msh">specify_bsvar_msh</a></code>, <code><a href="#topic+specify_bsvar_mix">specify_bsvar_mix</a></code>, <code><a href="#topic+specify_bsvar_sv">specify_bsvar_sv</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 4)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 5)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 5) |&gt; 
  estimate(S = 10, thin = 2) -&gt; posterior

</code></pre>

<hr>
<h2 id='estimate.BSVAR'>Bayesian estimation of a homoskedastic Structural Vector Autoregression via Gibbs sampler</h2><span id='topic+estimate.BSVAR'></span>

<h3>Description</h3>

<p>Estimates the homoskedastic SVAR using the Gibbs sampler proposed by Waggoner &amp; Zha (2003)
for the structural matrix <code class="reqn">B</code> and the equation-by-equation sampler by Chan, Koop, &amp; Yu (2024)
for the autoregressive slope parameters <code class="reqn">A</code>. Additionally, the parameter matrices <code class="reqn">A</code> and <code class="reqn">B</code>
follow a Minnesota prior and generalised-normal prior distributions respectively with the matrix-specific
overall shrinkage parameters estimated using a hierarchical prior distribution
as in Lütkepohl, Shang, Uzeda, and Woźniak (2024). See section <b>Details</b> for the model equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BSVAR'
estimate(specification, S, thin = 1, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.BSVAR_+3A_specification">specification</code></td>
<td>
<p>an object of class BSVAR generated using the <code>specify_bsvar$new()</code> function.</p>
</td></tr>
<tr><td><code id="estimate.BSVAR_+3A_s">S</code></td>
<td>
<p>a positive integer, the number of posterior draws to be generated</p>
</td></tr>
<tr><td><code id="estimate.BSVAR_+3A_thin">thin</code></td>
<td>
<p>a positive integer, specifying the frequency of MCMC output thinning</p>
</td></tr>
<tr><td><code id="estimate.BSVAR_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The homoskedastic SVAR model is given by the reduced form equation:
</p>
<p style="text-align: center;"><code class="reqn">Y = AX + E</code>
</p>

<p>where <code class="reqn">Y</code> is an <code>NxT</code> matrix of dependent variables, <code class="reqn">X</code> is a <code>KxT</code> matrix of explanatory variables, 
<code class="reqn">E</code> is an <code>NxT</code> matrix of reduced form error terms, and <code class="reqn">A</code> is an <code>NxK</code> matrix of autoregressive slope coefficients and parameters on deterministic terms in <code class="reqn">X</code>.
</p>
<p>The structural equation is given by
</p>
<p style="text-align: center;"><code class="reqn">BE = U</code>
</p>

<p>where <code class="reqn">U</code> is an <code>NxT</code> matrix of structural form error terms, and
<code class="reqn">B</code> is an <code>NxN</code> matrix of contemporaneous relationships.
</p>
<p>Finally, the structural shocks, <code>U</code>, are temporally and contemporaneously independent and jointly normally distributed with zero mean and unit variances.
</p>


<h3>Value</h3>

<p>An object of class PosteriorBSVAR containing the Bayesian estimation output and containing two elements:
</p>
<p><code>posterior</code> a list with a collection of <code>S</code> draws from the posterior distribution generated via Gibbs sampler containing:
</p>

<dl>
<dt>A</dt><dd><p>an <code>NxKxS</code> array with the posterior draws for matrix <code class="reqn">A</code></p>
</dd>
<dt>B</dt><dd><p>an <code>NxNxS</code> array with the posterior draws for matrix <code class="reqn">B</code></p>
</dd>
<dt>hyper</dt><dd><p>a <code>5xS</code> matrix with the posterior draws for the hyper-parameters of the hierarchical prior distribution</p>
</dd>
</dl>

<p><code>last_draw</code> an object of class BSVAR with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Chan, J.C.C., Koop, G, and Yu, X. (2024) Large Order-Invariant Bayesian VARs with Stochastic Volatility. <em>Journal of Business &amp; Economic Statistics</em>, <b>42</b>, <a href="https://doi.org/10.1080/07350015.2023.2252039">doi:10.1080/07350015.2023.2252039</a>.
</p>
<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>
<p>Waggoner, D.F., and Zha, T., (2003) A Gibbs sampler for structural vector autoregressions. <em>Journal of Economic Dynamics and Control</em>, <b>28</b>, 349&ndash;366, <a href="https://doi.org/10.1016/S0165-1889%2802%2900168-9">doi:10.1016/S0165-1889(02)00168-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_bsvar">specify_bsvar</a></code>, <code><a href="#topic+specify_posterior_bsvar">specify_posterior_bsvar</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 4)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 5)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 5) |&gt; 
  estimate(S = 10, thin = 2) |&gt; 
  compute_impulse_responses(horizon = 4) -&gt; irf

</code></pre>

<hr>
<h2 id='estimate.BSVARMIX'>Bayesian estimation of a Structural Vector Autoregression with shocks following 
a finite mixture of normal components via Gibbs sampler</h2><span id='topic+estimate.BSVARMIX'></span>

<h3>Description</h3>

<p>Estimates the SVAR with non-normal residuals following a finite <code>M</code> mixture of normal distributions proposed by Woźniak &amp; Droumaguet (2022).
Implements the Gibbs sampler proposed by Waggoner &amp; Zha (2003)
for the structural matrix <code class="reqn">B</code> and the equation-by-equation sampler by Chan, Koop, &amp; Yu (2024)
for the autoregressive slope parameters <code class="reqn">A</code>. Additionally, the parameter matrices <code class="reqn">A</code> and <code class="reqn">B</code>
follow a Minnesota prior and generalised-normal prior distributions respectively with the matrix-specific
overall shrinkage parameters estimated thanks to a hierarchical prior distribution. The finite mixture of normals
model is estimated using the prior distributions and algorithms proposed by Woźniak &amp; Droumaguet (2024),
Lütkepohl &amp; Woźniak (2020), and Song &amp; Woźniak (2021). See section <b>Details</b> for the model equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BSVARMIX'
estimate(specification, S, thin = 1, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.BSVARMIX_+3A_specification">specification</code></td>
<td>
<p>an object of class BSVARMIX generated using the <code>specify_bsvar_mix$new()</code> function.</p>
</td></tr>
<tr><td><code id="estimate.BSVARMIX_+3A_s">S</code></td>
<td>
<p>a positive integer, the number of posterior draws to be generated</p>
</td></tr>
<tr><td><code id="estimate.BSVARMIX_+3A_thin">thin</code></td>
<td>
<p>a positive integer, specifying the frequency of MCMC output thinning</p>
</td></tr>
<tr><td><code id="estimate.BSVARMIX_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The heteroskedastic SVAR model is given by the reduced form equation:
</p>
<p style="text-align: center;"><code class="reqn">Y = AX + E</code>
</p>

<p>where <code class="reqn">Y</code> is an <code>NxT</code> matrix of dependent variables, <code class="reqn">X</code> is a <code>KxT</code> matrix of explanatory variables, 
<code class="reqn">E</code> is an <code>NxT</code> matrix of reduced form error terms, and <code class="reqn">A</code> is an <code>NxK</code> matrix of autoregressive slope coefficients and parameters on deterministic terms in <code class="reqn">X</code>.
</p>
<p>The structural equation is given by
</p>
<p style="text-align: center;"><code class="reqn">BE = U</code>
</p>

<p>where <code class="reqn">U</code> is an <code>NxT</code> matrix of structural form error terms, and
<code class="reqn">B</code> is an <code>NxN</code> matrix of contemporaneous relationships.
</p>
<p>Finally, the structural shocks, <code class="reqn">U</code>, are temporally and contemporaneously independent and finite-mixture of normals distributed with zero mean.
The conditional variance of the <code>n</code>th shock at time <code>t</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">Var_{t-1}[u_{n.t}] = s^2_{n.s_t}</code>
</p>

<p>where <code class="reqn">s_t</code> is a the regime indicator of 
the regime-specific conditional variances of structural shocks <code class="reqn">s^2_{n.s_t}</code>. 
In this model, the variances of each of the structural shocks sum to <code>M</code>.
</p>
<p>The regime indicator <code class="reqn">s_t</code> is either such that:
</p>

<ul>
<li><p> the regime probabilities are non-zero which requires all regimes to have 
a positive number occurrences over the sample period, or
</p>
</li>
<li><p> sparse with potentially many regimes with zero occurrences over the sample period
and in which the number of regimes is estimated.
</p>
</li></ul>

<p>These model selection also with this respect is made using function <code><a href="#topic+specify_bsvar_mix">specify_bsvar_mix</a></code>.
</p>


<h3>Value</h3>

<p>An object of class PosteriorBSVARMIX containing the Bayesian estimation output and containing two elements:
</p>
<p><code>posterior</code> a list with a collection of <code>S</code> draws from the posterior distribution generated via Gibbs sampler containing:
</p>

<dl>
<dt>A</dt><dd><p>an <code>NxKxS</code> array with the posterior draws for matrix <code class="reqn">A</code></p>
</dd>
<dt>B</dt><dd><p>an <code>NxNxS</code> array with the posterior draws for matrix <code class="reqn">B</code></p>
</dd>
<dt>hyper</dt><dd><p>a <code>5xS</code> matrix with the posterior draws for the hyper-parameters of the hierarchical prior distribution</p>
</dd>
<dt>sigma2</dt><dd><p>an <code>NxMxS</code> array with the posterior draws for the structural shocks conditional variances</p>
</dd>
<dt>PR_TR</dt><dd><p>an <code>MxMxS</code> array with the posterior draws for the transition matrix.</p>
</dd>
<dt>xi</dt><dd><p>an <code>MxTxS</code> array with the posterior draws for the regime allocation matrix.</p>
</dd>
<dt>pi_0</dt><dd><p>an <code>MxS</code> matrix with the posterior draws for the ergodic probabilities</p>
</dd>
<dt>sigma</dt><dd><p>an <code>NxTxS</code> array with the posterior draws for the structural shocks conditional standard deviations' series over the sample period</p>
</dd>
</dl>

<p><code>last_draw</code> an object of class BSVARMIX with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Chan, J.C.C., Koop, G, and Yu, X. (2024) Large Order-Invariant Bayesian VARs with Stochastic Volatility. <em>Journal of Business &amp; Economic Statistics</em>, <b>42</b>, <a href="https://doi.org/10.1080/07350015.2023.2252039">doi:10.1080/07350015.2023.2252039</a>.
</p>
<p>Lütkepohl, H., and Woźniak, T., (2020) Bayesian Inference for Structural Vector Autoregressions Identified by Markov-Switching Heteroskedasticity. <em>Journal of Economic Dynamics and Control</em> <b>113</b>, 103862, <a href="https://doi.org/10.1016/j.jedc.2020.103862">doi:10.1016/j.jedc.2020.103862</a>.
</p>
<p>Song, Y., and Woźniak, T., (2021) Markov Switching. <em>Oxford Research Encyclopedia of Economics and Finance</em>, Oxford University Press, <a href="https://doi.org/10.1093/acrefore/9780190625979.013.174">doi:10.1093/acrefore/9780190625979.013.174</a>.
</p>
<p>Waggoner, D.F., and Zha, T., (2003) A Gibbs sampler for structural vector autoregressions. <em>Journal of Economic Dynamics and Control</em>, <b>28</b>, 349&ndash;366, <a href="https://doi.org/10.1016/S0165-1889%2802%2900168-9">doi:10.1016/S0165-1889(02)00168-9</a>.
</p>
<p>Woźniak, T., and Droumaguet, M., (2024) Bayesian Assessment of Identifying Restrictions for Heteroskedastic Structural VARs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_bsvar_mix">specify_bsvar_mix</a></code>, <code><a href="#topic+specify_posterior_bsvar_mix">specify_posterior_bsvar_mix</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 1, M = 2)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 5)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 5) |&gt; 
  estimate(S = 10, thin = 2) |&gt; 
  compute_impulse_responses(horizon = 4) -&gt; irf
  
</code></pre>

<hr>
<h2 id='estimate.BSVARMSH'>Bayesian estimation of a Structural Vector Autoregression with 
Markov-switching heteroskedasticity via Gibbs sampler</h2><span id='topic+estimate.BSVARMSH'></span>

<h3>Description</h3>

<p>Estimates the SVAR with Markov-switching heteroskedasticity with <code>M</code> regimes (MS(M)) proposed by Woźniak &amp; Droumaguet (2022).
Implements the Gibbs sampler proposed by Waggoner &amp; Zha (2003)
for the structural matrix <code class="reqn">B</code> and the equation-by-equation sampler by Chan, Koop, &amp; Yu (2024)
for the autoregressive slope parameters <code class="reqn">A</code>. Additionally, the parameter matrices <code class="reqn">A</code> and <code class="reqn">B</code>
follow a Minnesota prior and generalised-normal prior distributions respectively with the matrix-specific
overall shrinkage parameters estimated thanks to a hierarchical prior distribution. The MS
model is estimated using the prior distributions and algorithms proposed by Woźniak &amp; Droumaguet (2024),
Lütkepohl &amp; Woźniak (2020), and Song &amp; Woźniak (2021). See section <b>Details</b> for the model equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BSVARMSH'
estimate(specification, S, thin = 1, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.BSVARMSH_+3A_specification">specification</code></td>
<td>
<p>an object of class BSVARMSH generated using the <code>specify_bsvar_msh$new()</code> function.</p>
</td></tr>
<tr><td><code id="estimate.BSVARMSH_+3A_s">S</code></td>
<td>
<p>a positive integer, the number of posterior draws to be generated</p>
</td></tr>
<tr><td><code id="estimate.BSVARMSH_+3A_thin">thin</code></td>
<td>
<p>a positive integer, specifying the frequency of MCMC output thinning</p>
</td></tr>
<tr><td><code id="estimate.BSVARMSH_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The heteroskedastic SVAR model is given by the reduced form equation:
</p>
<p style="text-align: center;"><code class="reqn">Y = AX + E</code>
</p>

<p>where <code class="reqn">Y</code> is an <code>NxT</code> matrix of dependent variables, <code class="reqn">X</code> is a <code>KxT</code> matrix of explanatory variables, 
<code class="reqn">E</code> is an <code>NxT</code> matrix of reduced form error terms, and <code class="reqn">A</code> is an <code>NxK</code> matrix of autoregressive slope coefficients and parameters on deterministic terms in <code>X</code>.
</p>
<p>The structural equation is given by
</p>
<p style="text-align: center;"><code class="reqn">BE = U</code>
</p>

<p>where <code class="reqn">U</code> is an <code>NxT</code> matrix of structural form error terms, and
<code class="reqn">B</code> is an <code>NxN</code> matrix of contemporaneous relationships.
</p>
<p>Finally, the structural shocks, <code class="reqn">U</code>, are temporally and contemporaneously independent and jointly normally distributed with zero mean.
The conditional variance of the <code>n</code>th shock at time <code>t</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">Var_{t-1}[u_{n.t}] = s^2_{n.s_t}</code>
</p>

<p>where <code class="reqn">s_t</code> is a Markov process driving the time-variability of 
the regime-specific conditional variances of structural shocks <code class="reqn">s^2_{n.s_t}</code>. 
In this model, the variances of each of the structural shocks sum to <code>M</code>.
</p>
<p>The Markov process <code class="reqn">s_t</code> is either:
</p>

<ul>
<li><p> stationary, irreducible, and aperiodic which requires all regimes to have 
a positive number occurrences over the sample period, or
</p>
</li>
<li><p> sparse with potentially many regimes with zero occurrences over the sample period
and in which the number of regimes is estimated.
</p>
</li></ul>

<p>These model selection also with this respect is made using function <code><a href="#topic+specify_bsvar_msh">specify_bsvar_msh</a></code>.
</p>


<h3>Value</h3>

<p>An object of class PosteriorBSVARMSH containing the Bayesian estimation output and containing two elements:
</p>
<p><code>posterior</code> a list with a collection of <code>S</code> draws from the posterior distribution generated via Gibbs sampler containing:
</p>

<dl>
<dt>A</dt><dd><p>an <code>NxKxS</code> array with the posterior draws for matrix <code class="reqn">A</code></p>
</dd>
<dt>B</dt><dd><p>an <code>NxNxS</code> array with the posterior draws for matrix <code class="reqn">B</code></p>
</dd>
<dt>hyper</dt><dd><p>a <code>5xS</code> matrix with the posterior draws for the hyper-parameters of the hierarchical prior distribution</p>
</dd>
<dt>sigma2</dt><dd><p>an <code>NxMxS</code> array with the posterior draws for the structural shocks conditional variances</p>
</dd>
<dt>PR_TR</dt><dd><p>an <code>MxMxS</code> array with the posterior draws for the transition matrix.</p>
</dd>
<dt>xi</dt><dd><p>an <code>MxTxS</code> array with the posterior draws for the regime allocation matrix.</p>
</dd>
<dt>pi_0</dt><dd><p>an <code>MxS</code> matrix with the posterior draws for the initial state probabilities</p>
</dd>
<dt>sigma</dt><dd><p>an <code>NxTxS</code> array with the posterior draws for the structural shocks conditional standard deviations' series over the sample period</p>
</dd>
</dl>

<p><code>last_draw</code> an object of class BSVARMSH with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Chan, J.C.C., Koop, G, and Yu, X. (2024) Large Order-Invariant Bayesian VARs with Stochastic Volatility. <em>Journal of Business &amp; Economic Statistics</em>, <b>42</b>, <a href="https://doi.org/10.1080/07350015.2023.2252039">doi:10.1080/07350015.2023.2252039</a>.
</p>
<p>Lütkepohl, H., and Woźniak, T., (2020) Bayesian Inference for Structural Vector Autoregressions Identified by Markov-Switching Heteroskedasticity. <em>Journal of Economic Dynamics and Control</em> <b>113</b>, 103862, <a href="https://doi.org/10.1016/j.jedc.2020.103862">doi:10.1016/j.jedc.2020.103862</a>.
</p>
<p>Song, Y., and Woźniak, T., (2021) Markov Switching. <em>Oxford Research Encyclopedia of Economics and Finance</em>, Oxford University Press, <a href="https://doi.org/10.1093/acrefore/9780190625979.013.174">doi:10.1093/acrefore/9780190625979.013.174</a>.
</p>
<p>Waggoner, D.F., and Zha, T., (2003) A Gibbs sampler for structural vector autoregressions. <em>Journal of Economic Dynamics and Control</em>, <b>28</b>, 349&ndash;366, <a href="https://doi.org/10.1016/S0165-1889%2802%2900168-9">doi:10.1016/S0165-1889(02)00168-9</a>.
</p>
<p>Woźniak, T., and Droumaguet, M., (2024) Bayesian Assessment of Identifying Restrictions for Heteroskedastic Structural VARs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_bsvar_msh">specify_bsvar_msh</a></code>, <code><a href="#topic+specify_posterior_bsvar_msh">specify_posterior_bsvar_msh</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 1, M = 2)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 5)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 5) |&gt; 
  estimate(S = 10, thin = 2) |&gt; 
  compute_impulse_responses(horizon = 4) -&gt; irf

</code></pre>

<hr>
<h2 id='estimate.BSVARSV'>Bayesian estimation of a Structural Vector Autoregression with 
Stochastic Volatility heteroskedasticity via Gibbs sampler</h2><span id='topic+estimate.BSVARSV'></span>

<h3>Description</h3>

<p>Estimates the SVAR with Stochastic Volatility (SV) heteroskedasticity 
proposed by Lütkepohl, Shang, Uzeda, and Woźniak (2024).
Implements the Gibbs sampler proposed by Waggoner &amp; Zha (2003)
for the structural matrix <code class="reqn">B</code> and the equation-by-equation sampler 
by Chan, Koop, &amp; Yu (2024)
for the autoregressive slope parameters <code class="reqn">A</code>. Additionally, 
the parameter matrices <code class="reqn">A</code> and <code class="reqn">B</code>
follow a Minnesota prior and generalised-normal prior distributions 
respectively with the matrix-specific
overall shrinkage parameters estimated thanks to a hierarchical prior distribution. 
The SV model is estimated using a range of techniques including: 
simulation smoother, auxiliary mixture, ancillarity-sufficiency interweaving strategy, 
and generalised inverse Gaussian distribution summarised by Kastner &amp; Frühwirth-Schnatter (2014). 
See section <b>Details</b> for the model equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BSVARSV'
estimate(specification, S, thin = 1, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.BSVARSV_+3A_specification">specification</code></td>
<td>
<p>an object of class BSVARSV generated using the <code>specify_bsvar_sv$new()</code> function.</p>
</td></tr>
<tr><td><code id="estimate.BSVARSV_+3A_s">S</code></td>
<td>
<p>a positive integer, the number of posterior draws to be generated</p>
</td></tr>
<tr><td><code id="estimate.BSVARSV_+3A_thin">thin</code></td>
<td>
<p>a positive integer, specifying the frequency of MCMC output thinning</p>
</td></tr>
<tr><td><code id="estimate.BSVARSV_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The heteroskedastic SVAR model is given by the reduced form equation:
</p>
<p style="text-align: center;"><code class="reqn">Y = AX + E</code>
</p>

<p>where <code class="reqn">Y</code> is an <code>NxT</code> matrix of dependent variables, <code class="reqn">X</code> is a <code>KxT</code> matrix of explanatory variables, 
<code class="reqn">E</code> is an <code>NxT</code> matrix of reduced form error terms, and <code class="reqn">A</code> is an <code>NxK</code> matrix of autoregressive slope coefficients and parameters on deterministic terms in <code class="reqn">X</code>.
</p>
<p>The structural equation is given by
</p>
<p style="text-align: center;"><code class="reqn">BE = U</code>
</p>

<p>where <code class="reqn">U</code> is an <code>NxT</code> matrix of structural form error terms, and
<code class="reqn">B</code> is an <code>NxN</code> matrix of contemporaneous relationships.
Finally, the structural shocks, <code class="reqn">U</code>, are temporally and contemporaneously independent and jointly normally distributed with zero mean.
</p>
<p>Two alternative specifications of the conditional variance of the <code>n</code>th shock at time <code>t</code> 
can be estimated: non-centred Stochastic Volatility by Lütkepohl, Shang, Uzeda, and Woźniak (2022) 
or centred Stochastic Volatility by Chan, Koop, &amp; Yu (2021).
</p>
<p>The non-centred Stochastic Volatility by Lütkepohl, Shang, Uzeda, and Woźniak (2022) 
is selected by setting argument <code>centred_sv</code> of function <code>specify_bsvar_sv$new()</code> to value <code>FALSE</code>.
It has the conditional variances given by:
</p>
<p style="text-align: center;"><code class="reqn">Var_{t-1}[u_{n.t}] = exp(w_n h_{n.t})</code>
</p>

<p>where <code class="reqn">w_n</code> is the estimated conditional standard deviation of the log-conditional variance
and the log-volatility process <code class="reqn">h_{n.t}</code> follows an autoregressive process:
</p>
<p style="text-align: center;"><code class="reqn">h_{n.t} = g_n h_{n.t-1} + v_{n.t}</code>
</p>

<p>where <code class="reqn">h_{n.0}=0</code>, <code class="reqn">g_n</code> is an autoregressive parameter and <code class="reqn">v_{n.t}</code> is a standard normal error term.
</p>
<p>The centred Stochastic Volatility by Chan, Koop, &amp; Yu (2021)
is selected by setting argument <code>centred_sv</code> of function <code>specify_bsvar_sv$new()</code> to value <code>TRUE</code>.
Its conditional variances are given by:
</p>
<p style="text-align: center;"><code class="reqn">Var_{t-1}[u_{n.t}] = exp(h_{n.t})</code>
</p>

<p>where the log-conditional variances <code class="reqn">h_{n.t}</code> follow an autoregressive process:
</p>
<p style="text-align: center;"><code class="reqn">h_{n.t} = g_n h_{n.t-1} + v_{n.t}</code>
</p>

<p>where <code class="reqn">h_{n.0}=0</code>, <code class="reqn">g_n</code> is an autoregressive parameter and <code class="reqn">v_{n.t}</code> is a zero-mean normal error term
with variance <code class="reqn">s_{v.n}^2</code>.
</p>


<h3>Value</h3>

<p>An object of class PosteriorBSVARSV containing the Bayesian estimation output and containing two elements:
</p>
<p><code>posterior</code> a list with a collection of <code>S</code> draws from the posterior distribution generated via Gibbs sampler containing:
</p>

<dl>
<dt>A</dt><dd><p>an <code>NxKxS</code> array with the posterior draws for matrix <code class="reqn">A</code></p>
</dd>
<dt>B</dt><dd><p>an <code>NxNxS</code> array with the posterior draws for matrix <code class="reqn">B</code></p>
</dd>
<dt>hyper</dt><dd><p>a <code>5xS</code> matrix with the posterior draws for the hyper-parameters of the hierarchical prior distribution</p>
</dd>
<dt>h</dt><dd><p>an <code>NxTxS</code> array with the posterior draws of the log-volatility processes</p>
</dd>
<dt>rho</dt><dd><p>an <code>NxS</code> matrix with the posterior draws of SV autoregressive parameters</p>
</dd>
<dt>omega</dt><dd><p>an <code>NxS</code> matrix with the posterior draws of SV process conditional standard deviations</p>
</dd>
<dt>S</dt><dd><p>an <code>NxTxS</code> array with the posterior draws of the auxiliary mixture component indicators</p>
</dd>
<dt>sigma2_omega</dt><dd><p>an <code>NxS</code> matrix with the posterior draws of the variances of the zero-mean normal prior for <code>omega</code></p>
</dd>
<dt>s_</dt><dd><p>an <code>S</code>-vector with the posterior draws of the scale of the gamma prior of the hierarchical prior for <code>sigma2_omega</code></p>
</dd>
</dl>

<p><code>last_draw</code> an object of class BSVARSV with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Chan, J.C.C., Koop, G, and Yu, X. (2024) Large Order-Invariant Bayesian VARs with Stochastic Volatility. <em>Journal of Business &amp; Economic Statistics</em>, <b>42</b>, <a href="https://doi.org/10.1080/07350015.2023.2252039">doi:10.1080/07350015.2023.2252039</a>.
</p>
<p>Kastner, G. and Frühwirth-Schnatter, S. (2014) Ancillarity-Sufficiency Interweaving Strategy (ASIS) for Boosting MCMC 
Estimation of Stochastic Volatility Models. <em>Computational Statistics &amp; Data Analysis</em>, <b>76</b>, 408&ndash;423, 
<a href="https://doi.org/10.1016/j.csda.2013.01.002">doi:10.1016/j.csda.2013.01.002</a>.
</p>
<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>
<p>Waggoner, D.F., and Zha, T., (2003) A Gibbs sampler for structural vector autoregressions. <em>Journal of Economic Dynamics and Control</em>, <b>28</b>, 349&ndash;366, <a href="https://doi.org/10.1016/S0165-1889%2802%2900168-9">doi:10.1016/S0165-1889(02)00168-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_bsvar_sv">specify_bsvar_sv</a></code>, <code><a href="#topic+specify_posterior_bsvar_sv">specify_posterior_bsvar_sv</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, 2)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 2) |&gt; 
  compute_impulse_responses(horizon = 4) -&gt; irf

</code></pre>

<hr>
<h2 id='estimate.PosteriorBSVAR'>Bayesian estimation of a homoskedastic Structural Vector Autoregression via Gibbs sampler</h2><span id='topic+estimate.PosteriorBSVAR'></span>

<h3>Description</h3>

<p>Estimates the homoskedastic SVAR using the Gibbs sampler proposed by Waggoner &amp; Zha (2003)
for the structural matrix <code class="reqn">B</code> and the equation-by-equation sampler by Chan, Koop, &amp; Yu (2024)
for the autoregressive slope parameters <code class="reqn">A</code>. Additionally, the parameter matrices <code class="reqn">A</code> and <code class="reqn">B</code>
follow a Minnesota prior and generalised-normal prior distributions respectively with the matrix-specific
overall shrinkage parameters estimated using a hierarchical prior distribution
as in Lütkepohl, Shang, Uzeda, and Woźniak (2024). See section <b>Details</b> for the model equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVAR'
estimate(specification, S, thin = 1, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.PosteriorBSVAR_+3A_specification">specification</code></td>
<td>
<p>an object of class PosteriorBSVAR generated using the <code>estimate.BSVAR()</code> function.
This setup facilitates the continuation of the MCMC sampling starting from the last draw of the previous run.</p>
</td></tr>
<tr><td><code id="estimate.PosteriorBSVAR_+3A_s">S</code></td>
<td>
<p>a positive integer, the number of posterior draws to be generated</p>
</td></tr>
<tr><td><code id="estimate.PosteriorBSVAR_+3A_thin">thin</code></td>
<td>
<p>a positive integer, specifying the frequency of MCMC output thinning</p>
</td></tr>
<tr><td><code id="estimate.PosteriorBSVAR_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The homoskedastic SVAR model is given by the reduced form equation:
</p>
<p style="text-align: center;"><code class="reqn">Y = AX + E</code>
</p>

<p>where <code class="reqn">Y</code> is an <code>NxT</code> matrix of dependent variables, <code class="reqn">X</code> is a <code>KxT</code> matrix of explanatory variables, 
<code class="reqn">E</code> is an <code>NxT</code> matrix of reduced form error terms, and <code class="reqn">A</code> is an <code>NxK</code> matrix of autoregressive slope coefficients and parameters on deterministic terms in <code class="reqn">X</code>.
</p>
<p>The structural equation is given by
</p>
<p style="text-align: center;"><code class="reqn">BE = U</code>
</p>

<p>where <code class="reqn">U</code> is an <code>NxT</code> matrix of structural form error terms, and
<code class="reqn">B</code> is an <code>NxN</code> matrix of contemporaneous relationships.
</p>
<p>Finally, the structural shocks, <code>U</code>, are temporally and contemporaneously independent and jointly normally distributed with zero mean and unit variances.
</p>


<h3>Value</h3>

<p>An object of class PosteriorBSVAR containing the Bayesian estimation output and containing two elements:
</p>
<p><code>posterior</code> a list with a collection of <code>S</code> draws from the posterior distribution generated via Gibbs sampler containing:
</p>

<dl>
<dt>A</dt><dd><p>an <code>NxKxS</code> array with the posterior draws for matrix <code class="reqn">A</code></p>
</dd>
<dt>B</dt><dd><p>an <code>NxNxS</code> array with the posterior draws for matrix <code class="reqn">B</code></p>
</dd>
<dt>hyper</dt><dd><p>a <code>5xS</code> matrix with the posterior draws for the hyper-parameters of the hierarchical prior distribution</p>
</dd>
</dl>

<p><code>last_draw</code> an object of class BSVAR with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Chan, J.C.C., Koop, G, and Yu, X. (2024) Large Order-Invariant Bayesian VARs with Stochastic Volatility. <em>Journal of Business &amp; Economic Statistics</em>, <b>42</b>, <a href="https://doi.org/10.1080/07350015.2023.2252039">doi:10.1080/07350015.2023.2252039</a>.
</p>
<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>
<p>Waggoner, D.F., and Zha, T., (2003) A Gibbs sampler for structural vector autoregressions. <em>Journal of Economic Dynamics and Control</em>, <b>28</b>, 349&ndash;366, <a href="https://doi.org/10.1016/S0165-1889%2802%2900168-9">doi:10.1016/S0165-1889(02)00168-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_bsvar">specify_bsvar</a></code>, <code><a href="#topic+specify_posterior_bsvar">specify_posterior_bsvar</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 5)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 5) |&gt; 
  estimate(S = 10, thin = 2) |&gt; 
  compute_impulse_responses(horizon = 4) -&gt; irf

</code></pre>

<hr>
<h2 id='estimate.PosteriorBSVARMIX'>Bayesian estimation of a Structural Vector Autoregression with shocks following 
a finite mixture of normal components via Gibbs sampler</h2><span id='topic+estimate.PosteriorBSVARMIX'></span>

<h3>Description</h3>

<p>Estimates the SVAR with non-normal residuals following a finite <code>M</code> mixture of normal distributions proposed by Woźniak &amp; Droumaguet (2022).
Implements the Gibbs sampler proposed by Waggoner &amp; Zha (2003)
for the structural matrix <code class="reqn">B</code> and the equation-by-equation sampler by Chan, Koop, &amp; Yu (2024)
for the autoregressive slope parameters <code class="reqn">A</code>. Additionally, the parameter matrices <code class="reqn">A</code> and <code class="reqn">B</code>
follow a Minnesota prior and generalised-normal prior distributions respectively with the matrix-specific
overall shrinkage parameters estimated thanks to a hierarchical prior distribution. The finite mixture of normals
model is estimated using the prior distributions and algorithms proposed by Woźniak &amp; Droumaguet (2024),
Lütkepohl &amp; Woźniak (2020), and Song &amp; Woźniak (2021). See section <b>Details</b> for the model equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMIX'
estimate(specification, S, thin = 1, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.PosteriorBSVARMIX_+3A_specification">specification</code></td>
<td>
<p>an object of class PosteriorBSVARMIX generated using the <code>estimate.BSVAR()</code> function.
This setup facilitates the continuation of the MCMC sampling starting from the last draw of the previous run.</p>
</td></tr>
<tr><td><code id="estimate.PosteriorBSVARMIX_+3A_s">S</code></td>
<td>
<p>a positive integer, the number of posterior draws to be generated</p>
</td></tr>
<tr><td><code id="estimate.PosteriorBSVARMIX_+3A_thin">thin</code></td>
<td>
<p>a positive integer, specifying the frequency of MCMC output thinning</p>
</td></tr>
<tr><td><code id="estimate.PosteriorBSVARMIX_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The heteroskedastic SVAR model is given by the reduced form equation:
</p>
<p style="text-align: center;"><code class="reqn">Y = AX + E</code>
</p>

<p>where <code class="reqn">Y</code> is an <code>NxT</code> matrix of dependent variables, <code class="reqn">X</code> is a <code>KxT</code> matrix of explanatory variables, 
<code class="reqn">E</code> is an <code>NxT</code> matrix of reduced form error terms, and <code class="reqn">A</code> is an <code>NxK</code> matrix of autoregressive slope coefficients and parameters on deterministic terms in <code class="reqn">X</code>.
</p>
<p>The structural equation is given by
</p>
<p style="text-align: center;"><code class="reqn">BE = U</code>
</p>

<p>where <code class="reqn">U</code> is an <code>NxT</code> matrix of structural form error terms, and
<code class="reqn">B</code> is an <code>NxN</code> matrix of contemporaneous relationships.
</p>
<p>Finally, the structural shocks, <code class="reqn">U</code>, are temporally and contemporaneously independent and finite-mixture of normals distributed with zero mean.
The conditional variance of the <code>n</code>th shock at time <code>t</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">Var_{t-1}[u_{n.t}] = s^2_{n.s_t}</code>
</p>

<p>where <code class="reqn">s_t</code> is a the regime indicator of 
the regime-specific conditional variances of structural shocks <code class="reqn">s^2_{n.s_t}</code>. 
In this model, the variances of each of the structural shocks sum to <code>M</code>.
</p>
<p>The regime indicator <code class="reqn">s_t</code> is either such that:
</p>

<ul>
<li><p> the regime probabilities are non-zero which requires all regimes to have 
a positive number occurrences over the sample period, or
</p>
</li>
<li><p> sparse with potentially many regimes with zero occurrences over the sample period
and in which the number of regimes is estimated.
</p>
</li></ul>

<p>These model selection also with this respect is made using function <code><a href="#topic+specify_bsvar_mix">specify_bsvar_mix</a></code>.
</p>


<h3>Value</h3>

<p>An object of class PosteriorBSVARMIX containing the Bayesian estimation output and containing two elements:
</p>
<p><code>posterior</code> a list with a collection of <code>S</code> draws from the posterior distribution generated via Gibbs sampler containing:
</p>

<dl>
<dt>A</dt><dd><p>an <code>NxKxS</code> array with the posterior draws for matrix <code class="reqn">A</code></p>
</dd>
<dt>B</dt><dd><p>an <code>NxNxS</code> array with the posterior draws for matrix <code class="reqn">B</code></p>
</dd>
<dt>hyper</dt><dd><p>a <code>5xS</code> matrix with the posterior draws for the hyper-parameters of the hierarchical prior distribution</p>
</dd>
<dt>sigma2</dt><dd><p>an <code>NxMxS</code> array with the posterior draws for the structural shocks conditional variances</p>
</dd>
<dt>PR_TR</dt><dd><p>an <code>MxMxS</code> array with the posterior draws for the transition matrix.</p>
</dd>
<dt>xi</dt><dd><p>an <code>MxTxS</code> array with the posterior draws for the regime allocation matrix.</p>
</dd>
<dt>pi_0</dt><dd><p>an <code>MxS</code> matrix with the posterior draws for the ergodic probabilities</p>
</dd>
<dt>sigma</dt><dd><p>an <code>NxTxS</code> array with the posterior draws for the structural shocks conditional standard deviations' series over the sample period</p>
</dd>
</dl>

<p><code>last_draw</code> an object of class BSVARMIX with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Chan, J.C.C., Koop, G, and Yu, X. (2024) Large Order-Invariant Bayesian VARs with Stochastic Volatility. <em>Journal of Business &amp; Economic Statistics</em>, <b>42</b>, <a href="https://doi.org/10.1080/07350015.2023.2252039">doi:10.1080/07350015.2023.2252039</a>.
</p>
<p>Lütkepohl, H., and Woźniak, T., (2020) Bayesian Inference for Structural Vector Autoregressions Identified by Markov-Switching Heteroskedasticity. <em>Journal of Economic Dynamics and Control</em> <b>113</b>, 103862, <a href="https://doi.org/10.1016/j.jedc.2020.103862">doi:10.1016/j.jedc.2020.103862</a>.
</p>
<p>Song, Y., and Woźniak, T., (2021) Markov Switching. <em>Oxford Research Encyclopedia of Economics and Finance</em>, Oxford University Press, <a href="https://doi.org/10.1093/acrefore/9780190625979.013.174">doi:10.1093/acrefore/9780190625979.013.174</a>.
</p>
<p>Waggoner, D.F., and Zha, T., (2003) A Gibbs sampler for structural vector autoregressions. <em>Journal of Economic Dynamics and Control</em>, <b>28</b>, 349&ndash;366, <a href="https://doi.org/10.1016/S0165-1889%2802%2900168-9">doi:10.1016/S0165-1889(02)00168-9</a>.
</p>
<p>Woźniak, T., and Droumaguet, M., (2024) Bayesian Assessment of Identifying Restrictions for Heteroskedastic Structural VARs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_bsvar_mix">specify_bsvar_mix</a></code>, <code><a href="#topic+specify_posterior_bsvar_mix">specify_posterior_bsvar_mix</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 1, M = 2)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, thin = 2)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 2) |&gt; 
  compute_impulse_responses(horizon = 4) -&gt; irf
  
</code></pre>

<hr>
<h2 id='estimate.PosteriorBSVARMSH'>Bayesian estimation of a Structural Vector Autoregression with 
Markov-switching heteroskedasticity via Gibbs sampler</h2><span id='topic+estimate.PosteriorBSVARMSH'></span>

<h3>Description</h3>

<p>Estimates the SVAR with Markov-switching heteroskedasticity with <code>M</code> regimes (MS(M)) proposed by Woźniak &amp; Droumaguet (2022).
Implements the Gibbs sampler proposed by Waggoner &amp; Zha (2003)
for the structural matrix <code class="reqn">B</code> and the equation-by-equation sampler by Chan, Koop, &amp; Yu (2024)
for the autoregressive slope parameters <code class="reqn">A</code>. Additionally, the parameter matrices <code class="reqn">A</code> and <code class="reqn">B</code>
follow a Minnesota prior and generalised-normal prior distributions respectively with the matrix-specific
overall shrinkage parameters estimated thanks to a hierarchical prior distribution. The MS
model is estimated using the prior distributions and algorithms proposed by Woźniak &amp; Droumaguet (2024),
Lütkepohl &amp; Woźniak (2020), and Song &amp; Woźniak (2021). See section <b>Details</b> for the model equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMSH'
estimate(specification, S, thin = 1, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.PosteriorBSVARMSH_+3A_specification">specification</code></td>
<td>
<p>an object of class PosteriorBSVARMSH generated using the <code>estimate.BSVAR()</code> function.
This setup facilitates the continuation of the MCMC sampling starting from the last draw of the previous run.</p>
</td></tr>
<tr><td><code id="estimate.PosteriorBSVARMSH_+3A_s">S</code></td>
<td>
<p>a positive integer, the number of posterior draws to be generated</p>
</td></tr>
<tr><td><code id="estimate.PosteriorBSVARMSH_+3A_thin">thin</code></td>
<td>
<p>a positive integer, specifying the frequency of MCMC output thinning</p>
</td></tr>
<tr><td><code id="estimate.PosteriorBSVARMSH_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The heteroskedastic SVAR model is given by the reduced form equation:
</p>
<p style="text-align: center;"><code class="reqn">Y = AX + E</code>
</p>

<p>where <code class="reqn">Y</code> is an <code>NxT</code> matrix of dependent variables, <code class="reqn">X</code> is a <code>KxT</code> matrix of explanatory variables, 
<code class="reqn">E</code> is an <code>NxT</code> matrix of reduced form error terms, and <code class="reqn">A</code> is an <code>NxK</code> matrix of autoregressive slope coefficients and parameters on deterministic terms in <code>X</code>.
</p>
<p>The structural equation is given by
</p>
<p style="text-align: center;"><code class="reqn">BE = U</code>
</p>

<p>where <code class="reqn">U</code> is an <code>NxT</code> matrix of structural form error terms, and
<code class="reqn">B</code> is an <code>NxN</code> matrix of contemporaneous relationships.
</p>
<p>Finally, the structural shocks, <code class="reqn">U</code>, are temporally and contemporaneously independent and jointly normally distributed with zero mean.
The conditional variance of the <code>n</code>th shock at time <code>t</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">Var_{t-1}[u_{n.t}] = s^2_{n.s_t}</code>
</p>

<p>where <code class="reqn">s_t</code> is a Markov process driving the time-variability of 
the regime-specific conditional variances of structural shocks <code class="reqn">s^2_{n.s_t}</code>. 
In this model, the variances of each of the structural shocks sum to <code>M</code>.
</p>
<p>The Markov process <code class="reqn">s_t</code> is either:
</p>

<ul>
<li><p> stationary, irreducible, and aperiodic which requires all regimes to have 
a positive number occurrences over the sample period, or
</p>
</li>
<li><p> sparse with potentially many regimes with zero occurrences over the sample period
and in which the number of regimes is estimated.
</p>
</li></ul>

<p>These model selection also with this respect is made using function <code><a href="#topic+specify_bsvar_msh">specify_bsvar_msh</a></code>.
</p>


<h3>Value</h3>

<p>An object of class PosteriorBSVARMSH containing the Bayesian estimation output and containing two elements:
</p>
<p><code>posterior</code> a list with a collection of <code>S</code> draws from the posterior distribution generated via Gibbs sampler containing:
</p>

<dl>
<dt>A</dt><dd><p>an <code>NxKxS</code> array with the posterior draws for matrix <code class="reqn">A</code></p>
</dd>
<dt>B</dt><dd><p>an <code>NxNxS</code> array with the posterior draws for matrix <code class="reqn">B</code></p>
</dd>
<dt>hyper</dt><dd><p>a <code>5xS</code> matrix with the posterior draws for the hyper-parameters of the hierarchical prior distribution</p>
</dd>
<dt>sigma2</dt><dd><p>an <code>NxMxS</code> array with the posterior draws for the structural shocks conditional variances</p>
</dd>
<dt>PR_TR</dt><dd><p>an <code>MxMxS</code> array with the posterior draws for the transition matrix.</p>
</dd>
<dt>xi</dt><dd><p>an <code>MxTxS</code> array with the posterior draws for the regime allocation matrix.</p>
</dd>
<dt>pi_0</dt><dd><p>an <code>MxS</code> matrix with the posterior draws for the initial state probabilities</p>
</dd>
<dt>sigma</dt><dd><p>an <code>NxTxS</code> array with the posterior draws for the structural shocks conditional standard deviations' series over the sample period</p>
</dd>
</dl>

<p><code>last_draw</code> an object of class BSVARMSH with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Chan, J.C.C., Koop, G, and Yu, X. (2024) Large Order-Invariant Bayesian VARs with Stochastic Volatility. <em>Journal of Business &amp; Economic Statistics</em>, <b>42</b>, <a href="https://doi.org/10.1080/07350015.2023.2252039">doi:10.1080/07350015.2023.2252039</a>.
</p>
<p>Lütkepohl, H., and Woźniak, T., (2020) Bayesian Inference for Structural Vector Autoregressions Identified by Markov-Switching Heteroskedasticity. <em>Journal of Economic Dynamics and Control</em> <b>113</b>, 103862, <a href="https://doi.org/10.1016/j.jedc.2020.103862">doi:10.1016/j.jedc.2020.103862</a>.
</p>
<p>Song, Y., and Woźniak, T., (2021) Markov Switching. <em>Oxford Research Encyclopedia of Economics and Finance</em>, Oxford University Press, <a href="https://doi.org/10.1093/acrefore/9780190625979.013.174">doi:10.1093/acrefore/9780190625979.013.174</a>.
</p>
<p>Waggoner, D.F., and Zha, T., (2003) A Gibbs sampler for structural vector autoregressions. <em>Journal of Economic Dynamics and Control</em>, <b>28</b>, 349&ndash;366, <a href="https://doi.org/10.1016/S0165-1889%2802%2900168-9">doi:10.1016/S0165-1889(02)00168-9</a>.
</p>
<p>Woźniak, T., and Droumaguet, M., (2024) Bayesian Assessment of Identifying Restrictions for Heteroskedastic Structural VARs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_bsvar_msh">specify_bsvar_msh</a></code>, <code><a href="#topic+specify_posterior_bsvar_msh">specify_posterior_bsvar_msh</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 1, M = 2)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 5)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 5) |&gt; 
  estimate(S = 10, thin = 2) |&gt; 
  compute_impulse_responses(horizon = 4) -&gt; irf

</code></pre>

<hr>
<h2 id='estimate.PosteriorBSVARSV'>Bayesian estimation of a Structural Vector Autoregression with 
Stochastic Volatility heteroskedasticity via Gibbs sampler</h2><span id='topic+estimate.PosteriorBSVARSV'></span>

<h3>Description</h3>

<p>Estimates the SVAR with Stochastic Volatility (SV) heteroskedasticity 
proposed by Lütkepohl, Shang, Uzeda, and Woźniak (2024).
Implements the Gibbs sampler proposed by Waggoner &amp; Zha (2003)
for the structural matrix <code class="reqn">B</code> and the equation-by-equation sampler 
by Chan, Koop, &amp; Yu (2024)
for the autoregressive slope parameters <code class="reqn">A</code>. Additionally, 
the parameter matrices <code class="reqn">A</code> and <code class="reqn">B</code>
follow a Minnesota prior and generalised-normal prior distributions 
respectively with the matrix-specific
overall shrinkage parameters estimated thanks to a hierarchical prior distribution. 
The SV model is estimated using a range of techniques including: 
simulation smoother, auxiliary mixture, ancillarity-sufficiency interweaving strategy, 
and generalised inverse Gaussian distribution summarised by Kastner &amp; Frühwirth-Schnatter (2014). 
See section <b>Details</b> for the model equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSV'
estimate(specification, S, thin = 1, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.PosteriorBSVARSV_+3A_specification">specification</code></td>
<td>
<p>an object of class PosteriorBSVARSV generated using the <code>estimate.BSVAR()</code> function.
This setup facilitates the continuation of the MCMC sampling starting from the last draw of the previous run.</p>
</td></tr>
<tr><td><code id="estimate.PosteriorBSVARSV_+3A_s">S</code></td>
<td>
<p>a positive integer, the number of posterior draws to be generated</p>
</td></tr>
<tr><td><code id="estimate.PosteriorBSVARSV_+3A_thin">thin</code></td>
<td>
<p>a positive integer, specifying the frequency of MCMC output thinning</p>
</td></tr>
<tr><td><code id="estimate.PosteriorBSVARSV_+3A_show_progress">show_progress</code></td>
<td>
<p>a logical value, if <code>TRUE</code> the estimation progress bar is visible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The heteroskedastic SVAR model is given by the reduced form equation:
</p>
<p style="text-align: center;"><code class="reqn">Y = AX + E</code>
</p>

<p>where <code class="reqn">Y</code> is an <code>NxT</code> matrix of dependent variables, <code class="reqn">X</code> is a <code>KxT</code> matrix of explanatory variables, 
<code class="reqn">E</code> is an <code>NxT</code> matrix of reduced form error terms, and <code class="reqn">A</code> is an <code>NxK</code> matrix of autoregressive slope coefficients and parameters on deterministic terms in <code class="reqn">X</code>.
</p>
<p>The structural equation is given by
</p>
<p style="text-align: center;"><code class="reqn">BE = U</code>
</p>

<p>where <code class="reqn">U</code> is an <code>NxT</code> matrix of structural form error terms, and
<code class="reqn">B</code> is an <code>NxN</code> matrix of contemporaneous relationships.
Finally, the structural shocks, <code class="reqn">U</code>, are temporally and contemporaneously independent and jointly normally distributed with zero mean.
</p>
<p>Two alternative specifications of the conditional variance of the <code>n</code>th shock at time <code>t</code> 
can be estimated: non-centred Stochastic Volatility by Lütkepohl, Shang, Uzeda, and Woźniak (2022) 
or centred Stochastic Volatility by Chan, Koop, &amp; Yu (2021).
</p>
<p>The non-centred Stochastic Volatility by Lütkepohl, Shang, Uzeda, and Woźniak (2022) 
is selected by setting argument <code>centred_sv</code> of function <code>specify_bsvar_sv$new()</code> to value <code>FALSE</code>.
It has the conditional variances given by:
</p>
<p style="text-align: center;"><code class="reqn">Var_{t-1}[u_{n.t}] = exp(w_n h_{n.t})</code>
</p>

<p>where <code class="reqn">w_n</code> is the estimated conditional standard deviation of the log-conditional variance
and the log-volatility process <code class="reqn">h_{n.t}</code> follows an autoregressive process:
</p>
<p style="text-align: center;"><code class="reqn">h_{n.t} = g_n h_{n.t-1} + v_{n.t}</code>
</p>

<p>where <code class="reqn">h_{n.0}=0</code>, <code class="reqn">g_n</code> is an autoregressive parameter and <code class="reqn">v_{n.t}</code> is a standard normal error term.
</p>
<p>The centred Stochastic Volatility by Chan, Koop, &amp; Yu (2021)
is selected by setting argument <code>centred_sv</code> of function <code>specify_bsvar_sv$new()</code> to value <code>TRUE</code>.
Its conditional variances are given by:
</p>
<p style="text-align: center;"><code class="reqn">Var_{t-1}[u_{n.t}] = exp(h_{n.t})</code>
</p>

<p>where the log-conditional variances <code class="reqn">h_{n.t}</code> follow an autoregressive process:
</p>
<p style="text-align: center;"><code class="reqn">h_{n.t} = g_n h_{n.t-1} + v_{n.t}</code>
</p>

<p>where <code class="reqn">h_{n.0}=0</code>, <code class="reqn">g_n</code> is an autoregressive parameter and <code class="reqn">v_{n.t}</code> is a zero-mean normal error term
with variance <code class="reqn">s_{v.n}^2</code>.
</p>


<h3>Value</h3>

<p>An object of class PosteriorBSVARSV containing the Bayesian estimation output and containing two elements:
</p>
<p><code>posterior</code> a list with a collection of <code>S</code> draws from the posterior distribution generated via Gibbs sampler containing:
</p>

<dl>
<dt>A</dt><dd><p>an <code>NxKxS</code> array with the posterior draws for matrix <code class="reqn">A</code></p>
</dd>
<dt>B</dt><dd><p>an <code>NxNxS</code> array with the posterior draws for matrix <code class="reqn">B</code></p>
</dd>
<dt>hyper</dt><dd><p>a <code>5xS</code> matrix with the posterior draws for the hyper-parameters of the hierarchical prior distribution</p>
</dd>
<dt>h</dt><dd><p>an <code>NxTxS</code> array with the posterior draws of the log-volatility processes</p>
</dd>
<dt>rho</dt><dd><p>an <code>NxS</code> matrix with the posterior draws of SV autoregressive parameters</p>
</dd>
<dt>omega</dt><dd><p>an <code>NxS</code> matrix with the posterior draws of SV process conditional standard deviations</p>
</dd>
<dt>S</dt><dd><p>an <code>NxTxS</code> array with the posterior draws of the auxiliary mixture component indicators</p>
</dd>
<dt>sigma2_omega</dt><dd><p>an <code>NxS</code> matrix with the posterior draws of the variances of the zero-mean normal prior for <code>omega</code></p>
</dd>
<dt>s_</dt><dd><p>an <code>S</code>-vector with the posterior draws of the scale of the gamma prior of the hierarchical prior for <code>sigma2_omega</code></p>
</dd>
</dl>

<p><code>last_draw</code> an object of class BSVARSV with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Chan, J.C.C., Koop, G, and Yu, X. (2024) Large Order-Invariant Bayesian VARs with Stochastic Volatility. <em>Journal of Business &amp; Economic Statistics</em>, <b>42</b>, <a href="https://doi.org/10.1080/07350015.2023.2252039">doi:10.1080/07350015.2023.2252039</a>.
</p>
<p>Kastner, G. and Frühwirth-Schnatter, S. (2014) Ancillarity-Sufficiency Interweaving Strategy (ASIS) for Boosting MCMC 
Estimation of Stochastic Volatility Models. <em>Computational Statistics &amp; Data Analysis</em>, <b>76</b>, 408&ndash;423, 
<a href="https://doi.org/10.1016/j.csda.2013.01.002">doi:10.1016/j.csda.2013.01.002</a>.
</p>
<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>
<p>Waggoner, D.F., and Zha, T., (2003) A Gibbs sampler for structural vector autoregressions. <em>Journal of Economic Dynamics and Control</em>, <b>28</b>, 349&ndash;366, <a href="https://doi.org/10.1016/S0165-1889%2802%2900168-9">doi:10.1016/S0165-1889(02)00168-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_bsvar_sv">specify_bsvar_sv</a></code>, <code><a href="#topic+specify_posterior_bsvar_sv">specify_posterior_bsvar_sv</a></code>, <code><a href="#topic+normalise_posterior">normalise_posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, 2)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 2) |&gt; 
  compute_impulse_responses(horizon = 4) -&gt; irf

</code></pre>

<hr>
<h2 id='forecast'>Forecasting using Structural Vector Autoregression</h2><span id='topic+forecast'></span>

<h3>Description</h3>

<p>Samples from the joint predictive density of all of the dependent 
variables for models from packages <span class="pkg">bsvars</span>, <span class="pkg">bsvarSIGNs</span> or 
<span class="pkg">bvarPANELs</span> at forecast horizons from 1 to <code>horizon</code> specified as 
an argument of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast(posterior, horizon = 1, exogenous_forecast, conditional_forecast)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome
obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="forecast_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer, specifying the forecasting horizon.</p>
</td></tr>
<tr><td><code id="forecast_+3A_exogenous_forecast">exogenous_forecast</code></td>
<td>
<p>forecasted values of the exogenous variables.</p>
</td></tr>
<tr><td><code id="forecast_+3A_conditional_forecast">conditional_forecast</code></td>
<td>
<p>forecasted values for selected variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>Forecasts</code> containing the
draws from the predictive density and for heteroskedastic models the draws 
from the predictive density of structural shocks conditional standard 
deviations and data. The output elements include:
</p>

<dl>
<dt>forecasts</dt><dd><p>an <code>NxTxS</code> array with the draws from predictive density</p>
</dd>
<dt>forecasts_sigma</dt><dd><p>provided only for heteroskedastic models, an <code>NxTxS</code> array with the draws 
from the predictive density of structural shocks conditional standard deviations</p>
</dd>
<dt>Y</dt><dd><p>an <code class="reqn">NxT</code> matrix with the data on dependent variables</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# sample from predictive density 1 year ahead
predictive     = forecast(posterior, 4)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  forecast(horizon = 4) -&gt; predictive

</code></pre>

<hr>
<h2 id='forecast.PosteriorBSVAR'>Forecasting using Structural Vector Autoregression</h2><span id='topic+forecast.PosteriorBSVAR'></span>

<h3>Description</h3>

<p>Samples from the joint predictive density of all of the dependent 
variables for models from packages <span class="pkg">bsvars</span>, <span class="pkg">bsvarSIGNs</span> or 
<span class="pkg">bvarPANELs</span> at forecast horizons from 1 to <code>horizon</code> specified as 
an argument of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVAR'
forecast(
  posterior,
  horizon = 1,
  exogenous_forecast = NULL,
  conditional_forecast = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.PosteriorBSVAR_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVAR</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVAR_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer, specifying the forecasting horizon.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVAR_+3A_exogenous_forecast">exogenous_forecast</code></td>
<td>
<p>a matrix of dimension <code>horizon x d</code> containing 
forecasted values of the exogenous variables.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVAR_+3A_conditional_forecast">conditional_forecast</code></td>
<td>
<p>a <code>horizon x N</code> matrix with forecasted values 
for selected variables. It should only contain <code>numeric</code> or <code>NA</code> 
values. The entries with <code>NA</code> values correspond to the values that are 
forecasted conditionally on the realisations provided as <code>numeric</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>Forecasts</code> containing the
draws from the predictive density and data. The output list includes element:
</p>

<dl>
<dt>forecasts</dt><dd><p>an <code>NxTxS</code> array with the draws from predictive density</p>
</dd>
<dt>Y</dt><dd><p>an <code class="reqn">NxT</code> matrix with the data on dependent variables</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# sample from predictive density 1 year ahead
predictive     = forecast(posterior, 4)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  forecast(horizon = 4) -&gt; predictive

# conditional forecasting 2 quarters ahead conditioning on 
#  provided future values for the Gross Domestic Product 
############################################################
cf        = matrix(NA , 2, 3)
cf[,3]    = tail(us_fiscal_lsuw, 1)[3]   # conditional forecasts equal to the last gdp observation
predictive    = forecast(posterior, 2, conditional_forecast = cf)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  forecast(horizon = 2, conditional_forecast = cf) -&gt; predictive

</code></pre>

<hr>
<h2 id='forecast.PosteriorBSVARMIX'>Forecasting using Structural Vector Autoregression</h2><span id='topic+forecast.PosteriorBSVARMIX'></span>

<h3>Description</h3>

<p>Samples from the joint predictive density of all of the dependent 
variables for models from packages <span class="pkg">bsvars</span>, <span class="pkg">bsvarSIGNs</span> or 
<span class="pkg">bvarPANELs</span> at forecast horizons from 1 to <code>horizon</code> specified as 
an argument of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMIX'
forecast(
  posterior,
  horizon = 1,
  exogenous_forecast = NULL,
  conditional_forecast = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.PosteriorBSVARMIX_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMIX</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVARMIX_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer, specifying the forecasting horizon.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVARMIX_+3A_exogenous_forecast">exogenous_forecast</code></td>
<td>
<p>a matrix of dimension <code>horizon x d</code> containing 
forecasted values of the exogenous variables.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVARMIX_+3A_conditional_forecast">conditional_forecast</code></td>
<td>
<p>a <code>horizon x N</code> matrix with forecasted values 
for selected variables. It should only contain <code>numeric</code> or <code>NA</code> 
values. The entries with <code>NA</code> values correspond to the values that are 
forecasted conditionally on the realisations provided as <code>numeric</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>Forecasts</code> containing the
draws from the predictive density and for heteroskedastic models the draws 
from the predictive density of structural shocks conditional standard 
deviations and data. The output elements include:
</p>

<dl>
<dt>forecasts</dt><dd><p>an <code>NxTxS</code> array with the draws from predictive density</p>
</dd>
<dt>forecasts_sigma</dt><dd><p>provided only for heteroskedastic models, an <code>NxTxS</code> array with the draws 
from the predictive density of structural shocks conditional standard deviations</p>
</dd>
<dt>Y</dt><dd><p>an <code class="reqn">NxT</code> matrix with the data on dependent variables</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# sample from predictive density 1 year ahead
predictive     = forecast(posterior, 4)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt;
  estimate(S = 20) |&gt;  
  forecast(horizon = 4) -&gt; predictive
  
# conditional forecasting 2 quarters ahead conditioning on 
#  provided future values for the Gross Domestic Product 
############################################################
cf        = matrix(NA , 2, 3)
cf[,3]    = tail(us_fiscal_lsuw, 1)[3]   # conditional forecasts equal to the last gdp observation
predictive    = forecast(posterior, 2, conditional_forecast = cf)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  forecast(horizon = 2, conditional_forecast = cf) -&gt; predictive
  
</code></pre>

<hr>
<h2 id='forecast.PosteriorBSVARMSH'>Forecasting using Structural Vector Autoregression</h2><span id='topic+forecast.PosteriorBSVARMSH'></span>

<h3>Description</h3>

<p>Samples from the joint predictive density of all of the dependent 
variables for models from packages <span class="pkg">bsvars</span>, <span class="pkg">bsvarSIGNs</span> or 
<span class="pkg">bvarPANELs</span> at forecast horizons from 1 to <code>horizon</code> specified as 
an argument of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMSH'
forecast(
  posterior,
  horizon = 1,
  exogenous_forecast = NULL,
  conditional_forecast = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.PosteriorBSVARMSH_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARMSH</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVARMSH_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer, specifying the forecasting horizon.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVARMSH_+3A_exogenous_forecast">exogenous_forecast</code></td>
<td>
<p>a matrix of dimension <code>horizon x d</code> containing 
forecasted values of the exogenous variables.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVARMSH_+3A_conditional_forecast">conditional_forecast</code></td>
<td>
<p>a <code>horizon x N</code> matrix with forecasted values 
for selected variables. It should only contain <code>numeric</code> or <code>NA</code> 
values. The entries with <code>NA</code> values correspond to the values that are 
forecasted conditionally on the realisations provided as <code>numeric</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>Forecasts</code> containing the
draws from the predictive density and for heteroskedastic models the draws 
from the predictive density of structural shocks conditional standard 
deviations and data. The output elements include:
</p>

<dl>
<dt>forecasts</dt><dd><p>an <code>NxTxS</code> array with the draws from predictive density</p>
</dd>
<dt>forecasts_sigma</dt><dd><p>provided only for heteroskedastic models, an <code>NxTxS</code> array with the draws 
from the predictive density of structural shocks conditional standard deviations</p>
</dd>
<dt>Y</dt><dd><p>an <code class="reqn">NxT</code> matrix with the data on dependent variables</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 1, M = 2)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20)

# sample from predictive density 1 year ahead
predictive     = forecast(posterior, 4)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  forecast(horizon = 4) -&gt; predictive
  
# conditional forecasting 2 quarters ahead conditioning on 
#  provided future values for the Gross Domestic Product 
############################################################
cf        = matrix(NA , 2, 3)
cf[,3]    = tail(us_fiscal_lsuw, 1)[3]   # conditional forecasts equal to the last gdp observation
predictive    = forecast(posterior, 2, conditional_forecast = cf)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20) |&gt; 
  forecast(horizon = 2, conditional_forecast = cf) -&gt; predictive
  
</code></pre>

<hr>
<h2 id='forecast.PosteriorBSVARSV'>Forecasting using Structural Vector Autoregression</h2><span id='topic+forecast.PosteriorBSVARSV'></span>

<h3>Description</h3>

<p>Samples from the joint predictive density of all of the dependent 
variables for models from packages <span class="pkg">bsvars</span>, <span class="pkg">bsvarSIGNs</span> or 
<span class="pkg">bvarPANELs</span> at forecast horizons from 1 to <code>horizon</code> specified as 
an argument of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSV'
forecast(
  posterior,
  horizon = 1,
  exogenous_forecast = NULL,
  conditional_forecast = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.PosteriorBSVARSV_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of class 
<code>PosteriorBSVARSV</code> obtained by running the <code>estimate</code> function.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVARSV_+3A_horizon">horizon</code></td>
<td>
<p>a positive integer, specifying the forecasting horizon.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVARSV_+3A_exogenous_forecast">exogenous_forecast</code></td>
<td>
<p>a matrix of dimension <code>horizon x d</code> containing 
forecasted values of the exogenous variables.</p>
</td></tr>
<tr><td><code id="forecast.PosteriorBSVARSV_+3A_conditional_forecast">conditional_forecast</code></td>
<td>
<p>a <code>horizon x N</code> matrix with forecasted values 
for selected variables. It should only contain <code>numeric</code> or <code>NA</code> 
values. The entries with <code>NA</code> values correspond to the values that are 
forecasted conditionally on the realisations provided as <code>numeric</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>Forecasts</code> containing the
draws from the predictive density and for heteroskedastic models the draws 
from the predictive density of structural shocks conditional standard 
deviations and data. The output elements include:
</p>

<dl>
<dt>forecasts</dt><dd><p>an <code>NxTxS</code> array with the draws from predictive density</p>
</dd>
<dt>forecasts_sigma</dt><dd><p>provided only for heteroskedastic models, an <code>NxTxS</code> array with the draws 
from the predictive density of structural shocks conditional standard deviations</p>
</dd>
<dt>Y</dt><dd><p>an <code class="reqn">NxT</code> matrix with the data on dependent variables</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)

# run the burn-in
burn_in        = estimate(specification, 5)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)

# sample from predictive density 1 year ahead
predictive     = forecast(posterior, 2)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 5) |&gt;
  estimate(S = 10, thin = 2) |&gt;  
  forecast(horizon = 2) -&gt; predictive
  
# conditional forecasting 2 quarters ahead conditioning on 
#  provided future values for the Gross Domestic Product 
############################################################
cf        = matrix(NA , 2, 3)
cf[,3]    = tail(us_fiscal_lsuw, 1)[3]   # conditional forecasts equal to the last gdp observation
predictive    = forecast(posterior, 2, conditional_forecast = cf)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 5) |&gt; 
  estimate(S = 10) |&gt; 
  forecast(horizon = 2, conditional_forecast = cf) -&gt; predictive
  
</code></pre>

<hr>
<h2 id='normalise_posterior'>Waggoner &amp; Zha (2003) row signs normalisation of the posterior draws for matrix <code class="reqn">B</code></h2><span id='topic+normalise_posterior'></span>

<h3>Description</h3>

<p>Normalises the sign of rows of matrix <code class="reqn">B</code> MCMC draws, 
provided as the first argument <code>posterior_B</code>, relative to matrix
<code>B_hat</code>, provided as the second argument of the function. The implemented
procedure proposed by Waggoner, Zha (2003) normalises the MCMC output in an
optimal way leading to the unimodal posterior. Only normalised MCMC output is 
suitable for the computations of the posterior characteristics of the <code class="reqn">B</code>
matrix elements and their functions such as the impulse response functions and other 
economically interpretable values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise_posterior(posterior, B_hat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalise_posterior_+3A_posterior">posterior</code></td>
<td>
<p>posterior estimation outcome - an object of either of classes: 
PosteriorBSVAR, PosteriorBSVARMSH, PosteriorBSVARMIX, or PosteriorBSVARSV
containing, amongst other draws, the <code>S</code> draws from the posterior 
distribution of the <code>NxN</code> matrix of contemporaneous relationships <code class="reqn">B</code>. 
These draws are to be normalised with respect to:</p>
</td></tr>
<tr><td><code id="normalise_posterior_+3A_b_hat">B_hat</code></td>
<td>
<p>an <code>NxN</code> matrix specified by the user to have the desired row signs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. The normalised elements overwrite the corresponding elements of 
the first argument <code>posterior_B</code> by reference.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Waggoner, D.F., and Zha, T., (2003) Likelihood Preserving Normalization in Multiple Equation Models. 
<em>Journal of Econometrics</em>, <b>114</b>(2), 329&ndash;47, <a href="https://doi.org/10.1016/S0304-4076%2803%2900087-3">doi:10.1016/S0304-4076(03)00087-3</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 4)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 1)

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag((-1) * sign(diag(BB))) %*% BB         # set negative diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

</code></pre>

<hr>
<h2 id='plot_ribbon'>Plots the median and an interval between two specified percentiles 
for a sequence of <code>K</code> random variables</h2><span id='topic+plot_ribbon'></span>

<h3>Description</h3>

<p>Plots the median and an interval between two specified percentiles 
for a sequence of <code>K</code> random variables based on the <code>S</code> posterior 
draws provided for each of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ribbon(
  draws,
  probability = 0.9,
  col = "#ff69b4",
  ylim,
  ylab,
  xlab,
  start_at = 0,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ribbon_+3A_draws">draws</code></td>
<td>
<p>a <code>K x S</code> matrix with <code>S</code> posterior draws of 
<code>K</code> random variables, or a <code>K x S x N</code> array with <code>N</code> such matrices</p>
</td></tr>
<tr><td><code id="plot_ribbon_+3A_probability">probability</code></td>
<td>
<p>a number from interval <code>(0,1)</code> denoting the probability 
content of the plotted interval. The interval stretches from the 
<code>0.5 * (1 - probability)</code> to <code>1 - 0.5 * (1 - probability)</code> percentile 
of the posterior distribution.</p>
</td></tr>
<tr><td><code id="plot_ribbon_+3A_col">col</code></td>
<td>
<p>a colour of the plot</p>
</td></tr>
<tr><td><code id="plot_ribbon_+3A_ylim">ylim</code></td>
<td>
<p>the range of the <code>y</code> axis</p>
</td></tr>
<tr><td><code id="plot_ribbon_+3A_ylab">ylab</code></td>
<td>
<p>the label of the <code>y</code> axis</p>
</td></tr>
<tr><td><code id="plot_ribbon_+3A_xlab">xlab</code></td>
<td>
<p>the label of the <code>x</code> axis</p>
</td></tr>
<tr><td><code id="plot_ribbon_+3A_start_at">start_at</code></td>
<td>
<p>an integer to denote the beginning of the <code>x</code> axis range</p>
</td></tr>
<tr><td><code id="plot_ribbon_+3A_add">add</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the current ribbon plot is added 
to an existing plot</p>
</td></tr>
<tr><td><code id="plot_ribbon_+3A_...">...</code></td>
<td>
<p>other graphical parameters to be passed to <code>base::plot</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)                                               # upload data
set.seed(123)                                                      # set seed
specification  = specify_bsvar$new(us_fiscal_lsuw)                 # specify model

burn_in        = estimate(specification, 10)                       # run the burn-in
posterior      = estimate(burn_in, 20, thin = 1)                   # estimate the model
irf            = compute_impulse_responses(posterior, horizon = 4) # impulse responses
plot_ribbon(irf[1,1,,])

</code></pre>

<hr>
<h2 id='plot.Forecasts'>Plots fitted values of dependent variables</h2><span id='topic+plot.Forecasts'></span>

<h3>Description</h3>

<p>Plots of fitted values of dependent variables including their 
median and percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Forecasts'
plot(
  x,
  probability = 0.9,
  data_in_plot = 1,
  col = "#ff69b4",
  main,
  xlab,
  mar.multi = c(1, 4.6, 0, 2.1),
  oma.multi = c(6, 0, 5, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Forecasts_+3A_x">x</code></td>
<td>
<p>an object of class Forecasts obtained using the
<code>forecast()</code> function containing posterior draws of 
fitted values of dependent variables.</p>
</td></tr>
<tr><td><code id="plot.Forecasts_+3A_probability">probability</code></td>
<td>
<p>a parameter determining the interval to be plotted. The 
interval stretches from the <code>0.5 * (1 - probability)</code> to 
<code>1 - 0.5 * (1 - probability)</code> percentile of the posterior distribution.</p>
</td></tr>
<tr><td><code id="plot.Forecasts_+3A_data_in_plot">data_in_plot</code></td>
<td>
<p>a fraction value in the range (0, 1) determining how many
of the last observations in the data should be plotted with the forecasts.</p>
</td></tr>
<tr><td><code id="plot.Forecasts_+3A_col">col</code></td>
<td>
<p>a colour of the plot line and the ribbon</p>
</td></tr>
<tr><td><code id="plot.Forecasts_+3A_main">main</code></td>
<td>
<p>an alternative main title for the plot</p>
</td></tr>
<tr><td><code id="plot.Forecasts_+3A_xlab">xlab</code></td>
<td>
<p>an alternative x-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot.Forecasts_+3A_mar.multi">mar.multi</code></td>
<td>
<p>the default <code>mar</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.Forecasts_+3A_oma.multi">oma.multi</code></td>
<td>
<p>the default <code>oma</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.Forecasts_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast">forecast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)                                  # upload data
set.seed(123)                                         # set seed
specification  = specify_bsvar$new(us_fiscal_lsuw)    # specify model
burn_in        = estimate(specification, 10)          # run the burn-in
posterior      = estimate(burn_in, 20, thin = 1)      # estimate the model

# compute forecasts
fore            = forecast(posterior, horizon = 4)
plot(fore)                                            # plot forecasts

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  forecast(horizon = 4) |&gt;
  plot()

</code></pre>

<hr>
<h2 id='plot.PosteriorFEVD'>Plots forecast error variance decompositions</h2><span id='topic+plot.PosteriorFEVD'></span>

<h3>Description</h3>

<p>Plots of the posterior means of the forecast error variance 
decompositions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorFEVD'
plot(
  x,
  cols,
  main,
  xlab,
  mar.multi = c(1, 4.6, 0, 4.6),
  oma.multi = c(6, 0, 5, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PosteriorFEVD_+3A_x">x</code></td>
<td>
<p>an object of class PosteriorFEVD obtained using the
<code>compute_variance_decompositions()</code> function containing posterior draws of 
forecast error variance decompositions.</p>
</td></tr>
<tr><td><code id="plot.PosteriorFEVD_+3A_cols">cols</code></td>
<td>
<p>an <code>N</code>-vector with colours of the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorFEVD_+3A_main">main</code></td>
<td>
<p>an alternative main title for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorFEVD_+3A_xlab">xlab</code></td>
<td>
<p>an alternative x-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorFEVD_+3A_mar.multi">mar.multi</code></td>
<td>
<p>the default <code>mar</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorFEVD_+3A_oma.multi">oma.multi</code></td>
<td>
<p>the default <code>oma</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorFEVD_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_variance_decompositions">compute_variance_decompositions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)                                  # upload data
set.seed(123)                                         # set seed
specification  = specify_bsvar$new(us_fiscal_lsuw)    # specify model
burn_in        = estimate(specification, 10)          # run the burn-in
posterior      = estimate(burn_in, 20, thin = 1)      # estimate the model

# compute forecast error variance decompositions
fevd           = compute_variance_decompositions(posterior, horizon = 4)
plot(fevd)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  compute_variance_decompositions(horizon = 4) |&gt;
  plot()

</code></pre>

<hr>
<h2 id='plot.PosteriorFitted'>Plots fitted values of dependent variables</h2><span id='topic+plot.PosteriorFitted'></span>

<h3>Description</h3>

<p>Plots of fitted values of dependent variables including their 
median and percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorFitted'
plot(
  x,
  probability = 0.9,
  col = "#ff69b4",
  main,
  xlab,
  mar.multi = c(1, 4.6, 0, 2.1),
  oma.multi = c(6, 0, 5, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PosteriorFitted_+3A_x">x</code></td>
<td>
<p>an object of class PosteriorFitted obtained using the
<code>compute_fitted_values()</code> function containing posterior draws of 
fitted values of dependent variables.</p>
</td></tr>
<tr><td><code id="plot.PosteriorFitted_+3A_probability">probability</code></td>
<td>
<p>a parameter determining the interval to be plotted. The 
interval stretches from the <code>0.5 * (1 - probability)</code> to 
<code>1 - 0.5 * (1 - probability)</code> percentile of the posterior distribution.</p>
</td></tr>
<tr><td><code id="plot.PosteriorFitted_+3A_col">col</code></td>
<td>
<p>a colour of the plot line and the ribbon</p>
</td></tr>
<tr><td><code id="plot.PosteriorFitted_+3A_main">main</code></td>
<td>
<p>an alternative main title for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorFitted_+3A_xlab">xlab</code></td>
<td>
<p>an alternative x-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorFitted_+3A_mar.multi">mar.multi</code></td>
<td>
<p>the default <code>mar</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorFitted_+3A_oma.multi">oma.multi</code></td>
<td>
<p>the default <code>oma</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorFitted_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_fitted_values">compute_fitted_values</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)                                  # upload data
set.seed(123)                                         # set seed
specification  = specify_bsvar$new(us_fiscal_lsuw)    # specify model
burn_in        = estimate(specification, 10)          # run the burn-in
posterior      = estimate(burn_in, 20, thin = 1)      # estimate the model

# compute fitted values
fitted         = compute_fitted_values(posterior)
plot(fitted)                                          # plot fitted values

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  compute_fitted_values() |&gt;
  plot()

</code></pre>

<hr>
<h2 id='plot.PosteriorHD'>Plots historical decompositions</h2><span id='topic+plot.PosteriorHD'></span>

<h3>Description</h3>

<p>Plots of the posterior means of the historical decompositions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorHD'
plot(
  x,
  cols,
  main,
  xlab,
  mar.multi = c(1, 4.6, 0, 4.6),
  oma.multi = c(6, 0, 5, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PosteriorHD_+3A_x">x</code></td>
<td>
<p>an object of class PosteriorHD obtained using the
<code>compute_historical_decompositions()</code> function containing posterior draws of 
historical decompositions.</p>
</td></tr>
<tr><td><code id="plot.PosteriorHD_+3A_cols">cols</code></td>
<td>
<p>an <code>N</code>-vector with colours of the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorHD_+3A_main">main</code></td>
<td>
<p>an alternative main title for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorHD_+3A_xlab">xlab</code></td>
<td>
<p>an alternative x-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorHD_+3A_mar.multi">mar.multi</code></td>
<td>
<p>the default <code>mar</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorHD_+3A_oma.multi">oma.multi</code></td>
<td>
<p>the default <code>oma</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorHD_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_historical_decompositions">compute_historical_decompositions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)                                  # upload data
set.seed(123)                                         # set seed
specification  = specify_bsvar$new(us_fiscal_lsuw)    # specify model
burn_in        = estimate(specification, 10)          # run the burn-in
posterior      = estimate(burn_in, 20, thin = 1)      # estimate the model

# compute historical decompositions
fevd           = compute_historical_decompositions(posterior)
plot(fevd)                                            

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  compute_historical_decompositions() |&gt;
  plot()

</code></pre>

<hr>
<h2 id='plot.PosteriorIR'>Plots impulse responses</h2><span id='topic+plot.PosteriorIR'></span>

<h3>Description</h3>

<p>Plots of of all variables to all shocks including their 
median and percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorIR'
plot(
  x,
  probability = 0.9,
  col = "#ff69b4",
  main,
  xlab,
  mar.multi = c(1, 4.1, 0, 1.1),
  oma.multi = c(6, 0, 5, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PosteriorIR_+3A_x">x</code></td>
<td>
<p>an object of class PosteriorIR obtained using the
<code>compute_impulse_responses()</code> function containing posterior draws of 
impulse responses.</p>
</td></tr>
<tr><td><code id="plot.PosteriorIR_+3A_probability">probability</code></td>
<td>
<p>a parameter determining the interval to be plotted. The 
interval stretches from the <code>0.5 * (1 - probability)</code> to 
<code>1 - 0.5 * (1 - probability)</code> percentile of the posterior distribution.</p>
</td></tr>
<tr><td><code id="plot.PosteriorIR_+3A_col">col</code></td>
<td>
<p>a colour of the plot line and the ribbon</p>
</td></tr>
<tr><td><code id="plot.PosteriorIR_+3A_main">main</code></td>
<td>
<p>an alternative main title for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorIR_+3A_xlab">xlab</code></td>
<td>
<p>an alternative x-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorIR_+3A_mar.multi">mar.multi</code></td>
<td>
<p>the default <code>mar</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorIR_+3A_oma.multi">oma.multi</code></td>
<td>
<p>the default <code>oma</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorIR_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_impulse_responses">compute_impulse_responses</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)                                  # upload data
set.seed(123)                                         # set seed
specification  = specify_bsvar$new(us_fiscal_lsuw)    # specify model
burn_in        = estimate(specification, 10)          # run the burn-in
posterior      = estimate(burn_in, 20, thin = 1)      # estimate the model

# compute impulse responses
fitted         = compute_impulse_responses(posterior, horizon = 4)
plot(fitted)                                          # plot

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  compute_impulse_responses(horizon = 4) |&gt;
  plot()

</code></pre>

<hr>
<h2 id='plot.PosteriorRegimePr'>Plots estimated regime probabilities</h2><span id='topic+plot.PosteriorRegimePr'></span>

<h3>Description</h3>

<p>Plots of estimated regime probabilities of Markov-switching 
heteroskedasticity or allocations of normal-mixture components including their 
median and percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorRegimePr'
plot(
  x,
  probability = 0.9,
  col = "#ff69b4",
  main,
  xlab,
  mar.multi = c(1, 4.6, 0, 2.1),
  oma.multi = c(6, 0, 5, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PosteriorRegimePr_+3A_x">x</code></td>
<td>
<p>an object of class PosteriorRegimePr obtained using the
<code>compute_regime_probabilities()</code> function containing posterior draws of 
regime probabilities.</p>
</td></tr>
<tr><td><code id="plot.PosteriorRegimePr_+3A_probability">probability</code></td>
<td>
<p>a parameter determining the interval to be plotted. The 
interval stretches from the <code>0.5 * (1 - probability)</code> to 
<code>1 - 0.5 * (1 - probability)</code> percentile of the posterior distribution.</p>
</td></tr>
<tr><td><code id="plot.PosteriorRegimePr_+3A_col">col</code></td>
<td>
<p>a colour of the plot line and the ribbon</p>
</td></tr>
<tr><td><code id="plot.PosteriorRegimePr_+3A_main">main</code></td>
<td>
<p>an alternative main title for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorRegimePr_+3A_xlab">xlab</code></td>
<td>
<p>an alternative x-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorRegimePr_+3A_mar.multi">mar.multi</code></td>
<td>
<p>the default <code>mar</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorRegimePr_+3A_oma.multi">oma.multi</code></td>
<td>
<p>the default <code>oma</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorRegimePr_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_regime_probabilities">compute_regime_probabilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)                                  # upload data
set.seed(123)                                         # set seed
specification  = specify_bsvar_msh$new(us_fiscal_lsuw)# specify model
burn_in        = estimate(specification, 10)          # run the burn-in
posterior      = estimate(burn_in, 20, thin = 1)      # estimate the model

# compute regime probabilities
rp             = compute_regime_probabilities(posterior)
plot(rp)                                              # plot

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  compute_regime_probabilities() |&gt;
  plot()

</code></pre>

<hr>
<h2 id='plot.PosteriorShocks'>Plots structural shocks</h2><span id='topic+plot.PosteriorShocks'></span>

<h3>Description</h3>

<p>Plots of structural shocks including their median and percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorShocks'
plot(
  x,
  probability = 0.9,
  col = "#ff69b4",
  main,
  xlab,
  mar.multi = c(1, 4.6, 0, 2.1),
  oma.multi = c(6, 0, 5, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PosteriorShocks_+3A_x">x</code></td>
<td>
<p>an object of class PosteriorShocks obtained using the
<code>compute_structural_shocks()</code> function containing posterior draws of 
structural shocks.</p>
</td></tr>
<tr><td><code id="plot.PosteriorShocks_+3A_probability">probability</code></td>
<td>
<p>a parameter determining the interval to be plotted. The 
interval stretches from the <code>0.5 * (1 - probability)</code> to 
<code>1 - 0.5 * (1 - probability)</code> percentile of the posterior distribution.</p>
</td></tr>
<tr><td><code id="plot.PosteriorShocks_+3A_col">col</code></td>
<td>
<p>a colour of the plot line and the ribbon</p>
</td></tr>
<tr><td><code id="plot.PosteriorShocks_+3A_main">main</code></td>
<td>
<p>an alternative main title for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorShocks_+3A_xlab">xlab</code></td>
<td>
<p>an alternative x-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorShocks_+3A_mar.multi">mar.multi</code></td>
<td>
<p>the default <code>mar</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorShocks_+3A_oma.multi">oma.multi</code></td>
<td>
<p>the default <code>oma</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorShocks_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_structural_shocks">compute_structural_shocks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)                                  # upload data
set.seed(123)                                         # set seed
specification  = specify_bsvar$new(us_fiscal_lsuw)    # specify model
burn_in        = estimate(specification, 10)          # run the burn-in
posterior      = estimate(burn_in, 20, thin = 1)      # estimate the model

# compute structural shocks
shocks         = compute_structural_shocks(posterior)
plot(shocks)                                          # plot

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  compute_structural_shocks() |&gt;
  plot()

</code></pre>

<hr>
<h2 id='plot.PosteriorSigma'>Plots structural shocks' conditional standard deviations</h2><span id='topic+plot.PosteriorSigma'></span>

<h3>Description</h3>

<p>Plots of structural shocks' conditional standard deviations 
including their median and percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorSigma'
plot(
  x,
  probability = 0.9,
  col = "#ff69b4",
  main,
  xlab,
  mar.multi = c(1, 4.6, 0, 2.1),
  oma.multi = c(6, 0, 5, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PosteriorSigma_+3A_x">x</code></td>
<td>
<p>an object of class PosteriorSigma obtained using the
<code>compute_conditional_sd()</code> function containing posterior draws of 
conditional standard deviations of structural shocks.</p>
</td></tr>
<tr><td><code id="plot.PosteriorSigma_+3A_probability">probability</code></td>
<td>
<p>a parameter determining the interval to be plotted. The 
interval stretches from the <code>0.5 * (1 - probability)</code> to 
<code>1 - 0.5 * (1 - probability)</code> percentile of the posterior distribution.</p>
</td></tr>
<tr><td><code id="plot.PosteriorSigma_+3A_col">col</code></td>
<td>
<p>a colour of the plot line and the ribbon</p>
</td></tr>
<tr><td><code id="plot.PosteriorSigma_+3A_main">main</code></td>
<td>
<p>an alternative main title for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorSigma_+3A_xlab">xlab</code></td>
<td>
<p>an alternative x-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot.PosteriorSigma_+3A_mar.multi">mar.multi</code></td>
<td>
<p>the default <code>mar</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorSigma_+3A_oma.multi">oma.multi</code></td>
<td>
<p>the default <code>oma</code> argument setting in <code>graphics::par</code>. Modify with care!</p>
</td></tr>
<tr><td><code id="plot.PosteriorSigma_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_conditional_sd">compute_conditional_sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)                                  # upload data
set.seed(123)                                         # set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw) # specify model
burn_in        = estimate(specification, 5)           # run the burn-in
posterior      = estimate(burn_in, 5)                 # estimate the model

# compute structural shocks' conditional standard deviations
sigma          = compute_conditional_sd(posterior)
plot(sigma)                                            # plot conditional sds

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 5) |&gt; 
  estimate(S = 5) |&gt; 
  compute_conditional_sd() |&gt;
  plot()

</code></pre>

<hr>
<h2 id='specify_bsvar'>R6 Class representing the specification of the homoskedastic BSVAR model</h2><span id='topic+specify_bsvar'></span>

<h3>Description</h3>

<p>The class BSVAR presents complete specification for the homoskedastic bsvar model.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>a non-negative integer specifying the autoregressive lag order of the model.</p>
</dd>
<dt><code>identification</code></dt><dd><p>an object IdentificationBSVAR with the identifying restrictions.</p>
</dd>
<dt><code>prior</code></dt><dd><p>an object PriorBSVAR with the prior specification.</p>
</dd>
<dt><code>data_matrices</code></dt><dd><p>an object DataMatricesBSVAR with the data matrices.</p>
</dd>
<dt><code>starting_values</code></dt><dd><p>an object StartingValuesBSVAR with the starting values.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BSVAR-new"><code>specify_bsvar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVAR-get_data_matrices"><code>specify_bsvar$get_data_matrices()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVAR-get_identification"><code>specify_bsvar$get_identification()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVAR-get_prior"><code>specify_bsvar$get_prior()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVAR-get_starting_values"><code>specify_bsvar$get_starting_values()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVAR-clone"><code>specify_bsvar$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BSVAR-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new specification of the homoskedastic bsvar model BSVAR.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar$new(
  data,
  p = 1L,
  B,
  exogenous = NULL,
  stationary = rep(FALSE, ncol(data))
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a <code>(T+p)xN</code> matrix with time series data.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer providing model's autoregressive lag order.</p>
</dd>
<dt><code>B</code></dt><dd><p>a logical <code>NxN</code> matrix containing value <code>TRUE</code> for the elements of 
the structural matrix <code class="reqn">B</code> to be estimated and value <code>FALSE</code> for exclusion restrictions 
to be set to zero.</p>
</dd>
<dt><code>exogenous</code></dt><dd><p>a <code>(T+p)xd</code> matrix of exogenous variables.</p>
</dd>
<dt><code>stationary</code></dt><dd><p>an <code>N</code> logical vector - its element set to <code>FALSE</code> sets 
the prior mean for the autoregressive parameters of the <code>N</code>th equation to the white noise process, 
otherwise to random walk.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new complete specification for the homoskedastic bsvar model BSVAR.
</p>


<hr>
<a id="method-BSVAR-get_data_matrices"></a>



<h4>Method <code>get_data_matrices()</code></h4>

<p>Returns the data matrices as the DataMatricesBSVAR object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar$get_data_matrices()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
spec = specify_bsvar$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_data_matrices()

</pre>
</div>


<hr>
<a id="method-BSVAR-get_identification"></a>



<h4>Method <code>get_identification()</code></h4>

<p>Returns the identifying restrictions as the IdentificationBSVARs object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar$get_identification()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
spec = specify_bsvar$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_identification()

</pre>
</div>


<hr>
<a id="method-BSVAR-get_prior"></a>



<h4>Method <code>get_prior()</code></h4>

<p>Returns the prior specification as the PriorBSVAR object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar$get_prior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
spec = specify_bsvar$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_prior()

</pre>
</div>


<hr>
<a id="method-BSVAR-get_starting_values"></a>



<h4>Method <code>get_starting_values()</code></h4>

<p>Returns the starting values as the StartingValuesBSVAR object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar$get_starting_values()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
spec = specify_bsvar$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_starting_values()

</pre>
</div>


<hr>
<a id="method-BSVAR-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+specify_posterior_bsvar">specify_posterior_bsvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)
spec = specify_bsvar$new(
   data = us_fiscal_lsuw,
   p = 4
)


## ------------------------------------------------
## Method `specify_bsvar$get_data_matrices`
## ------------------------------------------------

data(us_fiscal_lsuw)
spec = specify_bsvar$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_data_matrices()


## ------------------------------------------------
## Method `specify_bsvar$get_identification`
## ------------------------------------------------

data(us_fiscal_lsuw)
spec = specify_bsvar$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_identification()


## ------------------------------------------------
## Method `specify_bsvar$get_prior`
## ------------------------------------------------

data(us_fiscal_lsuw)
spec = specify_bsvar$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_prior()


## ------------------------------------------------
## Method `specify_bsvar$get_starting_values`
## ------------------------------------------------

data(us_fiscal_lsuw)
spec = specify_bsvar$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_starting_values()

</code></pre>

<hr>
<h2 id='specify_bsvar_mix'>R6 Class representing the specification of the BSVAR model with a zero-mean mixture of normals model for structural shocks.</h2><span id='topic+specify_bsvar_mix'></span>

<h3>Description</h3>

<p>The class BSVARMIX presents complete specification for the BSVAR model with a zero-mean mixture of normals model for structural shocks.
</p>


<h3>Super class</h3>

<p><code>bsvars::BSVARMSH</code> -&gt; <code>BSVARMIX</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>a non-negative integer specifying the autoregressive lag order of the model.</p>
</dd>
<dt><code>identification</code></dt><dd><p>an object IdentificationBSVARs with the identifying restrictions.</p>
</dd>
<dt><code>prior</code></dt><dd><p>an object PriorBSVARMIX with the prior specification.</p>
</dd>
<dt><code>data_matrices</code></dt><dd><p>an object DataMatricesBSVAR with the data matrices.</p>
</dd>
<dt><code>starting_values</code></dt><dd><p>an object StartingValuesBSVARMIX with the starting values.</p>
</dd>
<dt><code>finiteM</code></dt><dd><p>a logical value - if true a finite mixture model is estimated. Otherwise, a sparse mixture model is estimated in which <code>M=20</code> and the number of visited states is estimated.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BSVARMIX-new"><code>specify_bsvar_mix$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARMIX-clone"><code>specify_bsvar_mix$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bsvars" data-topic="BSVARMSH" data-id="get_data_matrices"><a href='../../bsvars/html/BSVARMSH.html#method-BSVARMSH-get_data_matrices'><code>bsvars::BSVARMSH$get_data_matrices()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bsvars" data-topic="BSVARMSH" data-id="get_identification"><a href='../../bsvars/html/BSVARMSH.html#method-BSVARMSH-get_identification'><code>bsvars::BSVARMSH$get_identification()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bsvars" data-topic="BSVARMSH" data-id="get_prior"><a href='../../bsvars/html/BSVARMSH.html#method-BSVARMSH-get_prior'><code>bsvars::BSVARMSH$get_prior()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bsvars" data-topic="BSVARMSH" data-id="get_starting_values"><a href='../../bsvars/html/BSVARMSH.html#method-BSVARMSH-get_starting_values'><code>bsvars::BSVARMSH$get_starting_values()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-BSVARMIX-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new specification of the BSVAR model with a zero-mean mixture of normals model for structural shocks, BSVARMIX.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_mix$new(
  data,
  p = 1L,
  M = 2L,
  B,
  exogenous = NULL,
  stationary = rep(FALSE, ncol(data)),
  finiteM = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a <code>(T+p)xN</code> matrix with time series data.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer providing model's autoregressive lag order.</p>
</dd>
<dt><code>M</code></dt><dd><p>an integer greater than 1 - the number of components of the mixture of normals.</p>
</dd>
<dt><code>B</code></dt><dd><p>a logical <code>NxN</code> matrix containing value <code>TRUE</code> for the elements of the structural matrix <code class="reqn">B</code> to be estimated and value <code>FALSE</code> for exclusion restrictions to be set to zero.</p>
</dd>
<dt><code>exogenous</code></dt><dd><p>a <code>(T+p)xd</code> matrix of exogenous variables.</p>
</dd>
<dt><code>stationary</code></dt><dd><p>an <code>N</code> logical vector - its element set to <code>FALSE</code> sets the prior mean for the autoregressive parameters of the <code>N</code>th equation to the white noise process, otherwise to random walk.</p>
</dd>
<dt><code>finiteM</code></dt><dd><p>a logical value - if true a finite mixture model is estimated. Otherwise, a sparse mixture model is estimated in which <code>M=20</code> and the number of visited states is estimated.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new complete specification for the bsvar model with a zero-mean mixture of normals model for structural shocks, BSVARMIX.
</p>


<hr>
<a id="method-BSVARMIX-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_mix$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+specify_posterior_bsvar_mix">specify_posterior_bsvar_mix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)
spec = specify_bsvar_mix$new(
   data = us_fiscal_lsuw,
   p = 4,
   M = 2
)

</code></pre>

<hr>
<h2 id='specify_bsvar_msh'>R6 Class representing the specification of the BSVAR model with Markov Switching Heteroskedasticity.</h2><span id='topic+specify_bsvar_msh'></span>

<h3>Description</h3>

<p>The class BSVARMSH presents complete specification for the BSVAR model with Markov Switching Heteroskedasticity.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>a non-negative integer specifying the autoregressive lag order of the model.</p>
</dd>
<dt><code>identification</code></dt><dd><p>an object IdentificationBSVARs with the identifying restrictions.</p>
</dd>
<dt><code>prior</code></dt><dd><p>an object PriorBSVARMSH with the prior specification.</p>
</dd>
<dt><code>data_matrices</code></dt><dd><p>an object DataMatricesBSVAR with the data matrices.</p>
</dd>
<dt><code>starting_values</code></dt><dd><p>an object StartingValuesBSVARMSH with the starting values.</p>
</dd>
<dt><code>finiteM</code></dt><dd><p>a logical value - if true a stationary Markov switching model is estimated. Otherwise, a sparse Markov switching model is estimated in which <code>M=20</code> and the number of visited states is estimated.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BSVARMSH-new"><code>specify_bsvar_msh$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARMSH-get_data_matrices"><code>specify_bsvar_msh$get_data_matrices()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARMSH-get_identification"><code>specify_bsvar_msh$get_identification()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARMSH-get_prior"><code>specify_bsvar_msh$get_prior()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARMSH-get_starting_values"><code>specify_bsvar_msh$get_starting_values()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARMSH-clone"><code>specify_bsvar_msh$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BSVARMSH-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new specification of the BSVAR model with Markov Switching Heteroskedasticity, BSVARMSH.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_msh$new(
  data,
  p = 1L,
  M = 2L,
  B,
  exogenous = NULL,
  stationary = rep(FALSE, ncol(data)),
  finiteM = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a <code>(T+p)xN</code> matrix with time series data.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer providing model's autoregressive lag order.</p>
</dd>
<dt><code>M</code></dt><dd><p>an integer greater than 1 - the number of Markov process' heteroskedastic regimes.</p>
</dd>
<dt><code>B</code></dt><dd><p>a logical <code>NxN</code> matrix containing value <code>TRUE</code> for the elements of the structural matrix <code class="reqn">B</code> to be estimated and value <code>FALSE</code> for exclusion restrictions to be set to zero.</p>
</dd>
<dt><code>exogenous</code></dt><dd><p>a <code>(T+p)xd</code> matrix of exogenous variables.</p>
</dd>
<dt><code>stationary</code></dt><dd><p>an <code>N</code> logical vector - its element set to <code>FALSE</code> sets the prior mean for the autoregressive parameters of the <code>N</code>th equation to the white noise process, otherwise to random walk.</p>
</dd>
<dt><code>finiteM</code></dt><dd><p>a logical value - if true a stationary Markov switching model is estimated. Otherwise, a sparse Markov switching model is estimated in which <code>M=20</code> and the number of visited states is estimated.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new complete specification for the bsvar model with Markov Switching Heteroskedasticity, BSVARMSH.
</p>


<hr>
<a id="method-BSVARMSH-get_data_matrices"></a>



<h4>Method <code>get_data_matrices()</code></h4>

<p>Returns the data matrices as the DataMatricesBSVAR object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_msh$get_data_matrices()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
spec = specify_bsvar_msh$new(
   data = us_fiscal_lsuw,
   p = 4,
   M = 2
)
spec$get_data_matrices()

</pre>
</div>


<hr>
<a id="method-BSVARMSH-get_identification"></a>



<h4>Method <code>get_identification()</code></h4>

<p>Returns the identifying restrictions as the IdentificationBSVARs object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_msh$get_identification()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
spec = specify_bsvar_msh$new(
   data = us_fiscal_lsuw,
   p = 4,
   M = 2
)
spec$get_identification()

</pre>
</div>


<hr>
<a id="method-BSVARMSH-get_prior"></a>



<h4>Method <code>get_prior()</code></h4>

<p>Returns the prior specification as the PriorBSVARMSH object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_msh$get_prior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
spec = specify_bsvar_msh$new(
   data = us_fiscal_lsuw,
   p = 4,
   M = 2
)
spec$get_prior()

</pre>
</div>


<hr>
<a id="method-BSVARMSH-get_starting_values"></a>



<h4>Method <code>get_starting_values()</code></h4>

<p>Returns the starting values as the StartingValuesBSVARMSH object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_msh$get_starting_values()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
spec = specify_bsvar_msh$new(
   data = us_fiscal_lsuw,
   p = 4,
   M = 2
)
spec$get_starting_values()

</pre>
</div>


<hr>
<a id="method-BSVARMSH-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_msh$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+specify_posterior_bsvar_msh">specify_posterior_bsvar_msh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)
spec = specify_bsvar_msh$new(
   data = us_fiscal_lsuw,
   p = 4,
   M = 2
)


## ------------------------------------------------
## Method `specify_bsvar_msh$get_data_matrices`
## ------------------------------------------------

data(us_fiscal_lsuw)
spec = specify_bsvar_msh$new(
   data = us_fiscal_lsuw,
   p = 4,
   M = 2
)
spec$get_data_matrices()


## ------------------------------------------------
## Method `specify_bsvar_msh$get_identification`
## ------------------------------------------------

data(us_fiscal_lsuw)
spec = specify_bsvar_msh$new(
   data = us_fiscal_lsuw,
   p = 4,
   M = 2
)
spec$get_identification()


## ------------------------------------------------
## Method `specify_bsvar_msh$get_prior`
## ------------------------------------------------

data(us_fiscal_lsuw)
spec = specify_bsvar_msh$new(
   data = us_fiscal_lsuw,
   p = 4,
   M = 2
)
spec$get_prior()


## ------------------------------------------------
## Method `specify_bsvar_msh$get_starting_values`
## ------------------------------------------------

data(us_fiscal_lsuw)
spec = specify_bsvar_msh$new(
   data = us_fiscal_lsuw,
   p = 4,
   M = 2
)
spec$get_starting_values()

</code></pre>

<hr>
<h2 id='specify_bsvar_sv'>R6 Class representing the specification of the BSVAR model with Stochastic Volatility heteroskedasticity.</h2><span id='topic+specify_bsvar_sv'></span>

<h3>Description</h3>

<p>The class BSVARSV presents complete specification for the BSVAR model with Stochastic Volatility heteroskedasticity.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>a non-negative integer specifying the autoregressive lag order of the model.</p>
</dd>
<dt><code>identification</code></dt><dd><p>an object IdentificationBSVARs with the identifying restrictions.</p>
</dd>
<dt><code>prior</code></dt><dd><p>an object PriorBSVARSV with the prior specification.</p>
</dd>
<dt><code>data_matrices</code></dt><dd><p>an object DataMatricesBSVAR with the data matrices.</p>
</dd>
<dt><code>starting_values</code></dt><dd><p>an object StartingValuesBSVARSV with the starting values.</p>
</dd>
<dt><code>centred_sv</code></dt><dd><p>a logical value - if true a centred parameterisation of the Stochastic Volatility process is estimated. Otherwise, its non-centred parameterisation is estimated. See Lütkepohl, Shang, Uzeda, Woźniak (2022) for more info.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BSVARSV-new"><code>specify_bsvar_sv$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARSV-get_data_matrices"><code>specify_bsvar_sv$get_data_matrices()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARSV-get_identification"><code>specify_bsvar_sv$get_identification()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARSV-get_prior"><code>specify_bsvar_sv$get_prior()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARSV-get_starting_values"><code>specify_bsvar_sv$get_starting_values()</code></a>
</p>
</li>
<li> <p><a href="#method-BSVARSV-clone"><code>specify_bsvar_sv$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BSVARSV-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new specification of the BSVAR model with Stochastic Volatility heteroskedasticity, BSVARSV.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_sv$new(
  data,
  p = 1L,
  B,
  exogenous = NULL,
  centred_sv = FALSE,
  stationary = rep(FALSE, ncol(data))
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a <code>(T+p)xN</code> matrix with time series data.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer providing model's autoregressive lag order.</p>
</dd>
<dt><code>B</code></dt><dd><p>a logical <code>NxN</code> matrix containing value <code>TRUE</code> for the elements of the structural matrix <code class="reqn">B</code> to be estimated and value <code>FALSE</code> for exclusion restrictions to be set to zero.</p>
</dd>
<dt><code>exogenous</code></dt><dd><p>a <code>(T+p)xd</code> matrix of exogenous variables.</p>
</dd>
<dt><code>centred_sv</code></dt><dd><p>a logical value. If <code>FALSE</code> a non-centred Stochastic Volatility processes for conditional variances are estimated. Otherwise, a centred process is estimated.</p>
</dd>
<dt><code>stationary</code></dt><dd><p>an <code>N</code> logical vector - its element set to <code>FALSE</code> sets the prior mean for the autoregressive parameters of the <code>N</code>th equation to the white noise process, otherwise to random walk.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new complete specification for the bsvar model with Stochastic Volatility heteroskedasticity, BSVARSV.
</p>


<hr>
<a id="method-BSVARSV-get_data_matrices"></a>



<h4>Method <code>get_data_matrices()</code></h4>

<p>Returns the data matrices as the DataMatricesBSVAR object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_sv$get_data_matrices()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
spec = specify_bsvar_sv$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_data_matrices()

</pre>
</div>


<hr>
<a id="method-BSVARSV-get_identification"></a>



<h4>Method <code>get_identification()</code></h4>

<p>Returns the identifying restrictions as the IdentificationBSVARs object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_sv$get_identification()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
spec = specify_bsvar_sv$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_identification()

</pre>
</div>


<hr>
<a id="method-BSVARSV-get_prior"></a>



<h4>Method <code>get_prior()</code></h4>

<p>Returns the prior specification as the PriorBSVARSV object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_sv$get_prior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
spec = specify_bsvar_sv$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_prior()

</pre>
</div>


<hr>
<a id="method-BSVARSV-get_starting_values"></a>



<h4>Method <code>get_starting_values()</code></h4>

<p>Returns the starting values as the StartingValuesBSVARSV object.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_sv$get_starting_values()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
spec = specify_bsvar_sv$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_starting_values()

</pre>
</div>


<hr>
<a id="method-BSVARSV-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_bsvar_sv$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+specify_posterior_bsvar_sv">specify_posterior_bsvar_sv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)
spec = specify_bsvar_sv$new(
   data = us_fiscal_lsuw,
   p = 4
)


## ------------------------------------------------
## Method `specify_bsvar_sv$get_data_matrices`
## ------------------------------------------------

data(us_fiscal_lsuw)
spec = specify_bsvar_sv$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_data_matrices()


## ------------------------------------------------
## Method `specify_bsvar_sv$get_identification`
## ------------------------------------------------

data(us_fiscal_lsuw)
spec = specify_bsvar_sv$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_identification()


## ------------------------------------------------
## Method `specify_bsvar_sv$get_prior`
## ------------------------------------------------

data(us_fiscal_lsuw)
spec = specify_bsvar_sv$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_prior()


## ------------------------------------------------
## Method `specify_bsvar_sv$get_starting_values`
## ------------------------------------------------

data(us_fiscal_lsuw)
spec = specify_bsvar_sv$new(
   data = us_fiscal_lsuw,
   p = 4
)
spec$get_starting_values()

</code></pre>

<hr>
<h2 id='specify_data_matrices'>R6 Class Representing DataMatricesBSVAR</h2><span id='topic+specify_data_matrices'></span>

<h3>Description</h3>

<p>The class DataMatricesBSVAR presents the data matrices of dependent variables, <code class="reqn">Y</code>, 
and regressors, <code class="reqn">X</code>, for the homoskedastic bsvar model.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Y</code></dt><dd><p>an <code>NxT</code> matrix of dependent variables, <code class="reqn">Y</code>.</p>
</dd>
<dt><code>X</code></dt><dd><p>an <code>KxT</code> matrix of regressors, <code class="reqn">X</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DataMatricesBSVAR-new"><code>specify_data_matrices$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DataMatricesBSVAR-get_data_matrices"><code>specify_data_matrices$get_data_matrices()</code></a>
</p>
</li>
<li> <p><a href="#method-DataMatricesBSVAR-clone"><code>specify_data_matrices$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DataMatricesBSVAR-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create new data matrices DataMatricesBSVAR.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_data_matrices$new(data, p = 1L, exogenous = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a <code>(T+p)xN</code> matrix with time series data.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer providing model's autoregressive lag order.</p>
</dd>
<dt><code>exogenous</code></dt><dd><p>a <code>(T+p)xd</code> matrix of exogenous variables. 
This matrix should not include a constant term.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New data matrices DataMatricesBSVAR.
</p>


<hr>
<a id="method-DataMatricesBSVAR-get_data_matrices"></a>



<h4>Method <code>get_data_matrices()</code></h4>

<p>Returns the data matrices DataMatricesBSVAR as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_data_matrices$get_data_matrices()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
YX = specify_data_matrices$new(data = us_fiscal_lsuw, p = 4)
YX$get_data_matrices()

</pre>
</div>


<hr>
<a id="method-DataMatricesBSVAR-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_data_matrices$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)
YX = specify_data_matrices$new(data = us_fiscal_lsuw, p = 4)
dim(YX$Y); dim(YX$X)


## ------------------------------------------------
## Method `specify_data_matrices$get_data_matrices`
## ------------------------------------------------

data(us_fiscal_lsuw)
YX = specify_data_matrices$new(data = us_fiscal_lsuw, p = 4)
YX$get_data_matrices()

</code></pre>

<hr>
<h2 id='specify_identification_bsvars'>R6 Class Representing IdentificationBSVARs</h2><span id='topic+specify_identification_bsvars'></span>

<h3>Description</h3>

<p>The class IdentificationBSVARs presents the identifying restrictions for the bsvar models.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>VB</code></dt><dd><p>a list of <code>N</code> matrices determining the unrestricted elements of matrix <code class="reqn">B</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IdentificationBSVARs-new"><code>specify_identification_bsvars$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IdentificationBSVARs-get_identification"><code>specify_identification_bsvars$get_identification()</code></a>
</p>
</li>
<li> <p><a href="#method-IdentificationBSVARs-set_identification"><code>specify_identification_bsvars$set_identification()</code></a>
</p>
</li>
<li> <p><a href="#method-IdentificationBSVARs-clone"><code>specify_identification_bsvars$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-IdentificationBSVARs-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create new identifying restrictions IdentificationBSVARs.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_identification_bsvars$new(N, B)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>a positive integer - the number of dependent variables in the model.</p>
</dd>
<dt><code>B</code></dt><dd><p>a logical <code>NxN</code> matrix containing value <code>TRUE</code> for the elements of 
the structural matrix <code class="reqn">B</code> to be estimated and value <code>FALSE</code> for exclusion restrictions 
to be set to zero.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Identifying restrictions IdentificationBSVARs.
</p>


<hr>
<a id="method-IdentificationBSVARs-get_identification"></a>



<h4>Method <code>get_identification()</code></h4>

<p>Returns the elements of the identification pattern IdentificationBSVARs as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_identification_bsvars$get_identification()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>B    = matrix(c(TRUE,TRUE,TRUE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE), 3, 3); B
spec = specify_identification_bsvars$new(N = 3, B = B)
spec$get_identification()

</pre>
</div>


<hr>
<a id="method-IdentificationBSVARs-set_identification"></a>



<h4>Method <code>set_identification()</code></h4>

<p>Set new starting values StartingValuesBSVAR.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_identification_bsvars$set_identification(N, B)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>a positive integer - the number of dependent variables in the model.</p>
</dd>
<dt><code>B</code></dt><dd><p>a logical <code>NxN</code> matrix containing value <code>TRUE</code> for the elements of 
the structural matrix <code class="reqn">B</code> to be estimated and value <code>FALSE</code> for exclusion restrictions 
to be set to zero.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>spec = specify_identification_bsvars$new(N = 3) # specify a model with the default option
B    = matrix(c(TRUE,TRUE,TRUE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE), 3, 3); B
spec$set_identification(N = 3, B = B)  # modify an existing specification
spec$get_identification()              # check the outcome
</pre>
</div>


<hr>
<a id="method-IdentificationBSVARs-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_identification_bsvars$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>specify_identification_bsvars$new(N = 3) # recursive specification for a 3-variable system

B = matrix(c(TRUE,TRUE,TRUE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE), 3, 3); B
specify_identification_bsvars$new(N = 3, B = B) # an alternative identification pattern


## ------------------------------------------------
## Method `specify_identification_bsvars$get_identification`
## ------------------------------------------------

B    = matrix(c(TRUE,TRUE,TRUE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE), 3, 3); B
spec = specify_identification_bsvars$new(N = 3, B = B)
spec$get_identification()


## ------------------------------------------------
## Method `specify_identification_bsvars$set_identification`
## ------------------------------------------------

spec = specify_identification_bsvars$new(N = 3) # specify a model with the default option
B    = matrix(c(TRUE,TRUE,TRUE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE), 3, 3); B
spec$set_identification(N = 3, B = B)  # modify an existing specification
spec$get_identification()              # check the outcome
</code></pre>

<hr>
<h2 id='specify_posterior_bsvar'>R6 Class Representing PosteriorBSVAR</h2><span id='topic+specify_posterior_bsvar'></span>

<h3>Description</h3>

<p>The class PosteriorBSVAR contains posterior output and the specification including 
the last MCMC draw for the homoskedastic bsvar model. 
Note that due to the thinning of the MCMC output the starting value in element <code>last_draw</code>
might not be equal to the last draw provided in element <code>posterior</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>last_draw</code></dt><dd><p>an object of class BSVAR with the last draw of the current MCMC run as 
the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>a list containing Bayesian estimation output collected in elements 
an <code>NxNxS</code> array <code>B</code>, an <code>NxKxS</code> array <code>A</code>, and a <code>5xS</code> matrix <code>hyper</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PosteriorBSVAR-new"><code>specify_posterior_bsvar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVAR-get_posterior"><code>specify_posterior_bsvar$get_posterior()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVAR-get_last_draw"><code>specify_posterior_bsvar$get_last_draw()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVAR-is_normalised"><code>specify_posterior_bsvar$is_normalised()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVAR-set_normalised"><code>specify_posterior_bsvar$set_normalised()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVAR-clone"><code>specify_posterior_bsvar$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PosteriorBSVAR-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new posterior output PosteriorBSVAR.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar$new(specification_bsvar, posterior_bsvar)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification_bsvar</code></dt><dd><p>an object of class BSVAR with the last draw of the current 
MCMC run as the starting value.</p>
</dd>
<dt><code>posterior_bsvar</code></dt><dd><p>a list containing Bayesian estimation output collected in elements 
an <code>NxNxS</code> array <code>B</code>, an <code>NxKxS</code> array <code>A</code>, and a <code>5xS</code> matrix <code>hyper</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A posterior output PosteriorBSVAR.
</p>


<hr>
<a id="method-PosteriorBSVAR-get_posterior"></a>



<h4>Method <code>get_posterior()</code></h4>

<p>Returns a list containing Bayesian estimation output collected in elements 
an <code>NxNxS</code> array <code>B</code>, an <code>NxKxS</code> array <code>A</code>, and a <code>5xS</code> matrix <code>hyper</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar$get_posterior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
specification  = specify_bsvar$new(us_fiscal_lsuw)
set.seed(123)
estimate       = estimate(specification, 50)
estimate$get_posterior()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVAR-get_last_draw"></a>



<h4>Method <code>get_last_draw()</code></h4>

<p>Returns an object of class BSVAR with the last draw of the current MCMC run as 
the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar$get_last_draw()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 4)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 10)

</pre>
</div>


<hr>
<a id="method-PosteriorBSVAR-is_normalised"></a>



<h4>Method <code>is_normalised()</code></h4>

<p>Returns <code>TRUE</code> if the posterior has been normalised using <code>normalise_posterior()</code> 
and <code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar$is_normalised()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 4)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag((-1) * sign(diag(BB))) %*% BB         # set negative diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVAR-set_normalised"></a>



<h4>Method <code>set_normalised()</code></h4>

<p>Sets the private indicator <code>normalised</code> to TRUE.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar$set_normalised(value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>(optional) a logical value to be passed to indicator <code>normalised</code>.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># This is an internal function that is run while executing normalise_posterior()
# Observe its working by analysing the workflow:

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 4)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag(sign(diag(BB))) %*% BB                # set positive diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVAR-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+specify_bsvar">specify_bsvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a function that is used within estimate()
data(us_fiscal_lsuw)
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 4)
set.seed(123)
estimate       = estimate(specification, 50)
class(estimate)


## ------------------------------------------------
## Method `specify_posterior_bsvar$get_posterior`
## ------------------------------------------------

data(us_fiscal_lsuw)
specification  = specify_bsvar$new(us_fiscal_lsuw)
set.seed(123)
estimate       = estimate(specification, 50)
estimate$get_posterior()


## ------------------------------------------------
## Method `specify_posterior_bsvar$get_last_draw`
## ------------------------------------------------

data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 4)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 10)


## ------------------------------------------------
## Method `specify_posterior_bsvar$is_normalised`
## ------------------------------------------------

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 4)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag((-1) * sign(diag(BB))) %*% BB         # set negative diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()


## ------------------------------------------------
## Method `specify_posterior_bsvar$set_normalised`
## ------------------------------------------------

# This is an internal function that is run while executing normalise_posterior()
# Observe its working by analysing the workflow:

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 4)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag(sign(diag(BB))) %*% BB                # set positive diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</code></pre>

<hr>
<h2 id='specify_posterior_bsvar_mix'>R6 Class Representing PosteriorBSVARMIX</h2><span id='topic+specify_posterior_bsvar_mix'></span>

<h3>Description</h3>

<p>The class PosteriorBSVARMIX contains posterior output and the specification including 
the last MCMC draw for the bsvar model with a zero-mean mixture of normals model for structural shocks.
Note that due to the thinning of the MCMC output the starting value in element <code>last_draw</code>
might not be equal to the last draw provided in element <code>posterior</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>last_draw</code></dt><dd><p>an object of class BSVARMIX with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>a list containing Bayesian estimation output.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PosteriorBSVARMIX-new"><code>specify_posterior_bsvar_mix$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMIX-get_posterior"><code>specify_posterior_bsvar_mix$get_posterior()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMIX-get_last_draw"><code>specify_posterior_bsvar_mix$get_last_draw()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMIX-is_normalised"><code>specify_posterior_bsvar_mix$is_normalised()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMIX-set_normalised"><code>specify_posterior_bsvar_mix$set_normalised()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMIX-clone"><code>specify_posterior_bsvar_mix$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PosteriorBSVARMIX-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new posterior output PosteriorBSVARMIX.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_mix$new(specification_bsvar, posterior_bsvar)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification_bsvar</code></dt><dd><p>an object of class BSVARMIX with the last draw of the current MCMC run as the starting value.</p>
</dd>
<dt><code>posterior_bsvar</code></dt><dd><p>a list containing Bayesian estimation output.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A posterior output PosteriorBSVARMIX.
</p>


<hr>
<a id="method-PosteriorBSVARMIX-get_posterior"></a>



<h4>Method <code>get_posterior()</code></h4>

<p>Returns a list containing Bayesian estimation output.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_mix$get_posterior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, M = 2)
set.seed(123)
estimate       = estimate(specification, 10, thin = 1)
estimate$get_posterior()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARMIX-get_last_draw"></a>



<h4>Method <code>get_last_draw()</code></h4>

<p>Returns an object of class BSVARMIX with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_mix$get_last_draw()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)

# run the burn-in
set.seed(123)
burn_in        = estimate(specification, 10, thin = 2)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARMIX-is_normalised"></a>



<h4>Method <code>is_normalised()</code></h4>

<p>Returns <code>TRUE</code> if the posterior has been normalised using <code>normalise_posterior()</code> and <code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_mix$is_normalised()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)

# estimate the model
set.seed(123)
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag((-1) * sign(diag(BB))) %*% BB         # set negative diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARMIX-set_normalised"></a>



<h4>Method <code>set_normalised()</code></h4>

<p>Sets the private indicator <code>normalised</code> to TRUE.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_mix$set_normalised(value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>(optional) a logical value to be passed to indicator <code>normalised</code>.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># This is an internal function that is run while executing normalise_posterior()
# Observe its working by analysing the workflow:

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag(sign(diag(BB))) %*% BB                # set positive diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARMIX-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_mix$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+specify_bsvar_mix">specify_bsvar_mix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a function that is used within estimate()
data(us_fiscal_lsuw)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)
set.seed(123)
estimate       = estimate(specification, 10, thin = 1)
class(estimate)


## ------------------------------------------------
## Method `specify_posterior_bsvar_mix$get_posterior`
## ------------------------------------------------

data(us_fiscal_lsuw)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, M = 2)
set.seed(123)
estimate       = estimate(specification, 10, thin = 1)
estimate$get_posterior()


## ------------------------------------------------
## Method `specify_posterior_bsvar_mix$get_last_draw`
## ------------------------------------------------

data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)

# run the burn-in
set.seed(123)
burn_in        = estimate(specification, 10, thin = 2)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)


## ------------------------------------------------
## Method `specify_posterior_bsvar_mix$is_normalised`
## ------------------------------------------------

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)

# estimate the model
set.seed(123)
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag((-1) * sign(diag(BB))) %*% BB         # set negative diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()


## ------------------------------------------------
## Method `specify_posterior_bsvar_mix$set_normalised`
## ------------------------------------------------

# This is an internal function that is run while executing normalise_posterior()
# Observe its working by analysing the workflow:

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 4, M = 2)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag(sign(diag(BB))) %*% BB                # set positive diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</code></pre>

<hr>
<h2 id='specify_posterior_bsvar_msh'>R6 Class Representing PosteriorBSVARMSH</h2><span id='topic+specify_posterior_bsvar_msh'></span>

<h3>Description</h3>

<p>The class PosteriorBSVARMSH contains posterior output and the specification including 
the last MCMC draw for the bsvar model with Markov Switching Heteroskedasticity. 
Note that due to the thinning of the MCMC output the starting value in element <code>last_draw</code>
might not be equal to the last draw provided in element <code>posterior</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>last_draw</code></dt><dd><p>an object of class BSVARMSH with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>a list containing Bayesian estimation output.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PosteriorBSVARMSH-new"><code>specify_posterior_bsvar_msh$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMSH-get_posterior"><code>specify_posterior_bsvar_msh$get_posterior()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMSH-get_last_draw"><code>specify_posterior_bsvar_msh$get_last_draw()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMSH-is_normalised"><code>specify_posterior_bsvar_msh$is_normalised()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMSH-set_normalised"><code>specify_posterior_bsvar_msh$set_normalised()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARMSH-clone"><code>specify_posterior_bsvar_msh$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PosteriorBSVARMSH-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new posterior output PosteriorBSVARMSH.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_msh$new(specification_bsvar, posterior_bsvar)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification_bsvar</code></dt><dd><p>an object of class BSVARMSH with the last draw of the current MCMC run as the starting value.</p>
</dd>
<dt><code>posterior_bsvar</code></dt><dd><p>a list containing Bayesian estimation output.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A posterior output PosteriorBSVARMSH.
</p>


<hr>
<a id="method-PosteriorBSVARMSH-get_posterior"></a>



<h4>Method <code>get_posterior()</code></h4>

<p>Returns a list containing Bayesian estimation output.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_msh$get_posterior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, M = 2)
set.seed(123)
estimate       = estimate(specification, 10, thin = 1)
estimate$get_posterior()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARMSH-get_last_draw"></a>



<h4>Method <code>get_last_draw()</code></h4>

<p>Returns an object of class BSVARMSH with the last draw of the current MCMC run as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_msh$get_last_draw()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 4, M = 2)

# run the burn-in
set.seed(123)
burn_in        = estimate(specification, 10, thin = 2)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARMSH-is_normalised"></a>



<h4>Method <code>is_normalised()</code></h4>

<p>Returns <code>TRUE</code> if the posterior has been normalised using <code>normalise_posterior()</code> and <code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_msh$is_normalised()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 4, M = 2)

# estimate the model
set.seed(123)
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag((-1) * sign(diag(BB))) %*% BB         # set negative diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARMSH-set_normalised"></a>



<h4>Method <code>set_normalised()</code></h4>

<p>Sets the private indicator <code>normalised</code> to TRUE.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_msh$set_normalised(value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>(optional) a logical value to be passed to indicator <code>normalised</code>.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># This is an internal function that is run while executing normalise_posterior()
# Observe its working by analysing the workflow:

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 4, M = 2)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag(sign(diag(BB))) %*% BB                # set positive diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARMSH-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_msh$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+specify_bsvar_msh">specify_bsvar_msh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a function that is used within estimate()
data(us_fiscal_lsuw)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 4, M = 2)
set.seed(123)
estimate       = estimate(specification, 10, thin = 1)
class(estimate)


## ------------------------------------------------
## Method `specify_posterior_bsvar_msh$get_posterior`
## ------------------------------------------------

data(us_fiscal_lsuw)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, M = 2)
set.seed(123)
estimate       = estimate(specification, 10, thin = 1)
estimate$get_posterior()


## ------------------------------------------------
## Method `specify_posterior_bsvar_msh$get_last_draw`
## ------------------------------------------------

data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 4, M = 2)

# run the burn-in
set.seed(123)
burn_in        = estimate(specification, 10, thin = 2)

# estimate the model
posterior      = estimate(burn_in, 10, thin = 2)


## ------------------------------------------------
## Method `specify_posterior_bsvar_msh$is_normalised`
## ------------------------------------------------

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 4, M = 2)

# estimate the model
set.seed(123)
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag((-1) * sign(diag(BB))) %*% BB         # set negative diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()


## ------------------------------------------------
## Method `specify_posterior_bsvar_msh$set_normalised`
## ------------------------------------------------

# This is an internal function that is run while executing normalise_posterior()
# Observe its working by analysing the workflow:

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 4, M = 2)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag(sign(diag(BB))) %*% BB                # set positive diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</code></pre>

<hr>
<h2 id='specify_posterior_bsvar_sv'>R6 Class Representing PosteriorBSVARSV</h2><span id='topic+specify_posterior_bsvar_sv'></span>

<h3>Description</h3>

<p>The class PosteriorBSVARSV contains posterior output and the specification including 
the last MCMC draw for the bsvar model with Stochastic Volatility heteroskedasticity.
Note that due to the thinning of the MCMC output the starting value in element <code>last_draw</code>
might not be equal to the last draw provided in element <code>posterior</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>last_draw</code></dt><dd><p>an object of class BSVARSV with the last draw of the current MCMC run 
as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.</p>
</dd>
<dt><code>posterior</code></dt><dd><p>a list containing Bayesian estimation output.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PosteriorBSVARSV-new"><code>specify_posterior_bsvar_sv$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARSV-get_posterior"><code>specify_posterior_bsvar_sv$get_posterior()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARSV-get_last_draw"><code>specify_posterior_bsvar_sv$get_last_draw()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARSV-is_normalised"><code>specify_posterior_bsvar_sv$is_normalised()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARSV-set_normalised"><code>specify_posterior_bsvar_sv$set_normalised()</code></a>
</p>
</li>
<li> <p><a href="#method-PosteriorBSVARSV-clone"><code>specify_posterior_bsvar_sv$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PosteriorBSVARSV-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new posterior output PosteriorBSVARSV.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_sv$new(specification_bsvar, posterior_bsvar)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification_bsvar</code></dt><dd><p>an object of class BSVARSV with the last draw of the current MCMC 
run as the starting value.</p>
</dd>
<dt><code>posterior_bsvar</code></dt><dd><p>a list containing Bayesian estimation output.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A posterior output PosteriorBSVARSV.
</p>


<hr>
<a id="method-PosteriorBSVARSV-get_posterior"></a>



<h4>Method <code>get_posterior()</code></h4>

<p>Returns a list containing Bayesian estimation.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_sv$get_posterior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw)
set.seed(123)
estimate       = estimate(specification, 5, thin = 1)
estimate$get_posterior()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARSV-get_last_draw"></a>



<h4>Method <code>get_last_draw()</code></h4>

<p>Returns an object of class BSVARSV with the last draw of the current MCMC run as 
the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_sv$get_last_draw()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 4)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 5, thin = 1)

# estimate the model
posterior      = estimate(burn_in, 5, thin = 1)

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARSV-is_normalised"></a>



<h4>Method <code>is_normalised()</code></h4>

<p>Returns <code>TRUE</code> if the posterior has been normalised using <code>normalise_posterior()</code> and <code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_sv$is_normalised()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 4)

# estimate the model
set.seed(123)
posterior      = estimate(specification, 5, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag((-1) * sign(diag(BB))) %*% BB         # set negative diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARSV-set_normalised"></a>



<h4>Method <code>set_normalised()</code></h4>

<p>Sets the private indicator <code>normalised</code> to TRUE.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_sv$set_normalised(value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>(optional) a logical value to be passed to indicator <code>normalised</code>.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># This is an internal function that is run while executing normalise_posterior()
# Observe its working by analysing the workflow:

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 4)

# estimate the model
set.seed(123)
posterior      = estimate(specification, 5, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag(sign(diag(BB))) %*% BB                # set positive diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</pre>
</div>


<hr>
<a id="method-PosteriorBSVARSV-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_posterior_bsvar_sv$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+specify_bsvar_sv">specify_bsvar_sv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a function that is used within estimate()
data(us_fiscal_lsuw)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 4)
set.seed(123)
estimate       = estimate(specification, 5, thin = 1)
class(estimate)


## ------------------------------------------------
## Method `specify_posterior_bsvar_sv$get_posterior`
## ------------------------------------------------

data(us_fiscal_lsuw)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw)
set.seed(123)
estimate       = estimate(specification, 5, thin = 1)
estimate$get_posterior()


## ------------------------------------------------
## Method `specify_posterior_bsvar_sv$get_last_draw`
## ------------------------------------------------

data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 4)
set.seed(123)

# run the burn-in
burn_in        = estimate(specification, 5, thin = 1)

# estimate the model
posterior      = estimate(burn_in, 5, thin = 1)


## ------------------------------------------------
## Method `specify_posterior_bsvar_sv$is_normalised`
## ------------------------------------------------

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 4)

# estimate the model
set.seed(123)
posterior      = estimate(specification, 5, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag((-1) * sign(diag(BB))) %*% BB         # set negative diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()


## ------------------------------------------------
## Method `specify_posterior_bsvar_sv$set_normalised`
## ------------------------------------------------

# This is an internal function that is run while executing normalise_posterior()
# Observe its working by analysing the workflow:

# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 4)

# estimate the model
set.seed(123)
posterior      = estimate(specification, 5, thin = 1)

# check normalisation status beforehand
posterior$is_normalised()

# normalise the posterior
BB            = posterior$last_draw$starting_values$B      # get the last draw of B
B_hat         = diag(sign(diag(BB))) %*% BB                # set positive diagonal elements
normalise_posterior(posterior, B_hat)                      # draws in posterior are normalised

# check normalisation status afterwards
posterior$is_normalised()

</code></pre>

<hr>
<h2 id='specify_prior_bsvar'>R6 Class Representing PriorBSVAR</h2><span id='topic+specify_prior_bsvar'></span>

<h3>Description</h3>

<p>The class PriorBSVAR presents a prior specification for the homoskedastic bsvar model.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>A</code></dt><dd><p>an <code>NxK</code> matrix, the mean of the normal prior distribution for the parameter matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>A_V_inv</code></dt><dd><p>a <code>KxK</code> precision matrix of the normal prior distribution for each of 
the row of the parameter matrix <code class="reqn">A</code>. This precision matrix is equation invariant.</p>
</dd>
<dt><code>B_V_inv</code></dt><dd><p>an <code>NxN</code> precision matrix of the generalised-normal prior distribution 
for the structural matrix <code class="reqn">B</code>. This precision matrix is equation invariant.</p>
</dd>
<dt><code>B_nu</code></dt><dd><p>a positive integer greater of equal than <code>N</code>, a shape parameter of 
the generalised-normal prior distribution for the structural matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_nu_B</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior
for the overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_a_B</code></dt><dd><p>a positive scalar, the shape parameter of the gamma prior
for the second-level hierarchy for the overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_s_BB</code></dt><dd><p>a positive scalar, the scale parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_nu_BB</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_nu_A</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior 
for the overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>hyper_a_A</code></dt><dd><p>a positive scalar, the shape parameter of the gamma prior
for the second-level hierarchy for the overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>hyper_s_AA</code></dt><dd><p>a positive scalar, the scale parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>hyper_nu_AA</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PriorBSVAR-new"><code>specify_prior_bsvar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PriorBSVAR-get_prior"><code>specify_prior_bsvar$get_prior()</code></a>
</p>
</li>
<li> <p><a href="#method-PriorBSVAR-clone"><code>specify_prior_bsvar$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PriorBSVAR-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new prior specification PriorBSVAR.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvar$new(N, p, d = 0, stationary = rep(FALSE, N))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>a positive integer - the number of dependent variables in the model.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer - the autoregressive lag order of the SVAR model.</p>
</dd>
<dt><code>d</code></dt><dd><p>a positive integer - the number of <code>exogenous</code> variables in the model.</p>
</dd>
<dt><code>stationary</code></dt><dd><p>an <code>N</code> logical vector - its element set to <code>FALSE</code> sets 
the prior mean for the autoregressive parameters of the <code>N</code>th equation to the white noise process, 
otherwise to random walk.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new prior specification PriorBSVAR.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># a prior for 3-variable example with one lag and stationary data
prior = specify_prior_bsvar$new(N = 3, p = 1, stationary = rep(TRUE, 3))
prior$A # show autoregressive prior mean

</pre>
</div>


<hr>
<a id="method-PriorBSVAR-get_prior"></a>



<h4>Method <code>get_prior()</code></h4>

<p>Returns the elements of the prior specification PriorBSVAR as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvar$get_prior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># a prior for 3-variable example with four lags
prior = specify_prior_bsvar$new(N = 3, p = 4)
prior$get_prior() # show the prior as list

</pre>
</div>


<hr>
<a id="method-PriorBSVAR-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>prior = specify_prior_bsvar$new(N = 3, p = 1)  # a prior for 3-variable example with one lag
prior$A                                        # show autoregressive prior mean


## ------------------------------------------------
## Method `specify_prior_bsvar$new`
## ------------------------------------------------

# a prior for 3-variable example with one lag and stationary data
prior = specify_prior_bsvar$new(N = 3, p = 1, stationary = rep(TRUE, 3))
prior$A # show autoregressive prior mean


## ------------------------------------------------
## Method `specify_prior_bsvar$get_prior`
## ------------------------------------------------

# a prior for 3-variable example with four lags
prior = specify_prior_bsvar$new(N = 3, p = 4)
prior$get_prior() # show the prior as list

</code></pre>

<hr>
<h2 id='specify_prior_bsvar_mix'>R6 Class Representing PriorBSVARMIX</h2><span id='topic+specify_prior_bsvar_mix'></span>

<h3>Description</h3>

<p>The class PriorBSVARMIX presents a prior specification for the bsvar model with a zero-mean mixture of normals model for structural shocks.
</p>


<h3>Super classes</h3>

<p><code>bsvars::PriorBSVAR</code> -&gt; <code>bsvars::PriorBSVARMSH</code> -&gt; <code>PriorBSVARMIX</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>A</code></dt><dd><p>an <code>NxK</code> matrix, the mean of the normal prior distribution for the parameter matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>A_V_inv</code></dt><dd><p>a <code>KxK</code> precision matrix of the normal prior distribution for each of the row of the parameter matrix <code class="reqn">A</code>. This precision matrix is equation invariant.</p>
</dd>
<dt><code>B_V_inv</code></dt><dd><p>an <code>NxN</code> precision matrix of the generalised-normal prior distribution for the structural matrix <code class="reqn">B</code>. This precision matrix is equation invariant.</p>
</dd>
<dt><code>B_nu</code></dt><dd><p>a positive integer greater of equal than <code>N</code>, a shape parameter of the generalised-normal prior distribution for the structural matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_nu_B</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior
for the overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_a_B</code></dt><dd><p>a positive scalar, the shape parameter of the gamma prior
for the second-level hierarchy for the overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_s_BB</code></dt><dd><p>a positive scalar, the scale parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_nu_BB</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_nu_A</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior 
for the overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>hyper_a_A</code></dt><dd><p>a positive scalar, the shape parameter of the gamma prior
for the second-level hierarchy for the overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>hyper_s_AA</code></dt><dd><p>a positive scalar, the scale parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>hyper_nu_AA</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>sigma_nu</code></dt><dd><p>a positive scalar,  the shape parameter of the inverted-gamma 2 for mixture component-dependent variances of the structural shocks, <code class="reqn">\sigma^2_{n.s_t}</code>.</p>
</dd>
<dt><code>sigma_s</code></dt><dd><p>a positive scalar,  the scale parameter of the inverted-gamma 2 for mixture component-dependent variances of the structural shocks, <code class="reqn">\sigma^2_{n.s_t}</code>.</p>
</dd>
<dt><code>PR_TR</code></dt><dd><p>an <code>MxM</code> matrix, the matrix of hyper-parameters of the row-specific Dirichlet prior distribution for the state probabilities the Markov process <code class="reqn">s_t</code>. Its rows must be identical.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PriorBSVARMIX-clone"><code>specify_prior_bsvar_mix$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bsvars" data-topic="PriorBSVARMSH" data-id="get_prior"><a href='../../bsvars/html/PriorBSVARMSH.html#method-PriorBSVARMSH-get_prior'><code>bsvars::PriorBSVARMSH$get_prior()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bsvars" data-topic="PriorBSVARMSH" data-id="initialize"><a href='../../bsvars/html/PriorBSVARMSH.html#method-PriorBSVARMSH-initialize'><code>bsvars::PriorBSVARMSH$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PriorBSVARMIX-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvar_mix$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>prior = specify_prior_bsvar_mix$new(N = 3, p = 1, M = 2)  # specify the prior
prior$A                                        # show autoregressive prior mean

</code></pre>

<hr>
<h2 id='specify_prior_bsvar_msh'>R6 Class Representing PriorBSVARMSH</h2><span id='topic+specify_prior_bsvar_msh'></span>

<h3>Description</h3>

<p>The class PriorBSVARMSH presents a prior specification for the bsvar model with Markov Switching Heteroskedasticity.
</p>


<h3>Super class</h3>

<p><code>bsvars::PriorBSVAR</code> -&gt; <code>PriorBSVARMSH</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>A</code></dt><dd><p>an <code>NxK</code> matrix, the mean of the normal prior distribution for the parameter matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>A_V_inv</code></dt><dd><p>a <code>KxK</code> precision matrix of the normal prior distribution for each of the row of the parameter matrix <code class="reqn">A</code>. This precision matrix is equation invariant.</p>
</dd>
<dt><code>B_V_inv</code></dt><dd><p>an <code>NxN</code> precision matrix of the generalised-normal prior distribution for the structural matrix <code class="reqn">B</code>. This precision matrix is equation invariant.</p>
</dd>
<dt><code>B_nu</code></dt><dd><p>a positive integer greater of equal than <code>N</code>, a shape parameter of the generalised-normal prior distribution for the structural matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_nu_B</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior
for the overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_a_B</code></dt><dd><p>a positive scalar, the shape parameter of the gamma prior
for the second-level hierarchy for the overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_s_BB</code></dt><dd><p>a positive scalar, the scale parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_nu_BB</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_nu_A</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior 
for the overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>hyper_a_A</code></dt><dd><p>a positive scalar, the shape parameter of the gamma prior
for the second-level hierarchy for the overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>hyper_s_AA</code></dt><dd><p>a positive scalar, the scale parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>hyper_nu_AA</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>sigma_nu</code></dt><dd><p>a positive scalar,  the shape parameter of the inverted-gamma 2 for MS state-dependent variances of the structural shocks, <code class="reqn">\sigma^2_{n.s_t}</code>.</p>
</dd>
<dt><code>sigma_s</code></dt><dd><p>a positive scalar,  the scale parameter of the inverted-gamma 2 for MS state-dependent variances of the structural shocks, <code class="reqn">\sigma^2_{n.s_t}</code>.</p>
</dd>
<dt><code>PR_TR</code></dt><dd><p>an <code>MxM</code> matrix, the matrix of hyper-parameters of the row-specific Dirichlet prior distribution for transition probabilities matrix <code class="reqn">P</code> of the Markov process <code class="reqn">s_t</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PriorBSVARMSH-new"><code>specify_prior_bsvar_msh$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PriorBSVARMSH-get_prior"><code>specify_prior_bsvar_msh$get_prior()</code></a>
</p>
</li>
<li> <p><a href="#method-PriorBSVARMSH-clone"><code>specify_prior_bsvar_msh$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PriorBSVARMSH-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new prior specification PriorBSVARMSH.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvar_msh$new(N, p, d = 0, M, stationary = rep(FALSE, N))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>a positive integer - the number of dependent variables in the model.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer - the autoregressive lag order of the SVAR model.</p>
</dd>
<dt><code>d</code></dt><dd><p>a positive integer - the number of <code>exogenous</code> variables in the model.</p>
</dd>
<dt><code>M</code></dt><dd><p>an integer greater than 1 - the number of Markov process' heteroskedastic regimes.</p>
</dd>
<dt><code>stationary</code></dt><dd><p>an <code>N</code> logical vector - its element set to <code>FALSE</code> sets the prior mean for the autoregressive parameters of the <code>N</code>th equation to the white noise process, otherwise to random walk.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new prior specification PriorBSVARMSH.
</p>


<hr>
<a id="method-PriorBSVARMSH-get_prior"></a>



<h4>Method <code>get_prior()</code></h4>

<p>Returns the elements of the prior specification PriorBSVARMSH as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvar_msh$get_prior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># a prior for 3-variable example with four lags and two regimes
prior = specify_prior_bsvar_msh$new(N = 3, p = 4, M = 2)
prior$get_prior() # show the prior as list

</pre>
</div>


<hr>
<a id="method-PriorBSVARMSH-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvar_msh$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>prior = specify_prior_bsvar_msh$new(N = 3, p = 1, M = 2)  # specify the prior
prior$A                                        # show autoregressive prior mean


## ------------------------------------------------
## Method `specify_prior_bsvar_msh$get_prior`
## ------------------------------------------------

# a prior for 3-variable example with four lags and two regimes
prior = specify_prior_bsvar_msh$new(N = 3, p = 4, M = 2)
prior$get_prior() # show the prior as list

</code></pre>

<hr>
<h2 id='specify_prior_bsvar_sv'>R6 Class Representing PriorBSVARSV</h2><span id='topic+specify_prior_bsvar_sv'></span>

<h3>Description</h3>

<p>The class PriorBSVARSV presents a prior specification for the bsvar model with Stochastic Volatility heteroskedasticity.
</p>


<h3>Super class</h3>

<p><code>bsvars::PriorBSVAR</code> -&gt; <code>PriorBSVARSV</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>A</code></dt><dd><p>an <code>NxK</code> matrix, the mean of the normal prior distribution for the parameter matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>A_V_inv</code></dt><dd><p>a <code>KxK</code> precision matrix of the normal prior distribution for each of the row of the parameter matrix <code class="reqn">A</code>. This precision matrix is equation invariant.</p>
</dd>
<dt><code>B_V_inv</code></dt><dd><p>an <code>NxN</code> precision matrix of the generalised-normal prior distribution for the structural matrix <code class="reqn">B</code>. This precision matrix is equation invariant.</p>
</dd>
<dt><code>B_nu</code></dt><dd><p>a positive integer greater of equal than <code>N</code>, a shape parameter of the generalised-normal prior distribution for the structural matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_nu_B</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior
for the overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_a_B</code></dt><dd><p>a positive scalar, the shape parameter of the gamma prior
for the second-level hierarchy for the overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_s_BB</code></dt><dd><p>a positive scalar, the scale parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_nu_BB</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper_nu_A</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior 
for the overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>hyper_a_A</code></dt><dd><p>a positive scalar, the shape parameter of the gamma prior
for the second-level hierarchy for the overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>hyper_s_AA</code></dt><dd><p>a positive scalar, the scale parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>hyper_nu_AA</code></dt><dd><p>a positive scalar, the shape parameter of the inverted-gamma 2 prior
for the third-level of hierarchy for overall shrinkage parameter for matrix <code class="reqn">A</code>.</p>
</dd>
<dt><code>sv_a_</code></dt><dd><p>a positive scalar, the shape parameter of the gamma prior in the hierarchical prior for <code class="reqn">\sigma^2_{\omega}</code>.</p>
</dd>
<dt><code>sv_s_</code></dt><dd><p>a positive scalar, the scale parameter of the gamma prior in the hierarchical prior for <code class="reqn">\sigma^2_{\omega}</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PriorBSVARSV-new"><code>specify_prior_bsvar_sv$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PriorBSVARSV-get_prior"><code>specify_prior_bsvar_sv$get_prior()</code></a>
</p>
</li>
<li> <p><a href="#method-PriorBSVARSV-clone"><code>specify_prior_bsvar_sv$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PriorBSVARSV-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new prior specification PriorBSVARSV.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvar_sv$new(N, p, d = 0, stationary = rep(FALSE, N))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>a positive integer - the number of dependent variables in the model.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer - the autoregressive lag order of the SVAR model.</p>
</dd>
<dt><code>d</code></dt><dd><p>a positive integer - the number of <code>exogenous</code> variables in the model.</p>
</dd>
<dt><code>stationary</code></dt><dd><p>an <code>N</code> logical vector - its element set to <code>FALSE</code> sets the prior mean for the autoregressive parameters of the <code>N</code>th equation to the white noise process, otherwise to random walk.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new prior specification PriorBSVARSV.
</p>


<hr>
<a id="method-PriorBSVARSV-get_prior"></a>



<h4>Method <code>get_prior()</code></h4>

<p>Returns the elements of the prior specification PriorBSVARSV as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvar_sv$get_prior()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># a prior for 3-variable example with four lags
prior = specify_prior_bsvar_sv$new(N = 3, p = 4)
prior$get_prior() # show the prior as list

</pre>
</div>


<hr>
<a id="method-PriorBSVARSV-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_prior_bsvar_sv$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>prior = specify_prior_bsvar_sv$new(N = 3, p = 1) # a prior for 3-variable example with one lag
prior$A                                          # show autoregressive prior mean


## ------------------------------------------------
## Method `specify_prior_bsvar_sv$get_prior`
## ------------------------------------------------

# a prior for 3-variable example with four lags
prior = specify_prior_bsvar_sv$new(N = 3, p = 4)
prior$get_prior() # show the prior as list

</code></pre>

<hr>
<h2 id='specify_starting_values_bsvar'>R6 Class Representing StartingValuesBSVAR</h2><span id='topic+specify_starting_values_bsvar'></span>

<h3>Description</h3>

<p>The class StartingValuesBSVAR presents starting values for the homoskedastic bsvar model.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>A</code></dt><dd><p>an <code>NxK</code> matrix of starting values for the parameter <code class="reqn">A</code>.</p>
</dd>
<dt><code>B</code></dt><dd><p>an <code>NxN</code> matrix of starting values for the parameter <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper</code></dt><dd><p>a <code>(2*N+1)x2</code> matrix of starting values for the shrinkage hyper-parameters of the 
hierarchical prior distribution.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-StartingValuesBSVAR-new"><code>specify_starting_values_bsvar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-StartingValuesBSVAR-get_starting_values"><code>specify_starting_values_bsvar$get_starting_values()</code></a>
</p>
</li>
<li> <p><a href="#method-StartingValuesBSVAR-set_starting_values"><code>specify_starting_values_bsvar$set_starting_values()</code></a>
</p>
</li>
<li> <p><a href="#method-StartingValuesBSVAR-clone"><code>specify_starting_values_bsvar$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-StartingValuesBSVAR-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create new starting values StartingValuesBSVAR.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar$new(N, p, d = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>a positive integer - the number of dependent variables in the model.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer - the autoregressive lag order of the SVAR model.</p>
</dd>
<dt><code>d</code></dt><dd><p>a positive integer - the number of <code>exogenous</code> variables in the model.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Starting values StartingValuesBSVAR.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># starting values for a homoskedastic bsvar with 4 lags for a 3-variable system
sv = specify_starting_values_bsvar$new(N = 3, p = 4)

</pre>
</div>


<hr>
<a id="method-StartingValuesBSVAR-get_starting_values"></a>



<h4>Method <code>get_starting_values()</code></h4>

<p>Returns the elements of the starting values StartingValuesBSVAR as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar$get_starting_values()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># starting values for a homoskedastic bsvar with 1 lag for a 3-variable system
sv = specify_starting_values_bsvar$new(N = 3, p = 1)
sv$get_starting_values()   # show starting values as list

</pre>
</div>


<hr>
<a id="method-StartingValuesBSVAR-set_starting_values"></a>



<h4>Method <code>set_starting_values()</code></h4>

<p>Returns the elements of the starting values StartingValuesBSVAR as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar$set_starting_values(last_draw)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>last_draw</code></dt><dd><p>a list containing the last draw of elements <code>B</code> - an <code>NxN</code> matrix, 
<code>A</code> - an <code>NxK</code> matrix, and <code>hyper</code> - a vector of 5 positive real numbers.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class StartingValuesBSVAR including the last draw of the current MCMC 
as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># starting values for a homoskedastic bsvar with 1 lag for a 3-variable system
sv = specify_starting_values_bsvar$new(N = 3, p = 1)

# Modify the starting values by:
sv_list = sv$get_starting_values()   # getting them as list
sv_list$A &lt;- matrix(rnorm(12), 3, 4) # modifying the entry
sv$set_starting_values(sv_list)      # providing to the class object

</pre>
</div>


<hr>
<a id="method-StartingValuesBSVAR-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># starting values for a homoskedastic bsvar for a 3-variable system
sv = specify_starting_values_bsvar$new(N = 3, p = 1)


## ------------------------------------------------
## Method `specify_starting_values_bsvar$new`
## ------------------------------------------------

# starting values for a homoskedastic bsvar with 4 lags for a 3-variable system
sv = specify_starting_values_bsvar$new(N = 3, p = 4)


## ------------------------------------------------
## Method `specify_starting_values_bsvar$get_starting_values`
## ------------------------------------------------

# starting values for a homoskedastic bsvar with 1 lag for a 3-variable system
sv = specify_starting_values_bsvar$new(N = 3, p = 1)
sv$get_starting_values()   # show starting values as list


## ------------------------------------------------
## Method `specify_starting_values_bsvar$set_starting_values`
## ------------------------------------------------

# starting values for a homoskedastic bsvar with 1 lag for a 3-variable system
sv = specify_starting_values_bsvar$new(N = 3, p = 1)

# Modify the starting values by:
sv_list = sv$get_starting_values()   # getting them as list
sv_list$A &lt;- matrix(rnorm(12), 3, 4) # modifying the entry
sv$set_starting_values(sv_list)      # providing to the class object

</code></pre>

<hr>
<h2 id='specify_starting_values_bsvar_mix'>R6 Class Representing StartingValuesBSVARMIX</h2><span id='topic+specify_starting_values_bsvar_mix'></span>

<h3>Description</h3>

<p>The class StartingValuesBSVARMIX presents starting values for the bsvar model with a zero-mean mixture of normals model for structural shocks.
</p>


<h3>Super classes</h3>

<p><code>bsvars::StartingValuesBSVAR</code> -&gt; <code>bsvars::StartingValuesBSVARMSH</code> -&gt; <code>StartingValuesBSVARMIX</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>A</code></dt><dd><p>an <code>NxK</code> matrix of starting values for the parameter <code class="reqn">A</code>.</p>
</dd>
<dt><code>B</code></dt><dd><p>an <code>NxN</code> matrix of starting values for the parameter <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper</code></dt><dd><p>a <code>(2*N+1)x2</code> matrix of starting values for the shrinkage hyper-parameters of the 
hierarchical prior distribution.</p>
</dd>
<dt><code>sigma2</code></dt><dd><p>an <code>NxM</code> matrix of starting values for the MS state-specific variances of the structural shocks. Its elements sum to value <code>M</code> over the rows.</p>
</dd>
<dt><code>PR_TR</code></dt><dd><p>an <code>MxM</code> matrix of starting values for the probability matrix of the Markov process. Its rows must be identical and the elements of each row sum to 1 over the rows.</p>
</dd>
<dt><code>xi</code></dt><dd><p>an <code>MxT</code> matrix of starting values for the Markov process indicator. Its columns are a chosen column of an identity matrix of order <code>M</code>.</p>
</dd>
<dt><code>pi_0</code></dt><dd><p>an <code>M</code>-vector of starting values for mixture components state probabilities. Its elements sum to 1.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-StartingValuesBSVARMIX-new"><code>specify_starting_values_bsvar_mix$new()</code></a>
</p>
</li>
<li> <p><a href="#method-StartingValuesBSVARMIX-clone"><code>specify_starting_values_bsvar_mix$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bsvars" data-topic="StartingValuesBSVARMSH" data-id="get_starting_values"><a href='../../bsvars/html/StartingValuesBSVARMSH.html#method-StartingValuesBSVARMSH-get_starting_values'><code>bsvars::StartingValuesBSVARMSH$get_starting_values()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bsvars" data-topic="StartingValuesBSVARMSH" data-id="set_starting_values"><a href='../../bsvars/html/StartingValuesBSVARMSH.html#method-StartingValuesBSVARMSH-set_starting_values'><code>bsvars::StartingValuesBSVARMSH$set_starting_values()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-StartingValuesBSVARMIX-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create new starting values StartingValuesBSVARMIX.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar_mix$new(N, p, M, T, d = 0, finiteM = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>a positive integer - the number of dependent variables in the model.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer - the autoregressive lag order of the SVAR model.</p>
</dd>
<dt><code>M</code></dt><dd><p>an integer greater than 1 - the number of components of the mixture of normals.</p>
</dd>
<dt><code>T</code></dt><dd><p>a positive integer - the the time series dimension of the dependent variable matrix <code class="reqn">Y</code>.</p>
</dd>
<dt><code>d</code></dt><dd><p>a positive integer - the number of <code>exogenous</code> variables in the model.</p>
</dd>
<dt><code>finiteM</code></dt><dd><p>a logical value - if true a finite mixture model is estimated. Otherwise, a sparse mixture model is estimated in which <code>M=20</code> and the number of visited states is estimated.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Starting values StartingValuesBSVARMIX.
</p>


<hr>
<a id="method-StartingValuesBSVARMIX-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar_mix$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># starting values for a bsvar model for a 3-variable system
sv = specify_starting_values_bsvar_mix$new(N = 3, p = 1, M = 2, T = 100)

</code></pre>

<hr>
<h2 id='specify_starting_values_bsvar_msh'>R6 Class Representing StartingValuesBSVARMSH</h2><span id='topic+specify_starting_values_bsvar_msh'></span>

<h3>Description</h3>

<p>The class StartingValuesBSVARMSH presents starting values for the bsvar model with Markov Switching Heteroskedasticity.
</p>


<h3>Super class</h3>

<p><code>bsvars::StartingValuesBSVAR</code> -&gt; <code>StartingValuesBSVARMSH</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>A</code></dt><dd><p>an <code>NxK</code> matrix of starting values for the parameter <code class="reqn">A</code>.</p>
</dd>
<dt><code>B</code></dt><dd><p>an <code>NxN</code> matrix of starting values for the parameter <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper</code></dt><dd><p>a <code>(2*N+1)x2</code> matrix of starting values for the shrinkage hyper-parameters of the 
hierarchical prior distribution.</p>
</dd>
<dt><code>sigma2</code></dt><dd><p>an <code>NxM</code> matrix of starting values for the MS state-specific variances of the structural shocks. Its elements sum to value <code>M</code> over the rows.</p>
</dd>
<dt><code>PR_TR</code></dt><dd><p>an <code>MxM</code> matrix of starting values for the transition probability matrix of the Markov process. Its elements sum to 1 over the rows.</p>
</dd>
<dt><code>xi</code></dt><dd><p>an <code>MxT</code> matrix of starting values for the Markov process indicator. Its columns are a chosen column of an identity matrix of order <code>M</code>.</p>
</dd>
<dt><code>pi_0</code></dt><dd><p>an <code>M</code>-vector of starting values for state probability at time <code>t=0</code>. Its elements sum to 1.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-StartingValuesBSVARMSH-new"><code>specify_starting_values_bsvar_msh$new()</code></a>
</p>
</li>
<li> <p><a href="#method-StartingValuesBSVARMSH-get_starting_values"><code>specify_starting_values_bsvar_msh$get_starting_values()</code></a>
</p>
</li>
<li> <p><a href="#method-StartingValuesBSVARMSH-set_starting_values"><code>specify_starting_values_bsvar_msh$set_starting_values()</code></a>
</p>
</li>
<li> <p><a href="#method-StartingValuesBSVARMSH-clone"><code>specify_starting_values_bsvar_msh$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-StartingValuesBSVARMSH-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create new starting values StartingValuesBSVAR-MS.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar_msh$new(N, p, M, T, d = 0, finiteM = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>a positive integer - the number of dependent variables in the model.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer - the autoregressive lag order of the SVAR model.</p>
</dd>
<dt><code>M</code></dt><dd><p>an integer greater than 1 - the number of Markov process' heteroskedastic regimes.</p>
</dd>
<dt><code>T</code></dt><dd><p>a positive integer - the the time series dimension of the dependent variable matrix <code class="reqn">Y</code>.</p>
</dd>
<dt><code>d</code></dt><dd><p>a positive integer - the number of <code>exogenous</code> variables in the model.</p>
</dd>
<dt><code>finiteM</code></dt><dd><p>a logical value - if true a stationary Markov switching model is estimated. Otherwise, a sparse Markov switching model is estimated in which <code>M=20</code> and the number of visited states is estimated.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Starting values StartingValuesBSVAR-MS.
</p>


<hr>
<a id="method-StartingValuesBSVARMSH-get_starting_values"></a>



<h4>Method <code>get_starting_values()</code></h4>

<p>Returns the elements of the starting values StartingValuesBSVAR-MS as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar_msh$get_starting_values()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># starting values for a homoskedastic bsvar with 1 lag for a 3-variable system
sv = specify_starting_values_bsvar_msh$new(N = 3, p = 1, M = 2, T = 100)
sv$get_starting_values()   # show starting values as list

</pre>
</div>


<hr>
<a id="method-StartingValuesBSVARMSH-set_starting_values"></a>



<h4>Method <code>set_starting_values()</code></h4>

<p>Returns the elements of the starting values StartingValuesBSVARMSH as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar_msh$set_starting_values(last_draw)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>last_draw</code></dt><dd><p>a list containing the last draw.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class StartingValuesBSVAR-MS including the last draw of the current MCMC as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># starting values for a bsvar model with 1 lag for a 3-variable system
sv = specify_starting_values_bsvar_msh$new(N = 3, p = 1, M = 2, T = 100)

# Modify the starting values by:
sv_list = sv$get_starting_values()   # getting them as list
sv_list$A &lt;- matrix(rnorm(12), 3, 4) # modifying the entry
sv$set_starting_values(sv_list)      # providing to the class object

</pre>
</div>


<hr>
<a id="method-StartingValuesBSVARMSH-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar_msh$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># starting values for a bsvar model for a 3-variable system
sv = specify_starting_values_bsvar_msh$new(N = 3, p = 1, M = 2, T = 100)


## ------------------------------------------------
## Method `specify_starting_values_bsvar_msh$get_starting_values`
## ------------------------------------------------

# starting values for a homoskedastic bsvar with 1 lag for a 3-variable system
sv = specify_starting_values_bsvar_msh$new(N = 3, p = 1, M = 2, T = 100)
sv$get_starting_values()   # show starting values as list


## ------------------------------------------------
## Method `specify_starting_values_bsvar_msh$set_starting_values`
## ------------------------------------------------

# starting values for a bsvar model with 1 lag for a 3-variable system
sv = specify_starting_values_bsvar_msh$new(N = 3, p = 1, M = 2, T = 100)

# Modify the starting values by:
sv_list = sv$get_starting_values()   # getting them as list
sv_list$A &lt;- matrix(rnorm(12), 3, 4) # modifying the entry
sv$set_starting_values(sv_list)      # providing to the class object

</code></pre>

<hr>
<h2 id='specify_starting_values_bsvar_sv'>R6 Class Representing StartingValuesBSVARSV</h2><span id='topic+specify_starting_values_bsvar_sv'></span>

<h3>Description</h3>

<p>The class StartingValuesBSVARSV presents starting values for the bsvar model with Stochastic Volatility heteroskedasticity.
</p>


<h3>Super class</h3>

<p><code>bsvars::StartingValuesBSVAR</code> -&gt; <code>StartingValuesBSVARSV</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>A</code></dt><dd><p>an <code>NxK</code> matrix of starting values for the parameter <code class="reqn">A</code>.</p>
</dd>
<dt><code>B</code></dt><dd><p>an <code>NxN</code> matrix of starting values for the parameter <code class="reqn">B</code>.</p>
</dd>
<dt><code>hyper</code></dt><dd><p>a <code>(2*N+1)x2</code> matrix of starting values for the shrinkage hyper-parameters of the 
hierarchical prior distribution.</p>
</dd>
<dt><code>h</code></dt><dd><p>an <code>NxT</code> matrix with the starting values of the log-volatility processes.</p>
</dd>
<dt><code>rho</code></dt><dd><p>an <code>N</code>-vector with values of SV autoregressive parameters.</p>
</dd>
<dt><code>omega</code></dt><dd><p>an <code>N</code>-vector with values of SV process conditional standard deviations.</p>
</dd>
<dt><code>sigma2v</code></dt><dd><p>an <code>N</code>-vector with values of SV process conditional variances.</p>
</dd>
<dt><code>S</code></dt><dd><p>an <code>NxT</code> integer matrix with the auxiliary mixture component indicators.</p>
</dd>
<dt><code>sigma2_omega</code></dt><dd><p>an <code>N</code>-vector with variances of the zero-mean normal prior for <code class="reqn">\omega_n</code>.</p>
</dd>
<dt><code>s_</code></dt><dd><p>a positive scalar with the scale of the gamma prior of the hierarchical prior for <code class="reqn">\sigma^2_{\omega}</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-StartingValuesBSVARSV-new"><code>specify_starting_values_bsvar_sv$new()</code></a>
</p>
</li>
<li> <p><a href="#method-StartingValuesBSVARSV-get_starting_values"><code>specify_starting_values_bsvar_sv$get_starting_values()</code></a>
</p>
</li>
<li> <p><a href="#method-StartingValuesBSVARSV-set_starting_values"><code>specify_starting_values_bsvar_sv$set_starting_values()</code></a>
</p>
</li>
<li> <p><a href="#method-StartingValuesBSVARSV-clone"><code>specify_starting_values_bsvar_sv$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-StartingValuesBSVARSV-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create new starting values StartingValuesBSVARSV.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar_sv$new(N, p, T, d = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>N</code></dt><dd><p>a positive integer - the number of dependent variables in the model.</p>
</dd>
<dt><code>p</code></dt><dd><p>a positive integer - the autoregressive lag order of the SVAR model.</p>
</dd>
<dt><code>T</code></dt><dd><p>a positive integer - the the time series dimension of the dependent variable matrix <code class="reqn">Y</code>.</p>
</dd>
<dt><code>d</code></dt><dd><p>a positive integer - the number of <code>exogenous</code> variables in the model.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Starting values StartingValuesBSVARSV.
</p>


<hr>
<a id="method-StartingValuesBSVARSV-get_starting_values"></a>



<h4>Method <code>get_starting_values()</code></h4>

<p>Returns the elements of the starting values StartingValuesBSVARSV as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar_sv$get_starting_values()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre># starting values for a bsvar model with 1 lag for a 3-variable system
sv = specify_starting_values_bsvar_sv$new(N = 3, p = 1, T = 100)
sv$get_starting_values()   # show starting values as list

</pre>
</div>


<hr>
<a id="method-StartingValuesBSVARSV-set_starting_values"></a>



<h4>Method <code>set_starting_values()</code></h4>

<p>Returns the elements of the starting values StartingValuesBSVAR_SV as a <code>list</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar_sv$set_starting_values(last_draw)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>last_draw</code></dt><dd><p>a list containing the last draw of the current MCMC run.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class StartingValuesBSVAR including the last draw of the current MCMC as the starting value to be passed to the continuation of the MCMC estimation using <code>estimate()</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># starting values for a bsvar model with 1 lag for a 3-variable system
sv = specify_starting_values_bsvar_sv$new(N = 3, p = 1, T = 100)

# Modify the starting values by:
sv_list = sv$get_starting_values()   # getting them as list
sv_list$A &lt;- matrix(rnorm(12), 3, 4) # modifying the entry
sv$set_starting_values(sv_list)      # providing to the class object

</pre>
</div>


<hr>
<a id="method-StartingValuesBSVARSV-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>specify_starting_values_bsvar_sv$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># starting values for a bsvar model for a 3-variable system
sv = specify_starting_values_bsvar_sv$new(N = 3, p = 1, T = 100)


## ------------------------------------------------
## Method `specify_starting_values_bsvar_sv$get_starting_values`
## ------------------------------------------------

# starting values for a bsvar model with 1 lag for a 3-variable system
sv = specify_starting_values_bsvar_sv$new(N = 3, p = 1, T = 100)
sv$get_starting_values()   # show starting values as list


## ------------------------------------------------
## Method `specify_starting_values_bsvar_sv$set_starting_values`
## ------------------------------------------------

# starting values for a bsvar model with 1 lag for a 3-variable system
sv = specify_starting_values_bsvar_sv$new(N = 3, p = 1, T = 100)

# Modify the starting values by:
sv_list = sv$get_starting_values()   # getting them as list
sv_list$A &lt;- matrix(rnorm(12), 3, 4) # modifying the entry
sv$set_starting_values(sv_list)      # providing to the class object

</code></pre>

<hr>
<h2 id='summary.Forecasts'>Provides posterior summary of Forecasts</h2><span id='topic+summary.Forecasts'></span>

<h3>Description</h3>

<p>Provides posterior summary of the forecasts including their 
mean, standard deviations, as well as 5 and 95 percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Forecasts'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Forecasts_+3A_object">object</code></td>
<td>
<p>an object of class Forecasts obtained using the
<code>forecast()</code> function containing draws the predictive density.</p>
</td></tr>
<tr><td><code id="summary.Forecasts_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list reporting the posterior mean, standard deviations, as well as 
5 and 95 percentiles of the forecasts for each of the variables and forecast 
horizons.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast">forecast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, thin = 1)

# forecast
fore           = forecast(posterior, horizon = 2)
fore_summary   = summary(fore)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  forecast(horizon = 2) |&gt;
  summary() -&gt; fore_summary

</code></pre>

<hr>
<h2 id='summary.PosteriorBSVAR'>Provides posterior summary of homoskedastic Structural VAR estimation</h2><span id='topic+summary.PosteriorBSVAR'></span>

<h3>Description</h3>

<p>Provides posterior mean, standard deviations, as well as 5 and 95 
percentiles of the parameters: the structural matrix <code class="reqn">B</code>, autoregressive 
parameters <code class="reqn">A</code>, and hyper parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVAR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PosteriorBSVAR_+3A_object">object</code></td>
<td>
<p>an object of class PosteriorBSVAR obtained using the
<code>estimate()</code> function applied to homoskedastic Bayesian Structural VAR
model specification set by function <code>specify_bsvar$new()</code> containing 
draws from the  posterior distribution of the parameters.</p>
</td></tr>
<tr><td><code id="summary.PosteriorBSVAR_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list reporting the posterior mean, standard deviations, as well as 5 and 95 
percentiles of the parameters: the structural matrix <code class="reqn">B</code>, autoregressive 
parameters <code class="reqn">A</code>, and hyper-parameters.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+specify_bsvar">specify_bsvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, thin = 1)
summary(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  summary()

</code></pre>

<hr>
<h2 id='summary.PosteriorBSVARMIX'>Provides posterior summary of non-normal Structural VAR estimation</h2><span id='topic+summary.PosteriorBSVARMIX'></span>

<h3>Description</h3>

<p>Provides posterior mean, standard deviations, as well as 5 and 95 
percentiles of the parameters: the structural matrix <code class="reqn">B</code>, autoregressive 
parameters <code class="reqn">A</code>, and hyper parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMIX'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PosteriorBSVARMIX_+3A_object">object</code></td>
<td>
<p>an object of class PosteriorBSVARMIX obtained using the
<code>estimate()</code> function applied to non-normal Bayesian Structural VAR
model specification set by function <code>specify_bsvar_mix$new()</code> containing 
draws from the  posterior distribution of the parameters.</p>
</td></tr>
<tr><td><code id="summary.PosteriorBSVARMIX_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list reporting the posterior mean, standard deviations, as well as 5 and 95 
percentiles of the parameters: the structural matrix <code class="reqn">B</code>, autoregressive 
parameters <code class="reqn">A</code>, and hyper-parameters.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+specify_bsvar_mix">specify_bsvar_mix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_mix$new(us_fiscal_lsuw)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, thin = 1)
summary(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  summary()

</code></pre>

<hr>
<h2 id='summary.PosteriorBSVARMSH'>Provides posterior summary of heteroskedastic Structural VAR estimation</h2><span id='topic+summary.PosteriorBSVARMSH'></span>

<h3>Description</h3>

<p>Provides posterior mean, standard deviations, as well as 5 and 95 
percentiles of the parameters: the structural matrix <code class="reqn">B</code>, autoregressive 
parameters <code class="reqn">A</code>, and hyper parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMSH'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PosteriorBSVARMSH_+3A_object">object</code></td>
<td>
<p>an object of class PosteriorBSVARMSH obtained using the
<code>estimate()</code> function applied to heteroskedastic Bayesian Structural VAR
model specification set by function <code>specify_bsvar_msh$new()</code> containing 
draws from the  posterior distribution of the parameters.</p>
</td></tr>
<tr><td><code id="summary.PosteriorBSVARMSH_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list reporting the posterior mean, standard deviations, as well as 5 and 95 
percentiles of the parameters: the structural matrix <code class="reqn">B</code>, autoregressive 
parameters <code class="reqn">A</code>, and hyper-parameters.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+specify_bsvar_msh">specify_bsvar_msh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, thin = 1)
summary(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  summary()

</code></pre>

<hr>
<h2 id='summary.PosteriorBSVARSV'>Provides posterior summary of heteroskedastic Structural VAR estimation</h2><span id='topic+summary.PosteriorBSVARSV'></span>

<h3>Description</h3>

<p>Provides posterior mean, standard deviations, as well as 5 and 95 
percentiles of the parameters: the structural matrix <code class="reqn">B</code>, autoregressive 
parameters <code class="reqn">A</code>, and hyper parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSV'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PosteriorBSVARSV_+3A_object">object</code></td>
<td>
<p>an object of class PosteriorBSVARSV obtained using the
<code>estimate()</code> function applied to heteroskedastic Bayesian Structural VAR
model specification set by function <code>specify_bsvar_sv$new()</code> containing 
draws from the  posterior distribution of the parameters.</p>
</td></tr>
<tr><td><code id="summary.PosteriorBSVARSV_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list reporting the posterior mean, standard deviations, as well as 5 and 95 
percentiles of the parameters: the structural matrix <code class="reqn">B</code>, autoregressive 
parameters <code class="reqn">A</code>, and hyper-parameters.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+specify_bsvar_sv">specify_bsvar_sv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, thin = 1)
summary(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  summary()

</code></pre>

<hr>
<h2 id='summary.PosteriorFEVD'>Provides posterior summary of forecast error variance decompositions</h2><span id='topic+summary.PosteriorFEVD'></span>

<h3>Description</h3>

<p>Provides posterior means of the forecast error variance 
decompositions of each variable at all horizons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorFEVD'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PosteriorFEVD_+3A_object">object</code></td>
<td>
<p>an object of class PosteriorFEVD obtained using the
<code>compute_variance_decompositions()</code> function containing draws from the 
posterior distribution of the forecast error variance decompositions.</p>
</td></tr>
<tr><td><code id="summary.PosteriorFEVD_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list reporting the posterior mean of the forecast error variance 
decompositions of each variable at all horizons.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_variance_decompositions">compute_variance_decompositions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, thin = 1)

# compute forecast error variance decompositions
fevd           = compute_variance_decompositions(posterior, horizon = 4)
fevd_summary   = summary(fevd)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  compute_variance_decompositions(horizon = 4) |&gt;
  summary() -&gt; fevd_summary

</code></pre>

<hr>
<h2 id='summary.PosteriorFitted'>Provides posterior summary of variables' fitted values</h2><span id='topic+summary.PosteriorFitted'></span>

<h3>Description</h3>

<p>Provides posterior summary of the fitted values including their 
mean, standard deviations, as well as 5 and 95 percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorFitted'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PosteriorFitted_+3A_object">object</code></td>
<td>
<p>an object of class PosteriorFitted obtained using the
<code>compute_fitted_values()</code> function containing draws the predictive 
density of the sample data.</p>
</td></tr>
<tr><td><code id="summary.PosteriorFitted_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list reporting the posterior mean, standard deviations, as well as 
5 and 95 percentiles of the fitted values for each of the shocks and periods.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_fitted_values">compute_fitted_values</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, thin = 1)

# compute fitted values
fitted         = compute_fitted_values(posterior)
fitted_summary = summary(fitted)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  compute_fitted_values() |&gt;
  summary() -&gt; fitted_summary

</code></pre>

<hr>
<h2 id='summary.PosteriorHD'>Provides posterior summary of historical decompositions</h2><span id='topic+summary.PosteriorHD'></span>

<h3>Description</h3>

<p>Provides posterior means of the historical decompositions variable
by variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorHD'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PosteriorHD_+3A_object">object</code></td>
<td>
<p>an object of class PosteriorHD obtained using the
<code>compute_historical_decompositions()</code> function containing posterior draws
of historical decompositions.</p>
</td></tr>
<tr><td><code id="summary.PosteriorHD_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list reporting the posterior means of historical decompositions for
each of the variables.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_historical_decompositions">compute_historical_decompositions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(diff(us_fiscal_lsuw))

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, thin = 1)

# compute historical decompositions
hds            = compute_historical_decompositions(posterior)
hds_summary    = summary(hds)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
diff(us_fiscal_lsuw) |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  compute_historical_decompositions() |&gt;
  summary() -&gt; hds_summary

</code></pre>

<hr>
<h2 id='summary.PosteriorIR'>Provides posterior summary of impulse responses</h2><span id='topic+summary.PosteriorIR'></span>

<h3>Description</h3>

<p>Provides posterior summary of the impulse responses of each 
variable to each of the shocks at all horizons. Includes their posterior 
means, standard deviations, as well as 5 and 95 percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorIR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PosteriorIR_+3A_object">object</code></td>
<td>
<p>an object of class PosteriorIR obtained using the
<code>compute_impulse_responses()</code> function containing draws from the posterior
distribution of the impulse responses.</p>
</td></tr>
<tr><td><code id="summary.PosteriorIR_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list reporting the posterior mean, standard deviations, as well as 
5 and 95 percentiles of the impulse responses of each variable to each of the 
shocks at all horizons.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_impulse_responses">compute_impulse_responses</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, thin = 1)

# compute impulse responses
irf            = compute_impulse_responses(posterior, horizon = 4)
irf_summary    = summary(irf)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  compute_impulse_responses(horizon = 4) |&gt;
  summary() -&gt; irf_summary

</code></pre>

<hr>
<h2 id='summary.PosteriorRegimePr'>Provides posterior summary of regime probabilities</h2><span id='topic+summary.PosteriorRegimePr'></span>

<h3>Description</h3>

<p>Provides posterior summary of regime probabilities 
including their mean, standard deviations, as well as 5 and 95 percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorRegimePr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PosteriorRegimePr_+3A_object">object</code></td>
<td>
<p>an object of class PosteriorRegimePr obtained using the
<code>compute_regime_probabilities()</code> function containing posterior draws of 
regime allocations.</p>
</td></tr>
<tr><td><code id="summary.PosteriorRegimePr_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list reporting the posterior mean and standard deviations of the
regime probabilities.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_regime_probabilities">compute_regime_probabilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_msh$new(us_fiscal_lsuw)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, thin = 1)

# compute regime probabilities
rp             = compute_regime_probabilities(posterior)
rp_summary     = summary(rp)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  compute_regime_probabilities() |&gt;
  summary() -&gt; rp_summary

</code></pre>

<hr>
<h2 id='summary.PosteriorShocks'>Provides posterior summary of structural shocks</h2><span id='topic+summary.PosteriorShocks'></span>

<h3>Description</h3>

<p>Provides posterior summary of the structural shocks including their 
mean, standard deviations, as well as 5 and 95 percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorShocks'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PosteriorShocks_+3A_object">object</code></td>
<td>
<p>an object of class PosteriorShocks obtained using the
<code>compute_structural_shocks()</code> function containing draws the posterior
distribution of the structural shocks.</p>
</td></tr>
<tr><td><code id="summary.PosteriorShocks_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list reporting the posterior mean, standard deviations, as well as 
5 and 95 percentiles of the structural shocks for each of the equations and periods.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_structural_shocks">compute_structural_shocks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar$new(us_fiscal_lsuw)

# run the burn-in
burn_in        = estimate(specification, 10)

# estimate the model
posterior      = estimate(burn_in, 20, thin = 1)

# compute structural shocks
shocks         = compute_structural_shocks(posterior)
shocks_summary = summary(shocks)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new() |&gt;
  estimate(S = 10) |&gt; 
  estimate(S = 20, thin = 1) |&gt; 
  compute_structural_shocks() |&gt;
  summary() -&gt; shocks_summary

</code></pre>

<hr>
<h2 id='summary.PosteriorSigma'>Provides posterior summary of structural shocks' conditional standard 
deviations</h2><span id='topic+summary.PosteriorSigma'></span>

<h3>Description</h3>

<p>Provides posterior summary of structural shocks' conditional 
standard deviations including their mean, standard deviations, as well as 
5 and 95 percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorSigma'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PosteriorSigma_+3A_object">object</code></td>
<td>
<p>an object of class PosteriorSigma obtained using the
<code>compute_conditional_sd()</code> function containing posterior draws of 
conditional standard deviations of structural shocks.</p>
</td></tr>
<tr><td><code id="summary.PosteriorSigma_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list reporting the posterior mean, standard deviations, as well as 
5 and 95 percentiles of the structural shocks' conditional standard deviations
for each of the shocks and periods.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_conditional_sd">compute_conditional_sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
set.seed(123)
specification  = specify_bsvar_sv$new(us_fiscal_lsuw)

# run the burn-in
burn_in        = estimate(specification, 5)

# estimate the model
posterior      = estimate(burn_in, 5)

# compute structural shocks' conditional standard deviations
sigma          = compute_conditional_sd(posterior)
sigma_summary  = summary(sigma)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new() |&gt;
  estimate(S = 5) |&gt; 
  estimate(S = 5) |&gt; 
  compute_conditional_sd() |&gt;
  summary() -&gt; sigma_summary

</code></pre>

<hr>
<h2 id='summary.SDDRautoregression'>Provides summary of verifying hypotheses about autoregressive parameters</h2><span id='topic+summary.SDDRautoregression'></span>

<h3>Description</h3>

<p>Provides summary of the Savage-Dickey density ratios
for verification of hypotheses about autoregressive parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SDDRautoregression'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.SDDRautoregression_+3A_object">object</code></td>
<td>
<p>an object of class <code>SDDRautoregression</code> obtained using the
<code>verify_autoregression()</code> function.</p>
</td></tr>
<tr><td><code id="summary.SDDRautoregression_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table reporting the logarithm of Bayes factors of the restriction
against no restriction posterior odds in <code>"log(SDDR)"</code>, 
its numerical standard error <code>"NSE"</code>, and the implied posterior 
probability of the restriction holding or not hypothesis, 
<code>"Pr[H0|data]"</code> and <code>"Pr[H1|data]"</code> 
respectively.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+verify_autoregression">verify_autoregression</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# verify autoregression
H0             = matrix(NA, ncol(us_fiscal_lsuw), ncol(us_fiscal_lsuw) + 1)
H0[1,3]        = 0        # a hypothesis of no Granger causality from gdp to ttr
sddr           = verify_autoregression(posterior, H0)
summary(sddr)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 10, thin = 1) |&gt; 
  verify_autoregression(hypothesis = H0) |&gt; 
  summary() -&gt; sddr_summary

</code></pre>

<hr>
<h2 id='summary.SDDRvolatility'>Provides summary of verifying homoskedasticity</h2><span id='topic+summary.SDDRvolatility'></span>

<h3>Description</h3>

<p>Provides summary of the Savage-Dickey density ratios
for verification of structural shocks homoskedasticity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SDDRvolatility'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.SDDRvolatility_+3A_object">object</code></td>
<td>
<p>an object of class <code>SDDRvolatility</code> obtained using the
<code>verify_volatility()</code> function.</p>
</td></tr>
<tr><td><code id="summary.SDDRvolatility_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table reporting the logarithm of Bayes factors of homoskedastic to
heteroskedastic posterior odds <code>"log(SDDR)"</code> for each structural shock, 
their numerical standard errors <code>"NSE"</code>, and the implied posterior 
probability of the homoskedasticity and heteroskedasticity hypothesis, 
<code>"Pr[homoskedasticity|data]"</code> and <code>"Pr[heteroskedasticity|data]"</code> 
respectively.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+verify_volatility">verify_volatility</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 1, M = 2)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# verify heteroskedasticity
sddr           = verify_volatility(posterior)
summary(sddr)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10, thin = 1) |&gt; 
  verify_volatility() |&gt; 
  summary() -&gt; sddr_summary

</code></pre>

<hr>
<h2 id='us_fiscal_ex'>A 3-variable system of exogenous variables for the US fiscal model for 
the period 1948 Q1 &ndash; 2024 Q1</h2><span id='topic+us_fiscal_ex'></span>

<h3>Description</h3>

<p>Exogenous variables used to identify the US fiscal policy shocks.
Last data update was implemented on 2024-06-15.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(us_fiscal_ex)
</code></pre>


<h3>Format</h3>

<p>A matrix and a <code>ts</code> object with time series of over three hundred observations on 3 variables:
</p>

<dl>
<dt>t</dt><dd><p>a time trend</p>
</dd>
<dt>t^2</dt><dd><p>a quadratic trend</p>
</dd>
<dt>1975Q2</dt><dd><p>a dummy variable taking the value of 1 for quarter 2 1975 and zero elsewhere</p>
</dd>
</dl>

<p>The series are as described by Mertens &amp; Ravn (2014). The data was used by 
Lütkepohl, Shang, Uzeda, Woźniak (2024).
</p>


<h3>References</h3>

<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>
<p>Mertens, K., and Ravn, M.O. (2014) A Reconciliation of SVAR and Narrative Estimates of Tax Multipliers, <em>Journal of Monetary Economics</em>, 68(S), S1–S19. DOI: <a href="https://doi.org/10.1016/j.jmoneco.2013.04.004">doi:10.1016/j.jmoneco.2013.04.004</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_ex)   # upload the data
plot(us_fiscal_ex)   # plot the data
</code></pre>

<hr>
<h2 id='us_fiscal_lsuw'>A 3-variable US fiscal system for the period 1948 Q1 &ndash; 2024 Q1</h2><span id='topic+us_fiscal_lsuw'></span>

<h3>Description</h3>

<p>A system used to identify the US fiscal policy shocks. 
Last data update was implemented on 2024-06-15.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)
</code></pre>


<h3>Format</h3>

<p>A matrix and a <code>ts</code> object with time series of over three hundred observations on 3 variables:
</p>

<dl>
<dt>ttr</dt><dd><p>quarterly US total tax revenue expressed in log, real, per person terms</p>
</dd>
<dt>gs</dt><dd><p>quarterly US total government spending expressed in log, real, per person terms</p>
</dd>
<dt>gdp</dt><dd><p>quarterly US gross domestic product expressed in log, real, per person terms</p>
</dd>
</dl>

<p>The series are as described by Mertens &amp; Ravn (2014) in footnote 3 and main body on page S3 of the paper. 
Differences with respect to Mertens &amp; Ravn's data :
</p>

<ul>
<li><p> The sample period is from quarter 1 of 1948 to the last available observation,
</p>
</li>
<li><p> The population variable is not from Francis &amp; Ramey (2009) but from the FRED (with the same definition),
</p>
</li>
<li><p> The original monthly population data is transformed to quarterly by taking monthly averages.
</p>
</li></ul>



<h3>Source</h3>

<p>U.S. Bureau of Economic Analysis, National Income and Product Accounts, <a href="https://www.bea.gov/">https://www.bea.gov/</a>
</p>
<p>FRED Economic Database, Federal Reserve Bank of St. Louis, <a href="https://fred.stlouisfed.org/">https://fred.stlouisfed.org/</a>
</p>


<h3>References</h3>

<p>Francis, N., and Ramey, V.A. (2009) Measures of per capita Hours and Their Implications for the Technology‐hours Debate. <em>Journal of Money, Credit and Banking</em>, 41(6), 1071-1097, DOI: <a href="https://doi.org/10.1111/j.1538-4616.2009.00247.x">doi:10.1111/j.1538-4616.2009.00247.x</a>.
</p>
<p>Mertens, K., and Ravn, M.O. (2014) A Reconciliation of SVAR and Narrative Estimates of Tax Multipliers, <em>Journal of Monetary Economics</em>, 68(S), S1–S19. DOI: <a href="https://doi.org/10.1016/j.jmoneco.2013.04.004">doi:10.1016/j.jmoneco.2013.04.004</a>.
</p>
<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(us_fiscal_lsuw)   # upload the data
plot(us_fiscal_lsuw)   # plot the data
</code></pre>

<hr>
<h2 id='verify_autoregression'>Verifies hypotheses involving autoregressive parameters</h2><span id='topic+verify_autoregression'></span>

<h3>Description</h3>

<p>Computes the logarithm of Bayes factor for the joint hypothesis, 
<code class="reqn">H_0</code>, possibly for many autoregressive parameters represented by argument 
<code>hypothesis</code> via Savage-Dickey Density Ration (SDDR).
The logarithm of Bayes factor for this hypothesis can be computed using the SDDR 
as the difference of logarithms of the marginal posterior distribution ordinate at the restriction 
less the marginal prior distribution ordinate at the same point:
</p>
<p style="text-align: center;"><code class="reqn">log p(H_0 | data) - log p(H_0)</code>
</p>

<p>Therefore, a negative value of the difference is the evidence against 
hypothesis. The estimation of both elements of the difference requires 
numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_autoregression(posterior, hypothesis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_autoregression_+3A_posterior">posterior</code></td>
<td>
<p>the <code>posterior</code> element of the list from the estimation outcome</p>
</td></tr>
<tr><td><code id="verify_autoregression_+3A_hypothesis">hypothesis</code></td>
<td>
<p>an <code>NxK</code> matrix of the same dimension as the autoregressive 
matrix <code class="reqn">A</code> with numeric values for the parameters to be verified,
in which case the values represent the joint hypothesis, and missing value <code>NA</code> 
for these parameters that are not tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SDDRautoregression</code> that is a list of three components:
</p>
<p><code>logSDDR</code> a scalar with values of the logarithm of the Bayes factors for 
the autoregressive hypothesis for each of the shocks
</p>
<p><code>log_SDDR_se</code> an <code>N</code>-vector with estimation standard errors of the logarithm of 
the Bayes factors reported in output element <code>logSDDR</code> that are computed based on 30 random 
sub-samples of the log-ordinates of the marginal posterior and prior distributions.
</p>
<p><code>components</code> a list of three components for the computation of the Bayes factor
</p>

<dl>
<dt>log_denominator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor denominators</p>
</dd>
<dt>log_numerator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor numerators</p>
</dd>
<dt>log_numerator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the numerator</p>
</dd>
<dt>log_denominator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the denominator</p>
</dd>
<dt>se_components</dt><dd><p>a <code>30</code>-vector containing the log-Bayes factors on the basis of which the standard errors are computed</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Woźniak, T., and Droumaguet, M., (2024) Bayesian Assessment of Identifying Restrictions for Heteroskedastic Structural VARs
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# verify autoregression
H0             = matrix(NA, ncol(us_fiscal_lsuw), ncol(us_fiscal_lsuw) + 1)
H0[1,3]        = 0        # a hypothesis of no Granger causality from gdp to ttr
sddr           = verify_autoregression(posterior, H0)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10, thin = 1) |&gt; 
  verify_autoregression(hypothesis = H0) -&gt; sddr

</code></pre>

<hr>
<h2 id='verify_autoregression.PosteriorBSVAR'>Verifies hypotheses involving autoregressive parameters</h2><span id='topic+verify_autoregression.PosteriorBSVAR'></span>

<h3>Description</h3>

<p>Computes the logarithm of Bayes factor for the joint hypothesis, 
<code class="reqn">H_0</code>, possibly for many autoregressive parameters represented by argument 
<code>hypothesis</code> via Savage-Dickey Density Ration (SDDR).
The logarithm of Bayes factor for this hypothesis can be computed using the SDDR 
as the difference of logarithms of the marginal posterior distribution ordinate at the restriction 
less the marginal prior distribution ordinate at the same point:
</p>
<p style="text-align: center;"><code class="reqn">log p(H_0 | data) - log p(H_0)</code>
</p>

<p>Therefore, a negative value of the difference is the evidence against 
hypothesis. The estimation of both elements of the difference requires 
numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVAR'
verify_autoregression(posterior, hypothesis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_autoregression.PosteriorBSVAR_+3A_posterior">posterior</code></td>
<td>
<p>the <code>posterior</code> element of the list from the estimation outcome</p>
</td></tr>
<tr><td><code id="verify_autoregression.PosteriorBSVAR_+3A_hypothesis">hypothesis</code></td>
<td>
<p>an <code>NxK</code> matrix of the same dimension as the autoregressive 
matrix <code class="reqn">A</code> with numeric values for the parameters to be verified,
in which case the values represent the joint hypothesis, and missing value <code>NA</code> 
for these parameters that are not tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SDDRautoregression</code> that is a list of three components:
</p>
<p><code>logSDDR</code> a scalar with values of the logarithm of the Bayes factors for 
the autoregressive hypothesis for each of the shocks
</p>
<p><code>log_SDDR_se</code> an <code>N</code>-vector with estimation standard errors of the logarithm of 
the Bayes factors reported in output element <code>logSDDR</code> that are computed based on 30 random 
sub-samples of the log-ordinates of the marginal posterior and prior distributions.
</p>
<p><code>components</code> a list of three components for the computation of the Bayes factor
</p>

<dl>
<dt>log_denominator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor denominators</p>
</dd>
<dt>log_numerator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor numerators</p>
</dd>
<dt>log_numerator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the numerator</p>
</dd>
<dt>log_denominator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the denominator</p>
</dd>
<dt>se_components</dt><dd><p>a <code>30</code>-vector containing the log-Bayes factors on the basis of which the standard errors are computed</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Woźniak, T., and Droumaguet, M., (2024) Bayesian Assessment of Identifying Restrictions for Heteroskedastic Structural VARs
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# verify autoregression
H0             = matrix(NA, ncol(us_fiscal_lsuw), ncol(us_fiscal_lsuw) + 1)
H0[1,3]        = 0        # a hypothesis of no Granger causality from gdp to ttr
sddr           = verify_autoregression(posterior, H0)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10, thin = 1) |&gt; 
  verify_autoregression(hypothesis = H0) -&gt; sddr

</code></pre>

<hr>
<h2 id='verify_autoregression.PosteriorBSVARMIX'>Verifies hypotheses involving autoregressive parameters</h2><span id='topic+verify_autoregression.PosteriorBSVARMIX'></span>

<h3>Description</h3>

<p>Computes the logarithm of Bayes factor for the joint hypothesis, 
<code class="reqn">H_0</code>, possibly for many autoregressive parameters represented by argument 
<code>hypothesis</code> via Savage-Dickey Density Ration (SDDR).
The logarithm of Bayes factor for this hypothesis can be computed using the SDDR 
as the difference of logarithms of the marginal posterior distribution ordinate at the restriction 
less the marginal prior distribution ordinate at the same point:
</p>
<p style="text-align: center;"><code class="reqn">log p(H_0 | data) - log p(H_0)</code>
</p>

<p>Therefore, a negative value of the difference is the evidence against 
hypothesis. The estimation of both elements of the difference requires 
numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMIX'
verify_autoregression(posterior, hypothesis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_autoregression.PosteriorBSVARMIX_+3A_posterior">posterior</code></td>
<td>
<p>the <code>posterior</code> element of the list from the estimation outcome</p>
</td></tr>
<tr><td><code id="verify_autoregression.PosteriorBSVARMIX_+3A_hypothesis">hypothesis</code></td>
<td>
<p>an <code>NxK</code> matrix of the same dimension as the autoregressive 
matrix <code class="reqn">A</code> with numeric values for the parameters to be verified,
in which case the values represent the joint hypothesis, and missing value <code>NA</code> 
for these parameters that are not tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SDDRautoregression</code> that is a list of three components:
</p>
<p><code>logSDDR</code> a scalar with values of the logarithm of the Bayes factors for 
the autoregressive hypothesis for each of the shocks
</p>
<p><code>log_SDDR_se</code> an <code>N</code>-vector with estimation standard errors of the logarithm of 
the Bayes factors reported in output element <code>logSDDR</code> that are computed based on 30 random 
sub-samples of the log-ordinates of the marginal posterior and prior distributions.
</p>
<p><code>components</code> a list of three components for the computation of the Bayes factor
</p>

<dl>
<dt>log_denominator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor denominators</p>
</dd>
<dt>log_numerator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor numerators</p>
</dd>
<dt>log_numerator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the numerator</p>
</dd>
<dt>log_denominator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the denominator</p>
</dd>
<dt>se_components</dt><dd><p>a <code>30</code>-vector containing the log-Bayes factors on the basis of which the standard errors are computed</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Woźniak, T., and Droumaguet, M., (2024) Bayesian Assessment of Identifying Restrictions for Heteroskedastic Structural VARs
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 1, M = 2)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# verify autoregression
H0             = matrix(NA, ncol(us_fiscal_lsuw), ncol(us_fiscal_lsuw) + 1)
H0[1,3]        = 0        # a hypothesis of no Granger causality from gdp to ttr
sddr           = verify_autoregression(posterior, H0)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 10, thin = 1) |&gt; 
  verify_autoregression(hypothesis = H0) -&gt; sddr

</code></pre>

<hr>
<h2 id='verify_autoregression.PosteriorBSVARMSH'>Verifies hypotheses involving autoregressive parameters</h2><span id='topic+verify_autoregression.PosteriorBSVARMSH'></span>

<h3>Description</h3>

<p>Computes the logarithm of Bayes factor for the joint hypothesis, 
<code class="reqn">H_0</code>, possibly for many autoregressive parameters represented by argument 
<code>hypothesis</code> via Savage-Dickey Density Ration (SDDR).
The logarithm of Bayes factor for this hypothesis can be computed using the SDDR 
as the difference of logarithms of the marginal posterior distribution ordinate at the restriction 
less the marginal prior distribution ordinate at the same point:
</p>
<p style="text-align: center;"><code class="reqn">log p(H_0 | data) - log p(H_0)</code>
</p>

<p>Therefore, a negative value of the difference is the evidence against 
hypothesis. The estimation of both elements of the difference requires 
numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMSH'
verify_autoregression(posterior, hypothesis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_autoregression.PosteriorBSVARMSH_+3A_posterior">posterior</code></td>
<td>
<p>the <code>posterior</code> element of the list from the estimation outcome</p>
</td></tr>
<tr><td><code id="verify_autoregression.PosteriorBSVARMSH_+3A_hypothesis">hypothesis</code></td>
<td>
<p>an <code>NxK</code> matrix of the same dimension as the autoregressive 
matrix <code class="reqn">A</code> with numeric values for the parameters to be verified,
in which case the values represent the joint hypothesis, and missing value <code>NA</code> 
for these parameters that are not tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SDDRautoregression</code> that is a list of three components:
</p>
<p><code>logSDDR</code> a scalar with values of the logarithm of the Bayes factors for 
the autoregressive hypothesis for each of the shocks
</p>
<p><code>log_SDDR_se</code> an <code>N</code>-vector with estimation standard errors of the logarithm of 
the Bayes factors reported in output element <code>logSDDR</code> that are computed based on 30 random 
sub-samples of the log-ordinates of the marginal posterior and prior distributions.
</p>
<p><code>components</code> a list of three components for the computation of the Bayes factor
</p>

<dl>
<dt>log_denominator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor denominators</p>
</dd>
<dt>log_numerator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor numerators</p>
</dd>
<dt>log_numerator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the numerator</p>
</dd>
<dt>log_denominator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the denominator</p>
</dd>
<dt>se_components</dt><dd><p>a <code>30</code>-vector containing the log-Bayes factors on the basis of which the standard errors are computed</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Woźniak, T., and Droumaguet, M., (2024) Bayesian Assessment of Identifying Restrictions for Heteroskedastic Structural VARs
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 1, M = 2)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# verify autoregression
H0             = matrix(NA, ncol(us_fiscal_lsuw), ncol(us_fiscal_lsuw) + 1)
H0[1,3]        = 0        # a hypothesis of no Granger causality from gdp to ttr
sddr           = verify_autoregression(posterior, H0)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10, thin = 1) |&gt; 
  verify_autoregression(hypothesis = H0) -&gt; sddr

</code></pre>

<hr>
<h2 id='verify_autoregression.PosteriorBSVARSV'>Verifies hypotheses involving autoregressive parameters</h2><span id='topic+verify_autoregression.PosteriorBSVARSV'></span>

<h3>Description</h3>

<p>Computes the logarithm of Bayes factor for the joint hypothesis, 
<code class="reqn">H_0</code>, possibly for many autoregressive parameters represented by argument 
<code>hypothesis</code> via Savage-Dickey Density Ration (SDDR).
The logarithm of Bayes factor for this hypothesis can be computed using the SDDR 
as the difference of logarithms of the marginal posterior distribution ordinate at the restriction 
less the marginal prior distribution ordinate at the same point:
</p>
<p style="text-align: center;"><code class="reqn">log p(H_0 | data) - log p(H_0)</code>
</p>

<p>Therefore, a negative value of the difference is the evidence against 
hypothesis. The estimation of both elements of the difference requires 
numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSV'
verify_autoregression(posterior, hypothesis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_autoregression.PosteriorBSVARSV_+3A_posterior">posterior</code></td>
<td>
<p>the <code>posterior</code> element of the list from the estimation outcome</p>
</td></tr>
<tr><td><code id="verify_autoregression.PosteriorBSVARSV_+3A_hypothesis">hypothesis</code></td>
<td>
<p>an <code>NxK</code> matrix of the same dimension as the autoregressive 
matrix <code class="reqn">A</code> with numeric values for the parameters to be verified,
in which case the values represent the joint hypothesis, and missing value <code>NA</code> 
for these parameters that are not tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SDDRautoregression</code> that is a list of three components:
</p>
<p><code>logSDDR</code> a scalar with values of the logarithm of the Bayes factors for 
the autoregressive hypothesis for each of the shocks
</p>
<p><code>log_SDDR_se</code> an <code>N</code>-vector with estimation standard errors of the logarithm of 
the Bayes factors reported in output element <code>logSDDR</code> that are computed based on 30 random 
sub-samples of the log-ordinates of the marginal posterior and prior distributions.
</p>
<p><code>components</code> a list of three components for the computation of the Bayes factor
</p>

<dl>
<dt>log_denominator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor denominators</p>
</dd>
<dt>log_numerator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor numerators</p>
</dd>
<dt>log_numerator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the numerator</p>
</dd>
<dt>log_denominator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the denominator</p>
</dd>
<dt>se_components</dt><dd><p>a <code>30</code>-vector containing the log-Bayes factors on the basis of which the standard errors are computed</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Woźniak, T., and Droumaguet, M., (2024) Bayesian Assessment of Identifying Restrictions for Heteroskedastic Structural VARs
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# verify autoregression
H0             = matrix(NA, ncol(us_fiscal_lsuw), ncol(us_fiscal_lsuw) + 1)
H0[1,3]        = 0        # a hypothesis of no Granger causality from gdp to ttr
sddr           = verify_autoregression(posterior, H0)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 10, thin = 1) |&gt; 
  verify_autoregression(hypothesis = H0) -&gt; sddr

</code></pre>

<hr>
<h2 id='verify_volatility'>Verifies heteroskedasticity of structural shocks equation by equation</h2><span id='topic+verify_volatility'></span>

<h3>Description</h3>

<p>Computes the logarithm of Bayes factor for the homoskedasticity hypothesis 
for each of the structural shocks via Savage-Dickey Density Ration (SDDR).
The hypothesis of homoskedasticity, <code class="reqn">H_0</code>, is represented by model-specific restrictions.
Consult help files for individual classes of models for details.
The logarithm of Bayes factor for this hypothesis can be computed using the SDDR 
as the difference of logarithms of the marginal posterior distribution ordinate at the restriction 
less the marginal prior distribution ordinate at the same point:
</p>
<p style="text-align: center;"><code class="reqn">log p(H_0 | data) - log p(H_0)</code>
</p>

<p>Therefore, a negative value of the difference is the evidence against 
homoskedasticity of the structural shock. The estimation of both elements of the difference requires 
numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_volatility(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_volatility_+3A_posterior">posterior</code></td>
<td>
<p>the <code>posterior</code> element of the list from the estimation outcome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SDDRvolatility</code> that is a list of three components:
</p>
<p><code>logSDDR</code> an <code>N</code>-vector with values of the logarithm of the Bayes factors for 
the homoskedasticity hypothesis for each of the shocks
</p>
<p><code>log_SDDR_se</code> an <code>N</code>-vector with estimation standard errors of the logarithm of 
the Bayes factors reported in output element <code>logSDDR</code> that are computed based on 30 random 
sub-samples of the log-ordinates of the marginal posterior and prior distributions.
</p>
<p><code>components</code> a list of three components for the computation of the Bayes factor
</p>

<dl>
<dt>log_denominator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor denominators</p>
</dd>
<dt>log_numerator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor numerators</p>
</dd>
<dt>log_numerator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the numerator</p>
</dd>
<dt>se_components</dt><dd><p>an <code>Nx30</code> matrix containing the log-Bayes factors on the basis of which the standard errors are computed</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Lütkepohl, H., and Woźniak, T., (2020) Bayesian Inference for Structural Vector Autoregressions Identified by Markov-Switching Heteroskedasticity. <em>Journal of Economic Dynamics and Control</em> <b>113</b>, 103862, <a href="https://doi.org/10.1016/j.jedc.2020.103862">doi:10.1016/j.jedc.2020.103862</a>.
</p>
<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# verify heteroskedasticity
sddr           = verify_volatility(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 10, thin = 1) |&gt; 
  verify_volatility() -&gt; sddr

</code></pre>

<hr>
<h2 id='verify_volatility.PosteriorBSVAR'>Verifies heteroskedasticity of structural shocks equation by equation</h2><span id='topic+verify_volatility.PosteriorBSVAR'></span>

<h3>Description</h3>

<p>Displays information that the model is homoskedastic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVAR'
verify_volatility(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_volatility.PosteriorBSVAR_+3A_posterior">posterior</code></td>
<td>
<p>the <code>posterior</code> element of the list from the estimation outcome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Just displays a message: The model is homoskedastic.
</p>


<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Lütkepohl, H., and Woźniak, T., (2020) Bayesian Inference for Structural Vector Autoregressions Identified by Markov-Switching Heteroskedasticity. <em>Journal of Economic Dynamics and Control</em> <b>113</b>, 103862, <a href="https://doi.org/10.1016/j.jedc.2020.103862">doi:10.1016/j.jedc.2020.103862</a>.
</p>
<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar$new(us_fiscal_lsuw, p = 1)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# verify heteroskedasticity
sddr           = verify_volatility(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar$new(p = 1) |&gt;
  estimate(S = 10, thin = 1) |&gt; 
  verify_volatility() -&gt; sddr
  
</code></pre>

<hr>
<h2 id='verify_volatility.PosteriorBSVARMIX'>Verifies heteroskedasticity of structural shocks equation by equation</h2><span id='topic+verify_volatility.PosteriorBSVARMIX'></span>

<h3>Description</h3>

<p>Computes the logarithm of Bayes factor for the homoskedasticity hypothesis 
for each of the structural shocks via Savage-Dickey Density Ration (SDDR).
The hypothesis of homoskedasticity is represented by restriction:
</p>
<p style="text-align: center;"><code class="reqn">H_0: \sigma^2_{n.1} = ... = \sigma^2_{n.M} = 1</code>
</p>

<p>The logarithm of Bayes factor for this hypothesis can be computed using the SDDR 
as the difference of logarithms of the marginal posterior distribution ordinate at the restriction 
less the marginal prior distribution ordinate at the same point:
</p>
<p style="text-align: center;"><code class="reqn">log p(\omega_n = 0 | data) - log p(\omega_n = 0)</code>
</p>

<p>Therefore, a negative value of the difference is the evidence against 
homoskedasticity of the structural shock. The estimation of both elements of the difference requires 
numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMIX'
verify_volatility(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_volatility.PosteriorBSVARMIX_+3A_posterior">posterior</code></td>
<td>
<p>the <code>posterior</code> element of the list from the estimation outcome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SDDRvolatility</code> that is a list of three components:
</p>
<p><code>logSDDR</code> an <code>N</code>-vector with values of the logarithm of the Bayes factors for 
the homoskedasticity hypothesis for each of the shocks
</p>
<p><code>log_SDDR_se</code> an <code>N</code>-vector with estimation standard errors of the logarithm of 
the Bayes factors reported in output element <code>logSDDR</code> that are computed based on 30 random 
sub-samples of the log-ordinates of the marginal posterior and prior distributions.
</p>
<p><code>components</code> a list of three components for the computation of the Bayes factor
</p>

<dl>
<dt>log_denominator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor denominators</p>
</dd>
<dt>log_numerator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor numerators</p>
</dd>
<dt>log_numerator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the numerator</p>
</dd>
<dt>se_components</dt><dd><p>an <code>Nx30</code> matrix containing the log-Bayes factors on the basis of which the standard errors are computed</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Lütkepohl, H., and Woźniak, T., (2020) Bayesian Inference for Structural Vector Autoregressions Identified by Markov-Switching Heteroskedasticity. <em>Journal of Economic Dynamics and Control</em> <b>113</b>, 103862, <a href="https://doi.org/10.1016/j.jedc.2020.103862">doi:10.1016/j.jedc.2020.103862</a>.
</p>
<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_bsvar_mix">specify_bsvar_mix</a></code>, <code><a href="#topic+estimate">estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_mix$new(us_fiscal_lsuw, p = 1, M = 2)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# verify heteroskedasticity
sddr           = verify_volatility(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_mix$new(p = 1, M = 2) |&gt;
  estimate(S = 10, thin = 1) |&gt; 
  verify_volatility() -&gt; sddr
  
</code></pre>

<hr>
<h2 id='verify_volatility.PosteriorBSVARMSH'>Verifies heteroskedasticity of structural shocks equation by equation</h2><span id='topic+verify_volatility.PosteriorBSVARMSH'></span>

<h3>Description</h3>

<p>Computes the logarithm of Bayes factor for the homoskedasticity hypothesis 
for each of the structural shocks via Savage-Dickey Density Ration (SDDR).
The hypothesis of homoskedasticity is represented by restriction:
</p>
<p style="text-align: center;"><code class="reqn">H_0: \sigma^2_{n.1} = ... = \sigma^2_{n.M} = 1</code>
</p>

<p>The logarithm of Bayes factor for this hypothesis can be computed using the SDDR 
as the difference of logarithms of the marginal posterior distribution ordinate at the restriction 
less the marginal prior distribution ordinate at the same point:
</p>
<p style="text-align: center;"><code class="reqn">log p(\omega_n = 0 | data) - log p(\omega_n = 0)</code>
</p>

<p>Therefore, a negative value of the difference is the evidence against 
homoskedasticity of the structural shock. The estimation of both elements of the difference requires 
numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARMSH'
verify_volatility(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_volatility.PosteriorBSVARMSH_+3A_posterior">posterior</code></td>
<td>
<p>the <code>posterior</code> element of the list from the estimation outcome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SDDRvolatility</code> that is a list of three components:
</p>
<p><code>logSDDR</code> an <code>N</code>-vector with values of the logarithm of the Bayes factors for 
the homoskedasticity hypothesis for each of the shocks
</p>
<p><code>log_SDDR_se</code> an <code>N</code>-vector with estimation standard errors of the logarithm of 
the Bayes factors reported in output element <code>logSDDR</code> that are computed based on 30 random 
sub-samples of the log-ordinates of the marginal posterior and prior distributions.
</p>
<p><code>components</code> a list of three components for the computation of the Bayes factor
</p>

<dl>
<dt>log_denominator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor denominators</p>
</dd>
<dt>log_numerator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor numerators</p>
</dd>
<dt>log_numerator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the numerator</p>
</dd>
<dt>se_components</dt><dd><p>an <code>Nx30</code> matrix containing the log-Bayes factors on the basis of which the standard errors are computed</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Lütkepohl, H., and Woźniak, T., (2020) Bayesian Inference for Structural Vector Autoregressions Identified by Markov-Switching Heteroskedasticity. <em>Journal of Economic Dynamics and Control</em> <b>113</b>, 103862, <a href="https://doi.org/10.1016/j.jedc.2020.103862">doi:10.1016/j.jedc.2020.103862</a>.
</p>
<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_bsvar_msh">specify_bsvar_msh</a></code>, <code><a href="#topic+estimate">estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_msh$new(us_fiscal_lsuw, p = 1, M = 2)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# verify heteroskedasticity
sddr           = verify_volatility(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_msh$new(p = 1, M = 2) |&gt;
  estimate(S = 10, thin = 1) |&gt; 
  verify_volatility() -&gt; sddr
  
</code></pre>

<hr>
<h2 id='verify_volatility.PosteriorBSVARSV'>Verifies heteroskedasticity of structural shocks equation by equation</h2><span id='topic+verify_volatility.PosteriorBSVARSV'></span>

<h3>Description</h3>

<p>Computes the logarithm of Bayes factor for the homoskedasticity hypothesis 
for each of the structural shocks via Savage-Dickey Density Ration (SDDR).
The hypothesis of homoskedasticity is represented by restriction:
</p>
<p style="text-align: center;"><code class="reqn">H_0: \omega_n = 0</code>
</p>

<p>The logarithm of Bayes factor for this hypothesis can be computed using the SDDR 
as the difference of logarithms of the marginal posterior distribution ordinate at the restriction 
less the marginal prior distribution ordinate at the same point:
</p>
<p style="text-align: center;"><code class="reqn">log p(\omega_n = 0 | data) - log p(\omega_n = 0)</code>
</p>

<p>Therefore, a negative value of the difference is the evidence against 
homoskedasticity of the structural shock. The estimation of both elements of the difference requires 
numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PosteriorBSVARSV'
verify_volatility(posterior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_volatility.PosteriorBSVARSV_+3A_posterior">posterior</code></td>
<td>
<p>the <code>posterior</code> element of the list from the estimation outcome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SDDRvolatility</code> that is a list of three components:
</p>
<p><code>logSDDR</code> an <code>N</code>-vector with values of the logarithm of the Bayes factors for 
the homoskedasticity hypothesis for each of the shocks
</p>
<p><code>log_SDDR_se</code> an <code>N</code>-vector with estimation standard errors of the logarithm of 
the Bayes factors reported in output element <code>logSDDR</code> that are computed based on 30 random 
sub-samples of the log-ordinates of the marginal posterior and prior distributions.
</p>
<p><code>components</code> a list of three components for the computation of the Bayes factor
</p>

<dl>
<dt>log_denominator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor denominators</p>
</dd>
<dt>log_numerator</dt><dd><p>an <code>N</code>-vector with values of the logarithm of the Bayes factor numerators</p>
</dd>
<dt>log_numerator_s</dt><dd><p>an <code>NxS</code> matrix of the log-full conditional posterior density ordinates computed to estimate the numerator</p>
</dd>
<dt>se_components</dt><dd><p>an <code>Nx30</code> matrix containing the log-Bayes factors on the basis of which the standard errors are computed</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tomasz Woźniak <a href="mailto:wozniak.tom@pm.me">wozniak.tom@pm.me</a>
</p>


<h3>References</h3>

<p>Lütkepohl, H., and Woźniak, T., (2020) Bayesian Inference for Structural Vector Autoregressions Identified by Markov-Switching Heteroskedasticity. <em>Journal of Economic Dynamics and Control</em> <b>113</b>, 103862, <a href="https://doi.org/10.1016/j.jedc.2020.103862">doi:10.1016/j.jedc.2020.103862</a>.
</p>
<p>Lütkepohl, H., Shang, F., Uzeda, L., and Woźniak, T. (2024) Partial Identification of Heteroskedastic Structural VARs: Theory and Bayesian Inference. <em>University of Melbourne Working Paper</em>, 1&ndash;57, <a href="https://doi.org/10.48550/arXiv.2404.11057">doi:10.48550/arXiv.2404.11057</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_bsvar_sv">specify_bsvar_sv</a></code>, <code><a href="#topic+estimate">estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple workflow
############################################################
# upload data
data(us_fiscal_lsuw)

# specify the model and set seed
specification  = specify_bsvar_sv$new(us_fiscal_lsuw, p = 1)
set.seed(123)

# estimate the model
posterior      = estimate(specification, 10, thin = 1)

# verify heteroskedasticity
sddr           = verify_volatility(posterior)

# workflow with the pipe |&gt;
############################################################
set.seed(123)
us_fiscal_lsuw |&gt;
  specify_bsvar_sv$new(p = 1) |&gt;
  estimate(S = 10, thin = 1) |&gt; 
  verify_volatility() -&gt; sddr
  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
