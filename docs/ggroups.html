<!DOCTYPE html><html><head><title>Help for package ggroups</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggroups}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#buildA'><p>Relationship matrix <strong>A</strong></p></a></li>
<li><a href='#buildD'><p>Relationship matrix <strong>D</strong></p></a></li>
<li><a href='#gghead'><p>Append genetic groups to the pedigree</p></a></li>
<li><a href='#ggroups-package'><p>Pedigree and genetic groups</p></a></li>
<li><a href='#inb'><p>Individual's inbreeding coefficient</p></a></li>
<li><a href='#inbreed'><p>Inbreeding coefficients</p></a></li>
<li><a href='#mat2tab'><p>Matrix to tabular</p></a></li>
<li><a href='#offspring'><p>Descendants of an individual per generation</p></a></li>
<li><a href='#pedcheck'><p>Basic pedigree checks</p></a></li>
<li><a href='#peddown'><p>Downward pedigree extraction</p></a></li>
<li><a href='#pedup'><p>Upward pedigree extraction</p></a></li>
<li><a href='#pruneped'><p>Pedigree pruning</p></a></li>
<li><a href='#Qgpu'><p>Vector <strong>Qg</strong> + <strong>u</strong></p></a></li>
<li><a href='#qmat'><p>Matrix <strong>Q</strong></p></a></li>
<li><a href='#qmatL'><p>Matrix <strong>Q</strong> for large pedigrees</p></a></li>
<li><a href='#qmatXL'><p>Matrix <strong>Q</strong> for large pedigrees (parallel processing)</p></a></li>
<li><a href='#renum'><p>Pedigree renumbering</p></a></li>
<li><a href='#rg'><p>Genetic relationship coefficient</p></a></li>
<li><a href='#smgsped'><p>Sire-maternal grandsire (S-MGS) pedigree</p></a></li>
<li><a href='#tab2mat'><p>Tabular to matrix</p></a></li>
<li><a href='#tabA'><p>Relationship matrix <strong>A</strong> in a tabular format</p></a></li>
<li><a href='#tabAinv'><p>Inverse of the relationship matrix <strong>A</strong> in a tabular format</p></a></li>
<li><a href='#tabD'><p>Dominance relationship matrix <strong>D</strong> in a tabular-sparse format</p></a></li>
<li><a href='#tabDinv'><p>Inverse of the dominance relationship matrix <strong>D</strong> in a tabular format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Pedigree and Genetic Groups</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates additive and dominance genetic relationship matrices and their inverses, in matrix and tabular-sparse formats. It includes functions for checking and processing pedigree, calculating inbreeding coefficients (Meuwissen &amp; Luo, 1992 &lt;<a href="https://doi.org/10.1186%2F1297-9686-24-4-305">doi:10.1186/1297-9686-24-4-305</a>&gt;), as well as functions to calculate the matrix of genetic group contributions (Q), and adding those contributions to the genetic merit of animals (Quaas (1988) &lt;<a href="https://doi.org/10.3168%2Fjds.S0022-0302%2888%2979691-5">doi:10.3168/jds.S0022-0302(88)79691-5</a>&gt;). Calculation of Q is computationally extensive. There are computationally optimized functions to calculate Q.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nilforooshan/ggroups">https://github.com/nilforooshan/ggroups</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nilforooshan/ggroups/issues">https://github.com/nilforooshan/ggroups/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel (&ge; 1.0.14), foreach (&ge; 1.4.4)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-27 21:07:19 UTC; monil0</td>
</tr>
<tr>
<td>Author:</td>
<td>Mohammad Ali Nilforooshan
    <a href="https://orcid.org/0000-0003-0339-5442"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mohammad Ali Nilforooshan &lt;m.a.nilforooshan@gmail.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-27 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='buildA'>Relationship matrix <strong>A</strong></h2><span id='topic+buildA'></span>

<h3>Description</h3>

<p>Builds the pedigree-based additive genetic relationship matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildA(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildA_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Relationship <code>matrix</code> <strong>A</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:6, SIRE=c(0,0,1,3,1,4), DAM=c(0,0,2,2,2,5))
buildA(ped)

</code></pre>

<hr>
<h2 id='buildD'>Relationship matrix <strong>D</strong></h2><span id='topic+buildD'></span>

<h3>Description</h3>

<p>Builds the pedigree-based dominance relationship matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildD(ped, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildD_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
<tr><td><code id="buildD_+3A_a">A</code></td>
<td>
<p>: Relationship matrix <strong>A</strong> created by function <code><a href="#topic+buildA">buildA</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Relationship <code>matrix</code> <strong>D</strong>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:6, SIRE=c(0,0,1,3,1,4), DAM=c(0,0,2,2,2,5))
buildD(ped, buildA(ped))

</code></pre>

<hr>
<h2 id='gghead'>Append genetic groups to the pedigree</h2><span id='topic+gghead'></span>

<h3>Description</h3>

<p>This function appends parents that are not available in the first column of the pedigree, to the head of the pedigree, and sorts it. Given a pedigree with all missing parents replaced with the corresponding genetic groups, this functions appends genetic groups to the head of the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gghead(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gghead_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider this simple pedigree:
</p>
<p><code>3 0 0</code>
</p>
<p><code>4 3 0</code>
</p>
<p><code>6 4 5</code>
</p>
<p><code>5 0 0</code>
</p>
<p>First, unknown parents are replaced with the corresponding genetic groups.
</p>
<p>Please note that unknown parent IDs should be smaller than progeny IDs.
</p>
<p><code>3 1 2</code>
</p>
<p><code>4 3 2</code>
</p>
<p><code>6 4 5</code>
</p>
<p><code>5 1 2</code>
</p>
<p>Then, <code>gghead</code> is applied to this pedigree (see the example).
</p>


<h3>Value</h3>

<p>Processed pedigree <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=c(3,4,6,5), SIRE=c(1,3,4,1), DAM=c(2,2,5,2))
gghead(ped)

</code></pre>

<hr>
<h2 id='ggroups-package'>Pedigree and genetic groups</h2><span id='topic+ggroups-package'></span>

<h3>Description</h3>

<p>This package contains pedigree processing and analyzing functions, including functions for checking and renumbering the pedigree, making the additive and dominance pedigree relationship matrices and their inverses, in matrix and tabular formats, calculating inbreeding coefficients, as well as functions related to genetic groups.
</p>


<h3>Details</h3>

<p>First, it is recommended to check the pedigree <code>data.frame</code> with the <code><a href="#topic+pedcheck">pedcheck</a></code> function. Pedigree relationship matrix and its inverse are fundamentals in the conventional and modern animal breeding. The concept of genetic groups stems from the fact that not all the unknown parents are of the same genetic level. The genetic group contribution matrix (<strong>Q</strong>) is required to weight and add genetic group effects (<b>&gcirc;</b>) to the genetic merit of animals (<b>&ucirc;</b>), which is equal to <strong>Q</strong><b>&gcirc;</b> + <b>&ucirc;</b> (Quaas, 1988). Calculating <strong>Q</strong> is computationally challenging, and for large pedigree, large RAM and long computational time is required. Therefore, the functions <code>qmatL</code> and its parallel version, <code>qmatXL</code> are introduced. Overlap between sire and dam genetic groups is supported.
</p>


<h3>Author(s)</h3>

<p>Mohammad Ali Nilforooshan <a href="mailto:m.a.nilforooshan@gmail.com">m.a.nilforooshan@gmail.com</a>
</p>


<h3>References</h3>

<p>Meuwissen, T. and Luo, Z. 1992. Computing Inbreeding Coefficients in Large Populations. Genet. Sel. Evol., 24:305. &lt;doi:10.1186/1297-9686-24-4-305&gt;
</p>
<p>Mrode, R. A. 2005. Linear Models for the Prediction of Animal Breeding Values, 2nd ed. Cambridge, MA: CABI Publishing.
</p>
<p>Quaas, R. L. 1988. Additive Genetic Model with Groups and Relationships. J. Dairy Sci., 71:1338-1345. &lt;doi:10.3168.jds.S0022-0302(88)79691-5&gt;
</p>

<hr>
<h2 id='inb'>Individual's inbreeding coefficient</h2><span id='topic+inb'></span>

<h3>Description</h3>

<p>Calculates inbreeding coefficient for an individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inb(ped, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inb_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
<tr><td><code id="inb_+3A_id">id</code></td>
<td>
<p>: Numeric ID of an individual</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Inbreeding coefficient of the individual
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:7, SIRE=c(0,0,1,1,3,1,5), DAM=c(0,0,0,2,4,4,6))
inb(ped, 7)

</code></pre>

<hr>
<h2 id='inbreed'>Inbreeding coefficients</h2><span id='topic+inbreed'></span>

<h3>Description</h3>

<p>Calculates inbreeding coefficients for all animals in the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inbreed(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inbreed_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of inbreeding coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:7, SIRE=c(0,0,1,1,3,1,5), DAM=c(0,0,0,2,4,4,6))
inbreed(ped)

</code></pre>

<hr>
<h2 id='mat2tab'>Matrix to tabular</h2><span id='topic+mat2tab'></span>

<h3>Description</h3>

<p>Converts matrix data to tabular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2tab(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2tab_+3A_mat">mat</code></td>
<td>
<p>: <code>matrix</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with 2 integer (IDs) and 1 numeric (values) columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:6, SIRE=c(0,0,1,3,1,4), DAM=c(0,0,2,2,2,5))
mat2tab(buildA(ped))

</code></pre>

<hr>
<h2 id='offspring'>Descendants of an individual per generation</h2><span id='topic+offspring'></span>

<h3>Description</h3>

<p>Counts and collects progeny and phenotyped progeny of an individual in successive generations. In pedigrees with generation overlap, animals are reported in the 1st generation that they appear in, rather than in multiple generations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>offspring(ped, id, pheno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="offspring_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
<tr><td><code id="offspring_+3A_id">id</code></td>
<td>
<p>: The ID of the individual, for which the descendants to be extracted.</p>
</td></tr>
<tr><td><code id="offspring_+3A_pheno">pheno</code></td>
<td>
<p>: Vector of phenotyped individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prgn : <code>list</code> of progeny per generation.
</p>
<p>prgn.ph : <code>list</code> of phenotyped progeny per generation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(V1 = 1:19,
   V2 = c(0,0,1,1,0,0,0,0,0,4,5,5,7,0,0,9,0,0,12),
   V3 = c(0,0,0,2,0,2,0,3,3,3,0,6,8,8,8,10,11,11,0))
pheno = 10:18
# Find progeny and phenotyped progeny of individual 1.
offspring(ped, 1, pheno)
# Find phenotyped progeny of individual 1, in the 2nd generation.
offspring(ped, 1, 10:18)$prgn.ph[[2]]
# If only interested in finding the progeny of individual 1:
offspring(ped, 1, c())$prgn

</code></pre>

<hr>
<h2 id='pedcheck'>Basic pedigree checks</h2><span id='topic+pedcheck'></span>

<h3>Description</h3>

<p>Performs basic pedigree checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedcheck(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedcheck_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(127)
ped = data.frame(ID=c(1:50,NA,0,1:3),
                 SIRE=c(0, sample(c(0,10:25), 53, replace=TRUE), 51),
                 DAM=c(0, NA, 52, sample(c(0,20:35), 52, replace=TRUE)))
pedcheck(ped)

</code></pre>

<hr>
<h2 id='peddown'>Downward pedigree extraction</h2><span id='topic+peddown'></span>

<h3>Description</h3>

<p>Extracts pedigree downward for one or a group of individuals to find their descendants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peddown(ped, parents, maxgen = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peddown_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
<tr><td><code id="peddown_+3A_parents">parents</code></td>
<td>
<p>: Vector of individual ID(s), from which the new pedigree is being extracted.</p>
</td></tr>
<tr><td><code id="peddown_+3A_maxgen">maxgen</code></td>
<td>
<p>: (optional) a positive integer for the maximum number of generations to proceed. If no value is provided, there is no limitation on the maximum number of generations to proceed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extracted pedigree <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:6, SIRE=c(0,0,1,3,1,4), DAM=c(0,0,2,2,2,5))
peddown(ped, c(1,4))
peddown(ped, 1, maxgen=1)

</code></pre>

<hr>
<h2 id='pedup'>Upward pedigree extraction</h2><span id='topic+pedup'></span>

<h3>Description</h3>

<p>Extracts pedigree upward for one or a group of individuals to find their ascendants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedup(ped, progeny, maxgen = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedup_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
<tr><td><code id="pedup_+3A_progeny">progeny</code></td>
<td>
<p>: Vector of individual ID(s), from which the new pedigree is being extracted.</p>
</td></tr>
<tr><td><code id="pedup_+3A_maxgen">maxgen</code></td>
<td>
<p>: (optional) a positive integer for the maximum number of generations (continuing from parents of <code>progeny</code>) to proceed. If no value is provided, there is no limitation on the maximum number of generations to proceed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extracted pedigree <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:6, SIRE=c(0,0,1,3,1,4), DAM=c(0,0,2,2,2,5))
pedup(ped, c(1,4))
pedup(ped, 6, maxgen=1)

</code></pre>

<hr>
<h2 id='pruneped'>Pedigree pruning</h2><span id='topic+pruneped'></span>

<h3>Description</h3>

<p>Pruning pedigree in two different modes (strict, loose)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pruneped(ped, pheno, mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pruneped_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
<tr><td><code id="pruneped_+3A_pheno">pheno</code></td>
<td>
<p>: Vector of phenotyped individuals</p>
</td></tr>
<tr><td><code id="pruneped_+3A_mode">mode</code></td>
<td>
<p>: <code>strict</code> or <code>loose</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In strict pruning, individuals without progeny and phenotype are recursively deleted from the pedigree, and then individuals without known parent and without progeny (if any) are deleted. Therefore, all uninfluential individuals are deleted. The downside is that individuals without phenotype or phenotyped progeny cannot receive any genetic merit based on the information from their phenotyped relatives.
In loose pruning, the pedigree is upward extracted for phenotyped individuals to thier founders, and then the pedigree is downward extracted from the founders.
</p>


<h3>Value</h3>

<p>Pruned pedigree <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:7, SIRE=c(0,0,1,3,1,4,0), DAM=c(0,0,2,2,2,5,0))
pheno = c(1,4)
pruneped(ped, pheno, mode="strict")
pruneped(ped, pheno, mode="loose")

</code></pre>

<hr>
<h2 id='Qgpu'>Vector <strong>Qg</strong> + <strong>u</strong></h2><span id='topic+Qgpu'></span>

<h3>Description</h3>

<p>Adds genetic group contributions to the genetic merit of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qgpu(Q, sol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qgpu_+3A_q">Q</code></td>
<td>
<p>: The output <code>matrix</code> from <code><a href="#topic+qmatL">qmatL</a></code> (for more details: <code>?<a href="#topic+qmatL">qmatL</a></code>)</p>
</td></tr>
<tr><td><code id="Qgpu_+3A_sol">sol</code></td>
<td>
<p>: <code>data.frame</code> with 2 numeric columns corresponding to ID, EBV ([<b>&gcirc;</b>, <b>&ucirc;</b>]), where <b>&gcirc;</b> and <b>&ucirc;</b> are the genetic group and genetic merit solutions, respectively. The order of solutions must be the order of columns and the order of rows in matrix <strong>Q</strong>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of <strong>Q</strong><b>&gcirc;</b> + <b>&ucirc;</b>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=c(3,4,6,5), SIRE=c(1,3,4,1), DAM=c(2,2,5,2))
Q = qmatL(gghead(ped))
ghat = c(0.1, -0.2)
uhat = seq(-1.5, 1.5, 1)
sol = data.frame(ID=1:6, EBV=c(ghat, uhat))
Qgpu(Q, sol)

</code></pre>

<hr>
<h2 id='qmat'>Matrix <strong>Q</strong></h2><span id='topic+qmat'></span>

<h3>Description</h3>

<p>Creates the genetic group contribution matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmat(ped2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmat_+3A_ped2">ped2</code></td>
<td>
<p>: The output <code>data.frame</code> from <code><a href="#topic+gghead">gghead</a></code> (for more details: <code>?<a href="#topic+gghead">gghead</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>Q</strong> <code>matrix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=c(3,4,6,5), SIRE=c(1,3,4,1), DAM=c(2,2,5,2))
ped2 = gghead(ped)
qmat(ped2)

</code></pre>

<hr>
<h2 id='qmatL'>Matrix <strong>Q</strong> for large pedigrees</h2><span id='topic+qmatL'></span>

<h3>Description</h3>

<p>Creates the genetic group contribution matrix for large pedigrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmatL(ped2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmatL_+3A_ped2">ped2</code></td>
<td>
<p>: The output <code>data.frame</code> from <code><a href="#topic+gghead">gghead</a></code> (for more details: <code>?<a href="#topic+gghead">gghead</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>Q</strong> <code>matrix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=c(3,4,6,5), SIRE=c(1,3,4,1), DAM=c(2,2,5,2))
ped2 = gghead(ped)
qmatL(ped2)

</code></pre>

<hr>
<h2 id='qmatXL'>Matrix <strong>Q</strong> for large pedigrees (parallel processing)</h2><span id='topic+qmatXL'></span>

<h3>Description</h3>

<p>Creates the genetic group contribution matrix for large pedigrees, with parallel processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmatXL(ped2, ncl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmatXL_+3A_ped2">ped2</code></td>
<td>
<p>: The output <code>data.frame</code> from <code><a href="#topic+gghead">gghead</a></code> (for more details: <code>?<a href="#topic+gghead">gghead</a></code>)</p>
</td></tr>
<tr><td><code id="qmatXL_+3A_ncl">ncl</code></td>
<td>
<p>: User defined number of nodes; if the number of user defined nodes is greater than the number of genetic groups, the number genetic groups is considered as the number of nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the parallel version of <code><a href="#topic+qmatL">qmatL</a></code>. It requires <code>foreach</code> and <code>doParallel</code> packages.
</p>


<h3>Value</h3>

<p><strong>Q</strong> <code>matrix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=c(3,4,6,5), SIRE=c(1,3,4,1), DAM=c(2,2,5,2))
ped2 = gghead(ped)
qmatXL(ped2, 2)

</code></pre>

<hr>
<h2 id='renum'>Pedigree renumbering</h2><span id='topic+renum'></span>

<h3>Description</h3>

<p>Renumbering pedigree to numerical IDs, so that progeny's ID is smaller than parents' IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renum(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renum_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>newped : Pedigree <code>data.frame</code> with renumberred IDs.
</p>
<p>xrf : Cross-reference <code>data.frame</code> with 2 columns for original and renumberred IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=letters[1:6], SIRE=c(0,0,letters[c(1,3,1,4)]), DAM=c(0,0,letters[c(2,2,2,5)]))
renum(ped)$newped
renum(ped)$xrf

</code></pre>

<hr>
<h2 id='rg'>Genetic relationship coefficient</h2><span id='topic+rg'></span>

<h3>Description</h3>

<p>Calculates genetic relationship coefficient between two individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rg(ped, id1, id2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rg_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
<tr><td><code id="rg_+3A_id1">id1</code></td>
<td>
<p>: Numeric ID of an individual</p>
</td></tr>
<tr><td><code id="rg_+3A_id2">id2</code></td>
<td>
<p>: Numeric ID of an individual</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Genetic relationship coefficient between the two individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:7, SIRE=c(0,0,1,1,3,1,5), DAM=c(0,0,0,2,4,4,6))
rg(ped, 5, 6)

</code></pre>

<hr>
<h2 id='smgsped'>Sire-maternal grandsire (S-MGS) pedigree</h2><span id='topic+smgsped'></span>

<h3>Description</h3>

<p>Extract sire-maternal grandsire (S-MGS) pedigree from a sire-dam pedigree. Sire and MGS information is extracted for sires of phenotyped individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smgsped(ped, pheno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smgsped_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
<tr><td><code id="smgsped_+3A_pheno">pheno</code></td>
<td>
<p>: Vector of phenotyped individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S-MGS pedigree <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:10, SIRE=c(0,0,1,2,0,5,4,4,0,8), DAM=c(0,0,0,3,3,0,6,6,6,0))
smgsped(ped, 7:10)

</code></pre>

<hr>
<h2 id='tab2mat'>Tabular to matrix</h2><span id='topic+tab2mat'></span>

<h3>Description</h3>

<p>Converts tabular data to matrix data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab2mat(tab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tab2mat_+3A_tab">tab</code></td>
<td>
<p>: <code>data.frame</code> with 2 integer (IDs) and 1 numeric (values) columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Converted <code>data.frame</code> to <code>matrix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:6, SIRE=c(0,0,1,3,1,4), DAM=c(0,0,2,2,2,5))
tab2mat(tabA(ped))

</code></pre>

<hr>
<h2 id='tabA'>Relationship matrix <strong>A</strong> in a tabular format</h2><span id='topic+tabA'></span>

<h3>Description</h3>

<p>Creates the pedigree-based additive genetic relationship <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabA(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabA_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Genetic relationship <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:6, SIRE=c(0,0,1,3,1,4), DAM=c(0,0,2,2,2,5))
tabA(ped)

</code></pre>

<hr>
<h2 id='tabAinv'>Inverse of the relationship matrix <strong>A</strong> in a tabular format</h2><span id='topic+tabAinv'></span>

<h3>Description</h3>

<p>Creates the <code>data.frame</code> of the inverse of the pedigree-based genetic relationship matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabAinv(ped, inbr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabAinv_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
<tr><td><code id="tabAinv_+3A_inbr">inbr</code></td>
<td>
<p>: Vector of inbreeding coefficients in the order of individuals in the relationship matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> of the inverse of the genetic relationship matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:6, SIRE=c(0,0,1,3,1,4), DAM=c(0,0,2,2,2,5))
inbr = c(0, 0, 0, 0.25, 0, 0.25)
# or
(inbr = diag(buildA(ped)) - 1)
# or
inbr = tabA(ped); (inbr = inbr[inbr[,1]==inbr[,2],]$a - 1)
# or
# For individual inbreeding values, use function inb.
tabAinv(ped, inbr)

</code></pre>

<hr>
<h2 id='tabD'>Dominance relationship matrix <strong>D</strong> in a tabular-sparse format</h2><span id='topic+tabD'></span>

<h3>Description</h3>

<p>Creates the pedigree-based dominance relationship <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabD(ped, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabD_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
<tr><td><code id="tabD_+3A_a">A</code></td>
<td>
<p>: Relationship matrix <strong>A</strong> in a tabular format created by function <code><a href="#topic+tabA">tabA</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dominance relationship <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:6, SIRE=c(0,0,1,3,1,4), DAM=c(0,0,2,2,2,5))
tabD(ped, tabA(ped))

</code></pre>

<hr>
<h2 id='tabDinv'>Inverse of the dominance relationship matrix <strong>D</strong> in a tabular format</h2><span id='topic+tabDinv'></span>

<h3>Description</h3>

<p>Creates the <code>data.frame</code> of the inverse of the pedigree-based dominance relationship matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabDinv(ped, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabDinv_+3A_ped">ped</code></td>
<td>
<p>: <code>data.frame</code> with integer columns corresponding to ID, SIRE, DAM. Missing value is 0.</p>
</td></tr>
<tr><td><code id="tabDinv_+3A_a">A</code></td>
<td>
<p>: Relationship matrix <strong>A</strong> in a tabular format created by function <code><a href="#topic+tabA">tabA</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> of the inverse of the dominance relationship matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped = data.frame(ID=1:6, SIRE=c(0,0,1,3,1,4), DAM=c(0,0,2,2,2,5))
tabDinv(ped, tabA(ped))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
