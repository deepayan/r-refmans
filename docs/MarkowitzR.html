<!DOCTYPE html><html><head><title>Help for package MarkowitzR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MarkowitzR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#itheta_vcov'><p>Compute variance covariance of Inverse 'Unified' Second Moment</p></a></li>
<li><a href='#MarkowitzR'><p>statistics concerning the Markowitz portfolio</p></a></li>
<li><a href='#MarkowitzR-NEWS'><p>News for package 'MarkowitzR':</p></a></li>
<li><a href='#mp_vcov'><p>Estimate Markowitz Portfolio</p></a></li>
<li><a href='#theta_vcov'><p>Compute variance covariance of 'Unified' Second Moment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Steven E. Pav &lt;shabbychef@gmail.com&gt;</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-20</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Significance of the Markowitz Portfolio</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shabbychef/MarkowitzR/issues">https://github.com/shabbychef/MarkowitzR/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of tools for analyzing significance of 
    Markowitz portfolios, using the delta method on the second moment
    matrix, &lt;<a href="https://arxiv.org/abs/1312.0557">arXiv:1312.0557</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>matrixcalc, gtools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sandwich, SharpeR, testthat, formatR, knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/shabbychef/MarkowitzR">https://github.com/shabbychef/MarkowitzR</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'MarkowitzR.r' 'portinf.r' 'utils.r' 'vcov.r'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 15:57:27 UTC; spav</td>
</tr>
<tr>
<td>Author:</td>
<td>Steven E. Pav <a href="https://orcid.org/0000-0002-4197-6195"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 18:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='itheta_vcov'>Compute variance covariance of Inverse 'Unified' Second Moment</h2><span id='topic+itheta_vcov'></span>

<h3>Description</h3>

<p>Computes the variance covariance matrix of the inverse unified 
second moment matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itheta_vcov(X,vcov.func=vcov,fit.intercept=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itheta_vcov_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">n \times p</code> matrix of observed returns.</p>
</td></tr>
<tr><td><code id="itheta_vcov_+3A_vcov.func">vcov.func</code></td>
<td>
<p>a function which takes an object of class <code>lm</code>,
and computes a variance-covariance matrix. If equal to the string
<code>"normal"</code>, we assume multivariate normal returns.</p>
</td></tr>
<tr><td><code id="itheta_vcov_+3A_fit.intercept">fit.intercept</code></td>
<td>
<p>a boolean controlling whether we add a column
of ones to the data, or fit the raw uncentered second moment.
For now, must be true when assuming normal returns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">p</code>-vector <code class="reqn">x</code> with mean <code class="reqn">\mu</code> and
covariance, <code class="reqn">\Sigma</code>, let <code class="reqn">y</code> be <code class="reqn">x</code>
with a one prepended. Then let 
<code class="reqn">\Theta = E\left(y y^{\top}\right)</code>,
the uncentered second moment matrix. The inverse of
<code class="reqn">\Theta</code> contains the (negative) Markowitz portfolio 
and the precision matrix. 
</p>
<p>Given <code class="reqn">n</code> contemporaneous observations of <code class="reqn">p</code>-vectors,
stacked as rows in the <code class="reqn">n \times p</code> matrix <code class="reqn">X</code>,
this function estimates the mean and the asymptotic 
variance-covariance matrix of <code class="reqn">\Theta^{-1}</code>.
</p>
<p>One may use the default method for computing covariance,
via the <code><a href="stats.html#topic+vcov">vcov</a></code> function, or via a 'fancy' estimator,
like <code>sandwich:vcovHAC</code>, <code>sandwich:vcovHC</code>, <em>etc.</em>
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>a <code class="reqn">q = (p+1)(p+2)/2</code> vector of 1 + squared maximum
Sharpe, the negative Markowitz 
portfolio, then the vech'd precision matrix of the sample data</p>
</td></tr>
<tr><td><code>Ohat</code></td>
<td>
<p>the <code class="reqn">q \times q</code> estimated variance 
covariance matrix.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of rows in <code>X</code>.</p>
</td></tr>
<tr><td><code>pp</code></td>
<td>
<p>the number of assets plus <code>as.numeric(fit.intercept)</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>By flipping the sign of <code class="reqn">X</code>, the inverse of 
<code class="reqn">\Theta</code> contains the <em>positive</em> Markowitz
portfolio and the precision matrix on <code class="reqn">X</code>. Performing
this transform before passing the data to this function
should be considered idiomatic.
</p>
<p>A more general form of this function exists as <code><a href="#topic+mp_vcov">mp_vcov</a></code>.
</p>
<p>Replaces similar functionality from SharpeR package, but with 
modified API.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. &quot;Asymptotic Distribution of the Markowitz Portfolio.&quot;
2013 <a href="https://arxiv.org/abs/1312.0557">https://arxiv.org/abs/1312.0557</a>
</p>
<p>Pav, S. E. &quot;Portfolio Inference with this One Weird Trick.&quot;
R in Finance, 2014 <a href="http://past.rinfinance.com/agenda/2014/talk/StevenPav.pdf">http://past.rinfinance.com/agenda/2014/talk/StevenPav.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theta_vcov">theta_vcov</a></code>, <code><a href="#topic+mp_vcov">mp_vcov</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(1000*3),ncol=3)
# putting in -X is idiomatic:
ism &lt;- itheta_vcov(-X)
iSigmas.n &lt;- itheta_vcov(-X,vcov.func="normal")
iSigmas.n &lt;- itheta_vcov(-X,fit.intercept=FALSE)
# compute the marginal Wald test statistics:
qidx &lt;- 2:ism$pp
wald.stats &lt;- ism$mu[qidx] / sqrt(diag(ism$Ohat[qidx,qidx]))

# make it fat tailed:
X &lt;- matrix(rt(1000*3,df=5),ncol=3)
ism &lt;- itheta_vcov(X)
qidx &lt;- 2:ism$pp
wald.stats &lt;- ism$mu[qidx] / sqrt(diag(ism$Ohat[qidx,qidx]))

if (require(sandwich)) {
 ism &lt;- itheta_vcov(X,vcov.func=vcovHC)
 qidx &lt;- 2:ism$pp
 wald.stats &lt;- ism$mu[qidx] / sqrt(diag(ism$Ohat[qidx,qidx]))
}

# add some autocorrelation to X
Xf &lt;- filter(X,c(0.2),"recursive")
colnames(Xf) &lt;- colnames(X)
ism &lt;- itheta_vcov(Xf)
qidx &lt;- 2:ism$pp
wald.stats &lt;- ism$mu[qidx] / sqrt(diag(ism$Ohat[qidx,qidx]))

if (require(sandwich)) {
ism &lt;- itheta_vcov(Xf,vcov.func=vcovHAC)
 qidx &lt;- 2:ism$pp
 wald.stats &lt;- ism$mu[qidx] / sqrt(diag(ism$Ohat[qidx,qidx]))
}

</code></pre>

<hr>
<h2 id='MarkowitzR'>statistics concerning the Markowitz portfolio</h2><span id='topic+MarkowitzR'></span><span id='topic+_PACKAGE'></span><span id='topic+MarkowitzR-package'></span>

<h3>Description</h3>

<p>Inference on the Markowitz portfolio.
</p>


<h3>Markowitz Portfolio</h3>

<p>Suppose <code class="reqn">x</code> is a <code class="reqn">p</code>-vector of returns of some assets with expected
value <code class="reqn">\mu</code> and covariance <code class="reqn">\Sigma</code>. The 
<em>Markowitz Portfolio</em> is the portfolio 
<code class="reqn">w = \Sigma^{-1}\mu</code>. Scale multiples of this portfolio
solve various portfolio optimization problems, among them
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{argmax}_{w: w^{\top}\Sigma w \le R^2} \frac{\mu^{\top} w -
r_0}{\sqrt{w^{\top}\Sigma w}}</code>
</p>

<p>This packages supports various statistical tests around the elements of 
the Markowitz Portfolio, and its Sharpe ratio, including the possibility of
hedging, and scalar conditional heteroskedasticity and conditional
expectation.
</p>


<h3>Legal Mumbo Jumbo</h3>

<p>MarkowitzR is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.
</p>


<h3>Note</h3>

<p>This package is maintained as a hobby.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>
<p><strong>Maintainer</strong>: Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a> (<a href="https://orcid.org/0000-0002-4197-6195">ORCID</a>)
</p>


<h3>References</h3>

<p>Pav, S. E. &quot;Asymptotic Distribution of the Markowitz Portfolio.&quot;
2013 <a href="https://arxiv.org/abs/1312.0557">https://arxiv.org/abs/1312.0557</a>
</p>
<p>Pav, S. E. &quot;Portfolio Inference with this One Weird Trick.&quot;
R in Finance, 2014 <a href="http://past.rinfinance.com/agenda/2014/talk/StevenPav.pdf">http://past.rinfinance.com/agenda/2014/talk/StevenPav.pdf</a>
</p>
<p>Britten-Jones, Mark. &quot;The Sampling Error in Estimates of Mean-Variance 
Efficient Portfolio Weights.&quot; The Journal of Finance 54, no. 2 (1999):
655&ndash;671. <a href="https://www.jstor.org/stable/2697722">https://www.jstor.org/stable/2697722</a>
</p>
<p>Bodnar, Taras and Okhrin, Yarema. &quot;On the Product of Inverse Wishart
and Normal Distributions with Applications to Discriminant Analysis 
and Portfolio Theory.&quot; Scandinavian Journal of Statistics 38, no. 2 (2011):
311&ndash;331. <a href="https://doi.org/10.1111/j.1467-9469.2011.00729.x">doi:10.1111/j.1467-9469.2011.00729.x</a>
</p>
<p>Markowitz, Harry. &quot;Portfolio Selection.&quot; The Journal of Finance 7, no. 1
(1952): 77&ndash;91. <a href="https://www.jstor.org/stable/2975974">https://www.jstor.org/stable/2975974</a>
</p>
<p>Brandt, Michael W. &quot;Portfolio Choice Problems.&quot; Handbook of Financial
Econometrics 1 (2009): 269&ndash;336. 
<a href="https://scholars.duke.edu/publication/964964">https://scholars.duke.edu/publication/964964</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/shabbychef/MarkowitzR">https://github.com/shabbychef/MarkowitzR</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/shabbychef/MarkowitzR/issues">https://github.com/shabbychef/MarkowitzR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='MarkowitzR-NEWS'>News for package 'MarkowitzR':</h2><span id='topic+MarkowitzR-NEWS'></span>

<h3>Description</h3>

<p>News for package &lsquo;MarkowitzR&rsquo;
</p>




<h3>Changes in <a href="https://cran.r-project.org/package=MarkowitzR"><span class="pkg">MarkowitzR</span></a> Version 1.0.3 (2023-08-20) </h3>


<ul>
<li><p> fix package documentation.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=MarkowitzR"><span class="pkg">MarkowitzR</span></a> Version 1.0.2 (2020-01-07) </h3>


<ul>
<li><p> emergency fix for broken tests under atlas on CRAN.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=MarkowitzR"><span class="pkg">MarkowitzR</span></a> Version 1.0.1 (2018-05-25) </h3>


<ul>
<li><p> move figures around for README on CRAN.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=MarkowitzR"><span class="pkg">MarkowitzR</span></a> Version 0.9900 (2016-09-15) </h3>


<ul>
<li><p> yet again, conform to CRAN rules.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=MarkowitzR"><span class="pkg">MarkowitzR</span></a> Version 0.1502 (2015-01-26) </h3>


<ul>
<li><p> conform to CRAN rules.
</p>
</li></ul>



<h3>Changes in <a href="https://cran.r-project.org/package=MarkowitzR"><span class="pkg">MarkowitzR</span></a> Version 0.1403 (2014-06-01) </h3>


<ul>
<li><p> fix bug preventing multi-row hedging or constraint matrices.
</p>
</li></ul>



<h3><a href="https://cran.r-project.org/package=MarkowitzR"><span class="pkg">MarkowitzR</span></a> Initial Version 0.1402 (2014-02-14) </h3>


<ul>
<li><p> first CRAN release.
</p>
</li></ul>


<hr>
<h2 id='mp_vcov'>Estimate Markowitz Portfolio</h2><span id='topic+mp_vcov'></span>

<h3>Description</h3>

<p>Estimates the Markowitz Portfolio or Markowitz Coefficient subject
to subspace and hedging constraints, and heteroskedasticity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_vcov(X,feat=NULL,vcov.func=vcov,fit.intercept=TRUE,weights=NULL,Jmat=NULL,Gmat=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mp_vcov_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">n \times p</code> matrix of observed returns.</p>
</td></tr>
<tr><td><code id="mp_vcov_+3A_feat">feat</code></td>
<td>
<p>an <code class="reqn">n \times f</code> matrix of observed features.
defaults to none, in which case <code>fit.intercept</code> must be
<code>TRUE</code>. If <code>fit.intercept</code> is true, ones will be prepended
to the features.</p>
</td></tr>
<tr><td><code id="mp_vcov_+3A_vcov.func">vcov.func</code></td>
<td>
<p>a function which takes an object of class <code>lm</code>,
and computes a variance-covariance matrix. If equal to the string
<code>"normal"</code>, we assume multivariate normal returns.</p>
</td></tr>
<tr><td><code id="mp_vcov_+3A_fit.intercept">fit.intercept</code></td>
<td>
<p>a boolean controlling whether we add a column
of ones to the data, or fit the raw uncentered second moment.
For now, must be true when assuming normal returns.</p>
</td></tr>
<tr><td><code id="mp_vcov_+3A_weights">weights</code></td>
<td>
<p>an optional <code class="reqn">n</code> vector of the weights. The returns
and features will be multiplied by the weights. Weights should be
inverse volatility estimates. Defaults to homoskedasticity.</p>
</td></tr>
<tr><td><code id="mp_vcov_+3A_jmat">Jmat</code></td>
<td>
<p>an optional <code class="reqn">p_j \times p</code> matrix of the
subspace in which we constrain portfolios. Defaults essentially to the
<code class="reqn">p \times p</code> identity matrix.</p>
</td></tr>
<tr><td><code id="mp_vcov_+3A_gmat">Gmat</code></td>
<td>
<p>an optional <code class="reqn">p_g \times p</code> matrix of the
subspace to which we constrain portfolios to have zero covariance. 
The rowspace of <code>Gmat</code> must be spanned by the rowspace of <code>Jmat</code>.
Defaults essentially to the <code class="reqn">0 \times p</code> empty matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that the expectation of <code class="reqn">p</code>-vector <code class="reqn">x</code> is linear
in the <code class="reqn">f</code>-vector <code class="reqn">f</code>, but the covariance of <code class="reqn">x</code> is
stationary and independent of <code class="reqn">f</code>. The 'Markowitz Coefficient' 
is the <code class="reqn">p \times f</code> matrix <code class="reqn">W</code> such that, 
conditional on observing <code class="reqn">f</code>, the portfolio <code class="reqn">Wf</code> maximizes
Sharpe. When <code class="reqn">f</code> is the constant 1, the Markowitz Coefficient
is the traditional Markowitz Portfolio.
</p>
<p>Given <code class="reqn">n</code> observations of the returns and features, given
as matrices <code class="reqn">X, F</code>, this code computes the Markowitz Coefficient
along with the variance-covariance matrix of the Coefficient and the
precision matrix.  One may give optional weights, which are inverse
conditional volatility. One may also give optional matrix <code class="reqn">J, G</code>
which define subspace and hedging constraints. Briefly, they constrain
the portfolio optimization problem to portfolios in the row space of
<code class="reqn">J</code> and with zero covariance with the rows of <code class="reqn">G</code>. It must 
be the case that the rows of <code class="reqn">J</code> span the rows of <code class="reqn">G</code>. 
<code class="reqn">J</code> defaults to the <code class="reqn">p \times p</code> identity matrix, 
and <code class="reqn">G</code> defaults to a null matrix.
</p>
<p>One may use the default method for computing covariance,
via the <code><a href="stats.html#topic+vcov">vcov</a></code> function, or via a 'fancy' estimator,
like <code>sandwich:vcovHAC</code>, <code>sandwich:vcovHC</code>, <em>etc.</em>
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>Letting <code class="reqn">r = f + p + fit.intercept</code>, this is a 
<code class="reqn">q = (r)(r+1)/2</code> vector...</p>
</td></tr>
<tr><td><code>Ohat</code></td>
<td>
<p>The <code class="reqn">q \times q</code> estimated variance covariance 
matrix of <code>mu</code>.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>The estimated Markowitz coefficient, a 
<code class="reqn">p \times (fit.intercept + f)</code> matrix. The
first column corresponds to the intercept term if it is fit. Note that
for convenience this function performs the sign flip, which is not performed
on <code>mu</code>.</p>
</td></tr>
<tr><td><code>What</code></td>
<td>
<p>The estimated variance covariance matrix of <code>vech(W)</code>.
Letting <code class="reqn">s = p(fit.intercept + f)</code>, this is a <code class="reqn">s \times s</code>
matrix.</p>
</td></tr>
<tr><td><code>widxs</code></td>
<td>
<p>The indices into <code>mu</code> giving <code>W</code>, and into
<code>Ohat</code> giving <code>What</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of rows in <code>X</code>.</p>
</td></tr>
<tr><td><code>ff</code></td>
<td>
<p>The number of features plus <code>as.numeric(fit.intercept)</code>.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The number of assets.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Should also modify to include the theta estimates.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. &quot;Asymptotic Distribution of the Markowitz Portfolio.&quot;
2013 <a href="https://arxiv.org/abs/1312.0557">https://arxiv.org/abs/1312.0557</a>
</p>
<p>Pav, S. E. &quot;Portfolio Inference with this One Weird Trick.&quot;
R in Finance, 2014 <a href="http://past.rinfinance.com/agenda/2014/talk/StevenPav.pdf">http://past.rinfinance.com/agenda/2014/talk/StevenPav.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theta_vcov">theta_vcov</a></code>, <code><a href="#topic+itheta_vcov">itheta_vcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1001)
X &lt;- matrix(rnorm(1000*3),ncol=3)
ism &lt;- mp_vcov(X,fit.intercept=TRUE)
walds &lt;- ism$W / sqrt(diag(ism$What))
print(t(walds))
# subspace constraint
Jmat &lt;- matrix(rnorm(6),ncol=3)
ism &lt;- mp_vcov(X,fit.intercept=TRUE,Jmat=Jmat)
walds &lt;- ism$W / sqrt(diag(ism$What))
print(t(walds))
# hedging constraint
Gmat &lt;- matrix(1,nrow=1,ncol=3)
ism &lt;- mp_vcov(X,fit.intercept=TRUE,Gmat=Gmat)
walds &lt;- ism$W / sqrt(diag(ism$What))

# now conditional expectation:

# generate data with given W, Sigma
Xgen &lt;- function(W,Sigma,Feat) {
 Btrue &lt;- Sigma %*% W
 Xmean &lt;- Feat %*% t(Btrue)
 Shalf &lt;- chol(Sigma)
 X &lt;- Xmean + matrix(rnorm(prod(dim(Xmean))),ncol=dim(Xmean)[2]) %*% Shalf
}

n.feat &lt;- 2
n.ret &lt;- 8
n.obs &lt;- 10000
set.seed(101)
Feat &lt;- matrix(rnorm(n.obs * n.feat),ncol=n.feat)
Wtrue &lt;- 10 * matrix(rnorm(n.feat * n.ret),ncol=n.feat)
Sigma &lt;- cov(matrix(rnorm(100*n.ret),ncol=n.ret))
Sigma &lt;- Sigma + diag(seq(from=1,to=3,length.out=n.ret))
X &lt;- Xgen(Wtrue,Sigma,Feat)
ism &lt;- mp_vcov(X,feat=Feat,fit.intercept=TRUE)
Wcomp &lt;- cbind(0,Wtrue)
errs &lt;- ism$W - Wcomp
dim(errs) &lt;- c(length(errs),1)
Zerr &lt;- solve(t(chol(ism$What)),errs)

</code></pre>

<hr>
<h2 id='theta_vcov'>Compute variance covariance of 'Unified' Second Moment</h2><span id='topic+theta_vcov'></span>

<h3>Description</h3>

<p>Computes the variance covariance matrix of sample mean and second moment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta_vcov(X,vcov.func=vcov,fit.intercept=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_vcov_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">n \times p</code> matrix of observed returns.</p>
</td></tr>
<tr><td><code id="theta_vcov_+3A_vcov.func">vcov.func</code></td>
<td>
<p>a function which takes an object of class <code>lm</code>,
and computes a variance-covariance matrix. If equal to the string
<code>"normal"</code>, we assume multivariate normal returns.</p>
</td></tr>
<tr><td><code id="theta_vcov_+3A_fit.intercept">fit.intercept</code></td>
<td>
<p>a boolean controlling whether we add a column
of ones to the data, or fit the raw uncentered second moment.
For now, must be true when assuming normal returns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">p</code>-vector <code class="reqn">x</code>, the 'unified' sample is the 
<code class="reqn">(p+1)(p+2)/2</code> vector of 1, <code class="reqn">x</code>, and 
<code class="reqn">\mbox{vech}(x x^{\top})</code> stacked on top
of each other.
Given <code class="reqn">n</code> contemporaneous observations of <code class="reqn">p</code>-vectors,
stacked as rows in the <code class="reqn">n \times p</code> matrix <code class="reqn">X</code>,
this function computes the mean and the variance-covariance
matrix of the 'unified' sample. 
</p>
<p>One may use the default method for computing covariance,
via the <code><a href="stats.html#topic+vcov">vcov</a></code> function, or via a 'fancy' estimator,
like <code>sandwich:vcovHAC</code>, <code>sandwich:vcovHC</code>, <em>etc.</em>
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>a <code class="reqn">q = (p+1)(p+2)/2</code> vector of 1, then the mean, 
then the vech'd second moment of the sample data.</p>
</td></tr>
<tr><td><code>Ohat</code></td>
<td>
<p>the <code class="reqn">q \times q</code> estimated variance covariance 
matrix. When <code>fit.intercept</code> is true, the left column and top row
are all zeros.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of rows in <code>X</code>.</p>
</td></tr>
<tr><td><code>pp</code></td>
<td>
<p>the number of assets plus <code>as.numeric(fit.intercept)</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Replaces similar functionality from SharpeR package, but with 
modified API.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, S. E. &quot;Asymptotic Distribution of the Markowitz Portfolio.&quot;
2013 <a href="https://arxiv.org/abs/1312.0557">https://arxiv.org/abs/1312.0557</a>
</p>
<p>Pav, S. E. &quot;Portfolio Inference with this One Weird Trick.&quot;
R in Finance, 2014 <a href="http://past.rinfinance.com/agenda/2014/talk/StevenPav.pdf">http://past.rinfinance.com/agenda/2014/talk/StevenPav.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+itheta_vcov">itheta_vcov</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(1000*3),ncol=3)
Sigmas &lt;- theta_vcov(X)
Sigmas.n &lt;- theta_vcov(X,vcov.func="normal")
Sigmas.n &lt;- theta_vcov(X,fit.intercept=FALSE)

# make it fat tailed:
X &lt;- matrix(rt(1000*3,df=5),ncol=3)
Sigmas &lt;- theta_vcov(X)

if (require(sandwich)) {
 Sigmas &lt;- theta_vcov(X,vcov.func=vcovHC)
}

# add some autocorrelation to X
Xf &lt;- filter(X,c(0.2),"recursive")
colnames(Xf) &lt;- colnames(X)
Sigmas &lt;- theta_vcov(Xf)

if (require(sandwich)) {
Sigmas &lt;- theta_vcov(Xf,vcov.func=vcovHAC)
}


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
