<!DOCTYPE html><html lang="en"><head><title>Help for package wyz.code.metaTesting</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wyz.code.metaTesting}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#buildSemanticArgumentName'>
<p>Build semantic argument name</p></a></li>
<li><a href='#computeArgumentsCombination'><p>Compute Function Arguments Combination</p></a></li>
<li><a href='#exploreSignatures'><p>Explore Signatures</p></a></li>
<li><a href='#generateData'><p> Generate Data</p></a></li>
<li><a href='#opMetaTestingInformation'><p>Package functions information</p></a></li>
<li><a href='#opwf'>
<p>Offensive Programming Wrap Function</p></a></li>
<li><a href='#qualifyFunctionArguments'><p>Qualify function arguments.</p></a></li>
<li><a href='#retrieveDataFactory'><p>Retrieve Data Factory</p></a></li>
<li><a href='#setDefaultArgumentsGenerationContext'><p>Set default arguments generation context.</p></a></li>
<li><a href='#setGenerationContext'><p>Set generation context.</p></a></li>
<li><a href='#testFunction'><p>Test function</p></a></li>
<li><a href='#usesSemanticArgumentNames'><p>Uses semantic argument names.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wizardry Code Meta Testing</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.22</td>
</tr>
<tr>
<td>Author:</td>
<td>Fabien Gelineau &lt;neonira@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fabien Gelineau &lt;neonira@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Meta testing is the ability to test a function without having to 
    provide its parameter values.
    Those values will be generated, based on semantic naming of parameters, as 
    introduced by package 'wyz.code.offensiveProgramming'.
    Value generation logic can be completed with your own data types 
    and generation schemes. This to meet your most specific requirements and to 
    answer to a wide variety of usages, from general use case to very specific
    ones.
    While using meta testing, it becomes easier to generate stress test 
    campaigns, non-regression test campaigns and robustness test campaigns, as 
    generated tests can be saved and reused from session to session. 
    Main benefits of using 'wyz.code.metaTesting' is ability to discover valid 
    and invalid function parameter combinations, ability to infer valid 
    parameter values, and to provide smart summaries that allows you to focus
    on dysfunctional cases. </td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, data.table (&ge; 1.11.8), tidyr,
wyz.code.offensiveProgramming (&ge; 1.1.22), crayon, utils, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://neonira.github.io/offensiveProgrammingBook_v1.2.2/">https://neonira.github.io/offensiveProgrammingBook_v1.2.2/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-25 06:38:41 UTC; fabien</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-25 07:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='buildSemanticArgumentName'>
Build semantic argument name
</h2><span id='topic+buildSemanticArgumentName'></span>

<h3>Description</h3>

<p>Build a semantic argument name from the suffix you provide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildSemanticArgumentName(suffix_s_1, variableName_s_1 = "x_")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildSemanticArgumentName_+3A_suffix_s_1">suffix_s_1</code></td>
<td>
<p> one <em><code>string</code></em> to be used as a suffix. Use
<code>retrieveDataFactory()$getKnownSuffixes()</code> to get a <em><code>vector</code></em>
of known suffixes.
</p>
</td></tr>
<tr><td><code id="buildSemanticArgumentName_+3A_variablename_s_1">variableName_s_1</code></td>
<td>
<p> a <em><code>string</code></em> that is the variable name you want to use. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Know that no checks are done on <b><code>suffix_s_1</code></b>. Value you provide will be trusted,
regular or irregular one.
</p>


<h3>Value</h3>

<p>A single <em><code>string</code></em> that is the argument name build from your <b><code>variableName_s_1</code></b>
and <b><code>suffix_s_1</code></b> values.
</p>


<h3>Author(s)</h3>

<p>Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>
<p>Maintainer: Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Refer to <code><a href="#topic+testFunction">testFunction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># typical example
buildSemanticArgumentName('i') # x_i

buildSemanticArgumentName('ui_1', 'numberOfItems') # numberOfItems_ui_1
</code></pre>

<hr>
<h2 id='computeArgumentsCombination'>Compute Function Arguments Combination </h2><span id='topic+computeArgumentsCombination'></span>

<h3>Description</h3>

<p>Computes a priori legal combinations of function arguments, according to the
function definition (see <code><a href="base.html#topic+formals">formals</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeArgumentsCombination(fun_f_1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeArgumentsCombination_+3A_fun_f_1">fun_f_1</code></td>
<td>
<p> an <span class="rlang"><b>R</b></span> <em><code>function</code></em> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes an a priori legal <em><code>list</code></em> of argument signatures for the provided
function.
</p>
<p>Allows to foresee test complexity for a function, as this is in narrow relationship,
with the number of various call signatures that should be tested. The number of signatures
is in itself a good indicator of complexity.
</p>


<h3>Value</h3>

<p>A <em><code>list</code></em> containing following named <b><code>list</code></b>
</p>

<table>
<tr>
 <td style="text-align: left;">
<b><code>names</code></b> </td><td style="text-align: left;"> names of mandatory <b><code>arguments</code></b>, <b><code>ellipsis</code> (...)</b>
arguments and of <b><code>default</code></b> arguments. </td>
</tr>
<tr>
 <td style="text-align: left;">
<b><code>number</code></b> </td><td style="text-align: left;"> The <code>number</code> provides the number of replacements per argument. </td>
</tr>
<tr>
 <td style="text-align: left;">
<b><code>signatures</code></b> </td><td style="text-align: left;"> The <code>signatures</code> are the resulting textual argument combinations. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>
<p>Maintainer: Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Refer to <code><a href="#topic+testFunction">testFunction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># typical example
computeArgumentsCombination(append)

computeArgumentsCombination(kronecker)
</code></pre>

<hr>
<h2 id='exploreSignatures'>Explore Signatures</h2><span id='topic+exploreSignatures'></span>

<h3>Description</h3>

<p>Test an offensive programming wrapper function, applying various argument
signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exploreSignatures(fun_f_1,
                  argumentsTypeRestrictions_l = list(),
                  signaturesRestrictions_l = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exploreSignatures_+3A_fun_f_1">fun_f_1</code></td>
<td>
<p> a single <span class="rlang"><b>R</b></span> <em><code>functiion</code></em>. Must be an offensive programming wrapper
function. See <code><a href="#topic+opwf">opwf</a></code>.
</p>
</td></tr>
<tr><td><code id="exploreSignatures_+3A_argumentstyperestrictions_l">argumentsTypeRestrictions_l</code></td>
<td>

<p>a named <em><code>list</code></em>. Each name must match
a function argument name. Each content must be a vector of strings, each of them
matching a <code>retrieveDataFactory()$getKnownSuffixes()</code> known suffix.
</p>
</td></tr>
<tr><td><code id="exploreSignatures_+3A_signaturesrestrictions_l">signaturesRestrictions_l</code></td>
<td>

<p>an unnamed <em><code>list</code></em> of single strings, each of them
matching one of <code>computeArgumentsCombination(fun_f_1)$signature</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function offers a really convenient way to test your own functions, without
the burden of building the execution context, that is much trickier than one can imagine at first glance.
</p>
<p>Moreover it provides argument signature analysis, which is not provided by <code><a href="#topic+testFunction">testFunction</a></code>.
</p>
<p>Arguments restriction parameter <em><code>argumentsTypeRestrictions_l</code></em> allows to restrict on demand, value types exploration. It is very useful and convenient to reduce the exploration tree, and to shorten execution time.
</p>
<p>By default, a total of 768 tests will run for a single function, when no
<code>signaturesRestrictions_l</code> is set. This may requires some time to achieve.
</p>
<p>When working interactively, a good practice is to use <code><a href="#topic+computeArgumentsCombination">computeArgumentsCombination</a></code> prior to use function <code><a href="#topic+computeArgumentsCombination">computeArgumentsCombination</a></code>, as it will provide complexity information about the function you wish to test. The number of signature is a good metric of function call complexity. Know that each of them will be tested, and data generation has to be achieved for each parameter according to global or restricted scheme, depending on your <em><code>argumentsTypeRestrictions_l</code></em> inputs.
</p>


<h3>Value</h3>

<p>A <em><code>list</code></em> with names <b><code>info</code></b>, <b><code>success</code></b>, <b><code>failure</code></b>, each of them
being a <b>list</b>.
</p>
<p>The <em><code>info</code></em> sub <em><code>list</code></em> holds execution results. It holds following entries
</p>

<ul>
<li><p><b><em><code>raw</code></em></b> is a <em><code>list</code></em> , providing capture of execution context, data and results.
</p>
</li>
<li><p><b><em><code>good</code></em></b> is a <em><code>list</code></em> , providing same information as <em><code>raw</code></em>, filtered to retain only tests that do not generate any error.
</p>
</li>
<li><p><b><em><code>bad</code></em></b> is a <em><code>list</code></em> , providing same information as <em><code>raw</code></em>, filtered to retain only tests that do generate error.

</p>
</li></ul>

<p>The <em><code>success</code></em> sub <em><code>list</code></em> holds analysis results for tests which do
not generate errors. It holds following entries
</p>

<ul>
<li><p><b><em><code>code</code></em></b> is a <em><code>data.table</code></em>, providing used call code and results.
</p>
</li>
<li><p><b><em><code>table</code></em></b> is a <em><code>data.table</code></em>, providing used argument signatures and execution context information.
</p>
</li>
<li><p><b><em><code>synthesis</code></em></b> is a <em><code>list</code></em>, providing synthesis information. Much easier to read, than <code>table</code> entry.

</p>
</li></ul>

<p>The <em><code>failure</code></em> sub <em><code>list</code></em> holds analysis results for tests which do
generate errors. It holds following entries
</p>

<ul>
<li><p><b><em><code>table</code></em></b> is a <em><code>data.table</code></em>, providing encountered error messages and execution
context information
</p>
</li>
<li><p><b><em><code>synthesis</code></em></b> is a <em><code>list</code></em>, providing synthesis information. Much easier to read,
than <em><code>table</code></em> entry.

</p>
</li></ul>



<h3>Author(s)</h3>

<p>Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>
<p>Maintainer: Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Refer to <code><a href="#topic+testFunction">testFunction</a></code> and to <code><a href="#topic+generateData">generateData</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# typical use case
op_sum &lt;- opwf(sum, c('...', 'removeNA_b_1'))

rv_sum &lt;- exploreSignatures(op_sum, list(... = c('im', 'r', 'cm')))

# which are the errors of exploration and in what context do they occur?
print(rv_sum$failure$synthesis)

# which are the good behaviors of exploration and in what context do they occur?
print(rv_sum$success$synthesis)

# Restrict signatures to use for exploration testing on op_sum
# Consider only two cases: no argument and ellipsis1_, ellispsis2_
cac_sum &lt;- computeArgumentsCombination(op_sum)
rv_sum_f &lt;- exploreSignatures(op_sum, list(... = c('im', 'r', 'cm')),
                              cac_sum$signatures[c(1, 5)])

</code></pre>

<hr>
<h2 id='generateData'> Generate Data </h2><span id='topic+generateData'></span>

<h3>Description</h3>

<p> Function to generate data. </p>


<h3>Usage</h3>

<pre><code class='language-R'>generateData(function_f_1,
             argumentsTypeRestrictions_l = list(),
             replacementContext_l = setGenerationContext(),
             ellipsisReplacementContext_l = setGenerationContext(),
             defaultArgumentsContext_l = setDefaultArgumentsGenerationContext(),
             functionName_s_1 = deparse(substitute(function_f_1))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateData_+3A_function_f_1">function_f_1</code></td>
<td>
<p> a single <span class="rlang"><b>R</b></span> <em><code>function</code></em>, offensive programming ready,
therefore using semantic argument names </p>
</td></tr>
<tr><td><code id="generateData_+3A_argumentstyperestrictions_l">argumentsTypeRestrictions_l</code></td>
<td>
<p> a named <em><code>list</code></em>. Each name must match
a function argument name. Each content must be a vector of strings, each of them
matching a <code>retrieveDataFactory()$getKnownSuffixes()</code> known suffix.
</p>
</td></tr>
<tr><td><code id="generateData_+3A_replacementcontext_l">replacementContext_l</code></td>
<td>
<p> a generation context <em><code>object</code></em>, as defined by
<b><em><code><a href="#topic+setGenerationContext">setGenerationContext</a></code></em></b> function, applicable to standard
arguments of the function, if any.
</p>
</td></tr>
<tr><td><code id="generateData_+3A_ellipsisreplacementcontext_l">ellipsisReplacementContext_l</code></td>
<td>
<p> an ellipsis replacement context <em><code>object</code></em>,
as defined by
<em><b><code><a href="#topic+setGenerationContext">setGenerationContext</a></code></b></em> function, applicable to ...
arguments of the function.
</p>
</td></tr>
<tr><td><code id="generateData_+3A_defaultargumentscontext_l">defaultArgumentsContext_l</code></td>
<td>

<p>a default argument context <em><code>object</code></em>, as defined by
<em><b><code><a href="#topic+setDefaultArgumentsGenerationContext">setDefaultArgumentsGenerationContext</a></code></b></em> function,
applicable to default arguments of the function.
</p>
</td></tr>
<tr><td><code id="generateData_+3A_functionname_s_1">functionName_s_1</code></td>
<td>
<p> A character <em><code>vector</code></em> of length 1,
holding the function name. Particularly useful in <span class="rlang"><b>R</b></span> scripts. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate a driven aleatory set of data to be used as argument in a call to <em><code>function</code></em>
<code>fun_f_1</code>. Generation is driven by the <code>argumentsTypeRestrictions_l</code> argument.
</p>


<h3>Value</h3>

<p>A <em><code>object</code></em> with following names
</p>

<table>
<tr>
 <td style="text-align: left;">
<b><code>generation</code></b> </td><td style="text-align: left;"> argument name generation </td>
</tr>
<tr>
 <td style="text-align: left;">
<b>codedata</b> </td><td style="text-align: left;"> the generated data </td>
</tr>
<tr>
 <td style="text-align: left;">
<b><code>context</code></b> </td><td style="text-align: left;"> data type generation context </td>
</tr>
<tr>
 <td style="text-align: left;">
<b><code>n</code></b> </td><td style="text-align: left;"> number of first level data generations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p>Refer to <b><em>code<a href="#topic+retrieveDataFactory">retrieveDataFactory</a></em></b> and to
<b><em><code><a href="#topic+testFunction">testFunction</a></code></em></b>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># typical example
op_sum &lt;- opwf(sum, c('...', 'removeNA_b_1'))
op_sum_atr &lt;- list('...' = c('i', 'd', 'c'))
ec &lt;- setGenerationContext(0, TRUE, FALSE)
gd &lt;- generateData(op_sum, op_sum_atr, ec, erc$hetero_vector[[1]], dac$none)
</code></pre>

<hr>
<h2 id='opMetaTestingInformation'>Package functions information</h2><span id='topic+opMetaTestingInformation'></span>

<h3>Description</h3>

<p>A reminder of available functions from this package, and, most common usage
intent. A poor man CLI cheat sheet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opMetaTestingInformation()
</code></pre>


<h3>Value</h3>

<p>See <b><em><code><a href="wyz.code.offensiveProgramming.html#topic+opInformation">opInformation</a></code></em></b> value
description.
</p>


<h3>Author(s)</h3>

<p>Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>
<p>Maintainer: Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Refer also to package vignettes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- typical case ----
opMetaTestingInformation()
</code></pre>

<hr>
<h2 id='opwf'>
Offensive Programming Wrap Function
</h2><span id='topic+opwf'></span><span id='topic+offensiveProgrammingWrapFunction'></span>

<h3>Description</h3>

<p>Create an offensive programming function, wrapping a standard <span class="rlang"><b>R</b></span> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opwf(fun_f_1, parameterNames_s, functionName_s_1 = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opwf_+3A_fun_f_1">fun_f_1</code></td>
<td>
<p> a single <span class="rlang"><b>R</b></span> <em><code>function</code></em> </p>
</td></tr>
<tr><td><code id="opwf_+3A_parameternames_s">parameterNames_s</code></td>
<td>
<p> the new names of the parameter function, must be
semantic argument names.  Must be a bijection to actual <b><code>fun_f_1</code></b> argument names. </p>
</td></tr>
<tr><td><code id="opwf_+3A_functionname_s_1">functionName_s_1</code></td>
<td>
<p> A <em><code>string</code></em> holding the function name.
Default value, implies evaluation using <em><code>deparse(substitute(fun_f_1))</code></em>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If any arguments default values are present, they are managed transparently and
should be correctly and automatically substituted.
</p>


<h3>Value</h3>

<p>A <span class="rlang"><b>R</b></span> <em><code>function</code></em> which takes given <b><code>parameterNames_s</code></b> as arguments.
</p>


<h3>Author(s)</h3>

<p>Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>
<p>Maintainer: Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Refer to <b><em><code><a href="#topic+testFunction">testFunction</a></code></em></b>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># typical example
op_sum &lt;- opwf(sum, c('...', 'removeNA_b_1'))

# example with substituted argument in existing default valued arguments
op_append &lt;- opwf(append, c('originalValues_', 'valuesToInsert_', 'afterIndex_ui_1'))
</code></pre>

<hr>
<h2 id='qualifyFunctionArguments'>Qualify function arguments.</h2><span id='topic+qualifyFunctionArguments'></span>

<h3>Description</h3>

<p>Retrieve information about function arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualifyFunctionArguments(fun_f_1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qualifyFunctionArguments_+3A_fun_f_1">fun_f_1</code></td>
<td>
<p>A single <code>function</code>, not a string. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A emph<code>list</code> with following names
</p>
<table role = "presentation">
<tr><td><code>argument_names</code></td>
<td>
<p> a character <code>vector</code> of all the function argument names</p>
</td></tr>
<tr><td><code>owns_ellipsis</code></td>
<td>
<p> a boolean. Is <code>TRUE</code> when ... belongs to argument names</p>
</td></tr>
<tr><td><code>symbol_names</code></td>
<td>
<p> a character <code>vector</code>  of argument names that are symbols </p>
</td></tr>
<tr><td><code>symbol_indexes</code></td>
<td>
<p> the integer indexes of symbol names in the argument names</p>
</td></tr>
<tr><td><code>stripped_symbol_names</code></td>
<td>
<p> a character <code>vector</code> of argument names that are symbols,
not considering ...</p>
</td></tr>
<tr><td><code>stripped_symbol_indexes</code></td>
<td>
<p> the integer indexes of stripped symbol names
in the argument names</p>
</td></tr>
<tr><td><code>default_names</code></td>
<td>
<p>  a character <code>vector</code> of argument names that owns default values </p>
</td></tr>
<tr><td><code>default_indexes</code></td>
<td>
<p> the integer indexes of default valued arguments names in
the argument names</p>
</td></tr>
<tr><td><code>code{arguments}</code></td>
<td>
<p>a <code>pairList</code> of argument names and values.
Refer to <code><a href="base.html#topic+formals">formals</a></code> for more information</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>
<p>Maintainer: Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># typical examples

qualifyFunctionArguments(Sys.Date)

qualifyFunctionArguments(cos)

qualifyFunctionArguments(sum)

</code></pre>

<hr>
<h2 id='retrieveDataFactory'>Retrieve Data Factory</h2><span id='topic+retrieveDataFactory'></span>

<h3>Description</h3>

<p>As the data factory may be modified, this function allows you to make changes and to record them in
your own specialized data generation factory, to match various needs and ease reuse. </p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieveDataFactory()
</code></pre>


<h3>Details</h3>

<p>Provides a data factory.
</p>
<p>Retrieves a <b><em><code><a href="#topic+retrieveDataFactory">retrieveDataFactory</a></code></em></b> from options variable
<b><code>op_mt_data_factory</code></b>.
</p>
<p>Allow to customize data factory entries.
</p>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> <em><code>object</code></em>  that is a <b><em><code><a href="#topic+retrieveDataFactory">retrieveDataFactory</a></code></em></b> .
</p>


<h3>Author(s)</h3>

<p>Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>
<p>Maintainer: Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- typical case ----

draw_integer_array_dim2 &lt;- function(n, replace_b_1 = TRUE) {
  m &lt;- n + sample(0:3, 1)
  matrix(seq(1, n * m), byrow = TRUE, nrow = n,
         dimnames = list(paste('row_', 1:n), paste('col_', 1:m)))
}

df &lt;- retrieveDataFactory()
df$addSuffix('a', "array", draw_integer_array_dim2)

options(op_mt_data_factory = df)
fg &lt;- retrieveDataFactory() # retrieves the user defined data factory
fg$getRecordedTypes()[suffix == 'a'] # right behavior !

# wrong behavior as retrieveDataFactory will provide the default factory and not yours!
options(op_mt_data_factory = NULL)
fh &lt;- retrieveDataFactory() # retrieves the default factory
fh$getRecordedTypes()[suffix == 'a']
</code></pre>

<hr>
<h2 id='setDefaultArgumentsGenerationContext'>Set default arguments generation context.</h2><span id='topic+setDefaultArgumentsGenerationContext'></span><span id='topic+default_arguments_context'></span><span id='topic+dac'></span>

<h3>Description</h3>

<p>Set default arguments generation context
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDefaultArgumentsGenerationContext(useDefaultArguments_b_1 = TRUE,
                                     useAllDefaultArguments_b_1 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setDefaultArgumentsGenerationContext_+3A_usedefaultarguments_b_1">useDefaultArguments_b_1</code></td>
<td>
<p>a single <em><code>boolean</code></em> value to specify the usage of
default arguments in generated function call</p>
</td></tr>
<tr><td><code id="setDefaultArgumentsGenerationContext_+3A_usealldefaultarguments_b_1">useAllDefaultArguments_b_1</code></td>
<td>
<p>A single <em><code>boolean</code></em>  value to specify usage of all
default valued arguments in generated function call. Second argument is
considered only when first argument is <em><code>TRUE</code></em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em><code>list</code></em> holding the provided values, allowing easy reuse either interactively
or programmatically, accessible through names
<b><code>use</code></b>,  and <b><code>use_all</code></b>.
</p>
<p>Predefined variables named <b><code>default_arguments_context</code></b> and <b><code>dac</code></b>
hold most common definition cases. Very helpfull as it simplifies reuses and reduces code
length.
</p>


<h3>Author(s)</h3>

<p>Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>
<p>Maintainer: Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a typical instanciation
mydgc &lt;- list(
  setDefaultArgumentsGenerationContext(FALSE, FALSE),
  setDefaultArgumentsGenerationContext(TRUE, FALSE),
  setDefaultArgumentsGenerationContext(TRUE, TRUE)
)

# uses predefined variable
print(dac$partial)
</code></pre>

<hr>
<h2 id='setGenerationContext'>Set generation context.</h2><span id='topic+setGenerationContext'></span><span id='topic+established_replacement_context'></span><span id='topic+erc'></span>

<h3>Description</h3>

<p> Use this function to set a generation context </p>


<h3>Usage</h3>

<pre><code class='language-R'> setGenerationContext(replacementNumber_ui_1 = sample(0:3L, 1),
                      homogeneousTypeReplacement_b_1 = FALSE,
                      allowList_b_1 = TRUE,
                      forceList_b_1 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setGenerationContext_+3A_replacementnumber_ui_1">replacementNumber_ui_1</code></td>
<td>
<p> a single positive <em><code>integer</code></em> expressing the number
of arguments to generate.</p>
</td></tr>
<tr><td><code id="setGenerationContext_+3A_homogeneoustypereplacement_b_1">homogeneousTypeReplacement_b_1</code></td>
<td>
<p>A single <em><code>boolean</code></em>  expressing willingness to
replace chosen argument with same type arguments, or not. Useful when dealing with
.... </p>
</td></tr>
<tr><td><code id="setGenerationContext_+3A_allowlist_b_1">allowList_b_1</code></td>
<td>
<p>a single <em><code>boolean</code></em> , expressing the desired result. When <code>TRUE</code>
result is a <code>list</code>, a <code>vector</code> otherwise. </p>
</td></tr>
<tr><td><code id="setGenerationContext_+3A_forcelist_b_1">forceList_b_1</code></td>
<td>
<p>a single <em><code>boolean</code></em> , expressing the desire to get the result as
a <em><code>list</code></em>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em><code>list</code></em> containing all the provided arguments, accessible through names
<b><code>homogeneous_type</code></b>, <b><code>number_replacements</code></b>, and <b><code>allow_list</code></b>.
</p>
<p>Predefined variables named <b><code>established_replacement_context</code></b> and <b><code>erc</code></b>
hold most common definition cases. Very helpfull as it simplifies reuses and reduces code
length.
</p>


<h3>Author(s)</h3>

<p>Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>
<p>Maintainer: Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a typical instanciation
egc &lt;- list(
  setGenerationContext(homogeneous = TRUE),
  setGenerationContext(allowList = FALSE)
)

# uses predefined variable
print(erc$homo_vector[[2]])
</code></pre>

<hr>
<h2 id='testFunction'>Test function</h2><span id='topic+testFunction'></span>

<h3>Description</h3>

<p>Apply data to function signature and record results.</p>


<h3>Usage</h3>

<pre><code class='language-R'>testFunction(function_f_1,
             generatedData_l,
             functionName_s_1 = deparse(substitute(function_f_1)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testFunction_+3A_function_f_1">function_f_1</code></td>
<td>
<p> a single <span class="rlang"><b>R</b></span> <em><code>function</code></em>, offensive programming ready, with
using semantic argument names </p>
</td></tr>
<tr><td><code id="testFunction_+3A_generateddata_l">generatedData_l</code></td>
<td>

<p>data to apply to the function. Could be generated by <em><b><code><a href="#topic+generateData">generateData</a></code></b></em>
function is desired.
</p>
</td></tr>
<tr><td><code id="testFunction_+3A_functionname_s_1">functionName_s_1</code></td>
<td>
<p>A <em><code>string</code></em> that is the function name.
Particularly useful, in scripts.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Executes code and captures execution context and result, for posterior analysis.
</p>


<h3>Value</h3>

<p>A <em><code>list</code></em> with following names
</p>

<table>
<tr>
 <td style="text-align: left;">
<b><code>generation</code></b> </td><td style="text-align: left;"> argument name generation </td>
</tr>
<tr>
 <td style="text-align: left;">
<b><code>data</code></b> </td><td style="text-align: left;"> generated data </td>
</tr>
<tr>
 <td style="text-align: left;">
<b><code>context</code></b> </td><td style="text-align: left;"> data tyep generation context </td>
</tr>
<tr>
 <td style="text-align: left;">
<b><code>n</code></b> </td><td style="text-align: left;"> number of first level data generated </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Generated data are ready for use and accessible using the <b><code>data</code></b> name of
the <em><code>list</code></em>.
</p>


<h3>See Also</h3>

<p>Refer to <code><a href="#topic+opwf">opwf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># typical example
op_sum &lt;- opwf(sum, c('...', 'removeNA_b_1'))
op_sum_atr &lt;- list('...' = c('i', 'd', 'c'))
ec &lt;- setGenerationContext(0, TRUE, FALSE)
gd &lt;- generateData(op_sum, op_sum_atr, ec, erc$hetero_vector[[1]], dac$none)
tf &lt;- testFunction(op_sum, gd$data)
</code></pre>

<hr>
<h2 id='usesSemanticArgumentNames'>Uses semantic argument names.</h2><span id='topic+usesSemanticArgumentNames'></span>

<h3>Description</h3>

<p>Determine if the given function uses semantic argument names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usesSemanticArgumentNames(fun_f_1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="usesSemanticArgumentNames_+3A_fun_f_1">fun_f_1</code></td>
<td>
<p>A single <em><code>function</code></em></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em><code>TRUE</code></em> when arguments used by function are all semantic names.
</p>


<h3>Author(s)</h3>

<p>Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>
<p>Maintainer: Fabien Gelineau &lt;neonira@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x_) x_

usesSemanticArgumentNames(f)
# TRUE

usesSemanticArgumentNames(sum)
# FALSE
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
