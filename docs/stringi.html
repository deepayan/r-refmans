<!DOCTYPE html><html><head><title>Help for package stringi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stringi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#about_stringi'><p>Fast and Portable Character String Processing in R</p></a></li>
<li><a href='#+25s+26lt+3B+25'><p>Compare Strings with or without Collation</p></a></li>
<li><a href='#+25s+2B+25'><p>Concatenate Two Character Vectors</p></a></li>
<li><a href='#+25s+24+25'><p>C-Style Formatting with <code>stri_sprintf</code> as a Binary Operator</p></a></li>
<li><a href='#about_arguments'><p>Passing Arguments to Functions in <span class="pkg">stringi</span></p></a></li>
<li><a href='#about_encoding'><p>Character Encodings and <span class="pkg">stringi</span></p></a></li>
<li><a href='#about_locale'><p>Locales and <span class="pkg">stringi</span></p></a></li>
<li><a href='#about_search'><p>String Searching</p></a></li>
<li><a href='#about_search_boundaries'><p>Text Boundary Analysis in <span class="pkg">stringi</span></p></a></li>
<li><a href='#about_search_charclass'><p>Character Classes in <span class="pkg">stringi</span></p></a></li>
<li><a href='#about_search_coll'><p>Locale-Sensitive Text Searching in <span class="pkg">stringi</span></p></a></li>
<li><a href='#about_search_fixed'><p>Locale-Insensitive Fixed Pattern Matching in <span class="pkg">stringi</span></p></a></li>
<li><a href='#about_search_regex'><p>Regular Expressions in <span class="pkg">stringi</span></p></a></li>
<li><a href='#stri_compare'><p>Compare Strings with or without Collation</p></a></li>
<li><a href='#stri_count'><p>Count the Number of Pattern Occurrences</p></a></li>
<li><a href='#stri_count_boundaries'><p>Count the Number of Text Boundaries</p></a></li>
<li><a href='#stri_datetime_add'><p>Date and Time Arithmetic</p></a></li>
<li><a href='#stri_datetime_create'><p>Create a Date-Time Object</p></a></li>
<li><a href='#stri_datetime_fields'><p>Get Values for Date and Time Fields</p></a></li>
<li><a href='#stri_datetime_format'><p>Date and Time Formatting and Parsing</p></a></li>
<li><a href='#stri_datetime_fstr'><p>Convert <code>strptime</code>-Style Format Strings</p></a></li>
<li><a href='#stri_datetime_now'><p>Get Current Date and Time</p></a></li>
<li><a href='#stri_datetime_symbols'><p>List Localizable Date-Time Formatting Data</p></a></li>
<li><a href='#stri_detect'><p>Detect Pattern Occurrences</p></a></li>
<li><a href='#stri_dup'><p>Duplicate Strings</p></a></li>
<li><a href='#stri_duplicated'><p>Determine Duplicated Elements</p></a></li>
<li><a href='#stri_enc_detect'><p>Detect Character Set and Language</p></a></li>
<li><a href='#stri_enc_detect2'><p>[DEPRECATED] Detect Locale-Sensitive Character Encoding</p></a></li>
<li><a href='#stri_enc_fromutf32'><p>Convert From UTF-32</p></a></li>
<li><a href='#stri_enc_info'><p>Query a Character Encoding</p></a></li>
<li><a href='#stri_enc_isascii'><p>Check If a Data Stream Is Possibly in ASCII</p></a></li>
<li><a href='#stri_enc_isutf16be'><p>Check If a Data Stream Is Possibly in UTF-16 or UTF-32</p></a></li>
<li><a href='#stri_enc_isutf8'><p>Check If a Data Stream Is Possibly in UTF-8</p></a></li>
<li><a href='#stri_enc_list'><p>List Known Character Encodings</p></a></li>
<li><a href='#stri_enc_mark'><p>Get Declared Encodings of Each String</p></a></li>
<li><a href='#stri_enc_set'><p>Set or Get Default Character Encoding in <span class="pkg">stringi</span></p></a></li>
<li><a href='#stri_enc_toascii'><p>Convert To ASCII</p></a></li>
<li><a href='#stri_enc_tonative'><p>Convert Strings To Native Encoding</p></a></li>
<li><a href='#stri_enc_toutf32'><p>Convert Strings To UTF-32</p></a></li>
<li><a href='#stri_enc_toutf8'><p>Convert Strings To UTF-8</p></a></li>
<li><a href='#stri_encode'><p>Convert Strings Between Given Encodings</p></a></li>
<li><a href='#stri_escape_unicode'><p>Escape Unicode Code Points</p></a></li>
<li><a href='#stri_extract_all'><p>Extract Pattern Occurrences</p></a></li>
<li><a href='#stri_extract_all_boundaries'><p>Extract Data Between Text Boundaries</p></a></li>
<li><a href='#stri_flatten'><p>Flatten a String</p></a></li>
<li><a href='#stri_info'><p>Query Default Settings for <span class="pkg">stringi</span></p></a></li>
<li><a href='#stri_isempty'><p>Determine if a String is of Length Zero</p></a></li>
<li><a href='#stri_join'><p>Concatenate Character Vectors</p></a></li>
<li><a href='#stri_join_list'><p>Concatenate Strings in a List</p></a></li>
<li><a href='#stri_length'><p>Count the Number of Code Points</p></a></li>
<li><a href='#stri_list2matrix'><p>Convert a List to a Character Matrix</p></a></li>
<li><a href='#stri_locale_info'><p>Query Given Locale</p></a></li>
<li><a href='#stri_locale_list'><p>List Available Locales</p></a></li>
<li><a href='#stri_locale_set'><p>Set or Get Default Locale in <span class="pkg">stringi</span></p></a></li>
<li><a href='#stri_locate_all'><p>Locate Pattern Occurrences</p></a></li>
<li><a href='#stri_locate_all_boundaries'><p>Locate Text Boundaries</p></a></li>
<li><a href='#stri_match_all'><p>Extract Regex Pattern Matches, Together with Capture Groups</p></a></li>
<li><a href='#stri_na2empty'><p>Replace NAs with Empty Strings</p></a></li>
<li><a href='#stri_numbytes'><p>Count the Number of Bytes</p></a></li>
<li><a href='#stri_opts_brkiter'><p>Generate a List with BreakIterator Settings</p></a></li>
<li><a href='#stri_opts_collator'><p>Generate a List with Collator Settings</p></a></li>
<li><a href='#stri_opts_fixed'><p>Generate a List with Fixed Pattern Search Engine's Settings</p></a></li>
<li><a href='#stri_opts_regex'><p>Generate a List with Regex Matcher Settings</p></a></li>
<li><a href='#stri_order'><p>Ordering Permutation</p></a></li>
<li><a href='#stri_pad_both'><p>Pad (Center/Left/Right Align) a String</p></a></li>
<li><a href='#stri_rand_lipsum'><p>A Lorem Ipsum Generator</p></a></li>
<li><a href='#stri_rand_shuffle'><p>Randomly Shuffle Code Points in Each String</p></a></li>
<li><a href='#stri_rand_strings'><p>Generate Random Strings</p></a></li>
<li><a href='#stri_rank'><p>Ranking</p></a></li>
<li><a href='#stri_read_lines'><p>Read Text Lines from a Text File</p></a></li>
<li><a href='#stri_read_raw'><p>Read Text File as Raw</p></a></li>
<li><a href='#stri_remove_empty'><p>Remove All Empty Strings from a Character Vector</p></a></li>
<li><a href='#stri_replace_all'><p>Replace Pattern Occurrences</p></a></li>
<li><a href='#stri_replace_na'><p>Replace Missing Values in a Character Vector</p></a></li>
<li><a href='#stri_replace_rstr'><p>Convert gsub-Style Replacement Strings</p></a></li>
<li><a href='#stri_reverse'><p>Reverse Each String</p></a></li>
<li><a href='#stri_sort'><p>String Sorting</p></a></li>
<li><a href='#stri_sort_key'><p>Sort Keys</p></a></li>
<li><a href='#stri_split'><p>Split a String By Pattern Matches</p></a></li>
<li><a href='#stri_split_boundaries'><p>Split a String at Text Boundaries</p></a></li>
<li><a href='#stri_split_lines'><p>Split a String Into Text Lines</p></a></li>
<li><a href='#stri_sprintf'><p>Format Strings</p></a></li>
<li><a href='#stri_startswith'><p>Determine if the Start or End of a String Matches a Pattern</p></a></li>
<li><a href='#stri_stats_general'><p>General Statistics for a Character Vector</p></a></li>
<li><a href='#stri_stats_latex'><p>Statistics for a Character Vector Containing LaTeX Commands</p></a></li>
<li><a href='#stri_sub'><p>Extract a Substring From or Replace a Substring In a Character Vector</p></a></li>
<li><a href='#stri_sub_all'><p>Extract or Replace Multiple Substrings</p></a></li>
<li><a href='#stri_subset'><p>Select Elements that Match a Given Pattern</p></a></li>
<li><a href='#stri_timezone_get'><p>Set or Get Default Time Zone in <span class="pkg">stringi</span></p></a></li>
<li><a href='#stri_timezone_info'><p>Query a Given Time Zone</p></a></li>
<li><a href='#stri_timezone_list'><p>List Available Time Zone Identifiers</p></a></li>
<li><a href='#stri_trans_char'><p>Translate Characters</p></a></li>
<li><a href='#stri_trans_general'><p>General Text Transforms, Including Transliteration</p></a></li>
<li><a href='#stri_trans_list'><p>List Available Text Transforms and Transliterators</p></a></li>
<li><a href='#stri_trans_nfc'><p>Perform or Check For Unicode Normalization</p></a></li>
<li><a href='#stri_trans_tolower'><p>Transform Strings with Case Mapping or Folding</p></a></li>
<li><a href='#stri_trim_both'><p>Trim Characters from the Left and/or Right Side of a String</p></a></li>
<li><a href='#stri_unescape_unicode'><p>Un-escape All Escape Sequences</p></a></li>
<li><a href='#stri_unique'><p>Extract Unique Elements</p></a></li>
<li><a href='#stri_width'><p>Determine the Width of Code Points</p></a></li>
<li><a href='#stri_wrap'><p>Word Wrap Text to Format Paragraphs</p></a></li>
<li><a href='#stri_write_lines'><p>Write Text Lines to a Text File</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.8.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-06</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast and Portable Character String Processing Facilities</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of character string/text/natural language
    processing tools for pattern searching (e.g., with 'Java'-like regular
    expressions or the 'Unicode' collation algorithm), random string generation,
    case mapping, string transliteration, concatenation, sorting, padding,
    wrapping, Unicode normalisation, date-time formatting and parsing,
    and many more. They are fast, consistent, convenient, and -
    thanks to 'ICU' (International Components for Unicode) -
    portable across all locales and platforms. Documentation about 'stringi' is
    provided via its website at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a> and
    the paper by Gagolewski (2022, &lt;<a href="https://doi.org/10.18637%2Fjss.v103.i02">doi:10.18637/jss.v103.i02</a>&gt;).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>,
<a href="https://github.com/gagolews/stringi">https://github.com/gagolews/stringi</a>, <a href="https://icu.unicode.org/">https://icu.unicode.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gagolews/stringi/issues">https://github.com/gagolews/stringi/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>ICU4C (&gt;= 61, optional)</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tools, utils, stats</td>
</tr>
<tr>
<td>Biarch:</td>
<td>TRUE</td>
</tr>
<tr>
<td>License:</td>
<td>file LICENSE</td>
</tr>
<tr>
<td>Author:</td>
<td>Marek Gagolewski [aut, cre, cph] (&lt;https://orcid.org/0000-0003-0637-6028&gt;),
    Bartek Tartanus [ctb], and others (stringi source code);
    Unicode, Inc. and others (ICU4C source code, Unicode Character Database)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marek Gagolewski &lt;marek@gagolewski.com&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-06 12:50:25 UTC; gagolews</td>
</tr>
<tr>
<td>License_is_FOSS:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-06 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='about_stringi'>Fast and Portable Character String Processing in R</h2><span id='topic+about_stringi'></span><span id='topic+stringi'></span><span id='topic+stringi-package'></span>

<h3>Description</h3>

<p><span class="pkg">stringi</span> is THE R package for fast, correct, consistent,
and convenient string/text manipulation.
It gives predictable results on every platform, in each locale,
and under any native character encoding.
</p>
<p><b>Keywords</b>: R, text processing, character strings,
internationalization, localization, ICU, ICU4C, i18n, l10n, Unicode.
</p>
<p><b>Homepage</b>: <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p><b>License</b>: The BSD-3-clause license for the package code,
the ICU license for the accompanying ICU4C distribution,
and the UCD license for the Unicode Character Database.
See the COPYRIGHTS and LICENSE file for more details.
</p>


<h3>Details</h3>

<p>Manual pages on general topics:
</p>

<ul>
<li> <p><a href="#topic+about_encoding">about_encoding</a> &ndash; character encoding issues, including
information on encoding management in <span class="pkg">stringi</span>, as well as
on encoding detection and conversion.
</p>
</li>
<li> <p><a href="#topic+about_locale">about_locale</a> &ndash; locale issues, including locale
management and specification in <span class="pkg">stringi</span>, and the list of
locale-sensitive operations. In particular, see
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code> for a description of the string
collation algorithm, which is used for string comparing, ordering,
ranking, sorting, case-folding, and searching.
</p>
</li>
<li> <p><a href="#topic+about_arguments">about_arguments</a> &ndash; information on how <span class="pkg">stringi</span>
handles the arguments passed to its function.
</p>
</li></ul>



<h3>Facilities available</h3>

<p>Refer to the following:
</p>

<ul>
<li> <p><a href="#topic+about_search">about_search</a> for string searching facilities;
these include pattern searching, matching, string splitting, and so on.
The following independent search engines are provided:
</p>

<ul>
<li> <p><a href="#topic+about_search_regex">about_search_regex</a> &ndash; with ICU (Java-like) regular expressions,
</p>
</li>
<li> <p><a href="#topic+about_search_fixed">about_search_fixed</a> &ndash; fast, locale-independent, byte-wise pattern
matching,
</p>
</li>
<li> <p><a href="#topic+about_search_coll">about_search_coll</a> &ndash; locale-aware pattern matching
for natural language processing tasks,
</p>
</li>
<li> <p><a href="#topic+about_search_charclass">about_search_charclass</a> &ndash; seeking elements of
particular character classes, like &ldquo;all whites-paces&rdquo; or &ldquo;all digits&rdquo;,
</p>
</li>
<li> <p><a href="#topic+about_search_boundaries">about_search_boundaries</a> &ndash; text boundary analysis.
</p>
</li></ul>

</li>
<li> <p><code><a href="#topic+stri_datetime_format">stri_datetime_format</a></code> for date/time formatting
and parsing. Also refer to the links therein for other date/time/time zone-
related operations.
</p>
</li>
<li> <p><code><a href="#topic+stri_stats_general">stri_stats_general</a></code> and <code><a href="#topic+stri_stats_latex">stri_stats_latex</a></code>
for gathering some fancy statistics on a character vector's contents.
</p>
</li>
<li> <p><code><a href="#topic+stri_join">stri_join</a></code>, <code><a href="#topic+stri_dup">stri_dup</a></code>, <code><a href="#topic++25s+2B+25">%s+%</a></code>,
and <code><a href="#topic+stri_flatten">stri_flatten</a></code> for concatenation-based operations.
</p>
</li>
<li> <p><code><a href="#topic+stri_sub">stri_sub</a></code> for extracting and replacing substrings,
and <code><a href="#topic+stri_reverse">stri_reverse</a></code> for a joyful function
to reverse all code points in a string.
</p>
</li>
<li> <p><code><a href="#topic+stri_length">stri_length</a></code> (among others) for determining the number
of code points in a string. See also <code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a></code>
for counting the number of Unicode characters
and <code><a href="#topic+stri_width">stri_width</a></code> for approximating the width of a string.
</p>
</li>
<li> <p><code><a href="#topic+stri_trim">stri_trim</a></code> (among others) for
trimming characters from the beginning or/and end of a string,
see also <a href="#topic+about_search_charclass">about_search_charclass</a>, and <code><a href="#topic+stri_pad">stri_pad</a></code>
for padding strings so that they are of the same width.
Additionally, <code><a href="#topic+stri_wrap">stri_wrap</a></code> wraps text into lines.
</p>
</li>
<li> <p><code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a></code> (among others) for case mapping,
i.e., conversion to lower, UPPER, or Title Case,
<code><a href="#topic+stri_trans_nfc">stri_trans_nfc</a></code> (among others) for Unicode normalization,
<code><a href="#topic+stri_trans_char">stri_trans_char</a></code> for translating individual code points,
and <code><a href="#topic+stri_trans_general">stri_trans_general</a></code> for other universal
text transforms, including transliteration.
</p>
</li>
<li> <p><code><a href="#topic+stri_cmp">stri_cmp</a></code>, <code><a href="#topic++25s+3C+25">%s&lt;%</a></code>, <code><a href="#topic+stri_order">stri_order</a></code>,
<code><a href="#topic+stri_sort">stri_sort</a></code>, <code><a href="#topic+stri_rank">stri_rank</a></code>, <code><a href="#topic+stri_unique">stri_unique</a></code>,
and <code><a href="#topic+stri_duplicated">stri_duplicated</a></code> for collation-based,
locale-aware operations, see also <a href="#topic+about_locale">about_locale</a>.
</p>
</li>
<li> <p><code><a href="#topic+stri_split_lines">stri_split_lines</a></code> (among others)
to split a string into text lines.
</p>
</li>
<li> <p><code><a href="#topic+stri_escape_unicode">stri_escape_unicode</a></code> (among others) for escaping
some code points.
</p>
</li>
<li> <p><code><a href="#topic+stri_rand_strings">stri_rand_strings</a></code>, <code><a href="#topic+stri_rand_shuffle">stri_rand_shuffle</a></code>,
and <code><a href="#topic+stri_rand_lipsum">stri_rand_lipsum</a></code> for generating (pseudo)random strings.
</p>
</li>
<li> <p><code><a href="#topic+stri_read_raw">stri_read_raw</a></code>,
<code><a href="#topic+stri_read_lines">stri_read_lines</a></code>, and  <code><a href="#topic+stri_write_lines">stri_write_lines</a></code>
for reading and writing text files.
</p>
</li></ul>

<p>Note that each man page provides many further links to other
interesting facilities and topics.
</p>


<h3>Author(s)</h3>

<p>Marek Gagolewski,
with contributions from Bartek Tartanus and many others.
ICU4C was developed by IBM, Unicode, Inc., and others.
</p>


<h3>References</h3>

<p><em><span class="pkg">stringi</span> Package Homepage</em>,
<a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string
processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59,
<a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p><em>ICU &ndash; International Components for Unicode</em>,
<a href="https://icu.unicode.org/">https://icu.unicode.org/</a>
</p>
<p><em>ICU4C API Documentation</em>,
<a href="https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/">https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/</a>
</p>
<p><em>The Unicode Consortium</em>,
<a href="https://home.unicode.org/">https://home.unicode.org/</a>
</p>
<p><em>UTF-8, A Transformation Format of ISO 10646</em> &ndash; RFC 3629,
<a href="https://www.rfc-editor.org/rfc/rfc3629">https://www.rfc-editor.org/rfc/rfc3629</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other stringi_general_topics: 
<code><a href="#topic+about_arguments">about_arguments</a></code>,
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_charclass">about_search_charclass</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+about_search_fixed">about_search_fixed</a></code>,
<code><a href="#topic+about_search_regex">about_search_regex</a></code>,
<code><a href="#topic+about_search">about_search</a></code>
</p>

<hr>
<h2 id='+25s+26lt+3B+25'>Compare Strings with or without Collation</h2><span id='topic++25s+3C+25'></span><span id='topic+operator_compare'></span><span id='topic+oper_comparison'></span><span id='topic+oper_compare'></span><span id='topic++25s+3C+3D+25'></span><span id='topic++25s+3E+25'></span><span id='topic++25s+3E+3D+25'></span><span id='topic++25s+3D+3D+25'></span><span id='topic++25s+21+3D+25'></span><span id='topic++25s+3D+3D+3D+25'></span><span id='topic++25s+21+3D+3D+25'></span><span id='topic++25stri+3C+25'></span><span id='topic++25stri+3C+3D+25'></span><span id='topic++25stri+3E+25'></span><span id='topic++25stri+3E+3D+25'></span><span id='topic++25stri+3D+3D+25'></span><span id='topic++25stri+21+3D+25'></span><span id='topic++25stri+3D+3D+3D+25'></span><span id='topic++25stri+21+3D+3D+25'></span>

<h3>Description</h3>

<p>Relational operators for comparing corresponding strings in
two character vectors, with a typical R look-and-feel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %s&lt;% e2

e1 %s&lt;=% e2

e1 %s&gt;% e2

e1 %s&gt;=% e2

e1 %s==% e2

e1 %s!=% e2

e1 %s===% e2

e1 %s!==% e2

e1 %stri&lt;% e2

e1 %stri&lt;=% e2

e1 %stri&gt;% e2

e1 %stri&gt;=% e2

e1 %stri==% e2

e1 %stri!=% e2

e1 %stri===% e2

e1 %stri!==% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25s+2B26lt+2B3B+2B25_+3A_e1">e1</code>, <code id="+2B25s+2B26lt+2B3B+2B25_+3A_e2">e2</code></td>
<td>
<p>character vectors or objects coercible to character vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions call <code><a href="#topic+stri_cmp_le">stri_cmp_le</a></code> or its
friends, using the default collator options.
As a consequence, they are vectorized over <code>e1</code> and <code>e2</code>.
</p>
<p><code>%stri==%</code> tests for canonical equivalence of strings
(see <code><a href="#topic+stri_cmp_equiv">stri_cmp_equiv</a></code>) and is a locale-dependent operation.
</p>
<p><code>%stri===%</code> performs a locale-independent,
code point-based comparison.
</p>


<h3>Value</h3>

<p>All the functions return a logical vector
indicating the result of a pairwise comparison.
As usual, the elements of shorter vectors are recycled if necessary.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>'a' %stri&lt;% 'b'
c('a', 'b', 'c') %stri&gt;=% 'b'

</code></pre>

<hr>
<h2 id='+25s+2B+25'>Concatenate Two Character Vectors</h2><span id='topic++25s+2B+25'></span><span id='topic+oper_plus'></span><span id='topic+operator_add'></span><span id='topic+operator_plus'></span><span id='topic++25stri+2B+25'></span>

<h3>Description</h3>

<p>Binary operators for joining (concatenating) two character vectors,
with a typical R look-and-feel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %s+% e2

e1 %stri+% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25s+2B2B+2B25_+3A_e1">e1</code></td>
<td>
<p>a character vector or an object coercible to a character vector</p>
</td></tr>
<tr><td><code id="+2B25s+2B2B+2B25_+3A_e2">e2</code></td>
<td>
<p>a character vector or an object coercible to a character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>e1</code> and <code>e2</code>.
</p>
<p>These operators act like a call to <code><a href="#topic+stri_join">stri_join</a>(e1, e2, sep='')</code>.
However, note that joining 3 vectors, e.g., <code>e1 %s+% e2 %s+% e3</code>
is slower than <code><a href="#topic+stri_join">stri_join</a>(e1, e2, e3, sep='')</code>,
because it creates a new (temporary) result vector each time
the operator is applied.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other join: 
<code><a href="#topic+stri_dup">stri_dup</a>()</code>,
<code><a href="#topic+stri_flatten">stri_flatten</a>()</code>,
<code><a href="#topic+stri_join_list">stri_join_list</a>()</code>,
<code><a href="#topic+stri_join">stri_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c('abc', '123', 'xy') %s+% letters[1:6]
'ID_' %s+% 1:5

</code></pre>

<hr>
<h2 id='+25s+24+25'>C-Style Formatting with <code><a href="#topic+stri_sprintf">stri_sprintf</a></code> as a Binary Operator</h2><span id='topic++25s+24+25'></span><span id='topic+operator_dollar'></span><span id='topic+oper_dollar'></span><span id='topic++25stri+24+25'></span>

<h3>Description</h3>

<p>Provides access to <code><a href="#topic+stri_sprintf">stri_sprintf</a></code> in form of a binary
operator in a way similar to Python's <code>%</code> overloaded for strings.
</p>
<p>Missing values and empty vectors are propagated as usual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %s$% e2

e1 %stri$% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25s+2B24+2B25_+3A_e1">e1</code></td>
<td>
<p>format strings, see <code><a href="#topic+stri_sprintf">stri_sprintf</a></code> for syntax</p>
</td></tr>
<tr><td><code id="+2B25s+2B24+2B25_+3A_e2">e2</code></td>
<td>
<p>a list of atomic vectors to be passed to <code><a href="#topic+stri_sprintf">stri_sprintf</a></code>
or a single atomic vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>e1</code> and <code>e2</code>.
</p>
<p><code>e1 %s$% atomic_vector</code> is equivalent to
<code>e1 %s$% list(atomic_vector)</code>.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other length: 
<code><a href="#topic+stri_isempty">stri_isempty</a>()</code>,
<code><a href="#topic+stri_length">stri_length</a>()</code>,
<code><a href="#topic+stri_numbytes">stri_numbytes</a>()</code>,
<code><a href="#topic+stri_pad_both">stri_pad_both</a>()</code>,
<code><a href="#topic+stri_sprintf">stri_sprintf</a>()</code>,
<code><a href="#topic+stri_width">stri_width</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>"value='%d'" %s$% 3
"value='%d'" %s$% 1:3
"%s='%d'" %s$% list("value", 3)
"%s='%d'" %s$% list("value", 1:3)
"%s='%d'" %s$% list(c("a", "b", "c"), 1)
"%s='%d'" %s$% list(c("a", "b", "c"), 1:3)

x &lt;- c("abcd", "\u00DF\u00B5\U0001F970", "abcdef")
cat("[%6s]" %s$% x, sep="\n")  # width used, not the number of bytes

</code></pre>

<hr>
<h2 id='about_arguments'>Passing Arguments to Functions in <span class="pkg">stringi</span></h2><span id='topic+about_arguments'></span><span id='topic+arguments'></span><span id='topic+stringi-arguments'></span>

<h3>Description</h3>

<p>Below we explain how <span class="pkg">stringi</span> deals with its functions' arguments.
</p>
<p>If some function violates one of the following rules
(for a very important reason),
this is clearly indicated in its documentation (with discussion).
</p>


<h3>Coercion of Arguments</h3>

<p>When a character vector argument is expected, factors and other vectors
coercible to characters vectors are silently converted with
<code><a href="base.html#topic+as.character">as.character</a></code>, otherwise an error is generated.
Coercion from a list which does not consist of length-1 atomic vectors
issues a warning.
</p>
<p>When a logical, numeric, or integer vector argument is expected,
factors are converted with <code>as.*(<a href="base.html#topic+as.character">as.character</a>(...))</code>,
and other coercible vectors are converted with <code>as.*</code>,
otherwise an error is generated.
</p>


<h3>Vectorization</h3>

<p>Almost all functions are vectorized with respect to all their arguments
and the recycling rule is applied whenever necessary.
Due to this property you may,
for instance, search for one pattern in each given string,
search for each pattern in one given string,
and search for the i-th pattern within the i-th string.
</p>
<p>We of course took great care of performance issues:
e.g., in regular expression searching, regex matchers are reused
from iteration to iteration, as long as it is possible.
</p>
<p>Functions with some non-vectorized arguments are rare:
e.g., regular expression matcher's settings are established
once per each call.
</p>
<p>Some functions
assume that a vector with one element is given
as an argument (like <code>collapse</code> in <code><a href="#topic+stri_join">stri_join</a></code>).
In such cases, if an empty vector is given you will get an error
and for vectors with more than 1 elements - a warning will be
generated (only the first element will be used).
</p>
<p>You may find details on vectorization behavior in the man pages
on each particular function of your interest.
</p>


<h3>Handling Missing Values (<code>NA</code>s)</h3>

<p><span class="pkg">stringi</span> handles missing values consistently.
For any vectorized operation, if at least one vector element is missing,
then the corresponding resulting value is also set to <code>NA</code>.
</p>


<h3>Preserving Object Attributes</h3>

<p>Generally, all our functions drop input objects' attributes
(e.g., <code><a href="base.html#topic+names">names</a></code>, <code><a href="base.html#topic+dim">dim</a></code>, etc.).
This is due to deep vectorization as well as for efficiency reasons.
If the preservation of attributes is needed,
important attributes can be manually copied. Alternatively, the notation
<code>x[] &lt;- stri_...(x, ...)</code> can sometimes be used too.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other stringi_general_topics: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_charclass">about_search_charclass</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+about_search_fixed">about_search_fixed</a></code>,
<code><a href="#topic+about_search_regex">about_search_regex</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+about_stringi">about_stringi</a></code>
</p>

<hr>
<h2 id='about_encoding'>Character Encodings and <span class="pkg">stringi</span></h2><span id='topic+about_encoding'></span><span id='topic+stringi-encoding'></span><span id='topic+encoding'></span>

<h3>Description</h3>

<p>This manual page explains how <span class="pkg">stringi</span> deals with character
strings in various encodings.
</p>
<p>In particular we should note that:
</p>

<ul>
<li> <p><span class="rlang"><b>R</b></span> lets strings in ASCII, UTF-8, and your platform's
native encoding coexist. A character vector printed on the console
by calling <code><a href="base.html#topic+print">print</a></code> or <code><a href="base.html#topic+cat">cat</a></code> is
silently re-encoded to the native encoding.
</p>
</li>
<li><p> Functions in <span class="pkg">stringi</span> process each string internally in
Unicode, the most universal character encoding ever.
Even if a string is given in the native encoding, i.e., your platform's
default one, it will be converted to Unicode (precisely: UTF-8 or UTF-16).
</p>
</li>
<li><p> Most <span class="pkg">stringi</span> functions always return UTF-8 encoded strings,
regardless of the input encoding. What is more, the functions have been
optimized for UTF-8/ASCII input (they have competitive, if not better
performance, especially when performing more complex operations like
string comparison, sorting, and even concatenation). Thus, it is
best to rely on cascading calls to <span class="pkg">stringi</span> operations solely.
</p>
</li></ul>



<h3>Details</h3>

<p>Quoting the ICU User Guide,
'Hundreds of encodings have been developed over the years, each for small
groups of languages and for special purposes. As a result,
the interpretation of text, input, sorting, display, and storage
depends on the knowledge of all the different types of character sets
and their encodings. Programs have been written to handle either
one single encoding at a time and switch between them, or to convert
between external and internal encodings.'
</p>
<p>'Unicode provides a single character set that covers the major
languages of the world, and a small number of machine-friendly encoding
forms and schemes to fit the needs of existing applications and protocols.
It is designed for best interoperability with both ASCII and ISO-8859-1
(the most widely used character sets) to make it easier for Unicode to be
used in almost all applications and protocols' (see the ICU User Guide).
</p>
<p>The Unicode Standard determines the way to map any possible character
to a numeric value &ndash; a so-called code point. Such code points, however,
have to be stored somehow in computer's memory.
The Unicode Standard encodes characters in the range U+0000..U+10FFFF,
which amounts to a 21-bit code space. Depending on the encoding
form (UTF-8, UTF-16, or UTF-32), each character will
then be represented either as a sequence of one to four 8-bit bytes,
one or two 16-bit code units, or a single 32-bit integer
(compare the ICU FAQ).
</p>
<p>Unicode can be thought of as a superset of the spectrum of characters
supported by any given code page.
</p>


<h3>UTF-8 and UTF-16</h3>

<p>For portability reasons, the UTF-8 encoding is the most natural choice
for representing Unicode character strings in <span class="rlang"><b>R</b></span>. UTF-8 has ASCII as its
subset (code points 1&ndash;127 represent the same characters in both of them).
Code points larger than 127 are represented by multi-byte sequences
(from 2 to 4 bytes: Please note that not all sequences of bytes
are valid UTF-8, compare <code><a href="#topic+stri_enc_isutf8">stri_enc_isutf8</a></code>).
</p>
<p>Most of the computations in <span class="pkg">stringi</span> are performed internally
using either UTF-8 or UTF-16 encodings (this depends on type of service
you request: some <span class="pkg">ICU</span> services are designed only to work with UTF-16).
Due to such a choice, with <span class="pkg">stringi</span> you get the same result on
each platform, which is &ndash; unfortunately &ndash; not the case of base <span class="rlang"><b>R</b></span>'s
functions (for instance, it is known that performing a regular expression
search under Linux on some texts may give you a different result
to those obtained under Windows). We really had portability in our minds
while developing our package!
</p>
<p>We have observed that <span class="rlang"><b>R</b></span> correctly handles UTF-8 strings regardless of your
platform's native encoding (see below). Therefore, we decided that most
functions in <span class="pkg">stringi</span> will output its results in UTF-8
&ndash; this speeds ups computations on cascading calls to our functions:
the strings does not have to be re-encoded each time.
</p>
<p>Note that some Unicode characters may have an ambiguous representation.
For example, &ldquo;a with ogonek&rdquo; (one character) and &ldquo;a&rdquo;+&ldquo;ogonek&rdquo;
(two graphemes) are semantically the same. <span class="pkg">stringi</span> provides functions
to normalize character sequences, see <code><a href="#topic+stri_trans_nfc">stri_trans_nfc</a></code>
for discussion. However, it is observed that denormalized strings
do appear very rarely in typical string processing activities.
</p>
<p>Additionally, do note that <span class="pkg">stringi</span> silently removes byte order marks
(BOMs - they may incidentally appear in a string read from a text file)
from UTF8-encoded strings, see <code><a href="#topic+stri_enc_toutf8">stri_enc_toutf8</a></code>.
</p>


<h3>Character Encodings in <span class="rlang"><b>R</b></span></h3>

<p>Data in memory are just bytes (small integer
values) &ndash; an en<em>coding</em> is a way to represent characters with such
numbers, it is a semantic 'key' to understand a given byte sequence.
For example, in ISO-8859-2 (Central European), the value 177 represents
Polish &ldquo;a with ogonek&rdquo;, and in ISO-8859-1 (Western European),
the same value denotes the &ldquo;plus-minus&rdquo; sign. Thus, a character encoding
is a translation scheme: we need to communicate with <span class="rlang"><b>R</b></span> somehow,
relying on how it represents strings.
</p>
<p>Overall, <span class="rlang"><b>R</b></span> has a very simple encoding marking mechanism,
see <code><a href="#topic+stri_enc_mark">stri_enc_mark</a></code>. There is an implicit assumption
that your platform's default (native) encoding always extends
ASCII &ndash; <span class="pkg">stringi</span> checks that whenever your native encoding
is being detected automatically on <span class="pkg">ICU</span>'s initialization and each time
when you change it manually by calling <code><a href="#topic+stri_enc_set">stri_enc_set</a></code>.
</p>
<p>Character strings in <span class="rlang"><b>R</b></span> (internally) can be declared to be in:
</p>

<ul>
<li> <p><code>UTF-8</code>;
</p>
</li>
<li> <p><code>latin1</code>, i.e., either ISO-8859-1 (Western European on
Linux, OS X, and other Unixes) or WINDOWS-1252 (Windows);
</p>
</li>
<li> <p><code>bytes</code> &ndash; for strings that
should be manipulated as sequences of bytes.
</p>
</li></ul>

<p>Moreover, there are two other cases:
</p>

<ul>
<li><p> ASCII &ndash; for strings consisting only of byte codes
not greater than 127;
</p>
</li>
<li> <p><code>native</code> (a.k.a. <code>unknown</code> in <code><a href="base.html#topic+Encoding">Encoding</a></code>;
quite a misleading name: no explicit encoding mark) &ndash; for
strings that are assumed to be in your platform's native (default) encoding.
This can represent UTF-8 if you are an OS X user,
or some 8-bit Windows code page, for example.
The native encoding used by <span class="rlang"><b>R</b></span> may be determined by examining
the LC_CTYPE category, see <code><a href="base.html#topic+Sys.getlocale">Sys.getlocale</a></code>.
</p>
</li></ul>

<p>Intuitively, &ldquo;native&rdquo; strings result from reading
a string from stdin (e.g., keyboard input). This makes sense: your operating
system works in some encoding and provides <span class="rlang"><b>R</b></span> with some data.
</p>
<p>Each time when a <span class="pkg">stringi</span> function encounters a string declared
in native encoding, it assumes that the input data should be translated
from the default encoding, i.e., the one returned by <code><a href="#topic+stri_enc_get">stri_enc_get</a></code>
(unless you know what you are doing, the default encoding should only be
changed if the automatic encoding detection process fails on <span class="pkg">stringi</span>
load).
</p>
<p>Functions which allow <code>'bytes'</code> encoding markings are very rare in
<span class="pkg">stringi</span>, and were carefully selected. These are:
<code><a href="#topic+stri_enc_toutf8">stri_enc_toutf8</a></code> (with argument <code>is_unknown_8bit=TRUE</code>),
<code><a href="#topic+stri_enc_toascii">stri_enc_toascii</a></code>, and <code><a href="#topic+stri_encode">stri_encode</a></code>.
</p>
<p>Finally, note that <span class="rlang"><b>R</b></span> lets strings in ASCII, UTF-8, and your platform's
native encoding coexist. A character vector printed with
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+cat">cat</a></code>, etc., is silently re-encoded
so that it can be properly shown, e.g., on the console.
</p>


<h3>Encoding Conversion</h3>

<p>Apart from automatic conversion from the native encoding,
you may re-encode a string manually, for example
when you read it from a file created on a different platform.
Call <code><a href="#topic+stri_enc_list">stri_enc_list</a></code> for the list of
encodings supported by <span class="pkg">ICU</span>.
Note that converter names are case-insensitive
and <span class="pkg">ICU</span> tries to normalize the encoding specifiers.
Leading zeroes are ignored in sequences of digits (if further digits follow),
and all non-alphanumeric characters are ignored. Thus the strings
'UTF-8', 'utf_8', 'u*Tf08' and 'Utf 8' are equivalent.
</p>
<p>The <code><a href="#topic+stri_encode">stri_encode</a></code> function
allows you to convert between any given encodings
(in some cases you will obtain <code>bytes</code>-marked
strings, or even lists of raw vectors (i.e., for UTF-16).
There are also some useful more specialized functions,
like <code><a href="#topic+stri_enc_toutf32">stri_enc_toutf32</a></code> (converts a character vector to a list
of integers, where one code point is exactly one numeric value)
or <code><a href="#topic+stri_enc_toascii">stri_enc_toascii</a></code> (substitutes all non-ASCII
bytes with the SUBSTITUTE CHARACTER,
which plays a similar role as <span class="rlang"><b>R</b></span>'s <code>NA</code> value).
</p>
<p>There are also some routines for automated encoding detection,
see, e.g., <code><a href="#topic+stri_enc_detect">stri_enc_detect</a></code>.
</p>


<h3>Encoding Detection</h3>

<p>Given a text file, one has to know how to interpret (encode)
raw data in order to obtain meaningful information.
</p>
<p>Encoding detection is always an imprecise operation and
needs a considerable amount of data. However, in case of some
encodings (like UTF-8, ASCII, or UTF-32) a &ldquo;false positive&rdquo; byte
sequence is quite rare (statistically speaking).
</p>
<p>Check out <code><a href="#topic+stri_enc_detect">stri_enc_detect</a></code> (among others) for a useful
function in this category.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Unicode Basics</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/icu/unicode.html">https://unicode-org.github.io/icu/userguide/icu/unicode.html</a>
</p>
<p><em>Conversion</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/conversion/">https://unicode-org.github.io/icu/userguide/conversion/</a>
</p>
<p><em>Converters</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/conversion/converters.html">https://unicode-org.github.io/icu/userguide/conversion/converters.html</a>
(technical details)
</p>
<p><em>UTF-8, UTF-16, UTF-32 &amp; BOM</em> &ndash; ICU FAQ,
<a href="https://www.unicode.org/faq/utf_bom.html">https://www.unicode.org/faq/utf_bom.html</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other stringi_general_topics: 
<code><a href="#topic+about_arguments">about_arguments</a></code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_charclass">about_search_charclass</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+about_search_fixed">about_search_fixed</a></code>,
<code><a href="#topic+about_search_regex">about_search_regex</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+about_stringi">about_stringi</a></code>
</p>
<p>Other encoding_management: 
<code><a href="#topic+stri_enc_info">stri_enc_info</a>()</code>,
<code><a href="#topic+stri_enc_list">stri_enc_list</a>()</code>,
<code><a href="#topic+stri_enc_mark">stri_enc_mark</a>()</code>,
<code><a href="#topic+stri_enc_set">stri_enc_set</a>()</code>
</p>
<p>Other encoding_detection: 
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_enc_detect">stri_enc_detect</a>()</code>,
<code><a href="#topic+stri_enc_isascii">stri_enc_isascii</a>()</code>,
<code><a href="#topic+stri_enc_isutf16be">stri_enc_isutf16be</a>()</code>,
<code><a href="#topic+stri_enc_isutf8">stri_enc_isutf8</a>()</code>
</p>
<p>Other encoding_conversion: 
<code><a href="#topic+stri_enc_fromutf32">stri_enc_fromutf32</a>()</code>,
<code><a href="#topic+stri_enc_toascii">stri_enc_toascii</a>()</code>,
<code><a href="#topic+stri_enc_tonative">stri_enc_tonative</a>()</code>,
<code><a href="#topic+stri_enc_toutf32">stri_enc_toutf32</a>()</code>,
<code><a href="#topic+stri_enc_toutf8">stri_enc_toutf8</a>()</code>,
<code><a href="#topic+stri_encode">stri_encode</a>()</code>
</p>

<hr>
<h2 id='about_locale'>Locales and <span class="pkg">stringi</span></h2><span id='topic+about_locale'></span><span id='topic+locale'></span><span id='topic+stringi-locale'></span>

<h3>Description</h3>

<p>In this section we explain how we specify locales in <span class="pkg">stringi</span>.
Locale is a fundamental concept in <span class="pkg">ICU</span>.
It identifies a specific user community, i.e., a group of users
who have similar culture and language expectations
for human-computer interaction.
</p>


<h3>Details</h3>

<p>Because a locale is just an identifier of a region,
no validity check is performed when you specify a Locale.
<span class="pkg">ICU</span> is implemented as a set of services.
If you want to verify whether particular resources are available
in the locale you asked for, you must query those resources.
Note: when you ask for a resource for a particular locale, you get back
the best available match, not necessarily precisely the one you requested.
</p>


<h3>Locale Identifiers</h3>

<p><span class="pkg">ICU</span> services are parametrized by locale,
to deliver culturally correct results.
Locales are identified by character strings
of the form <code>Language</code> code,
<code>Language_Country</code> code, or <code>Language_Country_Variant</code>
code, e.g., 'en_US'.
</p>
<p>The two-letter <code>Language</code> code uses the ISO-639-1 standard,
e.g., 'en' stands for English, 'pl' &ndash; Polish, 'fr' &ndash; French,
and 'de' for German.
</p>
<p><code>Country</code> is a two-letter code following the ISO-3166 standard.
This is to reflect different language conventions within the same language,
for example in US-English ('en_US') and Australian-English ('en_AU').
</p>
<p>Differences may also appear in language conventions used within
the same country. For example, the Euro currency may be used in several European
countries while the individual country's currency is still in circulation.
In such a case, <span class="pkg">ICU</span> <code>Variant</code> '_EURO' could be used for selecting
locales that support the Euro currency.
</p>
<p>The final (optional) element of a locale is a list of
keywords together with their values. Keywords must be unique.
Their order is not significant. Unknown keywords are ignored.
The handling of keywords depends on the specific services that
utilize them. Currently, the following keywords are recognized:
<code>calendar</code>, <code>collation</code>, <code>currency</code>, and <code>numbers</code>,
e.g., <code>fr@collation=phonebook;</code><code>calendar=islamic-civil</code> is a valid
French locale specifier together with keyword arguments. For
more information, refer to the ICU user guide.
</p>
<p>For a list of locales that are recognized by <span class="pkg">ICU</span>,
call <code><a href="#topic+stri_locale_list">stri_locale_list</a></code>.
</p>
<p>Note that in <span class="pkg">stringi</span>, 'C' is a synonym of 'en_US_POSIX'.
</p>


<h3>A Note on Default Locales</h3>

<p>Each locale-sensitive function in <span class="pkg">stringi</span>
selects the current default locale if an empty string or <code>NULL</code>
is provided as its <code>locale</code> argument. Default locales are available
to all the functions; initially, the system locale on that platform is used,
but it may be changed by calling <code><a href="#topic+stri_locale_set">stri_locale_set</a></code>.
</p>
<p>Your program should avoid changing the default locale.
All locale-sensitive functions may request
any desired locale per-call (by specifying the <code>locale</code> argument),
i.e., without referencing to the default locale.
During many tests, however, we did not observe any improper
behavior of <span class="pkg">stringi</span> while using a modified default locale.
</p>


<h3>Locale-Sensitive Functions in <span class="pkg">stringi</span></h3>

<p>One of many examples of locale-dependent services is the Collator, which
performs a locale-aware string comparison. It is used for string comparing,
ordering, sorting, and searching. See <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>
for the description on how to tune its settings, and its <code>locale</code>
argument in particular.
</p>
<p>When choosing a resource bundle that is not available in the explicitly
requested locale (but not when using the default locale)
nor in its more general variants (e.g., 'es_ES' vs 'es'),
a warning is emitted.
</p>
<p>Other locale-sensitive functions include, e.g.,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a></code> (that does character case mapping).
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Locale</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/locale/">https://unicode-org.github.io/icu/userguide/locale/</a>
</p>
<p><em>ISO 639: Language Codes</em>,
<a href="https://www.iso.org/iso-639-language-codes.html">https://www.iso.org/iso-639-language-codes.html</a>
</p>
<p><em>ISO 3166: Country Codes</em>,
<a href="https://www.iso.org/iso-3166-country-codes.html">https://www.iso.org/iso-3166-country-codes.html</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_management: 
<code><a href="#topic+stri_locale_info">stri_locale_info</a>()</code>,
<code><a href="#topic+stri_locale_list">stri_locale_list</a>()</code>,
<code><a href="#topic+stri_locale_set">stri_locale_set</a>()</code>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>
<p>Other stringi_general_topics: 
<code><a href="#topic+about_arguments">about_arguments</a></code>,
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_charclass">about_search_charclass</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+about_search_fixed">about_search_fixed</a></code>,
<code><a href="#topic+about_search_regex">about_search_regex</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+about_stringi">about_stringi</a></code>
</p>

<hr>
<h2 id='about_search'>String Searching</h2><span id='topic+about_search'></span><span id='topic+search'></span><span id='topic+stringi-search'></span>

<h3>Description</h3>

<p>This man page explains how to perform string search-based
operations in <span class="pkg">stringi</span>.
</p>


<h3>Details</h3>

<p>The following independent string searching engines are available
in <span class="pkg">stringi</span>.
</p>

<ul>
<li> <p><code>stri_*_regex</code> &ndash; <span class="pkg">ICU</span>'s regular expressions (regexes),
see <a href="#topic+about_search_regex">about_search_regex</a>,
</p>
</li>
<li> <p><code>stri_*_fixed</code> &ndash; locale-independent byte-wise pattern matching,
see <a href="#topic+about_search_fixed">about_search_fixed</a>,
</p>
</li>
<li> <p><code>stri_*_coll</code> &ndash; <span class="pkg">ICU</span>'s <code>StringSearch</code>,
locale-sensitive, Collator-based pattern search,
useful for natural language processing tasks,
see <a href="#topic+about_search_coll">about_search_coll</a>,
</p>
</li>
<li> <p><code>stri_*_charclass</code> &ndash; character classes search,
e.g., Unicode General Categories or Binary Properties,
see <a href="#topic+about_search_charclass">about_search_charclass</a>,
</p>
</li>
<li> <p><code>stri_*_boundaries</code> &ndash; text boundary analysis,
see <a href="#topic+about_search_boundaries">about_search_boundaries</a>
</p>
</li></ul>

<p>Each search engine is able to perform many search-based operations.
These may include:
</p>

<ul>
<li> <p><code>stri_detect_*</code> - detect if a pattern occurs in a string,
see, e.g., <code><a href="#topic+stri_detect">stri_detect</a></code>,
</p>
</li>
<li> <p><code>stri_count_*</code> - count the number of pattern occurrences,
see, e.g., <code><a href="#topic+stri_count">stri_count</a></code>,
</p>
</li>
<li> <p><code>stri_locate_*</code> - locate all, first, or last occurrences
of a pattern, see, e.g., <code><a href="#topic+stri_locate">stri_locate</a></code>,
</p>
</li>
<li> <p><code>stri_extract_*</code> - extract all, first, or last occurrences
of a pattern, see, e.g., <code><a href="#topic+stri_extract">stri_extract</a></code>
and, in case of regexes, <code><a href="#topic+stri_match">stri_match</a></code>,
</p>
</li>
<li> <p><code>stri_replace_*</code> - replace all, first, or last occurrences
of a pattern, see, e.g., <code><a href="#topic+stri_replace">stri_replace</a></code>
and also <code><a href="#topic+stri_trim">stri_trim</a></code>,
</p>
</li>
<li> <p><code>stri_split_*</code> - split a string into chunks indicated
by occurrences of a pattern,
see, e.g., <code><a href="#topic+stri_split">stri_split</a></code>,
</p>
</li>
<li> <p><code>stri_startswith_*</code> and <code>stri_endswith_*</code> detect
if a string starts or ends with a pattern match, see,
e.g., <code><a href="#topic+stri_startswith">stri_startswith</a></code>,
</p>
</li>
<li> <p><code>stri_subset_*</code> - return a subset of a character vector
with strings that match a given pattern, see, e.g., <code><a href="#topic+stri_subset">stri_subset</a></code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other text_boundaries: 
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_split_lines">stri_split_lines</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>
<p>Other search_regex: 
<code><a href="#topic+about_search_regex">about_search_regex</a></code>,
<code><a href="#topic+stri_opts_regex">stri_opts_regex</a>()</code>
</p>
<p>Other search_fixed: 
<code><a href="#topic+about_search_fixed">about_search_fixed</a></code>,
<code><a href="#topic+stri_opts_fixed">stri_opts_fixed</a>()</code>
</p>
<p>Other search_coll: 
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>
</p>
<p>Other search_charclass: 
<code><a href="#topic+about_search_charclass">about_search_charclass</a></code>,
<code><a href="#topic+stri_trim_both">stri_trim_both</a>()</code>
</p>
<p>Other search_detect: 
<code><a href="#topic+stri_detect">stri_detect</a>()</code>,
<code><a href="#topic+stri_startswith">stri_startswith</a>()</code>
</p>
<p>Other search_count: 
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_count">stri_count</a>()</code>
</p>
<p>Other search_locate: 
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all">stri_locate_all</a>()</code>
</p>
<p>Other search_replace: 
<code><a href="#topic+stri_replace_all">stri_replace_all</a>()</code>,
<code><a href="#topic+stri_replace_rstr">stri_replace_rstr</a>()</code>,
<code><a href="#topic+stri_trim_both">stri_trim_both</a>()</code>
</p>
<p>Other search_split: 
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_split_lines">stri_split_lines</a>()</code>,
<code><a href="#topic+stri_split">stri_split</a>()</code>
</p>
<p>Other search_subset: 
<code><a href="#topic+stri_subset">stri_subset</a>()</code>
</p>
<p>Other search_extract: 
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_extract_all">stri_extract_all</a>()</code>,
<code><a href="#topic+stri_match_all">stri_match_all</a>()</code>
</p>
<p>Other stringi_general_topics: 
<code><a href="#topic+about_arguments">about_arguments</a></code>,
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_charclass">about_search_charclass</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+about_search_fixed">about_search_fixed</a></code>,
<code><a href="#topic+about_search_regex">about_search_regex</a></code>,
<code><a href="#topic+about_stringi">about_stringi</a></code>
</p>

<hr>
<h2 id='about_search_boundaries'>Text Boundary Analysis in <span class="pkg">stringi</span></h2><span id='topic+about_search_boundaries'></span><span id='topic+search_boundaries'></span><span id='topic+stringi-search-boundaries'></span>

<h3>Description</h3>

<p>Text boundary analysis is the process of locating linguistic boundaries
while formatting and handling text.
</p>


<h3>Details</h3>

<p>Examples of the boundary analysis process include:
</p>

<ul>
<li><p> Locating positions to word-wrap text to fit
within specific margins while displaying or printing,
see <code><a href="#topic+stri_wrap">stri_wrap</a></code> and <code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a></code>.
</p>
</li>
<li><p> Counting characters, words, sentences, or paragraphs,
see <code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a></code>.
</p>
</li>
<li><p> Making a list of the unique words in a document,
see <code><a href="#topic+stri_extract_all_words">stri_extract_all_words</a></code> and then <code><a href="#topic+stri_unique">stri_unique</a></code>.
</p>
</li>
<li><p> Capitalizing the first letter of each word
or sentence, see also <code><a href="#topic+stri_trans_totitle">stri_trans_totitle</a></code>.
</p>
</li>
<li><p> Locating a particular unit of the text (for example,
finding the third word in the document),
see <code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a></code>.
</p>
</li></ul>

<p>Generally, text boundary analysis is a locale-dependent operation.
For example, in Japanese and Chinese one does not separate words with spaces
- a line break can occur even in the middle of a word.
These languages have punctuation and diacritical
marks that cannot start or end a line, so this must also be taken into account.
</p>
<p><span class="pkg">stringi</span> uses <span class="pkg">ICU</span>'s <code>BreakIterator</code> to locate specific
text boundaries. Note that the <code>BreakIterator</code>'s behavior
may be controlled in come cases, see <code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a></code>.
</p>

<ul>
<li><p> The <code>character</code> boundary iterator tries to match what a user
would think of as a &ldquo;character&rdquo;  &ndash; a basic unit of a writing system
for a language &ndash; which may be more than just a single Unicode code point.
</p>
</li>
<li><p> The <code>word</code> boundary iterator locates the boundaries
of words, for purposes such as &ldquo;Find whole words&rdquo; operations.
</p>
</li>
<li><p> The <code>line_break</code> iterator locates positions that would
be appropriate to wrap lines when displaying the text.
</p>
</li>
<li><p> The break iterator of type <code>sentence</code>
locates sentence boundaries.
</p>
</li></ul>

<p>For technical details on different classes of text boundaries refer
to the <span class="pkg">ICU</span> User Guide, see below.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Boundary Analysis</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/boundaryanalysis/">https://unicode-org.github.io/icu/userguide/boundaryanalysis/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>
<p>Other text_boundaries: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_split_lines">stri_split_lines</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>
<p>Other stringi_general_topics: 
<code><a href="#topic+about_arguments">about_arguments</a></code>,
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_charclass">about_search_charclass</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+about_search_fixed">about_search_fixed</a></code>,
<code><a href="#topic+about_search_regex">about_search_regex</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+about_stringi">about_stringi</a></code>
</p>

<hr>
<h2 id='about_search_charclass'>Character Classes in <span class="pkg">stringi</span></h2><span id='topic+about_search_charclass'></span><span id='topic+search_charclass'></span><span id='topic+stringi-search-charclass'></span>

<h3>Description</h3>

<p>Here we describe how character classes (sets) can be specified
in the <span class="pkg">stringi</span> package. These are useful for defining
search patterns (note that the <span class="pkg">ICU</span> regex engine uses the same
scheme for denoting character classes) or, e.g.,
generating random code points with <code><a href="#topic+stri_rand_strings">stri_rand_strings</a></code>.
</p>


<h3>Details</h3>

<p>All <code>stri_*_charclass</code> functions in <span class="pkg">stringi</span> perform
a single character (i.e., Unicode code point) search-based operations.
You may obtain the same results using <a href="#topic+about_search_regex">about_search_regex</a>.
However, these very functions aim to be faster.
</p>
<p>Character classes are defined using <span class="pkg">ICU</span>'s <code>UnicodeSet</code>
patterns. Below we briefly summarize their syntax.
For more details refer to the bibliographic References below.
</p>


<h3><code>UnicodeSet</code> patterns</h3>

<p>A <code>UnicodeSet</code> represents a subset of Unicode code points
(recall that <span class="pkg">stringi</span> converts strings in your native encoding
to Unicode automatically). Legal code points are U+0000 to U+10FFFF,
inclusive.
</p>
<p>Patterns either consist of series of characters  bounded by
square brackets
(such patterns follow a syntax similar to that employed
by regular expression character classes)
or of Perl-like Unicode property set specifiers.
</p>
<p><code>[]</code> denotes an empty set, <code>[a]</code> &ndash;
a set consisting of character &ldquo;a&rdquo;,
<code>[\u0105]</code> &ndash; a set with character U+0105,
and <code>[abc]</code> &ndash; a set with &ldquo;a&rdquo;, &ldquo;b&rdquo;, and &ldquo;c&rdquo;.
</p>
<p><code>[a-z]</code> denotes a set consisting of characters
&ldquo;a&rdquo; through &ldquo;z&rdquo; inclusively, in Unicode code point order.
</p>
<p>Some set-theoretic operations are available.
<code>^</code> denotes the complement, e.g., <code>[^a-z]</code> contains
all characters but &ldquo;a&rdquo; through &ldquo;z&rdquo;.
Moreover, <code>[[pat1][pat2]]</code>,
<code>[[pat1]\&amp;[pat2]]</code>, and <code>[[pat1]-[pat2]]</code>
denote union, intersection, and asymmetric difference of sets
specified by <code>pat1</code> and <code>pat2</code>, respectively.
</p>
<p>Note that all white-spaces are ignored unless they are quoted or back-slashed
(white spaces can be freely used for clarity, as <code>[a c d-f m]</code>
means the same as <code>[acd-fm]</code>).
<span class="pkg">stringi</span> does not allow including multi-character strings
(see <code>UnicodeSet</code> API documentation).
Also, empty string patterns are disallowed.
</p>
<p>Any character may be preceded by
a backslash in order to remove its special meaning.
</p>
<p>A malformed pattern always results in an error.
</p>
<p>Set expressions at a glance
(according to <a href="https://unicode-org.github.io/icu/userguide/strings/regexp.html">https://unicode-org.github.io/icu/userguide/strings/regexp.html</a>):
</p>
<p>Some examples:
</p>

<dl>
<dt><code>[abc]</code></dt><dd><p>Match any of the characters a, b or c.</p>
</dd>
<dt><code>[^abc]</code></dt><dd><p>Negation &ndash; match any character except a, b or c.</p>
</dd>
<dt><code>[A-M]</code></dt><dd><p>Range &ndash; match any character from A to M. The characters
to include are determined by Unicode code point ordering.</p>
</dd>
<dt><code>[\u0000-\U0010ffff]</code></dt><dd><p>Range &ndash; match all characters.</p>
</dd>
<dt><code>[\p{Letter}]</code> or <code>[\p{General_Category=Letter}]</code> or <code>[\p{L}]</code></dt><dd>
<p>Characters with Unicode Category = Letter. All forms shown are equivalent.</p>
</dd>
<dt><code>[\P{Letter}]</code></dt><dd><p>Negated property
(Note the upper case <code>\P</code>) &ndash; match everything except Letters.</p>
</dd>
<dt><code>[\p{numeric_value=9}]</code></dt><dd><p>Match all numbers with a numeric value of 9.
Any Unicode Property may be used in set expressions.</p>
</dd>
<dt><code>[\p{Letter}&amp;\p{script=cyrillic}]</code></dt><dd><p>Set
intersection &ndash; match the set of all Cyrillic letters.</p>
</dd>
<dt><code>[\p{Letter}-\p{script=latin}]</code></dt><dd><p>Set difference &ndash;
match all non-Latin letters.</p>
</dd>
<dt><code>[[a-z][A-Z][0-9]]</code> or <code>[a-zA-Z0-9]</code></dt><dd><p>Implicit union of
sets &ndash; match ASCII letters and digits (the two forms are equivalent).</p>
</dd>
<dt><code>[:script=Greek:]</code></dt><dd><p>Alternative POSIX-like syntax for properties &ndash;
equivalent to <code>\p{script=Greek}</code>.</p>
</dd>
</dl>



<h3>Unicode properties</h3>

<p>Unicode property sets are specified with a POSIX-like syntax,
e.g., <code>[:Letter:]</code>,
or with a (extended) Perl-style syntax, e.g., <code>\p{L}</code>.
The complements of the above sets are
<code>[:^Letter:]</code> and <code>\P{L}</code>, respectively.
</p>
<p>The names are normalized before matching
(for example, the match is case-insensitive).
Moreover, many names have short aliases.
</p>
<p>Among predefined Unicode properties we find, e.g.:
</p>

<ul>
<li><p> Unicode General Categories, e.g., <code>Lu</code> for uppercase letters,
</p>
</li>
<li><p> Unicode Binary Properties, e.g., <code>WHITE_SPACE</code>,
</p>
</li></ul>

<p>and many more (including Unicode scripts).
</p>
<p>Each property provides access to the large and comprehensive
Unicode Character Database.
Generally, the list of properties available in <span class="pkg">ICU</span>
is not well-documented. Please refer to the References section
for some links.
</p>
<p>Please note that some classes might overlap.
However, e.g., General Category <code>Z</code> (some space) and Binary Property
<code>WHITE_SPACE</code> matches different character sets.
</p>


<h3>Unicode General Categories</h3>

<p>The Unicode General Category property of a code point provides the most
general classification of that code point.
Each code point falls into one and only one Category.
</p>

<dl>
<dt><code>Cc</code></dt><dd><p>a C0 or C1 control code.</p>
</dd>
<dt><code>Cf</code></dt><dd><p>a format control character.</p>
</dd>
<dt><code>Cn</code></dt><dd><p>a reserved unassigned code point or a non-character.</p>
</dd>
<dt><code>Co</code></dt><dd><p>a private-use character.</p>
</dd>
<dt><code>Cs</code></dt><dd><p>a surrogate code point.</p>
</dd>
<dt><code>Lc</code></dt><dd><p>the union of Lu, Ll, Lt.</p>
</dd>
<dt><code>Ll</code></dt><dd><p>a lowercase letter.</p>
</dd>
<dt><code>Lm</code></dt><dd><p>a modifier letter.</p>
</dd>
<dt><code>Lo</code></dt><dd><p>other letters, including syllables and ideographs.</p>
</dd>
<dt><code>Lt</code></dt><dd><p>a digraphic character, with the first part uppercase.</p>
</dd>
<dt><code>Lu</code></dt><dd><p>an uppercase letter.</p>
</dd>
<dt><code>Mc</code></dt><dd><p>a spacing combining mark (positive advance width).</p>
</dd>
<dt><code>Me</code></dt><dd><p>an enclosing combining mark.</p>
</dd>
<dt><code>Mn</code></dt><dd><p>a non-spacing combining mark (zero advance width).</p>
</dd>
<dt><code>Nd</code></dt><dd><p>a decimal digit.</p>
</dd>
<dt><code>Nl</code></dt><dd><p>a letter-like numeric character.</p>
</dd>
<dt><code>No</code></dt><dd><p>a numeric character of other type.</p>
</dd>
<dt><code>Pd</code></dt><dd><p>a dash or hyphen punctuation mark.</p>
</dd>
<dt><code>Ps</code></dt><dd><p>an opening punctuation mark (of a pair).</p>
</dd>
<dt><code>Pe</code></dt><dd><p>a closing punctuation mark (of a pair).</p>
</dd>
<dt><code>Pc</code></dt><dd><p>a connecting punctuation mark, like a tie.</p>
</dd>
<dt><code>Po</code></dt><dd><p>a punctuation mark of other type.</p>
</dd>
<dt><code>Pi</code></dt><dd><p>an initial quotation mark.</p>
</dd>
<dt><code>Pf</code></dt><dd><p>a final quotation mark.</p>
</dd>
<dt><code>Sm</code></dt><dd><p>a symbol of mathematical use.</p>
</dd>
<dt><code>Sc</code></dt><dd><p>a currency sign.</p>
</dd>
<dt><code>Sk</code></dt><dd><p>a non-letter-like modifier symbol.</p>
</dd>
<dt><code>So</code></dt><dd><p>a symbol of other type.</p>
</dd>
<dt><code>Zs</code></dt><dd><p>a space character (of non-zero width).</p>
</dd>
<dt><code>Zl</code></dt><dd><p>U+2028 LINE SEPARATOR only.</p>
</dd>
<dt><code>Zp</code></dt><dd><p>U+2029 PARAGRAPH SEPARATOR only.</p>
</dd>
<dt><code>C</code> </dt><dd><p>the union of Cc, Cf, Cs, Co, Cn.</p>
</dd>
<dt><code>L</code> </dt><dd><p>the union of Lu, Ll, Lt, Lm, Lo.</p>
</dd>
<dt><code>M</code> </dt><dd><p>the union of Mn, Mc, Me.</p>
</dd>
<dt><code>N</code> </dt><dd><p>the union of Nd, Nl, No.</p>
</dd>
<dt><code>P</code> </dt><dd><p>the union of Pc, Pd, Ps, Pe, Pi, Pf, Po.</p>
</dd>
<dt><code>S</code> </dt><dd><p>the union of Sm, Sc, Sk, So.</p>
</dd>
<dt><code>Z</code> </dt><dd><p>the union of Zs, Zl, Zp </p>
</dd>
</dl>



<h3>Unicode Binary Properties</h3>

<p>Each character may follow many Binary Properties at a time.
</p>
<p>Here is a comprehensive list of supported Binary Properties:
</p>

<dl>
<dt><code>ALPHABETIC</code>     </dt><dd><p>alphabetic character.</p>
</dd>
<dt><code>ASCII_HEX_DIGIT</code></dt><dd><p>a character matching the <code>[0-9A-Fa-f]</code> charclass.</p>
</dd>
<dt><code>BIDI_CONTROL</code>   </dt><dd><p>a format control which have specific functions
in the Bidi (bidirectional text) Algorithm.</p>
</dd>
<dt><code>BIDI_MIRRORED</code>  </dt><dd><p>a character that may change display in right-to-left text.</p>
</dd>
<dt><code>DASH</code>           </dt><dd><p>a kind of a dash character.</p>
</dd>
<dt><code>DEFAULT_IGNORABLE_CODE_POINT</code></dt><dd><p>characters that are ignorable in most
text processing activities,
e.g., &lt;2060..206F, FFF0..FFFB, E0000..E0FFF&gt;.</p>
</dd>
<dt><code>DEPRECATED</code>     </dt><dd><p>a deprecated character according
to the current Unicode standard (the usage of deprecated characters
is strongly discouraged).</p>
</dd>
<dt><code>DIACRITIC</code>      </dt><dd><p>a character that linguistically modifies
the meaning of another character to which it applies.</p>
</dd>
<dt><code>EXTENDER</code>       </dt><dd><p>a character that extends the value
or shape of a preceding alphabetic character,
e.g., a length and iteration mark.</p>
</dd>
<dt><code>HEX_DIGIT</code>      </dt><dd><p>a character commonly
used for hexadecimal numbers,
see also <code>ASCII_HEX_DIGIT</code>.</p>
</dd>
<dt><code>HYPHEN</code></dt><dd><p>a dash used to mark connections between
pieces of words, plus the Katakana middle dot.</p>
</dd>
<dt><code>ID_CONTINUE</code></dt><dd><p>a character that can continue an identifier,
<code>ID_START</code>+<code>Mn</code>+<code>Mc</code>+<code>Nd</code>+<code>Pc</code>.</p>
</dd>
<dt><code>ID_START</code></dt><dd><p>a character that can start an identifier,
<code>Lu</code>+<code>Ll</code>+<code>Lt</code>+<code>Lm</code>+<code>Lo</code>+<code>Nl</code>.</p>
</dd>
<dt><code>IDEOGRAPHIC</code></dt><dd><p>a CJKV (Chinese-Japanese-Korean-Vietnamese)
ideograph.</p>
</dd>
<dt><code>LOWERCASE</code></dt><dd><p>...</p>
</dd>
<dt><code>MATH</code></dt><dd><p>...</p>
</dd>
<dt><code>NONCHARACTER_CODE_POINT</code></dt><dd><p>...</p>
</dd>
<dt><code>QUOTATION_MARK</code></dt><dd><p>...</p>
</dd>
<dt><code>SOFT_DOTTED</code></dt><dd><p>a character with a &ldquo;soft dot&rdquo;, like i or j,
such that an accent placed on this character causes the dot to disappear.</p>
</dd>
<dt><code>TERMINAL_PUNCTUATION</code></dt><dd><p>a punctuation character that generally
marks the end of textual units.</p>
</dd>
<dt><code>UPPERCASE</code></dt><dd><p>...</p>
</dd>
<dt><code>WHITE_SPACE</code></dt><dd><p>a space character or TAB or CR or LF or ZWSP or ZWNBSP.</p>
</dd>
<dt><code>CASE_SENSITIVE</code></dt><dd><p>...</p>
</dd>
<dt><code>POSIX_ALNUM</code></dt><dd><p>...</p>
</dd>
<dt><code>POSIX_BLANK</code></dt><dd><p>...</p>
</dd>
<dt><code>POSIX_GRAPH</code></dt><dd><p>...</p>
</dd>
<dt><code>POSIX_PRINT</code></dt><dd><p>...</p>
</dd>
<dt><code>POSIX_XDIGIT</code></dt><dd><p>...</p>
</dd>
<dt><code>CASED</code></dt><dd><p>...</p>
</dd>
<dt><code>CASE_IGNORABLE</code></dt><dd><p>...</p>
</dd>
<dt><code>CHANGES_WHEN_LOWERCASED</code></dt><dd><p>...</p>
</dd>
<dt><code>CHANGES_WHEN_UPPERCASED</code></dt><dd><p>...</p>
</dd>
<dt><code>CHANGES_WHEN_TITLECASED</code></dt><dd><p>...</p>
</dd>
<dt><code>CHANGES_WHEN_CASEFOLDED</code></dt><dd><p>...</p>
</dd>
<dt><code>CHANGES_WHEN_CASEMAPPED</code></dt><dd><p>...</p>
</dd>
<dt><code>CHANGES_WHEN_NFKC_CASEFOLDED</code></dt><dd><p>...</p>
</dd>
<dt><code>EMOJI</code></dt><dd><p>Since ICU 57</p>
</dd>
<dt><code>EMOJI_PRESENTATION</code></dt><dd><p>Since ICU 57</p>
</dd>
<dt><code>EMOJI_MODIFIER</code></dt><dd><p>Since ICU 57</p>
</dd>
<dt><code>EMOJI_MODIFIER_BASE</code></dt><dd><p>Since ICU 57</p>
</dd>
</dl>



<h3>POSIX Character Classes</h3>

<p>Avoid using POSIX character classes,
e.g., <code>[:punct:]</code>. The ICU User Guide (see below)
states that in general they are not well-defined, so you may end up
with something different than you expect.
</p>
<p>In particular, in POSIX-like regex engines, <code>[:punct:]</code> stands for
the character class corresponding to the <code>ispunct()</code> classification
function (check out <code>man 3 ispunct</code> on UNIX-like systems).
According to ISO/IEC 9899:1990 (ISO C90), the <code>ispunct()</code> function
tests for any printing character except for space or a character
for which <code>isalnum()</code> is true. However, in a POSIX setting,
the details of what characters belong into which class depend
on the current locale. So the <code>[:punct:]</code> class does not lead
to a portable code (again, in POSIX-like regex engines).
</p>
<p>Therefore, a POSIX flavor of <code>[:punct:]</code> is more like
<code>[\p{P}\p{S}]</code> in <span class="pkg">ICU</span>. You have been warned.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>The Unicode Character Database</em> &ndash; Unicode Standard Annex #44,
<a href="https://www.unicode.org/reports/tr44/">https://www.unicode.org/reports/tr44/</a>
</p>
<p><em>UnicodeSet</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/strings/unicodeset.html">https://unicode-org.github.io/icu/userguide/strings/unicodeset.html</a>
</p>
<p><em>Properties</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/strings/properties.html">https://unicode-org.github.io/icu/userguide/strings/properties.html</a>
</p>
<p><em>C/POSIX Migration</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/icu/posix.html">https://unicode-org.github.io/icu/userguide/icu/posix.html</a>
</p>
<p><em>Unicode Script Data</em>, <a href="https://www.unicode.org/Public/UNIDATA/Scripts.txt">https://www.unicode.org/Public/UNIDATA/Scripts.txt</a>
</p>
<p><em>icu::Unicodeset Class Reference</em> &ndash; ICU4C API Documentation,
<a href="https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1UnicodeSet.html">https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1UnicodeSet.html</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_charclass: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_trim_both">stri_trim_both</a>()</code>
</p>
<p>Other stringi_general_topics: 
<code><a href="#topic+about_arguments">about_arguments</a></code>,
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+about_search_fixed">about_search_fixed</a></code>,
<code><a href="#topic+about_search_regex">about_search_regex</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+about_stringi">about_stringi</a></code>
</p>

<hr>
<h2 id='about_search_coll'>Locale-Sensitive Text Searching in <span class="pkg">stringi</span></h2><span id='topic+about_search_coll'></span><span id='topic+search_coll'></span><span id='topic+stringi-search-coll'></span>

<h3>Description</h3>

<p>String searching facilities described here
provide a way to locate a specific piece of
text. Interestingly, locale-sensitive searching, especially
on a non-English text, is a much more complex process
than it seems at first glance.
</p>


<h3>Locale-Aware String Search Engine</h3>

<p>All <code>stri_*_coll</code> functions in <span class="pkg">stringi</span> use
<span class="pkg">ICU</span>'s <code>StringSearch</code> engine,
which implements a locale-sensitive string search algorithm.
The matches are defined by using the notion of &ldquo;canonical equivalence&rdquo;
between strings.
</p>
<p>Tuning the Collator's parameters allows you to perform correct matching
that properly takes into account accented letters, conjoined letters,
ignorable punctuation and letter case.
</p>
<p>For more information on <span class="pkg">ICU</span>'s Collator and the search engine
and how to tune it up
in <span class="pkg">stringi</span>, refer to <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>.
</p>
<p>Please note that <span class="pkg">ICU</span>'s <code>StringSearch</code>-based functions
are often much slower that those to perform fixed pattern searches.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>ICU String Search Service</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/collation/string-search.html">https://unicode-org.github.io/icu/userguide/collation/string-search.html</a>
</p>
<p>L. Werner, <em>Efficient Text Searching in Java</em>, 1999,
<a href="https://icu-project.org/docs/papers/efficient_text_searching_in_java.html">https://icu-project.org/docs/papers/efficient_text_searching_in_java.html</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_coll: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>
<p>Other stringi_general_topics: 
<code><a href="#topic+about_arguments">about_arguments</a></code>,
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_charclass">about_search_charclass</a></code>,
<code><a href="#topic+about_search_fixed">about_search_fixed</a></code>,
<code><a href="#topic+about_search_regex">about_search_regex</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+about_stringi">about_stringi</a></code>
</p>

<hr>
<h2 id='about_search_fixed'>Locale-Insensitive Fixed Pattern Matching in <span class="pkg">stringi</span></h2><span id='topic+about_search_fixed'></span><span id='topic+search_fixed'></span><span id='topic+stringi-search-fixed'></span>

<h3>Description</h3>

<p>String searching facilities described here
provide a way to locate a specific sequence of bytes in a string.
The search engine's settings may be tuned up (for example
to perform case-insensitive search) via a call to the
<code><a href="#topic+stri_opts_fixed">stri_opts_fixed</a></code> function.
</p>


<h3>Byte Compare</h3>

<p>The fast Knuth-Morris-Pratt search algorithm, with worst time complexity of
O(n+p) (<code>n == length(str)</code>, <code>p == length(pattern)</code>)
is implemented (with some tweaks for very short search patterns).
</p>
<p>Be aware that, for natural language processing,
fixed pattern searching might not be what
you actually require. It is because a bitwise match will
not give correct results in cases of:
</p>

<ol>
<li><p> accented letters;
</p>
</li>
<li><p> conjoined letters;
</p>
</li>
<li><p> ignorable punctuation;
</p>
</li>
<li><p> ignorable case,
</p>
</li></ol>

<p>see also <a href="#topic+about_search_coll">about_search_coll</a>.
</p>
<p>Note that the conversion of input data
to Unicode is done as usual.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_fixed: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_opts_fixed">stri_opts_fixed</a>()</code>
</p>
<p>Other stringi_general_topics: 
<code><a href="#topic+about_arguments">about_arguments</a></code>,
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_charclass">about_search_charclass</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+about_search_regex">about_search_regex</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+about_stringi">about_stringi</a></code>
</p>

<hr>
<h2 id='about_search_regex'>Regular Expressions in <span class="pkg">stringi</span></h2><span id='topic+about_search_regex'></span><span id='topic+search_regex'></span><span id='topic+stringi-search-regex'></span>

<h3>Description</h3>

<p>A regular expression is a pattern describing, possibly in a very
abstract way, a text fragment.
With so many regex functions in <span class="pkg">stringi</span>,
regular expressions may be a very powerful tool
to perform string searching, substring extraction, string splitting, etc.,
tasks.
</p>


<h3>Details</h3>

<p>All <code>stri_*_regex</code> functions in <span class="pkg">stringi</span> use
the <span class="pkg">ICU</span> regex engine. Its settings may be tuned up (for example
to perform case-insensitive search) via the
<code><a href="#topic+stri_opts_regex">stri_opts_regex</a></code> function.
</p>
<p>Regular expression patterns in <span class="pkg">ICU</span> are quite similar in form and
behavior to Perl's regexes. Their implementation is loosely inspired
by JDK 1.4 <code>java.util.regex</code>.
<span class="pkg">ICU</span> Regular Expressions conform to the Unicode Technical Standard #18
(see References section) and its features are summarized in
the ICU User Guide (see below). A good general introduction
to regexes is (Friedl, 2002).
Some general topics are also covered in the <span class="rlang"><b>R</b></span> manual, see <a href="base.html#topic+regex">regex</a>.
</p>


<h3><span class="pkg">ICU</span> Regex Operators at a Glance</h3>

<p>Here is a list of operators provided by the
ICU User Guide on regexes.
</p>

<dl>
<dt><code>|</code></dt><dd><p>Alternation. <code>A|B</code> matches either A or B.</p>
</dd>
<dt><code>*</code></dt><dd><p>Match 0 or more times. Match as many times as possible.</p>
</dd>
<dt><code>+</code></dt><dd><p>Match 1 or more times. Match as many times as possible.</p>
</dd>
<dt><code>?</code></dt><dd><p>Match zero or one times. Prefer one.</p>
</dd>
<dt><code>{n}</code> </dt><dd><p>Match exactly n times.</p>
</dd>
<dt><code>{n,}</code> </dt><dd><p>Match at least n times. Match as many times as possible.</p>
</dd>
<dt><code>{n,m}</code> </dt><dd><p>Match between n and m times.
Match as many times as possible, but not more than m.</p>
</dd>
<dt><code>*?</code></dt><dd><p>Match 0 or more times. Match as few times as possible.</p>
</dd>
<dt><code>+?</code></dt><dd><p>Match 1 or more times. Match as few times as possible.</p>
</dd>
<dt><code>??</code></dt><dd><p>Match zero or one times. Prefer zero.</p>
</dd>
<dt><code>{n}?</code></dt><dd><p>Match exactly n times.</p>
</dd>
<dt><code>{n,}?</code></dt><dd><p>Match at least n times, but no more than required
for an overall pattern match.</p>
</dd>
<dt><code>{n,m}?</code></dt><dd><p>Match between n and m times. Match as few times
as possible, but not less than n.</p>
</dd>
<dt><code>*+</code></dt><dd><p>Match 0 or more times. Match as many times as possible
when first encountered, do not retry with fewer even if overall match fails
(Possessive Match).</p>
</dd>
<dt><code>++</code></dt><dd><p>Match 1 or more times. Possessive match.</p>
</dd>
<dt><code>?+</code></dt><dd><p>Match zero or one times. Possessive match.</p>
</dd>
<dt><code>{n}+</code></dt><dd><p>Match exactly n times.</p>
</dd>
<dt><code>{n,}+</code></dt><dd><p>Match at least n times. Possessive Match.</p>
</dd>
<dt><code>{n,m}+</code></dt><dd><p>Match between n and m times. Possessive Match.</p>
</dd>
<dt><code>(...)</code></dt><dd><p>Capturing parentheses. Range of input that matched
the parenthesized sub-expression is available after the match,
see <code><a href="#topic+stri_match">stri_match</a></code>.</p>
</dd>
<dt><code>(?:...)</code></dt><dd><p>Non-capturing parentheses. Groups the included pattern,
but does not provide capturing of matching text. Somewhat more efficient
than capturing parentheses.</p>
</dd>
<dt><code>(?&gt;...)</code></dt><dd><p>Atomic-match parentheses. The first match of the
parenthesized sub-expression is the only one tried; if it does not lead to
an overall pattern match, back up the search for a match to a position
before the <code>(?&gt;</code>.</p>
</dd>
<dt><code>(?#...)</code></dt><dd><p>Free-format comment <code>(?# comment )</code>.</p>
</dd>
<dt><code>(?=...)</code></dt><dd><p>Look-ahead assertion. True if the parenthesized
pattern matches at the current input position, but does not advance
the input position.</p>
</dd>
<dt><code>(?!...)</code></dt><dd><p>Negative look-ahead assertion. True if the
parenthesized pattern does not match at the current input position.
Does not advance the input position.</p>
</dd>
<dt><code>(?&lt;=...)</code></dt><dd><p>Look-behind assertion. True if the parenthesized
pattern matches text preceding the current input position, with the last
character of the match being the input character just before the current
position. Does not alter the input position. The length of possible strings
matched by the look-behind pattern must not be unbounded (no <code>*</code>
or <code>+</code> operators.)</p>
</dd>
<dt><code>(?&lt;!...)</code></dt><dd><p>Negative Look-behind assertion. True if the
parenthesized pattern does not match text preceding the current input
position, with the last character of the match being the input character
just before the current position. Does not alter the input position.
The length of possible strings matched by the look-behind pattern must
not be unbounded (no <code>*</code> or <code>+</code> operators.)</p>
</dd>
<dt><code>(?&lt;name&gt;...)</code></dt><dd><p>Named capture group, where <code>name</code>
(enclosed within the angle brackets)
is a sequence like <code>[A-Za-z][A-Za-z0-9]*</code></p>
</dd>
<dt><code>(?ismwx-ismwx:...)</code></dt><dd><p>Flag settings. Evaluate the parenthesized
expression with the specified flags enabled or <code>-</code>disabled,
see also <code><a href="#topic+stri_opts_regex">stri_opts_regex</a></code>.</p>
</dd>
<dt><code>(?ismwx-ismwx)</code></dt><dd><p>Flag settings. Change the flag settings.
Changes apply to the portion of the pattern following the setting.
For example, <code>(?i)</code> changes to a case insensitive match,
see also <code><a href="#topic+stri_opts_regex">stri_opts_regex</a></code>.</p>
</dd>
</dl>



<h3><span class="pkg">ICU</span> Regex Meta-characters at a Glance</h3>

<p>Here is a list of meta-characters provided by the
ICU User Guide on regexes.
</p>

<dl>
<dt><code>\a</code></dt><dd><p>Match a BELL, <code>\u0007</code>.</p>
</dd>
<dt><code>\A</code></dt><dd><p>Match at the beginning of the input. Differs from <code>^</code>.
in that <code>\A</code> will not match after a new line within the input.</p>
</dd>
<dt><code>\b</code></dt><dd><p>Match if the current position is a word boundary.
Boundaries occur at the transitions between word (<code>\w</code>) and non-word
(<code>\W</code>) characters, with combining marks ignored. For better word
boundaries, see <span class="pkg">ICU</span> Boundary Analysis, e.g., <code><a href="#topic+stri_extract_all_words">stri_extract_all_words</a></code>.</p>
</dd>
<dt><code>\B</code></dt><dd><p>Match if the current position is not a word boundary.</p>
</dd>
<dt><code>\cX</code></dt><dd><p>Match a control-<code>X</code> character.</p>
</dd>
<dt><code>\d</code></dt><dd><p>Match any character with the Unicode General Category of
<code>Nd</code> (Number, Decimal Digit.).</p>
</dd>
<dt><code>\D</code></dt><dd><p>Match any character that is not a decimal digit.</p>
</dd>
<dt><code>\e</code></dt><dd><p>Match an ESCAPE, <code>\u001B</code>.</p>
</dd>
<dt><code>\E</code></dt><dd><p>Terminates a <code>\Q</code> ... <code>\E</code> quoted sequence.</p>
</dd>
<dt><code>\f</code></dt><dd><p>Match a FORM FEED, <code>\u000C</code>.</p>
</dd>
<dt><code>\G</code></dt><dd><p>Match if the current position is at the end of the
previous match.</p>
</dd>
<dt><code>\h</code></dt><dd><p>Match a Horizontal White Space character.
They are characters with Unicode General Category of Space_Separator plus
the ASCII tab, <code>\u0009</code>. [Since ICU 55]</p>
</dd>
<dt><code>\H</code></dt><dd><p>Match a non-Horizontal White Space character.
[Since ICU 55]</p>
</dd>
<dt><code>\k&lt;name&gt;</code></dt><dd><p>Named Capture Back Reference. [Since ICU 55]</p>
</dd>
<dt><code>\n</code></dt><dd><p>Match a LINE FEED, <code>\u000A</code>.</p>
</dd>
<dt><code>\N{UNICODE CHARACTER NAME}</code> </dt><dd><p>Match the named character.</p>
</dd>
<dt><code>\p{UNICODE PROPERTY NAME}</code> </dt><dd><p>Match any character with the
specified Unicode Property.</p>
</dd>
<dt><code>\P{UNICODE PROPERTY NAME}</code> </dt><dd><p>Match any character not having
the specified Unicode Property.</p>
</dd>
<dt><code>\Q</code></dt><dd><p>Quotes all following characters until <code>\E</code>.</p>
</dd>
<dt><code>\r</code></dt><dd><p>Match a CARRIAGE RETURN, <code>\u000D</code>.</p>
</dd>
<dt><code>\s</code></dt><dd><p>Match a white space character. White space is defined
as <code>[\t\n\f\r\p{Z}]</code>.</p>
</dd>
<dt><code>\S</code></dt><dd><p>Match a non-white space character.</p>
</dd>
<dt><code>\t</code></dt><dd><p>Match a HORIZONTAL TABULATION, <code>\u0009</code>.</p>
</dd>
<dt><code>\uhhhh</code></dt><dd><p>Match the character with the hex value <code>hhhh</code>.</p>
</dd>
<dt><code>\Uhhhhhhhh</code></dt><dd><p>Match the character with the hex value <code>hhhhhhhh</code>.
Exactly eight hex digits must be provided, even though the largest
Unicode code point is <code>\U0010ffff</code>.</p>
</dd>
<dt><code>\w</code></dt><dd><p>Match a word character. Word characters are
<code>[\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\u200c\u200d]</code>.</p>
</dd>
<dt><code>\W</code></dt><dd><p>Match a non-word character.</p>
</dd>
<dt><code>\x{hhhh}</code> </dt><dd><p>Match the character with hex value hhhh.
From one to six hex digits may be supplied.</p>
</dd>
<dt><code>\xhh</code></dt><dd><p>Match the character with two digit hex value hh </p>
</dd>
<dt><code>\X</code></dt><dd><p>Match a Grapheme Cluster.</p>
</dd>
<dt><code>\Z</code></dt><dd><p>Match if the current position is at the end of input,
but before the final line terminator, if one exists.</p>
</dd>
<dt><code>\z</code></dt><dd><p>Match if the current position is at the end of input.</p>
</dd>
<dt><code>\n</code></dt><dd><p>Back Reference. Match whatever the nth capturing
group matched. n must be a number &gt; 1 and &lt; total number of capture
groups in the pattern.</p>
</dd>
<dt><code>\0ooo</code></dt><dd><p>Match an Octal character.  <code>'ooo'</code> is from one to three
octal digits.  0377 is the largest allowed Octal character.  The leading
zero is required; it distinguishes Octal constants from back references.</p>
</dd>
<dt><code>[pattern]</code></dt><dd><p>Match any one character from the set.</p>
</dd>
<dt><code>.</code></dt><dd><p>Match any character except for - by default - newline, compare <code><a href="#topic+stri_opts_regex">stri_opts_regex</a></code>.</p>
</dd>
<dt><code>^</code></dt><dd><p>Match at the beginning of a line.</p>
</dd>
<dt><code>$</code></dt><dd><p>Match at the end of a line.</p>
</dd>
<dt><code>\</code></dt><dd><p>[outside of sets] Quotes the following character.
Characters that must be quoted to be treated as literals are
<code>* ? + [ ( ) { } ^ $ | \ .</code>.</p>
</dd>
<dt><code>\</code></dt><dd><p>[inside sets] Quotes the following character.
Characters that must be quoted to be treated as literals are
<code>[ ] \</code>; Characters that may need to be quoted, depending
on the context are <code>- &amp;</code>.</p>
</dd>
</dl>



<h3>Character Classes</h3>

<p>The syntax is similar, but not 100% compatible with the one
described in <a href="#topic+about_search_charclass">about_search_charclass</a>. In particular,
whitespaces are not ignored and set-theoretic operations are
denoted slightly differently. However, other than this
<a href="#topic+about_search_charclass">about_search_charclass</a> is a good reference
on the capabilities offered.
</p>
<p>The ICU User Guide on regexes lists what follows.
</p>

<dl>
<dt><code>[abc]</code></dt><dd><p>Match any of the characters a, b, or c</p>
</dd>
<dt><code>[^abc]</code></dt><dd><p>Negation &ndash; match any character except a, b, or c</p>
</dd>
<dt><code>[A-M]</code></dt><dd><p>Range &ndash; match any character from A to M (based on Unicode code point ordering)</p>
</dd>
<dt><code>[\p{L}]</code>, <code>[\p{Letter}]</code>, <code>[\p{General_Category=Letter}]</code>, <code>[:letter:]</code></dt><dd><p>Characters with Unicode Category = Letter (4 equivalent forms)</p>
</dd>
<dt><code>[\P{Letter}]</code></dt><dd><p>Negated property &ndash; natch everything except Letters</p>
</dd>
<dt><code>[\p{numeric_value=9}]</code></dt><dd><p>Match all numbers with a numeric value of 9</p>
</dd>
<dt><code>[\p{Letter}&amp;&amp;\p{script=cyrillic}]</code></dt><dd><p>Intersection; match the set of all Cyrillic letters</p>
</dd>
<dt><code>[\p{Letter}--\p{script=latin}]</code></dt><dd><p>Set difference; match all non-Latin letters</p>
</dd>
<dt><code>[[a-z][A-Z][0-9]]</code>, <code>[a-zA-Z0-9]</code></dt><dd><p>Union; match ASCII letters and digits (2 equivalent forms)</p>
</dd>
</dl>



<h3>Regex Functions in <span class="pkg">stringi</span></h3>

<p>Note that if a given regex <code>pattern</code> is empty,
then all the functions in <span class="pkg">stringi</span> give <code>NA</code> in result
and generate a warning.
On a syntax error, a quite informative failure message is shown.
</p>
<p>If you wish to search for a fixed pattern,
refer to <a href="#topic+about_search_coll">about_search_coll</a> or <a href="#topic+about_search_fixed">about_search_fixed</a>.
They allow to perform a locale-aware text lookup,
or a very fast exact-byte search, respectively.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Regular expressions</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/strings/regexp.html">https://unicode-org.github.io/icu/userguide/strings/regexp.html</a>
</p>
<p>J.E.F. Friedl, <em>Mastering Regular Expressions</em>, O'Reilly, 2002
</p>
<p><em>Unicode Regular Expressions</em> &ndash; Unicode Technical Standard #18,
<a href="https://www.unicode.org/reports/tr18/">https://www.unicode.org/reports/tr18/</a>
</p>
<p><em>Unicode Regular Expressions</em> &ndash; Regex tutorial,
<a href="https://www.regular-expressions.info/unicode.html">https://www.regular-expressions.info/unicode.html</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_regex: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_opts_regex">stri_opts_regex</a>()</code>
</p>
<p>Other stringi_general_topics: 
<code><a href="#topic+about_arguments">about_arguments</a></code>,
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_charclass">about_search_charclass</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+about_search_fixed">about_search_fixed</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+about_stringi">about_stringi</a></code>
</p>

<hr>
<h2 id='stri_compare'>Compare Strings with or without Collation</h2><span id='topic+stri_compare'></span><span id='topic+stri_cmp'></span><span id='topic+stri_cmp_eq'></span><span id='topic+stri_cmp_neq'></span><span id='topic+stri_cmp_equiv'></span><span id='topic+stri_cmp_nequiv'></span><span id='topic+stri_cmp_lt'></span><span id='topic+stri_cmp_gt'></span><span id='topic+stri_cmp_le'></span><span id='topic+stri_cmp_ge'></span>

<h3>Description</h3>

<p>These functions may be used to determine if two strings
are equal, canonically equivalent (this is performed in a much more clever
fashion than when testing for equality), or to check whether they are in
a specific lexicographic order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_compare(e1, e2, ..., opts_collator = NULL)

stri_cmp(e1, e2, ..., opts_collator = NULL)

stri_cmp_eq(e1, e2)

stri_cmp_neq(e1, e2)

stri_cmp_equiv(e1, e2, ..., opts_collator = NULL)

stri_cmp_nequiv(e1, e2, ..., opts_collator = NULL)

stri_cmp_lt(e1, e2, ..., opts_collator = NULL)

stri_cmp_gt(e1, e2, ..., opts_collator = NULL)

stri_cmp_le(e1, e2, ..., opts_collator = NULL)

stri_cmp_ge(e1, e2, ..., opts_collator = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_compare_+3A_e1">e1</code>, <code id="stri_compare_+3A_e2">e2</code></td>
<td>
<p>character vectors or objects coercible to character vectors</p>
</td></tr>
<tr><td><code id="stri_compare_+3A_...">...</code></td>
<td>
<p>additional settings for <code>opts_collator</code></p>
</td></tr>
<tr><td><code id="stri_compare_+3A_opts_collator">opts_collator</code></td>
<td>
<p>a named list with <span class="pkg">ICU</span> Collator's options,
see <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code>NULL</code>
for the default collation options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the functions listed here are vectorized over <code>e1</code> and <code>e2</code>.
</p>
<p><code>stri_cmp_eq</code> tests whether two corresponding strings
consist of exactly the same code points, while <code>stri_cmp_neq</code> allows
to check whether there is any difference between them. These are
locale-independent operations: for natural language processing,
where the notion of canonical equivalence is more valid, this might
not be exactly what you are looking for, see Examples.
Please note that <span class="pkg">stringi</span> always silently removes UTF-8
BOMs from input strings, therefore, e.g., <code>stri_cmp_eq</code> does not take
BOMs into account while comparing strings.
</p>
<p><code>stri_cmp_equiv</code> tests for canonical equivalence of two strings
and is locale-dependent. Additionally, the <span class="pkg">ICU</span>'s Collator may be
tuned up so that, e.g., the comparison is case-insensitive.
To test whether two strings are not canonically equivalent,
call <code>stri_cmp_nequiv</code>.
</p>
<p><code>stri_cmp_le</code> tests whether
the elements in the first vector are less than or equal to
the corresponding elements in the second vector,
<code>stri_cmp_ge</code> tests whether they are greater or equal,
<code>stri_cmp_lt</code> if less, and <code>stri_cmp_gt</code> if greater,
see also, e.g., <code><a href="#topic++25s+3C+25">%s&lt;%</a></code>.
</p>
<p><code>stri_compare</code> is an alias to <code>stri_cmp</code>. They both
perform exactly the same locale-dependent operation.
Both functions provide a C library's <code>strcmp()</code> look-and-feel,
see Value for details.
</p>
<p>For more information on <span class="pkg">ICU</span>'s Collator and how to tune its settings
refer to <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>.
Note that different locale settings may lead to different results
(see the examples below).
</p>


<h3>Value</h3>

<p>The <code>stri_cmp</code> and <code>stri_compare</code> functions
return an integer vector representing the comparison results:
<code>-1</code> if <code>e1[...] &lt; e2[...]</code>,
<code>0</code> if they are canonically equivalent, and <code>1</code> if greater.
</p>
<p>All the other functions return a logical vector that indicates
whether a given relation holds between two corresponding elements
in <code>e1</code> and <code>e2</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Collation</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/collation/">https://unicode-org.github.io/icu/userguide/collation/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># in Polish, ch &lt; h:
stri_cmp_lt('hladny', 'chladny', locale='pl_PL')

# in Slovak, ch &gt; h:
stri_cmp_lt('hladny', 'chladny', locale='sk_SK')

# &lt; or &gt; (depends on locale):
stri_cmp('hladny', 'chladny')

# ignore case differences:
stri_cmp_equiv('hladny', 'HLADNY', strength=2)

# also ignore diacritical differences:
stri_cmp_equiv('hladn\u00FD', 'hladny', strength=1, locale='sk_SK')

marios &lt;- c('Mario', 'mario', 'M\\u00e1rio', 'm\\u00e1rio')
stri_cmp_equiv(marios, 'mario', case_level=TRUE, strength=2L)
stri_cmp_equiv(marios, 'mario', case_level=TRUE, strength=1L)
stri_cmp_equiv(marios, 'mario', strength=1L)
stri_cmp_equiv(marios, 'mario', strength=2L)

# non-Unicode-normalized vs normalized string:
stri_cmp_equiv(stri_trans_nfkd('\u0105'), '\u105')

# note the difference:
stri_cmp_eq(stri_trans_nfkd('\u0105'), '\u105')

# ligatures:
stri_cmp_equiv('\ufb00', 'ff', strength=2)

# phonebook collation
stri_cmp_equiv('G\u00e4rtner', 'Gaertner', locale='de_DE@collation=phonebook', strength=1L)
stri_cmp_equiv('G\u00e4rtner', 'Gaertner', locale='de_DE', strength=1L)

</code></pre>

<hr>
<h2 id='stri_count'>Count the Number of Pattern Occurrences</h2><span id='topic+stri_count'></span><span id='topic+stri_count_charclass'></span><span id='topic+stri_count_coll'></span><span id='topic+stri_count_fixed'></span><span id='topic+stri_count_regex'></span>

<h3>Description</h3>

<p>These functions count the number of occurrences
of a pattern in a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_count(str, ..., regex, fixed, coll, charclass)

stri_count_charclass(str, pattern)

stri_count_coll(str, pattern, ..., opts_collator = NULL)

stri_count_fixed(str, pattern, ..., opts_fixed = NULL)

stri_count_regex(str, pattern, ..., opts_regex = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_count_+3A_str">str</code></td>
<td>
<p>character vector; strings to search in</p>
</td></tr>
<tr><td><code id="stri_count_+3A_...">...</code></td>
<td>
<p>supplementary arguments passed to the underlying functions,
including additional settings for <code>opts_collator</code>, <code>opts_regex</code>,
<code>opts_fixed</code>, and so on</p>
</td></tr>
<tr><td><code id="stri_count_+3A_pattern">pattern</code>, <code id="stri_count_+3A_regex">regex</code>, <code id="stri_count_+3A_fixed">fixed</code>, <code id="stri_count_+3A_coll">coll</code>, <code id="stri_count_+3A_charclass">charclass</code></td>
<td>
<p>character vector;
search patterns; for more details refer to <a href="#topic+stringi-search">stringi-search</a></p>
</td></tr>
<tr><td><code id="stri_count_+3A_opts_collator">opts_collator</code>, <code id="stri_count_+3A_opts_fixed">opts_fixed</code>, <code id="stri_count_+3A_opts_regex">opts_regex</code></td>
<td>
<p>a named list used to tune up
the search engine's settings; see
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code><a href="#topic+stri_opts_fixed">stri_opts_fixed</a></code>,
and <code><a href="#topic+stri_opts_regex">stri_opts_regex</a></code>, respectively; <code>NULL</code>
for the defaults</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code> and <code>pattern</code> (with recycling
of the elements in the shorter vector if necessary). This allows to,
for instance, search for one pattern in each given string,
search for each pattern in one given string,
and search for the i-th pattern within the i-th string.
</p>
<p>If <code>pattern</code> is empty, then the result is <code>NA</code>
and a warning is generated.
</p>
<p><code>stri_count</code> is a convenience function.
It calls either <code>stri_count_regex</code>,
<code>stri_count_fixed</code>, <code>stri_count_coll</code>,
or <code>stri_count_charclass</code>, depending on the argument used.
</p>


<h3>Value</h3>

<p>All the functions return an integer vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_count: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- 'Lorem ipsum dolor sit amet, consectetur adipisicing elit.'
stri_count(s, fixed='dolor')
stri_count(s, regex='\\p{L}+')

stri_count_fixed(s, ' ')
stri_count_fixed(s, 'o')
stri_count_fixed(s, 'it')
stri_count_fixed(s, letters)
stri_count_fixed('babab', 'b')
stri_count_fixed(c('stringi', '123'), 'string')

stri_count_charclass(c('stRRRingi', 'STrrrINGI', '123'),
   c('\\p{Ll}', '\\p{Lu}', '\\p{Zs}'))
stri_count_charclass(' \t\n', '\\p{WHITE_SPACE}') # white space - binary property
stri_count_charclass(' \t\n', '\\p{Z}') # white-space - general category (note the difference)

stri_count_regex(s, '(s|el)it')
stri_count_regex(s, 'i.i')
stri_count_regex(s, '.it')
stri_count_regex('bab baab baaab', c('b.*?b', 'b.b'))
stri_count_regex(c('stringi', '123'), '^(s|1)')

</code></pre>

<hr>
<h2 id='stri_count_boundaries'>Count the Number of Text Boundaries</h2><span id='topic+stri_count_boundaries'></span><span id='topic+stri_count_words'></span>

<h3>Description</h3>

<p>These functions determine the number of text boundaries
(like character, word, line, or sentence boundaries) in a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_count_boundaries(str, ..., opts_brkiter = NULL)

stri_count_words(str, locale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_count_boundaries_+3A_str">str</code></td>
<td>
<p>character vector or an object coercible to</p>
</td></tr>
<tr><td><code id="stri_count_boundaries_+3A_...">...</code></td>
<td>
<p>additional settings for <code>opts_brkiter</code></p>
</td></tr>
<tr><td><code id="stri_count_boundaries_+3A_opts_brkiter">opts_brkiter</code></td>
<td>
<p>a named list with <span class="pkg">ICU</span> BreakIterator's settings,
see <code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a></code>;
<code>NULL</code> for the default break iterator, i.e., <code>line_break</code></p>
</td></tr>
<tr><td><code id="stri_count_boundaries_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for text boundary analysis following
the conventions of the default locale, or a single string with
locale identifier, see <a href="#topic+stringi-locale">stringi-locale</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code>.
</p>
<p>For more information on text boundary analysis
performed by <span class="pkg">ICU</span>'s <code>BreakIterator</code>, see
<a href="#topic+stringi-search-boundaries">stringi-search-boundaries</a>.
</p>
<p>In case of <code>stri_count_words</code>,
just like in <code><a href="#topic+stri_extract_all_words">stri_extract_all_words</a></code> and
<code><a href="#topic+stri_locate_all_words">stri_locate_all_words</a></code>,
<span class="pkg">ICU</span>'s word <code>BreakIterator</code> iterator is used
to locate the word boundaries, and all non-word characters
(<code>UBRK_WORD_NONE</code> rule status) are ignored.
This function is equivalent to a call to
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>(str, type='word', skip_word_none=TRUE, locale=locale)</code>.
</p>
<p>Note that a <code>BreakIterator</code> of type <code>character</code>
may be used to count the number of <em>Unicode characters</em> in a string.
The <code><a href="#topic+stri_length">stri_length</a></code> function,
which aims to count the number of <em>Unicode code points</em>,
might report different results.
</p>
<p>Moreover, a <code>BreakIterator</code> of type <code>sentence</code>
may be used to count the number of sentences in a text piece.
</p>


<h3>Value</h3>

<p>Both functions return an integer vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_count: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_count">stri_count</a>()</code>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>
<p>Other text_boundaries: 
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_split_lines">stri_split_lines</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- 'The\u00a0above-mentioned    features are very useful. Spam, spam, eggs, bacon, and spam.'
stri_count_boundaries(test, type='word')
stri_count_boundaries(test, type='sentence')
stri_count_boundaries(test, type='character')
stri_count_words(test)

test2 &lt;- stri_trans_nfkd('\u03c0\u0153\u0119\u00a9\u00df\u2190\u2193\u2192')
stri_count_boundaries(test2, type='character')
stri_length(test2)
stri_numbytes(test2)

</code></pre>

<hr>
<h2 id='stri_datetime_add'>Date and Time Arithmetic</h2><span id='topic+stri_datetime_add'></span><span id='topic+stri_datetime_add+3C-'></span>

<h3>Description</h3>

<p>Modifies a date-time object by adding a specific amount of time units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_datetime_add(
  time,
  value = 1L,
  units = "seconds",
  tz = NULL,
  locale = NULL
)

stri_datetime_add(time, units = "seconds", tz = NULL, locale = NULL) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_datetime_add_+3A_time">time</code></td>
<td>
<p>an object of class <code><a href="base.html#topic+POSIXct">POSIXct</a></code>
(<code>as.POSIXct</code> will be called on character vectors
and objects of class <code>POSIXlt</code>, <code>Date</code>, and <code>factor</code>)</p>
</td></tr>
<tr><td><code id="stri_datetime_add_+3A_value">value</code></td>
<td>
<p>integer vector; signed number of units to add to <code>time</code></p>
</td></tr>
<tr><td><code id="stri_datetime_add_+3A_units">units</code></td>
<td>
<p>single string; one of <code>'years'</code>, <code>'months'</code>,
<code>'weeks'</code>, <code>'days'</code>, <code>'hours'</code>, <code>'minutes'</code>,
<code>'seconds'</code>, or <code>'milliseconds'</code></p>
</td></tr>
<tr><td><code id="stri_datetime_add_+3A_tz">tz</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for the default time zone
or a single string with a timezone identifier,</p>
</td></tr>
<tr><td><code id="stri_datetime_add_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for default locale,
or a single string with locale identifier; a non-Gregorian calendar
may be specified by setting the <code>@calendar=name</code> keyword</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>time</code> and <code>value</code>.
</p>
<p>Note that, e.g., January, 31 + 1 month = February, 28 or 29.
</p>


<h3>Value</h3>

<p>Both functions return an object of class <code><a href="base.html#topic+POSIXct">POSIXct</a></code>.
</p>
<p>The replacement version of <code>stri_datetime_add</code> modifies
the state of the <code>time</code> object.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Calendar Classes</em> - ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/datetime/calendar/">https://unicode-org.github.io/icu/userguide/datetime/calendar/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other datetime: 
<code><a href="#topic+stri_datetime_create">stri_datetime_create</a>()</code>,
<code><a href="#topic+stri_datetime_fields">stri_datetime_fields</a>()</code>,
<code><a href="#topic+stri_datetime_format">stri_datetime_format</a>()</code>,
<code><a href="#topic+stri_datetime_fstr">stri_datetime_fstr</a>()</code>,
<code><a href="#topic+stri_datetime_now">stri_datetime_now</a>()</code>,
<code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a>()</code>,
<code><a href="#topic+stri_timezone_get">stri_timezone_get</a>()</code>,
<code><a href="#topic+stri_timezone_info">stri_timezone_info</a>()</code>,
<code><a href="#topic+stri_timezone_list">stri_timezone_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- stri_datetime_now()
stri_datetime_add(x, units='months') &lt;- 2
print(x)
stri_datetime_add(x, -2, units='months')
stri_datetime_add(stri_datetime_create(2014, 4, 20), 1, units='years')
stri_datetime_add(stri_datetime_create(2014, 4, 20), 1, units='years', locale='@calendar=hebrew')

stri_datetime_add(stri_datetime_create(2016, 1, 31), 1, units='months')

</code></pre>

<hr>
<h2 id='stri_datetime_create'>Create a Date-Time Object</h2><span id='topic+stri_datetime_create'></span>

<h3>Description</h3>

<p>Constructs date-time objects from numeric representations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_datetime_create(
  year = NULL,
  month = NULL,
  day = NULL,
  hour = 0L,
  minute = 0L,
  second = 0,
  lenient = FALSE,
  tz = NULL,
  locale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_datetime_create_+3A_year">year</code></td>
<td>
<p>integer vector; 0 is 1BCE, -1 is 2BCE, etc.;
<code>NULL</code> for the current year</p>
</td></tr>
<tr><td><code id="stri_datetime_create_+3A_month">month</code></td>
<td>
<p>integer vector; months are 1-based;
<code>NULL</code> for the current month</p>
</td></tr>
<tr><td><code id="stri_datetime_create_+3A_day">day</code></td>
<td>
<p>integer vector;
<code>NULL</code> for the current day</p>
</td></tr>
<tr><td><code id="stri_datetime_create_+3A_hour">hour</code></td>
<td>
<p>integer vector;
<code>NULL</code> for the current hour</p>
</td></tr>
<tr><td><code id="stri_datetime_create_+3A_minute">minute</code></td>
<td>
<p>integer vector;
<code>NULL</code> for the current minute</p>
</td></tr>
<tr><td><code id="stri_datetime_create_+3A_second">second</code></td>
<td>
<p>numeric vector; fractional seconds are allowed;
<code>NULL</code> for the current seconds (without milliseconds)</p>
</td></tr>
<tr><td><code id="stri_datetime_create_+3A_lenient">lenient</code></td>
<td>
<p>single logical value; should the operation be lenient?</p>
</td></tr>
<tr><td><code id="stri_datetime_create_+3A_tz">tz</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for the default time zone or
a single string with time zone identifier, see <code><a href="#topic+stri_timezone_list">stri_timezone_list</a></code></p>
</td></tr>
<tr><td><code id="stri_datetime_create_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for default locale,
or a single string with locale identifier; a non-Gregorian calendar
may be specified by setting <code>@calendar=name</code> keyword</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>,
<code>hour</code>, <code>minute</code>, and <code>second</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="base.html#topic+POSIXct">POSIXct</a></code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other datetime: 
<code><a href="#topic+stri_datetime_add">stri_datetime_add</a>()</code>,
<code><a href="#topic+stri_datetime_fields">stri_datetime_fields</a>()</code>,
<code><a href="#topic+stri_datetime_format">stri_datetime_format</a>()</code>,
<code><a href="#topic+stri_datetime_fstr">stri_datetime_fstr</a>()</code>,
<code><a href="#topic+stri_datetime_now">stri_datetime_now</a>()</code>,
<code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a>()</code>,
<code><a href="#topic+stri_timezone_get">stri_timezone_get</a>()</code>,
<code><a href="#topic+stri_timezone_info">stri_timezone_info</a>()</code>,
<code><a href="#topic+stri_timezone_list">stri_timezone_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_datetime_create(2015, 12, 31, 23, 59, 59.999)
stri_datetime_create(5775, 8, 1, locale='@calendar=hebrew')  # 1 Nisan 5775 -&gt; 2015-03-21
stri_datetime_create(2015, 02, 29)
stri_datetime_create(2015, 02, 29, lenient=TRUE)
stri_datetime_create(hour=15, minute=59)

</code></pre>

<hr>
<h2 id='stri_datetime_fields'>Get Values for Date and Time Fields</h2><span id='topic+stri_datetime_fields'></span>

<h3>Description</h3>

<p>Computes and returns values for all date and time fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_datetime_fields(time, tz = attr(time, "tzone"), locale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_datetime_fields_+3A_time">time</code></td>
<td>
<p>an object of class <code><a href="base.html#topic+POSIXct">POSIXct</a></code>
(<code>as.POSIXct</code> will be called on character vectors
and objects of class <code>POSIXlt</code>, <code>Date</code>, and <code>factor</code>)</p>
</td></tr>
<tr><td><code id="stri_datetime_fields_+3A_tz">tz</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for the default time zone or
a single string with time zone identifier, see <code><a href="#topic+stri_timezone_list">stri_timezone_list</a></code></p>
</td></tr>
<tr><td><code id="stri_datetime_fields_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for the current default locale,
or a single string with a locale identifier; a non-Gregorian calendar
may be specified by setting <code>@calendar=name</code> keyword</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>time</code>.
</p>


<h3>Value</h3>

<p>Returns a data frame with the following columns:
</p>

<ol>
<li><p> Year (0 is 1BC, -1 is 2BC, etc.)
</p>
</li>
<li><p> Month (1-based, i.e., 1 stands for the first month, e.g., January;
note that the number of months depends on the selected calendar,
see <code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a></code>)
</p>
</li>
<li><p> Day
</p>
</li>
<li><p> Hour (24-h clock)
</p>
</li>
<li><p> Minute
</p>
</li>
<li><p> Second
</p>
</li>
<li><p> Millisecond
</p>
</li>
<li><p> WeekOfYear (this is locale-dependent)
</p>
</li>
<li><p> WeekOfMonth (this is locale-dependent)
</p>
</li>
<li><p> DayOfYear
</p>
</li>
<li><p> DayOfWeek (1-based, 1 denotes Sunday; see <code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a></code>)
</p>
</li>
<li><p> Hour12 (12-h clock)
</p>
</li>
<li><p> AmPm (see <code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a></code>)
</p>
</li>
<li><p> Era (see <code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a></code>)
</p>
</li></ol>



<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other datetime: 
<code><a href="#topic+stri_datetime_add">stri_datetime_add</a>()</code>,
<code><a href="#topic+stri_datetime_create">stri_datetime_create</a>()</code>,
<code><a href="#topic+stri_datetime_format">stri_datetime_format</a>()</code>,
<code><a href="#topic+stri_datetime_fstr">stri_datetime_fstr</a>()</code>,
<code><a href="#topic+stri_datetime_now">stri_datetime_now</a>()</code>,
<code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a>()</code>,
<code><a href="#topic+stri_timezone_get">stri_timezone_get</a>()</code>,
<code><a href="#topic+stri_timezone_info">stri_timezone_info</a>()</code>,
<code><a href="#topic+stri_timezone_list">stri_timezone_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_datetime_fields(stri_datetime_now())
stri_datetime_fields(stri_datetime_now(), locale='@calendar=hebrew')
stri_datetime_symbols(locale='@calendar=hebrew')$Month[
   stri_datetime_fields(stri_datetime_now(), locale='@calendar=hebrew')$Month
]

</code></pre>

<hr>
<h2 id='stri_datetime_format'>Date and Time Formatting and Parsing</h2><span id='topic+stri_datetime_format'></span><span id='topic+stri_datetime_parse'></span>

<h3>Description</h3>

<p>These functions convert a given date/time object
to a character vector, or vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_datetime_format(
  time,
  format = "uuuu-MM-dd HH:mm:ss",
  tz = NULL,
  locale = NULL
)

stri_datetime_parse(
  str,
  format = "uuuu-MM-dd HH:mm:ss",
  lenient = FALSE,
  tz = NULL,
  locale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_datetime_format_+3A_time">time</code></td>
<td>
<p>an object of class <code><a href="base.html#topic+POSIXct">POSIXct</a></code> with date-time data
to be formatted
(<code>as.POSIXct</code> will be called on character vectors
and objects of class <code>POSIXlt</code>, <code>Date</code>, and <code>factor</code>)</p>
</td></tr>
<tr><td><code id="stri_datetime_format_+3A_format">format</code></td>
<td>
<p>character vector, see Details; see also <code><a href="#topic+stri_datetime_fstr">stri_datetime_fstr</a></code></p>
</td></tr>
<tr><td><code id="stri_datetime_format_+3A_tz">tz</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for the default time zone
or a single string with a timezone identifier,
see <code><a href="#topic+stri_timezone_get">stri_timezone_get</a></code> and <code><a href="#topic+stri_timezone_list">stri_timezone_list</a></code></p>
</td></tr>
<tr><td><code id="stri_datetime_format_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for the default locale,
or a single string with locale identifier; a non-Gregorian calendar
may be specified by setting the <code>@calendar=name</code> keyword</p>
</td></tr>
<tr><td><code id="stri_datetime_format_+3A_str">str</code></td>
<td>
<p>character vector with strings to be parsed</p>
</td></tr>
<tr><td><code id="stri_datetime_format_+3A_lenient">lenient</code></td>
<td>
<p>single logical value; should date/time parsing be lenient?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>format</code> and <code>time</code> or <code>str</code>.
</p>
<p>When parsing strings, unspecified date-time fields
(e.g., seconds where only hours and minutes are given)
are based on today's midnight in the local time zone
(for compatibility with <code><a href="base.html#topic+strptime">strptime</a></code>).
</p>
<p>By default, <code>stri_datetime_format</code> (for compatibility
with the <code><a href="base.html#topic+strftime">strftime</a></code> function)
formats a date/time object using the current default time zone.
</p>
<p><code>format</code> may be one of <code>DT_STYLE</code> or <code>DT_relative_STYLE</code>,
where <code>DT</code> is equal to <code>date</code>, <code>time</code>, or <code>datetime</code>,
and <code>STYLE</code> is equal to <code>full</code>, <code>long</code>, <code>medium</code>,
or <code>short</code>. This gives a locale-dependent date and/or time format.
Note that currently <span class="pkg">ICU</span> does not support <code>relative</code>
<code>time</code> formats, thus this flag is currently ignored in such a context.
</p>
<p>Otherwise, <code>format</code> is a pattern:
a string where specific sequences of characters are replaced
with date/time data from a calendar when formatting or used
to generate data for a calendar when parsing.
For example, <code>y</code> stands for 'year'. Characters
may be used multiple times:
<code>yy</code> might produce <code>99</code>, whereas <code>yyyy</code> yields <code>1999</code>.
For most numerical fields, the number of characters specifies
the field width. For example, if <code>h</code> is the hour, <code>h</code> might
produce <code>5</code>, but <code>hh</code> yields <code>05</code>.
For some characters, the count specifies whether an abbreviated
or full form should be used.
</p>
<p>Two single quotes represent a literal single quote, either
inside or outside single quotes. Text within single quotes
is not interpreted in any way (except for two adjacent single quotes).
Otherwise, all ASCII letters from <code>a</code> to <code>z</code> and
<code>A</code> to <code>Z</code> are reserved as syntax characters, and require quoting
if they are to represent literal characters. In addition, certain
ASCII punctuation characters may become available in the future
(e.g., <code>:</code> being interpreted as the time separator and <code>/</code>
as a date separator, and replaced by respective
locale-sensitive characters in display).
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>Symbol</b> </td><td style="text-align: left;"> <b>Meaning</b> </td><td style="text-align: left;"> <b>Example(s)</b> </td><td style="text-align: left;"> <b>Output</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
G </td><td style="text-align: left;"> era designator </td><td style="text-align: left;"> G, GG, or GGG </td><td style="text-align: left;"> AD </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> GGGG </td><td style="text-align: left;"> Anno Domini </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> GGGGG </td><td style="text-align: left;"> A </td>
</tr>
<tr>
 <td style="text-align: left;">
y </td><td style="text-align: left;"> year </td><td style="text-align: left;"> yy </td><td style="text-align: left;"> 96 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> y or yyyy </td><td style="text-align: left;"> 1996 </td>
</tr>
<tr>
 <td style="text-align: left;">
u </td><td style="text-align: left;"> extended year </td><td style="text-align: left;"> u </td><td style="text-align: left;"> 4601 </td>
</tr>
<tr>
 <td style="text-align: left;">
U </td><td style="text-align: left;"> cyclic year name, as in Chinese lunar calendar </td><td style="text-align: left;"> U </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
r </td><td style="text-align: left;"> related Gregorian year </td><td style="text-align: left;"> r </td><td style="text-align: left;"> 1996 </td>
</tr>
<tr>
 <td style="text-align: left;">
Q </td><td style="text-align: left;"> quarter </td><td style="text-align: left;"> Q or QQ </td><td style="text-align: left;"> 02 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> QQQ </td><td style="text-align: left;"> Q2 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> QQQQ </td><td style="text-align: left;"> 2nd quarter </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> QQQQQ </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
q </td><td style="text-align: left;"> Stand Alone quarter </td><td style="text-align: left;"> q or qq </td><td style="text-align: left;"> 02 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> qqq </td><td style="text-align: left;"> Q2 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> qqqq </td><td style="text-align: left;"> 2nd quarter </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> qqqqq </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
M </td><td style="text-align: left;"> month in year </td><td style="text-align: left;"> M or MM </td><td style="text-align: left;"> 09 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> MMM </td><td style="text-align: left;"> Sep </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> MMMM </td><td style="text-align: left;"> September </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> MMMMM </td><td style="text-align: left;"> S </td>
</tr>
<tr>
 <td style="text-align: left;">
L </td><td style="text-align: left;"> Stand Alone month in year </td><td style="text-align: left;"> L or LL </td><td style="text-align: left;"> 09 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> LLL </td><td style="text-align: left;"> Sep </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> LLLL </td><td style="text-align: left;"> September </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> LLLLL </td><td style="text-align: left;"> S </td>
</tr>
<tr>
 <td style="text-align: left;">
w </td><td style="text-align: left;"> week of year </td><td style="text-align: left;"> w or ww </td><td style="text-align: left;"> 27 </td>
</tr>
<tr>
 <td style="text-align: left;">
W </td><td style="text-align: left;"> week of month </td><td style="text-align: left;"> W </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
d </td><td style="text-align: left;"> day in month </td><td style="text-align: left;"> d </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> dd </td><td style="text-align: left;"> 02 </td>
</tr>
<tr>
 <td style="text-align: left;">
D </td><td style="text-align: left;"> day of year </td><td style="text-align: left;"> D </td><td style="text-align: left;"> 189 </td>
</tr>
<tr>
 <td style="text-align: left;">
F </td><td style="text-align: left;"> day of week in month </td><td style="text-align: left;"> F </td><td style="text-align: left;"> 2 (2nd Wed in July) </td>
</tr>
<tr>
 <td style="text-align: left;">
g </td><td style="text-align: left;"> modified Julian day </td><td style="text-align: left;"> g </td><td style="text-align: left;"> 2451334 </td>
</tr>
<tr>
 <td style="text-align: left;">
E </td><td style="text-align: left;"> day of week </td><td style="text-align: left;"> E, EE, or EEE </td><td style="text-align: left;"> Tue </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> EEEE </td><td style="text-align: left;"> Tuesday </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> EEEEE </td><td style="text-align: left;"> T </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> EEEEEE </td><td style="text-align: left;"> Tu </td>
</tr>
<tr>
 <td style="text-align: left;">
e </td><td style="text-align: left;"> local day of week </td><td style="text-align: left;"> e or ee </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  example: if Monday is 1st day, Tuesday is 2nd )  </td><td style="text-align: left;"> eee </td><td style="text-align: left;"> Tue </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> eeee </td><td style="text-align: left;"> Tuesday </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> eeeee </td><td style="text-align: left;"> T </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> eeeeee </td><td style="text-align: left;"> Tu </td>
</tr>
<tr>
 <td style="text-align: left;">
c </td><td style="text-align: left;"> Stand Alone local day of week </td><td style="text-align: left;"> c or cc </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> ccc </td><td style="text-align: left;"> Tue </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> cccc </td><td style="text-align: left;"> Tuesday </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> ccccc </td><td style="text-align: left;"> T </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> cccccc </td><td style="text-align: left;"> Tu </td>
</tr>
<tr>
 <td style="text-align: left;">
a </td><td style="text-align: left;"> am/pm marker </td><td style="text-align: left;"> a </td><td style="text-align: left;"> pm </td>
</tr>
<tr>
 <td style="text-align: left;">
h </td><td style="text-align: left;"> hour in am/pm (1~12) </td><td style="text-align: left;"> h </td><td style="text-align: left;"> 7 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> hh </td><td style="text-align: left;"> 07 </td>
</tr>
<tr>
 <td style="text-align: left;">
H </td><td style="text-align: left;"> hour in day (0~23) </td><td style="text-align: left;"> H </td><td style="text-align: left;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> HH </td><td style="text-align: left;"> 00 </td>
</tr>
<tr>
 <td style="text-align: left;">
k </td><td style="text-align: left;"> hour in day (1~24) </td><td style="text-align: left;"> k </td><td style="text-align: left;"> 24 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> kk </td><td style="text-align: left;"> 24 </td>
</tr>
<tr>
 <td style="text-align: left;">
K </td><td style="text-align: left;"> hour in am/pm (0~11) </td><td style="text-align: left;"> K </td><td style="text-align: left;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> KK </td><td style="text-align: left;"> 00 </td>
</tr>
<tr>
 <td style="text-align: left;">
m </td><td style="text-align: left;"> minute in hour </td><td style="text-align: left;"> m </td><td style="text-align: left;"> 4 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> mm </td><td style="text-align: left;"> 04 </td>
</tr>
<tr>
 <td style="text-align: left;">
s </td><td style="text-align: left;"> second in minute </td><td style="text-align: left;"> s </td><td style="text-align: left;"> 5 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> ss </td><td style="text-align: left;"> 05 </td>
</tr>
<tr>
 <td style="text-align: left;">
S </td><td style="text-align: left;"> fractional second - truncates (like other time fields)  </td><td style="text-align: left;"> S </td><td style="text-align: left;"> 2 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> to the count of letters when formatting. Appends  </td><td style="text-align: left;"> SS </td><td style="text-align: left;"> 23 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> zeros if more than 3 letters specified. Truncates at  </td><td style="text-align: left;"> SSS </td><td style="text-align: left;"> 235 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> three significant digits when parsing.  </td><td style="text-align: left;"> SSSS </td><td style="text-align: left;"> 2350 </td>
</tr>
<tr>
 <td style="text-align: left;">
A </td><td style="text-align: left;"> milliseconds in day </td><td style="text-align: left;"> A </td><td style="text-align: left;"> 61201235 </td>
</tr>
<tr>
 <td style="text-align: left;">
z </td><td style="text-align: left;"> Time Zone: specific non-location </td><td style="text-align: left;"> z, zz, or zzz </td><td style="text-align: left;"> PDT </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;">  </td><td style="text-align: left;"> zzzz </td><td style="text-align: left;"> Pacific Daylight Time </td>
</tr>
<tr>
 <td style="text-align: left;">
Z </td><td style="text-align: left;"> Time Zone: ISO8601 basic hms? / RFC 822 </td><td style="text-align: left;"> Z, ZZ, or ZZZ </td><td style="text-align: left;"> -0800 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: long localized GMT (=OOOO) </td><td style="text-align: left;"> ZZZZ </td><td style="text-align: left;"> GMT-08:00 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: ISO8601 extended hms? (=XXXXX) </td><td style="text-align: left;"> ZZZZZ </td><td style="text-align: left;"> -08:00, -07:52:58, Z </td>
</tr>
<tr>
 <td style="text-align: left;">
O </td><td style="text-align: left;"> Time Zone: short localized GMT </td><td style="text-align: left;"> O </td><td style="text-align: left;"> GMT-8 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: long localized GMT (=ZZZZ) </td><td style="text-align: left;"> OOOO </td><td style="text-align: left;"> GMT-08:00 </td>
</tr>
<tr>
 <td style="text-align: left;">
v </td><td style="text-align: left;"> Time Zone: generic non-location </td><td style="text-align: left;"> v </td><td style="text-align: left;"> PT </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> (falls back first to VVVV) </td><td style="text-align: left;"> vvvv </td><td style="text-align: left;"> Pacific Time or Los Angeles Time </td>
</tr>
<tr>
 <td style="text-align: left;">
V </td><td style="text-align: left;"> Time Zone: short time zone ID </td><td style="text-align: left;"> V </td><td style="text-align: left;"> uslax </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: long time zone ID </td><td style="text-align: left;"> VV </td><td style="text-align: left;"> America/Los_Angeles </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: time zone exemplar city </td><td style="text-align: left;"> VVV </td><td style="text-align: left;"> Los Angeles </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: generic location (falls back to OOOO) </td><td style="text-align: left;"> VVVV </td><td style="text-align: left;"> Los Angeles Time </td>
</tr>
<tr>
 <td style="text-align: left;">
X </td><td style="text-align: left;"> Time Zone: ISO8601 basic hm?, with Z for 0 </td><td style="text-align: left;"> X </td><td style="text-align: left;"> -08, +0530, Z </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: ISO8601 basic hm, with Z </td><td style="text-align: left;"> XX </td><td style="text-align: left;"> -0800, Z </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: ISO8601 extended hm, with Z </td><td style="text-align: left;"> XXX </td><td style="text-align: left;"> -08:00, Z </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: ISO8601 basic hms?, with Z </td><td style="text-align: left;"> XXXX </td><td style="text-align: left;"> -0800, -075258, Z </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: ISO8601 extended hms?, with Z </td><td style="text-align: left;"> XXXXX </td><td style="text-align: left;"> -08:00, -07:52:58, Z </td>
</tr>
<tr>
 <td style="text-align: left;">
x </td><td style="text-align: left;"> Time Zone: ISO8601 basic hm?, without Z for 0 </td><td style="text-align: left;"> x </td><td style="text-align: left;"> -08, +0530 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: ISO8601 basic hm, without Z </td><td style="text-align: left;"> xx </td><td style="text-align: left;"> -0800 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: ISO8601 extended hm, without Z </td><td style="text-align: left;"> xxx </td><td style="text-align: left;"> -08:00 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: ISO8601 basic hms?, without Z </td><td style="text-align: left;"> xxxx </td><td style="text-align: left;"> -0800, -075258 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Time Zone: ISO8601 extended hms?, without Z </td><td style="text-align: left;"> xxxxx </td><td style="text-align: left;"> -08:00, -07:52:58 </td>
</tr>
<tr>
 <td style="text-align: left;">
' </td><td style="text-align: left;"> escape for text </td><td style="text-align: left;"> ' </td><td style="text-align: left;"> (nothing) </td>
</tr>
<tr>
 <td style="text-align: left;">
' ' </td><td style="text-align: left;"> two single quotes produce one </td><td style="text-align: left;"> ' ' </td><td style="text-align: left;"> '
</td>
</tr>

</table>

<p>Note that any characters in the pattern that are not in the ranges
of <code>[a-z]</code> and <code>[A-Z]</code> will be treated as quoted text.
For instance, characters like <code>:</code>, <code>.</code>,  (a space),
<code>#</code> and <code>@</code> will appear in the resulting time text
even if they are not enclosed within single quotes. The single quote is used
to &ldquo;escape&rdquo; the letters. Two single quotes in a row,
inside or outside a quoted sequence, represent a &ldquo;real&rdquo; single quote.
</p>
<p>A few examples:
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>Example Pattern</b> </td><td style="text-align: left;">  <b>Result</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
yyyy.MM.dd 'at' HH:mm:ss zzz </td><td style="text-align: left;"> 2015.12.31 at 23:59:59 GMT+1 </td>
</tr>
<tr>
 <td style="text-align: left;">
EEE, MMM d, ''yy </td><td style="text-align: left;"> czw., gru 31, '15 </td>
</tr>
<tr>
 <td style="text-align: left;">
h:mm a </td><td style="text-align: left;"> 11:59 PM </td>
</tr>
<tr>
 <td style="text-align: left;">
hh 'o''clock' a, zzzz </td><td style="text-align: left;"> 11 o'clock PM, GMT+01:00 </td>
</tr>
<tr>
 <td style="text-align: left;">
K:mm a, z </td><td style="text-align: left;"> 11:59 PM, GMT+1 </td>
</tr>
<tr>
 <td style="text-align: left;">
yyyyy.MMMM.dd GGG hh:mm aaa </td><td style="text-align: left;"> 2015.grudnia.31 n.e. 11:59 PM </td>
</tr>
<tr>
 <td style="text-align: left;">
uuuu-MM-dd'T'HH:mm:ssZ </td><td style="text-align: left;"> 2015-12-31T23:59:59+0100 (the ISO 8601 guideline) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p><code>stri_datetime_format</code> returns a character vector.
</p>
<p><code>stri_datetime_parse</code> returns an object of class <code><a href="base.html#topic+POSIXct">POSIXct</a></code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Formatting Dates and Times</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/format_parse/datetime/">https://unicode-org.github.io/icu/userguide/format_parse/datetime/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other datetime: 
<code><a href="#topic+stri_datetime_add">stri_datetime_add</a>()</code>,
<code><a href="#topic+stri_datetime_create">stri_datetime_create</a>()</code>,
<code><a href="#topic+stri_datetime_fields">stri_datetime_fields</a>()</code>,
<code><a href="#topic+stri_datetime_fstr">stri_datetime_fstr</a>()</code>,
<code><a href="#topic+stri_datetime_now">stri_datetime_now</a>()</code>,
<code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a>()</code>,
<code><a href="#topic+stri_timezone_get">stri_timezone_get</a>()</code>,
<code><a href="#topic+stri_timezone_info">stri_timezone_info</a>()</code>,
<code><a href="#topic+stri_timezone_list">stri_timezone_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c('2015-02-28', '2015-02-29')
stri_datetime_parse(x, 'yyyy-MM-dd')
stri_datetime_parse(x, 'yyyy-MM-dd', lenient=TRUE)
stri_datetime_parse(x %s+% " 17:13", "yyyy-MM-dd HH:mm")
stri_datetime_parse('19 lipca 2015', 'date_long', locale='pl_PL')
stri_datetime_format(stri_datetime_now(), 'datetime_relative_medium')

</code></pre>

<hr>
<h2 id='stri_datetime_fstr'>Convert <code>strptime</code>-Style Format Strings</h2><span id='topic+stri_datetime_fstr'></span>

<h3>Description</h3>

<p>This function converts <code><a href="base.html#topic+strptime">strptime</a></code> or
<code><a href="base.html#topic+strftime">strftime</a></code>-style
format strings to <span class="pkg">ICU</span> format strings that may be used
in <code><a href="#topic+stri_datetime_parse">stri_datetime_parse</a></code> and <code><a href="#topic+stri_datetime_format">stri_datetime_format</a></code>
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_datetime_fstr(x, ignore_special = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_datetime_fstr_+3A_x">x</code></td>
<td>
<p>character vector of date/time format strings</p>
</td></tr>
<tr><td><code id="stri_datetime_fstr_+3A_ignore_special">ignore_special</code></td>
<td>
<p>if <code>FALSE</code>, special identifiers like
<code>"datetime_full"</code> or <code>date_relative_short</code>
(see <code><a href="#topic+stri_datetime_format">stri_datetime_format</a></code>) are left as-is</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on conversion specifiers please refer to
the manual page of <code><a href="base.html#topic+strptime">strptime</a></code>. Most of the formatters
of the form <code>%x</code>, where <code>x</code> is a letter, are supported.
Moreover, each <code>%%</code> is replaced with <code>%</code>.
</p>
<p>Warnings are given in the case of <code>%x</code>, <code>%X</code>, <code>%u</code>,
<code>%w</code>, <code>%g</code>, <code>%G</code>, <code>%c</code>, <code>%U</code>, and <code>%W</code>
as in such circumstances either <span class="pkg">ICU</span> does not
support the functionality requested using the string format API
or there are some inconsistencies between base R and <span class="pkg">ICU</span>.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other datetime: 
<code><a href="#topic+stri_datetime_add">stri_datetime_add</a>()</code>,
<code><a href="#topic+stri_datetime_create">stri_datetime_create</a>()</code>,
<code><a href="#topic+stri_datetime_fields">stri_datetime_fields</a>()</code>,
<code><a href="#topic+stri_datetime_format">stri_datetime_format</a>()</code>,
<code><a href="#topic+stri_datetime_now">stri_datetime_now</a>()</code>,
<code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a>()</code>,
<code><a href="#topic+stri_timezone_get">stri_timezone_get</a>()</code>,
<code><a href="#topic+stri_timezone_info">stri_timezone_info</a>()</code>,
<code><a href="#topic+stri_timezone_list">stri_timezone_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_datetime_fstr('%Y-%m-%d %H:%M:%S')

</code></pre>

<hr>
<h2 id='stri_datetime_now'>Get Current Date and Time</h2><span id='topic+stri_datetime_now'></span>

<h3>Description</h3>

<p>Returns the current date and time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_datetime_now()
</code></pre>


<h3>Details</h3>

<p>The current date and time in <span class="pkg">stringi</span> is represented as the (signed)
number of seconds since 1970-01-01 00:00:00 UTC.
UTC leap seconds are ignored.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="base.html#topic+POSIXct">POSIXct</a></code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other datetime: 
<code><a href="#topic+stri_datetime_add">stri_datetime_add</a>()</code>,
<code><a href="#topic+stri_datetime_create">stri_datetime_create</a>()</code>,
<code><a href="#topic+stri_datetime_fields">stri_datetime_fields</a>()</code>,
<code><a href="#topic+stri_datetime_format">stri_datetime_format</a>()</code>,
<code><a href="#topic+stri_datetime_fstr">stri_datetime_fstr</a>()</code>,
<code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a>()</code>,
<code><a href="#topic+stri_timezone_get">stri_timezone_get</a>()</code>,
<code><a href="#topic+stri_timezone_info">stri_timezone_info</a>()</code>,
<code><a href="#topic+stri_timezone_list">stri_timezone_list</a>()</code>
</p>

<hr>
<h2 id='stri_datetime_symbols'>List Localizable Date-Time Formatting Data</h2><span id='topic+stri_datetime_symbols'></span>

<h3>Description</h3>

<p>Returns a list of all localizable date-time formatting data,
including month and weekday names, localized AM/PM strings, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_datetime_symbols(locale = NULL, context = "standalone", width = "wide")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_datetime_symbols_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for default locale,
or a single string with locale identifier</p>
</td></tr>
<tr><td><code id="stri_datetime_symbols_+3A_context">context</code></td>
<td>
<p>single string; one of: <code>'format'</code>, <code>'standalone'</code></p>
</td></tr>
<tr><td><code id="stri_datetime_symbols_+3A_width">width</code></td>
<td>
<p>single string; one of: <code>'abbreviated'</code>, <code>'wide'</code>, <code>'narrow'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>context</code> stands for a selector for date formatting context
and <code>width</code> - for date formatting width.
</p>


<h3>Value</h3>

<p>Returns a list with the following named components:
</p>

<ol>
<li> <p><code>Month</code> - month names,
</p>
</li>
<li> <p><code>Weekday</code> - weekday names,
</p>
</li>
<li> <p><code>Quarter</code> - quarter names,
</p>
</li>
<li> <p><code>AmPm</code> - AM/PM names,
</p>
</li>
<li> <p><code>Era</code> - era names.
</p>
</li></ol>



<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Calendar</em> - ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/datetime/calendar/">https://unicode-org.github.io/icu/userguide/datetime/calendar/</a>
</p>
<p><em>DateFormatSymbols</em> class &ndash; ICU API Documentation,
<a href="https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1DateFormatSymbols.html">https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1DateFormatSymbols.html</a>
</p>
<p><em>Formatting Dates and Times</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/format_parse/datetime/">https://unicode-org.github.io/icu/userguide/format_parse/datetime/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other datetime: 
<code><a href="#topic+stri_datetime_add">stri_datetime_add</a>()</code>,
<code><a href="#topic+stri_datetime_create">stri_datetime_create</a>()</code>,
<code><a href="#topic+stri_datetime_fields">stri_datetime_fields</a>()</code>,
<code><a href="#topic+stri_datetime_format">stri_datetime_format</a>()</code>,
<code><a href="#topic+stri_datetime_fstr">stri_datetime_fstr</a>()</code>,
<code><a href="#topic+stri_datetime_now">stri_datetime_now</a>()</code>,
<code><a href="#topic+stri_timezone_get">stri_timezone_get</a>()</code>,
<code><a href="#topic+stri_timezone_info">stri_timezone_info</a>()</code>,
<code><a href="#topic+stri_timezone_list">stri_timezone_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_datetime_symbols() # uses the Gregorian calendar in most locales
stri_datetime_symbols('@calendar=hebrew')
stri_datetime_symbols('he_IL@calendar=hebrew')
stri_datetime_symbols('@calendar=islamic')
stri_datetime_symbols('@calendar=persian')
stri_datetime_symbols('@calendar=indian')
stri_datetime_symbols('@calendar=coptic')
stri_datetime_symbols('@calendar=japanese')

stri_datetime_symbols('ja_JP_TRADITIONAL') # uses the Japanese calendar by default
stri_datetime_symbols('th_TH_TRADITIONAL') # uses the Buddhist calendar

stri_datetime_symbols('pl_PL', context='format')
stri_datetime_symbols('pl_PL', context='standalone')

stri_datetime_symbols(width='wide')
stri_datetime_symbols(width='abbreviated')
stri_datetime_symbols(width='narrow')

</code></pre>

<hr>
<h2 id='stri_detect'>Detect Pattern Occurrences</h2><span id='topic+stri_detect'></span><span id='topic+stri_detect_fixed'></span><span id='topic+stri_detect_charclass'></span><span id='topic+stri_detect_coll'></span><span id='topic+stri_detect_regex'></span>

<h3>Description</h3>

<p>These functions determine, for each string in <code>str</code>,
if there is at least one match to a corresponding <code>pattern</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_detect(str, ..., regex, fixed, coll, charclass)

stri_detect_fixed(
  str,
  pattern,
  negate = FALSE,
  max_count = -1,
  ...,
  opts_fixed = NULL
)

stri_detect_charclass(str, pattern, negate = FALSE, max_count = -1)

stri_detect_coll(
  str,
  pattern,
  negate = FALSE,
  max_count = -1,
  ...,
  opts_collator = NULL
)

stri_detect_regex(
  str,
  pattern,
  negate = FALSE,
  max_count = -1,
  ...,
  opts_regex = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_detect_+3A_str">str</code></td>
<td>
<p>character vector; strings to search in</p>
</td></tr>
<tr><td><code id="stri_detect_+3A_...">...</code></td>
<td>
<p>supplementary arguments passed to the underlying functions,
including additional settings for <code>opts_collator</code>, <code>opts_regex</code>,
<code>opts_fixed</code>, and so on</p>
</td></tr>
<tr><td><code id="stri_detect_+3A_pattern">pattern</code>, <code id="stri_detect_+3A_regex">regex</code>, <code id="stri_detect_+3A_fixed">fixed</code>, <code id="stri_detect_+3A_coll">coll</code>, <code id="stri_detect_+3A_charclass">charclass</code></td>
<td>
<p>character vector;
search patterns; for more details refer to <a href="#topic+stringi-search">stringi-search</a></p>
</td></tr>
<tr><td><code id="stri_detect_+3A_negate">negate</code></td>
<td>
<p>single logical value; whether a no-match to a pattern
is rather of interest</p>
</td></tr>
<tr><td><code id="stri_detect_+3A_max_count">max_count</code></td>
<td>
<p>single integer; allows to stop searching once a given
number of occurrences is detected; <code>-1</code> (the default) inspects all
elements</p>
</td></tr>
<tr><td><code id="stri_detect_+3A_opts_collator">opts_collator</code>, <code id="stri_detect_+3A_opts_fixed">opts_fixed</code>, <code id="stri_detect_+3A_opts_regex">opts_regex</code></td>
<td>
<p>a named list used to tune up
the search engine's settings; see
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code><a href="#topic+stri_opts_fixed">stri_opts_fixed</a></code>,
and <code><a href="#topic+stri_opts_regex">stri_opts_regex</a></code>, respectively; <code>NULL</code>
for the defaults</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code> and <code>pattern</code> (with recycling
of the elements in the shorter vector if necessary). This allows to,
for instance, search for one pattern in each given string,
search for each pattern in one given string,
and search for the i-th pattern within the i-th string.
</p>
<p>If <code>pattern</code> is empty, then the result is <code>NA</code>
and a warning is generated.
</p>
<p><code>stri_detect</code> is a convenience function.
It calls either <code>stri_detect_regex</code>,
<code>stri_detect_fixed</code>, <code>stri_detect_coll</code>,
or <code>stri_detect_charclass</code>, depending on the argument used.
</p>
<p>See also <code><a href="#topic+stri_startswith">stri_startswith</a></code> and <code><a href="#topic+stri_endswith">stri_endswith</a></code>
for testing whether a string starts or ends with a match to a given pattern.
Moreover, see <code><a href="#topic+stri_subset">stri_subset</a></code> for a character vector subsetting.
</p>
<p>If <code>max_count</code> is negative, then all stings are examined.
Otherwise, searching terminates
once <code>max_count</code> matches (or, if <code>negate</code> is <code>TRUE</code>,
no-matches) are detected. The uninspected cases are marked
as missing in the return vector. Be aware that, unless <code>pattern</code> is a
singleton, the elements in <code>str</code> might be inspected in a
non-consecutive order.
</p>


<h3>Value</h3>

<p>Each function returns a logical vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_detect: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_startswith">stri_startswith</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_detect_fixed(c('stringi R', 'R STRINGI', '123'), c('i', 'R', '0'))
stri_detect_fixed(c('stringi R', 'R STRINGI', '123'), 'R')

stri_detect_charclass(c('stRRRingi','R STRINGI', '123'),
   c('\\p{Ll}', '\\p{Lu}', '\\p{Zs}'))

stri_detect_regex(c('stringi R', 'R STRINGI', '123'), 'R.')
stri_detect_regex(c('stringi R', 'R STRINGI', '123'), '[[:alpha:]]*?')
stri_detect_regex(c('stringi R', 'R STRINGI', '123'), '[a-zC1]')
stri_detect_regex(c('stringi R', 'R STRINGI', '123'), '( R|RE)')
stri_detect_regex('stringi', 'STRING.', case_insensitive=TRUE)

stri_detect_regex(c('abc', 'def', '123', 'ghi', '456', '789', 'jkl'),
   '^[0-9]+$', max_count=1)
stri_detect_regex(c('abc', 'def', '123', 'ghi', '456', '789', 'jkl'),
   '^[0-9]+$', max_count=2)
stri_detect_regex(c('abc', 'def', '123', 'ghi', '456', '789', 'jkl'),
   '^[0-9]+$', negate=TRUE, max_count=3)

</code></pre>

<hr>
<h2 id='stri_dup'>Duplicate Strings</h2><span id='topic+stri_dup'></span><span id='topic+operator_multiply'></span><span id='topic+oper_multiply'></span><span id='topic++25s+2A+25'></span><span id='topic++25stri+2A+25'></span>

<h3>Description</h3>

<p>Duplicates each <code>str</code>(<code>e1</code>) string <code>times</code>(<code>e2</code>) times
and concatenates the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_dup(str, times)

e1 %s*% e2

e1 %stri*% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_dup_+3A_str">str</code>, <code id="stri_dup_+3A_e1">e1</code></td>
<td>
<p>a character vector of strings to be duplicated</p>
</td></tr>
<tr><td><code id="stri_dup_+3A_times">times</code>, <code id="stri_dup_+3A_e2">e2</code></td>
<td>
<p>an integer vector with the numbers of times to duplicate each string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over all arguments.
</p>
<p><code>e1 %s*% e2</code> and <code>e1 %stri*% e2</code> are synonyms
for <code>stri_dup(e1, e2)</code>
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other join: 
<code><a href="#topic++25s+2B+25">%s+%</a>()</code>,
<code><a href="#topic+stri_flatten">stri_flatten</a>()</code>,
<code><a href="#topic+stri_join_list">stri_join_list</a>()</code>,
<code><a href="#topic+stri_join">stri_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_dup('a', 1:5)
stri_dup(c('a', NA, 'ba'), 4)
stri_dup(c('abc', 'pqrst'), c(4, 2))
"a" %s*% 5
</code></pre>

<hr>
<h2 id='stri_duplicated'>Determine Duplicated Elements</h2><span id='topic+stri_duplicated'></span><span id='topic+stri_duplicated_any'></span>

<h3>Description</h3>

<p><code>stri_duplicated()</code> determines which strings in a character vector
are duplicates of other elements.
</p>
<p><code>stri_duplicated_any()</code> determines if there are any duplicated
strings in a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_duplicated(
  str,
  from_last = FALSE,
  fromLast = from_last,
  ...,
  opts_collator = NULL
)

stri_duplicated_any(
  str,
  from_last = FALSE,
  fromLast = from_last,
  ...,
  opts_collator = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_duplicated_+3A_str">str</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="stri_duplicated_+3A_from_last">from_last</code></td>
<td>
<p>a single logical value;
indicates whether search should be performed from the last to the
first string</p>
</td></tr>
<tr><td><code id="stri_duplicated_+3A_fromlast">fromLast</code></td>
<td>
<p>[DEPRECATED] alias of <code>from_last</code></p>
</td></tr>
<tr><td><code id="stri_duplicated_+3A_...">...</code></td>
<td>
<p>additional settings for <code>opts_collator</code></p>
</td></tr>
<tr><td><code id="stri_duplicated_+3A_opts_collator">opts_collator</code></td>
<td>
<p>a named list with <span class="pkg">ICU</span> Collator's options,
see <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code>NULL</code>
for default collation options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are regarded as equal.
</p>
<p>Unlike <code><a href="base.html#topic+duplicated">duplicated</a></code> and <code><a href="base.html#topic+anyDuplicated">anyDuplicated</a></code>,
these functions test for canonical equivalence of strings
(and not whether the strings are just bytewise equal)
Such operations are locale-dependent.
Hence, <code>stri_duplicated</code> and <code>stri_duplicated_any</code>
are significantly slower (but much better suited for natural language
processing) than their base R counterparts.
</p>
<p>See also <code><a href="#topic+stri_unique">stri_unique</a></code> for extracting unique elements.
</p>


<h3>Value</h3>

<p><code>stri_duplicated()</code> returns a logical vector of the same length
as <code>str</code>. Each of its elements indicates whether a canonically
equivalent string was already found in <code>str</code>.
</p>
<p><code>stri_duplicated_any()</code> returns a single non-negative integer.
Value of 0 indicates that all the elements in <code>str</code> are unique.
Otherwise, it gives the index of the first non-unique element.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Collation</em> - ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/collation/">https://unicode-org.github.io/icu/userguide/collation/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In the following examples, we have 3 duplicated values,
# 'a' - 2 times, NA - 1 time
stri_duplicated(c('a', 'b', 'a', NA, 'a', NA))
stri_duplicated(c('a', 'b', 'a', NA, 'a', NA), from_last=TRUE)
stri_duplicated_any(c('a', 'b', 'a', NA, 'a', NA))

# compare the results:
stri_duplicated(c('\u0105', stri_trans_nfkd('\u0105')))
duplicated(c('\u0105', stri_trans_nfkd('\u0105')))

stri_duplicated(c('gro\u00df', 'GROSS', 'Gro\u00df', 'Gross'), strength=1)
duplicated(c('gro\u00df', 'GROSS', 'Gro\u00df', 'Gross'))

</code></pre>

<hr>
<h2 id='stri_enc_detect'>Detect Character Set and Language</h2><span id='topic+stri_enc_detect'></span>

<h3>Description</h3>

<p>This function uses the <span class="pkg">ICU</span> engine to determine the character set,
or encoding, of character data in an unknown format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_detect(str, filter_angle_brackets = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_detect_+3A_str">str</code></td>
<td>
<p>character vector, a raw vector, or
a list of <code>raw</code> vectors</p>
</td></tr>
<tr><td><code id="stri_enc_detect_+3A_filter_angle_brackets">filter_angle_brackets</code></td>
<td>
<p>logical; If filtering is enabled,
text within angle brackets ('&lt;' and '&gt;') will be removed before detection,
which will remove most HTML or XML markup.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code> and <code>filter_angle_brackets</code>.
</p>
<p>For a character vector input, merging all text lines
via <code><a href="#topic+stri_flatten">stri_flatten</a>(str, collapse='\n')</code>
might be needed if <code>str</code> has been obtained via a call to
<code>readLines</code> and in fact represents an image of a single text file.
</p>
<p>This is, at best, an imprecise operation using statistics and heuristics.
Because of this, detection works best if you supply at least a few hundred
bytes of character data that is mostly in a single language.
However, because the detection only looks at a limited amount of the input
data, some of the returned character sets may fail to handle all of the
input data. Note that in some cases,
the language can be determined along with the encoding.
</p>
<p>Several different techniques are used for character set detection.
For multi-byte encodings, the sequence of bytes is checked for legible
patterns. The detected characters are also checked against a list of
frequently used characters in that encoding. For single byte encodings,
the data is checked against a list of the most commonly occurring three
letter groups for each language that can be written using that encoding.
</p>
<p>The detection process can be configured to optionally ignore
HTML or XML style markup (using <span class="pkg">ICU</span>'s internal facilities),
which can interfere with the detection
process by changing the statistics.
</p>
<p>This function should most often be used for byte-marked input strings,
especially after loading them from text files and before the main
conversion with <code><a href="#topic+stri_encode">stri_encode</a></code>.
The input encoding is of course not taken into account here, even
if marked.
</p>
<p>The following table shows all the encodings that can be detected:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Character_Set</strong> </td><td style="text-align: left;"> <strong>Languages</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
UTF-8 </td><td style="text-align: left;"> -- </td>
</tr>
<tr>
 <td style="text-align: left;">
UTF-16BE </td><td style="text-align: left;"> -- </td>
</tr>
<tr>
 <td style="text-align: left;">
UTF-16LE </td><td style="text-align: left;"> -- </td>
</tr>
<tr>
 <td style="text-align: left;">
UTF-32BE </td><td style="text-align: left;"> -- </td>
</tr>
<tr>
 <td style="text-align: left;">
UTF-32LE </td><td style="text-align: left;"> -- </td>
</tr>
<tr>
 <td style="text-align: left;">
Shift_JIS </td><td style="text-align: left;"> Japanese </td>
</tr>
<tr>
 <td style="text-align: left;">
ISO-2022-JP </td><td style="text-align: left;"> Japanese </td>
</tr>
<tr>
 <td style="text-align: left;">
ISO-2022-CN </td><td style="text-align: left;"> Simplified Chinese </td>
</tr>
<tr>
 <td style="text-align: left;">
ISO-2022-KR </td><td style="text-align: left;"> Korean </td>
</tr>
<tr>
 <td style="text-align: left;">
GB18030 </td><td style="text-align: left;"> Chinese </td>
</tr>
<tr>
 <td style="text-align: left;">
Big5 </td><td style="text-align: left;"> Traditional Chinese </td>
</tr>
<tr>
 <td style="text-align: left;">
EUC-JP </td><td style="text-align: left;"> Japanese </td>
</tr>
<tr>
 <td style="text-align: left;">
EUC-KR </td><td style="text-align: left;"> Korean </td>
</tr>
<tr>
 <td style="text-align: left;">
ISO-8859-1 </td><td style="text-align: left;"> Danish, Dutch, English, French, German, Italian, Norwegian, Portuguese, Swedish </td>
</tr>
<tr>
 <td style="text-align: left;">
ISO-8859-2 </td><td style="text-align: left;"> Czech, Hungarian, Polish, Romanian </td>
</tr>
<tr>
 <td style="text-align: left;">
ISO-8859-5 </td><td style="text-align: left;"> Russian </td>
</tr>
<tr>
 <td style="text-align: left;">
ISO-8859-6 </td><td style="text-align: left;"> Arabic </td>
</tr>
<tr>
 <td style="text-align: left;">
ISO-8859-7 </td><td style="text-align: left;"> Greek </td>
</tr>
<tr>
 <td style="text-align: left;">
ISO-8859-8 </td><td style="text-align: left;"> Hebrew </td>
</tr>
<tr>
 <td style="text-align: left;">
ISO-8859-9 </td><td style="text-align: left;"> Turkish </td>
</tr>
<tr>
 <td style="text-align: left;">
windows-1250 </td><td style="text-align: left;"> Czech, Hungarian, Polish, Romanian </td>
</tr>
<tr>
 <td style="text-align: left;">
windows-1251 </td><td style="text-align: left;"> Russian </td>
</tr>
<tr>
 <td style="text-align: left;">
windows-1252 </td><td style="text-align: left;"> Danish, Dutch, English, French, German, Italian, Norwegian, Portuguese, Swedish </td>
</tr>
<tr>
 <td style="text-align: left;">
windows-1253 </td><td style="text-align: left;"> Greek </td>
</tr>
<tr>
 <td style="text-align: left;">
windows-1254 </td><td style="text-align: left;"> Turkish </td>
</tr>
<tr>
 <td style="text-align: left;">
windows-1255 </td><td style="text-align: left;"> Hebrew </td>
</tr>
<tr>
 <td style="text-align: left;">
windows-1256 </td><td style="text-align: left;"> Arabic </td>
</tr>
<tr>
 <td style="text-align: left;">
KOI8-R </td><td style="text-align: left;"> Russian </td>
</tr>
<tr>
 <td style="text-align: left;">
IBM420 </td><td style="text-align: left;"> Arabic </td>
</tr>
<tr>
 <td style="text-align: left;">
IBM424 </td><td style="text-align: left;"> Hebrew </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Returns a list of length equal to the length of <code>str</code>.
Each list element is a data frame with the following three named vectors
representing all the guesses:
</p>

<ul>
<li> <p><code>Encoding</code> &ndash; string; guessed encodings; <code>NA</code> on failure,
</p>
</li>
<li> <p><code>Language</code> &ndash; string; guessed languages; <code>NA</code> if the language could
not be determined (e.g., in case of UTF-8),
</p>
</li>
<li> <p><code>Confidence</code> &ndash; numeric in [0,1]; the higher the value,
the more confidence there is in the match; <code>NA</code> on failure.
</p>
</li></ul>

<p>The guesses are ordered by decreasing confidence.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Character Set Detection</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/conversion/detection.html">https://unicode-org.github.io/icu/userguide/conversion/detection.html</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_detection: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_enc_isascii">stri_enc_isascii</a>()</code>,
<code><a href="#topic+stri_enc_isutf16be">stri_enc_isutf16be</a>()</code>,
<code><a href="#topic+stri_enc_isutf8">stri_enc_isutf8</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:
## f &lt;- rawToChar(readBin('test.txt', 'raw', 100000))
## stri_enc_detect(f)

</code></pre>

<hr>
<h2 id='stri_enc_detect2'>[DEPRECATED] Detect Locale-Sensitive Character Encoding</h2><span id='topic+stri_enc_detect2'></span>

<h3>Description</h3>

<p>This function tries to detect character encoding
in case the language of text is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_detect2(str, locale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_detect2_+3A_str">str</code></td>
<td>
<p>character vector, a raw vector, or
a list of <code>raw</code> vectors</p>
</td></tr>
<tr><td><code id="stri_enc_detect2_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for the default locale,
or a single string with locale identifier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code>.
</p>
<p>First, the text is checked whether it is valid
UTF-32BE, UTF-32LE, UTF-16BE, UTF-16LE, UTF-8
(as in <code><a href="#topic+stri_enc_detect">stri_enc_detect</a></code>,
this is roughly inspired by <span class="pkg">ICU</span>'s <code>i18n/csrucode.cpp</code>) or ASCII.
</p>
<p>If <code>locale</code> is not <code>NA</code> and the above fails,
the text is checked for the number of occurrences
of language-specific code points (data provided by the <span class="pkg">ICU</span> library)
converted to all possible 8-bit encodings
that fully cover the indicated language.
The encoding is selected based on the greatest number of total
byte hits.
</p>
<p>The guess is of course imprecise,
as it is obtained using statistics and heuristics.
Because of this, detection works best if you supply at least a few hundred
bytes of character data that is in a single language.
</p>
<p>If you have no initial guess on the language and encoding, try with
<code><a href="#topic+stri_enc_detect">stri_enc_detect</a></code> (uses <span class="pkg">ICU</span> facilities).
</p>


<h3>Value</h3>

<p>Just like <code><a href="#topic+stri_enc_detect">stri_enc_detect</a></code>,
this function returns a list of length equal to the length of <code>str</code>.
Each list element is a data frame with the following three named components:
</p>

<ul>
<li> <p><code>Encoding</code> &ndash; string; guessed encodings; <code>NA</code> on failure
(if and only if <code>encodings</code> is empty),
</p>
</li>
<li> <p><code>Language</code> &ndash; always <code>NA</code>,
</p>
</li>
<li> <p><code>Confidence</code> &ndash; numeric in [0,1]; the higher the value,
the more confidence there is in the match; <code>NA</code> on failure.
</p>
</li></ul>

<p>The guesses are ordered by decreasing confidence.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>
<p>Other encoding_detection: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_detect">stri_enc_detect</a>()</code>,
<code><a href="#topic+stri_enc_isascii">stri_enc_isascii</a>()</code>,
<code><a href="#topic+stri_enc_isutf16be">stri_enc_isutf16be</a>()</code>,
<code><a href="#topic+stri_enc_isutf8">stri_enc_isutf8</a>()</code>
</p>

<hr>
<h2 id='stri_enc_fromutf32'>Convert From UTF-32</h2><span id='topic+stri_enc_fromutf32'></span>

<h3>Description</h3>

<p>This function converts integer vectors,
representing sequences of UTF-32 code points, to UTF-8 strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_fromutf32(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_fromutf32_+3A_vec">vec</code></td>
<td>
<p>a list of integer vectors (or objects coercible to such vectors)
or <code>NULL</code>s. For convenience, a single integer vector can also
be given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>UTF-32 is a 32-bit encoding where each Unicode code point
corresponds to exactly one integer value.
</p>
<p>This function is a vectorized version of
<code><a href="base.html#topic+intToUtf8">intToUtf8</a></code>. As usual in <span class="pkg">stringi</span>,
it returns character strings in UTF-8.
See <code><a href="#topic+stri_enc_toutf32">stri_enc_toutf32</a></code> for a dual operation.
</p>
<p>If an ill-defined code point is given, a warning is generated
and the corresponding string is set to <code>NA</code>.
Note that <code>0</code>s are not allowed in <code>vec</code>, as they are used
internally to mark the end of a string (in the C API).
</p>
<p>See also <code><a href="#topic+stri_encode">stri_encode</a></code> for decoding arbitrary byte sequences
from any given encoding.
</p>


<h3>Value</h3>

<p>Returns a character vector (in UTF-8).
<code>NULL</code>s in the input list are converted to <code>NA_character_</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_conversion: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_toascii">stri_enc_toascii</a>()</code>,
<code><a href="#topic+stri_enc_tonative">stri_enc_tonative</a>()</code>,
<code><a href="#topic+stri_enc_toutf32">stri_enc_toutf32</a>()</code>,
<code><a href="#topic+stri_enc_toutf8">stri_enc_toutf8</a>()</code>,
<code><a href="#topic+stri_encode">stri_encode</a>()</code>
</p>

<hr>
<h2 id='stri_enc_info'>Query a Character Encoding</h2><span id='topic+stri_enc_info'></span>

<h3>Description</h3>

<p>Gets basic information on a character encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_info(enc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_info_+3A_enc">enc</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for the default encoding,
or a single string with encoding name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An error is raised if the provided encoding is unknown to <span class="pkg">ICU</span>
(see <code><a href="#topic+stri_enc_list">stri_enc_list</a></code> for more details).
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>

<ul>
<li> <p><code>Name.friendly</code> &ndash; friendly encoding name:
MIME Name or JAVA Name or <span class="pkg">ICU</span> Canonical Name
(the first of provided ones is selected, see below);
</p>
</li>
<li> <p><code>Name.ICU</code> &ndash; encoding name as identified by <span class="pkg">ICU</span>;
</p>
</li>
<li> <p><code>Name.*</code> &ndash; other standardized encoding names,
e.g., <code>Name.UTR22</code>, <code>Name.IBM</code>, <code>Name.WINDOWS</code>,
<code>Name.JAVA</code>, <code>Name.IANA</code>, <code>Name.MIME</code> (some of them
may be unavailable for all the encodings);
</p>
</li>
<li> <p><code>ASCII.subset</code> &ndash; is ASCII a subset of the given encoding?;
</p>
</li>
<li> <p><code>Unicode.1to1</code> &ndash; for 8-bit encodings only: are all characters
translated to exactly one Unicode code point and is the translation
scheme reversible?;
</p>
</li>
<li> <p><code>CharSize.8bit</code> &ndash; is this an 8-bit encoding, i.e., do we have
<code>CharSize.min == CharSize.max</code> and <code>CharSize.min == 1</code>?;
</p>
</li>
<li> <p><code>CharSize.min</code> &ndash; minimal number of bytes used
to represent a UChar (in UTF-16, this is not the same as UChar32)
</p>
</li>
<li> <p><code>CharSize.max</code> &ndash; maximal number of bytes used
to represent a UChar (in UTF-16, this is not the same as UChar32,
i.e., does not reflect the maximal code point representation size)
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_management: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_list">stri_enc_list</a>()</code>,
<code><a href="#topic+stri_enc_mark">stri_enc_mark</a>()</code>,
<code><a href="#topic+stri_enc_set">stri_enc_set</a>()</code>
</p>

<hr>
<h2 id='stri_enc_isascii'>Check If a Data Stream Is Possibly in ASCII</h2><span id='topic+stri_enc_isascii'></span>

<h3>Description</h3>

<p>The function checks whether all bytes in a string are &lt;= 127.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_isascii(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_isascii_+3A_str">str</code></td>
<td>
<p>character vector, a raw vector, or
a list of <code>raw</code> vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is independent of the way <span class="rlang"><b>R</b></span> marks encodings in
character strings (see <a href="base.html#topic+Encoding">Encoding</a> and <a href="#topic+stringi-encoding">stringi-encoding</a>).
</p>


<h3>Value</h3>

<p>Returns a logical vector.
The i-th element indicates whether the i-th string
corresponds to a valid ASCII byte sequence.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_detection: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_enc_detect">stri_enc_detect</a>()</code>,
<code><a href="#topic+stri_enc_isutf16be">stri_enc_isutf16be</a>()</code>,
<code><a href="#topic+stri_enc_isutf8">stri_enc_isutf8</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_enc_isascii(letters[1:3])
stri_enc_isascii('\u0105\u0104')

</code></pre>

<hr>
<h2 id='stri_enc_isutf16be'>Check If a Data Stream Is Possibly in UTF-16 or UTF-32</h2><span id='topic+stri_enc_isutf16be'></span><span id='topic+stri_enc_isutf16le'></span><span id='topic+stri_enc_isutf32be'></span><span id='topic+stri_enc_isutf32le'></span>

<h3>Description</h3>

<p>These functions detect whether a given byte stream is
valid UTF-16LE, UTF-16BE, UTF-32LE, or UTF-32BE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_isutf16be(str)

stri_enc_isutf16le(str)

stri_enc_isutf32be(str)

stri_enc_isutf32le(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_isutf16be_+3A_str">str</code></td>
<td>
<p>character vector, a raw vector, or
a list of <code>raw</code> vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are independent of the way <span class="rlang"><b>R</b></span> marks encodings in
character strings (see <a href="base.html#topic+Encoding">Encoding</a> and <a href="#topic+stringi-encoding">stringi-encoding</a>).
Most often, these functions act on raw vectors.
</p>
<p>A result of <code>FALSE</code> means that a string is surely not valid UTF-16
or UTF-32. However, false positives are possible.
</p>
<p>Also note that a data stream may be sometimes classified
as both valid UTF-16LE and UTF-16BE.
</p>


<h3>Value</h3>

<p>Returns a logical vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_detection: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_enc_detect">stri_enc_detect</a>()</code>,
<code><a href="#topic+stri_enc_isascii">stri_enc_isascii</a>()</code>,
<code><a href="#topic+stri_enc_isutf8">stri_enc_isutf8</a>()</code>
</p>

<hr>
<h2 id='stri_enc_isutf8'>Check If a Data Stream Is Possibly in UTF-8</h2><span id='topic+stri_enc_isutf8'></span>

<h3>Description</h3>

<p>The function checks whether given sequences of bytes forms
a proper UTF-8 string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_isutf8(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_isutf8_+3A_str">str</code></td>
<td>
<p>character vector, a raw vector, or
a list of <code>raw</code> vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FALSE</code> means that a string is certainly not valid UTF-8.
However, false positives are possible. For instance,
<code>(c4,85)</code> represents ('a with ogonek') in UTF-8
as well as ('A umlaut', 'Ellipsis') in WINDOWS-1250.
Also note that UTF-8, as well as most 8-bit encodings, extend ASCII
(note that <code><a href="#topic+stri_enc_isascii">stri_enc_isascii</a></code> implies that
<code><a href="#topic+stri_enc_isutf8">stri_enc_isutf8</a></code>).
</p>
<p>However, the longer the sequence,
the greater the possibility that the result
is indeed in UTF-8 &ndash; this is because not all sequences of bytes
are valid UTF-8.
</p>
<p>This function is independent of the way <span class="rlang"><b>R</b></span> marks encodings in
character strings (see <a href="base.html#topic+Encoding">Encoding</a> and <a href="#topic+stringi-encoding">stringi-encoding</a>).
</p>


<h3>Value</h3>

<p>Returns a logical vector.
Its i-th element indicates whether the i-th string
corresponds to a valid UTF-8 byte sequence.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_detection: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_enc_detect">stri_enc_detect</a>()</code>,
<code><a href="#topic+stri_enc_isascii">stri_enc_isascii</a>()</code>,
<code><a href="#topic+stri_enc_isutf16be">stri_enc_isutf16be</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_enc_isutf8(letters[1:3])
stri_enc_isutf8('\u0105\u0104')
stri_enc_isutf8('\u1234\u0222')

</code></pre>

<hr>
<h2 id='stri_enc_list'>List Known Character Encodings</h2><span id='topic+stri_enc_list'></span>

<h3>Description</h3>

<p>Gives the list of encodings that are supported by <span class="pkg">ICU</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_list(simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_list_+3A_simplify">simplify</code></td>
<td>
<p>single logical value; return a character vector or a
list of character vectors?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apart from given encoding identifiers and their aliases,
some other specifiers might additionally be available.
This is due to the fact that <span class="pkg">ICU</span> tries to normalize
converter names. For instance, <code>'UTF8'</code> is also valid,
see <a href="#topic+stringi-encoding">stringi-encoding</a> for more information.
</p>


<h3>Value</h3>

<p>If <code>simplify</code> is <code>FALSE</code>, a list of
character vectors is returned. Each list element represents a unique
character encoding. The <code>name</code> attribute gives the <span class="pkg">ICU</span> Canonical
Name of an encoding family. The elements (character vectors) are
its aliases.
</p>
<p>If <code>simplify</code> is <code>TRUE</code> (the default), then the resulting list
is coerced to a character vector and sorted, and returned with
removed duplicated entries.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_management: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_info">stri_enc_info</a>()</code>,
<code><a href="#topic+stri_enc_mark">stri_enc_mark</a>()</code>,
<code><a href="#topic+stri_enc_set">stri_enc_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_enc_list()
stri_enc_list(FALSE)

</code></pre>

<hr>
<h2 id='stri_enc_mark'>Get Declared Encodings of Each String</h2><span id='topic+stri_enc_mark'></span>

<h3>Description</h3>

<p>Reads declared encodings for each string in a character vector
as seen by <span class="pkg">stringi</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_mark(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_mark_+3A_str">str</code></td>
<td>
<p>character vector
or an object coercible to a character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to <code><a href="base.html#topic+Encoding">Encoding</a></code>,
<span class="rlang"><b>R</b></span> has a simple encoding marking mechanism:
strings can be declared to be in <code>latin1</code>,
<code>UTF-8</code> or <code>bytes</code>.
</p>
<p>Moreover, we may check (via the R/C API) whether
a string is in ASCII (<span class="rlang"><b>R</b></span> assumes that this holds if and only if
all bytes in a string are not greater than 127,
so there is an implicit assumption that your platform uses
an encoding that extends ASCII)
or in the system's default (a.k.a. <code>unknown</code> in <code><a href="base.html#topic+Encoding">Encoding</a></code>)
encoding.
</p>
<p>Intuitively, the default encoding should be equivalent to
the one you use on <code>stdin</code> (e.g., your 'keyboard').
In <span class="pkg">stringi</span> we assume that such an encoding
is equivalent to the one returned by <code><a href="#topic+stri_enc_get">stri_enc_get</a></code>.
It is automatically detected by <span class="pkg">ICU</span>
to match &ndash; by default &ndash; the encoding part of the <code>LC_CTYPE</code> category
as given by <code><a href="base.html#topic+Sys.getlocale">Sys.getlocale</a></code>.
</p>


<h3>Value</h3>

<p>Returns a character vector of the same length as <code>str</code>.
Unlike in the <code><a href="base.html#topic+Encoding">Encoding</a></code> function, here the possible encodings are:
<code>ASCII</code>, <code>latin1</code>, <code>bytes</code>, <code>native</code>,
and <code>UTF-8</code>. Additionally, missing values are handled properly.
</p>
<p>This gives exactly the same data that is used by
all the functions in <span class="pkg">stringi</span> to re-encode their inputs.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_management: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_info">stri_enc_info</a>()</code>,
<code><a href="#topic+stri_enc_list">stri_enc_list</a>()</code>,
<code><a href="#topic+stri_enc_set">stri_enc_set</a>()</code>
</p>

<hr>
<h2 id='stri_enc_set'>Set or Get Default Character Encoding in <span class="pkg">stringi</span></h2><span id='topic+stri_enc_set'></span><span id='topic+stri_enc_get'></span>

<h3>Description</h3>

<p><code>stri_enc_set</code> sets the encoding used to re-encode strings
internally (i.e., by <span class="rlang"><b>R</b></span>) declared to be in native encoding,
see <a href="#topic+stringi-encoding">stringi-encoding</a> and <code><a href="#topic+stri_enc_mark">stri_enc_mark</a></code>.
<code>stri_enc_get</code> returns the currently used default encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_set(enc)

stri_enc_get()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_set_+3A_enc">enc</code></td>
<td>
<p>single string; character encoding name,
see <code><a href="#topic+stri_enc_list">stri_enc_list</a></code> for the list of supported encodings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stri_enc_get</code> is the same as
<code><a href="#topic+stri_enc_info">stri_enc_info</a>(NULL)$Name.friendly</code>.
</p>
<p>Note that changing the default encoding may have undesired consequences.
Unless you are an expert user and you know what you are doing,
<code>stri_enc_set</code> should only be used if <span class="pkg">ICU</span> fails to detect
your system's encoding correctly (while testing <span class="pkg">stringi</span>
we only encountered such a situation on a very old Solaris machine).
Note that <span class="pkg">ICU</span> tries to match the encoding part of the <code>LC_CTYPE</code>
category as given by <code><a href="base.html#topic+Sys.getlocale">Sys.getlocale</a></code>.
</p>
<p>If you set a default encoding that is neither a superset of ASCII,
nor an 8-bit encoding, a warning will be generated,
see <a href="#topic+stringi-encoding">stringi-encoding</a> for discussion.
</p>
<p><code>stri_enc_set</code> has no effect if the system ICU assumes that
the default charset is always UTF-8 (i.e., where the internal
<code>U_CHARSET_IS_UTF8</code> is defined and set to 1), see
<code><a href="#topic+stri_info">stri_info</a></code>.
</p>


<h3>Value</h3>

<p><code>stri_enc_set</code> returns a string with
previously used character encoding, invisibly.
</p>
<p><code>stri_enc_get</code> returns a string with current default character
encoding.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_management: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_info">stri_enc_info</a>()</code>,
<code><a href="#topic+stri_enc_list">stri_enc_list</a>()</code>,
<code><a href="#topic+stri_enc_mark">stri_enc_mark</a>()</code>
</p>

<hr>
<h2 id='stri_enc_toascii'>Convert To ASCII</h2><span id='topic+stri_enc_toascii'></span>

<h3>Description</h3>

<p>This function converts input strings to ASCII,
i.e., to character strings consisting of bytes not greater than 127.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_toascii(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_toascii_+3A_str">str</code></td>
<td>
<p>a character vector to be converted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All code points greater than 127 are replaced with the ASCII SUBSTITUTE
CHARACTER (0x1A).
<span class="rlang"><b>R</b></span> encoding declarations are always used to determine
which encoding is assumed for each input, see <code><a href="#topic+stri_enc_mark">stri_enc_mark</a></code>.
If ill-formed byte sequences are found in UTF-8 byte
streams, a warning is generated.
</p>
<p>A <code>bytes</code>-marked string is assumed to be in an 8-bit encoding
extending the ASCII map (a common assumption in <span class="rlang"><b>R</b></span> itself).
</p>
<p>Note that the SUBSTITUTE CHARACTER (<code>\x1a == \032</code>) may be interpreted
as the ASCII missing value for single characters.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_conversion: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_fromutf32">stri_enc_fromutf32</a>()</code>,
<code><a href="#topic+stri_enc_tonative">stri_enc_tonative</a>()</code>,
<code><a href="#topic+stri_enc_toutf32">stri_enc_toutf32</a>()</code>,
<code><a href="#topic+stri_enc_toutf8">stri_enc_toutf8</a>()</code>,
<code><a href="#topic+stri_encode">stri_encode</a>()</code>
</p>

<hr>
<h2 id='stri_enc_tonative'>Convert Strings To Native Encoding</h2><span id='topic+stri_enc_tonative'></span>

<h3>Description</h3>

<p>Converts character strings with declared encodings
to the current native encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_tonative(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_tonative_+3A_str">str</code></td>
<td>
<p>a character vector to be converted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function just calls <code><a href="#topic+stri_encode">stri_encode</a>(str, NULL, NULL)</code>.
The current native encoding can be read with <code><a href="#topic+stri_enc_get">stri_enc_get</a></code>.
Character strings declared to be in <code>bytes</code> encoding will fail here.
</p>
<p>Note that if working in a UTF-8 environment,
resulting strings will be marked with <code>UTF-8</code>
and not <code>native</code>, see <code><a href="#topic+stri_enc_mark">stri_enc_mark</a></code>.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_conversion: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_fromutf32">stri_enc_fromutf32</a>()</code>,
<code><a href="#topic+stri_enc_toascii">stri_enc_toascii</a>()</code>,
<code><a href="#topic+stri_enc_toutf32">stri_enc_toutf32</a>()</code>,
<code><a href="#topic+stri_enc_toutf8">stri_enc_toutf8</a>()</code>,
<code><a href="#topic+stri_encode">stri_encode</a>()</code>
</p>

<hr>
<h2 id='stri_enc_toutf32'>Convert Strings To UTF-32</h2><span id='topic+stri_enc_toutf32'></span>

<h3>Description</h3>

<p>UTF-32 is a 32-bit encoding where each Unicode code point
corresponds to exactly one integer value.
This function converts a character vector to a list
of integer vectors so that, e.g.,
individual code points may be easily accessed, changed, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_toutf32(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_toutf32_+3A_str">str</code></td>
<td>
<p>a character vector (or an object coercible to)
to be converted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+stri_enc_fromutf32">stri_enc_fromutf32</a></code> for a dual operation.
</p>
<p>This function is roughly equivalent to a vectorized call
to <code><a href="base.html#topic+utf8ToInt">utf8ToInt</a>(enc2utf8(str))</code>.
If you want a list of raw vectors on output,
use <code><a href="#topic+stri_encode">stri_encode</a></code>.
</p>
<p>Unlike <code>utf8ToInt</code>, if ill-formed UTF-8 byte sequences are detected,
a corresponding element is set to NULL and a warning is generated.
To deal with such issues, use, e.g., <code><a href="#topic+stri_enc_toutf8">stri_enc_toutf8</a></code>.
</p>


<h3>Value</h3>

<p>Returns a list of integer vectors.
Missing values are converted to <code>NULL</code>s.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_conversion: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_fromutf32">stri_enc_fromutf32</a>()</code>,
<code><a href="#topic+stri_enc_toascii">stri_enc_toascii</a>()</code>,
<code><a href="#topic+stri_enc_tonative">stri_enc_tonative</a>()</code>,
<code><a href="#topic+stri_enc_toutf8">stri_enc_toutf8</a>()</code>,
<code><a href="#topic+stri_encode">stri_encode</a>()</code>
</p>

<hr>
<h2 id='stri_enc_toutf8'>Convert Strings To UTF-8</h2><span id='topic+stri_enc_toutf8'></span>

<h3>Description</h3>

<p>Converts character strings with declared marked encodings
to UTF-8 strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_enc_toutf8(str, is_unknown_8bit = FALSE, validate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_enc_toutf8_+3A_str">str</code></td>
<td>
<p>a character vector to be converted</p>
</td></tr>
<tr><td><code id="stri_enc_toutf8_+3A_is_unknown_8bit">is_unknown_8bit</code></td>
<td>
<p>a single logical value, see Details</p>
</td></tr>
<tr><td><code id="stri_enc_toutf8_+3A_validate">validate</code></td>
<td>
<p>a single logical value (can be <code>NA</code>), see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>is_unknown_8bit</code> is set to <code>FALSE</code> (the default),
then R encoding marks are used, see <code><a href="#topic+stri_enc_mark">stri_enc_mark</a></code>.
Bytes-marked strings will cause the function to fail.
</p>
<p>If a string is in UTF-8 and has a byte order mark (BOM),
then the BOM will be silently removed from the output string.
</p>
<p>If the default encoding is UTF-8, see <code><a href="#topic+stri_enc_get">stri_enc_get</a></code>,
then strings marked with <code>native</code> are &ndash; for efficiency reasons &ndash;
returned as-is, i.e., with unchanged markings.
A similar behavior is observed when calling <code><a href="base.html#topic+enc2utf8">enc2utf8</a></code>.
</p>
<p>For <code>is_unknown_8bit=TRUE</code>, if a string is declared to be neither
in ASCII nor in UTF-8, then all byte codes &gt; 127 are replaced with
the Unicode REPLACEMENT CHARACTER (\Ufffd).
Note that the REPLACEMENT CHARACTER may be interpreted as Unicode
missing value for single characters.
Here a <code>bytes</code>-marked string is assumed to use an 8-bit encoding
that extends the ASCII map.
</p>
<p>What is more, setting <code>validate</code> to <code>TRUE</code>
or <code>NA</code> in both cases validates the resulting UTF-8 byte stream.
If <code>validate=TRUE</code>, then
in case of any incorrect byte sequences, they will be
replaced with the REPLACEMENT CHARACTER.
This option may be used in a case
where you want to fix an invalid UTF-8 byte sequence.
For <code>NA</code>, a bogus string will be replaced with a missing value.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_conversion: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_fromutf32">stri_enc_fromutf32</a>()</code>,
<code><a href="#topic+stri_enc_toascii">stri_enc_toascii</a>()</code>,
<code><a href="#topic+stri_enc_tonative">stri_enc_tonative</a>()</code>,
<code><a href="#topic+stri_enc_toutf32">stri_enc_toutf32</a>()</code>,
<code><a href="#topic+stri_encode">stri_encode</a>()</code>
</p>

<hr>
<h2 id='stri_encode'>Convert Strings Between Given Encodings</h2><span id='topic+stri_encode'></span><span id='topic+stri_conv'></span>

<h3>Description</h3>

<p>These functions convert strings between encodings.
They aim to serve as a more portable and faster replacement
for <span class="rlang"><b>R</b></span>'s own <code><a href="base.html#topic+iconv">iconv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_encode(str, from = NULL, to = NULL, to_raw = FALSE)

stri_conv(str, from = NULL, to = NULL, to_raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_encode_+3A_str">str</code></td>
<td>
<p>a character vector, a raw vector, or
a list of <code>raw</code> vectors to be converted</p>
</td></tr>
<tr><td><code id="stri_encode_+3A_from">from</code></td>
<td>
<p>input encoding:
<code>NULL</code> or <code>''</code> for the default encoding
or internal encoding marks' usage (see Details);
otherwise, a single string with encoding name,
see <code><a href="#topic+stri_enc_list">stri_enc_list</a></code></p>
</td></tr>
<tr><td><code id="stri_encode_+3A_to">to</code></td>
<td>
<p>target encoding:
<code>NULL</code> or <code>''</code> for default encoding
(see <code><a href="#topic+stri_enc_get">stri_enc_get</a></code>),
or a single string with encoding name</p>
</td></tr>
<tr><td><code id="stri_encode_+3A_to_raw">to_raw</code></td>
<td>
<p>a single logical value; indicates whether a list of raw vectors
rather than a character vector should be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stri_conv</code> is an alias for <code>stri_encode</code>.
</p>
<p>Refer to <code><a href="#topic+stri_enc_list">stri_enc_list</a></code> for the list
of supported encodings and <a href="#topic+stringi-encoding">stringi-encoding</a>
for a general discussion.
</p>
<p>If <code>from</code> is either missing, <code>''</code>, or <code>NULL</code>,
and if <code>str</code> is a character vector
then the marked encodings are used
(see <code><a href="#topic+stri_enc_mark">stri_enc_mark</a></code>) &ndash; in such a case <code>bytes</code>-declared
strings are disallowed.
Otherwise, i.e., if <code>str</code> is a <code>raw</code>-type vector
or a list of raw vectors,
we assume that the input encoding is the current default encoding
as given by <code><a href="#topic+stri_enc_get">stri_enc_get</a></code>.
</p>
<p>However, if <code>from</code> is given explicitly,
the internal encoding declarations are always ignored.
</p>
<p>For <code>to_raw=FALSE</code>, the output
strings always have the encodings marked according to the target converter
used (as specified by <code>to</code>) and the current default Encoding
(<code>ASCII</code>, <code>latin1</code>, <code>UTF-8</code>, <code>native</code>,
or <code>bytes</code> in all other cases).
</p>
<p>Note that some issues might occur if <code>to</code> indicates, e.g,
UTF-16 or UTF-32, as the output strings may have embedded NULs.
In such cases, please use <code>to_raw=TRUE</code> and consider
specifying a byte order marker (BOM) for portability reasons
(e.g., set <code>UTF-16</code> or <code>UTF-32</code> which automatically
adds the BOMs).
</p>
<p>Note that <code>stri_encode(as.raw(data), 'encodingname')</code>
is a clever substitute for <code><a href="base.html#topic+rawToChar">rawToChar</a></code>.
</p>
<p>In the current version of <span class="pkg">stringi</span>, if an incorrect code point is found
on input, it is replaced with the default (for that target encoding)
'missing/erroneous' character (with a warning), e.g.,
the SUBSTITUTE character (U+001A) or the REPLACEMENT one (U+FFFD).
Occurrences thereof can be located in the output string to diagnose
the problematic sequences, e.g., by calling:
<code>stri_locate_all_regex(converted_string, '[\ufffd\u001a]'</code>.
</p>
<p>Because of the way this function is currently implemented,
maximal size of a single string to be converted cannot exceed ~0.67 GB.
</p>


<h3>Value</h3>

<p>If <code>to_raw</code> is <code>FALSE</code>,
then a character vector with encoded strings (and appropriate
encoding marks) is returned.
Otherwise, a list of vectors of type raw is produced.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Conversion</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/conversion/">https://unicode-org.github.io/icu/userguide/conversion/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other encoding_conversion: 
<code><a href="#topic+about_encoding">about_encoding</a></code>,
<code><a href="#topic+stri_enc_fromutf32">stri_enc_fromutf32</a>()</code>,
<code><a href="#topic+stri_enc_toascii">stri_enc_toascii</a>()</code>,
<code><a href="#topic+stri_enc_tonative">stri_enc_tonative</a>()</code>,
<code><a href="#topic+stri_enc_toutf32">stri_enc_toutf32</a>()</code>,
<code><a href="#topic+stri_enc_toutf8">stri_enc_toutf8</a>()</code>
</p>

<hr>
<h2 id='stri_escape_unicode'>Escape Unicode Code Points</h2><span id='topic+stri_escape_unicode'></span>

<h3>Description</h3>

<p>Generates an ASCII string where all non-printable characters
and non-ASCII characters are converted to escape sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_escape_unicode(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_escape_unicode_+3A_str">str</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For non-printable and certain special (well-known,
see also the R man page <a href="base.html#topic+Quotes">Quotes</a>)
ASCII characters, the following
(also recognized in R) convention is used.
We get <code>\a</code>, <code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\v</code>,
<code>\f</code>, <code>\r</code>, <code>\"</code>, <code>\'</code>, <code>\\</code>
or either <code>\uXXXX</code> (4 hex digits) or <code>\UXXXXXXXX</code> (8 hex digits)
otherwise.
</p>
<p>As usual in stringi, any input string is converted to Unicode
before executing the escape process.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other escape: 
<code><a href="#topic+stri_unescape_unicode">stri_unescape_unicode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_escape_unicode('a\u0105!')

</code></pre>

<hr>
<h2 id='stri_extract_all'>Extract Pattern Occurrences</h2><span id='topic+stri_extract_all'></span><span id='topic+stri_extract_first'></span><span id='topic+stri_extract_last'></span><span id='topic+stri_extract'></span><span id='topic+stri_extract_all_charclass'></span><span id='topic+stri_extract_first_charclass'></span><span id='topic+stri_extract_last_charclass'></span><span id='topic+stri_extract_all_coll'></span><span id='topic+stri_extract_first_coll'></span><span id='topic+stri_extract_last_coll'></span><span id='topic+stri_extract_all_regex'></span><span id='topic+stri_extract_first_regex'></span><span id='topic+stri_extract_last_regex'></span><span id='topic+stri_extract_all_fixed'></span><span id='topic+stri_extract_first_fixed'></span><span id='topic+stri_extract_last_fixed'></span>

<h3>Description</h3>

<p>These functions extract all substrings matching a given pattern.
</p>
<p><code>stri_extract_all_*</code> extracts all the matches.
<code>stri_extract_first_*</code> and <code>stri_extract_last_*</code>
yield the first or the last matches, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_extract_all(str, ..., regex, fixed, coll, charclass)

stri_extract_first(str, ..., regex, fixed, coll, charclass)

stri_extract_last(str, ..., regex, fixed, coll, charclass)

stri_extract(
  str,
  ...,
  regex,
  fixed,
  coll,
  charclass,
  mode = c("first", "all", "last")
)

stri_extract_all_charclass(
  str,
  pattern,
  merge = TRUE,
  simplify = FALSE,
  omit_no_match = FALSE
)

stri_extract_first_charclass(str, pattern)

stri_extract_last_charclass(str, pattern)

stri_extract_all_coll(
  str,
  pattern,
  simplify = FALSE,
  omit_no_match = FALSE,
  ...,
  opts_collator = NULL
)

stri_extract_first_coll(str, pattern, ..., opts_collator = NULL)

stri_extract_last_coll(str, pattern, ..., opts_collator = NULL)

stri_extract_all_regex(
  str,
  pattern,
  simplify = FALSE,
  omit_no_match = FALSE,
  ...,
  opts_regex = NULL
)

stri_extract_first_regex(str, pattern, ..., opts_regex = NULL)

stri_extract_last_regex(str, pattern, ..., opts_regex = NULL)

stri_extract_all_fixed(
  str,
  pattern,
  simplify = FALSE,
  omit_no_match = FALSE,
  ...,
  opts_fixed = NULL
)

stri_extract_first_fixed(str, pattern, ..., opts_fixed = NULL)

stri_extract_last_fixed(str, pattern, ..., opts_fixed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_extract_all_+3A_str">str</code></td>
<td>
<p>character vector; strings to search in</p>
</td></tr>
<tr><td><code id="stri_extract_all_+3A_...">...</code></td>
<td>
<p>supplementary arguments passed to the underlying functions,
including additional settings for <code>opts_collator</code>, <code>opts_regex</code>,
and so on</p>
</td></tr>
<tr><td><code id="stri_extract_all_+3A_mode">mode</code></td>
<td>
<p>single string;
one of: <code>'first'</code> (the default), <code>'all'</code>, <code>'last'</code></p>
</td></tr>
<tr><td><code id="stri_extract_all_+3A_pattern">pattern</code>, <code id="stri_extract_all_+3A_regex">regex</code>, <code id="stri_extract_all_+3A_fixed">fixed</code>, <code id="stri_extract_all_+3A_coll">coll</code>, <code id="stri_extract_all_+3A_charclass">charclass</code></td>
<td>
<p>character vector;
search patterns; for more details refer to <a href="#topic+stringi-search">stringi-search</a></p>
</td></tr>
<tr><td><code id="stri_extract_all_+3A_merge">merge</code></td>
<td>
<p>single logical value; indicates whether consecutive pattern
matches will be merged into one string;
<code>stri_extract_all_charclass</code> only</p>
</td></tr>
<tr><td><code id="stri_extract_all_+3A_simplify">simplify</code></td>
<td>
<p>single logical value;
if <code>TRUE</code> or <code>NA</code>, then a character matrix is returned;
otherwise (the default), a list of character vectors is given, see Value;
<code>stri_extract_all_*</code> only</p>
</td></tr>
<tr><td><code id="stri_extract_all_+3A_omit_no_match">omit_no_match</code></td>
<td>
<p>single logical value; if <code>FALSE</code>,
then a missing value will indicate that there was no match;
<code>stri_extract_all_*</code> only</p>
</td></tr>
<tr><td><code id="stri_extract_all_+3A_opts_collator">opts_collator</code>, <code id="stri_extract_all_+3A_opts_fixed">opts_fixed</code>, <code id="stri_extract_all_+3A_opts_regex">opts_regex</code></td>
<td>
<p>a named list to tune up
the search engine's settings; see <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>,
<code><a href="#topic+stri_opts_fixed">stri_opts_fixed</a></code>, and <code><a href="#topic+stri_opts_regex">stri_opts_regex</a></code>,
respectively; <code>NULL</code> for the defaults</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code> and <code>pattern</code> (with recycling
of the elements in the shorter vector if necessary). This allows to,
for instance, search for one pattern in each given string,
search for each pattern in one given string,
and search for the i-th pattern within the i-th string.
</p>
<p>Check out <code><a href="#topic+stri_match">stri_match</a></code> for the extraction of matches
to individual regex capture groups.
</p>
<p><code>stri_extract</code>, <code>stri_extract_all</code>, <code>stri_extract_first</code>,
and <code>stri_extract_last</code> are convenience functions.
They merely call <code>stri_extract_*_*</code>, depending on the arguments used.
</p>


<h3>Value</h3>

<p>For <code>stri_extract_all*</code>, if <code>simplify=FALSE</code> (the default), then
a list of character vectors is returned. Each list element
represents the results of a different search scenario.
If a pattern is not found and <code>omit_no_match=FALSE</code>,
then a character vector of length 1
with single <code>NA</code> value will be generated.
</p>
<p>Otherwise, i.e., if <code>simplify</code> is not <code>FALSE</code>,
then <code><a href="#topic+stri_list2matrix">stri_list2matrix</a></code> with <code>byrow=TRUE</code> argument
is called on the resulting object.
In such a case, the function yields a character matrix with an appropriate
number of rows (according to the length of <code>str</code>, <code>pattern</code>, etc.).
Note that <code><a href="#topic+stri_list2matrix">stri_list2matrix</a></code>'s <code>fill</code> argument is set
either to an empty string or <code>NA</code>, depending on
whether <code>simplify</code> is <code>TRUE</code> or <code>NA</code>, respectively.
</p>
<p><code>stri_extract_first*</code> and <code>stri_extract_last*</code>
return a character vector. A <code>NA</code> element indicates a no-match.
</p>
<p>Note that <code>stri_extract_last_regex</code> searches from start to end,
but skips overlapping matches, see the example below.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_extract: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_match_all">stri_match_all</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_extract_all('XaaaaX', regex=c('\\p{Ll}', '\\p{Ll}+', '\\p{Ll}{2,3}', '\\p{Ll}{2,3}?'))
stri_extract_all('Bartolini', coll='i')
stri_extract_all('stringi is so good!', charclass='\\p{Zs}') # all white-spaces

stri_extract_all_charclass(c('AbcdeFgHijK', 'abc', 'ABC'), '\\p{Ll}')
stri_extract_all_charclass(c('AbcdeFgHijK', 'abc', 'ABC'), '\\p{Ll}', merge=FALSE)
stri_extract_first_charclass('AaBbCc', '\\p{Ll}')
stri_extract_last_charclass('AaBbCc', '\\p{Ll}')

## Not run: 
# emoji support available since ICU 57
stri_extract_all_charclass(stri_enc_fromutf32(32:55200), '\\p{EMOJI}')

## End(Not run)

stri_extract_all_coll(c('AaaaaaaA', 'AAAA'), 'a')
stri_extract_first_coll(c('Yy\u00FD', 'AAA'), 'y', strength=2, locale='sk_SK')
stri_extract_last_coll(c('Yy\u00FD', 'AAA'), 'y',  strength=1, locale='sk_SK')

stri_extract_all_regex('XaaaaX', c('\\p{Ll}', '\\p{Ll}+', '\\p{Ll}{2,3}', '\\p{Ll}{2,3}?'))
stri_extract_first_regex('XaaaaX', c('\\p{Ll}', '\\p{Ll}+', '\\p{Ll}{2,3}', '\\p{Ll}{2,3}?'))
stri_extract_last_regex('XaaaaX', c('\\p{Ll}', '\\p{Ll}+', '\\p{Ll}{2,3}', '\\p{Ll}{2,3}?'))

stri_list2matrix(stri_extract_all_regex('XaaaaX', c('\\p{Ll}', '\\p{Ll}+')))
stri_extract_all_regex('XaaaaX', c('\\p{Ll}', '\\p{Ll}+'), simplify=TRUE)
stri_extract_all_regex('XaaaaX', c('\\p{Ll}', '\\p{Ll}+'), simplify=NA)

stri_extract_all_fixed('abaBAba', 'Aba', case_insensitive=TRUE)
stri_extract_all_fixed('abaBAba', 'Aba', case_insensitive=TRUE, overlap=TRUE)

# Searching for the last occurrence:
# Note the difference - regex searches left to right, with no overlaps.
stri_extract_last_fixed("agAGA", "aga", case_insensitive=TRUE)
stri_extract_last_regex("agAGA", "aga", case_insensitive=TRUE)

</code></pre>

<hr>
<h2 id='stri_extract_all_boundaries'>Extract Data Between Text Boundaries</h2><span id='topic+stri_extract_all_boundaries'></span><span id='topic+stri_extract_last_boundaries'></span><span id='topic+stri_extract_first_boundaries'></span><span id='topic+stri_extract_all_words'></span><span id='topic+stri_extract_first_words'></span><span id='topic+stri_extract_last_words'></span>

<h3>Description</h3>

<p>These functions extract data between text boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_extract_all_boundaries(
  str,
  simplify = FALSE,
  omit_no_match = FALSE,
  ...,
  opts_brkiter = NULL
)

stri_extract_last_boundaries(str, ..., opts_brkiter = NULL)

stri_extract_first_boundaries(str, ..., opts_brkiter = NULL)

stri_extract_all_words(
  str,
  simplify = FALSE,
  omit_no_match = FALSE,
  locale = NULL
)

stri_extract_first_words(str, locale = NULL)

stri_extract_last_words(str, locale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_extract_all_boundaries_+3A_str">str</code></td>
<td>
<p>character vector or an object coercible to</p>
</td></tr>
<tr><td><code id="stri_extract_all_boundaries_+3A_simplify">simplify</code></td>
<td>
<p>single logical value;
if <code>TRUE</code> or <code>NA</code>, then a character matrix is returned;
otherwise (the default), a list of character vectors is given, see Value</p>
</td></tr>
<tr><td><code id="stri_extract_all_boundaries_+3A_omit_no_match">omit_no_match</code></td>
<td>
<p>single logical value; if <code>FALSE</code>,
then a missing value will indicate that there are no words</p>
</td></tr>
<tr><td><code id="stri_extract_all_boundaries_+3A_...">...</code></td>
<td>
<p>additional settings for <code>opts_brkiter</code></p>
</td></tr>
<tr><td><code id="stri_extract_all_boundaries_+3A_opts_brkiter">opts_brkiter</code></td>
<td>
<p>a named list with <span class="pkg">ICU</span> BreakIterator's settings,
see <code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a></code>;
<code>NULL</code> for the default break iterator, i.e., <code>line_break</code></p>
</td></tr>
<tr><td><code id="stri_extract_all_boundaries_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for text boundary analysis following
the conventions of the default locale, or a single string with
locale identifier, see <a href="#topic+stringi-locale">stringi-locale</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code>.
</p>
<p>For more information on text boundary analysis
performed by <span class="pkg">ICU</span>'s <code>BreakIterator</code>, see
<a href="#topic+stringi-search-boundaries">stringi-search-boundaries</a>.
</p>
<p>In case of <code>stri_extract_*_words</code>,
just like in <code><a href="#topic+stri_count_words">stri_count_words</a></code>,
<span class="pkg">ICU</span>'s word <code>BreakIterator</code> iterator is used
to locate the word boundaries, and all non-word characters
(<code>UBRK_WORD_NONE</code> rule status) are ignored.
</p>


<h3>Value</h3>

<p>For <code>stri_extract_all_*</code>,
if <code>simplify=FALSE</code> (the default), then a
list of character vectors is returned. Each string consists of
a separate word. In case of <code>omit_no_match=FALSE</code> and
if there are no words or if a string is missing,
a single <code>NA</code> is provided on output.
</p>
<p>Otherwise, <code><a href="#topic+stri_list2matrix">stri_list2matrix</a></code> with <code>byrow=TRUE</code> argument
is called on the resulting object.
In such a case, a character matrix with <code>length(str)</code> rows
is returned. Note that <code><a href="#topic+stri_list2matrix">stri_list2matrix</a></code>'s <code>fill</code> argument
is set to an empty string and <code>NA</code>,
for <code>simplify</code> <code>TRUE</code> and <code>NA</code>, respectively.
</p>
<p>For <code>stri_extract_first_*</code> and <code>stri_extract_last_*</code>,
a character vector is returned.
A <code>NA</code> element indicates a no-match.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_extract: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_extract_all">stri_extract_all</a>()</code>,
<code><a href="#topic+stri_match_all">stri_match_all</a>()</code>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>
<p>Other text_boundaries: 
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_split_lines">stri_split_lines</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_extract_all_words('stringi: THE string processing package 123.48...')

</code></pre>

<hr>
<h2 id='stri_flatten'>Flatten a String</h2><span id='topic+stri_flatten'></span>

<h3>Description</h3>

<p>Joins the elements of a character vector into one string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_flatten(str, collapse = "", na_empty = FALSE, omit_empty = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_flatten_+3A_str">str</code></td>
<td>
<p>a vector of strings to be coerced to character</p>
</td></tr>
<tr><td><code id="stri_flatten_+3A_collapse">collapse</code></td>
<td>
<p>a single string denoting the separator</p>
</td></tr>
<tr><td><code id="stri_flatten_+3A_na_empty">na_empty</code></td>
<td>
<p>single logical value; should missing values
in <code>str</code> be treated as empty strings (<code>TRUE</code>)
or be omitted whatsoever (<code>NA</code>)?</p>
</td></tr>
<tr><td><code id="stri_flatten_+3A_omit_empty">omit_empty</code></td>
<td>
<p>single logical value; should empty strings
in <code>str</code> be omitted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stri_flatten(str, collapse='XXX')</code> call
is equivalent to <code><a href="base.html#topic+paste">paste</a>(str, collapse='XXX', sep='')</code>.
</p>
<p>If you wish to use some more fancy (e.g., differing)
separators between flattened strings,
call <code><a href="#topic+stri_join">stri_join</a>(str, separators, collapse='')</code>.
</p>
<p>If <code>str</code> is not empty, then a single string is returned.
If <code>collapse</code> has length &gt; 1, then only the first string
will be used.
</p>


<h3>Value</h3>

<p>Returns a single string, i.e., a character
vector of length 1.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other join: 
<code><a href="#topic++25s+2B+25">%s+%</a>()</code>,
<code><a href="#topic+stri_dup">stri_dup</a>()</code>,
<code><a href="#topic+stri_join_list">stri_join_list</a>()</code>,
<code><a href="#topic+stri_join">stri_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_flatten(LETTERS)
stri_flatten(LETTERS, collapse=',')
stri_flatten(stri_dup(letters[1:6], 1:3))
stri_flatten(c(NA, '', 'A', '', 'B', NA, 'C'), collapse=',', na_empty=TRUE, omit_empty=TRUE)
stri_flatten(c(NA, '', 'A', '', 'B', NA, 'C'), collapse=',', na_empty=NA)

</code></pre>

<hr>
<h2 id='stri_info'>Query Default Settings for <span class="pkg">stringi</span></h2><span id='topic+stri_info'></span>

<h3>Description</h3>

<p>Gives the current default settings used by the <span class="pkg">ICU</span> library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_info(short = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_info_+3A_short">short</code></td>
<td>
<p>logical; whether or not the results should be given
in a concise form; defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>short</code> is <code>TRUE</code>, then a single string providing
information on the default character encoding, locale, and Unicode
as well as <span class="pkg">ICU</span> version is returned.
</p>
<p>Otherwise, a list with the following components is returned:
</p>

<ul>
<li> <p><code>Unicode.version</code> &ndash; version of Unicode supported
by the <span class="pkg">ICU</span> library;
</p>
</li>
<li> <p><code>ICU.version</code> &ndash; <span class="pkg">ICU</span> library version used;
</p>
</li>
<li> <p><code>Locale</code> &ndash; contains information on default locale,
as returned by <code><a href="#topic+stri_locale_info">stri_locale_info</a></code>;
</p>
</li>
<li> <p><code>Charset.internal</code> &ndash; fixed at <code>c('UTF-8', 'UTF-16')</code>;
</p>
</li>
<li> <p><code>Charset.native</code> &ndash; information on the default encoding,
as returned by <code><a href="#topic+stri_enc_info">stri_enc_info</a></code>;
</p>
</li>
<li> <p><code>ICU.system</code> &ndash; logical; <code>TRUE</code> indicates that
the system <span class="pkg">ICU</span> libs are used, otherwise <span class="pkg">ICU</span> was built together
with <span class="pkg">stringi</span>;
</p>
</li>
<li> <p><code>ICU.UTF8</code> &ndash; logical; <code>TRUE</code> if the internal
<code>U_CHARSET_IS_UTF8</code> flag is defined and set.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>

<hr>
<h2 id='stri_isempty'>Determine if a String is of Length Zero</h2><span id='topic+stri_isempty'></span>

<h3>Description</h3>

<p>This is the fastest way to find out
whether the elements of a character vector are empty strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_isempty(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_isempty_+3A_str">str</code></td>
<td>
<p>character vector or an object coercible to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are handled properly.
</p>


<h3>Value</h3>

<p>Returns a logical vector of the same length as <code>str</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other length: 
<code><a href="#topic++25s+24+25">%s$%</a>()</code>,
<code><a href="#topic+stri_length">stri_length</a>()</code>,
<code><a href="#topic+stri_numbytes">stri_numbytes</a>()</code>,
<code><a href="#topic+stri_pad_both">stri_pad_both</a>()</code>,
<code><a href="#topic+stri_sprintf">stri_sprintf</a>()</code>,
<code><a href="#topic+stri_width">stri_width</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_isempty(letters[1:3])
stri_isempty(c(',', '', 'abc', '123', '\u0105\u0104'))
stri_isempty(character(1))

</code></pre>

<hr>
<h2 id='stri_join'>Concatenate Character Vectors</h2><span id='topic+stri_join'></span><span id='topic+stri_c'></span><span id='topic+stri_paste'></span>

<h3>Description</h3>

<p>These are the <span class="pkg">stringi</span>'s equivalents of the built-in
<code><a href="base.html#topic+paste">paste</a></code> function.
<code>stri_c</code> and <code>stri_paste</code> are aliases for <code>stri_join</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_join(..., sep = "", collapse = NULL, ignore_null = FALSE)

stri_c(..., sep = "", collapse = NULL, ignore_null = FALSE)

stri_paste(..., sep = "", collapse = NULL, ignore_null = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_join_+3A_...">...</code></td>
<td>
<p>character vectors (or objects coercible to character vectors)
whose corresponding elements are to be concatenated</p>
</td></tr>
<tr><td><code id="stri_join_+3A_sep">sep</code></td>
<td>
<p>a single string; separates terms</p>
</td></tr>
<tr><td><code id="stri_join_+3A_collapse">collapse</code></td>
<td>
<p>a single string or <code>NULL</code>; an optional
results separator</p>
</td></tr>
<tr><td><code id="stri_join_+3A_ignore_null">ignore_null</code></td>
<td>
<p>a single logical value; if <code>TRUE</code>, then empty
vectors provided via <code>...</code> are silently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over each atomic vector in '<code>...</code>'.
</p>
<p>Unless <code>collapse</code> is <code>NULL</code>, the result will be a single string.
Otherwise, you get a character vector of length equal
to the length of the longest argument.
</p>
<p>If any of the arguments in '<code>...</code>' is a vector of length 0
(not to be confused with vectors of empty strings)
and <code>ignore_null</code> is <code>FALSE</code>, then
you will get a 0-length character vector in result.
</p>
<p>If <code>collapse</code> or <code>sep</code> has length greater than 1,
then only the first string will be used.
</p>
<p>In case where there are missing values in any of the input vectors,
<code>NA</code> is set to the corresponding element.
Note that this behavior is different from <code><a href="base.html#topic+paste">paste</a></code>,
which treats missing values as ordinary strings like <code>'NA'</code>.
Moreover, as usual in <span class="pkg">stringi</span>, the resulting strings are
always in UTF-8.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other join: 
<code><a href="#topic++25s+2B+25">%s+%</a>()</code>,
<code><a href="#topic+stri_dup">stri_dup</a>()</code>,
<code><a href="#topic+stri_flatten">stri_flatten</a>()</code>,
<code><a href="#topic+stri_join_list">stri_join_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_join(1:13, letters)
stri_join(1:13, letters, sep=',')
stri_join(1:13, letters, collapse='; ')
stri_join(1:13, letters, sep=',', collapse='; ')
stri_join(c('abc', '123', 'xyz'),'###', 1:6, sep=',')
stri_join(c('abc', '123', 'xyz'),'###', 1:6, sep=',', collapse='; ')

</code></pre>

<hr>
<h2 id='stri_join_list'>Concatenate Strings in a List</h2><span id='topic+stri_join_list'></span><span id='topic+stri_c_list'></span><span id='topic+stri_paste_list'></span>

<h3>Description</h3>

<p>These functions concatenate all the strings in each character vector
in a given list.
<code>stri_c_list</code> and <code>stri_paste_list</code> are aliases for
<code>stri_join_list</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_join_list(x, sep = "", collapse = NULL)

stri_c_list(x, sep = "", collapse = NULL)

stri_paste_list(x, sep = "", collapse = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_join_list_+3A_x">x</code></td>
<td>
<p>a list consisting of character vectors</p>
</td></tr>
<tr><td><code id="stri_join_list_+3A_sep">sep</code></td>
<td>
<p>a single string; separates strings in each of the character
vectors in <code>x</code></p>
</td></tr>
<tr><td><code id="stri_join_list_+3A_collapse">collapse</code></td>
<td>
<p>a single string or <code>NULL</code>; an optional
results separator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unless <code>collapse</code> is <code>NULL</code>, the result will be a single string.
Otherwise, you get a character vector of length equal
to the length of <code>x</code>.
</p>
<p>Vectors in <code>x</code> of length 0 are silently ignored.
</p>
<p>If <code>collapse</code> or <code>sep</code> has length greater than 1,
then only the first string will be used.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other join: 
<code><a href="#topic++25s+2B+25">%s+%</a>()</code>,
<code><a href="#topic+stri_dup">stri_dup</a>()</code>,
<code><a href="#topic+stri_flatten">stri_flatten</a>()</code>,
<code><a href="#topic+stri_join">stri_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_join_list(
   stri_extract_all_words(c('Lorem ipsum dolor sit amet.',
   'Spam spam bacon sausage and spam.')),
sep=', ')

stri_join_list(
   stri_extract_all_words(c('Lorem ipsum dolor sit amet.',
   'Spam spam bacon sausage and spam.')),
sep=', ', collapse='. ')

stri_join_list(
   stri_extract_all_regex(
      c('spam spam bacon', '123 456', 'spam 789 sausage'), '\\p{L}+'
   ),
sep=',')

stri_join_list(
   stri_extract_all_regex(
      c('spam spam bacon', '123 456', 'spam 789 sausage'), '\\p{L}+',
      omit_no_match=TRUE
   ),
sep=',', collapse='; ')

</code></pre>

<hr>
<h2 id='stri_length'>Count the Number of Code Points</h2><span id='topic+stri_length'></span>

<h3>Description</h3>

<p>This function returns the number of code points
in each string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_length(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_length_+3A_str">str</code></td>
<td>
<p>character vector or an object coercible to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the number of code points is
not the same as the 'width' of the string when
printed on the console.
</p>
<p>If a given string is in UTF-8 and has not been properly normalized
(e.g., by <code><a href="#topic+stri_trans_nfc">stri_trans_nfc</a></code>), the returned counts may sometimes be
misleading. See <code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a></code> for a method to count
<em>Unicode characters</em>. Moreover, if an incorrect UTF-8 byte sequence
is detected, then a warning is generated and the corresponding output element
is set to <code>NA</code>, see also <code><a href="#topic+stri_enc_toutf8">stri_enc_toutf8</a></code> for a method
to deal with such cases.
</p>
<p>Missing values are handled properly.
For 'byte' encodings we get, as usual, an error.
</p>


<h3>Value</h3>

<p>Returns an integer vector of the same length as <code>str</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other length: 
<code><a href="#topic++25s+24+25">%s$%</a>()</code>,
<code><a href="#topic+stri_isempty">stri_isempty</a>()</code>,
<code><a href="#topic+stri_numbytes">stri_numbytes</a>()</code>,
<code><a href="#topic+stri_pad_both">stri_pad_both</a>()</code>,
<code><a href="#topic+stri_sprintf">stri_sprintf</a>()</code>,
<code><a href="#topic+stri_width">stri_width</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_length(LETTERS)
stri_length(c('abc', '123', '\u0105\u0104'))
stri_length('\u0105') # length is one, but...
stri_numbytes('\u0105') # 2 bytes are used
stri_numbytes(stri_trans_nfkd('\u0105')) # 3 bytes here but...
stri_length(stri_trans_nfkd('\u0105')) # ...two code points (!)
stri_count_boundaries(stri_trans_nfkd('\u0105'), type='character') # ...and one Unicode character

</code></pre>

<hr>
<h2 id='stri_list2matrix'>Convert a List to a Character Matrix</h2><span id='topic+stri_list2matrix'></span>

<h3>Description</h3>

<p>This function converts a given list of atomic vectors to
a character matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_list2matrix(
  x,
  byrow = FALSE,
  fill = NA_character_,
  n_min = 0,
  by_row = byrow
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_list2matrix_+3A_x">x</code></td>
<td>
<p>a list of atomic vectors</p>
</td></tr>
<tr><td><code id="stri_list2matrix_+3A_byrow">byrow</code></td>
<td>
<p>a single logical value; should the resulting matrix be
transposed?</p>
</td></tr>
<tr><td><code id="stri_list2matrix_+3A_fill">fill</code></td>
<td>
<p>a single string, see Details</p>
</td></tr>
<tr><td><code id="stri_list2matrix_+3A_n_min">n_min</code></td>
<td>
<p>a single integer value; minimal number of rows (<code>byrow==FALSE</code>)
or columns (otherwise) in the resulting matrix</p>
</td></tr>
<tr><td><code id="stri_list2matrix_+3A_by_row">by_row</code></td>
<td>
<p>alias of <code>byrow</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to the built-in <code><a href="base.html#topic+simplify2array">simplify2array</a></code>
function. However, it always returns a character matrix,
even if each element in <code>x</code> is of length 1
or if elements in <code>x</code> are not of the same lengths.
Moreover, the elements in <code>x</code> are always coerced to character vectors.
</p>
<p>If <code>byrow</code> is <code>FALSE</code>, then a matrix with <code>length(x)</code>
columns is returned.
The number of rows is the length of the
longest vector in <code>x</code>, but no less than <code>n_min</code>. Basically, we have
<code>result[i,j] == x[[j]][i]</code> if <code>i &lt;= length(x[[j]])</code>
and <code>result[i,j] == fill</code> otherwise, see Examples.
</p>
<p>If <code>byrow</code> is <code>TRUE</code>, then the resulting matrix is
a transposition of the above-described one.
</p>
<p>This function may be useful, e.g., in connection with <code><a href="#topic+stri_split">stri_split</a></code>
and <code><a href="#topic+stri_extract_all">stri_extract_all</a></code>.
</p>


<h3>Value</h3>

<p>Returns a character matrix.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other utils: 
<code><a href="#topic+stri_na2empty">stri_na2empty</a>()</code>,
<code><a href="#topic+stri_remove_empty">stri_remove_empty</a>()</code>,
<code><a href="#topic+stri_replace_na">stri_replace_na</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simplify2array(list(c('a', 'b'), c('c', 'd'), c('e', 'f')))
stri_list2matrix(list(c('a', 'b'), c('c', 'd'), c('e', 'f')))
stri_list2matrix(list(c('a', 'b'), c('c', 'd'), c('e', 'f')), byrow=TRUE)

simplify2array(list('a', c('b', 'c')))
stri_list2matrix(list('a', c('b', 'c')))
stri_list2matrix(list('a', c('b', 'c')), fill='')
stri_list2matrix(list('a', c('b', 'c')), fill='', n_min=5)

</code></pre>

<hr>
<h2 id='stri_locale_info'>Query Given Locale</h2><span id='topic+stri_locale_info'></span>

<h3>Description</h3>

<p>Provides some basic information on a given locale identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_locale_info(locale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_locale_info_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for default locale,
or a single string with locale identifier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With this function you may obtain some basic information
on any provided locale identifier,
even if it is unsupported by <span class="pkg">ICU</span> or if you pass a malformed locale
identifier (the one that is not, e.g., of the form Language_Country).
See <a href="#topic+stringi-locale">stringi-locale</a> for discussion.
</p>
<p>This function does not do anything really complicated. In many
cases it is similar to a call to
<code><a href="base.html#topic+as.list">as.list</a>(<a href="#topic+stri_split_fixed">stri_split_fixed</a>(locale, '_', 3L)[[1]])</code>,
with <code>locale</code> case mapped.
It may be used, however, to get insight on how ICU understands a given
locale identifier.
</p>


<h3>Value</h3>

<p>Returns a list with the following named character strings:
<code>Language</code>, <code>Country</code>, <code>Variant</code>, and
<code>Name</code>, being their underscore separated combination.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_management: 
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+stri_locale_list">stri_locale_list</a>()</code>,
<code><a href="#topic+stri_locale_set">stri_locale_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_locale_info('pl_PL')
stri_locale_info('Pl_pL') # the same result

</code></pre>

<hr>
<h2 id='stri_locale_list'>List Available Locales</h2><span id='topic+stri_locale_list'></span>

<h3>Description</h3>

<p>Creates a character vector with all available locale identifies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_locale_list()
</code></pre>


<h3>Details</h3>

<p>Note that some of the services may be unavailable in some locales.
Querying for locale-specific services is always performed
during the resource request.
</p>
<p>See <a href="#topic+stringi-locale">stringi-locale</a> for more information.
</p>


<h3>Value</h3>

<p>Returns a character vector with locale identifiers
that are known to <span class="pkg">ICU</span>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_management: 
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+stri_locale_info">stri_locale_info</a>()</code>,
<code><a href="#topic+stri_locale_set">stri_locale_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_locale_list()

</code></pre>

<hr>
<h2 id='stri_locale_set'>Set or Get Default Locale in <span class="pkg">stringi</span></h2><span id='topic+stri_locale_set'></span><span id='topic+stri_locale_get'></span>

<h3>Description</h3>

<p><code>stri_locale_set</code> changes the default locale for all the functions
in the <span class="pkg">stringi</span> package,
i.e., establishes the meaning of the &ldquo;<code>NULL</code> locale&rdquo; argument
of locale-sensitive functions.
<code>stri_locale_get</code>
gives the current default locale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_locale_set(locale)

stri_locale_get()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_locale_set_+3A_locale">locale</code></td>
<td>
<p>single string of the form <code>Language</code>,
<code>Language_Country</code>, or <code>Language_Country_Variant</code>, e.g.,
<code>'en_US'</code>, see <code><a href="#topic+stri_locale_list">stri_locale_list</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+stringi-locale">stringi-locale</a> for more information on the effect of
changing the default locale.
</p>
<p><code>stri_locale_get</code> is the same as <code><a href="#topic+stri_locale_info">stri_locale_info</a>(NULL)$Name</code>.
</p>


<h3>Value</h3>

<p><code>stri_locale_set</code> returns a string with
previously used locale, invisibly.
</p>
<p><code>stri_locale_get</code> returns a string of the form <code>Language</code>,
<code>Language_Country</code>, or <code>Language_Country_Variant</code>,
e.g., <code>'en_US'</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_management: 
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+stri_locale_info">stri_locale_info</a>()</code>,
<code><a href="#topic+stri_locale_list">stri_locale_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
oldloc &lt;- stri_locale_set('pt_BR')
# ... some locale-dependent operations
# ... note that you may always modify a locale per-call
# ... changing the default locale is convenient if you perform
# ... many operations
stri_locale_set(oldloc) # restore the previous default locale

## End(Not run)
</code></pre>

<hr>
<h2 id='stri_locate_all'>Locate Pattern Occurrences</h2><span id='topic+stri_locate_all'></span><span id='topic+stri_locate_first'></span><span id='topic+stri_locate_last'></span><span id='topic+stri_locate'></span><span id='topic+stri_locate_all_charclass'></span><span id='topic+stri_locate_first_charclass'></span><span id='topic+stri_locate_last_charclass'></span><span id='topic+stri_locate_all_coll'></span><span id='topic+stri_locate_first_coll'></span><span id='topic+stri_locate_last_coll'></span><span id='topic+stri_locate_all_regex'></span><span id='topic+stri_locate_first_regex'></span><span id='topic+stri_locate_last_regex'></span><span id='topic+stri_locate_all_fixed'></span><span id='topic+stri_locate_first_fixed'></span><span id='topic+stri_locate_last_fixed'></span>

<h3>Description</h3>

<p>These functions find the indexes (positions) where
there is a match to some pattern.
The functions <code>stri_locate_all_*</code> locate all the matches.
<code>stri_locate_first_*</code> and <code>stri_locate_last_*</code>
give the first and the last matches, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_locate_all(str, ..., regex, fixed, coll, charclass)

stri_locate_first(str, ..., regex, fixed, coll, charclass)

stri_locate_last(str, ..., regex, fixed, coll, charclass)

stri_locate(
  str,
  ...,
  regex,
  fixed,
  coll,
  charclass,
  mode = c("first", "all", "last")
)

stri_locate_all_charclass(
  str,
  pattern,
  merge = TRUE,
  omit_no_match = FALSE,
  get_length = FALSE
)

stri_locate_first_charclass(str, pattern, get_length = FALSE)

stri_locate_last_charclass(str, pattern, get_length = FALSE)

stri_locate_all_coll(
  str,
  pattern,
  omit_no_match = FALSE,
  get_length = FALSE,
  ...,
  opts_collator = NULL
)

stri_locate_first_coll(
  str,
  pattern,
  get_length = FALSE,
  ...,
  opts_collator = NULL
)

stri_locate_last_coll(
  str,
  pattern,
  get_length = FALSE,
  ...,
  opts_collator = NULL
)

stri_locate_all_regex(
  str,
  pattern,
  omit_no_match = FALSE,
  capture_groups = FALSE,
  get_length = FALSE,
  ...,
  opts_regex = NULL
)

stri_locate_first_regex(
  str,
  pattern,
  capture_groups = FALSE,
  get_length = FALSE,
  ...,
  opts_regex = NULL
)

stri_locate_last_regex(
  str,
  pattern,
  capture_groups = FALSE,
  get_length = FALSE,
  ...,
  opts_regex = NULL
)

stri_locate_all_fixed(
  str,
  pattern,
  omit_no_match = FALSE,
  get_length = FALSE,
  ...,
  opts_fixed = NULL
)

stri_locate_first_fixed(
  str,
  pattern,
  get_length = FALSE,
  ...,
  opts_fixed = NULL
)

stri_locate_last_fixed(
  str,
  pattern,
  get_length = FALSE,
  ...,
  opts_fixed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_locate_all_+3A_str">str</code></td>
<td>
<p>character vector; strings to search in</p>
</td></tr>
<tr><td><code id="stri_locate_all_+3A_...">...</code></td>
<td>
<p>supplementary arguments passed to the underlying functions,
including additional settings for <code>opts_collator</code>,
<code>opts_regex</code>, <code>opts_fixed</code>, and so on</p>
</td></tr>
<tr><td><code id="stri_locate_all_+3A_mode">mode</code></td>
<td>
<p>single string;
one of: <code>'first'</code> (the default), <code>'all'</code>, <code>'last'</code></p>
</td></tr>
<tr><td><code id="stri_locate_all_+3A_pattern">pattern</code>, <code id="stri_locate_all_+3A_regex">regex</code>, <code id="stri_locate_all_+3A_fixed">fixed</code>, <code id="stri_locate_all_+3A_coll">coll</code>, <code id="stri_locate_all_+3A_charclass">charclass</code></td>
<td>
<p>character vector;
search patterns; for more details refer to <a href="#topic+stringi-search">stringi-search</a></p>
</td></tr>
<tr><td><code id="stri_locate_all_+3A_merge">merge</code></td>
<td>
<p>single logical value;
indicates whether consecutive sequences of indexes in the resulting
matrix should be merged; <code>stri_locate_all_charclass</code> only</p>
</td></tr>
<tr><td><code id="stri_locate_all_+3A_omit_no_match">omit_no_match</code></td>
<td>
<p>single logical value; if <code>TRUE</code>,
a no-match will be indicated by a matrix with 0 rows
<code>stri_locate_all_*</code> only</p>
</td></tr>
<tr><td><code id="stri_locate_all_+3A_get_length">get_length</code></td>
<td>
<p>single logical value; if <code>FALSE</code> (default),
generate <em>from-to</em> matrices; otherwise, output
<em>from-length</em> ones</p>
</td></tr>
<tr><td><code id="stri_locate_all_+3A_opts_collator">opts_collator</code>, <code id="stri_locate_all_+3A_opts_fixed">opts_fixed</code>, <code id="stri_locate_all_+3A_opts_regex">opts_regex</code></td>
<td>
<p>named list used to tune up
the selected search engine's settings; see
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code><a href="#topic+stri_opts_fixed">stri_opts_fixed</a></code>,
and <code><a href="#topic+stri_opts_regex">stri_opts_regex</a></code>, respectively; <code>NULL</code>
for the defaults</p>
</td></tr>
<tr><td><code id="stri_locate_all_+3A_capture_groups">capture_groups</code></td>
<td>
<p>single logical value;
whether positions of matches to parenthesized subexpressions
should be returned too (as <code>capture_groups</code> attribute);
<code>stri_locate_*_regex</code> only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code> and <code>pattern</code> (with recycling
of the elements in the shorter vector if necessary). This allows to,
for instance, search for one pattern in each string,
search for each pattern in one string,
and search for the i-th pattern within the i-th string.
</p>
<p>The matches may be extracted by calling
<code><a href="#topic+stri_sub">stri_sub</a></code> or <code><a href="#topic+stri_sub_all">stri_sub_all</a></code>.
Alternatively, you may call <code><a href="#topic+stri_extract">stri_extract</a></code> directly.
</p>
<p><code>stri_locate</code>, <code>stri_locate_all</code>, <code>stri_locate_first</code>,
and <code>stri_locate_last</code> are convenience functions.
They just call <code>stri_locate_*_*</code>, depending on the arguments used.
</p>


<h3>Value</h3>

<p>For <code>stri_locate_all_*</code>,
a list of integer matrices is returned. Each list element
represents the results of a separate search scenario.
The first column gives the start positions
of the matches, and the second column gives the end positions.
Moreover, two <code>NA</code>s in a row denote <code>NA</code> arguments
or a no-match (the latter only if <code>omit_no_match</code> is <code>FALSE</code>).
</p>
<p><code>stri_locate_first_*</code> and <code>stri_locate_last_*</code>
return an integer matrix with
two columns, giving the start and end positions of the first
or the last matches, respectively, and two <code>NA</code>s if and
only if they are not found.
</p>
<p>For <code>stri_locate_*_regex</code>, if the match is of zero length,
<code>end</code> will be one character less than <code>start</code>.
Note that <code>stri_locate_last_regex</code> searches from start to end,
but skips overlapping matches, see the example below.
</p>
<p>Setting <code>get_length=TRUE</code> results in the 2nd column representing
the length of the match instead of the end position. In this case,
negative length denotes a no-match.
</p>
<p>If <code>capture_groups=TRUE</code>, then the outputs are equipped with the
<code>capture_groups</code> attribute, which is a list of matrices
giving the start-end positions of matches to parenthesized subexpressions.
Similarly to <code>stri_match_regex</code>, capture group names are extracted
unless looking for first/last occurrences of many different patterns.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_locate: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>
</p>
<p>Other indexing: 
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_sub_all">stri_sub_all</a>()</code>,
<code><a href="#topic+stri_sub">stri_sub</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_locate_all('stringi', fixed='i')

stri_locate_first_coll('hladn\u00FD', 'HLADNY', strength=1, locale='sk_SK')

stri_locate_all_regex(
    c('breakfast=eggs;lunch=pizza', 'breakfast=spam', 'no food here'),
   '(?&lt;when&gt;\\w+)=(?&lt;what&gt;\\w+)',
   capture_groups=TRUE
)  # named capture groups

stri_locate_all_fixed("abababa", "ABA", case_insensitive=TRUE, overlap=TRUE)
stri_locate_first_fixed("ababa", "aba")
stri_locate_last_fixed("ababa", "aba")  # starts from end
stri_locate_last_regex("ababa", "aba")  # no overlaps, from left to right

x &lt;- c("yes yes", "no", NA)
stri_locate_all_fixed(x, "yes")
stri_locate_all_fixed(x, "yes", omit_no_match=TRUE)
stri_locate_all_fixed(x, "yes", get_length=TRUE)
stri_locate_all_fixed(x, "yes", get_length=TRUE, omit_no_match=TRUE)
stri_locate_first_fixed(x, "yes")
stri_locate_first_fixed(x, "yes", get_length=TRUE)

# Use regex positive-lookahead to locate overlapping pattern matches:
stri_locate_all_regex('ACAGAGACTTTAGATAGAGAAGA', '(?=AGA)')
# note that start &gt; end here (match of length zero)


</code></pre>

<hr>
<h2 id='stri_locate_all_boundaries'>Locate Text Boundaries</h2><span id='topic+stri_locate_all_boundaries'></span><span id='topic+stri_locate_last_boundaries'></span><span id='topic+stri_locate_first_boundaries'></span><span id='topic+stri_locate_all_words'></span><span id='topic+stri_locate_last_words'></span><span id='topic+stri_locate_first_words'></span>

<h3>Description</h3>

<p>These functions locate text boundaries
(like character, word, line, or sentence boundaries).
Use <code>stri_locate_all_*</code> to locate all the matches.
<code>stri_locate_first_*</code> and <code>stri_locate_last_*</code>
give the first or the last matches, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_locate_all_boundaries(
  str,
  omit_no_match = FALSE,
  get_length = FALSE,
  ...,
  opts_brkiter = NULL
)

stri_locate_last_boundaries(str, get_length = FALSE, ..., opts_brkiter = NULL)

stri_locate_first_boundaries(str, get_length = FALSE, ..., opts_brkiter = NULL)

stri_locate_all_words(
  str,
  omit_no_match = FALSE,
  locale = NULL,
  get_length = FALSE
)

stri_locate_last_words(str, locale = NULL, get_length = FALSE)

stri_locate_first_words(str, locale = NULL, get_length = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_locate_all_boundaries_+3A_str">str</code></td>
<td>
<p>character vector or an object coercible to</p>
</td></tr>
<tr><td><code id="stri_locate_all_boundaries_+3A_omit_no_match">omit_no_match</code></td>
<td>
<p>single logical value; if <code>TRUE</code>,
a no-match will be indicated by a matrix with 0 rows
<code>stri_locate_all_*</code> only</p>
</td></tr>
<tr><td><code id="stri_locate_all_boundaries_+3A_get_length">get_length</code></td>
<td>
<p>single logical value; if <code>FALSE</code> (default),
generate <em>from-to</em> matrices; otherwise, output
<em>from-length</em> ones</p>
</td></tr>
<tr><td><code id="stri_locate_all_boundaries_+3A_...">...</code></td>
<td>
<p>additional settings for <code>opts_brkiter</code></p>
</td></tr>
<tr><td><code id="stri_locate_all_boundaries_+3A_opts_brkiter">opts_brkiter</code></td>
<td>
<p>named list with <span class="pkg">ICU</span> BreakIterator's settings,
see <code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a></code>;
<code>NULL</code> for default break iterator, i.e., <code>line_break</code></p>
</td></tr>
<tr><td><code id="stri_locate_all_boundaries_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for text boundary analysis following
the conventions of the default locale, or a single string with
locale identifier, see <a href="#topic+stringi-locale">stringi-locale</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code>.
</p>
<p>For more information on text boundary analysis
performed by <span class="pkg">ICU</span>'s <code>BreakIterator</code>, see
<a href="#topic+stringi-search-boundaries">stringi-search-boundaries</a>.
</p>
<p>For <code>stri_locate_*_words</code>,
just like in <code><a href="#topic+stri_extract_all_words">stri_extract_all_words</a></code> and <code><a href="#topic+stri_count_words">stri_count_words</a></code>,
<span class="pkg">ICU</span>'s word <code>BreakIterator</code> iterator is used
to locate the word boundaries, and all non-word characters
(<code>UBRK_WORD_NONE</code> rule status) are ignored.
This function is equivalent to a call to
<code>stri_locate_*_boundaries(str, type='word', skip_word_none=TRUE, locale=locale)</code>
</p>


<h3>Value</h3>

<p><code>stri_locate_all_*</code> yields a list of <code>length(str)</code>
integer matrices.
<code>stri_locate_first_*</code> and <code>stri_locate_last_*</code> generate
return an integer matrix.
See <code><a href="#topic+stri_locate">stri_locate</a></code> for more details.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_locate: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_locate_all">stri_locate_all</a>()</code>
</p>
<p>Other indexing: 
<code><a href="#topic+stri_locate_all">stri_locate_all</a>()</code>,
<code><a href="#topic+stri_sub_all">stri_sub_all</a>()</code>,
<code><a href="#topic+stri_sub">stri_sub</a>()</code>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>
<p>Other text_boundaries: 
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_split_lines">stri_split_lines</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- 'The\u00a0above-mentioned    features are very useful. Spam, spam, eggs, bacon, and spam.'
stri_locate_all_words(test)
stri_locate_all_boundaries(
    'Mr. Jones and Mrs. Brown are very happy. So am I, Prof. Smith.',
    type='sentence',
    locale='en_US@ss=standard' # ICU &gt;= 56 only
)



</code></pre>

<hr>
<h2 id='stri_match_all'>Extract Regex Pattern Matches, Together with Capture Groups</h2><span id='topic+stri_match_all'></span><span id='topic+stri_match_first'></span><span id='topic+stri_match_last'></span><span id='topic+stri_match'></span><span id='topic+stri_match_all_regex'></span><span id='topic+stri_match_first_regex'></span><span id='topic+stri_match_last_regex'></span>

<h3>Description</h3>

<p>These functions extract substrings in <code>str</code> that
match a given regex <code>pattern</code>. Additionally, they extract matches
to every <em>capture group</em>, i.e., to all the sub-patterns given
in round parentheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_match_all(str, ..., regex)

stri_match_first(str, ..., regex)

stri_match_last(str, ..., regex)

stri_match(str, ..., regex, mode = c("first", "all", "last"))

stri_match_all_regex(
  str,
  pattern,
  omit_no_match = FALSE,
  cg_missing = NA_character_,
  ...,
  opts_regex = NULL
)

stri_match_first_regex(
  str,
  pattern,
  cg_missing = NA_character_,
  ...,
  opts_regex = NULL
)

stri_match_last_regex(
  str,
  pattern,
  cg_missing = NA_character_,
  ...,
  opts_regex = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_match_all_+3A_str">str</code></td>
<td>
<p>character vector; strings to search in</p>
</td></tr>
<tr><td><code id="stri_match_all_+3A_...">...</code></td>
<td>
<p>supplementary arguments passed to the underlying functions,
including additional settings for <code>opts_regex</code></p>
</td></tr>
<tr><td><code id="stri_match_all_+3A_mode">mode</code></td>
<td>
<p>single string;
one of: <code>'first'</code> (the default), <code>'all'</code>, <code>'last'</code></p>
</td></tr>
<tr><td><code id="stri_match_all_+3A_pattern">pattern</code>, <code id="stri_match_all_+3A_regex">regex</code></td>
<td>
<p>character vector;
search patterns; for more details refer to <a href="#topic+stringi-search">stringi-search</a></p>
</td></tr>
<tr><td><code id="stri_match_all_+3A_omit_no_match">omit_no_match</code></td>
<td>
<p>single logical value; if <code>FALSE</code>,
then a row with missing values will indicate that there was no match;
<code>stri_match_all_*</code> only</p>
</td></tr>
<tr><td><code id="stri_match_all_+3A_cg_missing">cg_missing</code></td>
<td>
<p>single string to be used if a capture group match
is unavailable</p>
</td></tr>
<tr><td><code id="stri_match_all_+3A_opts_regex">opts_regex</code></td>
<td>
<p>a named list with <span class="pkg">ICU</span> Regex settings,
see <code><a href="#topic+stri_opts_regex">stri_opts_regex</a></code>; <code>NULL</code>
for default settings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code> and <code>pattern</code> (with recycling
of the elements in the shorter vector if necessary). This allows to,
for instance, search for one pattern in each given string,
search for each pattern in one given string,
and search for the i-th pattern within the i-th string.
</p>
<p>If no pattern match is detected and <code>omit_no_match=FALSE</code>,
then <code>NA</code>s are included in the resulting matrix (matrices), see Examples.
</p>
<p><code>stri_match</code>, <code>stri_match_all</code>, <code>stri_match_first</code>,
and <code>stri_match_last</code> are convenience functions.
They merely call <code>stri_match_*_regex</code> and are
provided for consistency with other string searching functions' wrappers,
see, among others, <code><a href="#topic+stri_extract">stri_extract</a></code>.
</p>


<h3>Value</h3>

<p>For <code>stri_match_all*</code>,
a list of character matrices is returned. Each list element
represents the results of a different search scenario.
</p>
<p>For <code>stri_match_first*</code> and <code>stri_match_last*</code>
a character matrix is returned.
Each row corresponds to a different search result.
</p>
<p>The first matrix column gives the whole match. The second one corresponds to
the first capture group, the third &ndash; the second capture group, and so on.
</p>
<p>If regular expressions feature a named capture group,
the matrix columns will be named accordingly.
However, for <code>stri_match_first*</code> and <code>stri_match_last*</code>
this will only be the case if there is a single pattern.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_extract: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_extract_all">stri_extract_all</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_match_all_regex('breakfast=eggs, lunch=pizza, dessert=icecream',
   '(\\w+)=(\\w+)')
stri_match_all_regex(c('breakfast=eggs', 'lunch=pizza', 'no food here'),
   '(\\w+)=(\\w+)')
stri_match_all_regex(c('breakfast=eggs;lunch=pizza',
   'breakfast=bacon;lunch=spaghetti', 'no food here'),
   '(\\w+)=(\\w+)')
stri_match_all_regex(c('breakfast=eggs;lunch=pizza',
   'breakfast=bacon;lunch=spaghetti', 'no food here'),
   '(?&lt;when&gt;\\w+)=(?&lt;what&gt;\\w+)')  # named capture groups
stri_match_first_regex(c('breakfast=eggs;lunch=pizza',
   'breakfast=bacon;lunch=spaghetti', 'no food here'),
   '(\\w+)=(\\w+)')
stri_match_last_regex(c('breakfast=eggs;lunch=pizza',
   'breakfast=bacon;lunch=spaghetti', 'no food here'),
   '(\\w+)=(\\w+)')

stri_match_first_regex(c('abcd', ':abcd', ':abcd:'), '^(:)?([^:]*)(:)?$')
stri_match_first_regex(c('abcd', ':abcd', ':abcd:'), '^(:)?([^:]*)(:)?$', cg_missing='')

# Match all the pattern of the form XYX, including overlapping matches:
stri_match_all_regex('ACAGAGACTTTAGATAGAGAAGA', '(?=(([ACGT])[ACGT]\\2))')[[1]][,2]
# Compare the above to:
stri_extract_all_regex('ACAGAGACTTTAGATAGAGAAGA', '([ACGT])[ACGT]\\1')

</code></pre>

<hr>
<h2 id='stri_na2empty'>Replace NAs with Empty Strings</h2><span id='topic+stri_na2empty'></span>

<h3>Description</h3>

<p>This function replaces all missing values with empty strings.
See <code><a href="#topic+stri_replace_na">stri_replace_na</a></code> for a generalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_na2empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_na2empty_+3A_x">x</code></td>
<td>
<p>a character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other utils: 
<code><a href="#topic+stri_list2matrix">stri_list2matrix</a>()</code>,
<code><a href="#topic+stri_remove_empty">stri_remove_empty</a>()</code>,
<code><a href="#topic+stri_replace_na">stri_replace_na</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_na2empty(c('a', NA, '', 'b'))

</code></pre>

<hr>
<h2 id='stri_numbytes'>Count the Number of Bytes</h2><span id='topic+stri_numbytes'></span>

<h3>Description</h3>

<p>Counts the number of bytes needed to store
each string in the computer's memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_numbytes(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_numbytes_+3A_str">str</code></td>
<td>
<p>character vector or an object coercible to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often, this is not the function you would normally use
in your string processing activities. See <code><a href="#topic+stri_length">stri_length</a></code> instead.
</p>
<p>For 8-bit encoded strings, this is the same as <code><a href="#topic+stri_length">stri_length</a></code>.
For UTF-8 strings, the returned values may be greater
than the number of code points, as UTF-8 is not a fixed-byte encoding:
one code point may be encoded by 1-4 bytes
(according to the current Unicode standard).
</p>
<p>Missing values are handled properly.
</p>
<p>The strings do not need to be re-encoded to perform this operation.
</p>
<p>The returned values do not include the trailing NUL bytes,
which are used internally to mark the end of string data (in C).
</p>


<h3>Value</h3>

<p>Returns an integer vector of the same length as <code>str</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other length: 
<code><a href="#topic++25s+24+25">%s$%</a>()</code>,
<code><a href="#topic+stri_isempty">stri_isempty</a>()</code>,
<code><a href="#topic+stri_length">stri_length</a>()</code>,
<code><a href="#topic+stri_pad_both">stri_pad_both</a>()</code>,
<code><a href="#topic+stri_sprintf">stri_sprintf</a>()</code>,
<code><a href="#topic+stri_width">stri_width</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_numbytes(letters)
stri_numbytes(c('abc', '123', '\u0105\u0104'))

## Not run: 
# this used to fail on Windows, where there were no native support
# for 4-bytes Unicode characters; see, however, stri_unescape_unicode():
stri_numbytes('\U001F600') # compare stri_length('\U001F600')

## End(Not run)

</code></pre>

<hr>
<h2 id='stri_opts_brkiter'>Generate a List with BreakIterator Settings</h2><span id='topic+stri_opts_brkiter'></span>

<h3>Description</h3>

<p>A convenience function to tune the <span class="pkg">ICU</span> <code>BreakIterator</code>'s behavior
in some text boundary analysis functions, see
<a href="#topic+stringi-search-boundaries">stringi-search-boundaries</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_opts_brkiter(
  type,
  locale,
  skip_word_none,
  skip_word_number,
  skip_word_letter,
  skip_word_kana,
  skip_word_ideo,
  skip_line_soft,
  skip_line_hard,
  skip_sentence_term,
  skip_sentence_sep
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_opts_brkiter_+3A_type">type</code></td>
<td>
<p>single string; either the break iterator type, one of <code>character</code>,
<code>line_break</code>, <code>sentence</code>, <code>word</code>,
or a custom set of ICU break iteration rules;
see <a href="#topic+stringi-search-boundaries">stringi-search-boundaries</a></p>
</td></tr>
<tr><td><code id="stri_opts_brkiter_+3A_locale">locale</code></td>
<td>
<p>single string, <code>NULL</code> or <code>''</code> for default locale</p>
</td></tr>
<tr><td><code id="stri_opts_brkiter_+3A_skip_word_none">skip_word_none</code></td>
<td>
<p>logical; perform no action for 'words' that
do not fit into any other categories</p>
</td></tr>
<tr><td><code id="stri_opts_brkiter_+3A_skip_word_number">skip_word_number</code></td>
<td>
<p>logical; perform no action for words that
appear to be numbers</p>
</td></tr>
<tr><td><code id="stri_opts_brkiter_+3A_skip_word_letter">skip_word_letter</code></td>
<td>
<p>logical; perform no action for words that
contain letters, excluding hiragana, katakana, or ideographic characters</p>
</td></tr>
<tr><td><code id="stri_opts_brkiter_+3A_skip_word_kana">skip_word_kana</code></td>
<td>
<p>logical; perform no action for words
containing kana characters</p>
</td></tr>
<tr><td><code id="stri_opts_brkiter_+3A_skip_word_ideo">skip_word_ideo</code></td>
<td>
<p>logical; perform no action for words
containing ideographic characters</p>
</td></tr>
<tr><td><code id="stri_opts_brkiter_+3A_skip_line_soft">skip_line_soft</code></td>
<td>
<p>logical; perform no action for soft line breaks,
i.e., positions where a line break is acceptable but not required</p>
</td></tr>
<tr><td><code id="stri_opts_brkiter_+3A_skip_line_hard">skip_line_hard</code></td>
<td>
<p>logical; perform no action for hard,
or mandatory line breaks</p>
</td></tr>
<tr><td><code id="stri_opts_brkiter_+3A_skip_sentence_term">skip_sentence_term</code></td>
<td>
<p>logical; perform no action for sentences
ending with a sentence terminator ('<code>.</code>', '<code>,</code>', '<code>?</code>',
'<code>!</code>'), possibly followed by a hard separator
(<code>CR</code>, <code>LF</code>, <code>PS</code>, etc.)</p>
</td></tr>
<tr><td><code id="stri_opts_brkiter_+3A_skip_sentence_sep">skip_sentence_sep</code></td>
<td>
<p>logical; perform no action for sentences
that do not contain an ending sentence terminator, but are ended
by a hard separator or end of input</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>skip_*</code> family of settings may be used to prevent performing
any special actions on particular types of text boundaries, e.g.,
in case of the <code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a></code> and
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a></code> functions.
</p>
<p>Note that custom break iterator rules (advanced users only)
should be specified as a single string.
For a detailed description of the syntax of RBBI rules, please refer
to the ICU User Guide on Boundary Analysis.
</p>


<h3>Value</h3>

<p>Returns a named list object.
Omitted <code>skip_*</code> values act as they have been set to <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em><code>ubrk.h</code> File Reference</em> &ndash; ICU4C API Documentation,
<a href="https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/ubrk_8h.html">https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/ubrk_8h.html</a>
</p>
<p><em>Boundary Analysis</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/boundaryanalysis/">https://unicode-org.github.io/icu/userguide/boundaryanalysis/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other text_boundaries: 
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_split_lines">stri_split_lines</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>

<hr>
<h2 id='stri_opts_collator'>Generate a List with Collator Settings</h2><span id='topic+stri_opts_collator'></span><span id='topic+stri_coll'></span>

<h3>Description</h3>

<p>A convenience function to tune the <span class="pkg">ICU</span> Collator's behavior,
e.g., in <code><a href="#topic+stri_compare">stri_compare</a></code>, <code><a href="#topic+stri_order">stri_order</a></code>,
<code><a href="#topic+stri_unique">stri_unique</a></code>, <code><a href="#topic+stri_duplicated">stri_duplicated</a></code>,
as well as <code><a href="#topic+stri_detect_coll">stri_detect_coll</a></code>
and other <a href="#topic+stringi-search-coll">stringi-search-coll</a> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_opts_collator(
  locale = NULL,
  strength = 3L,
  alternate_shifted = FALSE,
  french = FALSE,
  uppercase_first = NA,
  case_level = FALSE,
  normalization = FALSE,
  normalisation = normalization,
  numeric = FALSE
)

stri_coll(
  locale = NULL,
  strength = 3L,
  alternate_shifted = FALSE,
  french = FALSE,
  uppercase_first = NA,
  case_level = FALSE,
  normalization = FALSE,
  normalisation = normalization,
  numeric = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_opts_collator_+3A_locale">locale</code></td>
<td>
<p>single string, <code>NULL</code> or
<code>''</code> for default locale</p>
</td></tr>
<tr><td><code id="stri_opts_collator_+3A_strength">strength</code></td>
<td>
<p>single integer in {1,2,3,4}, which defines collation strength;
<code>1</code> for the most permissive collation rules, <code>4</code> for the strictest
ones</p>
</td></tr>
<tr><td><code id="stri_opts_collator_+3A_alternate_shifted">alternate_shifted</code></td>
<td>
<p>single logical value; <code>FALSE</code>
treats all the code points with non-ignorable primary weights in the same way,
<code>TRUE</code> causes code points with primary weights that are equal or below
the variable top value to be ignored on primary level and moved to the quaternary level</p>
</td></tr>
<tr><td><code id="stri_opts_collator_+3A_french">french</code></td>
<td>
<p>single logical value; used in Canadian French;
<code>TRUE</code> results in secondary weights being considered backwards</p>
</td></tr>
<tr><td><code id="stri_opts_collator_+3A_uppercase_first">uppercase_first</code></td>
<td>
<p>single logical value; <code>NA</code>
orders upper and lower case letters in accordance to their tertiary weights,
<code>TRUE</code> forces upper case letters to sort before lower case letters,
<code>FALSE</code> does the opposite</p>
</td></tr>
<tr><td><code id="stri_opts_collator_+3A_case_level">case_level</code></td>
<td>
<p>single logical value;
controls whether an extra case level (positioned before the third level) is generated or not</p>
</td></tr>
<tr><td><code id="stri_opts_collator_+3A_normalization">normalization</code></td>
<td>
<p>single logical value; if <code>TRUE</code>,
then incremental check is performed to see whether the input data is in
the FCD form. If the data is not in the FCD form, incremental NFD
normalization is performed</p>
</td></tr>
<tr><td><code id="stri_opts_collator_+3A_normalisation">normalisation</code></td>
<td>
<p>alias of <code>normalization</code></p>
</td></tr>
<tr><td><code id="stri_opts_collator_+3A_numeric">numeric</code></td>
<td>
<p>single logical value;
when turned on, this attribute generates a collation key for
the numeric value of substrings of digits;
this is a way to get '100' to sort AFTER '2';
note that negative or non-integer numbers will not be ordered properly</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">ICU</span>'s <em>collator</em> performs a locale-aware, natural-language
alike string comparison.
This is a more reliable way of establishing relationships between
strings than the one provided by base <span class="rlang"><b>R</b></span>, and definitely
one that is more complex and appropriate than ordinary bytewise
comparison.
</p>


<h3>Value</h3>

<p>Returns a named list object; missing settings are left with default values.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Collation</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/collation/">https://unicode-org.github.io/icu/userguide/collation/</a>
</p>
<p><em>ICU Collation Service Architecture</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/collation/architecture.html">https://unicode-org.github.io/icu/userguide/collation/architecture.html</a>
</p>
<p><em><code>icu::Collator</code> Class Reference</em> &ndash; ICU4C API Documentation,
<a href="https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1Collator.html">https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1Collator.html</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>
<p>Other search_coll: 
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+about_search">about_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_cmp('number100', 'number2')
stri_cmp('number100', 'number2', opts_collator=stri_opts_collator(numeric=TRUE))
stri_cmp('number100', 'number2', numeric=TRUE) # equivalent
stri_cmp('above mentioned', 'above-mentioned')
stri_cmp('above mentioned', 'above-mentioned', alternate_shifted=TRUE)
</code></pre>

<hr>
<h2 id='stri_opts_fixed'>Generate a List with Fixed Pattern Search Engine's Settings</h2><span id='topic+stri_opts_fixed'></span>

<h3>Description</h3>

<p>A convenience function used to tune up the behavior of <code>stri_*_fixed</code>
functions, see <a href="#topic+stringi-search-fixed">stringi-search-fixed</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_opts_fixed(case_insensitive = FALSE, overlap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_opts_fixed_+3A_case_insensitive">case_insensitive</code></td>
<td>
<p>logical; enable simple case insensitive matching</p>
</td></tr>
<tr><td><code id="stri_opts_fixed_+3A_overlap">overlap</code></td>
<td>
<p>logical; enable overlapping matches' detection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Case-insensitive matching uses a simple, single-code point case mapping
(via ICU's <code>u_toupper()</code> function).
Full case mappings should be used whenever possible because they produce
better results by working on whole strings. They also take into account
the string context and the language, see <a href="#topic+stringi-search-coll">stringi-search-coll</a>.
</p>
<p>Searching for overlapping pattern matches is available in
<code><a href="#topic+stri_extract_all_fixed">stri_extract_all_fixed</a></code>, <code><a href="#topic+stri_locate_all_fixed">stri_locate_all_fixed</a></code>,
and <code><a href="#topic+stri_count_fixed">stri_count_fixed</a></code> functions.
</p>


<h3>Value</h3>

<p>Returns a named list object.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>C/POSIX Migration</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/icu/posix.html">https://unicode-org.github.io/icu/userguide/icu/posix.html</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_fixed: 
<code><a href="#topic+about_search_fixed">about_search_fixed</a></code>,
<code><a href="#topic+about_search">about_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_detect_fixed('ala', 'ALA') # case-sensitive by default
stri_detect_fixed('ala', 'ALA', opts_fixed=stri_opts_fixed(case_insensitive=TRUE))
stri_detect_fixed('ala', 'ALA', case_insensitive=TRUE) # equivalent
</code></pre>

<hr>
<h2 id='stri_opts_regex'>Generate a List with Regex Matcher Settings</h2><span id='topic+stri_opts_regex'></span>

<h3>Description</h3>

<p>A convenience function to tune the <span class="pkg">ICU</span> regular expressions
matcher's behavior, e.g., in <code><a href="#topic+stri_count_regex">stri_count_regex</a></code>
and other <a href="#topic+stringi-search-regex">stringi-search-regex</a> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_opts_regex(
  case_insensitive,
  comments,
  dotall,
  dot_all = dotall,
  literal,
  multiline,
  multi_line = multiline,
  unix_lines,
  uword,
  error_on_unknown_escapes,
  time_limit = 0L,
  stack_limit = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_opts_regex_+3A_case_insensitive">case_insensitive</code></td>
<td>
<p>logical; enables case insensitive matching [regex flag <code>(?i)</code>]</p>
</td></tr>
<tr><td><code id="stri_opts_regex_+3A_comments">comments</code></td>
<td>
<p>logical; allows white space and comments within patterns [regex flag <code>(?x)</code>]</p>
</td></tr>
<tr><td><code id="stri_opts_regex_+3A_dotall">dotall</code></td>
<td>
<p>logical;  if set, '<code>.</code>' matches line terminators,
otherwise matching of '<code>.</code>'  stops at a line end [regex flag <code>(?s)</code>]</p>
</td></tr>
<tr><td><code id="stri_opts_regex_+3A_dot_all">dot_all</code></td>
<td>
<p>alias of <code>dotall</code></p>
</td></tr>
<tr><td><code id="stri_opts_regex_+3A_literal">literal</code></td>
<td>
<p>logical; if set, treat the entire pattern as a literal string:
metacharacters or escape sequences in the input sequence will be given no special meaning;
note that in most cases you would rather use the <a href="#topic+stringi-search-fixed">stringi-search-fixed</a>
facilities in this case</p>
</td></tr>
<tr><td><code id="stri_opts_regex_+3A_multiline">multiline</code></td>
<td>
<p>logical; controls the behavior of '<code>$</code>' and '<code>^</code>'.
If set, recognize line terminators within a string, otherwise,
match only at start and end of input string [regex flag <code>(?m)</code>]</p>
</td></tr>
<tr><td><code id="stri_opts_regex_+3A_multi_line">multi_line</code></td>
<td>
<p>alias of <code>multiline</code></p>
</td></tr>
<tr><td><code id="stri_opts_regex_+3A_unix_lines">unix_lines</code></td>
<td>
<p>logical; Unix-only line endings;
when enabled, only <code>U+000a</code> is recognized as a
line ending by '<code>.</code>', '<code>$</code>', and '<code>^</code>'.</p>
</td></tr>
<tr><td><code id="stri_opts_regex_+3A_uword">uword</code></td>
<td>
<p>logical; Unicode word boundaries;
if set, uses the Unicode TR 29 definition of word boundaries;
warning: Unicode word boundaries are quite different from traditional
regex word boundaries. [regex flag <code>(?w)</code>]
See <a href="https://unicode.org/reports/tr29/#Word_Boundaries">https://unicode.org/reports/tr29/#Word_Boundaries</a></p>
</td></tr>
<tr><td><code id="stri_opts_regex_+3A_error_on_unknown_escapes">error_on_unknown_escapes</code></td>
<td>
<p>logical;
whether to generate an error on unrecognized backslash escapes;
if set, fail with an error on patterns that contain backslash-escaped ASCII
letters without a known special meaning;
otherwise, these escaped letters represent themselves</p>
</td></tr>
<tr><td><code id="stri_opts_regex_+3A_time_limit">time_limit</code></td>
<td>
<p>integer; processing time limit, in ~milliseconds (but not precisely so,
depends on the CPU speed), for match operations;
setting a limit is desirable if poorly written regexes are expected on input;
0 for no limit</p>
</td></tr>
<tr><td><code id="stri_opts_regex_+3A_stack_limit">stack_limit</code></td>
<td>
<p>integer; maximal size, in bytes, of the heap storage available
for the match backtracking stack; setting a limit is desirable if poorly
written regexes are expected on input; 0 for no limit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that some regex settings may be changed using ICU regex flags
inside regexes. For example, <code>'(?i)pattern'</code> performs
a case-insensitive match of a given pattern,
see the <span class="pkg">ICU</span> User Guide entry on Regular Expressions
in the References section or <a href="#topic+stringi-search-regex">stringi-search-regex</a>.
</p>


<h3>Value</h3>

<p>Returns a named list object; missing settings are left with default values.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em><code>enum URegexpFlag</code>: Constants for Regular Expression Match Modes</em>
&ndash; ICU4C API Documentation,
<a href="https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/uregex_8h.html">https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/uregex_8h.html</a>
</p>
<p><em>Regular Expressions</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/strings/regexp.html">https://unicode-org.github.io/icu/userguide/strings/regexp.html</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_regex: 
<code><a href="#topic+about_search_regex">about_search_regex</a></code>,
<code><a href="#topic+about_search">about_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_detect_regex('ala', 'ALA') # case-sensitive by default
stri_detect_regex('ala', 'ALA', opts_regex=stri_opts_regex(case_insensitive=TRUE))
stri_detect_regex('ala', 'ALA', case_insensitive=TRUE) # equivalent
stri_detect_regex('ala', '(?i)ALA') # equivalent
</code></pre>

<hr>
<h2 id='stri_order'>Ordering Permutation</h2><span id='topic+stri_order'></span>

<h3>Description</h3>

<p>This function finds a permutation which rearranges the
strings in a given character vector into the ascending or descending
locale-dependent lexicographic order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_order(str, decreasing = FALSE, na_last = TRUE, ..., opts_collator = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_order_+3A_str">str</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="stri_order_+3A_decreasing">decreasing</code></td>
<td>
<p>a single logical value; should the sort order
be nondecreasing (<code>FALSE</code>, default)
or nonincreasing (<code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="stri_order_+3A_na_last">na_last</code></td>
<td>
<p>a single logical value; controls the treatment of <code>NA</code>s
in <code>str</code>. If <code>TRUE</code>, then missing values in <code>str</code> are put
at the end; if <code>FALSE</code>, they are put at the beginning;
if <code>NA</code>, then they are removed from the output</p>
</td></tr>
<tr><td><code id="stri_order_+3A_...">...</code></td>
<td>
<p>additional settings for <code>opts_collator</code></p>
</td></tr>
<tr><td><code id="stri_order_+3A_opts_collator">opts_collator</code></td>
<td>
<p>a named list with <span class="pkg">ICU</span> Collator's options,
see <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code>NULL</code>
for default collation options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information on <span class="pkg">ICU</span>'s Collator and how to tune it up
in <span class="pkg">stringi</span>, refer to <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>.
</p>
<p>As usual in <span class="pkg">stringi</span>, non-character inputs are coerced to strings,
see an example below for a somewhat non-intuitive behavior of lexicographic
sorting on numeric inputs.
</p>
<p>This function uses a stable sort algorithm (<span class="pkg">STL</span>'s <code>stable_sort</code>),
which performs up to <code class="reqn">N*log^2(N)</code> element comparisons,
where <code class="reqn">N</code> is the length of <code>str</code>.
</p>
<p>For ordering with regards to multiple criteria (such as sorting
data frames by more than 1 column), see <code><a href="#topic+stri_rank">stri_rank</a></code>.
</p>


<h3>Value</h3>

<p>The function yields an integer vector that gives the sort order.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Collation</em> - ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/collation/">https://unicode-org.github.io/icu/userguide/collation/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_order(c('hladny', 'chladny'), locale='pl_PL')
stri_order(c('hladny', 'chladny'), locale='sk_SK')

stri_order(c(1, 100, 2, 101, 11, 10))  # lexicographic order
stri_order(c(1, 100, 2, 101, 11, 10), numeric=TRUE)  # OK for integers
stri_order(c(0.25, 0.5, 1, -1, -2, -3), numeric=TRUE)  # incorrect
</code></pre>

<hr>
<h2 id='stri_pad_both'>Pad (Center/Left/Right Align) a String</h2><span id='topic+stri_pad_both'></span><span id='topic+stri_pad_left'></span><span id='topic+stri_pad_right'></span><span id='topic+stri_pad'></span>

<h3>Description</h3>

<p>Add multiple <code>pad</code> characters at the given <code>side</code>(s) of each string
so that each output string is of total width of at least <code>width</code>.
These functions may be used to center or left/right-align each string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_pad_both(
  str,
  width = floor(0.9 * getOption("width")),
  pad = " ",
  use_length = FALSE
)

stri_pad_left(
  str,
  width = floor(0.9 * getOption("width")),
  pad = " ",
  use_length = FALSE
)

stri_pad_right(
  str,
  width = floor(0.9 * getOption("width")),
  pad = " ",
  use_length = FALSE
)

stri_pad(
  str,
  width = floor(0.9 * getOption("width")),
  side = c("left", "right", "both"),
  pad = " ",
  use_length = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_pad_both_+3A_str">str</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="stri_pad_both_+3A_width">width</code></td>
<td>
<p>integer vector giving minimal output string lengths</p>
</td></tr>
<tr><td><code id="stri_pad_both_+3A_pad">pad</code></td>
<td>
<p>character vector giving padding code points</p>
</td></tr>
<tr><td><code id="stri_pad_both_+3A_use_length">use_length</code></td>
<td>
<p>single logical value; should the number of code
points be used instead of the total code point width
(see <code><a href="#topic+stri_width">stri_width</a></code>)?</p>
</td></tr>
<tr><td><code id="stri_pad_both_+3A_side">side</code></td>
<td>
<p>[<code>stri_pad</code> only] single character string;
sides on which padding character is added
(<code>left</code> (default), <code>right</code>, or <code>both</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code>, <code>width</code>, and <code>pad</code>.
Each string in <code>pad</code> should consist of a code points of total width
equal to 1 or, if <code>use_length</code> is <code>TRUE</code>, exactly one code point.
</p>
<p><code>stri_pad</code> is a convenience function, which dispatches
to <code>stri_pad_*</code>.
</p>
<p>Note that Unicode code points may have various widths when
printed on the console and that, by default, the function takes that
into account. By changing the state of the <code>use_length</code>
argument, this function starts acting like each code point
was of width 1. This feature should rather be used with
text in Latin script.
</p>
<p>See <code><a href="#topic+stri_trim_left">stri_trim_left</a></code> (among others) for reverse operation.
Also check out <code><a href="#topic+stri_wrap">stri_wrap</a></code> for line wrapping.
</p>


<h3>Value</h3>

<p>These functions return a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other length: 
<code><a href="#topic++25s+24+25">%s$%</a>()</code>,
<code><a href="#topic+stri_isempty">stri_isempty</a>()</code>,
<code><a href="#topic+stri_length">stri_length</a>()</code>,
<code><a href="#topic+stri_numbytes">stri_numbytes</a>()</code>,
<code><a href="#topic+stri_sprintf">stri_sprintf</a>()</code>,
<code><a href="#topic+stri_width">stri_width</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_pad_left('stringi', 10, pad='#')
stri_pad_both('stringi', 8:12, pad='*')
# center on screen:
cat(stri_pad_both(c('the', 'string', 'processing', 'package'),
   getOption('width')*0.9), sep='\n')
cat(stri_pad_both(c('\ud6c8\ubbfc\uc815\uc74c', # takes width into account
   stri_trans_nfkd('\ud6c8\ubbfc\uc815\uc74c'), 'abcd'),
   width=10), sep='\n')

</code></pre>

<hr>
<h2 id='stri_rand_lipsum'>A Lorem Ipsum Generator</h2><span id='topic+stri_rand_lipsum'></span>

<h3>Description</h3>

<p>Generates (pseudo)random <em>lorem ipsum</em> text consisting
of a given number of text paragraphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_rand_lipsum(n_paragraphs, start_lipsum = TRUE, nparagraphs = n_paragraphs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_rand_lipsum_+3A_n_paragraphs">n_paragraphs</code></td>
<td>
<p>single integer, number of paragraphs to generate</p>
</td></tr>
<tr><td><code id="stri_rand_lipsum_+3A_start_lipsum">start_lipsum</code></td>
<td>
<p>single logical value; should the resulting
text start with <em>Lorem ipsum dolor sit amet</em>?</p>
</td></tr>
<tr><td><code id="stri_rand_lipsum_+3A_nparagraphs">nparagraphs</code></td>
<td>
<p>[DEPRECATED] alias of <code>n_paragraphs</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Lorem ipsum</em> is a dummy text often used as a source
of data for string processing and displaying/lay-outing exercises.
</p>
<p>The current implementation is very simple:
words are selected randomly from a Zipf distribution
(based on a set of ca. 190 predefined Latin words).
The number of words per sentence and sentences per paragraph
follows a discretized, truncated normal distribution.
No Markov chain modeling, just i.i.d. word selection.
</p>


<h3>Value</h3>

<p>Returns a character vector of length <code>n_paragraphs</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other random: 
<code><a href="#topic+stri_rand_shuffle">stri_rand_shuffle</a>()</code>,
<code><a href="#topic+stri_rand_strings">stri_rand_strings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat(sapply(
   stri_wrap(stri_rand_lipsum(10), 80, simplify=FALSE),
   stri_flatten, collapse='\n'), sep='\n\n')
cat(stri_rand_lipsum(10), sep='\n\n')

</code></pre>

<hr>
<h2 id='stri_rand_shuffle'>Randomly Shuffle Code Points in Each String</h2><span id='topic+stri_rand_shuffle'></span>

<h3>Description</h3>

<p>Generates a (pseudo)random permutation of the code points
in each string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_rand_shuffle(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_rand_shuffle_+3A_str">str</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operation may result in non-Unicode-normalized
strings and may give peculiar outputs in case of bidirectional strings.
</p>
<p>See also <code><a href="#topic+stri_reverse">stri_reverse</a></code> for reversing the order of code points.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other random: 
<code><a href="#topic+stri_rand_lipsum">stri_rand_lipsum</a>()</code>,
<code><a href="#topic+stri_rand_strings">stri_rand_strings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_rand_shuffle(c('abcdefghi', '0123456789'))
# you can do better than this with stri_rand_strings:
stri_rand_shuffle(rep(stri_paste(letters, collapse=''), 10))

</code></pre>

<hr>
<h2 id='stri_rand_strings'>Generate Random Strings</h2><span id='topic+stri_rand_strings'></span>

<h3>Description</h3>

<p>Generates (pseudo)random strings of desired lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_rand_strings(n, length, pattern = "[A-Za-z0-9]")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_rand_strings_+3A_n">n</code></td>
<td>
<p>single integer, number of observations</p>
</td></tr>
<tr><td><code id="stri_rand_strings_+3A_length">length</code></td>
<td>
<p>integer vector, desired string lengths</p>
</td></tr>
<tr><td><code id="stri_rand_strings_+3A_pattern">pattern</code></td>
<td>
<p>character vector specifying character classes to draw
elements from, see <a href="#topic+stringi-search-charclass">stringi-search-charclass</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>length</code> and <code>pattern</code>.
If length of <code>length</code> or <code>pattern</code> is greater than <code>n</code>,
then redundant elements are ignored. Otherwise,
these vectors are recycled if necessary.
</p>
<p>This operation may result in non-Unicode-normalized
strings and may give peculiar outputs for bidirectional strings.
</p>
<p>Sampling of code points from the set specified by <code>pattern</code>
is always done with replacement and each code point appears with equal
probability.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other random: 
<code><a href="#topic+stri_rand_lipsum">stri_rand_lipsum</a>()</code>,
<code><a href="#topic+stri_rand_shuffle">stri_rand_shuffle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_rand_strings(5, 10) # 5 strings of length 10
stri_rand_strings(5, sample(1:10, 5, replace=TRUE)) # 5 strings of random lengths
stri_rand_strings(10, 5, '[\\p{script=latin}&amp;\\p{Ll}]') # small letters from the Latin script

# generate n random passwords of length in [8, 14]
# consisting of at least one digit, small and big ASCII letter:
n &lt;- 10
stri_rand_shuffle(stri_paste(
   stri_rand_strings(n, 1, '[0-9]'),
   stri_rand_strings(n, 1, '[a-z]'),
   stri_rand_strings(n, 1, '[A-Z]'),
   stri_rand_strings(n, sample(5:11, 5, replace=TRUE), '[a-zA-Z0-9]')
))

</code></pre>

<hr>
<h2 id='stri_rank'>Ranking</h2><span id='topic+stri_rank'></span>

<h3>Description</h3>

<p>This function ranks each string in a character vector according to a
locale-dependent lexicographic order.
It is a portable replacement for the base <code>xtfrm</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_rank(str, ..., opts_collator = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_rank_+3A_str">str</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="stri_rank_+3A_...">...</code></td>
<td>
<p>additional settings for <code>opts_collator</code></p>
</td></tr>
<tr><td><code id="stri_rank_+3A_opts_collator">opts_collator</code></td>
<td>
<p>a named list with <span class="pkg">ICU</span> Collator's options,
see <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code>NULL</code>
for default collation options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values result in missing ranks and tied observations receive
the same ranks (based on min).
</p>
<p>For more information on <span class="pkg">ICU</span>'s Collator and how to tune it up
in <span class="pkg">stringi</span>, refer to <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>.
</p>


<h3>Value</h3>

<p>The result is a vector of ranks corresponding to each
string in <code>str</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Collation</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/collation/">https://unicode-org.github.io/icu/userguide/collation/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_rank(c('hladny', 'chladny'), locale='pl_PL')
stri_rank(c('hladny', 'chladny'), locale='sk_SK')

stri_rank("a" %s+% c(1, 100, 2, 101, 11, 10))  # lexicographic order
stri_rank("a" %s+% c(1, 100, 2, 101, 11, 10), numeric=TRUE)  # OK
stri_rank("a" %s+% c(0.25, 0.5, 1, -1, -2, -3), numeric=TRUE)  # incorrect

# Ordering a data frame with respect to two criteria:
X &lt;- data.frame(a=c("b", NA, "b", "b", NA, "a", "a", "c"), b=runif(8))
X[order(stri_rank(X$a), X$b), ]

</code></pre>

<hr>
<h2 id='stri_read_lines'>Read Text Lines from a Text File</h2><span id='topic+stri_read_lines'></span>

<h3>Description</h3>

<p>Reads a text file in ins entirety, re-encodes it, and splits it into text lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_read_lines(con, encoding = NULL, fname = con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_read_lines_+3A_con">con</code></td>
<td>
<p>name of the output file or a connection object
(opened in the binary mode)</p>
</td></tr>
<tr><td><code id="stri_read_lines_+3A_encoding">encoding</code></td>
<td>
<p>single string; input encoding;
<code>NULL</code> or <code>''</code> for the current default encoding.</p>
</td></tr>
<tr><td><code id="stri_read_lines_+3A_fname">fname</code></td>
<td>
<p>[DEPRECATED] alias of <code>con</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This aims to be a substitute for the <code><a href="base.html#topic+readLines">readLines</a></code> function,
with the ability to re-encode the input file in a much more robust way,
and split the text into lines with <code><a href="#topic+stri_split_lines1">stri_split_lines1</a></code>
(which conforms with the Unicode guidelines for newline markers).
</p>
<p>The function calls <code><a href="#topic+stri_read_raw">stri_read_raw</a></code>,
<code><a href="#topic+stri_encode">stri_encode</a></code>, and <code><a href="#topic+stri_split_lines1">stri_split_lines1</a></code>,
in this order.
</p>
<p>Because of the way this function is currently implemented,
maximal file size cannot exceed ~0.67 GB.
</p>


<h3>Value</h3>

<p>Returns a character vector, each text line is a separate string.
The output is always marked as UTF-8.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other files: 
<code><a href="#topic+stri_read_raw">stri_read_raw</a>()</code>,
<code><a href="#topic+stri_write_lines">stri_write_lines</a>()</code>
</p>

<hr>
<h2 id='stri_read_raw'>Read Text File as Raw</h2><span id='topic+stri_read_raw'></span>

<h3>Description</h3>

<p>Reads a text file as-is, with no conversion or text line splitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_read_raw(con, fname = con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_read_raw_+3A_con">con</code></td>
<td>
<p>name of the output file or a connection object
(opened in the binary mode)</p>
</td></tr>
<tr><td><code id="stri_read_raw_+3A_fname">fname</code></td>
<td>
<p>[DEPRECATED] alias of <code>con</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once a text file is read into memory,
encoding detection (see <code><a href="#topic+stri_enc_detect">stri_enc_detect</a></code>),
conversion (see <code><a href="#topic+stri_encode">stri_encode</a></code>), and/or
splitting of text into lines (see <code><a href="#topic+stri_split_lines1">stri_split_lines1</a></code>)
can be performed.
</p>


<h3>Value</h3>

<p>Returns a vector of type <code>raw</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other files: 
<code><a href="#topic+stri_read_lines">stri_read_lines</a>()</code>,
<code><a href="#topic+stri_write_lines">stri_write_lines</a>()</code>
</p>

<hr>
<h2 id='stri_remove_empty'>Remove All Empty Strings from a Character Vector</h2><span id='topic+stri_remove_empty'></span><span id='topic+stri_omit_empty'></span><span id='topic+stri_remove_empty_na'></span><span id='topic+stri_omit_empty_na'></span><span id='topic+stri_remove_na'></span><span id='topic+stri_omit_na'></span>

<h3>Description</h3>

<p><code>stri_remove_empty</code> (alias <code>stri_omit_empty</code>)
removes all empty strings from a character vector,
and, if <code>na_empty</code> is <code>TRUE</code>, also gets rid of all missing
values.
</p>
<p><code>stri_remove_empty_na</code> (alias <code>stri_omit_empty_na</code>)
removes both empty strings and missing values.
</p>
<p><code>stri_remove_na</code> (alias <code>stri_omit_na</code>)
returns a version of <code>x</code> with missing values removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_remove_empty(x, na_empty = FALSE)

stri_omit_empty(x, na_empty = FALSE)

stri_remove_empty_na(x)

stri_omit_empty_na(x)

stri_remove_na(x)

stri_omit_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_remove_empty_+3A_x">x</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="stri_remove_empty_+3A_na_empty">na_empty</code></td>
<td>
<p>should missing values be treated as empty strings?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other utils: 
<code><a href="#topic+stri_list2matrix">stri_list2matrix</a>()</code>,
<code><a href="#topic+stri_na2empty">stri_na2empty</a>()</code>,
<code><a href="#topic+stri_replace_na">stri_replace_na</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_remove_empty(stri_na2empty(c('a', NA, '', 'b')))
stri_remove_empty(c('a', NA, '', 'b'))
stri_remove_empty(c('a', NA, '', 'b'), TRUE)

stri_omit_empty_na(c('a', NA, '', 'b'))

</code></pre>

<hr>
<h2 id='stri_replace_all'>Replace Pattern Occurrences</h2><span id='topic+stri_replace_all'></span><span id='topic+stri_replace_first'></span><span id='topic+stri_replace_last'></span><span id='topic+stri_replace'></span><span id='topic+stri_replace_all_charclass'></span><span id='topic+stri_replace_first_charclass'></span><span id='topic+stri_replace_last_charclass'></span><span id='topic+stri_replace_all_coll'></span><span id='topic+stri_replace_first_coll'></span><span id='topic+stri_replace_last_coll'></span><span id='topic+stri_replace_all_fixed'></span><span id='topic+stri_replace_first_fixed'></span><span id='topic+stri_replace_last_fixed'></span><span id='topic+stri_replace_all_regex'></span><span id='topic+stri_replace_first_regex'></span><span id='topic+stri_replace_last_regex'></span>

<h3>Description</h3>

<p>These functions replace, with the given replacement string, every/first/last
substring of the input that matches the specified <code>pattern</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_replace_all(str, replacement, ..., regex, fixed, coll, charclass)

stri_replace_first(str, replacement, ..., regex, fixed, coll, charclass)

stri_replace_last(str, replacement, ..., regex, fixed, coll, charclass)

stri_replace(
  str,
  replacement,
  ...,
  regex,
  fixed,
  coll,
  charclass,
  mode = c("first", "all", "last")
)

stri_replace_all_charclass(
  str,
  pattern,
  replacement,
  merge = FALSE,
  vectorize_all = TRUE,
  vectorise_all = vectorize_all
)

stri_replace_first_charclass(str, pattern, replacement)

stri_replace_last_charclass(str, pattern, replacement)

stri_replace_all_coll(
  str,
  pattern,
  replacement,
  vectorize_all = TRUE,
  vectorise_all = vectorize_all,
  ...,
  opts_collator = NULL
)

stri_replace_first_coll(str, pattern, replacement, ..., opts_collator = NULL)

stri_replace_last_coll(str, pattern, replacement, ..., opts_collator = NULL)

stri_replace_all_fixed(
  str,
  pattern,
  replacement,
  vectorize_all = TRUE,
  vectorise_all = vectorize_all,
  ...,
  opts_fixed = NULL
)

stri_replace_first_fixed(str, pattern, replacement, ..., opts_fixed = NULL)

stri_replace_last_fixed(str, pattern, replacement, ..., opts_fixed = NULL)

stri_replace_all_regex(
  str,
  pattern,
  replacement,
  vectorize_all = TRUE,
  vectorise_all = vectorize_all,
  ...,
  opts_regex = NULL
)

stri_replace_first_regex(str, pattern, replacement, ..., opts_regex = NULL)

stri_replace_last_regex(str, pattern, replacement, ..., opts_regex = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_replace_all_+3A_str">str</code></td>
<td>
<p>character vector; strings to search in</p>
</td></tr>
<tr><td><code id="stri_replace_all_+3A_replacement">replacement</code></td>
<td>
<p>character vector with replacements for matched patterns</p>
</td></tr>
<tr><td><code id="stri_replace_all_+3A_...">...</code></td>
<td>
<p>supplementary arguments passed to the underlying functions,
including additional settings for <code>opts_collator</code>, <code>opts_regex</code>,
<code>opts_fixed</code>, and so on</p>
</td></tr>
<tr><td><code id="stri_replace_all_+3A_mode">mode</code></td>
<td>
<p>single string;
one of: <code>'first'</code> (the default), <code>'all'</code>, <code>'last'</code></p>
</td></tr>
<tr><td><code id="stri_replace_all_+3A_pattern">pattern</code>, <code id="stri_replace_all_+3A_regex">regex</code>, <code id="stri_replace_all_+3A_fixed">fixed</code>, <code id="stri_replace_all_+3A_coll">coll</code>, <code id="stri_replace_all_+3A_charclass">charclass</code></td>
<td>
<p>character vector;
search patterns; for more details refer to <a href="#topic+stringi-search">stringi-search</a></p>
</td></tr>
<tr><td><code id="stri_replace_all_+3A_merge">merge</code></td>
<td>
<p>single logical value;
should consecutive matches be merged into one string;
<code>stri_replace_all_charclass</code> only</p>
</td></tr>
<tr><td><code id="stri_replace_all_+3A_vectorize_all">vectorize_all</code></td>
<td>
<p>single logical value;
should each occurrence of a pattern in every string
be replaced by a corresponding replacement string?;
<code>stri_replace_all_*</code> only</p>
</td></tr>
<tr><td><code id="stri_replace_all_+3A_vectorise_all">vectorise_all</code></td>
<td>
<p>alias of <code>vectorize_all</code></p>
</td></tr>
<tr><td><code id="stri_replace_all_+3A_opts_collator">opts_collator</code>, <code id="stri_replace_all_+3A_opts_fixed">opts_fixed</code>, <code id="stri_replace_all_+3A_opts_regex">opts_regex</code></td>
<td>
<p>a named list used to tune up
the search engine's settings; see
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code><a href="#topic+stri_opts_fixed">stri_opts_fixed</a></code>,
and <code><a href="#topic+stri_opts_regex">stri_opts_regex</a></code>, respectively; <code>NULL</code>
for the defaults</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, all the functions are vectorized over
<code>str</code>, <code>pattern</code>, <code>replacement</code> (with recycling
of the elements in the shorter vector if necessary).
Input that is not part of any match is left unchanged;
each match is replaced in the result by the replacement string.
</p>
<p>However, for <code>stri_replace_all*</code>, if <code>vectorize_all</code> is <code>FALSE</code>,
then each substring matching any of the supplied <code>pattern</code>s
is replaced by a corresponding <code>replacement</code> string.
In such a case, the vectorization is over <code>str</code>,
and - independently - over <code>pattern</code> and <code>replacement</code>.
In other words, this is equivalent to something like
<code>for (i in 1:npatterns) str &lt;- stri_replace_all(str, pattern[i], replacement[i]</code>.
Note that you must set <code>length(pattern) &gt;= length(replacement)</code>.
</p>
<p>In case of <code>stri_replace_*_regex</code>,
the replacement string may contain references to capture groups
(in round parentheses).
References are of the form <code>$n</code>, where <code>n</code> is the number
of the capture group (<code>$1</code> denotes the first group).
For the literal <code>$</code>,
escape it with a backslash.
Moreover, <code>${name}</code> are used for named capture groups.
</p>
<p>Note that <code>stri_replace_last_regex</code> searches from start to end,
but skips overlapping matches, see the example below.
</p>
<p><code>stri_replace</code>, <code>stri_replace_all</code>, <code>stri_replace_first</code>,
and <code>stri_replace_last</code> are convenience functions; they just call
<code>stri_replace_*_*</code> variants, depending on the arguments used.
</p>
<p>If you wish to remove white-spaces from the start or end
of a string, see <code><a href="#topic+stri_trim">stri_trim</a></code>.
</p>


<h3>Value</h3>

<p>All the functions return a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_replace: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_replace_rstr">stri_replace_rstr</a>()</code>,
<code><a href="#topic+stri_trim_both">stri_trim_both</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_replace_all_charclass('aaaa', '[a]', 'b', merge=c(TRUE, FALSE))

stri_replace_all_charclass('a\nb\tc   d', '\\p{WHITE_SPACE}', ' ')
stri_replace_all_charclass('a\nb\tc   d', '\\p{WHITE_SPACE}', ' ', merge=TRUE)

s &lt;- 'Lorem ipsum dolor sit amet, consectetur adipisicing elit.'
stri_replace_all_fixed(s, ' ', '#')
stri_replace_all_fixed(s, 'o', '0')

stri_replace_all_fixed(c('1', 'NULL', '3'), 'NULL', NA)

stri_replace_all_regex(s, ' .*? ', '#')
stri_replace_all_regex(s, '(el|s)it', '1234')
stri_replace_all_regex('abaca', 'a', c('!', '*'))
stri_replace_all_regex('123|456|789', '(\\p{N}).(\\p{N})', '$2-$1')
stri_replace_all_regex(c('stringi R', 'REXAMINE', '123'), '( R|R.)', ' r ')

# named capture groups are available since ICU 55
## Not run: 
stri_replace_all_regex('words 123 and numbers 456',
   '(?&lt;numbers&gt;[0-9]+)', '!${numbers}!')

## End(Not run)

# Compare the results:
stri_replace_all_fixed('The quick brown fox jumped over the lazy dog.',
     c('quick', 'brown', 'fox'), c('slow',  'black', 'bear'), vectorize_all=TRUE)
stri_replace_all_fixed('The quick brown fox jumped over the lazy dog.',
     c('quick', 'brown', 'fox'), c('slow',  'black', 'bear'), vectorize_all=FALSE)

# Compare the results:
stri_replace_all_fixed('The quicker brown fox jumped over the lazy dog.',
     c('quick', 'brown', 'fox'), c('slow',  'black', 'bear'), vectorize_all=FALSE)
stri_replace_all_regex('The quicker brown fox jumped over the lazy dog.',
     '\\b'%s+%c('quick', 'brown', 'fox')%s+%'\\b', c('slow',  'black', 'bear'), vectorize_all=FALSE)

# Searching for the last occurrence:
# Note the difference - regex searches left to right, with no overlaps.
stri_replace_last_fixed("agAGA", "aga", "*", case_insensitive=TRUE)
stri_replace_last_regex("agAGA", "aga", "*", case_insensitive=TRUE)

</code></pre>

<hr>
<h2 id='stri_replace_na'>Replace Missing Values in a Character Vector</h2><span id='topic+stri_replace_na'></span>

<h3>Description</h3>

<p>This function gives a convenient way to replace each missing (<code>NA</code>)
value with a given string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_replace_na(str, replacement = "NA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_replace_na_+3A_str">str</code></td>
<td>
<p>character vector or an object coercible to</p>
</td></tr>
<tr><td><code id="stri_replace_na_+3A_replacement">replacement</code></td>
<td>
<p>single string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is roughly equivalent to
<code>str2 &lt;- stri_enc_toutf8(str);
str2[is.na(str2)] &lt;- stri_enc_toutf8(replacement);
str2</code>.
It may be used, e.g., wherever the 'plain R' <code>NA</code> handling is
desired, see Examples.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other utils: 
<code><a href="#topic+stri_list2matrix">stri_list2matrix</a>()</code>,
<code><a href="#topic+stri_na2empty">stri_na2empty</a>()</code>,
<code><a href="#topic+stri_remove_empty">stri_remove_empty</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c('test', NA)
stri_paste(x, 1:2)                           # 'test1' NA
paste(x, 1:2)                                # 'test 1' 'NA 2'
stri_paste(stri_replace_na(x), 1:2, sep=' ') # 'test 1' 'NA 2'

</code></pre>

<hr>
<h2 id='stri_replace_rstr'>Convert gsub-Style Replacement Strings</h2><span id='topic+stri_replace_rstr'></span>

<h3>Description</h3>

<p>Converts a <code><a href="base.html#topic+gsub">gsub</a></code>-style replacement strings
to those which can be used in <code><a href="#topic+stri_replace">stri_replace</a></code>.
In particular, <code>$</code> becomes <code>\$</code> and <code>\1</code> becomes <code>$1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_replace_rstr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_replace_rstr_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_replace: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_replace_all">stri_replace_all</a>()</code>,
<code><a href="#topic+stri_trim_both">stri_trim_both</a>()</code>
</p>

<hr>
<h2 id='stri_reverse'>Reverse Each String</h2><span id='topic+stri_reverse'></span>

<h3>Description</h3>

<p>Reverses the order of the code points in every string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_reverse(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_reverse_+3A_str">str</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this operation may result in non-Unicode-normalized
strings and may give peculiar outputs for bidirectional strings.
</p>
<p>See also <code><a href="#topic+stri_rand_shuffle">stri_rand_shuffle</a></code> for a random permutation
of code points.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_reverse(c('123', 'abc d e f'))
stri_reverse('ZXY (\u0105\u0104123$^).')
stri_reverse(stri_trans_nfd('\u0105')) == stri_trans_nfd('\u0105') # A, ogonek -&gt; agonek, A

</code></pre>

<hr>
<h2 id='stri_sort'>String Sorting</h2><span id='topic+stri_sort'></span>

<h3>Description</h3>

<p>This function sorts a character vector according to a locale-dependent
lexicographic order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_sort(str, decreasing = FALSE, na_last = NA, ..., opts_collator = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_sort_+3A_str">str</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="stri_sort_+3A_decreasing">decreasing</code></td>
<td>
<p>a single logical value; should the sort order
be nondecreasing (<code>FALSE</code>, default, i.e., weakly increasing)
or nonincreasing (<code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="stri_sort_+3A_na_last">na_last</code></td>
<td>
<p>a single logical value; controls the treatment of <code>NA</code>s
in <code>str</code>. If <code>TRUE</code>, then missing values in <code>str</code> are put
at the end; if <code>FALSE</code>, they are put at the beginning;
if <code>NA</code>, then they are removed from the output</p>
</td></tr>
<tr><td><code id="stri_sort_+3A_...">...</code></td>
<td>
<p>additional settings for <code>opts_collator</code></p>
</td></tr>
<tr><td><code id="stri_sort_+3A_opts_collator">opts_collator</code></td>
<td>
<p>a named list with <span class="pkg">ICU</span> Collator's options,
see <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code>NULL</code>
for default collation options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information on <span class="pkg">ICU</span>'s Collator and how to tune it up
in <span class="pkg">stringi</span>, refer to <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>.
</p>
<p>As usual in <span class="pkg">stringi</span>, non-character inputs are coerced to strings,
see an example below for a somewhat non-intuitive behavior of lexicographic
sorting on numeric inputs.
</p>
<p>This function uses a stable sort algorithm (<span class="pkg">STL</span>'s <code>stable_sort</code>),
which performs up to <code class="reqn">N*log^2(N)</code> element comparisons,
where <code class="reqn">N</code> is the length of <code>str</code>.
</p>


<h3>Value</h3>

<p>The result is a sorted version of <code>str</code>,
i.e., a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Collation</em> - ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/collation/">https://unicode-org.github.io/icu/userguide/collation/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_sort(c('hladny', 'chladny'), locale='pl_PL')
stri_sort(c('hladny', 'chladny'), locale='sk_SK')
stri_sort(sample(LETTERS))
stri_sort(c(1, 100, 2, 101, 11, 10))  # lexicographic order
stri_sort(c(1, 100, 2, 101, 11, 10), numeric=TRUE)  # OK for integers
stri_sort(c(0.25, 0.5, 1, -1, -2, -3), numeric=TRUE)  # incorrect
</code></pre>

<hr>
<h2 id='stri_sort_key'>Sort Keys</h2><span id='topic+stri_sort_key'></span>

<h3>Description</h3>

<p>This function computes a locale-dependent sort key, which is an alternative
character representation of the string that, when ordered in the C locale
(which orders using the underlying bytes directly), will give an equivalent
ordering to the original string. It is useful for enhancing algorithms
that sort only in the C locale (e.g., the <code>strcmp</code> function in libc)
with the ability to be locale-aware.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_sort_key(str, ..., opts_collator = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_sort_key_+3A_str">str</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="stri_sort_key_+3A_...">...</code></td>
<td>
<p>additional settings for <code>opts_collator</code></p>
</td></tr>
<tr><td><code id="stri_sort_key_+3A_opts_collator">opts_collator</code></td>
<td>
<p>a named list with <span class="pkg">ICU</span> Collator's options,
see <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code>NULL</code>
for default collation options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information on <span class="pkg">ICU</span>'s Collator and how to tune it up
in <span class="pkg">stringi</span>, refer to <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>.
</p>
<p>See also <code><a href="#topic+stri_rank">stri_rank</a></code> for ranking strings with a single character
vector, i.e., generating relative sort keys.
</p>


<h3>Value</h3>

<p>The result is a character vector with the same length as <code>str</code> that
contains the sort keys. The output is marked as <code>bytes</code>-encoded.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Collation</em> - ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/collation/">https://unicode-org.github.io/icu/userguide/collation/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_sort_key(c('hladny', 'chladny'), locale='pl_PL')
stri_sort_key(c('hladny', 'chladny'), locale='sk_SK')

</code></pre>

<hr>
<h2 id='stri_split'>Split a String By Pattern Matches</h2><span id='topic+stri_split'></span><span id='topic+stri_split_fixed'></span><span id='topic+stri_split_regex'></span><span id='topic+stri_split_coll'></span><span id='topic+stri_split_charclass'></span>

<h3>Description</h3>

<p>These functions split each element in <code>str</code> into substrings.
<code>pattern</code> defines the delimiters that separate the inputs into tokens.
The input data between the matches become the fields themselves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_split(str, ..., regex, fixed, coll, charclass)

stri_split_fixed(
  str,
  pattern,
  n = -1L,
  omit_empty = FALSE,
  tokens_only = FALSE,
  simplify = FALSE,
  ...,
  opts_fixed = NULL
)

stri_split_regex(
  str,
  pattern,
  n = -1L,
  omit_empty = FALSE,
  tokens_only = FALSE,
  simplify = FALSE,
  ...,
  opts_regex = NULL
)

stri_split_coll(
  str,
  pattern,
  n = -1L,
  omit_empty = FALSE,
  tokens_only = FALSE,
  simplify = FALSE,
  ...,
  opts_collator = NULL
)

stri_split_charclass(
  str,
  pattern,
  n = -1L,
  omit_empty = FALSE,
  tokens_only = FALSE,
  simplify = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_split_+3A_str">str</code></td>
<td>
<p>character vector; strings to search in</p>
</td></tr>
<tr><td><code id="stri_split_+3A_...">...</code></td>
<td>
<p>supplementary arguments passed to the underlying functions,
including additional settings for <code>opts_collator</code>, <code>opts_regex</code>,
<code>opts_fixed</code>, and so on</p>
</td></tr>
<tr><td><code id="stri_split_+3A_pattern">pattern</code>, <code id="stri_split_+3A_regex">regex</code>, <code id="stri_split_+3A_fixed">fixed</code>, <code id="stri_split_+3A_coll">coll</code>, <code id="stri_split_+3A_charclass">charclass</code></td>
<td>
<p>character vector;
search patterns; for more details refer to <a href="#topic+stringi-search">stringi-search</a></p>
</td></tr>
<tr><td><code id="stri_split_+3A_n">n</code></td>
<td>
<p>integer vector, maximal number of strings to return,
and, at the same time, maximal number of text boundaries to look for</p>
</td></tr>
<tr><td><code id="stri_split_+3A_omit_empty">omit_empty</code></td>
<td>
<p>logical vector; determines whether empty
tokens should be removed from the result (<code>TRUE</code> or <code>FALSE</code>)
or replaced with <code>NA</code>s (<code>NA</code>)</p>
</td></tr>
<tr><td><code id="stri_split_+3A_tokens_only">tokens_only</code></td>
<td>
<p>single logical value;
may affect the result if <code>n</code> is positive, see Details</p>
</td></tr>
<tr><td><code id="stri_split_+3A_simplify">simplify</code></td>
<td>
<p>single logical value;
if <code>TRUE</code> or <code>NA</code>, then a character matrix is returned;
otherwise (the default), a list of character vectors is given, see Value</p>
</td></tr>
<tr><td><code id="stri_split_+3A_opts_collator">opts_collator</code>, <code id="stri_split_+3A_opts_fixed">opts_fixed</code>, <code id="stri_split_+3A_opts_regex">opts_regex</code></td>
<td>
<p>a named list used to tune up
the search engine's settings; see
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code><a href="#topic+stri_opts_fixed">stri_opts_fixed</a></code>,
and <code><a href="#topic+stri_opts_regex">stri_opts_regex</a></code>, respectively; <code>NULL</code>
for the defaults</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code>, <code>pattern</code>, <code>n</code>, and <code>omit_empty</code>
(with recycling of the elements in the shorter vector if necessary).
</p>
<p>If <code>n</code> is negative, then all pieces are extracted.
Otherwise, if <code>tokens_only</code> is <code>FALSE</code> (which is the default),
then <code>n-1</code> tokens are extracted (if possible) and the <code>n</code>-th string
gives the remainder (see Examples).
On the other hand, if <code>tokens_only</code> is <code>TRUE</code>,
then only full tokens (up to <code>n</code> pieces) are extracted.
</p>
<p><code>omit_empty</code> is applied during the split process: if it is set to
<code>TRUE</code>, then tokens of zero length are ignored. Thus, empty strings
will never appear in the resulting vector. On the other hand, if
<code>omit_empty</code> is <code>NA</code>, then empty tokens are substituted with
missing strings.
</p>
<p>Empty search patterns are not supported. If you wish to split a
string into individual characters, use, e.g.,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>(str, type='character')</code> for THE Unicode way.
</p>
<p><code>stri_split</code> is a convenience function. It calls either
<code>stri_split_regex</code>, <code>stri_split_fixed</code>, <code>stri_split_coll</code>,
or <code>stri_split_charclass</code>, depending on the argument used.
</p>


<h3>Value</h3>

<p>If <code>simplify=FALSE</code> (the default),
then the functions return a list of character vectors.
</p>
<p>Otherwise, <code><a href="#topic+stri_list2matrix">stri_list2matrix</a></code> with <code>byrow=TRUE</code>
and <code>n_min=n</code> arguments is called on the resulting object.
In such a case, a character matrix with an appropriate number of rows
(according to the length of <code>str</code>, <code>pattern</code>, etc.)
is returned. Note that <code><a href="#topic+stri_list2matrix">stri_list2matrix</a></code>'s <code>fill</code> argument
is set to an empty string and <code>NA</code>, for <code>simplify</code> equal to
<code>TRUE</code> and <code>NA</code>, respectively.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_split: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_split_lines">stri_split_lines</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_split_fixed('a_b_c_d', '_')
stri_split_fixed('a_b_c__d', '_')
stri_split_fixed('a_b_c__d', '_', omit_empty=TRUE)
stri_split_fixed('a_b_c__d', '_', n=2, tokens_only=FALSE) # 'a' &amp; remainder
stri_split_fixed('a_b_c__d', '_', n=2, tokens_only=TRUE) # 'a' &amp; 'b' only
stri_split_fixed('a_b_c__d', '_', n=4, omit_empty=TRUE, tokens_only=TRUE)
stri_split_fixed('a_b_c__d', '_', n=4, omit_empty=FALSE, tokens_only=TRUE)
stri_split_fixed('a_b_c__d', '_', omit_empty=NA)
stri_split_fixed(c('ab_c', 'd_ef_g', 'h', ''), '_', n=1, tokens_only=TRUE, omit_empty=TRUE)
stri_split_fixed(c('ab_c', 'd_ef_g', 'h', ''), '_', n=2, tokens_only=TRUE, omit_empty=TRUE)
stri_split_fixed(c('ab_c', 'd_ef_g', 'h', ''), '_', n=3, tokens_only=TRUE, omit_empty=TRUE)

stri_list2matrix(stri_split_fixed(c('ab,c', 'd,ef,g', ',h', ''), ',', omit_empty=TRUE))
stri_split_fixed(c('ab,c', 'd,ef,g', ',h', ''), ',', omit_empty=FALSE, simplify=TRUE)
stri_split_fixed(c('ab,c', 'd,ef,g', ',h', ''), ',', omit_empty=NA, simplify=TRUE)
stri_split_fixed(c('ab,c', 'd,ef,g', ',h', ''), ',', omit_empty=TRUE, simplify=TRUE)
stri_split_fixed(c('ab,c', 'd,ef,g', ',h', ''), ',', omit_empty=NA, simplify=NA)

stri_split_regex(c('ab,c', 'd,ef  ,  g', ',  h', ''),
   '\\p{WHITE_SPACE}*,\\p{WHITE_SPACE}*', omit_empty=NA, simplify=TRUE)

stri_split_charclass('Lorem ipsum dolor sit amet', '\\p{WHITE_SPACE}')
stri_split_charclass(' Lorem  ipsum dolor', '\\p{WHITE_SPACE}', n=3,
   omit_empty=c(FALSE, TRUE))

stri_split_regex('Lorem ipsum dolor sit amet',
   '\\p{Z}+') # see also stri_split_charclass

</code></pre>

<hr>
<h2 id='stri_split_boundaries'>Split a String at Text Boundaries</h2><span id='topic+stri_split_boundaries'></span>

<h3>Description</h3>

<p>This function locates text boundaries
(like character, word, line, or sentence boundaries)
and splits strings at the indicated positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_split_boundaries(
  str,
  n = -1L,
  tokens_only = FALSE,
  simplify = FALSE,
  ...,
  opts_brkiter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_split_boundaries_+3A_str">str</code></td>
<td>
<p>character vector or an object coercible to</p>
</td></tr>
<tr><td><code id="stri_split_boundaries_+3A_n">n</code></td>
<td>
<p>integer vector, maximal number of strings to return</p>
</td></tr>
<tr><td><code id="stri_split_boundaries_+3A_tokens_only">tokens_only</code></td>
<td>
<p>single logical value; may affect the result if <code>n</code>
is positive, see Details</p>
</td></tr>
<tr><td><code id="stri_split_boundaries_+3A_simplify">simplify</code></td>
<td>
<p>single logical value; if <code>TRUE</code> or <code>NA</code>,
then a character matrix is returned; otherwise (the default), a list of
character vectors is given, see Value</p>
</td></tr>
<tr><td><code id="stri_split_boundaries_+3A_...">...</code></td>
<td>
<p>additional settings for <code>opts_brkiter</code></p>
</td></tr>
<tr><td><code id="stri_split_boundaries_+3A_opts_brkiter">opts_brkiter</code></td>
<td>
<p>a named list with <span class="pkg">ICU</span> BreakIterator's settings,
see <code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a></code>; <code>NULL</code> for the
default break iterator, i.e., <code>line_break</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code> and <code>n</code>.
</p>
<p>If <code>n</code> is negative (the default), then all text pieces are extracted.
</p>
<p>Otherwise, if <code>tokens_only</code> is <code>FALSE</code> (which is the default),
then <code>n-1</code> tokens are extracted (if possible) and the <code>n</code>-th string
gives the (non-split) remainder (see Examples).
On the other hand, if <code>tokens_only</code> is <code>TRUE</code>,
then only full tokens (up to <code>n</code> pieces) are extracted.
</p>
<p>For more information on text boundary analysis
performed by <span class="pkg">ICU</span>'s <code>BreakIterator</code>, see
<a href="#topic+stringi-search-boundaries">stringi-search-boundaries</a>.
</p>


<h3>Value</h3>

<p>If <code>simplify=FALSE</code> (the default),
then the functions return a list of character vectors.
</p>
<p>Otherwise, <code><a href="#topic+stri_list2matrix">stri_list2matrix</a></code> with <code>byrow=TRUE</code>
and <code>n_min=n</code> arguments is called on the resulting object.
In such a case, a character matrix with <code>length(str)</code> rows
is returned. Note that <code><a href="#topic+stri_list2matrix">stri_list2matrix</a></code>'s <code>fill</code>
argument is set to an empty string and <code>NA</code>,
for <code>simplify</code> equal to <code>TRUE</code> and <code>NA</code>, respectively.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_split: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_split_lines">stri_split_lines</a>()</code>,
<code><a href="#topic+stri_split">stri_split</a>()</code>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>
<p>Other text_boundaries: 
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a>()</code>,
<code><a href="#topic+stri_split_lines">stri_split_lines</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- 'The\u00a0above-mentioned    features are very useful. ' %s+%
   'Spam, spam, eggs, bacon, and spam. 123 456 789'
stri_split_boundaries(test, type='line')
stri_split_boundaries(test, type='word')
stri_split_boundaries(test, type='word', skip_word_none=TRUE)
stri_split_boundaries(test, type='word', skip_word_none=TRUE, skip_word_letter=TRUE)
stri_split_boundaries(test, type='word', skip_word_none=TRUE, skip_word_number=TRUE)
stri_split_boundaries(test, type='sentence')
stri_split_boundaries(test, type='sentence', skip_sentence_sep=TRUE)
stri_split_boundaries(test, type='character')

# a filtered break iterator with the new ICU:
stri_split_boundaries('Mr. Jones and Mrs. Brown are very happy.
So am I, Prof. Smith.', type='sentence', locale='en_US@ss=standard') # ICU &gt;= 56 only

</code></pre>

<hr>
<h2 id='stri_split_lines'>Split a String Into Text Lines</h2><span id='topic+stri_split_lines'></span><span id='topic+stri_split_lines1'></span>

<h3>Description</h3>

<p>These functions split each character string in a given vector
into text lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_split_lines(str, omit_empty = FALSE)

stri_split_lines1(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_split_lines_+3A_str">str</code></td>
<td>
<p>character vector (<code>stri_split_lines</code>)
or a single string (<code>stri_split_lines1</code>)</p>
</td></tr>
<tr><td><code id="stri_split_lines_+3A_omit_empty">omit_empty</code></td>
<td>
<p>logical vector; determines whether empty
strings should be removed from the result
[<code>stri_split_lines</code> only]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code> and <code>omit_empty</code>.
</p>
<p><code>omit_empty</code> is applied when splitting. If set to <code>TRUE</code>,
then empty strings will never appear in the resulting vector.
</p>
<p>Newlines are represented with the Carriage Return
(CR, 0x0D), Line Feed (LF, 0x0A), CRLF, or Next Line (NEL, 0x85) characters,
depending on the platform.
Moreover, the Unicode Standard defines two unambiguous separator characters,
the Paragraph Separator (PS, 0x2029) and the Line Separator (LS, 0x2028).
Sometimes also the Vertical Tab (VT, 0x0B) and the Form Feed (FF, 0x0C)
are used for this purpose.
</p>
<p>These <span class="pkg">stringi</span> functions follow UTR#18 rules,
where a newline sequence
corresponds to the following regular expression:
<code>(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]</code>.
Each match serves as a text line separator.
</p>


<h3>Value</h3>

<p><code>stri_split_lines</code> returns a list of character vectors.
If any input string is <code>NA</code>, then the corresponding list element
is a single <code>NA</code> string.
</p>
<p><code>stri_split_lines1(str)</code> is equivalent to
<code>stri_split_lines(str[1])[[1]]</code> (with default parameters),
therefore it returns a character vector. Moreover, if the input string
ends with a newline sequence, the last empty string is omitted from the
file's contents into text lines.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Unicode Newline Guidelines</em> &ndash; Unicode Technical Report #13,
<a href="https://www.unicode.org/standard/reports/tr13/tr13-5.html">https://www.unicode.org/standard/reports/tr13/tr13-5.html</a>
</p>
<p><em>Unicode Regular Expressions</em> &ndash; Unicode Technical Standard #18,
<a href="https://www.unicode.org/reports/tr18/">https://www.unicode.org/reports/tr18/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_split: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_split">stri_split</a>()</code>
</p>
<p>Other text_boundaries: 
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>

<hr>
<h2 id='stri_sprintf'>Format Strings</h2><span id='topic+stri_sprintf'></span><span id='topic+stri_string_format'></span><span id='topic+stri_printf'></span>

<h3>Description</h3>

<p><code>stri_sprintf</code> (synonym: <code>stri_string_format</code>)
is a Unicode-aware replacement for and enhancement of
the built-in <code><a href="base.html#topic+sprintf">sprintf</a></code> function.
Moreover, <code>stri_printf</code> prints formatted strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_sprintf(
  format,
  ...,
  na_string = NA_character_,
  inf_string = "Inf",
  nan_string = "NaN",
  use_length = FALSE
)

stri_string_format(
  format,
  ...,
  na_string = NA_character_,
  inf_string = "Inf",
  nan_string = "NaN",
  use_length = FALSE
)

stri_printf(
  format,
  ...,
  file = "",
  sep = "\n",
  append = FALSE,
  na_string = "NA",
  inf_string = "Inf",
  nan_string = "NaN",
  use_length = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_sprintf_+3A_format">format</code></td>
<td>
<p>character vector of format strings</p>
</td></tr>
<tr><td><code id="stri_sprintf_+3A_...">...</code></td>
<td>
<p>vectors (coercible to integer, real, or character)</p>
</td></tr>
<tr><td><code id="stri_sprintf_+3A_na_string">na_string</code></td>
<td>
<p>single string to represent missing values;
if <code>NA</code>, missing values in <code>...</code>
result in the corresponding outputs be missing too;
use <code>"NA"</code> for compatibility with base R</p>
</td></tr>
<tr><td><code id="stri_sprintf_+3A_inf_string">inf_string</code></td>
<td>
<p>single string to represent the (unsigned) infinity (<code>NA</code> allowed)</p>
</td></tr>
<tr><td><code id="stri_sprintf_+3A_nan_string">nan_string</code></td>
<td>
<p>single string to represent the not-a-number (<code>NA</code> allowed)</p>
</td></tr>
<tr><td><code id="stri_sprintf_+3A_use_length">use_length</code></td>
<td>
<p>single logical value; should the number of code
points be used when applying modifiers such as <code>%20s</code>
instead of the total code point width?</p>
</td></tr>
<tr><td><code id="stri_sprintf_+3A_file">file</code></td>
<td>
<p>see <code><a href="base.html#topic+cat">cat</a></code></p>
</td></tr>
<tr><td><code id="stri_sprintf_+3A_sep">sep</code></td>
<td>
<p>see <code><a href="base.html#topic+cat">cat</a></code></p>
</td></tr>
<tr><td><code id="stri_sprintf_+3A_append">append</code></td>
<td>
<p>see <code><a href="base.html#topic+cat">cat</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>format</code> and all vectors passed via <code>...</code>.
</p>
<p>Unicode code points may have various widths when
printed on the console (compare <code><a href="#topic+stri_width">stri_width</a></code>).
These functions, by default (see the <code>use_length</code> argument), take this
into account.
</p>
<p>These functions are not locale sensitive. For instance, numbers are
always formatted in the &quot;POSIX&quot; style, e.g., <code>-123456.789</code>
(no thousands separator, dot as a fractional separator).
Such a feature might be added at a later date, though.
</p>
<p>All arguments passed via <code>...</code> are evaluated. If some of them
are unused, a warning is generated. Too few arguments result in an error.
</p>
<p>Note that <code>stri_printf</code> treats missing values in <code>...</code>
as <code>"NA"</code> strings by default.
</p>
<p>All format specifiers supported <code><a href="base.html#topic+sprintf">sprintf</a></code> are
also available here. For the formatting of integers and floating-point
values, currently the system <code>std::snprintf()</code> is called, but
this may change in the future. Format specifiers are normalized
and necessary sanity checks are performed.
</p>
<p>Supported conversion specifiers: <code>dioxX</code> (integers)
<code>feEgGaA</code> (floats) and <code>s</code> (character strings).
Supported flags: <code>-</code> (left-align),
<code>+</code> (force output sign or blank when <code>NaN</code> or <code>NA</code>; numeric only),
<code>&lt;space&gt;</code> (output minus or space for a sign; numeric only)
<code>0</code> (pad with 0s; numeric only),
<code>#</code> (alternative output of some numerics).
</p>


<h3>Value</h3>

<p><code>stri_printf</code> is used for its side effect, which is printing
text on the standard output or other connection/file. Hence, it returns
<code>invisible(NULL)</code>.
</p>
<p>The other functions return a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><code>printf</code> in <code>glibc</code>,
<a href="https://man.archlinux.org/man/printf.3">https://man.archlinux.org/man/printf.3</a>
</p>
<p><code>printf</code> format strings &ndash; Wikipedia,
<a href="https://en.wikipedia.org/wiki/Printf_format_string">https://en.wikipedia.org/wiki/Printf_format_string</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other length: 
<code><a href="#topic++25s+24+25">%s$%</a>()</code>,
<code><a href="#topic+stri_isempty">stri_isempty</a>()</code>,
<code><a href="#topic+stri_length">stri_length</a>()</code>,
<code><a href="#topic+stri_numbytes">stri_numbytes</a>()</code>,
<code><a href="#topic+stri_pad_both">stri_pad_both</a>()</code>,
<code><a href="#topic+stri_width">stri_width</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_printf("%4s=%.3f", c("e", "e\u00b2", "\u03c0", "\u03c0\u00b2"),
    c(exp(1), exp(2), pi, pi^2))

x &lt;- c(
  "xxabcd",
  "xx\u0105\u0106\u0107\u0108",
  stri_paste(
    "\u200b\u200b\u200b\u200b",
    "\U0001F3F4\U000E0067\U000E0062\U000E0073\U000E0063\U000E0074\U000E007F",
    "abcd"
  ))
stri_printf("[%10s]", x)  # minimum width = 10
stri_printf("[%-10.3s]", x)  # output of max width = 3, but pad to width of 10
stri_printf("[%10s]", x, use_length=TRUE)  # minimum number of Unicode code points = 10

# vectorization wrt all arguments:
p &lt;- runif(10)
stri_sprintf(ifelse(p &gt; 0.5, "P(Y=1)=%1$.2f", "P(Y=0)=%2$.2f"), p, 1-p)

# using a "preformatted" logical vector:
x &lt;- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE)
stri_sprintf("%s) %s", letters[seq_along(x)], c("\u2718", "\u2713")[x+1])

# custom NA/Inf/NaN strings:
stri_printf("%+10.3f", c(-Inf, -0, 0, Inf, NaN, NA_real_),
    na_string="&lt;NA&gt;", nan_string="\U0001F4A9", inf_string="\u221E")

stri_sprintf("UNIX time %1$f is %1$s.", Sys.time())

# the following do not work in sprintf()
stri_sprintf("%1$#- *2$.*3$f", 1.23456, 10, 3)  # two asterisks
stri_sprintf(c("%s", "%f"), pi)  # re-coercion needed
stri_sprintf("%1$s is %1$f UNIX time.", Sys.time())  # re-coercion needed
stri_sprintf(c("%d", "%s"), factor(11:12))  # re-coercion needed
stri_sprintf(c("%s", "%d"), factor(11:12))  # re-coercion needed

</code></pre>

<hr>
<h2 id='stri_startswith'>Determine if the Start or End of a String Matches a Pattern</h2><span id='topic+stri_startswith'></span><span id='topic+stri_endswith'></span><span id='topic+stri_startswith_fixed'></span><span id='topic+stri_endswith_fixed'></span><span id='topic+stri_startswith_charclass'></span><span id='topic+stri_endswith_charclass'></span><span id='topic+stri_startswith_coll'></span><span id='topic+stri_endswith_coll'></span>

<h3>Description</h3>

<p>These functions check if a string starts or ends with a match
to a given pattern. Also, it is possible to check if there is a match
at a specific position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_startswith(str, ..., fixed, coll, charclass)

stri_endswith(str, ..., fixed, coll, charclass)

stri_startswith_fixed(
  str,
  pattern,
  from = 1L,
  negate = FALSE,
  ...,
  opts_fixed = NULL
)

stri_endswith_fixed(
  str,
  pattern,
  to = -1L,
  negate = FALSE,
  ...,
  opts_fixed = NULL
)

stri_startswith_charclass(str, pattern, from = 1L, negate = FALSE)

stri_endswith_charclass(str, pattern, to = -1L, negate = FALSE)

stri_startswith_coll(
  str,
  pattern,
  from = 1L,
  negate = FALSE,
  ...,
  opts_collator = NULL
)

stri_endswith_coll(
  str,
  pattern,
  to = -1L,
  negate = FALSE,
  ...,
  opts_collator = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_startswith_+3A_str">str</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="stri_startswith_+3A_...">...</code></td>
<td>
<p>supplementary arguments passed to the underlying functions,
including additional settings for <code>opts_collator</code>, <code>opts_fixed</code>,
and so on.</p>
</td></tr>
<tr><td><code id="stri_startswith_+3A_pattern">pattern</code>, <code id="stri_startswith_+3A_fixed">fixed</code>, <code id="stri_startswith_+3A_coll">coll</code>, <code id="stri_startswith_+3A_charclass">charclass</code></td>
<td>
<p>character vector defining search patterns;
for more details refer to <a href="#topic+stringi-search">stringi-search</a></p>
</td></tr>
<tr><td><code id="stri_startswith_+3A_from">from</code></td>
<td>
<p>integer vector</p>
</td></tr>
<tr><td><code id="stri_startswith_+3A_negate">negate</code></td>
<td>
<p>single logical value; whether a no-match to a pattern
is rather of interest</p>
</td></tr>
<tr><td><code id="stri_startswith_+3A_to">to</code></td>
<td>
<p>integer vector</p>
</td></tr>
<tr><td><code id="stri_startswith_+3A_opts_collator">opts_collator</code>, <code id="stri_startswith_+3A_opts_fixed">opts_fixed</code></td>
<td>
<p>a named list used to tune up
the search engine's settings; see <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>
and <code><a href="#topic+stri_opts_fixed">stri_opts_fixed</a></code>, respectively; <code>NULL</code>
for the defaults</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code>, <code>pattern</code>,
and <code>from</code> or <code>to</code> (with recycling
of the elements in the shorter vector if necessary).
</p>
<p>If <code>pattern</code> is empty, then the result is <code>NA</code>
and a warning is generated.
</p>
<p>Argument <code>start</code> controls the start position in <code>str</code>
where there is a match to a <code>pattern</code>.
<code>to</code> gives the end position.
</p>
<p>Indexes given by <code>from</code> or <code>to</code> are of course 1-based,
i.e., an index 1 denotes the first character
in a string. This gives a typical R look-and-feel.
</p>
<p>For negative indexes in <code>from</code> or <code>to</code>, counting starts
at the end of the string. For instance, index -1 denotes the last code point
in the string.
</p>
<p>If you wish to test for a pattern match at an arbitrary
position in <code>str</code>, use <code><a href="#topic+stri_detect">stri_detect</a></code>.
</p>
<p><code>stri_startswith</code> and <code>stri_endswith</code> are convenience functions.
They call either <code>stri_*_fixed</code>, <code>stri_*_coll</code>,
or <code>stri_*_charclass</code>, depending on the argument used.
Relying on these underlying functions directly will make your code run
slightly faster.
</p>
<p>Note that testing for a pattern match at the start or end of a string
has not been implemented separately for regex patterns.
For that you may use the '<code>^</code>' and '<code>$</code>' meta-characters,
see <a href="#topic+stringi-search-regex">stringi-search-regex</a>.
</p>


<h3>Value</h3>

<p>Each function returns a logical vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_detect: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_detect">stri_detect</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_startswith_charclass(' trim me! ', '\\p{WSpace}')
stri_startswith_fixed(c('a1', 'a2', 'b3', 'a4', 'c5'), 'a')
stri_detect_regex(c('a1', 'a2', 'b3', 'a4', 'c5'), '^a')
stri_startswith_fixed('ababa', 'ba')
stri_startswith_fixed('ababa', 'ba', from=2)
stri_startswith_coll(c('a1', 'A2', 'b3', 'A4', 'C5'), 'a', strength=1)
pat &lt;- stri_paste('\u0635\u0644\u0649 \u0627\u0644\u0644\u0647 ',
                  '\u0639\u0644\u064a\u0647 \u0648\u0633\u0644\u0645XYZ')
stri_endswith_coll('\ufdfa\ufdfa\ufdfaXYZ', pat, strength=1)

</code></pre>

<hr>
<h2 id='stri_stats_general'>General Statistics for a Character Vector</h2><span id='topic+stri_stats_general'></span>

<h3>Description</h3>

<p>This function gives general statistics for a character vector,
e.g., obtained by loading a text file with the
<code><a href="base.html#topic+readLines">readLines</a></code> or <code><a href="#topic+stri_read_lines">stri_read_lines</a></code> function,
where each text line' is represented by a separate string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_stats_general(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_stats_general_+3A_str">str</code></td>
<td>
<p>character vector to be aggregated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>None of the strings may contain <code>\r</code> or <code>\n</code> characters,
otherwise you will get at error.
</p>
<p>Below by 'white space' we mean the Unicode binary property
<code>WHITE_SPACE</code>, see <code>stringi-search-charclass</code>.
</p>


<h3>Value</h3>

<p>Returns an integer vector with the following named elements:
</p>

<ol>
<li> <p><code>Lines</code> - number of lines (number of
non-missing strings in the vector);
</p>
</li>
<li> <p><code>LinesNEmpty</code> - number of lines with at least
one non-<code>WHITE_SPACE</code> character;
</p>
</li>
<li> <p><code>Chars</code> - total number of Unicode code points detected;
</p>
</li>
<li> <p><code>CharsNWhite</code> - number of Unicode code points
that are not <code>WHITE_SPACE</code>s;
</p>
</li>
<li><p> ... (Other stuff that may appear in future releases of <span class="pkg">stringi</span>).
</p>
</li></ol>



<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other stats: 
<code><a href="#topic+stri_stats_latex">stri_stats_latex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- c('Lorem ipsum dolor sit amet, consectetur adipisicing elit.',
       'nibh augue, suscipit a, scelerisque sed, lacinia in, mi.',
       'Cras vel lorem. Etiam pellentesque aliquet tellus.',
       '')
stri_stats_general(s)

</code></pre>

<hr>
<h2 id='stri_stats_latex'>Statistics for a Character Vector Containing LaTeX Commands</h2><span id='topic+stri_stats_latex'></span>

<h3>Description</h3>

<p>This function gives LaTeX-oriented statistics for a character vector,
e.g., obtained by loading a text file with the
<code><a href="base.html#topic+readLines">readLines</a></code> function, where each text line
is represented by a separate string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_stats_latex(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_stats_latex_+3A_str">str</code></td>
<td>
<p>character vector to be aggregated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use a slightly modified LaTeX Word Count algorithm implemented in
Kile 2.1.3, see
<a href="https://kile.sourceforge.io/team.php">https://kile.sourceforge.io/team.php</a> for the original contributors.
</p>


<h3>Value</h3>

<p>Returns an integer vector with the following named elements:
</p>

<ol>
<li> <p><code>CharsWord</code> - number of word characters;
</p>
</li>
<li> <p><code>CharsCmdEnvir</code> - command and words characters;
</p>
</li>
<li> <p><code>CharsWhite</code> - LaTeX white spaces, including { and } in some contexts;
</p>
</li>
<li> <p><code>Words</code> - number of words;
</p>
</li>
<li> <p><code>Cmds</code> - number of commands;
</p>
</li>
<li> <p><code>Envirs</code> - number of environments;
</p>
</li>
<li><p> ... (Other stuff that may appear in future releases of <span class="pkg">stringi</span>).
</p>
</li></ol>



<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other stats: 
<code><a href="#topic+stri_stats_general">stri_stats_general</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- c('Lorem \\textbf{ipsum} dolor sit \\textit{amet}, consectetur adipisicing elit.',
       '\\begin{small}Proin nibh augue,\\end{small} suscipit a, scelerisque sed, lacinia in, mi.',
       '')
stri_stats_latex(s)

</code></pre>

<hr>
<h2 id='stri_sub'>Extract a Substring From or Replace a Substring In a Character Vector</h2><span id='topic+stri_sub'></span><span id='topic+stri_sub+3C-'></span><span id='topic+stri_sub_replace'></span>

<h3>Description</h3>

<p><code>stri_sub</code> extracts particular substrings at code point-based
index ranges provided. Its replacement version allows to substitute
(in-place) parts of
a string with given replacement strings. <code>stri_sub_replace</code>
is its forward pipe operator-friendly variant that returns
a copy of the input vector.
</p>
<p>For extracting/replacing multiple substrings from/within each string, see
<code><a href="#topic+stri_sub_all">stri_sub_all</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_sub(
  str,
  from = 1L,
  to = -1L,
  length,
  use_matrix = TRUE,
  ignore_negative_length = FALSE
)

stri_sub(str, from = 1L, to = -1L, length, omit_na = FALSE, use_matrix = TRUE) &lt;- value

stri_sub_replace(..., replacement, value = replacement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_sub_+3A_str">str</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="stri_sub_+3A_from">from</code></td>
<td>
<p>integer vector giving the start indexes; alternatively,
if <code>use_matrix=TRUE</code>,
a two-column matrix of type <code>cbind(from, to)</code>
(unnamed columns or the 2nd column named other than <code>length</code>)
or <code>cbind(from, length=length)</code> (2nd column named <code>length</code>)</p>
</td></tr>
<tr><td><code id="stri_sub_+3A_to">to</code></td>
<td>
<p>integer vector giving the end indexes; mutually exclusive with
<code>length</code> and <code>from</code> being a matrix</p>
</td></tr>
<tr><td><code id="stri_sub_+3A_length">length</code></td>
<td>
<p>integer vector giving the substring lengths;
mutually exclusive with <code>to</code> and <code>from</code> being a matrix</p>
</td></tr>
<tr><td><code id="stri_sub_+3A_use_matrix">use_matrix</code></td>
<td>
<p>single logical value; see <code>from</code></p>
</td></tr>
<tr><td><code id="stri_sub_+3A_ignore_negative_length">ignore_negative_length</code></td>
<td>
<p>single logical value; whether
negative lengths should be ignored or result in missing values</p>
</td></tr>
<tr><td><code id="stri_sub_+3A_omit_na">omit_na</code></td>
<td>
<p>single logical value; indicates whether missing values
in any of the indexes or in <code>value</code> leave the corresponding input string
unchanged [replacement function only]</p>
</td></tr>
<tr><td><code id="stri_sub_+3A_value">value</code></td>
<td>
<p>a character vector defining the replacement strings
[replacement function only]</p>
</td></tr>
<tr><td><code id="stri_sub_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>stri_sub&lt;-</code></p>
</td></tr>
<tr><td><code id="stri_sub_+3A_replacement">replacement</code></td>
<td>
<p>alias of <code>value</code> [wherever applicable]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code>, [<code>value</code>], <code>from</code> and
(<code>to</code> or <code>length</code>). Parameters
<code>to</code> and <code>length</code> are mutually exclusive.
</p>
<p>Indexes are 1-based, i.e., the start of a string is at index 1.
For negative indexes in <code>from</code> or <code>to</code>,
counting starts at the end of the string.
For instance, index -1 denotes the last code point in the string.
Non-positive <code>length</code> gives an empty string.
</p>
<p>Argument <code>from</code> gives the start of a substring to extract.
Argument <code>to</code> defines the last index of a substring, inclusive.
Alternatively, its <code>length</code> may be provided.
</p>
<p>If <code>from</code> is a two-column matrix, then these two columns are
used as <code>from</code> and <code>to</code>, respectively,
unless the second column is named <code>length</code>.
In such a case anything passed
explicitly as <code>to</code> or <code>length</code> is ignored.
Such types of index matrices are generated by <code><a href="#topic+stri_locate_first">stri_locate_first</a></code>
and <code><a href="#topic+stri_locate_last">stri_locate_last</a></code>. If extraction based on
<code><a href="#topic+stri_locate_all">stri_locate_all</a></code> is needed, see
<code><a href="#topic+stri_sub_all">stri_sub_all</a></code>.
</p>
<p>In <code>stri_sub</code>, out-of-bound indexes are silently
corrected. If <code>from</code> &gt; <code>to</code>, then an empty string is returned.
By default, negative <code>length</code> results in the corresponding output being
<code>NA</code>, see <code>ignore_negative_length</code>, though.
</p>
<p>In <code>stri_sub&lt;-</code>, some configurations of indexes may work as
substring 'injection' at the front, back, or in middle.
Negative <code>length</code> does not alter the corresponding input string.
</p>
<p>If both <code>to</code> and <code>length</code> are provided,
<code>length</code> has priority over <code>to</code>.
</p>
<p>Note that for some Unicode strings, the extracted substrings might not
be well-formed, especially if input strings are not normalized
(see <code><a href="#topic+stri_trans_nfc">stri_trans_nfc</a></code>),
include byte order marks, Bidirectional text marks, and so on.
Handle with care.
</p>


<h3>Value</h3>

<p><code>stri_sub</code> and <code>stri_sub_replace</code> return a character vector.
<code>stri_sub&lt;-</code> changes the <code>str</code> object 'in-place'.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other indexing: 
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all">stri_locate_all</a>()</code>,
<code><a href="#topic+stri_sub_all">stri_sub_all</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- c("spam, spam, bacon, and spam", "eggs and spam")
stri_sub(s, from=-4)
stri_sub(s, from=1, length=c(10, 4))
(stri_sub(s, 1, 4) &lt;- 'stringi')

x &lt;- c('12 3456 789', 'abc', '', NA, '667')
stri_sub(x, stri_locate_first_regex(x, '[0-9]+')) # see stri_extract_first
stri_sub(x, stri_locate_last_regex(x, '[0-9]+'))  # see stri_extract_last

stri_sub_replace(x, stri_locate_first_regex(x, '[0-9]+'),
    omit_na=TRUE, replacement='***') # see stri_replace_first
stri_sub_replace(x, stri_locate_last_regex(x, '[0-9]+'),
    omit_na=TRUE, replacement='***') # see stri_replace_last


## Not run: x |&gt; stri_sub_replace(1, 5, replacement='new_substring')
</code></pre>

<hr>
<h2 id='stri_sub_all'>Extract or Replace Multiple Substrings</h2><span id='topic+stri_sub_all'></span><span id='topic+stri_sub_all+3C-'></span><span id='topic+stri_sub_replace_all'></span><span id='topic+stri_sub_all_replace'></span>

<h3>Description</h3>

<p><code>stri_sub_all</code> extracts multiple substrings from each string.
Its replacement version substitutes (in-place) multiple substrings with the
corresponding replacement strings.
<code>stri_sub_replace_all</code> (alias <code>stri_sub_all_replace</code>)
is its forward pipe operator-friendly variant, returning
a copy of the input vector.
</p>
<p>For extracting/replacing single substrings from/within each string, see
<code><a href="#topic+stri_sub">stri_sub</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_sub_all(
  str,
  from = list(1L),
  to = list(-1L),
  length,
  use_matrix = TRUE,
  ignore_negative_length = TRUE
)

stri_sub_all(
  str,
  from = list(1L),
  to = list(-1L),
  length,
  omit_na = FALSE,
  use_matrix = TRUE
) &lt;- value

stri_sub_replace_all(..., replacement, value = replacement)

stri_sub_all_replace(..., replacement, value = replacement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_sub_all_+3A_str">str</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="stri_sub_all_+3A_from">from</code></td>
<td>
<p>list of integer vector giving the start indexes; alternatively,
if <code>use_matrix=TRUE</code>, a list of two-column matrices of type
<code>cbind(from, to)</code>
(unnamed columns or the 2nd column named other than <code>length</code>)
or <code>cbind(from, length=length)</code> (2nd column named <code>length</code>)</p>
</td></tr>
<tr><td><code id="stri_sub_all_+3A_to">to</code></td>
<td>
<p>list of integer vectors giving the end indexes</p>
</td></tr>
<tr><td><code id="stri_sub_all_+3A_length">length</code></td>
<td>
<p>list of integer vectors giving the substring lengths</p>
</td></tr>
<tr><td><code id="stri_sub_all_+3A_use_matrix">use_matrix</code></td>
<td>
<p>single logical value; see <code>from</code></p>
</td></tr>
<tr><td><code id="stri_sub_all_+3A_ignore_negative_length">ignore_negative_length</code></td>
<td>
<p>single logical value; whether
negative lengths should be ignored or result in missing values</p>
</td></tr>
<tr><td><code id="stri_sub_all_+3A_omit_na">omit_na</code></td>
<td>
<p>single logical value; indicates whether missing values
in any of the indexes or in <code>value</code> leave the part of the
corresponding input string
unchanged [replacement function only]</p>
</td></tr>
<tr><td><code id="stri_sub_all_+3A_value">value</code></td>
<td>
<p>a list of character vectors defining the replacement strings
[replacement function only]</p>
</td></tr>
<tr><td><code id="stri_sub_all_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>stri_sub_all&lt;-</code></p>
</td></tr>
<tr><td><code id="stri_sub_all_+3A_replacement">replacement</code></td>
<td>
<p>alias of <code>value</code> [wherever applicable]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code>, [<code>value</code>], <code>from</code> and
(<code>to</code> or <code>length</code>). Just like in <code><a href="#topic+stri_sub">stri_sub</a></code>, parameters
<code>to</code> and <code>length</code> are mutually exclusive.
</p>
<p>In one of the simplest scenarios, <code>stri_sub_all(str, from, to)</code>,
the i-th element of the resulting list
generated like <code>stri_sub(str[i], from[[i]], to[[i]])</code>.
As usual, if one of the inputs is shorter than the others,
recycling rule is applied.
</p>
<p>If any of <code>from</code>, <code>to</code>, <code>length</code>,
or <code>value</code> is not a list,
it is wrapped into a list.
</p>
<p>If <code>from</code> consists of a two-column matrix, then these two columns are
used as <code>from</code> and <code>to</code>, respectively,
unless the second column is named <code>length</code>.
Such types of index matrices are generated by
<code><a href="#topic+stri_locate_all">stri_locate_all</a></code>.
If extraction or replacement based on <code><a href="#topic+stri_locate_first">stri_locate_first</a></code>
or <code><a href="#topic+stri_locate_last">stri_locate_last</a></code> is needed, see <code><a href="#topic+stri_sub">stri_sub</a></code>.
</p>
<p>In the replacement function, the index ranges must be sorted
with respect to <code>from</code> and must be mutually disjoint.
Negative <code>length</code> does not result in any altering of the
corresponding input string. On the other hand, in <code>stri_sub_all</code>,
this make the corresponding chunk be ignored,
see <code>ignore_negative_length</code>, though.
</p>


<h3>Value</h3>

<p><code>stri_sub_all</code> returns a list of character vectors.
Its replacement versions modify the input 'in-place'.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other indexing: 
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all">stri_locate_all</a>()</code>,
<code><a href="#topic+stri_sub">stri_sub</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c('12 3456 789', 'abc', '', NA, '667')
stri_sub_all(x, stri_locate_all_regex(x, '[0-9]+')) # see stri_extract_all
stri_sub_all(x, stri_locate_all_regex(x, '[0-9]+', omit_no_match=TRUE))

stri_sub_all(x, stri_locate_all_regex(x, '[0-9]+', omit_no_match=TRUE)) &lt;- '***'
print(x)

stri_sub_replace_all('a b c', c(1, 3, 5), c(1, 3, 5), replacement=c('A', 'B', 'C'))


</code></pre>

<hr>
<h2 id='stri_subset'>Select Elements that Match a Given Pattern</h2><span id='topic+stri_subset'></span><span id='topic+stri_subset+3C-'></span><span id='topic+stri_subset_fixed'></span><span id='topic+stri_subset_fixed+3C-'></span><span id='topic+stri_subset_charclass'></span><span id='topic+stri_subset_charclass+3C-'></span><span id='topic+stri_subset_coll'></span><span id='topic+stri_subset_coll+3C-'></span><span id='topic+stri_subset_regex'></span><span id='topic+stri_subset_regex+3C-'></span>

<h3>Description</h3>

<p>These functions return or modify a sub-vector where there is a match to
a given pattern. In other words, they
are roughly equivalent (but faster and easier to use) to a call to
<code>str[<a href="#topic+stri_detect">stri_detect</a>(str, ...)]</code> or
<code>str[<a href="#topic+stri_detect">stri_detect</a>(str, ...)] &lt;- value</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_subset(str, ..., regex, fixed, coll, charclass)

stri_subset(str, ..., regex, fixed, coll, charclass) &lt;- value

stri_subset_fixed(
  str,
  pattern,
  omit_na = FALSE,
  negate = FALSE,
  ...,
  opts_fixed = NULL
)

stri_subset_fixed(str, pattern, negate=FALSE, ..., opts_fixed=NULL) &lt;- value

stri_subset_charclass(str, pattern, omit_na = FALSE, negate = FALSE)

stri_subset_charclass(str, pattern, negate=FALSE) &lt;- value

stri_subset_coll(
  str,
  pattern,
  omit_na = FALSE,
  negate = FALSE,
  ...,
  opts_collator = NULL
)

stri_subset_coll(str, pattern, negate=FALSE, ..., opts_collator=NULL) &lt;- value

stri_subset_regex(
  str,
  pattern,
  omit_na = FALSE,
  negate = FALSE,
  ...,
  opts_regex = NULL
)

stri_subset_regex(str, pattern, negate=FALSE, ..., opts_regex=NULL) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_subset_+3A_str">str</code></td>
<td>
<p>character vector; strings to search within</p>
</td></tr>
<tr><td><code id="stri_subset_+3A_...">...</code></td>
<td>
<p>supplementary arguments passed to the underlying functions,
including additional settings for <code>opts_collator</code>, <code>opts_regex</code>,
<code>opts_fixed</code>, and so on</p>
</td></tr>
<tr><td><code id="stri_subset_+3A_value">value</code></td>
<td>
<p>non-empty character vector of replacement strings;
replacement function only</p>
</td></tr>
<tr><td><code id="stri_subset_+3A_pattern">pattern</code>, <code id="stri_subset_+3A_regex">regex</code>, <code id="stri_subset_+3A_fixed">fixed</code>, <code id="stri_subset_+3A_coll">coll</code>, <code id="stri_subset_+3A_charclass">charclass</code></td>
<td>
<p>character vector;
search patterns (no more than the length of <code>str</code>);
for more details refer to <a href="#topic+stringi-search">stringi-search</a></p>
</td></tr>
<tr><td><code id="stri_subset_+3A_omit_na">omit_na</code></td>
<td>
<p>single logical value; should missing values be excluded
from the result?</p>
</td></tr>
<tr><td><code id="stri_subset_+3A_negate">negate</code></td>
<td>
<p>single logical value; whether a no-match is rather of interest</p>
</td></tr>
<tr><td><code id="stri_subset_+3A_opts_collator">opts_collator</code>, <code id="stri_subset_+3A_opts_fixed">opts_fixed</code>, <code id="stri_subset_+3A_opts_regex">opts_regex</code></td>
<td>
<p>a named list used to tune up
the search engine's settings; see
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code><a href="#topic+stri_opts_fixed">stri_opts_fixed</a></code>,
and <code><a href="#topic+stri_opts_regex">stri_opts_regex</a></code>, respectively; <code>NULL</code>
for the defaults</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code> as well as partially over <code>pattern</code>
and <code>value</code>,
with recycling of the elements in the shorter vector if necessary.
As the aim here is to subset <code>str</code>, <code>pattern</code>
cannot be longer than the former. Moreover, if the number of
items to replace is not a multiple of length of <code>value</code>,
a warning is emitted and the unused elements are ignored.
Hence, the length of the output will be the same as length of <code>str</code>.
</p>
<p><code>stri_subset</code> and <code>stri_subset&lt;-</code> are convenience functions.
They call either <code>stri_subset_regex</code>,
<code>stri_subset_fixed</code>, <code>stri_subset_coll</code>,
or <code>stri_subset_charclass</code>,
depending on the argument used.
</p>


<h3>Value</h3>

<p>The <code>stri_subset_*</code> functions return a character vector.
As usual, the output encoding is UTF-8.
</p>
<p>The <code>stri_subset_*&lt;-</code> functions modifies <code>str</code> 'in-place'.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_subset: 
<code><a href="#topic+about_search">about_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_subset_regex(c('stringi R', '123', 'ID456', ''), '^[0-9]+$')

x &lt;- c('stringi R', '123', 'ID456', '')
`stri_subset_regex&lt;-`(x, '[0-9]+$', negate=TRUE, value=NA)  # returns a copy
stri_subset_regex(x, '[0-9]+$') &lt;- NA  # modifies `x` in-place
print(x)

</code></pre>

<hr>
<h2 id='stri_timezone_get'>Set or Get Default Time Zone in <span class="pkg">stringi</span></h2><span id='topic+stri_timezone_get'></span><span id='topic+stri_timezone_set'></span>

<h3>Description</h3>

<p><code>stri_timezone_set</code> changes the current default time zone for all functions
in the <span class="pkg">stringi</span> package, i.e., establishes the meaning of the
&ldquo;<code>NULL</code> time zone&rdquo; argument to date/time processing functions.
</p>
<p><code>stri_timezone_get</code> gets the current default time zone.
</p>
<p>For more information on time zone representation in <span class="pkg">ICU</span>
and <span class="pkg">stringi</span>, refer to <code><a href="#topic+stri_timezone_list">stri_timezone_list</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_timezone_get()

stri_timezone_set(tz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_timezone_get_+3A_tz">tz</code></td>
<td>
<p>single string; time zone identifier</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unless the default time zone has already been set using
<code>stri_timezone_set</code>, the default time zone is determined
by querying the OS with methods in <span class="pkg">ICU</span>'s internal platform utilities.
</p>


<h3>Value</h3>

<p><code>stri_timezone_set</code> returns a string with
previously used timezone, invisibly.
</p>
<p><code>stri_timezone_get</code> returns a single string
with the current default time zone.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>TimeZone</em> class &ndash; ICU API Documentation,
<a href="https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1TimeZone.html">https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1TimeZone.html</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other datetime: 
<code><a href="#topic+stri_datetime_add">stri_datetime_add</a>()</code>,
<code><a href="#topic+stri_datetime_create">stri_datetime_create</a>()</code>,
<code><a href="#topic+stri_datetime_fields">stri_datetime_fields</a>()</code>,
<code><a href="#topic+stri_datetime_format">stri_datetime_format</a>()</code>,
<code><a href="#topic+stri_datetime_fstr">stri_datetime_fstr</a>()</code>,
<code><a href="#topic+stri_datetime_now">stri_datetime_now</a>()</code>,
<code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a>()</code>,
<code><a href="#topic+stri_timezone_info">stri_timezone_info</a>()</code>,
<code><a href="#topic+stri_timezone_list">stri_timezone_list</a>()</code>
</p>
<p>Other timezone: 
<code><a href="#topic+stri_timezone_info">stri_timezone_info</a>()</code>,
<code><a href="#topic+stri_timezone_list">stri_timezone_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
oldtz &lt;- stri_timezone_set('Europe/Warsaw')
# ... many time zone-dependent operations
stri_timezone_set(oldtz) # restore previous default time zone

## End(Not run)

</code></pre>

<hr>
<h2 id='stri_timezone_info'>Query a Given Time Zone</h2><span id='topic+stri_timezone_info'></span>

<h3>Description</h3>

<p>Provides some basic information on a given time zone identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_timezone_info(tz = NULL, locale = NULL, display_type = "long")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_timezone_info_+3A_tz">tz</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for default time zone,
or a single string with time zone ID otherwise</p>
</td></tr>
<tr><td><code id="stri_timezone_info_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for default locale,
or a single string with locale identifier</p>
</td></tr>
<tr><td><code id="stri_timezone_info_+3A_display_type">display_type</code></td>
<td>
<p>single string;
one of <code>'short'</code>, <code>'long'</code>, <code>'generic_short'</code>,
<code>'generic_long'</code>, <code>'gmt_short'</code>, <code>'gmt_long'</code>,
<code>'common'</code>, <code>'generic_location'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used to fetch basic information
on any supported time zone.
</p>
<p>For more information on time zone representation in <span class="pkg">ICU</span>,
see <code><a href="#topic+stri_timezone_list">stri_timezone_list</a></code>.
</p>


<h3>Value</h3>

<p>Returns a list with the following named components:
</p>

<ol>
<li> <p><code>ID</code> (time zone identifier),
</p>
</li>
<li> <p><code>Name</code> (localized human-readable time zone name),
</p>
</li>
<li> <p><code>Name.Daylight</code> (localized human-readable time zone
name when DST is used, if available),
</p>
</li>
<li> <p><code>Name.Windows</code> (Windows time zone ID, if available),
</p>
</li>
<li> <p><code>RawOffset</code> (raw GMT offset, in hours, before taking
daylight savings into account), and
</p>
</li>
<li> <p><code>UsesDaylightTime</code> (states whether a time zone uses
daylight savings time in the current Gregorian calendar year).
</p>
</li></ol>



<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other datetime: 
<code><a href="#topic+stri_datetime_add">stri_datetime_add</a>()</code>,
<code><a href="#topic+stri_datetime_create">stri_datetime_create</a>()</code>,
<code><a href="#topic+stri_datetime_fields">stri_datetime_fields</a>()</code>,
<code><a href="#topic+stri_datetime_format">stri_datetime_format</a>()</code>,
<code><a href="#topic+stri_datetime_fstr">stri_datetime_fstr</a>()</code>,
<code><a href="#topic+stri_datetime_now">stri_datetime_now</a>()</code>,
<code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a>()</code>,
<code><a href="#topic+stri_timezone_get">stri_timezone_get</a>()</code>,
<code><a href="#topic+stri_timezone_list">stri_timezone_list</a>()</code>
</p>
<p>Other timezone: 
<code><a href="#topic+stri_timezone_get">stri_timezone_get</a>()</code>,
<code><a href="#topic+stri_timezone_list">stri_timezone_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_timezone_info()
stri_timezone_info(locale='sk_SK')
sapply(c('short', 'long', 'generic_short', 'generic_long',
         'gmt_short', 'gmt_long', 'common', 'generic_location'),
  function(e) stri_timezone_info('Europe/London', display_type=e))

</code></pre>

<hr>
<h2 id='stri_timezone_list'>List Available Time Zone Identifiers</h2><span id='topic+stri_timezone_list'></span>

<h3>Description</h3>

<p>Returns a list of available time zone identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_timezone_list(region = NA_character_, offset = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_timezone_list_+3A_region">region</code></td>
<td>
<p>single string;
a ISO 3166 two-letter country code or UN M.49 three-digit area code;
<code>NA</code> for all regions</p>
</td></tr>
<tr><td><code id="stri_timezone_list_+3A_offset">offset</code></td>
<td>
<p>single numeric value;
a given raw offset from GMT, in hours;
<code>NA</code> for all offsets</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>offset</code> and <code>region</code> are <code>NA</code> (the default), then
all time zones are returned. Otherwise,
only time zone identifiers with a given raw offset from GMT
and/or time zones corresponding to a given region are provided.
Note that the effect of daylight savings time is ignored.
</p>
<p>A time zone represents an offset applied to the Greenwich Mean Time (GMT)
to obtain local time (Universal Coordinated Time, or UTC, is similar,
but not precisely identical, to GMT; in <span class="pkg">ICU</span> the two terms
are used interchangeably since <span class="pkg">ICU</span> does not concern itself with
either leap seconds or historical behavior).
The offset might vary throughout the year, if daylight savings time (DST)
is used, or might be the same all year long.
Typically, regions closer to the equator do not use DST.
If DST is in use, then specific rules define the point where
the offset changes and the amount by which it changes.
</p>
<p>If DST is observed, then three additional bits of information are needed:
</p>

<ol>
<li><p> The precise date and time during the year when DST begins.
In the first half of the year it is in the northern hemisphere,
and in the second half of the year it is in the southern hemisphere.
</p>
</li>
<li><p> The precise date and time during the year when DST ends.
In the first half of the year it is in the southern hemisphere,
and in the second half of the year it is in the northern hemisphere.
</p>
</li>
<li><p> The amount by which the GMT offset changes when DST is in effect.
This is almost always one hour.
</p>
</li></ol>



<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>TimeZone</em> class &ndash; ICU API Documentation,
<a href="https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1TimeZone.html">https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1TimeZone.html</a>
</p>
<p><em>ICU TimeZone classes</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/datetime/timezone/">https://unicode-org.github.io/icu/userguide/datetime/timezone/</a>
</p>
<p><em>Date/Time Services</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/datetime/">https://unicode-org.github.io/icu/userguide/datetime/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other datetime: 
<code><a href="#topic+stri_datetime_add">stri_datetime_add</a>()</code>,
<code><a href="#topic+stri_datetime_create">stri_datetime_create</a>()</code>,
<code><a href="#topic+stri_datetime_fields">stri_datetime_fields</a>()</code>,
<code><a href="#topic+stri_datetime_format">stri_datetime_format</a>()</code>,
<code><a href="#topic+stri_datetime_fstr">stri_datetime_fstr</a>()</code>,
<code><a href="#topic+stri_datetime_now">stri_datetime_now</a>()</code>,
<code><a href="#topic+stri_datetime_symbols">stri_datetime_symbols</a>()</code>,
<code><a href="#topic+stri_timezone_get">stri_timezone_get</a>()</code>,
<code><a href="#topic+stri_timezone_info">stri_timezone_info</a>()</code>
</p>
<p>Other timezone: 
<code><a href="#topic+stri_timezone_get">stri_timezone_get</a>()</code>,
<code><a href="#topic+stri_timezone_info">stri_timezone_info</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_timezone_list()
stri_timezone_list(offset=1)
stri_timezone_list(offset=5.5)
stri_timezone_list(offset=5.75)
stri_timezone_list(region='PL')
stri_timezone_list(region='US', offset=-10)

# Fetch information on all time zones
do.call(rbind.data.frame,
   lapply(stri_timezone_list(), function(tz) stri_timezone_info(tz)))

</code></pre>

<hr>
<h2 id='stri_trans_char'>Translate Characters</h2><span id='topic+stri_trans_char'></span>

<h3>Description</h3>

<p>Translates Unicode code points in each input string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_trans_char(str, pattern, replacement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_trans_char_+3A_str">str</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="stri_trans_char_+3A_pattern">pattern</code></td>
<td>
<p>a single character string providing code points to be translated</p>
</td></tr>
<tr><td><code id="stri_trans_char_+3A_replacement">replacement</code></td>
<td>
<p>a single character string giving translated code points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code> and with respect to each code point
in <code>pattern</code> and <code>replacement</code>.
</p>
<p>If <code>pattern</code> and <code>replacement</code> consist of a different number
of code points, then the extra code points in the longer of the two
are ignored, with a warning.
</p>
<p>If code points in a given <code>pattern</code> are not unique, the
last corresponding replacement code point is used.
</p>
<p>Time complexity for each string in <code>str</code> is
O(<code>stri_length(str)*stri_length(pattern)</code>).
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other transform: 
<code><a href="#topic+stri_trans_general">stri_trans_general</a>()</code>,
<code><a href="#topic+stri_trans_list">stri_trans_list</a>()</code>,
<code><a href="#topic+stri_trans_nfc">stri_trans_nfc</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_trans_char('id.123', '.', '_')
stri_trans_char('babaab', 'ab', '01')
stri_trans_char('GCUACGGAGCUUCGGAGCUAG', 'ACGT', 'TGCA')
</code></pre>

<hr>
<h2 id='stri_trans_general'>General Text Transforms, Including Transliteration</h2><span id='topic+stri_trans_general'></span>

<h3>Description</h3>

<p><span class="pkg">ICU</span> General transforms provide different ways
for processing Unicode text. They are useful in handling a variety
of different tasks, including:
</p>

<ul>
<li><p>    locale-independent upper case, lower case, title case,
full/halfwidth conversions,
</p>
</li>
<li><p>    normalization,
</p>
</li>
<li><p>    hex and character name conversions,
</p>
</li>
<li><p>    script to script conversion/transliteration.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>stri_trans_general(str, id, rules = FALSE, forward = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_trans_general_+3A_str">str</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="stri_trans_general_+3A_id">id</code></td>
<td>
<p>a single string with transform identifier,
see <code><a href="#topic+stri_trans_list">stri_trans_list</a></code>, or custom transliteration rules</p>
</td></tr>
<tr><td><code id="stri_trans_general_+3A_rules">rules</code></td>
<td>
<p>if <code>TRUE</code>, treat <code>id</code> as a string with
semicolon-separated transliteration rules (see the <span class="pkg">ICU</span> manual);</p>
</td></tr>
<tr><td><code id="stri_trans_general_+3A_forward">forward</code></td>
<td>
<p>transliteration direction (<code>TRUE</code> for forward,
<code>FALSE</code> for reverse)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">ICU</span> Transforms were mainly designed to transliterate characters
from one script to another (for example, from Greek to Latin,
or Japanese Katakana to Latin).
However, these services are also capable of handling a much
broader range of tasks.
In particular, the Transforms include prebuilt transformations
for case conversions, for normalization conversions, for the removal
of given characters, and also for a variety of language and script
transliterations. Transforms can be chained together to perform
a series of operations and each step of the process can use a
UnicodeSet to restrict the characters that are affected.
</p>
<p>To get the list of available transforms,
call <code><a href="#topic+stri_trans_list">stri_trans_list</a></code>.
</p>
<p>Note that transliterators are often combined in sequence
to achieve a desired transformation.
This is analogous to the composition of mathematical functions.
For example, given a script that converts lowercase ASCII characters
from Latin script to Katakana script, it is convenient to first
(1) separate input base characters and accents, and then (2)
convert uppercase to lowercase.
To achieve this, a compound transform can be specified as follows:
<code>NFKD; Lower; Latin-Katakana;</code> (with the default <code>rules=FALSE</code>).
</p>
<p>Custom rule-based transliteration is also supported, see the <span class="pkg">ICU</span>
manual and below for some examples.
</p>
<p>Transliteration is not dependent on the current locale.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>General Transforms</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/transforms/general/">https://unicode-org.github.io/icu/userguide/transforms/general/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other transform: 
<code><a href="#topic+stri_trans_char">stri_trans_char</a>()</code>,
<code><a href="#topic+stri_trans_list">stri_trans_list</a>()</code>,
<code><a href="#topic+stri_trans_nfc">stri_trans_nfc</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_trans_general('gro\u00df', 'latin-ascii')
stri_trans_general('stringi', 'latin-greek')
stri_trans_general('stringi', 'latin-cyrillic')
stri_trans_general('stringi', 'upper') # see stri_trans_toupper
stri_trans_general('\u0104', 'nfd; lower') # compound id; see stri_trans_nfd
stri_trans_general('Marek G\u0105golewski', 'pl-pl_FONIPA')
stri_trans_general('\u2620', 'any-name') # character name
stri_trans_general('\\N{latin small letter a}', 'name-any') # decode name
stri_trans_general('\u2620', 'hex/c') # to hex
stri_trans_general("\u201C\u2026\u201D \u0105\u015B\u0107\u017C",
    "NFKD; NFC; [^\\p{L}] latin-ascii")

x &lt;- "\uC885\uB85C\uAD6C \uC0AC\uC9C1\uB3D9"
stringi::stri_trans_general(x, "Hangul-Latin")
# Deviate from the ICU rules of romanisation of Korean,
# see https://en.wikipedia.org/wiki/Romanization_of_Korean
id &lt;- "
    :: NFD;
    \u11A8 &gt; k;
    \u11AE &gt; t;
    \u11B8 &gt; p;
    \u1105 &gt; r;
    :: Hangul-Latin;
"
stringi::stri_trans_general(x, id, rules=TRUE)


</code></pre>

<hr>
<h2 id='stri_trans_list'>List Available Text Transforms and Transliterators</h2><span id='topic+stri_trans_list'></span>

<h3>Description</h3>

<p>Returns a list of available text transform identifiers.
Each of them may be used in <code><a href="#topic+stri_trans_general">stri_trans_general</a></code>
tasks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_trans_list()
</code></pre>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>General Transforms</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/transforms/general/">https://unicode-org.github.io/icu/userguide/transforms/general/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other transform: 
<code><a href="#topic+stri_trans_char">stri_trans_char</a>()</code>,
<code><a href="#topic+stri_trans_general">stri_trans_general</a>()</code>,
<code><a href="#topic+stri_trans_nfc">stri_trans_nfc</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_trans_list()

</code></pre>

<hr>
<h2 id='stri_trans_nfc'>Perform or Check For Unicode Normalization</h2><span id='topic+stri_trans_nfc'></span><span id='topic+stri_trans_nfd'></span><span id='topic+stri_trans_nfkd'></span><span id='topic+stri_trans_nfkc'></span><span id='topic+stri_trans_nfkc_casefold'></span><span id='topic+stri_trans_isnfc'></span><span id='topic+stri_trans_isnfd'></span><span id='topic+stri_trans_isnfkd'></span><span id='topic+stri_trans_isnfkc'></span><span id='topic+stri_trans_isnfkc_casefold'></span>

<h3>Description</h3>

<p>These functions convert strings to NFC, NFKC, NFD, NFKD, or NFKC_Casefold
Unicode Normalization Form or check whether strings are normalized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_trans_nfc(str)

stri_trans_nfd(str)

stri_trans_nfkd(str)

stri_trans_nfkc(str)

stri_trans_nfkc_casefold(str)

stri_trans_isnfc(str)

stri_trans_isnfd(str)

stri_trans_isnfkd(str)

stri_trans_isnfkc(str)

stri_trans_isnfkc_casefold(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_trans_nfc_+3A_str">str</code></td>
<td>
<p>character vector to be encoded</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unicode Normalization Forms are formally defined normalizations of Unicode
strings which, e.g., make possible to determine whether any two
strings are equivalent.
Essentially, the Unicode Normalization Algorithm puts all combining
marks in a specified order, and uses rules for decomposition
and composition to transform each string into one of the
Unicode Normalization Forms.
</p>
<p>The following Normalization Forms (NFs) are supported:
</p>

<ul>
<li><p> NFC (Canonical Decomposition, followed by Canonical Composition),
</p>
</li>
<li><p> NFD (Canonical Decomposition),
</p>
</li>
<li><p> NFKC (Compatibility Decomposition, followed by Canonical Composition),
</p>
</li>
<li><p> NFKD (Compatibility Decomposition),
</p>
</li>
<li><p> NFKC_Casefold (combination of NFKC, case folding, and removing ignorable
characters which was introduced with Unicode 5.2).
</p>
</li></ul>

<p>Note that many W3C Specifications recommend using NFC for all content,
because this form avoids potential interoperability problems arising
from the use of canonically equivalent, yet different,
character sequences in document formats on the Web.
Thus, you will rather not use these functions in typical
string processing activities. Most often you may assume
that a string is in NFC, see RFC5198.
</p>
<p>As usual in <span class="pkg">stringi</span>,
if the input character vector is in the native encoding,
it will be automatically converted to UTF-8.
</p>
<p>For more general text transforms refer to <code><a href="#topic+stri_trans_general">stri_trans_general</a></code>.
</p>


<h3>Value</h3>

<p>The <code>stri_trans_nf*</code> functions return a character vector
of the same length as input (the output is always in UTF-8).
</p>
<p><code>stri_trans_isnf*</code> return a logical vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Unicode Normalization Forms</em> &ndash; Unicode Standard Annex #15,
<a href="https://unicode.org/reports/tr15/">https://unicode.org/reports/tr15/</a>
</p>
<p><em>Unicode Format for Network Interchange</em>
&ndash; RFC5198, <a href="https://www.rfc-editor.org/rfc/rfc5198">https://www.rfc-editor.org/rfc/rfc5198</a>
</p>
<p><em>Character Model for the World Wide Web 1.0: Normalization</em>
&ndash; W3C Working Draft, <a href="https://www.w3.org/TR/charmod-norm/">https://www.w3.org/TR/charmod-norm/</a>
</p>
<p><em>Normalization</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/transforms/normalization/">https://unicode-org.github.io/icu/userguide/transforms/normalization/</a>
(technical details)
</p>
<p><em>Unicode Equivalence</em> &ndash; Wikipedia,
<a href="https://en.wikipedia.org/wiki/Unicode_equivalence">https://en.wikipedia.org/wiki/Unicode_equivalence</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other transform: 
<code><a href="#topic+stri_trans_char">stri_trans_char</a>()</code>,
<code><a href="#topic+stri_trans_general">stri_trans_general</a>()</code>,
<code><a href="#topic+stri_trans_list">stri_trans_list</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_trans_nfd('\u0105') # a with ogonek -&gt; a, ogonek
stri_trans_nfkc('\ufdfa') # 1 codepoint -&gt; 18 codepoints

</code></pre>

<hr>
<h2 id='stri_trans_tolower'>Transform Strings with Case Mapping or Folding</h2><span id='topic+stri_trans_tolower'></span><span id='topic+stri_trans_toupper'></span><span id='topic+stri_trans_casefold'></span><span id='topic+stri_trans_totitle'></span>

<h3>Description</h3>

<p>These functions transform strings either to lower case,
UPPER CASE, or Title Case or perform case folding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_trans_tolower(str, locale = NULL)

stri_trans_toupper(str, locale = NULL)

stri_trans_casefold(str)

stri_trans_totitle(str, ..., opts_brkiter = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_trans_tolower_+3A_str">str</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="stri_trans_tolower_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for case mapping following
the conventions of the default locale, or a single string with
locale identifier, see <a href="#topic+stringi-locale">stringi-locale</a>.</p>
</td></tr>
<tr><td><code id="stri_trans_tolower_+3A_...">...</code></td>
<td>
<p>additional settings for <code>opts_brkiter</code></p>
</td></tr>
<tr><td><code id="stri_trans_tolower_+3A_opts_brkiter">opts_brkiter</code></td>
<td>
<p>a named list with <span class="pkg">ICU</span> BreakIterator's settings,
see <code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a></code>;
<code>NULL</code> for default break iterator, i.e., <code>word</code>;
<code>stri_trans_totitle</code> only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code>.
</p>
<p><span class="pkg">ICU</span> implements full Unicode string case mappings. It is
worth noting that, generally, case mapping:
</p>

<ul>
<li><p> can change the number of code points and/or code units
of a string,
</p>
</li>
<li><p> is language-sensitive (results may differ depending on the locale), and
</p>
</li>
<li><p> is context-sensitive (a character in the input string may map
differently depending on surrounding characters).
</p>
</li></ul>

<p>With <code>stri_trans_totitle</code>, if <code>word</code> <code>BreakIterator</code>
is used (the default), then the first letter of each word will be capitalized
and the rest will be transformed to lower case.
With the break iterator of type <code>sentence</code>, the first letter
of each sentence will be capitalized only.
Note that according the <span class="pkg">ICU</span> User Guide,
the string <code>'one. two. three.'</code> consists of one sentence.
</p>
<p>Case folding, on the other hand, is locale-independent.
Its purpose is to make two pieces of text that differ only in case identical.
This may come in handy when comparing strings.
</p>
<p>For more general (but not locale dependent)
text transforms refer to <code><a href="#topic+stri_trans_general">stri_trans_general</a></code>.
</p>


<h3>Value</h3>

<p>Each function returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Case Mappings</em> &ndash; ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/transforms/casemappings.html">https://unicode-org.github.io/icu/userguide/transforms/casemappings.html</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>
<p>Other transform: 
<code><a href="#topic+stri_trans_char">stri_trans_char</a>()</code>,
<code><a href="#topic+stri_trans_general">stri_trans_general</a>()</code>,
<code><a href="#topic+stri_trans_list">stri_trans_list</a>()</code>,
<code><a href="#topic+stri_trans_nfc">stri_trans_nfc</a>()</code>
</p>
<p>Other text_boundaries: 
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_split_lines">stri_split_lines</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_trans_toupper('\u00DF', 'de_DE') # small German Eszett / scharfes S
stri_cmp_eq(stri_trans_toupper('i', 'en_US'), stri_trans_toupper('i', 'tr_TR'))
stri_trans_toupper(c('abc', '123', '\u0105\u0104'))
stri_trans_tolower(c('AbC', '123', '\u0105\u0104'))
stri_trans_totitle(c('AbC', '123', '\u0105\u0104'))
stri_trans_casefold(c('AbC', '123', '\u0105\u0104'))
stri_trans_totitle('stringi is a FREE R pAcKaGe. WItH NO StrinGS attached.') # word boundary
stri_trans_totitle('stringi is a FREE R pAcKaGe. WItH NO StrinGS attached.', type='sentence')
</code></pre>

<hr>
<h2 id='stri_trim_both'>Trim Characters from the Left and/or Right Side of a String</h2><span id='topic+stri_trim_both'></span><span id='topic+stri_trim'></span><span id='topic+stri_trim_left'></span><span id='topic+stri_trim_right'></span>

<h3>Description</h3>

<p>These functions may be used, e.g., to remove unnecessary
white-spaces from strings. Trimming ends at the first or
starts at the last <code>pattern</code> match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_trim_both(str, pattern = "\\P{Wspace}", negate = FALSE)

stri_trim_left(str, pattern = "\\P{Wspace}", negate = FALSE)

stri_trim_right(str, pattern = "\\P{Wspace}", negate = FALSE)

stri_trim(
  str,
  side = c("both", "left", "right"),
  pattern = "\\P{Wspace}",
  negate = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_trim_both_+3A_str">str</code></td>
<td>
<p>a character vector of strings to be trimmed</p>
</td></tr>
<tr><td><code id="stri_trim_both_+3A_pattern">pattern</code></td>
<td>
<p>a single pattern, specifying the class of characters
(see <a href="#topic+stringi-search-charclass">stringi-search-charclass</a>) to
to be preserved (if <code>negate</code> is <code>FALSE</code>; default)
or trimmed (otherwise)</p>
</td></tr>
<tr><td><code id="stri_trim_both_+3A_negate">negate</code></td>
<td>
<p>either <code>TRUE</code> or <code>FALSE</code>; see <code>pattern</code></p>
</td></tr>
<tr><td><code id="stri_trim_both_+3A_side">side</code></td>
<td>
<p>character [<code>stri_trim</code> only]; defaults to <code>'both'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code> and <code>pattern</code>.
</p>
<p><code>stri_trim</code> is a convenience wrapper over <code>stri_trim_left</code>
and <code>stri_trim_right</code>.
</p>
<p>Contrary to many other string processing libraries,
our trimming functions are universal. The class of characters
to be retained or trimmed can be adjusted.
</p>
<p>For replacing pattern matches with
an arbitrary replacement string, see <code><a href="#topic+stri_replace">stri_replace</a></code>.
</p>
<p>Trimming can also be used where you would normally rely on
regular expressions. For instance, you may get
<code>'23.5'</code> out of <code>'total of 23.5 bitcoins'</code>.
</p>
<p>For trimming white-spaces, please note the difference
between Unicode binary property '<code>\p{Wspace}</code>' (more universal)
and general character category '<code>\p{Z}</code>',
see <a href="#topic+stringi-search-charclass">stringi-search-charclass</a>.
</p>


<h3>Value</h3>

<p>All functions return a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other search_replace: 
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_replace_all">stri_replace_all</a>()</code>,
<code><a href="#topic+stri_replace_rstr">stri_replace_rstr</a>()</code>
</p>
<p>Other search_charclass: 
<code><a href="#topic+about_search_charclass">about_search_charclass</a></code>,
<code><a href="#topic+about_search">about_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_trim_left('               aaa')
stri_trim_right('r-project.org/', '\\P{P}')
stri_trim_both(' Total of 23.5 bitcoins. ', '\\p{N}')
stri_trim_both(' Total of 23.5 bitcoins. ', '\\P{N}', negate=TRUE)

</code></pre>

<hr>
<h2 id='stri_unescape_unicode'>Un-escape All Escape Sequences</h2><span id='topic+stri_unescape_unicode'></span>

<h3>Description</h3>

<p>Un-escapes all known escape sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_unescape_unicode(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_unescape_unicode_+3A_str">str</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <span class="pkg">ICU</span>'s facilities to un-escape Unicode character sequences.
</p>
<p>The following escape sequences are recognized:
<code>\a</code>, <code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\v</code>, <code>\?</code>,
<code>\e</code>, <code>\f</code>, <code>\r</code>, <code>\"</code>, <code>\'</code>, <code>\\</code>,
<code>\uXXXX</code> (4 hex digits),
<code>\UXXXXXXXX</code> (8 hex digits),
<code>\xXX</code> (1-2 hex digits),
<code>\ooo</code> (1-3 octal digits),
<code>\cX</code> (control-X; X is masked with 0x1F).
For <code>\xXX</code> and <code>\ooo</code>, beware of non-valid UTF-8 byte sequences.
</p>
<p>Note that some versions of R on Windows cannot handle
characters defined with <code>\UXXXXXXXX</code>.
</p>


<h3>Value</h3>

<p>Returns a character vector.
If an escape sequence is ill-formed,
the result will be <code>NA</code> and a warning will be given.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other escape: 
<code><a href="#topic+stri_escape_unicode">stri_escape_unicode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_unescape_unicode('a\\u0105!\\u0032\\n')

</code></pre>

<hr>
<h2 id='stri_unique'>Extract Unique Elements</h2><span id='topic+stri_unique'></span>

<h3>Description</h3>

<p>This function returns a character vector like <code>str</code>,
but with duplicate elements removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_unique(str, ..., opts_collator = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_unique_+3A_str">str</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="stri_unique_+3A_...">...</code></td>
<td>
<p>additional settings for <code>opts_collator</code></p>
</td></tr>
<tr><td><code id="stri_unique_+3A_opts_collator">opts_collator</code></td>
<td>
<p>a named list with <span class="pkg">ICU</span> Collator's options,
see <code><a href="#topic+stri_opts_collator">stri_opts_collator</a></code>, <code>NULL</code>
for default collation options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As usual in <span class="pkg">stringi</span>, no attributes are copied.
Unlike <code><a href="base.html#topic+unique">unique</a></code>, this function
tests for canonical equivalence of strings (and not
whether the strings are just bytewise equal). Such an operation
is locale-dependent. Hence, <code>stri_unique</code> is significantly
slower (but much better suited for natural language processing)
than its base R counterpart.
</p>
<p>See also <code><a href="#topic+stri_duplicated">stri_duplicated</a></code> for indicating non-unique elements.
</p>


<h3>Value</h3>

<p>Returns a character vector.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>Collation</em> - ICU User Guide,
<a href="https://unicode-org.github.io/icu/userguide/collation/">https://unicode-org.github.io/icu/userguide/collation/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_wrap">stri_wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># normalized and non-Unicode-normalized version of the same code point:
stri_unique(c('\u0105', stri_trans_nfkd('\u0105')))
unique(c('\u0105', stri_trans_nfkd('\u0105')))

stri_unique(c('gro\u00df', 'GROSS', 'Gro\u00df', 'Gross'), strength=1)

</code></pre>

<hr>
<h2 id='stri_width'>Determine the Width of Code Points</h2><span id='topic+stri_width'></span>

<h3>Description</h3>

<p>Approximates the number of text columns the 'cat()' function
might use to print a string using a mono-spaced font.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_width(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_width_+3A_str">str</code></td>
<td>
<p>character vector or an object coercible to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Unicode standard does not formalize the notion of a character
width. Roughly based on <a href="http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c">http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c</a>,
<a href="https://github.com/nodejs/node/blob/master/src/node_i18n.cc">https://github.com/nodejs/node/blob/master/src/node_i18n.cc</a>,
and UAX #11 we proceed as follows.
The following code points are of width 0:
</p>

<ul>
<li><p> code points with general category (see <a href="#topic+stringi-search-charclass">stringi-search-charclass</a>)
<code>Me</code>, <code>Mn</code>, and <code>Cf</code>),
</p>
</li>
<li> <p><code>C0</code> and <code>C1</code> control codes (general category <code>Cc</code>)
- for compatibility with the <code><a href="base.html#topic+nchar">nchar</a></code> function,
</p>
</li>
<li><p> Hangul Jamo medial vowels and final consonants
(code points with enumerable property <code>UCHAR_HANGUL_SYLLABLE_TYPE</code>
equal to <code>U_HST_VOWEL_JAMO</code> or <code>U_HST_TRAILING_JAMO</code>;
note that applying the NFC normalization with <code><a href="#topic+stri_trans_nfc">stri_trans_nfc</a></code>
is encouraged),
</p>
</li>
<li><p> ZERO WIDTH SPACE (U+200B),
</p>
</li></ul>

<p>Characters with the <code>UCHAR_EAST_ASIAN_WIDTH</code> enumerable property
equal to <code>U_EA_FULLWIDTH</code> or <code>U_EA_WIDE</code> are
of width 2.
</p>
<p>Most emojis and characters with general category So (other symbols)
are of width 2.
</p>
<p>SOFT HYPHEN (U+00AD) (for compatibility with <code><a href="base.html#topic+nchar">nchar</a></code>)
as well as any other characters have width 1.
</p>


<h3>Value</h3>

<p>Returns an integer vector of the same length as <code>str</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p><em>East Asian Width</em> &ndash; Unicode Standard Annex #11,
<a href="https://www.unicode.org/reports/tr11/">https://www.unicode.org/reports/tr11/</a>
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other length: 
<code><a href="#topic++25s+24+25">%s$%</a>()</code>,
<code><a href="#topic+stri_isempty">stri_isempty</a>()</code>,
<code><a href="#topic+stri_length">stri_length</a>()</code>,
<code><a href="#topic+stri_numbytes">stri_numbytes</a>()</code>,
<code><a href="#topic+stri_pad_both">stri_pad_both</a>()</code>,
<code><a href="#topic+stri_sprintf">stri_sprintf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stri_width(LETTERS[1:5])
stri_width(stri_trans_nfkd('\u0105'))
stri_width(stri_trans_nfkd('\U0001F606'))
stri_width( # Full-width equivalents of ASCII characters:
   stri_enc_fromutf32(as.list(c(0x3000, 0xFF01:0xFF5E)))
)
stri_width(stri_trans_nfkd('\ubc1f')) # includes Hangul Jamo medial vowels and final consonants
</code></pre>

<hr>
<h2 id='stri_wrap'>Word Wrap Text to Format Paragraphs</h2><span id='topic+stri_wrap'></span>

<h3>Description</h3>

<p>This function breaks text paragraphs into lines,
of total width (if it is possible) at most given <code>width</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_wrap(
  str,
  width = floor(0.9 * getOption("width")),
  cost_exponent = 2,
  simplify = TRUE,
  normalize = TRUE,
  normalise = normalize,
  indent = 0,
  exdent = 0,
  prefix = "",
  initial = prefix,
  whitespace_only = FALSE,
  use_length = FALSE,
  locale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_wrap_+3A_str">str</code></td>
<td>
<p>character vector of strings to reformat</p>
</td></tr>
<tr><td><code id="stri_wrap_+3A_width">width</code></td>
<td>
<p>single integer giving the suggested
maximal total width/number of code points per line</p>
</td></tr>
<tr><td><code id="stri_wrap_+3A_cost_exponent">cost_exponent</code></td>
<td>
<p>single numeric value, values not greater than zero
will select a greedy word-wrapping algorithm; otherwise
this value denotes the exponent in the cost function
of a (more aesthetic) dynamic programming-based algorithm
(values in [2, 3] are recommended)</p>
</td></tr>
<tr><td><code id="stri_wrap_+3A_simplify">simplify</code></td>
<td>
<p>single logical value, see Value</p>
</td></tr>
<tr><td><code id="stri_wrap_+3A_normalize">normalize</code></td>
<td>
<p>single logical value, see Details</p>
</td></tr>
<tr><td><code id="stri_wrap_+3A_normalise">normalise</code></td>
<td>
<p>alias of <code>normalize</code></p>
</td></tr>
<tr><td><code id="stri_wrap_+3A_indent">indent</code></td>
<td>
<p>single non-negative integer; gives the indentation of the
first line in each paragraph</p>
</td></tr>
<tr><td><code id="stri_wrap_+3A_exdent">exdent</code></td>
<td>
<p>single non-negative integer; specifies the indentation
of subsequent lines in paragraphs</p>
</td></tr>
<tr><td><code id="stri_wrap_+3A_prefix">prefix</code>, <code id="stri_wrap_+3A_initial">initial</code></td>
<td>
<p>single strings; <code>prefix</code> is used as prefix for each
line except the first, for which <code>initial</code> is utilized</p>
</td></tr>
<tr><td><code id="stri_wrap_+3A_whitespace_only">whitespace_only</code></td>
<td>
<p>single logical value; allow breaks only at white-spaces?
if <code>FALSE</code>, <span class="pkg">ICU</span>'s line break iterator is used to split text
into words, which is suitable for natural language processing</p>
</td></tr>
<tr><td><code id="stri_wrap_+3A_use_length">use_length</code></td>
<td>
<p>single logical value; should the number of code
points be used instead of the total code point width (see <code><a href="#topic+stri_width">stri_width</a></code>)?</p>
</td></tr>
<tr><td><code id="stri_wrap_+3A_locale">locale</code></td>
<td>
<p><code>NULL</code> or <code>''</code> for text boundary analysis following
the conventions of the default locale, or a single string with
locale identifier, see <a href="#topic+stringi-locale">stringi-locale</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vectorized over <code>str</code>.
</p>
<p>If <code>whitespace_only</code> is <code>FALSE</code>,
then <span class="pkg">ICU</span>'s line-<code>BreakIterator</code> is used to determine
text boundaries where a line break is possible.
This is a locale-dependent operation.
Otherwise, the breaks are only at white-spaces.
</p>
<p>Note that Unicode code points may have various widths when
printed on the console and that this function, by default, takes that
into account. By changing the state of the <code>use_length</code>
argument, this function starts to act as if each code point
was of width 1.
</p>
<p>If <code>normalize</code> is <code>FALSE</code>,
then multiple white spaces between the word boundaries are
preserved within each wrapped line.
In such a case, none of the strings can contain <code>\r</code>, <code>\n</code>,
or other new line characters, otherwise you will get an error.
You should split the input text into lines
or, for example, substitute line breaks with spaces
before applying this function.
</p>
<p>If <code>normalize</code> is <code>TRUE</code>, then
all consecutive white space (ASCII space, horizontal TAB, CR, LF)
sequences are replaced with single ASCII spaces
before actual string wrapping. Moreover, <code><a href="#topic+stri_split_lines">stri_split_lines</a></code>
and <code><a href="#topic+stri_trans_nfc">stri_trans_nfc</a></code> is called on the input character vector.
This is for compatibility with <code><a href="base.html#topic+strwrap">strwrap</a></code>.
</p>
<p>The greedy algorithm (for <code>cost_exponent</code> being non-positive)
provides a very simple way for word wrapping.
It always puts as many words in each line as possible.
This method &ndash; contrary to the dynamic algorithm &ndash; does not minimize
the number of space left at the end of every line.
The dynamic algorithm (a.k.a. Knuth's word wrapping algorithm)
is more complex, but it returns text wrapped
in a more aesthetic way. This method minimizes the squared
(by default, see <code>cost_exponent</code>) number of spaces  (raggedness)
at the end of each line, so the text is mode arranged evenly.
Note that the cost of printing the last line is always zero.
</p>


<h3>Value</h3>

<p>If <code>simplify</code> is <code>TRUE</code>, then a character vector is returned.
Otherwise, you will get a list of <code>length(str)</code> character vectors.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>References</h3>

<p>D.E. Knuth, M.F. Plass,
Breaking paragraphs into lines, <em>Software: Practice and Experience</em> 11(11),
1981, pp. 1119&ndash;1184.
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other locale_sensitive: 
<code><a href="#topic++25s+3C+25">%s&lt;%</a>()</code>,
<code><a href="#topic+about_locale">about_locale</a></code>,
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search_coll">about_search_coll</a></code>,
<code><a href="#topic+stri_compare">stri_compare</a>()</code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_duplicated">stri_duplicated</a>()</code>,
<code><a href="#topic+stri_enc_detect2">stri_enc_detect2</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_collator">stri_opts_collator</a>()</code>,
<code><a href="#topic+stri_order">stri_order</a>()</code>,
<code><a href="#topic+stri_rank">stri_rank</a>()</code>,
<code><a href="#topic+stri_sort_key">stri_sort_key</a>()</code>,
<code><a href="#topic+stri_sort">stri_sort</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>,
<code><a href="#topic+stri_unique">stri_unique</a>()</code>
</p>
<p>Other text_boundaries: 
<code><a href="#topic+about_search_boundaries">about_search_boundaries</a></code>,
<code><a href="#topic+about_search">about_search</a></code>,
<code><a href="#topic+stri_count_boundaries">stri_count_boundaries</a>()</code>,
<code><a href="#topic+stri_extract_all_boundaries">stri_extract_all_boundaries</a>()</code>,
<code><a href="#topic+stri_locate_all_boundaries">stri_locate_all_boundaries</a>()</code>,
<code><a href="#topic+stri_opts_brkiter">stri_opts_brkiter</a>()</code>,
<code><a href="#topic+stri_split_boundaries">stri_split_boundaries</a>()</code>,
<code><a href="#topic+stri_split_lines">stri_split_lines</a>()</code>,
<code><a href="#topic+stri_trans_tolower">stri_trans_tolower</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- stri_paste(
   'Lorem ipsum dolor sit amet, consectetur adipisicing elit. Proin ',
   'nibh augue, suscipit a, scelerisque sed, lacinia in, mi. Cras vel ',
   'lorem. Etiam pellentesque aliquet tellus.')
cat(stri_wrap(s, 20, 0.0), sep='\n') # greedy
cat(stri_wrap(s, 20, 2.0), sep='\n') # dynamic
cat(stri_pad(stri_wrap(s), side='both'), sep='\n')

</code></pre>

<hr>
<h2 id='stri_write_lines'>Write Text Lines to a Text File</h2><span id='topic+stri_write_lines'></span>

<h3>Description</h3>

<p>Writes a text file is such a way that each element of a given
character vector becomes a separate text line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stri_write_lines(
  str,
  con,
  encoding = "UTF-8",
  sep = ifelse(.Platform$OS.type == "windows", "\r\n", "\n"),
  fname = con
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stri_write_lines_+3A_str">str</code></td>
<td>
<p>character vector with data to write</p>
</td></tr>
<tr><td><code id="stri_write_lines_+3A_con">con</code></td>
<td>
<p>name of the output file or a connection object
(opened in the binary mode)</p>
</td></tr>
<tr><td><code id="stri_write_lines_+3A_encoding">encoding</code></td>
<td>
<p>output encoding, <code>NULL</code> or <code>''</code> for
the current default one</p>
</td></tr>
<tr><td><code id="stri_write_lines_+3A_sep">sep</code></td>
<td>
<p>newline separator</p>
</td></tr>
<tr><td><code id="stri_write_lines_+3A_fname">fname</code></td>
<td>
<p>[DEPRECATED] alias of <code>con</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a substitute for the <span class="rlang"><b>R</b></span> <code><a href="base.html#topic+writeLines">writeLines</a></code> function,
with the ability to easily re-encode the output.
</p>
<p>We suggest using the UTF-8 encoding for all text files:
thus, it is the default one for the output.
</p>


<h3>Value</h3>

<p>This function returns nothing noteworthy.
</p>


<h3>Author(s)</h3>

<p><a href="https://www.gagolewski.com/">Marek Gagolewski</a> and other contributors
</p>


<h3>See Also</h3>

<p>The official online manual of <span class="pkg">stringi</span> at <a href="https://stringi.gagolewski.com/">https://stringi.gagolewski.com/</a>
</p>
<p>Gagolewski M., <span class="pkg">stringi</span>: Fast and portable character string processing in R, <em>Journal of Statistical Software</em> 103(2), 2022, 1-59, <a href="https://doi.org/10.18637/jss.v103.i02">doi:10.18637/jss.v103.i02</a>
</p>
<p>Other files: 
<code><a href="#topic+stri_read_lines">stri_read_lines</a>()</code>,
<code><a href="#topic+stri_read_raw">stri_read_raw</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
