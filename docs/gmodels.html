<!DOCTYPE html><html><head><title>Help for package gmodels</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gmodels}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.to.est'><p>Return a vector for cm in estimable()</p></a></li>
<li><a href='#ci'><p>Compute Confidence Intervals</p></a></li>
<li><a href='#coefFrame'><p>Return model parameters in a data frame</p></a></li>
<li><a href='#CrossTable'><p>Cross Tabulation with Tests for Factor Independence</p></a></li>
<li><a href='#est_p_ci'><p>Display estimate, confidence interval and p-value for one model term</p></a></li>
<li><a href='#estimable'><p>Contrasts and estimable linear functions of model coefficients</p></a></li>
<li><a href='#fast.prcomp'><p>Efficient computation of principal components and singular value</p>
decompositions.</a></li>
<li><a href='#fit.contrast'><p>Compute and test arbitrary contrasts for regression objects</p></a></li>
<li><a href='#glh.test'><p>Test a General Linear Hypothesis for a Regression Model</p></a></li>
<li><a href='#make.contrasts'><p>Construct a User-Specified Contrast Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.19.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Various R Programming Tools for Model Fitting</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-gregmisc/gmodels">https://github.com/r-gregmisc/gmodels</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-gregmisc/gmodels/issues">https://github.com/r-gregmisc/gmodels/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregory R. Warnes &lt;greg@warnes.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Various R programming tools for model fitting.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gplots, gtools, Matrix, nlme, lme4</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, gdata, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 15:32:38 UTC; warnes</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory R. Warnes [aut, cre],
  Ben Bolker [aut],
  Thomas Lumley [aut],
  Randall C. Johnson [aut] (Contributions from Randall C. Johnson are
    Copyright (2005) SAIC-Frederick, Inc. Funded by the Intramural
    Research Program, of the NIH, National Cancer Institute, Center for
    Cancer Research under NCI Contract NO1-CO-12400),
  Airel Muldoon [ctb],
  Nitin Jain [aut],
  Dirk Enzmann [ctb],
  Søren Højsgaards [ctb],
  Ulrich Halekoh [ctb],
  Mark Schwartz [aut],
  Jim Rogers [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-06 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.to.est'>Return a vector for cm in estimable()</h2><span id='topic+.to.est'></span>

<h3>Description</h3>

<p>Return a vector for cm in estimable()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.to.est(obj, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".to.est_+3A_obj">obj</code></td>
<td>
<p>estimable object</p>
</td></tr>
<tr><td><code id=".to.est_+3A_params">params</code></td>
<td>
<p>character vector of names or logical vector with one element per model parameter selecting desrired parameter(s).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Randy Johnson, Laboratory of Genomic Diversity at NCI-Frederick
</p>

<hr>
<h2 id='ci'>Compute Confidence Intervals</h2><span id='topic+ci'></span><span id='topic+ci.numeric'></span><span id='topic+ci.binom'></span><span id='topic+ci.lm'></span><span id='topic+ci.lme'></span><span id='topic+ci.estimable'></span><span id='topic+ci.fit_contrast'></span>

<h3>Description</h3>

<p>Compute and display confidence intervals for model estimates.  Methods are
provided for the mean of a numeric vector <code>ci.default</code>, the probability
of a binomial vector <code>ci.binom</code>, and for <code>lm</code>, <code>lme</code>, and
<code>mer</code> objects are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci(x, confidence = 0.95, alpha = 1 - confidence, ...)

## S3 method for class 'numeric'
ci(x, confidence = 0.95, alpha = 1 - confidence, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_+3A_x">x</code></td>
<td>
<p>object from which to compute confidence intervals.</p>
</td></tr>
<tr><td><code id="ci_+3A_confidence">confidence</code></td>
<td>
<p>confidence level. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="ci_+3A_alpha">alpha</code></td>
<td>
<p>type one error rate.  Defaults to 1.0-<code>confidence</code></p>
</td></tr>
<tr><td><code id="ci_+3A_...">...</code></td>
<td>
<p>Arguments for methods</p>
</td></tr>
<tr><td><code id="ci_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code> indicating whether missing values should be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or matrix with one row per model parameter and
elements/columns <code>Estimate</code>, <code style="white-space: pre;">&#8288;CI lower&#8288;</code>, <code style="white-space: pre;">&#8288;CI upper&#8288;</code>,
<code style="white-space: pre;">&#8288;Std. Error&#8288;</code>, <code>DF</code> (for lme objects only), and <code>p-value</code>.
</p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+confint">stats::confint()</a></code>, <code><a href="stats.html#topic+lm">stats::lm()</a></code>,
<code><a href="stats.html#topic+summary.lm">stats::summary.lm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# mean and confidence interval
ci( rnorm(10) )

# binomial proportion and exact confidence interval
b &lt;- rbinom( prob=0.75, size=1, n=20 )
ci.binom(b) # direct call
class(b) &lt;- 'binom'
ci(b)       # indirect call

# confidence intervals for regression parameteres
data(state)
reg  &lt;-  lm(Area ~ Population, data=as.data.frame(state.x77))
ci(reg)

</code></pre>

<hr>
<h2 id='coefFrame'>Return model parameters in a data frame</h2><span id='topic+coefFrame'></span>

<h3>Description</h3>

<p>Fits a model to each subgroup defined by <code>by</code>, then returns a data
frame with one row for each fit and one column for each parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefFrame(
  mod,
  data,
  by = NULL,
  fit.on = TRUE,
  fitfun,
  keep.unused.levels = TRUE,
  byvar.sep = "\001",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefFrame_+3A_mod">mod</code></td>
<td>
<p>a model formula, to be passed to by <code>fitfun</code>.</p>
</td></tr>
<tr><td><code id="coefFrame_+3A_data">data</code></td>
<td>
<p>a data frame, row subsets of which will be used as the
<code>data</code> argument to <code>fitfun</code>.</p>
</td></tr>
<tr><td><code id="coefFrame_+3A_by">by</code></td>
<td>
<p>names of columns in <code>x</code> that will be used to define the
subgroups.</p>
</td></tr>
<tr><td><code id="coefFrame_+3A_fit.on">fit.on</code></td>
<td>
<p>a logical vector indicating which rows of <code>x</code> are to be
used to fit the model (like the <code>subset</code> argument in a lot of other
functions). Can be given in terms of variables in <code>x</code></p>
</td></tr>
<tr><td><code id="coefFrame_+3A_fitfun">fitfun</code></td>
<td>
<p>a model fitting function (e.g. lm, nls). More specifically, a
function that expects at least a formula object (as the first argument) and
a data.frame object (passed as an argument named <code>data</code>) and returns a
model object for which a <code>coef</code> method has been defined (e.g. coef.lm,
coef.nls) to extract fit values of model parameters.</p>
</td></tr>
<tr><td><code id="coefFrame_+3A_keep.unused.levels">keep.unused.levels</code></td>
<td>
<p>Include rows in output for all unique values of
<code>by</code>, even those which were excluded by <code>fit.on</code>. The default
value <code>TRUE</code> should be left alone if you are going to go on to pass the
result to <code>backFit</code>.</p>
</td></tr>
<tr><td><code id="coefFrame_+3A_byvar.sep">byvar.sep</code></td>
<td>
<p>passed to frameApply, used to form the subsets of the data.</p>
</td></tr>
<tr><td><code id="coefFrame_+3A_...">...</code></td>
<td>
<p>other arguments to pass to <code>fitfun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with a row for each unique row of <code>x[by]</code>, and
column for each model paramter, as well as columns specified in <code>by</code>.
</p>


<h3>Author(s)</h3>

<p>Jim Rogers <a href="mailto:james.a.rogers@pfizer.com">james.a.rogers@pfizer.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load example data
library(gtools)
data(ELISA)

# Coefficients for four parameter logistic fits:
coefFrame(log(Signal) ~ SSfpl(log(Concentration), A, B, xmid, scal),
           data = ELISA, fitfun = nls,
           by = c("PlateDay", "Read"),
           fit.on = Description == "Standard" &amp; Concentration != 0)

# Coefficients for linear fits:
coefFrame(log(Signal) ~ log(Concentration), 
           data = ELISA, fitfun = lm, 
           by = c("PlateDay", "Read"),
           fit.on = Description == "Standard" &amp; Concentration != 0 )

# Example passing arguments to fitfun, and example of
# error handling during model fitting:
ELISA$Signal[1] &lt;- NA
coefFrame(log(Signal) ~ log(Concentration), 
           data = ELISA, fitfun = lm, na.action = na.fail,
           by = c("PlateDay", "Read"),
           fit.on = Description == "Standard" &amp; Concentration != 0 )




</code></pre>

<hr>
<h2 id='CrossTable'>Cross Tabulation with Tests for Factor Independence</h2><span id='topic+CrossTable'></span>

<h3>Description</h3>

<p>An implementation of a cross-tabulation function with output similar to
S-Plus crosstabs() and SAS Proc Freq (or SPSS format) with Chi-square,
Fisher and McNemar tests of the independence of all table factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CrossTable(
  x,
  y,
  digits = 3,
  max.width = 5,
  expected = FALSE,
  prop.r = TRUE,
  prop.c = TRUE,
  prop.t = TRUE,
  prop.chisq = TRUE,
  chisq = FALSE,
  fisher = FALSE,
  mcnemar = FALSE,
  resid = FALSE,
  sresid = FALSE,
  asresid = FALSE,
  missing.include = FALSE,
  format = c("SAS", "SPSS"),
  dnn = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CrossTable_+3A_x">x</code></td>
<td>
<p>A vector or a matrix. If y is specified, x must be a vector</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_y">y</code></td>
<td>
<p>A vector in a matrix or a dataframe</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_digits">digits</code></td>
<td>
<p>Number of digits after the decimal point for cell proportions</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_max.width">max.width</code></td>
<td>
<p>In the case of a 1 x n table, the default will be to print
the output horizontally. If the number of columns exceeds max.width, the
table will be wrapped for each successive increment of max.width columns. If
you want a single column vertical table, set max.width to 1</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_expected">expected</code></td>
<td>
<p>If <code>TRUE</code>, chisq will be set to <code>TRUE</code> and
expected cell counts from the <code class="reqn">\chi^2</code> will be included</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_prop.r">prop.r</code></td>
<td>
<p>If <code>TRUE</code>, row proportions will be included</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_prop.c">prop.c</code></td>
<td>
<p>If <code>TRUE</code>, column proportions will be included</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_prop.t">prop.t</code></td>
<td>
<p>If <code>TRUE</code>, table proportions will be included</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_prop.chisq">prop.chisq</code></td>
<td>
<p>If <code>TRUE</code>, chi-square contribution of each cell will
be included</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_chisq">chisq</code></td>
<td>
<p>If <code>TRUE</code>, the results of a chi-square test will be
included</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_fisher">fisher</code></td>
<td>
<p>If <code>TRUE</code>, the results of a Fisher Exact test will be
included</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_mcnemar">mcnemar</code></td>
<td>
<p>If <code>TRUE</code>, the results of a McNemar test will be
included</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_resid">resid</code></td>
<td>
<p>If <code>TRUE</code>, residual (Pearson) will be included</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_sresid">sresid</code></td>
<td>
<p>If <code>TRUE</code>, standardized residual will be included</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_asresid">asresid</code></td>
<td>
<p>If <code>TRUE</code>, adjusted standardized residual will be
included</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_missing.include">missing.include</code></td>
<td>
<p>If <code>TRUE</code>, then remove any unused factor levels</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_format">format</code></td>
<td>
<p>Either SAS (default) or SPSS, depending on the type of output
desired.</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_dnn">dnn</code></td>
<td>
<p>the names to be given to the dimensions in the result (the
dimnames names).</p>
</td></tr>
<tr><td><code id="CrossTable_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A summary table will be generated with cell row, column and table
proportions and marginal totals and proportions. Expected cell counts can be
printed if desired (if 'chisq = TRUE'). In the case of a 2 x 2 table, both
corrected and uncorrected values will be included for appropriate tests. In
the case of tabulating a single vector, cell counts and table proportions
will be printed.
</p>
<p>Note: If 'x' is a vector and 'y' is not specified, no statistical tests will
be performed, even if any are set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A list with multiple components including key table data and
statistical test results, where performed.
</p>
<p>t: An n by m matrix containing table cell counts
</p>
<p>prop.col: An n by m matrix containing cell column proportions
</p>
<p>prop.row: An n by m matrix containing cell row proportions
</p>
<p>prop.tbl: An n by m matrix containing cell table proportions
</p>
<p>chisq: Results from the Chi-Square test. A list with class 'htest'. See
?chisq.test for details
</p>
<p>chisq.corr: Results from the corrected Chi-Square test. A list with class
'htest'. See ?chisq.test for details. ONLY included in the case of a 2 x 2
table.
</p>
<p>fisher.ts: Results from the two-sided Fisher Exact test. A list with class
'htest'. See ?fisher.test for details. ONLY included if 'fisher' = TRUE.
</p>
<p>fisher.lt: Results from the Fisher Exact test with HA = &quot;less&quot;. A list with
class 'htest'. See ?fisher.test for details.  ONLY included if 'fisher' =
TRUE and in the case of a 2 x 2 table.
</p>
<p>fisher.gt: Results from the Fisher Exact test with HA = &quot;greater&quot;.  A list
with class 'htest'. See ?fisher.test for details.  ONLY included if 'fisher'
= TRUE and in the case of a 2 x 2 table.
</p>
<p>mcnemar: Results from the McNemar test. A list with class 'htest'. See
?mcnemar.test for details. ONLY included if 'mcnemar' = TRUE.
</p>
<p>mcnemar.corr: Results from the corrected McNemar test. A list with class
'htest'. See ?mcnemar.test for details. ONLY included if 'mcnemar' = TRUE
and in the case of a 2 x 2 table.
</p>
<p>resid/sresid/asresid: Pearson Residuals (from chi-square tests).
</p>


<h3>Author(s)</h3>

<p>Marc Schwartz <a href="mailto:marc_schwartz@comcast.net">marc_schwartz@comcast.net</a>. Original version
posted to r-devel on Jul 27, 2002. SPSS format modifications added by Nitin
Jain based upon code provided by Dirk Enzmann
<a href="mailto:dirk.enzmann@jura.uni-hamburg.de">dirk.enzmann@jura.uni-hamburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+xtabs">stats::xtabs()</a></code>, <code><a href="base.html#topic+table">base::table()</a></code>, <code><a href="base.html#topic+proportions">base::prop.table()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Simple cross tabulation of education versus prior induced abortions
# using infertility data
data(infert, package = "datasets")
CrossTable(infert$education, infert$induced, expected = TRUE)
CrossTable(infert$education, infert$induced, expected = TRUE, format="SAS")
CrossTable(infert$education, infert$induced, expected = TRUE, format="SPSS")
CrossTable(warpbreaks$wool, warpbreaks$tension, dnn = c("Wool", "Tension"))

</code></pre>

<hr>
<h2 id='est_p_ci'>Display estimate, confidence interval and p-value for one model term</h2><span id='topic+est_p_ci'></span>

<h3>Description</h3>

<p>Display estimate, confidence interval and p-value for one model term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_p_ci(model, term, mult = 1, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_p_ci_+3A_model">model</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="est_p_ci_+3A_term">term</code></td>
<td>
<p>model term</p>
</td></tr>
<tr><td><code id="est_p_ci_+3A_mult">mult</code></td>
<td>
<p>scale (multiply) the parameter by this factor</p>
</td></tr>
<tr><td><code id="est_p_ci_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to display</p>
</td></tr>
<tr><td><code id="est_p_ci_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(42)

# fit an example model with 3 groups
y &lt;- rnorm(100)
x &lt;-  cut(rnorm(100, mean=y, sd=0.25),c(-4,-1.5,0,1.5,4))
reg &lt;- lm(y ~ x)
reg

# show model estimate, p-value, and confidence interval
# for the first group
est_p_ci(reg, 2)

# estimate some group contrasts
cmat &lt;- rbind( "1 vs 4"    =c(-1, 0, 0, 1),
               "1+2 vs 3+4"=c(-1/2,-1/2, 1/2, 1/2),
               "1 vs 2+3+4"=c(-3/3, 1/3, 1/3, 1/3))
cont &lt;- fit.contrast(reg, x, cmat, conf.int = 0.95)
cont

# show the contrast estimate, p-value, and confidence interval
# for the first contrast
est_p_ci(cont, 2:3)

</code></pre>

<hr>
<h2 id='estimable'>Contrasts and estimable linear functions of model coefficients</h2><span id='topic+estimable'></span><span id='topic+estimable.default'></span><span id='topic+estimable.mlm'></span>

<h3>Description</h3>

<p>Compute and test contrasts and other estimable linear functions of model
coefficients for for lm, glm, lme, mer, and geese objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimable(obj, cm, beta0, conf.int = NULL, show.beta0, ...)

## Default S3 method:
estimable(obj, cm, beta0, conf.int = NULL, show.beta0, joint.test = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimable_+3A_obj">obj</code></td>
<td>
<p>Regression (lm, glm, lme, mer, mlm) object.</p>
</td></tr>
<tr><td><code id="estimable_+3A_cm">cm</code></td>
<td>
<p>Vector, List, or Matrix specifying estimable linear functions or
contrasts.  See below for details.</p>
</td></tr>
<tr><td><code id="estimable_+3A_beta0">beta0</code></td>
<td>
<p>Vector of null hypothesis values</p>
</td></tr>
<tr><td><code id="estimable_+3A_conf.int">conf.int</code></td>
<td>
<p>Confidence level.  If provided, confidence intervals will be
computed.</p>
</td></tr>
<tr><td><code id="estimable_+3A_show.beta0">show.beta0</code></td>
<td>
<p>Logical value. If TRUE a column for beta0 will be included
in the output table.  Defaults to TRUE when beta0 is specified, FALSE
otherwise.</p>
</td></tr>
<tr><td><code id="estimable_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="estimable_+3A_joint.test">joint.test</code></td>
<td>
<p>Logical value. If TRUE a 'joint' Wald test for the
hypothesis <code class="reqn">L \beta=\beta_0</code> is performed.
Otherwise 'row-wise' tests are performed, i.e. <code class="reqn">(L \beta)[i]=\beta_0[i]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>estimable</code> computes an estimate, test statitic, significance test, and
(optional) confidence interval for each linear functions of the model
coefficients specified by <code>cm</code>.
</p>
<p>The estimable function(s) may be specified via a vector, list, or matrix.
If <code>cm</code> is a vector, it should contained named elements each of which
gives the coefficient to be applied to the corresponding parameter. These
coefficients will be used to construct the contrast matrix, with unspecified
model parameters assigned zero coefficients. If <code>cm</code> is a list, it
should contain one or more coefficient vectors, which will be used to
construct rows of the contrast matrix.  If <code>cm</code> is a matrix, column
names must match (a subset of) the model parameters, and each row should
contain the corresponding coefficient to be applied.  Model parameters which
are not present in the set of column names of <code>cm</code> will be set to zero.
</p>
<p>The estimates and their variances are obtained by applying the contrast
matrix (generated from) <code>cm</code> to the model estimates variance-covariance
matrix.  Degrees of freedom are obtained from the appropriate model terms.
</p>
<p>The user is responsible for ensuring that the specified linear functions are
meaningful.
</p>
<p>For computing contrasts among levels of a single factor, <code>fit.contrast</code>
may be more convenient.  For computing contrasts between two specific
combinations of model parameters, the <code>contrast</code> function in Frank
Harrell's 'rms' library (formerly 'Design') may be more convenient.
</p>
<p>%The <code>.wald</code> function is called internally by <code>estimable</code> and %is
not intended for direct use.
</p>


<h3>Value</h3>

<p>Returns a matrix with one row per linear function.  Columns contain
the beta0 value (optional, see <code>show.beta0</code> above), estimated
coefficients, standard errors, t values, degrees of freedom, two-sided
p-values, and the lower and upper endpoints of the 1-alpha confidence
intervals.
</p>


<h3>Note</h3>

<p>The estimated fixed effect parameters of <code>lme</code> objects may have
different degrees of freedom.  If a specified contrast includes nonzero
coefficients for parameters with differing degrees of freedom, the smallest
number of degrees of freedom is used and a warning message is issued.
</p>


<h3>Author(s)</h3>

<p>BXC (Bendix Carstensen) <a href="mailto:b@bxc.dk">b@bxc.dk</a>, Gregory R. Warnes
<a href="mailto:greg@warnes.net">greg@warnes.net</a>, Soren Hojsgaard <a href="mailto:sorenh@agrsci.dk">sorenh@agrsci.dk</a>, and
Randall C Johnson <a href="mailto:rjohnson@ncifcrf.gov">rjohnson@ncifcrf.gov</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit.contrast">fit.contrast()</a></code>, <code><a href="stats.html#topic+lm">stats::lm()</a></code>,
<code><a href="nlme.html#topic+lme">nlme::lme()</a></code>, <code><a href="stats.html#topic+contrasts">stats::contrasts()</a></code>,
<code><a href="rms.html#topic+contrast">rms::contrast()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# setup example data
y &lt;- rnorm(100)
x &lt;-  cut(rnorm(100, mean=y, sd=0.25),c(-4,-1.5,0,1.5,4))
levels(x) &lt;- c("A","B","C","D")
x2 &lt;- rnorm(100, mean=y, sd=0.5)

# simple contrast and confidence interval
reg &lt;- lm(y ~ x)
estimable(reg, c(    0,   1,    0,   -1) )  # full coefficient vector
estimable(reg, c("xB"=1,"xD"=-1) )          # just the nonzero terms


# Fit a spline with a single knot at 0.5 and plot the *pointwise*
# confidence intervals
library(gplots)
pm &lt;- pmax(x2-0.5, 0) # knot at 0.5
reg2 &lt;- lm(y ~ x + x2 + pm )

range &lt;- seq(-2, 2, , 50)
tmp &lt;- estimable(reg2,
                 cm=cbind(
                          '(Intercept)'=1,
                          'xC'=1,
                          'x2'=range,
                          'pm'=pmax(range-0.5, 0)
                           ),
                 conf.int=0.95)
plotCI(x=range, y=tmp[, 1], li=tmp[, 6], ui=tmp[, 7])

# Fit both linear and quasi-Poisson models to iris data, then compute
# joint confidence intervals on contrasts for the Species and
# Sepal.Width by Species interaction terms.
data(iris)
lm1  &lt;- lm (Sepal.Length ~ Sepal.Width + Species + Sepal.Width:Species, data=iris)
glm1 &lt;- glm(Sepal.Length ~ Sepal.Width + Species + Sepal.Width:Species, data=iris,
            family=quasipoisson("identity"))

cm &lt;- rbind(
            'Setosa vs. Versicolor'   = c(0, 0, 1, 0, 1, 0),
            'Setosa vs. Virginica'    = c(0, 0, 0, 1, 0, 1),
            'Versicolor vs. Virginica'= c(0, 0, 1,-1, 1,-1)
            )
estimable(lm1, cm)
estimable(glm1, cm)

</code></pre>

<hr>
<h2 id='fast.prcomp'>Efficient computation of principal components and singular value
decompositions.</h2><span id='topic+fast.prcomp'></span><span id='topic+fast.svd'></span>

<h3>Description</h3>

<p>The standard <code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code> and <code><a href="base.html#topic+svd">svd()</a></code> function are
very inefficient for wide matrixes. <code>fast.prcomp</code> and <code>fast.svd</code>
are modified versions which are efficient even for matrixes that are very
wide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.prcomp(x, retx = TRUE, center = TRUE, scale. = FALSE, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast.prcomp_+3A_x">x</code></td>
<td>
<p>data matrix</p>
</td></tr>
<tr><td><code id="fast.prcomp_+3A_retx">retx</code></td>
<td>
<p>a logical value indicating whether the rotated variables
should be returned.</p>
</td></tr>
<tr><td><code id="fast.prcomp_+3A_center">center</code></td>
<td>
<p>a logical value indicating whether the variables
should be shifted to be zero centered. Alternately, a vector of
length equal the number of columns of <code>x</code> can be supplied.
The value is passed to <code>scale</code>.</p>
</td></tr>
<tr><td><code id="fast.prcomp_+3A_scale.">scale.</code></td>
<td>
<p>a logical value indicating whether the variables should
be scaled to have unit variance before the analysis takes
place.  The default is <code>FALSE</code> for consistency with S, but
in general scaling is advisable.  Alternatively, a vector of length
equal the number of columns of <code>x</code> can be supplied.  The
value is passed to <code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
<tr><td><code id="fast.prcomp_+3A_tol">tol</code></td>
<td>
<p>a value indicating the magnitude below which components
should be omitted. (Components are omitted if their
standard deviations are less than or equal to <code>tol</code> times the
standard deviation of the first component.)  With the default null
setting, no components are omitted (unless <code>rank.</code> is specified
less than <code>min(dim(x))</code>.).  Other settings for tol could be
<code>tol = 0</code> or <code>tol = sqrt(.Machine$double.eps)</code>, which
would omit essentially constant components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current implementation of the function <code><a href="base.html#topic+svd">svd()</a></code> in S-Plus and R
is much slower when operating on a matrix with a large number of columns
than on the transpose of this matrix, which has a large number of rows. As a
consequence, <code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>, which uses <code><a href="base.html#topic+svd">svd()</a></code>, is
also very slow when applied to matrixes with a large number of rows.
</p>
<p>The simple solution is to use <code><a href="base.html#topic+La.svd">La.svd()</a></code> instead of
<code><a href="base.html#topic+svd">svd()</a></code>.  A suitable patch to <code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code> has been
submitted.  In the mean time, the function <code>fast.prcomp</code> has been
provided as a short-term work-around.
</p>

<dl>
<dt>list(&quot;fast.prcomp&quot;)</dt><dd><p>is a modified versiom of
<code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code> that calls <code><a href="base.html#topic+La.svd">La.svd()</a></code> instead of
<code><a href="base.html#topic+svd">svd()</a></code> </p>
</dd>
<dt>list(&quot;fast.svd&quot;)</dt><dd><p>is simply a wrapper around
<code><a href="base.html#topic+La.svd">La.svd()</a></code>.  </p>
</dd>
</dl>



<h3>Value</h3>

<p>See the documetation for <code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code> or
<code><a href="base.html#topic+svd">svd()</a></code> .
</p>


<h3>Author(s)</h3>

<p>Modifications by Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>, <code><a href="base.html#topic+svd">base::svd()</a></code>, <code><a href="base.html#topic+svd">base::La.svd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # create test matrix
  set.seed(4943546)
  nr &lt;- 50
  nc &lt;- 2000
  x  &lt;- matrix( rnorm( nr*nc), nrow=nr, ncol=nc )
  tx &lt;- t(x)

  # SVD directly on matrix is SLOW:
  system.time( val.x &lt;- svd(x)$u )

  # SVD on t(matrix) is FAST:
  system.time( val.tx &lt;- svd(tx)$v )

  # and the results are equivalent:
  max( abs(val.x) - abs(val.tx) )

  # Time gap dissapears using fast.svd:
  system.time( val.x &lt;- fast.svd(x)$u )
  system.time( val.tx &lt;- fast.svd(tx)$v )
  max( abs(val.x) - abs(val.tx) )


  library(stats)

  # prcomp directly on matrix is SLOW:
  system.time( pr.x &lt;- prcomp(x) )

  # prcomp.fast is much faster
  system.time( fast.pr.x &lt;- fast.prcomp(x) )

  # and the results are equivalent
  max( pr.x$sdev - fast.pr.x$sdev )
  max( abs(pr.x$rotation[,1:49]) - abs(fast.pr.x$rotation[,1:49]) )
  max( abs(pr.x$x) - abs(fast.pr.x$x)  )

  # (except for the last and least significant component):
  max( abs(pr.x$rotation[,50]) - abs(fast.pr.x$rotation[,50]) )

</code></pre>

<hr>
<h2 id='fit.contrast'>Compute and test arbitrary contrasts for regression objects</h2><span id='topic+fit.contrast'></span><span id='topic+fit.contrast.lm'></span><span id='topic+fit.contrast.lme'></span>

<h3>Description</h3>

<p>Compute and test arbitrary contrasts for regression objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.contrast(model, varname, coeff, showall, conf.int, df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.contrast_+3A_model">model</code></td>
<td>
<p>regression (lm,glm,aov,lme) object for which the contrast(s)
will be computed.</p>
</td></tr>
<tr><td><code id="fit.contrast_+3A_varname">varname</code></td>
<td>
<p>variable name</p>
</td></tr>
<tr><td><code id="fit.contrast_+3A_coeff">coeff</code></td>
<td>
<p>vector or matrix specifying contrasts (one per row).</p>
</td></tr>
<tr><td><code id="fit.contrast_+3A_showall">showall</code></td>
<td>
<p>return all regression coefficients. If <code>TRUE</code>, all model
cofficients will be returned.  If <code>FALSE</code> (the default), only the
coefficients corresponding to the specified contrast will be returned.</p>
</td></tr>
<tr><td><code id="fit.contrast_+3A_conf.int">conf.int</code></td>
<td>
<p>numeric value on (0,1) or NULL.  If a numeric value is
specified, confidence intervals with nominal coverage probability
<code>conf.int</code> will be computed.  If <code>NULL</code>, confidence intervals will
not be computed.</p>
</td></tr>
<tr><td><code id="fit.contrast_+3A_df">df</code></td>
<td>
<p>boolean indicating whether to return a column containing the
degrees of freedom.</p>
</td></tr>
<tr><td><code id="fit.contrast_+3A_...">...</code></td>
<td>
<p>optional arguments provided by methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the specified contrast(s) by re-fitting the model with the
appropriate arguments.  A contrast of the form <code>c(1,0,0,-1)</code> would
compare the mean of the first group with the mean of the fourth group.
</p>


<h3>Value</h3>

<p>Returns a matrix containing estimated coefficients, standard errors,
t values, two-sided p-values. If <code>df</code> is TRUE, an additional column
containing the degrees of freedom is included.  If <code>conf.int</code> is
specified lower and upper confidence limits are also returned.
</p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>References</h3>

<p>Venables &amp; Ripley, Section 6.2
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="stats.html#topic+lm">stats::lm()</a></code>, <code><a href="stats.html#topic+contrasts">stats::contrasts()</a></code>, <code><a href="stats.html#topic+contrast">stats::contr.treatment()</a></code>, <code><a href="stats.html#topic+contrast">stats::contr.poly()</a></code>,
</p>
</li>
<li><p> Computation and testing of General Linear Hypothesis: <code><a href="#topic+glh.test">glh.test()</a></code>,
</p>
</li>
<li><p> Computation and testing of estimable functions of model coefficients: <code><a href="#topic+estimable">estimable()</a></code>, <code><a href="#topic+make.contrasts">make.contrasts()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(42)

y &lt;- rnorm(100)
x &lt;-  cut(rnorm(100, mean=y, sd=0.25),c(-4,-1.5,0,1.5,4))
reg &lt;- lm(y ~ x)
summary(reg)

# look at the group means
gm &lt;- sapply(split(y,x),mean)
gm


# mean of 1st group vs mean of 4th group
fit.contrast(reg, x, c(    1,    0,    0,   -1) )
# estimate should be equal to:
gm[1] - gm[4]

# mean of 1st and 2nd groups vs mean of 3rd and 4th groups
fit.contrast(reg, x, c( -1/2, -1/2,  1/2,  1/2) )
# estimate should be equal to:
sum(-1/2*gm[1], -1/2*gm[2], 1/2*gm[3], 1/2*gm[4])

# mean of 1st group vs mean of 2nd, 3rd and 4th groups
fit.contrast(reg, x, c( -3/3,  1/3,  1/3,  1/3) )
# estimate should be equal to:
sum(-3/3*gm[1], 1/3*gm[2], 1/3*gm[3], 1/3*gm[4])

# all at once
cmat &lt;- rbind( "1 vs 4"    =c(-1, 0, 0, 1),
               "1+2 vs 3+4"=c(-1/2,-1/2, 1/2, 1/2),
               "1 vs 2+3+4"=c(-3/3, 1/3, 1/3, 1/3))
fit.contrast(reg,x,cmat)

#
x2 &lt;- rnorm(100,mean=y,sd=0.5)
reg2 &lt;- lm(y ~ x + x2 )
fit.contrast(reg2,x,c(-1,0,0,1))

#
# Example for Analysis of Variance
#

set.seed(03215)
Genotype &lt;- sample(c("WT","KO"), 1000, replace=TRUE)
Time &lt;- factor(sample(1:3, 1000, replace=TRUE))
y &lt;- rnorm(1000)
data &lt;- data.frame(y, Genotype, Time)


# Compute Contrasts &amp; obtain 95% confidence intervals

model &lt;- aov( y ~ Genotype + Time + Genotype:Time, data=data )

fit.contrast( model, "Genotype", rbind("KO vs WT"=c(-1,1) ), conf=0.95 )

fit.contrast( model, "Time",
            rbind("1 vs 2"=c(-1,1,0),
                  "2 vs 3"=c(0,-1,1)
                  ),
            conf=0.95 )


cm.G &lt;- rbind("KO vs WT"=c(-1,1) )
cm.T &lt;- rbind("1 vs 2"=c(-1,1,0),
              "2 vs 3"=c(0,-1,1) )

# Compute contrasts and show SSQ decompositions

model &lt;- aov( y ~ Genotype + Time + Genotype:Time, data=data,
              contrasts=list(Genotype=make.contrasts(cm.G),
                             Time=make.contrasts(cm.T) )
            )

summary(model, split=list( Genotype=list( "KO vs WT"=1 ),
                           Time = list( "1 vs 2" = 1,
                                        "2 vs 3" = 2 ) ) )


# example for lme
library(nlme)
data(Orthodont)
fm1 &lt;- lme(distance ~ Sex, data = Orthodont,random=~1|Subject)

# Contrast for sex.  This example is equivalent to standard treatment
# contrast.
#
fit.contrast(fm1, "Sex", c(-1,1), conf.int=0.95 )
#
# and identical results can be obtained using lme built-in 'intervals'
#
intervals(fm1)

# Cut age into quantile groups &amp; compute some contrasts
Orthodont$AgeGroup &lt;- gtools::quantcut(Orthodont$age)
fm2 &lt;- lme(distance ~ Sex + AgeGroup, data = Orthodont,random=~1|Subject)
#
fit.contrast(fm2, "AgeGroup", rbind("Linear"=c(-2,-1,1,2),
                                    "U-Shaped"=c(-1,1,1,-1),
                                    "Change-Point at 11"=c(-1,-1,1,1)),
                              conf.int=0.95)


</code></pre>

<hr>
<h2 id='glh.test'>Test a General Linear Hypothesis for a Regression Model</h2><span id='topic+glh.test'></span><span id='topic+print.glh.test'></span><span id='topic+summary.glh.test'></span>

<h3>Description</h3>

<p>Test, print, or summarize a general linear hypothesis for a regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glh.test(reg, cm, d = rep(0, nrow(cm)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glh.test_+3A_reg">reg</code></td>
<td>
<p>Regression model</p>
</td></tr>
<tr><td><code id="glh.test_+3A_cm">cm</code></td>
<td>
<p>contrast matrix <code>C</code> .  Each row specifies a linear combination of the
coefficients</p>
</td></tr>
<tr><td><code id="glh.test_+3A_d">d</code></td>
<td>
<p>vector <code>d</code> specifying the null hypothesis values for each linear
combination</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Test the general linear hypothesis <code class="reqn">C \hat{\beta} = d </code> for the regression model <code>reg</code>.
</p>
<p>The test statistic is obtained from the formula:
</p>
<p style="text-align: center;"><code class="reqn">
 f = \frac{(C \hat{\beta} - d)' ( C (X'X)^{-1} C' ) (C \hat{\beta} - d) / r }{ 
     SSE / (n-p) } 
 </code>
</p>

<p>where
</p>

<ul>
<li> <p><code>r</code> is the number of contrasts contained in <code>C</code>, and
</p>
</li>
<li> <p><code>n-p</code> is the model degrees of freedom.
</p>
</li></ul>

<p>Under the null hypothesis, <code>f</code> will follow a F-distribution with <code>r</code> and <code>n-p</code>
degrees of freedom
</p>


<h3>Value</h3>

<p>Object of class <code>c("glh.test","htest")</code> with elements:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>Function call that created the object</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>F statistic</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>vector containing the numerator (r) and
denominator (n-p) degrees of freedom</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>computed estimate for each row of <code>cm</code></p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>d</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>description of the method</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the model given for <code>reg</code></p>
</td></tr>
<tr><td><code>matrix</code></td>
<td>
<p>matrix specifying the general linear hypotheis (<code>cm</code>)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When using treatment contrasts (the default) the first level of the
factors are subsumed into the intercept term.  The estimated model
coefficients are then contrasts versus the first level. This should be taken
into account when forming contrast matrixes, particularly when computing
contrasts that include 'baseline' level of factors.
</p>
<p>See the comparison with <code>fit.contrast</code> in the examples below.
</p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>References</h3>

<p>R.H. Myers, Classical and Modern Regression with Applications,
2nd Ed, 1990, p. 105
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit.contrast">fit.contrast()</a></code>, <code><a href="#topic+estimable">estimable()</a></code>, <code><a href="stats.html#topic+contrasts">stats::contrasts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# fit a simple model
y &lt;- rnorm(100)
x &lt;-  cut(rnorm(100, mean=y, sd=0.25),c(-4,-1.5,0,1.5,4))
reg &lt;- lm(y ~ x)
summary(reg)

# test both group 1 = group 2  and group 3 = group 4
# *Note the 0 in the column for the intercept term*

C &lt;- rbind( c(0,-1,0,0), c(0,0,-1,1) )
ret &lt;- glh.test(reg, C)
ret  # same as 'print(ret) '
summary(ret)

# To compute a contrast between the first and second level of the factor
# 'x' using 'fit.contrast' gives:

fit.contrast( reg, x,c(1,-1,0,0) )
	
# To test this same contrast using 'glh.test', use a contrast matrix
# with a zero coefficient for the intercept term.  See the Note section,
# above, for an explanation.

C &lt;- rbind( c(0,-1,0,0) )
glh.test( reg, C )

</code></pre>

<hr>
<h2 id='make.contrasts'>Construct a User-Specified Contrast Matrix</h2><span id='topic+make.contrasts'></span>

<h3>Description</h3>

<p>This function converts human-readable contrasts into the form that R
requires for computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.contrasts(contr, how.many = ncol(contr))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.contrasts_+3A_contr">contr</code></td>
<td>
<p>vector or matrix specifying contrasts (one per row).</p>
</td></tr>
<tr><td><code id="make.contrasts_+3A_how.many">how.many</code></td>
<td>
<p>dimensions of the desired contrast matrix.  This must equal
the number of levels of the target factor variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying a contrast row of the form <code>c(1,0,0,-1)</code> creates a contrast
that will compare the mean of the first group with the mean of the fourth
group.
</p>


<h3>Value</h3>

<p><code>make.contrasts</code> returns a matrix with dimensions
(<code>how.many</code>, <code>how.many</code>) containing the specified contrasts
augmented (if necessary) with orthogonal &quot;filler&quot; contrasts.
</p>
<p>This matrix can then be used as the argument to <code><a href="stats.html#topic+contrasts">contrasts()</a></code> or
to the <code>contrasts</code> argument of model functions (eg, <code><a href="stats.html#topic+lm">lm()</a></code>).
</p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="stats.html#topic+lm">stats::lm()</a></code>, <code><a href="stats.html#topic+contrasts">stats::contrasts()</a></code>, <code><a href="stats.html#topic+contrast">stats::contr.treatment()</a></code>,
<code><a href="stats.html#topic+contrast">stats::contr.poly()</a></code>,
</p>
</li>
<li><p> Computation and testing of General Linear Hypothesis: <code><a href="#topic+glh.test">glh.test()</a></code>,
</p>
</li>
<li><p> Computation and testing of estimable functions of model coefficients:
<code><a href="#topic+estimable">estimable()</a></code>,
</p>
</li>
<li><p> Estimate and Test Contrasts for a previously fit linear model:
<code><a href="#topic+fit.contrast">fit.contrast()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(4684)
y &lt;- rnorm(100)
x.true &lt;- rnorm(100, mean=y, sd=0.25)
x &lt;-  factor(cut(x.true,c(-4,-1.5,0,1.5,4)))
reg &lt;- lm(y ~ x)
summary(reg)

# Mirror default treatment contrasts
test &lt;- make.contrasts(rbind( c(-1,1,0,0), c(-1,0,1,0), c(-1,0,0,1) ))
lm( y ~ x, contrasts=list(x = test ))

# Specify some more complicated contrasts
#   - mean of 1st group vs mean of 4th group
#   - mean of 1st and 2nd groups vs mean of 3rd and 4th groups
#   - mean of 1st group vs mean of 2nd, 3rd and 4th groups
cmat &lt;- rbind( "1 vs 4"    =c(-1, 0, 0, 1),
               "1+2 vs 3+4"=c(-1/2,-1/2, 1/2, 1/2),
               "1 vs 2+3+4"=c(-3/3, 1/3, 1/3, 1/3))

summary(lm( y ~ x, contrasts=list(x=make.contrasts(cmat) )))
# or
contrasts(x) &lt;- make.contrasts(cmat)
summary(lm( y ~ x ) )

# or use contrasts.lm
reg &lt;- lm(y ~ x)
fit.contrast( reg, "x", cmat )

# compare with values computed directly using group means
gm &lt;- sapply(split(y,x),mean)
gm %*% t(cmat)


#
# Example for Analysis of Variance
#

set.seed(03215)
Genotype &lt;- sample(c("WT","KO"), 1000, replace=TRUE)
Time &lt;- factor(sample(1:3, 1000, replace=TRUE))
data &lt;- data.frame(y, Genotype, Time)
y &lt;- rnorm(1000)

data &lt;- data.frame(y, Genotype, as.factor(Time))

# Compute Contrasts &amp; obtain 95% confidence intervals

model &lt;- aov( y ~ Genotype + Time + Genotype:Time, data=data )

fit.contrast( model, "Genotype", rbind("KO vs WT"=c(-1,1) ), conf=0.95 )

fit.contrast( model, "Time",
            rbind("1 vs 2"=c(-1,1,0),
                  "2 vs 3"=c(0,-1,1)
                  ),
            conf=0.95 )


cm.G &lt;- rbind("KO vs WT"=c(-1,1) )
cm.T &lt;- rbind("1 vs 2"=c(-1,1,0),
              "2 vs 3"=c(0,-1,1) )

# Compute contrasts and show SSQ decompositions

model &lt;- model &lt;- aov( y ~ Genotype + Time + Genotype:Time, data=data,
                      contrasts=list(Genotype=make.contrasts(cm.G),
                                     Time=make.contrasts(cm.T) )
                      )

summary(model, split=list( Genotype=list( "KO vs WT"=1 ),
                           Time = list( "1 vs 2" = 1,
                                        "2 vs 3" = 2 ) ) )

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
