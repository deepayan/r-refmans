<!DOCTYPE html><html><head><title>Help for package bsearchtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bsearchtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bsearchtools-package'>
<p>Binary Search Tools</p></a></li>
<li><a href='#DFI'><p>Create a data.frame (or matrix) with indexes</p></a></li>
<li><a href='#DFI.coercion'>
<p>Coerce a DFI object</p></a></li>
<li><a href='#DFI.getIndex'>
<p>Extract the index information of a DFI object</p></a></li>
<li><a href='#DFI.indexes'>
<p>Get the indexes names of a DFI object</p></a></li>
<li><a href='#DFI.subset'>
<p>Subset a DFI object</p></a></li>
<li><a href='#DFI.unWrap'>
<p>Unwrap a DFI object returning the original wrapped object</p></a></li>
<li><a href='#indexesEqualTo'><p>Find indexes of a value using binary search</p></a></li>
<li><a href='#indexesInRange'><p>Find indexes in a range using binary search</p></a></li>
<li><a href='#indexesMerge'>
<p>Intersection / union of list of indexes</p></a></li>
<li><a href='#lb'><p>Binary search based lower bound operation</p></a></li>
<li><a href='#rowfilters.DFI'>
<p>Functions for row filters creation in <code>DFI.subset</code>.</p></a></li>
<li><a href='#ub'><p>Binary search based upper bound operation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Binary Search Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.61</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-02-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Marco Giuliano</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marco Giuliano &lt;mgiuliano.mail@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Exposes the binary search functions of the C++ standard library (std::lower_bound, std::upper_bound) plus other convenience functions, allowing faster lookups on sorted vectors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.4)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/digEmAll/bsearchtools">https://github.com/digEmAll/bsearchtools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/digEmAll/bsearchtools/issues">https://github.com/digEmAll/bsearchtools/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-02-22 17:47:41 UTC; marco</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-02-22 23:26:43</td>
</tr>
</table>
<hr>
<h2 id='bsearchtools-package'>
Binary Search Tools
</h2><span id='topic+bsearchtools-package'></span><span id='topic+bsearchtools'></span>

<h3>Description</h3>

<p>Exposes the binary search based functions of the C++ standard library 
(std::lower_bound, std::upper_bound) plus other convenience functions, allowing faster lookups on sorted vectors.
It also includes a lightweight data.frame/matrix wrapper (DFI), which automatically creates indexes on the columns for faster lookups.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bsearchtools</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.0.61</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-02-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package allows to perform the most common binary search operations on sorted vectors 
(integer, numeric, bool and charater vectors are supported).
It exposes lower-bound/upper-bound functions working exactly like their the C++ standard library counterparts, 
and some convenience functions allowing efficient values and ranges lookups.
</p>
<p>Note that these functions are especially designed to be used for non-vectorized operations (e.g. inside loops);
for vectorized operations, the great <code>data.table</code> package already fullfills basically every R programmer needs.
</p>


<h3>Author(s)</h3>

<p>Marco Giuliano
</p>
<p>Maintainer: Marco Giuliano &lt;mgiuliano.mail@gmail.com&gt;
</p>


<h3>References</h3>

<p>Project repository : https://github.com/digEmAll/bsearchtools/
</p>
<p>cpp reference page : http://en.cppreference.com/w/
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sort">sort</a></code>,
<code><a href="base.html#topic+order">order</a></code>,
<code><a href="data.table.html#topic+data.table">data.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bsearchtools)

######################################################
### get indexes of values in range
### search values in range [2,4]

# N.B. v must be sorted !
v1 &lt;- sort(c(3,5,7,10,4,8,13,3,2))

indexesInRangeNumeric(v1,2,4)
# is identical to:
which(v1 &gt;= 2 &amp; v1 &lt;= 4)

######################################################
### What if vector is not sorted ? 
### (and we're going to perform a lot of lookups on it)

v2 &lt;- c(3,5,7,10,4,8,13,3,2)

# we can create two intermediate vectors
ordIdxs &lt;- order(v2)
sortedV2 &lt;- v2[ordIdxs]

# then use them as follows :
ordIdxs[indexesInRangeNumeric(sortedV2,2,4)]

# this returns the same indexes :
# N.B. : 'which' returns ascending indexes while the previous line does not:
# sort the result if you want them ascending
which(v2 &gt;= 2 &amp; v2 &lt;= 4)

######################################################
###### N.B. the previous code is basically what is performed by DFI objects under the hood
######      check DFI function documentation for further information
DF &lt;- data.frame(v2=v2)
DFIobj &lt;- DFI(DF)
indexes &lt;- DFI.subset(DFIobj,RG('v2',2,4),return.indexes=TRUE)

## Not run: 
######################################################
### big example to measure the performance difference
set.seed(123) # for reproducibility
sortedValues &lt;- sort(sample(1:1e4,1e5,replace=TRUE))

# measure time difference doing same operation 500 times
tm1 &lt;- system.time( for(i in 1:500) res2 &lt;- which(sortedValues &gt;= 7000 &amp; sortedValues &lt;= 7500))
tm2 &lt;- system.time( for(i in 1:500) res1 &lt;- indexesInRangeInteger(sortedValues,7000,7500))

print(paste("'which' took:",tm1["elapsed"]))
print(paste("'indexesInRangeInteger' took:",tm2["elapsed"]))


## End(Not run)


</code></pre>

<hr>
<h2 id='DFI'>Create a data.frame (or matrix) with indexes</h2><span id='topic+DFI'></span><span id='topic+as.DFI'></span><span id='topic+is.DFI'></span><span id='topic+print.DFI'></span>

<h3>Description</h3>

<p>Turn a data.frame (or matrix) object into a DFI object allowing faster lookups on indexed columns (indexed column to be intended as DB indexes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFI(DF, indexes.col.names=colnames(DF))
as.DFI(DF, indexes.col.names=colnames(DF)) # exactly the same as DFI()
is.DFI(x)
## S3 method for class 'DFI'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DFI_+3A_df">DF</code></td>
<td>
<p>A data.frame or matrix object (must have column names defined). </p>
</td></tr>
<tr><td><code id="DFI_+3A_indexes.col.names">indexes.col.names</code></td>
<td>
<p>The column names for which we want to create the indexes. Only integer,numeric,logical and character are supported, so be careful since data.frame by default turns strings into factors (see data.frame <code>stringsAsFactors</code> argument) </p>
</td></tr>
<tr><td><code id="DFI_+3A_x">x</code></td>
<td>
<p>A DFI object.</p>
</td></tr>
<tr><td><code id="DFI_+3A_...">...</code></td>
<td>
<p>optional arguments passed to inner <code>print</code> methods of data.frame and matrix .</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, <code>DFI()</code> function creates a wrapper of <code>DF</code>. 
This wrapper contains the original data.frame or matrix plus the necessary indexes data and the class of the wrapped object.
These extra data will be used to perform faster lookups (in <code><a href="#topic+DFI.subset">DFI.subset</a></code> function) and can be extracted using the appropriate functions 
<code><a href="#topic+DFI.unWrap">DFI.unWrap</a></code>,
<code><a href="#topic+DFI.indexes">DFI.indexes</a></code>,
<code><a href="#topic+DFI.getIndex">DFI.getIndex</a></code>. 
</p>


<h3>Value</h3>

<p>An object with class <code>"DFI"</code>
</p>


<h3>Note</h3>

<p>Since version 0.0.47 DFI objects do not inherit from data.frame or matrix anymore, hence they cannot be modified/subsetted using data.frame/matrix standard operators.
This has been changed since the column indexes are not recreated automatically and once the object is modified, DFI.subset could give wrong results without any warning.
To use the standard replacement and subset operators, extract the original object first using <code>DFI.unWrap(DFIobj)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DFI.subset">DFI.subset</a></code>
<code><a href="#topic+DFI.unWrap">DFI.unWrap</a></code>
<code><a href="#topic+DFI.indexes">DFI.indexes</a></code>
<code><a href="#topic+DFI.getIndex">DFI.getIndex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
DF &lt;- data.frame(Foo=c(3,5,7,1,5,8,7,10),
                 Bar=c("A","B","B","C","B","B","C","A"),
                 Baz=c(TRUE,FALSE),
                 stringsAsFactors=FALSE)
DFIobj &lt;- DFI(DF, c("Foo","Bar")) # create a DFI from DF with indexes on "Foo" and "Bar" columns

</code></pre>

<hr>
<h2 id='DFI.coercion'>
Coerce a DFI object
</h2><span id='topic+as.data.frame.DFI'></span><span id='topic+as.matrix.DFI'></span>

<h3>Description</h3>

<p>Coerce a DFI object to data.frame or matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DFI'
as.data.frame(x, ...)
## S3 method for class 'DFI'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DFI.coercion_+3A_x">x</code></td>
<td>
<p>a DFI object</p>
</td></tr>
<tr><td><code id="DFI.coercion_+3A_...">...</code></td>
<td>
<p>optional arguments passed to inner <code>as.data.frame</code> and <code>as.matrix</code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame or matrix object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DFI">DFI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### create a simple DFIobj
DF &lt;- data.frame(Foo=c(3,5,7,1,5,8,7,10),
                 Bar=c("A","B","B","C","B","B","C","A"),
                 Baz=c(TRUE,FALSE),
                 stringsAsFactors=FALSE)
DFIobj &lt;- DFI(DF, c("Foo","Bar")) # create a DFI from DF with indexes on "Foo" and "Bar" columns

### coercion
as.data.frame(DFIobj)
as.matrix(DFIobj)

</code></pre>

<hr>
<h2 id='DFI.getIndex'>
Extract the index information of a DFI object
</h2><span id='topic+DFI.getIndex'></span>

<h3>Description</h3>

<p>Return the index data (i.e. ordered indexes, and sorted values) of an indexed column of a DFI object 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFI.getIndex(DFIobj,name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DFI.getIndex_+3A_dfiobj">DFIobj</code></td>
<td>
<p> a DFI object</p>
</td></tr>
<tr><td><code id="DFI.getIndex_+3A_name">name</code></td>
<td>
<p> the name of the indexed column in the DFI object </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two values:
</p>
<table>
<tr><td><code>idxs</code></td>
<td>
<p> the indexes used to sort the column values (as returned by <code>order(colValues,na.last=NA)</code> </p>
</td></tr>
<tr><td><code>sorted</code></td>
<td>
<p> the sorted values of the column (as returned by <code>colValues[idxs]</code>) </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+DFI">DFI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### create a simple DFIobj
DF &lt;- data.frame(Foo=c(3,5,7,1,5,8,7,10),
                 Bar=c("A","B","B","C","B","B","C","A"),
                 Baz=c(TRUE,FALSE),
                 stringsAsFactors=FALSE)
DFIobj &lt;- DFI(DF, c("Foo","Bar")) # create a DFI from DF with indexes on "Foo" and "Bar" columns

### get the index data of 'Bar' column
DFI.getIndex(DFIobj,"Bar")

</code></pre>

<hr>
<h2 id='DFI.indexes'>
Get the indexes names of a DFI object
</h2><span id='topic+DFI.indexes'></span>

<h3>Description</h3>

<p>Method to get the indexes names of a DFI object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFI.indexes(DFIobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DFI.indexes_+3A_dfiobj">DFIobj</code></td>
<td>
<p> A DFI object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the name of the indexed columns of the DFI object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### create a simple DFIobj
DF &lt;- data.frame(Foo=c(3,5,7,1,5,8,7,10),
                 Bar=c("A","B","B","C","B","B","C","A"),
                 Baz=c(TRUE,FALSE),
                 stringsAsFactors=FALSE)
DFIobj &lt;- DFI(DF, c("Foo","Bar")) # create a DFI from DF with indexes on "Foo" and "Bar" columns

### get the indexes names (returns c("Foo","Bar"))
DFI.indexes(DFIobj)
</code></pre>

<hr>
<h2 id='DFI.subset'>
Subset a DFI object
</h2><span id='topic+DFI.subset'></span>

<h3>Description</h3>

<p>Function to subset a DFI object efficiently (using binary search) by creating complex filters on indexed columns.
For details about column indexes, refer to <code><a href="#topic+DFI">DFI</a></code>, for information about <code>NA</code> handling, refer to <code><a href="#topic+rowfilters.DFI">rowfilters.DFI</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFI.subset(DFIobj, filter=NULL, return.indexes=FALSE, 
           sort.indexes=TRUE, colFilter=NULL, drop=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DFI.subset_+3A_dfiobj">DFIobj</code></td>
<td>
<p>a DFI object.</p>
</td></tr>
<tr><td><code id="DFI.subset_+3A_filter">filter</code></td>
<td>
<p>a filter object created by functions <code>EQ,RG,IN,AND,OR,NOT</code>.</p>
</td></tr>
<tr><td><code id="DFI.subset_+3A_return.indexes">return.indexes</code></td>
<td>
<p>if TRUE, the row indexes satisfying the filter are returned instead of the DFI subset.</p>
</td></tr>
<tr><td><code id="DFI.subset_+3A_sort.indexes">sort.indexes</code></td>
<td>
<p>if FALSE the order of the rows or row.index returned will not be necessarily equal to the original order in the DFI object. If TRUE, subsetting will keep the original row/row.indexes order.
FALSE usually gives a better performance.</p>
</td></tr>
<tr><td><code id="DFI.subset_+3A_colfilter">colFilter</code></td>
<td>
<p>if <code>return.indexes==TRUE</code> is ignored; otherwise, if not NULL, it will be passed as second argument of data.frame/matrix subset operator i.e. <code>[,colFilter]</code>  </p>
</td></tr>
<tr><td><code id="DFI.subset_+3A_drop">drop</code></td>
<td>
<p>if different from <code>NULL</code> is passed as <code>drop</code> argument of data.frame and matrix subset (ignored if <code>return.indexes=TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the data.frame or matrix wrapped by the DFI object, unless <code>return.indexes==TRUE</code> in which case an integer vector with the row indexes will be returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DFI">DFI</a></code>,
<code><a href="#topic+EQ">EQ</a></code>,
<code><a href="#topic+IN">IN</a></code>,
<code><a href="#topic+RG">RG</a></code>,
<code><a href="#topic+NOT">NOT</a></code>,
<code><a href="#topic+AND">AND</a></code>,
<code><a href="#topic+OR">OR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### create a simple DFIobj
DF &lt;- data.frame(Foo=c(3,5,7,1,5,8,7,10),
                 Bar=c("A","B","B","C","B","B","C","A"),
                 Baz=c(TRUE,FALSE),
                 stringsAsFactors=FALSE)
DFIobj &lt;- DFI(DF, c("Foo","Bar")) # create a DFI from DF with indexes on "Foo" and "Bar" columns

DFI.subset(DFIobj, filter=OR(EQ('Foo',5),EQ('Bar','B')))

</code></pre>

<hr>
<h2 id='DFI.unWrap'>
Unwrap a DFI object returning the original wrapped object 
</h2><span id='topic+DFI.unWrap'></span>

<h3>Description</h3>

<p>Extract the original wrapped object (data.frame or matrix) inside a DFI object 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFI.unWrap(DFIobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DFI.unWrap_+3A_dfiobj">DFIobj</code></td>
<td>
<p> a DFI object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame or matrix according to the class of the original object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DFI">DFI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### create a simple DFIobj
DF &lt;- data.frame(Foo=c(3,5,7,1,5,8,7,10),
                 Bar=c("A","B","B","C","B","B","C","A"),
                 Baz=c(TRUE,FALSE),
                 stringsAsFactors=FALSE)
DFIobj &lt;- DFI(DF, c("Foo","Bar")) # create a DFI from DF with indexes on "Foo" and "Bar" columns

### get the inner data.frame
DFI.unWrap(DFIobj)

</code></pre>

<hr>
<h2 id='indexesEqualTo'>Find indexes of a value using binary search</h2><span id='topic+indexesEqualTo'></span><span id='topic+indexesEqualToNumeric'></span><span id='topic+indexesEqualToInteger'></span><span id='topic+indexesEqualToLogical'></span><span id='topic+indexesEqualToCharacter'></span>

<h3>Description</h3>

<p>Given a sorted vector, it returns the indexes of the vector elements equal to valueToSearch.
</p>
<p>The functions suffixed with the vector type (indexInRangeNumeric,indexInRangeLogical etc.) can be used ONLY with the specified type, otherwise the vector is coerced, and they are (hopefully negligibly) faster then the generic indexesEqualTo function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexesEqualTo(sortedValues,valueToSearch,indexesRemap=NULL)
indexesEqualToNumeric(sortedValues,valueToSearch,indexesRemap=NULL)
indexesEqualToInteger(sortedValues,valueToSearch,indexesRemap=NULL)
indexesEqualToLogical(sortedValues,valueToSearch,indexesRemap=NULL)
indexesEqualToCharacter(sortedValues,valueToSearch,indexesRemap=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indexesEqualTo_+3A_sortedvalues">sortedValues</code></td>
<td>
<p>A sorted atomic vector of type numeric, integer, logical or character </p>
</td></tr>
<tr><td><code id="indexesEqualTo_+3A_valuetosearch">valueToSearch</code></td>
<td>
<p>The value to search in the vector</p>
</td></tr>
<tr><td><code id="indexesEqualTo_+3A_indexesremap">indexesRemap</code></td>
<td>
<p>An integer vector to be used to remap the indexes returned by lookup on sortedValues, or NULL (the default). Mostly used internally by DFI. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indexes of the vector elements equal to valueToSearch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>indexesEqualTo(c(1,4,5,5,7,9),5) # returns c(3,4)
indexesEqualTo(c(1,4,5,5,7,9),10) # returns empty vector
</code></pre>

<hr>
<h2 id='indexesInRange'>Find indexes in a range using binary search</h2><span id='topic+indexesInRange'></span><span id='topic+indexesInRangeNumeric'></span><span id='topic+indexesInRangeInteger'></span><span id='topic+indexesInRangeLogical'></span><span id='topic+indexesInRangeCharacter'></span>

<h3>Description</h3>

<p>Given a sorted vector, it returns the indexes of the vector elements included in range [lbInclusive,ubInclusive].
</p>
<p>The functions suffixed with the vector type (indexInRangeNumeric,indexInRangeLogical etc.) can be used ONLY with the specified type, otherwise the vector is coerced, and they are (hopefully negligibly) faster then the generic indexInRange function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexesInRange(sortedValues,lbInclusive, ubInclusive,indexesRemap=NULL)
indexesInRangeNumeric(sortedValues,lbInclusive, ubInclusive,indexesRemap=NULL)
indexesInRangeInteger(sortedValues,lbInclusive, ubInclusive,indexesRemap=NULL)
indexesInRangeLogical(sortedValues,lbInclusive, ubInclusive,indexesRemap=NULL)
indexesInRangeCharacter(sortedValues,lbInclusive, ubInclusive,indexesRemap=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indexesInRange_+3A_sortedvalues">sortedValues</code></td>
<td>
<p>A sorted atomic vector of type numeric, integer, logical or character </p>
</td></tr>
<tr><td><code id="indexesInRange_+3A_lbinclusive">lbInclusive</code></td>
<td>
<p>The inclusive lower bound of the range</p>
</td></tr>
<tr><td><code id="indexesInRange_+3A_ubinclusive">ubInclusive</code></td>
<td>
<p>The inclusive upper bound of the range</p>
</td></tr>
<tr><td><code id="indexesInRange_+3A_indexesremap">indexesRemap</code></td>
<td>
<p>An integer vector to be used to remap the indexes returned by lookup on sortedValues, or NULL (the default). Mostly used internally by DFI. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indexes of the vector elements included in range [lbInclusive,ubInclusive].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>indexesInRange(c(1,4,5,5,7,9),5,7) # returns c(3,4,5)
indexesInRange(c(1,4,5,5,7,9),10,11) # returns empty vector
</code></pre>

<hr>
<h2 id='indexesMerge'>
Intersection / union of list of indexes
</h2><span id='topic+intersectIndexesList'></span><span id='topic+unionIndexesList'></span>

<h3>Description</h3>

<p>Functions to perform intersection or union of a list of integer vectors.
This functions are used by DFI.subset for AND/OR filters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersectIndexesList(lst,sorted=TRUE)
unionIndexesList(lst,sorted=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indexesMerge_+3A_lst">lst</code></td>
<td>
<p>list of integer vectors on which intersection or union must be performed</p>
</td></tr>
<tr><td><code id="indexesMerge_+3A_sorted">sorted</code></td>
<td>
<p>logical value used to specify if the returned indexes should be sorted ascending (default TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned vector is sorted ascending.
<code>intersectIndexesList</code> is implemented in C++ and corresponds to <code>sort(unique(Reduce(f=intersect,x=lst)))</code> (without the <code>sort</code> function if <code>sorted=FALSE</code>).
<code>unionIndexesList</code> is partially implemented in C++ and corresponds to <code>sort(unique(Reduce(f=union,x=lst)))</code> (without the <code>sort</code> function if <code>sorted=FALSE</code>).
</p>


<h3>Value</h3>

<p>A vector of integers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>intersectIndexesList(list(1:7,4:8,3:5))
unionIndexesList(list(1:7,4:8,3:5))
</code></pre>

<hr>
<h2 id='lb'>Binary search based lower bound operation</h2><span id='topic+lb'></span><span id='topic+lbNumeric'></span><span id='topic+lbInteger'></span><span id='topic+lbLogical'></span><span id='topic+lbCharacter'></span>

<h3>Description</h3>

<p>Returns the index pointing to the first element in the vector that is not less than (i.e. greater or equal to) valueToSearch.
The behavior is the same as C++ std::lower_bound function, hence, if the vector is empty or valueToSearch is lower than
the first element of the vector, it returns the first index (i.e. 1).
</p>
<p>The functions suffixed with the vector type (lbNumeric,lbLogical etc.) can be used ONLY with the specified type, otherwise the
vector is coerced, and they are (hopefully negligibly) faster then the generic lb function.
</p>
<p>For information about NAs handling see details section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lb(sortedValues, valueToSearch)
lbInteger(sortedValues, valueToSearch)
lbNumeric(sortedValues, valueToSearch)
lbLogical(sortedValues, valueToSearch)
lbCharacter(sortedValues, valueToSearch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lb_+3A_sortedvalues">sortedValues</code></td>
<td>
<p>A sorted atomic vector of type numeric, integer, logical or character.</p>
</td></tr>
<tr><td><code id="lb_+3A_valuetosearch">valueToSearch</code></td>
<td>
<p>The value to search. If equal to <code>NA</code>, <code>1</code> is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lb*</code> functions expect <code>sortedValues</code> to be a vector sorted ascending (duplicated values are allowed). 
Since the binary search functions rely on values comparison (using <code>&lt;</code> operator) and <code>NA</code> cannot be compared by definition, 
if <code>sortedValues</code> vector contains <code>NA</code>, the result is unpredictable and NO warning is given. Hence remove them before calling these functions.
</p>


<h3>Value</h3>

<p>The index pointing to the first element in the vector that is not less than (i.e. greater or equal to) valueToSearch.
</p>


<h3>References</h3>

<p>See http://en.cppreference.com/w/cpp/algorithm/lower_bound
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb(c(1,4,5,5,7,9),5) # returns 3
lb(c(1,4,5,5,7,9),-1) # returns 1
lb(numeric(),-1) # returns 1
</code></pre>

<hr>
<h2 id='rowfilters.DFI'>
Functions for row filters creation in <code>DFI.subset</code>.
</h2><span id='topic+EQ'></span><span id='topic+RG'></span><span id='topic+IN'></span><span id='topic+EQNA'></span><span id='topic+NOT'></span><span id='topic+AND'></span><span id='topic+OR'></span><span id='topic+print.DFI.FEXPR'></span><span id='topic+toString.DFI.FEXPR'></span><span id='topic+as.character.DFI.FEXPR'></span>

<h3>Description</h3>

<p>Functions for row filters creation in <code>DFI.subset</code>.
</p>
<p>For information about NAs handling see details section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RG(col,from,to)
IN(col,values)
EQ(col,val)
EQNA(col)
NOT(filter)
OR(...)
AND(...)
## S3 method for class 'DFI.FEXPR'
print(x,...)
## S3 method for class 'DFI.FEXPR'
toString(x,...)
## S3 method for class 'DFI.FEXPR'
as.character(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowfilters.DFI_+3A_col">col</code></td>
<td>
<p>column name to be used in the filter condition (must be an indexed column).</p>
</td></tr>
<tr><td><code id="rowfilters.DFI_+3A_from">from</code></td>
<td>
<p>inclusive lower-bound of the range (RG) filter condition.</p>
</td></tr>
<tr><td><code id="rowfilters.DFI_+3A_to">to</code></td>
<td>
<p>inclusive upper-bound of the range (RG) filter condition.</p>
</td></tr>
<tr><td><code id="rowfilters.DFI_+3A_values">values</code></td>
<td>
<p>valid values for the filter condition (used by IN).</p>
</td></tr>
<tr><td><code id="rowfilters.DFI_+3A_val">val</code></td>
<td>
<p>valid value for the filter condition (used by EQ).</p>
</td></tr>
<tr><td><code id="rowfilters.DFI_+3A_filter">filter</code></td>
<td>
<p>filter condition to be negated (created with RG,IN,EQ,NOT,OR,AND).</p>
</td></tr>
<tr><td><code id="rowfilters.DFI_+3A_...">...</code></td>
<td>
<p>one or more filters conditions to be put in AND or OR (created with RG,IN,EQ,NOT,OR,AND). For <code>print</code>, <code>toString</code> and <code>as.character</code> functions the optional arguments are currently ignored.</p>
</td></tr>
<tr><td><code id="rowfilters.DFI_+3A_x">x</code></td>
<td>
<p>an object of class DFI.FEXPR</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any filter function applied to an indexed column will filter out the NAs present in that column by default (except for <code>EQNA</code>). So, for example, 
the following filter: <code>EQ("A",3)</code> is actually equal to : <code>!is.na(A) &amp; A == 3</code>. The functions <code>print(filterExpr)</code>, <code>toString(filterExpr)</code> and <code>as.character(filterExpr)</code> return the string representation of the filter that you would use in a normal data.frame subset.
</p>
<p><code>RG</code> function accepts <code>NA</code> in <code>from,to</code> arguments, and this &quot;turns off&quot; the part of the filter set to <code>NA</code>. So, for instance <code>RG("A",NA,to)</code> will return all values <code>A &lt;= to</code> (but still filtering out the <code>NA</code> values).
</p>
<p><code>EQ</code> function accepts <code>NA</code> in <code>val</code> argument, and this simply &quot;turns off&quot; the filter on the column returning all the elements in the column (but still filtering out the <code>NA</code> values).
</p>
<p><code>IN(colName,values)</code> function is converted to <code>OR(EQ(colName,values[1]),EQ(colName,value[2]),...)</code> hence, if <code>values</code> contains <code>NA</code>, the filter will return all the elements in the column (but still filtering out the <code>NA</code> values).
</p>
<p><code>EQNA(colName)</code> function can be used to select the NAs in the column, which are excluded by the other operators.
</p>


<h3>Value</h3>

<p><code>EQ</code>,<code>RG</code>,<code>IN</code>,<code>EQNA</code>,<code>NOT</code>,<code>AND</code>,<code>OR</code> functions return an object inheriting from class 'DFI.FEXPR' to be used as row filter in <code><a href="#topic+DFI.subset">DFI.subset</a></code> function.
<code>print</code>,<code>toString</code>,<code>as.character</code> functions return the string representation of an object of class 'DFI.FEXPR'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DFI.subset">DFI.subset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create the following filter: 18 &lt;= Age &lt;= 55 &amp; Married == TRUE
filter &lt;- AND(RG('Age',18,55),EQ('Married',TRUE))

# create the following filter: Age == 25 | Married == TRUE | Name == 'John'
filter &lt;- OR(EQ('Age',25),EQ('Married',TRUE),EQ('Name','John'))

</code></pre>

<hr>
<h2 id='ub'>Binary search based upper bound operation</h2><span id='topic+ub'></span><span id='topic+ubNumeric'></span><span id='topic+ubInteger'></span><span id='topic+ubLogical'></span><span id='topic+ubCharacter'></span>

<h3>Description</h3>

<p>Returns the index pointing to the first element in the vector that is greater than valueToSearch.
The behavior is the same as C++ std::upper_bound function, hence, if the vector is empty it or if valueToSearch is greater than
the last element of the vector, it returns <code>length(sortedValues) + 1</code>.
</p>
<p>The functions suffixed with the vector type (ubNumeric,ubLogical etc.) can be used ONLY with the specified type, otherwise the
vector is coerced, and they are (hopefully negligibly) faster then the generic ub function.
</p>
<p>For information about NAs handling see details section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ub(sortedValues, valueToSearch)
ubInteger(sortedValues, valueToSearch)
ubNumeric(sortedValues, valueToSearch)
ubLogical(sortedValues, valueToSearch)
ubCharacter(sortedValues, valueToSearch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ub_+3A_sortedvalues">sortedValues</code></td>
<td>
<p>A sorted atomic vector of type numeric, integer, logical or character </p>
</td></tr>
<tr><td><code id="ub_+3A_valuetosearch">valueToSearch</code></td>
<td>
<p>The value to search. If equal to <code>NA</code>, <code>length(sortedValues)+1</code> is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ub*</code> functions expect <code>sortedValues</code> to be a vector sorted ascending (duplicated values are allowed). 
Since the binary search functions rely on values comparison (using <code>&lt;</code> operator) and <code>NA</code> cannot be compared by definition, 
if <code>sortedValues</code> vector contains <code>NA</code>, the result is unpredictable and NO warning is given. Hence remove them before calling these functions.
</p>


<h3>Value</h3>

<p>The index pointing to the first element in the vector that is not less than (i.e. greater or equal to) valueToSearch.
</p>


<h3>References</h3>

<p>See http://en.cppreference.com/w/cpp/algorithm/lower_bound
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ub(c(1,4,5,5,7,9),5) # returns 5
ub(c(1,4,5,5,7,9),10) # returns 7
ub(numeric(),10) # returns 1
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
