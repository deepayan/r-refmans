<!DOCTYPE html><html><head><title>Help for package elastic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {elastic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#elastic'><p>elastic</p></a></li>
<li><a href='#alias'><p>Elasticsearch alias APIs</p></a></li>
<li><a href='#cat'><p>Use the cat Elasticsearch api.</p></a></li>
<li><a href='#cluster'><p>Elasticsearch cluster endpoints</p></a></li>
<li><a href='#connect'><p>Set connection details to an Elasticsearch engine.</p></a></li>
<li><a href='#count'><p>Get counts of the number of records per index.</p></a></li>
<li><a href='#docs_bulk'><p>Use the bulk API to create, index, update, or delete documents.</p></a></li>
<li><a href='#docs_bulk_create'><p>Use the bulk API to create documents</p></a></li>
<li><a href='#docs_bulk_delete'><p>Use the bulk API to delete documents</p></a></li>
<li><a href='#docs_bulk_index'><p>Use the bulk API to index documents</p></a></li>
<li><a href='#docs_bulk_prep'><p>Use the bulk API to prepare bulk format data</p></a></li>
<li><a href='#docs_bulk_update'><p>Use the bulk API to update documents</p></a></li>
<li><a href='#docs_create'><p>Create a document</p></a></li>
<li><a href='#docs_delete'><p>Delete a document</p></a></li>
<li><a href='#docs_delete_by_query'><p>Delete documents by query</p></a></li>
<li><a href='#docs_get'><p>Get documents</p></a></li>
<li><a href='#docs_mget'><p>Get multiple documents via the multiple get API</p></a></li>
<li><a href='#docs_update'><p>Update a document</p></a></li>
<li><a href='#docs_update_by_query'><p>Update documents by query</p></a></li>
<li><a href='#documents'><p>Elasticsearch documents functions.</p></a></li>
<li><a href='#elastic-defunct'><p>Defunct functions in elastic</p></a></li>
<li><a href='#es_parse'><p>Parse raw data from es_get, es_mget, or es_search.</p></a></li>
<li><a href='#explain'><p>Explain a search query.</p></a></li>
<li><a href='#field_caps'><p>Field capabilities</p></a></li>
<li><a href='#field_stats'><p>Search field statistics</p></a></li>
<li><a href='#fielddata'><p>fielddata</p></a></li>
<li><a href='#index_status'><p>This function is defunct</p></a></li>
<li><a href='#index_template'><p>Index templates</p></a></li>
<li><a href='#indices'><p>Index API operations</p></a></li>
<li><a href='#info'><p>This function is defunct</p></a></li>
<li><a href='#ingest'><p>Ingest API operations</p></a></li>
<li><a href='#mapping'><p>Mapping management</p></a></li>
<li><a href='#mapping_delete'><p>Mapping delete</p></a></li>
<li><a href='#mlt'><p>This function is defunct</p></a></li>
<li><a href='#msearch'><p>Multi-search</p></a></li>
<li><a href='#mtermvectors'><p>Multi Termvectors</p></a></li>
<li><a href='#nodes'><p>Elasticsearch nodes endpoints.</p></a></li>
<li><a href='#nodes_shutdown'><p>This function is defunct</p></a></li>
<li><a href='#percolate'><p>Percolater</p></a></li>
<li><a href='#ping'><p>Ping an Elasticsearch server.</p></a></li>
<li><a href='#preference'><p>Preferences.</p></a></li>
<li><a href='#reindex'><p>Reindex</p></a></li>
<li><a href='#scroll'><p>Scroll search function</p></a></li>
<li><a href='#Search'><p>Full text search of Elasticsearch</p></a></li>
<li><a href='#search_body'><p>Full text search of Elasticsearch - body requests.</p></a></li>
<li><a href='#search_shards'><p>Search shards</p></a></li>
<li><a href='#Search_template'><p>Search or validate templates</p></a></li>
<li><a href='#Search_uri'><p>Full text search of Elasticsearch with URI search</p></a></li>
<li><a href='#searchapis'><p>Overview of search functions</p></a></li>
<li><a href='#tasks'><p>Elasticsearch tasks endpoints</p></a></li>
<li><a href='#termvectors'><p>Termvectors</p></a></li>
<li><a href='#tokenizer_set'><p>Tokenizer operations</p></a></li>
<li><a href='#type_remover'><p>Utility function to remove 'type' from bulk load files</p></a></li>
<li><a href='#units-distance'><p>Distance units</p></a></li>
<li><a href='#units-time'><p>Time units</p></a></li>
<li><a href='#validate'><p>Validate a search</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>General Purpose Interface to 'Elasticsearch'</td>
</tr>
<tr>
<td>Description:</td>
<td>Connect to 'Elasticsearch', a 'NoSQL' database built on the 'Java'
    Virtual Machine. Interacts with the 'Elasticsearch' 'HTTP' API
    (<a href="https://www.elastic.co/elasticsearch/">https://www.elastic.co/elasticsearch/</a>), including functions for
    setting connection details to 'Elasticsearch' instances, loading bulk data,
    searching for documents with both 'HTTP' query variables and 'JSON' based body
    requests. In addition, 'elastic' provides functions for interacting with API's
    for 'indices', documents, nodes, clusters, an interface to the cat API, and
    more.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/elastic/">https://docs.ropensci.org/elastic/</a> (website),
<a href="https://github.com/ropensci/elastic">https://github.com/ropensci/elastic</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/elastic/issues">https://github.com/ropensci/elastic/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, curl (&ge; 2.2), crul (&ge; 0.9.0), jsonlite (&ge; 1.1), R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>X-schema.org-applicationCategory:</td>
<td>Databases</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>database, Elasticsearch, HTTP, API, search,
NoSQL, Java, JSON, documents</td>
</tr>
<tr>
<td>X-schema.org-isPartOf:</td>
<td>https://ropensci.org</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-16 17:50:34 UTC; sckott</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Chamberlain <a href="https://orcid.org/0000-0003-1444-9135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Scott Chamberlain &lt;myrmecocystus@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-16 22:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='elastic'>elastic</h2><span id='topic+elastic'></span><span id='topic+elastic-package'></span>

<h3>Description</h3>

<p>An Elasticsearch R client.
</p>


<h3>About</h3>

<p>This package gives you access to local or remote Elasticsearch databases.
</p>


<h3>Quick start</h3>

<p>If you're connecting to a Elasticsearch server already running, skip ahead to <strong>Search</strong>
</p>
<p>Install Elasticsearch (on OSX)
</p>

<ul>
<li><p> Download zip or tar file from Elasticsearch see here for download:
<a href="https://www.elastic.co/downloads/elasticsearch">https://www.elastic.co/downloads/elasticsearch</a>
</p>
</li>
<li><p> Unzip it: <code style="white-space: pre;">&#8288;untar elasticsearch-2.3.5.tar.gz&#8288;</code>
</p>
</li>
<li><p> Move it: <code style="white-space: pre;">&#8288;sudo mv elasticsearch-2.3.5 /usr/local&#8288;</code>
(replace version with your version)
</p>
</li>
<li><p> Navigate to /usr/local: <code>cd /usr/local</code>
</p>
</li>
<li><p> Add shortcut: <code style="white-space: pre;">&#8288;sudo ln -s elasticsearch-2.3.5 elasticsearch&#8288;</code>
(replace version with your version)
</p>
</li></ul>

<p>For help on other platforms, see
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html</a>
</p>
<p><strong>Start Elasticsearch</strong>
</p>

<ul>
<li><p> Navigate to elasticsearch: <code>cd /usr/local/elasticsearch</code>
</p>
</li>
<li><p> Start elasticsearch: <code>bin/elasticsearch</code>
</p>
</li></ul>

<p><strong>Initialization</strong>
</p>
<p>The function <code><a href="#topic+connect">connect()</a></code> is used before doing anything else to set
the connection details to your remote or local elasticsearch store. The
details created by <code><a href="#topic+connect">connect()</a></code> are written to your options for the
current session, and are used by <code>elastic</code> functions.
</p>
<p><strong>Search</strong>
</p>
<p>The main way to search Elasticsearch is via the <code><a href="#topic+Search">Search()</a></code> function. E.g.:
</p>
<p><code>Search()</code>
</p>


<h3>Security</h3>

<p>Elasticsearch is insecure out of the box! If you are running Elasticsearch
locally on your own machine without exposing a port to the outside world, no
worries, but if you install on a server with a public IP address, take the
necessary precautions. There are a few options:
</p>

<ul>
<li><p> Shield - A paid product - so probably only applicable to enterprise users
</p>
</li>
<li><p> DIY security - there are a variety of techniques for securing your
Elasticsearch. I collected a number of resources in a blog post at
<a href="https://recology.info/2015/02/secure-elasticsearch/">https://recology.info/2015/02/secure-elasticsearch/</a>
</p>
</li></ul>



<h3>Elasticsearch changes</h3>

<p>As of Elasticsearch v2:
</p>

<ul>
<li><p> You can no longer create fields with dots in the name.
</p>
</li>
<li><p> Type names may not start with a dot (other than the special <code>.percolator</code> type)
</p>
</li>
<li><p> Type names may not be longer than 255 characters
</p>
</li>
<li><p> Types may no longer be deleted
</p>
</li>
<li><p> Queries and filters have been merged - all filter clauses are now query clauses.
Instead, query clauses can now be used in query context or in filter context. See
examples in <code><a href="#topic+Search">Search()</a></code> or <code><a href="#topic+Search_uri">Search_uri()</a></code>
</p>
</li></ul>



<h3>index names</h3>

<p>The following are illegal characters, and can not be used in index names or types:
<code style="white-space: pre;">&#8288;\\&#8288;</code>, <code>/</code>, <code>*</code>, <code style="white-space: pre;">&#8288;?&#8288;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>|</code>, <code style="white-space: pre;">&#8288;,&#8288;</code> (comma). double quote and whitespace are
also illegal.
</p>


<h3>Author(s)</h3>

<p>Scott Chamberlain
</p>

<hr>
<h2 id='alias'>Elasticsearch alias APIs</h2><span id='topic+alias'></span><span id='topic+alias_get'></span><span id='topic+aliases_get'></span><span id='topic+alias_exists'></span><span id='topic+alias_create'></span><span id='topic+alias_rename'></span><span id='topic+alias_delete'></span>

<h3>Description</h3>

<p>Elasticsearch alias APIs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alias_get(conn, index = NULL, alias = NULL, ignore_unavailable = FALSE, ...)

aliases_get(conn, index = NULL, alias = NULL, ignore_unavailable = FALSE, ...)

alias_exists(conn, index = NULL, alias = NULL, ...)

alias_create(
  conn,
  index,
  alias,
  filter = NULL,
  routing = NULL,
  search_routing = NULL,
  index_routing = NULL,
  ...
)

alias_rename(conn, index, alias, alias_new, ...)

alias_delete(conn, index = NULL, alias, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alias_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="alias_+3A_index">index</code></td>
<td>
<p>(character) An index name</p>
</td></tr>
<tr><td><code id="alias_+3A_alias">alias</code></td>
<td>
<p>(character) An alias name</p>
</td></tr>
<tr><td><code id="alias_+3A_ignore_unavailable">ignore_unavailable</code></td>
<td>
<p>(logical) What to do if an specified index name
doesn't exist. If set to <code>TRUE</code> then those indices are ignored.</p>
</td></tr>
<tr><td><code id="alias_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-POST">crul::verb-POST</a>, <a href="crul.html#topic+verb-GET">crul::verb-GET</a>,
<a href="crul.html#topic+verb-HEAD">crul::verb-HEAD</a>, or <a href="crul.html#topic+verb-DELETE">crul::verb-DELETE</a></p>
</td></tr>
<tr><td><code id="alias_+3A_filter">filter</code></td>
<td>
<p>(named list) provides an easy way to create different &quot;views&quot; of
the same index. Defined using Query DSL and is applied to all Search, Count,
Delete By Query and More Like This operations with this alias. See
examples</p>
</td></tr>
<tr><td><code id="alias_+3A_routing">routing</code>, <code id="alias_+3A_search_routing">search_routing</code>, <code id="alias_+3A_index_routing">index_routing</code></td>
<td>
<p>(character) Associate a routing
value with an alias</p>
</td></tr>
<tr><td><code id="alias_+3A_alias_new">alias_new</code></td>
<td>
<p>(character) A new alias name, used in rename only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that you can also create aliases when you create indices
by putting the directive in the request body. See the Elasticsearch
docs link
</p>


<h3>Author(s)</h3>

<p>Scott Chamberlain <a href="mailto:myrmecocystus@gmail.com">myrmecocystus@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

if (!index_exists(x, "plos")) {
  plosdat &lt;- system.file("examples", "plos_data.json", package = "elastic")
  invisible(docs_bulk(x, plosdat))
}
if (!index_exists(x, "shakespeare")) {
  shake &lt;- system.file("examples", "shakespeare_data_.json", package = "elastic")
  invisible(docs_bulk(x, shake))
}

# Create/update an alias
alias_create(x, index = "plos", alias = "candles")
## more than one alias
alias_create(x, index = "plos", alias = c("tables", "chairs"))

# associate an alias with two multiple different indices
alias_create(x, index = c("plos", "shakespeare"), alias = "stools")

# Retrieve a specified alias
alias_get(x, index="plos")
alias_get(x, alias="tables")
alias_get(x, alias="stools")
aliases_get(x)

# rename an alias
aliases_get(x, "plos")
alias_rename(x, index = 'plos', alias = "stools", alias_new = "plates")
aliases_get(x, "plos")

# filtered aliases
alias_create(x, index = "plos", alias = "candles", 
  filter = list(wildcard = list(title = "cell")))
## a search with the alias should give titles with cell in them
(titles &lt;- Search(x, "candles", asdf = TRUE)$hits$hits$`_source.title`)
grepl("cell", titles, ignore.case = TRUE)

# routing
alias_create(x, index = "plos", alias = "candles", 
  routing = "1")

# Check for alias existence
alias_exists(x, index = "plos")
alias_exists(x, alias = "tables")
alias_exists(x, alias = "adsfasdf")

# Delete an alias
alias_delete(x, index = "plos", alias = "tables")
alias_exists(x, alias = "tables")

# Curl options
alias_create(x, index = "plos", alias = "tables")
aliases_get(x, alias = "tables", verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cat'>Use the cat Elasticsearch api.</h2><span id='topic+cat'></span><span id='topic+cat_'></span><span id='topic+cat_aliases'></span><span id='topic+cat_allocation'></span><span id='topic+cat_count'></span><span id='topic+cat_segments'></span><span id='topic+cat_health'></span><span id='topic+cat_indices'></span><span id='topic+cat_master'></span><span id='topic+cat_nodes'></span><span id='topic+cat_nodeattrs'></span><span id='topic+cat_pending_tasks'></span><span id='topic+cat_plugins'></span><span id='topic+cat_recovery'></span><span id='topic+cat_thread_pool'></span><span id='topic+cat_shards'></span><span id='topic+cat_fielddata'></span>

<h3>Description</h3>

<p>Use the cat Elasticsearch api.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_(conn, parse = FALSE, ...)

cat_aliases(
  conn,
  verbose = FALSE,
  index = NULL,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  expand_wildcards = "all",
  ...
)

cat_allocation(
  conn,
  verbose = FALSE,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_count(
  conn,
  verbose = FALSE,
  index = NULL,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_segments(
  conn,
  verbose = FALSE,
  index = NULL,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_health(
  conn,
  verbose = FALSE,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_indices(
  conn,
  verbose = FALSE,
  index = NULL,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_master(
  conn,
  verbose = FALSE,
  index = NULL,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_nodes(
  conn,
  verbose = FALSE,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_nodeattrs(
  conn,
  verbose = FALSE,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_pending_tasks(
  conn,
  verbose = FALSE,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_plugins(
  conn,
  verbose = FALSE,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_recovery(
  conn,
  verbose = FALSE,
  index = NULL,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_thread_pool(
  conn,
  verbose = FALSE,
  index = NULL,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_shards(
  conn,
  verbose = FALSE,
  index = NULL,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)

cat_fielddata(
  conn,
  verbose = FALSE,
  index = NULL,
  fields = NULL,
  h = NULL,
  help = FALSE,
  bytes = FALSE,
  parse = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="cat_+3A_parse">parse</code></td>
<td>
<p>(logical) Parse to a data.frame or not. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="cat_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
<tr><td><code id="cat_+3A_verbose">verbose</code></td>
<td>
<p>(logical) If <code>TRUE</code> (default) the url call used printed to
console</p>
</td></tr>
<tr><td><code id="cat_+3A_index">index</code></td>
<td>
<p>(character) Index name</p>
</td></tr>
<tr><td><code id="cat_+3A_h">h</code></td>
<td>
<p>(character) Fields to return</p>
</td></tr>
<tr><td><code id="cat_+3A_help">help</code></td>
<td>
<p>(logical) Output available columns, and their meanings</p>
</td></tr>
<tr><td><code id="cat_+3A_bytes">bytes</code></td>
<td>
<p>(logical) Give numbers back machine friendly. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="cat_+3A_expand_wildcards">expand_wildcards</code></td>
<td>
<p>(character) Whether to expand wildcard expression
to concrete indices that are open, closed or both.  Valid choices: 'open',
'closed', 'hidden', 'none', 'all'. default: 'all'. Available in ES &gt;= v7.7</p>
</td></tr>
<tr><td><code id="cat_+3A_fields">fields</code></td>
<td>
<p>(character) Fields to return, only used with <code>fielddata</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html</a>
for the cat API documentation.
</p>
<p>Note how <code><a href="#topic+cat_">cat_()</a></code> has an underscore at the end to avoid conflict with the
function <code><a href="base.html#topic+cat">base::cat()</a></code> in base R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

# list Elasticsearch cat endpoints
cat_(x)

# Do other cat operations
cat_aliases(x)
alias_create(x, index = "plos", alias = c("tables", "chairs"))
cat_aliases(x, expand_wildcards='open')
cat_aliases(x, expand_wildcards='all')
cat_allocation(x)
cat_allocation(x, verbose=TRUE)
cat_count(x)
cat_count(x, index='plos')
cat_count(x, index='gbif')
cat_segments(x)
cat_segments(x, index='gbif')
cat_health(x)
cat_indices(x)
cat_master(x)
cat_nodes(x)
# cat_nodeattrs(x) # not available in older ES versions
cat_pending_tasks(x)
cat_plugins(x)
cat_recovery(x, verbose=TRUE)
cat_recovery(x, index='gbif')
cat_thread_pool(x)
cat_thread_pool(x, verbose=TRUE)
cat_shards(x)
cat_fielddata(x)
cat_fielddata(x, fields='body')

# capture cat data into a data.frame
cat_(x, parse = TRUE)
cat_indices(x, parse = TRUE)
cat_indices(x, parse = TRUE, verbose = TRUE)
cat_count(x, parse = TRUE)
cat_count(x, parse = TRUE, verbose = TRUE)
cat_health(x, parse = TRUE)
cat_health(x, parse = TRUE, verbose = TRUE)

# Get help - what does each column mean
head(cat_indices(x, help = TRUE, parse = TRUE))
cat_health(x, help = TRUE, parse = TRUE)
head(cat_nodes(x, help = TRUE, parse = TRUE))

# Get back only certain fields
cat_nodes(x)
cat_nodes(x, h = c('ip','port','heapPercent','name'))
cat_nodes(x, h = c('id', 'ip', 'port', 'v', 'm'))
cat_indices(x, verbose = TRUE)
cat_indices(x, verbose = TRUE, h = c('index','docs.count','store.size'))

# Get back machine friendly numbers instead of the normal human friendly
cat_indices(x, verbose = TRUE, bytes = TRUE)

# Curl options
# cat_count(x, timeout_ms = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='cluster'>Elasticsearch cluster endpoints</h2><span id='topic+cluster'></span><span id='topic+cluster_settings'></span><span id='topic+cluster_health'></span><span id='topic+cluster_state'></span><span id='topic+cluster_stats'></span><span id='topic+cluster_reroute'></span><span id='topic+cluster_pending_tasks'></span>

<h3>Description</h3>

<p>Elasticsearch cluster endpoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_settings(
  conn,
  index = NULL,
  raw = FALSE,
  callopts = list(),
  verbose = TRUE,
  ...
)

cluster_health(
  conn,
  index = NULL,
  level = NULL,
  wait_for_status = NULL,
  wait_for_relocating_shards = NULL,
  wait_for_active_shards = NULL,
  wait_for_nodes = NULL,
  timeout = NULL,
  raw = FALSE,
  callopts = list(),
  verbose = TRUE,
  ...
)

cluster_state(
  conn,
  index = NULL,
  metrics = NULL,
  raw = FALSE,
  callopts = list(),
  verbose = TRUE,
  ...
)

cluster_stats(
  conn,
  index = NULL,
  raw = FALSE,
  callopts = list(),
  verbose = TRUE,
  ...
)

cluster_reroute(conn, body, raw = FALSE, callopts = list(), ...)

cluster_pending_tasks(
  conn,
  index = NULL,
  raw = FALSE,
  callopts = list(),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="cluster_+3A_index">index</code></td>
<td>
<p>Index</p>
</td></tr>
<tr><td><code id="cluster_+3A_raw">raw</code></td>
<td>
<p>If <code>TRUE</code> (default), data is parsed to list. If <code>FALSE</code>, then raw JSON.</p>
</td></tr>
<tr><td><code id="cluster_+3A_callopts">callopts</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-POST">crul::verb-POST</a></p>
</td></tr>
<tr><td><code id="cluster_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) the url call used printed to console.</p>
</td></tr>
<tr><td><code id="cluster_+3A_...">...</code></td>
<td>
<p>Further args passed on to elastic search HTTP API as parameters.</p>
</td></tr>
<tr><td><code id="cluster_+3A_level">level</code></td>
<td>
<p>Can be one of cluster, indices or shards. Controls the details level of the
health information returned. Defaults to cluster.</p>
</td></tr>
<tr><td><code id="cluster_+3A_wait_for_status">wait_for_status</code></td>
<td>
<p>One of green, yellow or red. Will wait (until the timeout
provided) until the status of the cluster changes to the one provided or better, i.e.
green &gt; yellow &gt; red. By default, will not wait for any status.</p>
</td></tr>
<tr><td><code id="cluster_+3A_wait_for_relocating_shards">wait_for_relocating_shards</code></td>
<td>
<p>A number controlling to how many relocating shards
to wait for. Usually will be 0 to indicate to wait till all relocations have happened.
Defaults to not wait.</p>
</td></tr>
<tr><td><code id="cluster_+3A_wait_for_active_shards">wait_for_active_shards</code></td>
<td>
<p>A number controlling to how many active shards to wait for.
Defaults to not wait.</p>
</td></tr>
<tr><td><code id="cluster_+3A_wait_for_nodes">wait_for_nodes</code></td>
<td>
<p>The request waits until the specified number N of nodes is
available. It also accepts &gt;=N, &lt;=N, &gt;N and &lt;N. Alternatively, it is possible to use
ge(N), le(N), gt(N) and lt(N) notation.</p>
</td></tr>
<tr><td><code id="cluster_+3A_timeout">timeout</code></td>
<td>
<p>A time based parameter controlling how long to wait if one of the
wait_for_XXX are provided. Defaults to 30s.</p>
</td></tr>
<tr><td><code id="cluster_+3A_metrics">metrics</code></td>
<td>
<p>One or more of version, master_node, nodes, routing_table,
metadata, and blocks. See Details.</p>
</td></tr>
<tr><td><code id="cluster_+3A_body">body</code></td>
<td>
<p>Query, either a list or json.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>metrics param options:
</p>

<ul>
<li><p> version Shows the cluster state version.
</p>
</li>
<li><p> master_node Shows the elected master_node part of the response
</p>
</li>
<li><p> nodes Shows the nodes part of the response
</p>
</li>
<li><p> routing_table Shows the routing_table part of the response. If you supply
a comma separated list of indices, the returned output will only contain the
indices listed.
</p>
</li>
<li><p> metadata Shows the metadata part of the response. If you supply a comma
separated list of indices, the returned output will only contain the indices
listed.
</p>
</li>
<li><p> blocks Shows the blocks part of the response
</p>
</li></ul>

<p>Additional parameters that can be passed in:
</p>

<ul>
<li><p> metric A comma-separated list of metrics to display. Possible values: '_all',
'completion', 'docs', 'fielddata', 'filter_cache', 'flush', 'get', 'id_cache', 'indexing',
'merge', 'percolate', 'refresh', 'search', 'segments', 'store', 'warmer'
</p>
</li>
<li><p> completion_fields A comma-separated list of fields for completion metric (supports
wildcards)
</p>
</li>
<li><p> fielddata_fields A comma-separated list of fields for fielddata metric (supports
wildcards)
</p>
</li>
<li><p> fields A comma-separated list of fields for fielddata and completion metric (supports
wildcards)
</p>
</li>
<li><p> groups A comma-separated list of search groups for search statistics
</p>
</li>
<li><p> allow_no_indices Whether to ignore if a wildcard indices expression resolves into no
concrete indices. (This includes _all string or when no indices have been specified)
</p>
</li>
<li><p> expand_wildcards Whether to expand wildcard expression to concrete indices that are
open, closed or both.
</p>
</li>
<li><p> ignore_indices When performed on multiple indices, allows to ignore missing ones
(default: none)
</p>
</li>
<li><p> ignore_unavailable Whether specified concrete indices should be ignored when unavailable
(missing or closed)
</p>
</li>
<li><p> human Whether to return time and byte values in human-readable format.
</p>
</li>
<li><p> level Return stats aggregated at cluster, index or shard level. ('cluster', 'indices'
or 'shards', default: 'indices')
</p>
</li>
<li><p> types A comma-separated list of document types for the indexing index metric
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

cluster_settings(x)
cluster_health(x)

cluster_state(x)
cluster_state(x, metrics = "version")
cluster_state(x, metrics = "nodes")
cluster_state(x, metrics = c("version", "nodes"))
cluster_state(x, metrics = c("version", "nodes", 'blocks'))
cluster_state(x, "shakespeare", metrics = "metadata")
cluster_state(x, c("shakespeare", "flights"), metrics = "metadata")

cluster_stats(x)
cluster_pending_tasks(x)

body &lt;- '{
  "commands": [ 
    {
      "move": {
        "index" : "test", "shard" : 0,
        "from_node" : "node1", "to_node" : "node2"
      }
    },
    {
      "allocate_replica" : {
        "index" : "test", "shard" : 1, "node" : "node3"
      }
    }
  ]
}'
# cluster_reroute(x, body =  body)

cluster_health(x)
# cluster_health(x, wait_for_status = "yellow", timeout = "3s")

## End(Not run)
</code></pre>

<hr>
<h2 id='connect'>Set connection details to an Elasticsearch engine.</h2><span id='topic+connect'></span>

<h3>Description</h3>

<p>Set connection details to an Elasticsearch engine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connect(
  host = "127.0.0.1",
  port = 9200,
  path = NULL,
  transport_schema = "http",
  user = NULL,
  pwd = NULL,
  headers = NULL,
  cainfo = NULL,
  force = FALSE,
  errors = "simple",
  warn = TRUE,
  ignore_version = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connect_+3A_host">host</code></td>
<td>
<p>(character) The base host, defaults to <code style="white-space: pre;">&#8288;127.0.0.1&#8288;</code></p>
</td></tr>
<tr><td><code id="connect_+3A_port">port</code></td>
<td>
<p>(character) port to connect to, defaults to <code>9200</code>
(optional)</p>
</td></tr>
<tr><td><code id="connect_+3A_path">path</code></td>
<td>
<p>(character) context path that is appended to the end of the
url. Default: <code>NULL</code>, ignored</p>
</td></tr>
<tr><td><code id="connect_+3A_transport_schema">transport_schema</code></td>
<td>
<p>(character) http or https. Default: <code>http</code></p>
</td></tr>
<tr><td><code id="connect_+3A_user">user</code></td>
<td>
<p>(character) User name, if required for the connection. You
can specify,  but ignored for now.</p>
</td></tr>
<tr><td><code id="connect_+3A_pwd">pwd</code></td>
<td>
<p>(character) Password, if required for the connection. You
can specify, but ignored for now.</p>
</td></tr>
<tr><td><code id="connect_+3A_headers">headers</code></td>
<td>
<p>named list of headers. These headers are used in all requests</p>
</td></tr>
<tr><td><code id="connect_+3A_cainfo">cainfo</code></td>
<td>
<p>(character) path to a crt bundle, passed to curl option
<code>cainfo</code></p>
</td></tr>
<tr><td><code id="connect_+3A_force">force</code></td>
<td>
<p>(logical) Force re-load of connection details.
Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="connect_+3A_errors">errors</code></td>
<td>
<p>(character) One of simple (Default) or complete. Simple gives
http code and  error message on an error, while complete gives both http
code and error message,  and stack trace, if available.</p>
</td></tr>
<tr><td><code id="connect_+3A_warn">warn</code></td>
<td>
<p>(logical) whether to throw warnings from the Elasticsearch
server when provided. Pulls warnings from response headers when given.
default: <code>TRUE</code>. To turn these off, you can set <code>warn=FALSE</code> or
wrap function calls in <code><a href="base.html#topic+suppressWarnings">suppressWarnings()</a></code>. You can also see warnings in
headers by using curl verbose.</p>
</td></tr>
<tr><td><code id="connect_+3A_ignore_version">ignore_version</code></td>
<td>
<p>(logical) ignore Elasticsearch version checks?
default: <code>FALSE</code>. Setting this to <code>TRUE</code> may cause some problems, it
has not been fully tested yet. You may want to set this to <code>TRUE</code> if
it's not possible to ping the root route of the Elasticsearch instance,
which has the Elasticsearch version. We use the version to do
alter what request is sent as different Elasticsearch versions allow
different parameters.</p>
</td></tr>
<tr><td><code id="connect_+3A_...">...</code></td>
<td>
<p>additional curl options to be passed in ALL http requests</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default configuration is set up for localhost access on port
9200, with no username or password.
</p>
<p>Running this connection method doesn't ping the ES server, but only prints
your connection details.
</p>
<p>All connection details are stored within the returned object. We used to
store them in various env vars, but are now contained within the object
so you can have any number of connection objects and they shouldn't
conflict with one another.
</p>


<h3>What is the connection object?</h3>

<p>Creating a connection object with <code>connect()</code> does not create
a DBI-like connection object. DBI-like objects have externalptr, etc.,
while <code>connect()</code> simply holds details about your Elasticsearch
instance (host, port, authentication, etc.) that is used by other
methods in this package to interact with your instances' ES API.
<code>connect()</code> is more or less a fancy list.
</p>
<p>You can connect to different Elasticsearch intances within the same
R session by creating a separate connection object for each instance;
then pass the appropriate connection object to each <code>elastic</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# the default is set to 127.0.0.1 (i.e., localhost) and port 9200
(x &lt;- connect())
x$make_url()
x$ping()

# pass connection object to function calls
Search(x, q = "*:*")

# set username/password (hidden in print method)
connect(user = "me", pwd = "stuff")

# set a different host
# connect(host = '162.243.152.53')
# =&gt; http://162.243.152.53:9200

# set a different port
# connect(port = 8000)
# =&gt; http://localhost:8000

# set a different context path
# connect(path = 'foo_bar')
# =&gt; http://localhost:9200/foo_bar

# set to https
# connect(transport_schema = 'https')
# =&gt; https://localhost:9200

# set headers
connect(headers = list(a = 'foobar'))

# set cainfo path (hidden in print method)
connect(cainfo = '/some/path/bundle.crt')

## End(Not run)
</code></pre>

<hr>
<h2 id='count'>Get counts of the number of records per index.</h2><span id='topic+count'></span>

<h3>Description</h3>

<p>Get counts of the number of records per index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count(conn, index = NULL, type = NULL, callopts = list(), verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="count_+3A_index">index</code></td>
<td>
<p>Index, defaults to all indices</p>
</td></tr>
<tr><td><code id="count_+3A_type">type</code></td>
<td>
<p>Document type, optional</p>
</td></tr>
<tr><td><code id="count_+3A_callopts">callopts</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-GET">crul::verb-GET</a></p>
</td></tr>
<tr><td><code id="count_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) the url call used printed to console.</p>
</td></tr>
<tr><td><code id="count_+3A_...">...</code></td>
<td>
<p>Further args passed on to elastic search HTTP API as parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See docs for the count API here
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html</a>
</p>
<p>You can also get a count of documents using <code><a href="#topic+Search">Search()</a></code> or
<code><a href="#topic+Search_uri">Search_uri()</a></code> and setting <code>size = 0</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

if (!index_exists(x, "plos")) {
  plosdat &lt;- system.file("examples", "plos_data.json",
    package = "elastic")
  plosdat &lt;- type_remover(plosdat)
  invisible(docs_bulk(x, plosdat))
}
if (!index_exists(x, "shakespeare")) {
  shake &lt;- system.file("examples", "shakespeare_data_.json", 
    package = "elastic")
  invisible(docs_bulk(x, shake))
}

count(x)
count(x, index='plos')
count(x, index='shakespeare')
count(x, index=c('plos','shakespeare'), q="a*")
count(x, index=c('plos','shakespeare'), q="z*")

# Curl options
count(x, callopts = list(verbose = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_bulk'>Use the bulk API to create, index, update, or delete documents.</h2><span id='topic+docs_bulk'></span>

<h3>Description</h3>

<p>Use the bulk API to create, index, update, or delete documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_bulk(
  conn,
  x,
  index = NULL,
  type = NULL,
  chunk_size = 1000,
  doc_ids = NULL,
  es_ids = TRUE,
  raw = FALSE,
  quiet = FALSE,
  query = list(),
  digits = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_bulk_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="docs_bulk_+3A_x">x</code></td>
<td>
<p>A list, data.frame, or character path to a file. required.</p>
</td></tr>
<tr><td><code id="docs_bulk_+3A_index">index</code></td>
<td>
<p>(character) The index name to use. Required for data.frame
input, but optional for file inputs.</p>
</td></tr>
<tr><td><code id="docs_bulk_+3A_type">type</code></td>
<td>
<p>(character) The type. default: <code>NULL</code>. Note that <code>type</code> is
deprecated in Elasticsearch v7 and greater, and removed in Elasticsearch v8</p>
</td></tr>
<tr><td><code id="docs_bulk_+3A_chunk_size">chunk_size</code></td>
<td>
<p>(integer) Size of each chunk. If your data.frame is smaller
thank <code>chunk_size</code>, this parameter is essentially ignored. We write in
chunks because at some point, depending on size of each document, and
Elasticsearch setup, writing a very large number of documents in one go
becomes slow, so chunking can help. This parameter is ignored if you
pass a file name. Default: 1000</p>
</td></tr>
<tr><td><code id="docs_bulk_+3A_doc_ids">doc_ids</code></td>
<td>
<p>An optional vector (character or numeric/integer) of document
ids to use. This vector has to equal the size of the documents you are
passing in, and will error if not. If you pass a factor we convert to
character. Default: not passed</p>
</td></tr>
<tr><td><code id="docs_bulk_+3A_es_ids">es_ids</code></td>
<td>
<p>(boolean) Let Elasticsearch assign document IDs as UUIDs.
These are sequential, so there is order to the IDs they assign.
If <code>TRUE</code>, <code>doc_ids</code> is ignored. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_+3A_raw">raw</code></td>
<td>
<p>(logical) Get raw JSON back or not. If <code>TRUE</code>
you get JSON; if <code>FALSE</code> you get a list. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_+3A_quiet">quiet</code></td>
<td>
<p>(logical) Suppress progress bar. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_+3A_query">query</code></td>
<td>
<p>(list) a named list of query parameters. optional.
options include: pipeline, refresh, routing, _source, _source_excludes,
_source_includes, timeout, wait_for_active_shards. See the docs bulk
ES page for details</p>
</td></tr>
<tr><td><code id="docs_bulk_+3A_digits">digits</code></td>
<td>
<p>digits used by the parameter of the same name by
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code> to convert data to JSON before being submitted to
your ES instance. default: <code>NA</code></p>
</td></tr>
<tr><td><code id="docs_bulk_+3A_...">...</code></td>
<td>
<p>Pass on curl options to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>More on the Bulk API:
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html</a>
</p>
<p>This function dispatches on data.frame or character input. Character input
has to be a file name or the function stops with an error message.
</p>
<p>If you pass a data.frame to this function, we by default do an index
operation, that is, create the record in the index given by those
parameters to the function. Down the road perhaps we will try to support
other operations on the bulk API. if you pass a file, of course in that
file, you can specify any operations you want.
</p>
<p>Row names are dropped from data.frame, and top level names for a list
are dropped as well.
</p>
<p>A progress bar gives the progress for data.frames and lists - the progress
bar is based around a for loop, where progress indicates progress along
the iterations of the for loop, where each iteration is a chunk of data
that's converted to bulk format, then pushed into Elasticsearch. The
<code>character</code> method has no for loop, so no progress bar.
</p>


<h3>Value</h3>

<p>A list
</p>


<h3>Document IDs</h3>

<p>Document IDs can be passed in via the <code>doc_ids</code> paramater when passing
in data.frame or list, but not with files. If ids are not passed to
<code>doc_ids</code>, we assign document IDs from 1 to length of the object
(rows of a data.frame, or length of a list). In the future we may allow the
user to select whether they want to assign sequential numeric IDs or
to allow Elasticsearch to assign IDs, which are UUIDs that are actually
sequential, so you still can determine an order of your documents.
</p>


<h3>Document IDs and Factors</h3>

<p>If you pass in ids that are of class factor, we coerce them to character
with <code>as.character</code>. This applies to both data.frame and list inputs, but
not to file inputs.
</p>


<h3>Large numbers for document IDs</h3>

<p>Until recently, if you had very large integers for document IDs,
<code>docs_bulk</code> failed. It should be fixed now. Let us know if not.
</p>


<h3>Missing data</h3>

<p>As of <span class="pkg">elastic</span> version <code style="white-space: pre;">&#8288;0.7.8.9515&#8288;</code> we convert <code>NA</code> to
<code>null</code> before loading into Elasticsearch. Previously, fields that
had an <code>NA</code> were dropped - but when you read data back from
Elasticsearch into R, you retain those missing values as <span class="pkg">jsonlite</span>
fills those in for you. Now, fields with <code>NA</code>'s are made into
<code>null</code>, and are not dropped in Elasticsearch.
</p>
<p>Note also that null values can not be indexed or searched
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.3/null-value.html">https://www.elastic.co/guide/en/elasticsearch/reference/5.3/null-value.html</a>
</p>


<h3>Tips</h3>

<p>This function returns the response from Elasticsearch, but you'll likely
not be that interested in the response. If not, wrap your call to
<code>docs_bulk</code> in <code><a href="base.html#topic+invisible">invisible()</a></code>, like so: <code>invisible(docs_bulk(...))</code>
</p>


<h3>Connections/Files</h3>

<p>We create temporary files, and connections to those files, when data.frame's
and lists are passed in to <code>docs_bulk()</code> (not when a file is passed in
since we don't need to create a file). After inserting data into your
Elasticsearch instance, we close the connections and delete the temporary files.
</p>
<p>There are some exceptions though. When you pass in your own file, whether a
tempfile or not, we don't delete those files after using them - in case
you need those files again. Your own tempfile's will be cleaned up/delete
when the R session ends. Non-tempfile's won't be cleaned up/deleted after
the R session ends.
</p>


<h3>Elasticsearch versions that don't support type</h3>

<p>See the <code><a href="#topic+type_remover">type_remover()</a></code> function.
</p>


<h3>See Also</h3>

<p>Other bulk-functions: 
<code><a href="#topic+docs_bulk_create">docs_bulk_create</a>()</code>,
<code><a href="#topic+docs_bulk_delete">docs_bulk_delete</a>()</code>,
<code><a href="#topic+docs_bulk_index">docs_bulk_index</a>()</code>,
<code><a href="#topic+docs_bulk_prep">docs_bulk_prep</a>()</code>,
<code><a href="#topic+docs_bulk_update">docs_bulk_update</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

# From a file already in newline delimited JSON format
plosdat &lt;- system.file("examples", "plos_data.json", package = "elastic")
docs_bulk(x, plosdat)
aliases_get(x)
index_delete(x, index='plos')
aliases_get(x)

# From a data.frame
docs_bulk(x, mtcars, index = "hello")
## field names cannot contain dots
names(iris) &lt;- gsub("\\.", "_", names(iris))
docs_bulk(x, iris, "iris")
## type can be missing, but index can not
docs_bulk(x, iris, "flowers")
## big data.frame, 53K rows, load ggplot2 package first
# res &lt;- docs_bulk(x, diamonds, "diam")
# Search(x, "diam")$hits$total

# From a list
docs_bulk(x, apply(iris, 1, as.list), index="iris")
docs_bulk(x, apply(USArrests, 1, as.list), index="arrests")
# dim_list &lt;- apply(diamonds, 1, as.list)
# out &lt;- docs_bulk(x, dim_list, index="diamfromlist")

# When using in a loop
## We internally get last _id counter to know where to start on next bulk
## insert but you need to sleep in between docs_bulk calls, longer the
## bigger the data is
files &lt;- c(system.file("examples", "test1.csv", package = "elastic"),
           system.file("examples", "test2.csv", package = "elastic"),
           system.file("examples", "test3.csv", package = "elastic"))
for (i in seq_along(files)) {
  d &lt;- read.csv(files[[i]])
  docs_bulk(x, d, index = "testes")
  Sys.sleep(1)
}
count(x, "testes")
index_delete(x, "testes")

# You can include your own document id numbers
## Either pass in as an argument
index_create(x, "testes")
files &lt;- c(system.file("examples", "test1.csv", package = "elastic"),
           system.file("examples", "test2.csv", package = "elastic"),
           system.file("examples", "test3.csv", package = "elastic"))
tt &lt;- vapply(files, function(z) NROW(read.csv(z)), numeric(1))
ids &lt;- list(1:tt[1],
           (tt[1] + 1):(tt[1] + tt[2]),
           (tt[1] + tt[2] + 1):sum(tt))
for (i in seq_along(files)) {
  d &lt;- read.csv(files[[i]])
  docs_bulk(x, d, index = "testes", doc_ids = ids[[i]],
    es_ids = FALSE)
}
count(x, "testes")
index_delete(x, "testes")

## or include in the input data
### from data.frame's
index_create(x, "testes")
files &lt;- c(system.file("examples", "test1_id.csv", package = "elastic"),
           system.file("examples", "test2_id.csv", package = "elastic"),
           system.file("examples", "test3_id.csv", package = "elastic"))
readLines(files[[1]])
for (i in seq_along(files)) {
  d &lt;- read.csv(files[[i]])
  docs_bulk(x, d, index = "testes")
}
count(x, "testes")
index_delete(x, "testes")

### from lists via file inputs
index_create(x, "testes")
for (i in seq_along(files)) {
  d &lt;- read.csv(files[[i]])
  d &lt;- apply(d, 1, as.list)
  docs_bulk(x, d, index = "testes")
}
count(x, "testes")
index_delete(x, "testes")

# data.frame's with a single column
## this didn't use to work, but now should work
db &lt;- paste0(sample(letters, 10), collapse = "")
index_create(x, db)
res &lt;- data.frame(foo = 1:10)
out &lt;- docs_bulk(x, res, index = db)
count(x, db)
index_delete(x, db)


# data.frame with a mix of actions
## make sure you use a column named 'es_action' or this won't work
## if you need to delete or update you need document IDs
if (index_exists(x, "baz")) index_delete(x, "baz")
df &lt;- data.frame(a = 1:5, b = 6:10, c = letters[1:5], stringsAsFactors = FALSE) 
invisible(docs_bulk(x, df, "baz"))
Sys.sleep(3)
(res &lt;- Search(x, 'baz', asdf=TRUE)$hits$hits)
df[1, "a"] &lt;- 99
df[1, "c"] &lt;- "aa"
df[3, "c"] &lt;- 33
df[3, "c"] &lt;- "cc"
df$es_action &lt;- c('update', 'delete', 'update', 'delete', 'delete')
df$id &lt;- res$`_id`
df
invisible(docs_bulk(x, df, "baz", es_ids = FALSE))
### or es_ids = FALSE and pass in document ids to doc_ids
# invisible(docs_bulk(df, "baz", es_ids = FALSE, doc_ids = df$id))
Search(x, 'baz', asdf=TRUE)$hits$hits


# Curl options
plosdat &lt;- system.file("examples", "plos_data.json",
  package = "elastic")
plosdat &lt;- type_remover(plosdat)
invisible(docs_bulk(x, plosdat, verbose = TRUE))


# suppress progress bar
invisible(docs_bulk(x, mtcars, index = "hello", quiet = TRUE))
## vs. 
invisible(docs_bulk(x, mtcars, index = "hello", quiet = FALSE))

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_bulk_create'>Use the bulk API to create documents</h2><span id='topic+docs_bulk_create'></span>

<h3>Description</h3>

<p>Use the bulk API to create documents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_bulk_create(
  conn,
  x,
  index = NULL,
  type = NULL,
  chunk_size = 1000,
  doc_ids = NULL,
  es_ids = TRUE,
  raw = FALSE,
  quiet = FALSE,
  query = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_bulk_create_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="docs_bulk_create_+3A_x">x</code></td>
<td>
<p>A list, data.frame, or character path to a file. required.</p>
</td></tr>
<tr><td><code id="docs_bulk_create_+3A_index">index</code></td>
<td>
<p>(character) The index name to use. Required for data.frame
input, but optional for file inputs.</p>
</td></tr>
<tr><td><code id="docs_bulk_create_+3A_type">type</code></td>
<td>
<p>(character) The type. default: <code>NULL</code>. Note that <code>type</code> is
deprecated in Elasticsearch v7 and greater, and removed in Elasticsearch v8</p>
</td></tr>
<tr><td><code id="docs_bulk_create_+3A_chunk_size">chunk_size</code></td>
<td>
<p>(integer) Size of each chunk. If your data.frame is smaller
thank <code>chunk_size</code>, this parameter is essentially ignored. We write in
chunks because at some point, depending on size of each document, and
Elasticsearch setup, writing a very large number of documents in one go
becomes slow, so chunking can help. This parameter is ignored if you
pass a file name. Default: 1000</p>
</td></tr>
<tr><td><code id="docs_bulk_create_+3A_doc_ids">doc_ids</code></td>
<td>
<p>An optional vector (character or numeric/integer) of document
ids to use. This vector has to equal the size of the documents you are
passing in, and will error if not. If you pass a factor we convert to
character. Default: not passed</p>
</td></tr>
<tr><td><code id="docs_bulk_create_+3A_es_ids">es_ids</code></td>
<td>
<p>(boolean) Let Elasticsearch assign document IDs as UUIDs.
These are sequential, so there is order to the IDs they assign.
If <code>TRUE</code>, <code>doc_ids</code> is ignored. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_create_+3A_raw">raw</code></td>
<td>
<p>(logical) Get raw JSON back or not. If <code>TRUE</code>
you get JSON; if <code>FALSE</code> you get a list. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_create_+3A_quiet">quiet</code></td>
<td>
<p>(logical) Suppress progress bar. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_create_+3A_query">query</code></td>
<td>
<p>(list) a named list of query parameters. optional.
options include: pipeline, refresh, routing, _source, _source_excludes,
_source_includes, timeout, wait_for_active_shards. See the docs bulk
ES page for details</p>
</td></tr>
<tr><td><code id="docs_bulk_create_+3A_...">...</code></td>
<td>
<p>Pass on curl options to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For doing create with a file already prepared for the bulk API,
see <code><a href="#topic+docs_bulk">docs_bulk()</a></code>
</p>
<p>Only data.frame's are supported for now.
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html</a>
</p>


<h3>See Also</h3>

<p>Other bulk-functions: 
<code><a href="#topic+docs_bulk_delete">docs_bulk_delete</a>()</code>,
<code><a href="#topic+docs_bulk_index">docs_bulk_index</a>()</code>,
<code><a href="#topic+docs_bulk_prep">docs_bulk_prep</a>()</code>,
<code><a href="#topic+docs_bulk_update">docs_bulk_update</a>()</code>,
<code><a href="#topic+docs_bulk">docs_bulk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()
if (index_exists(x, "foobar")) index_delete(x, "foobar")

df &lt;- data.frame(name = letters[1:3], size = 1:3, id = 100:102)
docs_bulk_create(x, df, 'foobar', es_ids = FALSE)
Search(x, "foobar", asdf = TRUE)$hits$hits

# more examples
docs_bulk_create(x, mtcars, index = "hello")
## field names cannot contain dots
names(iris) &lt;- gsub("\\.", "_", names(iris))
docs_bulk_create(x, iris, "iris")
## type can be missing, but index can not
docs_bulk_create(x, iris, "flowers")
## big data.frame, 53K rows, load ggplot2 package first
# res &lt;- docs_bulk_create(x, diamonds, "diam")
# Search(x, "diam")$hits$total$value

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_bulk_delete'>Use the bulk API to delete documents</h2><span id='topic+docs_bulk_delete'></span>

<h3>Description</h3>

<p>Use the bulk API to delete documents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_bulk_delete(
  conn,
  x,
  index = NULL,
  type = NULL,
  chunk_size = 1000,
  doc_ids = NULL,
  raw = FALSE,
  quiet = FALSE,
  query = list(),
  digits = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_bulk_delete_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="docs_bulk_delete_+3A_x">x</code></td>
<td>
<p>A list, data.frame, or character path to a file. required.</p>
</td></tr>
<tr><td><code id="docs_bulk_delete_+3A_index">index</code></td>
<td>
<p>(character) The index name to use. Required for data.frame
input, but optional for file inputs.</p>
</td></tr>
<tr><td><code id="docs_bulk_delete_+3A_type">type</code></td>
<td>
<p>(character) The type. default: <code>NULL</code>. Note that <code>type</code> is
deprecated in Elasticsearch v7 and greater, and removed in Elasticsearch v8</p>
</td></tr>
<tr><td><code id="docs_bulk_delete_+3A_chunk_size">chunk_size</code></td>
<td>
<p>(integer) Size of each chunk. If your data.frame is smaller
thank <code>chunk_size</code>, this parameter is essentially ignored. We write in
chunks because at some point, depending on size of each document, and
Elasticsearch setup, writing a very large number of documents in one go
becomes slow, so chunking can help. This parameter is ignored if you
pass a file name. Default: 1000</p>
</td></tr>
<tr><td><code id="docs_bulk_delete_+3A_doc_ids">doc_ids</code></td>
<td>
<p>An optional vector (character or numeric/integer) of document
ids to use. This vector has to equal the size of the documents you are
passing in, and will error if not. If you pass a factor we convert to
character. Default: not passed</p>
</td></tr>
<tr><td><code id="docs_bulk_delete_+3A_raw">raw</code></td>
<td>
<p>(logical) Get raw JSON back or not. If <code>TRUE</code>
you get JSON; if <code>FALSE</code> you get a list. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_delete_+3A_quiet">quiet</code></td>
<td>
<p>(logical) Suppress progress bar. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_delete_+3A_query">query</code></td>
<td>
<p>(list) a named list of query parameters. optional.
options include: pipeline, refresh, routing, _source, _source_excludes,
_source_includes, timeout, wait_for_active_shards. See the docs bulk
ES page for details</p>
</td></tr>
<tr><td><code id="docs_bulk_delete_+3A_digits">digits</code></td>
<td>
<p>ignored, used in other docs bulk functions but not used here</p>
</td></tr>
<tr><td><code id="docs_bulk_delete_+3A_...">...</code></td>
<td>
<p>Pass on curl options to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For doing deletes with a file already prepared for the bulk API,
see <code><a href="#topic+docs_bulk">docs_bulk()</a></code>
</p>
<p>Only data.frame's are supported for now.
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html</a>
</p>


<h3>See Also</h3>

<p>Other bulk-functions: 
<code><a href="#topic+docs_bulk_create">docs_bulk_create</a>()</code>,
<code><a href="#topic+docs_bulk_index">docs_bulk_index</a>()</code>,
<code><a href="#topic+docs_bulk_prep">docs_bulk_prep</a>()</code>,
<code><a href="#topic+docs_bulk_update">docs_bulk_update</a>()</code>,
<code><a href="#topic+docs_bulk">docs_bulk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()
if (index_exists(x, "foobar")) index_delete(x, "foobar")

df &lt;- data.frame(name = letters[1:3], size = 1:3, id = 100:102)
invisible(docs_bulk(x, df, 'foobar', es_ids = FALSE))
Search(x, "foobar", asdf = TRUE)$hits$hits

# delete using doc ids from the data.frame you used to create
invisible(docs_bulk_delete(x, df, index = 'foobar'))
Search(x, "foobar", asdf = TRUE)$hits$total$value

# delete by passing in doc ids
## recreate data first
if (index_exists(x, "foobar")) index_delete(x, "foobar")
df &lt;- data.frame(name = letters[1:3], size = 1:3, id = 100:102)
invisible(docs_bulk(x, df, 'foobar', es_ids = FALSE))
docs_bulk_delete(x, df, index = 'foobar', doc_ids = df$id)
Search(x, "foobar", asdf = TRUE)$hits$total$value

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_bulk_index'>Use the bulk API to index documents</h2><span id='topic+docs_bulk_index'></span>

<h3>Description</h3>

<p>Use the bulk API to index documents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_bulk_index(
  conn,
  x,
  index = NULL,
  type = NULL,
  chunk_size = 1000,
  doc_ids = NULL,
  es_ids = TRUE,
  raw = FALSE,
  quiet = FALSE,
  query = list(),
  digits = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_bulk_index_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="docs_bulk_index_+3A_x">x</code></td>
<td>
<p>A list, data.frame, or character path to a file. required.</p>
</td></tr>
<tr><td><code id="docs_bulk_index_+3A_index">index</code></td>
<td>
<p>(character) The index name to use. Required for data.frame
input, but optional for file inputs.</p>
</td></tr>
<tr><td><code id="docs_bulk_index_+3A_type">type</code></td>
<td>
<p>(character) The type. default: <code>NULL</code>. Note that <code>type</code> is
deprecated in Elasticsearch v7 and greater, and removed in Elasticsearch v8</p>
</td></tr>
<tr><td><code id="docs_bulk_index_+3A_chunk_size">chunk_size</code></td>
<td>
<p>(integer) Size of each chunk. If your data.frame is smaller
thank <code>chunk_size</code>, this parameter is essentially ignored. We write in
chunks because at some point, depending on size of each document, and
Elasticsearch setup, writing a very large number of documents in one go
becomes slow, so chunking can help. This parameter is ignored if you
pass a file name. Default: 1000</p>
</td></tr>
<tr><td><code id="docs_bulk_index_+3A_doc_ids">doc_ids</code></td>
<td>
<p>An optional vector (character or numeric/integer) of document
ids to use. This vector has to equal the size of the documents you are
passing in, and will error if not. If you pass a factor we convert to
character. Default: not passed</p>
</td></tr>
<tr><td><code id="docs_bulk_index_+3A_es_ids">es_ids</code></td>
<td>
<p>(boolean) Let Elasticsearch assign document IDs as UUIDs.
These are sequential, so there is order to the IDs they assign.
If <code>TRUE</code>, <code>doc_ids</code> is ignored. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_index_+3A_raw">raw</code></td>
<td>
<p>(logical) Get raw JSON back or not. If <code>TRUE</code>
you get JSON; if <code>FALSE</code> you get a list. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_index_+3A_quiet">quiet</code></td>
<td>
<p>(logical) Suppress progress bar. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_index_+3A_query">query</code></td>
<td>
<p>(list) a named list of query parameters. optional.
options include: pipeline, refresh, routing, _source, _source_excludes,
_source_includes, timeout, wait_for_active_shards. See the docs bulk
ES page for details</p>
</td></tr>
<tr><td><code id="docs_bulk_index_+3A_digits">digits</code></td>
<td>
<p>digits used by the parameter of the same name by
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code> to convert data to JSON before being submitted to
your ES instance. default: <code>NA</code></p>
</td></tr>
<tr><td><code id="docs_bulk_index_+3A_...">...</code></td>
<td>
<p>Pass on curl options to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For doing index with a file already prepared for the bulk API,
see <code><a href="#topic+docs_bulk">docs_bulk()</a></code>
</p>
<p>Only data.frame's are supported for now.
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html</a>
</p>


<h3>See Also</h3>

<p>Other bulk-functions: 
<code><a href="#topic+docs_bulk_create">docs_bulk_create</a>()</code>,
<code><a href="#topic+docs_bulk_delete">docs_bulk_delete</a>()</code>,
<code><a href="#topic+docs_bulk_prep">docs_bulk_prep</a>()</code>,
<code><a href="#topic+docs_bulk_update">docs_bulk_update</a>()</code>,
<code><a href="#topic+docs_bulk">docs_bulk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()
if (index_exists(x, "foobar")) index_delete(x, "foobar")

df &lt;- data.frame(name = letters[1:3], size = 1:3, id = 100:102)
docs_bulk_index(x, df, 'foobar')
docs_bulk_index(x, df, 'foobar', es_ids = FALSE)
Search(x, "foobar", asdf = TRUE)$hits$hits

# more examples
docs_bulk_index(x, mtcars, index = "hello")
## field names cannot contain dots
names(iris) &lt;- gsub("\\.", "_", names(iris))
docs_bulk_index(x, iris, "iris")
## type can be missing, but index can not
docs_bulk_index(x, iris, "flowers")
## big data.frame, 53K rows, load ggplot2 package first
# res &lt;- docs_bulk_index(x, diamonds, "diam")
# Search(x, "diam")$hits$total$value

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_bulk_prep'>Use the bulk API to prepare bulk format data</h2><span id='topic+docs_bulk_prep'></span>

<h3>Description</h3>

<p>Use the bulk API to prepare bulk format data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_bulk_prep(
  x,
  index,
  path,
  type = NULL,
  chunk_size = 1000,
  doc_ids = NULL,
  quiet = FALSE,
  digits = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_bulk_prep_+3A_x">x</code></td>
<td>
<p>A data.frame or a list. required.</p>
</td></tr>
<tr><td><code id="docs_bulk_prep_+3A_index">index</code></td>
<td>
<p>(character) The index name. required.</p>
</td></tr>
<tr><td><code id="docs_bulk_prep_+3A_path">path</code></td>
<td>
<p>(character) Path to the file. If data is broken into chunks,
we'll use this path as the prefix, and suffix each file path with a number.
required.</p>
</td></tr>
<tr><td><code id="docs_bulk_prep_+3A_type">type</code></td>
<td>
<p>(character) The type. default: <code>NULL</code>. Note that <code>type</code> is
deprecated in Elasticsearch v7 and greater, and removed in Elasticsearch v8</p>
</td></tr>
<tr><td><code id="docs_bulk_prep_+3A_chunk_size">chunk_size</code></td>
<td>
<p>(integer) Size of each chunk. If your data.frame is smaller
thank <code>chunk_size</code>, this parameter is essentially ignored. We write in
chunks because at some point, depending on size of each document, and
Elasticsearch setup, writing a very large number of documents in one go
becomes slow, so chunking can help. This parameter is ignored if you
pass a file name. Default: 1000</p>
</td></tr>
<tr><td><code id="docs_bulk_prep_+3A_doc_ids">doc_ids</code></td>
<td>
<p>An optional vector (character or numeric/integer) of document
ids to use. This vector has to equal the size of the documents you are
passing in, and will error if not. If you pass a factor we convert to
character. Default: not passed</p>
</td></tr>
<tr><td><code id="docs_bulk_prep_+3A_quiet">quiet</code></td>
<td>
<p>(logical) Suppress progress bar. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_prep_+3A_digits">digits</code></td>
<td>
<p>digits used by the parameter of the same name by
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code> to convert data to JSON before being submitted to
your ES instance. default: <code>NA</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>File path(s). By default we use temporary files; these are cleaned
up at the end of a session
</p>


<h3>Tempfiles</h3>

<p>In <code>docs_bulk</code> we create temporary files in some cases, and delete
those before the function exits. However, we don't clean up those files
in this function because the point of the function is to create the
newline delimited JSON files that you need. Tempfiles are cleaned up
when you R session ends though - be aware of that. If you want to
keep the files make sure to move them outside of the temp directory.
</p>


<h3>See Also</h3>

<p>Other bulk-functions: 
<code><a href="#topic+docs_bulk_create">docs_bulk_create</a>()</code>,
<code><a href="#topic+docs_bulk_delete">docs_bulk_delete</a>()</code>,
<code><a href="#topic+docs_bulk_index">docs_bulk_index</a>()</code>,
<code><a href="#topic+docs_bulk_update">docs_bulk_update</a>()</code>,
<code><a href="#topic+docs_bulk">docs_bulk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# From a data.frame
ff &lt;- tempfile(fileext = ".json")
docs_bulk_prep(mtcars, index = "hello", path = ff)
readLines(ff)

## field names cannot contain dots
names(iris) &lt;- gsub("\\.", "_", names(iris))
docs_bulk_prep(iris, "iris", path = tempfile(fileext = ".json"))

## type can be missing, but index can not
docs_bulk_prep(iris, "flowers", path = tempfile(fileext = ".json"))

# From a list
docs_bulk_prep(apply(iris, 1, as.list), index="iris",
   path = tempfile(fileext = ".json"))
docs_bulk_prep(apply(USArrests, 1, as.list), index="arrests",
   path = tempfile(fileext = ".json"))

# when chunking
## multiple files created, one for each chunk
bigiris &lt;- do.call("rbind", replicate(30, iris, FALSE))
docs_bulk_prep(bigiris, index = "big", path = tempfile(fileext = ".json"))

# When using in a loop
## We internally get last _id counter to know where to start on next bulk
## insert but you need to sleep in between docs_bulk_prep calls, longer the
## bigger the data is
files &lt;- c(system.file("examples", "test1.csv", package = "elastic"),
           system.file("examples", "test2.csv", package = "elastic"),
           system.file("examples", "test3.csv", package = "elastic"))
paths &lt;- vector("list", length = length(files))
for (i in seq_along(files)) {
  d &lt;- read.csv(files[[i]])
  paths[i] &lt;- docs_bulk_prep(d, index = "stuff",
     path = tempfile(fileext = ".json"))
}
unlist(paths)

# You can include your own document id numbers
## Either pass in as an argument
files &lt;- c(system.file("examples", "test1.csv", package = "elastic"),
           system.file("examples", "test2.csv", package = "elastic"),
           system.file("examples", "test3.csv", package = "elastic"))
tt &lt;- vapply(files, function(z) NROW(read.csv(z)), numeric(1))
ids &lt;- list(1:tt[1],
           (tt[1] + 1):(tt[1] + tt[2]),
           (tt[1] + tt[2] + 1):sum(tt))
paths &lt;- vector("list", length = length(files))
for (i in seq_along(files)) {
  d &lt;- read.csv(files[[i]])
  paths[i] &lt;- docs_bulk_prep(d, index = "testes",
    doc_ids = ids[[i]], path = tempfile(fileext = ".json"))
}
unlist(paths)

## or include in the input data
### from data.frame's
files &lt;- c(system.file("examples", "test1_id.csv", package = "elastic"),
           system.file("examples", "test2_id.csv", package = "elastic"),
           system.file("examples", "test3_id.csv", package = "elastic"))
paths &lt;- vector("list", length = length(files))
for (i in seq_along(files)) {
  d &lt;- read.csv(files[[i]])
  paths[i] &lt;- docs_bulk_prep(d, index = "testes",
     path = tempfile(fileext = ".json"))
}
unlist(paths)

### from lists via file inputs
paths &lt;- vector("list", length = length(files))
for (i in seq_along(files)) {
  d &lt;- read.csv(files[[i]])
  d &lt;- apply(d, 1, as.list)
  paths[i] &lt;- docs_bulk_prep(d, index = "testes",
      path = tempfile(fileext = ".json"))
}
unlist(paths)


# A mix of actions
## make sure you use a column named 'es_action' or this won't work
## if you need to delete or update you need document IDs
if (index_exists(x, "baz")) index_delete(x, "baz")
df &lt;- data.frame(a = 1:5, b = 6:10, c = letters[1:5], stringsAsFactors = FALSE) 
f &lt;- tempfile(fileext = ".json")
invisible(docs_bulk_prep(df, "baz", f))
cat(readLines(f), sep = "\n")
docs_bulk(x, f)
Sys.sleep(2)
(res &lt;- Search(x, 'baz', asdf=TRUE)$hits$hits)

df[1, "a"] &lt;- 99
df[1, "c"] &lt;- "aa"
df[3, "c"] &lt;- 33
df[3, "c"] &lt;- "cc"
df$es_action &lt;- c('update', 'delete', 'update', 'delete', 'delete')
df$id &lt;- res$`_id`
df
f &lt;- tempfile(fileext = ".json")
invisible(docs_bulk_prep(df, "baz", path = f, doc_ids = df$id))
cat(readLines(f), sep = "\n")
docs_bulk(x, f)


# suppress progress bar
docs_bulk_prep(mtcars, index = "hello",
  path = tempfile(fileext = ".json"), quiet = TRUE)
## vs. 
docs_bulk_prep(mtcars, index = "hello",
  path = tempfile(fileext = ".json"), quiet = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_bulk_update'>Use the bulk API to update documents</h2><span id='topic+docs_bulk_update'></span>

<h3>Description</h3>

<p>Use the bulk API to update documents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_bulk_update(
  conn,
  x,
  index = NULL,
  type = NULL,
  chunk_size = 1000,
  doc_ids = NULL,
  raw = FALSE,
  quiet = FALSE,
  query = list(),
  digits = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_bulk_update_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="docs_bulk_update_+3A_x">x</code></td>
<td>
<p>A list, data.frame, or character path to a file. required.</p>
</td></tr>
<tr><td><code id="docs_bulk_update_+3A_index">index</code></td>
<td>
<p>(character) The index name to use. Required for data.frame
input, but optional for file inputs.</p>
</td></tr>
<tr><td><code id="docs_bulk_update_+3A_type">type</code></td>
<td>
<p>(character) The type. default: <code>NULL</code>. Note that <code>type</code> is
deprecated in Elasticsearch v7 and greater, and removed in Elasticsearch v8</p>
</td></tr>
<tr><td><code id="docs_bulk_update_+3A_chunk_size">chunk_size</code></td>
<td>
<p>(integer) Size of each chunk. If your data.frame is smaller
thank <code>chunk_size</code>, this parameter is essentially ignored. We write in
chunks because at some point, depending on size of each document, and
Elasticsearch setup, writing a very large number of documents in one go
becomes slow, so chunking can help. This parameter is ignored if you
pass a file name. Default: 1000</p>
</td></tr>
<tr><td><code id="docs_bulk_update_+3A_doc_ids">doc_ids</code></td>
<td>
<p>An optional vector (character or numeric/integer) of document
ids to use. This vector has to equal the size of the documents you are
passing in, and will error if not. If you pass a factor we convert to
character. Default: not passed</p>
</td></tr>
<tr><td><code id="docs_bulk_update_+3A_raw">raw</code></td>
<td>
<p>(logical) Get raw JSON back or not. If <code>TRUE</code>
you get JSON; if <code>FALSE</code> you get a list. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_update_+3A_quiet">quiet</code></td>
<td>
<p>(logical) Suppress progress bar. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="docs_bulk_update_+3A_query">query</code></td>
<td>
<p>(list) a named list of query parameters. optional.
options include: pipeline, refresh, routing, _source, _source_excludes,
_source_includes, timeout, wait_for_active_shards. See the docs bulk
ES page for details</p>
</td></tr>
<tr><td><code id="docs_bulk_update_+3A_digits">digits</code></td>
<td>
<p>digits used by the parameter of the same name by
<code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code> to convert data to JSON before being submitted to
your ES instance. default: <code>NA</code></p>
</td></tr>
<tr><td><code id="docs_bulk_update_+3A_...">...</code></td>
<td>
<p>Pass on curl options to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>doc_as_upsert</code> - is set to <code>TRUE</code> for all records
</p>
</li></ul>

<p>For doing updates with a file already prepared for the bulk API,
see <code><a href="#topic+docs_bulk">docs_bulk()</a></code>
</p>
<p>Only data.frame's are supported for now.
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html#bulk-update">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html#bulk-update</a>
</p>


<h3>See Also</h3>

<p>Other bulk-functions: 
<code><a href="#topic+docs_bulk_create">docs_bulk_create</a>()</code>,
<code><a href="#topic+docs_bulk_delete">docs_bulk_delete</a>()</code>,
<code><a href="#topic+docs_bulk_index">docs_bulk_index</a>()</code>,
<code><a href="#topic+docs_bulk_prep">docs_bulk_prep</a>()</code>,
<code><a href="#topic+docs_bulk">docs_bulk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()
if (index_exists(x, "foobar")) index_delete(x, "foobar")

df &lt;- data.frame(name = letters[1:3], size = 1:3, id = 100:102)
invisible(docs_bulk(x, df, 'foobar', es_ids = FALSE))

# add new rows in existing fields
(df2 &lt;- data.frame(size = c(45, 56), id = 100:101))
(df2 &lt;- data.frame(size = c(45, 56)))
df2$`_id` &lt;- 100:101
df2
Search(x, "foobar", asdf = TRUE)$hits$hits
invisible(docs_bulk_update(x, df2, index = 'foobar'))
Search(x, "foobar", asdf = TRUE)$hits$hits

# add new fields (and new rows by extension)
(df3 &lt;- data.frame(color = c("blue", "red", "green"), id = 100:102))
Search(x, "foobar", asdf = TRUE)$hits$hits
invisible(docs_bulk_update(x, df3, index = 'foobar'))
Sys.sleep(2) # wait for a few sec to make sure you see changes reflected
Search(x, "foobar", asdf = TRUE)$hits$hits

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_create'>Create a document</h2><span id='topic+docs_create'></span>

<h3>Description</h3>

<p>Create a document
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_create(
  conn,
  index,
  body,
  type = NULL,
  id = NULL,
  version = NULL,
  version_type = NULL,
  op_type = NULL,
  routing = NULL,
  parent = NULL,
  timestamp = NULL,
  ttl = NULL,
  refresh = NULL,
  timeout = NULL,
  callopts = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_create_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="docs_create_+3A_index">index</code></td>
<td>
<p>(character) The name of the index. Required</p>
</td></tr>
<tr><td><code id="docs_create_+3A_body">body</code></td>
<td>
<p>The document</p>
</td></tr>
<tr><td><code id="docs_create_+3A_type">type</code></td>
<td>
<p>(character) The type of the document. optional</p>
</td></tr>
<tr><td><code id="docs_create_+3A_id">id</code></td>
<td>
<p>(numeric/character) The document ID. Can be numeric or character.
Optional. if not provided, Elasticsearch creates the ID for you as a UUID.</p>
</td></tr>
<tr><td><code id="docs_create_+3A_version">version</code></td>
<td>
<p>(character) Explicit version number for concurrency control</p>
</td></tr>
<tr><td><code id="docs_create_+3A_version_type">version_type</code></td>
<td>
<p>(character) Specific version type. One of internal,
external, external_gte, or force</p>
</td></tr>
<tr><td><code id="docs_create_+3A_op_type">op_type</code></td>
<td>
<p>(character) Operation type. One of create, or ...</p>
</td></tr>
<tr><td><code id="docs_create_+3A_routing">routing</code></td>
<td>
<p>(character) Specific routing value</p>
</td></tr>
<tr><td><code id="docs_create_+3A_parent">parent</code></td>
<td>
<p>(numeric) A parent document ID</p>
</td></tr>
<tr><td><code id="docs_create_+3A_timestamp">timestamp</code></td>
<td>
<p>(date) Explicit timestamp for the document</p>
</td></tr>
<tr><td><code id="docs_create_+3A_ttl">ttl</code></td>
<td>
<p>(aka &ldquo;time to live&rdquo;) Expiration time for the document.
Expired documents will be expunged automatically. The expiration date that
will be set for a document with a provided ttl is relative to the timestamp
of the document,  meaning it can be based on the time of indexing or on
any time provided. The provided ttl must be strictly positive and can be
a number (in milliseconds) or any valid time value (e.g, 86400000, 1d).</p>
</td></tr>
<tr><td><code id="docs_create_+3A_refresh">refresh</code></td>
<td>
<p>(logical) Refresh the index after performing the operation</p>
</td></tr>
<tr><td><code id="docs_create_+3A_timeout">timeout</code></td>
<td>
<p>(character) Explicit operation timeout, e.g,. 5m (for
5 minutes)</p>
</td></tr>
<tr><td><code id="docs_create_+3A_callopts">callopts</code></td>
<td>
<p>Curl options passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
<tr><td><code id="docs_create_+3A_...">...</code></td>
<td>
<p>Further args to query DSL</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- connect())

if (!index_exists(x, 'plos')) {
  plosdat &lt;- system.file("examples", "plos_data.json",
    package = "elastic")
  plosdat &lt;- type_remover(plosdat)
  invisible(docs_bulk(x, plosdat))
}

# give a document id
z &lt;- docs_create(x, index = 'plos', id = 1002,
  body = list(id = "12345", title = "New title"))
z
# and the document is there now
docs_get(x, index = 'plos', id = 1002)

# let Elasticsearch create the document id for you
z &lt;- docs_create(x, index='plos', body=list(id="6789", title="Some title"))
z
# and the document is there now
docs_get(x, index='plos', id=z$`_id`)

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_delete'>Delete a document</h2><span id='topic+docs_delete'></span>

<h3>Description</h3>

<p>Delete a document
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_delete(
  conn,
  index,
  id,
  type = NULL,
  refresh = NULL,
  routing = NULL,
  timeout = NULL,
  version = NULL,
  version_type = NULL,
  callopts = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_delete_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="docs_delete_+3A_index">index</code></td>
<td>
<p>(character) The name of the index. Required</p>
</td></tr>
<tr><td><code id="docs_delete_+3A_id">id</code></td>
<td>
<p>(numeric/character) The document ID. Can be numeric or character.
Required</p>
</td></tr>
<tr><td><code id="docs_delete_+3A_type">type</code></td>
<td>
<p>(character) The type of the document. optional</p>
</td></tr>
<tr><td><code id="docs_delete_+3A_refresh">refresh</code></td>
<td>
<p>(logical) Refresh the index after performing the operation</p>
</td></tr>
<tr><td><code id="docs_delete_+3A_routing">routing</code></td>
<td>
<p>(character) Specific routing value</p>
</td></tr>
<tr><td><code id="docs_delete_+3A_timeout">timeout</code></td>
<td>
<p>(character) Explicit operation timeout, e.g,. 5m (for 5
minutes)</p>
</td></tr>
<tr><td><code id="docs_delete_+3A_version">version</code></td>
<td>
<p>(character) Explicit version number for concurrency control</p>
</td></tr>
<tr><td><code id="docs_delete_+3A_version_type">version_type</code></td>
<td>
<p>(character) Specific version type. One of internal
or external</p>
</td></tr>
<tr><td><code id="docs_delete_+3A_callopts">callopts</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
<tr><td><code id="docs_delete_+3A_...">...</code></td>
<td>
<p>Further args to query DSL</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- connect())
x$ping()

if (!index_exists(x, "plos")) {
 plosdat &lt;- system.file("examples", "plos_data.json",
    package = "elastic")
 plosdat &lt;- type_remover(plosdat)
 docs_bulk(x, plosdat)
}

# delete a document
if (!docs_get(x, index='plos', id=36, exists=TRUE)) {
  docs_create(x, index='plos', id=36, 
    body = list(id="12345", title="New title")
  )
}
docs_get(x, index='plos', id=36)
docs_delete(x, index='plos', id=36)
# docs_get(x, index='plos', id=36) # and the document is gone

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_delete_by_query'>Delete documents by query</h2><span id='topic+docs_delete_by_query'></span>

<h3>Description</h3>

<p>delete documents by query via a POST request
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_delete_by_query(
  conn,
  index,
  body,
  type = NULL,
  conflicts = NULL,
  routing = NULL,
  scroll_size = NULL,
  refresh = NULL,
  wait_for_completion = NULL,
  wait_for_active_shards = NULL,
  timeout = NULL,
  scroll = NULL,
  requests_per_second = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_delete_by_query_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_index">index</code></td>
<td>
<p>(character) The name of the index. Required</p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_body">body</code></td>
<td>
<p>(character/json) query to be passed on to POST request body</p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_type">type</code></td>
<td>
<p>(character) The type of the document. optional</p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_conflicts">conflicts</code></td>
<td>
<p>(character) If youd like to count version conflicts
rather than cause them to abort then set <code>conflicts=proceed</code></p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_routing">routing</code></td>
<td>
<p>(character) Specific routing value</p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_scroll_size">scroll_size</code></td>
<td>
<p>(integer) By default uses scroll batches of 1000.
Change batch size with this parameter.</p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_refresh">refresh</code></td>
<td>
<p>(logical) Refresh the index after performing the operation</p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_wait_for_completion">wait_for_completion</code></td>
<td>
<p>(logical) If <code>wait_for_completion=FALSE</code> then
Elasticsearch will perform some preflight checks, launch the request, and
then return a task which can be used with Tasks APIs to cancel or get the
status of the task. Elasticsearch will also create a record of this task
as a document at .tasks/task/$taskId. This is yours to keep or remove
as you see fit. When you are done with it, delete it so Elasticsearch
can reclaim the space it uses. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_wait_for_active_shards">wait_for_active_shards</code></td>
<td>
<p>(logical) controls how many copies of a
shard must be active before proceeding with the request.</p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_timeout">timeout</code></td>
<td>
<p>(character) Explicit operation timeout, e.g,. 5m (for 5
minutes)</p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_scroll">scroll</code></td>
<td>
<p>(integer) control how long the &quot;search context&quot; is kept
alive, eg <code>scroll='10m'</code>, by default its 5 minutes (<code style="white-space: pre;">&#8288;5m&#8288;</code>)</p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_requests_per_second">requests_per_second</code></td>
<td>
<p>(integer) any positive decimal number
(1.4, 6, 1000, etc); throttles rate at which <code style="white-space: pre;">&#8288;_delete_by_query&#8288;</code> issues
batches of delete operations by padding each batch with a wait time.
The throttling can be disabled by setting <code>requests_per_second=-1</code></p>
</td></tr>
<tr><td><code id="docs_delete_by_query_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-POST">crul::verb-POST</a></p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+docs_update_by_query">docs_update_by_query()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- connect())
x$ping()

plosdat &lt;- system.file("examples", "plos_data.json",
  package = "elastic")
plosdat &lt;- type_remover(plosdat)
if (!index_exists(x, "plos")) invisible(docs_bulk(x, plosdat))

# delete with fuzzy matching
body &lt;- '{
  "query": { 
    "match": {
      "title": {
        "query": "cells",
        "fuzziness": 1
      }
    }
  }
}'
docs_delete_by_query(x, index='plos', body = body) 

# delete with no fuzziness
if (index_exists(x, "plos")) index_delete(x, 'plos')
invisible(docs_bulk(x, plosdat))
count(x, "plos")
body &lt;- '{
  "query": { 
    "match": {
      "title": {
        "query": "cells",
        "fuzziness": 0
      }
    }
  }
}'
docs_delete_by_query(x, index='plos', body = body)

# delete all docs with match_all query
if (index_exists(x, "plos")) index_delete(x, 'plos')
invisible(docs_bulk(x, plosdat))
body &lt;- '{
  "query": { 
    "match_all": {}
  }
}'
docs_delete_by_query(x, index='plos', body = body)

# put plos back in 
if (index_exists(x, "plos")) index_delete(x, 'plos')
invisible(docs_bulk(x, plosdat))

# delete docs from more than one index
foo &lt;- system.file("examples/foo.json", package = "elastic")
if (!index_exists(x, "foo")) invisible(docs_bulk(x, foo))
bar &lt;- system.file("examples/bar.json", package = "elastic")
if (!index_exists(x, "bar")) invisible(docs_bulk(x, bar))

body &lt;- '{
  "query": { 
    "match_all": {}
  }
}'
docs_delete_by_query(x, index=c('foo','bar'), 
  body = body, verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_get'>Get documents</h2><span id='topic+docs_get'></span>

<h3>Description</h3>

<p>Get documents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_get(
  conn,
  index,
  id,
  type = NULL,
  source = NULL,
  fields = NULL,
  source_includes = NULL,
  source_excludes = NULL,
  exists = FALSE,
  raw = FALSE,
  callopts = list(),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_get_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="docs_get_+3A_index">index</code></td>
<td>
<p>(character) The name of the index. Required</p>
</td></tr>
<tr><td><code id="docs_get_+3A_id">id</code></td>
<td>
<p>(numeric/character) The document ID. Can be numeric or character.
Required</p>
</td></tr>
<tr><td><code id="docs_get_+3A_type">type</code></td>
<td>
<p>(character) The type of the document. optional</p>
</td></tr>
<tr><td><code id="docs_get_+3A_source">source</code></td>
<td>
<p>(logical) If <code>TRUE</code> (default), return source. note that
it is actually set to <code>NULL</code> in the function definition, but within
Elasticsearch, it returns the source by default. alternatively,
you can pass a vector of field names to return.</p>
</td></tr>
<tr><td><code id="docs_get_+3A_fields">fields</code></td>
<td>
<p>Fields to return from the response object.</p>
</td></tr>
<tr><td><code id="docs_get_+3A_source_includes">source_includes</code>, <code id="docs_get_+3A_source_excludes">source_excludes</code></td>
<td>
<p>(character) fields to include in the
returned document, or to exclude. a character vector</p>
</td></tr>
<tr><td><code id="docs_get_+3A_exists">exists</code></td>
<td>
<p>(logical) Only return a logical as to whether the document
exists or not.</p>
</td></tr>
<tr><td><code id="docs_get_+3A_raw">raw</code></td>
<td>
<p>If <code>TRUE</code> (default), data is parsed to list. If <code>FALSE</code>, then raw
JSON.</p>
</td></tr>
<tr><td><code id="docs_get_+3A_callopts">callopts</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
<tr><td><code id="docs_get_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE (default) the url call used printed to console.</p>
</td></tr>
<tr><td><code id="docs_get_+3A_...">...</code></td>
<td>
<p>Further args passed on to elastic search HTTP API as parameters.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- connect())

if (!index_exists(x, "shakespeare")) {
  shakespeare &lt;- system.file("examples", "shakespeare_data_.json",
    package = "elastic")
  shakespeare &lt;- type_remover(shakespeare)
  invisible(docs_bulk(x, shakespeare))
}

docs_get(x, index='shakespeare', id=10)
docs_get(x, index='shakespeare', id=12)
docs_get(x, index='shakespeare', id=12, source=TRUE)

# Get certain fields
if (gsub("\\.", "", x$ping()$version$number) &lt; 500) {
  ### ES &lt; v5
  docs_get(x, index='shakespeare', id=10, fields='play_name')
  docs_get(x, index='shakespeare', id=10, fields=c('play_name','speaker'))
} else {
  ### ES &gt; v5
  docs_get(x, index='shakespeare', id=10, source='play_name')
  docs_get(x, index='shakespeare', id=10, source=c('play_name','speaker'))
}

# Just test for existence of the document
docs_get(x, index='plos', id=1, exists=TRUE)
docs_get(x, index='plos', id=123456, exists=TRUE)

# source includes / excludes
docs_get(x, index='shakespeare', id=10, source_includes = "play_name")
docs_get(x, index='shakespeare', id=10, source_excludes = "play_name")

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_mget'>Get multiple documents via the multiple get API</h2><span id='topic+docs_mget'></span>

<h3>Description</h3>

<p>Get multiple documents via the multiple get API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_mget(
  conn,
  index = NULL,
  type = NULL,
  ids = NULL,
  type_id = NULL,
  index_type_id = NULL,
  source = NULL,
  fields = NULL,
  raw = FALSE,
  callopts = list(),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_mget_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="docs_mget_+3A_index">index</code></td>
<td>
<p>Index. Required.</p>
</td></tr>
<tr><td><code id="docs_mget_+3A_type">type</code></td>
<td>
<p>Document type. Required.</p>
</td></tr>
<tr><td><code id="docs_mget_+3A_ids">ids</code></td>
<td>
<p>More than one document id, see examples.</p>
</td></tr>
<tr><td><code id="docs_mget_+3A_type_id">type_id</code></td>
<td>
<p>List of vectors of length 2, each with an element for
type and id.</p>
</td></tr>
<tr><td><code id="docs_mget_+3A_index_type_id">index_type_id</code></td>
<td>
<p>List of vectors of length 3, each with an element for
index, type, and id.</p>
</td></tr>
<tr><td><code id="docs_mget_+3A_source">source</code></td>
<td>
<p>(logical) If <code>TRUE</code>, return source.</p>
</td></tr>
<tr><td><code id="docs_mget_+3A_fields">fields</code></td>
<td>
<p>Fields to return from the response object.</p>
</td></tr>
<tr><td><code id="docs_mget_+3A_raw">raw</code></td>
<td>
<p>If TRUE (default), data is parsed to list. If FALSE, then raw JSON.</p>
</td></tr>
<tr><td><code id="docs_mget_+3A_callopts">callopts</code></td>
<td>
<p>Curl args passed on to <code><a href="crul.html#topic+HttpClient">HttpClient</a></code></p>
</td></tr>
<tr><td><code id="docs_mget_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE (default) the url call used printed to console.</p>
</td></tr>
<tr><td><code id="docs_mget_+3A_...">...</code></td>
<td>
<p>Further args passed on to elastic search HTTP API as parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can pass in one of three combinations of parameters:
</p>

<ul>
<li><p> Pass in something for <code>index</code>, <code>type</code>, and <code>id</code>.
This is the simplest, allowing retrieval from the same index, same type,
and many ids.
</p>
</li>
<li><p> Pass in only <code>index</code> and <code>type_id</code> - this allows you to
get multiple documents from the same index, but from different types.
</p>
</li>
<li><p> Pass in only <code>index_type_id</code> - this is so that you can get
multiple documents from different indexes and different types.
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- connect())

if (!index_exists(x, 'plos')) {
  plosdat &lt;- system.file("examples", "plos_data.json",
    package = "elastic")
  plosdat &lt;- type_remover(plosdat)
  invisible(docs_bulk(x, plosdat))
}

# same index, many ids
docs_mget(x, index="plos", ids=c(9,10))

# Same index and type
docs_mget(x, index="plos", type="_doc", ids=c(9,10))

tmp &lt;- docs_mget(x, index="plos", ids=c(9, 10), raw=TRUE)
es_parse(tmp)
docs_mget(x, index="plos", ids=c(9, 10), source='title')
docs_mget(x, index="plos", ids=c(14, 19), source=TRUE)

# curl options
docs_mget(x, index="plos", ids=1:2, callopts=list(verbose=TRUE))

# Same index, but different types
if (index_exists(x, 'shakespeare')) index_delete(x, 'shakespeare')
shakedat &lt;- system.file("examples", "shakespeare_data.json",
  package = "elastic")
invisible(docs_bulk(x, shakedat))

docs_mget(x, index="shakespeare", type_id=list(c("scene",1), c("line",20)))
docs_mget(x, index="shakespeare", type_id=list(c("scene",1), c("line",20)),
  source='play_name')

# Different indices and different types pass in separately
docs_mget(x, index_type_id = list(
  c("shakespeare", "line", 20),
  c("plos", "article", 1)
 )
)

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_update'>Update a document</h2><span id='topic+docs_update'></span>

<h3>Description</h3>

<p>Update a document
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_update(
  conn,
  index,
  id,
  body,
  type = NULL,
  fields = NULL,
  source = NULL,
  version = NULL,
  version_type = NULL,
  routing = NULL,
  parent = NULL,
  timestamp = NULL,
  ttl = NULL,
  refresh = NULL,
  timeout = NULL,
  retry_on_conflict = NULL,
  wait_for_active_shards = NULL,
  detect_noop = NULL,
  callopts = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_update_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="docs_update_+3A_index">index</code></td>
<td>
<p>(character) The name of the index. Required</p>
</td></tr>
<tr><td><code id="docs_update_+3A_id">id</code></td>
<td>
<p>(numeric/character) The document ID. Can be numeric or character.
Required</p>
</td></tr>
<tr><td><code id="docs_update_+3A_body">body</code></td>
<td>
<p>The document, either a list or json</p>
</td></tr>
<tr><td><code id="docs_update_+3A_type">type</code></td>
<td>
<p>(character) The type of the document. optional</p>
</td></tr>
<tr><td><code id="docs_update_+3A_fields">fields</code></td>
<td>
<p>A comma-separated list of fields to return in the response</p>
</td></tr>
<tr><td><code id="docs_update_+3A_source">source</code></td>
<td>
<p>Allows to control if and how the updated source should be
returned in the response. By default the updated source is not returned.</p>
</td></tr>
<tr><td><code id="docs_update_+3A_version">version</code></td>
<td>
<p>(character) Explicit version number for concurrency control</p>
</td></tr>
<tr><td><code id="docs_update_+3A_version_type">version_type</code></td>
<td>
<p>(character) Specific version type. One of internal,
external, external_gte, or force</p>
</td></tr>
<tr><td><code id="docs_update_+3A_routing">routing</code></td>
<td>
<p>(character) Specific routing value</p>
</td></tr>
<tr><td><code id="docs_update_+3A_parent">parent</code></td>
<td>
<p>ID of the parent document. Is is only used for routing and
when for the upsert request</p>
</td></tr>
<tr><td><code id="docs_update_+3A_timestamp">timestamp</code></td>
<td>
<p>(date) Explicit timestamp for the document</p>
</td></tr>
<tr><td><code id="docs_update_+3A_ttl">ttl</code></td>
<td>
<p>(aka &ldquo;time to live&rdquo;) Expiration time for the document.
Expired documents will be expunged automatically. The expiration date that
will be set for a document with a provided ttl is relative to the timestamp
of the document,  meaning it can be based on the time of indexing or on
any time provided. The provided ttl must be strictly positive and can be
a number (in milliseconds) or any valid time value (e.g, 86400000, 1d).</p>
</td></tr>
<tr><td><code id="docs_update_+3A_refresh">refresh</code></td>
<td>
<p>Refresh the index after performing the operation.</p>
</td></tr>
<tr><td><code id="docs_update_+3A_timeout">timeout</code></td>
<td>
<p>(character) Explicit operation timeout, e.g,. 5m (for
5 minutes)</p>
</td></tr>
<tr><td><code id="docs_update_+3A_retry_on_conflict">retry_on_conflict</code></td>
<td>
<p>Specify how many times should the operation be
retried when a conflict occurs (default: 0)</p>
</td></tr>
<tr><td><code id="docs_update_+3A_wait_for_active_shards">wait_for_active_shards</code></td>
<td>
<p>The number of shard copies required to be
active before proceeding with the update operation.</p>
</td></tr>
<tr><td><code id="docs_update_+3A_detect_noop">detect_noop</code></td>
<td>
<p>(logical) Specifying <code>TRUE</code> will cause Elasticsearch
to check if there are changes and, if there aren't, turn the update request
into a noop.</p>
</td></tr>
<tr><td><code id="docs_update_+3A_callopts">callopts</code></td>
<td>
<p>Curl options passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
<tr><td><code id="docs_update_+3A_...">...</code></td>
<td>
<p>Further args to query DSL</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- connect())
if (!index_exists(x, 'plos')) {
  plosdat &lt;- system.file("examples", "plos_data.json",
    package = "elastic")
  plosdat &lt;- type_remover(plosdat)
  invisible(docs_bulk(x, plosdat))
}

docs_create(x, index='plos', id=1002,
  body=list(id="12345", title="New title"))
# and the document is there now
docs_get(x, index='plos', id=1002)
# update the document
docs_update(x, index='plos', id=1002,
  body = list(doc = list(title = "Even newer title again")))
# get it again, notice changes
docs_get(x, index='plos', id=1002)

if (!index_exists(x, 'stuffthings')) {
  index_create(x, "stuffthings")
}
docs_create(x, index='stuffthings', id=1,
  body=list(name = "foo", what = "bar"))
docs_update(x, index='stuffthings', id=1,
  body = list(doc = list(name = "hello", what = "bar")),
  source = 'name')

## End(Not run)
</code></pre>

<hr>
<h2 id='docs_update_by_query'>Update documents by query</h2><span id='topic+docs_update_by_query'></span>

<h3>Description</h3>

<p>update documents by query via a POST request
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docs_update_by_query(
  conn,
  index,
  body = NULL,
  type = NULL,
  conflicts = NULL,
  routing = NULL,
  scroll_size = NULL,
  refresh = NULL,
  wait_for_completion = NULL,
  wait_for_active_shards = NULL,
  timeout = NULL,
  scroll = NULL,
  requests_per_second = NULL,
  pipeline = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docs_update_by_query_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_index">index</code></td>
<td>
<p>(character) The name of the index. Required</p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_body">body</code></td>
<td>
<p>(character/json) query to be passed on to POST request body</p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_type">type</code></td>
<td>
<p>(character) The type of the document. optional</p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_conflicts">conflicts</code></td>
<td>
<p>(character) If youd like to count version conflicts
rather than cause them to abort then set <code>conflicts=proceed</code></p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_routing">routing</code></td>
<td>
<p>(character) Specific routing value</p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_scroll_size">scroll_size</code></td>
<td>
<p>(integer) By default uses scroll batches of 1000.
Change batch size with this parameter.</p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_refresh">refresh</code></td>
<td>
<p>(logical) Refresh the index after performing the operation</p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_wait_for_completion">wait_for_completion</code></td>
<td>
<p>(logical) If <code>wait_for_completion=FALSE</code> then
Elasticsearch will perform some preflight checks, launch the request, and
then return a task which can be used with Tasks APIs to cancel or get the
status of the task. Elasticsearch will also create a record of this task
as a document at .tasks/task/$taskId. This is yours to keep or remove
as you see fit. When you are done with it, delete it so Elasticsearch
can reclaim the space it uses. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_wait_for_active_shards">wait_for_active_shards</code></td>
<td>
<p>(logical) controls how many copies of a
shard must be active before proceeding with the request.</p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_timeout">timeout</code></td>
<td>
<p>(character) Explicit operation timeout, e.g,. 5m (for 5
minutes)</p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_scroll">scroll</code></td>
<td>
<p>(integer) control how long the &quot;search context&quot; is kept
alive, eg <code>scroll='10m'</code>, by default its 5 minutes (<code style="white-space: pre;">&#8288;5m&#8288;</code>)</p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_requests_per_second">requests_per_second</code></td>
<td>
<p>(integer) any positive decimal number
(1.4, 6, 1000, etc); throttles rate at which <code style="white-space: pre;">&#8288;_delete_by_query&#8288;</code> issues
batches of delete operations by padding each batch with a wait time.
The throttling can be disabled by setting <code>requests_per_second=-1</code></p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_pipeline">pipeline</code></td>
<td>
<p>(character) a pipeline name</p>
</td></tr>
<tr><td><code id="docs_update_by_query_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-POST">crul::verb-POST</a></p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html</a>
<a href="https://www.elastic.co/guide/en/elasticsearch/painless/current/painless-api-reference.html">https://www.elastic.co/guide/en/elasticsearch/painless/current/painless-api-reference.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+docs_delete_by_query">docs_delete_by_query()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- connect())
x$ping()

omdb &lt;- system.file("examples", "omdb.json", package = "elastic")
omdb &lt;- type_remover(omdb)
if (!index_exists(x, "omdb")) invisible(docs_bulk(x, omdb))

# can be sent without a body
docs_update_by_query(x, index='omdb')

# update
## note this works with imdbRating, a float, but didn't seem to work
## with Metascore, a long
## See link above for Painless API reference
body &lt;- '{
  "script": {
    "source": "ctx._source.imdbRating++",
    "lang": "painless"
  },
  "query": {
    "match": {
      "Rated": "R"
    }
  }
}'
Search(x, "omdb", q = "Rated:\"R\"", asdf=TRUE,
  source = c("Title", "Rated", "imdbRating"))$hits$hits
docs_update_by_query(x, index='omdb', body = body)
Search(x, "omdb", q = "Rated:\"R\"", asdf=TRUE,
  source = c("Title", "Rated", "imdbRating"))$hits$hits

## End(Not run)
</code></pre>

<hr>
<h2 id='documents'>Elasticsearch documents functions.</h2><span id='topic+documents'></span>

<h3>Description</h3>

<p>Elasticsearch documents functions.
</p>


<h3>Details</h3>

<p>There are five functions to work directly with documents.
</p>

<ul>
<li> <p><code><a href="#topic+docs_get">docs_get()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+docs_mget">docs_mget()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+docs_create">docs_create()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+docs_delete">docs_delete()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+docs_bulk">docs_bulk()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Get a document
# docs_get(index='plos', type='article', id=1)

# Get multiple documents
# docs_mget(index="shakespeare", type="line", id=c(9,10))

# Create a document
# docs_create(index='plos', type='article', id=35, body=list(id="12345", title="New title"))

# Delete a document
# docs_delete(index='plos', type='article', id=35)

# Bulk load documents
# plosdat &lt;- system.file("examples", "plos_data.json", package = "elastic")
# docs_bulk(plosdat)

## End(Not run)
</code></pre>

<hr>
<h2 id='elastic-defunct'>Defunct functions in elastic</h2><span id='topic+elastic-defunct'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+mlt">mlt()</a></code>: The MLT API has been removed, use More Like This Query
via <code><a href="#topic+Search">Search()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+nodes_shutdown">nodes_shutdown()</a></code>: The _shutdown API has been removed. Instead,
setup Elasticsearch to run as a service (see Running as a Service on Linux
(<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/setup-service.html">https://www.elastic.co/guide/en/elasticsearch/reference/2.0/setup-service.html</a>) or
Running as a Service on Windows
(<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/setup-service-win.html">https://www.elastic.co/guide/en/elasticsearch/reference/2.0/setup-service-win.html</a>))
or use the -p command line option to write the PID to a file.
</p>
</li>
<li> <p><code><a href="#topic+index_status">index_status()</a></code>: _status route for the index API has been removed.
Replaced with the Indices Stats and Indices Recovery APIs.
</p>
</li>
<li> <p><code><a href="#topic+mapping_delete">mapping_delete()</a></code>: Elasticsearch dropped this route in their API. Instead
of deleting a mapping, delete the index and recreate with a new mapping.
</p>
</li></ul>


<hr>
<h2 id='es_parse'>Parse raw data from es_get, es_mget, or es_search.</h2><span id='topic+es_parse'></span><span id='topic+es_parse.es_GET'></span><span id='topic+es_parse.index_delete'></span><span id='topic+es_parse.bulk_make'></span><span id='topic+es_parse.elastic_mget'></span><span id='topic+es_parse.elastic_search'></span><span id='topic+es_parse.elastic_status'></span><span id='topic+es_parse.elastic_stats'></span><span id='topic+es_parse.elastic_cluster_health'></span><span id='topic+es_parse.elastic_cluster_state'></span><span id='topic+es_parse.elastic_cluster_settings'></span><span id='topic+es_parse.elastic_cluster_stats'></span><span id='topic+es_parse.elastic_cluster_pending_tasks'></span><span id='topic+es_parse.elastic_nodes_stats'></span><span id='topic+es_parse.elastic_nodes_info'></span>

<h3>Description</h3>

<p>Parse raw data from es_get, es_mget, or es_search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>es_parse(input, parsetype, verbose)

## S3 method for class 'es_GET'
es_parse(input, parsetype = "list", verbose = FALSE)

## S3 method for class 'index_delete'
es_parse(input, parsetype = "list", verbose = FALSE)

## S3 method for class 'bulk_make'
es_parse(input, parsetype = "list", verbose = FALSE)

## S3 method for class 'elastic_mget'
es_parse(input, parsetype = "list", verbose = FALSE)

## S3 method for class 'elastic_search'
es_parse(input, parsetype = "list", verbose = FALSE)

## S3 method for class 'elastic_status'
es_parse(input, parsetype = "list", verbose = FALSE)

## S3 method for class 'elastic_stats'
es_parse(input, parsetype = "list", verbose = FALSE)

## S3 method for class 'elastic_cluster_health'
es_parse(input, parsetype = "list", verbose = TRUE)

## S3 method for class 'elastic_cluster_health'
es_parse(input, parsetype = "list", verbose = TRUE)

## S3 method for class 'elastic_cluster_state'
es_parse(input, parsetype = "list", verbose = TRUE)

## S3 method for class 'elastic_cluster_settings'
es_parse(input, parsetype = "list", verbose = TRUE)

## S3 method for class 'elastic_cluster_stats'
es_parse(input, parsetype = "list", verbose = TRUE)

## S3 method for class 'elastic_cluster_pending_tasks'
es_parse(input, parsetype = "list", verbose = TRUE)

## S3 method for class 'elastic_nodes_stats'
es_parse(input, parsetype = "list", verbose = TRUE)

## S3 method for class 'elastic_nodes_info'
es_parse(input, parsetype = "list", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="es_parse_+3A_input">input</code></td>
<td>
<p>Output from solr_facet</p>
</td></tr>
<tr><td><code id="es_parse_+3A_parsetype">parsetype</code></td>
<td>
<p>One of 'list' or 'df' (data.frame). Only list possible for now.</p>
</td></tr>
<tr><td><code id="es_parse_+3A_verbose">verbose</code></td>
<td>
<p>Print messages or not (default: FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the parser used internally in es_get, es_mget, and es_search,
but if you output raw data from es_* functions using raw=TRUE, then you can use this
function to parse that data (a es_* S3 object) after the fact to a list of
data.frame's for easier consumption.
</p>

<hr>
<h2 id='explain'>Explain a search query.</h2><span id='topic+explain'></span>

<h3>Description</h3>

<p>Explain a search query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explain(
  conn,
  index,
  id,
  type = NULL,
  source2 = NULL,
  fields = NULL,
  routing = NULL,
  parent = NULL,
  preference = NULL,
  source = NULL,
  q = NULL,
  df = NULL,
  analyzer = NULL,
  analyze_wildcard = NULL,
  lowercase_expanded_terms = NULL,
  lenient = NULL,
  default_operator = NULL,
  source_exclude = NULL,
  source_include = NULL,
  body = NULL,
  raw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explain_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="explain_+3A_index">index</code></td>
<td>
<p>Only one index. Required</p>
</td></tr>
<tr><td><code id="explain_+3A_id">id</code></td>
<td>
<p>Document id, only one. Required</p>
</td></tr>
<tr><td><code id="explain_+3A_type">type</code></td>
<td>
<p>Only one document type, optional</p>
</td></tr>
<tr><td><code id="explain_+3A_source2">source2</code></td>
<td>
<p>(logical) Set to TRUE to retrieve the _source of the document
explained. You can also retrieve part of the document by using
source_include &amp; source_exclude (see Get API for more details). This
matches the <code style="white-space: pre;">&#8288;_source&#8288;</code> term, but we want to avoid the leading underscore.</p>
</td></tr>
<tr><td><code id="explain_+3A_fields">fields</code></td>
<td>
<p>Allows to control which stored fields to return as part of
the document explained.</p>
</td></tr>
<tr><td><code id="explain_+3A_routing">routing</code></td>
<td>
<p>Controls the routing in the case the routing was used during
indexing.</p>
</td></tr>
<tr><td><code id="explain_+3A_parent">parent</code></td>
<td>
<p>Same effect as setting the routing parameter.</p>
</td></tr>
<tr><td><code id="explain_+3A_preference">preference</code></td>
<td>
<p>Controls on which shard the explain is executed.</p>
</td></tr>
<tr><td><code id="explain_+3A_source">source</code></td>
<td>
<p>Allows the data of the request to be put in the query string
of the url.</p>
</td></tr>
<tr><td><code id="explain_+3A_q">q</code></td>
<td>
<p>The query string (maps to the query_string query).</p>
</td></tr>
<tr><td><code id="explain_+3A_df">df</code></td>
<td>
<p>The default field to use when no field prefix is defined within
the query. Defaults to _all field.</p>
</td></tr>
<tr><td><code id="explain_+3A_analyzer">analyzer</code></td>
<td>
<p>The analyzer name to be used when analyzing the query
string. Defaults to the analyzer of the _all field.</p>
</td></tr>
<tr><td><code id="explain_+3A_analyze_wildcard">analyze_wildcard</code></td>
<td>
<p>(logical) Should wildcard and prefix queries be
analyzed or not. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="explain_+3A_lowercase_expanded_terms">lowercase_expanded_terms</code></td>
<td>
<p>Should terms be automatically lowercased
or not. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="explain_+3A_lenient">lenient</code></td>
<td>
<p>If set to true will cause format based failures (like
providing text to a numeric field) to be ignored. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="explain_+3A_default_operator">default_operator</code></td>
<td>
<p>The default operator to be used, can be AND or OR.
Defaults to OR.</p>
</td></tr>
<tr><td><code id="explain_+3A_source_exclude">source_exclude</code></td>
<td>
<p>A vector of fields to exclude from the returned
source2 field</p>
</td></tr>
<tr><td><code id="explain_+3A_source_include">source_include</code></td>
<td>
<p>A vector of fields to extract and return from the
source2 field</p>
</td></tr>
<tr><td><code id="explain_+3A_body">body</code></td>
<td>
<p>The query definition using the Query DSL. This is passed in the
body of the request.</p>
</td></tr>
<tr><td><code id="explain_+3A_raw">raw</code></td>
<td>
<p>If <code>TRUE</code> (default), data is parsed to list. If <code>FALSE</code>, then
raw JSON.</p>
</td></tr>
<tr><td><code id="explain_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- connect())

explain(x, index = "plos", id = 14, q = "title:Germ")

body &lt;- '{
 "query": {
   "match": { "title": "Germ" }
 }
}'
explain(x, index = "plos", id = 14, body=body)

## End(Not run)
</code></pre>

<hr>
<h2 id='field_caps'>Field capabilities</h2><span id='topic+field_caps'></span>

<h3>Description</h3>

<p>The field capabilities API allows to retrieve the capabilities of fields
among multiple indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>field_caps(conn, fields, index = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="field_caps_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="field_caps_+3A_fields">fields</code></td>
<td>
<p>A list of fields to compute stats for. required</p>
</td></tr>
<tr><td><code id="field_caps_+3A_index">index</code></td>
<td>
<p>Index name, one or more</p>
</td></tr>
<tr><td><code id="field_caps_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-GET">crul::verb-GET</a></p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-field-caps.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-field-caps.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+field_stats">field_stats()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()
x$ping()

if (x$es_ver() &gt;= 540) {
  field_caps(x, fields = "speaker", index = "shakespeare")
}


## End(Not run)
</code></pre>

<hr>
<h2 id='field_stats'>Search field statistics</h2><span id='topic+field_stats'></span>

<h3>Description</h3>

<p>Search field statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>field_stats(
  conn,
  fields = NULL,
  index = NULL,
  level = "cluster",
  body = list(),
  raw = FALSE,
  asdf = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="field_stats_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="field_stats_+3A_fields">fields</code></td>
<td>
<p>A list of fields to compute stats for. optional</p>
</td></tr>
<tr><td><code id="field_stats_+3A_index">index</code></td>
<td>
<p>Index name, one or more</p>
</td></tr>
<tr><td><code id="field_stats_+3A_level">level</code></td>
<td>
<p>Defines if field stats should be returned on a per index level
or on a cluster wide level. Valid values are 'indices' and 'cluster'
(default)</p>
</td></tr>
<tr><td><code id="field_stats_+3A_body">body</code></td>
<td>
<p>Query, either a list or json</p>
</td></tr>
<tr><td><code id="field_stats_+3A_raw">raw</code></td>
<td>
<p>(logical) Get raw JSON back or not</p>
</td></tr>
<tr><td><code id="field_stats_+3A_asdf">asdf</code></td>
<td>
<p>(logical) If <code>TRUE</code>, use <code><a href="jsonlite.html#topic+fromJSON">fromJSON</a></code>
to parse JSON directly to a data.frame. If <code>FALSE</code> (Default), list
output is given.</p>
</td></tr>
<tr><td><code id="field_stats_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The field stats api allows you to get statistical properties of a
field without executing a search, but looking up measurements that are
natively available in the Lucene index. This can be useful to explore a
dataset which you don't know much about. For example, this allows creating
a histogram aggregation with meaningful intervals based on the min/max range
of values.
</p>
<p>The field stats api by defaults executes on all indices, but can execute on
specific indices too.
</p>


<h3>Note</h3>

<p>Deprecated in Elasticsearch versions equal to/greater than 5.4.0
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search-field-stats.html">https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search-field-stats.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+field_caps">field_caps()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()

if (gsub("\\.", "", x$ping()$version$number) &lt; 500) {
  field_stats(x, body = '{ "fields": ["speaker"] }', index = "shakespeare")
  ff &lt;- c("scientificName", "continent", "decimalLatitude", "play_name", 
    "speech_number")
  field_stats(x, "play_name")
  field_stats(x, "play_name", level = "cluster")
  field_stats(x, ff, level = "indices")
  field_stats(x, ff)
  field_stats(x, ff, index = c("gbif", "shakespeare"))

  # can also pass a body, just as with Search()
  # field_stats(x, body = list(fields = "rating")) # doesn't work
  field_stats(x, body = '{ "fields": ["scientificName"] }', index = "gbif")

  body &lt;- '{
    "fields" : ["scientificName", "decimalLatitude"]
  }'
  field_stats(x, body = body, level = "indices", index = "gbif")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fielddata'>fielddata</h2><span id='topic+fielddata'></span>

<h3>Description</h3>

<p>Deep dive on fielddata details
</p>


<h3>Details</h3>

<p>Most fields are indexed by default, which makes them searchable. Sorting,
aggregations, and accessing field values in scripts, however, requires a
different access pattern from search.
</p>
<p>Text fields use a query-time in-memory data structure called fielddata.
This data structure is built on demand the first time that a field is
used for aggregations, sorting, or in a script. It is built by reading
the entire inverted index for each segment from disk, inverting the
term-document relationship, and storing the result in memory, in the
JVM heap.
</p>
<p>fielddata is disabled on text fields by default. Fielddata can consume a
lot of heap space, especially when loading high cardinality text fields.
Once fielddata has been loaded into the heap, it remains there for the
lifetime of the segment. Also, loading fielddata is an expensive process
which can cause users to experience latency hits. This is why fielddata
is disabled by default. If you try to sort, aggregate, or access values
from a script on a text field, you will see this exception:
</p>
<p>&quot;Fielddata is disabled on text fields by default. Set fielddata=true on
<code>your_field_name</code> in order to load fielddata in memory by uninverting
the inverted index. Note that this can however use significant memory.&quot;
</p>
<p>To enable fielddata on a text field use the PUT mapping API, for example
<code>mapping_create("shakespeare", body = '{
  "properties": {
    "speaker": { 
      "type":     "text",
      "fielddata": true
    }
  }
}')</code>
</p>
<p>You may get an error about <code>update_all_types</code>, in which case set
<code>update_all_types=TRUE</code> in <code>mapping_create</code>, e.g.,
</p>
<p><code>mapping_create("shakespeare", update_all_types=TRUE, body = '{
  "properties": {
    "speaker": { 
      "type":     "text",
      "fielddata": true
    }
  }
}')</code>
</p>
<p>See <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/fielddata.html#_enabling_fielddata_on_literal_text_literal_fields">https://www.elastic.co/guide/en/elasticsearch/reference/current/fielddata.html#_enabling_fielddata_on_literal_text_literal_fields</a>
for more information.
</p>

<hr>
<h2 id='index_status'>This function is defunct</h2><span id='topic+index_status'></span>

<h3>Description</h3>

<p>This function is defunct
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_status(...)
</code></pre>

<hr>
<h2 id='index_template'>Index templates</h2><span id='topic+index_template'></span><span id='topic+index_template_put'></span><span id='topic+index_template_get'></span><span id='topic+index_template_exists'></span><span id='topic+index_template_delete'></span>

<h3>Description</h3>

<p>Index templates allow you to define templates that
will automatically be applied when new indices are created
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_template_put(
  conn,
  name,
  body = NULL,
  create = NULL,
  flat_settings = NULL,
  master_timeout = NULL,
  order = NULL,
  timeout = NULL,
  ...
)

index_template_get(conn, name = NULL, filter_path = NULL, ...)

index_template_exists(conn, name, ...)

index_template_delete(conn, name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_template_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="index_template_+3A_name">name</code></td>
<td>
<p>(character) The name of the template</p>
</td></tr>
<tr><td><code id="index_template_+3A_body">body</code></td>
<td>
<p>(character/list) The template definition</p>
</td></tr>
<tr><td><code id="index_template_+3A_create">create</code></td>
<td>
<p>(logical) Whether the index template should only be added
if new or can also replace an existing one. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="index_template_+3A_flat_settings">flat_settings</code></td>
<td>
<p>(logical) Return settings in flat format.
Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="index_template_+3A_master_timeout">master_timeout</code></td>
<td>
<p>(integer) Specify timeout for connection to master</p>
</td></tr>
<tr><td><code id="index_template_+3A_order">order</code></td>
<td>
<p>(integer) The order for this template when merging
multiple matching ones (higher numbers are merged later, overriding the
lower numbers)</p>
</td></tr>
<tr><td><code id="index_template_+3A_timeout">timeout</code></td>
<td>
<p>(integer) Explicit operation timeout</p>
</td></tr>
<tr><td><code id="index_template_+3A_...">...</code></td>
<td>
<p>Curl options. Or in <code>percolate_list</code> function, further
args passed on to <code><a href="#topic+Search">Search()</a></code></p>
</td></tr>
<tr><td><code id="index_template_+3A_filter_path">filter_path</code></td>
<td>
<p>(character) a regex for filtering output path,
see example</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- connect())

body &lt;- '{
  "template": "te*",
  "settings": {
    "number_of_shards": 1
  },
  "mappings": {
    "type1": {
      "_source": {
        "enabled": false
      },
      "properties": {
        "host_name": {
          "type": "keyword"
        },
        "created_at": {
          "type": "date",
          "format": "EEE MMM dd HH:mm:ss Z YYYY"
        }
      }
    }
  }
}'
index_template_put(x, "template_1", body = body)

# get templates
index_template_get(x)
index_template_get(x, "template_1")
index_template_get(x, c("template_1", "template_2"))
index_template_get(x, "template_*")
## filter path
index_template_get(x, "template_1", filter_path = "*.template")

# template exists
index_template_exists(x, "template_1")
index_template_exists(x, "foobar")

# delete a template
index_template_delete(x, "template_1")
index_template_exists(x, "template_1")

## End(Not run)
</code></pre>

<hr>
<h2 id='indices'>Index API operations</h2><span id='topic+indices'></span><span id='topic+index_get'></span><span id='topic+index_exists'></span><span id='topic+index_delete'></span><span id='topic+index_create'></span><span id='topic+index_recreate'></span><span id='topic+index_close'></span><span id='topic+index_open'></span><span id='topic+index_stats'></span><span id='topic+index_settings'></span><span id='topic+index_settings_update'></span><span id='topic+index_segments'></span><span id='topic+index_recovery'></span><span id='topic+index_optimize'></span><span id='topic+index_forcemerge'></span><span id='topic+index_upgrade'></span><span id='topic+index_analyze'></span><span id='topic+index_flush'></span><span id='topic+index_clear_cache'></span><span id='topic+index_shrink'></span>

<h3>Description</h3>

<p>Index API operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_get(
  conn,
  index = NULL,
  features = NULL,
  raw = FALSE,
  verbose = TRUE,
  ...
)

index_exists(conn, index, ...)

index_delete(conn, index, raw = FALSE, verbose = TRUE, ...)

index_create(conn, index = NULL, body = NULL, raw = FALSE, verbose = TRUE, ...)

index_recreate(
  conn,
  index = NULL,
  body = NULL,
  raw = FALSE,
  verbose = TRUE,
  ...
)

index_close(conn, index, ...)

index_open(conn, index, ...)

index_stats(
  conn,
  index = NULL,
  metric = NULL,
  completion_fields = NULL,
  fielddata_fields = NULL,
  fields = NULL,
  groups = NULL,
  level = "indices",
  ...
)

index_settings(conn, index = "_all", ...)

index_settings_update(conn, index = NULL, body, ...)

index_segments(conn, index = NULL, ...)

index_recovery(conn, index = NULL, detailed = FALSE, active_only = FALSE, ...)

index_optimize(
  conn,
  index = NULL,
  max_num_segments = NULL,
  only_expunge_deletes = FALSE,
  flush = TRUE,
  wait_for_merge = TRUE,
  ...
)

index_forcemerge(
  conn,
  index = NULL,
  max_num_segments = NULL,
  only_expunge_deletes = FALSE,
  flush = TRUE,
  ...
)

index_upgrade(conn, index = NULL, wait_for_completion = FALSE, ...)

index_analyze(
  conn,
  text = NULL,
  field = NULL,
  index = NULL,
  analyzer = NULL,
  tokenizer = NULL,
  filters = NULL,
  char_filters = NULL,
  body = list(),
  ...
)

index_flush(
  conn,
  index = NULL,
  force = FALSE,
  full = FALSE,
  wait_if_ongoing = FALSE,
  ...
)

index_clear_cache(
  conn,
  index = NULL,
  filter = FALSE,
  filter_keys = NULL,
  fielddata = FALSE,
  query_cache = FALSE,
  id_cache = FALSE,
  ...
)

index_shrink(conn, index, index_new, body = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indices_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="indices_+3A_index">index</code></td>
<td>
<p>(character) A character vector of index names</p>
</td></tr>
<tr><td><code id="indices_+3A_features">features</code></td>
<td>
<p>(character) A single feature. One of settings, mappings, or
aliases</p>
</td></tr>
<tr><td><code id="indices_+3A_raw">raw</code></td>
<td>
<p>If <code>TRUE</code> (default), data is parsed to list. If FALSE, then raw JSON.</p>
</td></tr>
<tr><td><code id="indices_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) the url call used printed to console.</p>
</td></tr>
<tr><td><code id="indices_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
<tr><td><code id="indices_+3A_body">body</code></td>
<td>
<p>Query, either a list or json.</p>
</td></tr>
<tr><td><code id="indices_+3A_metric">metric</code></td>
<td>
<p>(character) A character vector of metrics to display. Possible
values: &quot;_all&quot;, &quot;completion&quot;, &quot;docs&quot;, &quot;fielddata&quot;, &quot;filter_cache&quot;, &quot;flush&quot;,
&quot;get&quot;, &quot;id_cache&quot;, &quot;indexing&quot;, &quot;merge&quot;, &quot;percolate&quot;, &quot;refresh&quot;, &quot;search&quot;,
&quot;segments&quot;, &quot;store&quot;, &quot;warmer&quot;.</p>
</td></tr>
<tr><td><code id="indices_+3A_completion_fields">completion_fields</code></td>
<td>
<p>(character) A character vector of fields for completion metric
(supports wildcards)</p>
</td></tr>
<tr><td><code id="indices_+3A_fielddata_fields">fielddata_fields</code></td>
<td>
<p>(character) A character vector of fields for fielddata metric
(supports wildcards)</p>
</td></tr>
<tr><td><code id="indices_+3A_fields">fields</code></td>
<td>
<p>(character) Fields to add.</p>
</td></tr>
<tr><td><code id="indices_+3A_groups">groups</code></td>
<td>
<p>(character) A character vector of search groups for search statistics.</p>
</td></tr>
<tr><td><code id="indices_+3A_level">level</code></td>
<td>
<p>(character) Return stats aggregated on &quot;cluster&quot;, &quot;indices&quot; (default) or &quot;shards&quot;</p>
</td></tr>
<tr><td><code id="indices_+3A_detailed">detailed</code></td>
<td>
<p>(logical) Whether to display detailed information about shard recovery.
Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="indices_+3A_active_only">active_only</code></td>
<td>
<p>(logical) Display only those recoveries that are currently on-going.
Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="indices_+3A_max_num_segments">max_num_segments</code></td>
<td>
<p>(character) The number of segments the index should be merged into.
Default: &quot;dynamic&quot;</p>
</td></tr>
<tr><td><code id="indices_+3A_only_expunge_deletes">only_expunge_deletes</code></td>
<td>
<p>(logical) Specify whether the operation should only expunge
deleted documents</p>
</td></tr>
<tr><td><code id="indices_+3A_flush">flush</code></td>
<td>
<p>(logical) Specify whether the index should be flushed after performing the
operation. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="indices_+3A_wait_for_merge">wait_for_merge</code></td>
<td>
<p>(logical) Specify whether the request should block until the merge
process is finished. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="indices_+3A_wait_for_completion">wait_for_completion</code></td>
<td>
<p>(logical) Should the request wait for the upgrade to complete.
Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="indices_+3A_text">text</code></td>
<td>
<p>The text on which the analysis should be performed (when request body is not used)</p>
</td></tr>
<tr><td><code id="indices_+3A_field">field</code></td>
<td>
<p>Use the analyzer configured for this field (instead of passing the analyzer name)</p>
</td></tr>
<tr><td><code id="indices_+3A_analyzer">analyzer</code></td>
<td>
<p>The name of the analyzer to use</p>
</td></tr>
<tr><td><code id="indices_+3A_tokenizer">tokenizer</code></td>
<td>
<p>The name of the tokenizer to use for the analysis</p>
</td></tr>
<tr><td><code id="indices_+3A_filters">filters</code></td>
<td>
<p>A character vector of filters to use for the analysis</p>
</td></tr>
<tr><td><code id="indices_+3A_char_filters">char_filters</code></td>
<td>
<p>A character vector of character filters to use for the analysis</p>
</td></tr>
<tr><td><code id="indices_+3A_force">force</code></td>
<td>
<p>(logical) Whether a flush should be forced even if it is not necessarily needed
ie. if no changes will be committed to the index.</p>
</td></tr>
<tr><td><code id="indices_+3A_full">full</code></td>
<td>
<p>(logical) If set to TRUE a new index writer is created and settings that have been
changed related to the index writer will be refreshed.</p>
</td></tr>
<tr><td><code id="indices_+3A_wait_if_ongoing">wait_if_ongoing</code></td>
<td>
<p>If TRUE, the flush operation will block until the flush can be executed
if another flush operation is already executing. The default is false and will cause an
exception to be thrown on the shard level if another flush operation is already running.</p>
</td></tr>
<tr><td><code id="indices_+3A_filter">filter</code></td>
<td>
<p>(logical) Clear filter caches</p>
</td></tr>
<tr><td><code id="indices_+3A_filter_keys">filter_keys</code></td>
<td>
<p>(character) A vector of keys to clear when using the <code>filter_cache</code>
parameter (default: all)</p>
</td></tr>
<tr><td><code id="indices_+3A_fielddata">fielddata</code></td>
<td>
<p>(logical) Clear field data</p>
</td></tr>
<tr><td><code id="indices_+3A_query_cache">query_cache</code></td>
<td>
<p>(logical) Clear query caches</p>
</td></tr>
<tr><td><code id="indices_+3A_id_cache">id_cache</code></td>
<td>
<p>(logical) Clear ID caches for parent/child</p>
</td></tr>
<tr><td><code id="indices_+3A_index_new">index_new</code></td>
<td>
<p>(character) an index name, required. only applies to
index_shrink method</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>index_analyze</strong>:
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-analyze.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-analyze.html</a>
This method can accept a string of text in the body, but this function passes it as a
parameter in a GET request to simplify.
</p>
<p><strong>index_flush</strong>:
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-flush.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-flush.html</a>
From the ES website: The flush process of an index basically frees memory from the index by
flushing data to the index storage and clearing the internal transaction log. By default,
Elasticsearch uses memory heuristics in order to automatically trigger flush operations as
required in order to clear memory.
</p>
<p><strong>index_status</strong>: The API endpoint for this function was deprecated in
Elasticsearch <code>v1.2.0</code>, and will likely be removed soon. Use <code><a href="#topic+index_recovery">index_recovery()</a></code>
instead.
</p>
<p><strong>index_settings_update</strong>: There are a lot of options you can change with this
function. See
https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-update-settings.html
for all the options.
</p>
<p><strong>index settings</strong>: See
https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html
for the <em>static</em> and <em>dynamic</em> settings you can set on indices.
</p>


<h3>Mappings</h3>

<p>The &quot;keyword&quot; type is not supported in Elasticsearch &lt; v5. If you do use a mapping
with &quot;keyword&quot; type in Elasticsearch &lt; v5 <code><a href="#topic+index_create">index_create()</a></code> should fail.
</p>


<h3>Author(s)</h3>

<p>Scott Chamberlain <a href="mailto:myrmecocystus@gmail.com">myrmecocystus@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

# get information on an index
index_get(x, index='shakespeare')
## this one is the same as running index_settings('shakespeare')
index_get(x, index='shakespeare', features='settings')
index_get(x, index='shakespeare', features='mappings')
index_get(x, index='shakespeare', features='alias')

# check for index existence
index_exists(x, index='shakespeare')
index_exists(x, index='plos')

# create an index
if (index_exists(x, 'twitter')) index_delete(x, 'twitter')
index_create(x, index='twitter')
if (index_exists(x, 'things')) index_delete(x, 'things')
index_create(x, index='things')
if (index_exists(x, 'plos')) index_delete(x, 'plos')
index_create(x, index='plos')

# re-create an index
index_recreate(x, "deer")
index_recreate(x, "deer", verbose = FALSE)

# delete an index
if (index_exists(x, 'plos')) index_delete(x, index='plos')

## with a body
body &lt;- '{
 "settings" : {
  "index" : {
    "number_of_shards" : 3,
    "number_of_replicas" : 2
   }
 }
}'
if (index_exists(x, 'alsothat')) index_delete(x, 'alsothat')
index_create(x, index='alsothat', body = body)
## with read only
body &lt;- '{
 "settings" : {
  "index" : {
    "blocks" : {
      "read_only" : true
    }
   }
 }
}'
# index_create(x, index='myindex', body = body)
# then this delete call should fail with something like:
## &gt; Error: 403 - blocked by: [FORBIDDEN/5/index read-only (api)]
# index_delete(x, index='myindex')

## with mappings
body &lt;- '{
 "mappings": {
   "properties": {
     "location" : {"type" : "geo_point"}
   }
 }
}'
if (!index_exists(x, 'gbifnewgeo')) index_create(x, index='gbifnewgeo', body=body)
gbifgeo &lt;- system.file("examples", "gbif_geosmall.json", package = "elastic")
docs_bulk(x, gbifgeo)

# close an index
index_create(x, 'plos')
index_close(x, 'plos')

# open an index
index_open(x, 'plos')

# Get stats on an index
index_stats(x, 'plos')
index_stats(x, c('plos','gbif'))
index_stats(x, c('plos','gbif'), metric='refresh')
index_stats(x, metric = "indexing")
index_stats(x, 'shakespeare', metric='completion')
index_stats(x, 'shakespeare', metric='completion', completion_fields = "completion")
index_stats(x, 'shakespeare', metric='fielddata')
index_stats(x, 'shakespeare', metric='fielddata', fielddata_fields = "evictions")
index_stats(x, 'plos', level="indices")
index_stats(x, 'plos', level="cluster")
index_stats(x, 'plos', level="shards")

# Get segments information that a Lucene index (shard level) is built with
index_segments(x)
index_segments(x, 'plos')
index_segments(x, c('plos','gbif'))

# Get recovery information that provides insight into on-going index shard recoveries
index_recovery(x)
index_recovery(x, 'plos')
index_recovery(x, c('plos','gbif'))
index_recovery(x, "plos", detailed = TRUE)
index_recovery(x, "plos", active_only = TRUE)

# Optimize an index, or many indices
if (x$es_ver() &lt; 500) {
  ### ES &lt; v5 - use optimize
  index_optimize(x, 'plos')
  index_optimize(x, c('plos','gbif'))
  index_optimize(x, 'plos')
} else {
  ### ES &gt; v5 - use forcemerge
  index_forcemerge(x, 'plos')
}

# Upgrade one or more indices to the latest format. The upgrade process converts any
# segments written with previous formats.
if (x$es_ver() &lt; 500) {
  index_upgrade(x, 'plos')
  index_upgrade(x, c('plos','gbif'))
}

# Performs the analysis process on a text and return the tokens breakdown
# of the text
index_analyze(x, text = 'this is a test', analyzer='standard')
index_analyze(x, text = 'this is a test', analyzer='whitespace')
index_analyze(x, text = 'this is a test', analyzer='stop')
index_analyze(x, text = 'this is a test', tokenizer='keyword',
  filters='lowercase')
index_analyze(x, text = 'this is a test', tokenizer='keyword',
  filters='lowercase', char_filters='html_strip')
index_analyze(x, text = 'this is a test', index = 'plos',
  analyzer="standard")
index_analyze(x, text = 'this is a test', index = 'shakespeare',
  analyzer="standard")

## NGram tokenizer
body &lt;- '{
        "settings" : {
             "analysis" : {
                 "analyzer" : {
                     "my_ngram_analyzer" : {
                         "tokenizer" : "my_ngram_tokenizer"
                     }
                 },
                 "tokenizer" : {
                     "my_ngram_tokenizer" : {
                         "type" : "nGram",
                         "min_gram" : "2",
                         "max_gram" : "3",
                         "token_chars": [ "letter", "digit" ]
                     }
                 }
             }
      }
}'
if (index_exists(x, "shakespeare2")) index_delete(x, "shakespeare2")
tokenizer_set(x, index = "shakespeare2", body=body)
index_analyze(x, text = "art thouh", index = "shakespeare2",
  analyzer='my_ngram_analyzer')

# Explicitly flush one or more indices.
index_flush(x, index = "plos")
index_flush(x, index = "shakespeare")
index_flush(x, index = c("plos","shakespeare"))
index_flush(x, index = "plos", wait_if_ongoing = TRUE)
index_flush(x, index = "plos", verbose = TRUE)

# Clear either all caches or specific cached associated with one ore more indices.
index_clear_cache(x)
index_clear_cache(x, index = "plos")
index_clear_cache(x, index = "shakespeare")
index_clear_cache(x, index = c("plos","shakespeare"))
index_clear_cache(x, filter = TRUE)

# Index settings
## get settings
index_settings(x)
index_settings(x, "_all")
index_settings(x, 'gbif')
index_settings(x, c('gbif','plos'))
index_settings(x, '*s')
## update settings
if (index_exists(x, 'foobar')) index_delete(x, 'foobar')
index_create(x, "foobar")
settings &lt;- list(index = list(number_of_replicas = 4))
index_settings_update(x, "foobar", body = settings)
index_get(x, "foobar")$foobar$settings

# Shrink index - Can only shrink an index if it has &gt;1 shard
## index must be read only, a copy of every shard in the index must
## reside on the same node, and the cluster health status must be green
### index_settings_update call to change these
settings &lt;- list(
  index.routing.allocation.require._name = "shrink_node_name",
  index.blocks.write = "true"
)
if (index_exists(x, 'barbarbar')) index_delete(x, 'barbarbar')
index_create(x, "barbarbar")
index_settings_update(x, "barbarbar", body = settings)
cat_recovery(x, index='barbarbar')
# index_shrink(x, "barbarbar", "barfoobbar")

## End(Not run)
</code></pre>

<hr>
<h2 id='info'>This function is defunct</h2><span id='topic+info'></span>

<h3>Description</h3>

<p>This function is defunct
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info(...)
</code></pre>

<hr>
<h2 id='ingest'>Ingest API operations</h2><span id='topic+ingest'></span><span id='topic+pipeline_create'></span><span id='topic+pipeline_attachment'></span><span id='topic+pipeline_get'></span><span id='topic+pipeline_delete'></span><span id='topic+pipeline_simulate'></span>

<h3>Description</h3>

<p>Ingest API operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipeline_create(conn, id, body, ...)

pipeline_attachment(conn, index, id, pipeline, body, type = NULL, ...)

pipeline_get(conn, id, filter_path = NULL, ...)

pipeline_delete(conn, id, body, ...)

pipeline_simulate(conn, body, id = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ingest_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="ingest_+3A_id">id</code></td>
<td>
<p>(character) one or more pipeline id's. with delete, you can use
a wildcard match</p>
</td></tr>
<tr><td><code id="ingest_+3A_body">body</code></td>
<td>
<p>body describing pipeline, see examples and Elasticsearch docs</p>
</td></tr>
<tr><td><code id="ingest_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-POST">crul::verb-POST</a>, <a href="crul.html#topic+verb-GET">crul::verb-GET</a>,
<a href="crul.html#topic+verb-PUT">crul::verb-PUT</a>, or <a href="crul.html#topic+verb-DELETE">crul::verb-DELETE</a></p>
</td></tr>
<tr><td><code id="ingest_+3A_index">index</code></td>
<td>
<p>(character) an index. only used in <code>pipeline_attachment</code></p>
</td></tr>
<tr><td><code id="ingest_+3A_pipeline">pipeline</code></td>
<td>
<p>(character) a pipeline name. only used in <code>pipeline_attachment</code></p>
</td></tr>
<tr><td><code id="ingest_+3A_type">type</code></td>
<td>
<p>(character) a type. only used in <code>pipeline_attachment</code>. by default
ths is set to <code>NULL</code> - optional in ES &lt;= v6.3; not allowed in ES &gt;= v6.4</p>
</td></tr>
<tr><td><code id="ingest_+3A_filter_path">filter_path</code></td>
<td>
<p>(character) fields to return. deafults to all if not given</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ingest/pipeline functions available in Elasticsearch v5 and
greater
</p>


<h3>Value</h3>

<p>a named list
</p>


<h3>Attachments</h3>

<p>See https://www.elastic.co/guide/en/elasticsearch/plugins/current/ingest-attachment.html
You need to install the attachment processor plugin to be able to use
attachments in pipelines
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/ingest-apis.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/ingest-apis.html</a>,
<a href="https://www.elastic.co/guide/en/elasticsearch/plugins/current/using-ingest-attachment.html">https://www.elastic.co/guide/en/elasticsearch/plugins/current/using-ingest-attachment.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

# create
body1 &lt;- '{
  "description" : "do a thing",
  "version" : 123,
  "processors" : [
    {
      "set" : {
        "field": "foo",
        "value": "bar"
      }
    }
  ]
}'
body2 &lt;- '{
  "description" : "do another thing",
  "processors" : [
    {
      "set" : {
        "field": "stuff",
        "value": "things"
      }
    }
  ]
}'
pipeline_create(x, id = 'foo', body = body1)
pipeline_create(x, id = 'bar', body = body2)

# get
pipeline_get(x, id = 'foo')
pipeline_get(x, id = 'bar')
pipeline_get(x, id = 'foo', filter_path = "*.version")
pipeline_get(x, id = c('foo', 'bar')) # get &gt;1

# delete
pipeline_delete(x, id = 'foo')

# simulate
## with pipeline included
body &lt;- '{
  "pipeline" : {
    "description" : "do another thing",
    "processors" : [
      {
        "set" : {
          "field": "stuff",
          "value": "things"
        }
      }
    ]
  },
  "docs" : [
    { "_source": {"foo": "bar"} },
    { "_source": {"foo": "world"} }
  ]
}'
pipeline_simulate(x, body)

## referencing existing pipeline
body &lt;- '{
  "docs" : [
    { "_source": {"foo": "bar"} },
    { "_source": {"foo": "world"} }
  ]
}'
pipeline_simulate(x, body, id = "foo")

# attchments - Note: you need the attachment plugin for this, see above
body1 &lt;- '{
  "description" : "do a thing",
  "version" : 123,
  "processors" : [
    {
      "attachment" : {
        "field" : "data"
      }
    }
  ]
}'
pipeline_create(x, "baz", body1)
body_attach &lt;- '{
  "data": "e1xydGYxXGFuc2kNCkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0DQpccGFyIH0="
}'
if (!index_exists(x, "boomarang")) index_create(x, "boomarang")
docs_create(x, 'boomarang', id = 1, body = list(title = "New title"))
pipeline_attachment(x, "boomarang", "1", "baz", body_attach)
pipeline_get(x, id = 'baz')

## End(Not run)
</code></pre>

<hr>
<h2 id='mapping'>Mapping management</h2><span id='topic+mapping'></span><span id='topic+mapping_create'></span><span id='topic+mapping_get'></span><span id='topic+field_mapping_get'></span><span id='topic+type_exists'></span>

<h3>Description</h3>

<p>Mapping management
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapping_create(
  conn,
  index,
  body,
  type = NULL,
  update_all_types = FALSE,
  include_type_name = NULL,
  ...
)

mapping_get(conn, index = NULL, type = NULL, include_type_name = NULL, ...)

field_mapping_get(
  conn,
  index = NULL,
  type = NULL,
  field,
  include_defaults = FALSE,
  include_type_name = NULL,
  ...
)

type_exists(conn, index, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapping_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="mapping_+3A_index">index</code></td>
<td>
<p>(character) An index</p>
</td></tr>
<tr><td><code id="mapping_+3A_body">body</code></td>
<td>
<p>(list) Either a list or json, representing the query.</p>
</td></tr>
<tr><td><code id="mapping_+3A_type">type</code></td>
<td>
<p>(character) A document type</p>
</td></tr>
<tr><td><code id="mapping_+3A_update_all_types">update_all_types</code></td>
<td>
<p>(logical) update all types. default: <code>FALSE</code>.
This parameter is deprecated in ES v6.3.0 and higher, see
https://github.com/elastic/elasticsearch/pull/28284</p>
</td></tr>
<tr><td><code id="mapping_+3A_include_type_name">include_type_name</code></td>
<td>
<p>(logical) If set to <code>TRUE</code>, you can include a type
name, if not an error will occur. default: not set. See Details.</p>
</td></tr>
<tr><td><code id="mapping_+3A_...">...</code></td>
<td>
<p>Curl options passed on to <a href="crul.html#topic+verb-PUT">crul::verb-PUT</a>, <a href="crul.html#topic+verb-GET">crul::verb-GET</a>,
or <a href="crul.html#topic+verb-HEAD">crul::verb-HEAD</a></p>
</td></tr>
<tr><td><code id="mapping_+3A_field">field</code></td>
<td>
<p>(character) One or more field names</p>
</td></tr>
<tr><td><code id="mapping_+3A_include_defaults">include_defaults</code></td>
<td>
<p>(logical) Whether to return default values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Find documentation for each function at:
</p>

<ul>
<li> <p><code>mapping_create</code> -
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-mapping.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-mapping.html</a>
</p>
</li>
<li> <p><code>type_exists</code> -
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-types-exists.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-types-exists.html</a>
</p>
</li>
<li> <p><code>mapping_delete</code> - FUNCTION DEFUNCT - instead of deleting mapping, delete
index and recreate index with new mapping
</p>
</li>
<li> <p><code>mapping_get</code> -
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html</a>
</p>
</li>
<li> <p><code>field_mapping_get</code> -
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-field-mapping.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-field-mapping.html</a>
</p>
</li></ul>

<p>See <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/removal-of-types.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/removal-of-types.html</a>
for information on type removal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

# Used to check if a type/types exists in an index/indices
type_exists(x, index = "plos", type = "article")
type_exists(x, index = "plos", type = "articles")
type_exists(x, index = "shakespeare", type = "line")

# The put mapping API allows to register specific mapping definition for a specific type.
## a good mapping body
body &lt;- list(properties = list(
 journal = list(type="text"),
 year = list(type="long")
))
if (!index_exists(x, "plos")) index_create(x, "plos")
mapping_create(x, index = "plos", type = "citation", body=body)
## OR if above fails, try
mapping_create(x, index = "plos", type = "citation", body=body,
  include_type_name=TRUE)
## ES &gt;= 7, no type
mapping_create(x, index = "plos", body=body)

### or as json
body &lt;- '{
  "properties": {
    "journal": { "type": "text" },
      "year": { "type": "long" }
}}'
mapping_create(x, index = "plos", type = "citation", body=body)
mapping_get(x, "plos", "citation")

## A bad mapping body
body &lt;- list(things = list(properties = list(
  journal = list("text")
)))
# mapping_create(x, index = "plos", type = "things", body=body)

# Get mappings
mapping_get(x, '_all')
mapping_get(x, index = "plos")
mapping_get(x, index = c("shakespeare","plos"))
# mapping_get(x, index = "shakespeare", type = "act")
# mapping_get(x, index = "shakespeare", type = c("act","line"))

# Get field mappings
plosdat &lt;- system.file("examples", "plos_data.json",
  package = "elastic")
plosdat &lt;- type_remover(plosdat)
invisible(docs_bulk(x, plosdat))
field_mapping_get(x, index = "_all", field = "text")
field_mapping_get(x, index = "plos", field = "title")
field_mapping_get(x, index = "plos", field = "*")
field_mapping_get(x, index = "plos", field = "title", include_defaults = TRUE)
field_mapping_get(x, type = c("article","record"), field = c("title","class"))
field_mapping_get(x, type = "a*", field = "t*")

# Create geospatial mapping
if (index_exists(x, "gbifgeopoint")) index_delete(x, "gbifgeopoint")
file &lt;- system.file("examples", "gbif_geopoint.json",
  package = "elastic")
file &lt;- type_remover(file)
index_create(x, "gbifgeopoint")
body &lt;- '{
 "properties" : {
   "location" : { "type" : "geo_point" }
 }
}'
mapping_create(x, "gbifgeopoint", body = body)
invisible(docs_bulk(x, file))

# update_all_fields, see also ?fielddata
if (x$es_ver() &lt; 603) {
 mapping_create(x, "shakespeare", "record", update_all_types=TRUE, body = '{
   "properties": {
     "speaker": { 
       "type":     "text",
       "fielddata": true
     }
   }
 }')
} else {
 index_create(x, 'brownchair')
 mapping_create(x, 'brownchair', body = '{
   "properties": {
     "foo": { 
       "type":     "text",
       "fielddata": true
     }
   }
 }')
}


## End(Not run)
</code></pre>

<hr>
<h2 id='mapping_delete'>Mapping delete</h2><span id='topic+mapping_delete'></span>

<h3>Description</h3>

<p>Mapping delete
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapping_delete(...)
</code></pre>

<hr>
<h2 id='mlt'>This function is defunct</h2><span id='topic+mlt'></span>

<h3>Description</h3>

<p>This function is defunct
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlt(...)
</code></pre>

<hr>
<h2 id='msearch'>Multi-search</h2><span id='topic+msearch'></span>

<h3>Description</h3>

<p>Performs multiple searches, defined in a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msearch(conn, x, raw = FALSE, asdf = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msearch_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="msearch_+3A_x">x</code></td>
<td>
<p>(character) A file path</p>
</td></tr>
<tr><td><code id="msearch_+3A_raw">raw</code></td>
<td>
<p>(logical) Get raw JSON back or not.</p>
</td></tr>
<tr><td><code id="msearch_+3A_asdf">asdf</code></td>
<td>
<p>(logical) If <code>TRUE</code>, use <code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code>
to parse JSON directly to a data.frame. If <code>FALSE</code> (Default), list
output is given.</p>
</td></tr>
<tr><td><code id="msearch_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-POST">crul::verb-POST</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function behaves similarly to <code><a href="#topic+docs_bulk">docs_bulk()</a></code> -
performs searches based on queries defined in a file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Search_uri">Search_uri()</a></code> <code><a href="#topic+Search">Search()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()

msearch1 &lt;- system.file("examples", "msearch_eg1.json", package = "elastic")
readLines(msearch1)
msearch(x, msearch1)

tf &lt;- tempfile(fileext = ".json")
cat('{"index" : "shakespeare"}', file = tf, sep = "\n")
cat('{"query" : {"match_all" : {}}, "from" : 0, "size" : 5}',  sep = "\n",
   file = tf, append = TRUE)
readLines(tf)
msearch(x, tf)

## End(Not run)
</code></pre>

<hr>
<h2 id='mtermvectors'>Multi Termvectors</h2><span id='topic+mtermvectors'></span>

<h3>Description</h3>

<p>Multi Termvectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtermvectors(
  conn,
  index = NULL,
  type = NULL,
  ids = NULL,
  body = list(),
  pretty = TRUE,
  field_statistics = TRUE,
  fields = NULL,
  offsets = TRUE,
  parent = NULL,
  payloads = TRUE,
  positions = TRUE,
  preference = "random",
  realtime = TRUE,
  routing = NULL,
  term_statistics = FALSE,
  version = NULL,
  version_type = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtermvectors_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_index">index</code></td>
<td>
<p>(character) The index in which the document resides.</p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_type">type</code></td>
<td>
<p>(character) The type of the document.</p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_ids">ids</code></td>
<td>
<p>(character) One or more document ids</p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_body">body</code></td>
<td>
<p>(character) Define parameters and or supply a document to get
termvectors for</p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_pretty">pretty</code></td>
<td>
<p>(logical) pretty print. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_field_statistics">field_statistics</code></td>
<td>
<p>(character) Specifies if document count, sum of
document frequencies and sum of total term frequencies should be returned.
Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_fields">fields</code></td>
<td>
<p>(character) A comma-separated list of fields to return.</p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_offsets">offsets</code></td>
<td>
<p>(character) Specifies if term offsets should be returned.
Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_parent">parent</code></td>
<td>
<p>(character) Parent id of documents.</p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_payloads">payloads</code></td>
<td>
<p>(character) Specifies if term payloads should be returned.
Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_positions">positions</code></td>
<td>
<p>(character) Specifies if term positions should be returned.
Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_preference">preference</code></td>
<td>
<p>(character) Specify the node or shard the operation
should be performed on (Default: <code>random</code>).</p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_realtime">realtime</code></td>
<td>
<p>(character) Specifies if request is real-time as opposed to
near-real-time (Default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_routing">routing</code></td>
<td>
<p>(character) Specific routing value.</p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_term_statistics">term_statistics</code></td>
<td>
<p>(character) Specifies if total term frequency and
document frequency should be returned. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_version">version</code></td>
<td>
<p>(character) Explicit version number for concurrency control</p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_version_type">version_type</code></td>
<td>
<p>(character) Specific version type, valid choices are:
'internal', 'external', 'external_gte', 'force'</p>
</td></tr>
<tr><td><code id="mtermvectors_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-POST">crul::verb-POST</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multi termvectors API allows to get multiple termvectors based on an
index, type and id.
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-termvectors.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-termvectors.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+termvectors">termvectors()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()

if (index_exists(x, 'omdb')) index_delete(x, "omdb")
omdb &lt;- system.file("examples", "omdb.json", package = "elastic")
omdb &lt;- type_remover(omdb)
invisible(docs_bulk(x, omdb))
out &lt;- Search(x, "omdb", size = 2)$hits$hits
ids &lt;- vapply(out, "[[", "", "_id")

# no index
body &lt;- '{
   "docs": [
      {
         "_index": "omdb",
         "_id": "%s",
         "term_statistics": true
      },
      {
         "_index": "omdb",
         "_id": "%s",
         "fields": [
            "Plot"
         ]
      }
   ]
}'
mtermvectors(x, body = sprintf(body, ids[1], ids[2]))

# index given
body &lt;- '{
   "docs": [
      {
         "_id": "%s",
         "fields": [
            "Plot"
         ],
         "term_statistics": true
      },
      {
         "_id": "%s",
         "fields": [
            "Title"
         ]
      }
   ]
}'
mtermvectors(x, 'omdb', body = sprintf(body, ids[1], ids[2]))

# parameters same for both documents, so can simplify
body &lt;- '{
    "ids" : ["%s", "%s"],
    "parameters": {
        "fields": [
            "Plot"
        ],
        "term_statistics": true
    }
}'
mtermvectors(x, 'omdb', body = sprintf(body, ids[1], ids[2]))

# you can give user provided documents via the 'docs' parameter
## though you have to give index and type that exist in your Elasticsearch 
## instance
body &lt;- '{
   "docs": [
      {
         "_index": "omdb",
         "doc" : {
            "Director" : "John Doe",
            "Plot" : "twitter test test test"
         }
      },
      {
         "_index": "omdb",
         "doc" : {
           "Director" : "Jane Doe",
           "Plot" : "Another twitter test ..."
         }
      }
   ]
}'
mtermvectors(x, body = body)

## End(Not run)
</code></pre>

<hr>
<h2 id='nodes'>Elasticsearch nodes endpoints.</h2><span id='topic+nodes'></span><span id='topic+nodes_stats'></span><span id='topic+nodes_info'></span><span id='topic+nodes_hot_threads'></span>

<h3>Description</h3>

<p>Elasticsearch nodes endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodes_stats(conn, node = NULL, metric = NULL, raw = FALSE, fields = NULL, ...)

nodes_info(conn, node = NULL, metric = NULL, raw = FALSE, ...)

nodes_hot_threads(
  conn,
  node = NULL,
  metric = NULL,
  threads = 3,
  interval = "500ms",
  type = NULL,
  raw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="nodes_+3A_node">node</code></td>
<td>
<p>The node</p>
</td></tr>
<tr><td><code id="nodes_+3A_metric">metric</code></td>
<td>
<p>A metric to get. See Details.</p>
</td></tr>
<tr><td><code id="nodes_+3A_raw">raw</code></td>
<td>
<p>If <code>TRUE</code> (default), data is parsed to list. If <code>FALSE</code>, then
raw JSON.</p>
</td></tr>
<tr><td><code id="nodes_+3A_fields">fields</code></td>
<td>
<p>You can get information about field data memory usage on
node level or on index level</p>
</td></tr>
<tr><td><code id="nodes_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-GET">crul::verb-GET</a></p>
</td></tr>
<tr><td><code id="nodes_+3A_threads">threads</code></td>
<td>
<p>(character) Number of hot threads to provide. Default: 3</p>
</td></tr>
<tr><td><code id="nodes_+3A_interval">interval</code></td>
<td>
<p>(character) The interval to do the second sampling of
threads. Default: 500ms</p>
</td></tr>
<tr><td><code id="nodes_+3A_type">type</code></td>
<td>
<p>(character) The type to sample, defaults to cpu, but supports
wait and block to see hot threads that are in wait or block state.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-stats.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-stats.html</a>
</p>
<p>By default, all stats are returned. You can limit this by combining any of
indices, os, process, jvm, network, transport, http, fs, breaker and
thread_pool. With the metric parameter you can select zero or more of:
</p>

<ul>
<li><p> indices Indices stats about size, document count, indexing and
deletion times, search times, field cache size, merges and flushes
</p>
</li>
<li><p> os retrieve information that concern the operating system
</p>
</li>
<li><p> fs File system information, data path, free disk space,
read/write stats
</p>
</li>
<li><p> http HTTP connection information
</p>
</li>
<li><p> jvm JVM stats, memory pool information, garbage collection,
buffer pools
</p>
</li>
<li><p> network TCP information
</p>
</li>
<li><p> os Operating system stats, load average, cpu, mem, swap
</p>
</li>
<li><p> process Process statistics, memory consumption, cpu usage, open
file descriptors
</p>
</li>
<li><p> thread_pool Statistics about each thread pool, including current
size, queue and rejected tasks
</p>
</li>
<li><p> transport Transport statistics about sent and received bytes in
cluster communication
</p>
</li>
<li><p> breaker Statistics about the field data circuit breaker
</p>
</li></ul>

<p><code><a href="#topic+nodes_hot_threads">nodes_hot_threads()</a></code> returns plain text, so <code><a href="base.html#topic+cat">base::cat()</a></code>
is used to print to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

(out &lt;- nodes_stats(x))
nodes_stats(x, node = names(out$nodes))
nodes_stats(x, metric='get')
nodes_stats(x, metric='jvm')
nodes_stats(x, metric=c('os','process'))
nodes_info(x)
nodes_info(x, metric='process')
nodes_info(x, metric='jvm')
nodes_info(x, metric='http')
nodes_info(x, metric='network')

## End(Not run)
</code></pre>

<hr>
<h2 id='nodes_shutdown'>This function is defunct</h2><span id='topic+nodes_shutdown'></span>

<h3>Description</h3>

<p>This function is defunct
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodes_shutdown(...)
</code></pre>

<hr>
<h2 id='percolate'>Percolater</h2><span id='topic+percolate'></span><span id='topic+percolate_register'></span><span id='topic+percolate_match'></span><span id='topic+percolate_list'></span><span id='topic+percolate_count'></span><span id='topic+percolate_delete'></span>

<h3>Description</h3>

<p>Store queries into an index then, via the percolate API, define
documents to retrieve these queries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percolate_register(
  conn,
  index,
  id,
  type = NULL,
  body = list(),
  routing = NULL,
  preference = NULL,
  ignore_unavailable = NULL,
  percolate_format = NULL,
  refresh = NULL,
  ...
)

percolate_match(
  conn,
  index,
  type = NULL,
  body,
  routing = NULL,
  preference = NULL,
  ignore_unavailable = NULL,
  percolate_format = NULL,
  ...
)

percolate_list(conn, index, ...)

percolate_count(conn, index, type, body, ...)

percolate_delete(conn, index, id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percolate_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="percolate_+3A_index">index</code></td>
<td>
<p>Index name. Required</p>
</td></tr>
<tr><td><code id="percolate_+3A_id">id</code></td>
<td>
<p>A precolator id. Required</p>
</td></tr>
<tr><td><code id="percolate_+3A_type">type</code></td>
<td>
<p>Document type. Required</p>
</td></tr>
<tr><td><code id="percolate_+3A_body">body</code></td>
<td>
<p>Body json, or R list.</p>
</td></tr>
<tr><td><code id="percolate_+3A_routing">routing</code></td>
<td>
<p>(character) In case the percolate queries are partitioned by a custom
routing value, that routing option makes sure that the percolate request only gets
executed on the shard where the routing value is partitioned to. This means that the
percolate request only gets executed on one shard instead of all shards. Multiple values
can be specified as a comma separated string, in that case the request can be be executed
on more than one shard.</p>
</td></tr>
<tr><td><code id="percolate_+3A_preference">preference</code></td>
<td>
<p>(character) Controls which shard replicas are preferred to execute
the request on. Works the same as in the search API.</p>
</td></tr>
<tr><td><code id="percolate_+3A_ignore_unavailable">ignore_unavailable</code></td>
<td>
<p>(logical) Controls if missing concrete indices should
silently be ignored. Same as is in the search API.</p>
</td></tr>
<tr><td><code id="percolate_+3A_percolate_format">percolate_format</code></td>
<td>
<p>(character) If ids is specified then the matches array in the
percolate response will contain a string array of the matching ids instead of an
array of objects. This can be useful to reduce the amount of data being send back to
the client. Obviously if there are two percolator queries with same id from different
indices there is no way to find out which percolator query belongs to what index. Any
other value to percolate_format will be ignored.</p>
</td></tr>
<tr><td><code id="percolate_+3A_refresh">refresh</code></td>
<td>
<p>If <code>TRUE</code> then refresh the affected shards to make this
operation visible to search, if &quot;wait_for&quot; then wait for a refresh to
make this operation visible to search, if <code>FALSE</code> (default) then do
nothing with refreshes. Valid choices: <code>TRUE</code>, <code>FALSE</code>, &quot;wait_for&quot;</p>
</td></tr>
<tr><td><code id="percolate_+3A_...">...</code></td>
<td>
<p>Curl options. Or in <code>percolate_list</code> function, further args
passed on to <code><a href="#topic+Search">Search()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional body options, pass those in the body. These aren't query string
parameters:
</p>

<ul>
<li><p> filter - Reduces the number queries to execute during percolating. Only the
percolator queries that match with the filter will be included in the percolate
execution. The filter option works in near realtime, so a refresh needs to have
occurred for the filter to included the latest percolate queries.
</p>
</li>
<li><p> query - Same as the filter option, but also the score is computed. The
computed scores can then be used by the track_scores and sort option.
</p>
</li>
<li><p> size - Defines to maximum number of matches (percolate queries) to be returned.
Defaults to unlimited.
</p>
</li>
<li><p> track_scores - Whether the _score is included for each match. The _score is
based on the query and represents how the query matched the percolate query's
metadata, not how the document (that is being percolated) matched the query. The query
option is required for this option. Defaults to false.
</p>
</li>
<li><p> sort - Define a sort specification like in the search API. Currently only
sorting _score reverse (default relevancy) is supported. Other sort fields will
throw an exception. The size and query option are required for this setting. Like
track_score the score is based on the query and represents how the query matched
to the percolate query's metadata and not how the document being percolated matched
to the query.
</p>
</li>
<li><p> aggs - Allows aggregation definitions to be included. The aggregations are
based on the matching percolator queries, look at the aggregation documentation on
how to define aggregations.
</p>
</li>
<li><p> highlight - Allows highlight definitions to be included. The document being
percolated is being highlight for each matching query. This allows you to see how
each match is highlighting the document being percolated. See highlight documentation
on how to define highlights. The size option is required for highlighting, the
performance of highlighting in the percolate API depends of how many matches are
being highlighted.
</p>
</li></ul>



<h3>The Elasticsearch v5 split</h3>

<p>In Elasticsearch &lt; v5, there's a certain set of percolate APIs available,
while in Elasticsearch &gt;= v5, there's a different set of APIs available.
</p>
<p>Internally within these percolate functions we detect your Elasticsearch
version, then use the appropriate APIs
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-percolate-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-percolate-query.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect(errors = "complete")

##### Elasticsearch &lt; v5
if (x$es_ver() &lt; 500) {
# typical usage
## create an index first
if (index_exists(x, "myindex")) index_delete(x, "myindex")
mapping &lt;- '{
  "mappings": {
    "mytype": {
      "properties": {
        "message": {
           "type": "text"
        },
        "query": {
           "type": "percolator"
        }
      }
    }
  }
}'
index_create(x, "myindex", body = mapping)

## register a percolator
perc_body = '{
 "query" : {
    "match" : {
      "message" : "bonsai tree"
    }
 }
}'
percolate_register(x, index = "myindex", type = "mytype", 
  id = 1, body = perc_body)

## register another
perc_body2 &lt;- '{
  "query" : {
    "match" : {
      "message" : "jane doe"
    }
  }
}'
percolate_register(x, index = "myindex", type = "mytype", 
  id = 2, body = perc_body2)

## match a document to a percolator
doc &lt;- '{
 "query": {
   "percolate": {
     "field": "query",
     "document": {
       "message" : "A new bonsai tree in the office"
     }
   }
 }
}'
percolate_match(x, index = "myindex", type = "mytype", body = doc)

## List percolators - for an index, no type, can't do across indices
percolate_list(x, index = "myindex")$hits$hits

## Percolate counter
percolate_count(x, index = "myindex", type = "mytype", body = doc)$total

## delete a percolator
percolate_delete(x, index = "myindex", id = 2)
} # end ES &lt; 5


##### Elasticsearch &gt;= v5
if (x$es_ver() &gt;= 500 &amp;&amp; x$es_ver() &lt;= 700) {
if (index_exists(x, "myindex")) index_delete(x, "myindex")

body &lt;- '{
  "mappings": {
    "mytype": {
      "properties": {
        "message": {
           "type": "text"
        },
        "query": {
           "type": "percolator"
        }
      }
    }
  }
}'

# create the index with mapping
index_create(x, "myindex", body = body)

## register a percolator
z &lt;- '{
  "query" : {
     "match" : {
       "message" : "bonsai tree"
     }
  }
}'
percolate_register(x, index = "myindex", type = "mytype", id = 1, body = z)

## register another
x2 &lt;- '{
  "query" : {
    "match" : {
      "message" : "the office"
    }
  }
}'
percolate_register(x, index = "myindex", type = "mytype", id = 2, body = x2)

## match a document to a percolator
query &lt;- '{
  "query" : {
    "percolate" : {
      "field": "query",
      "document": {
        "message": "A new bonsai tree in the office"
      }
    }
  }
}'
percolate_match(x, index = "myindex", body = query)
} # end ES &gt;= 5




##### Elasticsearch &gt;= v7
if (x$es_ver() &gt;= 700) {
if (index_exists(x, "myindex")) index_delete(x, "myindex")

body &lt;- '{
  "mappings": {
    "properties": {
      "message": {
        "type": "text"
      },
      "query": {
        "type": "percolator"
      }
    }
  }
}'

# create the index with mapping
index_create(x, "myindex", body = body)

## register a percolator
z &lt;- '{
  "query" : {
     "match" : {
       "message" : "bonsai tree"
     }
  }
}'
percolate_register(x, index = "myindex", id = 1, body = z)

## register another
x2 &lt;- '{
  "query" : {
    "match" : {
      "message" : "the office"
    }
  }
}'
percolate_register(x, index = "myindex", id = 2, body = x2)

## match a document to a percolator
query &lt;- '{
  "query" : {
    "percolate" : {
      "field": "query",
      "document": {
        "message": "A new bonsai tree in the office"
      }
    }
  }
}'
percolate_match(x, index = "myindex", body = query)
} # end ES &gt;= 7



## End(Not run)
</code></pre>

<hr>
<h2 id='ping'>Ping an Elasticsearch server.</h2><span id='topic+ping'></span>

<h3>Description</h3>

<p>Ping an Elasticsearch server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ping(conn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ping_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="ping_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-GET">crul::verb-GET</a></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+connect">connect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()
ping(x)
# ideally call ping on the connetion object itself
x$ping()

## End(Not run)
</code></pre>

<hr>
<h2 id='preference'>Preferences.</h2><span id='topic+preference'></span>

<h3>Description</h3>

<p>Preferences.
</p>


<h3>Details</h3>


<ul>
<li><p> _primary The operation will go and be executed only on the primary shards.
</p>
</li>
<li><p> _primary_first The operation will go and be executed on the primary shard, and if
not available (failover), will execute on other shards.
</p>
</li>
<li><p> _local The operation will prefer to be executed on a local allocated shard if possible.
</p>
</li>
<li><p> _only_node:xyz Restricts the search to execute only on a node with the provided
node id (xyz in this case).
</p>
</li>
<li><p> _prefer_node:xyz Prefers execution on the node with the provided node
id (xyz in this case) if applicable.
</p>
</li>
<li><p> _shards:2,3 Restricts the operation to the specified shards. (2 and 3 in this case).
This preference can be combined with other preferences but it has to appear
first: _shards:2,3;_primary
</p>
</li>
<li><p> Custom (string) value A custom value will be used to guarantee that the same shards
will be used for the same custom value. This can help with &quot;jumping values&quot; when hitting
different shards in different refresh states. A sample value can be something like the web
session id, or the user name.
</p>
</li></ul>


<hr>
<h2 id='reindex'>Reindex</h2><span id='topic+reindex'></span>

<h3>Description</h3>

<p>Reindex all documents from one index to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reindex(
  conn,
  body,
  refresh = NULL,
  requests_per_second = NULL,
  slices = NULL,
  timeout = NULL,
  wait_for_active_shards = NULL,
  wait_for_completion = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reindex_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="reindex_+3A_body">body</code></td>
<td>
<p>(list/character/json) The search definition using the Query DSL
and the prototype for the index request.</p>
</td></tr>
<tr><td><code id="reindex_+3A_refresh">refresh</code></td>
<td>
<p>(logical) Should the effected indexes be refreshed?</p>
</td></tr>
<tr><td><code id="reindex_+3A_requests_per_second">requests_per_second</code></td>
<td>
<p>(integer) The throttle to set on this request in
sub-requests per second. - 1 means no throttle. Default: 0</p>
</td></tr>
<tr><td><code id="reindex_+3A_slices">slices</code></td>
<td>
<p>(integer) The number of slices this task should be divided
into. Defaults to 1 meaning the task isn't sliced into subtasks. Default: 1</p>
</td></tr>
<tr><td><code id="reindex_+3A_timeout">timeout</code></td>
<td>
<p>(character) Time each individual bulk request should wait
for shards that are unavailable. Default: '1m'</p>
</td></tr>
<tr><td><code id="reindex_+3A_wait_for_active_shards">wait_for_active_shards</code></td>
<td>
<p>(integer) Sets the number of shard copies that
must be active before proceeding with the reindex operation. Defaults to 1,
meaning the primary shard only. Set to all for all shard copies, otherwise
set to any non-negative value less than or equal to the total number of
copies for the shard (number of replicas + 1)</p>
</td></tr>
<tr><td><code id="reindex_+3A_wait_for_completion">wait_for_completion</code></td>
<td>
<p>(logical) Should the request block until the
reindex is complete? Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="reindex_+3A_...">...</code></td>
<td>
<p>Curl options, passed on to <a href="crul.html#topic+verb-POST">crul::verb-POST</a></p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()

if (!index_exists(x, "twitter")) index_create(x, "twitter")
if (!index_exists(x, "new_twitter")) index_create(x, "new_twitter")
body &lt;- '{
  "source": {
    "index": "twitter"
  },
  "dest": {
    "index": "new_twitter"
  }
}'
reindex(x, body = body)

## End(Not run)
</code></pre>

<hr>
<h2 id='scroll'>Scroll search function</h2><span id='topic+scroll'></span><span id='topic+scroll_clear'></span>

<h3>Description</h3>

<p>Scroll search function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scroll(
  conn,
  x,
  time_scroll = "1m",
  raw = FALSE,
  asdf = FALSE,
  stream_opts = list(),
  ...
)

scroll_clear(conn, x = NULL, all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scroll_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="scroll_+3A_x">x</code></td>
<td>
<p>(character) For <code>scroll</code>, a single scroll id; for
<code>scroll_clear</code>, one or more scroll id's</p>
</td></tr>
<tr><td><code id="scroll_+3A_time_scroll">time_scroll</code></td>
<td>
<p>(character) Specify how long a consistent view of the
index should be maintained for scrolled search, e.g., &quot;30s&quot;, &quot;1m&quot;.
See <a href="#topic+units-time">units-time</a>.</p>
</td></tr>
<tr><td><code id="scroll_+3A_raw">raw</code></td>
<td>
<p>(logical) If <code>FALSE</code> (default), data is parsed to list.
If <code>TRUE</code>, then raw JSON.</p>
</td></tr>
<tr><td><code id="scroll_+3A_asdf">asdf</code></td>
<td>
<p>(logical) If <code>TRUE</code>, use <code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code>
to parse JSON directly to a data.frame. If <code>FALSE</code> (Default), list
output is given.</p>
</td></tr>
<tr><td><code id="scroll_+3A_stream_opts">stream_opts</code></td>
<td>
<p>(list) A list of options passed to
<code><a href="jsonlite.html#topic+stream_in">jsonlite::stream_out()</a></code> - Except that you can't pass <code>x</code> as
that's the data that's streamed out, and pass a file path sinstead of a
connection to <code>con</code>. <code>pagesize</code> param doesn't do much as
that's more or less controlled by paging with ES.</p>
</td></tr>
<tr><td><code id="scroll_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-POST">crul::verb-POST</a></p>
</td></tr>
<tr><td><code id="scroll_+3A_all">all</code></td>
<td>
<p>(logical) If <code>TRUE</code> (default) then all search contexts
cleared.  If <code>FALSE</code>, scroll id's must be passed to <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>scroll()</code> returns a list, identical to what
<code><a href="#topic+Search">Search()</a></code> returns. With attribute <code>scroll</code> that is the
scroll value set via the <code>time_scroll</code> parameter
</p>
<p><code>scroll_clear()</code> returns a boolean (<code>TRUE</code> on success)
</p>


<h3>Scores</h3>

<p>Scores will be the same for all documents that are returned from a
scroll request. Dems da rules.
</p>


<h3>Inputs</h3>

<p>Inputs to <code>scroll()</code> can be one of:
</p>

<ul>
<li><p> list - This usually will be the output of <code><a href="#topic+Search">Search()</a></code>, but
you could in theory make a list yourself with the appropriate elements
</p>
</li>
<li><p> character - A scroll ID - this is typically the scroll id output
from a call to <code><a href="#topic+Search">Search()</a></code>, accessed like <code>res$`_scroll_id`</code>
</p>
</li></ul>

<p>All other classes passed to <code>scroll()</code> will fail with message
</p>
<p>Lists passed to <code>scroll()</code> without a <code style="white-space: pre;">&#8288;_scroll_id&#8288;</code> element will
trigger an error.
</p>
<p>From lists output form <code><a href="#topic+Search">Search()</a></code> there should be an attribute
(&quot;scroll&quot;) that is the <code>scroll</code> value set in the <code><a href="#topic+Search">Search()</a></code>
request - if that attribute is missing from the list, we'll attempt to
use the <code>time_scroll</code> parameter value set in the
<code>scroll()</code> function call
</p>
<p>The output of <code>scroll()</code> has the scroll time value as an attribute so
the output can be passed back into <code>scroll()</code> to continue.
</p>


<h3>Clear scroll</h3>

<p>Search context are automatically removed when the scroll timeout has
been exceeded.  Keeping scrolls open has a cost, so scrolls should be
explicitly cleared as soon  as the scroll is not being used anymore
using <code>scroll_clear</code>
</p>


<h3>Sliced scrolling</h3>

<p>For scroll queries that return a lot of documents it is possible to split
the scroll in multiple slices which can be consumed independently.
</p>
<p>See the example in this man file.
</p>


<h3>Aggregations</h3>

<p>If the request specifies aggregations, only the initial search response
will contain the aggregations results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Search">Search()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(con &lt;- connect())

# Basic usage - can use across all indices
res &lt;- Search(con, time_scroll="1m")
scroll(con, res)$`_scroll_id`

# use on a specific index - and specify a query
res &lt;- Search(con, index = 'shakespeare', q="a*", time_scroll="1m")
res$`_scroll_id`

# Setting "sort=_doc" to turn off sorting of results - faster
res &lt;- Search(con, index = 'shakespeare', q="a*", time_scroll="1m",
  body = '{"sort": ["_doc"]}')
res$`_scroll_id`

# Pass scroll_id to scroll function
scroll(con, res$`_scroll_id`)

# Get all results - one approach is to use a while loop
res &lt;- Search(con, index = 'shakespeare', q="a*", time_scroll="5m",
  body = '{"sort": ["_doc"]}')
out &lt;- res$hits$hits
hits &lt;- 1
while(hits != 0){
  res &lt;- scroll(con, res$`_scroll_id`, time_scroll="5m")
  hits &lt;- length(res$hits$hits)
  if(hits &gt; 0)
    out &lt;- c(out, res$hits$hits)
}
length(out)
res$hits$total
out[[1]]

# clear scroll
## individual scroll id
res &lt;- Search(con, index = 'shakespeare', q="a*", time_scroll="5m",
  body = '{"sort": ["_doc"]}')
scroll_clear(con, res$`_scroll_id`)

## many scroll ids
res1 &lt;- Search(con, index = 'shakespeare', q="c*", time_scroll="5m",
  body = '{"sort": ["_doc"]}')
res2 &lt;- Search(con, index = 'shakespeare', q="d*", time_scroll="5m",
  body = '{"sort": ["_doc"]}')
nodes_stats(con, metric = "indices")$nodes[[1]]$indices$search$open_contexts
scroll_clear(con, c(res1$`_scroll_id`, res2$`_scroll_id`))
nodes_stats(con, metric = "indices")$nodes[[1]]$indices$search$open_contexts

## all scroll ids
res1 &lt;- Search(con, index = 'shakespeare', q="f*", time_scroll="1m",
  body = '{"sort": ["_doc"]}')
res2 &lt;- Search(con, index = 'shakespeare', q="g*", time_scroll="1m",
  body = '{"sort": ["_doc"]}')
res3 &lt;- Search(con, index = 'shakespeare', q="k*", time_scroll="1m",
  body = '{"sort": ["_doc"]}')
scroll_clear(con, all = TRUE)

## sliced scrolling
body1 &lt;- '{
  "slice": {
    "id": 0,
    "max": 2
  },
  "query": {
    "match" : {
      "text_entry" : "a*"
    }
  }
}'

body2 &lt;- '{
  "slice": {
    "id": 1,
    "max": 2
  },
  "query": {
    "match" : {
      "text_entry" : "a*"
    }
  }
}'

res1 &lt;- Search(con, index = 'shakespeare', time_scroll="1m", body = body1)
res2 &lt;- Search(con, index = 'shakespeare', time_scroll="1m", body = body2)
scroll(con, res1$`_scroll_id`)
scroll(con, res2$`_scroll_id`)

out1 &lt;- list()
hits &lt;- 1
while(hits != 0){
  tmp1 &lt;- scroll(con, res1$`_scroll_id`)
  hits &lt;- length(tmp1$hits$hits)
  if(hits &gt; 0)
    out1 &lt;- c(out1, tmp1$hits$hits)
}

out2 &lt;- list()
hits &lt;- 1
while(hits != 0){
  tmp2 &lt;- scroll(con, res2$`_scroll_id`)
  hits &lt;- length(tmp2$hits$hits)
  if(hits &gt; 0)
    out2 &lt;- c(out2, tmp2$hits$hits)
}

c(
 lapply(out1, "[[", "_source"),
 lapply(out2, "[[", "_source")
)


# using jsonlite::stream_out
res &lt;- Search(con, time_scroll = "1m")
file &lt;- tempfile()
scroll(con, 
  x = res$`_scroll_id`,
  stream_opts = list(file = file)
)
jsonlite::stream_in(file(file))
unlink(file)

## stream_out and while loop
(file &lt;- tempfile())
res &lt;- Search(con, index = "shakespeare", time_scroll = "5m",
  size = 1000, stream_opts = list(file = file))
while(!inherits(res, "warning")) {
  res &lt;- tryCatch(scroll(
    conn = con,
    x = res$`_scroll_id`,
    time_scroll = "5m",
    stream_opts = list(file = file)
  ), warning = function(w) w)
}
NROW(df &lt;- jsonlite::stream_in(file(file)))
head(df)

## End(Not run)
</code></pre>

<hr>
<h2 id='Search'>Full text search of Elasticsearch</h2><span id='topic+Search'></span>

<h3>Description</h3>

<p>Full text search of Elasticsearch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Search(
  conn,
  index = NULL,
  type = NULL,
  q = NULL,
  df = NULL,
  analyzer = NULL,
  default_operator = NULL,
  explain = NULL,
  source = NULL,
  fields = NULL,
  sort = NULL,
  track_scores = NULL,
  timeout = NULL,
  terminate_after = NULL,
  from = NULL,
  size = NULL,
  search_type = NULL,
  lowercase_expanded_terms = NULL,
  analyze_wildcard = NULL,
  version = NULL,
  lenient = NULL,
  body = list(),
  raw = FALSE,
  asdf = FALSE,
  track_total_hits = TRUE,
  time_scroll = NULL,
  search_path = "_search",
  stream_opts = list(),
  ignore_unavailable = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Search_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect</a></code></p>
</td></tr>
<tr><td><code id="Search_+3A_index">index</code></td>
<td>
<p>Index name, one or more</p>
</td></tr>
<tr><td><code id="Search_+3A_type">type</code></td>
<td>
<p>Document type. Note that <code>type</code> is deprecated in
Elasticsearch v7 and greater, and removed in Elasticsearch v8. We will
strive to support types for folks using older ES versions</p>
</td></tr>
<tr><td><code id="Search_+3A_q">q</code></td>
<td>
<p>The query string (maps to the query_string query, see Query String
Query for more details). See
https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html
for documentation and examples.</p>
</td></tr>
<tr><td><code id="Search_+3A_df">df</code></td>
<td>
<p>(character) The default field to use when no field prefix is
defined within the query.</p>
</td></tr>
<tr><td><code id="Search_+3A_analyzer">analyzer</code></td>
<td>
<p>(character) The analyzer name to be used when analyzing the
query string.</p>
</td></tr>
<tr><td><code id="Search_+3A_default_operator">default_operator</code></td>
<td>
<p>(character) The default operator to be used, can be
<code>AND</code> or <code>OR</code>. Default: <code>OR</code></p>
</td></tr>
<tr><td><code id="Search_+3A_explain">explain</code></td>
<td>
<p>(logical) For each hit, contain an explanation of how
scoring of the hits was computed. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="Search_+3A_source">source</code></td>
<td>
<p>(logical) Set to <code>FALSE</code> to disable retrieval of the
<code>_source</code> field. You can also retrieve part of the document by
using <code>_source_include</code> &amp; <code>_source_exclude</code> (see the <code>body</code>
documentation for more details). You can also include a comma-delimited
string of fields from the source document that you want back. See also
the <strong>fields</strong> parameter</p>
</td></tr>
<tr><td><code id="Search_+3A_fields">fields</code></td>
<td>
<p>(character) The selective stored fields of the document to
return for each hit. Not specifying any value will cause no fields to return.
Note that in Elasticsearch v5 and greater, <strong>fields</strong> parameter has
changed to <strong>stored_fields</strong>, which is not on by default. You can
however, pass fields to <strong>source</strong> parameter</p>
</td></tr>
<tr><td><code id="Search_+3A_sort">sort</code></td>
<td>
<p>(character) Sorting to perform. Can either be in the form of
fieldName, or <code>fieldName:asc</code>/<code>fieldName:desc</code>. The fieldName
can either be an actual field within the document, or the special
<code>_score</code> name to indicate sorting based on scores. There can be several
sort parameters (order is important).</p>
</td></tr>
<tr><td><code id="Search_+3A_track_scores">track_scores</code></td>
<td>
<p>(logical) When sorting, set to <code>TRUE</code> in order to
still track scores and return them as part of each hit.</p>
</td></tr>
<tr><td><code id="Search_+3A_timeout">timeout</code></td>
<td>
<p>(numeric) A search timeout, bounding the search request to
be executed within the specified time value and bail with the hits
accumulated up to that point when expired. Default: no timeout.</p>
</td></tr>
<tr><td><code id="Search_+3A_terminate_after">terminate_after</code></td>
<td>
<p>(numeric) The maximum number of documents to collect
for each shard, upon reaching which the query execution will terminate
early. If set, the response will have a boolean field terminated_early to
indicate whether the query execution has actually terminated_early.
Default: no terminate_after</p>
</td></tr>
<tr><td><code id="Search_+3A_from">from</code></td>
<td>
<p>(character) The starting from index of the hits to return.
Pass in as a character string to avoid problems with large number
conversion to scientific notation. Default: 0</p>
</td></tr>
<tr><td><code id="Search_+3A_size">size</code></td>
<td>
<p>(character) The number of hits to return. Pass in as a
character string to avoid problems with large number conversion to
scientific notation. Default: 10. The default maximum is 10,000 - however,
you can change this default maximum by changing the
<code>index.max_result_window</code> index level parameter.</p>
</td></tr>
<tr><td><code id="Search_+3A_search_type">search_type</code></td>
<td>
<p>(character) The type of the search operation to perform.
Can be <code>query_then_fetch</code> (default) or <code>dfs_query_then_fetch</code>.
Types <code>scan</code> and <code>count</code> are deprecated.
See Elasticsearch docs for more details on the different types of
search that can be performed.</p>
</td></tr>
<tr><td><code id="Search_+3A_lowercase_expanded_terms">lowercase_expanded_terms</code></td>
<td>
<p>(logical) Should terms be automatically
lowercased or not. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Search_+3A_analyze_wildcard">analyze_wildcard</code></td>
<td>
<p>(logical) Should wildcard and prefix queries be
analyzed or not. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Search_+3A_version">version</code></td>
<td>
<p>(logical) Print the document version with each document.</p>
</td></tr>
<tr><td><code id="Search_+3A_lenient">lenient</code></td>
<td>
<p>(logical) If <code>TRUE</code> will cause format based failures (like
providing text to a numeric field) to be ignored. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Search_+3A_body">body</code></td>
<td>
<p>Query, either a list or json.</p>
</td></tr>
<tr><td><code id="Search_+3A_raw">raw</code></td>
<td>
<p>(logical) If <code>FALSE</code> (default), data is parsed to list.
If <code>TRUE</code>, then raw JSON returned</p>
</td></tr>
<tr><td><code id="Search_+3A_asdf">asdf</code></td>
<td>
<p>(logical) If <code>TRUE</code>, use <code><a href="jsonlite.html#topic+fromJSON">fromJSON</a></code>
to parse JSON directly to a data.frame. If <code>FALSE</code> (Default), list
output is given.</p>
</td></tr>
<tr><td><code id="Search_+3A_track_total_hits">track_total_hits</code></td>
<td>
<p>(logical, numeric) If <code>TRUE</code> will always track
the number of hits that match the query accurately. If <code>FALSE</code> will
count documents accurately up to 10000 documents. If <code>is.integer</code> will
count documents accurately up to the number. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="Search_+3A_time_scroll">time_scroll</code></td>
<td>
<p>(character) Specify how long a consistent view of the
index should be maintained for scrolled search, e.g., &quot;30s&quot;, &quot;1m&quot;. See
<a href="#topic+units-time">units-time</a></p>
</td></tr>
<tr><td><code id="Search_+3A_search_path">search_path</code></td>
<td>
<p>(character) The path to use for searching. Default
to <code style="white-space: pre;">&#8288;_search&#8288;</code>, but in some cases you may already have that in the base
url set using <code><a href="#topic+connect">connect()</a></code>, in which case you can set this
to <code>NULL</code></p>
</td></tr>
<tr><td><code id="Search_+3A_stream_opts">stream_opts</code></td>
<td>
<p>(list) A list of options passed to
<code><a href="jsonlite.html#topic+stream_out">stream_out</a></code> - Except that you can't pass <code>x</code> as
that's the data that's streamed out, and pass a file path instead of a
connection to <code>con</code>. <code>pagesize</code> param doesn't do much as
that's more or less controlled by paging with ES.</p>
</td></tr>
<tr><td><code id="Search_+3A_ignore_unavailable">ignore_unavailable</code></td>
<td>
<p>(logical) What to do if an specified index name
doesn't exist. If set to <code>TRUE</code> then those indices are ignored.</p>
</td></tr>
<tr><td><code id="Search_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <code><a href="crul.html#topic+verb-POST">verb-POST</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function name has the &quot;S&quot; capitalized to avoid conflict with the function
<code>base::search</code>. I hate mixing cases, as I think it confuses users, but in this case
it seems neccessary.
</p>


<h3>profile</h3>

<p>The Profile API provides detailed timing information about the execution of
individual components in a search request. See
https://www.elastic.co/guide/en/elasticsearch/reference/current/search-profile.html
for more information
</p>
<p>In a body query, you can set to <code>profile: true</code> to enable profiling
results. e.g.
</p>
<pre>
{
  "profile": true,
  "query" : {
    "match" : { "message" : "some number" }
  }
}
</pre>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html</a>
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Search_uri">Search_uri()</a></code> <code><a href="#topic+Search_template">Search_template()</a></code> <code><a href="#topic+scroll">scroll()</a></code> <code><a href="#topic+count">count()</a></code>
<code><a href="#topic+validate">validate()</a></code> <code><a href="#topic+fielddata">fielddata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# make connection object
(x &lt;- connect())

# load some data
if (!index_exists(x, "shakespeare")) {
  shakespeare &lt;- system.file("examples", "shakespeare_data.json",
    package = "elastic")
  shakespeare &lt;- type_remover(shakespeare)
  invisible(docs_bulk(x, shakespeare))
}
if (!index_exists(x, "gbif")) {
  gbif &lt;- system.file("examples", "gbif_data.json",
    package = "elastic")
  gbif &lt;- type_remover(gbif)
  invisible(docs_bulk(x, gbif))
}
if (!index_exists(x, "plos")) {
  plos &lt;- system.file("examples", "plos_data.json",
    package = "elastic")
  plos &lt;- type_remover(plos)
  invisible(docs_bulk(x, plos))
}


# URI string queries
Search(x, index="shakespeare")
## if you're using an older ES version, you may have types
if (gsub("\\.", "", x$ping()$version$number) &lt; 700) {
  Search(x, index="shakespeare", type="act")
  Search(x, index="shakespeare", type="scene")
  Search(x, index="shakespeare", type="line")
}

## Return certain fields
if (gsub("\\.", "", x$ping()$version$number) &lt; 500) {
  ### ES &lt; v5
  Search(x, index="shakespeare", fields=c('play_name','speaker'))
} else {
  ### ES &gt; v5
  Search(x, index="shakespeare", body = '{
   "_source": ["play_name", "speaker"]
  }')
}

## Search multiple indices
Search(x, index = "gbif")$hits$total$value
Search(x, index = "shakespeare")$hits$total$value
Search(x, index = c("gbif", "shakespeare"))$hits$total$value

## search_type
Search(x, index="shakespeare", search_type = "query_then_fetch")
Search(x, index="shakespeare", search_type = "dfs_query_then_fetch")
### search type "scan" is gone - use time_scroll instead
Search(x, index="shakespeare", time_scroll = "2m")
### search type "count" is gone - use size=0 instead
Search(x, index="shakespeare", size = 0)$hits$total$value

## search exists check
### use size set to 0 and terminate_after set to 1
### if there are &gt; 0 hits, then there are matching documents
Search(x, index="shakespeare", size = 0, terminate_after = 1)

## sorting
### if ES &gt;5, we need to make sure fielddata is turned on for a field 
### before using it for sort 
if (gsub("\\.", "", x$ping()$version$number) &gt;= 500) {
 if (index_exists(x, "shakespeare")) index_delete(x, "shakespeare")
 index_create(x, "shakespeare")
 mapping_create(x, "shakespeare", body = '{
    "properties": {
      "speaker": { 
        "type":     "text",
        "fielddata": true
      }
    }
  }'
 )
 shakespeare &lt;- system.file("examples", "shakespeare_data.json",
   package = "elastic")
 shakespeare &lt;- type_remover(shakespeare)
 invisible(docs_bulk(x, shakespeare))
 z &lt;- Search(x, index="shakespeare", sort="speaker", size = 30)
 vapply(z$hits$hits, function(w) w$`_source`$speaker, "")
}

if (gsub("\\.", "", x$ping()$version$number) &lt; 500) {
  Search(x, index="shakespeare", type="line", sort="speaker:desc", 
    fields='speaker')
  Search(x, index="shakespeare", type="line",
    sort=c("speaker:desc","play_name:asc"), fields=c('speaker','play_name'))
}


## pagination
Search(x, index="shakespeare", size=1)$hits$hits
Search(x, index="shakespeare", size=1, from=1)$hits$hits

## queries
### Search in all fields
Search(x, index="shakespeare", q="york")

### Searchin specific fields
Search(x, index="shakespeare", q="speaker:KING HENRY IV")$hits$total$value

### Exact phrase search by wrapping in quotes
Search(x, index="shakespeare", q='speaker:"KING HENRY IV"')$hits$total$value

### can specify operators between multiple words parenthetically
Search(x, index="shakespeare", q="speaker:(HENRY OR ARCHBISHOP)")$hits$total$value

### where the field line_number has no value (or is missing)
Search(x, index="shakespeare", q="_missing_:line_number")$hits$total$value

### where the field line_number has any non-null value
Search(x, index="shakespeare", q="_exists_:line_number")$hits$total$value

### wildcards, either * or ?
Search(x, index="shakespeare", q="*ay")$hits$total$value
Search(x, index="shakespeare", q="m?y")$hits$total$value

### regular expressions, wrapped in forward slashes
Search(x, index="shakespeare", q="text_entry:/[a-z]/")$hits$total$value

### fuzziness
Search(x, index="shakespeare", q="text_entry:ma~")$hits$total$value
Search(x, index="shakespeare", q="text_entry:the~2")$hits$total$value
Search(x, index="shakespeare", q="text_entry:the~1")$hits$total$value

### Proximity searches
Search(x, index="shakespeare", q='text_entry:"as hath"~5')$hits$total$value
Search(x, index="shakespeare", q='text_entry:"as hath"~10')$hits$total$value

### Ranges, here where line_id value is between 10 and 20
Search(x, index="shakespeare", q="line_id:[10 TO 20]")$hits$total$value

### Grouping
Search(x, index="shakespeare", q="(hath OR as) AND the")$hits$total$value

# Limit number of hits returned with the size parameter
Search(x, index="shakespeare", size=1)

# Give explanation of search in result
Search(x, index="shakespeare", size=1, explain=TRUE)

## terminate query after x documents found
## setting to 1 gives back one document for each shard
Search(x, index="shakespeare", terminate_after=1)
## or set to other number
Search(x, index="shakespeare", terminate_after=2)

## Get version number for each document
Search(x, index="shakespeare", version=TRUE, size=2)

## Get raw data
Search(x, index="shakespeare", raw = TRUE)

## Curl options 
### verbose 
out &lt;- Search(x, index="shakespeare", verbose = TRUE)


# Query DSL searches - queries sent in the body of the request
## Pass in as an R list

### if ES &gt;5, we need to make sure fielddata is turned on for a field 
### before using it for aggregations 
if (gsub("\\.", "", x$ping()$version$number) &gt;= 500) {
  mapping_create(x, "shakespeare", update_all_types = TRUE, body = '{
    "properties": {
      "text_entry": { 
        "type":     "text",
        "fielddata": true
     }
   }
 }')
 aggs &lt;- list(aggs = list(stats = list(terms = list(field = "text_entry"))))
 Search(x, index="shakespeare", body=aggs)
}

### if ES &gt;5, you don't need to worry about fielddata
if (gsub("\\.", "", x$ping()$version$number) &lt; 500) {
   aggs &lt;- list(aggs = list(stats = list(terms = list(field = "text_entry"))))
   Search(x, index="shakespeare", body=aggs)
}

## or pass in as json query with newlines, easy to read
aggs &lt;- '{
    "aggs": {
        "stats" : {
            "terms" : {
                "field" : "speaker"
            }
        }
    }
}'
Search(x, index="shakespeare", body=aggs, asdf=TRUE, size = 0)

## or pass in collapsed json string
aggs &lt;- '{"aggs":{"stats":{"terms":{"field":"text_entry"}}}}'
Search(x, index="shakespeare", body=aggs)


## Aggregations
### Histograms
aggs &lt;- '{
    "aggs": {
        "latbuckets" : {
           "histogram" : {
               "field" : "decimalLatitude",
               "interval" : 5
           }
        }
    }
}'
Search(x, index="gbif", body=aggs, size=0)

### Histograms w/ more options
aggs &lt;- '{
    "aggs": {
        "latbuckets" : {
           "histogram" : {
               "field" : "decimalLatitude",
               "interval" : 5,
               "min_doc_count" : 0,
               "extended_bounds" : {
                   "min" : -90,
                   "max" : 90
               }
           }
        }
    }
}'
Search(x, index="gbif", body=aggs, size=0)

### Ordering the buckets by their doc_count - ascending:
aggs &lt;- '{
    "aggs": {
        "latbuckets" : {
           "histogram" : {
               "field" : "decimalLatitude",
               "interval" : 5,
               "min_doc_count" : 0,
               "extended_bounds" : {
                   "min" : -90,
                   "max" : 90
               },
               "order" : {
                   "_count" : "desc"
               }
           }
        }
    }
}'
out &lt;- Search(x, index="gbif", body=aggs, size=0)
lapply(out$aggregations$latbuckets$buckets, data.frame)

### By default, the buckets are returned as an ordered array. It is also possible to
### request the response as a hash instead keyed by the buckets keys:
aggs &lt;- '{
    "aggs": {
        "latbuckets" : {
           "histogram" : {
               "field" : "decimalLatitude",
               "interval" : 10,
               "keyed" : true
           }
        }
    }
}'
Search(x, index="gbif", body=aggs, size=0)

# match query
match &lt;- '{"query": {"match" : {"text_entry" : "Two Gentlemen"}}}'
Search(x, index="shakespeare", body=match)

# multi-match (multiple fields that is) query
mmatch &lt;- '{"query": {"multi_match" : {"query" : "henry", "fields": ["text_entry","play_name"]}}}'
Search(x, index="shakespeare", body=mmatch)

# bool query
mmatch &lt;- '{
 "query": {
   "bool" : {
     "must_not" : {
       "range" : {
         "speech_number" : {
           "from" : 1, "to": 5
}}}}}}'
Search(x, index="shakespeare", body=mmatch)

# Boosting query
boost &lt;- '{
 "query" : {
  "boosting" : {
      "positive" : {
          "term" : {
              "play_name" : "henry"
          }
      },
      "negative" : {
          "term" : {
              "text_entry" : "thou"
          }
      },
      "negative_boost" : 0.8
    }
 }
}'
Search(x, index="shakespeare", body=boost)

# Fuzzy query
## fuzzy query on numerics
fuzzy &lt;- list(query = list(fuzzy = list(text_entry = "arms")))
Search(x, index="shakespeare", body=fuzzy)$hits$total$value
fuzzy &lt;- list(query = list(fuzzy = list(text_entry = list(value = "arms", fuzziness = 4))))
Search(x, index="shakespeare", body=fuzzy)$hits$total$value

# geoshape query
## not working yets
geo &lt;- list(query = list(geo_shape = list(location = list(shape = list(type = "envelope",
   coordinates = "[[2,10],[10,20]]")))))
geo &lt;- '{
 "query": {
   "geo_shape": {
     "location": {
       "point": {
         "type": "envelope",
         "coordinates": [[2,0],[2.93,100]]
       }
     }
   }
 }
}'
# Search(x, index="gbifnewgeo", body=geo)

# range query
## with numeric
body &lt;- list(query=list(range=list(decimalLongitude=list(gte=1, lte=3))))
Search(x, 'gbif', body=body)$hits$total$value

body &lt;- list(query=list(range=list(decimalLongitude=list(gte=2.9, lte=10))))
Search(x, 'gbif', body=body)$hits$total$value

## with dates
body &lt;- list(query=list(range=list(eventDate=list(gte="2012-01-01", lte="now"))))
Search(x, 'gbif', body=body)$hits$total$value

body &lt;- list(query=list(range=list(eventDate=list(gte="2014-01-01", lte="now"))))
Search(x, 'gbif', body=body)$hits$total$value

# more like this query (more_like_this can be shortened to mlt)
body &lt;- '{
 "query": {
   "more_like_this": {
     "fields": ["title"],
     "like": "and then",
     "min_term_freq": 1,
     "max_query_terms": 12
   }
 }
}'
Search(x, 'plos', body=body)$hits$total$value

body &lt;- '{
 "query": {
   "more_like_this": {
     "fields": ["abstract","title"],
     "like": "cell",
     "min_term_freq": 1,
     "max_query_terms": 12
   }
 }
}'
Search(x, 'plos', body=body)$hits$total$value

# Highlighting
body &lt;- '{
 "query": {
   "query_string": {
     "query" : "cell"
   }
 },
 "highlight": {
   "fields": {
     "title": {"number_of_fragments": 2}
   }
 }
}'
out &lt;- Search(x, 'plos', body=body)
out$hits$total$value
sapply(out$hits$hits, function(x) x$`_source`$title[[1]])

### Common terms query
body &lt;- '{
 "query" : {
   "match": {
      "text_entry": {
         "query": "this is"
      }
   }
 }
}'
Search(x, 'shakespeare', body=body)

## Scrolling search - instead of paging
res &lt;- Search(x, index = 'shakespeare', q="a*", time_scroll="1m")
scroll(x, res$`_scroll_id`)

res &lt;- Search(x, index = 'shakespeare', q="a*", time_scroll="5m")
out &lt;- list()
hits &lt;- 1
while(hits != 0){
  res &lt;- scroll(x, res$`_scroll_id`)
  hits &lt;- length(res$hits$hits)
  if(hits &gt; 0)
    out &lt;- c(out, res$hits$hits)
}

### Sliced scrolling
#### For scroll queries that return a lot of documents it is possible to 
#### split the scroll in multiple slices which can be consumed independently
body1 &lt;- '{
  "slice": {
    "id": 0, 
    "max": 2 
  },
  "query": {
    "match" : {
      "text_entry" : "a*"
    }
  }
}'

body2 &lt;- '{
  "slice": {
    "id": 1, 
    "max": 2 
  },
  "query": {
    "match" : {
      "text_entry" : "a*"
    }
  }
}'

res1 &lt;- Search(x, index = 'shakespeare', time_scroll="1m", body = body1)
res2 &lt;- Search(x, index = 'shakespeare', time_scroll="1m", body = body2)
scroll(x, res1$`_scroll_id`)
scroll(x, res2$`_scroll_id`)

out1 &lt;- list()
hits &lt;- 1
while(hits != 0){
  tmp1 &lt;- scroll(x, res1$`_scroll_id`)
  hits &lt;- length(tmp1$hits$hits)
  if(hits &gt; 0)
    out1 &lt;- c(out1, tmp1$hits$hits)
}

out2 &lt;- list()
hits &lt;- 1
while(hits != 0) {
  tmp2 &lt;- scroll(x, res2$`_scroll_id`)
  hits &lt;- length(tmp2$hits$hits)
  if(hits &gt; 0)
    out2 &lt;- c(out2, tmp2$hits$hits)
}

c(
 lapply(out1, "[[", "_source"),
 lapply(out2, "[[", "_source")
) 



# Using filters
## A bool filter
body &lt;- '{
 "query":{
   "bool": {
     "must_not" : {
       "range" : {
         "year" : { "from" : 2011, "to" : 2012 }
       }
     }
   }
 }
}'
Search(x, 'gbif', body = body)$hits$total$value

## Geo filters - fun!
### Note that filers have many geospatial filter options, but queries 
### have fewer, andrequire a geo_shape mapping

body &lt;- '{
 "mappings": {
     "properties": {
         "location" : {"type" : "geo_point"}
      }
   }
}'
index_recreate(x, index='gbifgeopoint', body=body)
path &lt;- system.file("examples", "gbif_geopoint.json",
  package = "elastic")
path &lt;- type_remover(path)
invisible(docs_bulk(x, path))

### Points within a bounding box
body &lt;- '{
 "query":{
   "bool" : {
     "must" : {
       "match_all" : {}
     },
     "filter":{
        "geo_bounding_box" : {
          "location" : {
            "top_left" : {
              "lat" : 60,
              "lon" : 1
            },
            "bottom_right" : {
              "lat" : 40,
              "lon" : 14
            }
          }
       }
     }
   }
 }
}'
out &lt;- Search(x, 'gbifgeopoint', body = body, size = 300)
out$hits$total$value
do.call(rbind, lapply(out$hits$hits, function(x) x$`_source`$location))

### Points within distance of a point
body &lt;- '{
"query": {
  "bool" : {
    "must" : {
      "match_all" : {}
    },
   "filter" : {
     "geo_distance" : {
       "distance" : "200km",
       "location" : {
         "lon" : 4,
         "lat" : 50
       }
     }
  }
}}}'
out &lt;- Search(x, 'gbifgeopoint', body = body)
out$hits$total$value
do.call(rbind, lapply(out$hits$hits, function(x) x$`_source`$location))

### Points within distance range of a point
body &lt;- '{
 "aggs":{
   "points_within_dist" : {
     "geo_distance" : {
        "field": "location",
        "origin" : "4, 50",
        "ranges": [ 
          {"from" : 200},
          {"to" : 400}
         ]
     }
   }
 }
}'
out &lt;- Search(x, 'gbifgeopoint', body = body)
out$hits$total$value
do.call(rbind, lapply(out$hits$hits, function(x) x$`_source`$location))

### Points within a polygon
body &lt;- '{
 "query":{
   "bool" : {
     "must" : {
       "match_all" : {}
     },
     "filter":{
        "geo_polygon" : {
          "location" : {
             "points" : [
               [80.0, -20.0], [-80.0, -20.0], [-80.0, 60.0], [40.0, 60.0], [80.0, -20.0]
             ]
           }
         }
       }
     }
   }
}'
out &lt;- Search(x, 'gbifgeopoint', body = body)
out$hits$total$value
do.call(rbind, lapply(out$hits$hits, function(x) x$`_source`$location))

### Geoshape filters using queries instead of filters
#### Get data with geojson type location data loaded first
body &lt;- '{
 "mappings": {
     "properties": {
         "location" : {"type" : "geo_shape"}
      }
   }
}'
index_recreate(x, index='geoshape', body=body)
path &lt;- system.file("examples", "gbif_geoshape.json",
  package = "elastic")
path &lt;- type_remover(path)
invisible(docs_bulk(x, path))

#### Get data with a square envelope, w/ point defining upper left and the other
#### defining the lower right
body &lt;- '{
 "query":{
   "geo_shape" : {
     "location" : {
         "shape" : {
           "type": "envelope",
            "coordinates": [[-30, 50],[30, 0]]
         }
       }
     }
   }
}'
out &lt;- Search(x, 'geoshape', body = body)
out$hits$total$value

#### Get data with a circle, w/ point defining center, and radius
body &lt;- '{
 "query":{
   "geo_shape" : {
     "location" : {
         "shape" : {
           "type": "circle",
           "coordinates": [-10, 45],
           "radius": "2000km"
         }
       }
     }
   }
}'
out &lt;- Search(x, 'geoshape', body = body)
out$hits$total$value

#### Use a polygon, w/ point defining center, and radius
body &lt;- '{
 "query":{
   "geo_shape" : {
     "location" : {
         "shape" : {
           "type": "polygon",
           "coordinates":  [
              [ [80.0, -20.0], [-80.0, -20.0], [-80.0, 60.0], [40.0, 60.0], [80.0, -20.0] ]
           ]
         }
       }
     }
   }
}'
out &lt;- Search(x, 'geoshape', body = body)
out$hits$total$value


# Geofilter with WKT
# format follows "BBOX (minlon, maxlon, maxlat, minlat)"
body &lt;- '{
    "query": {
        "bool" : {
            "must" : {
                "match_all" : {}
            },
            "filter" : {
                "geo_bounding_box" : {
                    "location" : {
                        "wkt" : "BBOX (1, 14, 60, 40)"
                    }
                }
            }
        }
    }
}'
out &lt;- Search(x, 'gbifgeopoint', body = body)
out$hits$total$value



# Missing filter
if (gsub("\\.", "", x$ping()$version$number) &lt; 500) {
  ### ES &lt; v5
  body &lt;- '{
   "query":{
     "constant_score" : {
       "filter" : {
         "missing" : { "field" : "play_name" }
       }
     }
    }
  }'
  Search(x, "shakespeare", body = body)
} else {
  ### ES =&gt; v5
  body &lt;- '{
   "query":{
     "bool" : {
       "must_not" : {
         "exists" : { 
           "field" : "play_name" 
         }
       }
    }
   }
  }'
  Search(x, "shakespeare", body = body)
}

# prefix filter
body &lt;- '{
 "query": {
   "bool": {
     "must": {
       "prefix" : {
         "speaker" : "we"
       }
     }
   }
 }
}'
z &lt;- Search(x, "shakespeare", body = body)
z$hits$total$value
vapply(z$hits$hits, "[[", "", c("_source", "speaker"))


# ids filter
if (gsub("\\.", "", x$ping()$version$number) &lt; 500) {
  ### ES &lt; v5
  body &lt;- '{
   "query":{
     "bool": {
       "must": {
         "ids" : {
           "values": ["1","2","10","2000"]
        }
      }
    }
   }
  }'
  z &lt;- Search(x, "shakespeare", body = body)
  z$hits$total$value
  identical(
   c("1","2","10","2000"),
   vapply(z$hits$hits, "[[", "", "_id")
  )
} else {
  body &lt;- '{
   "query":{
     "ids" : {
       "values": ["1","2","10","2000"]
     }
   }
  }'
  z &lt;- Search(x, "shakespeare", body = body)
  z$hits$total$value
  identical(
   c("1","2","10","2000"),
   vapply(z$hits$hits, "[[", "", "_id")
  )
}

# combined prefix and ids filters
if (gsub("\\.", "", x$ping()$version$number) &lt; 500) {
  ### ES &lt; v5
  body &lt;- '{
   "query":{
     "bool" : {
       "should" : {
         "or": [{
           "ids" : {
             "values": ["1","2","3","10","2000"]
           }
         }, {
         "prefix" : {
           "speaker" : "we"
         }
        }
      ]
     }
    }
   }
  }'
  z &lt;- Search(x, "shakespeare", body = body)
  z$hits$total$value
} else {
  ### ES =&gt; v5
  body &lt;- '{
   "query":{
     "bool" : {
       "should" : [
         {
           "ids" : {
             "values": ["1","2","3","10","2000"]
           }
         }, 
         {
           "prefix" : {
             "speaker" : "we"
           }
         }
      ]
     }
    }
  }'
  z &lt;- Search(x, "shakespeare", body = body)
  z$hits$total$value
}

# Suggestions
sugg &lt;- '{
 "query" : {
    "match" : {
      "text_entry" : "late"
     }
 },  
 "suggest" : {
   "sugg" : {
     "text" : "late",
     "term" : {
         "field" : "text_entry"
      }
    }
  }
}'
Search(x, index = "shakespeare", body = sugg, 
  asdf = TRUE, size = 0)$suggest$sugg$options



# stream data out using jsonlite::stream_out
file &lt;- tempfile()
res &lt;- Search(x, "shakespeare", size = 1000, stream_opts = list(file = file))
head(df &lt;- jsonlite::stream_in(file(file)))
NROW(df)
unlink(file)


# get profile data
body &lt;- '{
  "profile": true,
  "query" : {
    "match" : { "text_entry" : "war" }
  }
}'
res &lt;- Search(x, "shakespeare", body = body)
res$profile
# time in nanoseconds across each of the shards
vapply(res$profile$shards, function(w) {
  w$searches[[1]]$query[[1]]$time_in_nanos
}, 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='search_body'>Full text search of Elasticsearch - body requests.</h2><span id='topic+search_body'></span>

<h3>Description</h3>

<p>Full text search of Elasticsearch - body requests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_body(
  conn,
  index = NULL,
  type = NULL,
  raw = FALSE,
  callopts = list(),
  query = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_body_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="search_body_+3A_index">index</code></td>
<td>
<p>Index name</p>
</td></tr>
<tr><td><code id="search_body_+3A_type">type</code></td>
<td>
<p>Document type</p>
</td></tr>
<tr><td><code id="search_body_+3A_raw">raw</code></td>
<td>
<p>If <code>TRUE</code> (default), data is parsed to list. If <code>FALSE</code>, then
raw JSON.</p>
</td></tr>
<tr><td><code id="search_body_+3A_callopts">callopts</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-POST">crul::verb-POST</a></p>
</td></tr>
<tr><td><code id="search_body_+3A_query">query</code></td>
<td>
<p>Query, either a list or json.</p>
</td></tr>
<tr><td><code id="search_body_+3A_...">...</code></td>
<td>
<p>Further args passed on to elastic search HTTP API as parameters.
Not used right now.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
# x &lt;- connect()
# x$ping()

# pass in as an R list
aggs &lt;- list(aggs = list(stats = list(terms = list(field = "text_entry"))))
# search_body(x, index="shakespeare", query=aggs)

# or pass in as json query with newlines, easy to read
aggs &lt;- '{
    "aggs": {
        "stats" : {
            "terms" : {
                "field" : "text_entry"
            }
        }
    }
}'
# search_body(x, index="shakespeare", query=aggs)


# or pass in collapsed json string
aggs &lt;- '{"aggs":{"stats":{"terms":{"field":"text_entry"}}}}'
# search_body(x, index="shakespeare", query=aggs)

# match query
match &lt;- '{"query": {"match" : {"text_entry" : "Two Gentlemen"}}}'
# search_body(x, index="shakespeare", query=match)

# multi-match (multiple fields that is) query
mmatch &lt;- '{"query": {"multi_match" : {"query" : "henry", "fields": 
["text_entry","play_name"]}}}'
# search_body(x, index="shakespeare", query=mmatch)

# bool query
mmatch &lt;- '{
 "query": {
   "bool" : {
     "must_not" : {
       "range" : {
         "speech_number" : {
           "from" : 1, "to": 5
}}}}}}'
# search_body(x, index="shakespeare", query=mmatch)

# Boosting query
boost &lt;- '{
 "query" : {
  "boosting" : {
      "positive" : {
          "term" : {
              "play_name" : "henry"
          }
      },
      "negative" : {
          "term" : {
              "text_entry" : "thou"
          }
      },
      "negative_boost" : 0.2
    }
 }
}'
# search_body(x, index="shakespeare", query=mmatch)

## End(Not run)
</code></pre>

<hr>
<h2 id='search_shards'>Search shards</h2><span id='topic+search_shards'></span>

<h3>Description</h3>

<p>Search shards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_shards(
  conn,
  index = NULL,
  raw = FALSE,
  routing = NULL,
  preference = NULL,
  local = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_shards_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="search_shards_+3A_index">index</code></td>
<td>
<p>One or more indeces</p>
</td></tr>
<tr><td><code id="search_shards_+3A_raw">raw</code></td>
<td>
<p>If <code>TRUE</code> (default), data is parsed to list. If <code>FALSE</code>, then
raw JSON</p>
</td></tr>
<tr><td><code id="search_shards_+3A_routing">routing</code></td>
<td>
<p>A character vector of routing values to take into account
when determining which shards a request would be executed against.</p>
</td></tr>
<tr><td><code id="search_shards_+3A_preference">preference</code></td>
<td>
<p>Controls a preference of which shard replicas to execute
the search request on. By default, the operation is randomized between the
shard replicas. See <a href="#topic+preference">preference</a> for a list of all acceptable
values.</p>
</td></tr>
<tr><td><code id="search_shards_+3A_local">local</code></td>
<td>
<p>(logical) Whether to read the cluster state locally in order
to determine where shards are allocated instead of using the Master node's
cluster state.</p>
</td></tr>
<tr><td><code id="search_shards_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-GET">crul::verb-GET</a></p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-shards.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-shards.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

search_shards(x, index = "plos")
search_shards(x, index = c("plos","gbif"))
search_shards(x, index = "plos", preference='_primary')
search_shards(x, index = "plos", preference='_shards:2')

# curl options
search_shards(x, index = "plos", verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='Search_template'>Search or validate templates</h2><span id='topic+Search_template'></span><span id='topic+Search_template_register'></span><span id='topic+Search_template_get'></span><span id='topic+Search_template_delete'></span><span id='topic+Search_template_render'></span>

<h3>Description</h3>

<p>Search or validate templates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Search_template(conn, body = list(), raw = FALSE, ...)

Search_template_register(conn, template, body = list(), raw = FALSE, ...)

Search_template_get(conn, template, ...)

Search_template_delete(conn, template, ...)

Search_template_render(conn, body = list(), raw = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Search_template_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="Search_template_+3A_body">body</code></td>
<td>
<p>Query, either a list or json.</p>
</td></tr>
<tr><td><code id="Search_template_+3A_raw">raw</code></td>
<td>
<p>(logical) If <code>FALSE</code> (default), data is parsed to list.
If <code>TRUE</code>, then raw JSON returned</p>
</td></tr>
<tr><td><code id="Search_template_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-POST">crul::verb-POST</a></p>
</td></tr>
<tr><td><code id="Search_template_+3A_template">template</code></td>
<td>
<p>(character) a template name</p>
</td></tr>
</table>


<h3>Template search</h3>

<p>With <code>Search_template</code> you can search with a template, using
mustache templating. Added in Elasticsearch v1.1
</p>


<h3>Template render</h3>

<p>With <code>Search_template_render</code> you validate a template without
conducting the search. Added in Elasticsearch v2.0
</p>


<h3>Pre-registered templates</h3>

<p>Register a template with <code>Search_template_register</code>. You can get
the template with <code>Search_template_get</code> and delete the template
with <code>Search_template_delete</code>
</p>
<p>You can also pre-register search templates by storing them in the
<code>config/scripts</code> directory, in a file using the .mustache
extension. In order to execute the stored template, reference it
by it's name under the template key, like
<code style="white-space: pre;">&#8288;"file": "templateName", ...&#8288;</code>
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Search">Search()</a></code>, <code><a href="#topic+Search_uri">Search_uri()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

if (!index_exists(x, "iris")) {
  invisible(docs_bulk(x, iris, "iris"))
}

body1 &lt;- '{
  "inline" : {
    "query": { "match" : { "{{my_field}}" : "{{my_value}}" } },
    "size" : "{{my_size}}"
  },
  "params" : {
    "my_field" : "Species",
    "my_value" : "setosa",
    "my_size" : 3
  }
}'
Search_template(x, body = body1)

body2 &lt;- '{
 "inline": {
   "query": {
      "match": {
          "Species": "{{query_string}}"
      }
   }
 },
 "params": {
   "query_string": "versicolor"
 }
}'
Search_template(x, body = body2)

# pass in a list
mylist &lt;- list(
  inline = list(query = list(match = list(`{{my_field}}` = "{{my_value}}"))),
  params = list(my_field = "Species", my_value = "setosa", my_size = 3L)
)
Search_template(x, body = mylist)

## Validating templates w/ Search_template_render()
Search_template_render(x, body = body1)
Search_template_render(x, body = body2)

## pre-registered templates
### register a template
if (x$es_ver() &lt;= 520) {
  body3 &lt;- '{
    "template": {
       "query": {
           "match": {
               "Species": "{{query_string}}"
           }
       }
     }
  }'
  Search_template_register(x, 'foobar', body = body3)
} else {
  body3 &lt;- '{
   "script": {
     "lang": "mustache",
       "source": {
         "query": {
           "match": {
             "Species": "{{query_string}}"
           }
         }
       }
     }
  }'
  Search_template_register(x, 'foobar', body = body3)
}

### get template
Search_template_get(x, 'foobar')

### use the template
body4 &lt;- '{
 "id": "foobar",
  	"params": {
      "query_string": "setosa"
  }
}'
Search_template(x, body = body4)

### delete the template
Search_template_delete(x, 'foobar')

## End(Not run)
</code></pre>

<hr>
<h2 id='Search_uri'>Full text search of Elasticsearch with URI search</h2><span id='topic+Search_uri'></span>

<h3>Description</h3>

<p>Full text search of Elasticsearch with URI search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Search_uri(
  conn,
  index = NULL,
  type = NULL,
  q = NULL,
  df = NULL,
  analyzer = NULL,
  default_operator = NULL,
  explain = NULL,
  source = NULL,
  fields = NULL,
  sort = NULL,
  track_scores = NULL,
  timeout = NULL,
  terminate_after = NULL,
  from = NULL,
  size = NULL,
  search_type = NULL,
  lowercase_expanded_terms = NULL,
  analyze_wildcard = NULL,
  version = NULL,
  lenient = NULL,
  raw = FALSE,
  asdf = FALSE,
  track_total_hits = TRUE,
  search_path = "_search",
  stream_opts = list(),
  ignore_unavailable = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Search_uri_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect</a></code></p>
</td></tr>
<tr><td><code id="Search_uri_+3A_index">index</code></td>
<td>
<p>Index name, one or more</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_type">type</code></td>
<td>
<p>Document type. Note that <code>type</code> is deprecated in
Elasticsearch v7 and greater, and removed in Elasticsearch v8. We will
strive to support types for folks using older ES versions</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_q">q</code></td>
<td>
<p>The query string (maps to the query_string query, see Query String
Query for more details). See
https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html
for documentation and examples.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_df">df</code></td>
<td>
<p>(character) The default field to use when no field prefix is
defined within the query.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_analyzer">analyzer</code></td>
<td>
<p>(character) The analyzer name to be used when analyzing the
query string.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_default_operator">default_operator</code></td>
<td>
<p>(character) The default operator to be used, can be
<code>AND</code> or <code>OR</code>. Default: <code>OR</code></p>
</td></tr>
<tr><td><code id="Search_uri_+3A_explain">explain</code></td>
<td>
<p>(logical) For each hit, contain an explanation of how
scoring of the hits was computed. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="Search_uri_+3A_source">source</code></td>
<td>
<p>(logical) Set to <code>FALSE</code> to disable retrieval of the
<code>_source</code> field. You can also retrieve part of the document by
using <code>_source_include</code> &amp; <code>_source_exclude</code> (see the <code>body</code>
documentation for more details). You can also include a comma-delimited
string of fields from the source document that you want back. See also
the <strong>fields</strong> parameter</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_fields">fields</code></td>
<td>
<p>(character) The selective stored fields of the document to
return for each hit. Not specifying any value will cause no fields to return.
Note that in Elasticsearch v5 and greater, <strong>fields</strong> parameter has
changed to <strong>stored_fields</strong>, which is not on by default. You can
however, pass fields to <strong>source</strong> parameter</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_sort">sort</code></td>
<td>
<p>(character) Sorting to perform. Can either be in the form of
fieldName, or <code>fieldName:asc</code>/<code>fieldName:desc</code>. The fieldName
can either be an actual field within the document, or the special
<code>_score</code> name to indicate sorting based on scores. There can be several
sort parameters (order is important).</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_track_scores">track_scores</code></td>
<td>
<p>(logical) When sorting, set to <code>TRUE</code> in order to
still track scores and return them as part of each hit.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_timeout">timeout</code></td>
<td>
<p>(numeric) A search timeout, bounding the search request to
be executed within the specified time value and bail with the hits
accumulated up to that point when expired. Default: no timeout.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_terminate_after">terminate_after</code></td>
<td>
<p>(numeric) The maximum number of documents to collect
for each shard, upon reaching which the query execution will terminate
early. If set, the response will have a boolean field terminated_early to
indicate whether the query execution has actually terminated_early.
Default: no terminate_after</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_from">from</code></td>
<td>
<p>(character) The starting from index of the hits to return.
Pass in as a character string to avoid problems with large number
conversion to scientific notation. Default: 0</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_size">size</code></td>
<td>
<p>(character) The number of hits to return. Pass in as a
character string to avoid problems with large number conversion to
scientific notation. Default: 10. The default maximum is 10,000 - however,
you can change this default maximum by changing the
<code>index.max_result_window</code> index level parameter.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_search_type">search_type</code></td>
<td>
<p>(character) The type of the search operation to perform.
Can be <code>query_then_fetch</code> (default) or <code>dfs_query_then_fetch</code>.
Types <code>scan</code> and <code>count</code> are deprecated.
See Elasticsearch docs for more details on the different types of
search that can be performed.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_lowercase_expanded_terms">lowercase_expanded_terms</code></td>
<td>
<p>(logical) Should terms be automatically
lowercased or not. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_analyze_wildcard">analyze_wildcard</code></td>
<td>
<p>(logical) Should wildcard and prefix queries be
analyzed or not. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_version">version</code></td>
<td>
<p>(logical) Print the document version with each document.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_lenient">lenient</code></td>
<td>
<p>(logical) If <code>TRUE</code> will cause format based failures (like
providing text to a numeric field) to be ignored. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="Search_uri_+3A_raw">raw</code></td>
<td>
<p>(logical) If <code>FALSE</code> (default), data is parsed to list.
If <code>TRUE</code>, then raw JSON returned</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_asdf">asdf</code></td>
<td>
<p>(logical) If <code>TRUE</code>, use <code><a href="jsonlite.html#topic+fromJSON">fromJSON</a></code>
to parse JSON directly to a data.frame. If <code>FALSE</code> (Default), list
output is given.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_track_total_hits">track_total_hits</code></td>
<td>
<p>(logical, numeric) If <code>TRUE</code> will always track
the number of hits that match the query accurately. If <code>FALSE</code> will
count documents accurately up to 10000 documents. If <code>is.integer</code> will
count documents accurately up to the number. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="Search_uri_+3A_search_path">search_path</code></td>
<td>
<p>(character) The path to use for searching. Default
to <code style="white-space: pre;">&#8288;_search&#8288;</code>, but in some cases you may already have that in the base
url set using <code><a href="#topic+connect">connect()</a></code>, in which case you can set this
to <code>NULL</code></p>
</td></tr>
<tr><td><code id="Search_uri_+3A_stream_opts">stream_opts</code></td>
<td>
<p>(list) A list of options passed to
<code><a href="jsonlite.html#topic+stream_out">stream_out</a></code> - Except that you can't pass <code>x</code> as
that's the data that's streamed out, and pass a file path instead of a
connection to <code>con</code>. <code>pagesize</code> param doesn't do much as
that's more or less controlled by paging with ES.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_ignore_unavailable">ignore_unavailable</code></td>
<td>
<p>(logical) What to do if an specified index name
doesn't exist. If set to <code>TRUE</code> then those indices are ignored.</p>
</td></tr>
<tr><td><code id="Search_uri_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <code><a href="crul.html#topic+verb-POST">verb-POST</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fielddata">fielddata()</a></code>
</p>
<p><code><a href="#topic+Search">Search()</a></code> <code><a href="#topic+Search_template">Search_template()</a></code> <code><a href="#topic+count">count()</a></code> <code><a href="#topic+fielddata">fielddata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

# URI string queries
Search_uri(x, index="shakespeare")
## if you're using an older ES version, you may have types
if (gsub("\\.", "", x$ping()$version$number) &lt; 700) {
Search_uri(x, index="shakespeare", type="act")
Search_uri(x, index="shakespeare", type="scene")
Search_uri(x, index="shakespeare", type="line")
}

## Return certain fields
if (gsub("\\.", "", ping()$version$number) &lt; 500) {
  ### ES &lt; v5
  Search_uri(x, index="shakespeare", fields=c('play_name','speaker'))
} else {
  ### ES &gt; v5
  Search_uri(x, index="shakespeare", source=c('play_name','speaker'))
}

## Search many indices
Search_uri(x, index = "gbif")$hits$total$value
Search_uri(x, index = "shakespeare")$hits$total$value
Search_uri(x, index = c("gbif", "shakespeare"))$hits$total$value

## search_type
## NOTE: If you're in ES V5 or greater, see \code{?fielddata}
Search_uri(x, index="shakespeare", search_type = "query_then_fetch")
Search_uri(x, index="shakespeare", search_type = "dfs_query_then_fetch")
# Search_uri(x, index="shakespeare", search_type = "scan") # only when scrolling

## sorting
Search_uri(x, index="shakespeare", sort="text_entry")
if (gsub("\\.", "", x$ping()$version$number) &lt; 500) {
  Search_uri(x, index="shakespeare", sort="speaker:desc", fields='speaker')
  Search_uri(x, index="shakespeare", sort=c("speaker:desc","play_name:asc"),
    fields=c('speaker','play_name'))
}

## pagination
Search_uri(x, index="shakespeare", size=1)$hits$hits
Search_uri(x, index="shakespeare", size=1, from=1)$hits$hits

## queries
### Search in all fields
Search_uri(x, index="shakespeare", q="york")

### Searchin specific fields
Search_uri(x, index="shakespeare", q="speaker:KING HENRY IV")$hits$total$value

### Exact phrase search by wrapping in quotes
Search_uri(x, index="shakespeare", q='speaker:"KING HENRY IV"')$hits$total$value

### can specify operators between multiple words parenthetically
Search_uri(x, index="shakespeare", q="speaker:(HENRY OR ARCHBISHOP)")$hits$total$value

### where the field line_number has no value (or is missing)
Search_uri(x, index="shakespeare", q="_missing_:line_number")$hits$total$value

### where the field line_number has any non-null value
Search_uri(x, index="shakespeare", q="_exists_:line_number")$hits$total$value

### wildcards, either * or ?
Search_uri(x, index="shakespeare", q="*ay")$hits$total$value
Search_uri(x, index="shakespeare", q="m?y")$hits$total$value

### regular expressions, wrapped in forward slashes
Search_uri(x, index="shakespeare", q="text_entry:/[a-z]/")$hits$total$value

### fuzziness
Search_uri(x, index="shakespeare", q="text_entry:ma~")$hits$total$value
Search_uri(x, index="shakespeare", q="text_entry:the~2")$hits$total$value
Search_uri(x, index="shakespeare", q="text_entry:the~1")$hits$total$value

### Proximity searches
Search_uri(x, index="shakespeare", q='text_entry:"as hath"~5')$hits$total$value
Search_uri(x, index="shakespeare", q='text_entry:"as hath"~10')$hits$total$value

### Ranges, here where line_id value is between 10 and 20
Search_uri(x, index="shakespeare", q="line_id:[10 TO 20]")$hits$total$value

### Grouping
Search_uri(x, index="shakespeare", q="(hath OR as) AND the")$hits$total$value

# Limit number of hits returned with the size parameter
Search_uri(x, index="shakespeare", size=1)

# Give explanation of search in result
Search_uri(x, index="shakespeare", size=1, explain=TRUE)

## terminate query after x documents found
## setting to 1 gives back one document for each shard
Search_uri(x, index="shakespeare", terminate_after=1)
## or set to other number
Search_uri(x, index="shakespeare", terminate_after=2)

## Get version number for each document
Search_uri(x, index="shakespeare", version=TRUE, size=2)

## Get raw data
Search_uri(x, index="shakespeare", raw=TRUE)

## Curl options
### verbose
out &lt;- Search_uri(x, index="shakespeare", verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='searchapis'>Overview of search functions</h2><span id='topic+searchapis'></span>

<h3>Description</h3>

<p>Overview of search functions
</p>


<h3>Details</h3>

<p>Elasticsearch search APIs include the following functions:
</p>

<ul>
<li> <p><code><a href="#topic+Search">Search()</a></code> - Search using the Query DSL via the body of the request.
</p>
</li>
<li> <p><code><a href="#topic+Search_uri">Search_uri()</a></code> - Search using the URI search API only. This may be
needed for servers that block POST requests for security, or maybe you don't need
complicated requests, in which case URI only requests are suffice.
</p>
</li>
<li> <p><code><a href="#topic+msearch">msearch()</a></code> - Multi Search - execute several search requests defined
in a file passed to <code>msearch</code>
</p>
</li>
<li> <p><code><a href="#topic+search_shards">search_shards()</a></code> - Search shards.
</p>
</li>
<li> <p><code><a href="#topic+count">count()</a></code> - Get counts for various searches.
</p>
</li>
<li> <p><code><a href="#topic+explain">explain()</a></code> - Computes a score explanation for a query and a specific
document. This can give useful feedback whether a document matches or didn't match
a specific query.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code> - Validate a search
</p>
</li>
<li> <p><code><a href="#topic+field_stats">field_stats()</a></code> - Search field statistics
</p>
</li>
<li> <p><code><a href="#topic+percolate">percolate()</a></code> - Store queries into an index then, via the percolate API,
define documents to retrieve these queries.
</p>
</li></ul>

<p>More will be added soon.
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html</a>
</p>

<hr>
<h2 id='tasks'>Elasticsearch tasks endpoints</h2><span id='topic+tasks'></span><span id='topic+tasks_cancel'></span>

<h3>Description</h3>

<p>Elasticsearch tasks endpoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tasks(
  conn,
  task_id = NULL,
  nodes = NULL,
  actions = NULL,
  parent_task_id = NULL,
  detailed = FALSE,
  group_by = NULL,
  wait_for_completion = FALSE,
  timeout = NULL,
  raw = FALSE,
  ...
)

tasks_cancel(
  conn,
  node_id = NULL,
  task_id = NULL,
  nodes = NULL,
  actions = NULL,
  parent_task_id = NULL,
  detailed = FALSE,
  group_by = NULL,
  wait_for_completion = FALSE,
  timeout = NULL,
  raw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tasks_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="tasks_+3A_task_id">task_id</code></td>
<td>
<p>a task id</p>
</td></tr>
<tr><td><code id="tasks_+3A_nodes">nodes</code></td>
<td>
<p>(character) The nodes</p>
</td></tr>
<tr><td><code id="tasks_+3A_actions">actions</code></td>
<td>
<p>(character) Actions</p>
</td></tr>
<tr><td><code id="tasks_+3A_parent_task_id">parent_task_id</code></td>
<td>
<p>(character) A parent task ID</p>
</td></tr>
<tr><td><code id="tasks_+3A_detailed">detailed</code></td>
<td>
<p>(character) get detailed results. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="tasks_+3A_group_by">group_by</code></td>
<td>
<p>(character) &quot;nodes&quot; (default, i.e., NULL) or &quot;parents&quot;</p>
</td></tr>
<tr><td><code id="tasks_+3A_wait_for_completion">wait_for_completion</code></td>
<td>
<p>(logical) wait for completion. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="tasks_+3A_timeout">timeout</code></td>
<td>
<p>(integer) timeout time</p>
</td></tr>
<tr><td><code id="tasks_+3A_raw">raw</code></td>
<td>
<p>If <code>TRUE</code> (default), data is parsed to list. If <code>FALSE</code>, then
raw JSON.</p>
</td></tr>
<tr><td><code id="tasks_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-GET">crul::verb-GET</a> or
<a href="crul.html#topic+verb-POST">crul::verb-POST</a></p>
</td></tr>
<tr><td><code id="tasks_+3A_node_id">node_id</code></td>
<td>
<p>a node id</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/tasks.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/tasks.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()

tasks(x)
# tasks(x, parent_task_id = "1234")

# delete a task
# tasks_cancel(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='termvectors'>Termvectors</h2><span id='topic+termvectors'></span>

<h3>Description</h3>

<p>Termvectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>termvectors(
  conn,
  index,
  type = NULL,
  id = NULL,
  body = list(),
  pretty = TRUE,
  field_statistics = TRUE,
  fields = NULL,
  offsets = TRUE,
  parent = NULL,
  payloads = TRUE,
  positions = TRUE,
  realtime = TRUE,
  preference = "random",
  routing = NULL,
  term_statistics = FALSE,
  version = NULL,
  version_type = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="termvectors_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="termvectors_+3A_index">index</code></td>
<td>
<p>(character) The index in which the document resides.</p>
</td></tr>
<tr><td><code id="termvectors_+3A_type">type</code></td>
<td>
<p>(character) The type of the document. optional</p>
</td></tr>
<tr><td><code id="termvectors_+3A_id">id</code></td>
<td>
<p>(character) The id of the document, when not specified a doc
param should be supplied.</p>
</td></tr>
<tr><td><code id="termvectors_+3A_body">body</code></td>
<td>
<p>(character) Define parameters and or supply a document to get
termvectors for</p>
</td></tr>
<tr><td><code id="termvectors_+3A_pretty">pretty</code></td>
<td>
<p>(logical) pretty print. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="termvectors_+3A_field_statistics">field_statistics</code></td>
<td>
<p>(character) Specifies if document count, sum
of document frequencies and sum of total term frequencies should be
returned. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="termvectors_+3A_fields">fields</code></td>
<td>
<p>(character) A comma-separated list of fields to return.</p>
</td></tr>
<tr><td><code id="termvectors_+3A_offsets">offsets</code></td>
<td>
<p>(character) Specifies if term offsets should be returned.
Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="termvectors_+3A_parent">parent</code></td>
<td>
<p>(character) Parent id of documents.</p>
</td></tr>
<tr><td><code id="termvectors_+3A_payloads">payloads</code></td>
<td>
<p>(character) Specifies if term payloads should be returned.
Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="termvectors_+3A_positions">positions</code></td>
<td>
<p>(character) Specifies if term positions should be returned.
Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="termvectors_+3A_realtime">realtime</code></td>
<td>
<p>(character) Specifies if request is real-time as opposed to
near-real-time (Default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="termvectors_+3A_preference">preference</code></td>
<td>
<p>(character) Specify the node or shard the operation
should be performed on (Default: <code>random</code>).</p>
</td></tr>
<tr><td><code id="termvectors_+3A_routing">routing</code></td>
<td>
<p>(character) Specific routing value.</p>
</td></tr>
<tr><td><code id="termvectors_+3A_term_statistics">term_statistics</code></td>
<td>
<p>(character) Specifies if total term frequency and
document frequency should be returned. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="termvectors_+3A_version">version</code></td>
<td>
<p>(character) Explicit version number for concurrency control</p>
</td></tr>
<tr><td><code id="termvectors_+3A_version_type">version_type</code></td>
<td>
<p>(character) Specific version type, valid choices are:
'internal', 'external', 'external_gte', 'force'</p>
</td></tr>
<tr><td><code id="termvectors_+3A_...">...</code></td>
<td>
<p>Curl args passed on to <a href="crul.html#topic+verb-POST">crul::verb-POST</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns information and statistics on terms in the fields of a
particular document. The document could be stored in the index or
artificially provided by the user (Added in 1.4). Note that for
documents stored in the index, this is a near realtime API as the term
vectors are not available until the next refresh.
</p>


<h3>References</h3>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mtermvectors">mtermvectors()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()

if (!index_exists(x, 'plos')) {
  plosdat &lt;- system.file("examples", "plos_data.json",
    package = "elastic")
  plosdat &lt;- type_remover(plosdat)
  invisible(docs_bulk(x, plosdat))
}
if (!index_exists(x, 'omdb')) {
  omdb &lt;- system.file("examples", "omdb.json", package = "elastic")
  omdb &lt;- type_remover(omdb)
  invisible(docs_bulk(x, omdb))
}

body &lt;- '{
  "fields" : ["title"],
  "offsets" : true,
  "positions" : true,
  "term_statistics" : true,
  "field_statistics" : true
}'
termvectors(x, 'plos', id = 29, body = body)

body &lt;- '{
  "fields" : ["Plot"],
  "offsets" : true,
  "positions" : true,
  "term_statistics" : true,
  "field_statistics" : true
}'
termvectors(x, 'omdb', id = Search(x, "omdb", size=1)$hits$hits[[1]]$`_id`,
body = body)

## End(Not run)
</code></pre>

<hr>
<h2 id='tokenizer_set'>Tokenizer operations</h2><span id='topic+tokenizer_set'></span>

<h3>Description</h3>

<p>Tokenizer operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tokenizer_set(conn, index, body, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tokenizer_set_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="tokenizer_set_+3A_index">index</code></td>
<td>
<p>(character) A character vector of index names</p>
</td></tr>
<tr><td><code id="tokenizer_set_+3A_body">body</code></td>
<td>
<p>Query, either a list or json.</p>
</td></tr>
<tr><td><code id="tokenizer_set_+3A_...">...</code></td>
<td>
<p>Curl options passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Scott Chamberlain <a href="mailto:myrmecocystus@gmail.com">myrmecocystus@gmail.com</a>
</p>


<h3>References</h3>

<p>https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# connection setup
(x &lt;- connect())

# set tokenizer

## NGram tokenizer
body &lt;- '{
        "settings" : {
             "analysis" : {
                 "analyzer" : {
                     "my_ngram_analyzer" : {
                         "tokenizer" : "my_ngram_tokenizer"
                     }
                 },
                 "tokenizer" : {
                     "my_ngram_tokenizer" : {
                         "type" : "nGram",
                         "min_gram" : "2",
                         "max_gram" : "3",
                         "token_chars": [ "letter", "digit" ]
                     }
                 }
             }
      }
}'
if (index_exists('test1')) index_delete('test1')
tokenizer_set(index = "test1", body=body)
index_analyze(text = "hello world", index = "test1", 
  analyzer='my_ngram_analyzer')

## End(Not run)
</code></pre>

<hr>
<h2 id='type_remover'>Utility function to remove 'type' from bulk load files</h2><span id='topic+type_remover'></span>

<h3>Description</h3>

<p>Types are being removed from Elasticsearch. This little function
aims to help remove &quot;_type&quot; fields from bulk newline-delimited JSON
files. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type_remover(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type_remover_+3A_file">file</code></td>
<td>
<p>(character) a file path, required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Looks for any lines that have an &quot;index&quot; key, then drops
any &quot;_type&quot; keys in the hash given by the &quot;index&quot; key.
</p>
<p>You can of course manually modify these files as an alternative,
in a text editor or with command line tools like sed, etc.
</p>


<h3>Value</h3>

<p>a file path for a temporary file with the types removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
z &lt;- system.file("examples/omdb.json", package = "elastic")
readLines(z, 6)
ff &lt;- type_remover(z)
readLines(ff, 6)
unlink(ff)

## End(Not run)
</code></pre>

<hr>
<h2 id='units-distance'>Distance units</h2><span id='topic+units-distance'></span>

<h3>Description</h3>

<p>Wherever distances need to be specified, such as the distance parameter in the
Geo Distance Filter), the default unit if none is specified is the meter. Distances
can be specified in other units, such as &quot;1km&quot; or &quot;2mi&quot; (2 miles).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
mi or miles </td><td style="text-align: left;"> Mile </td>
</tr>
<tr>
 <td style="text-align: left;">
yd or yards </td><td style="text-align: left;"> Yard </td>
</tr>
<tr>
 <td style="text-align: left;">
ft or feet </td><td style="text-align: left;"> Feet </td>
</tr>
<tr>
 <td style="text-align: left;">
in or inch </td><td style="text-align: left;"> Inch </td>
</tr>
<tr>
 <td style="text-align: left;">
km or kilometers </td><td style="text-align: left;"> Kilometer </td>
</tr>
<tr>
 <td style="text-align: left;">
m or meters </td><td style="text-align: left;"> Meter </td>
</tr>
<tr>
 <td style="text-align: left;">
cm or centimeters </td><td style="text-align: left;"> Centimeter </td>
</tr>
<tr>
 <td style="text-align: left;">
mm or millimeters </td><td style="text-align: left;"> Millimeter </td>
</tr>
<tr>
 <td style="text-align: left;">
NM, nmi or nauticalmiles </td><td style="text-align: left;"> Nautical mile </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The precision parameter in the Geohash Cell Filter accepts distances with the above
units, but if no unit is specified, then the precision is interpreted as the length
of the geohash.
</p>


<h3>See Also</h3>

<p><a href="#topic+units-time">units-time</a>
</p>

<hr>
<h2 id='units-time'>Time units</h2><span id='topic+units-time'></span>

<h3>Description</h3>

<p>Whenever durations need to be specified, eg for a timeout parameter, the duration can
be specified as a whole number representing time in milliseconds, or as a time value
like 2d for 2 days. The supported units are:
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
y </td><td style="text-align: left;"> Year </td>
</tr>
<tr>
 <td style="text-align: left;">
M </td><td style="text-align: left;"> Month </td>
</tr>
<tr>
 <td style="text-align: left;">
w </td><td style="text-align: left;"> Week </td>
</tr>
<tr>
 <td style="text-align: left;">
d </td><td style="text-align: left;"> Day </td>
</tr>
<tr>
 <td style="text-align: left;">
h </td><td style="text-align: left;"> Hour </td>
</tr>
<tr>
 <td style="text-align: left;">
m </td><td style="text-align: left;"> Minute </td>
</tr>
<tr>
 <td style="text-align: left;">
s </td><td style="text-align: left;"> Second </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+units-distance">units-distance</a>
</p>

<hr>
<h2 id='validate'>Validate a search</h2><span id='topic+validate'></span>

<h3>Description</h3>

<p>Validate a search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate(conn, index, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_+3A_conn">conn</code></td>
<td>
<p>an Elasticsearch connection object, see <code><a href="#topic+connect">connect()</a></code></p>
</td></tr>
<tr><td><code id="validate_+3A_index">index</code></td>
<td>
<p>Index name. Required.</p>
</td></tr>
<tr><td><code id="validate_+3A_type">type</code></td>
<td>
<p>Document type. Optional.</p>
</td></tr>
<tr><td><code id="validate_+3A_...">...</code></td>
<td>
<p>Additional args passed on to <code><a href="#topic+Search">Search()</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Search">Search()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- connect()

if (!index_exists(x, "twitter")) index_create(x, "twitter")
docs_create(x, 'twitter', id=1, body = list(
   "user" = "foobar", 
   "post_date" = "2014-01-03",
   "message" = "trying out Elasticsearch"
 )
)
validate(x, "twitter", q='user:foobar')
validate(x, "twitter", q='user:foobar')

body &lt;- '{
"query" : {
  "bool" : {
    "must" : {
      "query_string" : {
        "query" : "*:*"
      }
    },
    "filter" : {
      "term" : { "user" : "kimchy" }
    }
  }
}
}'
validate(x, "twitter", body = body)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
