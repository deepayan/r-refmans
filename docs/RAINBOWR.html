<!DOCTYPE html><html lang="en"><head><title>Help for package RAINBOWR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RAINBOWR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RAINBOWR'><p>RAINBOWR:</p>
Perform Genome-Wide Asscoiation Study (GWAS) By Kernel-Based Methods</a></li>
<li><a href='#adjustGRM'><p>Function to adjust genomic relationship matrix (GRM) with subpopulations</p></a></li>
<li><a href='#calcGRM'><p>Function to calculate genomic relationship matrix (GRM)</p></a></li>
<li><a href='#CalcThreshold'><p>Function to calculate threshold for GWAS</p></a></li>
<li><a href='#convertBlockList'><p>Function to convert haplotype block list from PLINK to RAINBOWR format</p></a></li>
<li><a href='#cumsumPos'><p>Function to calculate cumulative position (beyond chromosome)</p></a></li>
<li><a href='#design.Z'><p>Function to generate design matrix (Z)</p></a></li>
<li><a href='#EM3.cpp'><p>Equation of mixed model for multi-kernel (slow, general version)</p></a></li>
<li><a href='#EM3.general'><p>Equation of mixed model for multi-kernel including using other packages (with other packages, much faster than EM3.cpp)</p></a></li>
<li><a href='#EM3.linker.cpp'><p>Equation of mixed model for multi-kernel (fast, for limited cases)</p></a></li>
<li><a href='#EM3.op'><p>Equation of mixed model for multi-kernel using other packages (much faster than EM3.cpp)</p></a></li>
<li><a href='#EMM.cpp'><p>Equation of mixed model for one kernel, a wrapper of two methods</p></a></li>
<li><a href='#EMM1.cpp'><p>Equation of mixed model for one kernel, GEMMA-based method (inplemented by Rcpp)</p></a></li>
<li><a href='#EMM2.cpp'><p>Equation of mixed model for one kernel, EMMA-based method (inplemented by Rcpp)</p></a></li>
<li><a href='#estNetwork'><p>Function to estimate &amp; plot haplotype network</p></a></li>
<li><a href='#estPhylo'><p>Function to estimate &amp; plot phylogenetic tree</p></a></li>
<li><a href='#genesetmap'><p>Function to generate map for gene set</p></a></li>
<li><a href='#genetrait'><p>Generate pseudo phenotypic values</p></a></li>
<li><a href='#is.diag'><p>Function to judge the square matrix whether it is diagonal matrix or not</p></a></li>
<li><a href='#MAF.cut'><p>Function to remove the minor alleles</p></a></li>
<li><a href='#make.full'><p>Change a matrix to full-rank matrix</p></a></li>
<li><a href='#manhattan'><p>Draw manhattan plot</p></a></li>
<li><a href='#manhattan.plus'><p>Add points of -log10(p) corrected by kernel methods to manhattan plot</p></a></li>
<li><a href='#manhattan2'><p>Draw manhattan plot (another method)</p></a></li>
<li><a href='#manhattan3'><p>Draw the effects of epistasis (3d plot and 2d plot)</p></a></li>
<li><a href='#modify.data'><p>Function to modify genotype and phenotype data to match</p></a></li>
<li><a href='#parallel.compute'><p>Function to parallelize computation with various methods</p></a></li>
<li><a href='#plotHaploNetwork'><p>Function to plot haplotype network from the estimated results</p></a></li>
<li><a href='#plotPhyloTree'><p>Function to plot phylogenetic tree from the estimated results</p></a></li>
<li><a href='#qq'><p>Draw qq plot</p></a></li>
<li><a href='#RGWAS.epistasis'><p>Check epistatic effects by kernel-based GWAS (genome-wide association studies)</p></a></li>
<li><a href='#RGWAS.menu'><p>Print the R code which you should perform for RAINBOWR GWAS</p></a></li>
<li><a href='#RGWAS.multisnp'><p>Testing multiple SNPs simultaneously for GWAS</p></a></li>
<li><a href='#RGWAS.multisnp.interaction'><p>Testing multiple SNPs and their interaction with some kernel simultaneously for GWAS</p></a></li>
<li><a href='#RGWAS.normal'><p>Perform normal GWAS (test each single SNP)</p></a></li>
<li><a href='#RGWAS.normal.interaction'><p>Perform normal GWAS including interaction (test each single SNP)</p></a></li>
<li><a href='#RGWAS.twostep'><p>Perform normal GWAS (genome-wide association studies) first, then perform SNP-set GWAS for relatively significant markers</p></a></li>
<li><a href='#RGWAS.twostep.epi'><p>Perform normal GWAS (genome-wide association studies) first, then check epistatic effects for relatively significant markers</p></a></li>
<li><a href='#Rice_geno_map'><p>Physical map of rice genome</p></a></li>
<li><a href='#Rice_geno_score'><p>Marker genotype of rice genome</p></a></li>
<li><a href='#Rice_haplo_block'><p>Physical map of rice genome</p></a></li>
<li><a href='#Rice_pheno'><p>Phenotype data of rice field trial</p></a></li>
<li><a href='#Rice_Zhao_etal'><p>Rice_Zhao_etal:</p></a></li>
<li><a href='#score.calc'><p>Calculate -log10(p) for single-SNP GWAS</p></a></li>
<li><a href='#score.calc.epistasis.LR'><p>Calculate -log10(p) of epistatic effects by LR test</p></a></li>
<li><a href='#score.calc.epistasis.LR.MC'><p>Calculate -log10(p) of epistatic effects by LR test (multi-cores)</p></a></li>
<li><a href='#score.calc.epistasis.score'><p>Calculate -log10(p) of epistatic effects with score test</p></a></li>
<li><a href='#score.calc.epistasis.score.MC'><p>Calculate -log10(p) of epistatic effects with score test (multi-cores)</p></a></li>
<li><a href='#score.calc.int'><p>Calculate -log10(p) for single-SNP GWAS with interaction</p></a></li>
<li><a href='#score.calc.int.MC'><p>Calculate -log10(p) for single-SNP GWAS with interaction (multi-cores)</p></a></li>
<li><a href='#score.calc.LR'><p>Calculate -log10(p) of each SNP-set by the LR test</p></a></li>
<li><a href='#score.calc.LR.int'><p>Calculate -log10(p) of each SNP-set and its interaction with kernels by the LR test</p></a></li>
<li><a href='#score.calc.LR.int.MC'><p>Calculate -log10(p) of each SNP-set and its interaction with kernels by the LR test (multi-cores)</p></a></li>
<li><a href='#score.calc.LR.MC'><p>Calculate -log10(p) of each SNP-set by the LR test (multi-cores)</p></a></li>
<li><a href='#score.calc.MC'><p>Calculate -log10(p) for single-SNP GWAS (multi-cores)</p></a></li>
<li><a href='#score.calc.score'><p>Calculate -log10(p) of each SNP-set by the score test</p></a></li>
<li><a href='#score.calc.score.MC'><p>Calculate -log10(p) of each SNP-set by the score test (multi-cores)</p></a></li>
<li><a href='#score.cpp'><p>Calculte -log10(p) by score test (slow, for general cases)</p></a></li>
<li><a href='#score.linker.cpp'><p>Calculte -log10(p) by score test (fast, for limited cases)</p></a></li>
<li><a href='#See'><p>Function to view the first part of data (like head(), tail())</p></a></li>
<li><a href='#spectralG.cpp'><p>Perform spectral decomposition (inplemented by Rcpp)</p></a></li>
<li><a href='#SS_gwas'><p>Calculate some summary statistics of GWAS (genome-wide association studies) for simulation study</p></a></li>
<li><a href='#welcome_to_RGWAS'><p>Function to greet to users</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genome-Wide Association Study with SNP-Set Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.35</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kosuke Hamazaki &lt;hamazaki@ut-biomet.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>By using 'RAINBOWR' (Reliable Association INference By Optimizing Weights with R), users can test multiple SNPs (Single Nucleotide Polymorphisms) simultaneously by kernel-based (SNP-set) methods. This package can also be applied to haplotype-based GWAS (Genome-Wide Association Study). Users can test not only additive effects but also dominance and epistatic effects. In detail, please check our paper on PLOS Computational Biology: Kosuke Hamazaki and Hiroyoshi Iwata (2020) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1007663">doi:10.1371/journal.pcbi.1007663</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, Matrix, cluster, MASS, pbmcapply, optimx, methods, ape,
stringr, pegas, rrBLUP, expm, here, htmlwidgets, Rfast, gaston,
MM4LMM, R.utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, plotly, haplotypes, adegenet, ggplot2,
ggtree, scatterpie, phylobase, furrr, future, progressr,
foreach, doParallel, data.table</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-03 08:29:24 UTC; hamazaki</td>
</tr>
<tr>
<td>Author:</td>
<td>Kosuke Hamazaki [aut, cre],
  Hiroyoshi Iwata [aut, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-03 09:12:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='RAINBOWR'>RAINBOWR:
Perform Genome-Wide Asscoiation Study (GWAS) By Kernel-Based Methods</h2><span id='topic+RAINBOWR-package'></span><span id='topic+RAINBOWR'></span>

<h3>Description</h3>

<p>By using 'RAINBOWR' (Reliable Association INference By Optimizing Weights with R), users can test multiple SNPs (Single Nucleotide Polymorphisms) simultaneously by kernel-based (SNP-set) methods.
Users can test not only additive effects but also dominance and epistatic effects.
In detail, please check our preprint on bioRxiv: Kosuke Hamazaki and Hiroyoshi Iwata (2019) &lt;doi:10.1101/612028&gt;.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kosuke Hamazaki <a href="mailto:hamazaki@ut-biomet.org">hamazaki@ut-biomet.org</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Hiroyoshi Iwata <a href="mailto:aiwata@mail.ecc.u-tokyo.ac.jp">aiwata@mail.ecc.u-tokyo.ac.jp</a> [contributor]
</p>
</li></ul>


<hr>
<h2 id='adjustGRM'>Function to adjust genomic relationship matrix (GRM) with subpopulations</h2><span id='topic+adjustGRM'></span>

<h3>Description</h3>

<p>Function to adjust genomic relationship matrix (GRM) with subpopulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustGRM(
  y,
  X = NULL,
  ZETA,
  subpopInfo = NULL,
  nSubpop = 5,
  nPcsFindCluster = 10,
  include.epistasis = FALSE,
  package.MM = "gaston"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjustGRM_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="adjustGRM_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="adjustGRM_+3A_zeta">ZETA</code></td>
<td>
<p>A list of variance matrices and its design matrices of random effects.
You can use only one kernel matrix for this function.
For example, ZETA = list(A = list(Z = Z.A, K = K.A)) (A for additive)
Please set names of lists &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="adjustGRM_+3A_subpopinfo">subpopInfo</code></td>
<td>
<p>The information on group memberships (e.g., subgroups for the population) will be required.
You can set a vector of group names (or clustering ids) for each genotype as this argument. This vector should be factor.</p>
</td></tr>
<tr><td><code id="adjustGRM_+3A_nsubpop">nSubpop</code></td>
<td>
<p>When 'subpopInfo = NULL', 'subpopInfo' will be automatically determined by using <code><a href="adegenet.html#topic+find.clusters">find.clusters</a></code> function.
You should specify the number of groups by this argument to decide 'subpopInfo'.</p>
</td></tr>
<tr><td><code id="adjustGRM_+3A_npcsfindcluster">nPcsFindCluster</code></td>
<td>
<p>Number of principal components to be used for 'adegenet::find.clusters'.
This argument is used inly when 'subpopInfo' is 'NULL'.</p>
</td></tr>
<tr><td><code id="adjustGRM_+3A_include.epistasis">include.epistasis</code></td>
<td>
<p>Whether or not including the genome-wide epistastic effects into the model
to adjust ZETA.</p>
</td></tr>
<tr><td><code id="adjustGRM_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A List of
</p>
<dl>
<dt>$ZETAAdjust</dt><dd><p>Adjusted ZETA including only one kernel.</p>
</dd>
<dt>$subpopInfo</dt><dd><p>A vector of 'subpopInfo' used in this function.</p>
</dd>
<dt>$covariates</dt><dd><p>A matrix of covariates used in the mixed effects model.</p>
</dd>
</dl>
<p>#' </p>
<dl>
<dt>$nullModel</dt><dd><p>Results of mixed-effects model for multiple kernels.</p>
</dd>
<dt>$nSubpop</dt><dd><p>'nSubpop' used in this function.</p>
</dd>
<dt>$include.epistasis</dt><dd><p>'include.epistasis' used in this function.</p>
</dd>
</dl>



<h3>References</h3>

<p>Rio S, Mary-Huard T, Moreau L, Bauland C, Palaffre C, et al. (2020)
Disentangling group specific QTL allele effects from
genetic background epistasis using admixed individuals in GWAS:
An application to maize flowering. PLOS Genetics 16(3): e1008241.
</p>

<hr>
<h2 id='calcGRM'>Function to calculate genomic relationship matrix (GRM)</h2><span id='topic+calcGRM'></span>

<h3>Description</h3>

<p>Function to calculate genomic relationship matrix (GRM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcGRM(
  genoMat,
  methodGRM = "addNOIA",
  subpop = NULL,
  kernel.h = "tuned",
  returnWMat = FALSE,
  probaa = NULL,
  probAa = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcGRM_+3A_genomat">genoMat</code></td>
<td>
<p>A <code class="reqn">N \times M</code> matrix of marker genotype</p>
</td></tr>
<tr><td><code id="calcGRM_+3A_methodgrm">methodGRM</code></td>
<td>
<p>Method to calculate genomic relationship matrix (GRM). We offer the following methods;
&quot;addNOIA&quot;, &quot;domNOIA&quot;, &quot;A.mat&quot;, &quot;linear&quot;, &quot;gaussian&quot;, &quot;exponential&quot;, &quot;correlation&quot;.
For NOIA methods, please refer to Vitezica et al. 2017.</p>
</td></tr>
<tr><td><code id="calcGRM_+3A_subpop">subpop</code></td>
<td>
<p>Sub-population names corresponding to each individual.
By utilizing 'subpop' argument, you can consider the difference of allele frequencies
between sub-populations when computing the genomic relationship matrix. This argument is only valid when NOIA methods are selected.</p>
</td></tr>
<tr><td><code id="calcGRM_+3A_kernel.h">kernel.h</code></td>
<td>
<p>The hyper parameter for gaussian or exponential kernel.
If kernel.h = &quot;tuned&quot;, this hyper parameter is calculated as the median of off-diagonals of distance matrix of genotype data.</p>
</td></tr>
<tr><td><code id="calcGRM_+3A_returnwmat">returnWMat</code></td>
<td>
<p>If this argument is TRUE, we will return W matrix instead of GRM.
Here, W satisfies <code class="reqn">GRM = W W ^ {T}</code>. W corresponds to H matix in Vitezica et al. 2017.</p>
</td></tr>
<tr><td><code id="calcGRM_+3A_probaa">probaa</code></td>
<td>
<p>Probability of being homozygous for the reference allele for each marker.
If NULL (default), it will be calculated from genoMat.</p>
</td></tr>
<tr><td><code id="calcGRM_+3A_probaa">probAa</code></td>
<td>
<p>Probability of being heterozygous for the reference and alternative alleles for each marker
If NULL (default), it will be calculated from genoMat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>genomic relationship matrix (GRM)
</p>


<h3>References</h3>

<p>Vitezica, Z.G., Legarra, A., Toro, M.A. and Varona, L. (2017) Orthogonal Estimates of Variances for Additive, Dominance, and Epistatic Effects in Populations. Genetics. 206(3): 1297-1307.
</p>
<p>Endelman, J.B. and Jannink, J.L. (2012) Shrinkage Estimation of the Realized Relationship Matrix. G3 Genes, Genomes, Genet. 2(11): 1405-1413.
</p>

<hr>
<h2 id='CalcThreshold'>Function to calculate threshold for GWAS</h2><span id='topic+CalcThreshold'></span>

<h3>Description</h3>

<p>Calculate thresholds for the given GWAS (genome-wide association studies) result by the Benjamini-Hochberg method or Bonferroni method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcThreshold(input, sig.level = 0.05, method = "BH")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcThreshold_+3A_input">input</code></td>
<td>
<p>Data frame of GWAS results where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="CalcThreshold_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level for the threshold. The default is 0.05. You can also assign vector of sinificance levels.</p>
</td></tr>
<tr><td><code id="CalcThreshold_+3A_method">method</code></td>
<td>
<p>Three methods are offered:
</p>
<p>&quot;BH&quot;: Benjamini-Hochberg method. To control FDR, use this method.
</p>
<p>&quot;Bonf&quot;: Bonferroni method. To perform simple correction of multiple testing, use this method.
</p>
<p>&quot;Sidak&quot;: Sidak method.
</p>
<p>You can also assign two of them by 'method = c(&quot;BH&quot;, &quot;Bonf&quot;)'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the threshold. If there is no threshold, it returns NA.
</p>


<h3>References</h3>

<p>Benjamini, Y. and Hochberg, Y. (1995) Controlling the false discovery rate:
a practical and powerful approach to multiple testing. J R Stat Soc. 57(1): 289-300.
</p>
<p>Storey, J.D. and Tibshirani, R. (2003) Statistical significance for genomewide studies. Proc Natl Acad Sci. 100(16): 9440-9445.
</p>

<hr>
<h2 id='convertBlockList'>Function to convert haplotype block list from PLINK to RAINBOWR format</h2><span id='topic+convertBlockList'></span>

<h3>Description</h3>

<p>Function to convert haplotype block list from PLINK to RAINBOWR format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertBlockList(
  fileNameBlocksDetPlink,
  map,
  blockNamesHead = "haploblock_",
  imputeOneSNP = FALSE,
  insertZeros = FALSE,
  n.core = 1,
  parallel.method = "mclapply",
  count = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertBlockList_+3A_filenameblocksdetplink">fileNameBlocksDetPlink</code></td>
<td>
<p>File name of the haplotype block list generated by PLINK (See reference).
The file names must contain &quot;.blocks.det&quot; in the tail.</p>
</td></tr>
<tr><td><code id="convertBlockList_+3A_map">map</code></td>
<td>
<p>Data frame with the marker names in the first column.
The second and third columns contain the chromosome and map position.</p>
</td></tr>
<tr><td><code id="convertBlockList_+3A_blocknameshead">blockNamesHead</code></td>
<td>
<p>You can specify the header of block names for the returned data.frame.</p>
</td></tr>
<tr><td><code id="convertBlockList_+3A_imputeonesnp">imputeOneSNP</code></td>
<td>
<p>As default, blocks including only one SNP will be discarded from the returned data.
If you want to include them when creating haplotype-block list for RAINBOWR,
please set 'imputeOneSNP = TRUE'.</p>
</td></tr>
<tr><td><code id="convertBlockList_+3A_insertzeros">insertZeros</code></td>
<td>
<p>When naming blocks, whether or not inserting zeros to the name of blocks.
For example, if there are 1,000 blocks in total, the function will name the block 1 as
&quot;block_1&quot; when 'insertZeros = FALSE' and &quot;block_0001&quot; when 'insertZeros = TRUE'.</p>
</td></tr>
<tr><td><code id="convertBlockList_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="convertBlockList_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="convertBlockList_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>


<p>A data.frame object of
</p>
<dl>
<dt>$block</dt><dd><p>Block names for SNP-set methods in RAINBOWR</p>
</dd>
<dt>$marker</dt><dd><p>Marker names in each block for SNP-set methods in RAINBOWR</p>
</dd>
</dl>

<p>Purcell, S. and Chang, C. (2018). PLINK 1.9, www.cog-genomics.org/plink/1.9/.
Chang CC, Chow CC, Tellier LCAM, Vattikuti S, Purcell SM, Lee JJ (2015) Second-generation PLINK: rising to the challenge of larger and richer datasets. GigaScience, 4.
Gaunt T, Rodr√≠guez S, Day I (2007) Cubic exact solutions for the estimation of pairwise haplotype frequencies: implications for linkage disequilibrium analyses and a web tool 'CubeX'. BMC Bioinformatics, 8.
Taliun D, Gamper J, Pattaro C (2014) Efficient haplotype block recognition of very long and dense genetic sequences. BMC Bioinformatics, 15.
</p>

<hr>
<h2 id='cumsumPos'>Function to calculate cumulative position (beyond chromosome)</h2><span id='topic+cumsumPos'></span>

<h3>Description</h3>

<p>Function to calculate cumulative position (beyond chromosome)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumsumPos(map)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumsumPos_+3A_map">map</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cumulative position (beyond chromosome) will be returned.
</p>

<hr>
<h2 id='design.Z'>Function to generate design matrix (Z)</h2><span id='topic+design.Z'></span>

<h3>Description</h3>

<p>Function to generate design matrix (Z)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design.Z(pheno.labels, geno.names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design.Z_+3A_pheno.labels">pheno.labels</code></td>
<td>
<p>A vector of genotype (line; accesion; variety) names which correpond to phenotypic values.</p>
</td></tr>
<tr><td><code id="design.Z_+3A_geno.names">geno.names</code></td>
<td>
<p>A vector of genotype (line; accesion; variety) names for marker genotype data (duplication is not recommended).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Z of <code class="reqn">y = X\beta + Zu + e</code>. Design matrix, which is useful for GS or GWAS.
</p>

<hr>
<h2 id='EM3.cpp'>Equation of mixed model for multi-kernel (slow, general version)</h2><span id='topic+EM3.cpp'></span>

<h3>Description</h3>

<p>This function solves the following multi-kernel linear mixed effects model.
</p>
<p><code class="reqn">y = X \beta + \sum _{l=1} ^ {L} Z _ {l} u _ {l} + \epsilon</code>
</p>
<p>where <code class="reqn">Var[y] = \sum _{l=1} ^ {L} Z _ {l} K _ {l} Z _ {l}' \sigma _ {l} ^ 2 + I \sigma _ {e} ^ {2}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM3.cpp(
  y,
  X0 = NULL,
  ZETA,
  eigen.G = NULL,
  eigen.SGS = NULL,
  tol = NULL,
  n.core = NA,
  optimizer = "nlminb",
  traceInside = 0,
  n.thres = 450,
  REML = TRUE,
  pred = TRUE,
  return.u.always = TRUE,
  return.u.each = TRUE,
  return.Hinv = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM3.cpp_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_x0">X0</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_zeta">ZETA</code></td>
<td>
<p>A list of variance matrices and its design matrices of random effects. You can use more than one kernel matrix.
For example, ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D)) (A for additive, D for dominance)
Please set names of lists &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_eigen.sgs">eigen.SGS</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">SGS</code>, where <code class="reqn">S = I - X(X'X)^{-1}X'</code>, <code class="reqn">G = ZKZ'</code>.
You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_tol">tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of G = ZKZ'.
Eigen vectors whose eigen values are less than &quot;tol&quot; argument will be omitted from results.
If tol is NULL, top 'n' eigen values will be effective.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_traceinside">traceInside</code></td>
<td>
<p>Perform trace for the optimzation if traceInside &gt;= 1, and this argument shows the frequency of reports.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_n.thres">n.thres</code></td>
<td>
<p>If <code class="reqn">n &gt;= n.thres</code>, perform EMM1.cpp. Else perform EMM2.cpp.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_reml">REML</code></td>
<td>
<p>You can choose which method you will use, &quot;REML&quot; or &quot;ML&quot;.
If REML = TRUE, you will perform &quot;REML&quot;, and if REML = FALSE, you will perform &quot;ML&quot;.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_pred">pred</code></td>
<td>
<p>If TRUE, the fitting values of y is returned.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_return.u.always">return.u.always</code></td>
<td>
<p>If TRUE, BLUP ('u'; <code class="reqn">u</code>) will be returned.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_return.u.each">return.u.each</code></td>
<td>
<p>If TRUE, the function also computes each BLUP corresponding
to different kernels (when solving multi-kernel mixed-effects model). It takes
additional time compared to the one with 'return.u.each = FALSE'.</p>
</td></tr>
<tr><td><code id="EM3.cpp_+3A_return.hinv">return.Hinv</code></td>
<td>
<p>If TRUE, <code class="reqn">H ^ {-1} = (Var[y] / \sum _{l=1} ^ {L} \sigma _ {l} ^ 2) ^ {-1}</code>
will be computed. It also returns <code class="reqn">V ^ {-1} = (Var[y]) ^ {-1}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$y.pred</dt><dd><p>The fitting values of y <code class="reqn">y = X\beta + Zu</code></p>
</dd>
<dt>$Vu</dt><dd><p>Estimator for <code class="reqn">\sigma^2_u</code>, all of the genetic variance</p>
</dd>
<dt>$Ve</dt><dd><p>Estimator for <code class="reqn">\sigma^2_e</code></p>
</dd>
<dt>$beta</dt><dd><p>BLUE(<code class="reqn">\beta</code>)</p>
</dd>
<dt>$u</dt><dd><p>BLUP(Sum of <code class="reqn">Zu</code>)</p>
</dd>
<dt>$u.each</dt><dd><p>BLUP(Each <code class="reqn">u</code>)</p>
</dd>
<dt>$weights</dt><dd><p>The proportion of each genetic variance (corresponding to each kernel of ZETA) to Vu</p>
</dd>
<dt>$LL</dt><dd><p>Maximized log-likelihood (full or restricted, depending on method)</p>
</dd>
<dt>$Vinv</dt><dd><p>The inverse of <code class="reqn">V = Vu \times ZKZ' + Ve \times I</code></p>
</dd>
<dt>$Hinv</dt><dd><p>The inverse of <code class="reqn">H = ZKZ' + \lambda I</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure
in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis
for association studies. Nat Genet. 44(7): 821-824.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



  ### Import RAINBOWR
  require(RAINBOWR)
  
  ### Load example datasets
  data("Rice_Zhao_etal")
  Rice_geno_score &lt;- Rice_Zhao_etal$genoScore
  Rice_geno_map &lt;- Rice_Zhao_etal$genoMap
  Rice_pheno &lt;- Rice_Zhao_etal$pheno
  
  ### View each dataset
  See(Rice_geno_score)
  See(Rice_geno_map)
  See(Rice_pheno)
  
  ### Select one trait for example
  trait.name &lt;- "Flowering.time.at.Arkansas"
  y &lt;- as.matrix(Rice_pheno[, trait.name, drop = FALSE])
  
  ### Remove SNPs whose MAF &lt;= 0.05
  x.0 &lt;- t(Rice_geno_score)
  MAF.cut.res &lt;- MAF.cut(x.0 = x.0, map.0 = Rice_geno_map)
  x &lt;- MAF.cut.res$x
  map &lt;- MAF.cut.res$map
  
  
  ### Estimate additive genomic relationship matrix (GRM) &amp; epistatic relationship matrix
  K.A &lt;- calcGRM(genoMat = x) 
  K.AA &lt;- K.A * K.A   ### additive x additive epistatic effects
  
  
  ### Modify data
  Z &lt;- design.Z(pheno.labels = rownames(y),
                geno.names = rownames(K.A))  ### design matrix for random effects
  pheno.mat &lt;- y[rownames(Z), , drop = FALSE]
  ZETA &lt;- list(A = list(Z = Z, K = K.A),
               AA = list(Z = Z, K = K.AA))
  
  
  ### Solve multi-kernel linear mixed effects model (2 random efects)
  EM3.res &lt;- EM3.cpp(y = pheno.mat, X0 = NULL, ZETA = ZETA)
  (Vu &lt;- EM3.res$Vu)   ### estimated genetic variance
  (Ve &lt;- EM3.res$Ve)   ### estimated residual variance
  (weights &lt;- EM3.res$weights)   ### estimated proportion of two genetic variances
  (herit &lt;- Vu * weights / (Vu + Ve))   ### genomic heritability (additive, additive x additive)
  
  (beta &lt;- EM3.res$beta)   ### Here, this is an intercept.
  u.each &lt;- EM3.res$u.each   ### estimated genotypic values (additive, additive x additive)
  See(u.each)
  
  
  ### Perform genomic prediction with 10-fold cross validation (multi-kernel)
  noNA &lt;- !is.na(c(pheno.mat))   ### NA (missing) in the phenotype data
  
  phenoNoNA &lt;- pheno.mat[noNA, , drop = FALSE]   ### remove NA
  ZETANoNA &lt;- ZETA
  ZETANoNA &lt;- lapply(X = ZETANoNA, FUN = function (List) {
    List$Z &lt;- List$Z[noNA, ]
    
    return(List)
  })   ### remove NA
  
  
  nFold &lt;- 10    ### # of folds
  nLine &lt;- nrow(phenoNoNA)
  idCV &lt;- sample(1:nLine %% nFold)   ### assign random ids for cross-validation
  idCV[idCV == 0] &lt;- nFold
  
  yPred &lt;- rep(NA, nLine)
  
  for (noCV in 1:nFold) {
    print(paste0("Fold: ", noCV))
    yTrain &lt;- phenoNoNA
    yTrain[idCV == noCV, ] &lt;- NA   ### prepare test data
    
    EM3.resCV &lt;- EM3.cpp(y = yTrain, X0 = NULL, ZETA = ZETANoNA)   ### prediction
    yTest &lt;-  EM3.resCV$y.pred     ### predicted values
    
    yPred[idCV == noCV] &lt;- yTest[idCV == noCV]
  }
  
  ### Plot the results
  plotRange &lt;- range(phenoNoNA, yPred)
  plot(x = phenoNoNA, y = yPred,xlim = plotRange, ylim = plotRange,
       xlab = "Observed values", ylab = "Predicted values",
       main = "Results of Genomic Prediction (multi-kernel)",
       cex.lab = 1.5, cex.main = 1.5, cex.axis = 1.3)
  abline(a = 0, b = 1, col = 2, lwd = 2, lty = 2)
  R2 &lt;- cor(x = phenoNoNA[, 1], y = yPred) ^ 2
  text(x = plotRange[2] - 10,
       y = plotRange[1] + 10,
       paste0("R2 = ", round(R2, 3)), 
       cex = 1.5)

</code></pre>

<hr>
<h2 id='EM3.general'>Equation of mixed model for multi-kernel including using other packages (with other packages, much faster than EM3.cpp)</h2><span id='topic+EM3.general'></span>

<h3>Description</h3>

<p>This function solves the following multi-kernel linear mixed effects model
using <code><a href="MM4LMM.html#topic+MMEst">MMEst</a></code> function in 'MM4LMM' package,
<code><a href="gaston.html#topic+lmm.aireml">lmm.aireml</a></code> or <code><a href="gaston.html#topic+lmm.diago">lmm.diago</a></code> functions in 'gaston' package,
or <code><a href="#topic+EM3.cpp">EM3.cpp</a></code> function in 'RAINBOWR' package.
</p>
<p><code class="reqn">y = X \beta + \sum _{l=1} ^ {L} Z _ {l} u _ {l} + \epsilon</code>
</p>
<p>where <code class="reqn">Var[y] = \sum _{l=1} ^ {L} Z _ {l} K _ {l} Z _ {l}' \sigma _ {l} ^ 2 + I \sigma _ {e} ^ {2}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM3.general(
  y,
  X0 = NULL,
  ZETA,
  eigen.G = NULL,
  package = "gaston",
  tol = NULL,
  n.core = 1,
  optimizer = "nlminb",
  REML = TRUE,
  pred = TRUE,
  return.u.always = TRUE,
  return.u.each = TRUE,
  return.Hinv = TRUE,
  recheck.RAINBOWR = TRUE,
  var.ratio.range = c(1e-09, 1e+07)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM3.general_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_x0">X0</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_zeta">ZETA</code></td>
<td>
<p>A list of variance matrices and its design matrices of random effects. You can use more than one kernel matrix.
For example, ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D)) (A for additive, D for dominance)
Please set names of lists &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_package">package</code></td>
<td>
<p>Package name to be used in this function. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_tol">tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of G = ZKZ'.
Eigen vectors whose eigen values are less than &quot;tol&quot; argument will be omitted from results.
If tol is NULL, top 'n' eigen values will be effective.</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
(&lsquo;n.core' will be replaced by 1 for 'package = &rsquo;gaston'')</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process.
We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.
This argument is only valid when &lsquo;package = &rsquo;RAINBOWR''.</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_reml">REML</code></td>
<td>
<p>You can choose which method you will use, &quot;REML&quot; or &quot;ML&quot;.
If REML = TRUE, you will perform &quot;REML&quot;, and if REML = FALSE, you will perform &quot;ML&quot;.</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_pred">pred</code></td>
<td>
<p>If TRUE, the fitting values of y is returned.</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_return.u.always">return.u.always</code></td>
<td>
<p>When using the &quot;gaston&quot; package with missing values or
using the &quot;MM4LMM&quot; package (with/without missings), computing BLUP will take
some time in addition to solving the mixed-effects model. You can choose
whether BLUP ('u'; <code class="reqn">u</code>) will be returned or not.</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_return.u.each">return.u.each</code></td>
<td>
<p>If TRUE, the function also computes each BLUP corresponding
to different kernels (when solving multi-kernel mixed-effects model). It takes
additional time compared to the one with 'return.u.each = FALSE'  when using packages other than 'RAINBOWR'.</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_return.hinv">return.Hinv</code></td>
<td>
<p>If TRUE, <code class="reqn">H ^ {-1} = (Var[y] / \sum _{l=1} ^ {L} \sigma _ {l} ^ 2) ^ {-1}</code>
will be computed. It also returns <code class="reqn">V ^ {-1} = (Var[y]) ^ {-1}</code>.
It will take some time in addition to solving the mixed-effects model when using packages other than 'RAINBOWR'.</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_recheck.rainbowr">recheck.RAINBOWR</code></td>
<td>
<p>When you use the package other than 'RAINBOWR' and the ratio of variance components
is out of the range of 'var.ratio.range', the function will solve the mixed-effects model again
with 'RAINBOWR' package, if 'recheck.RAINBOWR = TRUE'.</p>
</td></tr>
<tr><td><code id="EM3.general_+3A_var.ratio.range">var.ratio.range</code></td>
<td>
<p>The range of variance components to check that the results by
the package other than RAINBOWR is correct or not when 'recheck.RAINBOWR = TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$y.pred</dt><dd><p>The fitting values of y <code class="reqn">y = X\beta + Zu</code></p>
</dd>
<dt>$Vu</dt><dd><p>Estimator for <code class="reqn">\sigma^2_u</code>, all of the genetic variance</p>
</dd>
<dt>$Ve</dt><dd><p>Estimator for <code class="reqn">\sigma^2_e</code></p>
</dd>
<dt>$beta</dt><dd><p>BLUE(<code class="reqn">\beta</code>)</p>
</dd>
<dt>$u</dt><dd><p>BLUP(Sum of <code class="reqn">Zu</code>)</p>
</dd>
<dt>$u.each</dt><dd><p>BLUP(Each <code class="reqn">u</code>)</p>
</dd>
<dt>$weights</dt><dd><p>The proportion of each genetic variance (corresponding to each kernel of ZETA) to Vu</p>
</dd>
<dt>$LL</dt><dd><p>Maximized log-likelihood (full or restricted, depending on method)</p>
</dd>
<dt>$Vinv</dt><dd><p>The inverse of <code class="reqn">V = Vu \times ZKZ' + Ve \times I</code></p>
</dd>
<dt>$Hinv</dt><dd><p>The inverse of <code class="reqn">H = ZKZ' + \lambda I</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure
in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis
for association studies. Nat Genet. 44(7): 821-824.
</p>
<p>Johnson, D. L., &amp; Thompson, R. (1995). Restricted maximum likelihood estimation of variance
components for univariate animal models using sparse matrix techniques and average information.
Journal of dairy science, 78(2), 449-456.
</p>
<p>Hunter, D. R., &amp; Lange, K. (2004). A tutorial on MM algorithms.
The American Statistician, 58(1), 30-37.
</p>
<p>Zhou, H., Hu, L., Zhou, J., &amp; Lange, K. (2015). MM algorithms for variance components models.
arXiv preprint arXiv:1509.07426.
</p>
<p>Gilmour, A. R., Thompson, R., &amp; Cullis, B. R. (1995), Average information REML:
an efficient algorithm for variance parameter estimation in linear mixed models,
Biometrics, 1440-1450.
</p>


<h3>See Also</h3>

<p><code><a href="MM4LMM.html#topic+MMEst">MMEst</a></code>, <code><a href="gaston.html#topic+lmm.aireml">lmm.aireml</a></code>, <code><a href="gaston.html#topic+lmm.diago">lmm.diago</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



  ### Import RAINBOWR
  require(RAINBOWR)
  
  ### Load example datasets
  data("Rice_Zhao_etal")
  Rice_geno_score &lt;- Rice_Zhao_etal$genoScore
  Rice_geno_map &lt;- Rice_Zhao_etal$genoMap
  Rice_pheno &lt;- Rice_Zhao_etal$pheno
  
  ### View each dataset
  See(Rice_geno_score)
  See(Rice_geno_map)
  See(Rice_pheno)
  
  ### Select one trait for example
  trait.name &lt;- "Flowering.time.at.Arkansas"
  y &lt;- as.matrix(Rice_pheno[, trait.name, drop = FALSE])
  
  ### Remove SNPs whose MAF &lt;= 0.05
  x.0 &lt;- t(Rice_geno_score)
  MAF.cut.res &lt;- MAF.cut(x.0 = x.0, map.0 = Rice_geno_map)
  x &lt;- MAF.cut.res$x
  map &lt;- MAF.cut.res$map
  
  
  ### Estimate additive genomic relationship matrix (GRM) &amp; epistatic relationship matrix
  K.A &lt;- calcGRM(genoMat = x) 
  K.AA &lt;- K.A * K.A   ### additive x additive epistatic effects
  
  
  ### Modify data
  Z &lt;- design.Z(pheno.labels = rownames(y),
                geno.names = rownames(K.A))  ### design matrix for random effects
  pheno.mat &lt;- y[rownames(Z), , drop = FALSE]
  ZETA &lt;- list(A = list(Z = Z, K = K.A),
               AA = list(Z = Z, K = K.AA))
  
  
  ### Solve multi-kernel linear mixed effects model using gaston package (2 random efects)
  EM3.gaston.res &lt;- EM3.general(y = pheno.mat, X0 = NULL, ZETA = ZETA,
                                package = "gaston", return.u.always = TRUE,
                                pred = TRUE, return.u.each = TRUE,
                                return.Hinv = TRUE)
  (Vu &lt;- EM3.gaston.res$Vu)   ### estimated genetic variance
  (Ve &lt;- EM3.gaston.res$Ve)   ### estimated residual variance
  (weights &lt;- EM3.gaston.res$weights)   ### estimated proportion of two genetic variances
  (herit &lt;- Vu * weights / (Vu + Ve))   ### genomic heritability (additive, additive x additive)
  
  (beta &lt;- EM3.gaston.res$beta)   ### Here, this is an intercept.
  u.each &lt;- EM3.gaston.res$u.each   ### estimated genotypic values (additive, additive x additive)
  See(u.each)
  
  
  ### Perform genomic prediction with 10-fold cross validation using gaston package (multi-kernel)
  noNA &lt;- !is.na(c(pheno.mat))   ### NA (missing) in the phenotype data
  
  phenoNoNA &lt;- pheno.mat[noNA, , drop = FALSE]   ### remove NA
  ZETANoNA &lt;- ZETA
  ZETANoNA &lt;- lapply(X = ZETANoNA, FUN = function (List) {
    List$Z &lt;- List$Z[noNA, ]
    
    return(List)
  })   ### remove NA
  
  
  nFold &lt;- 10    ### # of folds
  nLine &lt;- nrow(phenoNoNA)
  idCV &lt;- sample(1:nLine %% nFold)   ### assign random ids for cross-validation
  idCV[idCV == 0] &lt;- nFold
  
  yPred &lt;- rep(NA, nLine)
  
  for (noCV in 1:nFold) {
    print(paste0("Fold: ", noCV))
    yTrain &lt;- phenoNoNA
    yTrain[idCV == noCV, ] &lt;- NA   ### prepare test data
    
    EM3.gaston.resCV &lt;- EM3.general(y = yTrain, X0 = NULL, ZETA = ZETANoNA,
                                    package = "gaston", return.u.always = TRUE,
                                    pred = TRUE, return.u.each = TRUE,
                                    return.Hinv = TRUE)   ### prediction
    yTest &lt;-  EM3.gaston.resCV$y.pred     ### predicted values
    
    yPred[idCV == noCV] &lt;- yTest[idCV == noCV]
  }
  
  ### Plot the results
  plotRange &lt;- range(phenoNoNA, yPred)
  plot(x = phenoNoNA, y = yPred,xlim = plotRange, ylim = plotRange,
       xlab = "Observed values", ylab = "Predicted values",
       main = "Results of Genomic Prediction (multi-kernel)",
       cex.lab = 1.5, cex.main = 1.5, cex.axis = 1.3)
  abline(a = 0, b = 1, col = 2, lwd = 2, lty = 2)
  R2 &lt;- cor(x = phenoNoNA[, 1], y = yPred) ^ 2
  text(x = plotRange[2] - 10,
       y = plotRange[1] + 10,
       paste0("R2 = ", round(R2, 3)), 
       cex = 1.5)

</code></pre>

<hr>
<h2 id='EM3.linker.cpp'>Equation of mixed model for multi-kernel (fast, for limited cases)</h2><span id='topic+EM3.linker.cpp'></span>

<h3>Description</h3>

<p>This function solves multi-kernel mixed model using fastlmm.snpset approach (Lippert et al., 2014).
This function can be used only when the kernels other than genomic relationship matrix are linear kernels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM3.linker.cpp(
  y0,
  X0 = NULL,
  ZETA = NULL,
  Zs0 = NULL,
  Ws0,
  Gammas0 = lapply(Ws0, function(x) diag(ncol(x))),
  gammas.diag = TRUE,
  X.fix = TRUE,
  eigen.SGS = NULL,
  eigen.G = NULL,
  n.core = 1,
  tol = NULL,
  bounds = c(1e-06, 1e+06),
  optimizer = "nlminb",
  traceInside = 0,
  n.thres = 450,
  spectral.method = NULL,
  REML = TRUE,
  pred = TRUE,
  return.u.always = TRUE,
  return.u.each = TRUE,
  return.Hinv = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM3.linker.cpp_+3A_y0">y0</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_x0">X0</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_zeta">ZETA</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_zs0">Zs0</code></td>
<td>
<p>A list of design matrices (Z; <code class="reqn">n \times m</code> matrix) for Ws.
For example, Zs0 = list(A.part = Z.A.part, D.part = Z.D.part)</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_ws0">Ws0</code></td>
<td>
<p>A list of low rank matrices (W; <code class="reqn">m \times k</code> matrix). This forms linear kernel <code class="reqn">K = W \Gamma W'</code>.
For example, Ws0 = list(A.part = W.A, D.part = W.D)</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_gammas0">Gammas0</code></td>
<td>
<p>A list of matrices for weighting SNPs (Gamma; <code class="reqn">k \times k</code> matrix). This forms linear kernel <code class="reqn">K = W \Gamma W'</code>.
For example, if there is no weighting, Gammas0 = lapply(Ws0, function(x) diag(ncol(x)))</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_gammas.diag">gammas.diag</code></td>
<td>
<p>If each Gamma is the diagonal matrix, please set this argument TRUE. The calculationtime can be saved.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_x.fix">X.fix</code></td>
<td>
<p>If you repeat this function and when X0 is fixed during iterations, please set this argument TRUE.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_eigen.sgs">eigen.SGS</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">SGS</code>, where <code class="reqn">S = I - X(X'X)^{-1}X'</code>, <code class="reqn">G = ZKZ'</code>.
You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_tol">tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of G = ZKZ'.
Eigen vectors whose eigen values are less than &quot;tol&quot; argument will be omitted from results.
If tol is NULL, top 'n' eigen values will be effective.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_bounds">bounds</code></td>
<td>
<p>Lower and upper bounds for weights.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_traceinside">traceInside</code></td>
<td>
<p>Perform trace for the optimzation if traceInside &gt;= 1, and this argument shows the frequency of reports.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_n.thres">n.thres</code></td>
<td>
<p>If <code class="reqn">n &gt;= n.thres</code>, perform EMM1.cpp. Else perform EMM2.cpp.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_spectral.method">spectral.method</code></td>
<td>
<p>The method of spectral decomposition.
In this function, &quot;eigen&quot; : eigen decomposition and &quot;cholesky&quot; : cholesky and singular value decomposition are offered.
If this argument is NULL, either method will be chosen accorsing to the dimension of Z and X.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_reml">REML</code></td>
<td>
<p>You can choose which method you will use, &quot;REML&quot; or &quot;ML&quot;.
If REML = TRUE, you will perform &quot;REML&quot;, and if REML = FALSE, you will perform &quot;ML&quot;.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_pred">pred</code></td>
<td>
<p>If TRUE, the fitting values of y is returned.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_return.u.always">return.u.always</code></td>
<td>
<p>If TRUE, BLUP ('u'; <code class="reqn">u</code>) will be returned.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_return.u.each">return.u.each</code></td>
<td>
<p>If TRUE, the function also computes each BLUP corresponding
to different kernels (when solving multi-kernel mixed-effects model). It takes
additional time compared to the one with 'return.u.each = FALSE'.</p>
</td></tr>
<tr><td><code id="EM3.linker.cpp_+3A_return.hinv">return.Hinv</code></td>
<td>
<p>If TRUE, <code class="reqn">H ^ {-1} = (Var[y] / \sum _{l=1} ^ {L} \sigma _ {l} ^ 2) ^ {-1}</code>
will be computed. It also returns <code class="reqn">V ^ {-1} = (Var[y]) ^ {-1}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$y.pred</dt><dd><p>The fitting values of y <code class="reqn">y = X\beta + Zu</code></p>
</dd>
<dt>$Vu</dt><dd><p>Estimator for <code class="reqn">\sigma^2_u</code>, all of the genetic variance</p>
</dd>
<dt>$Ve</dt><dd><p>Estimator for <code class="reqn">\sigma^2_e</code></p>
</dd>
<dt>$beta</dt><dd><p>BLUE(<code class="reqn">\beta</code>)</p>
</dd>
<dt>$u</dt><dd><p>BLUP(Sum of <code class="reqn">Zu</code>)</p>
</dd>
<dt>$u.each</dt><dd><p>BLUP(Each <code class="reqn">u</code>)</p>
</dd>
<dt>$weights</dt><dd><p>The proportion of each genetic variance (corresponding to each kernel of ZETA) to Vu</p>
</dd>
<dt>$LL</dt><dd><p>Maximized log-likelihood (full or restricted, depending on method)</p>
</dd>
<dt>$Vinv</dt><dd><p>The inverse of <code class="reqn">V = Vu \times ZKZ' + Ve \times I</code></p>
</dd>
<dt>$Hinv</dt><dd><p>The inverse of <code class="reqn">H = ZKZ' + \lambda I</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure
in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis
for association studies. Nat Genet. 44(7): 821-824.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based
association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



  ### Import RAINBOWR
  require(RAINBOWR)
  
  ### Load example datasets
  data("Rice_Zhao_etal")
  Rice_geno_score &lt;- Rice_Zhao_etal$genoScore
  Rice_geno_map &lt;- Rice_Zhao_etal$genoMap
  Rice_pheno &lt;- Rice_Zhao_etal$pheno
  
  ### View each dataset
  See(Rice_geno_score)
  See(Rice_geno_map)
  See(Rice_pheno)
  
  ### Select one trait for example
  trait.name &lt;- "Flowering.time.at.Arkansas"
  y &lt;- as.matrix(Rice_pheno[, trait.name, drop = FALSE])
  
  ### Remove SNPs whose MAF &lt;= 0.05
  x.0 &lt;- t(Rice_geno_score)
  MAF.cut.res &lt;- MAF.cut(x.0 = x.0, map.0 = Rice_geno_map)
  x &lt;- MAF.cut.res$x
  map &lt;- MAF.cut.res$map
  
  
  ### Estimate additive genomic relationship matrix (GRM)
  K.A &lt;- calcGRM(genoMat = x)
  
  
  ### Modify data
  Z &lt;- design.Z(pheno.labels = rownames(y),
                geno.names = rownames(K.A))  ### design matrix for random effects
  pheno.mat &lt;- y[rownames(Z), , drop = FALSE]
  ZETA &lt;- list(A = list(Z = Z, K = K.A))
  
  
  ### Including the additional linear kernel for chromosome 12
  chrNo &lt;- 12
  W.A &lt;- x[, map$chr == chrNo]    ### marker genotype data of chromosome 12
  
  Zs0 &lt;- list(A.part = Z)
  Ws0 &lt;- list(A.part = W.A)       ### This will be regarded as linear kernel
  ### for the variance-covariance matrix of another random effects.
  
  
  ### Solve multi-kernel linear mixed effects model (2 random efects)
  EM3.linker.res &lt;- EM3.linker.cpp(y0 = pheno.mat, X0 = NULL, ZETA = ZETA,
                                   Zs0 = Zs0, Ws0 = Ws0)
  (Vu &lt;- EM3.linker.res$Vu)   ### estimated genetic variance
  (Ve &lt;- EM3.linker.res$Ve)   ### estimated residual variance
  (weights &lt;- EM3.linker.res$weights)   ### estimated proportion of two genetic variances
  (herit &lt;- Vu * weights / (Vu + Ve))   ### genomic heritability (all chromosomes, chromosome 12)
  
  (beta &lt;- EM3.linker.res$beta)   ### Here, this is an intercept.
  u.each &lt;- EM3.linker.res$u.each   ### estimated genotypic values (all chromosomes, chromosome 12)
  See(u.each)

</code></pre>

<hr>
<h2 id='EM3.op'>Equation of mixed model for multi-kernel using other packages (much faster than EM3.cpp)</h2><span id='topic+EM3.op'></span>

<h3>Description</h3>

<p>This function solves the following multi-kernel linear mixed effects model
using <code><a href="MM4LMM.html#topic+MMEst">MMEst</a></code> function in 'MM4LMM' package,
<code><a href="gaston.html#topic+lmm.aireml">lmm.aireml</a></code> or <code><a href="gaston.html#topic+lmm.diago">lmm.diago</a></code> functions in 'gaston' package,
or <code><a href="#topic+EM3.cpp">EM3.cpp</a></code> function in 'RAINBOWR' package.
</p>
<p><code class="reqn">y = X \beta + \sum _{l=1} ^ {L} Z _ {l} u _ {l} + \epsilon</code>
</p>
<p>where <code class="reqn">Var[y] = \sum _{l=1} ^ {L} Z _ {l} K _ {l} Z _ {l}' \sigma _ {l} ^ 2 + I \sigma _ {e} ^ {2}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM3.op(
  y,
  X0 = NULL,
  ZETA,
  eigen.G = NULL,
  package = "gaston",
  tol = NULL,
  n.core = 1,
  REML = TRUE,
  pred = TRUE,
  return.u.always = TRUE,
  return.u.each = TRUE,
  return.Hinv = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM3.op_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="EM3.op_+3A_x0">X0</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="EM3.op_+3A_zeta">ZETA</code></td>
<td>
<p>A list of variance matrices and its design matrices of random effects. You can use more than one kernel matrix.
For example, ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D)) (A for additive, D for dominance)
Please set names of lists &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="EM3.op_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="EM3.op_+3A_package">package</code></td>
<td>
<p>Package name to be used in this function. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.</p>
</td></tr>
<tr><td><code id="EM3.op_+3A_tol">tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of G = ZKZ'.
Eigen vectors whose eigen values are less than &quot;tol&quot; argument will be omitted from results.
If tol is NULL, top 'n' eigen values will be effective.</p>
</td></tr>
<tr><td><code id="EM3.op_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores (only for 'MM4LMM').</p>
</td></tr>
<tr><td><code id="EM3.op_+3A_reml">REML</code></td>
<td>
<p>You can choose which method you will use, &quot;REML&quot; or &quot;ML&quot;.
If REML = TRUE, you will perform &quot;REML&quot;, and if REML = FALSE, you will perform &quot;ML&quot;.</p>
</td></tr>
<tr><td><code id="EM3.op_+3A_pred">pred</code></td>
<td>
<p>If TRUE, the fitting values of y is returned.</p>
</td></tr>
<tr><td><code id="EM3.op_+3A_return.u.always">return.u.always</code></td>
<td>
<p>When using the &quot;gaston&quot; package with missing values or
using the &quot;MM4LMM&quot; package (with/without missings), computing BLUP will take
some time in addition to solving the mixed-effects model. You can choose
whether BLUP ('u'; <code class="reqn">u</code>) will be returned or not.</p>
</td></tr>
<tr><td><code id="EM3.op_+3A_return.u.each">return.u.each</code></td>
<td>
<p>If TRUE, the function also computes each BLUP corresponding
to different kernels (when solving multi-kernel mixed-effects model). It takes
additional time compared to the one with 'return.u.each = FALSE'.</p>
</td></tr>
<tr><td><code id="EM3.op_+3A_return.hinv">return.Hinv</code></td>
<td>
<p>If TRUE, <code class="reqn">H ^ {-1} = (Var[y] / \sum _{l=1} ^ {L} \sigma _ {l} ^ 2) ^ {-1}</code>
will be computed. It also returns <code class="reqn">V ^ {-1} = (Var[y]) ^ {-1}</code>.
It will take some time in addition to solving the mixed-effects model.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$y.pred</dt><dd><p>The fitting values of y <code class="reqn">y = X\beta + Zu</code></p>
</dd>
<dt>$Vu</dt><dd><p>Estimator for <code class="reqn">\sigma^2_u</code>, all of the genetic variance</p>
</dd>
<dt>$Ve</dt><dd><p>Estimator for <code class="reqn">\sigma^2_e</code></p>
</dd>
<dt>$beta</dt><dd><p>BLUE(<code class="reqn">\beta</code>)</p>
</dd>
<dt>$u</dt><dd><p>BLUP(Sum of <code class="reqn">Zu</code>)</p>
</dd>
<dt>$u.each</dt><dd><p>BLUP(Each <code class="reqn">u</code>)</p>
</dd>
<dt>$weights</dt><dd><p>The proportion of each genetic variance (corresponding to each kernel of ZETA) to Vu</p>
</dd>
<dt>$LL</dt><dd><p>Maximized log-likelihood (full or restricted, depending on method)</p>
</dd>
<dt>$Vinv</dt><dd><p>The inverse of <code class="reqn">V = Vu \times ZKZ' + Ve \times I</code></p>
</dd>
<dt>$Hinv</dt><dd><p>The inverse of <code class="reqn">H = ZKZ' + \lambda I</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure
in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis
for association studies. Nat Genet. 44(7): 821-824.
</p>
<p>Johnson, D. L., &amp; Thompson, R. (1995). Restricted maximum likelihood estimation of variance
components for univariate animal models using sparse matrix techniques and average information.
Journal of dairy science, 78(2), 449-456.
</p>
<p>Hunter, D. R., &amp; Lange, K. (2004). A tutorial on MM algorithms.
The American Statistician, 58(1), 30-37.
</p>
<p>Zhou, H., Hu, L., Zhou, J., &amp; Lange, K. (2015). MM algorithms for variance components models.
arXiv preprint arXiv:1509.07426.
</p>
<p>Gilmour, A. R., Thompson, R., &amp; Cullis, B. R. (1995), Average information REML:
an efficient algorithm for variance parameter estimation in linear mixed models,
Biometrics, 1440-1450.
</p>


<h3>See Also</h3>

<p><code><a href="MM4LMM.html#topic+MMEst">MMEst</a></code>, <code><a href="gaston.html#topic+lmm.aireml">lmm.aireml</a></code>, <code><a href="gaston.html#topic+lmm.diago">lmm.diago</a></code>
</p>

<hr>
<h2 id='EMM.cpp'>Equation of mixed model for one kernel, a wrapper of two methods</h2><span id='topic+EMM.cpp'></span>

<h3>Description</h3>

<p>This function estimates maximum-likelihood (ML/REML; resticted maximum likelihood) solutions for the following mixed model.
</p>
<p style="text-align: center;"><code class="reqn">y = X \beta + Z u + \epsilon</code>
</p>

<p>where <code class="reqn">\beta</code> is a vector of fixed effects and <code class="reqn">u</code> is a vector of random effects with
<code class="reqn">Var[u] = K \sigma^2_u</code>. The residual variance is <code class="reqn">Var[\epsilon] = I \sigma^2_e</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMM.cpp(
  y,
  X = NULL,
  ZETA,
  eigen.G = NULL,
  eigen.SGS = NULL,
  n.thres = 450,
  reestimation = FALSE,
  n.core = NA,
  lam.len = 4,
  init.range = c(1e-06, 100),
  init.one = 0.5,
  conv.param = 1e-06,
  count.max = 20,
  bounds = c(1e-06, 1e+06),
  tol = NULL,
  optimizer = "nlminb",
  traceInside = 0,
  REML = TRUE,
  silent = TRUE,
  plot.l = FALSE,
  SE = FALSE,
  return.Hinv = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMM.cpp_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_zeta">ZETA</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_eigen.sgs">eigen.SGS</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">SGS</code>, where <code class="reqn">S = I - X(X'X)^{-1}X'</code>, <code class="reqn">G = ZKZ'</code>.
You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_n.thres">n.thres</code></td>
<td>
<p>If <code class="reqn">n &gt;= n.thres</code>, perform EMM1.cpp. Else perform EMM2.cpp.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_reestimation">reestimation</code></td>
<td>
<p>If TRUE, EMM2.cpp is performed when the estimation by EMM1.cpp may not be accurate.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_lam.len">lam.len</code></td>
<td>
<p>The number of initial values you set. If this number is large, the estimation will be more accurate,
but computational cost will be large. We recommend setting this value 3 &lt;= lam.len &lt;= 6.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_init.range">init.range</code></td>
<td>
<p>The range of the initial parameters. For example, if lam.len = 5 and init.range = c(1e-06, 1e02),
corresponding initial heritabilities will be calculated as seq(1e-06, 1 - 1e-02, length = 5),
and then initial lambdas will be set.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_init.one">init.one</code></td>
<td>
<p>The initial parameter if lam.len = 1.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_conv.param">conv.param</code></td>
<td>
<p>The convergence parameter. If the diffrence of log-likelihood by updating the parameter &quot;lambda&quot;
is smaller than this conv.param, the iteration steps will be stopped.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_count.max">count.max</code></td>
<td>
<p>Sometimes algorithms won't converge for some initial parameters.
So if the iteration steps reache to this argument, you can stop the calculation even if algorithm doesn't converge.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_bounds">bounds</code></td>
<td>
<p>Lower and Upper bounds of the parameter lambda. If the updated parameter goes out of this range,
the parameter is reset to the value in this range.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_tol">tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of G = ZKZ'.
Eigen vectors whose eigen values are less than &quot;tol&quot; argument will be omitted from results.
If tol is NULL, top 'n' eigen values will be effective.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_traceinside">traceInside</code></td>
<td>
<p>Perform trace for the optimzation if traceInside &gt;= 1, and this argument shows the frequency of reports.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_reml">REML</code></td>
<td>
<p>You can choose which method you will use, &quot;REML&quot; or &quot;ML&quot;.
If REML = TRUE, you will perform &quot;REML&quot;, and if REML = FALSE, you will perform &quot;ML&quot;.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_silent">silent</code></td>
<td>
<p>If this argument is TRUE, warning messages will be shown when estimation is not accurate.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_plot.l">plot.l</code></td>
<td>
<p>If you want to plot log-likelihood, please set plot.l = TRUE.
We don't recommend plot.l = TRUE when lam.len &gt;= 2.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_se">SE</code></td>
<td>
<p>If TRUE, standard errors are calculated.</p>
</td></tr>
<tr><td><code id="EMM.cpp_+3A_return.hinv">return.Hinv</code></td>
<td>
<p>If TRUE, the function returns the inverse of <code class="reqn">H = ZKZ' + \lambda I</code> where <code class="reqn">\lambda = \sigma^2_e / \sigma^2_u</code>. This is useful for GWAS.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$Vu</dt><dd><p>Estimator for <code class="reqn">\sigma^2_u</code></p>
</dd>
<dt>$Ve</dt><dd><p>Estimator for <code class="reqn">\sigma^2_e</code></p>
</dd>
<dt>$beta</dt><dd><p>BLUE(<code class="reqn">\beta</code>)</p>
</dd>
<dt>$u</dt><dd><p>BLUP(<code class="reqn">u</code>)</p>
</dd>
<dt>$LL</dt><dd><p>Maximized log-likelihood (full or restricted, depending on method)</p>
</dd>
<dt>$beta.SE</dt><dd><p>Standard error for <code class="reqn">\beta</code> (If SE = TRUE)</p>
</dd>
<dt>$u.SE</dt><dd><p>Standard error for <code class="reqn">u^*-u</code> (If SE = TRUE)</p>
</dd>
<dt>$Hinv</dt><dd><p>The inverse of <code class="reqn">H = ZKZ' + \lambda I</code> (If return.Hinv = TRUE)</p>
</dd>
<dt>$Hinv2</dt><dd><p>The inverse of <code class="reqn">H2 = ZKZ'/\lambda + I</code> (If return.Hinv = TRUE)</p>
</dd>
<dt>$lambda</dt><dd><p>Estimators for <code class="reqn">\lambda = \sigma^2_e / \sigma^2_u</code> (If <code class="reqn">n &gt;= n.thres</code>)</p>
</dd>
<dt>$lambdas</dt><dd><p>Lambdas for each initial values (If <code class="reqn">n &gt;= n.thres</code>)</p>
</dd>
<dt>$reest</dt><dd><p>If parameter estimation may not be accurate, reest = 1, else reest = 0 (If <code class="reqn">n &gt;= n.thres</code>)</p>
</dd>
<dt>$counts</dt><dd><p>The number of iterations until convergence for each initial values (If <code class="reqn">n &gt;= n.thres</code>)</p>
</dd>
</dl>



<h3>References</h3>

<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure
in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis
for association studies. Nat Genet. 44(7): 821-824.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

### Perform genomic prediction with 10-fold cross validation

  ### Import RAINBOWR
  require(RAINBOWR)

  ### Load example datasets
  data("Rice_Zhao_etal")
  Rice_geno_score &lt;- Rice_Zhao_etal$genoScore
  Rice_geno_map &lt;- Rice_Zhao_etal$genoMap
  Rice_pheno &lt;- Rice_Zhao_etal$pheno

  ### View each dataset
  See(Rice_geno_score)
  See(Rice_geno_map)
  See(Rice_pheno)

  ### Select one trait for example
  trait.name &lt;- "Flowering.time.at.Arkansas"
  y &lt;- as.matrix(Rice_pheno[, trait.name, drop = FALSE])

  ### Remove SNPs whose MAF &lt;= 0.05
  x.0 &lt;- t(Rice_geno_score)
  MAF.cut.res &lt;- MAF.cut(x.0 = x.0, map.0 = Rice_geno_map)
  x &lt;- MAF.cut.res$x
  map &lt;- MAF.cut.res$map

  ### Estimate genomic relationship matrix (GRM)
  K.A &lt;- calcGRM(genoMat = x)

  ### Modify data
  modify.res &lt;- modify.data(pheno.mat = y, geno.mat = x, return.ZETA = TRUE)
  pheno.mat &lt;- modify.res$pheno.modi
  ZETA &lt;- modify.res$ZETA


  ### Solve linear mixed effects model
  EMM.res &lt;- EMM.cpp(y = pheno.mat, X = NULL, ZETA = ZETA)
  (Vu &lt;- EMM.res$Vu)   ### estimated genetic variance
  (Ve &lt;- EMM.res$Ve)   ### estimated residual variance
  (herit &lt;- Vu / (Vu + Ve))   ### genomic heritability

  (beta &lt;- EMM.res$beta)   ### Here, this is an intercept.
  u &lt;- EMM.res$u   ### estimated genotypic values
  See(u)

  ### Estimate marker effects from estimated genotypic values
  x.modi &lt;- modify.res$geno.modi
  WMat &lt;- calcGRM(genoMat = x.modi, methodGRM = "addNOIA",
                  returnWMat = TRUE)
  K.A &lt;- ZETA$A$K
  if (min(eigen(K.A)$values) &lt; 1e-08) {
    diag(K.A) &lt;- diag(K.A) + 1e-06
  }

  mrkEffectsForW &lt;- crossprod(x = WMat,
                              y = solve(K.A)) %*% as.matrix(u)
  mrkEffects &lt;- mrkEffectsForW / mean(scale(x.modi %*% mrkEffectsForW, scale = FALSE) / u)




  #### Cross-validation for genomic prediction
  noNA &lt;- !is.na(c(pheno.mat))   ### NA (missing) in the phenotype data

  phenoNoNA &lt;- pheno.mat[noNA, , drop = FALSE]   ### remove NA
  ZETANoNA &lt;- ZETA
  ZETANoNA$A$Z &lt;- ZETA$A$Z[noNA, ]   ### remove NA


  nFold &lt;- 10    ### # of folds
  nLine &lt;- nrow(phenoNoNA)
  idCV &lt;- sample(1:nLine %% nFold)   ### assign random ids for cross-validation
  idCV[idCV == 0] &lt;- nFold

  yPred &lt;- rep(NA, nLine)

  for (noCV in 1:nFold) {
    yTrain &lt;- phenoNoNA
    yTrain[idCV == noCV, ] &lt;- NA   ### prepare test data

    EMM.resCV &lt;- EMM.cpp(y = yTrain, X = NULL, ZETA = ZETANoNA)   ### prediction
    yTest &lt;-  EMM.resCV$beta + EMM.resCV$u   ### predicted values

    yPred[idCV == noCV] &lt;- (yTest[noNA])[idCV == noCV]
  }

  ### Plot the results
  plotRange &lt;- range(phenoNoNA, yPred)
  plot(x = phenoNoNA, y = yPred,xlim = plotRange, ylim = plotRange,
       xlab = "Observed values", ylab = "Predicted values",
       main = "Results of Genomic Prediction",
       cex.lab = 1.5, cex.main = 1.5, cex.axis = 1.3)
  abline(a = 0, b = 1, col = 2, lwd = 2, lty = 2)
  R2 &lt;- cor(x = phenoNoNA[, 1], y = yPred) ^ 2
  text(x = plotRange[2] - 10,
       y = plotRange[1] + 10,
       paste0("R2 = ", round(R2, 3)),
       cex = 1.5)

</code></pre>

<hr>
<h2 id='EMM1.cpp'>Equation of mixed model for one kernel, GEMMA-based method (inplemented by Rcpp)</h2><span id='topic+EMM1.cpp'></span>

<h3>Description</h3>

<p>This function solves the single-kernel linear mixed effects model by GEMMA
(genome wide efficient mixed model association; Zhou et al., 2012) approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMM1.cpp(
  y,
  X = NULL,
  ZETA,
  eigen.G = NULL,
  n.core = NA,
  lam.len = 4,
  init.range = c(1e-04, 100),
  init.one = 0.5,
  conv.param = 1e-06,
  count.max = 15,
  bounds = c(1e-06, 1e+06),
  tol = NULL,
  REML = TRUE,
  silent = TRUE,
  plot.l = FALSE,
  SE = FALSE,
  return.Hinv = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMM1.cpp_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_zeta">ZETA</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_lam.len">lam.len</code></td>
<td>
<p>The number of initial values you set. If this number is large, the estimation will be more accurate,
but computational cost will be large. We recommend setting this value 3 &lt;= lam.len &lt;= 6.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_init.range">init.range</code></td>
<td>
<p>The range of the initial parameters. For example, if lam.len = 5 and init.range = c(1e-06, 1e02),
corresponding initial heritabilities will be calculated as seq(1e-06, 1 - 1e-02, length = 5),
and then initial lambdas will be set.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_init.one">init.one</code></td>
<td>
<p>The initial parameter if lam.len = 1.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_conv.param">conv.param</code></td>
<td>
<p>The convergence parameter. If the diffrence of log-likelihood by updating the parameter &quot;lambda&quot;
is smaller than this conv.param, the iteration steps will be stopped.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_count.max">count.max</code></td>
<td>
<p>Sometimes algorithms won't converge for some initial parameters.
So if the iteration steps reache to this argument, you can stop the calculation even if algorithm doesn't converge.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_bounds">bounds</code></td>
<td>
<p>Lower and Upper bounds of the parameter 1 / lambda. If the updated parameter goes out of this range,
the parameter is reset to the value in this range.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_tol">tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of G = ZKZ'.
Eigen vectors whose eigen values are less than &quot;tol&quot; argument will be omitted from results.
If tol is NULL, top 'n' eigen values will be effective.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_reml">REML</code></td>
<td>
<p>You can choose which method you will use, &quot;REML&quot; or &quot;ML&quot;.
If REML = TRUE, you will perform &quot;REML&quot;, and if REML = FALSE, you will perform &quot;ML&quot;.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_silent">silent</code></td>
<td>
<p>If this argument is TRUE, warning messages will be shown when estimation is not accurate.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_plot.l">plot.l</code></td>
<td>
<p>If you want to plot log-likelihood, please set plot.l = TRUE.
We don't recommend plot.l = TRUE when lam.len &gt;= 2.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_se">SE</code></td>
<td>
<p>If TRUE, standard errors are calculated.</p>
</td></tr>
<tr><td><code id="EMM1.cpp_+3A_return.hinv">return.Hinv</code></td>
<td>
<p>If TRUE, the function returns the inverse of <code class="reqn">H = ZKZ' + \lambda I</code> where <code class="reqn">\lambda = \sigma^2_e / \sigma^2_u</code>. This is useful for GWAS.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$Vu</dt><dd><p>Estimator for <code class="reqn">\sigma^2_u</code></p>
</dd>
<dt>$Ve</dt><dd><p>Estimator for <code class="reqn">\sigma^2_e</code></p>
</dd>
<dt>$beta</dt><dd><p>BLUE(<code class="reqn">\beta</code>)</p>
</dd>
<dt>$u</dt><dd><p>BLUP(<code class="reqn">u</code>)</p>
</dd>
<dt>$LL</dt><dd><p>Maximized log-likelihood (full or restricted, depending on method)</p>
</dd>
<dt>$beta.SE</dt><dd><p>Standard error for <code class="reqn">\beta</code> (If SE = TRUE)</p>
</dd>
<dt>$u.SE</dt><dd><p>Standard error for <code class="reqn">u^*-u</code> (If SE = TRUE)</p>
</dd>
<dt>$Hinv</dt><dd><p>The inverse of <code class="reqn">H = ZKZ' + \lambda I</code> (If return.Hinv = TRUE)</p>
</dd>
<dt>$Hinv2</dt><dd><p>The inverse of <code class="reqn">H2 = ZKZ'/\lambda + I</code> (If return.Hinv = TRUE)</p>
</dd>
<dt>$lambda</dt><dd><p>Estimators for <code class="reqn">\lambda = \sigma^2_e / \sigma^2_u</code></p>
</dd>
<dt>$lambdas</dt><dd><p>Lambdas for each initial values</p>
</dd>
<dt>$reest</dt><dd><p>If parameter estimation may not be accurate, reest = 1, else reest = 0</p>
</dd>
<dt>$counts</dt><dd><p>The number of iterations until convergence for each initial values</p>
</dd>
</dl>



<h3>References</h3>

<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure
in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis
for association studies. Nat Genet. 44(7): 821-824.
</p>

<hr>
<h2 id='EMM2.cpp'>Equation of mixed model for one kernel, EMMA-based method (inplemented by Rcpp)</h2><span id='topic+EMM2.cpp'></span>

<h3>Description</h3>

<p>This function solves single-kernel linear mixed model by EMMA
(efficient mixed model association; Kang et al., 2008) approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMM2.cpp(
  y,
  X = NULL,
  ZETA,
  eigen.G = NULL,
  eigen.SGS = NULL,
  tol = NULL,
  optimizer = "nlminb",
  traceInside = 0,
  REML = TRUE,
  bounds = c(1e-09, 1e+09),
  SE = FALSE,
  return.Hinv = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMM2.cpp_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="EMM2.cpp_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="EMM2.cpp_+3A_zeta">ZETA</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="EMM2.cpp_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="EMM2.cpp_+3A_eigen.sgs">eigen.SGS</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">SGS</code>, where <code class="reqn">S = I - X(X'X)^{-1}X'</code>, <code class="reqn">G = ZKZ'</code>.
You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="EMM2.cpp_+3A_tol">tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of G = ZKZ'.
Eigen vectors whose eigen values are less than &quot;tol&quot; argument will be omitted from results.
If tol is NULL, top 'n' eigen values will be effective.</p>
</td></tr>
<tr><td><code id="EMM2.cpp_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="EMM2.cpp_+3A_traceinside">traceInside</code></td>
<td>
<p>Perform trace for the optimzation if traceInside &gt;= 1, and this argument shows the frequency of reports.</p>
</td></tr>
<tr><td><code id="EMM2.cpp_+3A_reml">REML</code></td>
<td>
<p>You can choose which method you will use, &quot;REML&quot; or &quot;ML&quot;.
If REML = TRUE, you will perform &quot;REML&quot;, and if REML = FALSE, you will perform &quot;ML&quot;.</p>
</td></tr>
<tr><td><code id="EMM2.cpp_+3A_bounds">bounds</code></td>
<td>
<p>Lower and Upper bounds of the parameter lambda. If the updated parameter goes out of this range,
the parameter is reset to the value in this range.</p>
</td></tr>
<tr><td><code id="EMM2.cpp_+3A_se">SE</code></td>
<td>
<p>If TRUE, standard errors are calculated.</p>
</td></tr>
<tr><td><code id="EMM2.cpp_+3A_return.hinv">return.Hinv</code></td>
<td>
<p>If TRUE, the function returns the inverse of <code class="reqn">H = ZKZ' + \lambda I</code> where <code class="reqn">\lambda = \sigma^2_e / \sigma^2_u</code>. This is useful for GWAS.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$Vu</dt><dd><p>Estimator for <code class="reqn">\sigma^2_u</code></p>
</dd>
<dt>$Ve</dt><dd><p>Estimator for <code class="reqn">\sigma^2_e</code></p>
</dd>
<dt>$beta</dt><dd><p>BLUE(<code class="reqn">\beta</code>)</p>
</dd>
<dt>$u</dt><dd><p>BLUP(<code class="reqn">u</code>)</p>
</dd>
<dt>$LL</dt><dd><p>Maximized log-likelihood (full or restricted, depending on method)</p>
</dd>
<dt>$beta.SE</dt><dd><p>Standard error for <code class="reqn">\beta</code> (If SE = TRUE)</p>
</dd>
<dt>$u.SE</dt><dd><p>Standard error for <code class="reqn">u^*-u</code> (If SE = TRUE)</p>
</dd>
<dt>$Hinv</dt><dd><p>The inverse of <code class="reqn">H = ZKZ' + \lambda I</code> (If return.Hinv = TRUE)</p>
</dd>
</dl>



<h3>References</h3>

<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure
in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>

<hr>
<h2 id='estNetwork'>Function to estimate &amp; plot haplotype network</h2><span id='topic+estNetwork'></span>

<h3>Description</h3>

<p>Function to estimate &amp; plot haplotype network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estNetwork(
  blockInterest = NULL,
  gwasRes = NULL,
  nTopRes = 1,
  gene.set = NULL,
  indexRegion = 1:10,
  chrInterest = NULL,
  posRegion = NULL,
  blockName = NULL,
  nHaplo = NULL,
  pheno = NULL,
  geno = NULL,
  ZETA = NULL,
  chi2Test = TRUE,
  thresChi2Test = 0.05,
  plotNetwork = TRUE,
  distMat = NULL,
  distMethod = "manhattan",
  evolutionDist = FALSE,
  complementHaplo = "phylo",
  subpopInfo = NULL,
  groupingMethod = "kmedoids",
  nGrp = 3,
  nIterClustering = 100,
  iterRmst = 100,
  networkMethod = "rmst",
  autogamous = FALSE,
  probParsimony = 0.95,
  nMaxHaplo = 1000,
  kernelTypes = "addNOIA",
  n.core = parallel::detectCores() - 1,
  parallel.method = "mclapply",
  hOpt = "optimized",
  hOpt2 = "optimized",
  maxIter = 20,
  rangeHStart = 10^c(-1:1),
  saveName = NULL,
  saveStyle = "png",
  plotWhichMDS = 1:2,
  colConnection = c("grey40", "grey60"),
  ltyConnection = c("solid", "dashed"),
  lwdConnection = c(1.5, 0.8),
  pchBase = c(1, 16),
  colCompBase = c(2, 4),
  colHaploBase = c(3, 5, 6),
  cexMax = 2,
  cexMin = 0.7,
  ggPlotNetwork = FALSE,
  cexMaxForGG = 0.025,
  cexMinForGG = 0.008,
  alphaBase = c(0.9, 0.3),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estNetwork_+3A_blockinterest">blockInterest</code></td>
<td>
<p>A <code class="reqn">n \times M</code> matrix representing the marker genotype that belongs to the haplotype block of interest.
If this argument is NULL, this argument will automatically be determined by 'geno',</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_gwasres">gwasRes</code></td>
<td>
<p>You can use the results (data.frame) of haplotype-based (SNP-set) GWAS by 'RGWAS.multisnp' function.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_ntopres">nTopRes</code></td>
<td>
<p>Haplotype blocks (or gene sets, SNP-sets) with top 'nTopRes' p-values by 'gwasRes' will be used.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene (or haplotype block), you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_indexregion">indexRegion</code></td>
<td>
<p>You can specify the haplotype block (or gene set, SNP-set) of interest by the marker index in 'geno'.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_chrinterest">chrInterest</code></td>
<td>
<p>You can specify the haplotype block (or gene set, SNP-set) of interest by the marker position in 'geno'.
Please assign the chromosome number to this argument.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_posregion">posRegion</code></td>
<td>
<p>You can specify the haplotype block (or gene set, SNP-set) of interest by the marker position in 'geno'.
Please assign the position in the chromosome to this argument.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_blockname">blockName</code></td>
<td>
<p>You can specify the haplotype block (or gene set, SNP-set) of interest by the name of haplotype block in 'geno'.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_nhaplo">nHaplo</code></td>
<td>
<p>Number of haplotypes. If not defined, this is automatically defined by the data.
If defined, k-medoids clustering is performed to define haplotypes.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_pheno">pheno</code></td>
<td>
<p>Data frame where the first column is the line name (gid).
The remaining columns should be a phenotype to test.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_geno">geno</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.
Columns 4 and higher contain the marker scores for each line, coded as [-1, 0, 1] = [aa, Aa, AA].</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_zeta">ZETA</code></td>
<td>
<p>A list of covariance (relationship) matrix (K: <code class="reqn">m \times m</code>) and its design matrix (Z: <code class="reqn">n \times m</code>) of random effects.
Please set names of list &quot;Z&quot; and &quot;K&quot;! You can use more than one kernel matrix.
For example,
</p>
<p>ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D))
</p>

<dl>
<dt>Z.A, Z.D</dt><dd><p>Design matrix (<code class="reqn">n \times m</code>) for the random effects. So, in many cases, you can use the identity matrix.</p>
</dd>
<dt>K.A, K.D</dt><dd><p>Different kernels which express some relationships between lines.</p>
</dd>
</dl>

<p>For example, K.A is additive relationship matrix for the covariance between lines, and K.D is dominance relationship matrix.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_chi2test">chi2Test</code></td>
<td>
<p>If TRUE, chi-square test for the relationship between haplotypes &amp; subpopulations will be performed.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_threschi2test">thresChi2Test</code></td>
<td>
<p>The threshold for the chi-square test.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_plotnetwork">plotNetwork</code></td>
<td>
<p>If TRUE, the function will return the plot of haplotype network.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_distmat">distMat</code></td>
<td>
<p>You can assign the distance matrix of the block of interest.
If NULL, the distance matrix will be computed in this function.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_distmethod">distMethod</code></td>
<td>
<p>You can choose the method to calculate distance between accessions.
This argument corresponds to the 'method' argument in the 'dist' function.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_evolutiondist">evolutionDist</code></td>
<td>
<p>If TRUE, the evolution distance will be used instead of the pure distance.
The 'distMat' will be converted to the distance matrix by the evolution distance when you use 'complementHaplo = &quot;phylo&quot;'.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_complementhaplo">complementHaplo</code></td>
<td>
<p>how to complement unobserved haplotypes.
When 'complementHaplo = &quot;all&quot;', all possible haplotypes will be complemented from the observed haplotypes.
When 'complementHaplo = &quot;never&quot;', unobserved haplotypes will not be complemented.
When 'complementHaplo = &quot;phylo&quot;', unobserved haplotypes will be complemented as nodes of phylogenetic tree.
When 'complementHaplo = &quot;TCS&quot;', unobserved haplotypes will be complemented by TCS methods (Clement et al., 2002).</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_subpopinfo">subpopInfo</code></td>
<td>
<p>The information of subpopulations. This argument should be a vector of factor.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_groupingmethod">groupingMethod</code></td>
<td>
<p>If 'subpopInfo' argument is NULL, this function estimates subpopulation information from marker genotype.
You can choose the grouping method from 'kmeans', 'kmedoids', and 'hclust'.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_ngrp">nGrp</code></td>
<td>
<p>The number of groups (or subpopulations) grouped by 'groupingMethod'.
If this argument is 0, the subpopulation information will not be estimated.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_niterclustering">nIterClustering</code></td>
<td>
<p>If 'groupingMethod' = 'kmeans', the clustering will be performed multiple times.
This argument specifies the number of classification performed by the function.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_iterrmst">iterRmst</code></td>
<td>
<p>The number of iterations for RMST (randomized minimum spanning tree).</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_networkmethod">networkMethod</code></td>
<td>
<p>Either one of 'mst' (minimum spanning tree),
'msn' (minimum spanning network), and 'rmst' (randomized minimum spanning tree).
'rmst' is recommended.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_autogamous">autogamous</code></td>
<td>
<p>This argument will be valid only when you use 'complementHaplo = &quot;all&quot;' or 'complementHaplo = &quot;TCS&quot;'.
This argument specifies whether the plant is autogamous or not. If autogamous = TRUE,
complemented haplotype will consist of only homozygous sites ([-1, 1]).
If FALSE, complemented haplotype will consist of both homozygous &amp; heterozygous sites ([-1, 0, 1]).</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_probparsimony">probParsimony</code></td>
<td>
<p>Equal to the argument 'prob' in 'haplotypes::parsimnet' function:
</p>
<p>A numeric vector of length one in the range [0.01, 0.99] giving the probability of parsimony as defined in Templeton et al. (1992).
In order to set maximum connection steps to Inf (to connect all the haplotypes in a single network), set the probability to NULL.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_nmaxhaplo">nMaxHaplo</code></td>
<td>
<p>The maximum number of haplotypes. If the number of total (complemented + original) haplotypes are larger than 'nMaxHaplo',
we will only show the results only for the original haplotypes to reduce the computational time.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_kerneltypes">kernelTypes</code></td>
<td>
<p>In the function, similarlity matrix between accessions will be computed from marker genotype to estimate genotypic values.
This argument specifies the method to compute similarity matrix:
If this argument is 'addNOIA' (or one of other options in 'methodGRM' in 'calcGRM'),
then the 'addNOIA' (or corresponding) option in the 'calcGRM' function will be used,
and if this argument is 'diffusion', the diffusion kernel based on Laplacian matrix will be computed from network.
You can assign more than one kernelTypes for this argument; for example, kernelTypes = c(&quot;addNOIA&quot;, &quot;diffusion&quot;).</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation in optimizing hyperparameters for estimating haplotype effects.
We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_hopt">hOpt</code></td>
<td>
<p>Optimized hyper parameter for constructing kernel when estimating haplotype effects.
If hOpt = &quot;optimized&quot;, hyper parameter will be optimized in the function.
If hOpt is numeric, that value will be directly used in the function.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_hopt2">hOpt2</code></td>
<td>
<p>Optimized hyper parameter for constructing kernel when estimating complemented haplotype effects.
If hOpt2 = &quot;optimized&quot;, hyper parameter will be optimized in the function.
If hOpt2 is numeric, that value will be directly used in the function.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_maxiter">maxIter</code></td>
<td>
<p>Max number of iterations for optimization algorithm.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_rangehstart">rangeHStart</code></td>
<td>
<p>The median of off-diagonal of distance matrix multiplied by rangeHStart will be used
as the initial values for optimization of hyper parameters.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_savestyle">saveStyle</code></td>
<td>
<p>This argument specifies how to save the plot of phylogenetic tree.
The function offers 'png', 'pdf', 'jpg', and 'tiff'.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_plotwhichmds">plotWhichMDS</code></td>
<td>
<p>We will show the MDS (multi-dimensional scaling) plot,
and this argument is a vector of two integers specifying that will define which MDS dimension will be plotted.
The first and second integers correspond to the horizontal and vertical axes, respectively.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_colconnection">colConnection</code></td>
<td>
<p>A vector of two integers or characters specifying the colors of connection between nodes for the original and complemented haplotypes, respectively.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_ltyconnection">ltyConnection</code></td>
<td>
<p>A vector of two characters specifying the line types of connection between nodes for the original and complemented haplotypes, respectively.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_lwdconnection">lwdConnection</code></td>
<td>
<p>A vector of two integers specifying the line widths of connection between nodes for the original and complemented haplotypes, respectively.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_pchbase">pchBase</code></td>
<td>
<p>A vector of two integers specifying the plot types for the positive and negative genotypic values respectively.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_colcompbase">colCompBase</code></td>
<td>
<p>A vector of two integers or characters specifying color of complemented haplotypes for the positive and negative genotypic values respectively.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_colhaplobase">colHaploBase</code></td>
<td>
<p>A vector of integers or characters specifying color of original haplotypes for the positive and negative genotypic values respectively.
The length of the vector should equal to the number of subpopulations.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_cexmax">cexMax</code></td>
<td>
<p>A numeric specifying the maximum point size of the plot.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_cexmin">cexMin</code></td>
<td>
<p>A numeric specifying the minimum point size of the plot.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_ggplotnetwork">ggPlotNetwork</code></td>
<td>
<p>If TRUE, the function will return the ggplot version of haplotype network.
It offers the precise information on subgroups for each haplotype.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_cexmaxforgg">cexMaxForGG</code></td>
<td>
<p>A numeric specifying the maximum point size of the plot for the ggplot version of haplotype network,
relative to the range of x and y-axes (0 &lt; cexMaxForGG &lt;= 1).</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_cexminforgg">cexMinForGG</code></td>
<td>
<p>A numeric specifying the minimum point size of the plot for the ggplot version of haplotype network,
relative to the range of x and y-axes (0 &lt; cexMaxForGG &lt;= 1).</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_alphabase">alphaBase</code></td>
<td>
<p>alpha (parameter that indicates the opacity of a geom) for original haplotype with positive / negative effects.
alpha for complemented haplotype will be same as the alpha for original haplotype with negative effects.</p>
</td></tr>
<tr><td><code id="estNetwork_+3A_verbose">verbose</code></td>
<td>
<p>If this argument is TRUE, messages for the current steps will be shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list / lists of
</p>
<dl>
<dt>$haplotypeInfo</dt><dd><p>A list of haplotype information with
</p>
<dl>
<dt>$haploCluster</dt><dd><p>A vector indicating each individual belongs to which haplotypes.</p>
</dd>
<dt>$haploMat</dt><dd><p>A n x h matrix where n is the number of genotypes and h is the number of haplotypes.</p>
</dd>
<dt>$haploBlock</dt><dd><p>Marker genotype of haplotype block of interest for the representing haplotypes.</p>
</dd>
</dl>

</dd>
<dt>$subpopInfo</dt><dd><p>The information of subpopulations.</p>
</dd>
<dt>$pValChi2Test</dt><dd><p>A p-value of the chi-square test for the dependency between haplotypes &amp; subpopulations.
If 'chi2Test = FALSE', 'NA' will be returned.</p>
</dd>
<dt>$mstResults</dt><dd><p>A list of estimated results of MST / MSN / RMST:
</p>
<dl>
<dt>$mstRes</dt><dd><p>Estimated results of MST / MSN / RMST for the data including original haplotypes.</p>
</dd>
<dt>$mstResComp</dt><dd><p>Estimated results of MST / MSN / RMST for the data including both original and complemented haplotype.</p>
</dd>
</dl>

</dd>
<dt>$distMats</dt><dd><p>A list of distance matrix:
</p>
<dl>
<dt>$distMat</dt><dd><p>Distance matrix between haplotypes.</p>
</dd>
<dt>$distMatComp</dt><dd><p>Distance matrix between haplotypes (including unobserved ones).</p>
</dd>
<dt>$laplacianMat</dt><dd><p>Laplacian matrix between haplotypes (including unobserved ones).</p>
</dd>
</dl>

</dd>
<dt>$gvTotal</dt><dd><p>Estimated genotypic values by kernel regression for each haplotype.</p>
</dd>
<dt>$gvTotalForLine</dt><dd><p>Estimated genotypic values by kernel regression for each individual.</p>
</dd>
<dt>$minuslog10p</dt><dd><p><code class="reqn">-log_{10}(p)</code> for haplotype block of interest.
p is the p-value for the siginifacance of the haplotype block effect.</p>
</dd>
<dt>$hOpts</dt><dd><p>Optimized hyper parameters, hOpt1 &amp; hOpt2.</p>
</dd>
<dt>$EMMResults</dt><dd><p>A list of estimated results of kernel regression:
</p>
<dl>
<dt>$EM3Res</dt><dd><p>Estimated results of kernel regression for the estimation of haplotype effects. (1st step)</p>
</dd>
<dt>$EMMRes</dt><dd><p>Estimated results of kernel regression for the estimation of haplotype effects of nodes. (2nd step)</p>
</dd>
<dt>$EMM0Res</dt><dd><p>Estimated results of kernel regression for the null model.</p>
</dd>
</dl>

</dd>
<dt>$clusterNosForHaplotype</dt><dd><p>A list of cluster Nos of individuals that belong to each haplotype.</p>
</dd>
</dl>


<hr>
<h2 id='estPhylo'>Function to estimate &amp; plot phylogenetic tree</h2><span id='topic+estPhylo'></span>

<h3>Description</h3>

<p>Function to estimate &amp; plot phylogenetic tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estPhylo(
  blockInterest = NULL,
  gwasRes = NULL,
  nTopRes = 1,
  gene.set = NULL,
  indexRegion = 1:10,
  chrInterest = NULL,
  posRegion = NULL,
  blockName = NULL,
  nHaplo = NULL,
  pheno = NULL,
  geno = NULL,
  ZETA = NULL,
  chi2Test = TRUE,
  thresChi2Test = 0.05,
  plotTree = TRUE,
  distMat = NULL,
  distMethod = "manhattan",
  evolutionDist = FALSE,
  subpopInfo = NULL,
  groupingMethod = "kmedoids",
  nGrp = 3,
  nIterClustering = 100,
  kernelTypes = "addNOIA",
  n.core = parallel::detectCores() - 1,
  parallel.method = "mclapply",
  hOpt = "optimized",
  hOpt2 = "optimized",
  maxIter = 20,
  rangeHStart = 10^c(-1:1),
  saveName = NULL,
  saveStyle = "png",
  pchBase = c(1, 16),
  colNodeBase = c(2, 4),
  colTipBase = c(3, 5, 6),
  cexMax = 2,
  cexMin = 0.7,
  edgeColoring = TRUE,
  tipLabel = TRUE,
  ggPlotTree = FALSE,
  cexMaxForGG = 0.12,
  cexMinForGG = 0.06,
  alphaBase = c(0.9, 0.3),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estPhylo_+3A_blockinterest">blockInterest</code></td>
<td>
<p>A <code class="reqn">n \times M</code> matrix representing the marker genotype that belongs to the haplotype block of interest.
If this argument is NULL, this argument will automatically be determined by 'geno',</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_gwasres">gwasRes</code></td>
<td>
<p>You can use the results (data.frame) of haplotype-based (SNP-set) GWAS by 'RGWAS.multisnp' function.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_ntopres">nTopRes</code></td>
<td>
<p>Haplotype blocks (or gene sets, SNP-sets) with top 'nTopRes' p-values by 'gwasRes' will be used.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene (or haplotype block), you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_indexregion">indexRegion</code></td>
<td>
<p>You can specify the haplotype block (or gene set, SNP-set) of interest by the marker index in 'geno'.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_chrinterest">chrInterest</code></td>
<td>
<p>You can specify the haplotype block (or gene set, SNP-set) of interest by the marker position in 'geno'.
Please assign the chromosome number to this argument.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_posregion">posRegion</code></td>
<td>
<p>You can specify the haplotype block (or gene set, SNP-set) of interest by the marker position in 'geno'.
Please assign the position in the chromosome to this argument.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_blockname">blockName</code></td>
<td>
<p>You can specify the haplotype block (or gene set, SNP-set) of interest by the name of haplotype block in 'geno'.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_nhaplo">nHaplo</code></td>
<td>
<p>Number of haplotypes. If not defined, this is automatically defined by the data.
If defined, k-medoids clustering is performed to define haplotypes.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_pheno">pheno</code></td>
<td>
<p>Data frame where the first column is the line name (gid).
The remaining columns should be a phenotype to test.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_geno">geno</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.
Columns 4 and higher contain the marker scores for each line, coded as [-1, 0, 1] = [aa, Aa, AA].</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_zeta">ZETA</code></td>
<td>
<p>A list of covariance (relationship) matrix (K: <code class="reqn">m \times m</code>) and its design matrix (Z: <code class="reqn">n \times m</code>) of random effects.
Please set names of list &quot;Z&quot; and &quot;K&quot;! You can use more than one kernel matrix.
For example,
</p>
<p>ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D))
</p>

<dl>
<dt>Z.A, Z.D</dt><dd><p>Design matrix (<code class="reqn">n \times m</code>) for the random effects. So, in many cases, you can use the identity matrix.</p>
</dd>
<dt>K.A, K.D</dt><dd><p>Different kernels which express some relationships between lines.</p>
</dd>
</dl>

<p>For example, K.A is additive relationship matrix for the covariance between lines, and K.D is dominance relationship matrix.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_chi2test">chi2Test</code></td>
<td>
<p>If TRUE, chi-square test for the relationship between haplotypes &amp; subpopulations will be performed.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_threschi2test">thresChi2Test</code></td>
<td>
<p>The threshold for the chi-square test.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_plottree">plotTree</code></td>
<td>
<p>If TRUE, the function will return the plot of phylogenetic tree.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_distmat">distMat</code></td>
<td>
<p>You can assign the distance matrix of the block of interest.
If NULL, the distance matrix will be computed in this function.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_distmethod">distMethod</code></td>
<td>
<p>You can choose the method to calculate distance between accessions.
This argument corresponds to the 'method' argument in the 'dist' function.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_evolutiondist">evolutionDist</code></td>
<td>
<p>If TRUE, the evolution distance will be used instead of the pure distance.
The 'distMat' will be converted to the distance matrix by the evolution distance.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_subpopinfo">subpopInfo</code></td>
<td>
<p>The information of subpopulations. This argument should be a vector of factor.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_groupingmethod">groupingMethod</code></td>
<td>
<p>If 'subpopInfo' argument is NULL, this function estimates subpopulation information from marker genotype.
You can choose the grouping method from 'kmeans', 'kmedoids', and 'hclust'.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_ngrp">nGrp</code></td>
<td>
<p>The number of groups (or subpopulations) grouped by 'groupingMethod'.
If this argument is 0, the subpopulation information will not be estimated.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_niterclustering">nIterClustering</code></td>
<td>
<p>If 'groupingMethod' = 'kmeans', the clustering will be performed multiple times.
This argument specifies the number of classification performed by the function.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_kerneltypes">kernelTypes</code></td>
<td>
<p>In the function, similarlity matrix between accessions will be computed from marker genotype to estimate genotypic values.
This argument specifies the method to compute similarity matrix:
If this argument is 'addNOIA' (or one of other options in 'methodGRM' in 'calcGRM'),
then the 'addNOIA' (or corresponding) option in the 'calcGRM' function will be used,
and if this argument is 'phylo', the gaussian kernel based on phylogenetic distance will be computed from phylogenetic tree.
You can assign more than one kernelTypes for this argument; for example, kernelTypes = c(&quot;addNOIA&quot;, &quot;phylo&quot;).</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation in optimizing hyperparameters for estimating haplotype effects.
We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_hopt">hOpt</code></td>
<td>
<p>Optimized hyper parameter for constructing kernel when estimating haplotype effects.
If hOpt = &quot;optimized&quot;, hyper parameter will be optimized in the function.
If hOpt = &quot;tuned&quot;, hyper parameter will be replaced by the median of off-diagonal of distance matrix.
If hOpt is numeric, that value will be directly used in the function.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_hopt2">hOpt2</code></td>
<td>
<p>Optimized hyper parameter for constructing kernel when estimating haplotype effects of nodes.
If hOpt2 = &quot;optimized&quot;, hyper parameter will be optimized in the function.
If hOpt2 = &quot;tuned&quot;, hyper parameter will be replaced by the median of off-diagonal of distance matrix.
If hOpt2 is numeric, that value will be directly used in the function.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_maxiter">maxIter</code></td>
<td>
<p>Max number of iterations for optimization algorithm.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_rangehstart">rangeHStart</code></td>
<td>
<p>The median of off-diagonal of distance matrix multiplied by rangeHStart will be used
as the initial values for optimization of hyper parameters.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_savestyle">saveStyle</code></td>
<td>
<p>This argument specifies how to save the plot of phylogenetic tree.
The function offers 'png', 'pdf', 'jpg', and 'tiff'.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_pchbase">pchBase</code></td>
<td>
<p>A vector of two integers specifying the plot types for the positive and negative genotypic values respectively.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_colnodebase">colNodeBase</code></td>
<td>
<p>A vector of two integers or chracters specifying color of nodes for the positive and negative genotypic values respectively.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_coltipbase">colTipBase</code></td>
<td>
<p>A vector of integers or chracters specifying color of tips for the positive and negative genotypic values respectively.
The length of the vector should equal to the number of subpopulations.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_cexmax">cexMax</code></td>
<td>
<p>A numeric specifying the maximum point size of the plot.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_cexmin">cexMin</code></td>
<td>
<p>A numeric specifying the minimum point size of the plot.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_edgecoloring">edgeColoring</code></td>
<td>
<p>If TRUE, the edge branch of phylogenetic tree wiil be colored.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_tiplabel">tipLabel</code></td>
<td>
<p>If TRUE, lavels for tips will be shown.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_ggplottree">ggPlotTree</code></td>
<td>
<p>If TRUE, the function will return the ggplot version of phylogenetic tree.
It offers the precise information on subgroups for each haplotype.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_cexmaxforgg">cexMaxForGG</code></td>
<td>
<p>A numeric specifying the maximum point size of the plot for ggtree,
relative to the range of x and y-axes (0 &lt; cexMaxForGG &lt;= 1).</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_cexminforgg">cexMinForGG</code></td>
<td>
<p>A numeric specifying the minimum point size of the plot for ggtree,
relative to the range of x and y-axes (0 &lt; cexMaxForGG &lt;= 1).</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_alphabase">alphaBase</code></td>
<td>
<p>alpha (parameter that indicates the opacity of a geom) for tip with positive / negative effects.
alpha for node will be same as the alpha for tip with negative effects.</p>
</td></tr>
<tr><td><code id="estPhylo_+3A_verbose">verbose</code></td>
<td>
<p>If this argument is TRUE, messages for the current step_s will be shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list / lists of
</p>
<dl>
<dt>$haplotypeInfo</dt><dd><p>A list of haplotype information with
</p>
<dl>
<dt>$haploCluster</dt><dd><p>A vector indicating each individual belongs to which haplotypes.</p>
</dd>
<dt>$haploMat</dt><dd><p>A n x h matrix where n is the number of genotypes and h is the number of haplotypes.</p>
</dd>
<dt>$haploBlock</dt><dd><p>Marker genotype of haplotype block of interest for the representing haplotypes.</p>
</dd>
</dl>

</dd>
<dt>$subpopInfo</dt><dd><p>The information of subpopulations.</p>
</dd>
<dt>$distMats</dt><dd><p>A list of distance matrix:
</p>
<dl>
<dt>$distMat</dt><dd><p>Distance matrix between haplotypes.</p>
</dd>
<dt>$distMatEvol</dt><dd><p>Evolutionary distance matrix between haplotypes.</p>
</dd>
<dt>$distMatNJ</dt><dd><p>Phylogenetic distance matrix between haplotypes including nodes.</p>
</dd>
</dl>

</dd>
<dt>$pValChi2Test</dt><dd><p>A p-value of the chi-square test for the dependency between haplotypes &amp; subpopulations.
If 'chi2Test = FALSE', 'NA' will be returned.</p>
</dd>
<dt>$njRes</dt><dd><p>The result of phylogenetic tree by neighborhood-joining method</p>
</dd>
<dt>$gvTotal</dt><dd><p>Estimated genotypic values by kernel regression for each haplotype.</p>
</dd>
<dt>$gvTotalForLine</dt><dd><p>Estimated genotypic values by kernel regression for each individual.</p>
</dd>
<dt>$minuslog10p</dt><dd><p><code class="reqn">-log_{10}(p)</code> for haplotype block of interest.
p is the p-value for the siginifacance of the haplotype block effect.</p>
</dd>
<dt>$hOpts</dt><dd><p>Optimized hyper parameters, hOpt1 &amp; hOpt2.</p>
</dd>
<dt>$EMMResults</dt><dd><p>A list of estimated results of kernel regression:
</p>
<dl>
<dt>$EM3Res</dt><dd><p>Estimated results of kernel regression for the estimation of haplotype effects. (1st step)</p>
</dd>
<dt>$EMMRes</dt><dd><p>Estimated results of kernel regression for the estimation of haplotype effects of nodes. (2nd step)</p>
</dd>
<dt>$EMM0Res</dt><dd><p>Estimated results of kernel regression for the null model.</p>
</dd>
</dl>

</dd>
<dt>$clusterNosForHaplotype</dt><dd><p>A list of cluster Nos of individuals that belong to each haplotype.</p>
</dd>
</dl>


<hr>
<h2 id='genesetmap'>Function to generate map for gene set</h2><span id='topic+genesetmap'></span>

<h3>Description</h3>

<p>Function to generate map for gene set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genesetmap(map, gene.set, cumulative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genesetmap_+3A_map">map</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.</p>
</td></tr>
<tr><td><code id="genesetmap_+3A_gene.set">gene.set</code></td>
<td>
<p>Gene information with the format of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;map&quot; argument.</p>
</td></tr>
<tr><td><code id="genesetmap_+3A_cumulative">cumulative</code></td>
<td>
<p>If this argument is TRUE, cumulative position will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Map for gene set.
</p>

<hr>
<h2 id='genetrait'>Generate pseudo phenotypic values</h2><span id='topic+genetrait'></span>

<h3>Description</h3>

<p>This function generates pseudo phenotypic values according to the following formula.
</p>
<p style="text-align: center;"><code class="reqn">y = X \beta + Z u + e</code>
</p>

<p>where effects of major genes are regarded as fixed effects <code class="reqn">\beta</code> and
polygenetic effects are regarded as random effects <code class="reqn">u</code>.
The variances of <code class="reqn">u</code> and <code class="reqn">e</code> are automatically determined by the heritability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genetrait(
  x,
  sample.sets = NULL,
  candidate = NULL,
  pos = NULL,
  x.par = NULL,
  ZETA = NULL,
  x2 = NULL,
  num.qtn = 3,
  weight = c(2, 1, 1),
  qtn.effect = rep("A", num.qtn),
  prop = 1,
  polygene.weight = 1,
  polygene = TRUE,
  h2 = 0.6,
  h.correction = FALSE,
  seed = NULL,
  plot = TRUE,
  saveAt = NULL,
  subpop = NULL,
  return.all = FALSE,
  seed.env = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genetrait_+3A_x">x</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_sample.sets">sample.sets</code></td>
<td>
<p>A n.sample x n.mark genotype matrix. Markers with fixed effects (QTNs) are chosen from sample.sets.
If sample.sets = NULL, sample.sets = x.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_candidate">candidate</code></td>
<td>
<p>If you want to fix QTN postitions, please set the number where SNPs to be fixed are located in your data (so not position).
If candidate = NULL, QTNs were randomly sampled from sample.sets or x.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_pos">pos</code></td>
<td>
<p>A n.mark x 1 vector. Cumulative position (over chromosomes) of each marker.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_x.par">x.par</code></td>
<td>
<p>If you don't want to match the sampling population and the genotype data to QTN effects, then use this argument as the latter.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_zeta">ZETA</code></td>
<td>
<p>A list of covariance (relationship) matrix (K: <code class="reqn">m \times m</code>) and its design matrix (Z: <code class="reqn">n \times m</code>) of random effects.
Please set names of list &quot;Z&quot; and &quot;K&quot;! You can use more than one kernel matrix.
For example,
</p>
<p>ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D))
</p>

<dl>
<dt>Z.A, Z.D</dt><dd><p>Design matrix (<code class="reqn">n \times m</code>) for the random effects. So, in many cases, you can use the identity matrix.</p>
</dd>
<dt>K.A, K.D</dt><dd><p>Different kernels which express some relationships between lines.</p>
</dd>
</dl>

<p>For example, K.A is additive relationship matrix for the covariance between lines, and K.D is dominance relationship matrix.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_x2">x2</code></td>
<td>
<p>A genotype matrix to calculate additive relationship matrix when Z.ETA = NULL.
If Z.ETA = NULL &amp; x2 = NULL, calcGRM(x) will be calculated as kernel matrix.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_num.qtn">num.qtn</code></td>
<td>
<p>The number of QTNs</p>
</td></tr>
<tr><td><code id="genetrait_+3A_weight">weight</code></td>
<td>
<p>The weights for each QTN by their standard deviations. Negative value is also allowed.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_qtn.effect">qtn.effect</code></td>
<td>
<p>Additive of dominance for each marker effect. This argument should be the same length as num.qtn.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_prop">prop</code></td>
<td>
<p>The proportion of effects of QTNs to polygenetic effects.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_polygene.weight">polygene.weight</code></td>
<td>
<p>If there are multiple kernels, this argument determines the weights of each kernel effect.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_polygene">polygene</code></td>
<td>
<p>If polygene = FALSE, pseudo phenotypes with only QTN effects will be generated.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_h2">h2</code></td>
<td>
<p>The wide-sense heritability for generating phenotypes. 0 &lt;= h2 &lt; 1</p>
</td></tr>
<tr><td><code id="genetrait_+3A_h.correction">h.correction</code></td>
<td>
<p>If TRUE, this function will generate phenotypes to match the genomic heritability and &quot;h2&quot;.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_seed">seed</code></td>
<td>
<p>If seed is not NULL, some fixed phenotypic values will be generated according to set.seed(seed)</p>
</td></tr>
<tr><td><code id="genetrait_+3A_plot">plot</code></td>
<td>
<p>If TRUE, boxplot for generated phenotypic values will be drawn.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_saveat">saveAt</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveAt, you should substitute the name you want to save.
When saveAt = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_subpop">subpop</code></td>
<td>
<p>If there is subpopulation structure, you can draw boxpots divide by subpopulations.
n.sample x n.subpop matrix. Please indicate the subpopulation information by (0, 1) for each element.
(0 means that line doen't belong to that subpopulation, and 1 means that line belongs to that subpopulation)</p>
</td></tr>
<tr><td><code id="genetrait_+3A_return.all">return.all</code></td>
<td>
<p>If FALSE, only returns generated phenotypic values.
If TRUE, this function will return other information such as positions of candidate QTNs.</p>
</td></tr>
<tr><td><code id="genetrait_+3A_seed.env">seed.env</code></td>
<td>
<p>If TRUE, this function will generate different environment effects every time.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>trait</dt><dd><p>Generated phenotypic values</p>
</dd>
<dt>u</dt><dd><p>Generated genotyope values</p>
</dd>
<dt>e</dt><dd><p>Generated environmental effects</p>
</dd>
<dt>candidate</dt><dd><p>The numbers where QTNs are located in your data (so not position).</p>
</dd>
<dt>qtn.position</dt><dd><p>QTN positions</p>
</dd>
<dt>heritability</dt><dd><p>Genomic heritability for generated phenotypic values.</p>
</dd>
</dl>


<hr>
<h2 id='is.diag'>Function to judge the square matrix whether it is diagonal matrix or not</h2><span id='topic+is.diag'></span>

<h3>Description</h3>

<p>Function to judge the square matrix whether it is diagonal matrix or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.diag(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.diag_+3A_x">x</code></td>
<td>
<p>Square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'x' is diagonal matrix, 'TRUE'. Otherwise the function returns 'FALSE'.
</p>

<hr>
<h2 id='MAF.cut'>Function to remove the minor alleles</h2><span id='topic+MAF.cut'></span>

<h3>Description</h3>

<p>Function to remove the minor alleles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAF.cut(
  x.0,
  map.0 = NULL,
  min.MAF = 0.05,
  max.HE = 0.999,
  max.MS = 0.05,
  return.MAF = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAF.cut_+3A_x.0">x.0</code></td>
<td>
<p>A <code class="reqn">n \times m</code> original marker genotype matrix.</p>
</td></tr>
<tr><td><code id="MAF.cut_+3A_map.0">map.0</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.</p>
</td></tr>
<tr><td><code id="MAF.cut_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is removed from the original marker genotype data.</p>
</td></tr>
<tr><td><code id="MAF.cut_+3A_max.he">max.HE</code></td>
<td>
<p>Specifies the maximum heterozygous rate (HE).
If a marker has a HE more than max.HE, it is removed from the original marker genotype data.</p>
</td></tr>
<tr><td><code id="MAF.cut_+3A_max.ms">max.MS</code></td>
<td>
<p>Specifies the maximum missing rate (MS).
If a marker has a MS more than max.MS, it is removed from the original marker genotype data.</p>
</td></tr>
<tr><td><code id="MAF.cut_+3A_return.maf">return.MAF</code></td>
<td>
<p>If TRUE, MAF will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$x</dt><dd><p>The modified marker genotype data whose SNPs with MAF &lt;= min.MAF were removed.</p>
</dd>
<dt>$map</dt><dd><p>The modified map information whose SNPs with MAF &lt;= min.MAF were removed.</p>
</dd>
<dt>$before</dt><dd><p>Minor allele frequencies of the original marker genotype.</p>
</dd>
<dt>$after</dt><dd><p>Minor allele frequencies of the modified marker genotype.</p>
</dd>
</dl>


<hr>
<h2 id='make.full'>Change a matrix to full-rank matrix</h2><span id='topic+make.full'></span>

<h3>Description</h3>

<p>Change a matrix to full-rank matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.full(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.full_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix which you want to change into full-rank matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A full-rank matrix
</p>

<hr>
<h2 id='manhattan'>Draw manhattan plot</h2><span id='topic+manhattan'></span>

<h3>Description</h3>

<p>Draw manhattan plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manhattan(
  input,
  sig.level = 0.05,
  method.thres = "BH",
  y.max = NULL,
  cex = 1,
  cex.lab = 1,
  lwd.thres = 1,
  plot.col1 = c("dark blue", "cornflowerblue"),
  cex.axis.x = 1,
  cex.axis.y = 1,
  plot.type = "p",
  plot.pch = 16
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manhattan_+3A_input">input</code></td>
<td>
<p>Data frame of GWAS results where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level for the threshold. The default is 0.05.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_method.thres">method.thres</code></td>
<td>
<p>Method for detemining threshold of significance. &quot;BH&quot; and &quot;Bonferroni are offered.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_y.max">y.max</code></td>
<td>
<p>The maximum value for the vertical axis of manhattan plot. If NULL, automatically determined.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_cex">cex</code></td>
<td>
<p>A numerical value giving the amount by which plotting text and symbols should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_cex.lab">cex.lab</code></td>
<td>
<p>The font size of the labels.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_lwd.thres">lwd.thres</code></td>
<td>
<p>The line width for the threshold.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_plot.col1">plot.col1</code></td>
<td>
<p>This argument determines the color of the manhattan plot.
You should substitute this argument as color vector whose length is 2.
plot.col1[1] for odd chromosomes and plot.col1[2] for even chromosomes.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_cex.axis.x">cex.axis.x</code></td>
<td>
<p>The font size of the x axis.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_cex.axis.y">cex.axis.y</code></td>
<td>
<p>The font size of the y axis.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_plot.type">plot.type</code></td>
<td>
<p>This argument determines the type of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_plot.pch">plot.pch</code></td>
<td>
<p>This argument determines the shape of the dot of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draw manhttan plot
</p>

<hr>
<h2 id='manhattan.plus'>Add points of -log10(p) corrected by kernel methods to manhattan plot</h2><span id='topic+manhattan.plus'></span>

<h3>Description</h3>

<p>Add points of -log10(p) corrected by kernel methods to manhattan plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manhattan.plus(
  input,
  checks,
  cex = 1,
  plot.col1 = c("dark blue", "cornflowerblue"),
  plot.col3 = c("red3", "orange3"),
  plot.type = "p",
  plot.pch = 16
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manhattan.plus_+3A_input">input</code></td>
<td>
<p>Data frame of GWAS results where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="manhattan.plus_+3A_checks">checks</code></td>
<td>
<p>The marker numbers whose -log10(p)s are corrected by kernel methods.</p>
</td></tr>
<tr><td><code id="manhattan.plus_+3A_cex">cex</code></td>
<td>
<p>A numerical value giving the amount by which plotting text and symbols should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="manhattan.plus_+3A_plot.col1">plot.col1</code></td>
<td>
<p>This argument determines the color of the manhattan plot.
You should substitute this argument as a color vector whose length is 2.
plot.col1[1] for odd chromosomes and plot.col1[2] for even chromosomes.</p>
</td></tr>
<tr><td><code id="manhattan.plus_+3A_plot.col3">plot.col3</code></td>
<td>
<p>Color of -log10(p) corrected by kernel methods. plot.col3[1] for odd chromosomes and plot.col3[2] for even chromosomes</p>
</td></tr>
<tr><td><code id="manhattan.plus_+3A_plot.type">plot.type</code></td>
<td>
<p>This argument determines the type of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="manhattan.plus_+3A_plot.pch">plot.pch</code></td>
<td>
<p>This argument determines the shape of the dot of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draw manhttan plot
</p>

<hr>
<h2 id='manhattan2'>Draw manhattan plot (another method)</h2><span id='topic+manhattan2'></span>

<h3>Description</h3>

<p>Draw manhattan plot (another method)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manhattan2(
  input,
  sig.level = 0.05,
  method.thres = "BH",
  cex = 1,
  plot.col2 = 1,
  plot.type = "p",
  plot.pch = 16,
  cum.pos = NULL,
  lwd.thres = 1,
  cex.lab = 1,
  cex.axis = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manhattan2_+3A_input">input</code></td>
<td>
<p>Data frame of GWAS results where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="manhattan2_+3A_sig.level">sig.level</code></td>
<td>
<p>Siginifincance level for the threshold. The default is 0.05.</p>
</td></tr>
<tr><td><code id="manhattan2_+3A_method.thres">method.thres</code></td>
<td>
<p>Method for detemining threshold of significance. &quot;BH&quot; and &quot;Bonferroni are offered.</p>
</td></tr>
<tr><td><code id="manhattan2_+3A_cex">cex</code></td>
<td>
<p>A numerical value giving the amount by which plotting text and symbols should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="manhattan2_+3A_plot.col2">plot.col2</code></td>
<td>
<p>Color of the manhattan plot. color changes with chromosome and it starts from plot.col2 + 1
(so plot.col2 = 1 means color starts from red.)</p>
</td></tr>
<tr><td><code id="manhattan2_+3A_plot.type">plot.type</code></td>
<td>
<p>This argument determines the type of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="manhattan2_+3A_plot.pch">plot.pch</code></td>
<td>
<p>This argument determines the shape of the dot of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="manhattan2_+3A_cum.pos">cum.pos</code></td>
<td>
<p>Cumulative position (over chromosomes) of each marker</p>
</td></tr>
<tr><td><code id="manhattan2_+3A_lwd.thres">lwd.thres</code></td>
<td>
<p>The line width for the threshold.</p>
</td></tr>
<tr><td><code id="manhattan2_+3A_cex.lab">cex.lab</code></td>
<td>
<p>The font size of the labels.</p>
</td></tr>
<tr><td><code id="manhattan2_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The font size of the axes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draw manhttan plot
</p>

<hr>
<h2 id='manhattan3'>Draw the effects of epistasis (3d plot and 2d plot)</h2><span id='topic+manhattan3'></span>

<h3>Description</h3>

<p>Draw the effects of epistasis (3d plot and 2d plot)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manhattan3(
  input,
  map,
  cum.pos,
  plot.epi.3d = TRUE,
  plot.epi.2d = TRUE,
  main.epi.3d = NULL,
  main.epi.2d = NULL,
  saveName = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manhattan3_+3A_input">input</code></td>
<td>
<p>List of results of RGWAS.epistasis / RGWAS.twostep.epi. If the output of 'RGWAS.epistasis' is 'res',
'input' corresponds to 'res$scores'. If the output of 'RGWAS.twostep.epi.' is 'res',
'input' corresponds to 'res$epistasis$scores'. See: Value of <a href="#topic+RGWAS.epistasis">RGWAS.epistasis</a></p>
</td></tr>
<tr><td><code id="manhattan3_+3A_map">map</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.
This is map information for SNPs which are tested epistatic effects.</p>
</td></tr>
<tr><td><code id="manhattan3_+3A_cum.pos">cum.pos</code></td>
<td>
<p>Cumulative position (over chromosomes) of each marker</p>
</td></tr>
<tr><td><code id="manhattan3_+3A_plot.epi.3d">plot.epi.3d</code></td>
<td>
<p>If TRUE, draw 3d plot</p>
</td></tr>
<tr><td><code id="manhattan3_+3A_plot.epi.2d">plot.epi.2d</code></td>
<td>
<p>If TRUE, draw 2d plot</p>
</td></tr>
<tr><td><code id="manhattan3_+3A_main.epi.3d">main.epi.3d</code></td>
<td>
<p>The title of 3d plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="manhattan3_+3A_main.epi.2d">main.epi.2d</code></td>
<td>
<p>The title of 2d plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="manhattan3_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveAt = NULL, the plot is not saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draw 3d plot and 2d plot to show epistatic effects
</p>

<hr>
<h2 id='modify.data'>Function to modify genotype and phenotype data to match</h2><span id='topic+modify.data'></span>

<h3>Description</h3>

<p>Function to modify genotype and phenotype data to match
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify.data(
  pheno.mat,
  geno.mat,
  pheno.labels = NULL,
  geno.names = NULL,
  map = NULL,
  return.ZETA = TRUE,
  return.GWAS.format = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify.data_+3A_pheno.mat">pheno.mat</code></td>
<td>
<p>A <code class="reqn">n _ 1 \times p</code> matrix of phenotype data. rownames(pheno.mat) should be genotype (line; accesion; variety) names.</p>
</td></tr>
<tr><td><code id="modify.data_+3A_geno.mat">geno.mat</code></td>
<td>
<p>A <code class="reqn">n _ 2 \times m</code> matrix of marker genotype data. rownames(geno.mat) should be genotype (line; accesion; variety) names.</p>
</td></tr>
<tr><td><code id="modify.data_+3A_pheno.labels">pheno.labels</code></td>
<td>
<p>A vector of genotype (line; accesion; variety) names which correpond to phenotypic values.</p>
</td></tr>
<tr><td><code id="modify.data_+3A_geno.names">geno.names</code></td>
<td>
<p>A vector of genotype (line; accesion; variety) names for marker genotype data (duplication is not recommended).</p>
</td></tr>
<tr><td><code id="modify.data_+3A_map">map</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.</p>
</td></tr>
<tr><td><code id="modify.data_+3A_return.zeta">return.ZETA</code></td>
<td>
<p>If this argument is TRUE, the list for mixed model equation (ZETA) will be returned.</p>
</td></tr>
<tr><td><code id="modify.data_+3A_return.gwas.format">return.GWAS.format</code></td>
<td>
<p>If this argument is TRUE, phenotype and genotype data for GWAS will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$geno.modi</dt><dd><p>The modified marker genotype data.</p>
</dd>
<dt>$pheno.modi</dt><dd><p>The modified phenotype data.</p>
</dd>
<dt>$ZETA</dt><dd><p>The list for mixed model equation (ZETA).</p>
</dd>
<dt>$pheno.GWAS</dt><dd><p>GWAS formatted phenotype data.</p>
</dd>
<dt>$geno.GWAS</dt><dd><p>GWAS formatted marker genotype data.</p>
</dd>
</dl>


<hr>
<h2 id='parallel.compute'>Function to parallelize computation with various methods</h2><span id='topic+parallel.compute'></span>

<h3>Description</h3>

<p>Function to parallelize computation with various methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel.compute(
  vec,
  func,
  n.core = 2,
  parallel.method = "mclapply",
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parallel.compute_+3A_vec">vec</code></td>
<td>
<p>Numeric vector including the values that are computed in parallel.</p>
</td></tr>
<tr><td><code id="parallel.compute_+3A_func">func</code></td>
<td>
<p>The function to be applied to each element of 'vec' argument.
This function must only have one argument.</p>
</td></tr>
<tr><td><code id="parallel.compute_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="parallel.compute_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="parallel.compute_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of the results for each element of 'vec' argument.
</p>

<hr>
<h2 id='plotHaploNetwork'>Function to plot haplotype network from the estimated results</h2><span id='topic+plotHaploNetwork'></span>

<h3>Description</h3>

<p>Function to plot haplotype network from the estimated results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHaploNetwork(
  estNetworkRes,
  traitName = NULL,
  blockName = NULL,
  plotNetwork = TRUE,
  subpopInfo = estNetworkRes$subpopInfo,
  saveName = NULL,
  saveStyle = "png",
  plotWhichMDS = 1:2,
  colConnection = c("grey40", "grey60"),
  ltyConnection = c("solid", "dashed"),
  lwdConnection = c(1.5, 0.8),
  pchBase = c(1, 16),
  colCompBase = c(2, 4),
  colHaploBase = c(3, 5, 6),
  cexMax = 2,
  cexMin = 0.7,
  ggPlotNetwork = FALSE,
  cexMaxForGG = 0.025,
  cexMinForGG = 0.008,
  alphaBase = c(0.9, 0.3)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotHaploNetwork_+3A_estnetworkres">estNetworkRes</code></td>
<td>
<p>The estimated results of haplotype network by 'estNetwork' function for one</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_traitname">traitName</code></td>
<td>
<p>Name of trait of interest. This will be used in the title of the plots.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_blockname">blockName</code></td>
<td>
<p>You can specify the haplotype block (or gene set, SNP-set) of interest by the name of haplotype block in 'geno'.
This will be used in the title of the plots.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_plotnetwork">plotNetwork</code></td>
<td>
<p>If TRUE, the function will return the plot of haplotype network.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_subpopinfo">subpopInfo</code></td>
<td>
<p>The information of subpopulations.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_savestyle">saveStyle</code></td>
<td>
<p>This argument specifies how to save the plot of phylogenetic tree.
The function offers 'png', 'pdf', 'jpg', and 'tiff'.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_plotwhichmds">plotWhichMDS</code></td>
<td>
<p>We will show the MDS (multi-dimensional scaling) plot,
and this argument is a vector of two integers specifying that will define which MDS dimension will be plotted.
The first and second integers correspond to the horizontal and vertical axes, respectively.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_colconnection">colConnection</code></td>
<td>
<p>A vector of two integers or characters specifying the colors of connection between nodes for the original and complemented haplotypes, respectively.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_ltyconnection">ltyConnection</code></td>
<td>
<p>A vector of two characters specifying the line types of connection between nodes for the original and complemented haplotypes, respectively.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_lwdconnection">lwdConnection</code></td>
<td>
<p>A vector of two integers specifying the line widths of connection between nodes for the original and complemented haplotypes, respectively.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_pchbase">pchBase</code></td>
<td>
<p>A vector of two integers specifying the plot types for the positive and negative genotypic values respectively.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_colcompbase">colCompBase</code></td>
<td>
<p>A vector of two integers or characters specifying color of complemented haplotypes for the positive and negative genotypic values respectively.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_colhaplobase">colHaploBase</code></td>
<td>
<p>A vector of integers or characters specifying color of original haplotypes for the positive and negative genotypic values respectively.
The length of the vector should equal to the number of subpopulations.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_cexmax">cexMax</code></td>
<td>
<p>A numeric specifying the maximum point size of the plot.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_cexmin">cexMin</code></td>
<td>
<p>A numeric specifying the minimum point size of the plot.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_ggplotnetwork">ggPlotNetwork</code></td>
<td>
<p>If TRUE, the function will return the ggplot version of haplotype network.
It offers the precise information on subgroups for each haplotype.</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_cexmaxforgg">cexMaxForGG</code></td>
<td>
<p>A numeric specifying the maximum point size of the plot for the ggplot version of haplotype network,
relative to the range of x and y-axes (0 &lt; cexMaxForGG &lt;= 1).</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_cexminforgg">cexMinForGG</code></td>
<td>
<p>A numeric specifying the minimum point size of the plot for the ggplot version of haplotype network,
relative to the range of x and y-axes (0 &lt; cexMaxForGG &lt;= 1).</p>
</td></tr>
<tr><td><code id="plotHaploNetwork_+3A_alphabase">alphaBase</code></td>
<td>
<p>alpha (parameter that indicates the opacity of a geom) for original haplotype with positive / negative effects.
alpha for complemented haplotype will be same as the alpha for original haplotype with negative effects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draw plot of haplotype network.
</p>

<hr>
<h2 id='plotPhyloTree'>Function to plot phylogenetic tree from the estimated results</h2><span id='topic+plotPhyloTree'></span>

<h3>Description</h3>

<p>Function to plot phylogenetic tree from the estimated results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPhyloTree(
  estPhyloRes,
  traitName = NULL,
  blockName = NULL,
  plotTree = TRUE,
  subpopInfo = estPhyloRes$subpopInfo,
  saveName = NULL,
  saveStyle = "png",
  pchBase = c(1, 16),
  colNodeBase = c(2, 4),
  colTipBase = c(3, 5, 6),
  cexMax = 2,
  cexMin = 0.7,
  edgeColoring = TRUE,
  tipLabel = TRUE,
  ggPlotTree = FALSE,
  cexMaxForGG = 0.12,
  cexMinForGG = 0.06,
  alphaBase = c(0.9, 0.3)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotPhyloTree_+3A_estphylores">estPhyloRes</code></td>
<td>
<p>The estimated results of phylogenetic analysis by 'estPhylo' function for one</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_traitname">traitName</code></td>
<td>
<p>Name of trait of interest. This will be used in the title of the plots.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_blockname">blockName</code></td>
<td>
<p>You can specify the haplotype block (or gene set, SNP-set) of interest by the name of haplotype block in 'geno'.
This will be used in the title of the plots.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_plottree">plotTree</code></td>
<td>
<p>If TRUE, the function will return the plot of phylogenetic tree.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_subpopinfo">subpopInfo</code></td>
<td>
<p>The information of subpopulations.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_savestyle">saveStyle</code></td>
<td>
<p>This argument specifies how to save the plot of phylogenetic tree.
The function offers 'png', 'pdf', 'jpg', and 'tiff'.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_pchbase">pchBase</code></td>
<td>
<p>A vector of two integers specifying the plot types for the positive and negative genotypic values respectively.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_colnodebase">colNodeBase</code></td>
<td>
<p>A vector of two integers or chracters specifying color of nodes for the positive and negative genotypic values respectively.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_coltipbase">colTipBase</code></td>
<td>
<p>A vector of integers or chracters specifying color of tips for the positive and negative genotypic values respectively.
The length of the vector should equal to the number of subpopulations.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_cexmax">cexMax</code></td>
<td>
<p>A numeric specifying the maximum point size of the plot.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_cexmin">cexMin</code></td>
<td>
<p>A numeric specifying the minimum point size of the plot.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_edgecoloring">edgeColoring</code></td>
<td>
<p>If TRUE, the edge branch of phylogenetic tree wiil be colored.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_tiplabel">tipLabel</code></td>
<td>
<p>If TRUE, lavels for tips will be shown.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_ggplottree">ggPlotTree</code></td>
<td>
<p>If TRUE, the function will return the ggplot version of phylogenetic tree.
It offers the precise information on subgroups for each haplotype.</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_cexmaxforgg">cexMaxForGG</code></td>
<td>
<p>A numeric specifying the maximum point size of the plot for ggtree,
relative to the range of x and y-axes (0 &lt; cexMaxForGG &lt;= 1).</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_cexminforgg">cexMinForGG</code></td>
<td>
<p>A numeric specifying the minimum point size of the plot for ggtree,
relative to the range of x and y-axes (0 &lt; cexMaxForGG &lt;= 1).</p>
</td></tr>
<tr><td><code id="plotPhyloTree_+3A_alphabase">alphaBase</code></td>
<td>
<p>alpha (parameter that indicates the opacity of a geom) for tip with positive / negative effects.
alpha for node will be same as the alpha for tip with negative effects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draw plots of phylogenetic tree.
</p>

<hr>
<h2 id='qq'>Draw qq plot</h2><span id='topic+qq'></span>

<h3>Description</h3>

<p>Draw qq plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qq(scores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qq_+3A_scores">scores</code></td>
<td>
<p>A vector of -log10(p) for each marker</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draw qq plot
</p>

<hr>
<h2 id='RGWAS.epistasis'>Check epistatic effects by kernel-based GWAS (genome-wide association studies)</h2><span id='topic+RGWAS.epistasis'></span>

<h3>Description</h3>

<p>Check epistatic effects by kernel-based GWAS (genome-wide association studies)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGWAS.epistasis(
  pheno,
  geno,
  ZETA = NULL,
  package.MM = "gaston",
  covariate = NULL,
  covariate.factor = NULL,
  structure.matrix = NULL,
  n.PC = 0,
  min.MAF = 0.02,
  n.core = 1,
  parallel.method = "mclapply",
  test.method = "LR",
  dominance.eff = TRUE,
  skip.self.int = FALSE,
  haplotype = TRUE,
  num.hap = NULL,
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  optimizer = "nlminb",
  gene.set = NULL,
  map.gene.set = NULL,
  plot.epi.3d = TRUE,
  plot.epi.2d = TRUE,
  main.epi.3d = NULL,
  main.epi.2d = NULL,
  saveName = NULL,
  skip.check = FALSE,
  verbose = TRUE,
  verbose2 = FALSE,
  count = TRUE,
  time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGWAS.epistasis_+3A_pheno">pheno</code></td>
<td>
<p>Data frame where the first column is the line name (gid). The remaining columns should be a phenotype to test.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_geno">geno</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.
Columns 4 and higher contain the marker scores for each line, coded as [-1, 0, 1] = [aa, Aa, AA].</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_zeta">ZETA</code></td>
<td>
<p>A list of covariance (relationship) matrix (K: <code class="reqn">m \times m</code>) and its design matrix (Z: <code class="reqn">n \times m</code>) of random effects.
Please set names of list &quot;Z&quot; and &quot;K&quot;! You can use more than one kernel matrix.
For example,
</p>
<p>ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D))
</p>

<dl>
<dt>Z.A, Z.D</dt><dd><p>Design matrix (<code class="reqn">n \times m</code>) for the random effects. So, in many cases, you can use the identity matrix.</p>
</dd>
<dt>K.A, K.D</dt><dd><p>Different kernels which express some relationships between lines.</p>
</dd>
</dl>

<p>For example, K.A is additive relationship matrix for the covariance between lines, and K.D is dominance relationship matrix.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_covariate">covariate</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector or a <code class="reqn">n \times p _ 1</code> matrix. You can insert continuous values, such as other traits or genotype score for special markers.
This argument is regarded as one of the fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_covariate.factor">covariate.factor</code></td>
<td>
<p>A <code class="reqn">n \times p _ 2</code> dataframe. You should assign a factor vector for each column.
Then RGWAS changes this argument into model matrix, and this model matrix will be included in the model as fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_structure.matrix">structure.matrix</code></td>
<td>
<p>You can use structure matrix calculated by structure analysis when there are population structure.
You should not use this argument with n.PC &gt; 0.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_n.pc">n.PC</code></td>
<td>
<p>Number of principal components to include as fixed effects. Default is 0 (equals K model).</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_test.method">test.method</code></td>
<td>
<p>RGWAS supports two methods to test effects of each SNP-set.
</p>

<dl>
<dt>&quot;LR&quot;</dt><dd><p>Likelihood-ratio test, relatively slow, but accurate (default).</p>
</dd>
<dt>&quot;score&quot;</dt><dd><p>Score test, much faster than LR, but sometimes overestimate -log10(p).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_dominance.eff">dominance.eff</code></td>
<td>
<p>If this argument is TRUE, dominance effect is included in the model,
and additive x dominance and dominance x dominance are also tested as epistatic effects.
When you use inbred lines, please set this argument FALSE.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_skip.self.int">skip.self.int</code></td>
<td>
<p>As default, the function also tests the self-interactions among the same SNP-sets.
If you want to avoid this, please set 'skip.self.int = TRUE'.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the deviance is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene (or haplotype block), you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_map.gene.set">map.gene.set</code></td>
<td>
<p>Genotype map for 'gene.set' (list of haplotype blocks).
This is a data.frame with the haplotype block (SNP-set, or gene-set) names in the first column.
The second and third columns contain the chromosome and map position for each block.
The forth column contains the cumulative map position for each block, which can be computed by <code><a href="#topic+cumsumPos">cumsumPos</a></code> function.
If this argument is NULL, the map will be constructed by <code><a href="#topic+genesetmap">genesetmap</a></code> function after the SNP-set GWAS.
It will take some time, so you can reduce the computational time by assigning this argument beforehand.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_plot.epi.3d">plot.epi.3d</code></td>
<td>
<p>If TRUE, draw 3d plot</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_plot.epi.2d">plot.epi.2d</code></td>
<td>
<p>If TRUE, draw 2d plot</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_main.epi.3d">main.epi.3d</code></td>
<td>
<p>The title of 3d plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_main.epi.2d">main.epi.2d</code></td>
<td>
<p>The title of 2d plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_skip.check">skip.check</code></td>
<td>
<p>As default, RAINBOWR checks the type of input data and modifies it into the correct format.
However, it will take some time, so if you prepare the correct format of input data, you can skip this procedure
by setting 'skip.check = TRUE'.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_verbose">verbose</code></td>
<td>
<p>If this argument is TRUE, messages for the current steps will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_verbose2">verbose2</code></td>
<td>
<p>If this argument is TRUE, welcome message will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
<tr><td><code id="RGWAS.epistasis_+3A_time">time</code></td>
<td>
<p>When time is TRUE, you can know how much time it took to perform RGWAS.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$map</dt><dd><p>Map information for SNPs which are tested epistatic effects.</p>
</dd>
<dt>$scores</dt><dd>
<dl>
<dt>$scores</dt><dd><p>This is the matrix which contains -log10(p) calculated by the test about epistasis effects.</p>
</dd>
<dt>$x, $y</dt><dd><p>The information of the positions of SNPs detected by regular GWAS.
These vectors are used when drawing plots. Each output correspond to the replication of row and column of scores.</p>
</dd>
<dt>$z</dt><dd><p>This is a vector of $scores.  This vector is also used when drawing plots.</p>
</dd>
</dl>

</dd>
</dl>



<h3>References</h3>

<p>Storey, J.D. and Tibshirani, R. (2003) Statistical significance for genomewide studies. Proc Natl Acad Sci. 100(16): 9440-9445.
</p>
<p>Yu, J. et al. (2006) A unified mixed-model method for association mapping that accounts for multiple levels of relatedness. Nat Genet. 38(2): 203-208.
</p>
<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Endelman, J.B. (2011) Ridge Regression and Other Kernels for Genomic Selection with R Package rrBLUP. Plant Genome J. 4(3): 250.
</p>
<p>Endelman, J.B. and Jannink, J.L. (2012) Shrinkage Estimation of the Realized Relationship Matrix. G3 Genes, Genomes, Genet. 2(11): 1405-1413.
</p>
<p>Su, G. et al. (2012) Estimating Additive and Non-Additive Genetic Variances and Predicting Genetic Merits Using Genome-Wide Dense Single Nucleotide Polymorphism Markers. PLoS One. 7(9): 1-7.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis for association studies. Nat Genet. 44(7): 821-824.
</p>
<p>Listgarten, J. et al. (2013) A powerful and efficient set test for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>
<p>Jiang, Y. and Reif, J.C. (2015) Modeling epistasis in genomic selection. Genetics. 201(2): 759-768.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



  ### Import RAINBOWR
  require(RAINBOWR)

  ### Load example datasets
  data("Rice_Zhao_etal")
  Rice_geno_score &lt;- Rice_Zhao_etal$genoScore
  Rice_geno_map &lt;- Rice_Zhao_etal$genoMap
  Rice_pheno &lt;- Rice_Zhao_etal$pheno
  Rice_haplo_block &lt;- Rice_Zhao_etal$haploBlock

  ### View each dataset
  See(Rice_geno_score)
  See(Rice_geno_map)
  See(Rice_pheno)
  See(Rice_haplo_block)

  ### Select one trait for example
  trait.name &lt;- "Flowering.time.at.Arkansas"
  y &lt;- as.matrix(Rice_pheno[, trait.name, drop = FALSE])

  ### Remove SNPs whose MAF &lt;= 0.05
  x.0 &lt;- t(Rice_geno_score)
  MAF.cut.res &lt;- MAF.cut(x.0 = x.0, map.0 = Rice_geno_map)
  x &lt;- MAF.cut.res$x
  map &lt;- MAF.cut.res$map


  ### Estimate genomic relationship matrix (GRM)
  K.A &lt;- calcGRM(genoMat = x)


  ### Modify data
  modify.data.res &lt;- modify.data(pheno.mat = y, geno.mat = x, map = map,
                                 return.ZETA = TRUE, return.GWAS.format = TRUE)
  pheno.GWAS &lt;- modify.data.res$pheno.GWAS
  geno.GWAS &lt;- modify.data.res$geno.GWAS
  ZETA &lt;- modify.data.res$ZETA


  ### View each data for RAINBOWR
  See(pheno.GWAS)
  See(geno.GWAS)
  str(ZETA)


  ### Check epistatic effects (by regarding 11 SNPs as one SNP-set)
  epistasis.res &lt;- RGWAS.epistasis(pheno = pheno.GWAS, geno = geno.GWAS, ZETA = ZETA,
                                   n.PC = 4, test.method = "LR", gene.set = NULL,
                                   window.size.half = 5, window.slide = 11,
                                   package.MM = "gaston", parallel.method = "mclapply",
                                   skip.check = TRUE, n.core = 2)

  See(epistasis.res$scores$scores)


  ### Check epistatic effects (by using the list of haplotype blocks estimated by PLINK)
  ### It will take almost 2 minutes...
  epistasis_haplo_block.res &lt;- RGWAS.epistasis(pheno = pheno.GWAS, geno = geno.GWAS,
                                               ZETA = ZETA, n.PC = 4,
                                               test.method = "LR", gene.set = Rice_haplo_block,
                                               package.MM = "gaston", parallel.method = "mclapply",
                                               skip.check = TRUE, n.core = 2)

  See(epistasis_haplo_block.res$scores$scores)

</code></pre>

<hr>
<h2 id='RGWAS.menu'>Print the R code which you should perform for RAINBOWR GWAS</h2><span id='topic+RGWAS.menu'></span>

<h3>Description</h3>

<p>Print the R code which you should perform for RAINBOWR (Reliable Association INference By Optimizing Weights with R).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGWAS.menu()
</code></pre>


<h3>Value</h3>

<p>The R code which you should perform for RAINBOWR GWAS
</p>

<hr>
<h2 id='RGWAS.multisnp'>Testing multiple SNPs simultaneously for GWAS</h2><span id='topic+RGWAS.multisnp'></span>

<h3>Description</h3>

<p>This function performs SNP-set GWAS (genome-wide association studies),
which tests multiple SNPs (single nucleotide polymorphisms) simultaneously. The model of SNP-set GWAS is
</p>
<p style="text-align: center;"><code class="reqn">y = X \beta + Q v +  Z _ {c} u _ {c} +  Z _ {r} u _ {r} + \epsilon,</code>
</p>

<p>where <code class="reqn">y</code> is the vector of phenotypic values,
<code class="reqn">X \beta</code> and <code class="reqn">Q v</code> are the terms of fixed effects,
<code class="reqn">Z _ {c} u _ {c}</code> and <code class="reqn">Z _ {c} u _ {c}</code> are the term of random effects and <code class="reqn">e</code> is the vector of residuals.
<code class="reqn">X \beta</code> indicates all of the fixed effects other than population structure, and often this term also plays
a role as an intercept. <code class="reqn">Q v</code> is the term to correct the effect of population structure.
<code class="reqn">Z _ {c} u _ {c}</code> is the term of polygenetic effects, and suppose that <code class="reqn">u _ {c}</code>
follows the multivariate normal distribution whose variance-covariance
matrix is the genetic covariance matrix. <code class="reqn">u _ {c} \sim MVN (0, K _ {c} \sigma_{c}^{2})</code>.
<code class="reqn">Z _ {r} u _ {r}</code> is the term of effects for SNP-set of interest, and suppose that <code class="reqn">u _ {r}</code>
follows the multivariate normal distribution whose variance-covariance
matrix is the Gram matrix (linear, exponential, or gaussian kernel)
calculated from marker genotype which belong to that SNP-set.
Therefore, <code class="reqn">u _ {r} \sim MVN (0, K _ {r} \sigma_{r}^{2})</code>.
Finally, the residual term is assumed to identically and independently follow
a normal distribution as shown in the following equation.
<code class="reqn">e \sim MVN (0, I \sigma_{e}^{2})</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGWAS.multisnp(
  pheno,
  geno,
  ZETA = NULL,
  package.MM = "gaston",
  covariate = NULL,
  covariate.factor = NULL,
  structure.matrix = NULL,
  n.PC = 0,
  min.MAF = 0.02,
  test.method = "LR",
  n.core = 1,
  parallel.method = "mclapply",
  kernel.method = "linear",
  kernel.h = "tuned",
  haplotype = TRUE,
  num.hap = NULL,
  test.effect = "additive",
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  gene.set = NULL,
  map.gene.set = NULL,
  weighting.center = TRUE,
  weighting.other = NULL,
  sig.level = 0.05,
  method.thres = "BH",
  plot.qq = TRUE,
  plot.Manhattan = TRUE,
  plot.method = 1,
  plot.col1 = c("dark blue", "cornflowerblue"),
  plot.col2 = 1,
  plot.type = "p",
  plot.pch = 16,
  saveName = NULL,
  main.qq = NULL,
  main.man = NULL,
  plot.add.last = FALSE,
  return.EMM.res = FALSE,
  optimizer = "nlminb",
  thres = TRUE,
  skip.check = FALSE,
  verbose = TRUE,
  verbose2 = FALSE,
  count = TRUE,
  time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGWAS.multisnp_+3A_pheno">pheno</code></td>
<td>
<p>Data frame where the first column is the line name (gid). The remaining columns should be a phenotype to test.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_geno">geno</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.
Columns 4 and higher contain the marker scores for each line, coded as [-1, 0, 1] = [aa, Aa, AA].</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_zeta">ZETA</code></td>
<td>
<p>A list of covariance (relationship) matrix (K: <code class="reqn">m \times m</code>) and its design matrix (Z: <code class="reqn">n \times m</code>) of random effects.
Please set names of list &quot;Z&quot; and &quot;K&quot;! You can use more than one kernel matrix.
For example,
</p>
<p>ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D))
</p>

<dl>
<dt>Z.A, Z.D</dt><dd><p>Design matrix (<code class="reqn">n \times m</code>) for the random effects. So, in many cases, you can use the identity matrix.</p>
</dd>
<dt>K.A, K.D</dt><dd><p>Different kernels which express some relationships between lines.</p>
</dd>
</dl>

<p>For example, K.A is additive relationship matrix for the covariance between lines, and K.D is dominance relationship matrix.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_covariate">covariate</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector or a <code class="reqn">n \times p _ 1</code> matrix. You can insert continuous values, such as other traits or genotype score for special markers.
This argument is regarded as one of the fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_covariate.factor">covariate.factor</code></td>
<td>
<p>A <code class="reqn">n \times p _ 2</code> dataframe. You should assign a factor vector for each column.
Then RGWAS changes this argument into model matrix, and this model matrix will be included in the model as fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_structure.matrix">structure.matrix</code></td>
<td>
<p>You can use structure matrix calculated by structure analysis when there are population structure.
You should not use this argument with n.PC &gt; 0.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_n.pc">n.PC</code></td>
<td>
<p>Number of principal components to include as fixed effects. Default is 0 (equals K model).</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_test.method">test.method</code></td>
<td>
<p>RGWAS supports two methods to test effects of each SNP-set.
</p>

<dl>
<dt>&quot;LR&quot;</dt><dd><p>Likelihood-ratio test, relatively slow, but accurate (default).</p>
</dd>
<dt>&quot;score&quot;</dt><dd><p>Score test, much faster than LR, but sometimes overestimate -log10(p).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_kernel.method">kernel.method</code></td>
<td>
<p>It determines how to calculate kernel. There are three methods.
</p>

<dl>
<dt>&quot;gaussian&quot;</dt><dd><p>It is the default method. Gaussian kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;exponential&quot;</dt><dd><p>When this method is selected, exponential kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;linear&quot;</dt><dd><p>When this method is selected, linear kernel is calculated by NOIA methods for additive GRM.</p>
</dd>
</dl>

<p>So local genomic relation matrix is regarded as kernel.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_kernel.h">kernel.h</code></td>
<td>
<p>The hyper parameter for gaussian or exponential kernel.
If kernel.h = &quot;tuned&quot;, this hyper parameter is calculated as the median of off-diagonals of distance matrix of genotype data.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_test.effect">test.effect</code></td>
<td>
<p>Effect of each marker to test. You can choose &quot;test.effect&quot; from &quot;additive&quot;, &quot;dominance&quot; and &quot;additive+dominance&quot;.
You also can choose more than one effect, for example, test.effect = c(&quot;additive&quot;, &quot;aditive+dominance&quot;)</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the deviance is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene (or haplotype block), you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_map.gene.set">map.gene.set</code></td>
<td>
<p>Genotype map for 'gene.set' (list of haplotype blocks).
This is a data.frame with the haplotype block (SNP-set, or gene-set) names in the first column.
The second and third columns contain the chromosome and map position for each block.
The forth column contains the cumulative map position for each block, which can be computed by <code><a href="#topic+cumsumPos">cumsumPos</a></code> function.
If this argument is NULL, the map will be constructed by <code><a href="#topic+genesetmap">genesetmap</a></code> function after the SNP-set GWAS.
It will take some time, so you can reduce the computational time by assigning this argument beforehand.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_weighting.center">weighting.center</code></td>
<td>
<p>In kernel-based GWAS, weights according to the Gaussian distribution (centered on the tested SNP) are taken into account when calculating the kernel if Rainbow = TRUE.
If weighting.center = FALSE, weights are not taken into account.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_weighting.other">weighting.other</code></td>
<td>
<p>You can set other weights in addition to weighting.center. The length of this argument should be equal to the number of SNPs.
For example, you can assign SNP effects from the information of gene annotation.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level for the threshold. The default is 0.05.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_method.thres">method.thres</code></td>
<td>
<p>Method for detemining threshold of significance. &quot;BH&quot; and &quot;Bonferroni are offered.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_plot.qq">plot.qq</code></td>
<td>
<p>If TRUE, draw qq plot.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_plot.manhattan">plot.Manhattan</code></td>
<td>
<p>If TRUE, draw manhattan plot.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_plot.method">plot.method</code></td>
<td>
<p>If this argument = 1, the default manhattan plot will be drawn.
If this argument = 2, the manhattan plot with axis based on Position (bp) will be drawn.
Also, this plot's color is changed by all chromosomes.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_plot.col1">plot.col1</code></td>
<td>
<p>This argument determines the color of the manhattan plot.
You should substitute this argument as color vector whose length is 2.
plot.col1[1] for odd chromosomes and plot.col1[2] for even chromosomes</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_plot.col2">plot.col2</code></td>
<td>
<p>Color of the manhattan plot. color changes with chromosome and it starts from plot.col2 + 1
(so plot.col2 = 1 means color starts from red.)</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_plot.type">plot.type</code></td>
<td>
<p>This argument determines the type of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_plot.pch">plot.pch</code></td>
<td>
<p>This argument determines the shape of the dot of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_main.qq">main.qq</code></td>
<td>
<p>The title of qq plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_main.man">main.man</code></td>
<td>
<p>The title of manhattan plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_plot.add.last">plot.add.last</code></td>
<td>
<p>If saveName is not NULL and this argument is TRUE, then you can add lines or dots to manhattan plots.
However, you should also write &quot;dev.off()&quot; after adding something.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_return.emm.res">return.EMM.res</code></td>
<td>
<p>When return.EMM.res = TRUE, the results of equation of mixed models are included in the result of RGWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_thres">thres</code></td>
<td>
<p>If thres = TRUE, the threshold of the manhattan plot is included in the result of RGWAS.
When return.EMM.res or thres is TRUE, the results will be &quot;list&quot; class.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_skip.check">skip.check</code></td>
<td>
<p>As default, RAINBOWR checks the type of input data and modifies it into the correct format.
However, it will take some time, so if you prepare the correct format of input data, you can skip this procedure
by setting 'skip.check = TRUE'.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_verbose">verbose</code></td>
<td>
<p>If this argument is TRUE, messages for the current steps will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_verbose2">verbose2</code></td>
<td>
<p>If this argument is TRUE, welcome message will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp_+3A_time">time</code></td>
<td>
<p>When time is TRUE, you can know how much time it took to perform RGWAS.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>P-value for each SNP-set is calculated by performing the LR test
or the score test (Lippert et al., 2014).
</p>
<p>In the LR test, first, the function solves the multi-kernel mixed model and
calaculates the maximum restricted log likelihood.
Then it performs the LR test by using the fact that the deviance
</p>
<p style="text-align: center;"><code class="reqn">D = 2 \times (LL _ {alt} - LL _ {null})</code>
</p>

<p>follows the chi-square distribution.
</p>
<p>In the score test, the maximization of the likelihood is only performed for the null model.
In other words, the function calculates the score statistic
without solving the multi-kernel mixed model for each SNP-set.
Then it performs the score test by using the fact that the score statistic follows the chi-square distribution.
</p>


<h3>Value</h3>


<dl>
<dt>$D</dt><dd><p>Dataframe which contains the information of the map you input and the results of RGWAS (-log10(p)) which correspond to the map.
If there are more than one test.effects, then multiple lists for each test.effect are returned respectively.</p>
</dd>
<dt>$thres</dt><dd><p>A vector which contains the information of threshold determined by FDR = 0.05.</p>
</dd>
<dt>$EMM.res</dt><dd><p>This output is a list which contains the information about the results of &quot;EMM&quot; perfomed at first in regular GWAS.
If you want to know details, see the description for the function &quot;EMM1&quot; or &quot;EMM2&quot;.</p>
</dd>
</dl>



<h3>References</h3>

<p>Storey, J.D. and Tibshirani, R. (2003) Statistical significance for genomewide studies. Proc Natl Acad Sci. 100(16): 9440-9445.
</p>
<p>Yu, J. et al. (2006) A unified mixed-model method for association mapping that accounts for multiple levels of relatedness. Nat Genet. 38(2): 203-208.
</p>
<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Endelman, J.B. (2011) Ridge Regression and Other Kernels for Genomic Selection with R Package rrBLUP. Plant Genome J. 4(3): 250.
</p>
<p>Endelman, J.B. and Jannink, J.L. (2012) Shrinkage Estimation of the Realized Relationship Matrix. G3 Genes, Genomes, Genet. 2(11): 1405-1413.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis for association studies. Nat Genet. 44(7): 821-824.
</p>
<p>Listgarten, J. et al. (2013) A powerful and efficient set test for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



  ### Import RAINBOWR
  require(RAINBOWR)

  ### Load example datasets
  data("Rice_Zhao_etal")
  Rice_geno_score &lt;- Rice_Zhao_etal$genoScore
  Rice_geno_map &lt;- Rice_Zhao_etal$genoMap
  Rice_pheno &lt;- Rice_Zhao_etal$pheno
  Rice_haplo_block &lt;- Rice_Zhao_etal$haploBlock

  ### View each dataset
  See(Rice_geno_score)
  See(Rice_geno_map)
  See(Rice_pheno)
  See(Rice_haplo_block)

  ### Select one trait for example
  trait.name &lt;- "Flowering.time.at.Arkansas"
  y &lt;- as.matrix(Rice_pheno[, trait.name, drop = FALSE])

  ### Remove SNPs whose MAF &lt;= 0.05
  x.0 &lt;- t(Rice_geno_score)
  MAF.cut.res &lt;- MAF.cut(x.0 = x.0, map.0 = Rice_geno_map)
  x &lt;- MAF.cut.res$x
  map &lt;- MAF.cut.res$map


  ### Estimate genomic relationship matrix (GRM)
  K.A &lt;- calcGRM(genoMat = x)


  ### Modify data
  modify.data.res &lt;- modify.data(pheno.mat = y, geno.mat = x, map = map,
                                 return.ZETA = TRUE, return.GWAS.format = TRUE)
  pheno.GWAS &lt;- modify.data.res$pheno.GWAS
  geno.GWAS &lt;- modify.data.res$geno.GWAS
  ZETA &lt;- modify.data.res$ZETA


  ### View each data for RAINBOWR
  See(pheno.GWAS)
  See(geno.GWAS)
  str(ZETA)


  ### Perform SNP-set GWAS (by regarding 21 SNPs as one SNP-set)
  SNP_set.res &lt;- RGWAS.multisnp(pheno = pheno.GWAS, geno = geno.GWAS,
                                ZETA = ZETA, n.PC = 4, test.method = "LR",
                                kernel.method = "linear", gene.set = NULL,
                                test.effect = "additive", window.size.half = 10,
                                window.slide = 21, package.MM = "gaston",
                                parallel.method = "mclapply",
                                skip.check = TRUE, n.core = 2)
  See(SNP_set.res$D)  ### Column 4 contains -log10(p) values for markers

  ### Perform SNP-set GWAS 2 (by regarding 11 SNPs as one SNP-set with sliding window)
  ### It will take almost 2 minutes...
  SNP_set.res2 &lt;- RGWAS.multisnp(pheno = pheno.GWAS, geno = geno.GWAS,
                                 ZETA = ZETA, n.PC = 4, test.method = "LR",
                                 kernel.method = "linear", gene.set = NULL,
                                 test.effect = "additive", window.size.half = 5,
                                 window.slide = 1, package.MM = "gaston",
                                 parallel.method = "mclapply",
                                 skip.check = TRUE, n.core = 2)
  See(SNP_set.res2$D)  ### Column 4 contains -log10(p) values for markers


  ### Perform haplotype-block GWAS (by using the list of haplotype blocks estimated by PLINK)
  haplo_block.res &lt;- RGWAS.multisnp(pheno = pheno.GWAS, geno = geno.GWAS,
                                    ZETA = ZETA, n.PC = 4, test.method = "LR",
                                    kernel.method = "linear", gene.set = Rice_haplo_block,
                                    test.effect = "additive", package.MM = "gaston",
                                    parallel.method = "mclapply",
                                    skip.check = TRUE, n.core = 2)
  See(haplo_block.res$D)  ### Column 4 contains -log10(p) values for markers

</code></pre>

<hr>
<h2 id='RGWAS.multisnp.interaction'>Testing multiple SNPs and their interaction with some kernel simultaneously for GWAS</h2><span id='topic+RGWAS.multisnp.interaction'></span>

<h3>Description</h3>

<p>This function performs SNP-set GWAS (genome-wide association studies),
which tests multiple SNPs (single nucleotide polymorphisms) simultaneously. The model of SNP-set GWAS is
</p>
<p style="text-align: center;"><code class="reqn">y = X \beta + Q v +  Z _ {c} u _ {c} +  Z _ {r} u _ {r} + \epsilon,</code>
</p>

<p>where <code class="reqn">y</code> is the vector of phenotypic values,
<code class="reqn">X \beta</code> and <code class="reqn">Q v</code> are the terms of fixed effects,
<code class="reqn">Z _ {c} u _ {c}</code> and <code class="reqn">Z _ {c} u _ {c}</code> are the term of random effects and <code class="reqn">e</code> is the vector of residuals.
<code class="reqn">X \beta</code> indicates all of the fixed effects other than population structure, and often this term also plays
a role as an intercept. <code class="reqn">Q v</code> is the term to correct the effect of population structure.
<code class="reqn">Z _ {c} u _ {c}</code> is the term of polygenetic effects, and suppose that <code class="reqn">u _ {c}</code>
follows the multivariate normal distribution whose variance-covariance
matrix is the genetic covariance matrix. <code class="reqn">u _ {c} \sim MVN (0, K _ {c} \sigma_{c}^{2})</code>.
<code class="reqn">Z _ {r} u _ {r}</code> is the term of effects for SNP-set of interest, and suppose that <code class="reqn">u _ {r}</code>
follows the multivariate normal distribution whose variance-covariance
matrix is the Gram matrix (linear, exponential, or gaussian kernel)
calculated from marker genotype which belong to that SNP-set.
Therefore, <code class="reqn">u _ {r} \sim MVN (0, K _ {r} \sigma_{r}^{2})</code>.
Finally, the residual term is assumed to identically and independently follow
a normal distribution as shown in the following equation.
<code class="reqn">e \sim MVN (0, I \sigma_{e}^{2})</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGWAS.multisnp.interaction(
  pheno,
  geno,
  ZETA = NULL,
  interaction.kernel = NULL,
  include.interaction.kernel.null = FALSE,
  include.interaction.with.gb.null = FALSE,
  package.MM = "gaston",
  covariate = NULL,
  covariate.factor = NULL,
  structure.matrix = NULL,
  n.PC = 0,
  min.MAF = 0.02,
  test.method = "LR",
  n.core = 1,
  parallel.method = "mclapply",
  kernel.method = "linear",
  kernel.h = "tuned",
  haplotype = TRUE,
  num.hap = NULL,
  test.effect = "additive",
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  gene.set = NULL,
  map.gene.set = NULL,
  weighting.center = TRUE,
  weighting.other = NULL,
  sig.level = 0.05,
  method.thres = "BH",
  plot.qq = TRUE,
  plot.Manhattan = TRUE,
  plot.method = 1,
  plot.col1 = c("dark blue", "cornflowerblue"),
  plot.col2 = 1,
  plot.type = "p",
  plot.pch = 16,
  saveName = NULL,
  main.qq = NULL,
  main.man = NULL,
  plot.add.last = FALSE,
  return.EMM.res = FALSE,
  optimizer = "nlminb",
  thres = TRUE,
  skip.check = FALSE,
  verbose = TRUE,
  verbose2 = FALSE,
  count = TRUE,
  time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGWAS.multisnp.interaction_+3A_pheno">pheno</code></td>
<td>
<p>Data frame where the first column is the line name (gid). The remaining columns should be a phenotype to test.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_geno">geno</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.
Columns 4 and higher contain the marker scores for each line, coded as [-1, 0, 1] = [aa, Aa, AA].</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_zeta">ZETA</code></td>
<td>
<p>A list of covariance (relationship) matrix (K: <code class="reqn">m \times m</code>) and its design matrix (Z: <code class="reqn">n \times m</code>) of random effects.
Please set names of list &quot;Z&quot; and &quot;K&quot;! You can use more than one kernel matrix.
For example,
</p>
<p>ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D))
</p>

<dl>
<dt>Z.A, Z.D</dt><dd><p>Design matrix (<code class="reqn">n \times m</code>) for the random effects. So, in many cases, you can use the identity matrix.</p>
</dd>
<dt>K.A, K.D</dt><dd><p>Different kernels which express some relationships between lines.</p>
</dd>
</dl>

<p>For example, K.A is additive relationship matrix for the covariance between lines, and K.D is dominance relationship matrix.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_interaction.kernel">interaction.kernel</code></td>
<td>
<p>A <code class="reqn">n \times n</code> Gram (kernel) matrix which may indicate some interaction with SNP-sets to be tested.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_include.interaction.kernel.null">include.interaction.kernel.null</code></td>
<td>
<p>Whether or not including 'iteraction.kernel' itself into the null and alternative models.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_include.interaction.with.gb.null">include.interaction.with.gb.null</code></td>
<td>
<p>Whether or not including the interaction term between 'iteraction.kernel'
and the genetic background (= kinship matrix) into the null and alternative models. By setting this TRUE, you can avoid the false positives caused
by epistastis between polygenes, especially you set kinship matrix as 'interaction.kernel'.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_covariate">covariate</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector or a <code class="reqn">n \times p _ 1</code> matrix. You can insert continuous values, such as other traits or genotype score for special markers.
This argument is regarded as one of the fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_covariate.factor">covariate.factor</code></td>
<td>
<p>A <code class="reqn">n \times p _ 2</code> dataframe. You should assign a factor vector for each column.
Then RGWAS changes this argument into model matrix, and this model matrix will be included in the model as fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_structure.matrix">structure.matrix</code></td>
<td>
<p>You can use structure matrix calculated by structure analysis when there are population structure.
You should not use this argument with n.PC &gt; 0.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_n.pc">n.PC</code></td>
<td>
<p>Number of principal components to include as fixed effects. Default is 0 (equals K model).</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_test.method">test.method</code></td>
<td>
<p>RGWAS supports only one method to test effects of each SNP-set.
</p>

<dl>
<dt>&quot;LR&quot;</dt><dd><p>Likelihood-ratio test, relatively slow, but accurate (default).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_kernel.method">kernel.method</code></td>
<td>
<p>It determines how to calculate kernel. There are three methods.
</p>

<dl>
<dt>&quot;gaussian&quot;</dt><dd><p>It is the default method. Gaussian kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;exponential&quot;</dt><dd><p>When this method is selected, exponential kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;linear&quot;</dt><dd><p>When this method is selected, linear kernel is calculated by NOIA methods for additive GRM.</p>
</dd>
</dl>

<p>So local genomic relation matrix is regarded as kernel.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_kernel.h">kernel.h</code></td>
<td>
<p>The hyper parameter for gaussian or exponential kernel.
If kernel.h = &quot;tuned&quot;, this hyper parameter is calculated as the median of off-diagonals of distance matrix of genotype data.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_test.effect">test.effect</code></td>
<td>
<p>Effect of each marker to test. You can choose &quot;test.effect&quot; from &quot;additive&quot;, &quot;dominance&quot; and &quot;additive+dominance&quot;.
You also can choose more than one effect, for example, test.effect = c(&quot;additive&quot;, &quot;aditive+dominance&quot;)</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the deviance is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene (or haplotype block), you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_map.gene.set">map.gene.set</code></td>
<td>
<p>Genotype map for 'gene.set' (list of haplotype blocks).
This is a data.frame with the haplotype block (SNP-set, or gene-set) names in the first column.
The second and third columns contain the chromosome and map position for each block.
The forth column contains the cumulative map position for each block, which can be computed by <code><a href="#topic+cumsumPos">cumsumPos</a></code> function.
If this argument is NULL, the map will be constructed by <code><a href="#topic+genesetmap">genesetmap</a></code> function after the SNP-set GWAS.
It will take some time, so you can reduce the computational time by assigning this argument beforehand.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_weighting.center">weighting.center</code></td>
<td>
<p>In kernel-based GWAS, weights according to the Gaussian distribution (centered on the tested SNP) are taken into account when calculating the kernel if Rainbow = TRUE.
If weighting.center = FALSE, weights are not taken into account.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_weighting.other">weighting.other</code></td>
<td>
<p>You can set other weights in addition to weighting.center. The length of this argument should be equal to the number of SNPs.
For example, you can assign SNP effects from the information of gene annotation.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level for the threshold. The default is 0.05.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_method.thres">method.thres</code></td>
<td>
<p>Method for detemining threshold of significance. &quot;BH&quot; and &quot;Bonferroni are offered.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_plot.qq">plot.qq</code></td>
<td>
<p>If TRUE, draw qq plot.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_plot.manhattan">plot.Manhattan</code></td>
<td>
<p>If TRUE, draw manhattan plot.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_plot.method">plot.method</code></td>
<td>
<p>If this argument = 1, the default manhattan plot will be drawn.
If this argument = 2, the manhattan plot with axis based on Position (bp) will be drawn.
Also, this plot's color is changed by all chromosomes.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_plot.col1">plot.col1</code></td>
<td>
<p>This argument determines the color of the manhattan plot.
You should substitute this argument as color vector whose length is 2.
plot.col1[1] for odd chromosomes and plot.col1[2] for even chromosomes</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_plot.col2">plot.col2</code></td>
<td>
<p>Color of the manhattan plot. color changes with chromosome and it starts from plot.col2 + 1
(so plot.col2 = 1 means color starts from red.)</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_plot.type">plot.type</code></td>
<td>
<p>This argument determines the type of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_plot.pch">plot.pch</code></td>
<td>
<p>This argument determines the shape of the dot of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_main.qq">main.qq</code></td>
<td>
<p>The title of qq plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_main.man">main.man</code></td>
<td>
<p>The title of manhattan plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_plot.add.last">plot.add.last</code></td>
<td>
<p>If saveName is not NULL and this argument is TRUE, then you can add lines or dots to manhattan plots.
However, you should also write &quot;dev.off()&quot; after adding something.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_return.emm.res">return.EMM.res</code></td>
<td>
<p>When return.EMM.res = TRUE, the results of equation of mixed models are included in the result of RGWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_thres">thres</code></td>
<td>
<p>If thres = TRUE, the threshold of the manhattan plot is included in the result of RGWAS.
When return.EMM.res or thres is TRUE, the results will be &quot;list&quot; class.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_skip.check">skip.check</code></td>
<td>
<p>As default, RAINBOWR checks the type of input data and modifies it into the correct format.
However, it will take some time, so if you prepare the correct format of input data, you can skip this procedure
by setting 'skip.check = TRUE'.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_verbose">verbose</code></td>
<td>
<p>If this argument is TRUE, messages for the current steps will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_verbose2">verbose2</code></td>
<td>
<p>If this argument is TRUE, welcome message will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
<tr><td><code id="RGWAS.multisnp.interaction_+3A_time">time</code></td>
<td>
<p>When time is TRUE, you can know how much time it took to perform RGWAS.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>P-value for each SNP-set is calculated by performing the LR test
or the score test (Lippert et al., 2014).
</p>
<p>In the LR test, first, the function solves the multi-kernel mixed model and
calaculates the maximum restricted log likelihood.
Then it performs the LR test by using the fact that the deviance
</p>
<p style="text-align: center;"><code class="reqn">D = 2 \times (LL _ {alt} - LL _ {null})</code>
</p>

<p>follows the chi-square distribution.
</p>
<p>In the score test, the maximization of the likelihood is only performed for the null model.
In other words, the function calculates the score statistic
without solving the multi-kernel mixed model for each SNP-set.
Then it performs the score test by using the fact that the score statistic follows the chi-square distribution.
</p>


<h3>Value</h3>


<dl>
<dt>$D</dt><dd><p>Dataframe which contains the information of the map you input and the results of RGWAS (-log10(p)) which correspond to the map.
If there are more than one test.effects, then multiple lists for each test.effect are returned respectively.</p>
</dd>
<dt>$thres</dt><dd><p>A vector which contains the information of threshold determined by FDR = 0.05.</p>
</dd>
<dt>$EMM.res</dt><dd><p>This output is a list which contains the information about the results of &quot;EMM&quot; perfomed at first in regular GWAS.
If you want to know details, see the description for the function &quot;EMM1&quot; or &quot;EMM2&quot;.</p>
</dd>
</dl>



<h3>References</h3>

<p>Storey, J.D. and Tibshirani, R. (2003) Statistical significance for genomewide studies. Proc Natl Acad Sci. 100(16): 9440-9445.
</p>
<p>Yu, J. et al. (2006) A unified mixed-model method for association mapping that accounts for multiple levels of relatedness. Nat Genet. 38(2): 203-208.
</p>
<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Endelman, J.B. (2011) Ridge Regression and Other Kernels for Genomic Selection with R Package rrBLUP. Plant Genome J. 4(3): 250.
</p>
<p>Endelman, J.B. and Jannink, J.L. (2012) Shrinkage Estimation of the Realized Relationship Matrix. G3 Genes, Genomes, Genet. 2(11): 1405-1413.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis for association studies. Nat Genet. 44(7): 821-824.
</p>
<p>Listgarten, J. et al. (2013) A powerful and efficient set test for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



  ### Import RAINBOWR
  require(RAINBOWR)

  ### Load example datasets
  data("Rice_Zhao_etal")
  Rice_geno_score &lt;- Rice_Zhao_etal$genoScore
  Rice_geno_map &lt;- Rice_Zhao_etal$genoMap
  Rice_pheno &lt;- Rice_Zhao_etal$pheno
  Rice_haplo_block &lt;- Rice_Zhao_etal$haploBlock

  ### View each dataset
  See(Rice_geno_score)
  See(Rice_geno_map)
  See(Rice_pheno)
  See(Rice_haplo_block)

  ### Select one trait for example
  trait.name &lt;- "Flowering.time.at.Arkansas"
  y &lt;- as.matrix(Rice_pheno[, trait.name, drop = FALSE])

  ### Remove SNPs whose MAF &lt;= 0.05
  x.0 &lt;- t(Rice_geno_score)
  MAF.cut.res &lt;- MAF.cut(x.0 = x.0, map.0 = Rice_geno_map)
  x &lt;- MAF.cut.res$x
  map &lt;- MAF.cut.res$map


  ### Estimate genomic relationship matrix (GRM)
  K.A &lt;- calcGRM(genoMat = x)


  ### Modify data
  modify.data.res &lt;- modify.data(pheno.mat = y, geno.mat = x, map = map,
                                 return.ZETA = TRUE, return.GWAS.format = TRUE)
  pheno.GWAS &lt;- modify.data.res$pheno.GWAS
  geno.GWAS &lt;- modify.data.res$geno.GWAS
  ZETA &lt;- modify.data.res$ZETA


  ### View each data for RAINBOWR
  See(pheno.GWAS)
  See(geno.GWAS)
  str(ZETA)


  ### Perform SNP-set GWAS with interaction
  ### by regarding 21 SNPs as one SNP-set
  SNP_set.res.int &lt;- RGWAS.multisnp.interaction(
    pheno = pheno.GWAS,
    geno = geno.GWAS,
    ZETA = ZETA,
    interaction.kernel = ZETA$A$K,
    include.interaction.kernel.null = FALSE,
    include.interaction.with.gb.null = TRUE,
    n.PC = 4,
    test.method = "LR",
    kernel.method = "linear",
    gene.set = NULL,
    test.effect = "additive",
    window.size.half = 10,
    window.slide = 21,
    package.MM = "gaston",
    parallel.method = "mclapply",
    skip.check = TRUE,
    n.core = 2
  )
  See(SNP_set.res.int$D)  ### Column 4 contains -log10(p) values for markers

  ### Perform SNP-set GWAS with interaction 2
  ### by regarding 11 SNPs as one SNP-set with sliding window
  ### It will take almost 2 minutes...
  SNP_set.res.int2 &lt;- RGWAS.multisnp.interaction(
    pheno = pheno.GWAS,
    geno = geno.GWAS,
    ZETA = ZETA,
    interaction.kernel = ZETA$A$K,
    include.interaction.kernel.null = FALSE,
    include.interaction.with.gb.null = TRUE,
    n.PC = 4,
    test.method = "LR",
    kernel.method = "linear",
    gene.set = NULL,
    test.effect = "additive",
    window.size.half = 5,
    window.slide = 1,
    package.MM = "gaston",
    parallel.method = "mclapply",
    skip.check = TRUE,
    n.core = 2
  )
  See(SNP_set.res.int2$D)  ### Column 4 contains -log10(p) values for markers


  ### Perform haplotype-block GWAS with interaction
  ### by using the list of haplotype blocks estimated by PLINK
  haplo_block.res.int &lt;- RGWAS.multisnp.interaction(
    pheno = pheno.GWAS,
    geno = geno.GWAS,
    ZETA = ZETA,
    interaction.kernel = ZETA$A$K,
    include.interaction.kernel.null = FALSE,
    include.interaction.with.gb.null = TRUE,
    n.PC = 4,
    test.method = "LR",
    kernel.method = "linear",
    gene.set = Rice_haplo_block,
    test.effect = "additive",
    package.MM = "gaston",
    parallel.method = "mclapply",
    skip.check = TRUE,
    n.core = 2
  )
  See(haplo_block.res.int$D)  ### Column 4 contains -log10(p) values for markers

</code></pre>

<hr>
<h2 id='RGWAS.normal'>Perform normal GWAS (test each single SNP)</h2><span id='topic+RGWAS.normal'></span>

<h3>Description</h3>

<p>This function performs single-SNP GWAS (genome-wide association studies). The model of GWAS is
</p>
<p style="text-align: center;"><code class="reqn">y = X \beta + S _ {i} \alpha _ {i} + Q v +  Z u + \epsilon,</code>
</p>

<p>where <code class="reqn">y</code> is the vector of phenotypic values,
<code class="reqn">X \beta</code>, <code class="reqn">S _ {i} \alpha _ {i}</code>, <code class="reqn">Q v</code> are the terms of fixed effects,
<code class="reqn">Z u</code> is the term of random effects and <code class="reqn">e</code> is the vector of residuals.
<code class="reqn">X \beta</code> indicates all of the fixed effects other than the effect of SNPs
to be tested and of population structure, and often this term also plays
a role as an intercept. For <code class="reqn">S _ {i} \alpha _ {i}</code>, <code class="reqn">S _ {i}</code>
is the ith marker of genotype data and <code class="reqn">\alpha _ {i}</code> is the effect of that marker.
<code class="reqn">Q v</code> is the term to correct the effect of population structure.
<code class="reqn">Z u</code> is the term of polygenetic effects, and suppose that <code class="reqn">u</code>
follows the multivariate normal distribution whose variance-covariance
matrix is the genetic covariance matrix. <code class="reqn">u \sim MVN (0, K \sigma_{u}^{2})</code>.
Finally, the residual term is assumed to identically and independently follow
a normal distribution as shown in the following equation.
<code class="reqn">e \sim MVN (0, I \sigma_{e}^{2})</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGWAS.normal(
  pheno,
  geno,
  ZETA = NULL,
  package.MM = "gaston",
  covariate = NULL,
  covariate.factor = NULL,
  structure.matrix = NULL,
  n.PC = 0,
  min.MAF = 0.02,
  P3D = TRUE,
  n.core = 1,
  parallel.method = "mclapply",
  sig.level = 0.05,
  method.thres = "BH",
  plot.qq = TRUE,
  plot.Manhattan = TRUE,
  plot.method = 1,
  plot.col1 = c("dark blue", "cornflowerblue"),
  plot.col2 = 1,
  plot.type = "p",
  plot.pch = 16,
  saveName = NULL,
  main.qq = NULL,
  main.man = NULL,
  plot.add.last = FALSE,
  return.EMM.res = FALSE,
  optimizer = "nlminb",
  thres = TRUE,
  skip.check = FALSE,
  verbose = TRUE,
  verbose2 = FALSE,
  count = TRUE,
  time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGWAS.normal_+3A_pheno">pheno</code></td>
<td>
<p>Data frame where the first column is the line name (gid). The remaining columns should be a phenotype to test.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_geno">geno</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.
Columns 4 and higher contain the marker scores for each line, coded as [-1, 0, 1] = [aa, Aa, AA].</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_zeta">ZETA</code></td>
<td>
<p>A list of covariance (relationship) matrix (K: <code class="reqn">m \times m</code>) and its design matrix (Z: <code class="reqn">n \times m</code>) of random effects.
Please set names of list &quot;Z&quot; and &quot;K&quot;! You can use more than one kernel matrix.
For example,
</p>
<p>ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D))
</p>

<dl>
<dt>Z.A, Z.D</dt><dd><p>Design matrix (<code class="reqn">n \times m</code>) for the random effects. So, in many cases, you can use the identity matrix.</p>
</dd>
<dt>K.A, K.D</dt><dd><p>Different kernels which express some relationships between lines.</p>
</dd>
</dl>

<p>For example, K.A is additive relationship matrix for the covariance between lines, and K.D is dominance relationship matrix.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages: 
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_covariate">covariate</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector or a <code class="reqn">n \times p _ 1</code> matrix. You can insert continuous values, such as other traits or genotype score for special markers.
This argument is regarded as one of the fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_covariate.factor">covariate.factor</code></td>
<td>
<p>A <code class="reqn">n \times p _ 2</code> dataframe. You should assign a factor vector for each column.
Then RGWAS changes this argument into model matrix, and this model matrix will be included in the model as fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_structure.matrix">structure.matrix</code></td>
<td>
<p>You can use structure matrix calculated by structure analysis when there are population structure.
You should not use this argument with n.PC &gt; 0.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_n.pc">n.PC</code></td>
<td>
<p>Number of principal components to include as fixed effects. Default is 0 (equals K model).</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_p3d">P3D</code></td>
<td>
<p>When P3D = TRUE, variance components are estimated by REML only once, without any markers in the model.
When P3D = FALSE, variance components are estimated by REML for each marker separately.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores. 
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;. 
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package 
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'. 
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package. 
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar, 
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>). 
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by 
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package 
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package, 
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package. 
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and 
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users, 
this parallelization method is not supported. So, if you are Windows user, 
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level for the threshold. The default is 0.05.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_method.thres">method.thres</code></td>
<td>
<p>Method for detemining threshold of significance. &quot;BH&quot; and &quot;Bonferroni are offered.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_plot.qq">plot.qq</code></td>
<td>
<p>If TRUE, draw qq plot.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_plot.manhattan">plot.Manhattan</code></td>
<td>
<p>If TRUE, draw manhattan plot.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_plot.method">plot.method</code></td>
<td>
<p>If this argument = 1, the default manhattan plot will be drawn.
If this argument = 2, the manhattan plot with axis based on Position (bp) will be drawn.
Also, this plot's color is changed by all chromosomes.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_plot.col1">plot.col1</code></td>
<td>
<p>This argument determines the color of the manhattan plot.
You should substitute this argument as color vector whose length is 2.
plot.col1[1] for odd chromosomes and plot.col1[2] for even chromosomes</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_plot.col2">plot.col2</code></td>
<td>
<p>Color of the manhattan plot. color changes with chromosome and it starts from plot.col2 + 1
(so plot.col2 = 1 means color starts from red.)</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_plot.type">plot.type</code></td>
<td>
<p>This argument determines the type of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_plot.pch">plot.pch</code></td>
<td>
<p>This argument determines the shape of the dot of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_main.qq">main.qq</code></td>
<td>
<p>The title of qq plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_main.man">main.man</code></td>
<td>
<p>The title of manhattan plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_plot.add.last">plot.add.last</code></td>
<td>
<p>If saveName is not NULL and this argument is TRUE, then you can add lines or dots to manhattan plots.
However, you should also write &quot;dev.off()&quot; after adding something.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_return.emm.res">return.EMM.res</code></td>
<td>
<p>When return.EMM.res = TRUE, the results of equation of mixed models are included in the result of RGWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. 
We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions. 
This argument is only valid when &lsquo;package.MM = &rsquo;RAINBOWR''.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_thres">thres</code></td>
<td>
<p>If thres = TRUE, the threshold of the manhattan plot is included in the result of RGWAS.
When return.EMM.res or thres is TRUE, the results will be &quot;list&quot; class.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_skip.check">skip.check</code></td>
<td>
<p>As default, RAINBOWR checks the type of input data and modifies it into the correct format. 
However, it will take some time, so if you prepare the correct format of input data, you can skip this procedure 
by setting 'skip.check = TRUE'.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_verbose">verbose</code></td>
<td>
<p>If this argument is TRUE, messages for the current steps will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_verbose2">verbose2</code></td>
<td>
<p>If this argument is TRUE, welcome message will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
<tr><td><code id="RGWAS.normal_+3A_time">time</code></td>
<td>
<p>When time is TRUE, you can know how much time it took to perform RGWAS.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>P-value for each marker is calculated by performing F-test
against the F-value as follows (Kennedy et al., 1992).
</p>
<p style="text-align: center;"><code class="reqn">F = \frac { ( L' \hat { b } )' [ L' ( X' H ^ { - 1 } X ) ^ { - 1 }
L ] ^ { - 1 } ( L' \hat { b } ) } { f \hat { \sigma }_ { u } ^ { 2 } },</code>
</p>

<p>where <code class="reqn">b</code> is the vector of coefficients of the fixed effects, which combines
<code class="reqn">\beta</code>, <code class="reqn">\alpha _ {i}</code>, <code class="reqn">v</code> in the horizontal direction and <code class="reqn">L</code>
is a matrix to indicate which effects in <code class="reqn">b</code> are tested.
<code class="reqn">H</code> is calculated by dividing the estimated variance-covariance
matrix for the phenotypic values by <code class="reqn">\sigma _ { u } ^ { 2 }</code>,
and is calculated by <code class="reqn">H = Z K Z' + \hat{\lambda} I</code>.
<code class="reqn">\hat{\lambda}</code> is the maximum likelihood estimator
of the ratio between the residual variance and the additive genetic variance.
<code class="reqn">\hat{b}</code> is the maximum likelihood estimator of <code class="reqn">b</code>
and is calculated by <code class="reqn">\hat { b } = ( X' H ^ { - 1 } X ) ^ { - 1 } X' H ^ { - 1 } y </code>.
<code class="reqn">f</code> is the number of the fixed effects to be tested, and
<code class="reqn">\hat { \sigma }_ { u } ^ { 2 }</code> is estimated by the following formula.
</p>
<p style="text-align: center;"><code class="reqn">\hat { \sigma }_ { u } ^ { 2 } = \frac { ( y - X  \hat { b } )' H ^ { - 1 } ( y - X  \hat { b } ) } { n - p },</code>
</p>

<p>where <code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the number of the all fixed effects.
We calculated each p-value using the fact that the above F-value follows
the F distribution with the degree of freedom (<code class="reqn">f</code>,<code class="reqn">n - p</code>).
</p>


<h3>Value</h3>


<dl>
<dt>$D</dt><dd><p>Dataframe which contains the information of the map you input and the results of RGWAS (-log10(p)) which correspond to the map.</p>
</dd>
<dt>$thres</dt><dd><p>A vector which contains the information of threshold determined by FDR = 0.05.</p>
</dd>
<dt>$EMM.res</dt><dd><p>This output is a list which contains the information about the results of &quot;EMM&quot; perfomed at first in regular GWAS.
If you want to know details, see the description for the function &quot;EMM1&quot; or &quot;EMM2&quot;.</p>
</dd>
</dl>



<h3>References</h3>

<p>Kennedy, B.W., Quinton, M. and van Arendonk, J.A. (1992) Estimation of effects of single genes on quantitative traits. J Anim Sci. 70(7): 2000-2012.
</p>
<p>Storey, J.D. and Tibshirani, R. (2003) Statistical significance for genomewide studies. Proc Natl Acad Sci. 100(16): 9440-9445.
</p>
<p>Yu, J. et al. (2006) A unified mixed-model method for association mapping that accounts for multiple levels of relatedness. Nat Genet. 38(2): 203-208.
</p>
<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Kang, H.M. et al. (2010) Variance component model to account for sample structure in genome-wide association studies. Nat Genet. 42(4): 348-354.
</p>
<p>Zhang, Z. et al. (2010) Mixed linear model approach adapted for genome-wide association studies. Nat Genet. 42(4): 355-360.
</p>
<p>Endelman, J.B. (2011) Ridge Regression and Other Kernels for Genomic Selection with R Package rrBLUP. Plant Genome J. 4(3): 250.
</p>
<p>Endelman, J.B. and Jannink, J.L. (2012) Shrinkage Estimation of the Realized Relationship Matrix. G3 Genes, Genomes, Genet. 2(11): 1405-1413.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis for association studies. Nat Genet. 44(7): 821-824.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



  ### Import RAINBOWR
  require(RAINBOWR)

  ### Load example datasets
  data("Rice_Zhao_etal")
  Rice_geno_score &lt;- Rice_Zhao_etal$genoScore
  Rice_geno_map &lt;- Rice_Zhao_etal$genoMap
  Rice_pheno &lt;- Rice_Zhao_etal$pheno

  ### View each dataset
  See(Rice_geno_score)
  See(Rice_geno_map)
  See(Rice_pheno)

  ### Select one trait for example
  trait.name &lt;- "Flowering.time.at.Arkansas"
  y &lt;- as.matrix(Rice_pheno[, trait.name, drop = FALSE])

  ### Remove SNPs whose MAF &lt;= 0.05
  x.0 &lt;- t(Rice_geno_score)
  MAF.cut.res &lt;- MAF.cut(x.0 = x.0, map.0 = Rice_geno_map)
  x &lt;- MAF.cut.res$x
  map &lt;- MAF.cut.res$map


  ### Estimate genomic relationship matrix (GRM)
  K.A &lt;- calcGRM(genoMat = x)


  ### Modify data
  modify.data.res &lt;- modify.data(pheno.mat = y, geno.mat = x, map = map,
                                 return.ZETA = TRUE, return.GWAS.format = TRUE)
  pheno.GWAS &lt;- modify.data.res$pheno.GWAS
  geno.GWAS &lt;- modify.data.res$geno.GWAS
  ZETA &lt;- modify.data.res$ZETA


  ### View each data for RAINBOWR
  See(pheno.GWAS)
  See(geno.GWAS)
  str(ZETA)



  ### Perform single-SNP GWAS
  normal.res &lt;- RGWAS.normal(pheno = pheno.GWAS, geno = geno.GWAS,
                             ZETA = ZETA, n.PC = 4, P3D = TRUE,
                             package.MM = "gaston", parallel.method = "mclapply",
                             skip.check = TRUE, n.core = 2)
  See(normal.res$D)  ### Column 4 contains -log10(p) values for markers

</code></pre>

<hr>
<h2 id='RGWAS.normal.interaction'>Perform normal GWAS including interaction (test each single SNP)</h2><span id='topic+RGWAS.normal.interaction'></span>

<h3>Description</h3>

<p>This function performs single-SNP GWAS (genome-wide association studies), including the interaction between SNP and genetic background (or other environmental factors). 
The model of GWAS is quite similar to the one in the 'RGWAS.normal' function:
</p>
<p style="text-align: center;"><code class="reqn">y = X \beta + S _ {i} \alpha _ {i} + Q v +  Z u + \epsilon,</code>
</p>

<p>where <code class="reqn">y</code> is the vector of phenotypic values,
<code class="reqn">X \beta</code>, <code class="reqn">S _ {i} \alpha _ {i}</code>, <code class="reqn">Q v</code> are the terms of fixed effects,
<code class="reqn">Z u</code> is the term of random effects and <code class="reqn">e</code> is the vector of residuals.
<code class="reqn">X \beta</code> indicates all of the fixed effects other than the effect of SNPs
to be tested and of population structure, and often this term also plays
a role as an intercept. For <code class="reqn">S _ {i} \alpha _ {i}</code>, this term is only the difference 
compared to the model for normal single-SNP GWAS. Here, <code class="reqn">S _ {i}</code>
includes the ith marker of genotype data and the interaction variables between
the ith marker of genotype data and the matrix representing the genetic back ground 
(or some environmental factors). <code class="reqn">\alpha _ {i}</code> is the cooresponding effects
of that marker and the interaction term.
<code class="reqn">Q v</code> is the term to correct the effect of population structure.
<code class="reqn">Z u</code> is the term of polygenetic effects, and suppose that <code class="reqn">u</code>
follows the multivariate normal distribution whose variance-covariance
matrix is the genetic covariance matrix. <code class="reqn">u \sim MVN (0, K \sigma_{u}^{2})</code>.
Finally, the residual term is assumed to identically and independently follow
a normal distribution as shown in the following equation.
<code class="reqn">e \sim MVN (0, I \sigma_{e}^{2})</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGWAS.normal.interaction(
  pheno,
  geno,
  ZETA = NULL,
  package.MM = "gaston",
  covariate = NULL,
  covariate.factor = NULL,
  structure.matrix = NULL,
  interaction.with.SNPs = NULL,
  interaction.mat.method = "PCA",
  n.interaction.element = 1,
  interaction.group = NULL,
  n.interaction.group = 3,
  interaction.group.method = "find.clusters",
  n.PC.dapc = 1,
  test.method.interaction = "simultaneous",
  n.PC = 0,
  min.MAF = 0.02,
  P3D = TRUE,
  n.core = 1,
  parallel.method = "mclapply",
  sig.level = 0.05,
  method.thres = "BH",
  plot.qq = TRUE,
  plot.Manhattan = TRUE,
  plot.method = 1,
  plot.col1 = c("dark blue", "cornflowerblue"),
  plot.col2 = 1,
  plot.type = "p",
  plot.pch = 16,
  saveName = NULL,
  main.qq = NULL,
  main.man = NULL,
  plot.add.last = FALSE,
  return.EMM.res = FALSE,
  optimizer = "nlminb",
  thres = TRUE,
  skip.check = FALSE,
  verbose = TRUE,
  verbose2 = FALSE,
  count = TRUE,
  time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGWAS.normal.interaction_+3A_pheno">pheno</code></td>
<td>
<p>Data frame where the first column is the line name (gid). The remaining columns should be a phenotype to test.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_geno">geno</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.
Columns 4 and higher contain the marker scores for each line, coded as [-1, 0, 1] = [aa, Aa, AA].</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_zeta">ZETA</code></td>
<td>
<p>A list of covariance (relationship) matrix (K: <code class="reqn">m \times m</code>) and its design matrix (Z: <code class="reqn">n \times m</code>) of random effects.
Please set names of list &quot;Z&quot; and &quot;K&quot;! You can use more than one kernel matrix.
For example,
</p>
<p>ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D))
</p>

<dl>
<dt>Z.A, Z.D</dt><dd><p>Design matrix (<code class="reqn">n \times m</code>) for the random effects. So, in many cases, you can use the identity matrix.</p>
</dd>
<dt>K.A, K.D</dt><dd><p>Different kernels which express some relationships between lines.</p>
</dd>
</dl>

<p>For example, K.A is additive relationship matrix for the covariance between lines, and K.D is dominance relationship matrix.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages: 
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_covariate">covariate</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector or a <code class="reqn">n \times p _ 1</code> matrix. You can insert continuous values, such as other traits or genotype score for special markers.
This argument is regarded as one of the fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_covariate.factor">covariate.factor</code></td>
<td>
<p>A <code class="reqn">n \times p _ 2</code> dataframe. You should assign a factor vector for each column.
Then RGWAS changes this argument into model matrix, and this model matrix will be included in the model as fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_structure.matrix">structure.matrix</code></td>
<td>
<p>You can use structure matrix calculated by structure analysis when there are population structure.
You should not use this argument with n.PC &gt; 0.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_interaction.with.snps">interaction.with.SNPs</code></td>
<td>
<p>A <code class="reqn">m \times q</code> matrix. Interaction between each SNP and this matrix will also be tested.
For example, principal components of genomic relationship matrix can be used as this matrix to test the interaction between SNPs and the genetic background.
Or you can test the interaction with some environmental factors by inputting some omics data that represent the environment. (Test inluding GxE effects.)</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_interaction.mat.method">interaction.mat.method</code></td>
<td>
<p>Method to compute 'interaction.with.SNPs' when 'interaction.with.SNPs' is NULL.
We offer the following four different methods:
</p>
<p>&quot;PCA&quot;: Principal component analysis for genomic relationship matrix ('K' in 'ZETA') using 'prcomp' function
</p>
<p>&quot;LDA&quot;: Linear discriminant analysis with independent variables as genomic relationship matrix ('K' in 'ZETA') 
and dependent variables as some group information ('interaction.group') using 'lda' function
</p>
<p>&quot;GROUP&quot;: Dummy variables for some group information ('interaction.group')
</p>
<p>&quot;DAPC&quot;: Perform LDA to the principal components of PCAfor genomic relationship matrix ('K' in 'ZETA')
using 'dapc' function in 'adgenet' package. See Jombart et al., 2010 and <code><a href="adegenet.html#topic+dapc">dapc</a></code> for more details.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_n.interaction.element">n.interaction.element</code></td>
<td>
<p>Number of elements (variables) that are included in the model as interaction term for 'interaction.with.SNPs'.
If 'interaction.with.SNPs = NULL' and 'n.interaction.element = 0', then the standard SNP-based GWAS will be performed by 'RGWAS.normal' function.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_interaction.group">interaction.group</code></td>
<td>
<p>When you use &quot;LDA&quot;, &quot;GROUP&quot;, or &quot;DAPC&quot;, the information on groups (e.g., subgroups for the population) will be required.
You can set a vector of group names (or clustering ids) for each genotype as this argument. This vector should be factor.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_n.interaction.group">n.interaction.group</code></td>
<td>
<p>When 'interaction.group = NULL', 'interaction.group' will be automatically determined by using k-medoids method ('pam' function in 'cluster' package).
You should specify the number of groups by this argument to decide 'interaction.group'.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_interaction.group.method">interaction.group.method</code></td>
<td>
<p>The method to perform clustering when 'interaction.group = NULL'. 
We offer the following two methods &quot;find.clusters&quot; and &quot;pam&quot;.
&quot;find.clusters&quot; performs 'adegenet::find.clusters' functions to conduct successive K-means clustering,
&quot;pam&quot; performs 'cluster::pam' functions to conduct k-medoids clustering. 
See <code><a href="adegenet.html#topic+find.clusters">find.clusters</a></code> and <code><a href="cluster.html#topic+pam">pam</a></code> for more details.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_n.pc.dapc">n.PC.dapc</code></td>
<td>
<p>Number of principal components to be used for 'adegenet::find.clusters' or 'adegenet::dapc' functions.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_test.method.interaction">test.method.interaction</code></td>
<td>
<p>Method for how to test SNPs and the interactions between SNPs and the genetic background.
We offer three methods as follows:
</p>
<p>&quot;simultaneous&quot;: All effects (including SNP efects) are tested simultanously.
</p>
<p>&quot;snpSeparate&quot;: SNP effects are tested as one effect, and the other interaction effects are simulateneously.
</p>
<p>&quot;oneByOne&quot;: All efects are tested separately, one by one.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_n.pc">n.PC</code></td>
<td>
<p>Number of principal components to include as fixed effects. Default is 0 (equals K model).</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_p3d">P3D</code></td>
<td>
<p>When P3D = TRUE, variance components are estimated by REML only once, without any markers in the model.
When P3D = FALSE, variance components are estimated by REML for each marker separately.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores. 
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;. 
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package 
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'. 
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package. 
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar, 
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>). 
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by 
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package 
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package, 
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package. 
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and 
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users, 
this parallelization method is not supported. So, if you are Windows user, 
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level for the threshold. The default is 0.05.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_method.thres">method.thres</code></td>
<td>
<p>Method for detemining threshold of significance. &quot;BH&quot; and &quot;Bonferroni are offered.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_plot.qq">plot.qq</code></td>
<td>
<p>If TRUE, draw qq plot.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_plot.manhattan">plot.Manhattan</code></td>
<td>
<p>If TRUE, draw manhattan plot.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_plot.method">plot.method</code></td>
<td>
<p>If this argument = 1, the default manhattan plot will be drawn.
If this argument = 2, the manhattan plot with axis based on Position (bp) will be drawn.
Also, this plot's color is changed by all chromosomes.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_plot.col1">plot.col1</code></td>
<td>
<p>This argument determines the color of the manhattan plot.
You should substitute this argument as color vector whose length is 2.
plot.col1[1] for odd chromosomes and plot.col1[2] for even chromosomes</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_plot.col2">plot.col2</code></td>
<td>
<p>Color of the manhattan plot. color changes with chromosome and it starts from plot.col2 + 1
(so plot.col2 = 1 means color starts from red.)</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_plot.type">plot.type</code></td>
<td>
<p>This argument determines the type of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_plot.pch">plot.pch</code></td>
<td>
<p>This argument determines the shape of the dot of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_main.qq">main.qq</code></td>
<td>
<p>The title of qq plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_main.man">main.man</code></td>
<td>
<p>The title of manhattan plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_plot.add.last">plot.add.last</code></td>
<td>
<p>If saveName is not NULL and this argument is TRUE, then you can add lines or dots to manhattan plots.
However, you should also write &quot;dev.off()&quot; after adding something.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_return.emm.res">return.EMM.res</code></td>
<td>
<p>When return.EMM.res = TRUE, the results of equation of mixed models are included in the result of RGWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. 
We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions. 
This argument is only valid when &lsquo;package.MM = &rsquo;RAINBOWR''.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_thres">thres</code></td>
<td>
<p>If thres = TRUE, the threshold of the manhattan plot is included in the result of RGWAS.
When return.EMM.res or thres is TRUE, the results will be &quot;list&quot; class.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_skip.check">skip.check</code></td>
<td>
<p>As default, RAINBOWR checks the type of input data and modifies it into the correct format. 
However, it will take some time, so if you prepare the correct format of input data, you can skip this procedure 
by setting 'skip.check = TRUE'.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_verbose">verbose</code></td>
<td>
<p>If this argument is TRUE, messages for the current steps will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_verbose2">verbose2</code></td>
<td>
<p>If this argument is TRUE, welcome message will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
<tr><td><code id="RGWAS.normal.interaction_+3A_time">time</code></td>
<td>
<p>When time is TRUE, you can know how much time it took to perform RGWAS.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>P-value for each marker is calculated by performing F-test
against the F-value as follows (Kennedy et al., 1992).
</p>
<p style="text-align: center;"><code class="reqn">F = \frac { ( L' \hat { b } )' [ L' ( X' H ^ { - 1 } X ) ^ { - 1 }
L ] ^ { - 1 } ( L' \hat { b } ) } { f \hat { \sigma }_ { u } ^ { 2 } },</code>
</p>

<p>where <code class="reqn">b</code> is the vector of coefficients of the fixed effects, which combines
<code class="reqn">\beta</code>, <code class="reqn">\alpha _ {i}</code>, <code class="reqn">v</code> in the horizontal direction and <code class="reqn">L</code>
is a matrix to indicate which effects in <code class="reqn">b</code> are tested.
<code class="reqn">H</code> is calculated by dividing the estimated variance-covariance
matrix for the phenotypic values by <code class="reqn">\sigma _ { u } ^ { 2 }</code>,
and is calculated by <code class="reqn">H = Z K Z' + \hat{\lambda} I</code>.
<code class="reqn">\hat{\lambda}</code> is the maximum likelihood estimator
of the ratio between the residual variance and the additive genetic variance.
<code class="reqn">\hat{b}</code> is the maximum likelihood estimator of <code class="reqn">b</code>
and is calculated by <code class="reqn">\hat { b } = ( X' H ^ { - 1 } X ) ^ { - 1 } X' H ^ { - 1 } y </code>.
<code class="reqn">f</code> is the number of the fixed effects to be tested, and
<code class="reqn">\hat { \sigma }_ { u } ^ { 2 }</code> is estimated by the following formula.
</p>
<p style="text-align: center;"><code class="reqn">\hat { \sigma }_ { u } ^ { 2 } = \frac { ( y - X  \hat { b } )' H ^ { - 1 } ( y - X  \hat { b } ) } { n - p },</code>
</p>

<p>where <code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the number of the all fixed effects.
We calculated each p-value using the fact that the above F-value follows
the F distribution with the degree of freedom (<code class="reqn">f</code>,<code class="reqn">n - p</code>).
</p>


<h3>Value</h3>


<dl>
<dt>$D</dt><dd><p>List of data.frame which contains the information of the map you input and the results of RGWAS (-log10(p)) which correspond to the map for each tested effect.</p>
</dd>
<dt>$thres</dt><dd><p>A matrix which contains the information of threshold determined by FDR = 0.05. (each trait x each tested effect)</p>
</dd>
<dt>$EMM.res</dt><dd><p>This output is a list which contains the information about the results of &quot;EMM&quot; perfomed at first in regular GWAS.
If you want to know details, see the description for the function &quot;EMM1&quot; or &quot;EMM2&quot;.</p>
</dd>
</dl>



<h3>References</h3>

<p>Kennedy, B.W., Quinton, M. and van Arendonk, J.A. (1992) Estimation of effects of single genes on quantitative traits. J Anim Sci. 70(7): 2000-2012.
</p>
<p>Storey, J.D. and Tibshirani, R. (2003) Statistical significance for genomewide studies. Proc Natl Acad Sci. 100(16): 9440-9445.
</p>
<p>Yu, J. et al. (2006) A unified mixed-model method for association mapping that accounts for multiple levels of relatedness. Nat Genet. 38(2): 203-208.
</p>
<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Kang, H.M. et al. (2010) Variance component model to account for sample structure in genome-wide association studies. Nat Genet. 42(4): 348-354.
</p>
<p>Zhang, Z. et al. (2010) Mixed linear model approach adapted for genome-wide association studies. Nat Genet. 42(4): 355-360.
</p>
<p>Endelman, J.B. (2011) Ridge Regression and Other Kernels for Genomic Selection with R Package rrBLUP. Plant Genome J. 4(3): 250.
</p>
<p>Endelman, J.B. and Jannink, J.L. (2012) Shrinkage Estimation of the Realized Relationship Matrix. G3 Genes, Genomes, Genet. 2(11): 1405-1413.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis for association studies. Nat Genet. 44(7): 821-824.
</p>
<p>Jombart, T., Devillard, S. and Balloux, F. (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genet 11(1), 94.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



  ### Import RAINBOWR
  require(RAINBOWR)

  ### Load example datasets
  data("Rice_Zhao_etal")
  Rice_geno_score &lt;- Rice_Zhao_etal$genoScore
  Rice_geno_map &lt;- Rice_Zhao_etal$genoMap
  Rice_pheno &lt;- Rice_Zhao_etal$pheno

  ### View each dataset
  See(Rice_geno_score)
  See(Rice_geno_map)
  See(Rice_pheno)

  ### Select one trait for example
  trait.name &lt;- "Flowering.time.at.Arkansas"
  y &lt;- as.matrix(Rice_pheno[, trait.name, drop = FALSE])

  ### Remove SNPs whose MAF &lt;= 0.05
  x.0 &lt;- t(Rice_geno_score)
  MAF.cut.res &lt;- MAF.cut(x.0 = x.0, map.0 = Rice_geno_map)
  x &lt;- MAF.cut.res$x
  map &lt;- MAF.cut.res$map


  ### Estimate genomic relationship matrix (GRM)
  K.A &lt;- calcGRM(genoMat = x)


  ### Modify data
  modify.data.res &lt;-
    modify.data(
      pheno.mat = y,
      geno.mat = x,
      map = map,
      return.ZETA = TRUE,
      return.GWAS.format = TRUE
    )
  pheno.GWAS &lt;- modify.data.res$pheno.GWAS
  geno.GWAS &lt;- modify.data.res$geno.GWAS
  ZETA &lt;- modify.data.res$ZETA


  ### View each data for RAINBOWR
  See(pheno.GWAS)
  See(geno.GWAS)
  str(ZETA)



  ### Perform single-SNP GWAS with interaction
  ### by testing all effects (including SNP effects) simultaneously
  normal.res.int &lt;-
    RGWAS.normal.interaction(
      pheno = pheno.GWAS,
      geno = geno.GWAS,
      ZETA = ZETA,
      interaction.with.SNPs = NULL,
      interaction.mat.method = "PCA",
      n.interaction.element = 3,
      interaction.group = NULL,
      n.interaction.group = 3,
      interaction.group.method = "find.clusters",
      n.PC.dapc = 3,
      test.method.interaction = "simultaneous",
      n.PC = 3,
      P3D = TRUE,
      plot.qq = TRUE,
      plot.Manhattan = TRUE,
      verbose = TRUE,
      verbose2 = FALSE,
      count = TRUE,
      time = TRUE,
      package.MM = "gaston",
      parallel.method = "mclapply",
      skip.check = TRUE,
      n.core = 2
    )
  See(normal.res.int$D[[1]])  ### Column 4 contains -log10(p) values
                              ### for all effects (including SNP effects)

</code></pre>

<hr>
<h2 id='RGWAS.twostep'>Perform normal GWAS (genome-wide association studies) first, then perform SNP-set GWAS for relatively significant markers</h2><span id='topic+RGWAS.twostep'></span>

<h3>Description</h3>

<p>Perform normal GWAS (genome-wide association studies) first, then perform SNP-set GWAS for relatively significant markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGWAS.twostep(
  pheno,
  geno,
  ZETA = NULL,
  package.MM = "gaston",
  covariate = NULL,
  covariate.factor = NULL,
  structure.matrix = NULL,
  n.PC = 0,
  min.MAF = 0.02,
  n.core = 1,
  parallel.method = "mclapply",
  check.size = 40,
  check.gene.size = 4,
  kernel.percent = 0.1,
  GWAS.res.first = NULL,
  P3D = TRUE,
  test.method.1 = "normal",
  test.method.2 = "LR",
  kernel.method = "linear",
  kernel.h = "tuned",
  haplotype = TRUE,
  num.hap = NULL,
  test.effect.1 = "additive",
  test.effect.2 = "additive",
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  optimizer = "nlminb",
  gene.set = NULL,
  map.gene.set = NULL,
  weighting.center = TRUE,
  weighting.other = NULL,
  sig.level = 0.05,
  method.thres = "BH",
  plot.qq.1 = TRUE,
  plot.Manhattan.1 = TRUE,
  plot.qq.2 = TRUE,
  plot.Manhattan.2 = TRUE,
  plot.method = 1,
  plot.col1 = c("dark blue", "cornflowerblue"),
  plot.col2 = 1,
  plot.col3 = c("red3", "orange3"),
  plot.type = "p",
  plot.pch = 16,
  saveName = NULL,
  main.qq.1 = NULL,
  main.man.1 = NULL,
  main.qq.2 = NULL,
  main.man.2 = NULL,
  plot.add.last = FALSE,
  return.EMM.res = FALSE,
  thres = TRUE,
  skip.check = FALSE,
  verbose = TRUE,
  verbose2 = FALSE,
  count = TRUE,
  time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGWAS.twostep_+3A_pheno">pheno</code></td>
<td>
<p>Data frame where the first column is the line name (gid). The remaining columns should be a phenotype to test.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_geno">geno</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.
Columns 4 and higher contain the marker scores for each line, coded as [-1, 0, 1] = [aa, Aa, AA].</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_zeta">ZETA</code></td>
<td>
<p>A list of covariance (relationship) matrix (K: <code class="reqn">m \times m</code>) and its design matrix (Z: <code class="reqn">n \times m</code>) of random effects.
Please set names of list &quot;Z&quot; and &quot;K&quot;! You can use more than one kernel matrix.
For example,
</p>
<p>ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D))
</p>

<dl>
<dt>Z.A, Z.D</dt><dd><p>Design matrix (<code class="reqn">n \times m</code>) for the random effects. So, in many cases, you can use the identity matrix.</p>
</dd>
<dt>K.A, K.D</dt><dd><p>Different kernels which express some relationships between lines.</p>
</dd>
</dl>

<p>For example, K.A is additive relationship matrix for the covariance between lines, and K.D is dominance relationship matrix.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_covariate">covariate</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector or a <code class="reqn">n \times p _ 1</code> matrix. You can insert continuous values, such as other traits or genotype score for special markers.
This argument is regarded as one of the fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_covariate.factor">covariate.factor</code></td>
<td>
<p>A <code class="reqn">n \times p _ 2</code> dataframe. You should assign a factor vector for each column.
Then RGWAS changes this argument into model matrix, and this model matrix will be included in the model as fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_structure.matrix">structure.matrix</code></td>
<td>
<p>You can use structure matrix calculated by structure analysis when there are population structure.
You should not use this argument with n.PC &gt; 0.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_n.pc">n.PC</code></td>
<td>
<p>Number of principal components to include as fixed effects. Default is 0 (equals K model).</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_check.size">check.size</code></td>
<td>
<p>This argument determines how many SNPs (around the SNP detected by normal GWAS) you will recalculate -log10(p).</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_check.gene.size">check.gene.size</code></td>
<td>
<p>This argument determines how many genes (around the genes detected by normal GWAS) you will recalculate -log10(p).
This argument is valid only when you assign &quot;gene.set&quot; argument.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_kernel.percent">kernel.percent</code></td>
<td>
<p>This argument determines how many SNPs are detected by normal GWAS.
For example, when kernel.percent = 0.1, SNPs whose value of -log10(p) is in the top 0.1 percent are chosen as candidate for recalculation by SNP-set GWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_gwas.res.first">GWAS.res.first</code></td>
<td>
<p>If you have already performed normal GWAS and have the result, you can skip performing normal GWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_p3d">P3D</code></td>
<td>
<p>When P3D = TRUE, variance components are estimated by REML only once, without any markers in the model.
When P3D = FALSE, variance components are estimated by REML for each marker separately.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_test.method.1">test.method.1</code></td>
<td>
<p>RGWAS supports two methods to test effects of each SNP-set for 1st GWAS.
</p>

<dl>
<dt>&quot;normal&quot;</dt><dd><p>Normal GWAS (default).</p>
</dd>
<dt>&quot;score&quot;</dt><dd><p>Score test, much faster than LR, but sometimes overestimate -log10(p).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_test.method.2">test.method.2</code></td>
<td>
<p>RGWAS supports two methods to test effects of each SNP-set for 2nd GWAS.
</p>

<dl>
<dt>&quot;LR&quot;</dt><dd><p>Likelihood-ratio test, relatively slow, but accurate (default).</p>
</dd>
<dt>&quot;score&quot;</dt><dd><p>Score test, much faster than LR, but sometimes overestimate -log10(p).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_kernel.method">kernel.method</code></td>
<td>
<p>It determines how to calculate kernel. There are three methods.
</p>

<dl>
<dt>&quot;gaussian&quot;</dt><dd><p>It is the default method. Gaussian kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;exponential&quot;</dt><dd><p>When this method is selected, exponential kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;linear&quot;</dt><dd><p>When this method is selected, linear kernel is calculated by NOIA methods for additive GRM.</p>
</dd>
</dl>

<p>So local genomic relation matrix is regarded as kernel.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_kernel.h">kernel.h</code></td>
<td>
<p>The hyper parameter for gaussian or exponential kernel.
If kernel.h = &quot;tuned&quot;, this hyper parameter is calculated as the median of off-diagonals of distance matrix of genotype data.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_test.effect.1">test.effect.1</code></td>
<td>
<p>Effect of each marker to test for 1st GWAS. You can choose &quot;test.effect&quot; from &quot;additive&quot;, &quot;dominance&quot; and &quot;additive+dominance&quot;.
you can assign only one test effect for the 1st GWAS!</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_test.effect.2">test.effect.2</code></td>
<td>
<p>Effect of each marker to test for 2nd GWAS. You can choose &quot;test.effect&quot; from &quot;additive&quot;, &quot;dominance&quot; and &quot;additive+dominance&quot;.
You also can choose more than one effect, for example, test.effect = c(&quot;additive&quot;, &quot;aditive+dominance&quot;)</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the deviance is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene (or haplotype block), you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_map.gene.set">map.gene.set</code></td>
<td>
<p>Genotype map for 'gene.set' (list of haplotype blocks).
This is a data.frame with the haplotype block (SNP-set, or gene-set) names in the first column.
The second and third columns contain the chromosome and map position for each block.
The forth column contains the cumulative map position for each block, which can be computed by <code><a href="#topic+cumsumPos">cumsumPos</a></code> function.
If this argument is NULL, the map will be constructed by <code><a href="#topic+genesetmap">genesetmap</a></code> function after the SNP-set GWAS.
It will take some time, so you can reduce the computational time by assigning this argument beforehand.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_weighting.center">weighting.center</code></td>
<td>
<p>In kernel-based GWAS, weights according to the Gaussian distribution (centered on the tested SNP) are taken into account when calculating the kernel if Rainbow = TRUE.
If weighting.center = FALSE, weights are not taken into account.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_weighting.other">weighting.other</code></td>
<td>
<p>You can set other weights in addition to weighting.center. The length of this argument should be equal to the number of SNPs.
For example, you can assign SNP effects from the information of gene annotation.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level for the threshold. The default is 0.05.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_method.thres">method.thres</code></td>
<td>
<p>Method for detemining threshold of significance. &quot;BH&quot; and &quot;Bonferroni are offered.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_plot.qq.1">plot.qq.1</code></td>
<td>
<p>If TRUE, draw qq plot for normal GWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_plot.manhattan.1">plot.Manhattan.1</code></td>
<td>
<p>If TRUE, draw manhattan plot for normal GWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_plot.qq.2">plot.qq.2</code></td>
<td>
<p>If TRUE, draw qq plot for SNP-set GWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_plot.manhattan.2">plot.Manhattan.2</code></td>
<td>
<p>If TRUE, draw manhattan plot for SNP-set GWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_plot.method">plot.method</code></td>
<td>
<p>If this argument = 1, the default manhattan plot will be drawn.
If this argument = 2, the manhattan plot with axis based on Position (bp) will be drawn.
Also, this plot's color is changed by all chromosomes.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_plot.col1">plot.col1</code></td>
<td>
<p>This argument determines the color of the manhattan plot.
You should substitute this argument as color vector whose length is 2.
plot.col1[1] for odd chromosomes and plot.col1[2] for even chromosomes</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_plot.col2">plot.col2</code></td>
<td>
<p>Color of the manhattan plot. color changes with chromosome and it starts from plot.col2 + 1
(so plot.col2 = 1 means color starts from red.)</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_plot.col3">plot.col3</code></td>
<td>
<p>Color of the points of manhattan plot which are added after the reestimation by SNP-set method.
You should substitute this argument as color vector whose length is 2.
plot.col3[1] for odd chromosomes and plot.col3[2] for even chromosomes.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_plot.type">plot.type</code></td>
<td>
<p>This argument determines the type of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_plot.pch">plot.pch</code></td>
<td>
<p>This argument determines the shape of the dot of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_main.qq.1">main.qq.1</code></td>
<td>
<p>The title of qq plot for normal GWAS. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_main.man.1">main.man.1</code></td>
<td>
<p>The title of manhattan plot for normal GWAS. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_main.qq.2">main.qq.2</code></td>
<td>
<p>The title of qq plot for SNP-set GWAS. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_main.man.2">main.man.2</code></td>
<td>
<p>The title of manhattan plot for SNP-set GWAS. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_plot.add.last">plot.add.last</code></td>
<td>
<p>If saveName is not NULL and this argument is TRUE, then you can add lines or dots to manhattan plots.
However, you should also write &quot;dev.off()&quot; after adding something.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_return.emm.res">return.EMM.res</code></td>
<td>
<p>When return.EMM.res = TRUE, the results of equation of mixed models are included in the result of RGWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_thres">thres</code></td>
<td>
<p>If thres = TRUE, the threshold of the manhattan plot is included in the result of RGWAS.
When return.EMM.res or thres is TRUE, the results will be &quot;list&quot; class.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_skip.check">skip.check</code></td>
<td>
<p>As default, RAINBOWR checks the type of input data and modifies it into the correct format.
However, it will take some time, so if you prepare the correct format of input data, you can skip this procedure
by setting 'skip.check = TRUE'.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_verbose">verbose</code></td>
<td>
<p>If this argument is TRUE, messages for the current steps will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_verbose2">verbose2</code></td>
<td>
<p>If this argument is TRUE, welcome message will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep_+3A_time">time</code></td>
<td>
<p>When time is TRUE, you can know how much time it took to perform RGWAS.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$D</dt><dd><p>Dataframe which contains the information of the map you input and the results of RGWAS (-log10(p)) which correspond to the map.
-log10(p) by normal GWAS and recalculated -log10(p) by SNP-set GWAS will be obtained.
If there are more than one test.effects, then multiple lists for each test.effect are returned respectively.
</p>
</dd>
<dt>$thres</dt><dd><p>A vector which contains the information of threshold determined by FDR = 0.05.</p>
</dd>
<dt>$EMM.res</dt><dd><p>This output is a list which contains the information about the results of &quot;EMM&quot; perfomed at first in normal GWAS.
If you want to know details, see the description for the function &quot;EMM1&quot; or &quot;EMM2&quot;.</p>
</dd>
</dl>



<h3>References</h3>

<p>Kennedy, B.W., Quinton, M. and van Arendonk, J.A. (1992) Estimation of effects of single genes on quantitative traits. J Anim Sci. 70(7): 2000-2012.
</p>
<p>Storey, J.D. and Tibshirani, R. (2003) Statistical significance for genomewide studies. Proc Natl Acad Sci. 100(16): 9440-9445.
</p>
<p>Yu, J. et al. (2006) A unified mixed-model method for association mapping that accounts for multiple levels of relatedness. Nat Genet. 38(2): 203-208.
</p>
<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Kang, H.M. et al. (2010) Variance component model to account for sample structure in genome-wide association studies. Nat Genet. 42(4): 348-354.
</p>
<p>Zhang, Z. et al. (2010) Mixed linear model approach adapted for genome-wide association studies. Nat Genet. 42(4): 355-360.
</p>
<p>Endelman, J.B. (2011) Ridge Regression and Other Kernels for Genomic Selection with R Package rrBLUP. Plant Genome J. 4(3): 250.
</p>
<p>Endelman, J.B. and Jannink, J.L. (2012) Shrinkage Estimation of the Realized Relationship Matrix. G3 Genes, Genomes, Genet. 2(11): 1405-1413.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis for association studies. Nat Genet. 44(7): 821-824.
</p>
<p>Listgarten, J. et al. (2013) A powerful and efficient set test for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



  ### Import RAINBOWR
  require(RAINBOWR)

  ### Load example datasets
  data("Rice_Zhao_etal")
  Rice_geno_score &lt;- Rice_Zhao_etal$genoScore
  Rice_geno_map &lt;- Rice_Zhao_etal$genoMap
  Rice_pheno &lt;- Rice_Zhao_etal$pheno

  ### View each dataset
  See(Rice_geno_score)
  See(Rice_geno_map)
  See(Rice_pheno)

  ### Select one trait for example
  trait.name &lt;- "Flowering.time.at.Arkansas"
  y &lt;- as.matrix(Rice_pheno[, trait.name, drop = FALSE])

  ### Remove SNPs whose MAF &lt;= 0.05
  x.0 &lt;- t(Rice_geno_score)
  MAF.cut.res &lt;- MAF.cut(x.0 = x.0, map.0 = Rice_geno_map)
  x &lt;- MAF.cut.res$x
  map &lt;- MAF.cut.res$map


  ### Estimate genomic relationship matrix (GRM)
  K.A &lt;- calcGRM(genoMat = x)


  ### Modify data
  modify.data.res &lt;- modify.data(pheno.mat = y, geno.mat = x, map = map,
                                 return.ZETA = TRUE, return.GWAS.format = TRUE)
  pheno.GWAS &lt;- modify.data.res$pheno.GWAS
  geno.GWAS &lt;- modify.data.res$geno.GWAS
  ZETA &lt;- modify.data.res$ZETA


  ### View each data for RAINBOWR
  See(pheno.GWAS)
  See(geno.GWAS)
  str(ZETA)


  ### Perform two step SNP-set GWAS (single-snp GWAS -&gt; SNP-set GWAS for significant markers)
  twostep.SNP_set.res &lt;- RGWAS.twostep(pheno = pheno.GWAS, geno = geno.GWAS, ZETA = ZETA,
                                       kernel.percent = 0.2, n.PC = 4, test.method.2 = "LR",
                                       kernel.method = "linear", gene.set = NULL,
                                       test.effect.2 = "additive", window.size.half = 3,
                                       window.slide = 2, package.MM = "gaston",
                                       parallel.method = "mclapply",
                                       skip.check = TRUE, n.core = 2)

  See(twostep.SNP_set.res$D)
  ### Column 4 contains -log10(p) values for markers with the first method (single-SNP GWAS)
  ### Column 5 contains -log10(p) values for markers with the second method (SNP-set GWAS)

</code></pre>

<hr>
<h2 id='RGWAS.twostep.epi'>Perform normal GWAS (genome-wide association studies) first, then check epistatic effects for relatively significant markers</h2><span id='topic+RGWAS.twostep.epi'></span>

<h3>Description</h3>

<p>Perform normal GWAS (genome-wide association studies) first, then check epistatic effects for relatively significant markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGWAS.twostep.epi(
  pheno,
  geno,
  ZETA = NULL,
  package.MM = "gaston",
  covariate = NULL,
  covariate.factor = NULL,
  structure.matrix = NULL,
  n.PC = 0,
  min.MAF = 0.02,
  n.core = 1,
  parallel.method = "mclapply",
  check.size.epi = 4,
  epistasis.percent = 0.05,
  check.epi.max = 200,
  your.check = NULL,
  GWAS.res.first = NULL,
  P3D = TRUE,
  test.method = "LR",
  dominance.eff = TRUE,
  skip.self.int = FALSE,
  haplotype = TRUE,
  num.hap = NULL,
  optimizer = "nlminb",
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  gene.set = NULL,
  map.gene.set = NULL,
  sig.level = 0.05,
  method.thres = "BH",
  plot.qq.1 = TRUE,
  plot.Manhattan.1 = TRUE,
  plot.epi.3d = TRUE,
  plot.epi.2d = TRUE,
  plot.method = 1,
  plot.col1 = c("dark blue", "cornflowerblue"),
  plot.col2 = 1,
  plot.type = "p",
  plot.pch = 16,
  saveName = NULL,
  main.qq.1 = NULL,
  main.man.1 = NULL,
  main.epi.3d = NULL,
  main.epi.2d = NULL,
  skip.check = FALSE,
  verbose = TRUE,
  verbose2 = FALSE,
  count = TRUE,
  time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGWAS.twostep.epi_+3A_pheno">pheno</code></td>
<td>
<p>Data frame where the first column is the line name (gid). The remaining columns should be a phenotype to test.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_geno">geno</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.
Columns 4 and higher contain the marker scores for each line, coded as [-1, 0, 1] = [aa, Aa, AA].</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_zeta">ZETA</code></td>
<td>
<p>A list of covariance (relationship) matrix (K: <code class="reqn">m \times m</code>) and its design matrix (Z: <code class="reqn">n \times m</code>) of random effects.
Please set names of list &quot;Z&quot; and &quot;K&quot;! You can use more than one kernel matrix.
For example,
</p>
<p>ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D))
</p>

<dl>
<dt>Z.A, Z.D</dt><dd><p>Design matrix (<code class="reqn">n \times m</code>) for the random effects. So, in many cases, you can use the identity matrix.</p>
</dd>
<dt>K.A, K.D</dt><dd><p>Different kernels which express some relationships between lines.</p>
</dd>
</dl>

<p>For example, K.A is additive relationship matrix for the covariance between lines, and K.D is dominance relationship matrix.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_covariate">covariate</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector or a <code class="reqn">n \times p _ 1</code> matrix. You can insert continuous values, such as other traits or genotype score for special markers.
This argument is regarded as one of the fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_covariate.factor">covariate.factor</code></td>
<td>
<p>A <code class="reqn">n \times p _ 2</code> dataframe. You should assign a factor vector for each column.
Then RGWAS changes this argument into model matrix, and this model matrix will be included in the model as fixed effects.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_structure.matrix">structure.matrix</code></td>
<td>
<p>You can use structure matrix calculated by structure analysis when there are population structure.
You should not use this argument with n.PC &gt; 0.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_n.pc">n.PC</code></td>
<td>
<p>Number of principal components to include as fixed effects. Default is 0 (equals K model).</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_check.size.epi">check.size.epi</code></td>
<td>
<p>This argument determines how many SNPs (around the SNP detected by normal GWAS) you will check epistasis.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_epistasis.percent">epistasis.percent</code></td>
<td>
<p>This argument determines how many SNPs are detected by normal GWAS.
For example, when epistasis.percent = 0.1, SNPs whose value of -log10(p) is in the top 0.1 percent are chosen as candidate for checking epistasis.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_check.epi.max">check.epi.max</code></td>
<td>
<p>It takes a lot of time to check epistasis, so you can decide the maximum number of SNPs to check epistasis.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_your.check">your.check</code></td>
<td>
<p>Because there are less SNPs that can be tested in epistasis than in kernel-based GWAS, you can select which SNPs you want to test.
If you use this argument, please set the number where SNPs to be tested are located in your data (so not position).
In the default setting, your_check = NULL and epistasis between SNPs detected by GWAS will be tested.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_gwas.res.first">GWAS.res.first</code></td>
<td>
<p>If you have already performed regular GWAS and have the result, you can skip performing normal GWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_p3d">P3D</code></td>
<td>
<p>When P3D = TRUE, variance components are estimated by REML only once, without any markers in the model.
When P3D = FALSE, variance components are estimated by REML for each marker separately.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_test.method">test.method</code></td>
<td>
<p>RGWAS supports two methods to test effects of each SNP-set.
</p>

<dl>
<dt>&quot;LR&quot;</dt><dd><p>Likelihood-ratio test, relatively slow, but accurate (default).</p>
</dd>
<dt>&quot;score&quot;</dt><dd><p>Score test, much faster than LR, but sometimes overestimate -log10(p).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_dominance.eff">dominance.eff</code></td>
<td>
<p>If this argument is TRUE, dominance effect is included in the model,
and additive x dominance and dominance x dominance are also tested as epistatic effects.
When you use inbred lines, please set this argument FALSE.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_skip.self.int">skip.self.int</code></td>
<td>
<p>As default, the function also tests the self-interactions among the same SNP-sets.
If you want to avoid this, please set 'skip.self.int = TRUE'.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the deviance is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene (or haplotype block), you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_map.gene.set">map.gene.set</code></td>
<td>
<p>Genotype map for 'gene.set' (list of haplotype blocks).
This is a data.frame with the haplotype block (SNP-set, or gene-set) names in the first column.
The second and third columns contain the chromosome and map position for each block.
The forth column contains the cumulative map position for each block, which can be computed by <code><a href="#topic+cumsumPos">cumsumPos</a></code> function.
If this argument is NULL, the map will be constructed by <code><a href="#topic+genesetmap">genesetmap</a></code> function after the SNP-set GWAS.
It will take some time, so you can reduce the computational time by assigning this argument beforehand.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level for the threshold. The default is 0.05.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_method.thres">method.thres</code></td>
<td>
<p>Method for detemining threshold of significance. &quot;BH&quot; and &quot;Bonferroni are offered.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_plot.qq.1">plot.qq.1</code></td>
<td>
<p>If TRUE, draw qq plot for normal GWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_plot.manhattan.1">plot.Manhattan.1</code></td>
<td>
<p>If TRUE, draw manhattan plot for normal GWAS.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_plot.epi.3d">plot.epi.3d</code></td>
<td>
<p>If TRUE, draw 3d plot</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_plot.epi.2d">plot.epi.2d</code></td>
<td>
<p>If TRUE, draw 2d plot</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_plot.method">plot.method</code></td>
<td>
<p>If this argument = 1, the default manhattan plot will be drawn.
If this argument = 2, the manhattan plot with axis based on Position (bp) will be drawn.
Also, this plot's color is changed by all chromosomes.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_plot.col1">plot.col1</code></td>
<td>
<p>This argument determines the color of the manhattan plot.
You should substitute this argument as color vector whose length is 2.
plot.col1[1] for odd chromosomes and plot.col1[2] for even chromosomes</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_plot.col2">plot.col2</code></td>
<td>
<p>Color of the manhattan plot. color changes with chromosome and it starts from plot.col2 + 1
(so plot.col2 = 1 means color starts from red.)</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_plot.type">plot.type</code></td>
<td>
<p>This argument determines the type of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_plot.pch">plot.pch</code></td>
<td>
<p>This argument determines the shape of the dot of the manhattan plot. See the help page of &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_main.qq.1">main.qq.1</code></td>
<td>
<p>The title of qq plot for normal GWAS. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_main.man.1">main.man.1</code></td>
<td>
<p>The title of manhattan plot for normal GWAS. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_main.epi.3d">main.epi.3d</code></td>
<td>
<p>The title of 3d plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_main.epi.2d">main.epi.2d</code></td>
<td>
<p>The title of 2d plot. If this argument is NULL, trait name is set as the title.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_skip.check">skip.check</code></td>
<td>
<p>As default, RAINBOWR checks the type of input data and modifies it into the correct format.
However, it will take some time, so if you prepare the correct format of input data, you can skip this procedure
by setting 'skip.check = TRUE'.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_verbose">verbose</code></td>
<td>
<p>If this argument is TRUE, messages for the current steps will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_verbose2">verbose2</code></td>
<td>
<p>If this argument is TRUE, welcome message will be shown.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
<tr><td><code id="RGWAS.twostep.epi_+3A_time">time</code></td>
<td>
<p>When time is TRUE, you can know how much time it took to perform RGWAS.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$first</dt><dd><p>The results of first normal GWAS will be returned.</p>
</dd>
<dt>$map.epi</dt><dd><p>Map information for SNPs which are tested epistatic effects.</p>
</dd>
<dt>$epistasis</dt><dd>

<dl>
<dt>$scores</dt><dd>
<dl>
<dt>$scores</dt><dd><p>This is the matrix which contains -log10(p) calculated by the test about epistasis effects.</p>
</dd>
<dt>$x, $y</dt><dd><p>The information of the positions of SNPs detected by regular GWAS.
These vectors are used when drawing plots. Each output correspond to the replication of row and column of scores.</p>
</dd>
<dt>$z</dt><dd><p>This is a vector of $scores.  This vector is also used when drawing plots.</p>
</dd>
</dl>

</dd>
</dl>

</dd>
</dl>



<h3>References</h3>

<p>Kennedy, B.W., Quinton, M. and van Arendonk, J.A. (1992) Estimation of effects of single genes on quantitative traits. J Anim Sci. 70(7): 2000-2012.
</p>
<p>Storey, J.D. and Tibshirani, R. (2003) Statistical significance for genomewide studies. Proc Natl Acad Sci. 100(16): 9440-9445.
</p>
<p>Yu, J. et al. (2006) A unified mixed-model method for association mapping that accounts for multiple levels of relatedness. Nat Genet. 38(2): 203-208.
</p>
<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Kang, H.M. et al. (2010) Variance component model to account for sample structure in genome-wide association studies. Nat Genet. 42(4): 348-354.
</p>
<p>Zhang, Z. et al. (2010) Mixed linear model approach adapted for genome-wide association studies. Nat Genet. 42(4): 355-360.
</p>
<p>Endelman, J.B. (2011) Ridge Regression and Other Kernels for Genomic Selection with R Package rrBLUP. Plant Genome J. 4(3): 250.
</p>
<p>Endelman, J.B. and Jannink, J.L. (2012) Shrinkage Estimation of the Realized Relationship Matrix. G3 Genes, Genomes, Genet. 2(11): 1405-1413.
</p>
<p>Su, G. et al. (2012) Estimating Additive and Non-Additive Genetic Variances and Predicting Genetic Merits Using Genome-Wide Dense Single Nucleotide Polymorphism Markers. PLoS One. 7(9): 1-7.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis for association studies. Nat Genet. 44(7): 821-824.
</p>
<p>Listgarten, J. et al. (2013) A powerful and efficient set test for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>
<p>Jiang, Y. and Reif, J.C. (2015) Modeling epistasis in genomic selection. Genetics. 201(2): 759-768.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



  ### Import RAINBOWR
  require(RAINBOWR)

  ### Load example datasets
  data("Rice_Zhao_etal")
  Rice_geno_score &lt;- Rice_Zhao_etal$genoScore
  Rice_geno_map &lt;- Rice_Zhao_etal$genoMap
  Rice_pheno &lt;- Rice_Zhao_etal$pheno

  ### View each dataset
  See(Rice_geno_score)
  See(Rice_geno_map)
  See(Rice_pheno)

  ### Select one trait for example
  trait.name &lt;- "Flowering.time.at.Arkansas"
  y &lt;- Rice_pheno[, trait.name, drop = FALSE]

  ### Remove SNPs whose MAF &lt;= 0.05
  x.0 &lt;- t(Rice_geno_score)
  MAF.cut.res &lt;- MAF.cut(x.0 = x.0, map.0 = Rice_geno_map)
  x &lt;- MAF.cut.res$x
  map &lt;- MAF.cut.res$map


  ### Estimate genomic relationship matrix (GRM)
  K.A &lt;- calcGRM(genoMat = x)


  ### Modify data
  modify.data.res &lt;- modify.data(pheno.mat = y, geno.mat = x, map = map,
                                 return.ZETA = TRUE, return.GWAS.format = TRUE)
  pheno.GWAS &lt;- modify.data.res$pheno.GWAS
  geno.GWAS &lt;- modify.data.res$geno.GWAS
  ZETA &lt;- modify.data.res$ZETA


  ### View each data for RAINBOWR
  See(pheno.GWAS)
  See(geno.GWAS)
  str(ZETA)




  ### Perform two-step epistasis GWAS (single-snp GWAS -&gt; Check epistasis for significant markers)
  twostep.epi.res &lt;- RGWAS.twostep.epi(pheno = pheno.GWAS, geno = geno.GWAS, ZETA = ZETA,
                                       n.PC = 4, test.method = "LR", gene.set = NULL,
                                       window.size.half = 10, window.slide = 21,
                                       package.MM = "gaston", parallel.method = "mclapply",
                                       skip.check = TRUE, n.core = 2)

  See(twostep.epi.res$epistasis$scores)

</code></pre>

<hr>
<h2 id='Rice_geno_map'>Physical map of rice genome</h2><span id='topic+Rice_geno_map'></span>

<h3>Description</h3>

<p>A dataset containing the information of phycical map of rice genome (Zhao et al., 2010; PLoS One 5(5): e10780).
</p>


<h3>Format</h3>

<p>A data frame with 1311 rows and 3 variables:
</p>

<dl>
<dt>marker</dt><dd><p>marker name for each marker, character</p>
</dd>
<dt>chr</dt><dd><p>chromosome number for each marker, integer</p>
</dd>
<dt>pos</dt><dd><p>physical position for each marker, integer, (b.p.)</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.ricediversity.org/data/">http://www.ricediversity.org/data/</a>
</p>


<h3>References</h3>

<p>Zhao K, Wright M, Kimball J, Eizenga G, McClung A, Kovach M, Tyagi W, Ali ML, Tung CW, Reynolds A, Bustamante CD, McCouch SR (2010). Genomic Diversity and Introgression in O. sativa Reveal the Impact of Domestication and Breeding on the Rice Genome. PLoS One. 2010; 5(5): e10780.
</p>

<hr>
<h2 id='Rice_geno_score'>Marker genotype of rice genome</h2><span id='topic+Rice_geno_score'></span>

<h3>Description</h3>

<p>A dataset containing the information of marker genotype (scored with [-1, 0, 1])
of rice genome (Zhao et al., 2010; PLoS One 5(5): e10780).
</p>


<h3>Format</h3>

<p>A data frame with 1311 rows and 395 variables:
</p>

<p>Each column shows the marker genotype of each accession.
The column names are the names of accessions and the rownames are the names of markers.

</p>


<h3>Source</h3>

<p><a href="http://www.ricediversity.org/data/">http://www.ricediversity.org/data/</a>
</p>


<h3>References</h3>

<p>Zhao K, Wright M, Kimball J, Eizenga G, McClung A, Kovach M, Tyagi W, Ali ML, Tung CW, Reynolds A, Bustamante CD, McCouch SR (2010). Genomic Diversity and Introgression in O. sativa Reveal the Impact of Domestication and Breeding on the Rice Genome. PLoS One. 2010; 5(5): e10780.
</p>

<hr>
<h2 id='Rice_haplo_block'>Physical map of rice genome</h2><span id='topic+Rice_haplo_block'></span>

<h3>Description</h3>

<p>A dataset containing the information of haplotype block of rice genome (Zhao et al., 2010; PLoS One 5(5): e10780).
The haplotype blocks were estimated using PLINK 1.9 (See reference).
</p>


<h3>Format</h3>

<p>A data frame with 74 rows and 2 variables:
</p>

<dl>
<dt>block</dt><dd><p>names of haplotype blocks which consist of marker(s) in <a href="#topic+Rice_geno_score">Rice_geno_score</a>, character</p>
</dd>
<dt>marker</dt><dd><p>marker names for each marker corresponding to those in <a href="#topic+Rice_geno_score">Rice_geno_score</a>, character</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.ricediversity.org/data/">http://www.ricediversity.org/data/</a>
</p>


<h3>References</h3>

<p>Zhao K, Wright M, Kimball J, Eizenga G, McClung A, Kovach M, Tyagi W, Ali ML, Tung CW, Reynolds A, Bustamante CD, McCouch SR (2010). Genomic Diversity and Introgression in O. sativa Reveal the Impact of Domestication and Breeding on the Rice Genome. PLoS One. 2010; 5(5): e10780.
Purcell, S. and Chang, C. (2018). PLINK 1.9, www.cog-genomics.org/plink/1.9/.
Chang CC, Chow CC, Tellier LCAM, Vattikuti S, Purcell SM, Lee JJ (2015) Second-generation PLINK: rising to the challenge of larger and richer datasets. GigaScience, 4.
Gaunt T, Rodr√≠guez S, Day I (2007) Cubic exact solutions for the estimation of pairwise haplotype frequencies: implications for linkage disequilibrium analyses and a web tool 'CubeX'. BMC Bioinformatics, 8.
Taliun D, Gamper J, Pattaro C (2014) Efficient haplotype block recognition of very long and dense genetic sequences. BMC Bioinformatics, 15.
</p>

<hr>
<h2 id='Rice_pheno'>Phenotype data of rice field trial</h2><span id='topic+Rice_pheno'></span>

<h3>Description</h3>

<p>A dataset containing the information of phenotype data of rice field trial (Zhao et al., 2011; Nat Comm 2:467).
</p>


<h3>Format</h3>

<p>A data frame with 413 rows and 36 variables:
</p>

<p>Phenotypic data of 36 traits obtained by the field trial with 413 genotypes.

</p>


<h3>Source</h3>

<p><a href="http://www.ricediversity.org/data/">http://www.ricediversity.org/data/</a>
</p>


<h3>References</h3>

<p>Zhao, K. et al. (2011) Genome-wide association mapping reveals a rich genetic architecture of complex traits in Oryza sativa. Nat Commun. 2: 467.
</p>

<hr>
<h2 id='Rice_Zhao_etal'>Rice_Zhao_etal:</h2><span id='topic+Rice_Zhao_etal'></span>

<h3>Description</h3>

<p>A list containing the information of marker genotype of rice genome (Zhao et al., 2010; PLoS One 5(5): e10780)
and phenotype data of rice field trial (Zhao et al., 2011; Nat Comm 2:467).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rice_Zhao_etal
</code></pre>


<h3>Format</h3>

<p>A list of 4 data frames:
</p>

<dl>
<dt>$genoScore</dt><dd><p>marker genotyope, <a href="#topic+Rice_geno_score">Rice_geno_score</a></p>
</dd>
<dt>$genoMap</dt><dd><p>physical map, <a href="#topic+Rice_geno_map">Rice_geno_map</a></p>
</dd>
<dt>$pheno</dt><dd><p>phenotype, <a href="#topic+Rice_pheno">Rice_pheno</a></p>
</dd>
<dt>$haploBlock</dt><dd><p>haplotype block, <a href="#topic+Rice_haplo_block">Rice_haplo_block</a></p>
</dd>
</dl>



<h3>Details</h3>

<p>Marker genotype and phenotype data of rice by Zhao et al., 2010.
</p>


<h3>Source</h3>

<p><a href="http://www.ricediversity.org/data/">http://www.ricediversity.org/data/</a>
</p>


<h3>References</h3>

<p>Zhao K, Wright M, Kimball J, Eizenga G, McClung A, Kovach M, Tyagi W, Ali ML, Tung CW, Reynolds A, Bustamante CD, McCouch SR (2010). Genomic Diversity and Introgression in O. sativa Reveal the Impact of Domestication and Breeding on the Rice Genome. PLoS One. 2010; 5(5): e10780.
Zhao, K. et al. (2011) Genome-wide association mapping reveals a rich genetic architecture of complex traits in Oryza sativa. Nat Commun. 2: 467.
Purcell, S. and Chang, C. (2018). PLINK 1.9, www.cog-genomics.org/plink/1.9/.
Chang CC, Chow CC, Tellier LCAM, Vattikuti S, Purcell SM, Lee JJ (2015) Second-generation PLINK: rising to the challenge of larger and richer datasets. GigaScience, 4.
Gaunt T, Rodr√≠guez S, Day I (2007) Cubic exact solutions for the estimation of pairwise haplotype frequencies: implications for linkage disequilibrium analyses and a web tool 'CubeX'. BMC Bioinformatics, 8.
Taliun D, Gamper J, Pattaro C (2014) Efficient haplotype block recognition of very long and dense genetic sequences. BMC Bioinformatics, 15.
</p>


<h3>See Also</h3>

<p><a href="#topic+Rice_geno_score">Rice_geno_score</a>, <a href="#topic+Rice_geno_map">Rice_geno_map</a>, <a href="#topic+Rice_pheno">Rice_pheno</a>, <a href="#topic+Rice_haplo_block">Rice_haplo_block</a>
</p>

<hr>
<h2 id='score.calc'>Calculate -log10(p) for single-SNP GWAS</h2><span id='topic+score.calc'></span>

<h3>Description</h3>

<p>Calculate -log10(p) of each SNP by the Wald test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc(
  M.now,
  ZETA.now,
  y,
  X.now,
  package.MM = "gaston",
  Hinv,
  P3D = TRUE,
  eigen.G = NULL,
  optimizer = "nlminb",
  n.core = 1,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="score.calc_+3A_hinv">Hinv</code></td>
<td>
<p>The inverse of <code class="reqn">H = ZKZ' + \lambda I</code> where <code class="reqn">\lambda = \sigma^2_e / \sigma^2_u</code>.</p>
</td></tr>
<tr><td><code id="score.calc_+3A_p3d">P3D</code></td>
<td>
<p>When P3D = TRUE, variance components are estimated by REML only once, without any markers in the model.
When P3D = FALSE, variance components are estimated by REML for each marker separately.</p>
</td></tr>
<tr><td><code id="score.calc_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process.
We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.
This argument is only valid when &lsquo;package.MM = &rsquo;RAINBOWR''.</p>
</td></tr>
<tr><td><code id="score.calc_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.</p>
</td></tr>
<tr><td><code id="score.calc_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) for each marker
</p>


<h3>References</h3>

<p>Kennedy, B.W., Quinton, M. and van Arendonk, J.A. (1992)
Estimation of effects of single genes on quantitative traits. J Anim Sci. 70(7): 2000-2012.
</p>
<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure
in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Kang, H.M. et al. (2010) Variance component model to account for sample
structure in genome-wide association studies. Nat Genet. 42(4): 348-354.
</p>
<p>Zhang, Z. et al. (2010) Mixed linear model approach adapted for genome-wide
association studies. Nat Genet. 42(4): 355-360.
</p>

<hr>
<h2 id='score.calc.epistasis.LR'>Calculate -log10(p) of epistatic effects by LR test</h2><span id='topic+score.calc.epistasis.LR'></span>

<h3>Description</h3>

<p>Calculate -log10(p) of epistatic effects by LR test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.epistasis.LR(
  M.now,
  y,
  X.now,
  ZETA.now,
  package.MM = "gaston",
  eigen.SGS = NULL,
  eigen.G = NULL,
  n.core = 1,
  optimizer = "nlminb",
  map,
  haplotype = TRUE,
  num.hap = NULL,
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  gene.set = NULL,
  dominance.eff = TRUE,
  skip.self.int = FALSE,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.epistasis.LR_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_eigen.sgs">eigen.SGS</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">SGS</code>, where <code class="reqn">S = I - X(X'X)^{-1}X'</code>, <code class="reqn">G = ZKZ'</code>.
You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_map">map</code></td>
<td>
<p>Data frame of map information where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the tdeviance is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene, you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_dominance.eff">dominance.eff</code></td>
<td>
<p>If this argument is TRUE, dominance effect is included in the model,
and additive x dominance and dominance x dominance are also tested as epistatic effects.
When you use inbred lines, please set this argument FALSE.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_skip.self.int">skip.self.int</code></td>
<td>
<p>As default, the function also tests the self-interactions among the same SNP-sets.
If you want to avoid this, please set 'skip.self.int = TRUE'.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) of epistatic effects for each SNP-set
</p>


<h3>References</h3>

<p>Listgarten, J. et al. (2013) A powerful and efficient set test
for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based
association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>
<p>Jiang, Y. and Reif, J.C. (2015) Modeling epistasis in genomic selection. Genetics. 201(2): 759-768.
</p>

<hr>
<h2 id='score.calc.epistasis.LR.MC'>Calculate -log10(p) of epistatic effects by LR test (multi-cores)</h2><span id='topic+score.calc.epistasis.LR.MC'></span>

<h3>Description</h3>

<p>Calculate -log10(p) of epistatic effects by LR test (multi-cores)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.epistasis.LR.MC(
  M.now,
  y,
  X.now,
  ZETA.now,
  package.MM = "gaston",
  eigen.SGS = NULL,
  eigen.G = NULL,
  n.core = 2,
  parallel.method = "mclapply",
  optimizer = "nlminb",
  map,
  haplotype = TRUE,
  num.hap = NULL,
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  gene.set = NULL,
  dominance.eff = TRUE,
  skip.self.int = FALSE,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_eigen.sgs">eigen.SGS</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">SGS</code>, where <code class="reqn">S = I - X(X'X)^{-1}X'</code>, <code class="reqn">G = ZKZ'</code>.
You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_map">map</code></td>
<td>
<p>Data frame of map information where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the tdeviance is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene, you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_dominance.eff">dominance.eff</code></td>
<td>
<p>If this argument is TRUE, dominance effect is included in the model,
and additive x dominance and dominance x dominance are also tested as epistatic effects.
When you use inbred lines, please set this argument FALSE.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_skip.self.int">skip.self.int</code></td>
<td>
<p>As default, the function also tests the self-interactions among the same SNP-sets.
If you want to avoid this, please set 'skip.self.int = TRUE'.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.LR.MC_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) of epistatic effects for each SNP-set
</p>


<h3>References</h3>

<p>Listgarten, J. et al. (2013) A powerful and efficient set test
for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based
association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>
<p>Jiang, Y. and Reif, J.C. (2015) Modeling epistasis in genomic selection. Genetics. 201(2): 759-768.
</p>

<hr>
<h2 id='score.calc.epistasis.score'>Calculate -log10(p) of epistatic effects with score test</h2><span id='topic+score.calc.epistasis.score'></span>

<h3>Description</h3>

<p>Calculate -log10(p) of epistatic effects with score test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.epistasis.score(
  M.now,
  y,
  X.now,
  ZETA.now,
  Gu,
  Ge,
  P0,
  map,
  haplotype = TRUE,
  num.hap = NULL,
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  gene.set = NULL,
  dominance.eff = TRUE,
  skip.self.int = FALSE,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.epistasis.score_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_gu">Gu</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign <code class="reqn">ZKZ'</code>, where K is covariance (relationship) matrix and Z is its design matrix.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_ge">Ge</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign identity matrix I (diag(n)).</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_p0">P0</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. The Moore-Penrose generalized inverse of <code class="reqn">SV0S</code>, where <code class="reqn">S = X(X'X)^{-1}X'</code> and
<code class="reqn">V0 = \sigma^2_u Gu + \sigma^2_e Ge</code>. <code class="reqn">\sigma^2_u</code> and <code class="reqn">\sigma^2_e</code> are estimators of the null model.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_map">map</code></td>
<td>
<p>Data frame of map information where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the test statistic <code class="reqn">l1' F l1</code> is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where l1 is the first derivative of the log-likelihood and F is the Fisher information. And r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene, you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_dominance.eff">dominance.eff</code></td>
<td>
<p>If this argument is TRUE, dominance effect is included in the model,
and additive x dominance and dominance x dominance are also tested as epistatic effects.
When you use inbred lines, please set this argument FALSE.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_skip.self.int">skip.self.int</code></td>
<td>
<p>As default, the function also tests the self-interactions among the same SNP-sets.
If you want to avoid this, please set 'skip.self.int = TRUE'.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) of epistatic effects for each SNP-set
</p>


<h3>References</h3>

<p>Listgarten, J. et al. (2013) A powerful and efficient set test
for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based
association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>
<p>Jiang, Y. and Reif, J.C. (2015) Modeling epistasis in genomic selection. Genetics. 201(2): 759-768.
</p>

<hr>
<h2 id='score.calc.epistasis.score.MC'>Calculate -log10(p) of epistatic effects with score test (multi-cores)</h2><span id='topic+score.calc.epistasis.score.MC'></span>

<h3>Description</h3>

<p>Calculate -log10(p) of epistatic effects with score test (multi-cores)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.epistasis.score.MC(
  M.now,
  y,
  X.now,
  ZETA.now,
  n.core = 2,
  parallel.method = "mclapply",
  Gu,
  Ge,
  P0,
  map,
  haplotype = TRUE,
  num.hap = NULL,
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  gene.set = NULL,
  dominance.eff = TRUE,
  skip.self.int = FALSE,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.epistasis.score.MC_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_gu">Gu</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign <code class="reqn">ZKZ'</code>, where K is covariance (relationship) matrix and Z is its design matrix.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_ge">Ge</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign identity matrix I (diag(n)).</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_p0">P0</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. The Moore-Penrose generalized inverse of <code class="reqn">SV0S</code>, where <code class="reqn">S = X(X'X)^{-1}X'</code> and
<code class="reqn">V0 = \sigma^2_u Gu + \sigma^2_e Ge</code>. <code class="reqn">\sigma^2_u</code> and <code class="reqn">\sigma^2_e</code> are estimators of the null model.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_map">map</code></td>
<td>
<p>Data frame of map information where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the test statistic <code class="reqn">l1' F l1</code> is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where l1 is the first derivative of the log-likelihood and F is the Fisher information. And r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene, you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_dominance.eff">dominance.eff</code></td>
<td>
<p>If this argument is TRUE, dominance effect is included in the model,
and additive x dominance and dominance x dominance are also tested as epistatic effects.
When you use inbred lines, please set this argument FALSE.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_skip.self.int">skip.self.int</code></td>
<td>
<p>As default, the function also tests the self-interactions among the same SNP-sets.
If you want to avoid this, please set 'skip.self.int = TRUE'.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.epistasis.score.MC_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) of epistatic effects for each SNP-set
</p>


<h3>References</h3>

<p>Listgarten, J. et al. (2013) A powerful and efficient set test
for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based
association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>
<p>Jiang, Y. and Reif, J.C. (2015) Modeling epistasis in genomic selection. Genetics. 201(2): 759-768.
</p>

<hr>
<h2 id='score.calc.int'>Calculate -log10(p) for single-SNP GWAS with interaction</h2><span id='topic+score.calc.int'></span>

<h3>Description</h3>

<p>Calculate -log10(p) of each SNP by the Wald test for the model inluding interaction term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.int(
  M.now,
  ZETA.now,
  y,
  X.now,
  package.MM = "gaston",
  interaction.with.SNPs.now,
  test.method.interaction = "simultaneous",
  include.SNP.effect = TRUE,
  Hinv,
  P3D = TRUE,
  eigen.G = NULL,
  optimizer = "nlminb",
  n.core = 1,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.int_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_interaction.with.snps.now">interaction.with.SNPs.now</code></td>
<td>
<p>A <code class="reqn">m \times q</code> matrix. Interaction between each SNP and this matrix will also be tested.
For example, principal components of genomic relationship matrix can be used as this matrix to test the interaction between SNPs and the genetic background.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_test.method.interaction">test.method.interaction</code></td>
<td>
<p>Method for how to test SNPs and the interactions between SNPs and the genetic background.
We offer three methods as follows:
</p>
<p>&quot;simultaneous&quot;: All effects (including SNP efects) are tested simultanously.
</p>
<p>&quot;snpSeparate&quot;: SNP effects are tested as one effect, and the other interaction effects are simulateneously.
</p>
<p>&quot;oneByOne&quot;: All efects are tested separately, one by one.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_include.snp.effect">include.SNP.effect</code></td>
<td>
<p>Whether or not including SNP effects into the tested effects.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_hinv">Hinv</code></td>
<td>
<p>The inverse of <code class="reqn">H = ZKZ' + \lambda I</code> where <code class="reqn">\lambda = \sigma^2_e / \sigma^2_u</code>.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_p3d">P3D</code></td>
<td>
<p>When P3D = TRUE, variance components are estimated by REML only once, without any markers in the model.
When P3D = FALSE, variance components are estimated by REML for each marker separately.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process.
We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.
This argument is only valid when &lsquo;package.MM = &rsquo;RAINBOWR''.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.int_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) for each marker
</p>


<h3>References</h3>

<p>Kennedy, B.W., Quinton, M. and van Arendonk, J.A. (1992)
Estimation of effects of single genes on quantitative traits. J Anim Sci. 70(7): 2000-2012.
</p>
<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure
in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Kang, H.M. et al. (2010) Variance component model to account for sample
structure in genome-wide association studies. Nat Genet. 42(4): 348-354.
</p>
<p>Zhang, Z. et al. (2010) Mixed linear model approach adapted for genome-wide
association studies. Nat Genet. 42(4): 355-360.
</p>

<hr>
<h2 id='score.calc.int.MC'>Calculate -log10(p) for single-SNP GWAS with interaction (multi-cores)</h2><span id='topic+score.calc.int.MC'></span>

<h3>Description</h3>

<p>Calculate -log10(p) of each SNP by the Wald test for the model inluding interaction term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.int.MC(
  M.now,
  ZETA.now,
  y,
  X.now,
  package.MM = "gaston",
  interaction.with.SNPs.now,
  test.method.interaction = "simultaneous",
  include.SNP.effect = TRUE,
  Hinv,
  n.core = 2,
  parallel.method = "mclapply",
  P3D = TRUE,
  eigen.G = NULL,
  optimizer = "nlminb",
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.int.MC_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_interaction.with.snps.now">interaction.with.SNPs.now</code></td>
<td>
<p>A <code class="reqn">m \times q</code> matrix. Interaction between each SNP and this matrix will also be tested.
For example, principal components of genomic relationship matrix can be used as this matrix to test the interaction between SNPs and the genetic background.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_test.method.interaction">test.method.interaction</code></td>
<td>
<p>Method for how to test SNPs and the interactions between SNPs and the genetic background.
We offer three methods as follows:
</p>
<p>&quot;simultaneous&quot;: All effects (including SNP efects) are tested simultanously.
</p>
<p>&quot;snpSeparate&quot;: SNP effects are tested as one effect, and the other interaction effects are simulateneously.
</p>
<p>&quot;oneByOne&quot;: All efects are tested separately, one by one.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_include.snp.effect">include.SNP.effect</code></td>
<td>
<p>Whether or not including SNP effects into the tested effects.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_hinv">Hinv</code></td>
<td>
<p>The inverse of <code class="reqn">H = ZKZ' + \lambda I</code> where <code class="reqn">\lambda = \sigma^2_e / \sigma^2_u</code>.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_p3d">P3D</code></td>
<td>
<p>When P3D = TRUE, variance components are estimated by REML only once, without any markers in the model.
When P3D = FALSE, variance components are estimated by REML for each marker separately.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process.
We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.
This argument is only valid when &lsquo;package.MM = &rsquo;RAINBOWR''.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.int.MC_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) for each marker
</p>


<h3>References</h3>

<p>Kennedy, B.W., Quinton, M. and van Arendonk, J.A. (1992)
Estimation of effects of single genes on quantitative traits. J Anim Sci. 70(7): 2000-2012.
</p>
<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure
in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Kang, H.M. et al. (2010) Variance component model to account for sample
structure in genome-wide association studies. Nat Genet. 42(4): 348-354.
</p>
<p>Zhang, Z. et al. (2010) Mixed linear model approach adapted for genome-wide
association studies. Nat Genet. 42(4): 355-360.
</p>

<hr>
<h2 id='score.calc.LR'>Calculate -log10(p) of each SNP-set by the LR test</h2><span id='topic+score.calc.LR'></span>

<h3>Description</h3>

<p>This function calculates -log10(p) of each SNP-set by the LR (likelihood-ratio) test.
First, the function solves the multi-kernel mixed model and calaculates the maximum restricted log likelihood.
Then it performs the LR test by using the fact that the deviance
</p>
<p style="text-align: center;"><code class="reqn">D = 2 \times (LL _ {alt} - LL _ {null})</code>
</p>

<p>follows the chi-square distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.LR(
  M.now,
  y,
  X.now,
  ZETA.now,
  package.MM = "gaston",
  LL0,
  eigen.SGS = NULL,
  eigen.G = NULL,
  n.core = 1,
  optimizer = "nlminb",
  map,
  kernel.method = "linear",
  kernel.h = "tuned",
  haplotype = TRUE,
  num.hap = NULL,
  test.effect = "additive",
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  weighting.center = TRUE,
  weighting.other = NULL,
  gene.set = NULL,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.LR_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_ll0">LL0</code></td>
<td>
<p>The log-likelihood for the null model.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_eigen.sgs">eigen.SGS</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eeigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">SGS</code>, where <code class="reqn">S = I - X(X'X)^{-1}X'</code>, <code class="reqn">G = ZKZ'</code>.
You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_map">map</code></td>
<td>
<p>Data frame of map information where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_kernel.method">kernel.method</code></td>
<td>
<p>It determines how to calculate kernel. There are three methods.
</p>

<dl>
<dt>&quot;gaussian&quot;</dt><dd><p>It is the default method. Gaussian kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;exponential&quot;</dt><dd><p>When this method is selected, exponential kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;linear&quot;</dt><dd><p>When this method is selected, linear kernel is calculated by NOIA methods for additive GRM.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_kernel.h">kernel.h</code></td>
<td>
<p>The hyper-parameter for gaussian or exponential kernel.
If kernel.h = &quot;tuned&quot;, this hyper parameter is calculated as the median of off-diagonals of distance matrix of genotype data.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_test.effect">test.effect</code></td>
<td>
<p>Effect of each marker to test. You can choose &quot;test.effect&quot; from &quot;additive&quot;, &quot;dominance&quot; and &quot;additive+dominance&quot;.
You also can choose more than one effect, for example, test.effect = c(&quot;additive&quot;, &quot;aditive+dominance&quot;)</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the deviance is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_weighting.center">weighting.center</code></td>
<td>
<p>In kernel-based GWAS, weights according to the Gaussian distribution (centered on the tested SNP) are taken into account when calculating the kernel if Rainbow = TRUE.
If weighting.center = FALSE, weights are not taken into account.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_weighting.other">weighting.other</code></td>
<td>
<p>You can set other weights in addition to weighting.center. The length of this argument should be equal to the number of SNPs.
For example, you can assign SNP effects from the information of gene annotation.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene, you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.LR_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) for each SNP-set
</p>


<h3>References</h3>

<p>Listgarten, J. et al. (2013) A powerful and efficient set test
for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based
association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>

<hr>
<h2 id='score.calc.LR.int'>Calculate -log10(p) of each SNP-set and its interaction with kernels by the LR test</h2><span id='topic+score.calc.LR.int'></span>

<h3>Description</h3>

<p>This function calculates -log10(p) of each SNP-set and its interaction with kernels by the LR (likelihood-ratio) test.
First, the function solves the multi-kernel mixed model and calaculates the maximum restricted log likelihood.
Then it performs the LR test by using the fact that the deviance
</p>
<p style="text-align: center;"><code class="reqn">D = 2 \times (LL _ {alt} - LL _ {null})</code>
</p>

<p>follows the chi-square distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.LR.int(
  M.now,
  y,
  X.now,
  ZETA.now,
  interaction.kernel,
  package.MM = "gaston",
  LL0,
  eigen.SGS = NULL,
  eigen.G = NULL,
  n.core = 1,
  optimizer = "nlminb",
  map,
  kernel.method = "linear",
  kernel.h = "tuned",
  haplotype = TRUE,
  num.hap = NULL,
  test.effect = "additive",
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  weighting.center = TRUE,
  weighting.other = NULL,
  gene.set = NULL,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.LR.int_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_interaction.kernel">interaction.kernel</code></td>
<td>
<p>A <code class="reqn">n \times n</code> Gram (kernel) matrix which may indicate some interaction with SNP-sets to be tested.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_ll0">LL0</code></td>
<td>
<p>The log-likelihood for the null model.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_eigen.sgs">eigen.SGS</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eeigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">SGS</code>, where <code class="reqn">S = I - X(X'X)^{-1}X'</code>, <code class="reqn">G = ZKZ'</code>.
You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_map">map</code></td>
<td>
<p>Data frame of map information where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_kernel.method">kernel.method</code></td>
<td>
<p>It determines how to calculate kernel. There are three methods.
</p>

<dl>
<dt>&quot;gaussian&quot;</dt><dd><p>It is the default method. Gaussian kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;exponential&quot;</dt><dd><p>When this method is selected, exponential kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;linear&quot;</dt><dd><p>When this method is selected, linear kernel is calculated by NOIA methods for additive GRM.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_kernel.h">kernel.h</code></td>
<td>
<p>The hyper-parameter for gaussian or exponential kernel.
If kernel.h = &quot;tuned&quot;, this hyper parameter is calculated as the median of off-diagonals of distance matrix of genotype data.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_test.effect">test.effect</code></td>
<td>
<p>Effect of each marker to test. You can choose &quot;test.effect&quot; from &quot;additive&quot;, &quot;dominance&quot; and &quot;additive+dominance&quot;.
You also can choose more than one effect, for example, test.effect = c(&quot;additive&quot;, &quot;aditive+dominance&quot;)</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the deviance is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_weighting.center">weighting.center</code></td>
<td>
<p>In kernel-based GWAS, weights according to the Gaussian distribution (centered on the tested SNP) are taken into account when calculating the kernel if Rainbow = TRUE.
If weighting.center = FALSE, weights are not taken into account.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_weighting.other">weighting.other</code></td>
<td>
<p>You can set other weights in addition to weighting.center. The length of this argument should be equal to the number of SNPs.
For example, you can assign SNP effects from the information of gene annotation.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene, you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) for each SNP-set
</p>


<h3>References</h3>

<p>Listgarten, J. et al. (2013) A powerful and efficient set test
for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based
association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>

<hr>
<h2 id='score.calc.LR.int.MC'>Calculate -log10(p) of each SNP-set and its interaction with kernels by the LR test (multi-cores)</h2><span id='topic+score.calc.LR.int.MC'></span>

<h3>Description</h3>

<p>This function calculates -log10(p) of each SNP-set and its interaction with kernels by the LR (likelihood-ratio) test.
First, the function solves the multi-kernel mixed model and calaculates the maximum restricted log likelihood.
Then it performs the LR test by using the fact that the deviance
</p>
<p style="text-align: center;"><code class="reqn">D = 2 \times (LL _ {alt} - LL _ {null})</code>
</p>

<p>follows the chi-square distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.LR.int.MC(
  M.now,
  y,
  X.now,
  ZETA.now,
  interaction.kernel,
  package.MM = "gaston",
  LL0,
  eigen.SGS = NULL,
  eigen.G = NULL,
  n.core = 2,
  parallel.method = "mclapply",
  map,
  kernel.method = "linear",
  kernel.h = "tuned",
  haplotype = TRUE,
  num.hap = NULL,
  test.effect = "additive",
  window.size.half = 5,
  window.slide = 1,
  optimizer = "nlminb",
  chi0.mixture = 0.5,
  weighting.center = TRUE,
  weighting.other = NULL,
  gene.set = NULL,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.LR.int.MC_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_interaction.kernel">interaction.kernel</code></td>
<td>
<p>A <code class="reqn">n \times n</code> Gram (kernel) matrix which may indicate some interaction with SNP-sets to be tested.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_ll0">LL0</code></td>
<td>
<p>The log-likelihood for the null model.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_eigen.sgs">eigen.SGS</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">SGS</code>, where <code class="reqn">S = I - X(X'X)^{-1}X'</code>, <code class="reqn">G = ZKZ'</code>.
You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_map">map</code></td>
<td>
<p>Data frame of map information where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_kernel.method">kernel.method</code></td>
<td>
<p>It determines how to calculate kernel. There are three methods.
</p>

<dl>
<dt>&quot;gaussian&quot;</dt><dd><p>It is the default method. Gaussian kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;exponential&quot;</dt><dd><p>When this method is selected, exponential kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;linear&quot;</dt><dd><p>When this method is selected, linear kernel is calculated by NOIA methods for additive GRM.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_kernel.h">kernel.h</code></td>
<td>
<p>The hyper parameter for gaussian or exponential kernel.
If kernel.h = &quot;tuned&quot;, this hyper parameter is calculated as the median of off-diagonals of distance matrix of genotype data.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_test.effect">test.effect</code></td>
<td>
<p>Effect of each marker to test. You can choose &quot;test.effect&quot; from &quot;additive&quot;, &quot;dominance&quot; and &quot;additive+dominance&quot;.
You also can choose more than one effect, for example, test.effect = c(&quot;additive&quot;, &quot;aditive+dominance&quot;)</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the deviance is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_weighting.center">weighting.center</code></td>
<td>
<p>In kernel-based GWAS, weights according to the Gaussian distribution (centered on the tested SNP) are taken into account when calculating the kernel if Rainbow = TRUE.
If weighting.center = FALSE, weights are not taken into account.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_weighting.other">weighting.other</code></td>
<td>
<p>You can set other weights in addition to weighting.center. The length of this argument should be equal to the number of SNPs.
For example, you can assign SNP effects from the information of gene annotation.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene, you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.LR.int.MC_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) for each SNP-set
</p>


<h3>References</h3>

<p>Listgarten, J. et al. (2013) A powerful and efficient set test
for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based
association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>

<hr>
<h2 id='score.calc.LR.MC'>Calculate -log10(p) of each SNP-set by the LR test (multi-cores)</h2><span id='topic+score.calc.LR.MC'></span>

<h3>Description</h3>

<p>This function calculates -log10(p) of each SNP-set by the LR (likelihood-ratio) test.
First, the function solves the multi-kernel mixed model and calaculates the maximum restricted log likelihood.
Then it performs the LR test by using the fact that the deviance
</p>
<p style="text-align: center;"><code class="reqn">D = 2 \times (LL _ {alt} - LL _ {null})</code>
</p>

<p>follows the chi-square distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.LR.MC(
  M.now,
  y,
  X.now,
  ZETA.now,
  package.MM = "gaston",
  LL0,
  eigen.SGS = NULL,
  eigen.G = NULL,
  n.core = 2,
  parallel.method = "mclapply",
  map,
  kernel.method = "linear",
  kernel.h = "tuned",
  haplotype = TRUE,
  num.hap = NULL,
  test.effect = "additive",
  window.size.half = 5,
  window.slide = 1,
  optimizer = "nlminb",
  chi0.mixture = 0.5,
  weighting.center = TRUE,
  weighting.other = NULL,
  gene.set = NULL,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.LR.MC_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_ll0">LL0</code></td>
<td>
<p>The log-likelihood for the null model.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_eigen.sgs">eigen.SGS</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">SGS</code>, where <code class="reqn">S = I - X(X'X)^{-1}X'</code>, <code class="reqn">G = ZKZ'</code>.
You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_map">map</code></td>
<td>
<p>Data frame of map information where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_kernel.method">kernel.method</code></td>
<td>
<p>It determines how to calculate kernel. There are three methods.
</p>

<dl>
<dt>&quot;gaussian&quot;</dt><dd><p>It is the default method. Gaussian kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;exponential&quot;</dt><dd><p>When this method is selected, exponential kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;linear&quot;</dt><dd><p>When this method is selected, linear kernel is calculated by NOIA methods for additive GRM.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_kernel.h">kernel.h</code></td>
<td>
<p>The hyper parameter for gaussian or exponential kernel.
If kernel.h = &quot;tuned&quot;, this hyper parameter is calculated as the median of off-diagonals of distance matrix of genotype data.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_test.effect">test.effect</code></td>
<td>
<p>Effect of each marker to test. You can choose &quot;test.effect&quot; from &quot;additive&quot;, &quot;dominance&quot; and &quot;additive+dominance&quot;.
You also can choose more than one effect, for example, test.effect = c(&quot;additive&quot;, &quot;aditive+dominance&quot;)</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process. We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the deviance is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_weighting.center">weighting.center</code></td>
<td>
<p>In kernel-based GWAS, weights according to the Gaussian distribution (centered on the tested SNP) are taken into account when calculating the kernel if Rainbow = TRUE.
If weighting.center = FALSE, weights are not taken into account.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_weighting.other">weighting.other</code></td>
<td>
<p>You can set other weights in addition to weighting.center. The length of this argument should be equal to the number of SNPs.
For example, you can assign SNP effects from the information of gene annotation.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene, you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.LR.MC_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) for each SNP-set
</p>


<h3>References</h3>

<p>Listgarten, J. et al. (2013) A powerful and efficient set test
for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based
association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>

<hr>
<h2 id='score.calc.MC'>Calculate -log10(p) for single-SNP GWAS (multi-cores)</h2><span id='topic+score.calc.MC'></span>

<h3>Description</h3>

<p>Calculate -log10(p) of each SNP by the Wald test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.MC(
  M.now,
  ZETA.now,
  y,
  X.now,
  package.MM = "gaston",
  Hinv,
  n.core = 2,
  parallel.method = "mclapply",
  P3D = TRUE,
  eigen.G = NULL,
  optimizer = "nlminb",
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.MC_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.MC_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.MC_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.MC_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.MC_+3A_package.mm">package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages:
&quot;RAINBOWR&quot;, &quot;MM4LMM&quot; and &quot;gaston&quot;. Default package is 'gaston'.
See more details at <code><a href="#topic+EM3.general">EM3.general</a></code>.</p>
</td></tr>
<tr><td><code id="score.calc.MC_+3A_hinv">Hinv</code></td>
<td>
<p>The inverse of <code class="reqn">H = ZKZ' + \lambda I</code> where <code class="reqn">\lambda = \sigma^2_e / \sigma^2_u</code>.</p>
</td></tr>
<tr><td><code id="score.calc.MC_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.MC_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.MC_+3A_p3d">P3D</code></td>
<td>
<p>When P3D = TRUE, variance components are estimated by REML only once, without any markers in the model.
When P3D = FALSE, variance components are estimated by REML for each marker separately.</p>
</td></tr>
<tr><td><code id="score.calc.MC_+3A_eigen.g">eigen.G</code></td>
<td>
<p>A list with
</p>

<dl>
<dt>$values</dt><dd><p>Eigen values</p>
</dd>
<dt>$vectors</dt><dd><p>Eigen vectors</p>
</dd>
</dl>

<p>The result of the eigen decompsition of <code class="reqn">G = ZKZ'</code>. You can use &quot;spectralG.cpp&quot; function in RAINBOWR.
If this argument is NULL, the eigen decomposition will be performed in this function.
We recommend you assign the result of the eigen decomposition beforehand for time saving.</p>
</td></tr>
<tr><td><code id="score.calc.MC_+3A_optimizer">optimizer</code></td>
<td>
<p>The function used in the optimization process.
We offer &quot;optim&quot;, &quot;optimx&quot;, and &quot;nlminb&quot; functions.
This argument is only valid when &lsquo;package.MM = &rsquo;RAINBOWR''.</p>
</td></tr>
<tr><td><code id="score.calc.MC_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.MC_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) for each marker
</p>


<h3>References</h3>

<p>Kennedy, B.W., Quinton, M. and van Arendonk, J.A. (1992)
Estimation of effects of single genes on quantitative traits. J Anim Sci. 70(7): 2000-2012.
</p>
<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure
in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Kang, H.M. et al. (2010) Variance component model to account for sample
structure in genome-wide association studies. Nat Genet. 42(4): 348-354.
</p>
<p>Zhang, Z. et al. (2010) Mixed linear model approach adapted for genome-wide
association studies. Nat Genet. 42(4): 355-360.
</p>

<hr>
<h2 id='score.calc.score'>Calculate -log10(p) of each SNP-set by the score test</h2><span id='topic+score.calc.score'></span>

<h3>Description</h3>

<p>This function calculates -log10(p) of each SNP-set by the score test.
First, the function calculates the score statistic
without solving the multi-kernel mixed model for each SNP-set.
Then it performs the score test by using the fact that the score statistic follows the chi-square distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.score(
  M.now,
  y,
  X.now,
  ZETA.now,
  LL0,
  Gu,
  Ge,
  P0,
  map,
  kernel.method = "linear",
  kernel.h = "tuned",
  haplotype = TRUE,
  num.hap = NULL,
  test.effect = "additive",
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  weighting.center = TRUE,
  weighting.other = NULL,
  gene.set = NULL,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.score_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_ll0">LL0</code></td>
<td>
<p>The log-likelihood for the null model.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_gu">Gu</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign <code class="reqn">ZKZ'</code>, where K is covariance (relationship) matrix and Z is its design matrix.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_ge">Ge</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign identity matrix I (diag(n)).</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_p0">P0</code></td>
<td>
<p><code class="reqn">n \times n</code> matrix. The Moore-Penrose generalized inverse of <code class="reqn">SV0S</code>, where <code class="reqn">S = X(X'X)^{-1}X'</code> and
<code class="reqn">V0 = \sigma^2_u Gu + \sigma^2_e Ge</code>. <code class="reqn">\sigma^2_u</code> and <code class="reqn">\sigma^2_e</code> are estimators of the null model.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_map">map</code></td>
<td>
<p>Data frame of map information where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_kernel.method">kernel.method</code></td>
<td>
<p>It determines how to calculate kernel. There are three methods.
</p>

<dl>
<dt>&quot;gaussian&quot;</dt><dd><p>It is the default method. Gaussian kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;exponential&quot;</dt><dd><p>When this method is selected, exponential kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;linear&quot;</dt><dd><p>When this method is selected, linear kernel is calculated by NOIA methods for additive GRM.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="score.calc.score_+3A_kernel.h">kernel.h</code></td>
<td>
<p>The hyper parameter for gaussian or exponential kernel.
If kernel.h = &quot;tuned&quot;, this hyper parameter is calculated as the median of off-diagonals of distance matrix of genotype data.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_test.effect">test.effect</code></td>
<td>
<p>Effect of each marker to test. You can choose &quot;test.effect&quot; from &quot;additive&quot;, &quot;dominance&quot; and &quot;additive+dominance&quot;.
You also can choose more than one effect, for example, test.effect = c(&quot;additive&quot;, &quot;aditive+dominance&quot;)</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the test statistic <code class="reqn">l1' F l1</code> is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where l1 is the first derivative of the log-likelihood and F is the Fisher information. And r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_weighting.center">weighting.center</code></td>
<td>
<p>In kernel-based GWAS, weights according to the Gaussian distribution (centered on the tested SNP) are taken into account when calculating the kernel if Rainbow = TRUE.
If weighting.center = FALSE, weights are not taken into account.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_weighting.other">weighting.other</code></td>
<td>
<p>You can set other weights in addition to weighting.center. The length of this argument should be equal to the number of SNPs.
For example, you can assign SNP effects from the information of gene annotation.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene, you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.score_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) for each SNP-set
</p>


<h3>References</h3>

<p>Listgarten, J. et al. (2013) A powerful and efficient set test
for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based
association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>

<hr>
<h2 id='score.calc.score.MC'>Calculate -log10(p) of each SNP-set by the score test (multi-cores)</h2><span id='topic+score.calc.score.MC'></span>

<h3>Description</h3>

<p>This function calculates -log10(p) of each SNP-set by the score test.
First, the function calculates the score statistic
without solving the multi-kernel mixed model for each SNP-set.
Then it performs the score test by using the fact that the score statistic follows the chi-square distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.calc.score.MC(
  M.now,
  y,
  X.now,
  ZETA.now,
  LL0,
  Gu,
  Ge,
  P0,
  n.core = 2,
  parallel.method = "mclapply",
  map,
  kernel.method = "linear",
  kernel.h = "tuned",
  haplotype = TRUE,
  num.hap = NULL,
  test.effect = "additive",
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  weighting.center = TRUE,
  weighting.other = NULL,
  gene.set = NULL,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.calc.score.MC_+3A_m.now">M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_x.now">X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_zeta.now">ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_ll0">LL0</code></td>
<td>
<p>The log-likelihood for the null model.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_gu">Gu</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign <code class="reqn">ZKZ'</code>, where K is covariance (relationship) matrix and Z is its design matrix.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_ge">Ge</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign identity matrix I (diag(n)).</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_p0">P0</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. The Moore-Penrose generalized inverse of <code class="reqn">SV0S</code>, where <code class="reqn">S = X(X'X)^{-1}X'</code> and
<code class="reqn">V0 = \sigma^2_u Gu + \sigma^2_e Ge</code>. <code class="reqn">\sigma^2_u</code> and <code class="reqn">\sigma^2_e</code> are estimators of the null model.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_n.core">n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = &quot;furrr&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_parallel.method">parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, &quot;mclapply&quot;, &quot;furrr&quot;, and &quot;foreach&quot;.
</p>
<p>When 'parallel.method = &quot;mclapply&quot;', we utilize <code><a href="pbmcapply.html#topic+pbmclapply">pbmclapply</a></code> function in the 'pbmcapply' package
with 'count = TRUE' and <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = &quot;furrr&quot;', we utilize <code><a href="furrr.html#topic+future_map">future_map</a></code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code><a href="progressr.html#topic+progressor">progressor</a></code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = &quot;furrr&quot;', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = &quot;mclapply&quot;'.
</p>
<p>When 'parallel.method = &quot;foreach&quot;', we utilize <code><a href="foreach.html#topic+foreach">foreach</a></code> function in the 'foreach' package
with the utilization of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> function in 'parallel' package,
and <code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code><a href="utils.html#topic+setTxtProgressBar">setTxtProgressBar</a></code> and
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = &quot;mclapply&quot;', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = &quot;foreach&quot;'.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_map">map</code></td>
<td>
<p>Data frame of map information where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_kernel.method">kernel.method</code></td>
<td>
<p>It determines how to calculate kernel. There are three methods.
</p>

<dl>
<dt>&quot;gaussian&quot;</dt><dd><p>It is the default method. Gaussian kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;exponential&quot;</dt><dd><p>When this method is selected, exponential kernel is calculated by distance matrix.</p>
</dd>
<dt>&quot;linear&quot;</dt><dd><p>When this method is selected, linear kernel is calculated by NOIA methods for additive GRM.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_kernel.h">kernel.h</code></td>
<td>
<p>The hyper parameter for gaussian or exponential kernel.
If kernel.h = &quot;tuned&quot;, this hyper parameter is calculated as the median of off-diagonals of distance matrix of genotype data.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_haplotype">haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_num.hap">num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_test.effect">test.effect</code></td>
<td>
<p>Effect of each marker to test. You can choose &quot;test.effect&quot; from &quot;additive&quot;, &quot;dominance&quot; and &quot;additive+dominance&quot;.
You also can choose more than one effect, for example, test.effect = c(&quot;additive&quot;, &quot;aditive+dominance&quot;)</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_window.size.half">window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_window.slide">window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the test statistic <code class="reqn">l1' F l1</code> is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where l1 is the first derivative of the log-likelihood and F is the Fisher information. And r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_weighting.center">weighting.center</code></td>
<td>
<p>In kernel-based GWAS, weights according to the Gaussian distribution (centered on the tested SNP) are taken into account when calculating the kernel if Rainbow = TRUE.
If weighting.center = FALSE, weights are not taken into account.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_weighting.other">weighting.other</code></td>
<td>
<p>You can set other weights in addition to weighting.center. The length of this argument should be equal to the number of SNPs.
For example, you can assign SNP effects from the information of gene annotation.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene, you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;geno&quot; argument.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="score.calc.score.MC_+3A_count">count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) for each SNP-set
</p>


<h3>References</h3>

<p>Listgarten, J. et al. (2013) A powerful and efficient set test
for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based
association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>

<hr>
<h2 id='score.cpp'>Calculte -log10(p) by score test (slow, for general cases)</h2><span id='topic+score.cpp'></span>

<h3>Description</h3>

<p>Calculte -log10(p) by score test (slow, for general cases)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.cpp(y, Gs, Gu, Ge, P0, chi0.mixture = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.cpp_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.cpp_+3A_gs">Gs</code></td>
<td>
<p>A list of kernel matrices you want to test. For example, Gs = list(A.part = K.A.part, D.part = K.D.part)</p>
</td></tr>
<tr><td><code id="score.cpp_+3A_gu">Gu</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign <code class="reqn">ZKZ'</code>, where K is covariance (relationship) matrix and Z is its design matrix.</p>
</td></tr>
<tr><td><code id="score.cpp_+3A_ge">Ge</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign identity matrix I (diag(n)).</p>
</td></tr>
<tr><td><code id="score.cpp_+3A_p0">P0</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. The Moore-Penrose generalized inverse of <code class="reqn">SV0S</code>, where <code class="reqn">S = X(X'X)^{-1}X'</code> and
<code class="reqn">V0 = \sigma^2_u Gu + \sigma^2_e Ge</code>. <code class="reqn">\sigma^2_u</code> and <code class="reqn">\sigma^2_e</code> are estimators of the null model.</p>
</td></tr>
<tr><td><code id="score.cpp_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOW assumes the test statistic <code class="reqn">l1' F l1</code> is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where l1 is the first derivative of the log-likelihood and F is the Fisher information. And r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) calculated by score test
</p>

<hr>
<h2 id='score.linker.cpp'>Calculte -log10(p) by score test (fast, for limited cases)</h2><span id='topic+score.linker.cpp'></span>

<h3>Description</h3>

<p>Calculte -log10(p) by score test (fast, for limited cases)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.linker.cpp(
  y,
  Ws,
  Gammas,
  gammas.diag = TRUE,
  Gu,
  Ge,
  P0,
  chi0.mixture = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.linker.cpp_+3A_y">y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td></tr>
<tr><td><code id="score.linker.cpp_+3A_ws">Ws</code></td>
<td>
<p>A list of low rank matrices (ZW; <code class="reqn">n \times k</code> matrix). This forms linear kernel <code class="reqn">ZKZ' = ZW \Gamma (ZW)'</code>.
For example, Ws = list(A.part = ZW.A, D.part = ZW.D)</p>
</td></tr>
<tr><td><code id="score.linker.cpp_+3A_gammas">Gammas</code></td>
<td>
<p>A list of matrices for weighting SNPs (Gamma; <code class="reqn">k \times k</code> matrix). This forms linear kernel <code class="reqn">ZKZ' = ZW \Gamma (ZW)'</code>.
For example, if there is no weighting, Gammas = lapply(Ws, function(x) diag(ncol(x)))</p>
</td></tr>
<tr><td><code id="score.linker.cpp_+3A_gammas.diag">gammas.diag</code></td>
<td>
<p>If each Gamma is the diagonal matrix, please set this argument TRUE. The calculation time can be saved.</p>
</td></tr>
<tr><td><code id="score.linker.cpp_+3A_gu">Gu</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign <code class="reqn">ZKZ'</code>, where K is covariance (relationship) matrix and Z is its design matrix.</p>
</td></tr>
<tr><td><code id="score.linker.cpp_+3A_ge">Ge</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign identity matrix I (diag(n)).</p>
</td></tr>
<tr><td><code id="score.linker.cpp_+3A_p0">P0</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. The Moore-Penrose generalized inverse of <code class="reqn">SV0S</code>, where <code class="reqn">S = X(X'X)^{-1}X'</code> and
<code class="reqn">V0 = \sigma^2_u Gu + \sigma^2_e Ge</code>. <code class="reqn">\sigma^2_u</code> and <code class="reqn">\sigma^2_e</code> are estimators of the null model.</p>
</td></tr>
<tr><td><code id="score.linker.cpp_+3A_chi0.mixture">chi0.mixture</code></td>
<td>
<p>RAINBOW assumes the statistic <code class="reqn">l1' F l1</code> follows the mixture of <code class="reqn">\chi^2_0</code> and <code class="reqn">\chi^2_r</code>,
where l1 is the first derivative of the log-likelihood and F is the Fisher information. And r is the degree of freedom.
chi0.mixture determins the proportion of <code class="reqn">\chi^2_0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>-log10(p) calculated by score test
</p>

<hr>
<h2 id='See'>Function to view the first part of data (like head(), tail())</h2><span id='topic+See'></span>

<h3>Description</h3>

<p>Function to view the first part of data (like head(), tail())
</p>


<h3>Usage</h3>

<pre><code class='language-R'>See(
  data,
  fh = TRUE,
  fl = TRUE,
  rown = 6,
  coln = 6,
  rowst = 1,
  colst = 1,
  narray = 2,
  drop = FALSE,
  save.variable = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="See_+3A_data">data</code></td>
<td>
<p>Your data. 'vector', 'matrix', 'array' (whose dimensions &lt;= 4), 'data.frame' are supported format.
If other formatted data is assigned, str(data) will be returned.</p>
</td></tr>
<tr><td><code id="See_+3A_fh">fh</code></td>
<td>
<p>From head. If this argument is TRUE, first part (row) of data will be shown (like head() function).
If FALSE, last part (row) of your data will be shown (like tail() function).</p>
</td></tr>
<tr><td><code id="See_+3A_fl">fl</code></td>
<td>
<p>From left. If this argument is TRUE, first part (column) of data will be shown (like head() function).
If FALSE, last part (column) of your data will be shown (like tail() function).</p>
</td></tr>
<tr><td><code id="See_+3A_rown">rown</code></td>
<td>
<p>The number of rows shown in console.</p>
</td></tr>
<tr><td><code id="See_+3A_coln">coln</code></td>
<td>
<p>The number of columns shown in console.</p>
</td></tr>
<tr><td><code id="See_+3A_rowst">rowst</code></td>
<td>
<p>The start point for the direction of row.</p>
</td></tr>
<tr><td><code id="See_+3A_colst">colst</code></td>
<td>
<p>The start point for the direction of column.</p>
</td></tr>
<tr><td><code id="See_+3A_narray">narray</code></td>
<td>
<p>The number of dimensions other than row and column shown in console.
This argument is effective only your data is array (whose dimensions &gt;= 3).</p>
</td></tr>
<tr><td><code id="See_+3A_drop">drop</code></td>
<td>
<p>When rown = 1 or coln = 1, the dimension will be reduced if this argument is TRUE.</p>
</td></tr>
<tr><td><code id="See_+3A_save.variable">save.variable</code></td>
<td>
<p>If you want to assign the result to a variable, please set this agument TRUE.</p>
</td></tr>
<tr><td><code id="See_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print the first part of data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If save.variable is FALSE, NULL. If TRUE, the first part of your data will be returned.
</p>

<hr>
<h2 id='spectralG.cpp'>Perform spectral decomposition (inplemented by Rcpp)</h2><span id='topic+spectralG.cpp'></span>

<h3>Description</h3>

<p>Perform spectral decomposition for <code class="reqn">G = ZKZ'</code> or <code class="reqn">SGS</code> where <code class="reqn">S = I - X(X'X)^{-1}X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectralG.cpp(
  ZETA,
  ZWs = NULL,
  X = NULL,
  weights = 1,
  return.G = TRUE,
  return.SGS = FALSE,
  spectral.method = NULL,
  tol = NULL,
  df.H = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectralG.cpp_+3A_zeta">ZETA</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list &quot;Z&quot; and &quot;K&quot;!</p>
</td></tr>
<tr><td><code id="spectralG.cpp_+3A_zws">ZWs</code></td>
<td>
<p>A list of additional linear kernels other than genomic relationship matrix (GRM).
We utilize this argument in RGWAS.multisnp function, so you can ignore this.</p>
</td></tr>
<tr><td><code id="spectralG.cpp_+3A_x">X</code></td>
<td>
<p><code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td></tr>
<tr><td><code id="spectralG.cpp_+3A_weights">weights</code></td>
<td>
<p>If the length of ZETA &gt;= 2, you should assign the ratio of variance components to this argument.</p>
</td></tr>
<tr><td><code id="spectralG.cpp_+3A_return.g">return.G</code></td>
<td>
<p>If thie argument is TRUE, spectral decomposition results of G will be returned.
(<code class="reqn">G = ZKZ'</code>)</p>
</td></tr>
<tr><td><code id="spectralG.cpp_+3A_return.sgs">return.SGS</code></td>
<td>
<p>If this argument is TRUE, spectral decomposition results of SGS will be returned.
(<code class="reqn">S = I - X(X'X)^{-1}X</code>, <code class="reqn">G = ZKZ'</code>)</p>
</td></tr>
<tr><td><code id="spectralG.cpp_+3A_spectral.method">spectral.method</code></td>
<td>
<p>The method of spectral decomposition.
In this function, &quot;eigen&quot; : eigen decomposition and &quot;cholesky&quot; : cholesky and singular value decomposition are offered.
If this argument is NULL, either method will be chosen accorsing to the dimension of Z and X.</p>
</td></tr>
<tr><td><code id="spectralG.cpp_+3A_tol">tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of G = ZKZ'.
Eigen vectors whose eigen values are less than &quot;tol&quot; argument will be omitted from results.
If tol is NULL, top 'n' eigen values will be effective.</p>
</td></tr>
<tr><td><code id="spectralG.cpp_+3A_df.h">df.H</code></td>
<td>
<p>The degree of freedom of K matrix. If this argument is NULL, min(n, sum(nrow(K1), nrow(K2), ...)) will be assigned.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$spectral.G</dt><dd><p>The spectral decomposition results of G.</p>
</dd>
<dt>$U</dt><dd><p>Eigen vectors of G.</p>
</dd>
<dt>$delta</dt><dd><p>Eigen values of G.</p>
</dd>
<dt>$spectral.SGS</dt><dd><p>Estimator for <code class="reqn">\sigma^2_e</code></p>
</dd>
<dt>$Q</dt><dd><p>Eigen vectors of SGS.</p>
</dd>
<dt>$theta</dt><dd><p>Eigen values of SGS.</p>
</dd>
</dl>


<hr>
<h2 id='SS_gwas'>Calculate some summary statistics of GWAS (genome-wide association studies) for simulation study</h2><span id='topic+SS_gwas'></span>

<h3>Description</h3>

<p>Calculate some summary statistics of GWAS (genome-wide association studies) for simulation study
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SS_gwas(
  res,
  x,
  map.x,
  qtn.candidate,
  gene.set = NULL,
  n.top.false.block = 10,
  sig.level = c(0.05, 0.01),
  method.thres = "BH",
  inflator.plus = 2,
  LD_length = 150000,
  cor.thres = 0.35,
  window.size = 0,
  saveName = NULL,
  plot.ROC = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS_gwas_+3A_res">res</code></td>
<td>
<p>Data frame of GWAS results where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_x">x</code></td>
<td>
<p>A N (lines) x M (markers) marker genotype data (matrix), coded as [-1, 0, 1] = [aa, Aa, AA].</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_map.x">map.x</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_qtn.candidate">qtn.candidate</code></td>
<td>
<p>A vector of causal markers. You should assign where those causal markers are positioned in our marker genotype,
rather than physical position of those causal markers.</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_gene.set">gene.set</code></td>
<td>
<p>If you have information of gene (or haplotype block), and if you used it to perform kernel-based GWAS,
you should assign your gene information to gene.set in the form of a &quot;data.frame&quot; (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of &quot;x&quot; argument.</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_n.top.false.block">n.top.false.block</code></td>
<td>
<p>We will calculate the mean of -log10(p) values of top 'n.top.false.block' blocks
to evaluate the inflation level of results. The default is 10.</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level for the threshold. The default is 0.05.</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_method.thres">method.thres</code></td>
<td>
<p>Method for detemining threshold of significance. &quot;BH&quot; and &quot;Bonferroni are offered.</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_inflator.plus">inflator.plus</code></td>
<td>
<p>If 'the -log10(p) value for each marker' exceeds ('the inflation level' + 'inflator.plus'),
that marker is regarded as significant.</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_ld_length">LD_length</code></td>
<td>
<p>SNPs within the extent of LD are regareded as one set. This LD_length determines the size of LD block,
and 2 x LD_length (b.p.) will be the size of LD block.</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_cor.thres">cor.thres</code></td>
<td>
<p>SNPs within the extent of LD are regareded as one set. This cor.thres also determines the size of LD block,
and the region with square of correlation coefficients &gt;= cor.thres is regareded as one LD block. More precisely, the regions
which satisfies both LD_length and cor.thres condition is rearded as one LD block.</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_window.size">window.size</code></td>
<td>
<p>If you peform SNP-set analysis with slinding window, we can consider the effect of window size by this argument.</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_savename">saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td></tr>
<tr><td><code id="SS_gwas_+3A_plot.roc">plot.ROC</code></td>
<td>
<p>If this argunent is TRUE, ROC (Reciever Operating Characteristic) curve will be drawn with AUC (Area Under the Curve).</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$log.p</dt><dd><p>-log10(p)) values of the causals.</p>
</dd>
<dt>$qtn.logp.order</dt><dd><p>The rank of -log10(p) of causals.</p>
</dd>
<dt>$thres</dt><dd><p>A vector which contains the information of threshold.</p>
</dd>
<dt>$overthres</dt><dd><p>The number of markers which exceed the threshold.</p>
</dd>
<dt>$AUC</dt><dd><p>Area under the curve.</p>
</dd>
<dt>$AUC.relax</dt><dd><p>Area under the curve calculated with LD block units.</p>
</dd>
<dt>$FDR</dt><dd><p>False discovery rate. 1 - Precision.</p>
</dd>
<dt>$FPR</dt><dd><p>False positive rate.</p>
</dd>
<dt>$FNR</dt><dd><p>False negative rate. 1 - Recall.</p>
</dd>
<dt>$Recall</dt><dd><p>The proportion of the number of causals dected by GWAS to the number of causals you set.</p>
</dd>
<dt>$Precision</dt><dd><p>The proportion of the number of causals dected by GWAS to the number of markers detected by GWAS.</p>
</dd>
<dt>$Accuracy</dt><dd><p>The accuracy of GWAS results.</p>
</dd>
<dt>$Hm</dt><dd><p>Harmonic mean of Recall and Precision.</p>
</dd>
<dt>$haplo.name</dt><dd><p>The haplotype block name which correspond to causals.</p>
</dd>
<dt>$mean.false</dt><dd><p>The mean of -log10(p) values of top 'n.top.false.block' blocks.</p>
</dd>
<dt>$max.trues</dt><dd><p>Maximum of the -log10(p) values of the region near causals.</p>
</dd>
</dl>


<hr>
<h2 id='welcome_to_RGWAS'>Function to greet to users</h2><span id='topic+welcome_to_RGWAS'></span>

<h3>Description</h3>

<p>Function to greet to users
</p>


<h3>Usage</h3>

<pre><code class='language-R'>welcome_to_RGWAS()
</code></pre>


<h3>Value</h3>

<p>Show welcome messages
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
