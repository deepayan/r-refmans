<!DOCTYPE html><html lang="en"><head><title>Help for package ouch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ouch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ouch-package'><p>Ornstein-Uhlenbeck methods for comparative phylogenetic hypotheses</p></a></li>
<li><a href='#anolis.ssd'><p>Greater Antillean anolis lizard sexual size dimorphism data</p></a></li>
<li><a href='#as_data_frame'><p>Coerce an <span class="pkg">ouch</span> object to a data frame</p></a></li>
<li><a href='#bimac'><p>Anolis bimaculatus lizard size data</p></a></li>
<li><a href='#bootstrap'><p>Bootstrapping for uncertainty quantification</p></a></li>
<li><a href='#brown'><p>Phylogenetic Brownian motion models</p></a></li>
<li><a href='#coef'><p>Model coefficients</p></a></li>
<li><a href='#geospiza'><p>Data on Darwin's finches</p></a></li>
<li><a href='#glssoln'><p>Generalized least-squares solver</p></a></li>
<li><a href='#hansen'><p>Ornstein-Uhlenbeck models of trait evolution</p></a></li>
<li><a href='#logLik'><p>Log likelihood of a fitted model</p></a></li>
<li><a href='#ouchtree'><p>Phylogenetic tree object in <span class="pkg">ouch</span> format</p></a></li>
<li><a href='#paint'><p>Painting regimes on a phylogenetic tree</p></a></li>
<li><a href='#plot'><p><span class="pkg">ouch</span> plotting functions</p></a></li>
<li><a href='#print'><p>Print and show methods</p></a></li>
<li><a href='#simulate'><p>Simulations of a phylogenetic trait model</p></a></li>
<li><a href='#summary'><p>Summary methods</p></a></li>
<li><a href='#update'><p>Update and refit an <span class="pkg">ouch</span> model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ornstein-Uhlenbeck Models for Phylogenetic Comparative
Hypotheses</td>
</tr>
<tr>
<td>Version:</td>
<td>2.20</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-04</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aaron A. King &lt;kingaa@umich.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit and compare Ornstein-Uhlenbeck models for evolution along a phylogenetic tree.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, graphics, grDevices, utils, subplex</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kingaa.github.io/ouch/">https://kingaa.github.io/ouch/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kingaa/ouch/issues/">https://github.com/kingaa/ouch/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'anolis.R' 'print.R' 'package.R' 'ouchtree.R' 'ape2ouch.R'
'bootstrap.R' 'update.R' 'simulate.R' 'plot.R' 'summary.R'
'logLik.R' 'coef.R' 'rmvnorm.R' 'glssoln.R' 'hansen.R'
'brown.R' 'as_data_frame.R' 'bimac.R' 'geospiza.R' 'paint.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-04 14:47:21 UTC; kingaa</td>
</tr>
<tr>
<td>Author:</td>
<td>Aaron A. King <a href="https://orcid.org/0000-0001-6159-3207"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Marguerite A. Butler [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-04 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ouch-package'>Ornstein-Uhlenbeck methods for comparative phylogenetic hypotheses</h2><span id='topic+ouch'></span><span id='topic+ouch-package'></span><span id='topic+ouch+2Cpackage'></span>

<h3>Description</h3>

<p>The <span class="pkg">ouch</span> package provides facilities for phylogenetic comparative analysis based on Ornstein-Uhlenbeck models of trait evolution along a phylogeny.
Multivariate data and complex adaptive hypotheses are supported.
</p>


<h3>Classes</h3>

<p>The basic class, <code>ouchtree</code>, is provided to encode a phylogenetic tree.
Plot and print methods are provided.
</p>
<p>The class <code>browntree</code> derives from class <code>ouchtree</code> and encodes the results of fitting a Brownian Motion model to data.
</p>
<p>The class <code>hansentree</code> derives from class <code>ouchtree</code> and encodes the results of fitting a Hansen model to data.
</p>


<h3>Detailed Documentation</h3>


<ul>
<li><p> Phylogenies in <span class="pkg">ouch</span> format: <code><a href="#topic+ouchtree">ouchtree()</a></code>, <code><a href="#topic+ape2ouch">ape2ouch()</a></code>
</p>
</li>
<li><p> Brownian motion models: <code><a href="#topic+brown">brown()</a></code>
</p>
</li>
<li><p> Ornstein-Uhlenbeck models: <code><a href="#topic+hansen">hansen()</a></code>, <code><a href="#topic+paint">paint()</a></code>
</p>
</li>
<li><p> Simulation of models: <code><a href="#topic+simulate">simulate()</a></code>
</p>
</li>
<li><p> Display of data: <code><a href="#topic+plot">plot()</a></code>
</p>
</li>
<li><p> Extraction of information from fitted models: <code><a href="#topic+summary">summary()</a></code>, <code><a href="#topic+logLik">logLik()</a></code>, <code><a href="#topic+coef">coef()</a></code>
</p>
</li>
<li><p> Example datasets: <code><a href="#topic+anolis.ssd">anolis.ssd</a></code>, <code><a href="#topic+bimac">bimac</a></code>
</p>
</li></ul>



<h3>Citing <span class="pkg">ouch</span></h3>

<p>Execute <code>citation("ouch")</code> to view the correct citation for publications.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>References</h3>

<p>T.F. Hansen. 1997. Stabilizing selection and the comparative analysis of adaptation. Evolution, 51:1341&ndash;1351. <a href="https://doi.org/10.1111/j.1558-5646.1997.tb01457.x">doi:10.1111/j.1558-5646.1997.tb01457.x</a>.
</p>
<p>Butler, M.A. and A.A. King. 2004.  Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  American Naturalist 164:683&ndash;695. <a href="https://doi.org/10.1086/426002">doi:10.1086/426002</a>.
</p>
<p>Cressler, C. E., Butler, M. A., and King, A. A. 2015. Detecting adaptive evolution in phylogenetic comparative analysis using the Ornstein-Uhlenbeck model. Systematic Biology, 64:953&ndash;968. <a href="https://doi.org/10.1093/sysbio/syv043">doi:10.1093/sysbio/syv043</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://kingaa.github.io/ouch/">https://kingaa.github.io/ouch/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/kingaa/ouch/issues/">https://github.com/kingaa/ouch/issues/</a>
</p>
</li></ul>

<p>Other phylogenetic comparative models: 
<code><a href="#topic+brown">brown</a>()</code>,
<code><a href="#topic+hansen">hansen</a>()</code>,
<code><a href="#topic+ouchtree">ouchtree</a></code>,
<code><a href="#topic+paint">paint</a>()</code>
</p>
<p>Other methods for ouch trees: 
<code><a href="#topic+as_data_frame">as_data_frame</a></code>,
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+paint">paint</a>()</code>,
<code><a href="#topic+plot">plot</a>()</code>,
<code><a href="#topic+print">print</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+update">update</a>()</code>
</p>
<p>Other examples: 
<code><a href="#topic+anolis.ssd">anolis.ssd</a></code>,
<code><a href="#topic+bimac">bimac</a></code>,
<code><a href="#topic+geospiza">geospiza</a></code>
</p>

<hr>
<h2 id='anolis.ssd'>Greater Antillean anolis lizard sexual size dimorphism data</h2><span id='topic+anolis.ssd'></span>

<h3>Description</h3>

<p>The dataset consists of sexual size-dimorphism data for 38 species of anoles from Cuba, Hispaniola, Jamaica, and Puerto Rico (Butler, Schoener, and Losos 2000).
Each of these species belongs to one of six microhabitat types, or &quot;ecomorphs&quot; (sensu Williams, 1972):
trunk-ground, grass-bush, trunk, trunk-crown, twig, and crown-giant.
The data were used to demonstrate an evolutionary association between habitat type and degree of sexual size dimorphism.
</p>


<h3>Format</h3>

<p>A data frame with 38 observations on the following 6 variables.
</p>

<ul>
<li> <p><code>node</code>: Labels for the nodes.
</p>
</li>
<li> <p><code>species</code>: Names of extant species.
</p>
</li>
<li> <p><code>log.SSD</code>: Log sexual size dimorphism of extant species.
</p>
</li>
<li> <p><code>ancestor</code>: Name of ancestor node.
</p>
</li>
<li> <p><code>time</code>: Time of node.
</p>
</li>
<li> <p><code>OU.1</code>: a factor with one level, <code>ns</code>.
</p>
</li>
<li> <p><code>OU.7</code>: a factor with levels corresponding to ecomorph (<code>tg</code>, <code>tc</code>, <code>gb</code>, <code>cg</code>, <code>tw</code>, <code>tr</code>, <code>anc</code>).
</p>
</li></ul>



<h3>Details</h3>

<p>Size dimorphism was calcuated as the log-ratio of male snout-to-vent length to female snout-to-vent length (males are larger).
</p>
<p>In this example, we tested three models of evolution:
Brownian motion, Ornstein-Uhlenbeck with one global optimum, and Ornstein-Uhlenbeck with seven optima (one for each ecomorph type plus an additional one for an &quot;unknown&quot; type).
</p>
<p>For the seven-optima model, we assigned each terminal branch to an optimum according to the ecomorph type of the extant species.
Because we had no information to help guide hypotheses about internal branches, we assigned
internal branches to the &quot;unknown&quot; selective regime.
The phylogeny of these species is consistent with and adaptive radiation, with a burst of speciation events early in the evolutionary history of this clade (see phylogeny in Butler &amp; King (2004) or example below).
</p>


<h3>Author(s)</h3>

<p>Marguerite A. Butler, Aaron A. King
</p>


<h3>Source</h3>

<p>Butler, M.A. and A.A. King. 2004.  Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  American Naturalist 164:683&ndash;695. <a href="https://doi.org/10.1086/426002">doi:10.1086/426002</a>.
</p>


<h3>References</h3>

<p>Butler, M. A., T. W. Schoener, and J. B. Losos. 2000.  The relationship between sexual size dimorphism and habitat use in Greater Antillean Anolis lizards.  Evolution, 54:259&ndash;272. <a href="https://doi.org/10.1111/j.0014-3820.2000.tb00026.x">doi:10.1111/j.0014-3820.2000.tb00026.x</a>.
</p>
<p>Williams, E. E. 1972.  The origin of faunas. Evolution of lizard congeners in a complex island fauna: a trial analysis.  Evolutionary Biology, 6:47&ndash;89. <a href="https://doi.org/10.1007/978-1-4684-9063-3_3">doi:10.1007/978-1-4684-9063-3_3</a>.
</p>


<h3>See Also</h3>

<p>Other examples: 
<code><a href="#topic+bimac">bimac</a></code>,
<code><a href="#topic+geospiza">geospiza</a></code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Analysis of sexual size dimorphism data
 ## Save time for CRAN
tree &lt;- with(anolis.ssd,ouchtree(node,ancestor,time/max(time),species))
plot(tree,node.names=TRUE)

h1 &lt;- brown(anolis.ssd['log.SSD'],tree)
h1
plot(h1)

h2 &lt;- hansen(anolis.ssd['log.SSD'],tree,anolis.ssd['OU.1'],sqrt.alpha=1,sigma=1)
h2
plot(h2)

h3 &lt;- hansen(anolis.ssd['log.SSD'],tree,anolis.ssd['OU.7'],sqrt.alpha=1,sigma=1)
h3
plot(h3)

</code></pre>

<hr>
<h2 id='as_data_frame'>Coerce an <span class="pkg">ouch</span> object to a data frame</h2><span id='topic+as_data_frame'></span><span id='topic+as.data.frame.ouchtree'></span><span id='topic+as.data.frame.browntree'></span><span id='topic+as.data.frame.hansentree'></span>

<h3>Description</h3>

<p>Coerce an <span class="pkg">ouch</span> object to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ouchtree'
as.data.frame(x, ...)

## S3 method for class 'browntree'
as.data.frame(x, ...)

## S3 method for class 'hansentree'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_data_frame_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="as_data_frame_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other methods for ouch trees: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+paint">paint</a>()</code>,
<code><a href="#topic+plot">plot</a>()</code>,
<code><a href="#topic+print">print</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+update">update</a>()</code>
</p>

<hr>
<h2 id='bimac'>Anolis bimaculatus lizard size data</h2><span id='topic+bimac'></span>

<h3>Description</h3>

<p>This is the <em>Anolis bimaculatus</em> dataset used in Butler &amp; King (2004).
It is used to test a hypothesis of character displacement using an interspecific dataset of body sizes and current data on sympatry/allopatry.
</p>


<h3>Format</h3>

<p>A data frame with 45 observations on the following 11 variables.
</p>

<ul>
<li> <p><code>node</code>: Labels for the nodes.
</p>
</li>
<li> <p><code>spcode</code>: Two-letter code for each taxon.
</p>
</li>
<li> <p><code>species</code>: Species names for extant species.
</p>
</li>
<li> <p><code>island</code>: Name of the island on which the population is found.
</p>
</li>
<li> <p><code>size</code>: Body size (head length in mm) of extant species.
</p>
</li>
<li> <p><code>ancestor</code>: Ancestral node.
</p>
</li>
<li> <p><code>time</code>: Time of node.
</p>
</li>
<li> <p><code>OU.1</code>: a factor with levels <code>ns</code>
</p>
</li>
<li> <p><code>OU.3</code>: a factor with levels <code>small</code>, <code>medium</code>, <code>large</code>
</p>
</li>
<li> <p><code>OU.4</code>: a factor with levels <code>small</code>, <code>medium</code>, <code>large</code>, <code>anc</code>
</p>
</li>
<li> <p><code>OU.LP</code>: a factor with levels <code>small</code>, <code>medium</code>, <code>large</code>
</p>
</li></ul>



<h3>Details</h3>

<p>Explanations of the data follow:
</p>

<ul>
<li> <p><strong>Body size.</strong>
We use the phenotypic data and phylogeny of Losos (1990), which employed the head lengths (of males) as a proxy for body size.
In this group of lizards, head length correlates very strongly with snout-to-vent length and the cube root of mass, which are standard measures of body size.
The data are head lengths in mm; note that we use the log of this value in analyses.
</p>
</li>
<li> <p><strong>Tree structure.</strong>
The phylogenetic tree is encoded via three variables:
<code>node</code>, <code>ancestor</code>, and <code>time</code>.
The <code>node</code> variable gives a name to each node.
The <code>ancestor</code> variable names the ancestor of each node.
The root node has no ancestor (i.e., <code>ancestor=NA</code>).
The variable <code>time</code> specifies the temporal location of each node, the root node being at time 0.
</p>
</li>
<li> <p><strong>Specifications of selective regimes.</strong>
(Columns <code>OU.1</code>, <code>OU.3</code>, <code>OU.4</code>, <code>OU.LP</code>).
These columns are factors, the levels of which correspond to the &ldquo;paintings&rdquo; of the respective adaptive regime hypotheses onto the phylogeny (see <code><a href="#topic+paint">paint()</a></code>).
Each selective regime is named (small, medium, large, etc.).
Each column corresponds to a different painting of the selective regimes, and thus to a different hypothesis.
In this example, there are 3 alternative models (see Butler &amp; King 2004): <code>OU.4</code> is 4-regime model, <code>OU.3</code> is 3-regime model (all ancestors are medium), <code>OU.LP</code> is the linear parsimony model.
</p>
</li>
<li> <p><strong>Other variables.</strong>
In addition to the above, there is a two-letter code for each taxon (<code>spcode</code>) and the name of the island on which the taxon is found (<code>island</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Marguerite A. Butler and Aaron A. King
</p>


<h3>Source</h3>

<p>Butler, M.A. and A.A. King. 2004.  Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  American Naturalist 164:683&ndash;695. <a href="https://doi.org/10.1086/426002">doi:10.1086/426002</a>.
</p>


<h3>References</h3>

<p>Lazell, J. D. 1972.  The anoles (Sauria: Iguanidae) of the Lesser Antilles.  Bull. Mus. Comp. Zool., 143:1&ndash;115.
</p>
<p>Losos, J. B. 1990.  A phylogenetic analysis of character displacement in Caribbean Anolis lizards.  Evolution, 44:558&ndash;569. <a href="https://doi.org/10.1111/j.1558-5646.1990.tb05938.x">doi:10.1111/j.1558-5646.1990.tb05938.x</a>.
</p>


<h3>See Also</h3>

<p>Other examples: 
<code><a href="#topic+anolis.ssd">anolis.ssd</a></code>,
<code><a href="#topic+geospiza">geospiza</a></code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Analysis of Anolis bimaculatus data
 ## save time for CRAN
tree &lt;- with(bimac,ouchtree(node,ancestor,time/max(time),spcode))
plot(tree,node.names=TRUE)

h1 &lt;- brown(log(bimac['size']),tree)
h1
plot(h1)

h2 &lt;- hansen(log(bimac['size']),tree,bimac['OU.1'],sqrt.alpha=1,sigma=1)
h2
plot(h2)

h3 &lt;- hansen(log(bimac['size']),tree,bimac['OU.3'],sqrt.alpha=1,sigma=1)
h3
plot(h3)

h4 &lt;- hansen(log(bimac['size']),tree,bimac['OU.4'],sqrt.alpha=1,sigma=1)
h4
plot(h4)

h5 &lt;- hansen(log(bimac['size']),tree,bimac['OU.LP'],sqrt.alpha=1,sigma=1,reltol=1e-5)
h5 &lt;- update(h5,method='subplex',reltol=1e-11,parscale=c(0.1,0.1),hessian=TRUE)
h5
plot(h5)

simdat &lt;- simulate(h5,nsim=10)
hsim &lt;- update(h5,data=simdat[[1]])
summary(hsim)
bsim &lt;- update(h1,data=simdat[[1]])
summary(bsim)

</code></pre>

<hr>
<h2 id='bootstrap'>Bootstrapping for uncertainty quantification</h2><span id='topic+bootstrap'></span><span id='topic+bootstrap+2Cmissing-method'></span><span id='topic+bootstrap+2CANY-method'></span><span id='topic+bootstrap+2Chansentree-method'></span><span id='topic+bootstrap+2Cbrowntree-method'></span>

<h3>Description</h3>

<p>Parametric bootstrapping for <span class="pkg">ouch</span> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
bootstrap(object, ...)

## S4 method for signature 'ANY'
bootstrap(object, ...)

## S4 method for signature 'hansentree'
bootstrap(object, nboot = 200, seed = NULL, ...)

## S4 method for signature 'browntree'
bootstrap(object, nboot = 200, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap_+3A_object">object</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to <code><a href="#topic+update">update</a></code>.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_nboot">nboot</code></td>
<td>
<p>integer; number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_seed">seed</code></td>
<td>
<p>integer; setting <code>seed</code> to a non-<code>NULL</code> value allows one to fix the random seed (see <a href="#topic+simulate">simulate</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bootstrap</code> performs a parametric bootstrap for estimation of confidence intervals.
</p>


<h3>See Also</h3>

<p>Other methods for ouch trees: 
<code><a href="#topic+as_data_frame">as_data_frame</a></code>,
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+paint">paint</a>()</code>,
<code><a href="#topic+plot">plot</a>()</code>,
<code><a href="#topic+print">print</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+update">update</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Fit BM and a 5-regime OU model to the A. bimaculatus data
tree &lt;- with(bimac,ouchtree(node,ancestor,time/max(time),species))

h1 &lt;- brown(
  data=log(bimac['size']),
  tree=tree
)

h5 &lt;- hansen(
  data=log(bimac['size']),
  tree=tree,
  regimes=bimac['OU.LP'],
  sqrt.alpha=1,
  sigma=1,
  reltol=1e-11,
  parscale=c(0.1,0.1),
  hessian=TRUE
)

## What are appropriate AIC.c cutoffs?
simdat &lt;- simulate(h1,nsim=100,seed=92759587)
b1 &lt;- sapply(simdat,function(x)summary(update(h1,data=x))$aic.c)
tic &lt;- Sys.time()
b5 &lt;- sapply(simdat,function(x)summary(update(h5,data=x))$aic.c)
toc &lt;- Sys.time()
print(toc-tic)
cat("approximate 95% AIC.c cutoff",signif(quantile(b1-b5,0.95),digits=3),"\n")

## Bootstrap confidence intervals
boots.h1 &lt;- bootstrap(h1,nboot=200,seed=92759587)
cat("bootstrap 95% confidence intervals for h1:\n")
print(t(sapply(boots.h1,quantile,probs=c(0.025,0.975))),digits=3)

boots.h5 &lt;- bootstrap(h5,nboot=200,seed=92759587)
cat("bootstrap 95% confidence intervals for h5:\n")
print(t(sapply(boots.h5,quantile,probs=c(0.025,0.975))),digits=3)

## End(Not run)

</code></pre>

<hr>
<h2 id='brown'>Phylogenetic Brownian motion models</h2><span id='topic+brown'></span><span id='topic+browntree-class'></span>

<h3>Description</h3>

<p>The function <code>brown</code> creates a <code>browntree</code> object by fitting a
Brownian-motion model to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brown(data, tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brown_+3A_data">data</code></td>
<td>
<p>Phenotypic data for extant species, i.e., at the terminal ends of the phylogenetic tree.
This can either be a numeric vector or a list.
If it is a numeric vector, there must be one entry for every node.
If it is a list, it must consist entirely of numeric vectors, each of which has one entry per node.
A data-frame is coerced to a list.</p>
</td></tr>
<tr><td><code id="brown_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree, specified as an <code><a href="#topic+ouchtree">ouchtree</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>brown</code> returns an object of class <code>browntree</code>.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>References</h3>

<p>Butler, M.A. and A.A. King. 2004.  Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  American Naturalist 164:683&ndash;695. <a href="https://doi.org/10.1086/426002">doi:10.1086/426002</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bimac">bimac</a></code>, <code><a href="#topic+anolis.ssd">anolis.ssd</a></code>, <code><a href="#topic+hansen">hansen</a></code>
</p>
<p>Other phylogenetic comparative models: 
<code><a href="#topic+hansen">hansen</a>()</code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+ouchtree">ouchtree</a></code>,
<code><a href="#topic+paint">paint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Analysis of Anolis bimaculatus data
 ## save time for CRAN
tree &lt;- with(bimac,ouchtree(node,ancestor,time/max(time),spcode))
plot(tree,node.names=TRUE)

h1 &lt;- brown(log(bimac['size']),tree)
h1
plot(h1)

h2 &lt;- hansen(log(bimac['size']),tree,bimac['OU.1'],sqrt.alpha=1,sigma=1)
h2
plot(h2)

h3 &lt;- hansen(log(bimac['size']),tree,bimac['OU.3'],sqrt.alpha=1,sigma=1)
h3
plot(h3)

h4 &lt;- hansen(log(bimac['size']),tree,bimac['OU.4'],sqrt.alpha=1,sigma=1)
h4
plot(h4)

h5 &lt;- hansen(log(bimac['size']),tree,bimac['OU.LP'],sqrt.alpha=1,sigma=1,reltol=1e-5)
h5 &lt;- update(h5,method='subplex',reltol=1e-11,parscale=c(0.1,0.1),hessian=TRUE)
h5
plot(h5)

simdat &lt;- simulate(h5,nsim=10)
hsim &lt;- update(h5,data=simdat[[1]])
summary(hsim)
bsim &lt;- update(h1,data=simdat[[1]])
summary(bsim)

</code></pre>

<hr>
<h2 id='coef'>Model coefficients</h2><span id='topic+coef'></span><span id='topic+coef+2Chansentree-method'></span><span id='topic+coef+2Cbrowntree-method'></span>

<h3>Description</h3>

<p><code>coef</code> extracts the parameters from a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hansentree'
coef(object, ...)

## S4 method for signature 'browntree'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>fitted model object.</p>
</td></tr>
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>additional arguments, ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coef</code> applied to a <code>hansentree</code> object returns a named list containing the estimated <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code> matrices(given as the <code>alpha.matrix</code> and <code>sigma.sq.matrix</code> elements, respectively) but also the MLE returned by the optimizer
(as <code>sqrt.alpha</code> and <code>sigma</code>, respectively).
<strong>The latter elements should not be interpreted, but can be used to restart the algorithm, etc.</strong>
</p>
<p><code>coef</code> applied to a <code>browntree</code> object extracts a list with three elements:
</p>

<dl>
<dt><code>sigma</code></dt><dd><p>the coefficients of the sigma matrix.</p>
</dd>
<dt><code>theta</code></dt><dd><p>a list of the estimated optima, one per character.</p>
</dd>
<dt><code>sigma.sq.matrix</code></dt><dd><p>the sigma-squared matrix itself.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other methods for ouch trees: 
<code><a href="#topic+as_data_frame">as_data_frame</a></code>,
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+paint">paint</a>()</code>,
<code><a href="#topic+plot">plot</a>()</code>,
<code><a href="#topic+print">print</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+update">update</a>()</code>
</p>

<hr>
<h2 id='geospiza'>Data on Darwin's finches</h2><span id='topic+geospiza'></span>

<h3>Description</h3>

<p>Morphological measurements of Darwin's finches, together with a phylogeny.
</p>


<h3>Format</h3>

<p>The object <code>geospiza</code> is a list containing:
</p>

<ul>
<li> <p><code>phy</code>, a phylogenetic tree of class 'phylo' (see <code><a href="ape.html#topic+read.tree">read.tree</a></code>)
</p>
</li>
<li> <p><code>dat</code>, a data frame containing data on various morphological measurements.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aaron A. King, Emmanuel Paradis, Daniel Lawson
</p>


<h3>Source</h3>

<p>Data obtained from the <span class="pkg">geiger</span> package, version 2.0.7.1.
It is attributed there to D. Schluter, with no other details given.
</p>


<h3>See Also</h3>

<p>Other examples: 
<code><a href="#topic+anolis.ssd">anolis.ssd</a></code>,
<code><a href="#topic+bimac">bimac</a></code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Darwin's finches.
 ## Save time for CRAN
### The data were taken from package 'geiger' due to the latter being orphaned.
if (requireNamespace("ape")) {

  data(geospiza)
  plot(geospiza$phy)
  print(geospiza$dat)
  
### make an ouchtree out of the phy-format tree
  ot &lt;- ape2ouch(geospiza$phy)

### merge data with tree info
  otd &lt;- as(ot,"data.frame")
  otd &lt;- merge(otd,geospiza$dat,by.x="labels",by.y="row.names",all=TRUE)
### row-names are used by 'hansen'
  rownames(otd) &lt;- otd$nodes
  print(otd)
### this data-frame now contains the data as well as the tree geometry

### now remake the ouch tree
  ot &lt;- with(otd,ouchtree(nodes=nodes,ancestors=ancestors,times=times,labels=labels))
  plot(ot)

  b1 &lt;- brown(tree=ot,data=otd[c("tarsusL","beakD")])
  summary(b1)

### evaluate an OU model with a single, global selective regime
  otd$regimes &lt;- as.factor("global")
  h1 &lt;- hansen(
    tree=ot,
    data=otd[c("tarsusL","beakD")],
    regimes=otd["regimes"],
    sqrt.alpha=c(1,0,1),
    sigma=c(1,0,1),
    maxit=10000
  )
  summary(h1)
  plot(h1)

}

</code></pre>

<hr>
<h2 id='glssoln'>Generalized least-squares solver</h2><span id='topic+glssoln'></span>

<h3>Description</h3>

<p>Solves the generalized least squares problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glssoln(a, x, v, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Details</h3>

<p>Given matrices <code class="reqn">a</code>, <code class="reqn">x</code>, <code class="reqn">v</code>, <code>glssoln</code> computes <code class="reqn">y</code> such that
</p>
<p style="text-align: center;"><code class="reqn">(x-ay)^T v^{-1} (x-ay)</code>
</p>

<p>is minimized.
This is accomplished by first computing the Choleski decomposition of <code class="reqn">v</code>:
</p>
<p style="text-align: center;"><code class="reqn">v=LL^T.</code>
</p>

<p>One then solves for <code class="reqn">y</code> in the equation
</p>
<p style="text-align: center;"><code class="reqn">L^{-1}ay=L^{-1}x.</code>
</p>

<p>This is accomplished by means of a singular-value decomposition of <code class="reqn">L^{-1} a</code>.
</p>
<p>The resulting <code class="reqn">y</code> then satisfies
</p>
<p style="text-align: center;"><code class="reqn">x=ay+e,</code>
</p>

<p>where the entries of <code class="reqn">e</code> are the residuals.
</p>


<h3>Value</h3>

<p><code>glssoln</code> returns a list of two named components:
</p>

<ul>
<li> <p><code>coeff</code> is <code class="reqn">y</code> as above.
</p>
</li>
<li> <p><code>residuals</code> is <code class="reqn">e</code> as above.
</p>
</li></ul>


<hr>
<h2 id='hansen'>Ornstein-Uhlenbeck models of trait evolution</h2><span id='topic+hansen'></span><span id='topic+hansentree-class'></span>

<h3>Description</h3>

<p>The function <code>hansen</code> fits an Ornstein-Uhlenbeck model to data.
The fitting is done using <code>optim</code> or <code>subplex</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hansen(
  data,
  tree,
  regimes,
  sqrt.alpha,
  sigma,
  fit = TRUE,
  method = c("Nelder-Mead", "subplex", "BFGS", "L-BFGS-B"),
  hessian = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hansen_+3A_data">data</code></td>
<td>
<p>Phenotypic data for extant species, i.e., species at the terminal twigs of the phylogenetic tree.
This can either be a single named numeric vector, a list of <code>nchar</code> named vectors, or a data frame containing <code>nchar</code> data variables.
There must be an entry per variable for every node in the tree; use <code>NA</code> to represent missing data.
If the
data are supplied as one or more named vectors, the names attributes are taken to correspond to the node names specified when the <code>ouchtree</code> was constructed (see <code><a href="#topic+ouchtree">ouchtree</a></code>).
If the data are supplied as a
data-frame, the rownames serve that purpose.</p>
</td></tr>
<tr><td><code id="hansen_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree, specified as an <code>ouchtree</code> object.</p>
</td></tr>
<tr><td><code id="hansen_+3A_regimes">regimes</code></td>
<td>
<p>A vector of codes, one for each node in the tree, specifying the selective regimes hypothesized to have been operative.
Corresponding to each node, enter the code of the regime hypothesized for the branch segment terminating in that node.
For the root node, because it has no branch segment terminating on it, the regime specification is irrelevant.
If there are <code>nchar</code> quantitative characters, then one can specify a single set of <code>regimes</code> for all characters or a list of <code>nchar</code> regime specifications, one for each character.</p>
</td></tr>
<tr><td><code id="hansen_+3A_sqrt.alpha">sqrt.alpha</code>, <code id="hansen_+3A_sigma">sigma</code></td>
<td>
<p>These are used to initialize the optimization algorithm.
The selection strength matrix <code class="reqn">\alpha</code> and the random drift variance-covariance matrix <code class="reqn">\sigma^2</code> are parameterized by their matrix square roots.
Specifically, these initial guesses are each packed into lower-triangular matrices (column by column).
The product of this matrix with its transpose is the <code class="reqn">\alpha</code> or <code class="reqn">\sigma^2</code> matrix.
See Details for more information.</p>
</td></tr>
<tr><td><code id="hansen_+3A_fit">fit</code></td>
<td>
<p>If <code>fit=TRUE</code>, then the likelihood will be maximized.
If <code>fit=FALSE</code>, the likelihood will be evaluated at the specified values of <code>sqrt.alpha</code> and <code>sigma</code>;
the optima <code>theta</code> will be returned as well.</p>
</td></tr>
<tr><td><code id="hansen_+3A_method">method</code></td>
<td>
<p>The method to be used by the optimization algorithm.
See <code><a href="subplex.html#topic+subplex">subplex::subplex</a></code> and <code><a href="stats.html#topic+optim">stats::optim</a></code> for information on the available options.</p>
</td></tr>
<tr><td><code id="hansen_+3A_hessian">hessian</code></td>
<td>
<p>If <code>hessian=TRUE</code>, then the Hessian matrix will be computed by <code>optim</code>.</p>
</td></tr>
<tr><td><code id="hansen_+3A_...">...</code></td>
<td>
<p>Additional arguments will be passed as <code>control</code> options to <code>optim</code> or <code>subplex</code>.
See <code><a href="stats.html#topic+optim">stats::optim()</a></code> and <code><a href="subplex.html#topic+subplex">subplex::subplex()</a></code> for information on the available options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hansen model for the evolution of a multivariate trait <code class="reqn">X</code> along a lineage can be written as a stochastic differential equation (Ito diffusion)
</p>
<p style="text-align: center;"><code class="reqn">dX=\alpha(\theta(t)-X(t))dt+\sigma dB(t),</code>
</p>

<p>where <code class="reqn">t</code> is time along the lineage,
<code class="reqn">\theta(t)</code> is the optimum trait value, <code class="reqn">B(t)</code> is a standard Wiener process (Brownian motion),
and <code class="reqn">\alpha</code> and <code class="reqn">\sigma</code> are matrices
quantifying, respectively, the strength of selection and random drift.
Without loss of generality, one can assume <code class="reqn">\sigma</code> is lower-triangular.
This is because only the infinitesimal variance-covariance matrix
<code class="reqn">\sigma^2=\sigma\sigma^T</code>
is identifiable, and for any admissible variance-covariance matrix, we can choose <code class="reqn">\sigma</code> to be lower-triangular.
Moreover, if we view the basic model as describing evolution on a fitness landscape, then <code class="reqn">\alpha</code> will be symmetric.
If we further restrict ourselves to the case of stabilizing selection, <code class="reqn">\alpha</code> will be positive definite as well.
We make these assumptions and therefore can assume that the matrix <code class="reqn">\alpha</code> has a lower-triangular square root.
</p>
<p>The <code>hansen</code> code uses unconstrained numerical optimization to maximize the likelihood.
To do this, it parameterizes the <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code> matrices in a special way:
each matrix is parameterized by <code>nchar*(nchar+1)/2</code> parameters, where <code>nchar</code> is the number of quantitative characters.
Specifically, the parameters initialized by the <code>sqrt.alpha</code> argument of <code>hansen</code> are used
to fill the nonzero entries of a lower-triangular matrix (in column-major order),
which is then multiplied by its transpose to give the selection-strength matrix.
The parameters specified in <code>sigma</code> fill the nonzero entries in the lower triangular <code class="reqn">\sigma</code> matrix.
When <code>hansen</code> is executed, the numerical optimizer maximizes the likelihood over these parameters.
</p>


<h3>Value</h3>

<p><code>hansen</code> returns an object of class <code>hansentree</code>.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>References</h3>

<p>T.F. Hansen. 1997. Stabilizing selection and the comparative analysis of adaptation. Evolution, 51:1341&ndash;1351. <a href="https://doi.org/10.1111/j.1558-5646.1997.tb01457.x">doi:10.1111/j.1558-5646.1997.tb01457.x</a>.
</p>
<p>Butler, M.A. and A.A. King. 2004.  Phylogenetic comparative analysis: a modeling approach for adaptive evolution.  American Naturalist 164:683&ndash;695. <a href="https://doi.org/10.1086/426002">doi:10.1086/426002</a>.
</p>
<p>Cressler, C. E., Butler, M. A., and King, A. A. 2015. Detecting adaptive evolution in phylogenetic comparative analysis using the Ornstein-Uhlenbeck model. Systematic Biology, 64:953&ndash;968. <a href="https://doi.org/10.1093/sysbio/syv043">doi:10.1093/sysbio/syv043</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">stats::optim</a></code>, <code><a href="subplex.html#topic+subplex">subplex::subplex</a></code>, <code><a href="#topic+bimac">bimac</a></code>, <code><a href="#topic+anolis.ssd">anolis.ssd</a></code>
</p>
<p>Other phylogenetic comparative models: 
<code><a href="#topic+brown">brown</a>()</code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+ouchtree">ouchtree</a></code>,
<code><a href="#topic+paint">paint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Analysis of sexual size dimorphism data
 ## Save time for CRAN
tree &lt;- with(anolis.ssd,ouchtree(node,ancestor,time/max(time),species))
plot(tree,node.names=TRUE)

h1 &lt;- brown(anolis.ssd['log.SSD'],tree)
h1
plot(h1)

h2 &lt;- hansen(anolis.ssd['log.SSD'],tree,anolis.ssd['OU.1'],sqrt.alpha=1,sigma=1)
h2
plot(h2)

h3 &lt;- hansen(anolis.ssd['log.SSD'],tree,anolis.ssd['OU.7'],sqrt.alpha=1,sigma=1)
h3
plot(h3)

### Darwin's finches.
 ## Save time for CRAN
### The data were taken from package 'geiger' due to the latter being orphaned.
if (requireNamespace("ape")) {

  data(geospiza)
  plot(geospiza$phy)
  print(geospiza$dat)
  
### make an ouchtree out of the phy-format tree
  ot &lt;- ape2ouch(geospiza$phy)

### merge data with tree info
  otd &lt;- as(ot,"data.frame")
  otd &lt;- merge(otd,geospiza$dat,by.x="labels",by.y="row.names",all=TRUE)
### row-names are used by 'hansen'
  rownames(otd) &lt;- otd$nodes
  print(otd)
### this data-frame now contains the data as well as the tree geometry

### now remake the ouch tree
  ot &lt;- with(otd,ouchtree(nodes=nodes,ancestors=ancestors,times=times,labels=labels))
  plot(ot)

  b1 &lt;- brown(tree=ot,data=otd[c("tarsusL","beakD")])
  summary(b1)

### evaluate an OU model with a single, global selective regime
  otd$regimes &lt;- as.factor("global")
  h1 &lt;- hansen(
    tree=ot,
    data=otd[c("tarsusL","beakD")],
    regimes=otd["regimes"],
    sqrt.alpha=c(1,0,1),
    sigma=c(1,0,1),
    maxit=10000
  )
  summary(h1)
  plot(h1)

}

</code></pre>

<hr>
<h2 id='logLik'>Log likelihood of a fitted model</h2><span id='topic+logLik'></span><span id='topic+logLik+2Chansentree-method'></span><span id='topic+logLik+2Cbrowntree-method'></span>

<h3>Description</h3>

<p><code>logLik</code> extracts the log likelihood from a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hansentree'
logLik(object)

## S4 method for signature 'browntree'
logLik(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logLik</code> returns a numeric value.
</p>


<h3>See Also</h3>

<p>Other methods for ouch trees: 
<code><a href="#topic+as_data_frame">as_data_frame</a></code>,
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+paint">paint</a>()</code>,
<code><a href="#topic+plot">plot</a>()</code>,
<code><a href="#topic+print">print</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+update">update</a>()</code>
</p>

<hr>
<h2 id='ouchtree'>Phylogenetic tree object in <span class="pkg">ouch</span> format</h2><span id='topic+ouchtree'></span><span id='topic+ouchtree-class'></span><span id='topic+ape2ouch'></span>

<h3>Description</h3>

<p><code>ouchtree</code> constructs a representation of a phylogenetic tree.
</p>
<p><code>ape2ouch</code> translates <span class="pkg">ape</span>'s <code>phylo</code> representation of a phylogenetic tree into <span class="pkg">ouch</span>'s <code>ouchtree</code> representation.
Optionally, the user can adjust the branch lengths while preserving the topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ouchtree(nodes, ancestors, times, labels = as.character(nodes))

ape2ouch(tree, scale = TRUE, branch.lengths = tree$edge.length)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ouchtree_+3A_nodes">nodes</code></td>
<td>
<p>A character vector giving the name of each node.
These are used internally and must be unique.</p>
</td></tr>
<tr><td><code id="ouchtree_+3A_ancestors">ancestors</code></td>
<td>
<p>Specification of the topology of the phylogenetic tree.
This is in the form of a character vector specifying the name
(as given in the <code>nodes</code> argument)
of the immediate ancestor of each node.
In particular, the i-th name is that of the ancestor of the i-th node.
The root node is distinguished by having no ancestor (i.e., <code>NA</code>).</p>
</td></tr>
<tr><td><code id="ouchtree_+3A_times">times</code></td>
<td>
<p>A vector of nonnegative numbers, one per node in the tree,
specifying the time at which each node is located.
Time should be increasing from the root node to the terminal twigs.</p>
</td></tr>
<tr><td><code id="ouchtree_+3A_labels">labels</code></td>
<td>
<p>Optional vector of node labels.
These will be used in plots to label nodes.
It is not necessary that these be unique.</p>
</td></tr>
<tr><td><code id="ouchtree_+3A_tree">tree</code></td>
<td>
<p>a tree of class <a href="ape.html#topic+read.tree">ape::phylo</a>.</p>
</td></tr>
<tr><td><code id="ouchtree_+3A_scale">scale</code></td>
<td>
<p>optional.
If <code>scale=TRUE</code>, the tree's depth will be scaled to 1.
If <code>scale</code> is a number, then the branch lengths will be scaled by this number.</p>
</td></tr>
<tr><td><code id="ouchtree_+3A_branch.lengths">branch.lengths</code></td>
<td>
<p>optional vector of branch lengths.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ouchtree()</code> creates an <code>ouchtree</code> object given information on the phylogeny's topology and node times.
An <code>ouchtree</code> object also (optionally) holds names of taxa for display purposes.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>
<p>A. A. King, D. Ackerly
</p>


<h3>See Also</h3>

<p>Other phylogenetic comparative models: 
<code><a href="#topic+brown">brown</a>()</code>,
<code><a href="#topic+hansen">hansen</a>()</code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+paint">paint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- with(
  bimac,
  ouchtree(nodes=node,ancestors=ancestor,times=time,labels=spcode)
)
tree

plot(tree)
plot(tree, node.names=TRUE)    # display node names

</code></pre>

<hr>
<h2 id='paint'>Painting regimes on a phylogenetic tree</h2><span id='topic+paint'></span>

<h3>Description</h3>

<p>Function to paint selective regimes on a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paint(tree, subtree, branch, which = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paint_+3A_tree">tree</code></td>
<td>
<p>An object of class <code><a href="#topic+ouchtree">ouchtree</a></code>.</p>
</td></tr>
<tr><td><code id="paint_+3A_subtree">subtree</code></td>
<td>
<p>An optional named vector specifying the root nodes of subtrees.
Each branch that descends from this node will be painted with the specified regime.</p>
</td></tr>
<tr><td><code id="paint_+3A_branch">branch</code></td>
<td>
<p>An optional named vector specifying the end nodes of branches.
The unique branch that terminates at the named node will be painted with the specified regime.</p>
</td></tr>
<tr><td><code id="paint_+3A_which">which</code></td>
<td>
<p>integer;
if <code>tree</code> is a <code><a href="#topic+hansen">hansentree</a></code>, start not with a blank canvas but with the regime specifications <code>tree</code> contains for the character indicated by <code>which</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of <code>subtree</code> and <code>branch</code> must be the names of nodes of <code>tree</code>.
The painting proceeds in a particular order:
one can overpaint a branch.
The subtrees indicated by the elements of <code>subtree</code> are painted first, in order.
Then the branches indicated by <code>branch</code> are painted.
If <code>tree</code> is of class <code><a href="#topic+hansen">hansentree</a></code>, then <code>paint</code> begins with the regimes specified in the <code>regimes</code> slot of <code>tree</code>.
Otherwise, <code>paint</code> begins with a blank canvas,
i.e., a tree painted with the single regime &quot;nonspec&quot;.
Note that, if <code>tree</code> is a multivariate <code>hansentree</code>, then there are multiple regime specifications contained in <code>tree</code>.
In this case, the argument <code>which</code> lets you pick which one you wish to begin with;
by default, the first is used.
</p>


<h3>Value</h3>

<p>A vector of class 'factor' with names corresponding to the nodes in <code>tree</code>, specifying selective regimes.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>See Also</h3>

<p>Other methods for ouch trees: 
<code><a href="#topic+as_data_frame">as_data_frame</a></code>,
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+plot">plot</a>()</code>,
<code><a href="#topic+print">print</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+update">update</a>()</code>
</p>
<p>Other phylogenetic comparative models: 
<code><a href="#topic+brown">brown</a>()</code>,
<code><a href="#topic+hansen">hansen</a>()</code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+ouchtree">ouchtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- with(
  bimac,
  ouchtree(nodes=node,times=time/max(time),ancestors=ancestor,labels=species)
)

r &lt;- paint(x,subtree=c("1"="medium","9"="large","2"="small"),
  branch=c("38"="large","2"="medium"))
plot(x,regimes=r,node.names=TRUE)

## compare to bimac['OU.LP']
h5 &lt;- hansen(data=log(bimac['size']),tree=x,regimes=bimac['OU.LP'],
  sqrt.alpha=1,sigma=1,reltol=1e-5)
r &lt;- paint(h5,branch=c("18"="large"),subtree=c("9"="small"))
plot(x,regimes=r,node.names=TRUE)

</code></pre>

<hr>
<h2 id='plot'><span class="pkg">ouch</span> plotting functions</h2><span id='topic+plot'></span><span id='topic+plot+2Couchtree-method'></span><span id='topic+plot+2Chansentree-method'></span>

<h3>Description</h3>

<p>Plot phylogenetic trees, with or without regime paintings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ouchtree'
plot(
  x,
  ...,
  regimes = NULL,
  ladderize = TRUE,
  node.names = FALSE,
  legend = !is.null(regimes),
  labels,
  frame.plot = FALSE,
  palette = rainbow,
  margin = 0.1,
  text_opts = list(),
  legend_opts = list()
)

## S4 method for signature 'hansentree'
plot(x, ..., regimes, legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>object to plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to <code><a href="graphics.html#topic+plot.default">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_regimes">regimes</code></td>
<td>
<p>factor or character; a vector of regime paintings.</p>
</td></tr>
<tr><td><code id="plot_+3A_ladderize">ladderize</code></td>
<td>
<p>logical; should the tree be ladderized?</p>
</td></tr>
<tr><td><code id="plot_+3A_node.names">node.names</code></td>
<td>
<p>logical; should node names be displayed?</p>
</td></tr>
<tr><td><code id="plot_+3A_legend">legend</code></td>
<td>
<p>logical; display a legend?</p>
</td></tr>
<tr><td><code id="plot_+3A_labels">labels</code></td>
<td>
<p>character; taxon labels.</p>
</td></tr>
<tr><td><code id="plot_+3A_frame.plot">frame.plot</code></td>
<td>
<p>a logical indicating whether a box should be drawn
around the plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_palette">palette</code></td>
<td>
<p>function or character; specifies the colors to be used for the several regimes on the tree.
Specified as a function, when given an integer, <code>n</code>, the function should create a vector of <code>n</code> colors.
See, for example <code><a href="grDevices.html#topic+palettes">rainbow</a></code>.
One can also specify the <code>n</code> colors as a vector of color codes.
There must be at least as many colors as levels in the <code>regimes</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_margin">margin</code></td>
<td>
<p>numeric; width of the right margin (as a fraction of the plot width).
Adjust this if labels are clipped (see Examples below).
One can also adjust the width of the left margin (for example to aid in the formatting of the figure legend).
To do this, furnish <code>margin=c(L, R)</code>, where <code>L</code> and <code>R</code> are the widths of the right and left margins, respectively, as fractions of the plot width.
Obviously, in this case, we must have <code>L+R&lt;1</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_text_opts">text_opts</code></td>
<td>
<p>options for the labels; passed to <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_legend_opts">legend_opts</code></td>
<td>
<p>options for the the legend; passed to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other methods for ouch trees: 
<code><a href="#topic+as_data_frame">as_data_frame</a></code>,
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+paint">paint</a>()</code>,
<code><a href="#topic+print">print</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+update">update</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- with(
  bimac,
  ouchtree(nodes=node,ancestors=ancestor,times=time,labels=spcode)
)

plot(tree)
plot(tree, node.names=TRUE)    # display node names

## When taxon names are long, they are cut off when the
## default settings are used.  For example:
tree2 &lt;- with(
  bimac,
  ouchtree(nodes=node,ancestors=ancestor,times=time,
    labels=ifelse(is.na(species),NA,paste(species,island,sep=", "))
  )
)

plot(tree2) # long species names are cut off
## This is fixed by increasing right margin and font size:
plot(tree2,margin=0.35,text_opts=list(cex=0.7))

</code></pre>

<hr>
<h2 id='print'>Print and show methods</h2><span id='topic+print'></span><span id='topic+show'></span><span id='topic+print+2Couchtree-method'></span><span id='topic+show+2Couchtree-method'></span><span id='topic+print+2Chansentree-method'></span><span id='topic+show+2Chansentree-method'></span><span id='topic+show+2Cbrowntree-method'></span><span id='topic+print+2Cbrowntree-method'></span>

<h3>Description</h3>

<p>Print and show methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ouchtree'
print(x, ...)

## S4 method for signature 'ouchtree'
show(object)

## S4 method for signature 'hansentree'
print(x, ...)

## S4 method for signature 'hansentree'
show(object)

## S4 method for signature 'browntree'
show(object)

## S4 method for signature 'browntree'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>additional arguments, ignored.</p>
</td></tr>
<tr><td><code id="print_+3A_object">object</code>, <code id="print_+3A_x">x</code></td>
<td>
<p>object to display.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print</code> displays the tree as a table, along with the coefficients of the fitted model and diagnostic information.
<code>show</code> provides a similar display.
</p>


<h3>Value</h3>

<p><code>print</code> returns <code>x</code>, invisibly.
</p>
<p><code>show</code> returns <code>NULL</code>, invisibly.
</p>


<h3>See Also</h3>

<p>Other methods for ouch trees: 
<code><a href="#topic+as_data_frame">as_data_frame</a></code>,
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+paint">paint</a>()</code>,
<code><a href="#topic+plot">plot</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+update">update</a>()</code>
</p>

<hr>
<h2 id='simulate'>Simulations of a phylogenetic trait model</h2><span id='topic+simulate'></span><span id='topic+simulate+2Chansentree-method'></span><span id='topic+simulate+2Cbrowntree-method'></span>

<h3>Description</h3>

<p><code>simulate</code> generates random deviates from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hansentree'
simulate(object, nsim = 1, seed = NULL, ...)

## S4 method for signature 'browntree'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_+3A_object">object</code></td>
<td>
<p>fitted model object</p>
</td></tr>
<tr><td><code id="simulate_+3A_nsim">nsim</code></td>
<td>
<p>integer; number of independent simulations.</p>
</td></tr>
<tr><td><code id="simulate_+3A_seed">seed</code></td>
<td>
<p>integer; if non-<code>NULL</code>, the RNG will be initialized with this seed for the simulations.
The RNG will be reset to its pre-existing state when <code>simulate</code> returns.</p>
</td></tr>
<tr><td><code id="simulate_+3A_...">...</code></td>
<td>
<p>additional arguments, ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>simulate</code> returns a list of data-frames, each comparable to the original data.
</p>


<h3>See Also</h3>

<p>Other methods for ouch trees: 
<code><a href="#topic+as_data_frame">as_data_frame</a></code>,
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+paint">paint</a>()</code>,
<code><a href="#topic+plot">plot</a>()</code>,
<code><a href="#topic+print">print</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+update">update</a>()</code>
</p>

<hr>
<h2 id='summary'>Summary methods</h2><span id='topic+summary'></span><span id='topic+summary+2Chansentree-method'></span><span id='topic+summary+2Cbrowntree-method'></span>

<h3>Description</h3>

<p>Summary methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hansentree'
summary(object, ...)

## S4 method for signature 'browntree'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>fitted model object.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>additional arguments, ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary</code> applied to a <code>hansentree</code> method displays the estimated <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code> matrices as well as various quantities describing the goodness of model fit.
</p>
<p><code>summary</code> applied to a <code>browntree</code> object returns information about the fitted model, including parameter estimates and quantities describing the goodness of fit.
</p>


<h3>See Also</h3>

<p>Other methods for ouch trees: 
<code><a href="#topic+as_data_frame">as_data_frame</a></code>,
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+paint">paint</a>()</code>,
<code><a href="#topic+plot">plot</a>()</code>,
<code><a href="#topic+print">print</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+update">update</a>()</code>
</p>

<hr>
<h2 id='update'>Update and refit an <span class="pkg">ouch</span> model</h2><span id='topic+update'></span><span id='topic+update+2Chansentree-method'></span><span id='topic+update+2Cbrowntree-method'></span>

<h3>Description</h3>

<p><code>update</code> will update a model and re-fit.
This allows one to change the data and/or parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hansentree'
update(object, data, regimes, sqrt.alpha, sigma, ...)

## S4 method for signature 'browntree'
update(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_+3A_object">object</code></td>
<td>
<p>fitted model object.</p>
</td></tr>
<tr><td><code id="update_+3A_data">data</code></td>
<td>
<p>data that replace those used in the original fit.</p>
</td></tr>
<tr><td><code id="update_+3A_regimes">regimes</code></td>
<td>
<p>A vector of codes, one for each node in the tree, specifying the selective regimes hypothesized to have been operative.
Corresponding to each node, enter the code of the regime hypothesized for the branch segment terminating in that node.
For the root node, because it has no branch segment terminating on it, the regime specification is irrelevant.
If there are <code>nchar</code> quantitative characters, then one can specify a single set of <code>regimes</code> for all characters or a list of <code>nchar</code> regime specifications, one for each character.</p>
</td></tr>
<tr><td><code id="update_+3A_sqrt.alpha">sqrt.alpha</code>, <code id="update_+3A_sigma">sigma</code></td>
<td>
<p>These are used to initialize the optimization algorithm.
The selection strength matrix <code class="reqn">\alpha</code> and the random drift variance-covariance matrix <code class="reqn">\sigma^2</code> are parameterized by their matrix square roots.
Specifically, these initial guesses are each packed into lower-triangular matrices (column by column).
The product of this matrix with its transpose is the <code class="reqn">\alpha</code> or <code class="reqn">\sigma^2</code> matrix.
See Details for more information.</p>
</td></tr>
<tr><td><code id="update_+3A_...">...</code></td>
<td>
<p>Additional arguments replace the corresponding arguments in the original call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>update</code> returns a new fitted-model object of the same class as  <code>object</code>.
</p>


<h3>See Also</h3>

<p>Other methods for ouch trees: 
<code><a href="#topic+as_data_frame">as_data_frame</a></code>,
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+ouch-package">ouch-package</a></code>,
<code><a href="#topic+paint">paint</a>()</code>,
<code><a href="#topic+plot">plot</a>()</code>,
<code><a href="#topic+print">print</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
