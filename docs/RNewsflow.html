<!DOCTYPE html><html lang="en"><head><title>Help for package RNewsflow</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RNewsflow}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_document_network'><p>Create a document similarity network</p></a></li>
<li><a href='#compare_documents'><p>Compare the documents in a dtm</p></a></li>
<li><a href='#create_document_network'><p>Create a document similarity network</p></a></li>
<li><a href='#create_queries'><p>Automatically infer queries from combinations of terms in a dtm</p></a></li>
<li><a href='#delete_duplicates'><p>Delete duplicate (or similar) documents from a document term matrix</p></a></li>
<li><a href='#directed_network_plot'><p>A wrapper for plot.igraph for visualizing directed networks.</p></a></li>
<li><a href='#docnet'><p>Document similarity network for one news agency, and the print and online editions of two newspapers</p></a></li>
<li><a href='#document_network_plot'><p>Visualize (a subcomponent) of the document similarity network</p></a></li>
<li><a href='#filter_window'><p>Filter edges from the document similarity network based on hour difference</p></a></li>
<li><a href='#get_doc_terms'><p>View term scores for a given document</p></a></li>
<li><a href='#get_overlap_terms'><p>View overlapping terms for a given pair of documents</p></a></li>
<li><a href='#hourdiff_range_thresholds'><p>Inspect effects of thresholds on matches over time</p></a></li>
<li><a href='#network_aggregate'><p>Aggregate the edges of a network by vertex attributes</p></a></li>
<li><a href='#newsflow_compare'><p>Create a network of document similarities over time</p></a></li>
<li><a href='#only_first_match'><p>Transform document network so that each document only matches the earliest dated matching document</p></a></li>
<li><a href='#rnewsflow_dfm'><p>quanteda dfm for RNewsflow vignette demo</p></a></li>
<li><a href='#show_window'><p>Show time window of document pairs</p></a></li>
<li><a href='#tcrossprod_sparse'><p>tcrossprod with benefits, for people that like parameters</p></a></li>
<li><a href='#term_char_sim'><p>Find terms with similar spelling</p></a></li>
<li><a href='#term_day_dist'><p>Calculate statistics for term occurence across days</p></a></li>
<li><a href='#term_innovation'><p>Experimental: Convert dtm scores to a term innovation score, based on changes in term use over time</p></a></li>
<li><a href='#term_intersect'><p>Combine terms in a dtm</p></a></li>
<li><a href='#term_union'><p>Combine terms in a dtm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Comparing Text Messages Across Time and Media</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.8</td>
</tr>
<tr>
<td>Author:</td>
<td>Kasper Welbers &amp; Wouter van Atteveldt</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kasper Welbers &lt;kasperwelbers@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of tools for measuring the similarity of text messages and tracing the flow of messages over
    time and across media. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), igraph (&ge; 1.3.4), Matrix (&ge; 1.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringi (&ge; 1.7.8), scales (&ge; 1.2.1), wordcloud (&ge; 2.6),
data.table (&ge; 1.10.4), methods, quanteda (&ge; 3.2.3), Rcpp (&ge;
0.12.12)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.9), RcppEigen (&ge; 0.3.3.9.2), RcppProgress (&ge;
0.4.2)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.40), rmarkdown (&ge; 2.16)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-03 10:35:18 UTC; kasper</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-03 11:03:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_document_network'>Create a document similarity network</h2><span id='topic+as_document_network'></span>

<h3>Description</h3>

<p>This function can be used to structure the output of the <a href="#topic+compare_documents">compare_documents</a> function as an igraph network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_document_network(el)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_document_network_+3A_el">el</code></td>
<td>
<p>An RNewsflow_edgelist object, as created with <a href="#topic+compare_documents">compare_documents</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network/graph in the <a href="igraph.html#topic+igraph">igraph</a> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm = quanteda::dfm_tfidf(rnewsflow_dfm)
el = compare_documents(dtm, date_var='date', hour_window = c(0.1, 36))

g = as_document_network(el)
g
</code></pre>

<hr>
<h2 id='compare_documents'>Compare the documents in a dtm</h2><span id='topic+compare_documents'></span>

<h3>Description</h3>

<p>This function calculates document similarity scores using a vector space approach. The most important
benefit is that it includes options for limiting the number of comparisons that need to be made and filtering
the results, that are efficiently implemented in a custom inner product calculation. This makes it possible 
to compare a huge number of documents, especially for cases where only documents witihin a given time window need
to be compared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_documents(
  dtm,
  dtm_y = NULL,
  date_var = NULL,
  hour_window = c(-24, 24),
  group_var = NULL,
  measure = c("cosine", "overlap_pct", "overlap", "dot_product", "softcosine",
    "cp_lookup", "cp_lookup_norm"),
  tf_idf = F,
  min_similarity = 0,
  n_topsim = NULL,
  only_complete_window = T,
  copy_meta = T,
  backbone_p = 1,
  simmat = NULL,
  simmat_thres = NULL,
  batchsize = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_documents_+3A_dtm">dtm</code></td>
<td>
<p>A quanteda <a href="quanteda.html#topic+dfm">dfm</a>. Note that it is common to first weight the dtm(s) before calculating document similarity,
For this you can use quanteda's <a href="quanteda.html#topic+dfm_tfidf">dfm_tfidf</a> and <a href="quanteda.html#topic+dfm_weight">dfm_weight</a></p>
</td></tr>
<tr><td><code id="compare_documents_+3A_dtm_y">dtm_y</code></td>
<td>
<p>Optionally, another dtm. If given, the documents in dtm will be compared to the documents in dtm_y.</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_date_var">date_var</code></td>
<td>
<p>Optionally, the name of the column in docvars that specifies the document date. The values should be of type POSIXct, or coercable with as.POSIXct.
If given, the hour_window argument is used to only compare documents within a time window.</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_hour_window">hour_window</code></td>
<td>
<p>A vector of length 2, in which the first and second value determine the left and right side of the window, respectively. 
For example, c(-10, 36) will compare each document to all documents between the previous 10 and the next 36 hours.
It is possible to specify time windows down to the level of seconds by using fractions (hours / 60 / 60).</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_group_var">group_var</code></td>
<td>
<p>Optionally,  The name of the column in docvars that specifies a group (e.g., source, sourcetype). If given, only documents within the same group will be compared.</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_measure">measure</code></td>
<td>
<p>The measure that should be used to calculate similarity/distance/adjacency. Currently supports the symmetrical measure &quot;cosine&quot; (cosine similarity), the assymetrical measures &quot;overlap_pct&quot; (percentage of term scores in the document 
that also occur in the other document), &quot;overlap&quot; (like overlap_pct, but as the sum of overlap instead of the percentage) and the symmetrical soft cosine measure (experimental).
The regular dot product (dot_product) is also supported.</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_tf_idf">tf_idf</code></td>
<td>
<p>If TRUE, weigh the dtm (and dtm_y) by term frequency - inverse document frequency. For more control over weighting,
we recommend using quanteda's <a href="quanteda.html#topic+dfm_tfidf">dfm_tfidf</a> or <a href="quanteda.html#topic+dfm_weight">dfm_weight</a> on dtm and dtm_y.</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_min_similarity">min_similarity</code></td>
<td>
<p>A threshold for similarity. lower values are deleted. For all available similarity measures zero means no similarity.</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_n_topsim">n_topsim</code></td>
<td>
<p>An alternative or additional sort of threshold for similarity. Only keep the [n_topsim] highest similarity scores for x. Can return more than [n_topsim] similarity scores in the case of duplicate similarities.</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_only_complete_window">only_complete_window</code></td>
<td>
<p>If True, only compare articles (x) of which a full window of reference articles (y) is available. Thus, for the first and last [window.size] days, there will be no results for x.</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_copy_meta">copy_meta</code></td>
<td>
<p>If TRUE, copy the dtm docvars to the from_meta and to_meta data.tables</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_backbone_p">backbone_p</code></td>
<td>
<p>Apply backbone filtering with a &quot;disparity&quot; filter (see Serrano et al., DOI: 10.1073/pnas.0808904106).
It is different from the original disparity filter algorithm in that it only looks at outward edges. Also, the outward degree k is
measured as all possible edges (within a window), not just the non-zero edges.</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_simmat">simmat</code></td>
<td>
<p>If softcosine is used, a symmetrical matrix with the similarity scores of terms. If NULL, the cosine similarity of terms in dtm will be used</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_simmat_thres">simmat_thres</code></td>
<td>
<p>A large, dense simmat can lead to memory problems and slows down computation. A pragmatig (though not mathematically pure) solution is to use a threshold to prune small similarities.</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_batchsize">batchsize</code></td>
<td>
<p>For internal use (testing)</p>
</td></tr>
<tr><td><code id="compare_documents_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, report progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the function performs a regular tcrossprod of the dtm (with itself or with dtm_y). The following parameters can be
set to limit comparisons and filter output:
</p>

<ul>
<li><p>If the 'date_var' is specified. The given hour_window is used to only compare documents within the specified time distance.
</p>
</li>
<li><p>If the 'group_var' is specified, only documents for which the group is identical will be compared.
</p>
</li>
<li><p>With the 'min_similarity' argument, the output can be filtered with a minimum similarity threshold. For the inner product of two
DTMs the size of the output matrix is often the main bottleneck for comparing many documents, because it generally increases exponentially with
the number of documents in the DTMs. Even a low similarity threshold can greatly reduce the size of the output
</p>
</li>
<li><p>As an alternative or additional filter, you can limit the results for each row in dtm to the highest top_n similarity scores
</p>
</li></ul>

<p>Margin attributes are also included in the output in the from_meta and to_meta data.tables (see details).
If copy_meta = TRUE, The dtm docvars are also included in from_meta and to_meta.
</p>
<p>Margin attributes are added to the meta data.
The reason for including this is that some values that are normally available in a similarity matrix are missing if certain filter options are used.
If group or date is used, we don't know how many columns a rows has been compared to (normally this is all columns).
If a min/max or top_n filter is used, we don't know the true row sums (and thus row means).
The meta data therefore includes the &quot;row_n&quot;, &quot;row_sum&quot;, &quot;col_n&quot;, and &quot;col_sum&quot;.
In addition, there are &quot;lag_n&quot; and &quot;lag_sum&quot;. this is a special case where row_n and row_sum are calculated for only matches where the column date &lt; row date (lag).
This can be used for more refined calculations of edge probabilities before and after a row document.
</p>


<h3>Value</h3>

<p>A S3 class for RNewsflow_edgelist, which is a list with the edgelist, from_meta and to_meta data.tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm = quanteda::dfm_tfidf(rnewsflow_dfm)
el = compare_documents(dtm, date_var='date', hour_window = c(0.1, 36))


d = data.frame(text = c('a b c d e', 
                        'e f g h i j k',
                        'a b c'),
               date = as.POSIXct(c('2010-01-01','2010-01-01','2012-01-01')), 
               stringsAsFactors=FALSE)
corp = quanteda::corpus(d, text_field='text')
dtm = quanteda::tokens(corp) |&gt;
  quanteda::dfm()

g = compare_documents(dtm)
g

g = compare_documents(dtm, measure = 'overlap_pct')
g
</code></pre>

<hr>
<h2 id='create_document_network'>Create a document similarity network</h2><span id='topic+create_document_network'></span>

<h3>Description</h3>

<p>Combines document similarity data (d) with document meta data (meta) into an <a href="igraph.html#topic+igraph">igraph</a> network/graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_document_network(
  d,
  meta,
  id_var = "document_id",
  date_var = "date",
  min_similarity = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_document_network_+3A_d">d</code></td>
<td>
<p>A data.frame with three columns, that represents an edgelist with weight values. 
The first and second column represent the names/ids of the 'from' and 'to' documents/vertices. 
The third column represents the similarity score. Column names are ignored</p>
</td></tr>
<tr><td><code id="create_document_network_+3A_meta">meta</code></td>
<td>
<p>A data.frame where rows are documents and columns are document meta information. 
Should at least contain 2 columns: the document name/id and date. 
The name/id column should match the document names/ids of the edgelist, and its label is specified in the 'id_var' argument. 
The date column should be intepretable with <a href="base.html#topic+as.POSIXct">as.POSIXct</a>, and its label is specified in the 'date_var' argument.</p>
</td></tr>
<tr><td><code id="create_document_network_+3A_id_var">id_var</code></td>
<td>
<p>The label for the document name/id column in the 'meta' data.frame. Default is &quot;document_id&quot;</p>
</td></tr>
<tr><td><code id="create_document_network_+3A_date_var">date_var</code></td>
<td>
<p>The label for the document date column in the 'meta' data.frame . default is &quot;date&quot;</p>
</td></tr>
<tr><td><code id="create_document_network_+3A_min_similarity">min_similarity</code></td>
<td>
<p>For convenience, ignore all edges where the weight is below 'min_similarity'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly offered to mimic the output of the <a href="#topic+as_document_network">as_document_network</a> function when using imported document similarity data.
This way the functions for transforming, aggregating and visualizing the document similarity data can be used.
</p>


<h3>Value</h3>

<p>A network/graph in the <a href="igraph.html#topic+igraph">igraph</a> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d = data.frame(x = c(1,1,1,2,2,3),
               y = c(2,3,5,4,5,6),
               v = c(0.3,0.4,0.7,0.5,0.2,0.9))

meta = data.frame(document_id = 1:8,
                  date = seq.POSIXt(from = as.POSIXct('2010-01-01 12:00:00'), 
                         by='hour', length.out = 8),
                  medium = c(rep('Newspapers', 4), rep('Blog', 4)))

g = create_document_network(d, meta)

igraph::get.data.frame(g, 'both')
igraph::plot.igraph(g)
</code></pre>

<hr>
<h2 id='create_queries'>Automatically infer queries from combinations of terms in a dtm</h2><span id='topic+create_queries'></span>

<h3>Description</h3>

<p>This function was designed for the task of matching short event descriptions to news articles, but can more generally
be used for document matching tasks. However, it should be noted that it will require exponentially more
memory for dtms with more unique terms, which is why it is less suitable for matching larger documents. This only applies to
the dtm, not the ref_dtm. Thus, if your goal is to match smaller documents such as event descriptions to news, this function
might be usefull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_queries(
  dtm,
  ref_dtm = NULL,
  min_docfreq = 2,
  max_docprob = 0.01,
  weight = c("tfidf", "binary"),
  norm_weight = c("max", "doc_max", "dtm_max", "none"),
  min_obs_exp = NA,
  union_sim_thres = NA,
  combine_all = T,
  only_dtm_combs = T,
  use_dtm_and_ref = F,
  verbose = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_queries_+3A_dtm">dtm</code></td>
<td>
<p>A quanteda <a href="quanteda.html#topic+dfm">dfm</a></p>
</td></tr>
<tr><td><code id="create_queries_+3A_ref_dtm">ref_dtm</code></td>
<td>
<p>Optionally, another quanteda <a href="quanteda.html#topic+dfm">dfm</a>. If given, the ref_dtm will be used to calculate the docfreq/docprob scores.</p>
</td></tr>
<tr><td><code id="create_queries_+3A_min_docfreq">min_docfreq</code></td>
<td>
<p>The minimum frequency for terms or combinations of terms</p>
</td></tr>
<tr><td><code id="create_queries_+3A_max_docprob">max_docprob</code></td>
<td>
<p>The maximum probability (document frequency / N) for terms or combinations of terms</p>
</td></tr>
<tr><td><code id="create_queries_+3A_weight">weight</code></td>
<td>
<p>Determine how to weight the queries (if ref_dtm is used, uses the idf of the ref_dtm, or of both the dtm and ref dtm if use_dtm_and_ref is T). 
Default is &quot;binary&quot; (does/does not occur). &quot;tfidf&quot; uses common tf-idf weighting (actually just idf, since scores are binary).</p>
</td></tr>
<tr><td><code id="create_queries_+3A_norm_weight">norm_weight</code></td>
<td>
<p>Normalize the weight score so that the highest value is 1. If &quot;max&quot; is used, max is the highest possible value. &quot;doc_max&quot; uses the highest value within each document, and &quot;dtm_max&quot; uses the highest observed value in the dtm.</p>
</td></tr>
<tr><td><code id="create_queries_+3A_min_obs_exp">min_obs_exp</code></td>
<td>
<p>The minimum ratio of the observed and expected frequency of a term combination</p>
</td></tr>
<tr><td><code id="create_queries_+3A_union_sim_thres">union_sim_thres</code></td>
<td>
<p>If given, a number between 0 and 1, used as the cosine similarity threshold for combining clusters of terms</p>
</td></tr>
<tr><td><code id="create_queries_+3A_combine_all">combine_all</code></td>
<td>
<p>If True, combine all terms. If False (default), terms that are included as unigrams (i.e. that are within the min_docfreq and max_docprob) are not combined with other terms.</p>
</td></tr>
<tr><td><code id="create_queries_+3A_only_dtm_combs">only_dtm_combs</code></td>
<td>
<p>Only include term combinations that occur in dtm. This makes sense (and saves a lot of memory) if you are only interested in assymetric similarity measures based on the query</p>
</td></tr>
<tr><td><code id="create_queries_+3A_use_dtm_and_ref">use_dtm_and_ref</code></td>
<td>
<p>if a ref_dtm is used, the weight is computed based only on the document frequencies in the ref dtm. If use_dtm_and_ref is set to TRUE, both the dtm and ref_dtm are used.</p>
</td></tr>
<tr><td><code id="create_queries_+3A_verbose">verbose</code></td>
<td>
<p>If true, report progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of the function is that it intersects the terms in a dtm based to increase sparsity. 
This can improve certain document matching tasks, but at the cost of creating a bigger dtm. 
If all terms are combined this would be a quadratic increase of columns.
However, only term combinations that occur in dtm (not ref_dtm) will be used.
This is not a problem as long as the similarity of the documents in dtm to documents in dtm_y is calculated
as an assymetric similarity measure (i.e. in which the sum of terms in dtm_y is not used). 
</p>
<p>To emphasize that this feature preparation step is geared towards the task of 'looking up' documents,
we use the terminolog of a 'query'. The output of the function is a list of two dtm: query_dtm and ref_dtm.
Both dtms have the exact same columns that contain the query terms.
The values in query_dtm are by default tfidf weighted, and the values in ref_dtm are binary.
</p>
<p>Several options are given to only create term combinations that are informative. Firstly, a minimum and maximum document frequency of term combinations can be defined. 
Secondly, a minimum observed/expected ratio can be given. The expected probability of a combination of term A and term B
is the joint probability. If the observed probability is not higher, the combination is not more informative than chance.
Thirdly, before intersecting terms, one can first cluster very similar terms together as single columns to reduce the number
of possible combinations.
</p>


<h3>Value</h3>

<p>a list with a query dtm and ref_dtm. Designed for use in <code><a href="#topic+compare_documents">compare_documents</a></code> using the special 'query_lookup' measure
</p>


<h3>Examples</h3>

<pre><code class='language-R'> q = create_queries(rnewsflow_dfm, min_docfreq = 2, union_sim_thres = 0.9, 
                    max_docprob = 0.05, verbose = FALSE)
 head(colnames(q$query_dtm),100)
</code></pre>

<hr>
<h2 id='delete_duplicates'>Delete duplicate (or similar) documents from a document term matrix</h2><span id='topic+delete_duplicates'></span>

<h3>Description</h3>

<p>Delete duplicate (or similar) documents from a document term matrix. 
Duplicates are defined by: having high content similarity, occuring within a given time distance and being published by the same source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_duplicates(
  dtm,
  date_var = NULL,
  hour_window = c(-24, 24),
  group_var = NULL,
  measure = c("cosine", "overlap_pct"),
  similarity = 1,
  keep = "first",
  tf_idf = FALSE,
  dup_csv = NULL,
  verbose = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delete_duplicates_+3A_dtm">dtm</code></td>
<td>
<p>A quanteda <a href="quanteda.html#topic+dfm">dfm</a>.</p>
</td></tr>
<tr><td><code id="delete_duplicates_+3A_date_var">date_var</code></td>
<td>
<p>The name of the column in docvars(dtm) that specifies the document date. The values should be of type POSIXlt or POSIXct</p>
</td></tr>
<tr><td><code id="delete_duplicates_+3A_hour_window">hour_window</code></td>
<td>
<p>A vector of length 2, in which the first and second value determine the left and right side of the window, respectively. For example, c(-10, 36) will compare each document to all documents between the previous 10 and the next 36 hours.</p>
</td></tr>
<tr><td><code id="delete_duplicates_+3A_group_var">group_var</code></td>
<td>
<p>Optionally,  column name in docvars(dtm) that specifies a group (e.g., source, sourcetype). If given, only documents within the same group will be compared.</p>
</td></tr>
<tr><td><code id="delete_duplicates_+3A_measure">measure</code></td>
<td>
<p>The measure that should be used to calculate similarity/distance/adjacency. Currently supports the symmetrical measure &quot;cosine&quot; (cosine similarity), and the assymetrical measures &quot;overlap_pct&quot; (percentage of term scores in the document that also occur in the other document).</p>
</td></tr>
<tr><td><code id="delete_duplicates_+3A_similarity">similarity</code></td>
<td>
<p>A threshold for similarity. Documents of which similarity is equal or higher are deleted</p>
</td></tr>
<tr><td><code id="delete_duplicates_+3A_keep">keep</code></td>
<td>
<p>A character indicating whether to keep the 'first' or 'last' published of duplicate documents.</p>
</td></tr>
<tr><td><code id="delete_duplicates_+3A_tf_idf">tf_idf</code></td>
<td>
<p>If TRUE, weight the dtm with tf_idf before comparing documents. The original (non-weighted) DTM is returned.</p>
</td></tr>
<tr><td><code id="delete_duplicates_+3A_dup_csv">dup_csv</code></td>
<td>
<p>Optionally, a path for writing a csv file with the duplicates edgelist. For each duplicate pair it is noted if &quot;from&quot; or &quot;to&quot; is the duplicate, or if &quot;both&quot; are duplicates (of other documents)</p>
</td></tr>
<tr><td><code id="delete_duplicates_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, report progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this can also be used to delete &quot;updates&quot; of articles (e.g., on news sites, news agencies). 
This should be considered if the temporal order of publications is relevant for the analysis.
</p>


<h3>Value</h3>

<p>A dtm with the duplicate documents deleted
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example with very low similarity threshold (normally not recommended!)
dtm2 = delete_duplicates(rnewsflow_dfm, similarity = 0.5, keep='first', tf_idf = TRUE)
</code></pre>

<hr>
<h2 id='directed_network_plot'>A wrapper for <a href="igraph.html#topic+plot.igraph">plot.igraph</a> for visualizing directed networks.</h2><span id='topic+directed_network_plot'></span>

<h3>Description</h3>

<p>This is a convenience function for visualizing directed networks with edge labels using <a href="igraph.html#topic+plot.igraph">plot.igraph</a>. 
It was designed specifically for visualizing aggregated document similarity networks in the RNewsflow package, but works with any network in the <a href="igraph.html#topic+igraph">igraph</a> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directed_network_plot(
  g,
  weight_var = "from.Vprop",
  weight_thres = NULL,
  delete_isolates = FALSE,
  vertex.size = 30,
  vertex.color = "lightblue",
  vertex.label.color = "black",
  vertex.label.cex = 0.7,
  edge.color = "grey",
  show.edge.labels = TRUE,
  edge.label.color = "black",
  edge.label.cex = 0.6,
  edge.arrow.size = 1,
  layout = igraph::layout.davidson.harel,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="directed_network_plot_+3A_g">g</code></td>
<td>
<p>A network/graph in the <a href="igraph.html#topic+igraph">igraph</a> class</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_weight_var">weight_var</code></td>
<td>
<p>The edge attribute that is used to specify the edges</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_weight_thres">weight_thres</code></td>
<td>
<p>A threshold for weight. Edges below the threshold are ignored</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_delete_isolates">delete_isolates</code></td>
<td>
<p>If TRUE, isolates (i.e. vertices without edges) are ignored.</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_vertex.size">vertex.size</code></td>
<td>
<p>The size of the verticex/nodes. Defaults to 30. Can be a vector with values per vertex.</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_vertex.color">vertex.color</code></td>
<td>
<p>Color of vertices/nodes. Default is lightblue. Can be a vector with values per vertex.</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_vertex.label.color">vertex.label.color</code></td>
<td>
<p>Color of labels for vertices/nodes. Defaults to black. Can be a vector with values per vertex.</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>
<p>Size of the labels for vertices/nodes. Defaults to 0.7. Can be a vector with values per vertex.</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_edge.color">edge.color</code></td>
<td>
<p>Color of the edges. Defaults to grey. Can be a vector with values per edge.</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_show.edge.labels">show.edge.labels</code></td>
<td>
<p>Logical. Should edge labels be displayed? Default is TRUE.</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_edge.label.color">edge.label.color</code></td>
<td>
<p>Color of the edge labels. Defaults to black. Can be a vector with values per edge.</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_edge.label.cex">edge.label.cex</code></td>
<td>
<p>Size of the edge labels. Defaults to 0.6. Can be a vector with values per edge.</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_edge.arrow.size">edge.arrow.size</code></td>
<td>
<p>Size of the edge arrows. Defaults to 1. Can only be set globally (igraph might update this at some point)</p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_layout">layout</code></td>
<td>
<p>The igraph layout used to plot the network. Defaults to <a href="igraph.html#topic+layout.davidson.harel">layout.davidson.harel</a></p>
</td></tr>
<tr><td><code id="directed_network_plot_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the <a href="igraph.html#topic+plot.igraph">plot.igraph</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(docnet)
aggdocnet = network_aggregate(docnet, by='source')
directed_network_plot(aggdocnet, weight_var = 'to.Vprop', weight_thres = 0.2)
</code></pre>

<hr>
<h2 id='docnet'>Document similarity network for one news agency, and the print and online editions of two newspapers</h2><span id='topic+docnet'></span>

<h3>Description</h3>

<p>Document similarity network for one news agency, and the print and online editions of two newspapers
</p>


<h3>Format</h3>

<p>docnet: A network/graph in the <a href="igraph.html#topic+igraph">igraph</a> class as created with <a href="#topic+create_document_network">create_document_network</a> or <a href="#topic+newsflow_compare">newsflow_compare</a>.
</p>

<hr>
<h2 id='document_network_plot'>Visualize (a subcomponent) of the document similarity network</h2><span id='topic+document_network_plot'></span>

<h3>Description</h3>

<p>Visualize (a subcomponent) of the document similarity network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>document_network_plot(
  g,
  date_attribute = "date",
  source_attribute = "source",
  subcomp_i = NULL,
  dtm = NULL,
  sources = NULL,
  only_outer_date = FALSE,
  date_format = "%Y-%m-%d %H:%M",
  margins = c(5, 8, 1, 13),
  isolate_color = NULL,
  source_loops = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="document_network_plot_+3A_g">g</code></td>
<td>
<p>A document similarity network, as created with <a href="#topic+newsflow_compare">newsflow_compare</a> or <a href="#topic+create_document_network">create_document_network</a></p>
</td></tr>
<tr><td><code id="document_network_plot_+3A_date_attribute">date_attribute</code></td>
<td>
<p>The label of the vertex/document date attribute. Default is &quot;date&quot;</p>
</td></tr>
<tr><td><code id="document_network_plot_+3A_source_attribute">source_attribute</code></td>
<td>
<p>The label of the vertex/document source attribute. Default is &quot;source&quot;</p>
</td></tr>
<tr><td><code id="document_network_plot_+3A_subcomp_i">subcomp_i</code></td>
<td>
<p>Optional. If an integer is given, the network is decomposed into subcomponents (i.e. unconnected components) and only the i-th component is visualized.</p>
</td></tr>
<tr><td><code id="document_network_plot_+3A_dtm">dtm</code></td>
<td>
<p>Optional. If a document-term matrix that contains the documents in g is given, a wordcloud with the most common words of the network is added.</p>
</td></tr>
<tr><td><code id="document_network_plot_+3A_sources">sources</code></td>
<td>
<p>Optional. Use a character vector to select only certain sources</p>
</td></tr>
<tr><td><code id="document_network_plot_+3A_only_outer_date">only_outer_date</code></td>
<td>
<p>If TRUE, only the labels for the first and last date are reported on the x-axis</p>
</td></tr>
<tr><td><code id="document_network_plot_+3A_date_format">date_format</code></td>
<td>
<p>The date format of the date labels (see <a href="base.html#topic+format.POSIXct">format.POSIXct</a>)</p>
</td></tr>
<tr><td><code id="document_network_plot_+3A_margins">margins</code></td>
<td>
<p>The margins of the network plot. The four values represent bottom, left, top and right margin.</p>
</td></tr>
<tr><td><code id="document_network_plot_+3A_isolate_color">isolate_color</code></td>
<td>
<p>Optional. Set a custom color for isolates</p>
</td></tr>
<tr><td><code id="document_network_plot_+3A_source_loops">source_loops</code></td>
<td>
<p>If set to FALSE, all edges between vertices/documents of the same source are ignored.</p>
</td></tr>
<tr><td><code id="document_network_plot_+3A_...">...</code></td>
<td>
<p>Additional arguments for the network plotting function <a href="igraph.html#topic+plot.igraph">plot.igraph</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>docnet = docnet
dtm = rnewsflow_dfm

docnet_comps = igraph::decompose.graph(docnet) # get subcomponents

# subcomponent 1
document_network_plot(docnet_comps[[1]]) 

# subcomponent 2 with wordcloud
document_network_plot(docnet_comps[[2]], dtm=dtm) 

# subcomponent 3 with additional arguments passed to plot.igraph 
document_network_plot(docnet_comps[[3]], dtm=dtm, vertex.color='red') 
</code></pre>

<hr>
<h2 id='filter_window'>Filter edges from the document similarity network based on hour difference</h2><span id='topic+filter_window'></span>

<h3>Description</h3>

<p>The 'filter_window' function can be used to filter the document pairs (i.e. edges) using the 'hour_window' parameter, which works identical to the 'hour_window' parameter in the 'newsflow_compare' function. 
In addition, the 'from_vertices' and 'to_vertices' parameters can be used to select the vertices (i.e. documents) for which this filter is applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_window(g, hour_window, to_vertices = NULL, from_vertices = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_window_+3A_g">g</code></td>
<td>
<p>A document similarity network, as created with <a href="#topic+newsflow_compare">newsflow_compare</a> or <a href="#topic+create_document_network">create_document_network</a></p>
</td></tr>
<tr><td><code id="filter_window_+3A_hour_window">hour_window</code></td>
<td>
<p>A vector of length 2, in which the first and second value determine the left and right side of the window, respectively. For example, c(-10, 36) will compare each document to all documents between the previous 10 and the next 36 hours.</p>
</td></tr>
<tr><td><code id="filter_window_+3A_to_vertices">to_vertices</code></td>
<td>
<p>A filter to select the vertices 'to' which an edge is filtered. 
For example, if 'V(g)$sourcetype == &quot;newspaper&quot;' is used, then the hour_window filter is only applied for edges 'to' newspaper documents (specifically, where the sourcetype attribute is &quot;newspaper&quot;).</p>
</td></tr>
<tr><td><code id="filter_window_+3A_from_vertices">from_vertices</code></td>
<td>
<p>A filter to select the vertices 'from' which an edge is filtered. 
Works identical to 'to_vertices'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to use the <a href="#topic+show_window">show_window</a> function to verify whether the hour windows are correct according to the assumptions and focus of the study.
</p>


<h3>Value</h3>

<p>A network/graph in the <a href="igraph.html#topic+igraph">igraph</a> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(docnet)
show_window(docnet, to_attribute = 'source') # before filtering

docnet = filter_window(docnet, hour_window = c(0.1,24))

docnet = filter_window(docnet, hour_window = c(6,36), 
                       to_vertices = V(docnet)$sourcetype == 'Print NP')

show_window(docnet, to_attribute = 'sourcetype') # after filtering per sourcetype
show_window(docnet, to_attribute = 'source') # after filtering per source
</code></pre>

<hr>
<h2 id='get_doc_terms'>View term scores for a given document</h2><span id='topic+get_doc_terms'></span>

<h3>Description</h3>

<p>View term scores for a given document
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_doc_terms(dtm, docname = NULL, doc_i = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_doc_terms_+3A_dtm">dtm</code></td>
<td>
<p>A quanteda dfm</p>
</td></tr>
<tr><td><code id="get_doc_terms_+3A_docname">docname</code></td>
<td>
<p>name of document to select</p>
</td></tr>
<tr><td><code id="get_doc_terms_+3A_doc_i">doc_i</code></td>
<td>
<p>alternatively, select document by index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with terms (names) and scores
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_doc_terms(rnewsflow_dfm, doc_i=1)
</code></pre>

<hr>
<h2 id='get_overlap_terms'>View overlapping terms for a given pair of documents</h2><span id='topic+get_overlap_terms'></span>

<h3>Description</h3>

<p>View overlapping terms for a given pair of documents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_overlap_terms(dtm, doc.x, doc.y, dtm.y = dtm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_overlap_terms_+3A_dtm">dtm</code></td>
<td>
<p>A quanteda dfm</p>
</td></tr>
<tr><td><code id="get_overlap_terms_+3A_doc.x">doc.x</code></td>
<td>
<p>The name of the first document in dtm</p>
</td></tr>
<tr><td><code id="get_overlap_terms_+3A_doc.y">doc.y</code></td>
<td>
<p>The name of the second document in dtm (or dtm.y)</p>
</td></tr>
<tr><td><code id="get_overlap_terms_+3A_dtm.y">dtm.y</code></td>
<td>
<p>Optionally, a second dtm (for when the documents occur in separate dtm's)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_overlap_terms(rnewsflow_dfm, 
                  quanteda::docnames(rnewsflow_dfm)[1],
                  quanteda::docnames(rnewsflow_dfm)[5])
</code></pre>

<hr>
<h2 id='hourdiff_range_thresholds'>Inspect effects of thresholds on matches over time</h2><span id='topic+hourdiff_range_thresholds'></span>

<h3>Description</h3>

<p>If it can be assumed that matches should only occur within a given time range (e.g., event data should match news items after the event occured)
a low effort validation can be obtained by looking at whether the matches only occur within this time range. 
This function plots the percentage of matches within a given time range (hourdiff) for different thresholds of the weight column.
This can be used to determine a good threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hourdiff_range_thresholds(
  g,
  breaks = 20,
  hourdiff_range = c(0, Inf),
  min_weight = NA,
  min_hourdiff = NA,
  max_hourdiff = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hourdiff_range_thresholds_+3A_g">g</code></td>
<td>
<p>The output of newsflow.compare (either as &quot;igraph&quot; or &quot;edgelist&quot;)</p>
</td></tr>
<tr><td><code id="hourdiff_range_thresholds_+3A_breaks">breaks</code></td>
<td>
<p>The number of breaks for the weight threshold</p>
</td></tr>
<tr><td><code id="hourdiff_range_thresholds_+3A_hourdiff_range">hourdiff_range</code></td>
<td>
<p>The time period (hourdiff range) in which the match 'should' occur.</p>
</td></tr>
<tr><td><code id="hourdiff_range_thresholds_+3A_min_weight">min_weight</code></td>
<td>
<p>Optionally, filter out all value below the given weight</p>
</td></tr>
<tr><td><code id="hourdiff_range_thresholds_+3A_min_hourdiff">min_hourdiff</code></td>
<td>
<p>the lowest possible hourdiff value. This is used to estimate noise. If not specified, will be estimated based on data.</p>
</td></tr>
<tr><td><code id="hourdiff_range_thresholds_+3A_max_hourdiff">max_hourdiff</code></td>
<td>
<p>the highest possible hourdiff value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing... just plots
</p>

<hr>
<h2 id='network_aggregate'>Aggregate the edges of a network by vertex attributes</h2><span id='topic+network_aggregate'></span>

<h3>Description</h3>

<p>This function offers a versatile way to aggregate the edges of a network based on the vertex attributes.
Although it was designed specifically for document similarity networks, it can be used for any network in the <a href="igraph.html#topic+igraph">igraph</a> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_aggregate(
  g,
  by = NULL,
  by_from = by,
  by_to = by,
  edge_attribute = "weight",
  agg_FUN = mean,
  return_df = FALSE,
  keep_isolates = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="network_aggregate_+3A_g">g</code></td>
<td>
<p>A network/graph in the <a href="igraph.html#topic+igraph">igraph</a> class</p>
</td></tr>
<tr><td><code id="network_aggregate_+3A_by">by</code></td>
<td>
<p>A character string indicating the vertex attributes by which the edges will be aggregated.</p>
</td></tr>
<tr><td><code id="network_aggregate_+3A_by_from">by_from</code></td>
<td>
<p>Optionally, specify different vertex attributes to aggregate the 'from' side of edges</p>
</td></tr>
<tr><td><code id="network_aggregate_+3A_by_to">by_to</code></td>
<td>
<p>Optionally, specify different vertex attributes to aggregate the 'to' side of edges</p>
</td></tr>
<tr><td><code id="network_aggregate_+3A_edge_attribute">edge_attribute</code></td>
<td>
<p>Select an edge attribute to aggregate using the function specified in &lsquo;agg_FUN'. Defaults to &rsquo;weight'</p>
</td></tr>
<tr><td><code id="network_aggregate_+3A_agg_fun">agg_FUN</code></td>
<td>
<p>The function used to aggregate the edge attribute</p>
</td></tr>
<tr><td><code id="network_aggregate_+3A_return_df">return_df</code></td>
<td>
<p>Optional. If TRUE, the results are returned as a data.frame. This can in particular be convenient if by_from and by_to are used.</p>
</td></tr>
<tr><td><code id="network_aggregate_+3A_keep_isolates">keep_isolates</code></td>
<td>
<p>if True, also return scores for isolates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument is the network (in the 'igraph' class). 
The second argument, for the 'by' parameter, is a character vector to indicate one or more vertex attributes based on which the edges are aggregated.
Optionally, the 'by' parameter can also be specified separately for 'by_from' and 'by_to'. 
</p>
<p>By default, the function returns the aggregated network as an <a href="igraph.html#topic+igraph">igraph</a> class.
The edges in the aggregated network have five standard attributes. 
The 'edges' attribute counts the number of edges from the 'from' group to the 'to' group. 
The 'from.V' attribute shows the number of vertices in the 'from' group that matched with a vertex in the 'to' group.
The 'from.Vprop attribute shows this as the proportion of all vertices in the 'from' group.
The 'to.V' and 'to.Vprop' attributes show the same for the 'to' group.
</p>
<p>In addition, one of the edge attributes of the original network can be aggregated with a given function.
These are specified in the 'edge_attribute' and 'agg_FUN' parameters.
</p>


<h3>Value</h3>

<p>A network/graph in the <a href="igraph.html#topic+igraph">igraph</a> class, or a data.frame if return_df is TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(docnet)
aggdocnet = network_aggregate(docnet, by='sourcetype')
igraph::get.data.frame(aggdocnet, 'both')

aggdocdf = network_aggregate(docnet, by_from='sourcetype', by_to='source', return_df = TRUE)
head(aggdocdf)
</code></pre>

<hr>
<h2 id='newsflow_compare'>Create a network of document similarities over time</h2><span id='topic+newsflow_compare'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code><a href="#topic+compare_documents">compare_documents</a></code> function, specialised for the case of analyzing documents over time.
The difference is that using date_var is mandatory, and the output is returned as an igraph network (using <code><a href="#topic+as_document_network">as_document_network</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newsflow_compare(
  dtm,
  dtm_y = NULL,
  date_var = "date",
  hour_window = c(-24, 24),
  group_var = NULL,
  measure = c("cosine", "overlap_pct", "overlap", "dot_product", "softcosine"),
  tf_idf = F,
  min_similarity = 0,
  n_topsim = NULL,
  only_complete_window = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newsflow_compare_+3A_dtm">dtm</code></td>
<td>
<p>A quanteda <a href="quanteda.html#topic+dfm">dfm</a>. Note that it is common to first weight the dtm(s) before calculating document similarity,
For this you can use quanteda's <a href="quanteda.html#topic+dfm_tfidf">dfm_tfidf</a> and <a href="quanteda.html#topic+dfm_weight">dfm_weight</a></p>
</td></tr>
<tr><td><code id="newsflow_compare_+3A_dtm_y">dtm_y</code></td>
<td>
<p>Optionally, another dtm. If given, the documents in dtm will be compared to the documents in dtm_y.</p>
</td></tr>
<tr><td><code id="newsflow_compare_+3A_date_var">date_var</code></td>
<td>
<p>The name of the column in meta that specifies the document date. default is &quot;date&quot;. The values should be of type POSIXct, or coercable with as.POSIXct.
If given, the hour_window argument is used to only compare documents within a time window.</p>
</td></tr>
<tr><td><code id="newsflow_compare_+3A_hour_window">hour_window</code></td>
<td>
<p>A vector of length 2, in which the first and second value determine the left and right side of the window, respectively. 
For example, c(-10, 36) will compare each document to all documents between the previous 10 and the next 36 hours.
It is possible to specify time windows down to the level of seconds by using fractions (hours / 60 / 60).</p>
</td></tr>
<tr><td><code id="newsflow_compare_+3A_group_var">group_var</code></td>
<td>
<p>Optionally,  The name of the column in meta that specifies a group (e.g., source, sourcetype). If given, only documents within the same group will be compared.</p>
</td></tr>
<tr><td><code id="newsflow_compare_+3A_measure">measure</code></td>
<td>
<p>The measure that should be used to calculate similarity/distance/adjacency. Currently supports the symmetrical measure &quot;cosine&quot; (cosine similarity), the assymetrical measures &quot;overlap_pct&quot; (percentage of term scores in the document 
that also occur in the other document), &quot;overlap&quot; (like overlap_pct, but as the sum of overlap instead of the percentage) and the symmetrical soft cosine measure (experimental).
The regular dot product (dot_product) is also supported.</p>
</td></tr>
<tr><td><code id="newsflow_compare_+3A_tf_idf">tf_idf</code></td>
<td>
<p>If TRUE, weigh the dtm (and dtm_y) by term frequency - inverse document frequency. For more control over weighting,
we recommend using quanteda's <a href="quanteda.html#topic+dfm_tfidf">dfm_tfidf</a> or <a href="quanteda.html#topic+dfm_weight">dfm_weight</a> on dtm and dtm_y.</p>
</td></tr>
<tr><td><code id="newsflow_compare_+3A_min_similarity">min_similarity</code></td>
<td>
<p>A threshold for similarity. lower values are deleted. For all available similarity measures zero means no similarity.</p>
</td></tr>
<tr><td><code id="newsflow_compare_+3A_n_topsim">n_topsim</code></td>
<td>
<p>An alternative or additional sort of threshold for similarity. Only keep the [n_topsim] highest similarity scores for x. Can return more than [n_topsim] similarity scores in the case of duplicate similarities.</p>
</td></tr>
<tr><td><code id="newsflow_compare_+3A_only_complete_window">only_complete_window</code></td>
<td>
<p>If True, only compare articles (x) of which a full window of reference articles (y) is available. Thus, for the first and last [window.size] days, there will be no results for x.</p>
</td></tr>
<tr><td><code id="newsflow_compare_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+compare_documents">compare_documents</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm = quanteda::dfm_tfidf(rnewsflow_dfm)
el = newsflow_compare(dtm, date_var='date', hour_window = c(0.1, 36))
</code></pre>

<hr>
<h2 id='only_first_match'>Transform document network so that each document only matches the earliest dated matching document</h2><span id='topic+only_first_match'></span>

<h3>Description</h3>

<p>Transforms the network so that a document only has an edge to the earliest dated document it matches within the specified time window[^duplicate].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>only_first_match(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="only_first_match_+3A_g">g</code></td>
<td>
<p>A document similarity network, as created with <a href="#topic+newsflow_compare">newsflow_compare</a> or <a href="#topic+create_document_network">create_document_network</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are multiple earliest dated documents (that is, having the same publication date) then edges to all earliest dated documents are kept.
</p>


<h3>Value</h3>

<p>A network/graph in the <a href="igraph.html#topic+igraph">igraph</a> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(docnet)

subcomp1 = igraph::decompose.graph(docnet)[[2]]
subcomp2 = only_first_match(subcomp1)

igraph::get.data.frame(subcomp1)
igraph::get.data.frame(subcomp2)

graphics::par(mfrow=c(2,1))
document_network_plot(subcomp1, main='All matches')
document_network_plot(subcomp2, main='Only first match')
graphics::par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='rnewsflow_dfm'>quanteda dfm for RNewsflow vignette demo</h2><span id='topic+rnewsflow_dfm'></span>

<h3>Description</h3>

<p>quanteda dfm for RNewsflow vignette demo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnewsflow_dfm
</code></pre>


<h3>Format</h3>

<p>dfm
</p>

<hr>
<h2 id='show_window'>Show time window of document pairs</h2><span id='topic+show_window'></span>

<h3>Description</h3>

<p>This function aggregates the edges for all combinations of attributes specified in 'from_attribute' and 'to_attribute', and shows the minimum and maximum hour difference for each combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_window(g, to_attribute = NULL, from_attribute = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_window_+3A_g">g</code></td>
<td>
<p>A document similarity network, as created with <a href="#topic+newsflow_compare">newsflow_compare</a> or <a href="#topic+create_document_network">create_document_network</a></p>
</td></tr>
<tr><td><code id="show_window_+3A_to_attribute">to_attribute</code></td>
<td>
<p>The vertex attribute to aggregate the 'to' group of the edges</p>
</td></tr>
<tr><td><code id="show_window_+3A_from_attribute">from_attribute</code></td>
<td>
<p>The vertex attribute to aggregate the 'from' group of the edges</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="#topic+filter_window">filter_window</a> function can be used to filter edges that fall outside of the intended time window.
</p>


<h3>Value</h3>

<p>A data.frame showing the left and right edges of the window for each unique group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(docnet)
show_window(docnet, to_attribute = 'source')
show_window(docnet, to_attribute = 'sourcetype')
show_window(docnet, to_attribute = 'sourcetype', from_attribute = 'sourcetype')
</code></pre>

<hr>
<h2 id='tcrossprod_sparse'>tcrossprod with benefits, for people that like parameters</h2><span id='topic+tcrossprod_sparse'></span>

<h3>Description</h3>

<p>This function (including the underlying cpp function batched_tcrossprod_cpp) 
is the workhorse of the RNewsflow package. It has unnervingly many arguments for a tcrossprod because it needs to be able to do many thing efficiently.
While its mostly a backend function, we expose it because it has applications outside of RNewsflow, but we make no excuses for the fact that readability is very
much sacrificed here for the convenience of being able to keep adding features that we need for RNewsflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcrossprod_sparse(
  m,
  m2 = NULL,
  min_value = NULL,
  max_value = NULL,
  only_upper = F,
  diag = T,
  top_n = NULL,
  rowsum_div = F,
  max_p = 1,
  pvalue = c("disparity", "normal", "lognormal", "nz_normal", "nz_lognormal"),
  normalize = c("none", "l2", "softl2"),
  crossfun = c("prod", "min", "softprod", "maxproduct", "lookup", "cp_lookup",
    "cp_lookup_norm"),
  group = NULL,
  group2 = NULL,
  date = NULL,
  date2 = NULL,
  lwindow = -1,
  rwindow = 1,
  date_unit = c("days", "hours", "minutes", "seconds"),
  simmat = NULL,
  simmat_thres = NULL,
  row_attr = F,
  col_attr = F,
  lag_attr = F,
  batchsize = 1000,
  verbose = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tcrossprod_sparse_+3A_m">m</code></td>
<td>
<p>A CsparseMatrix</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_m2">m2</code></td>
<td>
<p>A CsparseMatrix</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_min_value">min_value</code></td>
<td>
<p>Optionally, a numerical value, specifying the threshold for including a score in the output.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_max_value">max_value</code></td>
<td>
<p>Optionally, a numerical value for the upper limit for including a score in the output.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_only_upper">only_upper</code></td>
<td>
<p>If true, only the upper triangle of the matrix is returned. Only possible for symmetrical output (m and m2 have same number of columns)</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_diag">diag</code></td>
<td>
<p>If false, the diagonal of the matrix is not returned. Only possible for symmetrical output (m and m2 have same number of columns)</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_top_n">top_n</code></td>
<td>
<p>An integer, specifying the top number of strongest similarities per row. So, for each row in m at most top_n scores are returned..</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_rowsum_div">rowsum_div</code></td>
<td>
<p>If true, divide crossproduct by column sums of m. (this has to happen within the loop for min_value and top_n filtering).</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_max_p">max_p</code></td>
<td>
<p>A threshold for maximium p value.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_pvalue">pvalue</code></td>
<td>
<p>If max_p &lt; 1, edges are removed based on a p value. For each document in dtm, a p value is calculated over its outward edges. 
Default is the p-value based on uniform distribution, akin to a &quot;disparity&quot; filter (see Serrano et al., DOI: 10.1073/pnas.0808904106) but without filtering on inward edges.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_normalize">normalize</code></td>
<td>
<p>Normalize rows by a given norm score (before calculating similarity). Default is 'none' (no normalization). 'l2' is the l2 norm (use in combination with 'prod' crossfun for cosine similarity). 
'l2soft' is the adaptation of l2 for soft similarity (use in combination with 'softprod' crossfun for soft cosine).</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_crossfun">crossfun</code></td>
<td>
<p>The function used in the vector operations. 
Normally this is the &quot;prod&quot;, for product (dot product). 
Here we also allow the &quot;min&quot;, for minimum value. 
We use this in our document overlap_pct score.
In addition, there is the (experimental) softprod, that can be used in combination with softl2 normalization to get the soft cosine similarity.
The &quot;maxproduct&quot; is a special case used in the query_lookup measure, that uses product but only returns the score of the strongest matching term. 
The &quot;cp_lookup&quot; and &quot;cp_lookup_norm&quot; are special cases for conditional probability sensitive lookup.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_group">group</code></td>
<td>
<p>Optionally, a character vector that specifies a group (e.g., source) for each row in m. If given, only pairs of rows with the same group are calculated.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_group2">group2</code></td>
<td>
<p>If m2 and group are used, group2 has to be used to specify the groups for the rows in m2 (otherwise group will be ignored)</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_date">date</code></td>
<td>
<p>Optionally, a POSIXct vector (or a vector that can be converted to as.POSIXct) that specifies a date for each row in m. If given, only pairs of rows within a given date range (see lwindow, rwindow and date_unit) are calculated.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_date2">date2</code></td>
<td>
<p>If m2 and date are used, date2 has to be used to specify the date for the rows in m2 (otherwise date will be ignored)</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_lwindow">lwindow</code></td>
<td>
<p>If date (and date2) are used, lwindow determines the left side of the date window. e.g. -10 means that rows are only matched with rows for which date is within 10 [date_units] before.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_rwindow">rwindow</code></td>
<td>
<p>Like lwindow, but for the right side. e.g. an lwindow of -1 and rwindow of 1, with date_unit is &quot;days&quot;, means that only rows are matched for which the dates are within a 1 day distance</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_date_unit">date_unit</code></td>
<td>
<p>The date unit used in lwindow and rwindow. Supports &quot;days&quot;, &quot;hours&quot;, &quot;minutes&quot; and &quot;seconds&quot;. Note that refers to the time distance between two rows (&quot;days&quot; doesn't refer to calendar days, but to a time of 24 hours)</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_simmat">simmat</code></td>
<td>
<p>If softcos is used, a symmetric matrix with terms that indicates the similarity of terms (i.e. adjacency matrix). If NULL, a cosine similarity matrix will be created on the go</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_simmat_thres">simmat_thres</code></td>
<td>
<p>If softcos is used, a threshold for the term similarity.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_row_attr">row_attr</code></td>
<td>
<p>If TRUE, add the &quot;row_n&quot; and &quot;row_sum&quot; elements to the &quot;margin&quot; attribute.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_col_attr">col_attr</code></td>
<td>
<p>Like row_attr, but adding &quot;col_n&quot; and &quot;col_sum&quot; to the &quot;margin&quot; attribute.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_lag_attr">lag_attr</code></td>
<td>
<p>If TRUE, adds &quot;lag_n&quot; and &quot;lag_sum&quot; to the &quot;margin&quot; attribute. These are the margin scores for rows, 
where the date of the column is before (lag) the date of the row. Only possible if date argument is given.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_batchsize">batchsize</code></td>
<td>
<p>If group and/or date are used, size of batches.</p>
</td></tr>
<tr><td><code id="tcrossprod_sparse_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, report progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Enables limiting row combinations to within specified groups 
and date windows, and filters results that do not pass the threshold on the fly.
To achieve this, options for similarity measures are included in the function.
For example, to get the cosine similarity, you can normalize with &quot;l2&quot; and use the &quot;prod&quot; (product) function for the   
</p>
<p>This function is called by the document comparison functions (newsflow_compare, delete_duplicates).
We only expose it here for additional flexibility, and because it could be usefull outside of the purpose of this package. 
</p>
<p>The output matrix also has an attribute &quot;margin&quot;, which contains margin scores (e.g., row_sum) if the row_attr or col_attr arguments are used.
The reason for including this is that some values that are normally available in the output of a cross product are broken if certain filter options are used.
If group or date is used, we don't know how many columns a rows has been compared to (normally this is all columns).
If a min/max or top_n filter is used, we don't know the true row sums (and thus row means).
</p>


<h3>Value</h3>

<p>A CsparseMatrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
m = Matrix::rsparsematrix(5,10,0.5)
tcrossprod_sparse(m, min_value = 0, only_upper = FALSE, diag = TRUE)
tcrossprod_sparse(m, min_value = 0, only_upper = FALSE, diag = FALSE)
tcrossprod_sparse(m, min_value = 0, only_upper = TRUE, diag = FALSE)
tcrossprod_sparse(m, min_value = 0.2, only_upper = TRUE, diag = FALSE)
tcrossprod_sparse(m, min_value = 0, only_upper = TRUE, diag = FALSE, top_n = 1)
</code></pre>

<hr>
<h2 id='term_char_sim'>Find terms with similar spelling</h2><span id='topic+term_char_sim'></span>

<h3>Description</h3>

<p>A quick, language agnostic way for finding terms with similar spelling. 
Calculates similarity as percentage of a terms bigram's or trigram's that also occur in the other term. 
The percentage has to be above the given threshold for both terms (unless allow_asym = T)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term_char_sim(
  voc,
  type = c("tri", "bi"),
  min_overlap = 2/3,
  max_diff = 4,
  pad = F,
  as_lower = T,
  same_start = 1,
  drop_non_alpha = T,
  min_length = 5,
  allow_asym = F,
  verbose = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="term_char_sim_+3A_voc">voc</code></td>
<td>
<p>A character vector that gives the vocabulary (e.g., colnames of a dtm)</p>
</td></tr>
<tr><td><code id="term_char_sim_+3A_type">type</code></td>
<td>
<p>Either &quot;bi&quot; (bigrams) or &quot;tri&quot; (trigrams)</p>
</td></tr>
<tr><td><code id="term_char_sim_+3A_min_overlap">min_overlap</code></td>
<td>
<p>The minimal overlap percentage. Works together with max_diff to determine required overlap</p>
</td></tr>
<tr><td><code id="term_char_sim_+3A_max_diff">max_diff</code></td>
<td>
<p>The maximum number of bi/tri-grams that is different</p>
</td></tr>
<tr><td><code id="term_char_sim_+3A_pad">pad</code></td>
<td>
<p>If True, pad the left size (ls) and right side (rs) of bi/tri-grams. So, trigrams for &quot;pad&quot; would be: &quot;ls_ls_p&quot;, &quot;ls_p_a&quot;, &quot;p_a_d&quot;, &quot;a_d_rs&quot;, &quot;d_rs_rs&quot;.</p>
</td></tr>
<tr><td><code id="term_char_sim_+3A_as_lower">as_lower</code></td>
<td>
<p>If True, ignore case</p>
</td></tr>
<tr><td><code id="term_char_sim_+3A_same_start">same_start</code></td>
<td>
<p>Should terms start with the same character(s)? Given as a number for the number of same characters. (also greatly speeds up calculation)</p>
</td></tr>
<tr><td><code id="term_char_sim_+3A_drop_non_alpha">drop_non_alpha</code></td>
<td>
<p>If True, ignore non alpha terms (e.g., numbers, punctuation). They will appear in the output matrix, but only with zeros.</p>
</td></tr>
<tr><td><code id="term_char_sim_+3A_min_length">min_length</code></td>
<td>
<p>The minimum number of characters in a term. Terms with fewer characters are ignored. They will appear in the output matrix, but only with zeros.</p>
</td></tr>
<tr><td><code id="term_char_sim_+3A_allow_asym">allow_asym</code></td>
<td>
<p>If True, the match only needs to be true for at least one term. In practice, this means that &quot;America&quot; would match perfectly with &quot;Southern-America&quot;.</p>
</td></tr>
<tr><td><code id="term_char_sim_+3A_verbose">verbose</code></td>
<td>
<p>If True, report progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A similarity matrix in the CsparseMatrix format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dfm = quanteda::tokens(c('That guy Gadaffi','Do you mean Kadaffi?',
                         'Nah more like Gadaffel','What Gargamel?')) |&gt;
  quanteda::dfm()
simmat = term_char_sim(colnames(dfm), same_start=0)
term_union(dfm, simmat, verbose = FALSE)
</code></pre>

<hr>
<h2 id='term_day_dist'>Calculate statistics for term occurence across days</h2><span id='topic+term_day_dist'></span>

<h3>Description</h3>

<p>Calculate statistics for term occurence across days
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term_day_dist(dtm, meta = NULL, date.var = "date")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="term_day_dist_+3A_dtm">dtm</code></td>
<td>
<p>A quanteda <a href="quanteda.html#topic+dfm">dfm</a>. Alternatively, a DocumentTermMatrix from the tm package can be used, but then the meta parameter needs to be specified manually</p>
</td></tr>
<tr><td><code id="term_day_dist_+3A_meta">meta</code></td>
<td>
<p>If dtm is a quanteda dfm, docvars(meta) is used by default (meta is NULL) to obtain the meta data. Otherwise, the meta data.frame has to be given by the user, with the rows of the meta data.frame matching the rows of the dtm (i.e. each row is a document)</p>
</td></tr>
<tr><td><code id="term_day_dist_+3A_date.var">date.var</code></td>
<td>
<p>The name of the meta column specifying the document date. default is &quot;date&quot;. The values should be of type POSIXlt or POSIXct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with statistics for each term.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tdd = term_day_dist(rnewsflow_dfm, date.var='date')
head(tdd)
tail(tdd)
</code></pre>

<hr>
<h2 id='term_innovation'>Experimental: Convert dtm scores to a term innovation score, based on changes in term use over time</h2><span id='topic+term_innovation'></span>

<h3>Description</h3>

<p>For each term in m, the usage before and after the document date is compared (with a chi2 test) to see whether usage increased.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term_innovation(
  m,
  date,
  m2 = NULL,
  date2 = NULL,
  lwindow = -7,
  rwindow = 7,
  date_unit = c("days", "hours", "minutes", "seconds"),
  min_chi = 5.024,
  min_ratio = 2,
  smooth = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="term_innovation_+3A_m">m</code></td>
<td>
<p>A CsparseMatrix</p>
</td></tr>
<tr><td><code id="term_innovation_+3A_date">date</code></td>
<td>
<p>a character vector that specifies a date for each row in m. If given, only pairs of rows within a given date range (see lwindow, rwindow and date_unit) are calculated.</p>
</td></tr>
<tr><td><code id="term_innovation_+3A_m2">m2</code></td>
<td>
<p>Optionally, use a different matrix for calculating the innovation scores. For example, if m is a DTM of press releases, m2 can be a DTM of news articles, to see if term usage increased in the news after the press release.</p>
</td></tr>
<tr><td><code id="term_innovation_+3A_date2">date2</code></td>
<td>
<p>If m2 is used, date2 has to be used to specify the date for the rows in m2 (otherwise date will be ignored)</p>
</td></tr>
<tr><td><code id="term_innovation_+3A_lwindow">lwindow</code></td>
<td>
<p>If date (and date2) are used, lwindow determines the left side of the date window. e.g. -10 means that rows are only matched with rows for which date is within 10 [date_units] before.</p>
</td></tr>
<tr><td><code id="term_innovation_+3A_rwindow">rwindow</code></td>
<td>
<p>Like lwindow, but for the right side. e.g. an lwindow of -1 and rwindow of 1, with date_unit is &quot;days&quot;, means that only rows are matched for which the dates are within a 1 day distance</p>
</td></tr>
<tr><td><code id="term_innovation_+3A_date_unit">date_unit</code></td>
<td>
<p>The date unit used in lwindow and rwindow. Supports &quot;days&quot;, &quot;hours&quot;, &quot;minutes&quot; and &quot;seconds&quot;. Note that refers to the time distance between two rows (&quot;days&quot; doesn't refer to calendar days, but to a time of 24 hours)</p>
</td></tr>
<tr><td><code id="term_innovation_+3A_min_chi">min_chi</code></td>
<td>
<p>The minimum chi-square value</p>
</td></tr>
<tr><td><code id="term_innovation_+3A_min_ratio">min_ratio</code></td>
<td>
<p>The minimum ratio (rwindow score / lwindow score)</p>
</td></tr>
<tr><td><code id="term_innovation_+3A_smooth">smooth</code></td>
<td>
<p>The smoothing factor (prevents -Inf/Inf ratio)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A CsparseMatrix
</p>

<hr>
<h2 id='term_intersect'>Combine terms in a dtm</h2><span id='topic+term_intersect'></span>

<h3>Description</h3>

<p>Given a dtm and a similarity (adjacency) matrix, create a new column for each nonzero cell in the
similarity matrix. For the term combinations  (everything except the diagonal) the column names will be
pasted together with a &quot;&amp;&quot; separator (read as AND)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term_intersect(dtm, simmat, as_dfm = T, verbose = F, sep = " &amp; ", par = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="term_intersect_+3A_dtm">dtm</code></td>
<td>
<p>A quanteda <a href="quanteda.html#topic+dfm">dfm</a> or a CsparseMatrix.</p>
</td></tr>
<tr><td><code id="term_intersect_+3A_simmat">simmat</code></td>
<td>
<p>A similarity matrix in CsparseMatrix format. For instance, created with <a href="#topic+term_char_sim">term_char_sim</a></p>
</td></tr>
<tr><td><code id="term_intersect_+3A_as_dfm">as_dfm</code></td>
<td>
<p>If True, return as quanteda dfm</p>
</td></tr>
<tr><td><code id="term_intersect_+3A_verbose">verbose</code></td>
<td>
<p>If True, report progress</p>
</td></tr>
<tr><td><code id="term_intersect_+3A_sep">sep</code></td>
<td>
<p>The separator used for pasting the terms</p>
</td></tr>
<tr><td><code id="term_intersect_+3A_par">par</code></td>
<td>
<p>If TRUE, add parentheses to colnames before combining. This is mainly for internal use, as it allows
specification if OR (term_union) and AND (term_intersect) operations are combined. 
If NA, this is based on whether parenthese are present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A CsparseMatrix or quanteda dfm
</p>

<hr>
<h2 id='term_union'>Combine terms in a dtm</h2><span id='topic+term_union'></span>

<h3>Description</h3>

<p>Given a dtm and a similarity (adjacency) matrix, group clusters of similar terms (simmat &gt; 0) into a single column.
Column names will be concatenated, with a &quot;|&quot; seperator (read as OR)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term_union(dtm, simmat, as_dfm = T, verbose = F, sep = "|", par = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="term_union_+3A_dtm">dtm</code></td>
<td>
<p>A quanteda <a href="quanteda.html#topic+dfm">dfm</a> or a CsparseMatrix.</p>
</td></tr>
<tr><td><code id="term_union_+3A_simmat">simmat</code></td>
<td>
<p>A similarity matrix in CsparseMatrix format. For instance, created with <a href="#topic+term_char_sim">term_char_sim</a></p>
</td></tr>
<tr><td><code id="term_union_+3A_as_dfm">as_dfm</code></td>
<td>
<p>If True, return as quanteda dfm</p>
</td></tr>
<tr><td><code id="term_union_+3A_verbose">verbose</code></td>
<td>
<p>If True, report progress</p>
</td></tr>
<tr><td><code id="term_union_+3A_sep">sep</code></td>
<td>
<p>The separator used for pasting the terms</p>
</td></tr>
<tr><td><code id="term_union_+3A_par">par</code></td>
<td>
<p>If TRUE, add parentheses to colnames before combining. This is mainly for internal use, as it allows
specification if OR (term_union) and AND (term_intersect) operations are combined. 
If NA, this is based on whether parenthese are present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A CsparseMatrix or quanteda dfm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dfm = quanteda::tokens(c('That guy Gadaffi','Do you mean Kadaffi?',
                         'Nah more like Gadaffel','Not Kadaffel?')) |&gt;
  quanteda::dfm()
simmat = term_char_sim(colnames(dfm), same_start=0)
term_union(dfm, simmat, verbose = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
