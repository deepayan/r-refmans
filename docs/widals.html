<!DOCTYPE html><html><head><title>Help for package widals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {widals}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#widals-package'>
<p>Weighting by Inverse Distance with Adaptive Least Squares for Massive Space-Time Data</p></a></li>
<li><a href='#applystnd.Hs'>
<p>Standardize Spacial Covariates with Existing Object</p></a></li>
<li><a href='#applystnd.Hst.ls'>
<p>Standardize Space-Time Covariates with Existing Object</p></a></li>
<li><a href='#create.rm.ndx.ls'>
<p>Cross-Validation Indices</p></a></li>
<li><a href='#crispify'>
<p>Observation-Space Stochastic Correction</p></a></li>
<li><a href='#distance'>
<p>Spacial Distance</p></a></li>
<li><a href='#dlog.norm'>
<p>Local Search Function</p></a></li>
<li><a href='#fun.load'>
<p>Stochastic Search Helper Functions</p></a></li>
<li><a href='#fuse.Hst.ls'>
<p>Merge Contemporaneous Space-Time Covariates</p></a></li>
<li><a href='#H.als.b'>
<p>Adaptive Least Squares</p></a></li>
<li><a href='#H.Earth.solar'>
<p>Solar Radiation</p></a></li>
<li><a href='#Hals.fastcv.snow'>
<p>ALS Spacial Cross-Validation</p></a></li>
<li><a href='#Hals.ses'>
<p>Effective Standard Errors</p></a></li>
<li><a href='#Hals.snow'>
<p>Fit ALS</p></a></li>
<li><a href='#Hst.sumup'>
<p>Create Covariance Matrix</p></a></li>
<li><a href='#load.Hst.ls.2Zs'>
<p>Load Observations into Space-Time Covariates</p></a></li>
<li><a href='#load.Hst.ls.Z'>
<p>Load Observations into Space-Time Covariates</p></a></li>
<li><a href='#MSS.snow'>
<p>Metaheuristic Stochastic Search</p></a></li>
<li><a href='#O3'>
<p>California Ozone</p></a></li>
<li><a href='#rm.cols.Hst.ls'>
<p>Remove Space-Time Covariates from Model</p></a></li>
<li><a href='#stnd.Hs'>
<p>Standardize Spacial Covariates</p></a></li>
<li><a href='#stnd.Hst.ls'>
<p>Standardize Space-Time Covariates</p></a></li>
<li><a href='#stnd.Ht'>
<p>Standardize Temporal Covariates</p></a></li>
<li><a href='#subsetsites.Hst.ls'>
<p>Site-Wise Extract Space-Time Covariates</p></a></li>
<li><a href='#unif.mh'>
<p>Local Search Function</p></a></li>
<li><a href='#unload.Hst.ls'>
<p>Convert a Space-Time Covariate into Data</p></a></li>
<li><a href='#widals.predict'>
<p>WIDALS Interpolation</p></a></li>
<li><a href='#widals.snow'>
<p>Fit WIDALS</p></a></li>
<li><a href='#Z.clean.up'>
<p>Clean Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Weighting by Inverse Distance with Adaptive Least Squares</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Dave Zes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dave Zes &lt;zesdave@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computationally easy modeling, interpolation, forecasting of massive temporal-spacial data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>snowfall</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SSsimple (&ge; 0.6.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-07 21:58:59 UTC; dzes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-07 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='widals-package'>
Weighting by Inverse Distance with Adaptive Least Squares for Massive Space-Time Data
</h2><span id='topic+widals-package'></span><span id='topic+widals'></span>

<h3>Description</h3>

<p>Fit, forecast, predict massive spacio-temporal data
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> widals</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.6.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-12-07</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The two essential functions are <code><a href="#topic+widals.snow">widals.snow</a></code> and <code><a href="#topic+widals.predict">widals.predict</a></code>, both contain an Adaptive Least Squares (ALS) prediction stage and complementary 'stochastic adjustment' stage.  The function <code><a href="#topic+H.als.b">H.als.b</a></code> solely fits with ALS.
</p>
<p>This package offers the user a metaheuristic stochastic search to locate the scalar WIDALS hyperparameters.  The function <code><a href="#topic+MSS.snow">MSS.snow</a></code> along with helper functions <code><a href="#topic+fun.load">fun.load</a></code> serve this end.  In fairness, providing some useful amount of generality makes this aspect of <code>widals</code> a bit challenging to learn.  The user new to this package should expect to spend a couple hours playing with the examples before effectively applying these functions to their own data.
</p>


<h3>Author(s)</h3>

<p>Dave Zes
</p>
<p>Maintainer: &lt;zesdave@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Package <code>LatticeKrig</code>.
</p>

<hr>
<h2 id='applystnd.Hs'>
Standardize Spacial Covariates with Existing Object 
</h2><span id='topic+applystnd.Hs'></span>

<h3>Description</h3>

<p>Standardize spacial covariates with respect to both the space and time dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applystnd.Hs(Hs0, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applystnd.Hs_+3A_hs0">Hs0</code></td>
<td>

<p>Spacial covariates (of interpolation sites).  An <code class="reqn">n</code>* x <code class="reqn">p_s</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="applystnd.Hs_+3A_x">x</code></td>
<td>

<p>Spacial standardization object, as created by <code><a href="#topic+stnd.Hs">stnd.Hs</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">n</code>* x <code class="reqn">p_s</code> matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stnd.Hst.ls">stnd.Hst.ls</a></code>, <code><a href="#topic+applystnd.Hst.ls">applystnd.Hst.ls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n.all &lt;- 21
Hs.all &lt;- cbind(1, rnorm(n.all, 1, 0.1), rnorm(n.all, -200, 21))

ndx.interp &lt;- c(1,3,5)
ndx.support &lt;- I(1:n.all)[ -ndx.interp ]


Hs &lt;- Hs.all[ndx.support, , drop=FALSE]

xsns.obj &lt;- stnd.Hs(Hs)

Hs0 &lt;- Hs.all[ndx.interp, , drop=FALSE]

sHs0 &lt;- applystnd.Hs(Hs0, xsns.obj)
sHs0

xsns.obj$sHs

crossprod(xsns.obj$sHs) / nrow(Hs)

crossprod(sHs0) / nrow(sHs0)


## The function is currently defined as
function (Hs0, x) 
{
    sHs0 &lt;- t((t(Hs0) - x$h.mean)/x$h.sd)
    if (x$intercept) {
        sHs0[, 1] &lt;- 1/sqrt(x$n)
    }
    return(sHs0)
  }
</code></pre>

<hr>
<h2 id='applystnd.Hst.ls'>
Standardize Space-Time Covariates with Existing Object 
</h2><span id='topic+applystnd.Hst.ls'></span>

<h3>Description</h3>

<p>Standardize spacio-temporal covariates with respect to both the space and time dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applystnd.Hst.ls(Hst0.ls, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applystnd.Hst.ls_+3A_hst0.ls">Hst0.ls</code></td>
<td>

<p>Space-time covariates (of interpolation sites).  A list of length <code class="reqn">\tau</code>, each element should be a <code class="reqn">n</code>* x <code class="reqn">p_st</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="applystnd.Hst.ls_+3A_x">x</code></td>
<td>

<p>Space-time standardization object, as created by <code><a href="#topic+stnd.Hst.ls">stnd.Hst.ls</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unnamed list of length <code class="reqn">\tau</code>, each element a <code class="reqn">n</code>* x <code class="reqn">p_st</code> numeric matrix. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
tau &lt;- 20
n.all &lt;- 10
	
Hst.ls.all &lt;- list()
for(tt in 1:tau) {
	Hst.ls.all[[tt]] &lt;- cbind(rnorm(n.all, 1, 0.1), rnorm(n.all, -200, 21))
}

ndx.interp &lt;- c(1,3,5)
ndx.support &lt;- I(1:n.all)[ -ndx.interp ]

Hst.ls &lt;- subsetsites.Hst.ls(Hst.ls.all, ndx.support)

xsnst.obj &lt;- stnd.Hst.ls(Hst.ls)

Hst0.ls &lt;- subsetsites.Hst.ls(Hst.ls.all, ndx.interp)

sHst0.ls &lt;- applystnd.Hst.ls(Hst0.ls, xsnst.obj)



Hst.sumup(xsnst.obj$sHst.ls)

Hst.sumup(sHst0.ls)



## The function is currently defined as
function (Hst0.ls, x) 
{
    tau &lt;- length(Hst0.ls)
    sHst0.ls &lt;- list()
    for (i in 1:tau) {
        sHst0.ls[[i]] &lt;- t((t(Hst0.ls[[i]]) - x$h.mean)/x$h.sd)
    }
    return(sHst0.ls)
  }
</code></pre>

<hr>
<h2 id='create.rm.ndx.ls'>
Cross-Validation Indices
</h2><span id='topic+create.rm.ndx.ls'></span>

<h3>Description</h3>

<p>Create a list of vectors of indices to remove for <em>k</em>-fold cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.rm.ndx.ls(n, xincmnt = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.rm.ndx.ls_+3A_n">n</code></td>
<td>

<p>Number of sites.  A scalar integer.
</p>
</td></tr>
<tr><td><code id="create.rm.ndx.ls_+3A_xincmnt">xincmnt</code></td>
<td>

<p>How many cv folds, i.e., <em>k</em>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name of the object produced by this function is commonly <code>rm.ndx</code> in this documentation.  See <code><a href="#topic+MSS.snow">MSS.snow</a></code> for a reminder that this object is passed out-of-scope when using <code>MSS.snow</code>.
</p>
<p>In this package <code>rm.ndx</code> is used by <code><a href="#topic+Hals.fastcv.snow">Hals.fastcv.snow</a></code> and <code><a href="#topic+widals.snow">widals.snow</a></code>; however, creating this object as a list using this function is only necessary when using <code><a href="#topic+widals.snow">widals.snow</a></code> with <code>cv=2</code> (i.e., 'true' cross-validation).
</p>


<h3>Value</h3>

<p>An unnamed list of integer (&gt;0) vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
xincmnt &lt;- 7
rm.ndx &lt;- create.rm.ndx.ls(n=n, xincmnt=xincmnt)
rm.ndx

######## if we want randomization of indices:
n &lt;- 100
xincmnt &lt;- 7
rm.ndx &lt;- create.rm.ndx.ls(n=n, xincmnt=xincmnt)

rnd.ndx &lt;- sample(I(1:n))
for(i in 1:length(rm.ndx)) { rm.ndx[[i]] &lt;- rnd.ndx[rm.ndx[[i]]] }
rm.ndx

## The function is currently defined as
function (n, xincmnt = 10) 
{
    rm.ndx.ls &lt;- list()
    for (i in 1:xincmnt) {
        xrm.ndxs &lt;- seq(i, n + xincmnt, by = xincmnt)
        xrm.ndxs &lt;- xrm.ndxs[xrm.ndxs &lt;= n]
        rm.ndx.ls[[i]] &lt;- xrm.ndxs
    }
    return(rm.ndx.ls)
}
</code></pre>

<hr>
<h2 id='crispify'>
Observation-Space Stochastic Correction
</h2><span id='topic+crispify'></span>

<h3>Description</h3>

<p>Improve observation-space predictions using 'left over' spacial correlation between model residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crispify(locs1, locs2, Z.delta, z.lags.vec, geodesic, alpha, flatten, self.refs, 
lags, stnd.d = FALSE, log10cutoff = -16)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crispify_+3A_locs1">locs1</code></td>
<td>

<p>Locations of supporting sites.  An <em>n</em> x 3 matrix, first column is spacial <code class="reqn">x</code>, second column is spacial <code class="reqn">y</code>, third column contains relative temporal 'distance'.  If the <code>geodesic</code> is <code>TRUE</code>, make sure latitude is in the first column.
</p>
</td></tr>
<tr><td><code id="crispify_+3A_locs2">locs2</code></td>
<td>

<p>Locations of interpolation sites.  An <code class="reqn">n</code>* x 3 matrix, where <code class="reqn">n</code>* is the number of interpolation sites.  See <code>locs1</code> above.
</p>
</td></tr>
<tr><td><code id="crispify_+3A_z.delta">Z.delta</code></td>
<td>

<p>Observed residuals.  A <code class="reqn">\tau</code> x <code class="reqn">x</code> matrix.
</p>
</td></tr>
<tr><td><code id="crispify_+3A_z.lags.vec">z.lags.vec</code></td>
<td>

<p>Temporal lags.  An integer vector or scalar.
</p>
</td></tr>
<tr><td><code id="crispify_+3A_geodesic">geodesic</code></td>
<td>

<p>Use geodesic distance?  Boolean.  If true, distance (used internally) is in units kilometers.
</p>
</td></tr>
<tr><td><code id="crispify_+3A_alpha">alpha</code></td>
<td>

<p>The WIDALS distance rate hyperparameter.  A scalar non-negative number.
</p>
</td></tr>
<tr><td><code id="crispify_+3A_flatten">flatten</code></td>
<td>

<p>The WIDALS 'flattening' hyperparameter.  A scalar non-negative number.  Typically between 0 and some number slightly greater than 1.  When 0, no crispification.
</p>
</td></tr>
<tr><td><code id="crispify_+3A_self.refs">self.refs</code></td>
<td>

<p>Which sites are self-referencing?  An integer vector of (zero-based) lag indices, OR a scalar set to <code>-1</code>.  This argument only has meaning when <code>locs1</code> is identical to <code>locs2</code>.  If the <code>lags</code> argument is, say, 0, then it would be pointless to smooth predictions with existing values.  In this case, we can set <code>self.refs = 0</code>.  If <code>locs1</code> is NOT the same as <code>locs2</code>, then set this argument to <code>-1</code>.
</p>
</td></tr>
<tr><td><code id="crispify_+3A_lags">lags</code></td>
<td>

<p>Temporal lags.  An integer vector or scalar.  E.g., if the data's time increment is daily, then <code>lags = c(-1,0,1)</code> would have <code>crispify</code> smooth today's predictions using yesterdays, today's, and tomorrow's observed residuals.
</p>
</td></tr>
<tr><td><code id="crispify_+3A_stnd.d">stnd.d</code></td>
<td>

<p>Spacial compression.  Boolean.
</p>
</td></tr>
<tr><td><code id="crispify_+3A_log10cutoff">log10cutoff</code></td>
<td>

<p>Weight threshold.  A scalar number.  A value of, e.g., -10, will instruct <code>crispify</code> to ignore weights less than 10^(-10) when smoothing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called inside <code><a href="#topic+widals.predict">widals.predict</a></code> and <code><a href="#topic+widals.snow">widals.snow</a></code>.  It may be useful for the user in building their own WIDALS model extensions.
</p>


<h3>Value</h3>

<p>A <code class="reqn">\tau</code> x <code class="reqn">x</code> matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+widals.predict">widals.predict</a></code>, <code><a href="#topic+widals.snow">widals.snow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
######### here's an itty-bitty example

######### simulate itty-bitty data

tau &lt;- 21 #### number of time points

d.alpha &lt;- 2
R.scale &lt;- 1
sigma2 &lt;- 0.01
F &lt;- 1
Q &lt;- 0

n.all &lt;- 14 ##### number of spacial locations

set.seed(9999)


library(SSsimple)

locs.all &lt;- cbind(runif(n.all, -1, 1), runif(n.all, -1, 1)) #### random location of sensors
D.mx &lt;- distance(locs.all, locs.all, FALSE) #### distance matrix

#### create measurement variance using distance and covariogram
R.all &lt;- exp(-d.alpha*D.mx) + diag(sigma2, n.all)

Hs.all &lt;- matrix(1, n.all, 1) #### constant mean function

##### use SSsimple to simulate system
xsssim &lt;- SS.sim(F=F, H=Hs.all, Q=Q, R=R.all, length.out=tau, beta0=0)
Z.all &lt;- xsssim$Z ###### system observation matrix


######## suppose use the global mean as a prediction

z.mean &lt;- mean(Z.all)

Z.delta &lt;- Z.all - z.mean


z.lags.vec &lt;- rep(0, n.all)

geodesic &lt;- FALSE
alpha &lt;- 5
flatten &lt;- 1

## emmulate cross-validation, i.e., 
## don't use observed site values to predict themselves (zero-based)
self.refs &lt;- 0 
lags &lt;- 0

locs1 &lt;- cbind(locs.all, rep(0, n.all))
locs2 &lt;- cbind(locs.all, rep(0, n.all))

Z.adj &lt;- crispify(locs1, locs2, Z.delta, z.lags.vec, geodesic, alpha, 
    flatten, self.refs, lags, stnd.d = FALSE, log10cutoff = -16) 

Z.adj

Z.hat &lt;- z.mean + Z.adj

sqrt( mean( (Z.all - Z.hat)^2 ) )


######### set flatten to zero -- this means no crispification

Z.adj &lt;- crispify(locs1, locs2, Z.delta, z.lags.vec, geodesic, alpha, 
    flatten=0, self.refs, lags, stnd.d = FALSE, log10cutoff = -16) 

Z.adj

Z.hat &lt;- z.mean + Z.adj

sqrt( mean( (Z.all - Z.hat)^2 ) )


</code></pre>

<hr>
<h2 id='distance'>
Spacial Distance
</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>Calculate spacial distance between two sets of locations (in two-space)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(locs1, locs2, geodesic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_locs1">locs1</code></td>
<td>

<p>First set of locations.  E.g., supporting sites: An <code class="reqn">n</code> x <code>2</code> matrix.  If <code>geodesic</code> is set to true, make sure to place latitude in first column.
</p>
</td></tr>
<tr><td><code id="distance_+3A_locs2">locs2</code></td>
<td>

<p>Second set of locations.  E.g., interpolation sites: An <code class="reqn">n</code>* x <code>2</code> matrix.  If <code>geodesic</code> is set to true, make sure to place latitude in first column.
</p>
</td></tr>
<tr><td><code id="distance_+3A_geodesic">geodesic</code></td>
<td>

<p>Use geodesic distance?  Boolean.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>geodesic</code> is set to <code>FALSE</code>, Euclidean distance is returned; if <code>TRUE</code>, Earth's geodesic distance is returned in units kilometers.
</p>


<h3>Value</h3>

<p>An <code class="reqn">n</code> x <code class="reqn">n</code>* matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
locs1 &lt;- cbind( c(-1, -1, 1, 1), c(-1, 1, -1, 1) )
locs2 &lt;- cbind( c(0), c(0) )

distance(locs1, locs2)


locs1 &lt;- cbind( c(32, 0), c(-114, -114) )
locs2 &lt;- cbind( c(0), c(0) )

distance(locs1, locs2, TRUE)


####### separation of one deg long at 88 degs lat (near North-Pole) is (appx)
locs1 &lt;- cbind( c(88), c(-114) )
locs2 &lt;- cbind( c(88), c(-115) )
distance(locs1, locs2, TRUE)

####### separation of one deg long at 0 degs lat (Equator) is (appx)
locs1 &lt;- cbind( c(0), c(-114) )
locs2 &lt;- cbind( c(0), c(-115) )
distance(locs1, locs2, TRUE)





## The function is currently defined as
function (locs1, locs2, geodesic = FALSE) 
{
#    dyn.load("~/Files/Creations/C/distance.so")
    n1 &lt;- nrow(locs1)
    n2 &lt;- nrow(locs2)
    d.out &lt;- rep(0, n1 * n2)
    if (geodesic) {
        D.Mx &lt;- .C("distance_geodesic_AB", as.double(locs1[, 
            1] * pi/180), as.double(locs1[, 2] * pi/180), as.double(locs2[, 
            1] * pi/180), as.double(locs2[, 2] * pi/180), as.double(d.out), 
            as.integer(n1), as.integer(n2))[[5]]
    }
    else {
        D.Mx &lt;- .C("distance_AB", as.double(locs1[, 1]), as.double(locs1[, 
            2]), as.double(locs2[, 1]), as.double(locs2[, 2]), 
            as.double(d.out), as.integer(n1), as.integer(n2))[[5]]
    }
    D.out &lt;- matrix(D.Mx, n1, n2)
    return(D.out)
  }
</code></pre>

<hr>
<h2 id='dlog.norm'>
Local Search Function
</h2><span id='topic+dlog.norm'></span>

<h3>Description</h3>

<p>Local hyperparameter exponentiated-normal search function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlog.norm(n, center, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlog.norm_+3A_n">n</code></td>
<td>

<p>Sample size.  A positive scalar integer.
</p>
</td></tr>
<tr><td><code id="dlog.norm_+3A_center">center</code></td>
<td>

<p>Exponential of the mean.  A numeric scalar (or vector).
</p>
</td></tr>
<tr><td><code id="dlog.norm_+3A_sd">sd</code></td>
<td>

<p>Standard deviation.  A numeric scalar (or vector).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used by <code><a href="#topic+MSS.snow">MSS.snow</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code class="reqn">n</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unif.mh">unif.mh</a></code>, <code><a href="#topic+MSS.snow">MSS.snow</a></code>, <code><a href="#topic+fun.load">fun.load</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dlog.norm(100, 1, 1)
hist(x)

## The function is currently defined as
function (n, center, sd) 
{
    return(exp(rnorm(n, log(center), sd)))
  }
</code></pre>

<hr>
<h2 id='fun.load'>
Stochastic Search Helper Functions
</h2><span id='topic+fun.load'></span><span id='topic+fun.load.hals.a'></span><span id='topic+fun.load.hals.fill'></span><span id='topic+fun.load.widals.a'></span><span id='topic+fun.load.widals.fill'></span>

<h3>Description</h3>

<p>Functions that assign values and functions needed by <code><a href="#topic+MSS.snow">MSS.snow</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fun.load.hals.a()
fun.load.hals.fill()
fun.load.widals.a()
fun.load.widals.fill()
</code></pre>


<h3>Details</h3>

<p>Please see <code><a href="#topic+MSS.snow">MSS.snow</a></code> and examples.
</p>


<h3>Value</h3>

<p>Nothing.  The central role of these functions is the creation of four functions required by <code><a href="#topic+MSS.snow">MSS.snow</a></code>: <code>FUN.MH</code>, <code>FUN.GP</code>, <code>FUN.I</code>, and <code>FUN.EXIT</code>.  These four functions are assigned to the Global Environment.  This <code><a href="#topic+fun.load">fun.load</a></code> suite of functions also passes needed objects (out-of-scope) to <code><a href="snowfall.html#topic+snowfall">snowfall</a></code> threads if the global user-made variable <code>run.parallel</code> is set to <code>TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MSS.snow">MSS.snow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


### Here's an itty bitty example:
### we use stochastic search to find the minimum number in a vector
### GP isn't used here, and hence neither are p.ndx.ls nor f.d
### however, we still need to create them since MSS.snow requires their existence

## Not run: 

fun.load.simpleExample &lt;- function() {

   if( run.parallel ) {
         sfExport("xx")
    }
    
    p.ndx.ls &lt;- list( c(1) )
    
    p.ndx.ls &lt;&lt;- p.ndx.ls
    
    f.d &lt;- list( dlog.norm )

    f.d &lt;&lt;- f.d
    
    FUN.MH &lt;- function(jj, GP.mx, X) {
        our.cost &lt;- sample(xx, 1)
    }

    FUN.MH &lt;&lt;- FUN.MH
    
    
    FUN.GP &lt;- NULL
    FUN.GP &lt;&lt;- FUN.GP
    
    
    FUN.I &lt;- function(envmh, X) {
        cat( "Hello, I have found an even smaller number in xx ---&gt; ", envmh$current.best, "\n" )
    }
    FUN.I &lt;&lt;- FUN.I
    
    FUN.EXIT &lt;- function(envmh, X) {
        cat( "Done",   "\n" )
    }

    FUN.EXIT &lt;&lt;- FUN.EXIT
    
}

xx &lt;- 1:600

GP &lt;- c(1)

run.parallel &lt;- TRUE
sfInit(TRUE, 2)

MH.source &lt;- fun.load.simpleExample
MH.source()

MSS.snow(MH.source, Inf, p.ndx.ls, f.d, matrix(1, nrow=28), 28, 7)
sfStop()




### Here's another itty bitty example:
### we use stochastic search to find the mean of a vector
### i.e., the argmin? of sum ( x - ? )^2

fun.load.simpleExample2 &lt;- function() {

   if( run.parallel ) {
         sfExport("xx")
    }
    
    p.ndx.ls &lt;- list( c(1) )
    p.ndx.ls &lt;&lt;- p.ndx.ls
    
    f.d &lt;- list( unif.mh )
    f.d &lt;&lt;- f.d
    
    FUN.MH &lt;- function(jj, GP.mx, X) {
        our.cost &lt;- sum( ( xx - GP.mx[jj, 1] )^2 )
        return(our.cost)
    }
    FUN.MH &lt;&lt;- FUN.MH
    
    FUN.GP &lt;- NULL
    FUN.GP &lt;&lt;-  FUN.GP
    
    FUN.I &lt;- function(envmh, X) {
        cat( "Improvement ---&gt; ", envmh$current.best, " ---- " , envmh$GP, "\n" )
    }
    FUN.I &lt;&lt;- FUN.I
    
    FUN.EXIT &lt;- function(envmh, X) {
        our.cost &lt;- envmh$current.best
        GP &lt;- envmh$GP
        cat( "Done",   "\n" )
        cat( envmh$GP, our.cost, "\n" )
    }
    FUN.EXIT &lt;&lt;- FUN.EXIT
    
}

##set.seed(99999)
xx &lt;- rnorm(300, 5, 10)

GP &lt;- c(1)

run.parallel &lt;- TRUE
sfInit(TRUE, 2)

MH.source &lt;- fun.load.simpleExample2
MH.source()

MSS.snow(MH.source, Inf, p.ndx.ls, f.d, matrix(1/10, nrow=140, ncol=length(GP)), 140, 14)
sfStop()

##### in fact:
mean(xx)


## End(Not run)

</code></pre>

<hr>
<h2 id='fuse.Hst.ls'>
Merge Contemporaneous Space-Time Covariates
</h2><span id='topic+fuse.Hst.ls'></span>

<h3>Description</h3>

<p>Fuse together two lists of spacio-temporal covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuse.Hst.ls(Hst.ls1, Hst.ls2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuse.Hst.ls_+3A_hst.ls1">Hst.ls1</code></td>
<td>

<p>Space-time covariates.  A list of length <code class="reqn">\tau</code>, each element should be a numeric <code class="reqn">n</code> x <code class="reqn">p_1</code> matrix. 
</p>
</td></tr>
<tr><td><code id="fuse.Hst.ls_+3A_hst.ls2">Hst.ls2</code></td>
<td>

<p>Space-time covariates.  A list of length <code class="reqn">\tau</code>, each element should be a numeric <code class="reqn">n</code> x <code class="reqn">p_2</code> matrix. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unnamed list of length <code class="reqn">\tau</code>, each element will be a numeric <code class="reqn">n</code> x <code class="reqn">(p_1+p_2)</code> matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(9999)

tau &lt;- 5
n &lt;- 7

p1 &lt;- 2
Hst.ls1 &lt;- list()
for(i in 1:tau) { Hst.ls1[[i]] &lt;- matrix(rnorm(n*p1), nrow=n) }

p2 &lt;- 3
Hst.ls2 &lt;- list()
for(i in 1:tau) { Hst.ls2[[i]] &lt;- matrix(rnorm(n*p2), nrow=n) }

fuse.Hst.ls(Hst.ls1, Hst.ls2)


## The function is currently defined as
function (Hst.ls1, Hst.ls2) 
{
    tau &lt;- length(Hst.ls1)
    for (i in 1:tau) {
        Hst.ls1[[i]] &lt;- cbind(Hst.ls1[[i]], Hst.ls2[[i]])
    }
    return(Hst.ls1)
  }
</code></pre>

<hr>
<h2 id='H.als.b'>
Adaptive Least Squares
</h2><span id='topic+H.als.b'></span>

<h3>Description</h3>

<p>Adaptive Least Squares expecially for large spacio-temporal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H.als.b(Z, Hs, Ht, Hst.ls, rho, reg, b.lag = -1, Hs0 = NULL, Ht0 = NULL, Hst0.ls = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="H.als.b_+3A_z">Z</code></td>
<td>

<p>Space-time data.  A <code class="reqn">\tau</code> x <code class="reqn">n</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="H.als.b_+3A_hs">Hs</code></td>
<td>

<p>Spacial covariates (of supporting sites).  An <code class="reqn">n</code> x <code class="reqn">p_s</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="H.als.b_+3A_ht">Ht</code></td>
<td>

<p>Temporal covariates (of supporting sites).  A <code class="reqn">\tau</code> x <code class="reqn">p_t</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="H.als.b_+3A_hst.ls">Hst.ls</code></td>
<td>

<p>Space-time covariates (of supporting sites).  A list of length <code class="reqn">\tau</code>, each element should be a <code class="reqn">n</code> x <code class="reqn">p_st</code> numeric matrix. 
</p>
</td></tr>
<tr><td><code id="H.als.b_+3A_rho">rho</code></td>
<td>

<p>ALS signal-to-noise ratio (SNR).  A non-negative scalar.
</p>
</td></tr>
<tr><td><code id="H.als.b_+3A_reg">reg</code></td>
<td>

<p>ALS regularizer.  A non-negative scalar.
</p>
</td></tr>
<tr><td><code id="H.als.b_+3A_b.lag">b.lag</code></td>
<td>

<p>ALS lag.  A scalar integer, typically -1 (<em>a-prior</em>), or 0 (<em>a-posteriori</em>).
</p>
</td></tr>
<tr><td><code id="H.als.b_+3A_hs0">Hs0</code></td>
<td>

<p>Spacial covariates (of interpolation sites).  An <code class="reqn">n</code>* x <code class="reqn">p_s</code> matrix, or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="H.als.b_+3A_ht0">Ht0</code></td>
<td>

<p>Temporal covariates (of interpolation sites).  A <code class="reqn">\tau</code> x <code class="reqn">p_t</code> matrix, or <code>NULL</code>.  If not <code>NULL</code>, I cannot imagine a scenario where this shouldn't be <code>Ht</code>.
</p>
</td></tr>
<tr><td><code id="H.als.b_+3A_hst0.ls">Hst0.ls</code></td>
<td>

<p>Space-time covariates (of interpolation sites).  A list of length <code class="reqn">\tau</code>, each element should be a numeric <code class="reqn">n</code> x <code class="reqn">p_st</code> matrix. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list.
</p>
<table>
<tr><td><code>Z.hat</code></td>
<td>
<p>A <code class="reqn">\tau</code> x <em>n</em> matrix, the <em>i</em>th row of which is the ALS prediction of the supporting sites at time <em>i</em>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>A <code class="reqn">\tau</code> x <code class="reqn">(p_s+p_t+p_st)</code> matrix, the <em>i</em>th row of which is the ALS state (partial slopes) prediction at time <em>i</em>.</p>
</td></tr>
<tr><td><code>Z0.hat</code></td>
<td>
<p>A <code class="reqn">\tau</code> x <em>n</em>* matrix, the <em>i</em>th row of which is the ALS prediction of the interpolation sites at time <em>i</em>.</p>
</td></tr>
<tr><td><code>inv.LHH</code></td>
<td>
<p>A <code class="reqn">(p_s+p_t+p_st)</code> x <code class="reqn">(p_s+p_t+p_st)</code> matrix.  This is the (ALS predicted) covariate precision matrix at time <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code>ALS.g</code></td>
<td>
<p>The ALS gain at time <code class="reqn">\tau</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(99999)

library(SSsimple)

tau &lt;- 70
n.all &lt;- 14

Hs.all &lt;- matrix(rnorm(n.all), nrow=n.all)
Ht &lt;- matrix(rnorm(tau*2), nrow=tau)
Hst.ls.all &lt;- list()
for(i in 1:tau) { Hst.ls.all[[i]] &lt;- matrix(rnorm(n.all*2), nrow=n.all) }

Hst.combined &lt;- list()
for(i in 1:tau) { 
    Hst.combined[[i]] &lt;- cbind( Hs.all, matrix(Ht[i, ], nrow=n.all, ncol=ncol(Ht), 
    byrow=TRUE), Hst.ls.all[[i]] ) 
}

######## use SSsimple to simulate
sssim.obj &lt;- SS.sim.tv( 0.999, Hst.combined, 0.01, diag(1, n.all), tau )


ndx.support &lt;- 1:10
ndx.interp &lt;- 11:14

Z.all &lt;- sssim.obj$Z
Z &lt;- Z.all[ , ndx.support]
Z0 &lt;- Z.all[ , ndx.interp]

Hst.ls &lt;- subsetsites.Hst.ls(Hst.ls.all, ndx.support)
Hst0.ls &lt;- subsetsites.Hst.ls(Hst.ls.all, ndx.interp)

Hs &lt;- Hs.all[ ndx.support, , drop=FALSE]
Hs0 &lt;- Hs.all[ ndx.interp, , drop=FALSE]

xrho &lt;- 1/10
xreg &lt;- 1/10
xALS &lt;- H.als.b(Z=Z, Hs=Hs, Ht=Ht, Hst.ls=Hst.ls, rho=xrho, reg=xreg, b.lag=-1, 
Hs0=Hs0, Ht0=Ht, Hst0.ls=Hst0.ls) 



test.rng &lt;- 20:tau

errs.sq &lt;- (Z0 - xALS$Z0.hat)^2
sqrt( mean(errs.sq[test.rng, ]) )


################ calculate the 'effective standard errors' (actually 'effective prediction
################ errors') of the ALS partial slopes
rmse &lt;- sqrt(mean((Z[test.rng, ] - xALS$Z.hat[test.rng, ])^2))
rmse
als.se &lt;- rmse * sqrt(xALS$ALS.g) * sqrt(diag(xALS$inv.LHH))
cbind(xALS$B[tau, ], als.se, xALS$B[tau, ]/als.se)


</code></pre>

<hr>
<h2 id='H.Earth.solar'>
Solar Radiation
</h2><span id='topic+H.Earth.solar'></span>

<h3>Description</h3>

<p>Calculate Incident Solar Area (ISA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H.Earth.solar(x, y, dateDate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="H.Earth.solar_+3A_x">x</code></td>
<td>

<p>Longitude.  Numeric vector of length <code class="reqn">n</code>.
</p>
</td></tr>
<tr><td><code id="H.Earth.solar_+3A_y">y</code></td>
<td>

<p>Latitude.  Numeric vector of length <code class="reqn">n</code>.
</p>
</td></tr>
<tr><td><code id="H.Earth.solar_+3A_datedate">dateDate</code></td>
<td>

<p>Posix date.  Numeric vector of length <code class="reqn">\tau</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a spacio-temporal covariate list (Earth's ISA is space-time <em>non-seperable</em>).  A negative value indicates that at that time (list index), and at that location (matrix row), the sun is below the horizon all day.
</p>


<h3>Value</h3>

<p>An unnamed list of length <code class="reqn">\tau</code>, each element of which is an <code class="reqn">n</code> x 1 matrix.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lat &lt;- c(0, -88)
lon &lt;- c(0, 0)
dateDate &lt;- strptime( c('20120621', '20120320'), '%Y%m%d')

H.Earth.solar(lon, lat, dateDate)


## The function is currently defined as
function (x, y, dateDate) 
{
    Hst.ls &lt;- list()
    n &lt;- length(y)
    tau &lt;- length(dateDate)
    equinox &lt;- strptime("20110320", "%Y%m%d")
    for (i in 1:tau) {
        this.date &lt;- dateDate[i]
        dfe &lt;- as.integer(difftime(this.date, equinox, units = "day"))
        dfe
        psi &lt;- 23.5 * sin(2 * pi * dfe/365.25)
        psi
        eta &lt;- 90 - (360/(2 * pi)) * acos(cos(2 * pi * y/360) * 
            cos(2 * pi * psi/360) + sin(2 * pi * y/360) * sin(2 * 
            pi * psi/360))
        surface.area &lt;- sin(2 * pi * eta/360)
        surface.area
        Hst.ls[[i]] &lt;- cbind(surface.area)
    }
    return(Hst.ls)
  }
</code></pre>

<hr>
<h2 id='Hals.fastcv.snow'>
ALS Spacial Cross-Validation
</h2><span id='topic+Hals.fastcv.snow'></span>

<h3>Description</h3>

<p>Fit Adaptive Least Squares with <code class="reqn">k</code>-fold cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hals.fastcv.snow(j, rm.ndx, Z, Hs, Ht, Hst.ls, GP.mx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hals.fastcv.snow_+3A_j">j</code></td>
<td>

<p>Index used by <code><a href="snowfall.html#topic+snowfall">snowfall</a></code>.  A scalar integer.  Which row of <code>GP.mx</code> to use for the ALS hyperparameters, <code>GP</code>.
</p>
</td></tr>
<tr><td><code id="Hals.fastcv.snow_+3A_rm.ndx">rm.ndx</code></td>
<td>

<p>A list of vectors of indices to remove for <em>k</em>-fold cross-validation.
</p>
</td></tr>
<tr><td><code id="Hals.fastcv.snow_+3A_z">Z</code></td>
<td>

<p>Data.  A <code class="reqn">\tau</code> x <code class="reqn">n</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hals.fastcv.snow_+3A_hs">Hs</code></td>
<td>

<p>Spacial covariates.  An <code class="reqn">n</code> x <code class="reqn">p_s</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hals.fastcv.snow_+3A_ht">Ht</code></td>
<td>

<p>Temporal covariates.  An <code class="reqn">\tau</code> x <code class="reqn">p_t</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hals.fastcv.snow_+3A_hst.ls">Hst.ls</code></td>
<td>

<p>Space-time covariates.  A list of length <code class="reqn">\tau</code>, each element containing a <code class="reqn">n</code> x <code class="reqn">p_st</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hals.fastcv.snow_+3A_gp.mx">GP.mx</code></td>
<td>

<p>Hyperparameters.  A <code class="reqn">k.glob</code> x 2 non-negative matrix.  See <code><a href="#topic+MSS.snow">MSS.snow</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">\tau</code> x <code class="reqn">n</code> numeric matrix.  The ALS cross-validated predictions of <code>Z</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hals.snow">Hals.snow</a></code>, <code><a href="#topic+MSS.snow">MSS.snow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(99999)



library(SSsimple)

tau &lt;- 70
n.all &lt;- 14

Hs.all &lt;- matrix(rnorm(n.all), nrow=n.all)
Ht &lt;- matrix(rnorm(tau*2), nrow=tau)
Hst.ls.all &lt;- list()
for(i in 1:tau) { Hst.ls.all[[i]] &lt;- matrix(rnorm(n.all*2), nrow=n.all) }

Hst.combined &lt;- list()
for(i in 1:tau) { 
    Hst.combined[[i]] &lt;- cbind( Hs.all, matrix(Ht[i, ], nrow=n.all, 
    ncol=ncol(Ht), byrow=TRUE), Hst.ls.all[[i]] ) 
}

######## use SSsimple to simulate
sssim.obj &lt;- SS.sim.tv( 0.999, Hst.combined, 0.01, diag(1, n.all), tau )



Z.all &lt;- sssim.obj$Z
Z &lt;- Z.all
n &lt;- n.all

Hst.ls &lt;- Hst.ls.all

Hs &lt;- Hs.all

xrho &lt;- 1/10
xreg &lt;- 1/10

GP.mx &lt;- matrix(c(xrho, xreg), nrow=1)

rm.ndx &lt;- create.rm.ndx.ls(n, 10)

Zcv &lt;- Hals.fastcv.snow(j=1, rm.ndx, Z, Hs, Ht, Hst.ls, GP.mx) 



test.rng &lt;- 20:tau

errs.sq &lt;- (Z - Zcv)^2
sqrt( mean(errs.sq[test.rng, ]) )


</code></pre>

<hr>
<h2 id='Hals.ses'>
Effective Standard Errors
</h2><span id='topic+Hals.ses'></span>

<h3>Description</h3>

<p>Calculate the ALS so-called 'effective standard errors'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hals.ses(Z, Hs, Ht, Hst.ls, rho, reg, b.lag, test.rng)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hals.ses_+3A_z">Z</code></td>
<td>

<p>Space-time data.  A <code class="reqn">\tau</code> x <code class="reqn">n</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hals.ses_+3A_hs">Hs</code></td>
<td>

<p>Spacial covariates (of supporting sites).  An <code class="reqn">n</code> x <code class="reqn">p_s</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hals.ses_+3A_ht">Ht</code></td>
<td>

<p>Temporal covariates (of supporting sites).  A <code class="reqn">\tau</code> x <code class="reqn">p_t</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hals.ses_+3A_hst.ls">Hst.ls</code></td>
<td>

<p>Space-time covariates (of supporting sites).  A list of length <code class="reqn">\tau</code>, each element should be a numeric <code class="reqn">n</code> x <code class="reqn">p_st</code> matrix. 
</p>
</td></tr>
<tr><td><code id="Hals.ses_+3A_rho">rho</code></td>
<td>

<p>ALS signal-to-noise ratio (SNR).  A non-negative scalar.
</p>
</td></tr>
<tr><td><code id="Hals.ses_+3A_reg">reg</code></td>
<td>

<p>ALS regularizer.  A non-negative scalar.
</p>
</td></tr>
<tr><td><code id="Hals.ses_+3A_b.lag">b.lag</code></td>
<td>

<p>ALS lag.  A scalar integer, typically -1 (<em>a-prior</em>), or 0 (<em>a-posteriori</em>).
</p>
</td></tr>
<tr><td><code id="Hals.ses_+3A_test.rng">test.rng</code></td>
<td>

<p>Temporal test range.  A vector of temporal indices of the model test range.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list.
</p>
<table>
<tr><td><code>estimates</code></td>
<td>
<p>A <code class="reqn">p_s+p_t+p_st</code> x 2 matrix, each row giving the ALS partial slope estimate/prediction at time <code class="reqn">\tau</code>, and the 'effective standard error (prediction error)' for the partial slope.</p>
</td></tr>
<tr><td><code>inv.LHH</code></td>
<td>
<p>A <code class="reqn">(p_s+p_t+p_st)</code> x <code class="reqn">(p_s+p_t+p_st)</code> matrix.  This is the (ALS predicted) covariate precision matrix at time <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code>ALS.g</code></td>
<td>
<p>The ALS gain at time <code class="reqn">\tau</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Please see the example in H.als.b

## The function is currently defined as
function (Z, Hs, Ht, Hst.ls, rho, reg, b.lag, test.rng) 
{
    tau &lt;- nrow(Z)
    xALS &lt;- H.als.b(Z = Z, Hs = Hs, Ht = Ht, Hst.ls = Hst.ls, 
        rho = rho, reg = reg, b.lag = b.lag, Hs0 = NULL, Ht0 = NULL, 
        Hst0.ls = NULL)
    rmse &lt;- sqrt(mean((Z[test.rng, ] - xALS$Z.hat[test.rng, ])^2))
    rmse
    als.se &lt;- rmse * sqrt(xALS$ALS.g) * sqrt(diag(xALS$inv.LHH))
    return(list(estimates = cbind(xALS$B[tau, ], als.se), inv.LHH = xALS$inv.LHH, 
        ALS.g = xALS$ALS.g))
  }
</code></pre>

<hr>
<h2 id='Hals.snow'>
Fit ALS
</h2><span id='topic+Hals.snow'></span>

<h3>Description</h3>

<p>Fit Adaptive Least Squares
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hals.snow(j, Z, Hs, Ht, Hst.ls, b.lag, GP.mx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hals.snow_+3A_j">j</code></td>
<td>

<p>Index used by <code><a href="snowfall.html#topic+snowfall">snowfall</a></code>.  A scalar integer.  Which row of <code>GP.mx</code> to use for the ALS hyperparameters, <code>GP</code>.
</p>
</td></tr>
<tr><td><code id="Hals.snow_+3A_z">Z</code></td>
<td>

<p>Data.  A <code class="reqn">\tau</code> x <code class="reqn">n</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hals.snow_+3A_hs">Hs</code></td>
<td>

<p>Spacial covariates.  An <code class="reqn">n</code> x <code class="reqn">p_s</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hals.snow_+3A_ht">Ht</code></td>
<td>

<p>Temporal covariates.  An <code class="reqn">\tau</code> x <code class="reqn">p_t</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hals.snow_+3A_hst.ls">Hst.ls</code></td>
<td>

<p>Space-time covariates.  A list of length <code class="reqn">\tau</code>, each element containing a <code class="reqn">n</code> x <code class="reqn">p_st</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hals.snow_+3A_b.lag">b.lag</code></td>
<td>

<p>ALS lag.  A scalar integer, typically -1 (<em>a-prior</em>), or 0 (<em>a-posteriori</em>).
</p>
</td></tr>
<tr><td><code id="Hals.snow_+3A_gp.mx">GP.mx</code></td>
<td>

<p>Hyperparameters.  A <code class="reqn">k.glob</code> x 2 non-negative matrix.  See <code><a href="#topic+MSS.snow">MSS.snow</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">\tau</code> x <code class="reqn">n</code> numeric matrix.  The ALS predictions of <code>Z</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hals.fastcv.snow">Hals.fastcv.snow</a></code>, <code><a href="#topic+MSS.snow">MSS.snow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(9999)


library(SSsimple)

tau &lt;- 280
n.all &lt;- 35

Hs.all &lt;- matrix(rnorm(n.all), nrow=n.all)
Ht &lt;- matrix(rnorm(tau*2), nrow=tau)
Hst.ls.all &lt;- list()
for(i in 1:tau) { Hst.ls.all[[i]] &lt;- matrix(rnorm(n.all*3), nrow=n.all) }

Hst.combined &lt;- list()
for(i in 1:tau) { 
    Hst.combined[[i]] &lt;- cbind( Hs.all, matrix(Ht[i, ], nrow=n.all, 
    ncol=ncol(Ht), byrow=TRUE), Hst.ls.all[[i]] ) 
}

######## use SSsimple to simulate
sssim.obj &lt;- SS.sim.tv( 0.999, Hst.combined, 0.1, diag(1, n.all), tau )



Z.all &lt;- sssim.obj$Z
Z &lt;- Z.all
n &lt;- n.all

Hst.ls &lt;- Hst.ls.all

Hs &lt;- Hs.all

xrho &lt;- 1/10
xreg &lt;- 1/10
b.lag &lt;- -1

GP.mx &lt;- matrix(c(xrho, xreg), nrow=1)

Zcv &lt;- Hals.snow(j=1, Z, Hs, Ht, Hst.ls, b.lag, GP.mx) 


test.rng &lt;- 20:tau

errs.sq &lt;- (Z - Zcv)^2
sqrt( mean(errs.sq[test.rng, ]) )

</code></pre>

<hr>
<h2 id='Hst.sumup'>
Create Covariance Matrix
</h2><span id='topic+Hst.sumup'></span>

<h3>Description</h3>

<p>Calculate the covariance matrix of all model covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hst.sumup(Hst.ls, Hs = NULL, Ht = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hst.sumup_+3A_hst.ls">Hst.ls</code></td>
<td>

<p>Space-time covariates.  A list of length <code class="reqn">\tau</code>, each element containing a <code class="reqn">n</code> x <code class="reqn">p_st</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hst.sumup_+3A_hs">Hs</code></td>
<td>

<p>Spacial covariates.  An <code class="reqn">n</code> x <code class="reqn">p_s</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="Hst.sumup_+3A_ht">Ht</code></td>
<td>

<p>Temporal covariates.  An <code class="reqn">\tau</code> x <code class="reqn">p_t</code> numeric matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Important: The order of the arguments in this function is NOT the same as in the returned covariance matrix.  The order in the covariance matrix is the same as in other functions in this package:  <code>Hs</code>, <code>Ht</code>, <code>Hst.ls</code>.
</p>


<h3>Value</h3>

<p>A <code class="reqn">(p_s+p_t+p_st)</code> x <code class="reqn">(p_s+p_t+p_st)</code> numeric, symmetrix, non-negative definite matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
tau &lt;- 20
n &lt;- 10
Ht &lt;- cbind(sin(1:tau), cos(1:tau))

Hs &lt;- cbind(rnorm(10), rnorm(n, 5, 49))

Hst.ls &lt;- list()
for(tt in 1:tau) {
Hst.ls[[tt]] &lt;- cbind(rnorm(n, 1, 0.1), rnorm(n, -200, 21))
}


Hst.sumup(Hst.ls, Hs, Ht)



########### standardize all covariates

x1 &lt;- stnd.Hst.ls(Hst.ls, NULL)$sHst.ls
x2 &lt;- stnd.Hs(Hs, NULL, FALSE)$sHs
x3 &lt;- stnd.Ht(Ht, n)


Hst.sumup(x1, x2, x3)



## The function is currently defined as
function (Hst.ls, Hs = NULL, Ht = NULL) 
{
    tau &lt;- length(Hst.ls)
    if(tau &lt; 1) { tau &lt;- nrow(Ht) }
    if(is.null(tau)) { tau &lt;- 10 ; cat("tau assumed to be 10.", "\n") }
    n &lt;- nrow(Hst.ls[[1]])
    if(is.null(n)) { n &lt;- nrow(Hs) }
    big.sum &lt;- 0
    for (i in 1:tau) {
        if (!is.null(Ht)) {
            Ht.mx &lt;- matrix(Ht[i, ], n, ncol(Ht), byrow = TRUE)
        }
        else {
            Ht.mx &lt;- NULL
        }
        big.sum &lt;- big.sum + crossprod(cbind(Hs, Ht.mx, Hst.ls[[i]]))
    }
    return(big.sum)
  }
</code></pre>

<hr>
<h2 id='load.Hst.ls.2Zs'>
Load Observations into Space-Time Covariates
</h2><span id='topic+load.Hst.ls.2Zs'></span>

<h3>Description</h3>

<p>Insert an observation matrix into space-time covariates, but segregate based on missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.Hst.ls.2Zs(Z, Z.na, Hst.ls.Z, xwhich, rgr.lags = c(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.Hst.ls.2Zs_+3A_z">Z</code></td>
<td>

<p>Observation data.  A <code class="reqn">\tau</code> x <code class="reqn">n</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="load.Hst.ls.2Zs_+3A_z.na">Z.na</code></td>
<td>

<p>Missing data indicator.  A <code class="reqn">\tau</code> x <code class="reqn">n</code> boolean matrix.
</p>
</td></tr>
<tr><td><code id="load.Hst.ls.2Zs_+3A_hst.ls.z">Hst.ls.Z</code></td>
<td>

<p>Space-time covariates.  A list of length <code class="reqn">\tau</code>, each element should be a numeric <code class="reqn">n</code> x <code class="reqn">p_st</code> matrix.
</p>
</td></tr>
<tr><td><code id="load.Hst.ls.2Zs_+3A_xwhich">xwhich</code></td>
<td>

<p>Which column-pair of <code>Hst.ls.Z[[i]]</code> to insert into the <code class="reqn">i</code>th row of <code>Z</code>.  A scalar positive integer.  By 'column-pair', we mean, e.g., a value of 1 will fill columns 1 and 2, a value of 2 will fill columns 3 and 4, a value of 3 will fill columns 5 and 6, etc.
</p>
</td></tr>
<tr><td><code id="load.Hst.ls.2Zs_+3A_rgr.lags">rgr.lags</code></td>
<td>

<p>Temporal lagging of <code>Z</code>.  A scalar integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, along with <code><a href="#topic+load.Hst.ls.Z">load.Hst.ls.Z</a></code>, allows the user to convert a set of observations into covariates for another set of observations.  Unlike <code><a href="#topic+load.Hst.ls.Z">load.Hst.ls.Z</a></code>, this function <em>splits</em> <code>Z</code> based on the argument <code>Z.na</code>.  Values associated with <code>FALSE</code> elements of <code>Z.na</code> are placed into the first column of the specified column-pair of <code>Hst.ls.Z</code>, Values associated with <code>TRUE</code> elements of <code>Z.na</code> are placed into the second column of the specified column-pair of <code>Hst.ls.Z</code> (all other values in in the specified column-pair of <code>Hst.ls.Z</code> are zeroed).
</p>


<h3>Value</h3>

<p>An unnamed list of length <code class="reqn">\tau</code>, each element will be a numeric <code class="reqn">n</code> x <code class="reqn">p_st</code> matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load.Hst.ls.Z">load.Hst.ls.Z</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

###### here's an itty-bitty example

tau &lt;- 7
n &lt;- 5

Z &lt;- matrix(1, tau, n)

Z.na &lt;- matrix(FALSE, tau, n)
Z.na[2:3, 4] &lt;- TRUE

Z[Z.na] &lt;- 2

Hst.ls &lt;- list()
for(i in 1:tau) { Hst.ls[[i]] &lt;- matrix(rnorm(n*4), nrow=n) }


load.Hst.ls.2Zs(Z, Z.na, Hst.ls.Z=Hst.ls, 1, 0)


########## insert into cols 3 and 4

load.Hst.ls.2Zs(Z, Z.na, Hst.ls.Z=Hst.ls, 2, 0)


</code></pre>

<hr>
<h2 id='load.Hst.ls.Z'>
Load Observations into Space-Time Covariates
</h2><span id='topic+load.Hst.ls.Z'></span>

<h3>Description</h3>

<p>Insert an observation matrix into space-time covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.Hst.ls.Z(Z, Hst.ls.Z, xwhich, rgr.lags = c(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.Hst.ls.Z_+3A_z">Z</code></td>
<td>

<p>Observation data.  A <code class="reqn">\tau</code> x <code class="reqn">n</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="load.Hst.ls.Z_+3A_hst.ls.z">Hst.ls.Z</code></td>
<td>

<p>Space-time covariates.  A list of length <code class="reqn">\tau</code>, each element should be a numeric <code class="reqn">n</code> x <code class="reqn">p_st</code> matrix. 
</p>
</td></tr>
<tr><td><code id="load.Hst.ls.Z_+3A_xwhich">xwhich</code></td>
<td>

<p>Which column of <code>Hst.ls.Z[[i]]</code> to insert into the <code class="reqn">i</code>th row of <code>Z</code>.  A scalar positive integer.
</p>
</td></tr>
<tr><td><code id="load.Hst.ls.Z_+3A_rgr.lags">rgr.lags</code></td>
<td>

<p>Temporal lagging of <code>Z</code>.  A scalar integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, along with <code><a href="#topic+load.Hst.ls.2Zs">load.Hst.ls.2Zs</a></code>, allows the user to convert a set of observations into covariates for another set of observations.  
</p>


<h3>Value</h3>

<p>An unnamed list of length <code class="reqn">\tau</code>, each element will be a numeric <code class="reqn">n</code> x <code class="reqn">p_st</code> matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load.Hst.ls.2Zs">load.Hst.ls.2Zs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


###### here's an itty-bitty example

tau &lt;- 7
n &lt;- 5

Z &lt;- matrix(1, tau, n)

Hst.ls &lt;- list()
for(i in 1:tau) { Hst.ls[[i]] &lt;- matrix(rnorm(n*4), nrow=n) }

load.Hst.ls.Z(Z, Hst.ls.Z=Hst.ls, 1, 0)


########## insert into col 3

load.Hst.ls.Z(Z, Hst.ls.Z=Hst.ls, 3, 0)




############ lag Z examples

Z &lt;- matrix(1:tau, tau, n)

######### lag -1 Z

load.Hst.ls.Z(Z, Hst.ls.Z=Hst.ls, 1, -1)

######### lag 0 Z -- default

load.Hst.ls.Z(Z, Hst.ls.Z=Hst.ls, 1, 0)

######### lag +1 Z

load.Hst.ls.Z(Z, Hst.ls.Z=Hst.ls, 1, +1)



</code></pre>

<hr>
<h2 id='MSS.snow'>
Metaheuristic Stochastic Search
</h2><span id='topic+MSS.snow'></span>

<h3>Description</h3>

<p>Locate WIDALS hyperparameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSS.snow(FUN.source, current.best, p.ndx.ls, f.d, sds.mx, k.glob, k.loc.coef, X = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSS.snow_+3A_fun.source">FUN.source</code></td>
<td>

<p>Search function definitions (see Details).  A path to source code, or function, e.g., <code><a href="#topic+fun.load.widals.a">fun.load.widals.a</a></code>.
</p>
</td></tr>
<tr><td><code id="MSS.snow_+3A_current.best">current.best</code></td>
<td>

<p>An initial cost.  A scalar.  Setting to NA will cause <code>MSS.snow</code> to make an initial pass over the data to create an initial cost to beat.
</p>
</td></tr>
<tr><td><code id="MSS.snow_+3A_p.ndx.ls">p.ndx.ls</code></td>
<td>

<p>Hyperparameter indices (of <code>GP</code>) to search.  A list of vectors.  For example, <code>list( c(1,2), c(3,4,5) )</code> will instruct <code>MSS.snow</code>, for each local search, to search over the first two hyperparameters as a pair, then to search the last three as a group.
</p>
</td></tr>
<tr><td><code id="MSS.snow_+3A_f.d">f.d</code></td>
<td>

<p>Local search functions.  A list of functions (one for each element of GP).  Typically, for WIDALS, all five will be <code><a href="#topic+dlog.norm">dlog.norm</a></code>.
</p>
</td></tr>
<tr><td><code id="MSS.snow_+3A_sds.mx">sds.mx</code></td>
<td>

<p>The standard deviations for <code>f.d</code>.  An <em>k.glob</em> x <em>q</em> matrix, where <em>q</em> is the number of hyperparameters, i.e., the length of GP.
</p>
</td></tr>
<tr><td><code id="MSS.snow_+3A_k.glob">k.glob</code></td>
<td>

<p>The number of global searches.  A scalar integer.
</p>
</td></tr>
<tr><td><code id="MSS.snow_+3A_k.loc.coef">k.loc.coef</code></td>
<td>

<p>The coeficient for the number of local searches to make.  A scalar integer.
</p>
</td></tr>
<tr><td><code id="MSS.snow_+3A_x">X</code></td>
<td>

<p>A placeholder for values to be passed between functions inside <code>MSS.snow</code> (see Details).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the presence of a number of values and functions out-of-scope.  It is assumed that these are available in the Global Environment.  They are: <code>run.parallel</code> (boolean), <code>FUN.MH</code> (a function that creates, for a given <code>GP</code>, a cost), <code>FUN.GP</code> (a function that applies constraints to <code>GP</code>), <code>FUN.I</code> (a function that does something when local searches have reduced the cost), <code>FUN.EXIT</code> (a function that does something when <code>MSS.snow</code> is done). 
</p>
<p>Examine the code for <code><a href="#topic+fun.load.widals.a">fun.load.widals.a</a></code> for an example of the four functions described above.  Note that these four functions may themselves require objects out-of-scope.
</p>
<p>In general, for a given <code>R</code> session, special care should be taken concerning the naming and assigning of the following objects: <code>Z</code> (the space-time data), <code>Z.na</code> (a boolean matrix indicating missing values in <code>Z</code>), <code>locs</code> (site locations), <code>Hs</code> (spacial covariates), <code>Ht</code> (temporal covariates), <code>Hst.ls</code> (space-time covariates), <code>lags</code> (temporal lag vector), <code>b.lag</code> (the ALS lag), <code>cv</code> (cross-validation switch), <code>xgeodesic</code> (boolean), <code>ltco</code> (weight cut-off), <code>GP</code> (hyperparameter vector), <code>run.parralel</code> (boolean), <code>stnd.d</code> (boolean), <code>train.rng</code> (time index vector), <code>test.rng</code> (time index vector).
</p>


<h3>Value</h3>

<p>Nothing.  After completion, the best hyperparameters, <code>GP</code>, are assigned to the Global Environment.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hals.fastcv.snow">Hals.fastcv.snow</a></code>, <code><a href="#topic+Hals.snow">Hals.snow</a></code>, <code><a href="#topic+widals.snow">widals.snow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##### simulate a state-space system (using pkg SSsimple)

## Not run: 

### using dontrun because of excessive run time for CRAN submission

set.seed(9999)

library(SSsimple)


tau &lt;- 77 #### number of time points

d.alpha &lt;- 2
R.scale &lt;- 1
sigma2 &lt;- 0.01
F &lt;- 0.999
Q &lt;- 0.1

udom &lt;- (0:300)/100
plot( udom,    R.scale * exp(-d.alpha*udom) ,  type="l", col="red" ) #### see the covariogram

n.all &lt;- 70 ##### number of spacial locations

set.seed(9999)
locs.all &lt;- cbind(runif(n.all, -1, 1), runif(n.all, -1, 1)) #### random location of sensors

D.mx &lt;- distance(locs.all, locs.all, FALSE) #### distance matrix

#### create measurement variance using distance and covariogram
R.all &lt;- exp(-d.alpha*D.mx) + diag(sigma2, n.all) 

Hs.all &lt;- matrix(1, n.all, 1) #### constant mean function

##### use SSsimple to simulate system
xsssim &lt;- SS.sim(F=F, H=Hs.all, Q=Q, R=R.all, length.out=tau, beta0=0)

Z.all &lt;- xsssim$Z ###### system observation matrix

	
	
########### now make assignments required by MSS.snow
	


##### randomly remove five sites to serve as interpolation points
ndx.interp &lt;- sample(1:n.all, size=5) 
ndx.support &lt;- I(1:n.all)[ -ndx.interp ] ##### support sites



########### what follows are important assignments, 
########### since MSS.snow and the four helper functions
########### will look for these in the Global Environment 
########### to commence fitting the model (as noted in Details above)
train.rng &lt;- 30:(tau) ; test.rng &lt;- train.rng

Z &lt;- Z.all[ , ndx.support ] 
Hs &lt;- Hs.all[ ndx.support, , drop=FALSE] 
locs &lt;- locs.all[ndx.support, , drop=FALSE] 

Ht &lt;- NULL
Hst.ls &lt;- NULL

lags &lt;- c(0) 
b.lag &lt;- c(-1) 
cv &lt;- -2
xgeodesic &lt;- FALSE
stnd.d &lt;- FALSE
ltco &lt;- -10
GP &lt;- c(1/10, 1, 20, 20, 1) ### -- initial hyperparameter values
run.parallel &lt;- TRUE 

if( cv==2 ) { rm.ndx &lt;- create.rm.ndx.ls( nrow(Hs), 14 ) } else { rm.ndx &lt;- 1:nrow(Hs) }
rgr.lower.limit &lt;- 10^(-7) ; d.alpha.lower.limit &lt;- 10^(-3) ; rho.upper.limit &lt;- 10^(4)


############## tell snowfall to use two threads for local searches
sfInit(TRUE, cpus=2)
fun.load.widals.a()


######## now, finally, search for best fit over support
######## Note that p.ndx.ls and f.d are produced inside fun.load.widals.a()
MSS.snow(fun.load.widals.a, NA, p.ndx.ls, f.d, matrix(1/10, 10, length(GP)), 10, 7)
sfStop()

######## we can use these hyperparameters to interpolate to the 
######## deliberately removed sites, and measure MSE, RMSE
Z0.hat &lt;- widals.predict(Z, Hs, Ht, Hst.ls, locs, lags, b.lag, 
Hs0=Hs.all[ ndx.interp, , drop=FALSE ], 
Hst0.ls=NULL, locs0=locs.all[ ndx.interp, , drop=FALSE],
geodesic = xgeodesic, wrap.around = NULL, GP, stnd.d = stnd.d, ltco = ltco)

resids.wid &lt;- ( Z.all[ , ndx.interp ] - Z0.hat )
mse.wid &lt;- mean( resids.wid[ test.rng, ]^2 )
mse.wid
sqrt(mse.wid)






########################################### Simulated Imputation with WIDALS
Z.all &lt;- xsssim$Z
Z.missing &lt;- Z.all

Z.na.all &lt;- matrix( sample(c(TRUE, FALSE), size=n.all*tau, prob=c(0.01, 0.99), replace=TRUE), 
tau, n.all)
Z.missing[ Z.na.all ] &lt;- NA


Z &lt;- Z.missing
Z[ is.na(Z) ] &lt;- mean(Z, na.rm=TRUE)
X &lt;- list("Z.fill"=Z)

Z.na &lt;- Z.na.all
Hs &lt;- Hs.all
locs &lt;- locs.all
Ht &lt;- NULL
Hst.ls &lt;- NULL
lags &lt;- c(0)
b.lag &lt;- c(-1)
cv &lt;- -2
xgeodesic &lt;- FALSE
ltco &lt;- -10
if( cv==2 ) { rm.ndx &lt;- create.rm.ndx.ls( nrow(Hs), 14 ) } else { rm.ndx &lt;- 1:nrow(Hs) }

GP &lt;- c(1/10, 1, 20, 20, 1)

rgr.lower.limit &lt;- 10^(-7) ; d.alpha.lower.limit &lt;- 10^(-3) ; rho.upper.limit &lt;- 10^(4)

run.parallel &lt;- TRUE

sfInit(TRUE, cpus=2)
fun.load.widals.fill()

MSS.snow(fun.load.widals.fill, NA, p.ndx.ls, f.d, 
seq(2, 0.01, length=10)*matrix(1/10, 10, length(GP)), 10, 7, X=X)
sfStop()

sqrt(mean(( (Z.all[train.rng, ] - Z.fill[train.rng, ])^2 )[ Z.na[ train.rng, ] ]))



    
    
    
    

############################################ Now Try with ALS alone

Z.all &lt;- xsssim$Z

GP &lt;- c(1/10, 1) ### -- initial hyperparameter values

############## tell snowfall to use two threads for local searches
sfInit(TRUE, cpus=2)
fun.load.hals.a()

######## now, finally, search for best fit over support
######## Note that p.ndx.ls and f.d are produced inside fun.load.widals.a()
MSS.snow(fun.load.hals.a, NA, p.ndx.ls, f.d, matrix(1/10, 10, length(GP)), 10, 7)
sfStop()

######## we can use these hyperparameters to interpolate to the deliberately removed sites, 
######## and measure MSE, RMSE
hals.obj &lt;- H.als.b(Z, Hs, Ht, Hst.ls, rho=GP[1], reg=GP[2], b.lag = b.lag, 
Hs0 = Hs.all[ ndx.interp, , drop=FALSE ], Ht0 = NULL, Hst0.ls = NULL)
Z0.hat &lt;- hals.obj$Z0.hat

resids.als &lt;- ( Z.all[ , ndx.interp ] - Z0.hat )
mse.als &lt;- mean( resids.als[ test.rng, ]^2 )
mse.als
sqrt(mse.als)



########################################### Simulated Imputation with ALS
Z.all &lt;- xsssim$Z
Z.missing &lt;- Z.all

set.seed(99)
Z.na.all &lt;- matrix( sample(c(TRUE, FALSE), size=n.all*tau, prob=c(0.03, 0.97), replace=TRUE), 
tau, n.all)
Z.missing[ Z.na.all ] &lt;- NA


Z &lt;- Z.missing
Z[ is.na(Z) ] &lt;- 0 #mean(Z, na.rm=TRUE)
X &lt;- list("Z.fill"=Z)
    
Z.na &lt;- Z.na.all

Hs &lt;- Hs.all

GP &lt;- c(1/10, 1) ### -- initial hyperparameter values

sfInit(TRUE, cpus=2)
fun.load.hals.fill()

MSS.snow(fun.load.hals.fill, NA, p.ndx.ls, f.d, 
seq(3, 0.01, length=10)*matrix(1, 10, length(GP)), 10, 7, X=X)
sfStop()

sqrt(mean(( (Z.all[train.rng, ] - Z.fill[train.rng, ])^2 )[ Z.na[ train.rng, ] ]))


## End(Not run)

</code></pre>

<hr>
<h2 id='O3'>
California Ozone
</h2><span id='topic+O3'></span>

<h3>Description</h3>

<p>Daily airborne Ozone concentrations (ppb) over California, 68 fixed sensors, 2005-2006
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(O3)</code></pre>


<h3>Format</h3>

<p>The format is:
</p>
<p>List of 5
</p>
<p><code>$Z</code>      :'data.frame': 730 obs. of  68 variables: Ozone ppb for 68 sensors.
</p>
<p><code>$locs</code>   :'data.frame': 68 obs. of  2 variables: longitude, latitude for 68 sites.
</p>
<p><code>$helevs</code> : elevations (meters) for 68 sites.
</p>
<p><code>$locs0</code>  : 2358 obs. of  2 variables: longitude, latitude for interpolation grid.
</p>
<p><code>$helevs0</code>: elevations (meters) for 2358 interpolation grid sites.
</p>


<h3>Source</h3>

<p>The Ozone data originates from the California Air Resources Board (CARB).  The interpolation grid elevations originate from the Google Elevation API.
</p>


<h3>References</h3>

<p>The O3 data comes from the California Air Resources Board (CARB).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(O3)
</code></pre>

<hr>
<h2 id='rm.cols.Hst.ls'>
Remove Space-Time Covariates from Model
</h2><span id='topic+rm.cols.Hst.ls'></span>

<h3>Description</h3>

<p>Remove spacial covariates from space-time covariate list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.cols.Hst.ls(Hst.ls, rm.col.ndx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm.cols.Hst.ls_+3A_hst.ls">Hst.ls</code></td>
<td>

<p>Space-time covariates (of supporting sites).  A list of length <code class="reqn">\tau</code>, each element should be a numeric <code class="reqn">n</code> x <code class="reqn">p_st</code> matrix. 
</p>
</td></tr>
<tr><td><code id="rm.cols.Hst.ls_+3A_rm.col.ndx">rm.col.ndx</code></td>
<td>

<p>Which columns of <code>Hst.ls</code> to remove.  A positive scalar integer.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unnamed list of length <code class="reqn">\tau</code>, each element will be a numeric <code class="reqn">n</code> x <code class="reqn">p_st - p_rm</code> matrix, where <code class="reqn">p_rm</code> is the length of <code>rm.col.ndx</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
tau &lt;- 21
n &lt;- 7
	
pst &lt;- 5
Hst.ls &lt;- list()
for(i in 1:tau) { Hst.ls[[i]] &lt;- matrix(1:pst, n, pst, byrow=TRUE) }

rm.cols.Hst.ls(Hst.ls, c(1,3))


## The function is currently defined as
function (Hst.ls, rm.col.ndx) 
{
    tau &lt;- length(Hst.ls)
    for (i in 1:tau) {
        Hst.ls[[i]] &lt;- Hst.ls[[i]][, -rm.col.ndx, drop = FALSE]
    }
    return(Hst.ls)
  }
</code></pre>

<hr>
<h2 id='stnd.Hs'>
Standardize Spacial Covariates
</h2><span id='topic+stnd.Hs'></span>

<h3>Description</h3>

<p>Standardize spacial covariates with respect to both the space and time dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stnd.Hs(Hs, Hs0 = NULL, intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stnd.Hs_+3A_hs">Hs</code></td>
<td>

<p>Spacial covariates (of supporting sites).  An <code class="reqn">n</code> x <code class="reqn">p_s</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="stnd.Hs_+3A_hs0">Hs0</code></td>
<td>

<p>Spacial covariates (of interpolation sites).  An <code class="reqn">n</code>* x <code class="reqn">p_s</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="stnd.Hs_+3A_intercept">intercept</code></td>
<td>

<p>Include intercept term?  Boolean.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list.
</p>
<table>
<tr><td><code>sHs</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p_s</code> numeric matrix.</p>
</td></tr>
<tr><td><code>sHs0</code></td>
<td>
<p>An <code class="reqn">n</code>* x <code class="reqn">p_s</code> numeric matrix.</p>
</td></tr>
<tr><td><code>h.mean</code></td>
<td>
<p>The covariates' mean over space.</p>
</td></tr>
<tr><td><code>h.sd</code></td>
<td>
<p>The covariates' standard deviation over space.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of support sites.</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>The supplied intercept argument.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+stnd.Ht">stnd.Ht</a></code>, <code><a href="#topic+stnd.Hst.ls">stnd.Hst.ls</a></code>, <code><a href="#topic+applystnd.Hs">applystnd.Hs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##### Please see the examples in Hst.sumup



## The function is currently defined as
function (Hs, Hs0 = NULL, intercept = TRUE) 
{
    n &lt;- nrow(Hs)
    h.mean &lt;- apply(Hs, 2, mean)
    h.sd &lt;- apply(t(t(Hs) - h.mean), 2, function(x) {
        sqrt(sum(x^2))
    })
    h.sd[h.sd == 0] &lt;- 1
    sHs &lt;- t((t(Hs) - h.mean)/h.sd)
    if (intercept) {
        sHs[, 1] &lt;- 1/sqrt(n)
    }
    sHs0 &lt;- NULL
    if (!is.null(Hs0)) {
        sHs0 &lt;- t((t(Hs0) - h.mean)/h.sd)
        if (intercept) {
            sHs0[, 1] &lt;- 1/sqrt(n)
        }
    }
    ls.out &lt;- list(sHs = sHs, sHs0 = sHs0, h.mean = h.mean, h.sd = h.sd, 
        n = n, intercept = intercept)
    return(ls.out)
  }
</code></pre>

<hr>
<h2 id='stnd.Hst.ls'>
Standardize Space-Time Covariates
</h2><span id='topic+stnd.Hst.ls'></span>

<h3>Description</h3>

<p>Standardize spacio-temporal covariates with respect to both the spacial and time dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stnd.Hst.ls(Hst.ls, Hst0.ls = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stnd.Hst.ls_+3A_hst.ls">Hst.ls</code></td>
<td>

<p>Space-time covariates (of supporting sites).  A list of length <code class="reqn">\tau</code>, each element should be a numeric <code class="reqn">n</code> x <code class="reqn">p_st</code> matrix. 
</p>
</td></tr>
<tr><td><code id="stnd.Hst.ls_+3A_hst0.ls">Hst0.ls</code></td>
<td>

<p>Space-time covariates (of interpolation sites).  A list of length <code class="reqn">\tau</code>, each element should be a numeric <code class="reqn">n</code>* x <code class="reqn">p_st</code> matrix. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list.
</p>
<table>
<tr><td><code>sHst.ls</code></td>
<td>
<p>A list of length <code class="reqn">\tau</code>, each element a numeric <code class="reqn">n</code> x <code class="reqn">p_st</code> matrix.</p>
</td></tr>
<tr><td><code>sHst0.ls</code></td>
<td>
<p>A list of length <code class="reqn">\tau</code>, each element a <code class="reqn">n</code>* x <code class="reqn">p_st</code> matrix</p>
</td></tr>
<tr><td><code>h.mean</code></td>
<td>
<p>The covariates' mean over space-time.</p>
</td></tr>
<tr><td><code>h.sd</code></td>
<td>
<p>The covariates' standard deviation over space-time.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+stnd.Ht">stnd.Ht</a></code>, <code><a href="#topic+stnd.Hs">stnd.Hs</a></code>, <code><a href="#topic+applystnd.Hst.ls">applystnd.Hst.ls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
##### Please see the examples in Hst.sumup

## The function is currently defined as
function (Hst.ls, Hst0.ls = NULL) 
{
    tau &lt;- length(Hst.ls)
    big.sum &lt;- 0
    for (i in 1:tau) {
        big.sum &lt;- big.sum + apply(Hst.ls[[i]], 2, mean)
    }
    h.mean &lt;- big.sum/tau
    sHst.ls &lt;- list()
    big.sum.mx &lt;- 0
    for (i in 1:tau) {
        sHst.ls[[i]] &lt;- t(t(Hst.ls[[i]]) - h.mean)
        big.sum.mx &lt;- big.sum.mx + crossprod(sHst.ls[[i]])
    }
    cov.mx &lt;- big.sum.mx/tau
    sqrtXX &lt;- 1/sqrt(diag(cov.mx))
    for (i in 1:tau) {
        sHst.ls[[i]] &lt;- t(t(sHst.ls[[i]]) * sqrtXX)
    }
    sHst0.ls &lt;- NULL
    if (!is.null(Hst0.ls)) {
        sHst0.ls &lt;- list()
        for (i in 1:tau) {
            sHst0.ls[[i]] &lt;- t((t(Hst0.ls[[i]]) - h.mean) * sqrtXX)
        }
    }
    ls.out &lt;- list(sHst.ls = sHst.ls, sHst0.ls = sHst0.ls, h.mean = h.mean, 
        h.sd = 1/sqrtXX)
    return(ls.out)
  }
</code></pre>

<hr>
<h2 id='stnd.Ht'>
Standardize Temporal Covariates
</h2><span id='topic+stnd.Ht'></span>

<h3>Description</h3>

<p>Standardize temporal covariates with respect to both the spacial and time dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stnd.Ht(Ht, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stnd.Ht_+3A_ht">Ht</code></td>
<td>

<p>Temporal covariates (of supporting sites).  A <code class="reqn">\tau</code> x <code class="reqn">p_t</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="stnd.Ht_+3A_n">n</code></td>
<td>

<p>Number of sites.  A positive scalar integer.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">\tau</code> x <code class="reqn">p_t</code> numeric matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stnd.Hs">stnd.Hs</a></code>, <code><a href="#topic+stnd.Hst.ls">stnd.Hst.ls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##### Please see the examples in Hst.sumup


## The function is currently defined as
function (Ht, n) 
{
    h.mean &lt;- apply(Ht, 2, mean)
    sHt &lt;- t(t(Ht) - h.mean)
    sHt &lt;- t(t(sHt)/apply(sHt, 2, function(x) {
        sqrt(sum(x^2))
    }))
    sHt &lt;- sHt * sqrt(nrow(Ht)/n)
    return(sHt)
  }
</code></pre>

<hr>
<h2 id='subsetsites.Hst.ls'>
Site-Wise Extract Space-Time Covariates
</h2><span id='topic+subsetsites.Hst.ls'></span>

<h3>Description</h3>

<p>Extract space-time covariates by site
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetsites.Hst.ls(Hst.ls, xmask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetsites.Hst.ls_+3A_hst.ls">Hst.ls</code></td>
<td>

<p>Space-time covariates.  A list of length <code class="reqn">\tau</code>, each element should be a <code class="reqn">n</code> x <code class="reqn">p_st</code> numeric matrix. 
</p>
</td></tr>
<tr><td><code id="subsetsites.Hst.ls_+3A_xmask">xmask</code></td>
<td>

<p>Which sites to remove from <code>Hst.ls</code>.  A boolean vector of length <code class="reqn">n</code>, or a vector of spacial indices.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Space-time covariates.  A list of length <code class="reqn">\tau</code>, each element a <code class="reqn">c</code> x <code class="reqn">p_st</code> numeric matrix, where <code class="reqn">c</code> is the number of <code>TRUE</code>'s in boolean <code>xmask</code>, or length of index <code>xmask</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
tau &lt;- 70
n &lt;- 28

Hst.ls &lt;- list()
for(i in 1:tau) { Hst.ls[[i]] &lt;- matrix(rnorm(n*4), nrow=n) }

subsetsites.Hst.ls(Hst.ls, c(1,3,10))


subsetsites.Hst.ls(Hst.ls, c(TRUE, TRUE, rep(FALSE, n-2)))


## The function is currently defined as
function (Hst.ls, xmask) 
{
    tau &lt;- length(Hst.ls)
    Hst.ls.out &lt;- list()
    for (i in 1:tau) {
        Hst.ls.out[[i]] &lt;- Hst.ls[[i]][xmask, , drop = FALSE]
    }
    return(Hst.ls.out)
  }
</code></pre>

<hr>
<h2 id='unif.mh'>
Local Search Function
</h2><span id='topic+unif.mh'></span>

<h3>Description</h3>

<p>Search function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unif.mh(n, center, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unif.mh_+3A_n">n</code></td>
<td>

<p>Sample size.  A positive scalar integer.
</p>
</td></tr>
<tr><td><code id="unif.mh_+3A_center">center</code></td>
<td>

<p>Mean.  A numeric scalar (or vector).
</p>
</td></tr>
<tr><td><code id="unif.mh_+3A_sd">sd</code></td>
<td>

<p>Standard deviation.  A numeric scalar (or vector).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code class="reqn">n</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dlog.norm">dlog.norm</a></code>, <code><a href="#topic+MSS.snow">MSS.snow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- unif.mh(100, 1, 1)
hist(x)

## The function is currently defined as
function (n, center, sd) 
{
    w &lt;- sd * sqrt(3)
    a &lt;- center - w
    b &lt;- center + w
    x &lt;- runif(n, a, b)
    return(x)
  }
</code></pre>

<hr>
<h2 id='unload.Hst.ls'>
Convert a Space-Time Covariate into Data
</h2><span id='topic+unload.Hst.ls'></span>

<h3>Description</h3>

<p>Convert a spacio-temporal covariate into contemporaneous data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unload.Hst.ls(Hst.ls, which.col, rgr.lags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unload.Hst.ls_+3A_hst.ls">Hst.ls</code></td>
<td>

<p>Space-time covariates.  A list of length <code class="reqn">\tau</code>, each element should be a <code class="reqn">n</code> x <code class="reqn">p_st</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="unload.Hst.ls_+3A_which.col">which.col</code></td>
<td>

<p>Which column of <code>Hst.ls[[i]]</code> to insert into the <code class="reqn">i</code>th row of <code>Z</code>.  A scalar positive integer. 
</p>
</td></tr>
<tr><td><code id="unload.Hst.ls_+3A_rgr.lags">rgr.lags</code></td>
<td>

<p>Temporal lagging of <code>Z</code>.  A scalar integer.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric <code class="reqn">\tau</code> x <code class="reqn">n</code> matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load.Hst.ls.Z">load.Hst.ls.Z</a></code>, <code><a href="#topic+load.Hst.ls.2Zs">load.Hst.ls.2Zs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
###### here's an itty-bitty example

tau &lt;- 7
n &lt;- 5

Hst.ls &lt;- list()
for(i in 1:tau) { Hst.ls[[i]] &lt;- matrix(rnorm(n*4), nrow=n) }

Zh &lt;- unload.Hst.ls(Hst.ls, 1, 0)


## The function is currently defined as
function (Hst.ls, which.col, rgr.lags) 
{
    n &lt;- nrow(Hst.ls[[1]])
    tau &lt;- length(Hst.ls)
    Z.out &lt;- matrix(NA, tau, n)
    min.ndx &lt;- max(1, -min(rgr.lags) + 1)
    max.ndx &lt;- min(tau, tau - max(rgr.lags))
    for (i in min.ndx:max.ndx) {
        Z.out[i - rgr.lags, ] &lt;- Hst.ls[[i]][, which.col]
    }
    return(Z.out)
  }
</code></pre>

<hr>
<h2 id='widals.predict'>
WIDALS Interpolation
</h2><span id='topic+widals.predict'></span>

<h3>Description</h3>

<p>Interpolate to unmonitored sites using WIDALS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>widals.predict(Z, Hs, Ht, Hst.ls, locs, lags, b.lag, Hs0, Hst0.ls, locs0, 
geodesic = FALSE, wrap.around = NULL, GP, stnd.d = FALSE, ltco = -16)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="widals.predict_+3A_z">Z</code></td>
<td>

<p>Space-time data.  A <code class="reqn">\tau</code> x <code class="reqn">n</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_hs">Hs</code></td>
<td>

<p>Spacial covariates (of supporting sites).  An <code class="reqn">n</code> x <code class="reqn">p_s</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_ht">Ht</code></td>
<td>

<p>Temporal covariates (of supporting sites).  A <code class="reqn">\tau</code> x <code class="reqn">p_t</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_hst.ls">Hst.ls</code></td>
<td>

<p>Space-time covariates (of supporting sites).  A list of length <code class="reqn">\tau</code>, each element should be a <code class="reqn">n</code> x <code class="reqn">p_st</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_locs">locs</code></td>
<td>

<p>Locations of supporting sites.  An <em>n</em> x 2 numeric matrix, first column is spacial <code class="reqn">x</code>, second column is spacial <code class="reqn">y</code>.  If the <code>geodesic</code> is <code>TRUE</code>, make sure latitude is in the first column.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_lags">lags</code></td>
<td>

<p>Temporal lags for stochastic smoothing.  An integer vector or scalar.  E.g., if the data's time increment is daily, then <code>lags = c(-1,0,1)</code> would tell the enclosed function <code><a href="#topic+crispify">crispify</a></code> smooth today's predictions using yesterdays, today's, and tomorrow's observed residuals.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_b.lag">b.lag</code></td>
<td>

<p>ALS lag.  A scalar integer, typically -1 (<em>a-prior</em>), or 0 (<em>a-posteriori</em>).
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_hs0">Hs0</code></td>
<td>

<p>Spacial covariates (of interpolation sites).  An <code class="reqn">n</code>* x <code class="reqn">p_s</code> matrix, or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_hst0.ls">Hst0.ls</code></td>
<td>

<p>Space-time covariates (of interpolation sites).  A list of length <code class="reqn">\tau</code>, each element should be a numeric <code class="reqn">n</code> x <code class="reqn">p_st</code> matrix.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_locs0">locs0</code></td>
<td>

<p>Locations of interpolation sites.  An <em>n</em>* x 2 numeric matrix.  See <code>locs</code> argument above.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_geodesic">geodesic</code></td>
<td>

<p>Use geodesic distance?  Boolean.  If true, distance (used internally) is in units kilometers.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_wrap.around">wrap.around</code></td>
<td>

<p>**Unused.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_gp">GP</code></td>
<td>

<p>Widals hyperparameters.  A non-negative vector.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_stnd.d">stnd.d</code></td>
<td>

<p>Spacial compression.  Boolean.
</p>
</td></tr>
<tr><td><code id="widals.predict_+3A_ltco">ltco</code></td>
<td>

<p>Weight threshold.  A scalar number.  A value of, e.g., -10, will instruct <code>crispify</code> to ignore weights less than 10^(-10) when smoothing.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">\tau</code> x <code class="reqn">n</code>* matrix.  The WIDALS predictions at <code>locs0</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crispify">crispify</a></code>, <code><a href="#topic+H.als.b">H.als.b</a></code>, <code><a href="#topic+widals.snow">widals.snow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
#### similar to example provided in H.als.b.
	
set.seed(99999)


library(SSsimple)

tau &lt;- 70
n.all &lt;- 14

Hs.all &lt;- matrix(rnorm(n.all), nrow=n.all)
Ht &lt;- matrix(rnorm(tau*2), nrow=tau)
Hst.ls.all &lt;- list()
for(i in 1:tau) { Hst.ls.all[[i]] &lt;- matrix(rnorm(n.all*2), nrow=n.all) }

Hst.combined &lt;- list()
for(i in 1:tau) { 
    Hst.combined[[i]] &lt;- cbind( Hs.all, matrix(Ht[i, ], nrow=n.all, ncol=ncol(Ht), 
    byrow=TRUE), Hst.ls.all[[i]] ) 
}

locs.all &lt;- cbind(runif(n.all, -1, 1), runif(n.all, -1, 1))
D.mx.all &lt;- distance(locs.all, locs.all, FALSE)
R.all &lt;- exp(-2*D.mx.all) + diag(0.01, n.all)

######## use SSsimple to simulate
sssim.obj &lt;- SS.sim.tv( 0.999, Hst.combined, 0.01, R.all, tau )


ndx.support &lt;- 1:10
ndx.interp &lt;- 11:14

locs &lt;- locs.all[ndx.support, ]
locs0 &lt;- locs.all[ndx.interp, ]

Z.all &lt;- sssim.obj$Z
Z &lt;- Z.all[ , ndx.support]
Z0 &lt;- Z.all[ , ndx.interp]

Hst.ls &lt;- subsetsites.Hst.ls(Hst.ls.all, ndx.support)
Hst0.ls &lt;- subsetsites.Hst.ls(Hst.ls.all, ndx.interp)

Hs &lt;- Hs.all[ ndx.support, , drop=FALSE]
Hs0 &lt;- Hs.all[ ndx.interp, , drop=FALSE]

test.rng &lt;- 20:tau


################# use ALS
xrho &lt;- 1/10
xreg &lt;- 1/10
xALS &lt;- H.als.b(Z=Z, Hs=Hs, Ht=Ht, Hst.ls=Hst.ls, rho=xrho, reg=xreg, 
b.lag=-1, Hs0=Hs0, Ht0=Ht, Hst0.ls=Hst0.ls) 

errs.sq &lt;- (Z0 - xALS$Z0.hat)^2
sqrt( mean(errs.sq[test.rng, ]) )

################# now use WIDALS

GP &lt;- c(1/10, 1/10, 2, 0, 1)
Zwid &lt;- widals.predict(Z=Z, Hs=Hs, Ht=Ht, Hst.ls=Hst.ls, locs=locs, lags=c(0), 
b.lag=-1, Hs0=Hs0, Hst0.ls=Hst0.ls, locs0=locs0, FALSE, NULL, GP) 

errs.sq &lt;- (Z0 - Zwid)^2
sqrt( mean(errs.sq[test.rng, ]) )


</code></pre>

<hr>
<h2 id='widals.snow'>
Fit WIDALS
</h2><span id='topic+widals.snow'></span>

<h3>Description</h3>

<p>Locate the WIDALS hyperparameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>widals.snow(j, rm.ndx, Z, Hs, Ht, Hst.ls, locs, lags, b.lag, cv = 0, 
geodesic = FALSE, wrap.around = NULL, GP.mx, stnd.d = FALSE, ltco = -16)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="widals.snow_+3A_j">j</code></td>
<td>

<p>Index used by <code><a href="snowfall.html#topic+snowfall">snowfall</a></code>.  A scalar integer.  Which row of <code>GP.mx</code> to use for the ALS hyperparameters, <code>GP</code>.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_rm.ndx">rm.ndx</code></td>
<td>

<p>A list of vectors of indices to remove for <em>k</em>-fold cross-validation.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_z">Z</code></td>
<td>

<p>Data.  A <code class="reqn">\tau</code> x <code class="reqn">n</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_hs">Hs</code></td>
<td>

<p>Spacial covariates.  An <code class="reqn">n</code> x <code class="reqn">p_s</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_ht">Ht</code></td>
<td>

<p>Temporal covariates.  A <code class="reqn">\tau</code> x <code class="reqn">p_t</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_hst.ls">Hst.ls</code></td>
<td>

<p>Space-time covariates.  A list of length <code class="reqn">\tau</code>, each element containing a <code class="reqn">n</code> x <code class="reqn">p_st</code> numeric matrix.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_locs">locs</code></td>
<td>

<p>Locations of supporting sites.  An <em>n</em> x 2 numeric matrix, first column is spacial <code class="reqn">x</code>, second column is spacial <code class="reqn">y</code>.  If the <code>geodesic</code> is <code>TRUE</code>, make sure latitude is in the first column.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_lags">lags</code></td>
<td>

<p>Temporal lags for stochastic smoothing.  An integer vector or scalar.  E.g., if the data's time increment is daily, then <code>lags = c(-1,0,1)</code> would tell the enclosed function <code><a href="#topic+crispify">crispify</a></code> smooth today's predictions using yesterdays, today's, and tomorrow's observed residuals.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_b.lag">b.lag</code></td>
<td>

<p>ALS lag.  A scalar integer, typically -1 (<em>a-prior</em>), or 0 (<em>a-posteriori</em>).
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_cv">cv</code></td>
<td>

<p>Cross-validation switch.  Currently takes on a value of <code>-2</code> or <code>2</code>.  See Details below.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_geodesic">geodesic</code></td>
<td>

<p>Use geodesic distance?  Boolean.  If true, distance (used internally) is in units kilometers.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_wrap.around">wrap.around</code></td>
<td>

<p>**Unused.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_gp.mx">GP.mx</code></td>
<td>

<p>Hyperparameters.  A <code class="reqn">k.glob</code> x 2 non-negative matrix.  See <code><a href="#topic+MSS.snow">MSS.snow</a></code>.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_stnd.d">stnd.d</code></td>
<td>

<p>Spacial compression.  Boolean.
</p>
</td></tr>
<tr><td><code id="widals.snow_+3A_ltco">ltco</code></td>
<td>

<p>Weight threshold.  A scalar number.  A value of, e.g., -10, will instruct <code>crispify</code> to ignore weights less than 10^(-10) when smoothing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the <code>cv</code> is set to 2, then this function uses spacial <em>k</em>-fold validation, according to the site indices present in <code>rm.ndx</code>.  When <code>cv</code> is set to -2, self-referencing sites are given zero-weight, i.e., a site's value is not allowed to contribute to its predicted value.
</p>


<h3>Value</h3>

<p>A <code class="reqn">\tau</code> x <code class="reqn">n</code> matrix.  The WIDALS predictions at <code>locs</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crispify">crispify</a></code>, <code><a href="#topic+H.als.b">H.als.b</a></code>, <code><a href="#topic+widals.predict">widals.predict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
set.seed(99999)

library(SSsimple)

tau &lt;- 100
n.all &lt;- 35

Hs.all &lt;- matrix(rnorm(n.all), nrow=n.all)
Ht &lt;- matrix(rnorm(tau*2), nrow=tau)
Hst.ls.all &lt;- list()
for(i in 1:tau) { Hst.ls.all[[i]] &lt;- matrix(rnorm(n.all*2), nrow=n.all) }

Hst.combined &lt;- list()
for(i in 1:tau) { 
    Hst.combined[[i]] &lt;- cbind( Hs.all, matrix(Ht[i, ], nrow=n.all, ncol=ncol(Ht), 
    byrow=TRUE), Hst.ls.all[[i]] ) 
}

locs.all &lt;- cbind(runif(n.all, -1, 1), runif(n.all, -1, 1))
D.mx.all &lt;- distance(locs.all, locs.all, FALSE)
R.all &lt;- exp(-2*D.mx.all) + diag(0.01, n.all)

######## use SSsimple to simulate
sssim.obj &lt;- SS.sim.tv( 0.999, Hst.combined, 0.01, R.all, tau )


n &lt;- n.all
locs &lt;- locs.all

Z.all &lt;- sssim.obj$Z
Z &lt;- Z.all


Hst.ls &lt;- Hst.ls.all
Hs &lt;- Hs.all

test.rng &lt;- 20:tau

################  WIDALS, true cross-validation

rm.ndx &lt;- create.rm.ndx.ls(n, 10)

cv &lt;- 2
lags &lt;- c(0)
b.lag &lt;- 0

GP &lt;- c(1/8, 1/12, 5, 0, 1)
GP.mx &lt;- matrix(GP, ncol=length(GP))
Zwid &lt;- widals.snow(j=1, rm.ndx, Z, Hs, Ht, Hst.ls, locs, lags, b.lag, cv = cv, 
geodesic = FALSE, wrap.around = NULL, GP.mx, stnd.d = FALSE, ltco = -16) 

errs.sq &lt;- (Z - Zwid)^2
sqrt( mean(errs.sq[test.rng, ]) )


################  WIDALS, pseudo cross-validation

rm.ndx &lt;- I(1:n)

cv &lt;- -2
lags &lt;- c(0)
b.lag &lt;- -1

GP &lt;- c(1/8, 1/12, 5, 0, 1)
GP.mx &lt;- matrix(GP, ncol=length(GP))
Zwid &lt;- widals.snow(j=1, rm.ndx, Z, Hs, Ht, Hst.ls, locs, lags, b.lag, cv = cv, 
geodesic = FALSE, wrap.around = NULL, GP.mx, stnd.d = FALSE, ltco = -16) 

errs.sq &lt;- (Z - Zwid)^2
sqrt( mean(errs.sq[test.rng, ]) )


</code></pre>

<hr>
<h2 id='Z.clean.up'>
Clean Data
</h2><span id='topic+Z.clean.up'></span>

<h3>Description</h3>

<p>A crude, brute-force way to destroy bad values in data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Z.clean.up(Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Z.clean.up_+3A_z">Z</code></td>
<td>

<p>Data.  A <code class="reqn">\tau</code> x <code class="reqn">n</code> matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces intractable values, e.g., <code>NA</code>, or <code>-Inf</code>, in data, with the global mean. 
</p>


<h3>Value</h3>

<p>A <code class="reqn">\tau</code> x <code class="reqn">n</code> numeric matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tau &lt;- 10
n &lt;- 7

Z &lt;- matrix(1, tau, n)
Z[2,4] &lt;- -Inf
Z[3,4] &lt;- Inf
Z[4,4] &lt;- NA
Z[5,4] &lt;- log(-1)
Z

Z.clean.up(Z)





## The function is currently defined as
function (Z) 
{
    Z[Z == Inf | Z == -Inf] &lt;- NA
    Z[is.na(Z) | is.nan(Z)] &lt;- mean(Z, na.rm = TRUE)
    return(Z)
  }
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
