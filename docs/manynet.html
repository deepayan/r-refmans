<!DOCTYPE html><html><head><title>Help for package manynet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {manynet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_nodes'><p>Modifying node data</p></a></li>
<li><a href='#add_ties'><p>Modifying tie data</p></a></li>
<li><a href='#as'><p>Modifying network classes</p></a></li>
<li><a href='#attributes'><p>Describing attributes of nodes or ties in a network</p></a></li>
<li><a href='#autographr'><p>Easily graph networks with sensible defaults</p></a></li>
<li><a href='#autographs'><p>Easily graph a set of networks with sensible defaults</p></a></li>
<li><a href='#autographt'><p>Easily animate dynamic networks with sensible defaults</p></a></li>
<li><a href='#configuration_layouts'><p>Layout algorithms based on configurational positions</p></a></li>
<li><a href='#create'><p>Making networks with defined structures</p></a></li>
<li><a href='#features'><p>Marking networks features</p></a></li>
<li><a href='#from'><p>Joining lists of networks, graphs, and matrices</p></a></li>
<li><a href='#generate'><p>Making networks with a stochastic element</p></a></li>
<li><a href='#is'><p>Marking networks classes</p></a></li>
<li><a href='#is_format'><p>Marking networks formats</p></a></li>
<li><a href='#ison_adolescents'><p>One-mode subset of the adolescent society network (Coleman 1961)</p></a></li>
<li><a href='#ison_algebra'><p>Multiplex graph object of friends, social, and task ties (McFarland 2001)</p></a></li>
<li><a href='#ison_brandes'><p>One-mode and two-mode centrality demonstration networks</p></a></li>
<li><a href='#ison_friends'><p>One-mode Friends character connections (McNulty, 2020)</p></a></li>
<li><a href='#ison_hightech'><p>One-mode multiplex, directed network of managers of a high-tech company (Krackhardt 1987)</p></a></li>
<li><a href='#ison_karateka'><p>One-mode karateka network (Zachary 1977)</p></a></li>
<li><a href='#ison_koenigsberg'><p>One-mode Seven Bridges of Koenigsberg network (Euler 1741)</p></a></li>
<li><a href='#ison_laterals'><p>Two-mode projection examples (Hollway 2021)</p></a></li>
<li><a href='#ison_lawfirm'><p>One-mode lawfirm (Lazega 2001)</p></a></li>
<li><a href='#ison_lotr'><p>One-mode network of Lord of the Rings character interactions</p></a></li>
<li><a href='#ison_marvel'><p>Multilevel two-mode affiliation, signed one-mode networks of Marvel comic</p>
book characters (Yuksel 2017)</a></li>
<li><a href='#ison_monastery'><p>Three one-mode signed, weighted networks and a three-wave longitudinal network of monks (Sampson 1969)</p></a></li>
<li><a href='#ison_networkers'><p>One-mode EIES dataset (Freeman and Freeman 1979)</p></a></li>
<li><a href='#ison_physicians'><p>Four multiplex one-mode physician diffusion data (Coleman, Katz, and Menzel, 1966)</p></a></li>
<li><a href='#ison_potter'><p>Six complex one-mode support data in Harry Potter books (Bossaert and Meidert 2013)</p></a></li>
<li><a href='#ison_southern_women'><p>Two-mode southern women (Davis, Gardner and Gardner 1941)</p></a></li>
<li><a href='#ison_starwars'><p>Seven one-mode Star Wars character interactions (Gabasova 2016)</p></a></li>
<li><a href='#ison_usstates'><p>One-mode undirected network of US state contiguity (Meghanathan 2017)</p></a></li>
<li><a href='#learning'><p>Making learning models on networks</p></a></li>
<li><a href='#many_palettes'><p>Many palettes generator</p></a></li>
<li><a href='#mark_diff'><p>Marking nodes based on diffusion properties</p></a></li>
<li><a href='#mark_nodes'><p>Marking nodes based on structural properties</p></a></li>
<li><a href='#mark_select'><p>Marking nodes for selection based on measures</p></a></li>
<li><a href='#mark_tie_select'><p>Marking ties for selection based on measures</p></a></li>
<li><a href='#mark_ties'><p>Marking ties based on structural properties</p></a></li>
<li><a href='#miss'><p>Modifying missing tie data</p></a></li>
<li><a href='#partition_layouts'><p>Layout algorithms based on bi- or other partitions</p></a></li>
<li><a href='#play'><p>Making diffusion models on networks</p></a></li>
<li><a href='#properties'><p>Describing network properties</p></a></li>
<li><a href='#read'><p>Making networks from external files</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reformat'><p>Modifying network formats</p></a></li>
<li><a href='#scales'><p>Many scales</p></a></li>
<li><a href='#split'><p>Splitting networks into lists</p></a></li>
<li><a href='#themes'><p>Many themes</p></a></li>
<li><a href='#to_levels'><p>Modifying network levels</p></a></li>
<li><a href='#to_paths'><p>Modifying networks paths</p></a></li>
<li><a href='#to_project'><p>Modifying networks projection</p></a></li>
<li><a href='#to_scope'><p>Modifying networks scope</p></a></li>
<li><a href='#tutorials'><p>Open and extract code from tutorials</p></a></li>
<li><a href='#write'><p>Making networks to external files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Many Ways to Make, Modify, Mark, and Map Myriad Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-15</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for making, modifying, marking, and mapping many different types of networks.
   All functions operate with matrices, edge lists, and 'igraph', 'network', and 'tidygraph' objects,
   and on one-mode, two-mode (bipartite), and sometimes three-mode networks.
   The package includes functions for importing and exporting, creating and generating networks,
   modifying networks and node and tie attributes,
   and describing and visualizing networks with sensible defaults.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://stocnet.github.io/manynet/">https://stocnet.github.io/manynet/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stocnet/manynet/issues">https://github.com/stocnet/manynet/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.1.0), ggplot2, ggraph, igraph (&ge; 1.6.0), network,
pillar, tidygraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BiocManager, concaveman, gganimate, ggforce, gifski,
graphlayouts, grDevices, knitr, learnr, methods, migraph,
minMSE, multiplex, patchwork, png, readxl, rmarkdown, roxygen2,
RSiena, testthat (&ge; 3.0.0), xml2, future, furrr</td>
</tr>
<tr>
<td>Enhances:</td>
<td>Rgraphviz</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>mark_is</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-15 18:52:27 UTC; hollway</td>
</tr>
<tr>
<td>Author:</td>
<td>James Hollway <a href="https://orcid.org/0000-0002-8361-9647"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, ctb] (IHEID),
  Henrique Sposito <a href="https://orcid.org/0000-0003-3420-6085"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (IHEID)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Hollway &lt;james.hollway@graduateinstitute.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-15 19:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_nodes'>Modifying node data</h2><span id='topic+add_nodes'></span><span id='topic+delete_nodes'></span><span id='topic+add_node_attribute'></span><span id='topic+mutate_nodes'></span><span id='topic+mutate'></span><span id='topic+bind_node_attributes'></span><span id='topic+join_nodes'></span><span id='topic+rename_nodes'></span><span id='topic+rename'></span><span id='topic+filter_nodes'></span>

<h3>Description</h3>

<p>These functions allow users to add and delete nodes and their attributes:
</p>

<ul>
<li> <p><code>add_nodes()</code> adds an additional number of nodes to network data.
</p>
</li>
<li> <p><code>delete_nodes()</code> deletes nodes from network data.
</p>
</li>
<li> <p><code>add_node_attribute()</code>, <code>mutate()</code>, or <code>mutate_nodes()</code> offer ways to add
a vector of values to a network as a nodal attribute.
</p>
</li>
<li> <p><code>rename_nodes()</code> and <code>rename()</code> rename nodal attributes.
</p>
</li>
<li> <p><code>bind_node_attributes()</code> appends all nodal attributes from one network to another,
and <code>join_nodes()</code> merges all nodal attributes from one network to another.
</p>
</li>
<li> <p><code>filter_nodes()</code> subsets nodes based on some nodal attribute-related logical statement.
</p>
</li></ul>

<p>Note that while <code style="white-space: pre;">&#8288;add_*()&#8288;</code>/<code style="white-space: pre;">&#8288;delete_*()&#8288;</code> functions operate similarly as comparable <code>{igraph}</code> functions,
<code style="white-space: pre;">&#8288;mutate*()&#8288;</code>, <code style="white-space: pre;">&#8288;bind*()&#8288;</code>, etc work like <code>{tidyverse}</code> or <code>{dplyr}</code>-style functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_nodes(.data, nodes, attribute = NULL)

delete_nodes(.data, nodes)

add_node_attribute(.data, attr_name, vector)

mutate_nodes(.data, ...)

mutate(.data, ...)

bind_node_attributes(.data, object2)

join_nodes(
  .data,
  object2,
  .by = NULL,
  join_type = c("full", "left", "right", "inner")
)

rename_nodes(.data, ...)

rename(.data, ...)

filter_nodes(.data, ..., .by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_nodes_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="add_nodes_+3A_nodes">nodes</code></td>
<td>
<p>The number of nodes to be added.</p>
</td></tr>
<tr><td><code id="add_nodes_+3A_attribute">attribute</code></td>
<td>
<p>A named list to be added as tie or node attributes.</p>
</td></tr>
<tr><td><code id="add_nodes_+3A_attr_name">attr_name</code></td>
<td>
<p>Name of the new attribute in the resulting object.</p>
</td></tr>
<tr><td><code id="add_nodes_+3A_vector">vector</code></td>
<td>
<p>A vector of values for the new attribute.</p>
</td></tr>
<tr><td><code id="add_nodes_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="add_nodes_+3A_object2">object2</code></td>
<td>
<p>A second object to copy nodes or ties from.</p>
</td></tr>
<tr><td><code id="add_nodes_+3A_.by">.by</code></td>
<td>
<p>An attribute name to join objects by.
By default, NULL.</p>
</td></tr>
<tr><td><code id="add_nodes_+3A_join_type">join_type</code></td>
<td>
<p>A type of join to be used.
Options are &quot;full&quot;,&quot;left&quot;, &quot;right&quot;, &quot;inner&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   add_nodes </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   delete_nodes </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>A data object of the same class as the function was given.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+add_ties">add_ties</a>()</code>,
<code><a href="#topic+as">as</a>()</code>,
<code><a href="#topic+from">from</a></code>,
<code><a href="#topic+miss">miss</a></code>,
<code><a href="#topic+reformat">reformat</a></code>,
<code><a href="#topic+split">split</a>()</code>,
<code><a href="#topic+to_levels">to_levels</a></code>,
<code><a href="#topic+to_paths">to_paths</a></code>,
<code><a href="#topic+to_project">to_project</a></code>,
<code><a href="#topic+to_scope">to_scope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  other &lt;- create_filled(4) %&gt;% mutate(name = c("A", "B", "C", "D"))
  add_nodes(other, 4, list(name = c("Matthew", "Mark", "Luke", "Tim")))
  other &lt;- create_filled(4) %&gt;% mutate(name = c("A", "B", "C", "D"))
  another &lt;- create_filled(3) %&gt;% mutate(name = c("E", "F", "G"))
  join_nodes(another, other)
</code></pre>

<hr>
<h2 id='add_ties'>Modifying tie data</h2><span id='topic+add_ties'></span><span id='topic+delete_ties'></span><span id='topic+add_tie_attribute'></span><span id='topic+mutate_ties'></span><span id='topic+rename_ties'></span><span id='topic+bind_ties'></span><span id='topic+join_ties'></span><span id='topic+filter_ties'></span><span id='topic+select_ties'></span><span id='topic+summarise_ties'></span>

<h3>Description</h3>

<p>These functions allow users to add and delete ties and their attributes:
</p>

<ul>
<li> <p><code>add_ties()</code> adds additional ties to network data
</p>
</li>
<li> <p><code>delete_ties()</code> deletes ties from network data
</p>
</li>
<li> <p><code>add_tie_attribute()</code> and <code>mutate_ties()</code> offer ways to add
a vector of values to a network as a tie attribute.
</p>
</li>
<li> <p><code>rename_ties()</code> renames tie attributes.
</p>
</li>
<li> <p><code>bind_ties()</code> appends the tie data from two networks and
<code>join_ties()</code> merges ties from two networks,
adding a tie attribute identifying the newly added ties.
</p>
</li>
<li> <p><code>filter_ties()</code> subsets ties based on some tie attribute-related logical statement.
</p>
</li></ul>

<p>Note that while <code style="white-space: pre;">&#8288;add_*()&#8288;</code>/<code style="white-space: pre;">&#8288;delete_*()&#8288;</code> functions operate similarly as comparable <code>{igraph}</code> functions,
<code style="white-space: pre;">&#8288;mutate*()&#8288;</code>, <code style="white-space: pre;">&#8288;bind*()&#8288;</code>, etc work like <code>{tidyverse}</code> or <code>{dplyr}</code>-style functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_ties(.data, ties, attribute = NULL)

delete_ties(.data, ties)

add_tie_attribute(.data, attr_name, vector)

mutate_ties(.data, ...)

rename_ties(.data, ...)

bind_ties(.data, ...)

join_ties(.data, object2, attr_name)

filter_ties(.data, ...)

select_ties(.data, ...)

summarise_ties(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_ties_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="add_ties_+3A_ties">ties</code></td>
<td>
<p>The number of ties to be added or an even list of ties.</p>
</td></tr>
<tr><td><code id="add_ties_+3A_attribute">attribute</code></td>
<td>
<p>A named list to be added as tie or node attributes.</p>
</td></tr>
<tr><td><code id="add_ties_+3A_attr_name">attr_name</code></td>
<td>
<p>Name of the new attribute in the resulting object.</p>
</td></tr>
<tr><td><code id="add_ties_+3A_vector">vector</code></td>
<td>
<p>A vector of values for the new attribute.</p>
</td></tr>
<tr><td><code id="add_ties_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="add_ties_+3A_object2">object2</code></td>
<td>
<p>A second object to copy nodes or ties from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidygraph (<code>tbl_graph</code>) data object.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+add_nodes">add_nodes</a>()</code>,
<code><a href="#topic+as">as</a>()</code>,
<code><a href="#topic+from">from</a></code>,
<code><a href="#topic+miss">miss</a></code>,
<code><a href="#topic+reformat">reformat</a></code>,
<code><a href="#topic+split">split</a>()</code>,
<code><a href="#topic+to_levels">to_levels</a></code>,
<code><a href="#topic+to_paths">to_paths</a></code>,
<code><a href="#topic+to_project">to_project</a></code>,
<code><a href="#topic+to_scope">to_scope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  other &lt;- create_filled(4) %&gt;% mutate(name = c("A", "B", "C", "D"))
  mutate_ties(other, form = 1:6) %&gt;% filter_ties(form &lt; 4)
  add_tie_attribute(other, "weight", c(1, 2, 2, 2, 1, 2))
</code></pre>

<hr>
<h2 id='as'>Modifying network classes</h2><span id='topic+as'></span><span id='topic+as_edgelist'></span><span id='topic+as_matrix'></span><span id='topic+as_igraph'></span><span id='topic+as_tidygraph'></span><span id='topic+as_network'></span><span id='topic+as_siena'></span><span id='topic+as_graphAM'></span><span id='topic+as_diffusion'></span>

<h3>Description</h3>

<p>The <code>as_</code> functions in <code>{manynet}</code> coerce objects of any of the following common classes
of social network objects in R into the declared class:
</p>

<ul>
<li> <p><code>as_edgelist()</code> coerces the object into an edgelist, as data frames or tibbles.
</p>
</li>
<li> <p><code>as_matrix()</code> coerces the object into an adjacency (one-mode/unipartite) or incidence (two-mode/bipartite) matrix.
</p>
</li>
<li> <p><code>as_igraph()</code> coerces the object into an <code>{igraph}</code> <code>graph</code> object.
</p>
</li>
<li> <p><code>as_tidygraph()</code> coerces the object into a <code>{tidygraph}</code> <code>tbl_graph</code> objects.
</p>
</li>
<li> <p><code>as_network()</code> coerces the object into a <code>{network}</code> <code>network</code> objects.
</p>
</li>
<li> <p><code>as_siena()</code> coerces the (igraph/tidygraph) object into a SIENA dependent variable.
</p>
</li>
<li> <p><code>as_graphAM()</code> coerces the object into a graph adjacency matrix.
</p>
</li>
<li> <p><code>as_diffusion()</code> coerces a table of diffusion events into
a <code>diff_model</code> object similar to the output of <code>play_diffusion()</code>.
</p>
</li></ul>

<p>An effort is made for all of these coercion routines to be as lossless
as possible, though some object classes are better at retaining certain
kinds of information than others.
Note also that there are some reserved column names in one or more
object classes, which could otherwise lead to some unexpected results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_edgelist(.data, twomode = FALSE)

as_matrix(.data, twomode = NULL)

as_igraph(.data, twomode = FALSE)

as_tidygraph(.data, twomode = FALSE)

as_network(.data, twomode = FALSE)

as_siena(.data, twomode = FALSE)

as_graphAM(.data, twomode = NULL)

as_diffusion(events, .data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="as_+3A_twomode">twomode</code></td>
<td>
<p>Logical option used to override heuristics for
distinguishing incidence (two-mode/bipartite) from
adjacency (one-mode/unipartite) networks.
By default FALSE.</p>
</td></tr>
<tr><td><code id="as_+3A_events">events</code></td>
<td>
<p>A table (data frame or tibble) of diffusion events
with columns <code>t</code> indicating the time (typically an integer) of the event,
<code>nodes</code> indicating the number or name of the node involved in the event,
and <code>event</code>, which can take on the values &quot;I&quot; for an infection event,
&quot;E&quot; for an exposure event, or &quot;R&quot; for a recovery event.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Edgelists are expected to be held in data.frame or tibble class objects.
The first two columns of such an object are expected to be the
senders and receivers of a tie, respectively, and are typically
named &quot;from&quot; and &quot;to&quot; (even in the case of an undirected network).
These columns can contain integers to identify nodes or character
strings/factors if the network is labelled.
If the sets of senders and receivers overlap, a one-mode network is inferred.
If the sets contain no overlap, a two-mode network is inferred.
If a third, numeric column is present, a weighted network will be created.
</p>
<p>Matrices can be either adjacency (one-mode) or incidence (two-mode) matrices.
Incidence matrices are typically inferred from unequal dimensions,
but since in rare cases a matrix with equal dimensions may still
be an incidence matrix, an additional argument <code>twomode</code> can be
specified to override this heuristic.
</p>
<p>This information is usually already embedded in <code>{igraph}</code>,
<code>{tidygraph}</code>, and <code>{network}</code> objects.
</p>


<h3>Value</h3>

<p>The currently implemented coercions or translations are:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> diff_model </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> list </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> network.goldfish </td><td style="text-align: right;"> siena </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_edgelist </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_graphAM </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_igraph </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_matrix </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_network </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_siena </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_tidygraph </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>as_diffusion()</code> and <code>play_diffusion()</code> return a 'diff_model' object
that contains two different tibbles (tables) &ndash;
a table of diffusion events and
a table of the number of nodes in each relevant component (S, E, I, or R) &ndash;
as well as a copy of the network upon which the diffusion ran.
By default, a compact version of the component table is printed
(to print all the changes at each time point, use <code>print(..., verbose = T)</code>).
To retrieve the diffusion events table, use <code>summary(...)</code>.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+add_nodes">add_nodes</a>()</code>,
<code><a href="#topic+add_ties">add_ties</a>()</code>,
<code><a href="#topic+from">from</a></code>,
<code><a href="#topic+miss">miss</a></code>,
<code><a href="#topic+reformat">reformat</a></code>,
<code><a href="#topic+split">split</a>()</code>,
<code><a href="#topic+to_levels">to_levels</a></code>,
<code><a href="#topic+to_paths">to_paths</a></code>,
<code><a href="#topic+to_project">to_project</a></code>,
<code><a href="#topic+to_scope">to_scope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- data.frame(from = c("A","B","B","C","C"), to = c("I","G","I","G","H"))
as_edgelist(test)
as_matrix(test)
as_igraph(test)
as_tidygraph(test)
as_network(test)
  # How to create a diff_model object from (basic) observed data
  events &lt;- data.frame(t = c(0,1,1,2,3), nodes = c(1,2,3,2,4), event = c("I","I","I","R","I"))
  as_diffusion(events, manynet::create_filled(4))
</code></pre>

<hr>
<h2 id='attributes'>Describing attributes of nodes or ties in a network</h2><span id='topic+attributes'></span><span id='topic+node_attribute'></span><span id='topic+node_names'></span><span id='topic+node_mode'></span><span id='topic+tie_attribute'></span><span id='topic+tie_weights'></span><span id='topic+tie_signs'></span>

<h3>Description</h3>

<p>These functions extract certain attributes from network data:
</p>

<ul>
<li> <p><code>node_attribute()</code> returns an attribute's values for the nodes in a network.
</p>
</li>
<li> <p><code>node_names()</code> returns the names of the nodes in a network.
</p>
</li>
<li> <p><code>node_mode()</code> returns the mode of the nodes in a network.
</p>
</li>
<li> <p><code>tie_attribute()</code> returns an attribute's values for the ties in a network.
</p>
</li>
<li> <p><code>tie_weights()</code> returns the weights of the ties in a network.
</p>
</li>
<li> <p><code>tie_signs()</code> returns the signs of the ties in a network.
</p>
</li></ul>

<p>These functions are also often used as helpers within other functions.
<code style="white-space: pre;">&#8288;node_*()&#8288;</code> and <code style="white-space: pre;">&#8288;tie_*()&#8288;</code> always return vectors the same length
as the number of nodes or ties in the network, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_attribute(.data, attribute)

node_names(.data)

node_mode(.data)

tie_attribute(.data, attribute)

tie_weights(.data)

tie_signs(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attributes_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="attributes_+3A_attribute">attribute</code></td>
<td>
<p>Character string naming an attribute in the object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other mapping: 
<code><a href="#topic+autographr">autographr</a>()</code>,
<code><a href="#topic+autographs">autographs</a>()</code>,
<code><a href="#topic+autographt">autographt</a>()</code>,
<code><a href="#topic+configuration_layouts">configuration_layouts</a></code>,
<code><a href="#topic+partition_layouts">partition_layouts</a></code>,
<code><a href="#topic+properties">properties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_attribute(ison_lotr, "Race")
node_names(ison_southern_women)
node_mode(ison_southern_women)
tie_attribute(ison_algebra, "task_tie")
tie_weights(to_mode1(ison_southern_women))
tie_signs(ison_marvel_relationships)
</code></pre>

<hr>
<h2 id='autographr'>Easily graph networks with sensible defaults</h2><span id='topic+autographr'></span><span id='topic+graphr'></span>

<h3>Description</h3>

<p>This function provides users with an easy way to graph
(m)any network data for exploration, investigation, and communication.
</p>
<p>It builds upon <code>{ggplot2}</code> and <code>{ggraph}</code> to offer
pretty and extensible graphing solutions.
However, compared to those solutions,
<code>autographr()</code> contains various algorithms to provide better looking
graphs by default.
This means that just passing the function some network data
will often be sufficient to return a reasonable-looking graph.
</p>
<p>The function also makes it easy to modify many of the most
commonly adapted aspects of a graph,
including node and edge size, colour, and shape,
as arguments rather than additional functions that you need to remember.
These can be defined outright, e.g. <code>node_size = 8</code>,
or in reference to an attribute of the network, e.g. <code>node_size = "wealth"</code>.
</p>
<p>Lastly, <code>autographr()</code> uses ggplot2-related theme information,
so it is easy to make colour palette and fonts institution-specific and consistent.
See e.g. <code>theme_iheid()</code> for more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autographr(
  .data,
  layout,
  labels = TRUE,
  node_color,
  node_shape,
  node_size,
  node_group,
  edge_color,
  edge_size,
  ...
)

graphr(
  .data,
  layout,
  labels = TRUE,
  node_color,
  node_shape,
  node_size,
  node_group,
  edge_color,
  edge_size,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autographr_+3A_.data">.data</code></td>
<td>
<p>A manynet-consistent object.</p>
</td></tr>
<tr><td><code id="autographr_+3A_layout">layout</code></td>
<td>
<p>An igraph, ggraph, or manynet layout algorithm.
If not declared, defaults to &quot;triad&quot; for networks with 3 nodes,
&quot;quad&quot; for networks with 4 nodes,
&quot;stress&quot; for all other one mode networks,
or &quot;hierarchy&quot; for two mode networks.
For &quot;hierarchy&quot; layout, one can further split graph by
declaring the &quot;center&quot; argument as the &quot;events&quot;, &quot;actors&quot;,
or by declaring a node name.
For &quot;concentric&quot; layout algorithm please declare the &quot;membership&quot; as an
extra argument.
The &quot;membership&quot; argument expects either a quoted node attribute present
in data or vector with the same length as nodes to draw concentric circles.
For &quot;multilevel&quot; layout algorithm please declare the &quot;level&quot;
as extra argument.
The &quot;level&quot; argument expects either a quoted node attribute present
in data or vector with the same length as nodes to hierarchically
order categories.
If &quot;level&quot; is missing, function will look for 'lvl' node attribute in data.
The &quot;lineage&quot; layout ranks nodes in Y axis according to values.
For &quot;lineage&quot; layout algorithm please declare the &quot;rank&quot;
as extra argument.
The &quot;rank&quot; argument expects either a quoted node attribute present
in data or vector with the same length as nodes.</p>
</td></tr>
<tr><td><code id="autographr_+3A_labels">labels</code></td>
<td>
<p>Logical, whether to print node names
as labels if present.</p>
</td></tr>
<tr><td><code id="autographr_+3A_node_color">node_color</code></td>
<td>
<p>Node variable to be used for coloring the nodes.
It is easiest if this is added as a node attribute to
the graph before plotting.
Nodes can also be colored by declaring a color instead.</p>
</td></tr>
<tr><td><code id="autographr_+3A_node_shape">node_shape</code></td>
<td>
<p>Node variable to be used for shaping the nodes.
It is easiest if this is added as a node attribute to
the graph before plotting.
Nodes can also be shaped by declaring a shape instead.</p>
</td></tr>
<tr><td><code id="autographr_+3A_node_size">node_size</code></td>
<td>
<p>Node variable to be used for sizing the nodes.
This can be any continuous variable on the nodes of the network.
Since this function expects this to be an existing variable,
it is recommended to calculate all node-related statistics prior
to using this function.
Nodes can also be sized by declaring a numeric size or vector instead.</p>
</td></tr>
<tr><td><code id="autographr_+3A_node_group">node_group</code></td>
<td>
<p>Node variable to be used for grouping the nodes.
It is easiest if this is added as a hull over
groups before plotting.
Group variables should have a minimum of 3 nodes,
if less, number groups will be reduced by
merging categories with lower counts into one called &quot;other&quot;.</p>
</td></tr>
<tr><td><code id="autographr_+3A_edge_color">edge_color</code></td>
<td>
<p>Tie variable to be used for coloring the nodes.
It is easiest if this is added as an edge or tie attribute
to the graph before plotting.
Edges can also be colored by declaring a color instead.</p>
</td></tr>
<tr><td><code id="autographr_+3A_edge_size">edge_size</code></td>
<td>
<p>Tie variable to be used for sizing the edges.
This can be any continuous variable on the nodes of the network.
Since this function expects this to be an existing variable,
it is recommended to calculate all edge-related statistics prior
to using this function.
Edges can also be sized by declaring a numeric size or vector instead.</p>
</td></tr>
<tr><td><code id="autographr_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass on to the layout algorithm, if necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2::ggplot()</code> object.
The last plot can be saved to the file system using <code>ggplot2::ggsave()</code>.
</p>


<h3>See Also</h3>

<p>Other mapping: 
<code><a href="#topic+attributes">attributes</a>()</code>,
<code><a href="#topic+autographs">autographs</a>()</code>,
<code><a href="#topic+autographt">autographt</a>()</code>,
<code><a href="#topic+configuration_layouts">configuration_layouts</a></code>,
<code><a href="#topic+partition_layouts">partition_layouts</a></code>,
<code><a href="#topic+properties">properties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>autographr(ison_adolescents)
ison_adolescents |&gt;
  mutate(color = rep(c("extrovert", "introvert"), times = 4),
         size = ifelse(node_is_cutpoint(ison_adolescents), 6, 3)) |&gt;
  mutate_ties(ecolor = rep(c("friends", "aquaintances"), times = 5)) |&gt;
  autographr(node_color = "color", node_size = "size",
             edge_size = 1.5, edge_color = "ecolor")
#autographr(ison_lotr, node_color = Race,
#           node_size = migraph::node_degree(ison_lotr)*2,
#           edge_color = "darkgreen",
#           edge_size = migraph::tie_degree(ison_lotr))
#autographr(ison_karateka, node_group = allegiance,
#           edge_size = migraph::tie_closeness(ison_karateka))
</code></pre>

<hr>
<h2 id='autographs'>Easily graph a set of networks with sensible defaults</h2><span id='topic+autographs'></span><span id='topic+graphs'></span>

<h3>Description</h3>

<p>This function provides users with an easy way to graph
lists of network data for comparison.
</p>
<p>It builds upon this package's <code>autographr()</code> function,
and inherits all the same features and arguments.
See <code>autographr()</code> for more.
However, it uses the <code>{patchwork}</code> package to plot the graphs
side by side and, if necessary, in successive rows.
This is useful for lists of networks that represent, for example,
ego or component subgraphs of a network,
or a list of a network's different types of tie or across time.
By default just the first and last network will be plotted,
but this can be overridden by the &quot;waves&quot; parameter.
</p>
<p>Where the graphs are of the same network (same nodes),
the graphs may share a layout to facilitate comparison.
By default, successive graphs will use the layout calculated for
the &quot;first&quot; network, but other options include the &quot;last&quot; layout,
or a mix, &quot;both&quot;, of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autographs(netlist, waves, based_on = c("first", "last", "both"), ...)

graphs(netlist, waves, based_on = c("first", "last", "both"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autographs_+3A_netlist">netlist</code></td>
<td>
<p>A list of manynet-compatible networks.</p>
</td></tr>
<tr><td><code id="autographs_+3A_waves">waves</code></td>
<td>
<p>Numeric, the number of plots to be displayed side-by-side.
If missing, the number of plots will be reduced to the first and last
when there are more than four plots.
This argument can also be passed a vector selecting the waves to plot.</p>
</td></tr>
<tr><td><code id="autographs_+3A_based_on">based_on</code></td>
<td>
<p>Whether the layout of the joint plots should
be based on the &quot;first&quot; or the &quot;last&quot; network, or &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="autographs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>autographr()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiple <code>ggplot2::ggplot()</code> objects displayed side-by-side.
</p>


<h3>See Also</h3>

<p>Other mapping: 
<code><a href="#topic+attributes">attributes</a>()</code>,
<code><a href="#topic+autographr">autographr</a>()</code>,
<code><a href="#topic+autographt">autographt</a>()</code>,
<code><a href="#topic+configuration_layouts">configuration_layouts</a></code>,
<code><a href="#topic+partition_layouts">partition_layouts</a></code>,
<code><a href="#topic+properties">properties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#autographs(to_egos(ison_adolescents))
#autographs(to_egos(ison_adolescents), waves = 8)
#autographs(to_egos(ison_adolescents), waves = c(2, 4, 6))
#autographs(play_diffusion(ison_adolescents))
</code></pre>

<hr>
<h2 id='autographt'>Easily animate dynamic networks with sensible defaults</h2><span id='topic+autographt'></span><span id='topic+autographd'></span><span id='topic+grapht'></span>

<h3>Description</h3>

<p>This function provides users with an easy way to graph
dynamic network data for exploration and presentation.
</p>
<p>It builds upon this package's <code>autographr()</code> function,
and inherits all the same features and arguments.
See <code>autographr()</code> for more.
However, it uses the <code>{gganimate}</code> package to animate the changes
between successive iterations of a network.
This is useful for networks in which the ties and/or the node or tie
attributes are changing.
</p>
<p>A progress bar is shown if it takes some time to encoding all the
.png files into a .gif.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autographt(
  tlist,
  layout,
  labels = TRUE,
  node_color,
  node_shape,
  node_size,
  edge_color,
  edge_size,
  keep_isolates = TRUE,
  ...
)

autographd(
  tlist,
  layout,
  labels = TRUE,
  node_color,
  node_shape,
  node_size,
  edge_color,
  edge_size,
  keep_isolates = TRUE,
  ...
)

grapht(
  tlist,
  layout,
  labels = TRUE,
  node_color,
  node_shape,
  node_size,
  edge_color,
  edge_size,
  keep_isolates = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autographt_+3A_tlist">tlist</code></td>
<td>
<p>The same migraph-compatible network listed according to
a time attribute, waves, or slices.</p>
</td></tr>
<tr><td><code id="autographt_+3A_layout">layout</code></td>
<td>
<p>An igraph, ggraph, or manynet layout algorithm.
If not declared, defaults to &quot;triad&quot; for networks with 3 nodes,
&quot;quad&quot; for networks with 4 nodes,
&quot;stress&quot; for all other one mode networks,
or &quot;hierarchy&quot; for two mode networks.
For &quot;hierarchy&quot; layout, one can further split graph by
declaring the &quot;center&quot; argument as the &quot;events&quot;, &quot;actors&quot;,
or by declaring a node name.
For &quot;concentric&quot; layout algorithm please declare the &quot;membership&quot; as an
extra argument.
The &quot;membership&quot; argument expects either a quoted node attribute present
in data or vector with the same length as nodes to draw concentric circles.
For &quot;multilevel&quot; layout algorithm please declare the &quot;level&quot;
as extra argument.
The &quot;level&quot; argument expects either a quoted node attribute present
in data or vector with the same length as nodes to hierarchically
order categories.
If &quot;level&quot; is missing, function will look for 'lvl' node attribute in data.
The &quot;lineage&quot; layout ranks nodes in Y axis according to values.
For &quot;lineage&quot; layout algorithm please declare the &quot;rank&quot;
as extra argument.
The &quot;rank&quot; argument expects either a quoted node attribute present
in data or vector with the same length as nodes.</p>
</td></tr>
<tr><td><code id="autographt_+3A_labels">labels</code></td>
<td>
<p>Logical, whether to print node names
as labels if present.</p>
</td></tr>
<tr><td><code id="autographt_+3A_node_color">node_color</code></td>
<td>
<p>Node variable to be used for coloring the nodes.
It is easiest if this is added as a node attribute to
the graph before plotting.
Nodes can also be colored by declaring a color instead.</p>
</td></tr>
<tr><td><code id="autographt_+3A_node_shape">node_shape</code></td>
<td>
<p>Node variable to be used for shaping the nodes.
It is easiest if this is added as a node attribute to
the graph before plotting.
Nodes can also be shaped by declaring a shape instead.</p>
</td></tr>
<tr><td><code id="autographt_+3A_node_size">node_size</code></td>
<td>
<p>Node variable to be used for sizing the nodes.
This can be any continuous variable on the nodes of the network.
Since this function expects this to be an existing variable,
it is recommended to calculate all node-related statistics prior
to using this function.
Nodes can also be sized by declaring a numeric size or vector instead.</p>
</td></tr>
<tr><td><code id="autographt_+3A_edge_color">edge_color</code></td>
<td>
<p>Tie variable to be used for coloring the nodes.
It is easiest if this is added as an edge or tie attribute
to the graph before plotting.
Edges can also be colored by declaring a color instead.</p>
</td></tr>
<tr><td><code id="autographt_+3A_edge_size">edge_size</code></td>
<td>
<p>Tie variable to be used for sizing the edges.
This can be any continuous variable on the nodes of the network.
Since this function expects this to be an existing variable,
it is recommended to calculate all edge-related statistics prior
to using this function.
Edges can also be sized by declaring a numeric size or vector instead.</p>
</td></tr>
<tr><td><code id="autographt_+3A_keep_isolates">keep_isolates</code></td>
<td>
<p>Logical, whether to keep isolate nodes in the graph.
TRUE by default.
If FALSE, removes nodes from each frame they are isolated in.</p>
</td></tr>
<tr><td><code id="autographt_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass on to the layout algorithm, if necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shows a .gif image. Assigning the result of the function
saves the gif to a temporary folder and the object holds the path to this file.
</p>


<h3>Source</h3>

<p>https://blog.schochastics.net/posts/2021-09-15_animating-network-evolutions-with-gganimate/
</p>


<h3>See Also</h3>

<p>Other mapping: 
<code><a href="#topic+attributes">attributes</a>()</code>,
<code><a href="#topic+autographr">autographr</a>()</code>,
<code><a href="#topic+autographs">autographs</a>()</code>,
<code><a href="#topic+configuration_layouts">configuration_layouts</a></code>,
<code><a href="#topic+partition_layouts">partition_layouts</a></code>,
<code><a href="#topic+properties">properties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#ison_adolescents %&gt;%
#  mutate_ties(year = sample(1995:1998, 10, replace = TRUE)) %&gt;%
#  to_waves(attribute = "year", cumulative = TRUE) %&gt;%
#  autographd()
#ison_adolescents %&gt;% 
#  mutate(gender = rep(c("male", "female"), times = 4),
#         hair = rep(c("black", "brown"), times = 4),
#         age = sample(11:16, 8, replace = TRUE)) %&gt;%
#  mutate_ties(year = sample(1995:1998, 10, replace = TRUE),
#              links = sample(c("friends", "not_friends"), 10, replace = TRUE),
#              weekly_meetings = sample(c(3, 5, 7), 10, replace = TRUE)) %&gt;%
#  to_waves(attribute = "year") %&gt;%
#  autographd(layout = "concentric", membership = "gender",
#             node_shape = "gender", node_color = "hair",
#             node_size =  "age", edge_color = "links",
#             edge_size = "weekly_meetings")
#autographd(play_diffusion(ison_adolescents, seeds = 5))
</code></pre>

<hr>
<h2 id='configuration_layouts'>Layout algorithms based on configurational positions</h2><span id='topic+configuration_layouts'></span><span id='topic+layout_tbl_graph_configuration'></span><span id='topic+layout_tbl_graph_triad'></span><span id='topic+layout_tbl_graph_quad'></span>

<h3>Description</h3>

<p>Configurational layouts locate nodes at symmetric coordinates
to help illustrate the particular layouts.
Currently &quot;triad&quot; and &quot;quad&quot; layouts are available.
The &quot;configuration&quot; layout will choose the appropriate configurational
layout automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_configuration(.data, circular = FALSE, times = 1000)

layout_tbl_graph_triad(.data, circular = FALSE, times = 1000)

layout_tbl_graph_quad(.data, circular = FALSE, times = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="configuration_layouts_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="configuration_layouts_+3A_circular">circular</code></td>
<td>
<p>Should the layout be transformed into a radial representation.
Only possible for some layouts. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="configuration_layouts_+3A_times">times</code></td>
<td>
<p>Maximum number of iterations, where appropriate</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other mapping: 
<code><a href="#topic+attributes">attributes</a>()</code>,
<code><a href="#topic+autographr">autographr</a>()</code>,
<code><a href="#topic+autographs">autographs</a>()</code>,
<code><a href="#topic+autographt">autographt</a>()</code>,
<code><a href="#topic+partition_layouts">partition_layouts</a></code>,
<code><a href="#topic+properties">properties</a></code>
</p>

<hr>
<h2 id='create'>Making networks with defined structures</h2><span id='topic+create'></span><span id='topic+create_empty'></span><span id='topic+create_filled'></span><span id='topic+create_ring'></span><span id='topic+create_star'></span><span id='topic+create_tree'></span><span id='topic+create_lattice'></span><span id='topic+create_components'></span><span id='topic+create_core'></span><span id='topic+create_explicit'></span>

<h3>Description</h3>

<p>These functions create networks with particular structural properties.
</p>

<ul>
<li> <p><code>create_empty()</code> creates an empty network without any ties.
</p>
</li>
<li> <p><code>create_filled()</code> creates a filled network with every possible tie realised.
</p>
</li>
<li> <p><code>create_ring()</code> creates a ring or chord network where each nodes'
neighbours form a clique.
</p>
</li>
<li> <p><code>create_star()</code> creates a network with a maximally central node.
</p>
</li>
<li> <p><code>create_tree()</code> creates a network with successive branches.
</p>
</li>
<li> <p><code>create_lattice()</code> creates a network that forms a regular tiling.
</p>
</li>
<li> <p><code>create_components()</code> creates a network that clusters nodes into separate components.
</p>
</li>
<li> <p><code>create_core()</code> creates a network in which a certain proportion of 'core' nodes
are densely tied to each other, and the rest peripheral, tied only to the core.
</p>
</li>
<li> <p><code>create_explicit()</code> creates a network based on explicitly
named nodes and ties between them.
</p>
</li></ul>

<p>These functions can create either one-mode or two-mode networks.
To create a one-mode network, pass the main argument <code>n</code> a single integer,
indicating the number of nodes in the network.
To create a two-mode network, pass <code>n</code> a vector of <em>two</em> integers,
where the first integer indicates the number of nodes in the first mode,
and the second integer indicates the number of nodes in the second mode.
As an alternative, an existing network can be provided to <code>n</code>
and the number of modes, nodes, and directedness will be inferred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_empty(n, directed = FALSE)

create_filled(n, directed = FALSE)

create_ring(n, directed = FALSE, width = 1, ...)

create_star(n, directed = FALSE)

create_tree(n, directed = FALSE, width = 2)

create_lattice(n, directed = FALSE, width = 8)

create_components(n, directed = FALSE, membership = NULL)

create_core(n, directed = FALSE, membership = NULL)

create_explicit(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_+3A_n">n</code></td>
<td>
<p>Given:
</p>

<ul>
<li><p> A single integer, e.g. <code>n = 10</code>,
a one-mode network will be created.
</p>
</li>
<li><p> A vector of two integers, e.g. <code>n = c(5,10)</code>,
a two-mode network will be created.
</p>
</li>
<li><p> A manynet-compatible object,
a network of the same dimensions will be created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="create_+3A_directed">directed</code></td>
<td>
<p>Logical whether the graph should be directed.
By default <code>directed = FALSE</code>.
If the opposite direction is desired,
use <code>to_redirected()</code> on the output of these functions.</p>
</td></tr>
<tr><td><code id="create_+3A_width">width</code></td>
<td>
<p>Integer specifying the width of the ring,
breadth of the branches, or maximum extent of the neighbourbood.</p>
</td></tr>
<tr><td><code id="create_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>{igraph}</code>.</p>
</td></tr>
<tr><td><code id="create_+3A_membership">membership</code></td>
<td>
<p>A vector of partition membership as integers.
If left as <code>NULL</code> (the default), nodes in each mode will be
assigned to two, equally sized partitions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default a <code>tbl_graph</code> object is returned,
but this can be coerced into other types of objects
using <code>as_edgelist()</code>, <code>as_matrix()</code>,
<code>as_tidygraph()</code>, or <code>as_network()</code>.
</p>
<p>By default, all networks are created as undirected.
This can be overruled with the argument <code>directed = TRUE</code>.
This will return a directed network in which the arcs are
out-facing or equivalent.
This direction can be swapped using <code>to_redirected()</code>.
In two-mode networks, the directed argument is ignored.
</p>


<h3>Lattice graphs</h3>

<p><code>create_lattice()</code> creates both two-dimensional grid and triangular
lattices with as even dimensions as possible.
When the <code>width</code> parameter is set to 4, nodes cannot have (in or out)
degrees larger than 4.
This creates regular square grid lattices where possible.
Such a network is bipartite, that is partitionable into two types that are
not adjacent to any of their own type.
If the number of nodes is a prime number, it will only return a chain
(a single dimensional lattice).
</p>
<p>A <code>width</code> parameter of 8 creates a network where the maximum degree of any
nodes is 8.
This can create a triangular mesh lattice or a Queen's move lattice,
depending on the dimensions.
A <code>width</code> parameter of 12 creates a network where the maximum degree of
any nodes is 12.
Prime numbers of nodes will return a chain.
</p>


<h3>See Also</h3>

<p><a href="#topic+as">as</a>
</p>
<p><code><a href="igraph.html#topic+graph_from_literal">igraph::graph_from_literal()</a></code> which <code>create_explicit()</code> mostly just wraps.
<code>create_explicit()</code> will also accept character input and not just a formula though,
and will never simplify the result.
</p>
<p>Other makes: 
<code><a href="#topic+generate">generate</a></code>,
<code><a href="#topic+learning">learning</a></code>,
<code><a href="#topic+play">play</a></code>,
<code><a href="#topic+read">read</a></code>,
<code><a href="#topic+write">write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_empty(10)
create_filled(10)
create_ring(8, width = 2)
create_star(12)
create_tree(c(7,8))
create_lattice(12, width = 4)
create_components(10, membership = c(1,1,1,2,2,2,3,3,3,3))
create_core(6)
  create_explicit(A -+ B, B -+ C, A +-+ C, D)
</code></pre>

<hr>
<h2 id='features'>Marking networks features</h2><span id='topic+features'></span><span id='topic+is_connected'></span><span id='topic+is_perfect_matching'></span><span id='topic+is_eulerian'></span><span id='topic+is_acyclic'></span><span id='topic+is_aperiodic'></span>

<h3>Description</h3>

<p>These functions implement logical tests for various network
features.
</p>

<ul>
<li> <p><code>is_connected()</code> tests whether network is strongly connected,
or weakly connected if undirected.
</p>
</li>
<li> <p><code>is_perfect_matching()</code> tests whether there is a matching
for a network that covers every node in the network.
</p>
</li>
<li> <p><code>is_eulerian()</code> tests whether there is a Eulerian path for a network
where that path passes through every tie exactly once.
</p>
</li>
<li> <p><code>is_acyclic()</code> tests whether network is a directed acyclic graph.
</p>
</li>
<li> <p><code>is_aperiodic()</code> tests whether network is aperiodic.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is_connected(.data)

is_perfect_matching(.data, mark = "type")

is_eulerian(.data)

is_acyclic(.data)

is_aperiodic(.data, max_path_length = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="features_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="features_+3A_mark">mark</code></td>
<td>
<p>A logical vector marking two types or modes.
By default &quot;type&quot;.</p>
</td></tr>
<tr><td><code id="features_+3A_max_path_length">max_path_length</code></td>
<td>
<p>Maximum path length considered.
If negative, paths of all lengths are considered.
By default 4, to avoid potentially very long computation times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the condition is met, or FALSE otherwise.
</p>


<h3>is_connected</h3>

<p>To test weak connection on a directed network,
please see <code>to_undirected()</code>.
</p>


<h3>is_perfect_matching</h3>

<p>For two-mode or bipartite networks, <code>to_matching()</code> is used
to identify whether a perfect matching is possible.
For one-mode networks, we use the Tutte theorem.
Note that currently only subgraphs with cutpoints removed are tested,
and not all possible subgraphs.
This is to avoid computationally expensive combinatorial operations,
but may come at the cost of some edge cases where a one-mode network
cannot perfectly match as suggested.
</p>


<h3>Source</h3>

<p>https://stackoverflow.com/questions/55091438/r-igraph-find-all-cycles
</p>


<h3>References</h3>

<p>Tutte, W. T. (1950).
&quot;The factorization of locally finite graphs&quot;.
<em>Canadian Journal of Mathematics</em>. 2: 44–49.
<a href="https://doi.org/10.4153/cjm-1950-005-2">doi:10.4153/cjm-1950-005-2</a>
</p>


<h3>See Also</h3>

<p>Other marking: 
<code><a href="#topic+is">is</a>()</code>,
<code><a href="#topic+is_format">is_format</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_connected(ison_southern_women)
is_perfect_matching(ison_southern_women)
is_eulerian(ison_brandes)
is_acyclic(ison_algebra)
is_aperiodic(ison_algebra)
</code></pre>

<hr>
<h2 id='from'>Joining lists of networks, graphs, and matrices</h2><span id='topic+from'></span><span id='topic+from_subgraphs'></span><span id='topic+from_egos'></span><span id='topic+from_waves'></span><span id='topic+from_slices'></span><span id='topic+from_ties'></span>

<h3>Description</h3>

<p>These functions offer tools for joining lists of manynet-consistent objects
(matrices, igraph, tidygraph, or network objects) into a single object.
</p>

<ul>
<li> <p><code>from_subgraphs()</code> modifies a list of subgraphs into a single tidygraph.
</p>
</li>
<li> <p><code>from_egos()</code> modifies a list of ego networks into a whole tidygraph
</p>
</li>
<li> <p><code>from_waves()</code> modifies a list of network waves into a longitudinal tidygraph.
</p>
</li>
<li> <p><code>from_slices()</code> modifies a list of time slices of a network into
a dynamic tidygraph.
</p>
</li>
<li> <p><code>from_ties()</code> modifies a list of different ties into a multiplex tidygraph
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>from_subgraphs(netlist)

from_egos(netlist)

from_waves(netlist)

from_slices(netlist, remove.duplicates = FALSE)

from_ties(netlist, netnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_+3A_netlist">netlist</code></td>
<td>
<p>A list of network, igraph, tidygraph, matrix, or edgelist objects.</p>
</td></tr>
<tr><td><code id="from_+3A_remove.duplicates">remove.duplicates</code></td>
<td>
<p>Should duplicates be removed?
By default FALSE.
If TRUE, duplicated edges are removed.</p>
</td></tr>
<tr><td><code id="from_+3A_netnames">netnames</code></td>
<td>
<p>A character vector of names for the different network objects,
if not already named within the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidygraph object combining the list of network data.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+add_nodes">add_nodes</a>()</code>,
<code><a href="#topic+add_ties">add_ties</a>()</code>,
<code><a href="#topic+as">as</a>()</code>,
<code><a href="#topic+miss">miss</a></code>,
<code><a href="#topic+reformat">reformat</a></code>,
<code><a href="#topic+split">split</a>()</code>,
<code><a href="#topic+to_levels">to_levels</a></code>,
<code><a href="#topic+to_paths">to_paths</a></code>,
<code><a href="#topic+to_project">to_project</a></code>,
<code><a href="#topic+to_scope">to_scope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ison_adolescents %&gt;%
  mutate(unicorn = sample(c("yes", "no"), 8, replace = TRUE)) %&gt;%
  to_subgraphs(attribute = "unicorn") %&gt;%
  from_subgraphs()
ison_adolescents %&gt;%
  to_egos() %&gt;%
  from_egos()
ison_adolescents %&gt;%
  mutate_ties(wave = sample(1:4, 10, replace = TRUE)) %&gt;%
  to_waves(attribute = "wave") %&gt;%
  from_waves()
ison_adolescents %&gt;%
  mutate_ties(time = 1:10, increment = 1) %&gt;% 
  add_ties(c(1,2), list(time = 3, increment = -1)) %&gt;% 
  to_slices(slice = c(5,7)) %&gt;%
  from_slices()
</code></pre>

<hr>
<h2 id='generate'>Making networks with a stochastic element</h2><span id='topic+generate'></span><span id='topic+generate_random'></span><span id='topic+generate_smallworld'></span><span id='topic+generate_scalefree'></span><span id='topic+generate_permutation'></span><span id='topic+generate_utilities'></span>

<h3>Description</h3>

<p>These functions are similar to the <code style="white-space: pre;">&#8288;create_*&#8288;</code> functions,
but include some element of randomisation.
They are particularly useful for creating a distribution of networks
for exploring or testing network properties.
</p>

<ul>
<li> <p><code>generate_random()</code> generates a random network with ties appearing at some probability.
</p>
</li>
<li> <p><code>generate_smallworld()</code> generates a small-world structure via ring rewiring at some probability.
</p>
</li>
<li> <p><code>generate_scalefree()</code> generates a scale-free structure via preferential attachment at some probability.
</p>
</li>
<li> <p><code>generate_permutation()</code> generates a permutation of the network
using a Fisher-Yates shuffle on both the rows and columns (for a one-mode network)
or on each of the rows and columns (for a two-mode network).
</p>
</li>
<li> <p><code>generate_utilities()</code> generates a random utility matrix.
</p>
</li></ul>

<p>These functions can create either one-mode or two-mode networks.
To create a one-mode network, pass the main argument <code>n</code> a single integer,
indicating the number of nodes in the network.
To create a two-mode network, pass <code>n</code> a vector of <em>two</em> integers,
where the first integer indicates the number of nodes in the first mode,
and the second integer indicates the number of nodes in the second mode.
As an alternative, an existing network can be provided to <code>n</code>
and the number of modes, nodes, and directedness will be inferred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random(n, p = 0.5, directed = FALSE, with_attr = TRUE)

generate_smallworld(n, p = 0.05, directed = FALSE, width = 2)

generate_scalefree(n, p = 1, directed = FALSE)

generate_permutation(.data, with_attr = TRUE)

generate_utilities(n, steps = 1, volatility = 0, threshold = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_+3A_n">n</code></td>
<td>
<p>Given:
</p>

<ul>
<li><p> A single integer, e.g. <code>n = 10</code>,
a one-mode network will be created.
</p>
</li>
<li><p> A vector of two integers, e.g. <code>n = c(5,10)</code>,
a two-mode network will be created.
</p>
</li>
<li><p> A manynet-compatible object,
a network of the same dimensions will be created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="generate_+3A_p">p</code></td>
<td>
<p>Power of the preferential attachment, default is 1.</p>
</td></tr>
<tr><td><code id="generate_+3A_directed">directed</code></td>
<td>
<p>Whether to generate network as directed. By default FALSE.</p>
</td></tr>
<tr><td><code id="generate_+3A_with_attr">with_attr</code></td>
<td>
<p>Logical whether any attributes of the object
should be retained.
By default TRUE.</p>
</td></tr>
<tr><td><code id="generate_+3A_width">width</code></td>
<td>
<p>Integer specifying the width of the ring,
breadth of the branches, or maximum extent of the neighbourbood.</p>
</td></tr>
<tr><td><code id="generate_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="generate_+3A_steps">steps</code></td>
<td>
<p>Number of simulation steps to run.
By default 1: a single, one-shot simulation.
If more than 1, further iterations will update the utilities
depending on the values of the volatility and threshold parameters.</p>
</td></tr>
<tr><td><code id="generate_+3A_volatility">volatility</code></td>
<td>
<p>How much change there is between steps.
Only if volatility is more than 1 do further simulation steps make sense.
This is passed on to <code>stats::rnorm</code> as the <code>sd</code> or standard deviation
parameter.</p>
</td></tr>
<tr><td><code id="generate_+3A_threshold">threshold</code></td>
<td>
<p>This parameter can be used to mute or disregard stepwise
changes in utility that are minor.
The default 0 will recognise all changes in utility,
but raising the threshold will mute any changes less than this threshold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default a <code>tbl_graph</code> object is returned,
but this can be coerced into other types of objects
using <code>as_edgelist()</code>, <code>as_matrix()</code>,
<code>as_tidygraph()</code>, or <code>as_network()</code>.
</p>
<p>By default, all networks are created as undirected.
This can be overruled with the argument <code>directed = TRUE</code>.
This will return a directed network in which the arcs are
out-facing or equivalent.
This direction can be swapped using <code>to_redirected()</code>.
In two-mode networks, the directed argument is ignored.
</p>


<h3>References</h3>

<p>Erdos, Paul, and Alfred Renyi. (1959).
&quot;<a href="https://www.renyi.hu/~p_erdos/1959-11.pdf">On Random Graphs I</a>&quot;
<em>Publicationes Mathematicae</em>. 6: 290–297.
</p>
<p>Watts, Duncan J., and Steven H. Strogatz. 1998.
“Collective Dynamics of ‘Small-World’ Networks.”
<em>Nature</em> 393(6684):440–42.
<a href="https://doi.org/10.1038/30918">doi:10.1038/30918</a>.
</p>
<p>Barabasi, Albert-Laszlo, and Reka Albert. 1999.
“Emergence of Scaling in Random Networks.”
<em>Science</em> 286(5439):509–12.
<a href="https://doi.org/10.1126/science.286.5439.509">doi:10.1126/science.286.5439.509</a>.
</p>


<h3>See Also</h3>

<p>Other makes: 
<code><a href="#topic+create">create</a></code>,
<code><a href="#topic+learning">learning</a></code>,
<code><a href="#topic+play">play</a></code>,
<code><a href="#topic+read">read</a></code>,
<code><a href="#topic+write">write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>autographr(generate_random(12, 0.4))
# autographr(generate_random(c(6, 6), 0.4))
autographr(generate_smallworld(12, 0.025))
autographr(generate_smallworld(12, 0.25))
autographr(generate_scalefree(12, 0.25))
autographr(generate_scalefree(12, 1.25))
autographr(ison_adolescents)
autographr(generate_permutation(ison_adolescents))
</code></pre>

<hr>
<h2 id='is'>Marking networks classes</h2><span id='topic+is'></span><span id='topic+is_manynet'></span><span id='topic+is_graph'></span><span id='topic+is_edgelist'></span><span id='topic+is_list'></span><span id='topic+is_longitudinal'></span><span id='topic+is_dynamic'></span>

<h3>Description</h3>

<p>These functions implement logical tests for networks' classes.
</p>

<ul>
<li> <p><code>is_manynet()</code> marks a network TRUE if it is compatible with <code>{manynet}</code> functions.
</p>
</li>
<li> <p><code>is_edgelist()</code> marks a network TRUE if it is an edgelist.
</p>
</li>
<li> <p><code>is_graph()</code> marks a network TRUE if it contains graph-level information.
</p>
</li>
<li> <p><code>is_list()</code> marks a network TRUE if it is a (non-igraph) list of networks,
for example a set of ego networks or a dynamic or longitudinal set of networks.
</p>
</li>
<li> <p><code>is_longitudinal()</code> marks a network TRUE if it contains longitudinal, panel data.
</p>
</li>
<li> <p><code>is_dynamic()</code> marks a network TRUE if it contains dynamic, time-stamped data
</p>
</li></ul>

<p>All <code style="white-space: pre;">&#8288;is_*()&#8288;</code> functions return a logical scalar (TRUE or FALSE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_manynet(.data)

is_graph(.data)

is_edgelist(.data)

is_list(.data)

is_longitudinal(.data)

is_dynamic(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the condition is met, or FALSE otherwise.
</p>


<h3>See Also</h3>

<p>Other marking: 
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+is_format">is_format</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_manynet(create_filled(2))
is_graph(create_star(2))
is_edgelist(matrix(c(2,2), 1, 2))
is_edgelist(as_edgelist(matrix(c(2,2), 1, 2)))
is_longitudinal(create_tree(5, 3))
is_dynamic(create_tree(3))
</code></pre>

<hr>
<h2 id='is_format'>Marking networks formats</h2><span id='topic+is_format'></span><span id='topic+is_twomode'></span><span id='topic+is_weighted'></span><span id='topic+is_directed'></span><span id='topic+is_labelled'></span><span id='topic+is_signed'></span><span id='topic+is_complex'></span><span id='topic+is_multiplex'></span><span id='topic+is_uniplex'></span>

<h3>Description</h3>

<p>These functions implement logical tests for various network properties.
All <code style="white-space: pre;">&#8288;is_*()&#8288;</code> functions return a logical scalar (TRUE or FALSE).
</p>

<ul>
<li> <p><code>is_twomode()</code> marks networks TRUE if they contain two sets of nodes.
</p>
</li>
<li> <p><code>is_weighted()</code> marks networks TRUE if they contain tie weights.
</p>
</li>
<li> <p><code>is_directed()</code> marks networks TRUE if the ties specify which node
is the sender and which the receiver.
</p>
</li>
<li> <p><code>is_labelled()</code> marks networks TRUE if there is a 'names' attribute
for the nodes.
</p>
</li>
<li> <p><code>is_signed()</code> marks networks TRUE if the ties can be either positive
or negative.
</p>
</li>
<li> <p><code>is_complex()</code> marks networks TRUE if any ties are loops,
with the sender and receiver being the same node.
</p>
</li>
<li> <p><code>is_multiplex()</code> marks networks TRUE if it contains multiple types
of ties, such that there can be multiple ties between the same
sender and receiver.
</p>
</li>
<li> <p><code>is_uniplex()</code> marks networks TRUE if it is neither complex nor multiplex.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is_twomode(.data)

is_weighted(.data)

is_directed(.data)

is_labelled(.data)

is_signed(.data)

is_complex(.data)

is_multiplex(.data)

is_uniplex(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_format_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other marking: 
<code><a href="#topic+features">features</a></code>,
<code><a href="#topic+is">is</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_twomode(create_filled(c(2,2)))
is_weighted(create_tree(3))
is_directed(create_tree(2))
is_directed(create_tree(2, directed = TRUE))
is_labelled(create_empty(3))
is_signed(create_lattice(3))
is_complex(create_lattice(4))
is_multiplex(create_filled(c(3,3)))
is_uniplex(create_star(3))
</code></pre>

<hr>
<h2 id='ison_adolescents'>One-mode subset of the adolescent society network (Coleman 1961)</h2><span id='topic+ison_adolescents'></span>

<h3>Description</h3>

<p>One-mode subset of Coleman's adolescent society network (Coleman 1961),
as used in Feld's (1991) &quot;Why your friends have more friends than you do&quot;.
Coleman collected data on friendships among students in 12 U.S. high schools.
Feld explored a subset of 8 girls from one of these schools, &quot;Marketville&quot;,
and gave them fictitious names, which are retained here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_adolescents)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, undirected network with 8 nodes and 10 ties
#&gt; # A tibble: 8 x 1
#&gt;   name 
#&gt;   &lt;chr&gt;
#&gt; 1 Betty
#&gt; 2 Sue  
#&gt; 3 Alice
#&gt; 4 Jane 
#&gt; 5 Dale 
#&gt; 6 Pam  
#&gt; # i 2 more rows
#&gt; # A tibble: 10 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     2
#&gt; 2     2     3
#&gt; 3     3     4
#&gt; 4     2     5
#&gt; 5     3     5
#&gt; 6     4     5
#&gt; # i 4 more rows
</pre></div>


<h3>References</h3>

<p>Coleman, James S. 1961. <em>The Adolescent Society</em>.
New York: Free Press.
</p>
<p>Feld, Scott. 1991. “Why your friends have more friends than you do”
<em>American Journal of Sociology</em> 96(6): 1464-1477.
<a href="https://doi.org/10.1086/229693">doi:10.1086/229693</a>.
</p>

<hr>
<h2 id='ison_algebra'>Multiplex graph object of friends, social, and task ties (McFarland 2001)</h2><span id='topic+ison_algebra'></span>

<h3>Description</h3>

<p>Multiplex graph object of friends, social, and task ties between 16 anonymous students.
M182 was an honors algebra class where researchers
collected friendship, social, and task ties between 16 students.
The edge attribute <code>friends</code> contains friendship ties,
where <code>2</code> = best friends, <code>1</code> = friend, and <code>0</code> is not a friend.
<code>social</code> consists of social interactions per hour,
and <code>tasks</code> consists of task interactions per hour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_algebra)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A multiplex, weighted, directed network with 16 nodes and 279 arcs
#&gt; # A tibble: 279 x 4
#&gt;    from    to type   weight
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;   &lt;dbl&gt;
#&gt; 1     1     5 social   1.2 
#&gt; 2     1     5 tasks    0.3 
#&gt; 3     1     8 social   0.15
#&gt; 4     1     9 social   2.85
#&gt; 5     1     9 tasks    0.3 
#&gt; 6     1    10 social   6.45
#&gt; # i 273 more rows
</pre></div>


<h3>Source</h3>

<p>See also <code>data(studentnets.M182, package = "NetData")</code>
Larger comprehensive data set publicly available, contact Daniel A. McFarland for details.
</p>


<h3>References</h3>

<p>McFarland, Daniel A. (2001) “Student Resistance.”
<em>American Journal of Sociology</em> 107(3): 612-78.
<a href="https://doi.org/10.1086/338779">doi:10.1086/338779</a>.
</p>

<hr>
<h2 id='ison_brandes'>One-mode and two-mode centrality demonstration networks</h2><span id='topic+ison_brandes'></span>

<h3>Description</h3>

<p>This network should solely be used
for demonstration purposes as it does not describe a real network.
To convert into the two-mode version,
assign <code>ison_brandes %&gt;% rename(type = twomode_type)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_brandes)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A undirected network with 11 nodes and 12 ties
#&gt; # A tibble: 11 x 1
#&gt;   twomode_type
#&gt;   &lt;lgl&gt;       
#&gt; 1 FALSE       
#&gt; 2 FALSE       
#&gt; 3 TRUE        
#&gt; 4 FALSE       
#&gt; 5 TRUE        
#&gt; 6 TRUE        
#&gt; # i 5 more rows
#&gt; # A tibble: 12 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     3
#&gt; 2     2     3
#&gt; 3     3     4
#&gt; 4     4     5
#&gt; 5     4     6
#&gt; 6     5     7
#&gt; # i 6 more rows
</pre></div>

<hr>
<h2 id='ison_friends'>One-mode Friends character connections (McNulty, 2020)</h2><span id='topic+ison_friends'></span>

<h3>Description</h3>

<p>One-mode network collected by <a href="https://github.com/keithmcnulty/friends_analysis/">McNulty (2020)</a>
on the connections between the Friends TV series characters
from Seasons 1 to 10.
The <code>ison_friends</code> is a directed network
containing connections between characters organised by season number,
which is reflected in the tie attribute 'season'.
The network contains 650 nodes
Each tie represents the connection between a character pair (appear in the same scene),
and the weight of the tie is the number of scenes the character pair appears in together.
For all networks, characters are named (eg. Phoebe, Ross, Rachel).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_friends)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, multiplex, weighted, directed network with 650 nodes and 3959 arcs
#&gt; # A tibble: 650 x 1
#&gt;   name        
#&gt;   &lt;chr&gt;       
#&gt; 1 Actor       
#&gt; 2 Alan        
#&gt; 3 Andrea      
#&gt; 4 Angela      
#&gt; 5 Aunt Iris   
#&gt; 6 Aunt Lillian
#&gt; # i 644 more rows
#&gt; # A tibble: 3,959 x 4
#&gt;    from    to season weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;  &lt;int&gt;
#&gt; 1     1    44      1      1
#&gt; 2     2    14      1      1
#&gt; 3     2    44      1      1
#&gt; 4     2    58      1      2
#&gt; 5     2    72      1      1
#&gt; 6     2    75      1      1
#&gt; # i 3,953 more rows
</pre></div>


<h3>Details</h3>

<p>The data contains both networks but each may be used separately.
</p>


<h3>References</h3>

<p>McNulty, K. (2020).
<em>Network analysis of Friends scripts.</em>.
</p>

<hr>
<h2 id='ison_hightech'>One-mode multiplex, directed network of managers of a high-tech company (Krackhardt 1987)</h2><span id='topic+ison_hightech'></span>

<h3>Description</h3>

<p>21 managers of a company of just over 100 employees manufactured high-tech equipment
on the west coast of the United States.
Three types of ties were collected:
</p>

<ul>
<li> <p><em>friends</em>: managers' answers to the question &quot;Who is your friend?&quot;
</p>
</li>
<li> <p><em>advice</em>: managers' answers to the question &quot;To whom do you go to for advice?&quot;
</p>
</li>
<li> <p><em>reports</em>: &quot;To whom do you report?&quot; based on company reports
</p>
</li></ul>

<p>The data is anonymised, but four nodal attributes are included:
</p>

<ul>
<li> <p><em>age</em>: the manager's age in years
</p>
</li>
<li> <p><em>tenure</em>: the manager's length of service
</p>
</li>
<li> <p><em>level</em>: the manager's level in the corporate hierarchy,
where 3 = CEO, 2 = Vice President, and 1 = manager
</p>
</li>
<li> <p><em>dept</em>: one of four departments, B, C, D, E,
with the CEO alone in A
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(ison_hightech)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A multiplex, directed network with 21 nodes and 312 arcs
#&gt; # A tibble: 21 x 4
#&gt;     age tenure level dept 
#&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;
#&gt; 1    33      9     1 E    
#&gt; 2    42     20     2 E    
#&gt; 3    40     13     1 C    
#&gt; 4    33      8     1 E    
#&gt; 5    32      3     1 C    
#&gt; 6    59     28     1 B    
#&gt; # i 15 more rows
#&gt; # A tibble: 312 x 3
#&gt;    from    to type   
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;  
#&gt; 1     1     2 friends
#&gt; 2     1     2 advice 
#&gt; 3     1     2 reports
#&gt; 4     1     4 friends
#&gt; 5     1     4 advice 
#&gt; 6     1     8 friends
#&gt; # i 306 more rows
</pre></div>


<h3>References</h3>

<p>Krackhardt, David. 1987. &quot;Cognitive social structures&quot;. <em>Social Networks</em> 9: 104-134.
</p>

<hr>
<h2 id='ison_karateka'>One-mode karateka network (Zachary 1977)</h2><span id='topic+ison_karateka'></span>

<h3>Description</h3>

<p>The network was observed in a university Karate club in 1977.
The network describes association patterns among 34 members
and maps out allegiance patterns between members and either Mr. Hi,
the instructor, or the John A. the club president
after an argument about hiking the price for lessons.
The allegiance of each node is listed in the <code>obc</code> argument
which takes the value 1 if the individual sided with Mr. Hi after the fight
and 2 if the individual sided with John A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_karateka)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, weighted, undirected network with 34 nodes and 78 ties
#&gt; # A tibble: 34 x 2
#&gt;   name  allegiance
#&gt;   &lt;chr&gt;      &lt;dbl&gt;
#&gt; 1 Mr Hi          1
#&gt; 2 2              1
#&gt; 3 3              1
#&gt; 4 4              1
#&gt; 5 5              1
#&gt; 6 6              1
#&gt; # i 28 more rows
#&gt; # A tibble: 78 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
#&gt; 1     1     2      4
#&gt; 2     1     3      5
#&gt; 3     2     3      6
#&gt; 4     1     4      3
#&gt; 5     2     4      3
#&gt; 6     3     4      3
#&gt; # i 72 more rows
</pre></div>


<h3>References</h3>

<p>Zachary, Wayne W. 1977. “An Information Flow Model for Conflict and Fission in Small Groups.”
<em>Journal of Anthropological Research</em> 33(4):452–73.
<a href="https://doi.org/10.1086/jar.33.4.3629752">doi:10.1086/jar.33.4.3629752</a>.
</p>

<hr>
<h2 id='ison_koenigsberg'>One-mode Seven Bridges of Koenigsberg network (Euler 1741)</h2><span id='topic+ison_koenigsberg'></span>

<h3>Description</h3>

<p>The Seven Bridges of Koenigsberg is a notable historical problem in mathematics and laid the foundations of graph theory.
The city of Koenigsberg in Prussia (now Kaliningrad, Russia) was set on both sides of the Pregel River,
and included two large islands which were connected to each other and the mainland by seven bridges.
A weekend diversion for inhabitants was to find a walk through the city that would cross each bridge once and only once.
The islands could not be reached by any route other than the bridges,
and every bridge must have been crossed completely every time
(one could not walk half way onto the bridge and then turn around and later cross the other half from the other side).
In 1735, Leonard Euler proved that the problem has no solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_koenigsberg)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, multiplex, undirected network with 4 nodes and 7 ties
#&gt; # A tibble: 4 x 3
#&gt;   name       lat   lon
#&gt;   &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1 Altstadt  54.7  20.5
#&gt; 2 Kneiphof  54.7  20.5
#&gt; 3 Lomse     54.7  20.5
#&gt; 4 Vorstadt  54.7  20.5
#&gt; # A tibble: 7 x 3
#&gt;    from    to name           
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;          
#&gt; 1     1     2 Kraemer Bruecke
#&gt; 2     1     2 Schmiedebruecke
#&gt; 3     1     3 Holzbruecke    
#&gt; 4     2     3 Honigbruecke   
#&gt; 5     2     4 Gruene Bruecke 
#&gt; 6     2     4 Koettelbruecke 
#&gt; # i 1 more row
</pre></div>


<h3>Source</h3>

<p><code>{igraphdata}</code>
</p>


<h3>References</h3>

<p>Euler, Leonard. 1741. “Solutio problematis ad geometriam situs pertinentis.”
<em>Commentarii academiae scientiarum Petropolitanae</em>.
</p>

<hr>
<h2 id='ison_laterals'>Two-mode projection examples (Hollway 2021)</h2><span id='topic+ison_laterals'></span>

<h3>Description</h3>

<p>These networks are for demonstration purposes and do not describe any real world network.
All examples contain named nodes.
The networks are gathered together as a list and can be retrieved simply by plucking
the desired network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_laterals)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; $ison_bb
#&gt; # A labelled, two-mode network with 10 nodes and 12 ties
#&gt; # A tibble: 10 x 2
#&gt;   name  type 
#&gt;   &lt;chr&gt; &lt;lgl&gt;
#&gt; 1 A     FALSE
#&gt; 2 U     TRUE 
#&gt; 3 B     FALSE
#&gt; 4 V     TRUE 
#&gt; 5 C     FALSE
#&gt; 6 W     TRUE 
#&gt; # i 4 more rows
#&gt; # A tibble: 12 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     2
#&gt; 2     1     4
#&gt; 3     3     2
#&gt; 4     3     6
#&gt; 5     3     7
#&gt; 6     3     8
#&gt; # i 6 more rows
#&gt; 
#&gt; $ison_bm
#&gt; # A labelled, two-mode network with 8 nodes and 9 ties
#&gt; # A tibble: 8 x 2
#&gt;   name  type 
#&gt;   &lt;chr&gt; &lt;lgl&gt;
#&gt; 1 A     FALSE
#&gt; 2 U     TRUE 
#&gt; 3 B     FALSE
#&gt; 4 V     TRUE 
#&gt; 5 C     FALSE
#&gt; 6 W     TRUE 
#&gt; # i 2 more rows
#&gt; # A tibble: 9 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     2
#&gt; 2     1     4
#&gt; 3     3     2
#&gt; 4     3     6
#&gt; 5     3     7
#&gt; 6     5     4
#&gt; # i 3 more rows
#&gt; 
#&gt; $ison_mb
#&gt; # A labelled, two-mode network with 8 nodes and 9 ties
#&gt; # A tibble: 8 x 2
#&gt;   name  type 
#&gt;   &lt;chr&gt; &lt;lgl&gt;
#&gt; 1 A     FALSE
#&gt; 2 M     TRUE 
#&gt; 3 B     FALSE
#&gt; 4 C     FALSE
#&gt; 5 X     TRUE 
#&gt; 6 Y     TRUE 
#&gt; # i 2 more rows
#&gt; # A tibble: 9 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     2
#&gt; 2     3     2
#&gt; 3     3     5
#&gt; 4     3     6
#&gt; 5     4     2
#&gt; 6     4     5
#&gt; # i 3 more rows
#&gt; 
#&gt; $ison_mm
#&gt; # A labelled, two-mode network with 6 nodes and 6 ties
#&gt; # A tibble: 6 x 2
#&gt;   name  type 
#&gt;   &lt;chr&gt; &lt;lgl&gt;
#&gt; 1 A     FALSE
#&gt; 2 M     TRUE 
#&gt; 3 B     FALSE
#&gt; 4 C     FALSE
#&gt; 5 N     TRUE 
#&gt; 6 D     FALSE
#&gt; # A tibble: 6 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     2
#&gt; 2     3     2
#&gt; 3     3     5
#&gt; 4     4     2
#&gt; 5     4     5
#&gt; 6     6     5
</pre></div>

<hr>
<h2 id='ison_lawfirm'>One-mode lawfirm (Lazega 2001)</h2><span id='topic+ison_lawfirm'></span>

<h3>Description</h3>

<p>One-mode network dataset collected by Lazega (2001)
on the relations between partners in a corporate law firm called SG&amp;R in New England 1988-1991.
This particular subset includes the 36 partners among the 71 attorneys of this firm.
Nodal attributes include seniority, formal status, office in which they work, gender, lawschool they attended,
their age, and how many years they had been at the firm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_lawfirm)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A multiplex, directed network with 71 nodes and 2571 arcs
#&gt; # A tibble: 71 x 7
#&gt;   status  gender office   seniority   age practice   school      
#&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;       
#&gt; 1 partner man    Boston          31    64 litigation Harvard/Yale
#&gt; 2 partner man    Boston          32    62 corporate  Harvard/Yale
#&gt; 3 partner man    Hartford        13    67 litigation Harvard/Yale
#&gt; 4 partner man    Boston          31    59 corporate  Other       
#&gt; 5 partner man    Hartford        31    59 litigation UConn       
#&gt; 6 partner man    Hartford        29    55 litigation Harvard/Yale
#&gt; # i 65 more rows
#&gt; # A tibble: 2,571 x 3
#&gt;    from    to type   
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;  
#&gt; 1     1     2 friends
#&gt; 2     1     2 advice 
#&gt; 3     1     4 friends
#&gt; 4     1     8 friends
#&gt; 5     1    17 friends
#&gt; 6     1    17 advice 
#&gt; # i 2,565 more rows
</pre></div>


<h3>Details</h3>

<p>The larger data from which this subset comes includes also individual performance measurements (hours worked, fees brought in)
and attitudes concerning various management policy options (see also <code>{sand}</code>),
their strong-coworker network, advice network, friendship network, and indirect control network.
</p>


<h3>Source</h3>

<p><code>{networkdata}</code>
</p>


<h3>References</h3>

<p>Lazega, Emmanuel. 2001.
<em>The Collegial Phenomenon: The Social Mechanisms of Cooperation Among Peers in a Corporate Law Partnership</em>.
Oxford: Oxford University Press.
</p>

<hr>
<h2 id='ison_lotr'>One-mode network of Lord of the Rings character interactions</h2><span id='topic+ison_lotr'></span>

<h3>Description</h3>

<p>A network of 36 Lord of the Rings book characters and 66 interactional relationships.
The ties are unweighted and concern only interaction.
Interaction can be cooperative or conflictual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_lotr)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, complex, undirected network with 36 nodes and 66 ties
#&gt; # A tibble: 36 x 2
#&gt;   name     Race  
#&gt;   &lt;chr&gt;    &lt;chr&gt; 
#&gt; 1 Aragorn  Human 
#&gt; 2 Beregond Human 
#&gt; 3 Bilbo    Hobbit
#&gt; 4 Celeborn Elf   
#&gt; 5 Denethor Human 
#&gt; 6 Elladan  Elf   
#&gt; # i 30 more rows
#&gt; # A tibble: 66 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     7
#&gt; 2     1     8
#&gt; 3     5     9
#&gt; 4     1    10
#&gt; 5     3    10
#&gt; 6     9    10
#&gt; # i 60 more rows
</pre></div>

<hr>
<h2 id='ison_marvel'>Multilevel two-mode affiliation, signed one-mode networks of Marvel comic
book characters (Yuksel 2017)</h2><span id='topic+ison_marvel'></span><span id='topic+ison_marvel_teams'></span><span id='topic+ison_marvel_relationships'></span>

<h3>Description</h3>

<p>This package includes two datasets related to the Marvel <em>comic book</em> universe.
The first, <code>ison_marvel_teams</code>,  is a two-mode affiliation network of 53
Marvel comic book characters and their affiliations to 141 different teams.
This network includes only information about nodes' names and nodeset,
but additional nodal data can be taken from the other Marvel dataset here.
</p>
<p>The second network, <code>ison_marvel_relationships</code>, is a one-mode signed network
of friendships and enmities between the 53 Marvel comic book characters.
Friendships are indicated by a positive sign in the tie <code>sign</code> attribute,
whereas enmities are indicated by a negative sign in this edge attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_marvel_teams)

data(ison_marvel_relationships)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, two-mode network with 194 nodes and 683 ties
#&gt; # A tibble: 194 x 2
#&gt;   type  name         
#&gt;   &lt;lgl&gt; &lt;chr&gt;        
#&gt; 1 FALSE Abomination  
#&gt; 2 FALSE Ant-Man      
#&gt; 3 FALSE Apocalypse   
#&gt; 4 FALSE Beast        
#&gt; 5 FALSE Black Panther
#&gt; 6 FALSE Black Widow  
#&gt; # i 188 more rows
#&gt; # A tibble: 683 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1   120
#&gt; 2     1   152
#&gt; 3     1   160
#&gt; 4     1   162
#&gt; 5     1   179
#&gt; 6     2    56
#&gt; # i 677 more rows
</pre></div>
<div class="sourceCode"><pre>#&gt; # A labelled, complex, multiplex, signed, undirected network with 53 nodes and 558 ties
#&gt; # A tibble: 53 x 10
#&gt;   name     Gender Appearances Attractive  Rich Intellect Omnilingual PowerOrigin
#&gt;   &lt;chr&gt;    &lt;chr&gt;        &lt;int&gt;      &lt;int&gt; &lt;int&gt;     &lt;int&gt;       &lt;int&gt; &lt;chr&gt;      
#&gt; 1 Abomina~ Male           427          0     0         1           1 Radiation  
#&gt; 2 Ant-Man  Male           589          1     0         1           0 Human      
#&gt; 3 Apocaly~ Male          1207          0     0         1           1 Mutant     
#&gt; 4 Beast    Male          7609          1     0         1           0 Mutant     
#&gt; 5 Black P~ Male          2189          1     1         1           0 Human      
#&gt; 6 Black W~ Female        2907          1     0         1           0 Human      
#&gt; # i 47 more rows
#&gt; # i 2 more variables: UnarmedCombat &lt;int&gt;, ArmedCombat &lt;int&gt;
#&gt; # A tibble: 558 x 3
#&gt;    from    to  sign
#&gt;   &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
#&gt; 1     1     4    -1
#&gt; 2     1    11    -1
#&gt; 3     1    12    -1
#&gt; 4     1    23    -1
#&gt; 5     1    24    -1
#&gt; 6     1    25    -1
#&gt; # i 552 more rows
</pre></div>


<h3>Details</h3>

<p>Additional nodal variables have been coded and included by Dr Umut Yuksel:
</p>

<ul>
<li> <p><strong>Gender</strong>: binary character, 43 &quot;Male&quot; and 10 &quot;Female&quot;
</p>
</li>
<li> <p><strong>PowerOrigin</strong>: binary character, 2 &quot;Alien&quot;, 1 &quot;Cyborg&quot;, 5 &quot;God/Eternal&quot;,
22 &quot;Human&quot;, 1 &quot;Infection&quot;, 16 &quot;Mutant&quot;, 5 &quot;Radiation&quot;, 1 &quot;Robot&quot;
</p>
</li>
<li> <p><strong>Appearances</strong>: integer, in how many comic book issues they appeared in
</p>
</li>
<li> <p><strong>Attractive</strong>: binary integer, 41 1 (yes) and 12 0 (no)
</p>
</li>
<li> <p><strong>Rich</strong>: binary integer, 11 1 (yes) and 42 0 (no)
</p>
</li>
<li> <p><strong>Intellect</strong>: binary integer, 39 1 (yes) and 14 0 (no)
</p>
</li>
<li> <p><strong>Omnilingual</strong>: binary integer, 8 1 (yes) and 45 0 (no)
</p>
</li>
<li> <p><strong>UnarmedCombat</strong>: binary integer, 51 1 (yes) and 2 0 (no)
</p>
</li>
<li> <p><strong>ArmedCombat</strong>: binary integer, 25 1 (yes) and 28 0 (no)
</p>
</li></ul>



<h3>Source</h3>

<p>Umut Yuksel, 31 March 2017
</p>

<hr>
<h2 id='ison_monastery'>Three one-mode signed, weighted networks and a three-wave longitudinal network of monks (Sampson 1969)</h2><span id='topic+ison_monastery'></span><span id='topic+ison_monastery_like'></span><span id='topic+ison_monastery_esteem'></span><span id='topic+ison_monastery_influence'></span><span id='topic+ison_monastery_praise'></span>

<h3>Description</h3>

<p>The data were collected for an ethnographic study of community structure in a New England monastery.
Various sociometric data was collected of the novices attending the minor seminary of 'Cloisterville'
preparing to join the monastic order:
</p>

<ul>
<li> <p><code>ison_monastery_like</code> records whom novices said they liked most at three time points/waves
</p>
</li>
<li> <p><code>ison_monastery_esteem</code> records whom novices said they held in esteem (sign &gt; 0) and disesteem (sign &lt; 0)
</p>
</li>
<li> <p><code>ison_monastery_praise</code> records whom novices said they praised (sign &gt; 0) and blamed (sign &lt; 0)
</p>
</li>
<li> <p><code>ison_monastery_influence</code> records whom novices said were a positive influence (sign &gt; 0) and negative influence (sign &lt; 0)
</p>
</li></ul>

<p>All networks are weighted.
Novices' first choices are weighted 3, the second 2, and third choices 1.
Some subjects offered tied ranks for their top four choices.
</p>
<p>In addition to node names,
a 'groups' variable records the four groups that Sampson observed during his time there:
</p>

<ul>
<li><p> The <em>Loyal</em> Opposition consists of novices who entered the monastery first and defended existing practices
</p>
</li>
<li><p> The <em>Young Turks</em> arrived later during a period of change and questioned practices in the monastery
</p>
</li>
<li><p> The <em>Interstitial</em> did not take sides in the debate
</p>
</li>
<li><p> The <em>Outcasts</em> were novices that were not accepted in the group
</p>
</li></ul>

<p>Information about senior monks was not included.
While <code>ison_monastery_like</code> is observed over three waves,
the rest of the data was recorded retrospectively from the end of the study,
after the network fragmented.
The waves in which the novitiates were expelled (1), voluntarily departed (2 and 3),
or remained (4) are given in the nodal attribute &quot;left&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_monastery_like)

data(ison_monastery_esteem)

data(ison_monastery_influence)

data(ison_monastery_praise)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A longitudinal, labelled, multiplex, weighted, directed network with 18 nodes and 168 arcs
#&gt; # A tibble: 18 x 3
#&gt;   name        groups        left
#&gt;   &lt;chr&gt;       &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1 Romuald     Interstitial     3
#&gt; 2 Bonaventure Loyal            4
#&gt; 3 Ambrose     Loyal            4
#&gt; 4 Berthold    Loyal            4
#&gt; 5 Peter       Loyal            3
#&gt; 6 Louis       Loyal            4
#&gt; # i 12 more rows
#&gt; # A tibble: 168 x 4
#&gt;    from    to weight  wave
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     1     5      3     1
#&gt; 2     1     7      1     1
#&gt; 3     1    11      2     1
#&gt; 4     2     5      3     1
#&gt; 5     2     6      2     1
#&gt; 6     2    15      1     1
#&gt; # i 162 more rows
</pre></div>
<div class="sourceCode"><pre>#&gt; # A labelled, signed, directed network with 18 nodes and 112 arcs
#&gt; # A tibble: 18 x 3
#&gt;   name        groups        left
#&gt;   &lt;chr&gt;       &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1 Romuald     Interstitial     3
#&gt; 2 Bonaventure Loyal            4
#&gt; 3 Ambrose     Loyal            4
#&gt; 4 Berthold    Loyal            4
#&gt; 5 Peter       Loyal            3
#&gt; 6 Louis       Loyal            4
#&gt; # i 12 more rows
#&gt; # A tibble: 112 x 3
#&gt;    from    to  sign
#&gt;   &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
#&gt; 1     2     3     1
#&gt; 2     2     5     3
#&gt; 3     2     6     2
#&gt; 4     2    16    -1
#&gt; 5     2    17    -3
#&gt; 6     2    18    -2
#&gt; # i 106 more rows
</pre></div>
<div class="sourceCode"><pre>#&gt; # A labelled, signed, directed network with 18 nodes and 103 arcs
#&gt; # A tibble: 18 x 3
#&gt;   name        groups        left
#&gt;   &lt;chr&gt;       &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1 Romuald     Interstitial     3
#&gt; 2 Bonaventure Loyal            4
#&gt; 3 Ambrose     Loyal            4
#&gt; 4 Berthold    Loyal            4
#&gt; 5 Peter       Loyal            3
#&gt; 6 Louis       Loyal            4
#&gt; # i 12 more rows
#&gt; # A tibble: 103 x 3
#&gt;    from    to  sign
#&gt;   &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
#&gt; 1     2     5     3
#&gt; 2     2     6     2
#&gt; 3     2    10     1
#&gt; 4     2    16    -1
#&gt; 5     2    17    -3
#&gt; 6     2    18    -2
#&gt; # i 97 more rows
</pre></div>
<div class="sourceCode"><pre>#&gt; # A labelled, signed, directed network with 18 nodes and 80 arcs
#&gt; # A tibble: 18 x 3
#&gt;   name        groups        left
#&gt;   &lt;chr&gt;       &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1 Romuald     Interstitial     3
#&gt; 2 Bonaventure Loyal            4
#&gt; 3 Ambrose     Loyal            4
#&gt; 4 Berthold    Loyal            4
#&gt; 5 Peter       Loyal            3
#&gt; 6 Louis       Loyal            4
#&gt; # i 12 more rows
#&gt; # A tibble: 80 x 3
#&gt;    from    to  sign
#&gt;   &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
#&gt; 1     4     3     1
#&gt; 2     4     5     3
#&gt; 3     4     6     2
#&gt; 4     4    13    -3
#&gt; 5     4    15    -1
#&gt; 6     4    17    -2
#&gt; # i 74 more rows
</pre></div>


<h3>References</h3>

<p>Sampson, Samuel F. 1969. <em>Crisis in a cloister</em>.
Unpublished doctoral dissertation, Cornell University.
</p>
<p>Breiger R., Boorman S. and Arabie P. 1975.
&quot;An algorithm for clustering relational data with applications to social network analysis and comparison with multidimensional scaling&quot;.
<em>Journal of Mathematical Psychology</em>, 12: 328-383.
</p>

<hr>
<h2 id='ison_networkers'>One-mode EIES dataset (Freeman and Freeman 1979)</h2><span id='topic+ison_networkers'></span>

<h3>Description</h3>

<p>A directed, simple, named, weighted graph with 32 nodes and 440
edges. Nodes are academics and edges illustrate the communication patterns
on an Electronic Information Exchange System among them. Node attributes
include the number of citations (<code>Citations</code>) and the discipline of the
researchers (<code>Discipline</code>). Edge weights illustrate the number of emails
sent from one academic to another over the studied time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_networkers)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, weighted, directed network with 32 nodes and 440 arcs
#&gt; # A tibble: 32 x 3
#&gt;   name               Discipline   Citations
#&gt;   &lt;chr&gt;              &lt;chr&gt;            &lt;dbl&gt;
#&gt; 1 Lin Freeman        Sociology           19
#&gt; 2 Doug White         Anthropology         3
#&gt; 3 Ev Rogers          Other              170
#&gt; 4 Richard Alba       Sociology           23
#&gt; 5 Phipps Arabie      Other               16
#&gt; 6 Carol Barner-Barry Other                6
#&gt; # i 26 more rows
#&gt; # A tibble: 440 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
#&gt; 1     1     2    488
#&gt; 2     1     3     28
#&gt; 3     1     4     65
#&gt; 4     1     5     20
#&gt; 5     1     6     65
#&gt; 6     1     7     45
#&gt; # i 434 more rows
</pre></div>


<h3>Source</h3>

<p>networkdata package
</p>


<h3>References</h3>

<p>Freeman, Sue C. and Linton C. Freeman. 1979.
<em>The networkers network: A study of the impact of a new communications medium on sociometric structure</em>.
Social Science Research Reports No 46. Irvine CA, University of California.
</p>
<p>Wasserman Stanley and Katherine Faust. 1994.
<em>Social Network Analysis: Methods and Applications</em>.
Cambridge University Press, Cambridge.
</p>

<hr>
<h2 id='ison_physicians'>Four multiplex one-mode physician diffusion data (Coleman, Katz, and Menzel, 1966)</h2><span id='topic+ison_physicians'></span>

<h3>Description</h3>

<p>Ron Burt prepared this data from
Coleman, Katz and Menzel's 1966 study on medical innovation.
They had collected data from physicians in four towns in Illinois:
Peoria, Bloomington, Quincy and Galesburg.
These four networks are held as separate networks in a list.
</p>
<p>Coleman, Katz and Menzel were concerned with the impact of network ties
on the physicians' adoption of a new drug, tetracycline.
Data on three types of ties were collected in response to three questions:
</p>

<ul>
<li><p> advice: &quot;When you need information or advice about questions of therapy
where do you usually turn?&quot;
</p>
</li>
<li><p> discussion: &quot;And who are the three or four physicians with whom you most often find yourself
discussing cases or therapy in the course of an ordinary week – last week for instance?&quot;
</p>
</li>
<li><p> friendship: &quot;Would you tell me the first names of your three friends
whom you see most often socially?&quot;
</p>
</li></ul>

<p>Additional questions and records of prescriptions provided additional information:
</p>

<ul>
<li><p> recorded date of tetracycline <code>adoption</code> date
</p>
</li>
<li><p> years in <code>practice</code>
(note that these are <code>{messydates}</code>-compatible dates)
</p>
</li>
<li> <p><code>conferences</code> attended
(those that attended &quot;Specialty&quot; conferences presumably also attended &quot;General&quot; conferences)
</p>
</li>
<li><p> regular subscriptions to medical <code>journals</code>
</p>
</li>
<li> <p><code>free_time</code> spent associating with doctors
</p>
</li>
<li> <p><code>discussions</code> on medical matters when with other doctors sociallyy
</p>
</li>
<li><p> memberships in <code>clubs</code> with other doctores
</p>
</li>
<li><p> number of top 3 <code>friends</code> that are doctors
</p>
</li>
<li><p> time practicing in current <code>community</code>
</p>
</li>
<li> <p><code>patients</code> load (ordinal)
</p>
</li>
<li><p> physical <code>proximity</code> to other physicians (in building/sharing office)
</p>
</li>
<li><p> medical <code>specialty</code> (GP/Internist/Pediatrician/Other)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(ison_physicians)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; $Peoria
#&gt; # A multiplex, directed network with 117 nodes and 543 arcs
#&gt; # A tibble: 117 x 12
#&gt;   adoption specialty    conferences journals practice   community patients
#&gt;      &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;   
#&gt; 1        1 Pediatrician Specialty          9 1920..1929 20+yrs    101-150 
#&gt; 2       12 GP           None               5 1945..     -1yr      76-100  
#&gt; 3        8 Internist    General            7 1935..1939 10-20yrs  76-100  
#&gt; 4        9 GP           General            6 1940..1944 5-10yrs   51-75   
#&gt; 5        9 GP           General            4 1935..1939 10-20yrs  51-75   
#&gt; 6       10 Internist    None               7 1930..1934 10-20yrs  101-150 
#&gt; # i 111 more rows
#&gt; # i 5 more variables: doc_freetime &lt;dbl&gt;, doc_discuss &lt;dbl&gt;, doc_friends &lt;dbl&gt;,
#&gt; #   doc_club &lt;dbl&gt;, doc_proximity &lt;chr&gt;
#&gt; # A tibble: 543 x 3
#&gt;    from    to type      
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;     
#&gt; 1     1     8 friendship
#&gt; 2     1    58 friendship
#&gt; 3     1    87 advice    
#&gt; 4     1    90 advice    
#&gt; 5     1   110 advice    
#&gt; 6     1   112 friendship
#&gt; # i 537 more rows
#&gt; 
#&gt; $Bloomington
#&gt; # A multiplex, directed network with 50 nodes and 211 arcs
#&gt; # A tibble: 50 x 12
#&gt;   adoption specialty conferences journals practice   community patients
#&gt;      &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;   
#&gt; 1       98 Internist Specialty          8 1930..1934 10-20yrs  101-150 
#&gt; 2        1 GP        General            3 1945..     5-10yrs   76-100  
#&gt; 3       98 GP        Specialty          4 1930..1934 10-20yrs  101-150 
#&gt; 4        7 Internist None               3 1945..     -1yr      26-50   
#&gt; 5        6 Internist General            9 1935..1939 5-10yrs   76-100  
#&gt; 6        1 GP        Specialty          5 1935..1939 10-20yrs  101-150 
#&gt; # i 44 more rows
#&gt; # i 5 more variables: doc_freetime &lt;dbl&gt;, doc_discuss &lt;dbl&gt;, doc_friends &lt;dbl&gt;,
#&gt; #   doc_club &lt;dbl&gt;, doc_proximity &lt;chr&gt;
#&gt; # A tibble: 211 x 3
#&gt;    from    to type      
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;     
#&gt; 1     1     3 friendship
#&gt; 2     1    10 discussion
#&gt; 3     1    24 advice    
#&gt; 4     1    44 advice    
#&gt; 5     2     4 advice    
#&gt; 6     2     6 advice    
#&gt; # i 205 more rows
#&gt; 
#&gt; $Quincy
#&gt; # A multiplex, directed network with 44 nodes and 174 arcs
#&gt; # A tibble: 44 x 12
#&gt;   adoption specialty conferences journals practice   community patients
#&gt;      &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;   
#&gt; 1        2 Internist None               6 1935..1939 10-20yrs  151+    
#&gt; 2       18 GP        General            3 1920..1929 20+yrs    151+    
#&gt; 3       18 Internist None               5 1945..     -1yr      -25     
#&gt; 4        4 GP        General            3 1930..1934 20+yrs    151+    
#&gt; 5       18 GP        Specialty          4 1935..1939 10-20yrs  151+    
#&gt; 6        5 Internist General            5 ..1919     20+yrs    51-75   
#&gt; # i 38 more rows
#&gt; # i 5 more variables: doc_freetime &lt;dbl&gt;, doc_discuss &lt;dbl&gt;, doc_friends &lt;dbl&gt;,
#&gt; #   doc_club &lt;dbl&gt;, doc_proximity &lt;chr&gt;
#&gt; # A tibble: 174 x 3
#&gt;    from    to type      
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;     
#&gt; 1     1     8 advice    
#&gt; 2     1     9 advice    
#&gt; 3     1    10 discussion
#&gt; 4     1    13 friendship
#&gt; 5     1    15 advice    
#&gt; 6     1    22 discussion
#&gt; # i 168 more rows
#&gt; 
#&gt; $Galesburg
#&gt; # A multiplex, directed network with 35 nodes and 171 arcs
#&gt; # A tibble: 35 x 12
#&gt;   adoption specialty conferences journals practice   community patients
#&gt;      &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;   
#&gt; 1       18 GP        General            4 1935..1939 5-10yrs   101-150 
#&gt; 2       18 GP        None               4 1935..1939 -1yr      151+    
#&gt; 3        4 GP        General            6 1945..     2-5yrs    51-75   
#&gt; 4        5 GP        None               4 1935..1939 10-20yrs  101-150 
#&gt; 5        8 Internist General            6 1935..1939 5-10yrs   151+    
#&gt; 6        4 Internist Specialty          8 ..1919     20+yrs    76-100  
#&gt; # i 29 more rows
#&gt; # i 5 more variables: doc_freetime &lt;dbl&gt;, doc_discuss &lt;dbl&gt;, doc_friends &lt;dbl&gt;,
#&gt; #   doc_club &lt;dbl&gt;, doc_proximity &lt;chr&gt;
#&gt; # A tibble: 171 x 3
#&gt;    from    to type      
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;     
#&gt; 1     1     5 advice    
#&gt; 2     1     6 advice    
#&gt; 3     1    20 discussion
#&gt; 4     1    23 discussion
#&gt; 5     1    30 friendship
#&gt; 6     1    31 friendship
#&gt; # i 165 more rows
</pre></div>


<h3>Source</h3>

<p><code>{networkdata}</code>
</p>


<h3>References</h3>

<p>Coleman, James, Elihu Katz, and Herbert Menzel. 1966.
<em>Medical innovation: A diffusion study</em>.
Indianapolis: The Bobbs-Merrill Company.
</p>

<hr>
<h2 id='ison_potter'>Six complex one-mode support data in Harry Potter books (Bossaert and Meidert 2013)</h2><span id='topic+ison_potter'></span>

<h3>Description</h3>

<p>Goele Bossaert and Nadine Meidert coded peer support ties among 64 characters
in the Harry Potter books.
Each author coded four of seven books using NVivo,
with the seventh book coded by both and serving to assess inter-rater reliability.
The first six books concentrated on adolescent interactions,
were studied in their paper, and are made available here.
The peer support ties mean voluntary emotional, instrumental, or informational support,
or praise from one living, adolescent character to another within the book's pages.
In addition, nodal attributes name, schoolyear (which doubles as their age),
gender, and their house assigned by the sorting hat are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_potter)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; $book1
#&gt; # A labelled, complex, directed network with 64 nodes and 47 arcs
#&gt; # A tibble: 64 x 4
#&gt;   name              schoolyear gender house     
#&gt;   &lt;chr&gt;                  &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
#&gt; 1 Adrian Pucey            1989 male   Slytherin 
#&gt; 2 Alicia Spinnet          1989 female Gryffindor
#&gt; 3 Angelina Johnson        1989 female Gryffindor
#&gt; 4 Anthony Goldstein       1991 male   Ravenclaw 
#&gt; 5 Blaise Zabini           1991 male   Slytherin 
#&gt; 6 C. Warrington           1989 male   Slytherin 
#&gt; # i 58 more rows
#&gt; # A tibble: 47 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1    11    11
#&gt; 2    11    25
#&gt; 3    11    26
#&gt; 4    11    44
#&gt; 5    11    56
#&gt; 6    11    58
#&gt; # i 41 more rows
#&gt; 
#&gt; $book2
#&gt; # A labelled, complex, directed network with 64 nodes and 110 arcs
#&gt; # A tibble: 64 x 4
#&gt;   name              schoolyear gender house     
#&gt;   &lt;chr&gt;                  &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
#&gt; 1 Adrian Pucey            1989 male   Slytherin 
#&gt; 2 Alicia Spinnet          1989 female Gryffindor
#&gt; 3 Angelina Johnson        1989 female Gryffindor
#&gt; 4 Anthony Goldstein       1991 male   Ravenclaw 
#&gt; 5 Blaise Zabini           1991 male   Slytherin 
#&gt; 6 C. Warrington           1989 male   Slytherin 
#&gt; # i 58 more rows
#&gt; # A tibble: 110 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     2     2
#&gt; 2     2     3
#&gt; 3     2    19
#&gt; 4     2    20
#&gt; 5     2    25
#&gt; 6     2    26
#&gt; # i 104 more rows
#&gt; 
#&gt; $book3
#&gt; # A labelled, complex, directed network with 64 nodes and 104 arcs
#&gt; # A tibble: 64 x 4
#&gt;   name              schoolyear gender house     
#&gt;   &lt;chr&gt;                  &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
#&gt; 1 Adrian Pucey            1989 male   Slytherin 
#&gt; 2 Alicia Spinnet          1989 female Gryffindor
#&gt; 3 Angelina Johnson        1989 female Gryffindor
#&gt; 4 Anthony Goldstein       1991 male   Ravenclaw 
#&gt; 5 Blaise Zabini           1991 male   Slytherin 
#&gt; 6 C. Warrington           1989 male   Slytherin 
#&gt; # i 58 more rows
#&gt; # A tibble: 104 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     2     2
#&gt; 2     2     3
#&gt; 3     2    19
#&gt; 4     2    20
#&gt; 5     2    25
#&gt; 6     2    26
#&gt; # i 98 more rows
#&gt; 
#&gt; $book4
#&gt; # A labelled, complex, directed network with 64 nodes and 49 arcs
#&gt; # A tibble: 64 x 4
#&gt;   name              schoolyear gender house     
#&gt;   &lt;chr&gt;                  &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
#&gt; 1 Adrian Pucey            1989 male   Slytherin 
#&gt; 2 Alicia Spinnet          1989 female Gryffindor
#&gt; 3 Angelina Johnson        1989 female Gryffindor
#&gt; 4 Anthony Goldstein       1991 male   Ravenclaw 
#&gt; 5 Blaise Zabini           1991 male   Slytherin 
#&gt; 6 C. Warrington           1989 male   Slytherin 
#&gt; # i 58 more rows
#&gt; # A tibble: 49 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     7     7
#&gt; 2     7     8
#&gt; 3     7    25
#&gt; 4     8     8
#&gt; 5     8    25
#&gt; 6     9     9
#&gt; # i 43 more rows
#&gt; 
#&gt; $book5
#&gt; # A labelled, complex, directed network with 64 nodes and 160 arcs
#&gt; # A tibble: 64 x 4
#&gt;   name              schoolyear gender house     
#&gt;   &lt;chr&gt;                  &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
#&gt; 1 Adrian Pucey            1989 male   Slytherin 
#&gt; 2 Alicia Spinnet          1989 female Gryffindor
#&gt; 3 Angelina Johnson        1989 female Gryffindor
#&gt; 4 Anthony Goldstein       1991 male   Ravenclaw 
#&gt; 5 Blaise Zabini           1991 male   Slytherin 
#&gt; 6 C. Warrington           1989 male   Slytherin 
#&gt; # i 58 more rows
#&gt; # A tibble: 160 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     2     2
#&gt; 2     2     3
#&gt; 3     2    19
#&gt; 4     2    20
#&gt; 5     2    25
#&gt; 6     2    29
#&gt; # i 154 more rows
#&gt; 
#&gt; $book6
#&gt; # A labelled, complex, directed network with 64 nodes and 74 arcs
#&gt; # A tibble: 64 x 4
#&gt;   name              schoolyear gender house     
#&gt;   &lt;chr&gt;                  &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
#&gt; 1 Adrian Pucey            1989 male   Slytherin 
#&gt; 2 Alicia Spinnet          1989 female Gryffindor
#&gt; 3 Angelina Johnson        1989 female Gryffindor
#&gt; 4 Anthony Goldstein       1991 male   Ravenclaw 
#&gt; 5 Blaise Zabini           1991 male   Slytherin 
#&gt; 6 C. Warrington           1989 male   Slytherin 
#&gt; # i 58 more rows
#&gt; # A tibble: 74 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1    11    11
#&gt; 2    11    25
#&gt; 3    11    56
#&gt; 4    11    58
#&gt; 5    12    12
#&gt; 6    14    14
#&gt; # i 68 more rows
</pre></div>


<h3>References</h3>

<p>Bossaert, Goele and Nadine Meidert (2013).
&quot;'We are only as strong as we are united, as weak as we are divided'. A dynamic analysis of the peer support networks in the Harry Potter books.&quot;
<em>Open Journal of Applied Sciences</em>, 3(2): 174-185.
<a href="https://doi.org/10.4236/ojapps.2013.32024">doi:10.4236/ojapps.2013.32024</a>
</p>

<hr>
<h2 id='ison_southern_women'>Two-mode southern women (Davis, Gardner and Gardner 1941)</h2><span id='topic+ison_southern_women'></span>

<h3>Description</h3>

<p>Two-mode network dataset collected by Davis, Gardner and Gardner (1941)
about the attendance pattern of women at informal social events
during a 9 month period. Events and women are named.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_southern_women)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, two-mode network with 32 nodes and 93 ties
#&gt; # A tibble: 32 x 2
#&gt;   type  name     
#&gt;   &lt;lgl&gt; &lt;chr&gt;    
#&gt; 1 FALSE Evelyn   
#&gt; 2 FALSE Laura    
#&gt; 3 FALSE Theresa  
#&gt; 4 FALSE Brenda   
#&gt; 5 FALSE Charlotte
#&gt; 6 FALSE Frances  
#&gt; # i 26 more rows
#&gt; # A tibble: 93 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1    19
#&gt; 2     1    20
#&gt; 3     1    21
#&gt; 4     1    22
#&gt; 5     1    23
#&gt; 6     1    24
#&gt; # i 87 more rows
</pre></div>


<h3>References</h3>

<p>Davis, Allison, Burleigh B. Gardner, and Mary R. Gardner. 1941.
<em>Deep South</em>.
Chicago: University of Chicago Press.
</p>

<hr>
<h2 id='ison_starwars'>Seven one-mode Star Wars character interactions (Gabasova 2016)</h2><span id='topic+ison_starwars'></span>

<h3>Description</h3>

<p>One-mode network dataset collected by Gabasova (2016)
on the interactions between Star Wars characters in each movie from
Episode 1 (The Phantom Menace) to Episode 7 (The Force Awakens).
There is a separate network for each episode,
and the data is listed in order from episode 1 to 7.
The network for each episode varies in the number of nodes and ties.
For all networks, characters are named (eg. R2-D2, Anakin, Chewbacca)
and the following node attributes are provided where available:
height, mass, hair color, skin color, eye color, birth year, sex, homeworld, and species.
The node attribute 'faction' has also been added,
denoting the faction (eg. Jedi, Rebel Alliance, etc)
that Star Wars characters belong to in each episode
(coding completed with help of Yichen Shen and Tiphaine Aeby).
Weighted ties represent the number of times characters speak
within the same scene of the film.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_starwars)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; $`Episode I`
#&gt; # A labelled, weighted, undirected network with 38 nodes and 135 ties
#&gt; # A tibble: 38 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 R2-D2      96    32 &lt;NA&gt;       white, bl~ red               33 none  Naboo    
#&gt; 2 QUI-G~    193    89 brown      fair       blue              92 male  &lt;NA&gt;     
#&gt; 3 NUTE ~    191    90 none       mottled g~ red               NA male  Cato Nei~
#&gt; 4 PK-4       NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;              NA &lt;NA&gt;  &lt;NA&gt;     
#&gt; 5 TC-14      NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;              NA &lt;NA&gt;  &lt;NA&gt;     
#&gt; 6 OBI-W~    182    77 auburn, w~ fair       blue-gray         57 male  Stewjon  
#&gt; # i 32 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 135 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     1    16     11
#&gt; 2     1     2     14
#&gt; 3     1    19     16
#&gt; 4     1    18      3
#&gt; 5     1    23      2
#&gt; 6     1    25      2
#&gt; # i 129 more rows
#&gt; 
#&gt; $`Episode II`
#&gt; # A labelled, weighted, undirected network with 33 nodes and 101 ties
#&gt; # A tibble: 33 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 R2-D2      96    32 &lt;NA&gt;       white, bl~ red               33 none  Naboo    
#&gt; 2 CAPTA~    185    85 black      dark       brown             NA male  Naboo    
#&gt; 3 EMPER~    170    75 grey       pale       yellow            82 male  Naboo    
#&gt; 4 SENAT~     NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;              NA &lt;NA&gt;  &lt;NA&gt;     
#&gt; 5 ORN F~     NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;              NA &lt;NA&gt;  &lt;NA&gt;     
#&gt; 6 MACE ~    188    84 none       dark       brown             72 male  Haruun K~
#&gt; # i 27 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 101 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     1    13      7
#&gt; 2     1    12      7
#&gt; 3     1    24      3
#&gt; 4     3     4      2
#&gt; 5     3     5      2
#&gt; 6     4     5      1
#&gt; # i 95 more rows
#&gt; 
#&gt; $`Episode III`
#&gt; # A labelled, weighted, undirected network with 24 nodes and 65 ties
#&gt; # A tibble: 24 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 R2-D2      96    32 &lt;NA&gt;       white, bl~ red             33   none  Naboo    
#&gt; 2 ANAKIN    188    84 blond      fair       blue            41.9 male  Tatooine 
#&gt; 3 OBI-W~    182    77 auburn, w~ fair       blue-gray       57   male  Stewjon  
#&gt; 4 ODD B~     NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;            NA   &lt;NA&gt;  &lt;NA&gt;     
#&gt; 5 GENER~    216   159 none       brown, wh~ green, y~       NA   male  Kalee    
#&gt; 6 EMPER~    170    75 grey       pale       yellow          82   male  Naboo    
#&gt; # i 18 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 65 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     1     6      2
#&gt; 2     1     3     12
#&gt; 3     1     2      9
#&gt; 4     1     9      5
#&gt; 5     1     8      4
#&gt; 6     1    10      4
#&gt; # i 59 more rows
#&gt; 
#&gt; $`Episode IV`
#&gt; # A labelled, weighted, undirected network with 21 nodes and 60 ties
#&gt; # A tibble: 21 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 R2-D2      96    32 &lt;NA&gt;       white, bl~ red             33   none  Naboo    
#&gt; 2 CHEWB~    228   112 brown      unknown    blue           200   male  Kashyyyk 
#&gt; 3 C-3PO     167    75 &lt;NA&gt;       gold       yellow         112   none  Tatooine 
#&gt; 4 LUKE      172    77 blond      fair       blue            19   male  Tatooine 
#&gt; 5 DARTH~    202   136 none       white      yellow          41.9 male  Tatooine 
#&gt; 6 CAMIE      NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;            NA   &lt;NA&gt;  &lt;NA&gt;     
#&gt; # i 15 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 60 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     1     2      3
#&gt; 2     1     3     17
#&gt; 3     1     9      1
#&gt; 4     1     4     14
#&gt; 5     1    10      1
#&gt; 6     1    11      4
#&gt; # i 54 more rows
#&gt; 
#&gt; $`Episode V`
#&gt; # A labelled, weighted, undirected network with 21 nodes and 55 ties
#&gt; # A tibble: 21 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 R2-D2      96    32 &lt;NA&gt;       white, bl~ red               33 none  Naboo    
#&gt; 2 CHEWB~    228   112 brown      unknown    blue             200 male  Kashyyyk 
#&gt; 3 LUKE      172    77 blond      fair       blue              19 male  Tatooine 
#&gt; 4 HAN       180    80 brown      fair       brown             29 male  Corellia 
#&gt; 5 RIEEK~     NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;              NA &lt;NA&gt;  &lt;NA&gt;     
#&gt; 6 LEIA      150    49 brown      light      brown             19 fema~ Alderaan 
#&gt; # i 15 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 55 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     1     2      5
#&gt; 2     1     7     10
#&gt; 3     1     3      7
#&gt; 4     1     4      4
#&gt; 5     1     6      5
#&gt; 6     1    21      1
#&gt; # i 49 more rows
#&gt; 
#&gt; $`Episode VI`
#&gt; # A labelled, weighted, undirected network with 20 nodes and 55 ties
#&gt; # A tibble: 20 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 R2-D2      96    32 &lt;NA&gt;       white, bl~ red             33   none  Naboo    
#&gt; 2 CHEWB~    228   112 brown      unknown    blue           200   male  Kashyyyk 
#&gt; 3 JERJE~     NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;            NA   &lt;NA&gt;  &lt;NA&gt;     
#&gt; 4 DARTH~    202   136 none       white      yellow          41.9 male  Tatooine 
#&gt; 5 C-3PO     167    75 &lt;NA&gt;       gold       yellow         112   none  Tatooine 
#&gt; 6 BIB F~    180    NA none       pale       pink            NA   male  Ryloth   
#&gt; # i 14 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 55 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     1     2      8
#&gt; 2     1     5     14
#&gt; 3     1    12      2
#&gt; 4     1     7      2
#&gt; 5     1     8      8
#&gt; 6     1    10      9
#&gt; # i 49 more rows
#&gt; 
#&gt; $`Episode VII`
#&gt; # A labelled, weighted, undirected network with 27 nodes and 92 ties
#&gt; # A tibble: 27 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 LUKE      172    77 blond      fair       blue              19 male  Tatooine 
#&gt; 2 R2-D2      96    32 &lt;NA&gt;       white, bl~ red               33 none  Naboo    
#&gt; 3 CHEWB~    228   112 brown      unknown    blue             200 male  Kashyyyk 
#&gt; 4 BB-8       NA    NA none       none       black             NA none  &lt;NA&gt;     
#&gt; 5 LOR S~     NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;              NA &lt;NA&gt;  &lt;NA&gt;     
#&gt; 6 POE        NA    NA brown      light      brown             NA male  &lt;NA&gt;     
#&gt; # i 21 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 92 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     2     3      1
#&gt; 2     2     4      2
#&gt; 3     3     4      9
#&gt; 4     2    18      2
#&gt; 5     3     9     20
#&gt; 6     3    11     13
#&gt; # i 86 more rows
</pre></div>


<h3>Details</h3>

<p>The network for each episode may be extracted and used separately,
eg. <code>ison_starwars[[1]]</code> or <code style="white-space: pre;">&#8288;ison_starwars$Episode I&#8288;</code> for Episode 1.
</p>


<h3>References</h3>

<p>Gabasova, E. (2016).
<em>Star Wars social network.</em>.
<a href="https://doi.org/10.5281/zenodo.1411479">doi:10.5281/zenodo.1411479</a>
</p>

<hr>
<h2 id='ison_usstates'>One-mode undirected network of US state contiguity (Meghanathan 2017)</h2><span id='topic+ison_usstates'></span>

<h3>Description</h3>

<p>This network is of contiguity between US states.
States that share a border are connected by a tie in the network.
The data is a network of 107 ties among 50 US states (nodes).
States are named by their two-letter ISO-3166 code.
This data includes also the names of the capitol cities of each state,
which are listed in the node attribute 'capitol'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_usstates)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, undirected network with 50 nodes and 107 ties
#&gt; # A tibble: 50 x 2
#&gt;   name  capitol    
#&gt;   &lt;chr&gt; &lt;chr&gt;      
#&gt; 1 AK    Juneau     
#&gt; 2 AL    Montgomery 
#&gt; 3 AR    Little Rock
#&gt; 4 AZ    Phoenix    
#&gt; 5 CA    Sacramento 
#&gt; 6 CO    Denver     
#&gt; # i 44 more rows
#&gt; # A tibble: 107 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     2     9
#&gt; 2     2    10
#&gt; 3     2    25
#&gt; 4     2    42
#&gt; 5     3    18
#&gt; 6     3    24
#&gt; # i 101 more rows
</pre></div>


<h3>References</h3>

<p>Meghanathan, Natarajan. 2017.
&quot;Complex network analysis of the contiguous United States graph.&quot;
<em>Computer and Information Science</em>, 10(1): 54-76.
<a href="https://doi.org/10.5539/cis.v10n1p54">doi:10.5539/cis.v10n1p54</a>
</p>

<hr>
<h2 id='learning'>Making learning models on networks</h2><span id='topic+learning'></span><span id='topic+play_learning'></span><span id='topic+play_segregation'></span>

<h3>Description</h3>

<p>These functions allow learning games to be played upon networks.
</p>

<ul>
<li> <p><code>play_learning()</code> plays a DeGroot learning model upon a network.
</p>
</li>
<li> <p><code>play_segregation()</code> plays a Schelling segregation model upon a network.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>play_learning(.data, beliefs, steps, epsilon = 5e-04)

play_segregation(
  .data,
  attribute,
  heterophily = 0,
  who_moves = c("ordered", "random", "most_dissatisfied"),
  choice_function = c("satisficing", "optimising", "minimising"),
  steps
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learning_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="learning_+3A_beliefs">beliefs</code></td>
<td>
<p>A vector indicating the probabilities nodes
put on some outcome being 'true'.</p>
</td></tr>
<tr><td><code id="learning_+3A_steps">steps</code></td>
<td>
<p>The number of steps forward in learning.
By default the number of nodes in the network.</p>
</td></tr>
<tr><td><code id="learning_+3A_epsilon">epsilon</code></td>
<td>
<p>The maximum difference in beliefs accepted
for convergence to a consensus.</p>
</td></tr>
<tr><td><code id="learning_+3A_attribute">attribute</code></td>
<td>
<p>A string naming some nodal attribute in the network.
Currently only tested for binary attributes.</p>
</td></tr>
<tr><td><code id="learning_+3A_heterophily">heterophily</code></td>
<td>
<p>A score ranging between -1 and 1 as a threshold for
how heterophilous nodes will accept their neighbours to be.
A single proportion means this threshold is shared by all nodes,
but it can also be a vector the same length of the nodes in the network
for issuing different thresholds to different nodes.
By default this is 0, meaning nodes will be dissatisfied if more than half
of their neighbours differ on the given attribute.</p>
</td></tr>
<tr><td><code id="learning_+3A_who_moves">who_moves</code></td>
<td>
<p>One of the following options:
&quot;ordered&quot; (the default) checks each node in turn for whether they are
dissatisfied and there is an available space that they can move to,
&quot;random&quot; will check a node at random,
and &quot;most_dissatisfied&quot; will check (one of) the most dissatisfied nodes first.</p>
</td></tr>
<tr><td><code id="learning_+3A_choice_function">choice_function</code></td>
<td>
<p>One of the following options:
&quot;satisficing&quot; (the default) will move the node to any coordinates that satisfy
their heterophily threshold,
&quot;optimising&quot; will move the node to coordinates that are most homophilous,
and &quot;minimising&quot; distance will move the node to the next nearest unoccupied coordinates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other makes: 
<code><a href="#topic+create">create</a></code>,
<code><a href="#topic+generate">generate</a></code>,
<code><a href="#topic+play">play</a></code>,
<code><a href="#topic+read">read</a></code>,
<code><a href="#topic+write">write</a>()</code>
</p>
<p>Other models: 
<code><a href="#topic+play">play</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  play_learning(ison_networkers, 
      rbinom(manynet::network_nodes(ison_networkers),1,prob = 0.25))
  startValues &lt;- rbinom(100,1,prob = 0.5)
  startValues[sample(seq_len(100), round(100*0.2))] &lt;- NA
  latticeEg &lt;- create_lattice(100)
  latticeEg &lt;- add_node_attribute(latticeEg, "startValues", startValues)
  latticeEg
  play_segregation(latticeEg, "startValues", 0.5)
  # autographr(latticeEg, node_color = "startValues", node_size = 5) + 
  # autographr(play_segregation(latticeEg, "startValues", 0.2), 
  #            node_color = "startValues", node_size = 5)
</code></pre>

<hr>
<h2 id='many_palettes'>Many palettes generator</h2><span id='topic+many_palettes'></span>

<h3>Description</h3>

<p>Many palettes generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>many_palettes(palette, n, type = c("discrete", "continuous"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="many_palettes_+3A_palette">palette</code></td>
<td>
<p>Name of desired palette. Current choices are:
<code>IHEID</code>, <code>Centres</code>, <code>SDGs</code>, <code>ETHZ</code>, <code>RUG</code>,
and <code>UZH</code>.</p>
</td></tr>
<tr><td><code id="many_palettes_+3A_n">n</code></td>
<td>
<p>Number of colors desired. If omitted, uses all colours.</p>
</td></tr>
<tr><td><code id="many_palettes_+3A_type">type</code></td>
<td>
<p>Either &quot;continuous&quot; or &quot;discrete&quot;. Use continuous if you want
to automatically interpolate between colours.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graphic display of colours in palette.
</p>


<h3>Source</h3>

<p>Adapted from <a href="https://github.com/karthik/wesanderson/blob/master/R/colors.R">https://github.com/karthik/wesanderson/blob/master/R/colors.R</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>many_palettes()
#many_palettes("IHEID")
</code></pre>

<hr>
<h2 id='mark_diff'>Marking nodes based on diffusion properties</h2><span id='topic+mark_diff'></span><span id='topic+node_is_latent'></span><span id='topic+node_is_infected'></span><span id='topic+node_is_recovered'></span><span id='topic+node_is_exposed'></span>

<h3>Description</h3>

<p>These functions return logical vectors the length of the
nodes in a network identifying which hold certain properties or positions in the network.
</p>

<ul>
<li> <p><code>node_is_infected()</code> marks nodes that are infected by a particular time point.
</p>
</li>
<li> <p><code>node_is_exposed()</code> marks nodes that are exposed to a given (other) mark.
</p>
</li>
<li> <p><code>node_is_latent()</code> marks nodes that are latent at a particular time point.
</p>
</li>
<li> <p><code>node_is_recovered()</code> marks nodes that are recovered at a particular time point.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_is_latent(diff_model, time = 0)

node_is_infected(diff_model, time = 0)

node_is_recovered(diff_model, time = 0)

node_is_exposed(.data, mark)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_diff_+3A_diff_model">diff_model</code></td>
<td>
<p>A diff_model object,
created either by <code>play_diffusion()</code> or <code>as_diffusion()</code>.</p>
</td></tr>
<tr><td><code id="mark_diff_+3A_time">time</code></td>
<td>
<p>A time step at which nodes are identified.</p>
</td></tr>
<tr><td><code id="mark_diff_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="mark_diff_+3A_mark">mark</code></td>
<td>
<p>vector denoting which nodes are infected</p>
</td></tr>
</table>


<h3>Exposed</h3>

<p><code>node_is_exposed()</code> is similar to <code>node_exposure()</code>,
but returns a mark (TRUE/FALSE) vector indicating which nodes
are currently exposed to the diffusion content.
This diffusion content can be expressed in the 'mark' argument.
If no 'mark' argument is provided,
and '.data' is a diff_model object,
then the function will return nodes exposure to the seed nodes
in that diffusion.
</p>


<h3>See Also</h3>

<p>Other marks: 
<code><a href="#topic+mark_nodes">mark_nodes</a></code>,
<code><a href="#topic+mark_select">mark_select</a></code>,
<code><a href="#topic+mark_tie_select">mark_tie_select</a></code>,
<code><a href="#topic+mark_ties">mark_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # To mark nodes that are latent by a particular time point
  node_is_latent(play_diffusion(create_tree(6), latency = 1), time = 1)
  # To mark nodes that are infected by a particular time point
  node_is_infected(play_diffusion(create_tree(6)), time = 1)
  # To mark nodes that are recovered by a particular time point
  node_is_recovered(play_diffusion(create_tree(6), recovery = 0.5), time = 3)
  # To mark which nodes are currently exposed
  (expos &lt;- node_is_exposed(manynet::create_tree(14), mark = c(1,3)))
  which(expos)
</code></pre>

<hr>
<h2 id='mark_nodes'>Marking nodes based on structural properties</h2><span id='topic+mark_nodes'></span><span id='topic+node_is_isolate'></span><span id='topic+node_is_cutpoint'></span><span id='topic+node_is_core'></span><span id='topic+node_is_fold'></span><span id='topic+node_is_mentor'></span>

<h3>Description</h3>

<p>These functions return logical vectors the length of the
nodes in a network identifying which hold certain properties or positions in the network.
</p>

<ul>
<li> <p><code>node_is_cutpoint()</code> marks nodes that cut or act as articulation points in a network,
increasing the number of connected components when removed.
</p>
</li>
<li> <p><code>node_is_isolate()</code> marks nodes that are isolates,
with neither incoming nor outgoing ties.
</p>
</li>
<li> <p><code>node_is_core()</code> marks nodes that are members of the network's core.
</p>
</li>
<li> <p><code>node_is_fold()</code> marks nodes that are in a structural fold between two or more
triangles that are only connected by that node.
</p>
</li>
<li> <p><code>node_is_mentor()</code> marks a proportion of high indegree nodes as 'mentors' (see details)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_is_isolate(.data)

node_is_cutpoint(.data)

node_is_core(.data)

node_is_fold(.data)

node_is_mentor(.data, elites = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_nodes_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="mark_nodes_+3A_elites">elites</code></td>
<td>
<p>The proportion of nodes to be selected as mentors.
By default this is set at 0.1.
This means that the top 10% of nodes in terms of degree,
or those equal to the highest rank degree in the network,
whichever is the higher, will be used to select the mentors.
</p>
<p>Note that if nodes are equidistant from two mentors,
they will choose one at random.
If a node is without a path to a mentor,
for example because they are an isolate,
a tie to themselves (a loop) will be created instead.
Note that this is a different default behaviour than that
described in Valente and Davis (1999).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Valente, Thomas, and Rebecca Davis. 1999.
&quot;Accelerating the Diffusion of Innovations Using Opinion Leaders&quot;,
<em>Annals of the American Academy of Political and Social Science</em> 566: 56-67.
</p>


<h3>See Also</h3>

<p>Other marks: 
<code><a href="#topic+mark_diff">mark_diff</a></code>,
<code><a href="#topic+mark_select">mark_select</a></code>,
<code><a href="#topic+mark_tie_select">mark_tie_select</a></code>,
<code><a href="#topic+mark_ties">mark_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_is_isolate(ison_brandes)
node_is_cutpoint(ison_brandes)
node_is_core(ison_brandes)
node_is_fold(create_explicit(A-B, B-C, A-C, C-D, C-E, D-E))
</code></pre>

<hr>
<h2 id='mark_select'>Marking nodes for selection based on measures</h2><span id='topic+mark_select'></span><span id='topic+node_is_random'></span><span id='topic+node_is_max'></span><span id='topic+node_is_min'></span>

<h3>Description</h3>

<p>These functions return logical vectors the length of the
nodes in a network identifying which hold certain properties or positions in the network.
</p>

<ul>
<li> <p><code>node_is_random()</code> marks one or more nodes at random.
</p>
</li>
<li> <p><code>node_is_max()</code> and <code>node_is_min()</code> are more generally useful
for converting the results from some node measure into a mark-class object.
They can be particularly useful for highlighting which node or nodes
are key because they minimise or, more often, maximise some measure.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_is_random(.data, size = 1)

node_is_max(node_measure, ranks = 1)

node_is_min(node_measure, ranks = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_select_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="mark_select_+3A_size">size</code></td>
<td>
<p>The number of nodes to select (as TRUE).</p>
</td></tr>
<tr><td><code id="mark_select_+3A_node_measure">node_measure</code></td>
<td>
<p>An object created by a <code>node_</code> measure.</p>
</td></tr>
<tr><td><code id="mark_select_+3A_ranks">ranks</code></td>
<td>
<p>The number of ranks of max or min to return.
For example, <code>ranks = 3</code> will return TRUE for nodes with
scores equal to any of the top (or, for <code>node_is_min()</code>, bottom)
three scores.
By default, <code>ranks = 1</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other marks: 
<code><a href="#topic+mark_diff">mark_diff</a></code>,
<code><a href="#topic+mark_nodes">mark_nodes</a></code>,
<code><a href="#topic+mark_tie_select">mark_tie_select</a></code>,
<code><a href="#topic+mark_ties">mark_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_is_random(ison_brandes, 2)
#node_is_max(migraph::node_degree(ison_brandes))
#node_is_min(migraph::node_degree(ison_brandes))
</code></pre>

<hr>
<h2 id='mark_tie_select'>Marking ties for selection based on measures</h2><span id='topic+mark_tie_select'></span><span id='topic+tie_is_random'></span><span id='topic+tie_is_max'></span><span id='topic+tie_is_min'></span>

<h3>Description</h3>

<p>These functions return logical vectors the length of the ties in a network:
</p>

<ul>
<li> <p><code>tie_is_random()</code> marks one or more nodes at random.
</p>
</li>
<li> <p><code>tie_is_max()</code> and <code>tie_is_min()</code> are more generally useful
for converting the results from some node measure into a mark-class object.
They can be particularly useful for highlighting which node or nodes
are key because they minimise or, more often, maximise some measure.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>tie_is_random(.data, size = 1)

tie_is_max(tie_measure)

tie_is_min(tie_measure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_tie_select_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="mark_tie_select_+3A_size">size</code></td>
<td>
<p>The number of nodes to select (as TRUE).</p>
</td></tr>
<tr><td><code id="mark_tie_select_+3A_tie_measure">tie_measure</code></td>
<td>
<p>An object created by a <code>tie_</code> measure.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other marks: 
<code><a href="#topic+mark_diff">mark_diff</a></code>,
<code><a href="#topic+mark_nodes">mark_nodes</a></code>,
<code><a href="#topic+mark_select">mark_select</a></code>,
<code><a href="#topic+mark_ties">mark_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tie_is_max(migraph::tie_betweenness(ison_brandes))
#tie_is_min(migraph::tie_betweenness(ison_brandes))
</code></pre>

<hr>
<h2 id='mark_ties'>Marking ties based on structural properties</h2><span id='topic+mark_ties'></span><span id='topic+tie_is_multiple'></span><span id='topic+tie_is_loop'></span><span id='topic+tie_is_reciprocated'></span><span id='topic+tie_is_feedback'></span><span id='topic+tie_is_bridge'></span>

<h3>Description</h3>

<p>These functions return logical vectors the length of the ties
in a network identifying which hold certain properties or positions in the network.
</p>

<ul>
<li> <p><code>tie_is_multiple()</code> marks ties that are multiples.
</p>
</li>
<li> <p><code>tie_is_loop()</code> marks ties that are loops.
</p>
</li>
<li> <p><code>tie_is_reciprocated()</code> marks ties that are mutual/reciprocated.
</p>
</li>
<li> <p><code>tie_is_feedback()</code> marks ties that are feedback arcs causing the network to not be acyclic.
</p>
</li>
<li> <p><code>tie_is_bridge()</code> marks ties that cut or act as articulation points in a network.
</p>
</li></ul>

<p>They are most useful in highlighting parts of the network that
are particularly well- or poorly-connected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tie_is_multiple(.data)

tie_is_loop(.data)

tie_is_reciprocated(.data)

tie_is_feedback(.data)

tie_is_bridge(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_ties_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other marks: 
<code><a href="#topic+mark_diff">mark_diff</a></code>,
<code><a href="#topic+mark_nodes">mark_nodes</a></code>,
<code><a href="#topic+mark_select">mark_select</a></code>,
<code><a href="#topic+mark_tie_select">mark_tie_select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tie_is_multiple(ison_marvel_relationships)
tie_is_loop(ison_marvel_relationships)
tie_is_reciprocated(ison_algebra)
tie_is_feedback(ison_algebra)
tie_is_bridge(ison_brandes)
</code></pre>

<hr>
<h2 id='miss'>Modifying missing tie data</h2><span id='topic+miss'></span><span id='topic+na_to_zero'></span><span id='topic+na_to_mean'></span>

<h3>Description</h3>

<p>These functions offer tools for imputing missing tie data.
Currently two options are available:
</p>

<ul>
<li> <p><code>na_to_zero()</code> replaces any missing values with zeros,
which are the modal value in sparse social networks.
</p>
</li>
<li> <p><code>na_to_mean()</code> replaces missing values with the average non-missing value.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>na_to_zero(.data)

na_to_mean(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miss_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A data object of the same class as the function was given.
</p>


<h3>References</h3>

<p>Krause, Robert, Mark Huisman, Christian Steglich, and Tom A.B. Snijders. 2020.
&quot;Missing data in cross-sectional networks–An extensive comparison of missing data treatment methods&quot;.
<em>Social Networks</em>, 62, 99-112.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+add_nodes">add_nodes</a>()</code>,
<code><a href="#topic+add_ties">add_ties</a>()</code>,
<code><a href="#topic+as">as</a>()</code>,
<code><a href="#topic+from">from</a></code>,
<code><a href="#topic+reformat">reformat</a></code>,
<code><a href="#topic+split">split</a>()</code>,
<code><a href="#topic+to_levels">to_levels</a></code>,
<code><a href="#topic+to_paths">to_paths</a></code>,
<code><a href="#topic+to_project">to_project</a></code>,
<code><a href="#topic+to_scope">to_scope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>missTest &lt;- ison_adolescents %&gt;% 
   add_tie_attribute("weight", c(1,NA,NA,1,1,1,NA,NA,1,1)) %&gt;% 
   as_matrix
missTest
na_to_zero(missTest)
na_to_mean(missTest)
</code></pre>

<hr>
<h2 id='partition_layouts'>Layout algorithms based on bi- or other partitions</h2><span id='topic+partition_layouts'></span><span id='topic+layout_tbl_graph_hierarchy'></span><span id='topic+layout_tbl_graph_alluvial'></span><span id='topic+layout_tbl_graph_railway'></span><span id='topic+layout_tbl_graph_ladder'></span><span id='topic+layout_tbl_graph_concentric'></span><span id='topic+layout_tbl_graph_multilevel'></span><span id='topic+layout_tbl_graph_lineage'></span>

<h3>Description</h3>

<p>These algorithms layout networks based on two or more partitions,
and are recommended for use with <code>autographr()</code> or <code>{ggraph}</code>.
Note that these layout algorithms use <code>{Rgraphviz}</code>,
a package that is only available on Bioconductor.
It will first need to be downloaded using <code>BiocManager::install("Rgraphviz")</code>.
If it has not already been installed, there is a prompt the first time
these functions are used though.
</p>
<p>The &quot;hierarchy&quot; layout layers the first node set along the bottom,
and the second node set along the top,
sequenced and spaced as necessary to minimise edge overlap.
The &quot;alluvial&quot; layout is similar to &quot;hierarchy&quot;,
but places successive layers horizontally rather than vertically.
The &quot;railway&quot; layout is similar to &quot;hierarchy&quot;,
but nodes are aligned across the layers.
The &quot;ladder&quot; layout is similar to &quot;railway&quot;,
but places successive layers horizontally rather than vertically.
The &quot;concentric&quot; layout places a &quot;hierarchy&quot; layout
around a circle, with successive layers appearing as concentric circles.
The &quot;multilevel&quot; layout places successive layers as multiple levels.
The &quot;lineage&quot; layout ranks nodes in Y axis according to values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_hierarchy(
  .data,
  center = NULL,
  circular = FALSE,
  times = 1000
)

layout_tbl_graph_alluvial(.data, circular = FALSE, times = 1000)

layout_tbl_graph_railway(.data, circular = FALSE, times = 1000)

layout_tbl_graph_ladder(.data, circular = FALSE, times = 1000)

layout_tbl_graph_concentric(
  .data,
  membership,
  radius = NULL,
  order.by = NULL,
  circular = FALSE,
  times = 1000
)

layout_tbl_graph_multilevel(.data, level, circular = FALSE)

layout_tbl_graph_lineage(.data, rank, circular = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_layouts_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="partition_layouts_+3A_center">center</code></td>
<td>
<p>Further split &quot;hierarchical&quot; layouts by
declaring the &quot;center&quot; argument as the &quot;events&quot;, &quot;actors&quot;,
or by declaring a node name in hierarchy layout.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="partition_layouts_+3A_circular">circular</code></td>
<td>
<p>Should the layout be transformed into a radial representation.
Only possible for some layouts. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="partition_layouts_+3A_times">times</code></td>
<td>
<p>Maximum number of iterations, where appropriate</p>
</td></tr>
<tr><td><code id="partition_layouts_+3A_membership">membership</code></td>
<td>
<p>A node attribute or a vector to draw concentric circles
for &quot;concentric&quot; layout.</p>
</td></tr>
<tr><td><code id="partition_layouts_+3A_radius">radius</code></td>
<td>
<p>A vector of radii at which the concentric circles
should be located for &quot;concentric&quot; layout.
By default this is equal placement around an empty centre,
unless one (the core) is a single node,
in which case this node occupies the centre of the graph.</p>
</td></tr>
<tr><td><code id="partition_layouts_+3A_order.by">order.by</code></td>
<td>
<p>An attribute label indicating the (decreasing) order
for the nodes around the circles for &quot;concentric&quot; layout.
By default ordering is given by a bipartite placement that reduces
the number of edge crossings.</p>
</td></tr>
<tr><td><code id="partition_layouts_+3A_level">level</code></td>
<td>
<p>A node attribute or a vector to hierarchically order levels for
&quot;multilevel&quot; layout.</p>
</td></tr>
<tr><td><code id="partition_layouts_+3A_rank">rank</code></td>
<td>
<p>A numerical node attribute to place nodes in Y axis
according to values for &quot;lineage&quot; layout.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Diego Diez, Andrew P. Hutchins and Diego Miranda-Saavedra. 2014.
&quot;Systematic identification of transcriptional regulatory modules from
protein-protein interaction networks&quot;.
<em>Nucleic Acids Research</em>, 42 (1) e6.
</p>


<h3>See Also</h3>

<p>Other mapping: 
<code><a href="#topic+attributes">attributes</a>()</code>,
<code><a href="#topic+autographr">autographr</a>()</code>,
<code><a href="#topic+autographs">autographs</a>()</code>,
<code><a href="#topic+autographt">autographt</a>()</code>,
<code><a href="#topic+configuration_layouts">configuration_layouts</a></code>,
<code><a href="#topic+properties">properties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#autographr(ison_southern_women, layout = "hierarchy", center = "events",
#           node_color = "type", node_size = 3)
#autographr(ison_southern_women, layout = "alluvial")
#autographr(ison_southern_women, layout = "concentric", membership = "type",
#           node_color = "type", node_size = 3)
#autographr(ison_lotr, layout = "multilevel",
#           node_color = "Race", level = "Race", node_size = 3)
# ison_adolescents %&gt;%
#   mutate(year = rep(c(1985, 1990, 1995, 2000), times = 2),
#          cut = node_is_cutpoint(ison_adolescents)) %&gt;%
#   autographr(layout = "lineage", rank = "year", node_color = "cut",
#              node_size = migraph::node_degree(ison_adolescents)*10)
</code></pre>

<hr>
<h2 id='play'>Making diffusion models on networks</h2><span id='topic+play'></span><span id='topic+play_diffusion'></span><span id='topic+play_diffusions'></span>

<h3>Description</h3>

<p>These functions simulate diffusion or compartment models upon a network.
</p>

<ul>
<li> <p><code>play_diffusion()</code> runs a single simulation of a compartment model,
allowing the results to be visualised and examined.
</p>
</li>
<li> <p><code>play_diffusions()</code> runs multiple simulations of a compartment model
for more robust inference.
</p>
</li></ul>

<p>These functions allow both a full range of compartment models,
as well as simplex and complex diffusion to be simulated upon a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>play_diffusion(
  .data,
  seeds = 1,
  thresholds = 1,
  transmissibility = 1,
  latency = 0,
  recovery = 0,
  waning = 0,
  immune = NULL,
  steps
)

play_diffusions(
  .data,
  seeds = 1,
  thresholds = 1,
  transmissibility = 1,
  latency = 0,
  recovery = 0,
  waning = 0,
  immune = NULL,
  steps,
  times = 5,
  strategy = "sequential",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="play_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="play_+3A_seeds">seeds</code></td>
<td>
<p>A valid mark vector the length of the
number of nodes in the network.</p>
</td></tr>
<tr><td><code id="play_+3A_thresholds">thresholds</code></td>
<td>
<p>A numeric vector indicating the thresholds
each node has. By default 1.
A single number means a generic threshold;
for thresholds that vary among the population please use a vector
the length of the number of nodes in the network.
If 1 or larger, the threshold is interpreted as a simple count
of the number of contacts/exposures sufficient for infection.
If less than 1, the threshold is interpreted as complex,
where the threshold concerns the proportion of contacts.</p>
</td></tr>
<tr><td><code id="play_+3A_transmissibility">transmissibility</code></td>
<td>
<p>The transmission rate probability,
<code class="reqn">\beta</code>.
By default 1, which means any node for which the threshold is met
or exceeded will become infected.
Anything lower means a correspondingly lower probability of adoption,
even when the threshold is met or exceeded.</p>
</td></tr>
<tr><td><code id="play_+3A_latency">latency</code></td>
<td>
<p>The inverse probability those who have been exposed
become infectious (infected), <code class="reqn">\sigma</code> or <code class="reqn">\kappa</code>.
For example, if exposed individuals take, on average,
four days to become infectious, then <code class="reqn">\sigma = 0.75</code> (1/1-0.75 = 1/0.25 = 4).
By default 0, which means those exposed become immediately infectious (i.e. an SI model).
Anything higher results in e.g. a SEI model.</p>
</td></tr>
<tr><td><code id="play_+3A_recovery">recovery</code></td>
<td>
<p>The probability those who are infected
recover, <code class="reqn">\gamma</code>.
For example, if infected individuals take, on average,
four days to recover, then <code class="reqn">\gamma = 0.25</code>.
By default 0, which means there is no recovery (i.e. an SI model).
Anything higher results in an SIR model.</p>
</td></tr>
<tr><td><code id="play_+3A_waning">waning</code></td>
<td>
<p>The probability those who are recovered
become susceptible again, <code class="reqn">\xi</code>.
For example, if recovered individuals take, on average,
four days to lose their immunity, then <code class="reqn">\xi = 0.25</code>.
By default 0, which means any recovered individuals retain lifelong immunity (i.e. an SIR model).
Anything higher results in e.g. a SIRS model.
<code class="reqn">\xi = 1</code> would mean there is no period of immunity, e.g. an SIS model.</p>
</td></tr>
<tr><td><code id="play_+3A_immune">immune</code></td>
<td>
<p>A logical or numeric vector identifying nodes
that begin the diffusion process as already recovered.
This could be interpreted as those who are vaccinated or equivalent.
Note however that a waning parameter will affect these nodes too.
By default NULL, indicating that no nodes begin immune.</p>
</td></tr>
<tr><td><code id="play_+3A_steps">steps</code></td>
<td>
<p>The number of steps forward in the diffusion to play.
By default the number of nodes in the network.
If <code>steps = Inf</code> then the diffusion process will continue until
there are no new infections or all nodes are infected.</p>
</td></tr>
<tr><td><code id="play_+3A_times">times</code></td>
<td>
<p>Integer indicating number of simulations.
By default <code>times=5</code>, but 1,000 - 10,000 simulations recommended for publication-ready results.</p>
</td></tr>
<tr><td><code id="play_+3A_strategy">strategy</code></td>
<td>
<p>If <code>{furrr}</code> is installed, then multiple cores can be used to accelerate the simulations.
By default &quot;sequential&quot;, but if multiple cores available, then &quot;multisession&quot; or &quot;multicore&quot; may be useful.
Generally this is useful only when times &gt; 1000. See <code>{furrr}</code> for more.</p>
</td></tr>
<tr><td><code id="play_+3A_verbose">verbose</code></td>
<td>
<p>Whether the function should report on its progress.
By default FALSE. See <code>{progressr}</code> for more.</p>
</td></tr>
</table>


<h3>Simple and complex diffusion</h3>

<p>By default, the function will simulate a simple diffusion process in
which some infectious disease or idea diffuses from seeds through
contacts at some constant rate (<code>transmissibility</code>).
</p>
<p>These <code>seeds</code> can be specified by a vector index
(the number of the position of each node in the network that should serve as a seed)
or as a logical vector where TRUE is interpreted as already infected.
</p>
<p><code>thresholds</code> can be set such that adoption/infection requires more than one
(the default) contact already being infected.
This parameter also accepts a vector so that thresholds can vary.
</p>
<p>Complex diffusion is where the <code>thresholds</code> are defined less than one.
In this case, the thresholds are interpreted as proportional.
That is, the threshold to adoption/infection is defined by the
proportion of the node's contacts infected.
</p>
<p>Nodes that cannot be infected can be indicated as <code>immune</code>
with a logical vector or index, similar to how <code>seeds</code> are identified.
Note that <code>immune</code> nodes are interpreted internally as Recovered (R)
and are thus subject to <code>waning</code> (see below).
</p>


<h3>Compartment models</h3>

<p>Compartment models are flexible models of diffusion or contagion,
where nodes are compartmentalised into one of two or more categories.
</p>
<p>The most basic model is the SI model.
The SI model is the default in <code>play_diffusion()</code>/<code>play_diffusions()</code>,
where nodes can only move from the Susceptible (S) category to the
Infected (I) category.
Whether nodes move from S to I depends on whether they are exposed
to the infection, for instance through a contact,
the <code>transmissibility</code> of the disease,
and their <code>thresholds</code> to the disease.
</p>
<p>Another common model is the SIR model.
Here nodes move from S to I, as above, but additionally they can
move from I to a Recovered (R) status.
The probability that an infected node recovers at a timepoint
is controlled by the <code>recovery</code> parameter.
</p>
<p>The next most common models are the SIS and SIRS models.
Here nodes move from S to I or additionally to R, as above,
but additionally they can move from I or R back to a Susceptible (S) state.
This probability is governed by the <code>waning</code> parameter.
Where <code>recover &gt; 0</code> and <code>waning = 1</code>, the Recovery (R) state will be skipped
and the node will return immediately to the Susceptible (S) compartment.
</p>
<p>Lastly, these functions also offer the possibility of specifying
a latency period in which nodes have been infected but are not yet infectious.
Where <code>latency &gt; 0</code>, an additional Exposed (E) compartment is introduced
that governs the probability that a node moves from this E compartment
to infectiousness (I).
This can be used in in SEI, SEIS, SEIR, and SEIRS models.
</p>


<h3>See Also</h3>

<p>Other makes: 
<code><a href="#topic+create">create</a></code>,
<code><a href="#topic+generate">generate</a></code>,
<code><a href="#topic+learning">learning</a></code>,
<code><a href="#topic+read">read</a></code>,
<code><a href="#topic+write">write</a>()</code>
</p>
<p>Other models: 
<code><a href="#topic+learning">learning</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  smeg &lt;- generate_smallworld(15, 0.025)
  plot(play_diffusion(smeg, recovery = 0.4))
  #autographr(play_diffusion(ison_karateka))
  plot(play_diffusions(smeg, times = 10))
</code></pre>

<hr>
<h2 id='properties'>Describing network properties</h2><span id='topic+properties'></span><span id='topic+network_nodes'></span><span id='topic+network_ties'></span><span id='topic+network_dims'></span><span id='topic+network_node_attributes'></span><span id='topic+network_tie_attributes'></span>

<h3>Description</h3>

<p>These functions extract certain attributes from given network data:
</p>

<ul>
<li> <p><code>network_nodes()</code> returns the total number of nodes (of any mode) in a network.
</p>
</li>
<li> <p><code>network_ties()</code> returns the number of ties in a network.
</p>
</li>
<li> <p><code>network_dims()</code> returns the dimensions of a network in a vector
as long as the number of modes in the network.
</p>
</li>
<li> <p><code>network_node_attributes()</code> returns a vector of nodal attributes in a network.
</p>
</li>
<li> <p><code>network_tie_attributes()</code> returns a vector of tie attributes in a network.
</p>
</li></ul>

<p>These functions are also often used as helpers within other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_nodes(.data)

network_ties(.data)

network_dims(.data)

network_node_attributes(.data)

network_tie_attributes(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="properties_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;network_*()&#8288;</code> functions always relate to the overall graph or network,
usually returning a scalar.
<code>network_dims()</code> returns an integer of the number of nodes in a one-mode network,
or two integers representing the number of nodes in each nodeset
in the case of a two-mode network.
<code style="white-space: pre;">&#8288;network_*_attributes()&#8288;</code> returns a string vector with the names
of all node or tie attributes in the network.
</p>


<h3>See Also</h3>

<p>Other mapping: 
<code><a href="#topic+attributes">attributes</a>()</code>,
<code><a href="#topic+autographr">autographr</a>()</code>,
<code><a href="#topic+autographs">autographs</a>()</code>,
<code><a href="#topic+autographt">autographt</a>()</code>,
<code><a href="#topic+configuration_layouts">configuration_layouts</a></code>,
<code><a href="#topic+partition_layouts">partition_layouts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_nodes(ison_southern_women)
network_ties(ison_southern_women)
network_dims(ison_southern_women)
network_dims(to_mode1(ison_southern_women))
  network_node_attributes(ison_lotr)
  network_tie_attributes(ison_algebra)
</code></pre>

<hr>
<h2 id='read'>Making networks from external files</h2><span id='topic+read'></span><span id='topic+read_matrix'></span><span id='topic+read_edgelist'></span><span id='topic+read_nodelist'></span><span id='topic+read_pajek'></span><span id='topic+read_ucinet'></span><span id='topic+read_dynetml'></span><span id='topic+read_graphml'></span>

<h3>Description</h3>

<p>Researchers regularly need to work with a variety of external data formats.
The following functions offer ways to import from some common external
file formats into objects that <code>{manynet}</code> and other graph/network packages
in R can work with:
</p>

<ul>
<li> <p><code>read_matrix()</code> imports adjacency matrices from Excel/csv files.
</p>
</li>
<li> <p><code>read_edgelist()</code> imports edgelists from Excel/csv files.
</p>
</li>
<li> <p><code>read_nodelist()</code> imports nodelists from Excel/csv files.
</p>
</li>
<li> <p><code>read_pajek()</code> imports Pajek (.net or .paj) files.
</p>
</li>
<li> <p><code>read_ucinet()</code> imports UCINET files from the header (.##h).
</p>
</li>
<li> <p><code>read_dynetml()</code> imports DyNetML interchange format for rich social network data.
</p>
</li>
<li> <p><code>read_graphml()</code> imports GraphML files.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>read_matrix(file = file.choose(), sv = c("comma", "semi-colon"), ...)

read_edgelist(file = file.choose(), sv = c("comma", "semi-colon"), ...)

read_nodelist(file = file.choose(), sv = c("comma", "semi-colon"), ...)

read_pajek(file = file.choose(), ties = NULL, ...)

read_ucinet(file = file.choose())

read_dynetml(file = file.choose())

read_graphml(file = file.choose())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_+3A_file">file</code></td>
<td>
<p>A character string with the system path to the file to import.
If left unspecified, an OS-specific file picker is opened to help users select it.
Note that in <code>read_ucinet()</code> the file path should be to the header file (.##h),
if it exists and that it is currently not possible to import multiple
networks from a single UCINET file. Please convert these one by one.</p>
</td></tr>
<tr><td><code id="read_+3A_sv">sv</code></td>
<td>
<p>Allows users to specify whether their csv file is
<code>"comma"</code> (English) or <code>"semi-colon"</code> (European) separated.</p>
</td></tr>
<tr><td><code id="read_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the read/write function.</p>
</td></tr>
<tr><td><code id="read_+3A_ties">ties</code></td>
<td>
<p>A character string indicating the ties/network,
where the data contains several.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that these functions are not as actively maintained as others
in the package, so please let us know if any are not currently working
for you or if there are missing import routines
by <a href="https://github.com/stocnet/manynet/issues">raising an issue on Github</a>.
</p>
<p>There are a number of repositories for network data
that hold various datasets in different formats. See for example:
</p>

<ul>
<li> <p><a href="https://sites.google.com/site/ucinetsoftware/datasets?authuser=0">UCINET data</a>
</p>
</li>
<li> <p><a href="http://vlado.fmf.uni-lj.si/pub/networks/data/">Pajek data</a>
</p>
</li>
<li> <p><a href="https://schochastics.github.io/networkdata/">networkdata</a>
</p>
</li>
<li> <p><a href="http://www-personal.umich.edu/~mejn/netdata/">GML datasets</a>
</p>
</li>
<li><p> UCIrvine Network Data Repository
</p>
</li>
<li> <p><a href="http://konect.cc/">KONECT project</a>
</p>
</li>
<li> <p><a href="http://snap.stanford.edu/data/">SNAP Stanford Large Network Dataset Collection</a>
</p>
</li></ul>

<p>Please let us know if you identify any further repositories
of social or political networks and we would be happy to add them here.
</p>
<p>The <code style="white-space: pre;">&#8288;_ucinet&#8288;</code> functions only work with relatively recent UCINET
file formats, e.g. type 6406 files.
To import earlier UCINET file types, you will need to update them first.
To import multiple matrices packed into a single UCINET file,
you will need to unpack them and convert them one by one.
</p>


<h3>Value</h3>

<p><code>read_edgelist()</code> and <code>read_nodelist()</code> will import
into edgelist (tibble) format which can then be coerced or combined into
different graph objects from there.
</p>
<p><code>read_pajek()</code> and <code>read_ucinet()</code> will import into
a tidygraph format, since they already contain both edge and attribute data.
<code>read_matrix()</code> will import into tidygraph format too.
Note that all graphs can be easily coerced into other formats
with <code>{manynet}</code>'s <code>as_</code> methods.
</p>


<h3>Source</h3>

<p><code>read_ucinet()</code> kindly supplied by Christian Steglich,
constructed on 18 June 2015.
</p>


<h3>See Also</h3>

<p><a href="#topic+as">as</a>
</p>
<p>Other makes: 
<code><a href="#topic+create">create</a></code>,
<code><a href="#topic+generate">generate</a></code>,
<code><a href="#topic+learning">learning</a></code>,
<code><a href="#topic+play">play</a></code>,
<code><a href="#topic+write">write</a>()</code>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+is_igraph'></span><span id='topic+is.network'></span><span id='topic+as.network'></span><span id='topic++25+3E+25'></span><span id='topic+with_graph'></span><span id='topic+is.tbl_graph'></span><span id='topic+.G'></span><span id='topic+.N'></span><span id='topic+.E'></span><span id='topic+ggplot'></span><span id='topic+ggtitle'></span><span id='topic+guides'></span><span id='topic+labs'></span><span id='topic+xlab'></span><span id='topic+ylab'></span><span id='topic+aes'></span><span id='topic+ggsave'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+aes">aes</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, <code><a href="ggplot2.html#topic+ggsave">ggsave</a></code>, <code><a href="ggplot2.html#topic+labs">ggtitle</a></code>, <code><a href="ggplot2.html#topic+guides">guides</a></code>, <code><a href="ggplot2.html#topic+labs">labs</a></code>, <code><a href="ggplot2.html#topic+labs">xlab</a></code>, <code><a href="ggplot2.html#topic+labs">ylab</a></code></p>
</dd>
<dt>igraph</dt><dd><p><code><a href="igraph.html#topic+is_igraph">is_igraph</a></code></p>
</dd>
<dt>network</dt><dd><p><code><a href="network.html#topic+network">as.network</a></code>, <code><a href="network.html#topic+network">is.network</a></code></p>
</dd>
<dt>tidygraph</dt><dd><p><code><a href="tidygraph.html#topic+context_accessors">.E</a></code>, <code><a href="tidygraph.html#topic+context_accessors">.G</a></code>, <code><a href="tidygraph.html#topic+context_accessors">.N</a></code>, <code><a href="tidygraph.html#topic+tbl_graph">is.tbl_graph</a></code>, <code><a href="tidygraph.html#topic+with_graph">with_graph</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reformat'>Modifying network formats</h2><span id='topic+reformat'></span><span id='topic+to_uniplex'></span><span id='topic+to_undirected'></span><span id='topic+to_directed'></span><span id='topic+to_redirected'></span><span id='topic+to_reciprocated'></span><span id='topic+to_acyclic'></span><span id='topic+to_unweighted'></span><span id='topic+to_unsigned'></span><span id='topic+to_unnamed'></span><span id='topic+to_named'></span><span id='topic+to_simplex'></span><span id='topic+to_anti'></span>

<h3>Description</h3>

<p>These functions reformat manynet-consistent data.
</p>

<ul>
<li> <p><code>to_uniplex()</code> reformats multiplex network data to a single type of tie.
</p>
</li>
<li> <p><code>to_undirected()</code> reformats directed network data to an undirected network.
</p>
</li>
<li> <p><code>to_directed()</code> reformats undirected network data to a directed network.
</p>
</li>
<li> <p><code>to_redirected()</code> reformats the direction of directed network data, flipping any existing direction.
</p>
</li>
<li> <p><code>to_reciprocated()</code> reformats directed network data such that every directed tie is reciprocated.
</p>
</li>
<li> <p><code>to_acyclic()</code> reformats network data to an acyclic graph.
</p>
</li>
<li> <p><code>to_unweighted()</code> reformats weighted network data to unweighted network data.
</p>
</li>
<li> <p><code>to_unsigned()</code> reformats signed network data to unsigned network data.
</p>
</li>
<li> <p><code>to_unnamed()</code> reformats labelled network data to unlabelled network data.
</p>
</li>
<li> <p><code>to_named()</code> reformats unlabelled network data to labelled network data.
</p>
</li>
<li> <p><code>to_simplex()</code> reformats complex network data, containing loops, to simplex network data, without any loops.
</p>
</li>
<li> <p><code>to_anti()</code> reformats network data into its complement, where only ties <em>not</em> present in the original network
are included in the new network.
</p>
</li></ul>

<p>If the format condition is not met,
for example <code>to_undirected()</code> is used on a network that is already undirected,
the network data is returned unaltered.
No warning is given so that these functions can be used to ensure conformance.
</p>
<p>Unlike the <code style="white-space: pre;">&#8288;as_*()&#8288;</code> group of functions,
these functions always return the same class as they are given,
only transforming these objects' properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_uniplex(.data, tie)

to_undirected(.data)

to_directed(.data)

to_redirected(.data)

to_reciprocated(.data)

to_acyclic(.data)

to_unweighted(.data, threshold = 1)

to_unsigned(.data, keep = c("positive", "negative"))

to_unnamed(.data)

to_named(.data, names = NULL)

to_simplex(.data)

to_anti(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reformat_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="reformat_+3A_tie">tie</code></td>
<td>
<p>Character string naming a tie attribute to retain from a graph.</p>
</td></tr>
<tr><td><code id="reformat_+3A_threshold">threshold</code></td>
<td>
<p>For a matrix, the threshold to binarise/dichotomise at.</p>
</td></tr>
<tr><td><code id="reformat_+3A_keep">keep</code></td>
<td>
<p>In the case of a signed network, whether to retain
the &quot;positive&quot; or &quot;negative&quot; ties.</p>
</td></tr>
<tr><td><code id="reformat_+3A_names">names</code></td>
<td>
<p>Character vector of the node names. NULL by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_acyclic </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_directed </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_named </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_reciprocated </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_redirected </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_simplex </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_undirected </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_uniplex </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_unnamed </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_unsigned </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_unweighted </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>All <code>to_</code> functions return an object of the same class as that provided.
So passing it an igraph object will return an igraph object
and passing it a network object will return a network object,
with certain modifications as outlined for each function.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>to_undirected()</code>: Returns an object that has any edge direction removed,
so that any pair of nodes with at least one directed edge will be
connected by an undirected edge in the new network.
This is equivalent to the &quot;collapse&quot; mode in <code>{igraph}</code>.
</p>
</li>
<li> <p><code>to_redirected()</code>: Returns an object that has any edge direction transposed,
or flipped, so that senders become receivers and receivers become senders.
This essentially has no effect on undirected networks or reciprocated ties.
</p>
</li>
<li> <p><code>to_reciprocated()</code>: Returns an object where all ties are reciprocated.
</p>
</li>
<li> <p><code>to_unweighted()</code>: Returns an object that has all edge weights removed.
</p>
</li>
<li> <p><code>to_unsigned()</code>: Returns a network with either just the &quot;positive&quot; ties
or just the &quot;negative&quot; ties
</p>
</li>
<li> <p><code>to_unnamed()</code>: Returns an object with all vertex names removed
</p>
</li>
<li> <p><code>to_named()</code>: Returns an object that has random vertex names added
</p>
</li>
<li> <p><code>to_simplex()</code>: Returns an object that has all loops or self-ties removed
</p>
</li></ul>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+add_nodes">add_nodes</a>()</code>,
<code><a href="#topic+add_ties">add_ties</a>()</code>,
<code><a href="#topic+as">as</a>()</code>,
<code><a href="#topic+from">from</a></code>,
<code><a href="#topic+miss">miss</a></code>,
<code><a href="#topic+split">split</a>()</code>,
<code><a href="#topic+to_levels">to_levels</a></code>,
<code><a href="#topic+to_paths">to_paths</a></code>,
<code><a href="#topic+to_project">to_project</a></code>,
<code><a href="#topic+to_scope">to_scope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_tidygraph(create_filled(5)) %&gt;%
  mutate_ties(type = sample(c("friend", "enemy"), 10, replace = TRUE)) %&gt;%
  to_uniplex("friend")
to_anti(ison_southern_women)
#autographr(to_anti(ison_southern_women))
</code></pre>

<hr>
<h2 id='scales'>Many scales</h2><span id='topic+scales'></span><span id='topic+scale_fill_iheid'></span><span id='topic+scale_colour_iheid'></span><span id='topic+scale_color_iheid'></span><span id='topic+scale_edge_colour_iheid'></span><span id='topic+scale_edge_color_iheid'></span><span id='topic+scale_fill_centres'></span><span id='topic+scale_colour_centres'></span><span id='topic+scale_color_centres'></span><span id='topic+scale_edge_colour_centres'></span><span id='topic+scale_edge_color_centres'></span><span id='topic+scale_fill_sdgs'></span><span id='topic+scale_colour_sdgs'></span><span id='topic+scale_color_sdgs'></span><span id='topic+scale_edge_colour_sdgs'></span><span id='topic+scale_edge_color_sdgs'></span><span id='topic+scale_fill_ethz'></span><span id='topic+scale_colour_ethz'></span><span id='topic+scale_color_ethz'></span><span id='topic+scale_edge_colour_ethz'></span><span id='topic+scale_edge_color_ethz'></span><span id='topic+scale_fill_uzh'></span><span id='topic+scale_colour_uzh'></span><span id='topic+scale_color_uzh'></span><span id='topic+scale_edge_colour_uzh'></span><span id='topic+scale_edge_color_uzh'></span><span id='topic+scale_fill_rug'></span><span id='topic+scale_colour_rug'></span><span id='topic+scale_color_rug'></span><span id='topic+scale_edge_colour_rug'></span><span id='topic+scale_edge_color_rug'></span>

<h3>Description</h3>

<p>These functions enable to add color scales to be graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_iheid(direction = 1, ...)

scale_colour_iheid(direction = 1, ...)

scale_color_iheid(direction = 1, ...)

scale_edge_colour_iheid(direction = 1, ...)

scale_edge_color_iheid(direction = 1, ...)

scale_fill_centres(direction = 1, ...)

scale_colour_centres(direction = 1, ...)

scale_color_centres(direction = 1, ...)

scale_edge_colour_centres(direction = 1, ...)

scale_edge_color_centres(direction = 1, ...)

scale_fill_sdgs(direction = 1, ...)

scale_colour_sdgs(direction = 1, ...)

scale_color_sdgs(direction = 1, ...)

scale_edge_colour_sdgs(direction = 1, ...)

scale_edge_color_sdgs(direction = 1, ...)

scale_fill_ethz(direction = 1, ...)

scale_colour_ethz(direction = 1, ...)

scale_color_ethz(direction = 1, ...)

scale_edge_colour_ethz(direction = 1, ...)

scale_edge_color_ethz(direction = 1, ...)

scale_fill_uzh(direction = 1, ...)

scale_colour_uzh(direction = 1, ...)

scale_color_uzh(direction = 1, ...)

scale_edge_colour_uzh(direction = 1, ...)

scale_edge_color_uzh(direction = 1, ...)

scale_fill_rug(direction = 1, ...)

scale_colour_rug(direction = 1, ...)

scale_color_rug(direction = 1, ...)

scale_edge_colour_rug(direction = 1, ...)

scale_edge_color_rug(direction = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scales_+3A_direction">direction</code></td>
<td>
<p>Direction for using palette colors.</p>
</td></tr>
<tr><td><code id="scales_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>ggplot2::discrete_scale()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#ison_brandes %&gt;%
#mutate(core = migraph::node_is_core(ison_brandes)) %&gt;%
#autographr(node_color = "core") +
#scale_color_iheid()
#autographr(ison_physicians[[1]], edge_color = "type") +
#scale_edge_color_ethz()
</code></pre>

<hr>
<h2 id='split'>Splitting networks into lists</h2><span id='topic+split'></span><span id='topic+to_egos'></span><span id='topic+to_subgraphs'></span><span id='topic+to_components'></span><span id='topic+to_waves'></span><span id='topic+to_slices'></span>

<h3>Description</h3>

<p>These functions offer tools for splitting manynet-consistent objects
(matrices, igraph, tidygraph, or network objects) into lists of networks.
</p>
<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> diff_model </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_components </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_egos </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_slices </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_subgraphs </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_waves </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>to_egos(.data, max_dist = 1, min_dist = 0)

to_subgraphs(.data, attribute)

to_components(.data)

to_waves(.data, attribute = "wave", panels = NULL, cumulative = FALSE)

to_slices(.data, attribute = "time", slice = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="split_+3A_max_dist">max_dist</code></td>
<td>
<p>The maximum breadth of the neighbourhood.
By default 1.</p>
</td></tr>
<tr><td><code id="split_+3A_min_dist">min_dist</code></td>
<td>
<p>The minimum breadth of the neighbourhood.
By default 0.
Increasing this to 1 excludes the ego,
and 2 excludes ego's direct alters.</p>
</td></tr>
<tr><td><code id="split_+3A_attribute">attribute</code></td>
<td>
<p>One or two attributes used to slice data.</p>
</td></tr>
<tr><td><code id="split_+3A_panels">panels</code></td>
<td>
<p>Would you like to select certain waves?
NULL by default.
That is, a list of networks for every available wave is returned.
Users can also list specific waves they want to select.</p>
</td></tr>
<tr><td><code id="split_+3A_cumulative">cumulative</code></td>
<td>
<p>Whether to make wave ties cumulative.
FALSE by default. That is, each wave is treated isolated.</p>
</td></tr>
<tr><td><code id="split_+3A_slice">slice</code></td>
<td>
<p>Character string or character list indicating the date(s)
or integer(s) range used to slice data (e.g slice = c(1:2, 3:4)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned object will be a list of network objects.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>to_egos()</code>: Returns a list of ego (or focal)
networks.
</p>
</li>
<li> <p><code>to_subgraphs()</code>: Returns a list of subgraphs
on some given node attribute.
</p>
</li>
<li> <p><code>to_components()</code>: Returns a list of the components
in a network.
</p>
</li>
<li> <p><code>to_waves()</code>: Returns a network
with some discrete observations over time
into a list of those observations.
</p>
</li>
<li> <p><code>to_slices()</code>: Returns a list of a network
with some continuous time variable at some time slice(s).
</p>
</li></ul>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+add_nodes">add_nodes</a>()</code>,
<code><a href="#topic+add_ties">add_ties</a>()</code>,
<code><a href="#topic+as">as</a>()</code>,
<code><a href="#topic+from">from</a></code>,
<code><a href="#topic+miss">miss</a></code>,
<code><a href="#topic+reformat">reformat</a></code>,
<code><a href="#topic+to_levels">to_levels</a></code>,
<code><a href="#topic+to_paths">to_paths</a></code>,
<code><a href="#topic+to_project">to_project</a></code>,
<code><a href="#topic+to_scope">to_scope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  to_egos(ison_adolescents)
  #autographs(to_egos(ison_adolescents,2))
ison_adolescents %&gt;%
  mutate(unicorn = sample(c("yes", "no"), 8,
                          replace = TRUE)) %&gt;%
  to_subgraphs(attribute = "unicorn")
  to_components(ison_marvel_relationships)
ison_adolescents %&gt;%
  mutate_ties(wave = sample(1995:1998, 10, replace = TRUE)) %&gt;%
  to_waves(attribute = "wave")
ison_adolescents %&gt;%
  mutate_ties(time = 1:10, increment = 1) %&gt;% 
  add_ties(c(1,2), list(time = 3, increment = -1)) %&gt;% 
  to_slices(slice = 7)
</code></pre>

<hr>
<h2 id='themes'>Many themes</h2><span id='topic+themes'></span><span id='topic+theme_iheid'></span><span id='topic+theme_ethz'></span><span id='topic+theme_uzh'></span><span id='topic+theme_rug'></span>

<h3>Description</h3>

<p>These functions enable graphs to be easily and quickly themed,
e.g. changing the default colour of the graph's vertices and edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_iheid(base_size = 12, base_family = "serif")

theme_ethz(base_size = 12, base_family = "sans")

theme_uzh(base_size = 12, base_family = "sans")

theme_rug(base_size = 12, base_family = "mono")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="themes_+3A_base_size">base_size</code></td>
<td>
<p>Font size, by default 12.</p>
</td></tr>
<tr><td><code id="themes_+3A_base_family">base_family</code></td>
<td>
<p>Font family, by default &quot;sans&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>to_mentoring(ison_brandes) %&gt;%
  mutate(color = c(rep(c(1,2,3), 3), 3)) %&gt;%
  autographr(node_color = "color") +
  labs(title = "Who leads and who follows?") +
  scale_color_iheid() +
  theme_iheid()
</code></pre>

<hr>
<h2 id='to_levels'>Modifying network levels</h2><span id='topic+to_levels'></span><span id='topic+to_onemode'></span><span id='topic+to_twomode'></span><span id='topic+to_multilevel'></span>

<h3>Description</h3>

<p>These functions reformat the levels in manynet-consistent network data.
</p>

<ul>
<li> <p><code>to_onemode()</code> reformats two-mode network data into one-mode network data by simply removing the nodeset 'type' information.
Note that this is not the same as <code>to_mode1()</code> or <code>to_mode2()</code>.
</p>
</li>
<li> <p><code>to_twomode()</code> reformats one-mode network data into two-mode network data, using a mark to distinguish the two sets of nodes.
</p>
</li>
<li> <p><code>to_multilevel()</code> reformats two-mode network data into multimodal network data, which allows for more levels and ties within modes.
</p>
</li></ul>

<p>If the format condition is not met,
for example <code>to_onemode()</code> is used on a network that is already one-mode,
the network data is returned unaltered.
No warning is given so that these functions can be used to ensure conformance.
</p>
<p>Unlike the <code style="white-space: pre;">&#8288;as_*()&#8288;</code> group of functions,
these functions always return the same class as they are given,
only transforming these objects' properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_onemode(.data)

to_twomode(.data, mark)

to_multilevel(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_levels_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="to_levels_+3A_mark">mark</code></td>
<td>
<p>A logical vector marking two types or modes.
By default &quot;type&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_multilevel </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_onemode </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_twomode </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>All <code>to_</code> functions return an object of the same class as that provided.
So passing it an igraph object will return an igraph object
and passing it a network object will return a network object,
with certain modifications as outlined for each function.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+add_nodes">add_nodes</a>()</code>,
<code><a href="#topic+add_ties">add_ties</a>()</code>,
<code><a href="#topic+as">as</a>()</code>,
<code><a href="#topic+from">from</a></code>,
<code><a href="#topic+miss">miss</a></code>,
<code><a href="#topic+reformat">reformat</a></code>,
<code><a href="#topic+split">split</a>()</code>,
<code><a href="#topic+to_paths">to_paths</a></code>,
<code><a href="#topic+to_project">to_project</a></code>,
<code><a href="#topic+to_scope">to_scope</a></code>
</p>

<hr>
<h2 id='to_paths'>Modifying networks paths</h2><span id='topic+to_paths'></span><span id='topic+to_matching'></span><span id='topic+to_mentoring'></span><span id='topic+to_eulerian'></span><span id='topic+to_tree'></span>

<h3>Description</h3>

<p>These functions return tidygraphs containing only special sets of ties:
</p>

<ul>
<li> <p><code>to_matching()</code> returns only the matching ties in some network data.
</p>
</li>
<li> <p><code>to_mentoring()</code> returns only ties to nodes' closest mentors.
</p>
</li>
<li> <p><code>to_eulerian()</code> returns only the Eulerian path within some network data.
</p>
</li>
<li> <p><code>to_tree()</code> returns the spanning tree in some network data or,
if the data is unconnected, a forest of spanning trees.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>to_matching(.data, mark = "type")

to_mentoring(.data, elites = 0.1)

to_eulerian(.data)

to_tree(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_paths_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="to_paths_+3A_mark">mark</code></td>
<td>
<p>A logical vector marking two types or modes.
By default &quot;type&quot;.</p>
</td></tr>
<tr><td><code id="to_paths_+3A_elites">elites</code></td>
<td>
<p>The proportion of nodes to be selected as mentors.
By default this is set at 0.1.
This means that the top 10% of nodes in terms of degree,
or those equal to the highest rank degree in the network,
whichever is the higher, will be used to select the mentors.
</p>
<p>Note that if nodes are equidistant from two mentors,
they will choose one at random.
If a node is without a path to a mentor,
for example because they are an isolate,
a tie to themselves (a loop) will be created instead.
Note that this is a different default behaviour than that
described in Valente and Davis (1999).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_eulerian </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_matching </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_mentoring </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>All <code>to_</code> functions return an object of the same class as that provided.
So passing it an igraph object will return an igraph object
and passing it a network object will return a network object,
with certain modifications as outlined for each function.
</p>


<h3><code>to_matching()</code></h3>

<p><code>to_matching()</code> uses <code>{igraph}</code>'s <code>max_bipartite_match()</code>
to return a network in which each node is only tied to
one of its previous ties.
The number of these ties left is its <em>cardinality</em>,
and the algorithm seeks to maximise this such that,
where possible, each node will be associated with just one
node in the other mode or some other mark.
The algorithm used is the push-relabel algorithm
with greedy initialization and a global relabelling
after every <code class="reqn">\frac{n}{2}</code> steps,
where <code class="reqn">n</code> is the number of nodes in the network.
</p>


<h3>References</h3>

<p>Goldberg, A V; Tarjan, R E (1986).
&quot;A new approach to the maximum flow problem&quot;.
<em>Proceedings of the eighteenth annual ACM symposium on Theory of computing – STOC '86</em>. p. 136.
<a href="https://doi.org/10.1145/12130.12144">doi:10.1145/12130.12144</a>
</p>
<p>Valente, Thomas, and Rebecca Davis. 1999.
&quot;Accelerating the Diffusion of Innovations Using Opinion Leaders&quot;,
<em>Annals of the American Academy of Political and Social Science</em> 566: 56-67.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+add_nodes">add_nodes</a>()</code>,
<code><a href="#topic+add_ties">add_ties</a>()</code>,
<code><a href="#topic+as">as</a>()</code>,
<code><a href="#topic+from">from</a></code>,
<code><a href="#topic+miss">miss</a></code>,
<code><a href="#topic+reformat">reformat</a></code>,
<code><a href="#topic+split">split</a>()</code>,
<code><a href="#topic+to_levels">to_levels</a></code>,
<code><a href="#topic+to_project">to_project</a></code>,
<code><a href="#topic+to_scope">to_scope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to_matching(ison_southern_women)
#autographr(to_matching(ison_southern_women))
autographr(to_mentoring(ison_adolescents))
  to_eulerian(delete_nodes(ison_koenigsberg, "Lomse"))
  #autographr(to_eulerian(delete_nodes(ison_koenigsberg, "Lomse")))
</code></pre>

<hr>
<h2 id='to_project'>Modifying networks projection</h2><span id='topic+to_project'></span><span id='topic+to_mode1'></span><span id='topic+to_mode2'></span><span id='topic+to_ties'></span><span id='topic+to_galois'></span>

<h3>Description</h3>

<p>These functions offer tools for projecting manynet-consistent data:
</p>

<ul>
<li> <p><code>to_mode1()</code> projects a two-mode network to a one-mode network
of the first node set's (e.g. rows) joint affiliations to nodes in the second node set (columns).
</p>
</li>
<li> <p><code>to_mode2()</code> projects a two-mode network to a one-mode network
of the second node set's (e.g. columns) joint affiliations to nodes in the first node set (rows).
</p>
</li>
<li> <p><code>to_ties()</code> projects a network to one where the ties become nodes and incident nodes become their ties.
</p>
</li>
<li> <p><code>to_galois()</code> projects a network to its Galois derivation.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>to_mode1(.data, similarity = c("count", "jaccard", "rand", "pearson", "yule"))

to_mode2(.data, similarity = c("count", "jaccard", "rand", "pearson", "yule"))

to_ties(.data)

to_galois(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_project_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="to_project_+3A_similarity">similarity</code></td>
<td>
<p>Method for establishing ties,
currently &quot;count&quot; (default), &quot;jaccard&quot;, or &quot;rand&quot;.
&quot;count&quot; calculates the number of coinciding ties,
and can be interpreted as indicating the degree of opportunities
between nodes.
&quot;jaccard&quot; uses this count as the numerator in a proportion,
where the denominator consists of any cell where either node has a tie.
It can be interpreted as opportunity weighted by participation.
&quot;rand&quot;, or the Simple Matching Coefficient,
is a proportion where the numerator consists of the count of cells where
both nodes are present or both are absent,
over all possible cells.
It can be interpreted as the (weighted) degree of behavioral mirroring
between two nodes.
&quot;pearson&quot; (Pearson's coefficient) and &quot;yule&quot; (Yule's Q)
produce correlations for valued and binary data, respectively.
Note that Yule's Q has a straightforward interpretation related to the odds ratio.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_mode1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_mode2 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_ties </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>All <code>to_</code> functions return an object of the same class as that provided.
So passing it an igraph object will return an igraph object
and passing it a network object will return a network object,
with certain modifications as outlined for each function.
</p>


<h3>Galois lattices</h3>

<p>Note that the output from <code>to_galois()</code> is very busy at the moment.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+add_nodes">add_nodes</a>()</code>,
<code><a href="#topic+add_ties">add_ties</a>()</code>,
<code><a href="#topic+as">as</a>()</code>,
<code><a href="#topic+from">from</a></code>,
<code><a href="#topic+miss">miss</a></code>,
<code><a href="#topic+reformat">reformat</a></code>,
<code><a href="#topic+split">split</a>()</code>,
<code><a href="#topic+to_levels">to_levels</a></code>,
<code><a href="#topic+to_paths">to_paths</a></code>,
<code><a href="#topic+to_scope">to_scope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to_mode1(ison_southern_women)
to_mode2(ison_southern_women)
#autographr(to_mode1(ison_southern_women))
#autographr(to_mode2(ison_southern_women))
to_ties(ison_adolescents)
#autographr(to_ties(ison_adolescents))
</code></pre>

<hr>
<h2 id='to_scope'>Modifying networks scope</h2><span id='topic+to_scope'></span><span id='topic+to_giant'></span><span id='topic+to_no_isolates'></span><span id='topic+to_subgraph'></span><span id='topic+to_blocks'></span>

<h3>Description</h3>

<p>These functions offer tools for transforming manynet-consistent objects
(matrices, igraph, tidygraph, or network objects).
Transforming means that the returned object may have different dimensions
than the original object.
</p>

<ul>
<li> <p><code>to_giant()</code> scopes a network into one including only the main component and no smaller components or isolates.
</p>
</li>
<li> <p><code>to_no_isolates()</code> scopes a network into one excluding all nodes without ties
</p>
</li>
<li> <p><code>to_subgraph()</code> scopes a network into a subgraph by filtering on some node-related logical statement.
</p>
</li>
<li> <p><code>to_blocks()</code> reduces a network to ties between a given partition membership vector.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>to_giant(.data)

to_no_isolates(.data)

to_subgraph(.data, ...)

to_blocks(.data, membership, FUN = mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_scope_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="to_scope_+3A_...">...</code></td>
<td>
<p>Arguments passed on to dplyr::filter</p>
</td></tr>
<tr><td><code id="to_scope_+3A_membership">membership</code></td>
<td>
<p>A vector of partition memberships.</p>
</td></tr>
<tr><td><code id="to_scope_+3A_fun">FUN</code></td>
<td>
<p>A function for summarising block content.
By default <code>mean</code>.
Other recommended options include <code>median</code>, <code>sum</code>,
<code>min</code> or <code>max</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> list </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_blocks </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_giant </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_no_isolates </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_subgraph </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>All <code>to_</code> functions return an object of the same class as that provided.
So passing it an igraph object will return an igraph object
and passing it a network object will return a network object,
with certain modifications as outlined for each function.
</p>


<h3><code>to_blocks()</code></h3>

<p>Reduced graphs provide summary representations of network structures
by collapsing groups of connected nodes into single nodes
while preserving the topology of the original structures.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+add_nodes">add_nodes</a>()</code>,
<code><a href="#topic+add_ties">add_ties</a>()</code>,
<code><a href="#topic+as">as</a>()</code>,
<code><a href="#topic+from">from</a></code>,
<code><a href="#topic+miss">miss</a></code>,
<code><a href="#topic+reformat">reformat</a></code>,
<code><a href="#topic+split">split</a>()</code>,
<code><a href="#topic+to_levels">to_levels</a></code>,
<code><a href="#topic+to_paths">to_paths</a></code>,
<code><a href="#topic+to_project">to_project</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ison_adolescents %&gt;%
  mutate_ties(wave = sample(1995:1998, 10, replace = TRUE)) %&gt;%
  to_waves(attribute = "wave") %&gt;%
  to_no_isolates()
</code></pre>

<hr>
<h2 id='tutorials'>Open and extract code from tutorials</h2><span id='topic+tutorials'></span><span id='topic+run_tute'></span><span id='topic+extract_tute'></span><span id='topic+pkg_data'></span>

<h3>Description</h3>

<p>These functions make it easy to use the tutorials
in the <code>{manynet}</code> and <code>{migraph}</code> packages:
</p>

<ul>
<li> <p><code>run_tute()</code> runs a <code>{learnr}</code> tutorial from
either the <code>{manynet}</code> or <code>{migraph}</code> packages,
wraps <code>learnr::run_tutorial()</code> with some convenience.
</p>
</li>
<li> <p><code>extract_tute()</code> extracts and opens just the solution code
from a <code>{manynet}</code> or <code>{migraph}</code> tutorial,
saving the .R script to the current working directory.
</p>
</li>
<li> <p><code>pkg_data()</code> returns a tibble with details of the
network datasets included in the packages.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>run_tute(tute)

extract_tute(tute)

pkg_data(pkg = "manynet")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tutorials_+3A_tute">tute</code></td>
<td>
<p>String, name of the tutorial (e.g. &quot;tutorial2&quot;).</p>
</td></tr>
<tr><td><code id="tutorials_+3A_pkg">pkg</code></td>
<td>
<p>String, name of the package.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#run_tute("tutorial2")
#extract_tute("tutorial2")
#pkg_data()
# to obtain overview of unique datasets:
 #pkg_data() %&gt;% 
  #dplyr::distinct(directed, weighted, twomode, signed, 
   #               .keep_all = TRUE)
</code></pre>

<hr>
<h2 id='write'>Making networks to external files</h2><span id='topic+write'></span><span id='topic+write_matrix'></span><span id='topic+write_edgelist'></span><span id='topic+write_nodelist'></span><span id='topic+write_pajek'></span><span id='topic+write_ucinet'></span><span id='topic+write_graphml'></span>

<h3>Description</h3>

<p>Researchers may want to save or work with networks outside R.
The following functions offer ways to export to some common external
file formats:
</p>

<ul>
<li> <p><code>write_matrix()</code> exports an adjacency matrix to a .csv file.
</p>
</li>
<li> <p><code>write_edgelist()</code> exports an edgelist to a .csv file.
</p>
</li>
<li> <p><code>write_nodelist()</code> exports a nodelist to a .csv file.
</p>
</li>
<li> <p><code>write_pajek()</code> exports Pajek .net files.
</p>
</li>
<li> <p><code>write_ucinet()</code> exports a pair of UCINET files in V6404 file format (.##h, .##d).
</p>
</li>
<li> <p><code>write_graphml()</code> exports GraphML files.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>write_matrix(.data, filename, ...)

write_edgelist(.data, filename, ...)

write_nodelist(.data, filename, ...)

write_pajek(.data, filename, ...)

write_ucinet(.data, filename, name)

write_graphml(.data, filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="write_+3A_filename">filename</code></td>
<td>
<p>Character string filename.
If missing, the files will have the same name as the object
and be saved to the working directory.
An appropriate extension will be added if not included.</p>
</td></tr>
<tr><td><code id="write_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the write function.</p>
</td></tr>
<tr><td><code id="write_+3A_name">name</code></td>
<td>
<p>Character string to name the network internally, e.g. in UCINET.
By default the name will be the same as the object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that these functions are not as actively maintained as others
in the package, so please let us know if any are not currently working
for you or if there are missing import routines
by <a href="https://github.com/stocnet/manynet/issues">raising an issue on Github</a>.
</p>


<h3>Value</h3>

<p>The <code>write_</code>functions export to different file formats,
depending on the function.
</p>
<p>A pair of UCINET files in V6404 file format (.##h, .##d)
</p>


<h3>Source</h3>

<p><code>write_ucinet()</code> kindly supplied by Christian Steglich,
constructed on 18 June 2015.
</p>


<h3>See Also</h3>

<p><a href="#topic+as">as</a>
</p>
<p>Other makes: 
<code><a href="#topic+create">create</a></code>,
<code><a href="#topic+generate">generate</a></code>,
<code><a href="#topic+learning">learning</a></code>,
<code><a href="#topic+play">play</a></code>,
<code><a href="#topic+read">read</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
