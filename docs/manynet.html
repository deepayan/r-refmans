<!DOCTYPE html><html lang="en-GB"><head><title>Help for package manynet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {manynet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#data_overview'><p>Obtain overview of available network data</p></a></li>
<li><a href='#defunct'><p>Functions that have been renamed, superseded, or are no longer working</p></a></li>
<li><a href='#depth_first_recursive_search'><p>Layouts for snapping layouts to a grid</p></a></li>
<li><a href='#fict_friends'><p>One-mode undirected Friends character scene co-appearances (McNulty, 2020)</p></a></li>
<li><a href='#fict_greys'><p>One-mode undirected network of characters hook-ups on Grey's Anatomy TV show</p></a></li>
<li><a href='#fict_lotr'><p>One-mode network of Lord of the Rings character interactions</p></a></li>
<li><a href='#fict_potter'><p>Six complex one-mode support data in Harry Potter books (Bossaert and Meidert 2013)</p></a></li>
<li><a href='#fict_thrones'><p>One-mode Game of Thrones kinship (Glander 2017)</p></a></li>
<li><a href='#glossary'><p>Adding network glossary items</p></a></li>
<li><a href='#irps_blogs'><p>One-mode directed network of links between US political blogs (Adamic and Glance 2005)</p></a></li>
<li><a href='#irps_books'><p>One-mode undirected network of co-purchased books about US politics on Amazon</p></a></li>
<li><a href='#irps_usgeo'><p>One-mode undirected network of US state contiguity (Meghanathan 2017)</p></a></li>
<li><a href='#irps_wwi'><p>One-mode signed network of relationships between European major powers (Antal et al. 2006)</p></a></li>
<li><a href='#ison_adolescents'><p>One-mode subset of the adolescent society network (Coleman 1961)</p></a></li>
<li><a href='#ison_algebra'><p>Multiplex graph object of friends, social, and task ties (McFarland 2001)</p></a></li>
<li><a href='#ison_brandes'><p>One-mode and two-mode centrality demonstration networks</p></a></li>
<li><a href='#ison_dolphins'><p>One-mode, undirected network of frequent associations in a dolphin pod (Lusseau et al. 2003)</p></a></li>
<li><a href='#ison_hightech'><p>One-mode multiplex, directed network of managers of a high-tech company (Krackhardt 1987)</p></a></li>
<li><a href='#ison_karateka'><p>One-mode karateka network (Zachary 1977)</p></a></li>
<li><a href='#ison_koenigsberg'><p>One-mode Seven Bridges of Koenigsberg network (Euler 1741)</p></a></li>
<li><a href='#ison_laterals'><p>Two-mode projection examples (Hollway 2021)</p></a></li>
<li><a href='#ison_lawfirm'><p>One-mode lawfirm (Lazega 2001)</p></a></li>
<li><a href='#ison_marvel'><p>Multilevel two-mode affiliation, signed one-mode networks of Marvel comic</p>
book characters (Yuksel 2017)</a></li>
<li><a href='#ison_monks'><p>Multiplex network of three one-mode signed, weighted networks and a three-wave longitudinal network of monks (Sampson 1969)</p></a></li>
<li><a href='#ison_networkers'><p>One-mode EIES dataset (Freeman and Freeman 1979)</p></a></li>
<li><a href='#ison_physicians'><p>Four multiplex one-mode physician diffusion data (Coleman, Katz, and Menzel, 1966)</p></a></li>
<li><a href='#ison_southern_women'><p>Two-mode southern women (Davis, Gardner and Gardner 1941)</p></a></li>
<li><a href='#ison_starwars'><p>Seven one-mode Star Wars character interactions (Gabasova 2016)</p></a></li>
<li><a href='#make_cran'><p>Making networks of package dependencies</p></a></li>
<li><a href='#make_create'><p>Making networks with defined structures</p></a></li>
<li><a href='#make_ego'><p>Making ego networks through interviewing</p></a></li>
<li><a href='#make_explicit'><p>Making networks with explicit ties</p></a></li>
<li><a href='#make_learning'><p>Making learning models on networks</p></a></li>
<li><a href='#make_motifs'><p>Making motifs</p></a></li>
<li><a href='#make_play'><p>Making diffusion models on networks</p></a></li>
<li><a href='#make_random'><p>Making unconditional and conditional random networks</p></a></li>
<li><a href='#make_read'><p>Making networks from external files</p></a></li>
<li><a href='#make_stochastic'><p>Making networks with a stochastic element</p></a></li>
<li><a href='#make_write'><p>Making networks to external files</p></a></li>
<li><a href='#manip_as'><p>Modifying network classes</p></a></li>
<li><a href='#manip_correlation'><p>Node correlation</p></a></li>
<li><a href='#manip_deformat'><p>Modifying network formats</p></a></li>
<li><a href='#manip_from'><p>Joining lists of networks, graphs, and matrices</p></a></li>
<li><a href='#manip_levels'><p>Modifying network levels</p></a></li>
<li><a href='#manip_miss'><p>Modifying missing tie data</p></a></li>
<li><a href='#manip_net'><p>Modifying network data</p></a></li>
<li><a href='#manip_nodes'><p>Modifying node data</p></a></li>
<li><a href='#manip_paths'><p>Modifying networks paths</p></a></li>
<li><a href='#manip_permutation'><p>Network permutation</p></a></li>
<li><a href='#manip_preformat'><p>Modifying network formats</p></a></li>
<li><a href='#manip_project'><p>Modifying networks projection</p></a></li>
<li><a href='#manip_reformat'><p>Modifying network formats</p></a></li>
<li><a href='#manip_scope'><p>Modifying networks scope</p></a></li>
<li><a href='#manip_split'><p>Splitting networks into lists</p></a></li>
<li><a href='#manip_ties'><p>Modifying tie data</p></a></li>
<li><a href='#map_graphr'><p>Easily graph networks with sensible defaults</p></a></li>
<li><a href='#map_graphs'><p>Easily graph a set of networks with sensible defaults</p></a></li>
<li><a href='#map_grapht'><p>Easily animate dynamic networks with sensible defaults</p></a></li>
<li><a href='#map_layout_configuration'><p>Layout algorithms based on configurational positions</p></a></li>
<li><a href='#map_layout_partition'><p>Layout algorithms based on bi- or other partitions</p></a></li>
<li><a href='#map_palettes'><p>Many palettes generator</p></a></li>
<li><a href='#map_scales'><p>Many scales</p></a></li>
<li><a href='#map_themes'><p>Many themes</p></a></li>
<li><a href='#mark_core'><p>Core-periphery clustering algorithms</p></a></li>
<li><a href='#mark_diff'><p>Marking nodes based on diffusion properties</p></a></li>
<li><a href='#mark_features'><p>Marking networks features</p></a></li>
<li><a href='#mark_format'><p>Marking networks formats</p></a></li>
<li><a href='#mark_is'><p>Marking networks classes</p></a></li>
<li><a href='#mark_nodes'><p>Marking nodes based on structural properties</p></a></li>
<li><a href='#mark_select'><p>Marking nodes for selection based on measures</p></a></li>
<li><a href='#mark_tie_select'><p>Marking ties for selection based on measures</p></a></li>
<li><a href='#mark_ties'><p>Marking ties based on structural properties</p></a></li>
<li><a href='#mark_triangles'><p>Marking ties based on structural properties</p></a></li>
<li><a href='#measure_attributes'><p>Describing attributes of nodes or ties in a network</p></a></li>
<li><a href='#measure_central_between'><p>Measures of betweenness-like centrality and centralisation</p></a></li>
<li><a href='#measure_central_close'><p>Measures of closeness-like centrality and centralisation</p></a></li>
<li><a href='#measure_central_degree'><p>Measures of degree-like centrality and centralisation</p></a></li>
<li><a href='#measure_central_eigen'><p>Measures of eigenvector-like centrality and centralisation</p></a></li>
<li><a href='#measure_closure'><p>Measures of network closure</p></a></li>
<li><a href='#measure_cohesion'><p>Measures of network cohesion or connectedness</p></a></li>
<li><a href='#measure_diffusion_infection'><p>Measures of network infection</p></a></li>
<li><a href='#measure_diffusion_net'><p>Measures of network diffusion</p></a></li>
<li><a href='#measure_diffusion_node'><p>Measures of nodes in a diffusion</p></a></li>
<li><a href='#measure_features'><p>Measures of network topological features</p></a></li>
<li><a href='#measure_heterogeneity'><p>Measures of network diversity</p></a></li>
<li><a href='#measure_hierarchy'><p>Graph theoretic dimensions of hierarchy</p></a></li>
<li><a href='#measure_holes'><p>Measures of structural holes</p></a></li>
<li><a href='#measure_over'><p>Helper functions for measuring over splits of networks</p></a></li>
<li><a href='#measure_periods'><p>Measures of network change</p></a></li>
<li><a href='#measure_properties'><p>Describing network properties</p></a></li>
<li><a href='#member_brokerage'><p>Memberships of brokerage</p></a></li>
<li><a href='#member_cliques'><p>Clique partitioning algorithms</p></a></li>
<li><a href='#member_community_hier'><p>Hierarchical community partitioning algorithms</p></a></li>
<li><a href='#member_community_non'><p>Non-hierarchical community partitioning algorithms</p></a></li>
<li><a href='#member_components'><p>Component partitioning algorithms</p></a></li>
<li><a href='#member_diffusion'><p>Membership of nodes in a diffusion</p></a></li>
<li><a href='#member_equivalence'><p>Equivalence clustering algorithms</p></a></li>
<li><a href='#model_cluster'><p>Methods for equivalence clustering</p></a></li>
<li><a href='#model_kselect'><p>Methods for selecting clusters</p></a></li>
<li><a href='#motif_brokerage'><p>Motifs of brokerage</p></a></li>
<li><a href='#motif_diffusion'><p>Motifs of diffusion</p></a></li>
<li><a href='#motif_net'><p>Motifs at the network level</p></a></li>
<li><a href='#motif_node'><p>Motifs at the nodal level</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#tutorials'><p>Open and extract code from tutorials</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Many Ways to Make, Modify, Map, Mark, and Measure Myriad
Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-05</td>
</tr>
<tr>
<td>Description:</td>
<td>Many tools for making, modifying, mapping, marking, measuring, 
   and motifs and memberships of many different types of networks.
   All functions operate with matrices, edge lists, and 'igraph', 'network', and 'tidygraph' objects,
   and on one-mode, two-mode (bipartite), and sometimes three-mode networks.
   The package includes functions for importing and exporting, creating and generating networks,
   modifying networks and node and tie attributes,
   and describing and visualizing networks with sensible defaults.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://stocnet.github.io/manynet/">https://stocnet.github.io/manynet/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stocnet/manynet/issues">https://github.com/stocnet/manynet/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr (&ge; 1.1.0), ggplot2, ggraph, igraph (&ge; 1.6.0),
network, pillar, tidygraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BiocManager, concaveman, future, furrr, gganimate, ggdendro,
ggforce, gifski, graphlayouts, knitr, learnr, methods,
netdiffuseR, patchwork, readxl, rmarkdown, RSiena, sna,
testthat (&ge; 3.0.0), tibble, tidyr, xml2</td>
</tr>
<tr>
<td>Enhances:</td>
<td>Rgraphviz</td>
</tr>
<tr>
<td>Config/Needs/build:</td>
<td>roxygen2, devtools</td>
</tr>
<tr>
<td>Config/Needs/check:</td>
<td>covr, lintr, spelling</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>pkgdown</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>mark_is</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-05 17:50:40 UTC; hollway</td>
</tr>
<tr>
<td>Author:</td>
<td>James Hollway <a href="https://orcid.org/0000-0002-8361-9647"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, ctb] (IHEID),
  Henrique Sposito <a href="https://orcid.org/0000-0003-3420-6085"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Christian Steglich [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Hollway &lt;james.hollway@graduateinstitute.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-05 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='data_overview'>Obtain overview of available network data</h2><span id='topic+data_overview'></span><span id='topic+table_data'></span>

<h3>Description</h3>

<p>This function makes it easy to get an overview of available data:
</p>

<ul>
<li> <p><code>table_data()</code> returns a tibble with details of the
network datasets included in the packages.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>table_data(pkg = c("manynet", "migraph"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_overview_+3A_pkg">pkg</code></td>
<td>
<p>String, name of the package.</p>
</td></tr>
<tr><td><code id="data_overview_+3A_...">...</code></td>
<td>
<p>Network marks, e.g. directed, twomode, or signed,
that are used to filter the results.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>table_data()
# to obtain list of all e.g. directed networks:
table_data(pkg = "manynet", directed)
# to obtain overview of unique datasets:
table_data() %&gt;% 
  dplyr::distinct(directed, weighted, twomode, signed, 
                 .keep_all = TRUE)
</code></pre>

<hr>
<h2 id='defunct'>Functions that have been renamed, superseded, or are no longer working</h2><span id='topic+defunct'></span><span id='topic+pkg_data'></span><span id='topic+node_mode'></span><span id='topic+autographr'></span><span id='topic+autographs'></span><span id='topic+autographd'></span><span id='topic+node_optimal'></span><span id='topic+node_kernighanlin'></span><span id='topic+node_edge_betweenness'></span><span id='topic+node_fast_greedy'></span><span id='topic+node_leading_eigen'></span><span id='topic+node_walktrap'></span><span id='topic+node_infomap'></span><span id='topic+node_spinglass'></span><span id='topic+node_fluid'></span><span id='topic+node_leiden'></span><span id='topic+node_louvain'></span><span id='topic+node_roulette'></span><span id='topic+node_components'></span><span id='topic+node_weak_components'></span><span id='topic+node_strong_components'></span><span id='topic+node_equivalence'></span><span id='topic+node_structural_equivalence'></span><span id='topic+node_regular_equivalence'></span><span id='topic+node_automorphic_equivalence'></span><span id='topic+network_transmissibility'></span><span id='topic+network_infection_length'></span><span id='topic+network_reproduction'></span><span id='topic+network_immunity'></span><span id='topic+network_hazard'></span><span id='topic+network_density'></span><span id='topic+network_components'></span><span id='topic+network_cohesion'></span><span id='topic+network_adhesion'></span><span id='topic+network_diameter'></span><span id='topic+network_length'></span><span id='topic+network_independence'></span><span id='topic+network_change'></span><span id='topic+network_stability'></span><span id='topic+network_reciprocity'></span><span id='topic+network_transitivity'></span><span id='topic+network_equivalency'></span><span id='topic+network_congruency'></span><span id='topic+network_richness'></span><span id='topic+network_diversity'></span><span id='topic+network_heterophily'></span><span id='topic+network_assortativity'></span><span id='topic+network_spatial'></span><span id='topic+network_connectedness'></span><span id='topic+network_efficiency'></span><span id='topic+network_upperbound'></span><span id='topic+network_nodes'></span><span id='topic+network_ties'></span><span id='topic+network_dims'></span><span id='topic+network_dims.data.frame'></span><span id='topic+network_dims.matrix'></span><span id='topic+network_dims.igraph'></span><span id='topic+network_dims.network'></span><span id='topic+network_node_attributes'></span><span id='topic+network_tie_attributes'></span><span id='topic+network_degree'></span><span id='topic+network_outdegree'></span><span id='topic+network_indegree'></span><span id='topic+network_betweenness'></span><span id='topic+network_closeness'></span><span id='topic+network_reach'></span><span id='topic+network_harmonic'></span><span id='topic+network_eigenvector'></span><span id='topic+network_core'></span><span id='topic+network_richclub'></span><span id='topic+network_factions'></span><span id='topic+network_modularity'></span><span id='topic+network_smallworld'></span><span id='topic+network_scalefree'></span><span id='topic+network_balance'></span><span id='topic+node_tie_census'></span><span id='topic+node_triad_census'></span><span id='topic+node_quad_census'></span><span id='topic+node_path_census'></span><span id='topic+network_dyad_census'></span><span id='topic+network_triad_census'></span><span id='topic+network_mixed_census'></span><span id='topic+node_brokerage_census'></span><span id='topic+network_brokerage_census'></span><span id='topic+node_brokering'></span><span id='topic+node_core'></span><span id='topic+node_by_quad'></span><span id='topic+net_by_quad'></span><span id='topic+layout_tbl_graph_quad'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Generally these functions have been superseded or renamed.
Upon using them, a message is provided directing the user to the new function.
However, at this stage of package development,
we generally clear older defunct functions at each minor release,
and so you are strongly encouraged to use the new functions/names/syntax
wherever possible and update your scripts accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkg_data(pkg = "manynet")

node_mode(.data)

autographr(
  .data,
  layout,
  labels = TRUE,
  node_color,
  node_shape,
  node_size,
  node_group,
  edge_color,
  edge_size,
  ...
)

autographs(netlist, waves, based_on = c("first", "last", "both"), ...)

autographd(
  tlist,
  layout,
  labels = TRUE,
  node_color,
  node_shape,
  node_size,
  edge_color,
  edge_size,
  keep_isolates = TRUE,
  ...
)

node_optimal(.data)

node_kernighanlin(.data)

node_edge_betweenness(.data)

node_fast_greedy(.data)

node_leading_eigen(.data)

node_walktrap(.data)

node_infomap(.data)

node_spinglass(.data)

node_fluid(.data)

node_leiden(.data)

node_louvain(.data)

node_roulette(.data)

node_components(.data)

node_weak_components(.data)

node_strong_components(.data)

node_equivalence(.data)

node_structural_equivalence(.data)

node_regular_equivalence(.data)

node_automorphic_equivalence(.data)

network_transmissibility(diff_model)

network_infection_length(diff_model)

network_reproduction(diff_model)

network_immunity(diff_model, normalized = TRUE)

network_hazard(diff_model)

network_density(.data)

network_components(.data)

network_cohesion(.data)

network_adhesion(.data)

network_diameter(.data)

network_length(.data)

network_independence(.data)

network_change(.data, object2)

network_stability(.data, object2)

network_reciprocity(.data, method = "default")

network_transitivity(.data)

network_equivalency(.data)

network_transitivity(.data)

network_congruency(.data)

network_richness(.data, attribute)

network_diversity(.data, attribute, clusters = NULL)

network_heterophily(.data, attribute)

network_assortativity(.data)

network_spatial(.data, attribute)

network_connectedness(.data)

network_efficiency(.data)

network_upperbound(.data)

network_nodes(.data)

network_ties(.data)

network_dims(.data)

network_dims.data.frame(.data)

network_dims.matrix(.data)

network_dims.igraph(.data)

network_dims.network(.data)

network_node_attributes(.data)

network_tie_attributes(.data)

network_degree(.data, normalized = TRUE, direction = c("all", "out", "in"))

network_outdegree(.data, normalized = TRUE)

network_indegree(.data, normalized = TRUE)

network_betweenness(
  .data,
  normalized = TRUE,
  direction = c("all", "out", "in")
)

network_closeness(.data, normalized = TRUE, direction = c("all", "out", "in"))

network_reach(.data, normalized = TRUE, k = 2)

network_harmonic(.data, normalized = TRUE, k = 2)

network_eigenvector(.data, normalized = TRUE)

network_core(.data, mark = NULL)

network_richclub(.data)

network_factions(.data, membership = NULL)

network_modularity(.data, membership = NULL, resolution = 1)

network_smallworld(.data, method = c("omega", "sigma", "SWI"), times = 100)

network_scalefree(.data)

network_balance(.data)

node_tie_census(.data)

node_triad_census(.data)

node_quad_census(.data)

node_path_census(.data)

network_dyad_census(.data)

network_triad_census(.data)

network_mixed_census(.data, object2)

node_brokerage_census(.data, membership, standardized = FALSE)

network_brokerage_census(.data, membership, standardized = FALSE)

node_brokering(.data, membership)

node_core(.data)

node_by_quad(.data)

net_by_quad(.data)

layout_tbl_graph_quad(.data, circular = FALSE, times = 1000)
</code></pre>


<h3>Functions</h3>


<ul>
<li> <p><code>pkg_data()</code>: Deprecated on 2024-06-17.
</p>
</li>
<li> <p><code>node_mode()</code>: Deprecated on 2024-06-17.
</p>
</li>
<li> <p><code>autographr()</code>: Deprecated on 2024-06-17.
</p>
</li>
<li> <p><code>autographs()</code>: Deprecated on 2024-06-17.
</p>
</li>
<li> <p><code>autographd()</code>: Deprecated on 2024-06-17.
</p>
</li>
<li> <p><code>node_optimal()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_kernighanlin()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_edge_betweenness()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_fast_greedy()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_leading_eigen()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_walktrap()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_infomap()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_spinglass()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_fluid()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_leiden()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_louvain()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_roulette()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_components()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_weak_components()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_strong_components()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_equivalence()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_structural_equivalence()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_regular_equivalence()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>node_automorphic_equivalence()</code>: Deprecated on 2024-06-14.
</p>
</li>
<li> <p><code>network_transmissibility()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_infection_length()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_reproduction()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_immunity()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_hazard()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_density()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_components()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_cohesion()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_adhesion()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_diameter()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_length()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_independence()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_change()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_stability()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_reciprocity()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_transitivity()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_equivalency()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_transitivity()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_congruency()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_richness()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_diversity()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_heterophily()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_assortativity()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_spatial()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_connectedness()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_efficiency()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_upperbound()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_nodes()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_ties()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_dims()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_dims.data.frame()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_dims.matrix()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_dims.igraph()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_dims.network()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_node_attributes()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_tie_attributes()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_degree()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_outdegree()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_indegree()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_betweenness()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_closeness()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_reach()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_harmonic()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_eigenvector()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_core()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_richclub()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_factions()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_modularity()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_smallworld()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_scalefree()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_balance()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>node_tie_census()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>node_triad_census()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>node_quad_census()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>node_path_census()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_dyad_census()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_triad_census()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_mixed_census()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>node_brokerage_census()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>network_brokerage_census()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>node_brokering()</code>: Deprecated on 2024-06-20.
</p>
</li>
<li> <p><code>node_core()</code>: Deprecated on 2024-06-21.
</p>
</li>
<li> <p><code>node_by_quad()</code>: Deprecated on 2024-10-10.
</p>
</li>
<li> <p><code>net_by_quad()</code>: Deprecated on 2024-10-10.
</p>
</li>
<li> <p><code>layout_tbl_graph_quad()</code>: Deprecated on 2024-10-10.
</p>
</li></ul>

<hr>
<h2 id='depth_first_recursive_search'>Layouts for snapping layouts to a grid</h2><span id='topic+depth_first_recursive_search'></span>

<h3>Description</h3>

<p>The function uses approximate pattern matching
to redistribute coarse layouts on square grid points, while
preserving the topological relationships among the nodes (see Inoue et al. 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth_first_recursive_search(layout)
</code></pre>


<h3>References</h3>

<p>Inoue, Kentaro, Shinichi Shimozono, Hideaki Yoshida, and Hiroyuki Kurata. 2012.
“Application of Approximate Pattern Matching in Two Dimensional Spaces to Grid Layout for Biochemical Network Maps” edited by J. Bourdon.
<em>PLoS ONE</em> 7(6):e37739.
<a href="https://doi.org/10.1371/journal.pone.0037739">doi:10.1371/journal.pone.0037739</a>.
</p>

<hr>
<h2 id='fict_friends'>One-mode undirected Friends character scene co-appearances (McNulty, 2020)</h2><span id='topic+fict_friends'></span>

<h3>Description</h3>

<p>One-mode network collected by <a href="https://github.com/keithmcnulty/friends_analysis/">McNulty (2020)</a>
on the connections between the Friends TV series characters
from Seasons 1 to 10.
The <code>fict_friends</code> is an undirected network
containing connections between characters organised by season number,
which is reflected in the tie attribute 'wave'.
The network contains 650 nodes
Each tie represents the connection between a character pair (appear in the same scene),
and the 'weight' of the tie is the number of scenes the character pair appears in together.
For all networks, characters are named (eg. Phoebe, Ross, Rachel).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fict_friends)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # Friends network
#&gt; # A labelled, weighted, undirected network of 650 characters and 2976 scene
#&gt; co-appearance ties
#&gt; # A tibble: 650 x 1
#&gt;   name        
#&gt;   &lt;chr&gt;       
#&gt; 1 Actor       
#&gt; 2 Alan        
#&gt; 3 Andrea      
#&gt; 4 Angela      
#&gt; 5 Aunt Iris   
#&gt; 6 Aunt Lillian
#&gt; # i 644 more rows
#&gt; # A tibble: 2,976 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
#&gt; 1     8     9      3
#&gt; 2     4    10      1
#&gt; 3     8    12      1
#&gt; 4     9    12      1
#&gt; 5     2    14      1
#&gt; 6     3    14      1
#&gt; # i 2,970 more rows
</pre></div>


<h3>References</h3>

<p>McNulty, K. (2020).
<em>Network analysis of Friends scripts.</em>.
</p>

<hr>
<h2 id='fict_greys'>One-mode undirected network of characters hook-ups on Grey's Anatomy TV show</h2><span id='topic+fict_greys'></span>

<h3>Description</h3>

<p>Grey's Anatomy is an American medical drama television series running on ABC since 2005.
It focuses on the personal and professional lives of surgical interns, residents, and attendings
at Seattle Grace Hospital, later renamed as the Grey Sloan Memorial Hospital.
<a href="https://gweissman.github.io/post/grey-s-anatomy-network-of-sexual-relations/">Gary Weissman</a>
collected data on the sexual contacts between characters on the television show
through observation of the story lines in the episodes and fan pages,
and this data was extended by
<a href="http://badhessian.org/2012/09/lessons-on-exponential-random-graph-modeling-from-greys-anatomy-hook-ups/">Benjamin Lind</a>
including nodal attributes:
</p>

<ul>
<li><p> 'name': first and, where available, surname
</p>
</li>
<li><p> 'sex': <code>F</code> for female and <code>M</code> for male
</p>
</li>
<li><p> 'race': <code>White</code>, <code>Black</code>, or <code>Other</code>
</p>
</li>
<li><p> 'birthyear': year born (some missing data)
</p>
</li>
<li><p> 'position': <code>"Chief"</code>, <code>"Attending"</code>, <code>"Resident"</code>, <code>"Intern"</code>, <code>"Nurse"</code>, <code>"Non-Staff"</code>, <code>"Other"</code>
</p>
</li>
<li><p> 'season': season that the character joined the show
</p>
</li>
<li><p> 'sign': character's astrological starsign, if known
</p>
</li></ul>

<p>The data is current up to (I think?) season 10?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fict_greys)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # Grey's Anatomy
#&gt; # A labelled, undirected network of 53 characters and 56 hook-up ties
#&gt; # A tibble: 53 x 7
#&gt;   name               sex   race  birthyear position  season sign  
#&gt;   &lt;chr&gt;              &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt; 
#&gt; 1 Addison Montgomery F     White      1967 Attending      1 Libra 
#&gt; 2 Adele Webber       F     Black      1949 Non-Staff      2 Leo   
#&gt; 3 Teddy Altman       F     White      1969 Attending      6 Pisces
#&gt; 4 Amelia Shepherd    F     White      1981 Attending      7 Libra 
#&gt; 5 Arizona Robbins    F     White      1976 Attending      5 Leo   
#&gt; 6 Rebecca Pope       F     White      1975 Non-Staff      3 Gemini
#&gt; # i 47 more rows
#&gt; # A tibble: 56 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     5    47
#&gt; 2    21    47
#&gt; 3     5    46
#&gt; 4     5    41
#&gt; 5    18    41
#&gt; 6    21    41
#&gt; # i 50 more rows
</pre></div>


<h3>Author(s)</h3>

<p>Gary Weissman and Benjamin Lind
</p>

<hr>
<h2 id='fict_lotr'>One-mode network of Lord of the Rings character interactions</h2><span id='topic+fict_lotr'></span>

<h3>Description</h3>

<p>A network of 36 Lord of the Rings book characters and 66 interactional relationships.
The ties are unweighted and concern only interaction.
Interaction can be cooperative or conflictual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fict_lotr)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # Lord of the Rings
#&gt; # A labelled, complex, undirected network of 36 characters and 66 interaction
#&gt; ties
#&gt; # A tibble: 36 x 2
#&gt;   name     Race  
#&gt;   &lt;chr&gt;    &lt;chr&gt; 
#&gt; 1 Aragorn  Human 
#&gt; 2 Beregond Human 
#&gt; 3 Bilbo    Hobbit
#&gt; 4 Celeborn Elf   
#&gt; 5 Denethor Human 
#&gt; 6 Elladan  Elf   
#&gt; # i 30 more rows
#&gt; # A tibble: 66 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     7
#&gt; 2     1     8
#&gt; 3     5     9
#&gt; 4     1    10
#&gt; 5     3    10
#&gt; 6     9    10
#&gt; # i 60 more rows
</pre></div>

<hr>
<h2 id='fict_potter'>Six complex one-mode support data in Harry Potter books (Bossaert and Meidert 2013)</h2><span id='topic+fict_potter'></span>

<h3>Description</h3>

<p>Goele Bossaert and Nadine Meidert coded peer support ties among 64 characters
in the Harry Potter books.
Each author coded four of seven books using NVivo,
with the seventh book coded by both and serving to assess inter-rater reliability.
The first six books concentrated on adolescent interactions,
were studied in their paper, and are made available here.
The peer support ties mean voluntary emotional, instrumental, or informational support,
or praise from one living, adolescent character to another within the book's pages.
In addition, nodal attributes name, schoolyear (which doubles as their age),
gender, and their house assigned by the sorting hat are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fict_potter)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # Harry Potter
#&gt; # A longitudinal, labelled, complex, directed network of 64 students and 544
#&gt; support arcs
#&gt; # A tibble: 64 x 4
#&gt;   name              schoolyear gender house     
#&gt;   &lt;chr&gt;                  &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
#&gt; 1 Adrian Pucey            1989 male   Slytherin 
#&gt; 2 Alicia Spinnet          1989 female Gryffindor
#&gt; 3 Angelina Johnson        1989 female Gryffindor
#&gt; 4 Anthony Goldstein       1991 male   Ravenclaw 
#&gt; 5 Blaise Zabini           1991 male   Slytherin 
#&gt; 6 C. Warrington           1989 male   Slytherin 
#&gt; # i 58 more rows
#&gt; # A tibble: 544 x 3
#&gt;    from    to  wave
#&gt;   &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
#&gt; 1     2     2     2
#&gt; 2     2     2     3
#&gt; 3     2     2     5
#&gt; 4     2     3     2
#&gt; 5     2     3     3
#&gt; 6     2     3     5
#&gt; # i 538 more rows
</pre></div>


<h3>References</h3>

<p>Bossaert, Goele and Nadine Meidert (2013).
&quot;'We are only as strong as we are united, as weak as we are divided'. A dynamic analysis of the peer support networks in the Harry Potter books.&quot;
<em>Open Journal of Applied Sciences</em>, 3(2): 174-185.
<a href="https://doi.org/10.4236/ojapps.2013.32024">doi:10.4236/ojapps.2013.32024</a>
</p>

<hr>
<h2 id='fict_thrones'>One-mode Game of Thrones kinship (Glander 2017)</h2><span id='topic+fict_thrones'></span>

<h3>Description</h3>

<p>The original dataset was put together by Erin Pierce and Ben Kahle for an
assignment for a course on Bayesian statistics.
The data included information on when characters died in the Song of Ice
and Fire books,
and some predictive factors such as whether they were nobles, married, etc.
Shirin Glander extended this data set on character deaths in the TV series
Game of Thrones with the kinship relationships between the characters,
by scraping &quot;A Wiki of Ice and Fire&quot; and adding missing information by hand.
There is certainly more that can be done here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fict_thrones)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # Game of Thrones Kinship
#&gt; # A labelled, multiplex, directed network of 208 characters and 404 kinship
#&gt; arcs
#&gt; # A tibble: 208 x 10
#&gt;   name          culture house  popularity Gender title birth death noble married
#&gt;   &lt;chr&gt;         &lt;fct&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt;  
#&gt; 1 Alys Arryn    &lt;NA&gt;    House~     0.0803 female ""       NA    NA FALSE TRUE   
#&gt; 2 Elys Waynwood &lt;NA&gt;    House~     0.0702 female "Ser"    NA    NA TRUE  TRUE   
#&gt; 3 Jasper Arryn  &lt;NA&gt;    House~     0.0435 male   "Eyr~    NA    NA TRUE  FALSE  
#&gt; 4 Jeyne Royce   &lt;NA&gt;    House~     0      female  &lt;NA&gt;    NA    NA NA    NA     
#&gt; 5 Jon Arryn     Valemen House~     0.836  male   "Eyr~   217   298 TRUE  TRUE   
#&gt; 6 Lysa Arryn    &lt;NA&gt;    House~     0      female "Lad~   266   300 TRUE  TRUE   
#&gt; # i 202 more rows
#&gt; # A tibble: 404 x 3
#&gt;    from    to type  
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt; 
#&gt; 1     1     2 spouse
#&gt; 2     2     1 spouse
#&gt; 3     3     1 parent
#&gt; 4     3     5 parent
#&gt; 5     4     5 spouse
#&gt; 6     5     4 spouse
#&gt; # i 398 more rows
</pre></div>


<h3>References</h3>

<p>Pierce, Erin, and Ben Kahle. 2015.
&quot;<a href="http://allendowney.blogspot.com/2015/03/bayesian-survival-analysis-for-game-of.html">Bayesian Survival Analysis in A Song of Ice and Fire</a>&quot;.
</p>
<p>Glander, Shirin. 2017.
&quot;<a href="https://datascienceplus.com/network-analysis-of-game-of-thrones/">Network analysis of Game of Thrones</a>&quot;.
</p>

<hr>
<h2 id='glossary'>Adding network glossary items</h2><span id='topic+glossary'></span><span id='topic+gloss'></span><span id='topic+print_glossary'></span><span id='topic+clear_glossary'></span>

<h3>Description</h3>

<p>This function adds a glossary item, useful in tutorials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gloss(text, ref = NULL)

print_glossary()

clear_glossary()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glossary_+3A_text">text</code></td>
<td>
<p>The text to appear.</p>
</td></tr>
<tr><td><code id="glossary_+3A_ref">ref</code></td>
<td>
<p>The name of the glossary item to index.
If NULL, then the function will search the glossary for 'text' instead.</p>
</td></tr>
</table>

<hr>
<h2 id='irps_blogs'>One-mode directed network of links between US political blogs (Adamic and Glance 2005)</h2><span id='topic+irps_blogs'></span>

<h3>Description</h3>

<p>This network consists of the blogosphere around the time of the 2004
US presidential election until February 2005.
The 2004 election was the first in which blogging played a significant role.
Ties were constructed from a crawl of the front page of each blog.
</p>
<p>Political leaning is indicated as &quot;Liberal&quot; (or left leaning) or
&quot;Conservative&quot; (or right leaning), sourced from blog directories.
Some blogs were labelled manually,
based on incoming and outgoing links and posts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(irps_blogs)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, complex, directed network of 1490 blogs and 19090 link arcs
#&gt; # A tibble: 1,490 x 3
#&gt;   name                       Leaning Source               
#&gt;   &lt;chr&gt;                      &lt;chr&gt;   &lt;chr&gt;                
#&gt; 1 100monkeystyping.com       Liberal Blogarama            
#&gt; 2 12thharmonic.com/wordpress Liberal BlogCatalog          
#&gt; 3 40ozblog.blogspot.com      Liberal Blogarama,BlogCatalog
#&gt; 4 4lina.tblog.com            Liberal Blogarama            
#&gt; 5 750volts.blogspot.com      Liberal Blogarama            
#&gt; 6 95theses.blogspot.com      Liberal Blogarama            
#&gt; # i 1,484 more rows
#&gt; # A tibble: 19,090 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1   267  1394
#&gt; 2   267   483
#&gt; 3   267  1051
#&gt; 4   904  1479
#&gt; 5   904   919
#&gt; 6   904  1045
#&gt; # i 19,084 more rows
</pre></div>


<h3>References</h3>

<p>Adamic, Lada, and Natalie Glance. 2005.
&quot;The political blogosphere and the 2004 US Election: Divided they blog&quot;.
<em>LinkKDD '05: Proceedings of the 3rd international workshop on Link discovery</em>, 36-43.
<a href="https://doi.org/10.1145/1134271.1134277">doi:10.1145/1134271.1134277</a>
</p>

<hr>
<h2 id='irps_books'>One-mode undirected network of co-purchased books about US politics on Amazon</h2><span id='topic+irps_books'></span>

<h3>Description</h3>

<p>This network consists of books about US politics sold by Amazon.com.
Ties represent books that are often purchased together,
as revealed by Amazon's 'customers who bought this book also bought these other
books' section on those books' pages on the website.
</p>
<p>Information about the book's leaning &quot;Liberal&quot;, &quot;Neutral&quot;, or &quot;Conservative&quot;
were added separately by Mark Newman based on the abstracts, descriptions,
and reviews posted on Amazon.
</p>
<p>These data should be cited as V. Krebs, unpublished, http://www.orgnet.com/.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(irps_books)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, undirected network of 105 nodes and 441 ties
#&gt; # A tibble: 105 x 2
#&gt;   name                       Leaning     
#&gt;   &lt;chr&gt;                      &lt;chr&gt;       
#&gt; 1 1000 Years for Revenge     Neutral     
#&gt; 2 Bush vs. the Beltway       Conservative
#&gt; 3 Charlie Wilson's War       Conservative
#&gt; 4 Losing Bin Laden           Conservative
#&gt; 5 Sleeping With the Devil    Neutral     
#&gt; 6 The Man Who Warned America Conservative
#&gt; # i 99 more rows
#&gt; # A tibble: 441 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     2
#&gt; 2     1     3
#&gt; 3     1     4
#&gt; 4     2     4
#&gt; 5     1     5
#&gt; 6     3     5
#&gt; # i 435 more rows
</pre></div>


<h3>Author(s)</h3>

<p>Valdis Krebs, Mark Newman
</p>

<hr>
<h2 id='irps_usgeo'>One-mode undirected network of US state contiguity (Meghanathan 2017)</h2><span id='topic+irps_usgeo'></span>

<h3>Description</h3>

<p>This network is of contiguity between US states.
States that share a border are connected by a tie in the network.
The data is a network of 107 ties among 50 US states (nodes).
States are named by their two-letter ISO-3166 code.
This data includes also the names of the capitol cities of each state,
which are listed in the node attribute 'capitol'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(irps_usgeo)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # US State Contiguity
#&gt; # A labelled, undirected network of 50 states and 107 contiguity ties
#&gt; # A tibble: 50 x 3
#&gt;   name  capitol     population
#&gt;   &lt;chr&gt; &lt;chr&gt;            &lt;int&gt;
#&gt; 1 AK    Juneau              NA
#&gt; 2 AL    Montgomery     4780127
#&gt; 3 AR    Little Rock    2915958
#&gt; 4 AZ    Phoenix        6392307
#&gt; 5 CA    Sacramento    37252895
#&gt; 6 CO    Denver         5029324
#&gt; # i 44 more rows
#&gt; # A tibble: 107 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     2     9
#&gt; 2     2    10
#&gt; 3     2    25
#&gt; 4     2    42
#&gt; 5     3    18
#&gt; 6     3    24
#&gt; # i 101 more rows
</pre></div>


<h3>References</h3>

<p>Meghanathan, Natarajan. 2017.
&quot;Complex network analysis of the contiguous United States graph.&quot;
<em>Computer and Information Science</em>, 10(1): 54-76.
<a href="https://doi.org/10.5539/cis.v10n1p54">doi:10.5539/cis.v10n1p54</a>
</p>

<hr>
<h2 id='irps_wwi'>One-mode signed network of relationships between European major powers (Antal et al. 2006)</h2><span id='topic+irps_wwi'></span>

<h3>Description</h3>

<p>This network records the evolution of the major relationship changes
between the protagonists of World War I (WWI) from 1872 to 1907.
It is incomplete both in terms of (eventual) parties to the war as well
as some other relations, but gives a good overview of the main alliances
and enmities.
</p>
<p>The data series begins with the Three Emperors' League (1872, revived in 1881)
between Germany, Austria-Hungary, and Russia.
The Triple Alliance in 1882 joined Germany, Austria-Hungary, and Italy into
a bloc that lasted until WWI.
A bilateral alliance between Germany and Russia lapsed in 1890,
and a French-Russian alliance developed between 1891-1894.
The Entente Cordiale thawed and then fostered relations between Great Britain
and France in 1904, and a British-Russian agreement in 1907 bound
Great Britain, France, and Russia into the Triple Entente.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(irps_wwi)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # World War I Protagonists
#&gt; # A dynamic, labelled, signed, undirected network of 6 European major powers
#&gt; and 20 relationship ties
#&gt; # A tibble: 6 x 1
#&gt;   name 
#&gt;   &lt;chr&gt;
#&gt; 1 GBR  
#&gt; 2 FRA  
#&gt; 3 RUS  
#&gt; 4 AUH  
#&gt; 5 DEU  
#&gt; 6 ITA  
#&gt; # A tibble: 20 x 5
#&gt;    from    to  sign begin   end
#&gt;   &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     1     2    -1  1872  1904
#&gt; 2     1     3    -1  1872  1907
#&gt; 3     1     4    -1  1872  1918
#&gt; 4     2     3    -1  1872  1890
#&gt; 5     2     4    -1  1872  1918
#&gt; 6     2     5    -1  1872  1918
#&gt; # i 14 more rows
</pre></div>


<h3>References</h3>

<p>Antal, Tibor, Pavel Krapivsky, and Sidney Redner. 2006.
&quot;Social balance on networks: The dynamics of friendship and enmity&quot;.
<em>Physica D</em> 224: 130-136.
<a href="https://doi.org/10.1016/j.physd.2006.09.028">doi:10.1016/j.physd.2006.09.028</a>
</p>

<hr>
<h2 id='ison_adolescents'>One-mode subset of the adolescent society network (Coleman 1961)</h2><span id='topic+ison_adolescents'></span>

<h3>Description</h3>

<p>One-mode subset of Coleman's adolescent society network (Coleman 1961),
as used in Feld's (1991) &quot;Why your friends have more friends than you do&quot;.
Coleman collected data on friendships among students in 12 U.S. high schools.
Feld explored a subset of 8 girls from one of these schools, &quot;Marketville&quot;,
and gave them fictitious names, which are retained here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_adolescents)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # The Adolescent Society
#&gt; # A labelled, undirected network of 8 adolescents and 10 friendships ties
#&gt; # A tibble: 8 x 1
#&gt;   name 
#&gt;   &lt;chr&gt;
#&gt; 1 Betty
#&gt; 2 Sue  
#&gt; 3 Alice
#&gt; 4 Jane 
#&gt; 5 Dale 
#&gt; 6 Pam  
#&gt; # i 2 more rows
#&gt; # A tibble: 10 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     2
#&gt; 2     2     3
#&gt; 3     3     4
#&gt; 4     2     5
#&gt; 5     3     5
#&gt; 6     4     5
#&gt; # i 4 more rows
</pre></div>


<h3>References</h3>

<p>Coleman, James S. 1961. <em>The Adolescent Society</em>.
New York: Free Press.
</p>
<p>Feld, Scott. 1991. “Why your friends have more friends than you do”
<em>American Journal of Sociology</em> 96(6): 1464-1477.
<a href="https://doi.org/10.1086/229693">doi:10.1086/229693</a>.
</p>

<hr>
<h2 id='ison_algebra'>Multiplex graph object of friends, social, and task ties (McFarland 2001)</h2><span id='topic+ison_algebra'></span>

<h3>Description</h3>

<p>Multiplex graph object of friends, social, and task ties between 16 anonymous students.
M182 was an honors algebra class where researchers
collected friendship, social, and task ties between 16 students.
The edge attribute <code>friends</code> contains friendship ties,
where <code>2</code> = best friends, <code>1</code> = friend, and <code>0</code> is not a friend.
<code>social</code> consists of social interactions per hour,
and <code>tasks</code> consists of task interactions per hour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_algebra)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A multiplex, weighted, directed network of 16 nodes and 279 social, tasks,
#&gt; and friends arcs
#&gt; # A tibble: 279 x 4
#&gt;    from    to type   weight
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;   &lt;dbl&gt;
#&gt; 1     1     5 social   1.2 
#&gt; 2     1     5 tasks    0.3 
#&gt; 3     1     8 social   0.15
#&gt; 4     1     9 social   2.85
#&gt; 5     1     9 tasks    0.3 
#&gt; 6     1    10 social   6.45
#&gt; # i 273 more rows
</pre></div>


<h3>Source</h3>

<p>See also <code>data(studentnets.M182, package = "NetData")</code>
Larger comprehensive data set publicly available, contact Daniel A. McFarland for details.
</p>


<h3>References</h3>

<p>McFarland, Daniel A. (2001) “Student Resistance.”
<em>American Journal of Sociology</em> 107(3): 612-78.
<a href="https://doi.org/10.1086/338779">doi:10.1086/338779</a>.
</p>

<hr>
<h2 id='ison_brandes'>One-mode and two-mode centrality demonstration networks</h2><span id='topic+ison_brandes'></span>

<h3>Description</h3>

<p>This network should solely be used
for demonstration purposes as it does not describe a real network.
To convert into the two-mode version,
assign <code>ison_brandes %&gt;% rename(type = twomode_type)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_brandes)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A undirected network of 11 nodes and 12 ties
#&gt; # A tibble: 11 x 1
#&gt;   twomode_type
#&gt;   &lt;lgl&gt;       
#&gt; 1 FALSE       
#&gt; 2 FALSE       
#&gt; 3 TRUE        
#&gt; 4 FALSE       
#&gt; 5 TRUE        
#&gt; 6 TRUE        
#&gt; # i 5 more rows
#&gt; # A tibble: 12 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     3
#&gt; 2     2     3
#&gt; 3     3     4
#&gt; 4     4     5
#&gt; 5     4     6
#&gt; 6     5     7
#&gt; # i 6 more rows
</pre></div>

<hr>
<h2 id='ison_dolphins'>One-mode, undirected network of frequent associations in a dolphin pod (Lusseau et al. 2003)</h2><span id='topic+ison_dolphins'></span>

<h3>Description</h3>

<p>These data contain the frequent associations between the 62 dolphins of a
pod of dolphins living off Doubtful Sound, New Zealand.
Additional information can be found in the literature cited below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_dolphins)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, undirected network of 62 nodes and 159 ties
#&gt; # A tibble: 62 x 1
#&gt;   name      
#&gt;   &lt;chr&gt;     
#&gt; 1 Beak      
#&gt; 2 Beescratch
#&gt; 3 Bumper    
#&gt; 4 CCL       
#&gt; 5 Cross     
#&gt; 6 DN16      
#&gt; # i 56 more rows
#&gt; # A tibble: 159 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     4     9
#&gt; 2     6    10
#&gt; 3     7    10
#&gt; 4     1    11
#&gt; 5     3    11
#&gt; 6     6    14
#&gt; # i 153 more rows
</pre></div>


<h3>References</h3>

<p>Lusseau, David, K. Schneider, O. J. Boisseau, P. Haase, E. Slooten, and S. M. Dawson. 2003.
&quot;The bottlenose dolphin community of Doubtful Sound features a large proportion of long-lasting associations&quot;,
<em>Behavioral Ecology and Sociobiology</em> 54, 396-405.
</p>
<p>Lusseau, David. 2003.
&quot;The emergent properties of a dolphin social network&quot;,
<em>Proc. R. Soc. London B</em> 270(S): S186-S188.
<a href="https://doi.org/10.1098/rsbl.2003.0057">doi:10.1098/rsbl.2003.0057</a>
</p>
<p>Lusseau, David. 2007.
&quot;Evidence for social role in a dolphin social network&quot;.
<em>Evolutionary Ecology</em> 21: 357–366.
<a href="https://doi.org/10.1007/s10682-006-9105-0">doi:10.1007/s10682-006-9105-0</a>
</p>

<hr>
<h2 id='ison_hightech'>One-mode multiplex, directed network of managers of a high-tech company (Krackhardt 1987)</h2><span id='topic+ison_hightech'></span>

<h3>Description</h3>

<p>21 managers of a company of just over 100 employees manufactured high-tech equipment
on the west coast of the United States.
Three types of ties were collected:
</p>

<ul>
<li> <p><em>friends</em>: managers' answers to the question &quot;Who is your friend?&quot;
</p>
</li>
<li> <p><em>advice</em>: managers' answers to the question &quot;To whom do you go to for advice?&quot;
</p>
</li>
<li> <p><em>reports</em>: &quot;To whom do you report?&quot; based on company reports
</p>
</li></ul>

<p>The data is anonymised, but four nodal attributes are included:
</p>

<ul>
<li> <p><em>age</em>: the manager's age in years
</p>
</li>
<li> <p><em>tenure</em>: the manager's length of service
</p>
</li>
<li> <p><em>level</em>: the manager's level in the corporate hierarchy,
where 3 = CEO, 2 = Vice President, and 1 = manager
</p>
</li>
<li> <p><em>dept</em>: one of four departments, B, C, D, E,
with the CEO alone in A
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(ison_hightech)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A multiplex, directed network of 21 nodes and 312 friends, advice, and
#&gt; reports arcs
#&gt; # A tibble: 21 x 4
#&gt;     age tenure level dept 
#&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;
#&gt; 1    33      9     1 E    
#&gt; 2    42     20     2 E    
#&gt; 3    40     13     1 C    
#&gt; 4    33      8     1 E    
#&gt; 5    32      3     1 C    
#&gt; 6    59     28     1 B    
#&gt; # i 15 more rows
#&gt; # A tibble: 312 x 3
#&gt;    from    to type   
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;  
#&gt; 1     1     2 friends
#&gt; 2     1     2 advice 
#&gt; 3     1     2 reports
#&gt; 4     1     4 friends
#&gt; 5     1     4 advice 
#&gt; 6     1     8 friends
#&gt; # i 306 more rows
</pre></div>


<h3>References</h3>

<p>Krackhardt, David. 1987. &quot;Cognitive social structures&quot;. <em>Social Networks</em> 9: 104-134.
</p>

<hr>
<h2 id='ison_karateka'>One-mode karateka network (Zachary 1977)</h2><span id='topic+ison_karateka'></span>

<h3>Description</h3>

<p>The network was observed in a university Karate club in 1977.
The network describes association patterns among 34 members
and maps out allegiance patterns between members and either Mr. Hi,
the instructor, or the John A. the club president
after an argument about hiking the price for lessons.
The allegiance of each node is listed in the <code>obc</code> argument
which takes the value 1 if the individual sided with Mr. Hi after the fight
and 2 if the individual sided with John A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_karateka)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, weighted, undirected network of 34 nodes and 78 ties
#&gt; # A tibble: 34 x 2
#&gt;   name  allegiance
#&gt;   &lt;chr&gt;      &lt;dbl&gt;
#&gt; 1 Mr Hi          1
#&gt; 2 2              1
#&gt; 3 3              1
#&gt; 4 4              1
#&gt; 5 5              1
#&gt; 6 6              1
#&gt; # i 28 more rows
#&gt; # A tibble: 78 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
#&gt; 1     1     2      4
#&gt; 2     1     3      5
#&gt; 3     2     3      6
#&gt; 4     1     4      3
#&gt; 5     2     4      3
#&gt; 6     3     4      3
#&gt; # i 72 more rows
</pre></div>


<h3>References</h3>

<p>Zachary, Wayne W. 1977. “An Information Flow Model for Conflict and Fission in Small Groups.”
<em>Journal of Anthropological Research</em> 33(4):452–73.
<a href="https://doi.org/10.1086/jar.33.4.3629752">doi:10.1086/jar.33.4.3629752</a>.
</p>

<hr>
<h2 id='ison_koenigsberg'>One-mode Seven Bridges of Koenigsberg network (Euler 1741)</h2><span id='topic+ison_koenigsberg'></span>

<h3>Description</h3>

<p>The Seven Bridges of Koenigsberg is a notable historical problem in mathematics and laid the foundations of graph theory.
The city of Koenigsberg in Prussia (now Kaliningrad, Russia) was set on both sides of the Pregel River,
and included two large islands which were connected to each other and the mainland by seven bridges.
A weekend diversion for inhabitants was to find a walk through the city that would cross each bridge once and only once.
The islands could not be reached by any route other than the bridges,
and every bridge must have been crossed completely every time
(one could not walk half way onto the bridge and then turn around and later cross the other half from the other side).
In 1735, Leonard Euler proved that the problem has no solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_koenigsberg)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, undirected network of 4 nodes and 7 ties
#&gt; # A tibble: 4 x 3
#&gt;   name       lat   lon
#&gt;   &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1 Altstadt  54.7  20.5
#&gt; 2 Kneiphof  54.7  20.5
#&gt; 3 Lomse     54.7  20.5
#&gt; 4 Vorstadt  54.7  20.5
#&gt; # A tibble: 7 x 3
#&gt;    from    to name           
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;          
#&gt; 1     1     2 Kraemer Bruecke
#&gt; 2     1     2 Schmiedebruecke
#&gt; 3     1     3 Holzbruecke    
#&gt; 4     2     3 Honigbruecke   
#&gt; 5     2     4 Gruene Bruecke 
#&gt; 6     2     4 Koettelbruecke 
#&gt; # i 1 more row
</pre></div>


<h3>Source</h3>

<p><code>{igraphdata}</code>
</p>


<h3>References</h3>

<p>Euler, Leonard. 1741. “Solutio problematis ad geometriam situs pertinentis.”
<em>Commentarii academiae scientiarum Petropolitanae</em>.
</p>

<hr>
<h2 id='ison_laterals'>Two-mode projection examples (Hollway 2021)</h2><span id='topic+ison_laterals'></span>

<h3>Description</h3>

<p>These networks are for demonstration purposes and do not describe any real world network.
All examples contain named nodes.
The networks are gathered together as a list and can be retrieved simply by plucking
the desired network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_laterals)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; $ison_bb
#&gt; # A labelled, two-mode network of 10 nodes and 12 ties
#&gt; # A tibble: 10 x 2
#&gt;   name  type 
#&gt;   &lt;chr&gt; &lt;lgl&gt;
#&gt; 1 A     FALSE
#&gt; 2 B     FALSE
#&gt; 3 C     FALSE
#&gt; 4 D     FALSE
#&gt; 5 U     TRUE 
#&gt; 6 V     TRUE 
#&gt; # i 4 more rows
#&gt; # A tibble: 12 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     5
#&gt; 2     1     6
#&gt; 3     2     5
#&gt; 4     2     7
#&gt; 5     2     8
#&gt; 6     2     9
#&gt; # i 6 more rows
#&gt; 
#&gt; $ison_bm
#&gt; # A labelled, two-mode network of 8 nodes and 9 ties
#&gt; # A tibble: 8 x 2
#&gt;   name  type 
#&gt;   &lt;chr&gt; &lt;lgl&gt;
#&gt; 1 A     FALSE
#&gt; 2 B     FALSE
#&gt; 3 C     FALSE
#&gt; 4 D     FALSE
#&gt; 5 U     TRUE 
#&gt; 6 V     TRUE 
#&gt; # i 2 more rows
#&gt; # A tibble: 9 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     5
#&gt; 2     1     6
#&gt; 3     2     5
#&gt; 4     2     7
#&gt; 5     2     8
#&gt; 6     3     6
#&gt; # i 3 more rows
#&gt; 
#&gt; $ison_mb
#&gt; # A labelled, two-mode network of 8 nodes and 9 ties
#&gt; # A tibble: 8 x 2
#&gt;   name  type 
#&gt;   &lt;chr&gt; &lt;lgl&gt;
#&gt; 1 A     FALSE
#&gt; 2 B     FALSE
#&gt; 3 C     FALSE
#&gt; 4 D     FALSE
#&gt; 5 M     TRUE 
#&gt; 6 X     TRUE 
#&gt; # i 2 more rows
#&gt; # A tibble: 9 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     5
#&gt; 2     2     5
#&gt; 3     2     6
#&gt; 4     2     7
#&gt; 5     3     5
#&gt; 6     3     6
#&gt; # i 3 more rows
#&gt; 
#&gt; $ison_mm
#&gt; # A labelled, two-mode network of 6 nodes and 6 ties
#&gt; # A tibble: 6 x 2
#&gt;   name  type 
#&gt;   &lt;chr&gt; &lt;lgl&gt;
#&gt; 1 A     FALSE
#&gt; 2 B     FALSE
#&gt; 3 C     FALSE
#&gt; 4 D     FALSE
#&gt; 5 M     TRUE 
#&gt; 6 N     TRUE 
#&gt; # A tibble: 6 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     5
#&gt; 2     2     5
#&gt; 3     2     6
#&gt; 4     3     5
#&gt; 5     3     6
#&gt; 6     4     6
</pre></div>

<hr>
<h2 id='ison_lawfirm'>One-mode lawfirm (Lazega 2001)</h2><span id='topic+ison_lawfirm'></span>

<h3>Description</h3>

<p>One-mode network dataset collected by Lazega (2001)
on the relations between partners in a corporate law firm called SG&amp;R in New England 1988-1991.
This particular subset includes the 36 partners among the 71 attorneys of this firm.
Nodal attributes include seniority, formal status, office in which they work, gender, lawschool they attended,
their age, and how many years they had been at the firm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_lawfirm)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A multiplex, directed network of 71 nodes and 2571 friends, advice, and
#&gt; cowork arcs
#&gt; # A tibble: 71 x 7
#&gt;   status  gender office   seniority   age practice   school      
#&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;       
#&gt; 1 partner man    Boston          31    64 litigation Harvard/Yale
#&gt; 2 partner man    Boston          32    62 corporate  Harvard/Yale
#&gt; 3 partner man    Hartford        13    67 litigation Harvard/Yale
#&gt; 4 partner man    Boston          31    59 corporate  Other       
#&gt; 5 partner man    Hartford        31    59 litigation UConn       
#&gt; 6 partner man    Hartford        29    55 litigation Harvard/Yale
#&gt; # i 65 more rows
#&gt; # A tibble: 2,571 x 3
#&gt;    from    to type   
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;  
#&gt; 1     1     2 friends
#&gt; 2     1     2 advice 
#&gt; 3     1     4 friends
#&gt; 4     1     8 friends
#&gt; 5     1    17 friends
#&gt; 6     1    17 advice 
#&gt; # i 2,565 more rows
</pre></div>


<h3>Details</h3>

<p>The larger data from which this subset comes includes also individual performance measurements (hours worked, fees brought in)
and attitudes concerning various management policy options (see also <code>{sand}</code>),
their strong-coworker network, advice network, friendship network, and indirect control network.
</p>


<h3>Source</h3>

<p><code>{networkdata}</code>
</p>


<h3>References</h3>

<p>Lazega, Emmanuel. 2001.
<em>The Collegial Phenomenon: The Social Mechanisms of Cooperation Among Peers in a Corporate Law Partnership</em>.
Oxford: Oxford University Press.
</p>

<hr>
<h2 id='ison_marvel'>Multilevel two-mode affiliation, signed one-mode networks of Marvel comic
book characters (Yuksel 2017)</h2><span id='topic+ison_marvel'></span><span id='topic+ison_marvel_teams'></span><span id='topic+ison_marvel_relationships'></span>

<h3>Description</h3>

<p>This package includes two datasets related to the Marvel <em>comic book</em> universe.
The first, <code>ison_marvel_teams</code>,  is a two-mode affiliation network of 53
Marvel comic book characters and their affiliations to 141 different teams.
This network includes only information about nodes' names and nodeset,
but additional nodal data can be taken from the other Marvel dataset here.
</p>
<p>The second network, <code>ison_marvel_relationships</code>, is a one-mode signed network
of friendships and enmities between the 53 Marvel comic book characters.
Friendships are indicated by a positive sign in the tie <code>sign</code> attribute,
whereas enmities are indicated by a negative sign in this edge attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_marvel_teams)

data(ison_marvel_relationships)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, two-mode network of 194 nodes and 683 ties
#&gt; # A tibble: 194 x 2
#&gt;   type  name         
#&gt;   &lt;lgl&gt; &lt;chr&gt;        
#&gt; 1 FALSE Abomination  
#&gt; 2 FALSE Ant-Man      
#&gt; 3 FALSE Apocalypse   
#&gt; 4 FALSE Beast        
#&gt; 5 FALSE Black Panther
#&gt; 6 FALSE Black Widow  
#&gt; # i 188 more rows
#&gt; # A tibble: 683 x 2
#&gt;    from    to
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1   120
#&gt; 2     1   152
#&gt; 3     1   160
#&gt; 4     1   162
#&gt; 5     1   179
#&gt; 6     2    56
#&gt; # i 677 more rows
</pre></div>
<div class="sourceCode"><pre>#&gt; # A labelled, complex, signed, undirected network of 53 nodes and 558 ties
#&gt; # A tibble: 53 x 10
#&gt;   name     Gender Appearances Attractive  Rich Intellect Omnilingual PowerOrigin
#&gt;   &lt;chr&gt;    &lt;chr&gt;        &lt;int&gt;      &lt;int&gt; &lt;int&gt;     &lt;int&gt;       &lt;int&gt; &lt;chr&gt;      
#&gt; 1 Abomina~ Male           427          0     0         1           1 Radiation  
#&gt; 2 Ant-Man  Male           589          1     0         1           0 Human      
#&gt; 3 Apocaly~ Male          1207          0     0         1           1 Mutant     
#&gt; 4 Beast    Male          7609          1     0         1           0 Mutant     
#&gt; 5 Black P~ Male          2189          1     1         1           0 Human      
#&gt; 6 Black W~ Female        2907          1     0         1           0 Human      
#&gt; # i 47 more rows
#&gt; # i 2 more variables: UnarmedCombat &lt;int&gt;, ArmedCombat &lt;int&gt;
#&gt; # A tibble: 558 x 3
#&gt;    from    to  sign
#&gt;   &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
#&gt; 1     1     4    -1
#&gt; 2     1    11    -1
#&gt; 3     1    12    -1
#&gt; 4     1    23    -1
#&gt; 5     1    24    -1
#&gt; 6     1    25    -1
#&gt; # i 552 more rows
</pre></div>


<h3>Details</h3>

<p>Additional nodal variables have been coded and included by Dr Umut Yuksel:
</p>

<ul>
<li> <p><strong>Gender</strong>: binary character, 43 &quot;Male&quot; and 10 &quot;Female&quot;
</p>
</li>
<li> <p><strong>PowerOrigin</strong>: binary character, 2 &quot;Alien&quot;, 1 &quot;Cyborg&quot;, 5 &quot;God/Eternal&quot;,
22 &quot;Human&quot;, 1 &quot;Infection&quot;, 16 &quot;Mutant&quot;, 5 &quot;Radiation&quot;, 1 &quot;Robot&quot;
</p>
</li>
<li> <p><strong>Appearances</strong>: integer, in how many comic book issues they appeared in
</p>
</li>
<li> <p><strong>Attractive</strong>: binary integer, 41 1 (yes) and 12 0 (no)
</p>
</li>
<li> <p><strong>Rich</strong>: binary integer, 11 1 (yes) and 42 0 (no)
</p>
</li>
<li> <p><strong>Intellect</strong>: binary integer, 39 1 (yes) and 14 0 (no)
</p>
</li>
<li> <p><strong>Omnilingual</strong>: binary integer, 8 1 (yes) and 45 0 (no)
</p>
</li>
<li> <p><strong>UnarmedCombat</strong>: binary integer, 51 1 (yes) and 2 0 (no)
</p>
</li>
<li> <p><strong>ArmedCombat</strong>: binary integer, 25 1 (yes) and 28 0 (no)
</p>
</li></ul>



<h3>Source</h3>

<p>Umut Yuksel, 31 March 2017
</p>

<hr>
<h2 id='ison_monks'>Multiplex network of three one-mode signed, weighted networks and a three-wave longitudinal network of monks (Sampson 1969)</h2><span id='topic+ison_monks'></span>

<h3>Description</h3>

<p>The data were collected for an ethnographic study of community structure in a New England monastery.
Various sociometric data was collected of the novices attending the minor seminary of 'Cloisterville'
preparing to join the monastic order.
</p>

<ul>
<li> <p><code>type = "like"</code> records whom novices said they liked most at three time points/waves
</p>
</li>
<li> <p><code>type = "esteem"</code> records whom novices said they held in esteem (sign &gt; 0) and disesteem (sign &lt; 0)
</p>
</li>
<li> <p><code>type = "praise"</code> records whom novices said they praised (sign &gt; 0) and blamed (sign &lt; 0)
</p>
</li>
<li> <p><code>type = "influence"</code> records whom novices said were a positive influence (sign &gt; 0) and negative influence (sign &lt; 0)
</p>
</li></ul>

<p>All networks are weighted.
Novices' first choices are weighted 3, the second 2, and third choices 1.
Some subjects offered tied ranks for their top four choices.
</p>
<p>In addition to node names,
a 'groups' variable records the four groups that Sampson observed during his time there:
</p>

<ul>
<li><p> The <em>Loyal</em> Opposition consists of novices who entered the monastery first and defended existing practices
</p>
</li>
<li><p> The <em>Young Turks</em> arrived later during a period of change and questioned practices in the monastery
</p>
</li>
<li><p> The <em>Interstitial</em> did not take sides in the debate
</p>
</li>
<li><p> The <em>Outcasts</em> were novices that were not accepted in the group
</p>
</li></ul>

<p>Information about senior monks was not included.
While <code>type = "like"</code> is observed over three waves,
the rest of the data was recorded retrospectively from the end of the study,
after the network fragmented.
The waves in which the novitiates were expelled (1), voluntarily departed (2 and 3),
or remained (4) are given in the nodal attribute &quot;left&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_monks)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A longitudinal, labelled, multiplex, signed, weighted, directed network of 18
#&gt; nodes and 463 like, esteem, influence, and praise arcs
#&gt; # A tibble: 18 x 3
#&gt;   name        groups        left
#&gt;   &lt;chr&gt;       &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1 Romuald     Interstitial     3
#&gt; 2 Bonaventure Loyal            4
#&gt; 3 Ambrose     Loyal            4
#&gt; 4 Berthold    Loyal            4
#&gt; 5 Peter       Loyal            3
#&gt; 6 Louis       Loyal            4
#&gt; # i 12 more rows
#&gt; # A tibble: 463 x 6
#&gt;    from    to  sign type  weight  wave
#&gt;   &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     1     2     1 like       1     2
#&gt; 2     1     2     1 like       1     3
#&gt; 3     1     3     1 like       1     3
#&gt; 4     1     5     1 like       3     1
#&gt; 5     1     5     1 like       3     2
#&gt; 6     1     5     1 like       3     3
#&gt; # i 457 more rows
</pre></div>


<h3>References</h3>

<p>Sampson, Samuel F. 1969. <em>Crisis in a cloister</em>.
Unpublished doctoral dissertation, Cornell University.
</p>
<p>Breiger R., Boorman S. and Arabie P. 1975.
&quot;An algorithm for clustering relational data with applications to social network analysis and comparison with multidimensional scaling&quot;.
<em>Journal of Mathematical Psychology</em>, 12: 328-383.
</p>

<hr>
<h2 id='ison_networkers'>One-mode EIES dataset (Freeman and Freeman 1979)</h2><span id='topic+ison_networkers'></span>

<h3>Description</h3>

<p>A directed, simple, named, weighted graph with 32 nodes and 440
edges. Nodes are academics and edges illustrate the communication patterns
on an Electronic Information Exchange System among them. Node attributes
include the number of citations (<code>Citations</code>) and the discipline of the
researchers (<code>Discipline</code>). Edge weights illustrate the number of emails
sent from one academic to another over the studied time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_networkers)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # A labelled, weighted, directed network of 32 nodes and 440 arcs
#&gt; # A tibble: 32 x 3
#&gt;   name               Discipline   Citations
#&gt;   &lt;chr&gt;              &lt;chr&gt;            &lt;dbl&gt;
#&gt; 1 Lin Freeman        Sociology           19
#&gt; 2 Doug White         Anthropology         3
#&gt; 3 Ev Rogers          Other              170
#&gt; 4 Richard Alba       Sociology           23
#&gt; 5 Phipps Arabie      Other               16
#&gt; 6 Carol Barner-Barry Other                6
#&gt; # i 26 more rows
#&gt; # A tibble: 440 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
#&gt; 1     1     2    488
#&gt; 2     1     3     28
#&gt; 3     1     4     65
#&gt; 4     1     5     20
#&gt; 5     1     6     65
#&gt; 6     1     7     45
#&gt; # i 434 more rows
</pre></div>


<h3>Source</h3>

<p>networkdata package
</p>


<h3>References</h3>

<p>Freeman, Sue C. and Linton C. Freeman. 1979.
<em>The networkers network: A study of the impact of a new communications medium on sociometric structure</em>.
Social Science Research Reports No 46. Irvine CA, University of California.
</p>
<p>Wasserman Stanley and Katherine Faust. 1994.
<em>Social Network Analysis: Methods and Applications</em>.
Cambridge University Press, Cambridge.
</p>

<hr>
<h2 id='ison_physicians'>Four multiplex one-mode physician diffusion data (Coleman, Katz, and Menzel, 1966)</h2><span id='topic+ison_physicians'></span>

<h3>Description</h3>

<p>Ron Burt prepared this data from
Coleman, Katz and Menzel's 1966 study on medical innovation.
They had collected data from physicians in four towns in Illinois:
Peoria, Bloomington, Quincy and Galesburg.
These four networks are held as separate networks in a list.
</p>
<p>Coleman, Katz and Menzel were concerned with the impact of network ties
on the physicians' adoption of a new drug, tetracycline.
Data on three types of ties were collected in response to three questions:
</p>

<ul>
<li><p> advice: &quot;When you need information or advice about questions of therapy
where do you usually turn?&quot;
</p>
</li>
<li><p> discussion: &quot;And who are the three or four physicians with whom you most often find yourself
discussing cases or therapy in the course of an ordinary week – last week for instance?&quot;
</p>
</li>
<li><p> friendship: &quot;Would you tell me the first names of your three friends
whom you see most often socially?&quot;
</p>
</li></ul>

<p>Additional questions and records of prescriptions provided additional information:
</p>

<ul>
<li><p> recorded date of tetracycline <code>adoption</code> date
</p>
</li>
<li><p> years in <code>practice</code>
(note that these are <code>{messydates}</code>-compatible dates)
</p>
</li>
<li> <p><code>conferences</code> attended
(those that attended &quot;Specialty&quot; conferences presumably also attended &quot;General&quot; conferences)
</p>
</li>
<li><p> regular subscriptions to medical <code>journals</code>
</p>
</li>
<li> <p><code>free_time</code> spent associating with doctors
</p>
</li>
<li> <p><code>discussions</code> on medical matters when with other doctors sociallyy
</p>
</li>
<li><p> memberships in <code>clubs</code> with other doctores
</p>
</li>
<li><p> number of top 3 <code>friends</code> that are doctors
</p>
</li>
<li><p> time practicing in current <code>community</code>
</p>
</li>
<li> <p><code>patients</code> load (ordinal)
</p>
</li>
<li><p> physical <code>proximity</code> to other physicians (in building/sharing office)
</p>
</li>
<li><p> medical <code>specialty</code> (GP/Internist/Pediatrician/Other)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(ison_physicians)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; $Peoria
#&gt; # A multiplex, directed network of 117 nodes and 543 friendship, advice, and
#&gt; discussion arcs
#&gt; # A tibble: 117 x 12
#&gt;   adoption specialty    conferences journals practice   community patients
#&gt;      &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;   
#&gt; 1        1 Pediatrician Specialty          9 1920..1929 20+yrs    101-150 
#&gt; 2       12 GP           None               5 1945..     -1yr      76-100  
#&gt; 3        8 Internist    General            7 1935..1939 10-20yrs  76-100  
#&gt; 4        9 GP           General            6 1940..1944 5-10yrs   51-75   
#&gt; 5        9 GP           General            4 1935..1939 10-20yrs  51-75   
#&gt; 6       10 Internist    None               7 1930..1934 10-20yrs  101-150 
#&gt; # i 111 more rows
#&gt; # i 5 more variables: doc_freetime &lt;dbl&gt;, doc_discuss &lt;dbl&gt;, doc_friends &lt;dbl&gt;,
#&gt; #   doc_club &lt;dbl&gt;, doc_proximity &lt;chr&gt;
#&gt; # A tibble: 543 x 3
#&gt;    from    to type      
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;     
#&gt; 1     1     8 friendship
#&gt; 2     1    58 friendship
#&gt; 3     1    87 advice    
#&gt; 4     1    90 advice    
#&gt; 5     1   110 advice    
#&gt; 6     1   112 friendship
#&gt; # i 537 more rows
#&gt; 
#&gt; $Bloomington
#&gt; # A multiplex, directed network of 50 nodes and 211 friendship, discussion, and
#&gt; advice arcs
#&gt; # A tibble: 50 x 12
#&gt;   adoption specialty conferences journals practice   community patients
#&gt;      &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;   
#&gt; 1       98 Internist Specialty          8 1930..1934 10-20yrs  101-150 
#&gt; 2        1 GP        General            3 1945..     5-10yrs   76-100  
#&gt; 3       98 GP        Specialty          4 1930..1934 10-20yrs  101-150 
#&gt; 4        7 Internist None               3 1945..     -1yr      26-50   
#&gt; 5        6 Internist General            9 1935..1939 5-10yrs   76-100  
#&gt; 6        1 GP        Specialty          5 1935..1939 10-20yrs  101-150 
#&gt; # i 44 more rows
#&gt; # i 5 more variables: doc_freetime &lt;dbl&gt;, doc_discuss &lt;dbl&gt;, doc_friends &lt;dbl&gt;,
#&gt; #   doc_club &lt;dbl&gt;, doc_proximity &lt;chr&gt;
#&gt; # A tibble: 211 x 3
#&gt;    from    to type      
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;     
#&gt; 1     1     3 friendship
#&gt; 2     1    10 discussion
#&gt; 3     1    24 advice    
#&gt; 4     1    44 advice    
#&gt; 5     2     4 advice    
#&gt; 6     2     6 advice    
#&gt; # i 205 more rows
#&gt; 
#&gt; $Quincy
#&gt; # A multiplex, directed network of 44 nodes and 174 advice, discussion, and
#&gt; friendship arcs
#&gt; # A tibble: 44 x 12
#&gt;   adoption specialty conferences journals practice   community patients
#&gt;      &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;   
#&gt; 1        2 Internist None               6 1935..1939 10-20yrs  151+    
#&gt; 2       18 GP        General            3 1920..1929 20+yrs    151+    
#&gt; 3       18 Internist None               5 1945..     -1yr      -25     
#&gt; 4        4 GP        General            3 1930..1934 20+yrs    151+    
#&gt; 5       18 GP        Specialty          4 1935..1939 10-20yrs  151+    
#&gt; 6        5 Internist General            5 ..1919     20+yrs    51-75   
#&gt; # i 38 more rows
#&gt; # i 5 more variables: doc_freetime &lt;dbl&gt;, doc_discuss &lt;dbl&gt;, doc_friends &lt;dbl&gt;,
#&gt; #   doc_club &lt;dbl&gt;, doc_proximity &lt;chr&gt;
#&gt; # A tibble: 174 x 3
#&gt;    from    to type      
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;     
#&gt; 1     1     8 advice    
#&gt; 2     1     9 advice    
#&gt; 3     1    10 discussion
#&gt; 4     1    13 friendship
#&gt; 5     1    15 advice    
#&gt; 6     1    22 discussion
#&gt; # i 168 more rows
#&gt; 
#&gt; $Galesburg
#&gt; # A multiplex, directed network of 35 nodes and 171 advice, discussion, and
#&gt; friendship arcs
#&gt; # A tibble: 35 x 12
#&gt;   adoption specialty conferences journals practice   community patients
#&gt;      &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;   
#&gt; 1       18 GP        General            4 1935..1939 5-10yrs   101-150 
#&gt; 2       18 GP        None               4 1935..1939 -1yr      151+    
#&gt; 3        4 GP        General            6 1945..     2-5yrs    51-75   
#&gt; 4        5 GP        None               4 1935..1939 10-20yrs  101-150 
#&gt; 5        8 Internist General            6 1935..1939 5-10yrs   151+    
#&gt; 6        4 Internist Specialty          8 ..1919     20+yrs    76-100  
#&gt; # i 29 more rows
#&gt; # i 5 more variables: doc_freetime &lt;dbl&gt;, doc_discuss &lt;dbl&gt;, doc_friends &lt;dbl&gt;,
#&gt; #   doc_club &lt;dbl&gt;, doc_proximity &lt;chr&gt;
#&gt; # A tibble: 171 x 3
#&gt;    from    to type      
#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;     
#&gt; 1     1     5 advice    
#&gt; 2     1     6 advice    
#&gt; 3     1    20 discussion
#&gt; 4     1    23 discussion
#&gt; 5     1    30 friendship
#&gt; 6     1    31 friendship
#&gt; # i 165 more rows
</pre></div>


<h3>Source</h3>

<p><code>{networkdata}</code>
</p>


<h3>References</h3>

<p>Coleman, James, Elihu Katz, and Herbert Menzel. 1966.
<em>Medical innovation: A diffusion study</em>.
Indianapolis: The Bobbs-Merrill Company.
</p>

<hr>
<h2 id='ison_southern_women'>Two-mode southern women (Davis, Gardner and Gardner 1941)</h2><span id='topic+ison_southern_women'></span>

<h3>Description</h3>

<p>Two-mode network dataset collected by Davis, Gardner and Gardner (1941)
about the pattern of a group of women's participation
at informal social events in Old City during a 9 month period,
as reported in the <em>Old City Herald</em> in 1936.
By convention, the nodes are named by the women's first names
and the code numbers of the events,
but the women's surnames and titles (Miss, Mrs.) are recorded here too.
The events' dates are recorded in place of the Surname,
and these dates are also offered as a tie attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_southern_women)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; # Southern Women Data
#&gt; # A labelled, two-mode network of 18 women and 14 social events and 89
#&gt; participation ties
#&gt; # A tibble: 32 x 4
#&gt;   type  name      Surname    Title
#&gt;   &lt;lgl&gt; &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;
#&gt; 1 FALSE Evelyn    Jefferson  Mrs  
#&gt; 2 FALSE Laura     Mandeville Miss 
#&gt; 3 FALSE Theresa   Anderson   Miss 
#&gt; 4 FALSE Brenda    Rogers     Miss 
#&gt; 5 FALSE Charlotte McDowd     Miss 
#&gt; 6 FALSE Frances   Anderson   Miss 
#&gt; # i 26 more rows
#&gt; # A tibble: 89 x 3
#&gt;    from    to date      
#&gt;   &lt;int&gt; &lt;int&gt; &lt;date&gt;    
#&gt; 1    14    29 1936-02-23
#&gt; 2    15    29 1936-02-23
#&gt; 3    17    29 1936-02-23
#&gt; 4    18    29 1936-02-23
#&gt; 5     1    23 1936-02-25
#&gt; 6     2    23 1936-02-25
#&gt; # i 83 more rows
</pre></div>


<h3>References</h3>

<p>Davis, Allison, Burleigh B. Gardner, and Mary R. Gardner. 1941.
<em>Deep South</em>.
Chicago: University of Chicago Press.
</p>

<hr>
<h2 id='ison_starwars'>Seven one-mode Star Wars character interactions (Gabasova 2016)</h2><span id='topic+ison_starwars'></span>

<h3>Description</h3>

<p>One-mode network dataset collected by Gabasova (2016)
on the interactions between Star Wars characters in each movie from
Episode 1 (The Phantom Menace) to Episode 7 (The Force Awakens).
There is a separate network for each episode,
and the data is listed in order from episode 1 to 7.
The network for each episode varies in the number of nodes and ties.
For all networks, characters are named (eg. R2-D2, Anakin, Chewbacca)
and the following node attributes are provided where available:
height, mass, hair color, skin color, eye color, birth year, sex, homeworld, and species.
The node attribute 'faction' has also been added,
denoting the faction (eg. Jedi, Rebel Alliance, etc)
that Star Wars characters belong to in each episode
(coding completed with help of Yichen Shen and Tiphaine Aeby).
Weighted ties represent the number of times characters speak
within the same scene of the film.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ison_starwars)
</code></pre>


<h3>Format</h3>

<div class="sourceCode"><pre>#&gt; $`Episode I`
#&gt; # A labelled, weighted, undirected network of 38 nodes and 135 ties
#&gt; # A tibble: 38 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 R2-D2      96    32 &lt;NA&gt;       white, bl~ red               33 none  Naboo    
#&gt; 2 QUI-G~    193    89 brown      fair       blue              92 male  &lt;NA&gt;     
#&gt; 3 NUTE ~    191    90 none       mottled g~ red               NA male  Cato Nei~
#&gt; 4 PK-4       NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;              NA &lt;NA&gt;  &lt;NA&gt;     
#&gt; 5 TC-14      NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;              NA &lt;NA&gt;  &lt;NA&gt;     
#&gt; 6 OBI-W~    182    77 auburn, w~ fair       blue-gray         57 male  Stewjon  
#&gt; # i 32 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 135 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     1    16     11
#&gt; 2     1     2     14
#&gt; 3     1    19     16
#&gt; 4     1    18      3
#&gt; 5     1    23      2
#&gt; 6     1    25      2
#&gt; # i 129 more rows
#&gt; 
#&gt; $`Episode II`
#&gt; # A labelled, weighted, undirected network of 33 nodes and 101 ties
#&gt; # A tibble: 33 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 R2-D2      96    32 &lt;NA&gt;       white, bl~ red               33 none  Naboo    
#&gt; 2 CAPTA~    185    85 black      dark       brown             NA male  Naboo    
#&gt; 3 EMPER~    170    75 grey       pale       yellow            82 male  Naboo    
#&gt; 4 SENAT~     NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;              NA &lt;NA&gt;  &lt;NA&gt;     
#&gt; 5 ORN F~     NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;              NA &lt;NA&gt;  &lt;NA&gt;     
#&gt; 6 MACE ~    188    84 none       dark       brown             72 male  Haruun K~
#&gt; # i 27 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 101 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     1    13      7
#&gt; 2     1    12      7
#&gt; 3     1    24      3
#&gt; 4     3     4      2
#&gt; 5     3     5      2
#&gt; 6     4     5      1
#&gt; # i 95 more rows
#&gt; 
#&gt; $`Episode III`
#&gt; # A labelled, weighted, undirected network of 24 nodes and 65 ties
#&gt; # A tibble: 24 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 R2-D2      96    32 &lt;NA&gt;       white, bl~ red             33   none  Naboo    
#&gt; 2 ANAKIN    188    84 blond      fair       blue            41.9 male  Tatooine 
#&gt; 3 OBI-W~    182    77 auburn, w~ fair       blue-gray       57   male  Stewjon  
#&gt; 4 ODD B~     NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;            NA   &lt;NA&gt;  &lt;NA&gt;     
#&gt; 5 GENER~    216   159 none       brown, wh~ green, y~       NA   male  Kalee    
#&gt; 6 EMPER~    170    75 grey       pale       yellow          82   male  Naboo    
#&gt; # i 18 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 65 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     1     6      2
#&gt; 2     1     3     12
#&gt; 3     1     2      9
#&gt; 4     1     9      5
#&gt; 5     1     8      4
#&gt; 6     1    10      4
#&gt; # i 59 more rows
#&gt; 
#&gt; $`Episode IV`
#&gt; # A labelled, weighted, undirected network of 21 nodes and 60 ties
#&gt; # A tibble: 21 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 R2-D2      96    32 &lt;NA&gt;       white, bl~ red             33   none  Naboo    
#&gt; 2 CHEWB~    228   112 brown      unknown    blue           200   male  Kashyyyk 
#&gt; 3 C-3PO     167    75 &lt;NA&gt;       gold       yellow         112   none  Tatooine 
#&gt; 4 LUKE      172    77 blond      fair       blue            19   male  Tatooine 
#&gt; 5 DARTH~    202   136 none       white      yellow          41.9 male  Tatooine 
#&gt; 6 CAMIE      NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;            NA   &lt;NA&gt;  &lt;NA&gt;     
#&gt; # i 15 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 60 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     1     2      3
#&gt; 2     1     3     17
#&gt; 3     1     9      1
#&gt; 4     1     4     14
#&gt; 5     1    10      1
#&gt; 6     1    11      4
#&gt; # i 54 more rows
#&gt; 
#&gt; $`Episode V`
#&gt; # A labelled, weighted, undirected network of 21 nodes and 55 ties
#&gt; # A tibble: 21 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 R2-D2      96    32 &lt;NA&gt;       white, bl~ red               33 none  Naboo    
#&gt; 2 CHEWB~    228   112 brown      unknown    blue             200 male  Kashyyyk 
#&gt; 3 LUKE      172    77 blond      fair       blue              19 male  Tatooine 
#&gt; 4 HAN       180    80 brown      fair       brown             29 male  Corellia 
#&gt; 5 RIEEK~     NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;              NA &lt;NA&gt;  &lt;NA&gt;     
#&gt; 6 LEIA      150    49 brown      light      brown             19 fema~ Alderaan 
#&gt; # i 15 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 55 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     1     2      5
#&gt; 2     1     7     10
#&gt; 3     1     3      7
#&gt; 4     1     4      4
#&gt; 5     1     6      5
#&gt; 6     1    21      1
#&gt; # i 49 more rows
#&gt; 
#&gt; $`Episode VI`
#&gt; # A labelled, weighted, undirected network of 20 nodes and 55 ties
#&gt; # A tibble: 20 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 R2-D2      96    32 &lt;NA&gt;       white, bl~ red             33   none  Naboo    
#&gt; 2 CHEWB~    228   112 brown      unknown    blue           200   male  Kashyyyk 
#&gt; 3 JERJE~     NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;            NA   &lt;NA&gt;  &lt;NA&gt;     
#&gt; 4 DARTH~    202   136 none       white      yellow          41.9 male  Tatooine 
#&gt; 5 C-3PO     167    75 &lt;NA&gt;       gold       yellow         112   none  Tatooine 
#&gt; 6 BIB F~    180    NA none       pale       pink            NA   male  Ryloth   
#&gt; # i 14 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 55 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     1     2      8
#&gt; 2     1     5     14
#&gt; 3     1    12      2
#&gt; 4     1     7      2
#&gt; 5     1     8      8
#&gt; 6     1    10      9
#&gt; # i 49 more rows
#&gt; 
#&gt; $`Episode VII`
#&gt; # A labelled, weighted, undirected network of 27 nodes and 92 ties
#&gt; # A tibble: 27 x 11
#&gt;   name   height  mass hair_color skin_color eye_color birth_year sex   homeworld
#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
#&gt; 1 LUKE      172    77 blond      fair       blue              19 male  Tatooine 
#&gt; 2 R2-D2      96    32 &lt;NA&gt;       white, bl~ red               33 none  Naboo    
#&gt; 3 CHEWB~    228   112 brown      unknown    blue             200 male  Kashyyyk 
#&gt; 4 BB-8       NA    NA none       none       black             NA none  &lt;NA&gt;     
#&gt; 5 LOR S~     NA    NA &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;              NA &lt;NA&gt;  &lt;NA&gt;     
#&gt; 6 POE        NA    NA brown      light      brown             NA male  &lt;NA&gt;     
#&gt; # i 21 more rows
#&gt; # i 2 more variables: species &lt;chr&gt;, faction &lt;chr&gt;
#&gt; # A tibble: 92 x 3
#&gt;    from    to weight
#&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt;
#&gt; 1     2     3      1
#&gt; 2     2     4      2
#&gt; 3     3     4      9
#&gt; 4     2    18      2
#&gt; 5     3     9     20
#&gt; 6     3    11     13
#&gt; # i 86 more rows
</pre></div>


<h3>Details</h3>

<p>The network for each episode may be extracted and used separately,
eg. <code>ison_starwars[[1]]</code> or <code style="white-space: pre;">&#8288;ison_starwars$Episode I&#8288;</code> for Episode 1.
</p>


<h3>References</h3>

<p>Gabasova, E. (2016).
<em>Star Wars social network.</em>.
<a href="https://doi.org/10.5281/zenodo.1411479">doi:10.5281/zenodo.1411479</a>
</p>

<hr>
<h2 id='make_cran'>Making networks of package dependencies</h2><span id='topic+make_cran'></span><span id='topic+read_cran'></span>

<h3>Description</h3>

<p>Researchers regularly need to work with a variety of external data formats.
The following functions offer ways to import from some common external
file formats into objects that <code>{manynet}</code> and other graph/network packages
in R can work with:
</p>

<ul>
<li> <p><code>read_matrix()</code> imports adjacency matrices from Excel/csv files.
</p>
</li>
<li> <p><code>read_edgelist()</code> imports edgelists from Excel/csv files.
</p>
</li>
<li> <p><code>read_nodelist()</code> imports nodelists from Excel/csv files.
</p>
</li>
<li> <p><code>read_pajek()</code> imports Pajek (.net or .paj) files.
</p>
</li>
<li> <p><code>read_ucinet()</code> imports UCINET files from the header (.##h).
</p>
</li>
<li> <p><code>read_dynetml()</code> imports DyNetML interchange format for rich social network data.
</p>
</li>
<li> <p><code>read_graphml()</code> imports GraphML files.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>read_cran(pkg = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_cran_+3A_pkg">pkg</code></td>
<td>
<p>The name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that these functions are not as actively maintained as others
in the package, so please let us know if any are not currently working
for you or if there are missing import routines
by <a href="https://github.com/stocnet/manynet/issues">raising an issue on Github</a>.
</p>


<h3>Source</h3>

<p>https://www.r-bloggers.com/2016/01/r-graph-objects-igraph-vs-network/
</p>


<h3>See Also</h3>

<p><a href="methods.html#topic+as">as</a>
</p>
<p>Other makes: 
<code><a href="#topic+make_create">make_create</a></code>,
<code><a href="#topic+make_ego">make_ego</a></code>,
<code><a href="#topic+make_explicit">make_explicit</a></code>,
<code><a href="#topic+make_learning">make_learning</a></code>,
<code><a href="#topic+make_motifs">make_motifs</a></code>,
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+make_random">make_random</a></code>,
<code><a href="#topic+make_read">make_read</a></code>,
<code><a href="#topic+make_stochastic">make_stochastic</a></code>,
<code><a href="#topic+make_write">make_write</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># mnet &lt;- read_cran()
# mnet &lt;- to_ego(mnet, "manynet", max_dist = 2)
# graphr(mnet, layout = "hierarchy", 
#        edge_color = "type", node_color = "Compilation")
</code></pre>

<hr>
<h2 id='make_create'>Making networks with defined structures</h2><span id='topic+make_create'></span><span id='topic+create_empty'></span><span id='topic+create_filled'></span><span id='topic+create_ring'></span><span id='topic+create_star'></span><span id='topic+create_tree'></span><span id='topic+create_lattice'></span><span id='topic+create_components'></span><span id='topic+create_degree'></span><span id='topic+create_core'></span>

<h3>Description</h3>

<p>These functions create networks with particular structural properties.
</p>

<ul>
<li> <p><code>create_empty()</code> creates an empty network without any ties.
</p>
</li>
<li> <p><code>create_filled()</code> creates a filled network with every possible tie realised.
</p>
</li>
<li> <p><code>create_ring()</code> creates a ring or chord network where each nodes'
neighbours form a clique.
</p>
</li>
<li> <p><code>create_star()</code> creates a network with a maximally central node.
</p>
</li>
<li> <p><code>create_tree()</code> creates a network with successive branches.
</p>
</li>
<li> <p><code>create_lattice()</code> creates a network that forms a regular tiling.
</p>
</li>
<li> <p><code>create_components()</code> creates a network that clusters nodes into separate components.
</p>
</li>
<li> <p><code>create_core()</code> creates a network in which a certain proportion of 'core' nodes
are densely tied to each other, and the rest peripheral, tied only to the core.
</p>
</li>
<li> <p><code>create_degree()</code> creates a network with a given (out/in)degree sequence,
which can also be used to create k-regular networks.
</p>
</li></ul>

<p>These functions can create either one-mode or two-mode networks.
To create a one-mode network, pass the main argument <code>n</code> a single integer,
indicating the number of nodes in the network.
To create a two-mode network, pass <code>n</code> a vector of <em>two</em> integers,
where the first integer indicates the number of nodes in the first mode,
and the second integer indicates the number of nodes in the second mode.
As an alternative, an existing network can be provided to <code>n</code>
and the number of modes, nodes, and directedness will be inferred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_empty(n, directed = FALSE)

create_filled(n, directed = FALSE)

create_ring(n, directed = FALSE, width = 1, ...)

create_star(n, directed = FALSE)

create_tree(n, directed = FALSE, width = 2)

create_lattice(n, directed = FALSE, width = 8)

create_components(n, directed = FALSE, membership = NULL)

create_degree(n, outdegree = NULL, indegree = NULL)

create_core(n, directed = FALSE, mark = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_create_+3A_n">n</code></td>
<td>
<p>Given:
</p>

<ul>
<li><p> A single integer, e.g. <code>n = 10</code>,
a one-mode network will be created.
</p>
</li>
<li><p> A vector of two integers, e.g. <code>n = c(5,10)</code>,
a two-mode network will be created.
</p>
</li>
<li><p> A manynet-compatible object,
a network of the same dimensions will be created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_create_+3A_directed">directed</code></td>
<td>
<p>Logical whether the graph should be directed.
By default <code>directed = FALSE</code>.
If the opposite direction is desired,
use <code>to_redirected()</code> on the output of these functions.</p>
</td></tr>
<tr><td><code id="make_create_+3A_width">width</code></td>
<td>
<p>Integer specifying the width of the ring,
breadth of the branches, or maximum extent of the neighbourbood.</p>
</td></tr>
<tr><td><code id="make_create_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>igraph::make_ring()</code>.</p>
</td></tr>
<tr><td><code id="make_create_+3A_membership">membership</code></td>
<td>
<p>A vector of partition membership as integers.
If left as <code>NULL</code> (the default), nodes in each mode will be
assigned to two, equally sized partitions.</p>
</td></tr>
<tr><td><code id="make_create_+3A_outdegree">outdegree</code></td>
<td>
<p>Numeric scalar or vector indicating the
desired outdegree distribution.
By default NULL and is required.
If <code>n</code> is an existing network object and the outdegree is not specified,
then the outdegree distribution will be inferred from that of the network.
Note that a scalar (single number) will result in a k-regular graph.</p>
</td></tr>
<tr><td><code id="make_create_+3A_indegree">indegree</code></td>
<td>
<p>Numeric vector indicating the desired indegree distribution.
By default NULL but not required unless a directed network is desired.
If <code>n</code> is an existing directed network object and the indegree is not specified,
then the indegree distribution will be inferred from that of the network.</p>
</td></tr>
<tr><td><code id="make_create_+3A_mark">mark</code></td>
<td>
<p>A logical vector the length of the nodes in the network.
This can be created by, among other things, any <code style="white-space: pre;">&#8288;node_is_*()&#8288;</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default a <code>tbl_graph</code> object is returned,
but this can be coerced into other types of objects
using <code>as_edgelist()</code>, <code>as_matrix()</code>,
<code>as_tidygraph()</code>, or <code>as_network()</code>.
</p>
<p>By default, all networks are created as undirected.
This can be overruled with the argument <code>directed = TRUE</code>.
This will return a directed network in which the arcs are
out-facing or equivalent.
This direction can be swapped using <code>to_redirected()</code>.
In two-mode networks, the directed argument is ignored.
</p>


<h3>Lattice graphs</h3>

<p><code>create_lattice()</code> creates both two-dimensional grid and triangular
lattices with as even dimensions as possible.
When the <code>width</code> parameter is set to 4, nodes cannot have (in or out)
degrees larger than 4.
This creates regular square grid lattices where possible.
Such a network is bipartite, that is partitionable into two types that are
not adjacent to any of their own type.
If the number of nodes is a prime number, it will only return a chain
(a single dimensional lattice).
</p>
<p>A <code>width</code> parameter of 8 creates a network where the maximum degree of any
nodes is 8.
This can create a triangular mesh lattice or a Queen's move lattice,
depending on the dimensions.
A <code>width</code> parameter of 12 creates a network where the maximum degree of
any nodes is 12.
Prime numbers of nodes will return a chain.
</p>


<h3>See Also</h3>

<p><a href="methods.html#topic+as">as</a>
</p>
<p>Other makes: 
<code><a href="#topic+make_cran">make_cran</a></code>,
<code><a href="#topic+make_ego">make_ego</a></code>,
<code><a href="#topic+make_explicit">make_explicit</a></code>,
<code><a href="#topic+make_learning">make_learning</a></code>,
<code><a href="#topic+make_motifs">make_motifs</a></code>,
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+make_random">make_random</a></code>,
<code><a href="#topic+make_read">make_read</a></code>,
<code><a href="#topic+make_stochastic">make_stochastic</a></code>,
<code><a href="#topic+make_write">make_write</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_empty(10)
create_filled(10)
create_ring(8, width = 2)
create_star(12)
create_tree(c(7,8))
create_lattice(12, width = 4)
create_components(10, membership = c(1,1,1,2,2,2,3,3,3,3))
create_degree(10, outdegree = rep(1:5, 2))
create_core(6)
</code></pre>

<hr>
<h2 id='make_ego'>Making ego networks through interviewing</h2><span id='topic+make_ego'></span><span id='topic+create_ego'></span>

<h3>Description</h3>

<p>This function creates an ego network through interactive interview questions.
Note that it only creates a simplex, directed network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_ego(
  max_alters = Inf,
  roster = NULL,
  interpreter = FALSE,
  interrelater = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_ego_+3A_max_alters">max_alters</code></td>
<td>
<p>The maximum number of alters to collect.
By default infinity, but many name generators will expect a maximum of
e.g. 5 alters to be named.</p>
</td></tr>
<tr><td><code id="make_ego_+3A_roster">roster</code></td>
<td>
<p>A vector of node names to offer as potential alters for ego.</p>
</td></tr>
<tr><td><code id="make_ego_+3A_interpreter">interpreter</code></td>
<td>
<p>Logical. If TRUE, then it will ask for which attributes
to collect and give prompts for each attribute for each node in the network.
By default FALSE.</p>
</td></tr>
<tr><td><code id="make_ego_+3A_interrelater">interrelater</code></td>
<td>
<p>Logical. If TRUE, then it will ask for the contacts from
each of the alters perspectives too.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other makes: 
<code><a href="#topic+make_cran">make_cran</a></code>,
<code><a href="#topic+make_create">make_create</a></code>,
<code><a href="#topic+make_explicit">make_explicit</a></code>,
<code><a href="#topic+make_learning">make_learning</a></code>,
<code><a href="#topic+make_motifs">make_motifs</a></code>,
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+make_random">make_random</a></code>,
<code><a href="#topic+make_read">make_read</a></code>,
<code><a href="#topic+make_stochastic">make_stochastic</a></code>,
<code><a href="#topic+make_write">make_write</a></code>
</p>

<hr>
<h2 id='make_explicit'>Making networks with explicit ties</h2><span id='topic+make_explicit'></span><span id='topic+create_explicit'></span>

<h3>Description</h3>

<p>This function creates a network from a vector of explicitly named nodes
and ties between them.
<code>create_explicit()</code> largely wraps <code>igraph::graph_from_literal()</code>,
but will also accept character input and not just a formula,
and will never simplify the result.
</p>
<p>Ties are indicated by <code>-</code>, and directed ties (arcs)
require <code>+</code> at either or both ends.
Ties are separated by commas, and isolates can be added as
an additional, unlinked node after the comma within the formula.
Sets of nodes can be linked to other sets of nodes through use of
a semi-colon.
See the example for a demonstration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_explicit(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_explicit_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>{igraph}</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other makes: 
<code><a href="#topic+make_cran">make_cran</a></code>,
<code><a href="#topic+make_create">make_create</a></code>,
<code><a href="#topic+make_ego">make_ego</a></code>,
<code><a href="#topic+make_learning">make_learning</a></code>,
<code><a href="#topic+make_motifs">make_motifs</a></code>,
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+make_random">make_random</a></code>,
<code><a href="#topic+make_read">make_read</a></code>,
<code><a href="#topic+make_stochastic">make_stochastic</a></code>,
<code><a href="#topic+make_write">make_write</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  create_explicit(A -+ B, B -+ C, A +-+ C, D, E:F:G-+A, E:F+-+G:H)
</code></pre>

<hr>
<h2 id='make_learning'>Making learning models on networks</h2><span id='topic+make_learning'></span><span id='topic+play_learning'></span><span id='topic+play_segregation'></span>

<h3>Description</h3>

<p>These functions allow learning games to be played upon networks.
</p>

<ul>
<li> <p><code>play_learning()</code> plays a DeGroot learning model upon a network.
</p>
</li>
<li> <p><code>play_segregation()</code> plays a Schelling segregation model upon a network.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>play_learning(.data, beliefs, steps, epsilon = 5e-04)

play_segregation(
  .data,
  attribute,
  heterophily = 0,
  who_moves = c("ordered", "random", "most_dissatisfied"),
  choice_function = c("satisficing", "optimising", "minimising"),
  steps
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_learning_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_learning_+3A_beliefs">beliefs</code></td>
<td>
<p>A vector indicating the probabilities nodes
put on some outcome being 'true'.</p>
</td></tr>
<tr><td><code id="make_learning_+3A_steps">steps</code></td>
<td>
<p>The number of steps forward in learning.
By default the number of nodes in the network.</p>
</td></tr>
<tr><td><code id="make_learning_+3A_epsilon">epsilon</code></td>
<td>
<p>The maximum difference in beliefs accepted
for convergence to a consensus.</p>
</td></tr>
<tr><td><code id="make_learning_+3A_attribute">attribute</code></td>
<td>
<p>A string naming some nodal attribute in the network.
Currently only tested for binary attributes.</p>
</td></tr>
<tr><td><code id="make_learning_+3A_heterophily">heterophily</code></td>
<td>
<p>A score ranging between -1 and 1 as a threshold for
how heterophilous nodes will accept their neighbours to be.
A single proportion means this threshold is shared by all nodes,
but it can also be a vector the same length of the nodes in the network
for issuing different thresholds to different nodes.
By default this is 0, meaning nodes will be dissatisfied if more than half
of their neighbours differ on the given attribute.</p>
</td></tr>
<tr><td><code id="make_learning_+3A_who_moves">who_moves</code></td>
<td>
<p>One of the following options:
&quot;ordered&quot; (the default) checks each node in turn for whether they are
dissatisfied and there is an available space that they can move to,
&quot;random&quot; will check a node at random,
and &quot;most_dissatisfied&quot; will check (one of) the most dissatisfied nodes first.</p>
</td></tr>
<tr><td><code id="make_learning_+3A_choice_function">choice_function</code></td>
<td>
<p>One of the following options:
&quot;satisficing&quot; (the default) will move the node to any coordinates that satisfy
their heterophily threshold,
&quot;optimising&quot; will move the node to coordinates that are most homophilous,
and &quot;minimising&quot; distance will move the node to the next nearest unoccupied coordinates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other makes: 
<code><a href="#topic+make_cran">make_cran</a></code>,
<code><a href="#topic+make_create">make_create</a></code>,
<code><a href="#topic+make_ego">make_ego</a></code>,
<code><a href="#topic+make_explicit">make_explicit</a></code>,
<code><a href="#topic+make_motifs">make_motifs</a></code>,
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+make_random">make_random</a></code>,
<code><a href="#topic+make_read">make_read</a></code>,
<code><a href="#topic+make_stochastic">make_stochastic</a></code>,
<code><a href="#topic+make_write">make_write</a></code>
</p>
<p>Other models: 
<code><a href="#topic+make_play">make_play</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  play_learning(ison_networkers, 
      rbinom(net_nodes(ison_networkers),1,prob = 0.25))
  startValues &lt;- rbinom(100,1,prob = 0.5)
  startValues[sample(seq_len(100), round(100*0.2))] &lt;- NA
  latticeEg &lt;- create_lattice(100)
  latticeEg &lt;- add_node_attribute(latticeEg, "startValues", startValues)
  latticeEg
  play_segregation(latticeEg, "startValues", 0.5)
  # graphr(latticeEg, node_color = "startValues", node_size = 5) + 
  # graphr(play_segregation(latticeEg, "startValues", 0.2), 
  #            node_color = "startValues", node_size = 5)
</code></pre>

<hr>
<h2 id='make_motifs'>Making motifs</h2><span id='topic+make_motifs'></span><span id='topic+create_motifs'></span>

<h3>Description</h3>

<p><code>create_motifs()</code> is used to create a list of networks that represent the
subgraphs or motifs corresponding to a certain number of nodes and direction.
Note that currently only <code>n==2</code> to <code>n==4</code> is implemented,
and the latter only for undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_motifs(n, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_motifs_+3A_n">n</code></td>
<td>
<p>Given:
</p>

<ul>
<li><p> A single integer, e.g. <code>n = 10</code>,
a one-mode network will be created.
</p>
</li>
<li><p> A vector of two integers, e.g. <code>n = c(5,10)</code>,
a two-mode network will be created.
</p>
</li>
<li><p> A manynet-compatible object,
a network of the same dimensions will be created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_motifs_+3A_directed">directed</code></td>
<td>
<p>Logical whether the graph should be directed.
By default <code>directed = FALSE</code>.
If the opposite direction is desired,
use <code>to_redirected()</code> on the output of these functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other makes: 
<code><a href="#topic+make_cran">make_cran</a></code>,
<code><a href="#topic+make_create">make_create</a></code>,
<code><a href="#topic+make_ego">make_ego</a></code>,
<code><a href="#topic+make_explicit">make_explicit</a></code>,
<code><a href="#topic+make_learning">make_learning</a></code>,
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+make_random">make_random</a></code>,
<code><a href="#topic+make_read">make_read</a></code>,
<code><a href="#topic+make_stochastic">make_stochastic</a></code>,
<code><a href="#topic+make_write">make_write</a></code>
</p>

<hr>
<h2 id='make_play'>Making diffusion models on networks</h2><span id='topic+make_play'></span><span id='topic+play_diffusion'></span><span id='topic+play_diffusions'></span>

<h3>Description</h3>

<p>These functions simulate diffusion or compartment models upon a network.
</p>

<ul>
<li> <p><code>play_diffusion()</code> runs a single simulation of a compartment model,
allowing the results to be visualised and examined.
</p>
</li>
<li> <p><code>play_diffusions()</code> runs multiple simulations of a compartment model
for more robust inference.
</p>
</li></ul>

<p>These functions allow both a full range of compartment models,
as well as simplex and complex diffusion to be simulated upon a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>play_diffusion(
  .data,
  seeds = 1,
  contact = NULL,
  prevalence = 0,
  thresholds = 1,
  transmissibility = 1,
  latency = 0,
  recovery = 0,
  waning = 0,
  immune = NULL,
  steps
)

play_diffusions(
  .data,
  seeds = 1,
  contact = NULL,
  prevalence = 0,
  thresholds = 1,
  transmissibility = 1,
  latency = 0,
  recovery = 0,
  waning = 0,
  immune = NULL,
  steps,
  times = 5,
  strategy = "sequential",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_play_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_play_+3A_seeds">seeds</code></td>
<td>
<p>A valid mark vector the length of the
number of nodes in the network.</p>
</td></tr>
<tr><td><code id="make_play_+3A_contact">contact</code></td>
<td>
<p>A matrix or network that replaces &quot;.data&quot; with some
other explicit contact network, e.g.
<code>create_components(.data, membership = node_in_structural(.data))</code>.
Can be of arbitrary complexity, but must of the same dimensions
as .data.</p>
</td></tr>
<tr><td><code id="make_play_+3A_prevalence">prevalence</code></td>
<td>
<p>The proportion that global prevalence contributes
to diffusion.
That is, if prevalence is 0.5, then the current number of infections
is multiplied by 0.5 and added
&quot;prevalence&quot; is 0 by default, i.e. there is no global mechanism.
Note that this is endogenously defined and is updated
at the outset of each step.</p>
</td></tr>
<tr><td><code id="make_play_+3A_thresholds">thresholds</code></td>
<td>
<p>A numeric vector indicating the thresholds
each node has. By default 1.
A single number means a generic threshold;
for thresholds that vary among the population please use a vector
the length of the number of nodes in the network.
If 1 or larger, the threshold is interpreted as a simple count
of the number of contacts/exposures sufficient for infection.
If less than 1, the threshold is interpreted as complex,
where the threshold concerns the proportion of contacts.</p>
</td></tr>
<tr><td><code id="make_play_+3A_transmissibility">transmissibility</code></td>
<td>
<p>The transmission rate probability,
<code class="reqn">\beta</code>.
By default 1, which means any node for which the threshold is met
or exceeded will become infected.
Anything lower means a correspondingly lower probability of adoption,
even when the threshold is met or exceeded.</p>
</td></tr>
<tr><td><code id="make_play_+3A_latency">latency</code></td>
<td>
<p>The inverse probability those who have been exposed
become infectious (infected), <code class="reqn">\sigma</code> or <code class="reqn">\kappa</code>.
For example, if exposed individuals take, on average,
four days to become infectious, then <code class="reqn">\sigma = 0.75</code> (1/1-0.75 = 1/0.25 = 4).
By default 0, which means those exposed become immediately infectious (i.e. an SI model).
Anything higher results in e.g. a SEI model.</p>
</td></tr>
<tr><td><code id="make_play_+3A_recovery">recovery</code></td>
<td>
<p>The probability those who are infected
recover, <code class="reqn">\gamma</code>.
For example, if infected individuals take, on average,
four days to recover, then <code class="reqn">\gamma = 0.25</code>.
By default 0, which means there is no recovery (i.e. an SI model).
Anything higher results in an SIR model.</p>
</td></tr>
<tr><td><code id="make_play_+3A_waning">waning</code></td>
<td>
<p>The probability those who are recovered
become susceptible again, <code class="reqn">\xi</code>.
For example, if recovered individuals take, on average,
four days to lose their immunity, then <code class="reqn">\xi = 0.25</code>.
By default 0, which means any recovered individuals retain lifelong immunity (i.e. an SIR model).
Anything higher results in e.g. a SIRS model.
<code class="reqn">\xi = 1</code> would mean there is no period of immunity, e.g. an SIS model.</p>
</td></tr>
<tr><td><code id="make_play_+3A_immune">immune</code></td>
<td>
<p>A logical or numeric vector identifying nodes
that begin the diffusion process as already recovered.
This could be interpreted as those who are vaccinated or equivalent.
Note however that a waning parameter will affect these nodes too.
By default NULL, indicating that no nodes begin immune.</p>
</td></tr>
<tr><td><code id="make_play_+3A_steps">steps</code></td>
<td>
<p>The number of steps forward in the diffusion to play.
By default the number of nodes in the network.
If <code>steps = Inf</code> then the diffusion process will continue until
there are no new infections or all nodes are infected.</p>
</td></tr>
<tr><td><code id="make_play_+3A_times">times</code></td>
<td>
<p>Integer indicating number of simulations.
By default <code>times=5</code>, but 1,000 - 10,000 simulations recommended for publication-ready results.</p>
</td></tr>
<tr><td><code id="make_play_+3A_strategy">strategy</code></td>
<td>
<p>If <code>{furrr}</code> is installed, then multiple cores can be used to accelerate the simulations.
By default &quot;sequential&quot;, but if multiple cores available, then &quot;multisession&quot; or &quot;multicore&quot; may be useful.
Generally this is useful only when times &gt; 1000. See <code>{furrr}</code> for more.</p>
</td></tr>
<tr><td><code id="make_play_+3A_verbose">verbose</code></td>
<td>
<p>Whether the function should report on its progress.
By default FALSE. See <code>{progressr}</code> for more.</p>
</td></tr>
</table>


<h3>Simple and complex diffusion</h3>

<p>By default, the function will simulate a simple diffusion process in
which some infectious disease or idea diffuses from seeds through
contacts at some constant rate (<code>transmissibility</code>).
</p>
<p>These <code>seeds</code> can be specified by a vector index
(the number of the position of each node in the network that should serve as a seed)
or as a logical vector where TRUE is interpreted as already infected.
</p>
<p><code>thresholds</code> can be set such that adoption/infection requires more than one
(the default) contact already being infected.
This parameter also accepts a vector so that thresholds can vary.
</p>
<p>Complex diffusion is where the <code>thresholds</code> are defined less than one.
In this case, the thresholds are interpreted as proportional.
That is, the threshold to adoption/infection is defined by the
proportion of the node's contacts infected.
</p>
<p>Nodes that cannot be infected can be indicated as <code>immune</code>
with a logical vector or index, similar to how <code>seeds</code> are identified.
Note that <code>immune</code> nodes are interpreted internally as Recovered (R)
and are thus subject to <code>waning</code> (see below).
</p>


<h3>Compartment models</h3>

<p>Compartment models are flexible models of diffusion or contagion,
where nodes are compartmentalised into one of two or more categories.
</p>
<p>The most basic model is the SI model.
The SI model is the default in <code>play_diffusion()</code>/<code>play_diffusions()</code>,
where nodes can only move from the Susceptible (S) category to the
Infected (I) category.
Whether nodes move from S to I depends on whether they are exposed
to the infection, for instance through a contact,
the <code>transmissibility</code> of the disease,
and their <code>thresholds</code> to the disease.
</p>
<p>Another common model is the SIR model.
Here nodes move from S to I, as above, but additionally they can
move from I to a Recovered (R) status.
The probability that an infected node recovers at a timepoint
is controlled by the <code>recovery</code> parameter.
</p>
<p>The next most common models are the SIS and SIRS models.
Here nodes move from S to I or additionally to R, as above,
but additionally they can move from I or R back to a Susceptible (S) state.
This probability is governed by the <code>waning</code> parameter.
Where <code>recover &gt; 0</code> and <code>waning = 1</code>, the Recovery (R) state will be skipped
and the node will return immediately to the Susceptible (S) compartment.
</p>
<p>Lastly, these functions also offer the possibility of specifying
a latency period in which nodes have been infected but are not yet infectious.
Where <code>latency &gt; 0</code>, an additional Exposed (E) compartment is introduced
that governs the probability that a node moves from this E compartment
to infectiousness (I).
This can be used in in SEI, SEIS, SEIR, and SEIRS models.
</p>


<h3>See Also</h3>

<p>Other makes: 
<code><a href="#topic+make_cran">make_cran</a></code>,
<code><a href="#topic+make_create">make_create</a></code>,
<code><a href="#topic+make_ego">make_ego</a></code>,
<code><a href="#topic+make_explicit">make_explicit</a></code>,
<code><a href="#topic+make_learning">make_learning</a></code>,
<code><a href="#topic+make_motifs">make_motifs</a></code>,
<code><a href="#topic+make_random">make_random</a></code>,
<code><a href="#topic+make_read">make_read</a></code>,
<code><a href="#topic+make_stochastic">make_stochastic</a></code>,
<code><a href="#topic+make_write">make_write</a></code>
</p>
<p>Other models: 
<code><a href="#topic+make_learning">make_learning</a></code>
</p>
<p>Other diffusion: 
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  smeg &lt;- generate_smallworld(15, 0.025)
  plot(play_diffusion(smeg, recovery = 0.4))
  #graphr(play_diffusion(ison_karateka))
# plot(play_diffusions(smeg, times = 10))
</code></pre>

<hr>
<h2 id='make_random'>Making unconditional and conditional random networks</h2><span id='topic+make_random'></span><span id='topic+generate_random'></span><span id='topic+generate_configuration'></span><span id='topic+generate_man'></span><span id='topic+generate_utilities'></span><span id='topic+generate_permutation'></span>

<h3>Description</h3>

<p>These functions are similar to the <code style="white-space: pre;">&#8288;create_*&#8288;</code> functions,
but include some element of randomisation.
They are particularly useful for creating a distribution of networks
for exploring or testing network properties.
</p>

<ul>
<li> <p><code>generate_random()</code> generates a random network with ties appearing at some probability.
</p>
</li>
<li> <p><code>generate_configuration()</code> generates a random network consistent with a
given degree distribution.
</p>
</li>
<li> <p><code>generate_man()</code> generates a random network conditional on the dyad census
of Mutual, Asymmetric, and Null dyads, respectively.
</p>
</li>
<li> <p><code>generate_utilities()</code> generates a random utility matrix.
</p>
</li></ul>

<p>These functions can create either one-mode or two-mode networks.
To create a one-mode network, pass the main argument <code>n</code> a single integer,
indicating the number of nodes in the network.
To create a two-mode network, pass <code>n</code> a vector of <em>two</em> integers,
where the first integer indicates the number of nodes in the first mode,
and the second integer indicates the number of nodes in the second mode.
As an alternative, an existing network can be provided to <code>n</code>
and the number of modes, nodes, and directedness will be inferred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random(n, p = 0.5, directed = FALSE, with_attr = TRUE)

generate_configuration(.data)

generate_man(n, man = NULL)

generate_utilities(n, steps = 1, volatility = 0, threshold = 0)

generate_permutation(.data, with_attr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_random_+3A_n">n</code></td>
<td>
<p>Given:
</p>

<ul>
<li><p> A single integer, e.g. <code>n = 10</code>,
a one-mode network will be created.
</p>
</li>
<li><p> A vector of two integers, e.g. <code>n = c(5,10)</code>,
a two-mode network will be created.
</p>
</li>
<li><p> A manynet-compatible object,
a network of the same dimensions will be created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_random_+3A_p">p</code></td>
<td>
<p>Proportion of possible ties in the network that are realised or,
if integer greater than 1, the number of ties in the network.</p>
</td></tr>
<tr><td><code id="make_random_+3A_directed">directed</code></td>
<td>
<p>Whether to generate network as directed. By default FALSE.</p>
</td></tr>
<tr><td><code id="make_random_+3A_with_attr">with_attr</code></td>
<td>
<p>Logical whether any attributes of the object
should be retained.
By default TRUE.</p>
</td></tr>
<tr><td><code id="make_random_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_random_+3A_man">man</code></td>
<td>
<p>Vector of Mutual, Asymmetric, and Null dyads, respectively.
Can be specified as proportions, e.g. <code>c(0.5, 0.5, 0.5)</code>,
or as a count, e.g. <code>c(10,0,20)</code>.
Is inferred from <code>n</code> if it is an existing network object.</p>
</td></tr>
<tr><td><code id="make_random_+3A_steps">steps</code></td>
<td>
<p>Number of simulation steps to run.
By default 1: a single, one-shot simulation.
If more than 1, further iterations will update the utilities
depending on the values of the volatility and threshold parameters.</p>
</td></tr>
<tr><td><code id="make_random_+3A_volatility">volatility</code></td>
<td>
<p>How much change there is between steps.
Only if volatility is more than 1 do further simulation steps make sense.
This is passed on to <code>stats::rnorm</code> as the <code>sd</code> or standard deviation
parameter.</p>
</td></tr>
<tr><td><code id="make_random_+3A_threshold">threshold</code></td>
<td>
<p>This parameter can be used to mute or disregard stepwise
changes in utility that are minor.
The default 0 will recognise all changes in utility,
but raising the threshold will mute any changes less than this threshold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default a <code>tbl_graph</code> object is returned,
but this can be coerced into other types of objects
using <code>as_edgelist()</code>, <code>as_matrix()</code>,
<code>as_tidygraph()</code>, or <code>as_network()</code>.
</p>
<p>By default, all networks are created as undirected.
This can be overruled with the argument <code>directed = TRUE</code>.
This will return a directed network in which the arcs are
out-facing or equivalent.
This direction can be swapped using <code>to_redirected()</code>.
In two-mode networks, the directed argument is ignored.
</p>


<h3>References</h3>



<h4>On random networks</h4>

<p>Erdos, Paul, and Alfred Renyi. 1959.
&quot;<a href="https://www.renyi.hu/~p_erdos/1959-11.pdf">On Random Graphs I</a>&quot;
<em>Publicationes Mathematicae</em>. 6: 290–297.
</p>



<h4>On configuration models</h4>

<p>Bollobas, Bela. 1980.
&quot;A Probabilistic Proof of an Asymptotic Formula for the Number of Labelled Regular Graphs&quot;.
<em>European Journal of Combinatorics</em> 1: 311-316.
</p>



<h4>On dyad-census conditioned networks</h4>

<p>Holland, Paul W., and Samuel Leinhardt. 1976.
“Local Structure in Social Networks.”
In D. Heise (Ed.), <em>Sociological Methodology</em>, pp 1-45.
San Francisco: Jossey-Bass.
</p>



<h3>See Also</h3>

<p>Other makes: 
<code><a href="#topic+make_cran">make_cran</a></code>,
<code><a href="#topic+make_create">make_create</a></code>,
<code><a href="#topic+make_ego">make_ego</a></code>,
<code><a href="#topic+make_explicit">make_explicit</a></code>,
<code><a href="#topic+make_learning">make_learning</a></code>,
<code><a href="#topic+make_motifs">make_motifs</a></code>,
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+make_read">make_read</a></code>,
<code><a href="#topic+make_stochastic">make_stochastic</a></code>,
<code><a href="#topic+make_write">make_write</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graphr(generate_random(12, 0.4))
# graphr(generate_random(c(6, 6), 0.4))
</code></pre>

<hr>
<h2 id='make_read'>Making networks from external files</h2><span id='topic+make_read'></span><span id='topic+read_matrix'></span><span id='topic+read_edgelist'></span><span id='topic+read_nodelist'></span><span id='topic+read_pajek'></span><span id='topic+read_ucinet'></span><span id='topic+read_dynetml'></span><span id='topic+read_graphml'></span><span id='topic+read_gml'></span>

<h3>Description</h3>

<p>Researchers regularly need to work with a variety of external data formats.
The following functions offer ways to import from some common external
file formats into objects that <code>{manynet}</code> and other graph/network packages
in R can work with:
</p>

<ul>
<li> <p><code>read_matrix()</code> imports adjacency matrices from Excel/csv files.
</p>
</li>
<li> <p><code>read_edgelist()</code> imports edgelists from Excel/csv files.
</p>
</li>
<li> <p><code>read_nodelist()</code> imports nodelists from Excel/csv files.
</p>
</li>
<li> <p><code>read_pajek()</code> imports Pajek (.net or .paj) files.
</p>
</li>
<li> <p><code>read_ucinet()</code> imports UCINET files from the header (.##h).
</p>
</li>
<li> <p><code>read_dynetml()</code> imports DyNetML interchange format for rich social network data.
</p>
</li>
<li> <p><code>read_graphml()</code> imports GraphML files.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>read_matrix(file = file.choose(), sv = c("comma", "semi-colon"), ...)

read_edgelist(file = file.choose(), sv = c("comma", "semi-colon"), ...)

read_nodelist(file = file.choose(), sv = c("comma", "semi-colon"), ...)

read_pajek(file = file.choose(), ties = NULL, ...)

read_ucinet(file = file.choose())

read_dynetml(file = file.choose())

read_graphml(file = file.choose())

read_gml(file = file.choose())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_read_+3A_file">file</code></td>
<td>
<p>A character string with the system path to the file to import.
If left unspecified, an OS-specific file picker is opened to help users select it.
Note that in <code>read_ucinet()</code> the file path should be to the header file (.##h),
if it exists and that it is currently not possible to import multiple
networks from a single UCINET file. Please convert these one by one.</p>
</td></tr>
<tr><td><code id="make_read_+3A_sv">sv</code></td>
<td>
<p>Allows users to specify whether their csv file is
<code>"comma"</code> (English) or <code>"semi-colon"</code> (European) separated.</p>
</td></tr>
<tr><td><code id="make_read_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the read/write function.</p>
</td></tr>
<tr><td><code id="make_read_+3A_ties">ties</code></td>
<td>
<p>A character string indicating the ties/network,
where the data contains several.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that these functions are not as actively maintained as others
in the package, so please let us know if any are not currently working
for you or if there are missing import routines
by <a href="https://github.com/stocnet/manynet/issues">raising an issue on Github</a>.
</p>
<p>There are a number of repositories for network data
that hold various datasets in different formats. See for example:
</p>

<ul>
<li> <p><a href="https://sites.google.com/site/ucinetsoftware/datasets?authuser=0">UCINET data</a>
</p>
</li>
<li> <p><a href="http://vlado.fmf.uni-lj.si/pub/networks/data/">Pajek data</a>
</p>
</li>
<li> <p><a href="https://schochastics.github.io/networkdata/">networkdata</a>
</p>
</li>
<li> <p><a href="http://www-personal.umich.edu/~mejn/netdata/">GML datasets</a>
</p>
</li>
<li><p> UCIrvine Network Data Repository
</p>
</li>
<li> <p><a href="http://snap.stanford.edu/data/">SNAP Stanford Large Network Dataset Collection</a>
</p>
</li></ul>

<p>Please let us know if you identify any further repositories
of social or political networks and we would be happy to add them here.
</p>
<p>The <code style="white-space: pre;">&#8288;_ucinet&#8288;</code> functions only work with relatively recent UCINET
file formats, e.g. type 6406 files.
To import earlier UCINET file types, you will need to update them first.
To import multiple matrices packed into a single UCINET file,
you will need to unpack them and convert them one by one.
</p>


<h3>Value</h3>

<p><code>read_edgelist()</code> and <code>read_nodelist()</code> will import
into edgelist (tibble) format which can then be coerced or combined into
different graph objects from there.
</p>
<p><code>read_pajek()</code> and <code>read_ucinet()</code> will import into
a tidygraph format, since they already contain both edge and attribute data.
<code>read_matrix()</code> will import into tidygraph format too.
Note that all graphs can be easily coerced into other formats
with <code>{manynet}</code>'s <code>as_</code> methods.
</p>


<h3>Source</h3>

<p><code>read_ucinet()</code> kindly supplied by Christian Steglich,
constructed on 18 June 2015.
</p>


<h3>See Also</h3>

<p><a href="methods.html#topic+as">as</a>
</p>
<p>Other makes: 
<code><a href="#topic+make_cran">make_cran</a></code>,
<code><a href="#topic+make_create">make_create</a></code>,
<code><a href="#topic+make_ego">make_ego</a></code>,
<code><a href="#topic+make_explicit">make_explicit</a></code>,
<code><a href="#topic+make_learning">make_learning</a></code>,
<code><a href="#topic+make_motifs">make_motifs</a></code>,
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+make_random">make_random</a></code>,
<code><a href="#topic+make_stochastic">make_stochastic</a></code>,
<code><a href="#topic+make_write">make_write</a></code>
</p>

<hr>
<h2 id='make_stochastic'>Making networks with a stochastic element</h2><span id='topic+make_stochastic'></span><span id='topic+generate_smallworld'></span><span id='topic+generate_scalefree'></span><span id='topic+generate_fire'></span><span id='topic+generate_islands'></span><span id='topic+generate_citations'></span>

<h3>Description</h3>

<p>These functions are similar to the <code style="white-space: pre;">&#8288;create_*&#8288;</code> functions,
but include some element of randomisation.
They are particularly useful for creating a distribution of networks
for exploring or testing network properties.
</p>

<ul>
<li> <p><code>generate_smallworld()</code> generates a small-world structure via ring rewiring at some probability.
</p>
</li>
<li> <p><code>generate_scalefree()</code> generates a scale-free structure via preferential attachment at some probability.
</p>
</li>
<li> <p><code>generate_fire()</code> generates a forest fire model.
</p>
</li>
<li> <p><code>generate_islands()</code> generates an islands model.
</p>
</li>
<li> <p><code>generate_citations()</code> generates a citations model.
</p>
</li></ul>

<p>These functions can create either one-mode or two-mode networks.
To create a one-mode network, pass the main argument <code>n</code> a single integer,
indicating the number of nodes in the network.
To create a two-mode network, pass <code>n</code> a vector of <em>two</em> integers,
where the first integer indicates the number of nodes in the first mode,
and the second integer indicates the number of nodes in the second mode.
As an alternative, an existing network can be provided to <code>n</code>
and the number of modes, nodes, and directedness will be inferred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_smallworld(n, p = 0.05, directed = FALSE, width = 2)

generate_scalefree(n, p = 1, directed = FALSE)

generate_fire(n, contacts = 1, their_out = 0, their_in = 1, directed = FALSE)

generate_islands(n, islands = 2, p = 0.5, bridges = 1, directed = FALSE)

generate_citations(
  n,
  ties = sample(1:4, 1),
  agebins = max(1, n/10),
  directed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_stochastic_+3A_n">n</code></td>
<td>
<p>Given:
</p>

<ul>
<li><p> A single integer, e.g. <code>n = 10</code>,
a one-mode network will be created.
</p>
</li>
<li><p> A vector of two integers, e.g. <code>n = c(5,10)</code>,
a two-mode network will be created.
</p>
</li>
<li><p> A manynet-compatible object,
a network of the same dimensions will be created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_stochastic_+3A_p">p</code></td>
<td>
<p>Power of the preferential attachment, default is 1.</p>
</td></tr>
<tr><td><code id="make_stochastic_+3A_directed">directed</code></td>
<td>
<p>Whether to generate network as directed. By default FALSE.</p>
</td></tr>
<tr><td><code id="make_stochastic_+3A_width">width</code></td>
<td>
<p>Integer specifying the width of the ring,
breadth of the branches, or maximum extent of the neighbourbood.</p>
</td></tr>
<tr><td><code id="make_stochastic_+3A_contacts">contacts</code></td>
<td>
<p>Number of contacts or ambassadors chosen from among existing
nodes in the network.
By default 1.
See <code>igraph::sample_forestfire()</code>.</p>
</td></tr>
<tr><td><code id="make_stochastic_+3A_their_out">their_out</code></td>
<td>
<p>Probability of tieing to a contact's outgoing ties.
By default 0.</p>
</td></tr>
<tr><td><code id="make_stochastic_+3A_their_in">their_in</code></td>
<td>
<p>Probability of tieing to a contact's incoming ties.
By default 1.</p>
</td></tr>
<tr><td><code id="make_stochastic_+3A_islands">islands</code></td>
<td>
<p>Number of islands or communities to create.
By default 2.
See <code>igraph::sample_islands()</code> for more.</p>
</td></tr>
<tr><td><code id="make_stochastic_+3A_bridges">bridges</code></td>
<td>
<p>Number of bridges between islands/communities.
By default 1.</p>
</td></tr>
<tr><td><code id="make_stochastic_+3A_ties">ties</code></td>
<td>
<p>Number of ties to add per new node.
By default a uniform random sample from 1 to 4 new ties.</p>
</td></tr>
<tr><td><code id="make_stochastic_+3A_agebins">agebins</code></td>
<td>
<p>Number of aging bins.
By default either <code class="reqn">\frac{n}{10}</code> or 1,
whichever is the larger.
See <code>igraphr::sample_last_cit()</code> for more.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default a <code>tbl_graph</code> object is returned,
but this can be coerced into other types of objects
using <code>as_edgelist()</code>, <code>as_matrix()</code>,
<code>as_tidygraph()</code>, or <code>as_network()</code>.
</p>
<p>By default, all networks are created as undirected.
This can be overruled with the argument <code>directed = TRUE</code>.
This will return a directed network in which the arcs are
out-facing or equivalent.
This direction can be swapped using <code>to_redirected()</code>.
In two-mode networks, the directed argument is ignored.
</p>


<h3>References</h3>



<h4>On small-world networks</h4>

<p>Watts, Duncan J., and Steven H. Strogatz. 1998.
“Collective Dynamics of ‘Small-World’ Networks.”
<em>Nature</em> 393(6684):440–42.
<a href="https://doi.org/10.1038/30918">doi:10.1038/30918</a>.
</p>



<h4>On scale-free networks</h4>

<p>Barabasi, Albert-Laszlo, and Reka Albert. 1999.
“Emergence of Scaling in Random Networks.”
<em>Science</em> 286(5439):509–12.
<a href="https://doi.org/10.1126/science.286.5439.509">doi:10.1126/science.286.5439.509</a>.
</p>



<h4>On the forest-fire model</h4>

<p>Leskovec, Jure, Jon Kleinberg, and Christos Faloutsos. 2007.
&quot;<a href="https://www.cs.cmu.edu/~jure/pubs/powergrowth-tkdd.pdf">Graph evolution: Densification and shrinking diameters</a>&quot;.
<em>ACM transactions on Knowledge Discovery from Data</em>, 1(1): 2-es.
</p>



<h3>See Also</h3>

<p>Other makes: 
<code><a href="#topic+make_cran">make_cran</a></code>,
<code><a href="#topic+make_create">make_create</a></code>,
<code><a href="#topic+make_ego">make_ego</a></code>,
<code><a href="#topic+make_explicit">make_explicit</a></code>,
<code><a href="#topic+make_learning">make_learning</a></code>,
<code><a href="#topic+make_motifs">make_motifs</a></code>,
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+make_random">make_random</a></code>,
<code><a href="#topic+make_read">make_read</a></code>,
<code><a href="#topic+make_write">make_write</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graphr(generate_smallworld(12, 0.025))
graphr(generate_smallworld(12, 0.25))
graphr(generate_scalefree(12, 0.25))
graphr(generate_scalefree(12, 1.25))
generate_fire(10)
generate_islands(10)
generate_citations(10)
</code></pre>

<hr>
<h2 id='make_write'>Making networks to external files</h2><span id='topic+make_write'></span><span id='topic+write_matrix'></span><span id='topic+write_edgelist'></span><span id='topic+write_nodelist'></span><span id='topic+write_pajek'></span><span id='topic+write_ucinet'></span><span id='topic+write_graphml'></span>

<h3>Description</h3>

<p>Researchers may want to save or work with networks outside R.
The following functions offer ways to export to some common external
file formats:
</p>

<ul>
<li> <p><code>write_matrix()</code> exports an adjacency matrix to a .csv file.
</p>
</li>
<li> <p><code>write_edgelist()</code> exports an edgelist to a .csv file.
</p>
</li>
<li> <p><code>write_nodelist()</code> exports a nodelist to a .csv file.
</p>
</li>
<li> <p><code>write_pajek()</code> exports Pajek .net files.
</p>
</li>
<li> <p><code>write_ucinet()</code> exports a pair of UCINET files in V6404 file format (.##h, .##d).
</p>
</li>
<li> <p><code>write_graphml()</code> exports GraphML files.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>write_matrix(.data, filename, ...)

write_edgelist(.data, filename, ...)

write_nodelist(.data, filename, ...)

write_pajek(.data, filename, ...)

write_ucinet(.data, filename, name)

write_graphml(.data, filename, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_write_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="make_write_+3A_filename">filename</code></td>
<td>
<p>Character string filename.
If missing, the files will have the same name as the object
and be saved to the working directory.
An appropriate extension will be added if not included.</p>
</td></tr>
<tr><td><code id="make_write_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the write function.</p>
</td></tr>
<tr><td><code id="make_write_+3A_name">name</code></td>
<td>
<p>Character string to name the network internally, e.g. in UCINET.
By default the name will be the same as the object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that these functions are not as actively maintained as others
in the package, so please let us know if any are not currently working
for you or if there are missing import routines
by <a href="https://github.com/stocnet/manynet/issues">raising an issue on Github</a>.
</p>


<h3>Value</h3>

<p>The <code>write_</code>functions export to different file formats,
depending on the function.
</p>
<p>A pair of UCINET files in V6404 file format (.##h, .##d)
</p>


<h3>Source</h3>

<p><code>write_ucinet()</code> kindly supplied by Christian Steglich,
constructed on 18 June 2015.
</p>


<h3>See Also</h3>

<p><a href="methods.html#topic+as">as</a>
</p>
<p>Other makes: 
<code><a href="#topic+make_cran">make_cran</a></code>,
<code><a href="#topic+make_create">make_create</a></code>,
<code><a href="#topic+make_ego">make_ego</a></code>,
<code><a href="#topic+make_explicit">make_explicit</a></code>,
<code><a href="#topic+make_learning">make_learning</a></code>,
<code><a href="#topic+make_motifs">make_motifs</a></code>,
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+make_random">make_random</a></code>,
<code><a href="#topic+make_read">make_read</a></code>,
<code><a href="#topic+make_stochastic">make_stochastic</a></code>
</p>

<hr>
<h2 id='manip_as'>Modifying network classes</h2><span id='topic+manip_as'></span><span id='topic+as_nodelist'></span><span id='topic+as_edgelist'></span><span id='topic+as_matrix'></span><span id='topic+as_igraph'></span><span id='topic+as_tidygraph'></span><span id='topic+as_network'></span><span id='topic+as_siena'></span><span id='topic+as_graphAM'></span><span id='topic+as_diffusion'></span><span id='topic+as_diffnet'></span>

<h3>Description</h3>

<p>The <code>as_</code> functions in <code>{manynet}</code> coerce objects of any of the following common classes
of social network objects in R into the declared class:
</p>

<ul>
<li> <p><code>as_edgelist()</code> coerces the object into an edgelist, as data frames or tibbles.
</p>
</li>
<li> <p><code>as_matrix()</code> coerces the object into an adjacency (one-mode/unipartite) or incidence (two-mode/bipartite) matrix.
</p>
</li>
<li> <p><code>as_igraph()</code> coerces the object into an <code>{igraph}</code> <code>graph</code> object.
</p>
</li>
<li> <p><code>as_tidygraph()</code> coerces the object into a <code>{tidygraph}</code> <code>tbl_graph</code> object.
</p>
</li>
<li> <p><code>as_network()</code> coerces the object into a <code>{network}</code> <code>network</code> object.
</p>
</li>
<li> <p><code>as_siena()</code> coerces the (igraph/tidygraph) object into a SIENA dependent variable.
</p>
</li>
<li> <p><code>as_graphAM()</code> coerces the object into a graph adjacency matrix.
</p>
</li>
<li> <p><code>as_diffusion()</code> coerces a table of diffusion events into
a <code>diff_model</code> object similar to the output of <code>play_diffusion()</code>.
</p>
</li>
<li> <p><code>as_diffnet()</code> coerces a <code>diff_model</code> object into a <code>{netdiffuseR}</code> <code>diffnet</code> object.
</p>
</li></ul>

<p>An effort is made for all of these coercion routines to be as lossless
as possible, though some object classes are better at retaining certain
kinds of information than others.
Note also that there are some reserved column names in one or more
object classes, which could otherwise lead to some unexpected results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_nodelist(.data)

as_edgelist(.data, twomode = FALSE)

as_matrix(.data, twomode = NULL)

as_igraph(.data, twomode = FALSE)

as_tidygraph(.data, twomode = FALSE)

as_network(.data, twomode = FALSE)

as_siena(.data, twomode = FALSE)

as_graphAM(.data, twomode = NULL)

as_diffusion(.data, twomode = FALSE, events)

as_diffnet(.data, twomode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_as_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_as_+3A_twomode">twomode</code></td>
<td>
<p>Logical option used to override heuristics for
distinguishing incidence (two-mode/bipartite) from
adjacency (one-mode/unipartite) networks.
By default FALSE.</p>
</td></tr>
<tr><td><code id="manip_as_+3A_events">events</code></td>
<td>
<p>A table (data frame or tibble) of diffusion events
with columns <code>t</code> indicating the time (typically an integer) of the event,
<code>nodes</code> indicating the number or name of the node involved in the event,
and <code>event</code>, which can take on the values &quot;I&quot; for an infection event,
&quot;E&quot; for an exposure event, or &quot;R&quot; for a recovery event.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Edgelists are expected to be held in data.frame or tibble class objects.
The first two columns of such an object are expected to be the
senders and receivers of a tie, respectively, and are typically
named &quot;from&quot; and &quot;to&quot; (even in the case of an undirected network).
These columns can contain integers to identify nodes or character
strings/factors if the network is labelled.
If the sets of senders and receivers overlap, a one-mode network is inferred.
If the sets contain no overlap, a two-mode network is inferred.
If a third, numeric column is present, a weighted network will be created.
</p>
<p>Matrices can be either adjacency (one-mode) or incidence (two-mode) matrices.
Incidence matrices are typically inferred from unequal dimensions,
but since in rare cases a matrix with equal dimensions may still
be an incidence matrix, an additional argument <code>twomode</code> can be
specified to override this heuristic.
</p>
<p>This information is usually already embedded in <code>{igraph}</code>,
<code>{tidygraph}</code>, and <code>{network}</code> objects.
</p>


<h3>Value</h3>

<p>The currently implemented coercions or translations are:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> diff_model </td><td style="text-align: right;"> diffnet </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> list </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> network.goldfish </td><td style="text-align: right;"> siena </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_diffnet </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_diffusion </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_edgelist </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_graphAM </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_igraph </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_matrix </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_network </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_siena </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   as_tidygraph </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>as_diffusion()</code> and <code>play_diffusion()</code> return a 'diff_model' object
that contains two different tibbles (tables) &ndash;
a table of diffusion events and
a table of the number of nodes in each relevant component (S, E, I, or R) &ndash;
as well as a copy of the network upon which the diffusion ran.
By default, a compact version of the component table is printed
(to print all the changes at each time point, use <code>print(..., verbose = T)</code>).
To retrieve the diffusion events table, use <code>summary(...)</code>.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- data.frame(from = c("A","B","B","C","C"), to = c("I","G","I","G","H"))
as_edgelist(test)
as_matrix(test)
as_igraph(test)
as_tidygraph(test)
as_network(test)
  # How to create a diff_model object from (basic) observed data
  events &lt;- data.frame(t = c(0,1,1,2,3), 
                       nodes = c(1,2,3,2,4), 
                       event = c("I","I","I","R","I"))
  as_diffusion(create_filled(4), events = events)
</code></pre>

<hr>
<h2 id='manip_correlation'>Node correlation</h2><span id='topic+manip_correlation'></span><span id='topic+to_correlation'></span><span id='topic+to_cosine'></span>

<h3>Description</h3>

<p>This function performs a Pearson pairwise correlation on a given matrix or network data.
It includes a switch:
whereas for a two-mode network it will perform a regular correlation,
including all rows,
for an undirected network it will perform a correlation on a matrix
with the diagonals removed,
for a reciprocated network it will include the difference
between reciprocated ties,
and for complex networks it will include also the difference
between the self ties in each pairwise calculation.
This function runs in <code class="reqn">O(mn^2)</code> complexity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_correlation(.data, method = NULL)

to_cosine(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_correlation_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_correlation_+3A_method">method</code></td>
<td>
<p>One of the following:
&quot;all&quot; includes all information,
&quot;diag&quot; excludes the diagonal (self-ties),
&quot;recip&quot; excludes the diagonal but compares pairs' reciprocal ties,
and &quot;complex&quot; compares pairs' reciprocal ties and their self ties.
By default the appropriate method is chosen based on the network format.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>

<hr>
<h2 id='manip_deformat'>Modifying network formats</h2><span id='topic+manip_deformat'></span><span id='topic+to_unnamed'></span><span id='topic+to_undirected'></span><span id='topic+to_unweighted'></span><span id='topic+to_unsigned'></span><span id='topic+to_simplex'></span><span id='topic+to_uniplex'></span>

<h3>Description</h3>

<p>These functions reformat manynet-consistent data.
</p>

<ul>
<li> <p><code>to_unnamed()</code> reformats labelled network data to unlabelled network data.
</p>
</li>
<li> <p><code>to_undirected()</code> reformats directed network data to an undirected network,
so that any pair of nodes with at least one directed edge will be
connected by an undirected edge in the new network.
This is equivalent to the &quot;collapse&quot; mode in <code>{igraph}</code>..
</p>
</li>
<li> <p><code>to_unweighted()</code> reformats weighted network data to unweighted network
data, with all tie weights removed.
</p>
</li>
<li> <p><code>to_unsigned()</code> reformats signed network data to unsigned network data
keeping just the &quot;positive&quot; or &quot;negative&quot; ties.
</p>
</li>
<li> <p><code>to_simplex()</code> reformats complex network data, containing loops, to simplex network data, without any loops.
</p>
</li>
<li> <p><code>to_uniplex()</code> reformats multiplex network data to a single type of tie.
</p>
</li></ul>

<p>If the format condition is not met,
for example <code>to_undirected()</code> is used on a network that is already undirected,
the network data is returned unaltered.
No warning is given so that these functions can be used to ensure conformance.
</p>
<p>Unlike the <code style="white-space: pre;">&#8288;as_*()&#8288;</code> group of functions,
these functions always return the same class as they are given,
only transforming these objects' properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_unnamed(.data)

to_undirected(.data)

to_unweighted(.data, threshold = 1)

to_unsigned(.data, keep = c("positive", "negative"))

to_simplex(.data)

to_uniplex(.data, tie)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_deformat_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_deformat_+3A_threshold">threshold</code></td>
<td>
<p>For a matrix, the threshold to binarise/dichotomise at.</p>
</td></tr>
<tr><td><code id="manip_deformat_+3A_keep">keep</code></td>
<td>
<p>In the case of a signed network, whether to retain
the &quot;positive&quot; or &quot;negative&quot; ties.</p>
</td></tr>
<tr><td><code id="manip_deformat_+3A_tie">tie</code></td>
<td>
<p>Character string naming a tie attribute to retain from a graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_simplex </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_undirected </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_uniplex </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_unnamed </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_unsigned </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_unweighted </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>All <code>to_</code> functions return an object of the same class as that provided.
So passing it an igraph object will return an igraph object
and passing it a network object will return a network object,
with certain modifications as outlined for each function.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_tidygraph(create_filled(5)) %&gt;%
  mutate_ties(type = sample(c("friend", "enemy"), 10, replace = TRUE)) %&gt;%
  to_uniplex("friend")
</code></pre>

<hr>
<h2 id='manip_from'>Joining lists of networks, graphs, and matrices</h2><span id='topic+manip_from'></span><span id='topic+from_subgraphs'></span><span id='topic+from_egos'></span><span id='topic+from_waves'></span><span id='topic+from_slices'></span><span id='topic+from_ties'></span>

<h3>Description</h3>

<p>These functions offer tools for joining lists of manynet-consistent objects
(matrices, igraph, tidygraph, or network objects) into a single object.
</p>

<ul>
<li> <p><code>from_subgraphs()</code> modifies a list of subgraphs into a single tidygraph.
</p>
</li>
<li> <p><code>from_egos()</code> modifies a list of ego networks into a whole tidygraph
</p>
</li>
<li> <p><code>from_waves()</code> modifies a list of network waves into a longitudinal tidygraph.
</p>
</li>
<li> <p><code>from_slices()</code> modifies a list of time slices of a network into
a dynamic tidygraph.
</p>
</li>
<li> <p><code>from_ties()</code> modifies a list of different ties into a multiplex tidygraph
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>from_subgraphs(netlist)

from_egos(netlist)

from_waves(netlist)

from_slices(netlist, remove.duplicates = FALSE)

from_ties(netlist, netnames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_from_+3A_netlist">netlist</code></td>
<td>
<p>A list of network, igraph, tidygraph, matrix, or edgelist objects.</p>
</td></tr>
<tr><td><code id="manip_from_+3A_remove.duplicates">remove.duplicates</code></td>
<td>
<p>Should duplicates be removed?
By default FALSE.
If TRUE, duplicated edges are removed.</p>
</td></tr>
<tr><td><code id="manip_from_+3A_netnames">netnames</code></td>
<td>
<p>A character vector of names for the different network objects,
if not already named within the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidygraph object combining the list of network data.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ison_adolescents %&gt;%
  mutate(unicorn = sample(c("yes", "no"), 8, replace = TRUE)) %&gt;%
  to_subgraphs(attribute = "unicorn") %&gt;%
  from_subgraphs()
ison_adolescents %&gt;%
  to_egos() %&gt;%
  from_egos()
ison_adolescents %&gt;%
  mutate_ties(wave = sample(1:4, 10, replace = TRUE)) %&gt;%
  to_waves(attribute = "wave") %&gt;%
  from_waves()
ison_adolescents %&gt;%
  mutate_ties(time = 1:10, increment = 1) %&gt;% 
  add_ties(c(1,2), list(time = 3, increment = -1)) %&gt;% 
  to_slices(slice = c(5,7)) %&gt;%
  from_slices()
</code></pre>

<hr>
<h2 id='manip_levels'>Modifying network levels</h2><span id='topic+manip_levels'></span><span id='topic+to_onemode'></span><span id='topic+to_twomode'></span><span id='topic+to_multilevel'></span>

<h3>Description</h3>

<p>These functions reformat the levels in manynet-consistent network data.
</p>

<ul>
<li> <p><code>to_onemode()</code> reformats two-mode network data into one-mode network data by simply removing the nodeset 'type' information.
Note that this is not the same as <code>to_mode1()</code> or <code>to_mode2()</code>.
</p>
</li>
<li> <p><code>to_twomode()</code> reformats one-mode network data into two-mode network data, using a mark to distinguish the two sets of nodes.
</p>
</li>
<li> <p><code>to_multilevel()</code> reformats two-mode network data into multimodal network data, which allows for more levels and ties within modes.
</p>
</li></ul>

<p>If the format condition is not met,
for example <code>to_onemode()</code> is used on a network that is already one-mode,
the network data is returned unaltered.
No warning is given so that these functions can be used to ensure conformance.
</p>
<p>Unlike the <code style="white-space: pre;">&#8288;as_*()&#8288;</code> group of functions,
these functions always return the same class as they are given,
only transforming these objects' properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_onemode(.data)

to_twomode(.data, mark)

to_multilevel(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_levels_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_levels_+3A_mark">mark</code></td>
<td>
<p>A logical vector marking two types or modes.
By default &quot;type&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_multilevel </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_onemode </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_twomode </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>All <code>to_</code> functions return an object of the same class as that provided.
So passing it an igraph object will return an igraph object
and passing it a network object will return a network object,
with certain modifications as outlined for each function.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>

<hr>
<h2 id='manip_miss'>Modifying missing tie data</h2><span id='topic+manip_miss'></span><span id='topic+na_to_zero'></span><span id='topic+na_to_mean'></span>

<h3>Description</h3>

<p>These functions offer tools for imputing missing tie data.
Currently two options are available:
</p>

<ul>
<li> <p><code>na_to_zero()</code> replaces any missing values with zeros,
which are the modal value in sparse social networks.
</p>
</li>
<li> <p><code>na_to_mean()</code> replaces missing values with the average non-missing value.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>na_to_zero(.data)

na_to_mean(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_miss_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A data object of the same class as the function was given.
</p>


<h3>References</h3>



<h4>On missing data</h4>

<p>Krause, Robert, Mark Huisman, Christian Steglich, and Tom A.B. Snijders. 2020.
&quot;Missing data in cross-sectional networks: An extensive comparison of missing data treatment methods&quot;.
<em>Social Networks</em>, 62: 99-112.
<a href="https://doi.org/10.1016/j.socnet.2020.02.004">doi:10.1016/j.socnet.2020.02.004</a>
</p>



<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>missTest &lt;- ison_adolescents %&gt;% 
   add_tie_attribute("weight", c(1,NA,NA,1,1,1,NA,NA,1,1)) %&gt;% 
   as_matrix
missTest
na_to_zero(missTest)
na_to_mean(missTest)
</code></pre>

<hr>
<h2 id='manip_net'>Modifying network data</h2><span id='topic+manip_net'></span><span id='topic+add_info'></span>

<h3>Description</h3>

<p>These functions allow users to add and edit information about the network
itself.
This includes the name, year, and mode of collection of the network,
as well as definitions of the nodes and ties in the network.
Where available, this information is printed for tidygraph-class objects,
and can be used for printing a grand table in the <code>{grand}</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_info(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_net_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_net_+3A_...">...</code></td>
<td>
<p>Named attributes. The following are currently recognised:
&quot;name&quot;, &quot;year&quot;, and &quot;doi&quot; of the network,
&quot;collection&quot; or &quot;mode&quot; of the network
(&quot;survey&quot;, &quot;interview&quot;,&quot;sensor&quot;,&quot;observation&quot;,&quot;archival&quot;, or &quot;simulation&quot;),
&quot;nodes&quot; (a vector of the names of the nodes) or &quot;vertex1&quot;/&quot;vertex2&quot;,
&quot;ties&quot; or &quot;edge.pos&quot;/&quot;edge.neg&quot; for defining the ties.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>add_info(ison_algebra, name = "Algebra")
</code></pre>

<hr>
<h2 id='manip_nodes'>Modifying node data</h2><span id='topic+manip_nodes'></span><span id='topic+add_nodes'></span><span id='topic+delete_nodes'></span><span id='topic+add_node_attribute'></span><span id='topic+mutate_nodes'></span><span id='topic+mutate'></span><span id='topic+bind_node_attributes'></span><span id='topic+join_nodes'></span><span id='topic+rename_nodes'></span><span id='topic+rename'></span><span id='topic+filter_nodes'></span>

<h3>Description</h3>

<p>These functions allow users to add and delete nodes and their attributes:
</p>

<ul>
<li> <p><code>add_nodes()</code> adds an additional number of nodes to network data.
</p>
</li>
<li> <p><code>delete_nodes()</code> deletes nodes from network data.
</p>
</li>
<li> <p><code>add_node_attribute()</code>, <code>mutate()</code>, or <code>mutate_nodes()</code> offer ways to add
a vector of values to a network as a nodal attribute.
</p>
</li>
<li> <p><code>rename_nodes()</code> and <code>rename()</code> rename nodal attributes.
</p>
</li>
<li> <p><code>bind_node_attributes()</code> appends all nodal attributes from one network to another,
and <code>join_nodes()</code> merges all nodal attributes from one network to another.
</p>
</li>
<li> <p><code>filter_nodes()</code> subsets nodes based on some nodal attribute-related logical statement.
</p>
</li></ul>

<p>Note that while <code style="white-space: pre;">&#8288;add_*()&#8288;</code>/<code style="white-space: pre;">&#8288;delete_*()&#8288;</code> functions operate similarly as comparable <code>{igraph}</code> functions,
<code style="white-space: pre;">&#8288;mutate*()&#8288;</code>, <code style="white-space: pre;">&#8288;bind*()&#8288;</code>, etc work like <code>{tidyverse}</code> or <code>{dplyr}</code>-style functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_nodes(.data, nodes, attribute = NULL)

delete_nodes(.data, nodes)

add_node_attribute(.data, attr_name, vector)

mutate_nodes(.data, ...)

mutate(.data, ...)

bind_node_attributes(.data, object2)

join_nodes(
  .data,
  object2,
  .by = NULL,
  join_type = c("full", "left", "right", "inner")
)

rename_nodes(.data, ...)

rename(.data, ...)

filter_nodes(.data, ..., .by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_nodes_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_nodes_+3A_nodes">nodes</code></td>
<td>
<p>The number of nodes to be added.</p>
</td></tr>
<tr><td><code id="manip_nodes_+3A_attribute">attribute</code></td>
<td>
<p>A named list to be added as tie or node attributes.</p>
</td></tr>
<tr><td><code id="manip_nodes_+3A_attr_name">attr_name</code></td>
<td>
<p>Name of the new attribute in the resulting object.</p>
</td></tr>
<tr><td><code id="manip_nodes_+3A_vector">vector</code></td>
<td>
<p>A vector of values for the new attribute.</p>
</td></tr>
<tr><td><code id="manip_nodes_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="manip_nodes_+3A_object2">object2</code></td>
<td>
<p>A second object to copy nodes or ties from.</p>
</td></tr>
<tr><td><code id="manip_nodes_+3A_.by">.by</code></td>
<td>
<p>An attribute name to join objects by.
By default, NULL.</p>
</td></tr>
<tr><td><code id="manip_nodes_+3A_join_type">join_type</code></td>
<td>
<p>A type of join to be used.
Options are &quot;full&quot;,&quot;left&quot;, &quot;right&quot;, &quot;inner&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   add_nodes </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   delete_nodes </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>A data object of the same class as the function was given.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  other &lt;- create_filled(4) %&gt;% mutate(name = c("A", "B", "C", "D"))
  add_nodes(other, 4, list(name = c("Matthew", "Mark", "Luke", "Tim")))
  other &lt;- create_filled(4) %&gt;% mutate(name = c("A", "B", "C", "D"))
  another &lt;- create_filled(3) %&gt;% mutate(name = c("E", "F", "G"))
  join_nodes(another, other)
</code></pre>

<hr>
<h2 id='manip_paths'>Modifying networks paths</h2><span id='topic+manip_paths'></span><span id='topic+to_matching'></span><span id='topic+to_mentoring'></span><span id='topic+to_eulerian'></span><span id='topic+to_tree'></span><span id='topic+to_dominating'></span>

<h3>Description</h3>

<p>These functions return tidygraphs containing only special sets of ties:
</p>

<ul>
<li> <p><code>to_matching()</code> returns only the matching ties in some network data.
</p>
</li>
<li> <p><code>to_mentoring()</code> returns only ties to nodes' closest mentors.
</p>
</li>
<li> <p><code>to_eulerian()</code> returns only the Eulerian path within some network data.
</p>
</li>
<li> <p><code>to_tree()</code> returns the spanning tree in some network data or,
if the data is unconnected, a forest of spanning trees.
</p>
</li>
<li> <p><code>to_dominating()</code> returns the dominating tree of the network
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>to_matching(.data, mark = "type")

to_mentoring(.data, elites = 0.1)

to_eulerian(.data)

to_tree(.data)

to_dominating(.data, from, direction = c("out", "in"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_paths_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_paths_+3A_mark">mark</code></td>
<td>
<p>A logical vector marking two types or modes.
By default &quot;type&quot;.</p>
</td></tr>
<tr><td><code id="manip_paths_+3A_elites">elites</code></td>
<td>
<p>The proportion of nodes to be selected as mentors.
By default this is set at 0.1.
This means that the top 10% of nodes in terms of degree,
or those equal to the highest rank degree in the network,
whichever is the higher, will be used to select the mentors.
</p>
<p>Note that if nodes are equidistant from two mentors,
they will choose one at random.
If a node is without a path to a mentor,
for example because they are an isolate,
a tie to themselves (a loop) will be created instead.
Note that this is a different default behaviour than that
described in Valente and Davis (1999).</p>
</td></tr>
<tr><td><code id="manip_paths_+3A_from">from</code></td>
<td>
<p>The index or name of the node from which the path should be traced.</p>
</td></tr>
<tr><td><code id="manip_paths_+3A_direction">direction</code></td>
<td>
<p>String, either &quot;out&quot; or &quot;in&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_eulerian </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_matching </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_mentoring </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>All <code>to_</code> functions return an object of the same class as that provided.
So passing it an igraph object will return an igraph object
and passing it a network object will return a network object,
with certain modifications as outlined for each function.
</p>


<h3><code>to_matching()</code></h3>

<p><code>to_matching()</code> uses <code>{igraph}</code>'s <code>max_bipartite_match()</code>
to return a network in which each node is only tied to
one of its previous ties.
The number of these ties left is its <em>cardinality</em>,
and the algorithm seeks to maximise this such that,
where possible, each node will be associated with just one
node in the other mode or some other mark.
The algorithm used is the push-relabel algorithm
with greedy initialization and a global relabelling
after every <code class="reqn">\frac{n}{2}</code> steps,
where <code class="reqn">n</code> is the number of nodes in the network.
</p>


<h3>References</h3>



<h4>On matching</h4>

<p>Goldberg, Andrew V., and Robert E. Tarjan. 1986.
&quot;A new approach to the maximum flow problem&quot;.
<em>Proceedings of the eighteenth annual ACM symposium on Theory of computing – STOC '86</em>.
136-146.
<a href="https://doi.org/10.1145/12130.12144">doi:10.1145/12130.12144</a>
</p>



<h4>On mentoring</h4>

<p>Valente, Thomas, and Rebecca Davis. 1999.
&quot;Accelerating the Diffusion of Innovations Using Opinion Leaders&quot;,
<em>Annals of the American Academy of Political and Social Science</em> 566: 56-67.
<a href="https://doi.org/10.1177/000271629956600105">doi:10.1177/000271629956600105</a>
</p>



<h4>On Eulerian trails</h4>

<p>Euler, Leonard. 1736.
&quot;Solutio problematis ad geometriam situs pertinentis&quot;.
<em>Comment. Academiae Sci. I. Petropolitanae</em> 8: 128–140.
</p>
<p>Hierholzer, Carl. 1873.
&quot;Ueber die Möglichkeit, einen Linienzug ohne Wiederholung und ohne Unterbrechung zu umfahren&quot;.
<em>Mathematische Annalen</em>, 6(1): 30–32.
<a href="https://doi.org/10.1007/BF01442866">doi:10.1007/BF01442866</a>
</p>



<h4>On minimum spanning trees</h4>

<p>Boruvka, Otakar. 1926.
&quot;O jistem problemu minimalnim&quot;.
<em>Prace Mor. Prirodoved. Spol. V Brne III</em> 3: 37-58.
</p>
<p>Kruskal, Joseph B. 1956.
&quot;On the shortest spanning subtree of a graph and the travelling salesman problem&quot;.
<em>Proceedings of the American Mathematical Society</em> 7(1): 48-50.
<a href="https://doi.org/10.1090/S0002-9939-1956-0078686-7">doi:10.1090/S0002-9939-1956-0078686-7</a>
</p>
<p>Prim, R.C. 1957.
&quot;Shortest connection networks and some generalizations&quot;.
<em>Bell System Technical Journal</em> 36(6):1389-1401.
<a href="https://doi.org/10.1002/j.1538-7305.1957.tb01515.x">doi:10.1002/j.1538-7305.1957.tb01515.x</a>
</p>



<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to_matching(ison_southern_women)
#graphr(to_matching(ison_southern_women))
graphr(to_mentoring(ison_adolescents))
  to_eulerian(delete_nodes(ison_koenigsberg, "Lomse"))
  #graphr(to_eulerian(delete_nodes(ison_koenigsberg, "Lomse")))
</code></pre>

<hr>
<h2 id='manip_permutation'>Network permutation</h2><span id='topic+manip_permutation'></span><span id='topic+to_permuted'></span>

<h3>Description</h3>

<p><code>to_permuted()</code> permutes the network using a Fisher-Yates shuffle
on both the rows and columns (for a one-mode network)
or on each of the rows and columns (for a two-mode network).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_permuted(.data, with_attr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_permutation_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_permutation_+3A_with_attr">with_attr</code></td>
<td>
<p>Logical whether any attributes of the object
should be retained.
By default TRUE.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graphr(ison_adolescents, node_size = 4)
graphr(to_permuted(ison_adolescents), node_size = 4)
</code></pre>

<hr>
<h2 id='manip_preformat'>Modifying network formats</h2><span id='topic+manip_preformat'></span><span id='topic+to_named'></span><span id='topic+to_signed'></span><span id='topic+to_weighted'></span>

<h3>Description</h3>

<p>These functions add some format to manynet-consistent data.
</p>

<ul>
<li> <p><code>to_directed()</code> reformats undirected network data to a directed network.
</p>
</li>
<li> <p><code>to_redirected()</code> reformats the direction of directed network data, flipping any existing direction.
</p>
</li>
<li> <p><code>to_reciprocated()</code> reformats directed network data such that every directed tie is reciprocated.
</p>
</li>
<li> <p><code>to_acyclic()</code> reformats network data to an acyclic graph.
</p>
</li>
<li> <p><code>to_named()</code> reformats unlabelled network data to labelled network data
from a vector of names or random baby names.
</p>
</li>
<li> <p><code>to_signed()</code> reformats unsigned network data to signed network data
with signs from a mark vector or at random.
</p>
</li></ul>

<p>If the format condition is not met,
for example <code>to_undirected()</code> is used on a network that is already undirected,
the network data is returned unaltered.
No warning is given so that these functions can be used to ensure conformance.
</p>
<p>Unlike the <code style="white-space: pre;">&#8288;as_*()&#8288;</code> group of functions,
these functions always return the same class as they are given,
only transforming these objects' properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_named(.data, names = NULL)

to_signed(.data, mark = NULL)

to_weighted(.data, measure = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_preformat_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_preformat_+3A_names">names</code></td>
<td>
<p>Character vector of the node names. NULL by default.</p>
</td></tr>
<tr><td><code id="manip_preformat_+3A_mark">mark</code></td>
<td>
<p>A mark (logical vector) the length of the ties in the network.</p>
</td></tr>
<tr><td><code id="manip_preformat_+3A_measure">measure</code></td>
<td>
<p>A numeric vector (measure) that will be added as the tie
weights to the network.
If this is NULL, then the tie weights will be drawn from a
Poisson distribution with <code class="reqn">\lambda = 4</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_acyclic </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_directed </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_named </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_reciprocated </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_redirected </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_simplex </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>All <code>to_</code> functions return an object of the same class as that provided.
So passing it an igraph object will return an igraph object
and passing it a network object will return a network object,
with certain modifications as outlined for each function.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>

<hr>
<h2 id='manip_project'>Modifying networks projection</h2><span id='topic+manip_project'></span><span id='topic+to_mode1'></span><span id='topic+to_mode2'></span><span id='topic+to_ties'></span>

<h3>Description</h3>

<p>These functions offer tools for projecting manynet-consistent data:
</p>

<ul>
<li> <p><code>to_mode1()</code> projects a two-mode network to a one-mode network
of the first node set's (e.g. rows) joint affiliations to nodes in the second node set (columns).
</p>
</li>
<li> <p><code>to_mode2()</code> projects a two-mode network to a one-mode network
of the second node set's (e.g. columns) joint affiliations to nodes in the first node set (rows).
</p>
</li>
<li> <p><code>to_ties()</code> projects a network to one where the ties become nodes and incident nodes become their ties.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>to_mode1(.data, similarity = c("count", "jaccard", "rand", "pearson", "yule"))

to_mode2(.data, similarity = c("count", "jaccard", "rand", "pearson", "yule"))

to_ties(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_project_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_project_+3A_similarity">similarity</code></td>
<td>
<p>Method for establishing ties,
currently &quot;count&quot; (default), &quot;jaccard&quot;, or &quot;rand&quot;.
&quot;count&quot; calculates the number of coinciding ties,
and can be interpreted as indicating the degree of opportunities
between nodes.
&quot;jaccard&quot; uses this count as the numerator in a proportion,
where the denominator consists of any cell where either node has a tie.
It can be interpreted as opportunity weighted by participation.
&quot;rand&quot;, or the Simple Matching Coefficient,
is a proportion where the numerator consists of the count of cells where
both nodes are present or both are absent,
over all possible cells.
It can be interpreted as the (weighted) degree of behavioral mirroring
between two nodes.
&quot;pearson&quot; (Pearson's coefficient) and &quot;yule&quot; (Yule's Q)
produce correlations for valued and binary data, respectively.
Note that Yule's Q has a straightforward interpretation related to the odds ratio.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_mode1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_mode2 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_ties </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>All <code>to_</code> functions return an object of the same class as that provided.
So passing it an igraph object will return an igraph object
and passing it a network object will return a network object,
with certain modifications as outlined for each function.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to_mode1(ison_southern_women)
to_mode2(ison_southern_women)
#graphr(to_mode1(ison_southern_women))
#graphr(to_mode2(ison_southern_women))
to_ties(ison_adolescents)
#graphr(to_ties(ison_adolescents))
</code></pre>

<hr>
<h2 id='manip_reformat'>Modifying network formats</h2><span id='topic+manip_reformat'></span><span id='topic+to_acyclic'></span><span id='topic+to_anti'></span><span id='topic+to_redirected'></span><span id='topic+to_reciprocated'></span><span id='topic+to_directed'></span>

<h3>Description</h3>

<p>These functions reformat manynet-consistent data.
</p>

<ul>
<li> <p><code>to_acyclic()</code> reformats network data to an acyclic graph.
</p>
</li>
<li> <p><code>to_anti()</code> reformats network data into its complement, where only ties <em>not</em> present in the original network
are included in the new network.
</p>
</li>
<li> <p><code>to_redirected()</code> reformats the direction of directed network data, flipping any existing direction.
</p>
</li>
<li> <p><code>to_reciprocated()</code> reformats directed network data such that every directed tie is reciprocated.
</p>
</li></ul>

<p>Unlike the <code style="white-space: pre;">&#8288;as_*()&#8288;</code> group of functions,
these functions always return the same class as they are given,
only transforming these objects' properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_acyclic(.data)

to_anti(.data)

to_redirected(.data)

to_reciprocated(.data)

to_directed(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_reformat_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_acyclic </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_anti </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_reciprocated </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_redirected </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>All <code>to_</code> functions return an object of the same class as that provided.
So passing it an igraph object will return an igraph object
and passing it a network object will return a network object,
with certain modifications as outlined for each function.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>to_redirected()</code>: Returns an object that has any edge direction transposed,
or flipped, so that senders become receivers and receivers become senders.
This essentially has no effect on undirected networks or reciprocated ties.
</p>
</li>
<li> <p><code>to_reciprocated()</code>: Returns an object where all ties are reciprocated.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to_anti(ison_southern_women)
#graphr(to_anti(ison_southern_women))
</code></pre>

<hr>
<h2 id='manip_scope'>Modifying networks scope</h2><span id='topic+manip_scope'></span><span id='topic+to_ego'></span><span id='topic+to_giant'></span><span id='topic+to_no_isolates'></span><span id='topic+to_subgraph'></span><span id='topic+to_blocks'></span>

<h3>Description</h3>

<p>These functions offer tools for transforming manynet-consistent objects
(matrices, igraph, tidygraph, or network objects).
Transforming means that the returned object may have different dimensions
than the original object.
</p>

<ul>
<li> <p><code>to_ego()</code> scopes a network into the local neighbourhood of a given node.
</p>
</li>
<li> <p><code>to_giant()</code> scopes a network into one including only the main component and no smaller components or isolates.
</p>
</li>
<li> <p><code>to_no_isolates()</code> scopes a network into one excluding all nodes without ties
</p>
</li>
<li> <p><code>to_subgraph()</code> scopes a network into a subgraph by filtering on some node-related logical statement.
</p>
</li>
<li> <p><code>to_blocks()</code> reduces a network to ties between a given partition membership vector.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>to_ego(.data, node, max_dist = 1, min_dist = 0, direction = c("out", "in"))

to_giant(.data)

to_no_isolates(.data)

to_subgraph(.data, ...)

to_blocks(.data, membership, FUN = mean)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_scope_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_scope_+3A_node">node</code></td>
<td>
<p>Name or index of node.</p>
</td></tr>
<tr><td><code id="manip_scope_+3A_max_dist">max_dist</code></td>
<td>
<p>The maximum breadth of the neighbourhood.
By default 1.</p>
</td></tr>
<tr><td><code id="manip_scope_+3A_min_dist">min_dist</code></td>
<td>
<p>The minimum breadth of the neighbourhood.
By default 0.
Increasing this to 1 excludes the ego,
and 2 excludes ego's direct alters.</p>
</td></tr>
<tr><td><code id="manip_scope_+3A_direction">direction</code></td>
<td>
<p>String, either &quot;out&quot; or &quot;in&quot;.</p>
</td></tr>
<tr><td><code id="manip_scope_+3A_...">...</code></td>
<td>
<p>Arguments passed on to dplyr::filter</p>
</td></tr>
<tr><td><code id="manip_scope_+3A_membership">membership</code></td>
<td>
<p>A vector of partition memberships.</p>
</td></tr>
<tr><td><code id="manip_scope_+3A_fun">FUN</code></td>
<td>
<p>A function for summarising block content.
By default <code>mean</code>.
Other recommended options include <code>median</code>, <code>sum</code>,
<code>min</code> or <code>max</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> list </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_blocks </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_ego </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_giant </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_no_isolates </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_subgraph </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>All <code>to_</code> functions return an object of the same class as that provided.
So passing it an igraph object will return an igraph object
and passing it a network object will return a network object,
with certain modifications as outlined for each function.
</p>


<h3><code>to_blocks()</code></h3>

<p>Reduced graphs provide summary representations of network structures
by collapsing groups of connected nodes into single nodes
while preserving the topology of the original structures.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ison_adolescents %&gt;%
  mutate_ties(wave = sample(1995:1998, 10, replace = TRUE)) %&gt;%
  to_waves(attribute = "wave") %&gt;%
  to_no_isolates()
</code></pre>

<hr>
<h2 id='manip_split'>Splitting networks into lists</h2><span id='topic+manip_split'></span><span id='topic+to_egos'></span><span id='topic+to_subgraphs'></span><span id='topic+to_components'></span><span id='topic+to_waves'></span><span id='topic+to_slices'></span>

<h3>Description</h3>

<p>These functions offer tools for splitting manynet-consistent objects
(matrices, igraph, tidygraph, or network objects) into lists of networks.
</p>
<p>Not all functions have methods available for all object classes.
Below are the currently implemented S3 methods:</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: right;"> data.frame </td><td style="text-align: right;"> diff_model </td><td style="text-align: right;"> igraph </td><td style="text-align: right;"> matrix </td><td style="text-align: right;"> network </td><td style="text-align: right;"> tbl_graph </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_components </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_egos </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_slices </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_subgraphs </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   to_waves </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>to_egos(.data, max_dist = 1, min_dist = 0, direction = c("out", "in"))

to_subgraphs(.data, attribute)

to_components(.data)

to_waves(.data, attribute = "wave", panels = NULL, cumulative = FALSE)

to_slices(.data, attribute = "time", slice = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_split_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_split_+3A_max_dist">max_dist</code></td>
<td>
<p>The maximum breadth of the neighbourhood.
By default 1.</p>
</td></tr>
<tr><td><code id="manip_split_+3A_min_dist">min_dist</code></td>
<td>
<p>The minimum breadth of the neighbourhood.
By default 0.
Increasing this to 1 excludes the ego,
and 2 excludes ego's direct alters.</p>
</td></tr>
<tr><td><code id="manip_split_+3A_direction">direction</code></td>
<td>
<p>String, either &quot;out&quot; or &quot;in&quot;.</p>
</td></tr>
<tr><td><code id="manip_split_+3A_attribute">attribute</code></td>
<td>
<p>One or two attributes used to slice data.</p>
</td></tr>
<tr><td><code id="manip_split_+3A_panels">panels</code></td>
<td>
<p>Would you like to select certain waves?
NULL by default.
That is, a list of networks for every available wave is returned.
Users can also list specific waves they want to select.</p>
</td></tr>
<tr><td><code id="manip_split_+3A_cumulative">cumulative</code></td>
<td>
<p>Whether to make wave ties cumulative.
FALSE by default. That is, each wave is treated isolated.</p>
</td></tr>
<tr><td><code id="manip_split_+3A_slice">slice</code></td>
<td>
<p>Character string or character list indicating the date(s)
or integer(s) range used to slice data (e.g slice = c(1:2, 3:4)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned object will be a list of network objects.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>to_egos()</code>: Returns a list of ego (or focal)
networks.
</p>
</li>
<li> <p><code>to_subgraphs()</code>: Returns a list of subgraphs
on some given node attribute.
</p>
</li>
<li> <p><code>to_components()</code>: Returns a list of the components
in a network.
</p>
</li>
<li> <p><code>to_waves()</code>: Returns a network
with some discrete observations over time
into a list of those observations.
</p>
</li>
<li> <p><code>to_slices()</code>: Returns a list of a network
with some continuous time variable at some time slice(s).
</p>
</li></ul>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_ties">manip_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  to_egos(ison_adolescents)
  # graphs(to_egos(ison_adolescents,2))
ison_adolescents %&gt;%
  mutate(unicorn = sample(c("yes", "no"), 8,
                          replace = TRUE)) %&gt;%
  to_subgraphs(attribute = "unicorn")
  to_components(ison_marvel_relationships)
ison_adolescents %&gt;%
  mutate_ties(wave = sample(1995:1998, 10, replace = TRUE)) %&gt;%
  to_waves(attribute = "wave")
ison_adolescents %&gt;%
  mutate_ties(time = 1:10, increment = 1) %&gt;% 
  add_ties(c(1,2), list(time = 3, increment = -1)) %&gt;% 
  to_slices(slice = 7)
</code></pre>

<hr>
<h2 id='manip_ties'>Modifying tie data</h2><span id='topic+manip_ties'></span><span id='topic+add_ties'></span><span id='topic+delete_ties'></span><span id='topic+add_tie_attribute'></span><span id='topic+mutate_ties'></span><span id='topic+rename_ties'></span><span id='topic+arrange_ties'></span><span id='topic+bind_ties'></span><span id='topic+join_ties'></span><span id='topic+filter_ties'></span><span id='topic+select_ties'></span><span id='topic+summarise_ties'></span>

<h3>Description</h3>

<p>These functions allow users to add and delete ties and their attributes:
</p>

<ul>
<li> <p><code>add_ties()</code> adds additional ties to network data
</p>
</li>
<li> <p><code>delete_ties()</code> deletes ties from network data
</p>
</li>
<li> <p><code>add_tie_attribute()</code> and <code>mutate_ties()</code> offer ways to add
a vector of values to a network as a tie attribute.
</p>
</li>
<li> <p><code>rename_ties()</code> renames tie attributes.
</p>
</li>
<li> <p><code>bind_ties()</code> appends the tie data from two networks and
<code>join_ties()</code> merges ties from two networks,
adding a tie attribute identifying the newly added ties.
</p>
</li>
<li> <p><code>filter_ties()</code> subsets ties based on some tie attribute-related logical statement.
</p>
</li></ul>

<p>Note that while <code style="white-space: pre;">&#8288;add_*()&#8288;</code>/<code style="white-space: pre;">&#8288;delete_*()&#8288;</code> functions operate similarly as comparable <code>{igraph}</code> functions,
<code style="white-space: pre;">&#8288;mutate*()&#8288;</code>, <code style="white-space: pre;">&#8288;bind*()&#8288;</code>, etc work like <code>{tidyverse}</code> or <code>{dplyr}</code>-style functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_ties(.data, ties, attribute = NULL)

delete_ties(.data, ties)

add_tie_attribute(.data, attr_name, vector)

mutate_ties(.data, ...)

rename_ties(.data, ...)

arrange_ties(.data, ...)

bind_ties(.data, ...)

join_ties(.data, object2, attr_name)

filter_ties(.data, ...)

select_ties(.data, ...)

summarise_ties(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manip_ties_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="manip_ties_+3A_ties">ties</code></td>
<td>
<p>The number of ties to be added or an even list of ties.</p>
</td></tr>
<tr><td><code id="manip_ties_+3A_attribute">attribute</code></td>
<td>
<p>A named list to be added as tie or node attributes.</p>
</td></tr>
<tr><td><code id="manip_ties_+3A_attr_name">attr_name</code></td>
<td>
<p>Name of the new attribute in the resulting object.</p>
</td></tr>
<tr><td><code id="manip_ties_+3A_vector">vector</code></td>
<td>
<p>A vector of values for the new attribute.</p>
</td></tr>
<tr><td><code id="manip_ties_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="manip_ties_+3A_object2">object2</code></td>
<td>
<p>A second object to copy nodes or ties from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidygraph (<code>tbl_graph</code>) data object.
</p>


<h3>See Also</h3>

<p>Other modifications: 
<code><a href="#topic+manip_as">manip_as</a></code>,
<code><a href="#topic+manip_correlation">manip_correlation</a></code>,
<code><a href="#topic+manip_deformat">manip_deformat</a></code>,
<code><a href="#topic+manip_from">manip_from</a></code>,
<code><a href="#topic+manip_levels">manip_levels</a></code>,
<code><a href="#topic+manip_miss">manip_miss</a></code>,
<code><a href="#topic+manip_nodes">manip_nodes</a></code>,
<code><a href="#topic+manip_paths">manip_paths</a></code>,
<code><a href="#topic+manip_permutation">manip_permutation</a></code>,
<code><a href="#topic+manip_preformat">manip_preformat</a></code>,
<code><a href="#topic+manip_project">manip_project</a></code>,
<code><a href="#topic+manip_reformat">manip_reformat</a></code>,
<code><a href="#topic+manip_scope">manip_scope</a></code>,
<code><a href="#topic+manip_split">manip_split</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  other &lt;- create_filled(4) %&gt;% mutate(name = c("A", "B", "C", "D"))
  mutate_ties(other, form = 1:6) %&gt;% filter_ties(form &lt; 4)
  add_tie_attribute(other, "weight", c(1, 2, 2, 2, 1, 2))
ison_adolescents %&gt;% add_ties(c("Betty","Tina")) %&gt;% graphr()
delete_ties(ison_adolescents, 3)
delete_ties(ison_adolescents, "Alice|Sue")
</code></pre>

<hr>
<h2 id='map_graphr'>Easily graph networks with sensible defaults</h2><span id='topic+map_graphr'></span><span id='topic+graphr'></span>

<h3>Description</h3>

<p>This function provides users with an easy way to graph
(m)any network data for exploration, investigation, inspiration,
and communication.
</p>
<p>It builds upon <code>{ggplot2}</code> and <code>{ggraph}</code> to offer
pretty and extensible graphing solutions.
However, compared to those solutions,
<code>graphr()</code> contains various algorithms to provide better looking
graphs by default.
This means that just passing the function some network data
will often be sufficient to return a reasonable-looking graph.
</p>
<p>The function also makes it easy to modify many of the most
commonly adapted aspects of a graph,
including node and edge size, colour, and shape,
as arguments rather than additional functions that you need to remember.
These can be defined outright, e.g. <code>node_size = 8</code>, or
in reference to an attribute of the network, e.g. <code>node_size = "wealth"</code>.
</p>
<p>Lastly, <code>graphr()</code> uses <code>{ggplot2}</code>-related theme information, so
it is easy to make colour palette and fonts institution-specific and consistent.
See e.g. <code>theme_iheid()</code> for more.
</p>
<p>To learn more about what can be done visually,
try <code>run_tute("Visualisation")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphr(
  .data,
  layout,
  labels = TRUE,
  node_color,
  node_shape,
  node_size,
  node_group,
  edge_color,
  edge_size,
  snap = FALSE,
  ...,
  node_colour,
  edge_colour
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_graphr_+3A_.data">.data</code></td>
<td>
<p>A manynet-consistent object.</p>
</td></tr>
<tr><td><code id="map_graphr_+3A_layout">layout</code></td>
<td>
<p>An igraph, ggraph, or manynet layout algorithm.
If not declared, defaults to &quot;triad&quot; for networks with 3 nodes,
&quot;quad&quot; for networks with 4 nodes,
&quot;stress&quot; for all other one mode networks,
or &quot;hierarchy&quot; for two mode networks.
For &quot;hierarchy&quot; layout, one can further split graph by
declaring the &quot;center&quot; argument as the &quot;events&quot;, &quot;actors&quot;,
or by declaring a node name.
For &quot;concentric&quot; layout algorithm please declare the &quot;membership&quot; as an
extra argument.
The &quot;membership&quot; argument expects either a quoted node attribute present
in data or vector with the same length as nodes to draw concentric circles.
For &quot;multilevel&quot; layout algorithm please declare the &quot;level&quot;
as extra argument.
The &quot;level&quot; argument expects either a quoted node attribute present
in data or vector with the same length as nodes to hierarchically
order categories.
If &quot;level&quot; is missing, function will look for 'lvl' node attribute in data.
The &quot;lineage&quot; layout ranks nodes in Y axis according to values.
For &quot;lineage&quot; layout algorithm please declare the &quot;rank&quot;
as extra argument.
The &quot;rank&quot; argument expects either a quoted node attribute present
in data or vector with the same length as nodes.</p>
</td></tr>
<tr><td><code id="map_graphr_+3A_labels">labels</code></td>
<td>
<p>Logical, whether to print node names
as labels if present.</p>
</td></tr>
<tr><td><code id="map_graphr_+3A_node_color">node_color</code>, <code id="map_graphr_+3A_node_colour">node_colour</code></td>
<td>
<p>Node variable to be used for coloring the nodes.
It is easiest if this is added as a node attribute to
the graph before plotting.
Nodes can also be colored by declaring a color instead.</p>
</td></tr>
<tr><td><code id="map_graphr_+3A_node_shape">node_shape</code></td>
<td>
<p>Node variable to be used for shaping the nodes.
It is easiest if this is added as a node attribute to
the graph before plotting.
Nodes can also be shaped by declaring a shape instead.</p>
</td></tr>
<tr><td><code id="map_graphr_+3A_node_size">node_size</code></td>
<td>
<p>Node variable to be used for sizing the nodes.
This can be any continuous variable on the nodes of the network.
Since this function expects this to be an existing variable,
it is recommended to calculate all node-related statistics prior
to using this function.
Nodes can also be sized by declaring a numeric size or vector instead.</p>
</td></tr>
<tr><td><code id="map_graphr_+3A_node_group">node_group</code></td>
<td>
<p>Node variable to be used for grouping the nodes.
It is easiest if this is added as a hull over
groups before plotting.
Group variables should have a minimum of 3 nodes,
if less, number groups will be reduced by
merging categories with lower counts into one called &quot;other&quot;.</p>
</td></tr>
<tr><td><code id="map_graphr_+3A_edge_color">edge_color</code>, <code id="map_graphr_+3A_edge_colour">edge_colour</code></td>
<td>
<p>Tie variable to be used for coloring the nodes.
It is easiest if this is added as an edge or tie attribute
to the graph before plotting.
Edges can also be colored by declaring a color instead.</p>
</td></tr>
<tr><td><code id="map_graphr_+3A_edge_size">edge_size</code></td>
<td>
<p>Tie variable to be used for sizing the edges.
This can be any continuous variable on the nodes of the network.
Since this function expects this to be an existing variable,
it is recommended to calculate all edge-related statistics prior
to using this function.
Edges can also be sized by declaring a numeric size or vector instead.</p>
</td></tr>
<tr><td><code id="map_graphr_+3A_snap">snap</code></td>
<td>
<p>Logical scalar, whether the layout should be snapped to a grid.</p>
</td></tr>
<tr><td><code id="map_graphr_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass on to the layout algorithm, if necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2::ggplot()</code> object.
The last plot can be saved to the file system using <code>ggplot2::ggsave()</code>.
</p>


<h3>See Also</h3>

<p>Other mapping: 
<code><a href="#topic+map_graphs">map_graphs</a></code>,
<code><a href="#topic+map_grapht">map_grapht</a></code>,
<code><a href="#topic+map_layout_configuration">map_layout_configuration</a></code>,
<code><a href="#topic+map_layout_partition">map_layout_partition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graphr(ison_adolescents)
ison_adolescents %&gt;%
  mutate(color = rep(c("introvert","extrovert"), times = 4),
         size = ifelse(node_is_cutpoint(ison_adolescents), 6, 3)) %&gt;%
  mutate_ties(ecolor = rep(c("friends", "acquaintances"), times = 5)) %&gt;%
  graphr(node_color = "color", node_size = "size",
         edge_size = 1.5, edge_color = "ecolor")
</code></pre>

<hr>
<h2 id='map_graphs'>Easily graph a set of networks with sensible defaults</h2><span id='topic+map_graphs'></span><span id='topic+graphs'></span>

<h3>Description</h3>

<p>This function provides users with an easy way to graph
lists of network data for comparison.
</p>
<p>It builds upon this package's <code>graphr()</code> function,
and inherits all the same features and arguments.
See <code>graphr()</code> for more.
However, it uses the <code>{patchwork}</code> package to plot the graphs
side by side and, if necessary, in successive rows.
This is useful for lists of networks that represent, for example,
ego or component subgraphs of a network,
or a list of a network's different types of tie or across time.
By default just the first and last network will be plotted,
but this can be overridden by the &quot;waves&quot; parameter.
</p>
<p>Where the graphs are of the same network (same nodes),
the graphs may share a layout to facilitate comparison.
By default, successive graphs will use the layout calculated for
the &quot;first&quot; network, but other options include the &quot;last&quot; layout,
or a mix, &quot;both&quot;, of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphs(netlist, waves, based_on = c("first", "last", "both"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_graphs_+3A_netlist">netlist</code></td>
<td>
<p>A list of manynet-compatible networks.</p>
</td></tr>
<tr><td><code id="map_graphs_+3A_waves">waves</code></td>
<td>
<p>Numeric, the number of plots to be displayed side-by-side.
If missing, the number of plots will be reduced to the first and last
when there are more than four plots.
This argument can also be passed a vector selecting the waves to plot.</p>
</td></tr>
<tr><td><code id="map_graphs_+3A_based_on">based_on</code></td>
<td>
<p>Whether the layout of the joint plots should
be based on the &quot;first&quot; or the &quot;last&quot; network, or &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="map_graphs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>graphr()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiple <code>ggplot2::ggplot()</code> objects displayed side-by-side.
</p>


<h3>See Also</h3>

<p>Other mapping: 
<code><a href="#topic+map_graphr">map_graphr</a></code>,
<code><a href="#topic+map_grapht">map_grapht</a></code>,
<code><a href="#topic+map_layout_configuration">map_layout_configuration</a></code>,
<code><a href="#topic+map_layout_partition">map_layout_partition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#graphs(to_egos(ison_adolescents))
#graphs(to_egos(ison_adolescents), waves = 8)
#graphs(to_egos(ison_adolescents), waves = c(2, 4, 6))
#graphs(play_diffusion(ison_adolescents))
</code></pre>

<hr>
<h2 id='map_grapht'>Easily animate dynamic networks with sensible defaults</h2><span id='topic+map_grapht'></span><span id='topic+grapht'></span>

<h3>Description</h3>

<p>This function provides users with an easy way to graph
dynamic network data for exploration and presentation.
</p>
<p>It builds upon this package's <code>graphr()</code> function,
and inherits all the same features and arguments.
See <code>graphr()</code> for more.
However, it uses the <code>{gganimate}</code> package to animate the changes
between successive iterations of a network.
This is useful for networks in which the ties and/or the node or tie
attributes are changing.
</p>
<p>A progress bar is shown if it takes some time to encoding all the
.png files into a .gif.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grapht(
  tlist,
  keep_isolates = TRUE,
  layout,
  labels = TRUE,
  node_color,
  node_shape,
  node_size,
  edge_color,
  edge_size,
  ...,
  node_colour,
  edge_colour
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_grapht_+3A_tlist">tlist</code></td>
<td>
<p>The same migraph-compatible network listed according to
a time attribute, waves, or slices.</p>
</td></tr>
<tr><td><code id="map_grapht_+3A_keep_isolates">keep_isolates</code></td>
<td>
<p>Logical, whether to keep isolate nodes in the graph.
TRUE by default.
If FALSE, removes nodes from each frame they are isolated in.</p>
</td></tr>
<tr><td><code id="map_grapht_+3A_layout">layout</code></td>
<td>
<p>An igraph, ggraph, or manynet layout algorithm.
If not declared, defaults to &quot;triad&quot; for networks with 3 nodes,
&quot;quad&quot; for networks with 4 nodes,
&quot;stress&quot; for all other one mode networks,
or &quot;hierarchy&quot; for two mode networks.
For &quot;hierarchy&quot; layout, one can further split graph by
declaring the &quot;center&quot; argument as the &quot;events&quot;, &quot;actors&quot;,
or by declaring a node name.
For &quot;concentric&quot; layout algorithm please declare the &quot;membership&quot; as an
extra argument.
The &quot;membership&quot; argument expects either a quoted node attribute present
in data or vector with the same length as nodes to draw concentric circles.
For &quot;multilevel&quot; layout algorithm please declare the &quot;level&quot;
as extra argument.
The &quot;level&quot; argument expects either a quoted node attribute present
in data or vector with the same length as nodes to hierarchically
order categories.
If &quot;level&quot; is missing, function will look for 'lvl' node attribute in data.
The &quot;lineage&quot; layout ranks nodes in Y axis according to values.
For &quot;lineage&quot; layout algorithm please declare the &quot;rank&quot;
as extra argument.
The &quot;rank&quot; argument expects either a quoted node attribute present
in data or vector with the same length as nodes.</p>
</td></tr>
<tr><td><code id="map_grapht_+3A_labels">labels</code></td>
<td>
<p>Logical, whether to print node names
as labels if present.</p>
</td></tr>
<tr><td><code id="map_grapht_+3A_node_color">node_color</code>, <code id="map_grapht_+3A_node_colour">node_colour</code></td>
<td>
<p>Node variable to be used for coloring the nodes.
It is easiest if this is added as a node attribute to
the graph before plotting.
Nodes can also be colored by declaring a color instead.</p>
</td></tr>
<tr><td><code id="map_grapht_+3A_node_shape">node_shape</code></td>
<td>
<p>Node variable to be used for shaping the nodes.
It is easiest if this is added as a node attribute to
the graph before plotting.
Nodes can also be shaped by declaring a shape instead.</p>
</td></tr>
<tr><td><code id="map_grapht_+3A_node_size">node_size</code></td>
<td>
<p>Node variable to be used for sizing the nodes.
This can be any continuous variable on the nodes of the network.
Since this function expects this to be an existing variable,
it is recommended to calculate all node-related statistics prior
to using this function.
Nodes can also be sized by declaring a numeric size or vector instead.</p>
</td></tr>
<tr><td><code id="map_grapht_+3A_edge_color">edge_color</code>, <code id="map_grapht_+3A_edge_colour">edge_colour</code></td>
<td>
<p>Tie variable to be used for coloring the nodes.
It is easiest if this is added as an edge or tie attribute
to the graph before plotting.
Edges can also be colored by declaring a color instead.</p>
</td></tr>
<tr><td><code id="map_grapht_+3A_edge_size">edge_size</code></td>
<td>
<p>Tie variable to be used for sizing the edges.
This can be any continuous variable on the nodes of the network.
Since this function expects this to be an existing variable,
it is recommended to calculate all edge-related statistics prior
to using this function.
Edges can also be sized by declaring a numeric size or vector instead.</p>
</td></tr>
<tr><td><code id="map_grapht_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass on to the layout algorithm, if necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shows a .gif image. Assigning the result of the function
saves the gif to a temporary folder and the object holds the path to this file.
</p>


<h3>Source</h3>

<p>https://blog.schochastics.net/posts/2021-09-15_animating-network-evolutions-with-gganimate/
</p>


<h3>See Also</h3>

<p>Other mapping: 
<code><a href="#topic+map_graphr">map_graphr</a></code>,
<code><a href="#topic+map_graphs">map_graphs</a></code>,
<code><a href="#topic+map_layout_configuration">map_layout_configuration</a></code>,
<code><a href="#topic+map_layout_partition">map_layout_partition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#ison_adolescents %&gt;%
#  mutate_ties(year = sample(1995:1998, 10, replace = TRUE)) %&gt;%
#  to_waves(attribute = "year", cumulative = TRUE) %&gt;%
#  grapht()
#ison_adolescents %&gt;% 
#  mutate(gender = rep(c("male", "female"), times = 4),
#         hair = rep(c("black", "brown"), times = 4),
#         age = sample(11:16, 8, replace = TRUE)) %&gt;%
#  mutate_ties(year = sample(1995:1998, 10, replace = TRUE),
#              links = sample(c("friends", "not_friends"), 10, replace = TRUE),
#              weekly_meetings = sample(c(3, 5, 7), 10, replace = TRUE)) %&gt;%
#  to_waves(attribute = "year") %&gt;%
#  grapht(layout = "concentric", membership = "gender",
#             node_shape = "gender", node_color = "hair",
#             node_size =  "age", edge_color = "links",
#             edge_size = "weekly_meetings")
#grapht(play_diffusion(ison_adolescents, seeds = 5))
</code></pre>

<hr>
<h2 id='map_layout_configuration'>Layout algorithms based on configurational positions</h2><span id='topic+map_layout_configuration'></span><span id='topic+layout_tbl_graph_configuration'></span><span id='topic+layout_tbl_graph_dyad'></span><span id='topic+layout_tbl_graph_triad'></span><span id='topic+layout_tbl_graph_tetrad'></span><span id='topic+layout_tbl_graph_pentad'></span><span id='topic+layout_tbl_graph_hexad'></span>

<h3>Description</h3>

<p>Configurational layouts locate nodes at symmetric coordinates
to help illustrate particular configurations.
Currently &quot;triad&quot; and &quot;quad&quot; layouts are available.
The &quot;configuration&quot; layout will choose the appropriate configurational
layout automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_configuration(.data, circular = FALSE, times = 1000)

layout_tbl_graph_dyad(.data, circular = FALSE, times = 1000)

layout_tbl_graph_triad(.data, circular = FALSE, times = 1000)

layout_tbl_graph_tetrad(.data, circular = FALSE, times = 1000)

layout_tbl_graph_pentad(.data, circular = FALSE, times = 1000)

layout_tbl_graph_hexad(.data, circular = FALSE, times = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_layout_configuration_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="map_layout_configuration_+3A_circular">circular</code></td>
<td>
<p>Should the layout be transformed into a radial representation.
Only possible for some layouts. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="map_layout_configuration_+3A_times">times</code></td>
<td>
<p>Maximum number of iterations, where appropriate</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other mapping: 
<code><a href="#topic+map_graphr">map_graphr</a></code>,
<code><a href="#topic+map_graphs">map_graphs</a></code>,
<code><a href="#topic+map_grapht">map_grapht</a></code>,
<code><a href="#topic+map_layout_partition">map_layout_partition</a></code>
</p>

<hr>
<h2 id='map_layout_partition'>Layout algorithms based on bi- or other partitions</h2><span id='topic+map_layout_partition'></span><span id='topic+layout_tbl_graph_hierarchy'></span><span id='topic+layout_tbl_graph_alluvial'></span><span id='topic+layout_tbl_graph_railway'></span><span id='topic+layout_tbl_graph_ladder'></span><span id='topic+layout_tbl_graph_concentric'></span><span id='topic+layout_tbl_graph_multilevel'></span><span id='topic+layout_tbl_graph_lineage'></span>

<h3>Description</h3>

<p>These algorithms layout networks based on two or more partitions,
and are recommended for use with <code>graphr()</code> or <code>{ggraph}</code>.
Note that these layout algorithms use <code>{Rgraphviz}</code>,
a package that is only available on Bioconductor.
It will first need to be downloaded using <code>BiocManager::install("Rgraphviz")</code>.
If it has not already been installed, there is a prompt the first time
these functions are used though.
</p>
<p>The &quot;hierarchy&quot; layout layers the first node set along the bottom,
and the second node set along the top,
sequenced and spaced as necessary to minimise edge overlap.
The &quot;alluvial&quot; layout is similar to &quot;hierarchy&quot;,
but places successive layers horizontally rather than vertically.
The &quot;railway&quot; layout is similar to &quot;hierarchy&quot;,
but nodes are aligned across the layers.
The &quot;ladder&quot; layout is similar to &quot;railway&quot;,
but places successive layers horizontally rather than vertically.
The &quot;concentric&quot; layout places a &quot;hierarchy&quot; layout
around a circle, with successive layers appearing as concentric circles.
The &quot;multilevel&quot; layout places successive layers as multiple levels.
The &quot;lineage&quot; layout ranks nodes in Y axis according to values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_tbl_graph_hierarchy(
  .data,
  center = NULL,
  circular = FALSE,
  times = 1000
)

layout_tbl_graph_alluvial(.data, circular = FALSE, times = 1000)

layout_tbl_graph_railway(.data, circular = FALSE, times = 1000)

layout_tbl_graph_ladder(.data, circular = FALSE, times = 1000)

layout_tbl_graph_concentric(
  .data,
  membership,
  radius = NULL,
  order.by = NULL,
  circular = FALSE,
  times = 1000
)

layout_tbl_graph_multilevel(.data, level, circular = FALSE)

layout_tbl_graph_lineage(.data, rank, circular = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_layout_partition_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="map_layout_partition_+3A_center">center</code></td>
<td>
<p>Further split &quot;hierarchical&quot; layouts by
declaring the &quot;center&quot; argument as the &quot;events&quot;, &quot;actors&quot;,
or by declaring a node name in hierarchy layout.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="map_layout_partition_+3A_circular">circular</code></td>
<td>
<p>Should the layout be transformed into a radial representation.
Only possible for some layouts. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="map_layout_partition_+3A_times">times</code></td>
<td>
<p>Maximum number of iterations, where appropriate</p>
</td></tr>
<tr><td><code id="map_layout_partition_+3A_membership">membership</code></td>
<td>
<p>A node attribute or a vector to draw concentric circles
for &quot;concentric&quot; layout.</p>
</td></tr>
<tr><td><code id="map_layout_partition_+3A_radius">radius</code></td>
<td>
<p>A vector of radii at which the concentric circles
should be located for &quot;concentric&quot; layout.
By default this is equal placement around an empty centre,
unless one (the core) is a single node,
in which case this node occupies the centre of the graph.</p>
</td></tr>
<tr><td><code id="map_layout_partition_+3A_order.by">order.by</code></td>
<td>
<p>An attribute label indicating the (decreasing) order
for the nodes around the circles for &quot;concentric&quot; layout.
By default ordering is given by a bipartite placement that reduces
the number of edge crossings.</p>
</td></tr>
<tr><td><code id="map_layout_partition_+3A_level">level</code></td>
<td>
<p>A node attribute or a vector to hierarchically order levels for
&quot;multilevel&quot; layout.</p>
</td></tr>
<tr><td><code id="map_layout_partition_+3A_rank">rank</code></td>
<td>
<p>A numerical node attribute to place nodes in Y axis
according to values for &quot;lineage&quot; layout.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Diego Diez, Andrew P. Hutchins and Diego Miranda-Saavedra. 2014.
&quot;Systematic identification of transcriptional regulatory modules from
protein-protein interaction networks&quot;.
<em>Nucleic Acids Research</em>, 42 (1) e6.
</p>


<h3>See Also</h3>

<p>Other mapping: 
<code><a href="#topic+map_graphr">map_graphr</a></code>,
<code><a href="#topic+map_graphs">map_graphs</a></code>,
<code><a href="#topic+map_grapht">map_grapht</a></code>,
<code><a href="#topic+map_layout_configuration">map_layout_configuration</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#graphr(ison_southern_women, layout = "hierarchy", center = "events",
#           node_color = "type", node_size = 3)
#graphr(ison_southern_women, layout = "alluvial")
#graphr(ison_southern_women, layout = "concentric", membership = "type",
#           node_color = "type", node_size = 3)
#graphr(ison_lotr, layout = "multilevel",
#           node_color = "Race", level = "Race", node_size = 3)
# ison_adolescents %&gt;%
#   mutate(year = rep(c(1985, 1990, 1995, 2000), times = 2),
#          cut = node_is_cutpoint(ison_adolescents)) %&gt;%
#   graphr(layout = "lineage", rank = "year", node_color = "cut",
#              node_size = migraph::node_degree(ison_adolescents)*10)
</code></pre>

<hr>
<h2 id='map_palettes'>Many palettes generator</h2><span id='topic+map_palettes'></span><span id='topic+many_palettes'></span>

<h3>Description</h3>

<p>Many palettes generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>many_palettes(palette, n, type = c("discrete", "continuous"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_palettes_+3A_palette">palette</code></td>
<td>
<p>Name of desired palette. Current choices are:
<code>IHEID</code>, <code>Centres</code>, <code>SDGs</code>, <code>ETHZ</code>, <code>RUG</code>,
and <code>UZH</code>.</p>
</td></tr>
<tr><td><code id="map_palettes_+3A_n">n</code></td>
<td>
<p>Number of colors desired. If omitted, uses all colours.</p>
</td></tr>
<tr><td><code id="map_palettes_+3A_type">type</code></td>
<td>
<p>Either &quot;continuous&quot; or &quot;discrete&quot;. Use continuous if you want
to automatically interpolate between colours.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graphic display of colours in palette.
</p>


<h3>Source</h3>

<p>Adapted from <a href="https://github.com/karthik/wesanderson/blob/master/R/colors.R">https://github.com/karthik/wesanderson/blob/master/R/colors.R</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>many_palettes()
#many_palettes("IHEID")
</code></pre>

<hr>
<h2 id='map_scales'>Many scales</h2><span id='topic+map_scales'></span><span id='topic+scale_fill_iheid'></span><span id='topic+scale_colour_iheid'></span><span id='topic+scale_color_iheid'></span><span id='topic+scale_edge_colour_iheid'></span><span id='topic+scale_edge_color_iheid'></span><span id='topic+scale_fill_centres'></span><span id='topic+scale_colour_centres'></span><span id='topic+scale_color_centres'></span><span id='topic+scale_edge_colour_centres'></span><span id='topic+scale_edge_color_centres'></span><span id='topic+scale_fill_sdgs'></span><span id='topic+scale_colour_sdgs'></span><span id='topic+scale_color_sdgs'></span><span id='topic+scale_edge_colour_sdgs'></span><span id='topic+scale_edge_color_sdgs'></span><span id='topic+scale_fill_ethz'></span><span id='topic+scale_colour_ethz'></span><span id='topic+scale_color_ethz'></span><span id='topic+scale_edge_colour_ethz'></span><span id='topic+scale_edge_color_ethz'></span><span id='topic+scale_fill_uzh'></span><span id='topic+scale_colour_uzh'></span><span id='topic+scale_color_uzh'></span><span id='topic+scale_edge_colour_uzh'></span><span id='topic+scale_edge_color_uzh'></span><span id='topic+scale_fill_rug'></span><span id='topic+scale_colour_rug'></span><span id='topic+scale_color_rug'></span><span id='topic+scale_edge_colour_rug'></span><span id='topic+scale_edge_color_rug'></span>

<h3>Description</h3>

<p>These functions enable to add color scales to be graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_iheid(direction = 1, ...)

scale_colour_iheid(direction = 1, ...)

scale_color_iheid(direction = 1, ...)

scale_edge_colour_iheid(direction = 1, ...)

scale_edge_color_iheid(direction = 1, ...)

scale_fill_centres(direction = 1, ...)

scale_colour_centres(direction = 1, ...)

scale_color_centres(direction = 1, ...)

scale_edge_colour_centres(direction = 1, ...)

scale_edge_color_centres(direction = 1, ...)

scale_fill_sdgs(direction = 1, ...)

scale_colour_sdgs(direction = 1, ...)

scale_color_sdgs(direction = 1, ...)

scale_edge_colour_sdgs(direction = 1, ...)

scale_edge_color_sdgs(direction = 1, ...)

scale_fill_ethz(direction = 1, ...)

scale_colour_ethz(direction = 1, ...)

scale_color_ethz(direction = 1, ...)

scale_edge_colour_ethz(direction = 1, ...)

scale_edge_color_ethz(direction = 1, ...)

scale_fill_uzh(direction = 1, ...)

scale_colour_uzh(direction = 1, ...)

scale_color_uzh(direction = 1, ...)

scale_edge_colour_uzh(direction = 1, ...)

scale_edge_color_uzh(direction = 1, ...)

scale_fill_rug(direction = 1, ...)

scale_colour_rug(direction = 1, ...)

scale_color_rug(direction = 1, ...)

scale_edge_colour_rug(direction = 1, ...)

scale_edge_color_rug(direction = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_scales_+3A_direction">direction</code></td>
<td>
<p>Direction for using palette colors.</p>
</td></tr>
<tr><td><code id="map_scales_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>ggplot2::discrete_scale()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#ison_brandes %&gt;%
#mutate(core = migraph::node_is_core(ison_brandes)) %&gt;%
#graphr(node_color = "core") +
#scale_color_iheid()
#graphr(ison_physicians[[1]], edge_color = "type") +
#scale_edge_color_ethz()
</code></pre>

<hr>
<h2 id='map_themes'>Many themes</h2><span id='topic+map_themes'></span><span id='topic+set_manynet_theme'></span><span id='topic+theme_iheid'></span><span id='topic+theme_ethz'></span><span id='topic+theme_uzh'></span><span id='topic+theme_rug'></span>

<h3>Description</h3>

<p>These functions enable graphs to be easily and quickly themed,
e.g. changing the default colour of the graph's vertices and edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_manynet_theme(theme = "default")

theme_iheid(base_size = 12, base_family = "serif")

theme_ethz(base_size = 12, base_family = "sans")

theme_uzh(base_size = 12, base_family = "sans")

theme_rug(base_size = 12, base_family = "mono")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_themes_+3A_theme">theme</code></td>
<td>
<p>String naming a theme.
By default &quot;default&quot;.</p>
</td></tr>
<tr><td><code id="map_themes_+3A_base_size">base_size</code></td>
<td>
<p>Font size, by default 12.</p>
</td></tr>
<tr><td><code id="map_themes_+3A_base_family">base_family</code></td>
<td>
<p>Font family, by default &quot;sans&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>to_mentoring(ison_brandes) %&gt;%
  mutate(color = c(rep(c(1,2,3), 3), 3)) %&gt;%
  graphr(node_color = "color") +
  labs(title = "Who leads and who follows?") +
  scale_color_iheid() +
  theme_iheid()
</code></pre>

<hr>
<h2 id='mark_core'>Core-periphery clustering algorithms</h2><span id='topic+mark_core'></span><span id='topic+node_is_core'></span><span id='topic+node_coreness'></span>

<h3>Description</h3>

<p>These functions identify nodes belonging to (some level of) the core of a network:
</p>

<ul>
<li> <p><code>node_is_core()</code> assigns nodes to either the core or periphery.
</p>
</li>
<li> <p><code>node_coreness()</code> assigns nodes to their level of k-coreness.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_is_core(.data, method = c("degree", "eigenvector"))

node_coreness(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark_core_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="mark_core_+3A_method">method</code></td>
<td>
<p>Which method to use to identify cores and periphery.
By default this is &quot;degree&quot;,
which relies on the heuristic that high degree nodes are more likely to be in the core.
An alternative is &quot;eigenvector&quot;, which instead begins with high eigenvector nodes.
Other methods, such as a genetic algorithm, CONCOR, and Rombach-Porter,
can be added if there is interest.</p>
</td></tr>
</table>


<h3>Core-periphery</h3>

<p>This function is used to identify which nodes should belong to the core,
and which to the periphery.
It seeks to minimize the following quantity:
</p>
<p style="text-align: center;"><code class="reqn">Z(S_1) = \sum_{(i&lt;j)\in S_1} \textbf{I}_{\{A_{ij}=0\}} + \sum_{(i&lt;j)\notin S_1} \textbf{I}_{\{A_{ij}=1\}}</code>
</p>

<p>where nodes <code class="reqn">\{i,j,...,n\}</code> are ordered in descending degree,
<code class="reqn">A</code> is the adjacency matrix,
and the indicator function is 1 if the predicate is true or 0 otherwise.
Note that minimising this quantity maximises density in the core block
and minimises density in the periphery block;
it ignores ties between these blocks.
</p>


<h3>References</h3>



<h4>On core-periphery partitioning</h4>

<p>Borgatti, Stephen P., &amp; Everett, Martin G. 1999.
Models of core /periphery structures.
<em>Social Networks</em>, 21, 375–395.
<a href="https://doi.org/10.1016/S0378-8733%2899%2900019-2">doi:10.1016/S0378-8733(99)00019-2</a>
</p>
<p>Lip, Sean Z. W. 2011.
“A Fast Algorithm for the Discrete Core/Periphery Bipartitioning Problem.”
<a href="https://doi.org/10.48550/arXiv.1102.5511">doi:10.48550/arXiv.1102.5511</a>
</p>



<h3>See Also</h3>

<p>Other memberships: 
<code><a href="#topic+member_brokerage">member_brokerage</a></code>,
<code><a href="#topic+member_cliques">member_cliques</a></code>,
<code><a href="#topic+member_community_hier">member_community_hier</a></code>,
<code><a href="#topic+member_community_non">member_community_non</a></code>,
<code><a href="#topic+member_components">member_components</a></code>,
<code><a href="#topic+member_equivalence">member_equivalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_is_core(ison_adolescents)
#ison_adolescents %&gt;% 
#   mutate(corep = node_is_core()) %&gt;% 
#   graphr(node_color = "corep")
node_coreness(ison_adolescents)
</code></pre>

<hr>
<h2 id='mark_diff'>Marking nodes based on diffusion properties</h2><span id='topic+mark_diff'></span><span id='topic+node_is_latent'></span><span id='topic+node_is_infected'></span><span id='topic+node_is_recovered'></span><span id='topic+node_is_exposed'></span>

<h3>Description</h3>

<p>These functions return logical vectors the length of the
nodes in a network identifying which hold certain properties or positions in the network.
</p>

<ul>
<li> <p><code>node_is_infected()</code> marks nodes that are infected by a particular time point.
</p>
</li>
<li> <p><code>node_is_exposed()</code> marks nodes that are exposed to a given (other) mark.
</p>
</li>
<li> <p><code>node_is_latent()</code> marks nodes that are latent at a particular time point.
</p>
</li>
<li> <p><code>node_is_recovered()</code> marks nodes that are recovered at a particular time point.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_is_latent(diff_model, time = 0)

node_is_infected(diff_model, time = 0)

node_is_recovered(diff_model, time = 0)

node_is_exposed(.data, mark)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark_diff_+3A_diff_model">diff_model</code></td>
<td>
<p>A diff_model object,
created either by <code>play_diffusion()</code> or <code>as_diffusion()</code>.</p>
</td></tr>
<tr><td><code id="mark_diff_+3A_time">time</code></td>
<td>
<p>A time step at which nodes are identified.</p>
</td></tr>
<tr><td><code id="mark_diff_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="mark_diff_+3A_mark">mark</code></td>
<td>
<p>vector denoting which nodes are infected</p>
</td></tr>
</table>


<h3>Exposed</h3>

<p><code>node_is_exposed()</code> is similar to <code>node_exposure()</code>,
but returns a mark (TRUE/FALSE) vector indicating which nodes
are currently exposed to the diffusion content.
This diffusion content can be expressed in the 'mark' argument.
If no 'mark' argument is provided,
and '.data' is a diff_model object,
then the function will return nodes exposure to the seed nodes
in that diffusion.
</p>


<h3>See Also</h3>

<p>Other marks: 
<code><a href="#topic+mark_nodes">mark_nodes</a></code>,
<code><a href="#topic+mark_select">mark_select</a></code>,
<code><a href="#topic+mark_tie_select">mark_tie_select</a></code>,
<code><a href="#topic+mark_ties">mark_ties</a></code>,
<code><a href="#topic+mark_triangles">mark_triangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # To mark nodes that are latent by a particular time point
  node_is_latent(play_diffusion(create_tree(6), latency = 1), time = 1)
  # To mark nodes that are infected by a particular time point
  node_is_infected(play_diffusion(create_tree(6)), time = 1)
  # To mark nodes that are recovered by a particular time point
  node_is_recovered(play_diffusion(create_tree(6), recovery = 0.5), time = 3)
  # To mark which nodes are currently exposed
  (expos &lt;- node_is_exposed(manynet::create_tree(14), mark = c(1,3)))
  which(expos)
</code></pre>

<hr>
<h2 id='mark_features'>Marking networks features</h2><span id='topic+mark_features'></span><span id='topic+is_connected'></span><span id='topic+is_perfect_matching'></span><span id='topic+is_eulerian'></span><span id='topic+is_acyclic'></span><span id='topic+is_aperiodic'></span>

<h3>Description</h3>

<p>These functions implement logical tests for various network
features.
</p>

<ul>
<li> <p><code>is_connected()</code> tests whether network is strongly connected,
or weakly connected if undirected.
</p>
</li>
<li> <p><code>is_perfect_matching()</code> tests whether there is a matching
for a network that covers every node in the network.
</p>
</li>
<li> <p><code>is_eulerian()</code> tests whether there is a Eulerian path for a network
where that path passes through every tie exactly once.
</p>
</li>
<li> <p><code>is_acyclic()</code> tests whether network is a directed acyclic graph.
</p>
</li>
<li> <p><code>is_aperiodic()</code> tests whether network is aperiodic.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is_connected(.data)

is_perfect_matching(.data, mark = "type")

is_eulerian(.data)

is_acyclic(.data)

is_aperiodic(.data, max_path_length = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark_features_+3A_.data">.data</code></td>
<td>
<p>An object of a <code>{manynet}</code>-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="mark_features_+3A_mark">mark</code></td>
<td>
<p>A logical vector marking two types or modes.
By default &quot;type&quot;.</p>
</td></tr>
<tr><td><code id="mark_features_+3A_max_path_length">max_path_length</code></td>
<td>
<p>Maximum path length considered.
If negative, paths of all lengths are considered.
By default 4, to avoid potentially very long computation times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the condition is met, or FALSE otherwise.
</p>


<h3>is_connected</h3>

<p>To test weak connection on a directed network,
please see <code>to_undirected()</code>.
</p>


<h3>is_perfect_matching</h3>

<p>For two-mode or bipartite networks, <code>to_matching()</code> is used
to identify whether a perfect matching is possible.
For one-mode networks, we use the Tutte theorem.
Note that currently only subgraphs with cutpoints removed are tested,
and not all possible subgraphs.
This is to avoid computationally expensive combinatorial operations,
but may come at the cost of some edge cases where a one-mode network
cannot perfectly match as suggested.
</p>


<h3>Source</h3>

<p>https://stackoverflow.com/questions/55091438/r-igraph-find-all-cycles
</p>


<h3>References</h3>



<h4>On perfect matching</h4>

<p>Tutte, William T. 1950.
&quot;The factorization of locally finite graphs&quot;.
<em>Canadian Journal of Mathematics</em>. 2: 44–49.
<a href="https://doi.org/10.4153/cjm-1950-005-2">doi:10.4153/cjm-1950-005-2</a>
</p>



<h4>On aperiodicity</h4>

<p>Jarvis, J.P, and D.R. Shier. 1996.
&quot;Graph-theoretic analysis of finite Markov chains&quot;,
in Shier, D.R., Wallenius, K.T. (eds) <em>Applied Mathematical Modeling: A Multidisciplinary Approach</em>.
CRC Press.
</p>



<h3>See Also</h3>

<p>Other marking: 
<code><a href="#topic+mark_format">mark_format</a></code>,
<code><a href="#topic+mark_is">mark_is</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_connected(ison_southern_women)
is_perfect_matching(ison_southern_women)
is_eulerian(ison_brandes)
is_acyclic(ison_algebra)
is_aperiodic(ison_algebra)
</code></pre>

<hr>
<h2 id='mark_format'>Marking networks formats</h2><span id='topic+mark_format'></span><span id='topic+is_twomode'></span><span id='topic+is_weighted'></span><span id='topic+is_directed'></span><span id='topic+is_labelled'></span><span id='topic+is_signed'></span><span id='topic+is_complex'></span><span id='topic+is_multiplex'></span><span id='topic+is_uniplex'></span><span id='topic+is_attributed'></span>

<h3>Description</h3>

<p>These functions implement logical tests for various network properties.
All <code style="white-space: pre;">&#8288;is_*()&#8288;</code> functions return a logical scalar (TRUE or FALSE).
</p>

<ul>
<li> <p><code>is_twomode()</code> marks networks TRUE if they contain two sets of nodes.
</p>
</li>
<li> <p><code>is_weighted()</code> marks networks TRUE if they contain tie weights.
</p>
</li>
<li> <p><code>is_directed()</code> marks networks TRUE if the ties specify which node
is the sender and which the receiver.
</p>
</li>
<li> <p><code>is_labelled()</code> marks networks TRUE if there is a 'names' attribute
for the nodes.
</p>
</li>
<li> <p><code>is_attributed()</code> marks networks TRUE if there are other nodal attributes
than 'names' or 'type'.
</p>
</li>
<li> <p><code>is_signed()</code> marks networks TRUE if the ties can be either positive
or negative.
</p>
</li>
<li> <p><code>is_complex()</code> marks networks TRUE if any ties are loops,
with the sender and receiver being the same node.
</p>
</li>
<li> <p><code>is_multiplex()</code> marks networks TRUE if it contains multiple types
of ties, such that there can be multiple ties between the same
sender and receiver.
</p>
</li>
<li> <p><code>is_uniplex()</code> marks networks TRUE if it is neither complex nor multiplex.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is_twomode(.data)

is_weighted(.data)

is_directed(.data)

is_labelled(.data)

is_signed(.data)

is_complex(.data)

is_multiplex(.data)

is_uniplex(.data)

is_attributed(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark_format_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other marking: 
<code><a href="#topic+mark_features">mark_features</a></code>,
<code><a href="#topic+mark_is">mark_is</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_twomode(create_filled(c(2,2)))
is_weighted(create_tree(3))
is_directed(create_tree(2))
is_directed(create_tree(2, directed = TRUE))
is_labelled(create_empty(3))
is_signed(create_lattice(3))
is_complex(create_lattice(4))
is_multiplex(create_filled(c(3,3)))
is_uniplex(create_star(3))
is_attributed(ison_algebra)
</code></pre>

<hr>
<h2 id='mark_is'>Marking networks classes</h2><span id='topic+mark_is'></span><span id='topic+is_manynet'></span><span id='topic+is_graph'></span><span id='topic+is_edgelist'></span><span id='topic+is_list'></span><span id='topic+is_longitudinal'></span><span id='topic+is_dynamic'></span>

<h3>Description</h3>

<p>These functions implement logical tests for networks' classes.
</p>

<ul>
<li> <p><code>is_manynet()</code> marks a network TRUE if it is compatible with <code>{manynet}</code> functions.
</p>
</li>
<li> <p><code>is_edgelist()</code> marks a network TRUE if it is an edgelist.
</p>
</li>
<li> <p><code>is_graph()</code> marks a network TRUE if it contains graph-level information.
</p>
</li>
<li> <p><code>is_list()</code> marks a network TRUE if it is a (non-igraph) list of networks,
for example a set of ego networks or a dynamic or longitudinal set of networks.
</p>
</li>
<li> <p><code>is_longitudinal()</code> marks a network TRUE if it contains longitudinal, panel data.
</p>
</li>
<li> <p><code>is_dynamic()</code> marks a network TRUE if it contains dynamic, time-stamped data
</p>
</li></ul>

<p>All <code style="white-space: pre;">&#8288;is_*()&#8288;</code> functions return a logical scalar (TRUE or FALSE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_manynet(.data)

is_graph(.data)

is_edgelist(.data)

is_list(.data)

is_longitudinal(.data)

is_dynamic(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark_is_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the condition is met, or FALSE otherwise.
</p>


<h3>See Also</h3>

<p>Other marking: 
<code><a href="#topic+mark_features">mark_features</a></code>,
<code><a href="#topic+mark_format">mark_format</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_manynet(create_filled(2))
is_graph(create_star(2))
is_edgelist(matrix(c(2,2), 1, 2))
is_edgelist(as_edgelist(matrix(c(2,2), 1, 2)))
is_longitudinal(create_tree(5, 3))
is_dynamic(create_tree(3))
</code></pre>

<hr>
<h2 id='mark_nodes'>Marking nodes based on structural properties</h2><span id='topic+mark_nodes'></span><span id='topic+node_is_isolate'></span><span id='topic+node_is_pendant'></span><span id='topic+node_is_independent'></span><span id='topic+node_is_cutpoint'></span><span id='topic+node_is_fold'></span><span id='topic+node_is_mentor'></span><span id='topic+node_is_neighbor'></span>

<h3>Description</h3>

<p>These functions return logical vectors the length of the
nodes in a network identifying which hold certain properties or positions in the network.
</p>

<ul>
<li> <p><code>node_is_isolate()</code> marks nodes that are isolates,
with neither incoming nor outgoing ties.
</p>
</li>
<li> <p><code>node_is_independent()</code> marks nodes that are members of the largest independent set,
aka largest internally stable set.
</p>
</li>
<li> <p><code>node_is_cutpoint()</code> marks nodes that cut or act as articulation points in a network,
increasing the number of connected components when removed.
</p>
</li>
<li> <p><code>node_is_core()</code> marks nodes that are members of the network's core.
</p>
</li>
<li> <p><code>node_is_fold()</code> marks nodes that are in a structural fold between two or more
triangles that are only connected by that node.
</p>
</li>
<li> <p><code>node_is_mentor()</code> marks a proportion of high indegree nodes as 'mentors' (see details).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_is_isolate(.data)

node_is_pendant(.data)

node_is_independent(.data)

node_is_cutpoint(.data)

node_is_fold(.data)

node_is_mentor(.data, elites = 0.1)

node_is_neighbor(.data, node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark_nodes_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="mark_nodes_+3A_elites">elites</code></td>
<td>
<p>The proportion of nodes to be selected as mentors.
By default this is set at 0.1.
This means that the top 10% of nodes in terms of degree,
or those equal to the highest rank degree in the network,
whichever is the higher, will be used to select the mentors.
</p>
<p>Note that if nodes are equidistant from two mentors,
they will choose one at random.
If a node is without a path to a mentor,
for example because they are an isolate,
a tie to themselves (a loop) will be created instead.
Note that this is a different default behaviour than that
described in Valente and Davis (1999).</p>
</td></tr>
<tr><td><code id="mark_nodes_+3A_node">node</code></td>
<td>
<p>Name or index of node.</p>
</td></tr>
</table>


<h3>References</h3>



<h4>On independent sets</h4>

<p>Tsukiyama, Shuji, Mikio Ide, Hiromu Ariyoshi, and Isao Shirawaka. 1977.
&quot;A new algorithm for generating all the maximal independent sets&quot;.
<em>SIAM Journal on Computing</em>, 6(3):505–517.
<a href="https://doi.org/10.1137/0206036">doi:10.1137/0206036</a>
</p>



<h4>On articulation or cut-points</h4>

<p>Tarjan, Robert E. and Uzi Vishkin. 1985.
&quot;An Efficient Parallel Biconnectivity Algorithm&quot;,
<em>SIAM Journal on Computing</em> 14(4): 862-874.
<a href="https://doi.org/10.1137/0214061">doi:10.1137/0214061</a>
</p>



<h4>On structural folds</h4>

<p>Vedres, Balazs, and David Stark. 2010.
&quot;Structural folds: Generative disruption in overlapping groups&quot;,
<em>American Journal of Sociology</em> 115(4): 1150-1190.
<a href="https://doi.org/10.1086/649497">doi:10.1086/649497</a>
</p>



<h4>On mentoring</h4>

<p>Valente, Thomas, and Rebecca Davis. 1999.
&quot;Accelerating the Diffusion of Innovations Using Opinion Leaders&quot;,
<em>Annals of the American Academy of Political and Social Science</em> 566: 56-67.
</p>



<h3>See Also</h3>

<p>Other marks: 
<code><a href="#topic+mark_diff">mark_diff</a></code>,
<code><a href="#topic+mark_select">mark_select</a></code>,
<code><a href="#topic+mark_tie_select">mark_tie_select</a></code>,
<code><a href="#topic+mark_ties">mark_ties</a></code>,
<code><a href="#topic+mark_triangles">mark_triangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_is_isolate(ison_brandes)
node_is_independent(ison_adolescents)
node_is_cutpoint(ison_brandes)
node_is_fold(create_explicit(A-B, B-C, A-C, C-D, C-E, D-E))
</code></pre>

<hr>
<h2 id='mark_select'>Marking nodes for selection based on measures</h2><span id='topic+mark_select'></span><span id='topic+node_is_random'></span><span id='topic+node_is_max'></span><span id='topic+node_is_min'></span>

<h3>Description</h3>

<p>These functions return logical vectors the length of the
nodes in a network identifying which hold certain properties or positions in the network.
</p>

<ul>
<li> <p><code>node_is_random()</code> marks one or more nodes at random.
</p>
</li>
<li> <p><code>node_is_max()</code> and <code>node_is_min()</code> are more generally useful
for converting the results from some node measure into a mark-class object.
They can be particularly useful for highlighting which node or nodes
are key because they minimise or, more often, maximise some measure.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_is_random(.data, size = 1)

node_is_max(node_measure, ranks = 1)

node_is_min(node_measure, ranks = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark_select_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="mark_select_+3A_size">size</code></td>
<td>
<p>The number of nodes to select (as TRUE).</p>
</td></tr>
<tr><td><code id="mark_select_+3A_node_measure">node_measure</code></td>
<td>
<p>An object created by a <code>node_</code> measure.</p>
</td></tr>
<tr><td><code id="mark_select_+3A_ranks">ranks</code></td>
<td>
<p>The number of ranks of max or min to return.
For example, <code>ranks = 3</code> will return TRUE for nodes with
scores equal to any of the top (or, for <code>node_is_min()</code>, bottom)
three scores.
By default, <code>ranks = 1</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other marks: 
<code><a href="#topic+mark_diff">mark_diff</a></code>,
<code><a href="#topic+mark_nodes">mark_nodes</a></code>,
<code><a href="#topic+mark_tie_select">mark_tie_select</a></code>,
<code><a href="#topic+mark_ties">mark_ties</a></code>,
<code><a href="#topic+mark_triangles">mark_triangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_is_random(ison_brandes, 2)
#node_is_max(migraph::node_degree(ison_brandes))
#node_is_min(migraph::node_degree(ison_brandes))
</code></pre>

<hr>
<h2 id='mark_tie_select'>Marking ties for selection based on measures</h2><span id='topic+mark_tie_select'></span><span id='topic+tie_is_random'></span><span id='topic+tie_is_max'></span><span id='topic+tie_is_min'></span>

<h3>Description</h3>

<p>These functions return logical vectors the length of the ties in a network:
</p>

<ul>
<li> <p><code>tie_is_random()</code> marks one or more ties at random.
</p>
</li>
<li> <p><code>tie_is_max()</code> and <code>tie_is_min()</code> are more useful
for converting the results from some tie measure into a mark-class object.
They can be particularly useful for highlighting which tie or ties
are key because they minimise or, more often, maximise some measure.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>tie_is_random(.data, size = 1)

tie_is_max(tie_measure)

tie_is_min(tie_measure)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark_tie_select_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="mark_tie_select_+3A_size">size</code></td>
<td>
<p>The number of nodes to select (as TRUE).</p>
</td></tr>
<tr><td><code id="mark_tie_select_+3A_tie_measure">tie_measure</code></td>
<td>
<p>An object created by a <code>tie_</code> measure.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other marks: 
<code><a href="#topic+mark_diff">mark_diff</a></code>,
<code><a href="#topic+mark_nodes">mark_nodes</a></code>,
<code><a href="#topic+mark_select">mark_select</a></code>,
<code><a href="#topic+mark_ties">mark_ties</a></code>,
<code><a href="#topic+mark_triangles">mark_triangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tie_is_max(migraph::tie_betweenness(ison_brandes))
#tie_is_min(migraph::tie_betweenness(ison_brandes))
</code></pre>

<hr>
<h2 id='mark_ties'>Marking ties based on structural properties</h2><span id='topic+mark_ties'></span><span id='topic+tie_is_multiple'></span><span id='topic+tie_is_loop'></span><span id='topic+tie_is_reciprocated'></span><span id='topic+tie_is_feedback'></span><span id='topic+tie_is_bridge'></span><span id='topic+tie_is_path'></span>

<h3>Description</h3>

<p>These functions return logical vectors the length of the ties
in a network identifying which hold certain properties or positions in the network.
</p>

<ul>
<li> <p><code>tie_is_multiple()</code> marks ties that are multiples.
</p>
</li>
<li> <p><code>tie_is_loop()</code> marks ties that are loops.
</p>
</li>
<li> <p><code>tie_is_reciprocated()</code> marks ties that are mutual/reciprocated.
</p>
</li>
<li> <p><code>tie_is_feedback()</code> marks ties that are feedback arcs causing the network to not be acyclic.
</p>
</li>
<li> <p><code>tie_is_bridge()</code> marks ties that cut or act as articulation points in a network.
</p>
</li>
<li> <p><code>tie_is_path()</code> marks ties on a path from one node to another.
</p>
</li></ul>

<p>They are most useful in highlighting parts of the network that
are particularly well- or poorly-connected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tie_is_multiple(.data)

tie_is_loop(.data)

tie_is_reciprocated(.data)

tie_is_feedback(.data)

tie_is_bridge(.data)

tie_is_path(.data, from, to, all_paths = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark_ties_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="mark_ties_+3A_from">from</code></td>
<td>
<p>The index or name of the node from which the path should be traced.</p>
</td></tr>
<tr><td><code id="mark_ties_+3A_to">to</code></td>
<td>
<p>The index or name of the node to which the path should be traced.</p>
</td></tr>
<tr><td><code id="mark_ties_+3A_all_paths">all_paths</code></td>
<td>
<p>Whether to return a list of paths or sample just one.
By default FALSE, sampling just a single path.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other marks: 
<code><a href="#topic+mark_diff">mark_diff</a></code>,
<code><a href="#topic+mark_nodes">mark_nodes</a></code>,
<code><a href="#topic+mark_select">mark_select</a></code>,
<code><a href="#topic+mark_tie_select">mark_tie_select</a></code>,
<code><a href="#topic+mark_triangles">mark_triangles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tie_is_multiple(ison_marvel_relationships)
tie_is_loop(ison_marvel_relationships)
tie_is_reciprocated(ison_algebra)
tie_is_feedback(ison_algebra)
tie_is_bridge(ison_brandes)
ison_adolescents %&gt;%
  mutate_ties(route = tie_is_path(from = "Jane", to = 7)) %&gt;% 
  graphr(edge_colour = "route")
</code></pre>

<hr>
<h2 id='mark_triangles'>Marking ties based on structural properties</h2><span id='topic+mark_triangles'></span><span id='topic+tie_is_triangular'></span><span id='topic+tie_is_transitive'></span><span id='topic+tie_is_triplet'></span><span id='topic+tie_is_cyclical'></span><span id='topic+tie_is_simmelian'></span><span id='topic+tie_is_forbidden'></span><span id='topic+tie_is_imbalanced'></span>

<h3>Description</h3>

<p>These functions return logical vectors the length of the ties
in a network identifying which hold certain properties or positions in the network.
</p>

<ul>
<li> <p><code>tie_is_triangular()</code> marks ties that are in triangles.
</p>
</li>
<li> <p><code>tie_is_cyclical()</code> marks ties that are in cycles.
</p>
</li>
<li> <p><code>tie_is_transitive()</code> marks ties that complete transitive closure.
</p>
</li>
<li> <p><code>tie_is_triplet()</code> marks ties that are in a transitive triplet.
</p>
</li>
<li> <p><code>tie_is_simmelian()</code> marks ties that are both in a triangle
and fully reciprocated.
</p>
</li></ul>

<p>They are most useful in highlighting parts of the network that
are cohesively connected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tie_is_triangular(.data)

tie_is_transitive(.data)

tie_is_triplet(.data)

tie_is_cyclical(.data)

tie_is_simmelian(.data)

tie_is_forbidden(.data)

tie_is_imbalanced(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark_triangles_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other marks: 
<code><a href="#topic+mark_diff">mark_diff</a></code>,
<code><a href="#topic+mark_nodes">mark_nodes</a></code>,
<code><a href="#topic+mark_select">mark_select</a></code>,
<code><a href="#topic+mark_tie_select">mark_tie_select</a></code>,
<code><a href="#topic+mark_ties">mark_ties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ison_monks %&gt;% to_uniplex("like") %&gt;% 
  mutate_ties(tri = tie_is_triangular()) %&gt;% 
  graphr(edge_color = "tri")
ison_adolescents %&gt;% to_directed() %&gt;% 
  mutate_ties(trans = tie_is_transitive()) %&gt;% 
  graphr(edge_color = "trans")
ison_adolescents %&gt;% to_directed() %&gt;% 
  mutate_ties(trip = tie_is_triplet()) %&gt;% 
  graphr(edge_color = "trip")
ison_adolescents %&gt;% to_directed() %&gt;% 
  mutate_ties(cyc = tie_is_cyclical()) %&gt;% 
  graphr(edge_color = "cyc")
ison_monks %&gt;% to_uniplex("like") %&gt;% 
  mutate_ties(simmel = tie_is_simmelian()) %&gt;% 
  graphr(edge_color = "simmel")
generate_random(8, directed = TRUE) %&gt;% 
  mutate_ties(forbid = tie_is_forbidden()) %&gt;% 
  graphr(edge_color = "forbid")
tie_is_imbalanced(ison_marvel_relationships)
</code></pre>

<hr>
<h2 id='measure_attributes'>Describing attributes of nodes or ties in a network</h2><span id='topic+measure_attributes'></span><span id='topic+node_attribute'></span><span id='topic+node_names'></span><span id='topic+node_is_mode'></span><span id='topic+tie_attribute'></span><span id='topic+tie_weights'></span><span id='topic+tie_signs'></span>

<h3>Description</h3>

<p>These functions extract certain attributes from network data:
</p>

<ul>
<li> <p><code>node_attribute()</code> returns an attribute's values for the nodes in a network.
</p>
</li>
<li> <p><code>node_names()</code> returns the names of the nodes in a network.
</p>
</li>
<li> <p><code>node_is_mode()</code> returns the mode of the nodes in a network.
</p>
</li>
<li> <p><code>tie_attribute()</code> returns an attribute's values for the ties in a network.
</p>
</li>
<li> <p><code>tie_weights()</code> returns the weights of the ties in a network.
</p>
</li>
<li> <p><code>tie_signs()</code> returns the signs of the ties in a network.
</p>
</li></ul>

<p>These functions are also often used as helpers within other functions.
<code style="white-space: pre;">&#8288;node_*()&#8288;</code> and <code style="white-space: pre;">&#8288;tie_*()&#8288;</code> always return vectors the same length
as the number of nodes or ties in the network, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_attribute(.data, attribute)

node_names(.data)

node_is_mode(.data)

tie_attribute(.data, attribute)

tie_weights(.data)

tie_signs(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_attributes_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_attributes_+3A_attribute">attribute</code></td>
<td>
<p>Character string naming an attribute in the object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_attribute(fict_lotr, "Race")
node_names(ison_southern_women)
node_is_mode(ison_southern_women)
tie_attribute(ison_algebra, "task_tie")
tie_weights(to_mode1(ison_southern_women))
tie_signs(ison_marvel_relationships)
</code></pre>

<hr>
<h2 id='measure_central_between'>Measures of betweenness-like centrality and centralisation</h2><span id='topic+measure_central_between'></span><span id='topic+node_betweenness'></span><span id='topic+node_induced'></span><span id='topic+node_flow'></span><span id='topic+node_stress'></span><span id='topic+tie_betweenness'></span><span id='topic+net_betweenness'></span>

<h3>Description</h3>

<p>These functions calculate common betweenness-related centrality measures for one- and two-mode networks:
</p>

<ul>
<li> <p><code>node_betweenness()</code> measures the betweenness centralities of nodes in a network.
</p>
</li>
<li> <p><code>node_induced()</code> measures the induced betweenness centralities of nodes in a network.
</p>
</li>
<li> <p><code>node_flow()</code> measures the flow betweenness centralities of nodes in a network,
which uses an electrical current model for information spreading
in contrast to the shortest paths model used by normal betweenness centrality.
</p>
</li>
<li> <p><code>node_stress()</code> measures the stress centrality of nodes in a network.
</p>
</li>
<li> <p><code>tie_betweenness()</code> measures the number of shortest paths going through a tie.
</p>
</li>
<li> <p><code>net_betweenness()</code> measures the betweenness centralization for a network.
</p>
</li></ul>

<p>All measures attempt to use as much information as they are offered,
including whether the networks are directed, weighted, or multimodal.
If this would produce unintended results,
first transform the salient properties using e.g. <code><a href="#topic+to_undirected">to_undirected()</a></code> functions.
All centrality and centralization measures return normalized measures by default,
including for two-mode networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_betweenness(.data, normalized = TRUE, cutoff = NULL)

node_induced(.data, normalized = TRUE, cutoff = NULL)

node_flow(.data, normalized = TRUE)

node_stress(.data, normalized = TRUE)

tie_betweenness(.data, normalized = TRUE)

net_betweenness(.data, normalized = TRUE, direction = c("all", "out", "in"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_central_between_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_central_between_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td></tr>
<tr><td><code id="measure_central_between_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum path length to consider when calculating betweenness.
If negative or NULL (the default), there's no limit to the path lengths considered.</p>
</td></tr>
<tr><td><code id="measure_central_between_+3A_direction">direction</code></td>
<td>
<p>Character string, “out” bases the measure on outgoing ties,
“in” on incoming ties, and &quot;all&quot; on either/the sum of the two.
For two-mode networks, &quot;all&quot; uses as numerator the sum of differences
between the maximum centrality score for the mode
against all other centrality scores in the network,
whereas &quot;in&quot; uses as numerator the sum of differences
between the maximum centrality score for the mode
against only the centrality scores of the other nodes in that mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector giving the betweenness centrality measure of each node.
</p>


<h3>Betweenness centrality</h3>

<p>Betweenness centrality is based on the number of shortest paths between
other nodes that a node lies upon:
</p>
<p style="text-align: center;"><code class="reqn">C_B(i) = \sum_{j,k:j \neq k, j \neq i, k \neq i} \frac{g_{jik}}{g_{jk}}</code>
</p>



<h3>Induced centrality</h3>

<p>Induced centrality or vitality centrality concerns the change in
total betweenness centrality between networks with and without a given node:
</p>
<p style="text-align: center;"><code class="reqn">C_I(i) = C_B(G) - C_B(G\ i)</code>
</p>



<h3>Flow betweenness centrality</h3>

<p>Flow betweenness centrality concerns the total maximum flow, <code class="reqn">f</code>,
between other nodes <code class="reqn">j,k</code> in a network <code class="reqn">G</code> that a given node mediates:
</p>
<p style="text-align: center;"><code class="reqn">C_F(i) = \sum_{j,k:j\neq k, j\neq i, k\neq i} f(j,k,G) - f(j,k,G\ i)</code>
</p>

<p>When normalized (by default) this sum of differences is divided by the
sum of flows <code class="reqn">f(i,j,G)</code>.
</p>


<h3>Stress centrality</h3>

<p>Stress centrality is the number of all shortest paths or geodesics, <code class="reqn">g</code>,
between other nodes that a given node mediates:
</p>
<p style="text-align: center;"><code class="reqn">C_S(i) = \sum_{j,k:j \neq k, j \neq i, k \neq i} g_{jik}</code>
</p>

<p>High stress nodes lie on a large number of shortest paths between other
nodes, and thus associated with bridging or spanning boundaries.
</p>


<h3>References</h3>



<h4>On betweenness centrality</h4>

<p>Freeman, Linton. 1977.
&quot;A set of measures of centrality based on betweenness&quot;.
<em>Sociometry</em>, 40(1): 35–41.
<a href="https://doi.org/10.2307/3033543">doi:10.2307/3033543</a>
</p>



<h4>On induced centrality</h4>

<p>Everett, Martin and Steve Borgatti. 2010.
&quot;Induced, endogenous and exogenous centrality&quot;
<em>Social Networks</em>, 32: 339-344.
<a href="https://doi.org/10.1016/j.socnet.2010.06.004">doi:10.1016/j.socnet.2010.06.004</a>
</p>



<h4>On flow centrality</h4>

<p>Freeman, Lin, Stephen Borgatti, and Douglas White. 1991.
&quot;Centrality in Valued Graphs: A Measure of Betweenness Based on Network Flow&quot;.
<em>Social Networks</em>, 13(2), 141-154.
</p>
<p>Koschutzki, D., K.A. Lehmann, L. Peeters, S. Richter, D. Tenfelde-Podehl, and O. Zlotowski. 2005.
&quot;Centrality Indices&quot;.
In U. Brandes and T. Erlebach (eds.), <em>Network Analysis: Methodological Foundations</em>.
Berlin: Springer.
</p>



<h4>On stress centrality</h4>

<p>Shimbel, A. 1953.
&quot;Structural Parameters of Communication Networks&quot;.
<em>Bulletin of Mathematical Biophysics</em>, 15:501-507.
<a href="https://doi.org/10.1007/BF02476438">doi:10.1007/BF02476438</a>
</p>



<h3>See Also</h3>

<p>Other centrality: 
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>
</p>
<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_betweenness(ison_southern_women)
node_induced(ison_adolescents)
(tb &lt;- tie_betweenness(ison_adolescents))
plot(tb)
ison_adolescents %&gt;% mutate_ties(weight = tb) %&gt;% 
     graphr()
net_betweenness(ison_southern_women, direction = "in")
</code></pre>

<hr>
<h2 id='measure_central_close'>Measures of closeness-like centrality and centralisation</h2><span id='topic+measure_central_close'></span><span id='topic+node_closeness'></span><span id='topic+node_harmonic'></span><span id='topic+node_reach'></span><span id='topic+node_information'></span><span id='topic+node_eccentricity'></span><span id='topic+node_distance'></span><span id='topic+node_vitality'></span><span id='topic+tie_closeness'></span><span id='topic+net_closeness'></span><span id='topic+net_reach'></span><span id='topic+net_harmonic'></span>

<h3>Description</h3>

<p>These functions calculate common closeness-related centrality measures
that rely on path-length for one- and two-mode networks:
</p>

<ul>
<li> <p><code>node_closeness()</code> measures the closeness centrality of nodes in a
network.
</p>
</li>
<li> <p><code>node_reach()</code> measures nodes' reach centrality,
or how many nodes they can reach within <em>k</em> steps.
</p>
</li>
<li> <p><code>node_harmonic()</code> measures nodes' harmonic centrality or valued
centrality, which is thought to behave better than reach centrality
for disconnected networks.
</p>
</li>
<li> <p><code>node_information()</code> measures nodes' information centrality or
current-flow closeness centrality.
</p>
</li>
<li> <p><code>node_eccentricity()</code> measures nodes' eccentricity or maximum distance
from another node in the network.
</p>
</li>
<li> <p><code>node_distance()</code> measures nodes' geodesic distance from or to a
given node.
</p>
</li>
<li> <p><code>tie_closeness()</code> measures the closeness of each tie to other ties
in the network.
</p>
</li>
<li> <p><code>net_closeness()</code> measures a network's closeness centralization.
</p>
</li>
<li> <p><code>net_reach()</code> measures a network's reach centralization.
</p>
</li>
<li> <p><code>net_harmonic()</code> measures a network's harmonic centralization.
</p>
</li></ul>

<p>All measures attempt to use as much information as they are offered,
including whether the networks are directed, weighted, or multimodal.
If this would produce unintended results,
first transform the salient properties using e.g. <code><a href="#topic+to_undirected">to_undirected()</a></code> functions.
All centrality and centralization measures return normalized measures by default,
including for two-mode networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_closeness(.data, normalized = TRUE, direction = "out", cutoff = NULL)

node_harmonic(.data, normalized = TRUE, cutoff = -1)

node_reach(.data, normalized = TRUE, cutoff = 2)

node_information(.data, normalized = TRUE)

node_eccentricity(.data, normalized = TRUE)

node_distance(.data, from, to, normalized = TRUE)

node_vitality(.data, normalized = TRUE)

tie_closeness(.data, normalized = TRUE)

net_closeness(.data, normalized = TRUE, direction = c("all", "out", "in"))

net_reach(.data, normalized = TRUE, cutoff = 2)

net_harmonic(.data, normalized = TRUE, cutoff = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_central_close_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_central_close_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td></tr>
<tr><td><code id="measure_central_close_+3A_direction">direction</code></td>
<td>
<p>Character string, “out” bases the measure on outgoing ties,
“in” on incoming ties, and &quot;all&quot; on either/the sum of the two.
For two-mode networks, &quot;all&quot; uses as numerator the sum of differences
between the maximum centrality score for the mode
against all other centrality scores in the network,
whereas &quot;in&quot; uses as numerator the sum of differences
between the maximum centrality score for the mode
against only the centrality scores of the other nodes in that mode.</p>
</td></tr>
<tr><td><code id="measure_central_close_+3A_cutoff">cutoff</code></td>
<td>
<p>Maximum path length to use during calculations.</p>
</td></tr>
<tr><td><code id="measure_central_close_+3A_from">from</code>, <code id="measure_central_close_+3A_to">to</code></td>
<td>
<p>Index or name of a node to calculate distances from or to.</p>
</td></tr>
</table>


<h3>Closeness centrality</h3>

<p>Closeness centrality or status centrality is defined as the reciprocal of
the farness or distance, <code class="reqn">d</code>,
from a node to all other nodes in the network:
</p>
<p style="text-align: center;"><code class="reqn">C_C(i) = \frac{1}{\sum_j d(i,j)}</code>
</p>

<p>When (more commonly) normalised, the numerator is instead <code class="reqn">N-1</code>.
</p>


<h3>Harmonic centrality</h3>

<p>Harmonic centrality or valued centrality reverses the sum and reciprocal
operations compared to closeness centrality:
</p>
<p style="text-align: center;"><code class="reqn">C_H(i) = \sum_{i, i \neq j} \frac{1}{d(i,j)}</code>
</p>

<p>where <code class="reqn">\frac{1}{d(i,j)} = 0</code> where there is no path between <code class="reqn">i</code> and
<code class="reqn">j</code>. Normalization is by <code class="reqn">N-1</code>.
Since the harmonic mean performs better than the arithmetic mean on
unconnected networks, i.e. networks with infinite distances,
harmonic centrality is to be preferred in these cases.
</p>


<h3>Reach centrality</h3>

<p>In some cases, longer path lengths are irrelevant and 'closeness' should
be defined as how many others are in a local neighbourhood.
How many steps out this neighbourhood should be defined as is given by
the 'cutoff' parameter.
This is usually termed <code class="reqn">k</code> or <code class="reqn">m</code> in equations,
which is why this is sometimes called (<code class="reqn">m</code>- or)
<code class="reqn">k</code>-step reach centrality:
</p>
<p style="text-align: center;"><code class="reqn">C_R(i) = \sum_j d(i,j) \leq k</code>
</p>

<p>The maximum reach score is <code class="reqn">N-1</code>, achieved when the node can reach all
other nodes in the network in <code class="reqn">k</code> steps or less,
but the normalised version, <code class="reqn">\frac{C_R}{N-1}</code>, is more common.
Note that if <code class="reqn">k = 1</code> (i.e. cutoff = 1), then this returns the node's degree.
At higher cutoff reach centrality returns the size of the node's component.
</p>


<h3>Information centrality</h3>

<p>Information centrality, also known as current-flow centrality,
is a hybrid measure relating to both path-length and walk-based measures.
The information centrality of a node is the harmonic average of the
“bandwidth” or inverse path-length for all paths originating from the node.
</p>
<p>As described in the <code>{sna}</code> package,
information centrality works on an undirected but potentially weighted
network excluding isolates (which take scores of zero).
It is defined as:
</p>
<p style="text-align: center;"><code class="reqn">C_I = \frac{1}{T + \frac{\sum T - 2 \sum C_1}{|N|}}</code>
</p>

<p>where <code class="reqn">C = B^-1</code> with <code class="reqn">B</code> is a pseudo-adjacency matrix replacing
the diagonal of <code class="reqn">1-A</code> with <code class="reqn">1+k</code>,
and <code class="reqn">T</code> is the trace of <code class="reqn">C</code> and <code class="reqn">S_R</code> an arbitrary row sum
(all rows in <code class="reqn">C</code> have the same sum).
</p>
<p>Nodes with higher information centrality have a large number of short paths
to many others in the network, and are thus considered to have greater
control of the flow of information.
</p>


<h3>Eccentricity centrality</h3>

<p>Eccentricity centrality, graph centrality, or the Koenig number,
is the (if normalized, inverse of) the distance to the furthest node:
</p>
<p style="text-align: center;"><code class="reqn">C_E(i) = \frac{1}{max_{j \in N} d(i,j)}</code>
</p>

<p>where the distance from <code class="reqn">i</code> to <code class="reqn">j</code> is <code class="reqn">\infty</code> if unconnected.
As such it is only well defined for connected networks.
</p>


<h3>Closeness vitality centrality</h3>

<p>The closeness vitality of a node is the change in the sum of all distances
in a network, also known as the Wiener Index, when that node is removed.
Note that the closeness vitality may be negative infinity if
removing that node would disconnect the network.
</p>


<h3>References</h3>



<h4>On closeness centrality</h4>

<p>Bavelas, Alex. 1950.
&quot;Communication Patterns in Task‐Oriented Groups&quot;.
<em>The Journal of the Acoustical Society of America</em>, 22(6): 725–730.
<a href="https://doi.org/10.1121/1.1906679">doi:10.1121/1.1906679</a>
</p>
<p>Harary, Frank. 1959.
&quot;Status and Contrastatus&quot;.
<em>Sociometry</em>, 22(1): 23–43.
<a href="https://doi.org/10.2307/2785610">doi:10.2307/2785610</a>
</p>



<h4>On harmonic centrality</h4>

<p>Marchiori, Massimo, and Vito Latora. 2000.
&quot;Harmony in the small-world&quot;.
<em>Physica A</em> 285: 539-546.
<a href="https://doi.org/10.1016/S0378-4371%2800%2900311-3">doi:10.1016/S0378-4371(00)00311-3</a>
</p>
<p>Dekker, Anthony. 2005.
&quot;Conceptual distance in social network analysis&quot;.
<em>Journal of Social Structure</em> 6(3).
</p>



<h4>On reach centrality</h4>

<p>Borgatti, Stephen P., Martin G. Everett, and J.C. Johnson. 2013.
<em>Analyzing social networks</em>.
London: SAGE Publications Limited.
</p>



<h4>On information centrality</h4>

<p>Stephenson, Karen, and Marvin Zelen. 1989.
&quot;Rethinking centrality: Methods and examples&quot;.
<em>Social Networks</em> 11(1):1-37.
<a href="https://doi.org/10.1016/0378-8733%2889%2990016-6">doi:10.1016/0378-8733(89)90016-6</a>
</p>
<p>Brandes, Ulrik, and Daniel Fleischer. 2005.
&quot;Centrality Measures Based on Current Flow&quot;.
<em>Proc. 22nd Symp. Theoretical Aspects of Computer Science</em> LNCS 3404: 533-544.
<a href="https://doi.org/10.1007/978-3-540-31856-9_44">doi:10.1007/978-3-540-31856-9_44</a>
</p>



<h4>On eccentricity centrality</h4>

<p>Hage, Per, and Frank Harary. 1995.
&quot;Eccentricity and centrality in networks&quot;.
<em>Social Networks</em>, 17(1): 57-63.
<a href="https://doi.org/10.1016/0378-8733%2894%2900248-9">doi:10.1016/0378-8733(94)00248-9</a>
</p>

<p>Koschuetzki, Dirk, Katharina Lehmann, Leon Peeters, Stefan Richter,
Dagmar Tenfelde-Podehl, and Oliver Zlotowski. 2005.
&quot;Centrality Indices&quot;, in
Brandes, Ulrik, and Thomas Erlebach (eds.).
<em>Network Analysis: Methodological Foundations</em>.
Springer: Berlin, pp. 16-61.
</p>


<h3>See Also</h3>

<p>Other centrality: 
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>
</p>
<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_closeness(ison_southern_women)
node_reach(ison_adolescents)
(ec &lt;- tie_closeness(ison_adolescents))
plot(ec)
ison_adolescents %&gt;% mutate_ties(weight = ec) %&gt;% 
   graphr()
net_closeness(ison_southern_women, direction = "in")
</code></pre>

<hr>
<h2 id='measure_central_degree'>Measures of degree-like centrality and centralisation</h2><span id='topic+measure_central_degree'></span><span id='topic+node_degree'></span><span id='topic+node_deg'></span><span id='topic+node_outdegree'></span><span id='topic+node_indegree'></span><span id='topic+node_multidegree'></span><span id='topic+node_posneg'></span><span id='topic+node_leverage'></span><span id='topic+tie_degree'></span><span id='topic+net_degree'></span><span id='topic+net_outdegree'></span><span id='topic+net_indegree'></span>

<h3>Description</h3>

<p>These functions calculate common degree-related centrality measures for one- and two-mode networks:
</p>

<ul>
<li> <p><code>node_degree()</code> measures the degree centrality of nodes in an unweighted network,
or weighted degree/strength of nodes in a weighted network;
there are several related shortcut functions:
</p>

<ul>
<li> <p><code>node_deg()</code> returns the unnormalised results.
</p>
</li>
<li> <p><code>node_indegree()</code> returns the <code>direction = 'in'</code> results.
</p>
</li>
<li> <p><code>node_outdegree()</code> returns the <code>direction = 'out'</code> results.
</p>
</li></ul>

</li>
<li> <p><code>node_multidegree()</code> measures the ratio between types of ties in a multiplex network.
</p>
</li>
<li> <p><code>node_posneg()</code> measures the PN (positive-negative) centrality of a signed network.
</p>
</li>
<li> <p><code>node_leverage()</code> measures the leverage centrality of nodes in a network.
</p>
</li>
<li> <p><code>tie_degree()</code> measures the degree centrality of ties in a network
</p>
</li>
<li> <p><code>net_degree()</code> measures a network's degree centralization;
there are several related shortcut functions:
</p>

<ul>
<li> <p><code>net_indegree()</code> returns the <code>direction = 'out'</code> results.
</p>
</li>
<li> <p><code>net_outdegree()</code> returns the <code>direction = 'out'</code> results.
</p>
</li></ul>

</li></ul>

<p>All measures attempt to use as much information as they are offered,
including whether the networks are directed, weighted, or multimodal.
If this would produce unintended results,
first transform the salient properties using e.g. <code><a href="#topic+to_undirected">to_undirected()</a></code> functions.
All centrality and centralization measures return normalized measures by default,
including for two-mode networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_degree(
  .data,
  normalized = TRUE,
  alpha = 1,
  direction = c("all", "out", "in")
)

node_deg(.data, alpha = 0, direction = c("all", "out", "in"))

node_outdegree(.data, normalized = TRUE, alpha = 0)

node_indegree(.data, normalized = TRUE, alpha = 0)

node_multidegree(.data, tie1, tie2)

node_posneg(.data)

node_leverage(.data)

tie_degree(.data, normalized = TRUE)

net_degree(.data, normalized = TRUE, direction = c("all", "out", "in"))

net_outdegree(.data, normalized = TRUE)

net_indegree(.data, normalized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_central_degree_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_central_degree_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td></tr>
<tr><td><code id="measure_central_degree_+3A_alpha">alpha</code></td>
<td>
<p>Numeric scalar, the positive tuning parameter introduced in
Opsahl et al (2010) for trading off between degree and strength centrality measures.
By default, <code>alpha = 0</code>, which ignores tie weights and the measure is solely based
upon degree (the number of ties).
<code>alpha = 1</code> ignores the number of ties and provides the sum of the tie weights
as strength centrality.
Values between 0 and 1 reflect different trade-offs in the relative contributions of
degree and strength to the final outcome, with 0.5 as the middle ground.
Values above 1 penalise for the number of ties.
Of two nodes with the same sum of tie weights, the node with fewer ties will obtain
the higher score.
This argument is ignored except in the case of a weighted network.</p>
</td></tr>
<tr><td><code id="measure_central_degree_+3A_direction">direction</code></td>
<td>
<p>Character string, “out” bases the measure on outgoing ties,
“in” on incoming ties, and &quot;all&quot; on either/the sum of the two.
For two-mode networks, &quot;all&quot; uses as numerator the sum of differences
between the maximum centrality score for the mode
against all other centrality scores in the network,
whereas &quot;in&quot; uses as numerator the sum of differences
between the maximum centrality score for the mode
against only the centrality scores of the other nodes in that mode.</p>
</td></tr>
<tr><td><code id="measure_central_degree_+3A_tie1">tie1</code></td>
<td>
<p>Character string indicating the first uniplex network.</p>
</td></tr>
<tr><td><code id="measure_central_degree_+3A_tie2">tie2</code></td>
<td>
<p>Character string indicating the second uniplex network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single centralization score if the object was one-mode,
and two centralization scores if the object was two-mode.
</p>
<p>Depending on how and what kind of an object is passed to the function,
the function will return a <code>tidygraph</code> object where the nodes have been updated
</p>


<h3>Leverage centrality</h3>

<p>Leverage centrality concerns the degree of a node compared with that of its
neighbours, <code class="reqn">J</code>:
</p>
<p style="text-align: center;"><code class="reqn">C_L(i) = \frac{1}{deg(i)} \sum_{j \in J(i)} \frac{deg(i) - deg(j)}{deg(i) + deg(j)}</code>
</p>



<h3>References</h3>



<h4>On multimodal centrality</h4>

<p>Faust, Katherine. 1997.
&quot;Centrality in affiliation networks.&quot;
<em>Social Networks</em> 19(2): 157-191.
<a href="https://doi.org/10.1016/S0378-8733%2896%2900300-0">doi:10.1016/S0378-8733(96)00300-0</a>
</p>
<p>Borgatti, Stephen P., and Martin G. Everett. 1997.
&quot;Network analysis of 2-mode data.&quot;
<em>Social Networks</em> 19(3): 243-270.
<a href="https://doi.org/10.1016/S0378-8733%2896%2900301-2">doi:10.1016/S0378-8733(96)00301-2</a>
</p>
<p>Borgatti, Stephen P., and Daniel S. Halgin. 2011.
&quot;Analyzing affiliation networks.&quot;
In <em>The SAGE Handbook of Social Network Analysis</em>,
edited by John Scott and Peter J. Carrington, 417–33.
London, UK: Sage.
<a href="https://doi.org/10.4135/9781446294413.n28">doi:10.4135/9781446294413.n28</a>
</p>



<h4>On strength centrality</h4>

<p>Opsahl, Tore, Filip Agneessens, and John Skvoretz. 2010.
&quot;Node centrality in weighted networks: Generalizing degree and shortest paths.&quot;
<em>Social Networks</em> 32, 245-251.
<a href="https://doi.org/10.1016/j.socnet.2010.03.006">doi:10.1016/j.socnet.2010.03.006</a>
</p>



<h4>On signed centrality</h4>

<p>Everett, Martin G., and Stephen P. Borgatti. 2014.
“Networks Containing Negative Ties.”
<em>Social Networks</em> 38:111–20.
<a href="https://doi.org/10.1016/j.socnet.2014.03.005">doi:10.1016/j.socnet.2014.03.005</a>
</p>



<h4>On leverage centrality</h4>

<p>Joyce, Karen E., Paul J. Laurienti, Jonathan H. Burdette, and Satoru Hayasaka. 2010.
&quot;A New Measure of Centrality for Brain Networks&quot;.
<em>PLoS ONE</em> 5(8): e12200.
<a href="https://doi.org/10.1371/journal.pone.0012200">doi:10.1371/journal.pone.0012200</a>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+to_undirected">to_undirected()</a></code> for removing edge directions
and <code><a href="#topic+to_unweighted">to_unweighted()</a></code> for removing weights from a graph.
</p>
<p>Other centrality: 
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>
</p>
<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_degree(ison_southern_women)
tie_degree(ison_adolescents)
net_degree(ison_southern_women, direction = "in")
</code></pre>

<hr>
<h2 id='measure_central_eigen'>Measures of eigenvector-like centrality and centralisation</h2><span id='topic+measure_central_eigen'></span><span id='topic+node_eigenvector'></span><span id='topic+node_power'></span><span id='topic+node_alpha'></span><span id='topic+node_pagerank'></span><span id='topic+node_authority'></span><span id='topic+node_hub'></span><span id='topic+tie_eigenvector'></span><span id='topic+net_eigenvector'></span>

<h3>Description</h3>

<p>These functions calculate common eigenvector-related centrality
measures, or walk-based eigenmeasures, for one- and two-mode networks:
</p>

<ul>
<li> <p><code>node_eigenvector()</code> measures the eigenvector centrality of nodes
in a network.
</p>
</li>
<li> <p><code>node_power()</code> measures the Bonacich, beta, or power centrality of
nodes in a network.
</p>
</li>
<li> <p><code>node_alpha()</code> measures the alpha or Katz centrality of nodes in a
network.
</p>
</li>
<li> <p><code>node_pagerank()</code> measures the pagerank centrality of nodes in a network.
</p>
</li>
<li> <p><code>node_hub()</code> measures how well nodes in a network serve as hubs pointing
to many authorities.
</p>
</li>
<li> <p><code>node_authority()</code> measures how well nodes in a network serve as
authorities from many hubs.
</p>
</li>
<li> <p><code>tie_eigenvector()</code> measures the eigenvector centrality of ties in a
network.
</p>
</li>
<li> <p><code>net_eigenvector()</code> measures the eigenvector centralization for a
network.
</p>
</li></ul>

<p>All measures attempt to use as much information as they are offered,
including whether the networks are directed, weighted, or multimodal.
If this would produce unintended results,
first transform the salient properties using e.g. <code><a href="#topic+to_undirected">to_undirected()</a></code> functions.
All centrality and centralization measures return normalized measures
by default, including for two-mode networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_eigenvector(.data, normalized = TRUE, scale = TRUE)

node_power(.data, normalized = TRUE, scale = FALSE, exponent = 1)

node_alpha(.data, alpha = 0.85)

node_pagerank(.data)

node_authority(.data)

node_hub(.data)

tie_eigenvector(.data, normalized = TRUE)

net_eigenvector(.data, normalized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_central_eigen_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_central_eigen_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td></tr>
<tr><td><code id="measure_central_eigen_+3A_scale">scale</code></td>
<td>
<p>Logical scalar, whether to rescale the vector so the maximum score is 1.</p>
</td></tr>
<tr><td><code id="measure_central_eigen_+3A_exponent">exponent</code></td>
<td>
<p>Decay rate or attentuation factor for
the Bonacich power centrality score.
Can be positive or negative.</p>
</td></tr>
<tr><td><code id="measure_central_eigen_+3A_alpha">alpha</code></td>
<td>
<p>A constant that trades off the importance of external influence against the importance of connection.
When <code class="reqn">\alpha = 0</code>, only the external influence matters.
As <code class="reqn">\alpha</code> gets larger, only the connectivity matters and we reduce to eigenvector centrality.
By default <code class="reqn">\alpha = 0.85</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use <code>{igraph}</code> routines behind the scenes here for consistency and because they are often faster.
For example, <code>igraph::eigencentrality()</code> is approximately 25% faster than <code>sna::evcent()</code>.
</p>


<h3>Value</h3>

<p>A numeric vector giving the eigenvector centrality measure of each node.
</p>
<p>A numeric vector giving each node's power centrality measure.
</p>


<h3>Eigenvector centrality</h3>

<p>Eigenvector centrality operates as a measure of a node's influence in a network.
The idea is that being connected to well-connected others results in a higher score.
Each node's eigenvector centrality can be defined as:
</p>
<p style="text-align: center;"><code class="reqn">x_i = \frac{1}{\lambda} \sum_{j \in N} a_{i,j} x_j</code>
</p>

<p>where <code class="reqn">a_{i,j} = 1</code> if <code class="reqn">i</code> is linked to <code class="reqn">j</code> and 0 otherwise,
and <code class="reqn">\lambda</code> is a constant representing the principal eigenvalue.
Rather than performing this iteration,
most routines solve the eigenvector equation <code class="reqn">Ax = \lambda x</code>.
Note that since <code>{igraph}</code> v2.1.1,
the values will always be rescaled so that the maximum is 1.
</p>


<h3>Power or beta (or Bonacich) centrality</h3>

<p>Power centrality includes an exponent that weights contributions to a node's
centrality based on how far away those other nodes are.
</p>
<p style="text-align: center;"><code class="reqn">c_b(i) = \sum A(i,j) (\alpha = \beta c(j))</code>
</p>

<p>Where <code class="reqn">\beta</code> is positive, this means being connected to central people
increases centrality.
Where <code class="reqn">\beta</code> is negative, this means being connected to central people
decreases centrality
(and being connected to more peripheral actors increases centrality).
When <code class="reqn">\beta = 0</code>, this is the outdegree.
<code class="reqn">\alpha</code> is calculated to make sure the root mean square equals
the network size.
</p>


<h3>Alpha centrality</h3>

<p>Alpha or Katz (or Katz-Bonacich) centrality operates better than eigenvector centrality
for directed networks.
Eigenvector centrality will return 0s for all nodes not in the main strongly-connected component.
Each node's alpha centrality can be defined as:
</p>
<p style="text-align: center;"><code class="reqn">x_i = \frac{1}{\lambda} \sum_{j \in N} a_{i,j} x_j + e_i</code>
</p>

<p>where <code class="reqn">a_{i,j} = 1</code> if <code class="reqn">i</code> is linked to <code class="reqn">j</code> and 0 otherwise,
<code class="reqn">\lambda</code> is a constant representing the principal eigenvalue,
and <code class="reqn">e_i</code> is some external influence used to ensure that even nodes beyond the main
strongly connected component begin with some basic influence.
Note that many equations replace <code class="reqn">\frac{1}{\lambda}</code> with <code class="reqn">\alpha</code>,
hence the name.
</p>
<p>For example, if <code class="reqn">\alpha = 0.5</code>, then each direct connection (or alter) would be worth <code class="reqn">(0.5)^1 = 0.5</code>,
each secondary connection (or tertius) would be worth <code class="reqn">(0.5)^2 = 0.25</code>,
each tertiary connection would be worth <code class="reqn">(0.5)^3 = 0.125</code>, and so on.
</p>
<p>Rather than performing this iteration though,
most routines solve the equation <code class="reqn">x = (I - \frac{1}{\lambda} A^T)^{-1} e</code>.
</p>


<h3>References</h3>



<h4>On eigenvector centrality</h4>

<p>Bonacich, Phillip. 1991.
“Simultaneous Group and Individual Centralities.”
<em>Social Networks</em> 13(2):155–68.
<a href="https://doi.org/10.1016/0378-8733%2891%2990018-O">doi:10.1016/0378-8733(91)90018-O</a>
</p>



<h4>On power centrality</h4>

<p>Bonacich, Phillip. 1987.
“Power and Centrality: A Family of Measures.”
<em>The American Journal of Sociology</em>, 92(5): 1170–82.
<a href="https://doi.org/10.1086/228631">doi:10.1086/228631</a>.
</p>



<h4>On alpha centrality</h4>

<p>Katz, Leo 1953.
&quot;A new status index derived from sociometric analysis&quot;.
<em>Psychometrika</em>. 18(1): 39–43.
</p>
<p>Bonacich, P. and Lloyd, P. 2001.
“Eigenvector-like measures of centrality for asymmetric relations”
<em>Social Networks</em>. 23(3):191-201.
</p>



<h4>On pagerank centrality</h4>

<p>Brin, Sergey and Page, Larry. 1998.
&quot;The anatomy of a large-scale hypertextual web search engine&quot;.
<em>Proceedings of the 7th World-Wide Web Conference</em>. Brisbane, Australia.
</p>



<h4>On hub and authority centrality</h4>

<p>Kleinberg, Jon. 1999.
&quot;Authoritative sources in a hyperlinked environment&quot;.
<em>Journal of the ACM</em> 46(5): 604–632.
<a href="https://doi.org/10.1145/324133.324140">doi:10.1145/324133.324140</a>
</p>



<h3>See Also</h3>

<p>Other centrality: 
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>
</p>
<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_eigenvector(ison_southern_women)
node_power(ison_southern_women, exponent = 0.5)
tie_eigenvector(ison_adolescents)
net_eigenvector(ison_southern_women)
</code></pre>

<hr>
<h2 id='measure_closure'>Measures of network closure</h2><span id='topic+measure_closure'></span><span id='topic+net_reciprocity'></span><span id='topic+node_reciprocity'></span><span id='topic+net_transitivity'></span><span id='topic+node_transitivity'></span><span id='topic+net_equivalency'></span><span id='topic+node_equivalency'></span><span id='topic+net_congruency'></span>

<h3>Description</h3>

<p>These functions offer methods for summarising the closure in configurations
in one-, two-, and three-mode networks:
</p>

<ul>
<li> <p><code>net_reciprocity()</code> measures reciprocity in a (usually directed) network.
</p>
</li>
<li> <p><code>node_reciprocity()</code> measures nodes' reciprocity.
</p>
</li>
<li> <p><code>net_transitivity()</code> measures transitivity in a network.
</p>
</li>
<li> <p><code>node_transitivity()</code> measures nodes' transitivity.
</p>
</li>
<li> <p><code>net_equivalency()</code> measures equivalence or reinforcement
in a (usually two-mode) network.
</p>
</li>
<li> <p><code>net_congruency()</code> measures congruency across two two-mode networks.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>net_reciprocity(.data, method = "default")

node_reciprocity(.data)

net_transitivity(.data)

node_transitivity(.data)

net_equivalency(.data)

node_equivalency(.data)

net_congruency(.data, object2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_closure_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_closure_+3A_method">method</code></td>
<td>
<p>For reciprocity, either <code>default</code> or <code>ratio</code>.
See <code>?igraph::reciprocity</code></p>
</td></tr>
<tr><td><code id="measure_closure_+3A_object2">object2</code></td>
<td>
<p>Optionally, a second (two-mode) matrix, igraph, or tidygraph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For one-mode networks, shallow wrappers of igraph versions exist via
<code>net_reciprocity</code> and <code>net_transitivity</code>.
</p>
<p>For two-mode networks, <code>net_equivalency</code> calculates the proportion of three-paths in the network
that are closed by fourth tie to establish a &quot;shared four-cycle&quot; structure.
</p>
<p>For three-mode networks, <code>net_congruency</code> calculates the proportion of three-paths
spanning two two-mode networks that are closed by a fourth tie to establish a
&quot;congruent four-cycle&quot; structure.
</p>


<h3>Equivalency</h3>

<p>The <code>net_equivalency()</code> function calculates the Robins and Alexander (2004)
clustering coefficient for two-mode networks.
Note that for weighted two-mode networks, the result is divided by the average tie weight.
</p>


<h3>References</h3>



<h4>On equivalency or four-cycles</h4>

<p>Robins, Garry L, and Malcolm Alexander. 2004.
Small worlds among interlocking directors: Network structure and distance in bipartite graphs.
<em>Computational &amp; Mathematical Organization Theory</em> 10(1): 69–94.
<a href="https://doi.org/10.1023/B%3ACMOT.0000032580.12184.c0">doi:10.1023/B:CMOT.0000032580.12184.c0</a>.
</p>



<h4>On congruency</h4>

<p>Knoke, David, Mario Diani, James Hollway, and Dimitris C Christopoulos. 2021.
<em>Multimodal Political Networks</em>.
Cambridge University Press. Cambridge University Press.
<a href="https://doi.org/10.1017/9781108985000">doi:10.1017/9781108985000</a>
</p>



<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net_reciprocity(ison_southern_women)
node_reciprocity(to_unweighted(ison_networkers))
net_transitivity(ison_adolescents)
node_transitivity(ison_adolescents)
net_equivalency(ison_southern_women)
node_equivalency(ison_southern_women)
</code></pre>

<hr>
<h2 id='measure_cohesion'>Measures of network cohesion or connectedness</h2><span id='topic+measure_cohesion'></span><span id='topic+net_density'></span><span id='topic+net_components'></span><span id='topic+net_cohesion'></span><span id='topic+net_adhesion'></span><span id='topic+net_diameter'></span><span id='topic+net_length'></span><span id='topic+net_independence'></span>

<h3>Description</h3>

<p>These functions return values or vectors relating to how connected a network is
and the number of nodes or edges to remove that would increase fragmentation.
</p>

<ul>
<li> <p><code>net_density()</code> measures the ratio of ties to the number
of possible ties.
</p>
</li>
<li> <p><code>net_components()</code> measures the number of (strong) components
in the network.
</p>
</li>
<li> <p><code>net_cohesion()</code> measures the minimum number of nodes to remove
from the network needed to increase the number of components.
</p>
</li>
<li> <p><code>net_adhesion()</code> measures the minimum number of ties to remove
from the network needed to increase the number of components.
</p>
</li>
<li> <p><code>net_diameter()</code> measures the maximum path length in the network.
</p>
</li>
<li> <p><code>net_length()</code> measures the average path length in the network.
</p>
</li>
<li> <p><code>net_independence()</code> measures the independence number,
or size of the largest independent set in the network.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>net_density(.data)

net_components(.data)

net_cohesion(.data)

net_adhesion(.data)

net_diameter(.data)

net_length(.data)

net_independence(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_cohesion_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Cohesion</h3>

<p>To get the 'weak' components of a directed graph,
please use <code>manynet::to_undirected()</code> first.
</p>


<h3>References</h3>



<h4>On cohesion</h4>

<p>White, Douglas R and Frank Harary. 2001.
&quot;The Cohesiveness of Blocks In Social Networks: Node Connectivity and Conditional Density.&quot;
<em>Sociological Methodology</em> 31(1): 305-59.
<a href="https://doi.org/10.1111/0081-1750.00098">doi:10.1111/0081-1750.00098</a>
</p>



<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net_density(ison_adolescents)
net_density(ison_southern_women)
  net_components(fict_thrones)
  net_components(to_undirected(fict_thrones))
net_cohesion(ison_marvel_relationships)
net_cohesion(to_giant(ison_marvel_relationships))
net_adhesion(ison_marvel_relationships)
net_adhesion(to_giant(ison_marvel_relationships))
net_diameter(ison_marvel_relationships)
net_diameter(to_giant(ison_marvel_relationships))
net_length(ison_marvel_relationships)
net_length(to_giant(ison_marvel_relationships))
net_independence(ison_adolescents)
</code></pre>

<hr>
<h2 id='measure_diffusion_infection'>Measures of network infection</h2><span id='topic+measure_diffusion_infection'></span><span id='topic+net_infection_complete'></span><span id='topic+net_infection_total'></span><span id='topic+net_infection_peak'></span>

<h3>Description</h3>

<p>These functions allow measurement of various features of
a diffusion process at the network level:
</p>

<ul>
<li> <p><code>net_infection_complete()</code> measures the number of time steps until
(the first instance of) complete infection.
For diffusions that are not observed to complete,
this function returns the value of <code>Inf</code> (infinity).
This makes sure that at least ordinality is respected.
</p>
</li>
<li> <p><code>net_infection_total()</code> measures the proportion or total number of nodes
that are infected/activated at some time by the end of the diffusion process.
This includes nodes that subsequently recover.
Where reinfection is possible, the proportion may be higher than 1.
</p>
</li>
<li> <p><code>net_infection_peak()</code> measures the number of time steps until the
highest infection rate is observed.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>net_infection_complete(diff_model)

net_infection_total(diff_model, normalized = TRUE)

net_infection_peak(diff_model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_diffusion_infection_+3A_diff_model">diff_model</code></td>
<td>
<p>A valid network diffusion model,
as created by <code>as_diffusion()</code> or <code>play_diffusion()</code>.</p>
</td></tr>
<tr><td><code id="measure_diffusion_infection_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>
<p>Other diffusion: 
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  smeg &lt;- generate_smallworld(15, 0.025)
  smeg_diff &lt;- play_diffusion(smeg, recovery = 0.2)
  net_infection_complete(smeg_diff)
  net_infection_total(smeg_diff)
  net_infection_peak(smeg_diff)
</code></pre>

<hr>
<h2 id='measure_diffusion_net'>Measures of network diffusion</h2><span id='topic+measure_diffusion_net'></span><span id='topic+net_transmissibility'></span><span id='topic+net_recovery'></span><span id='topic+net_reproduction'></span><span id='topic+net_immunity'></span><span id='topic+net_hazard'></span>

<h3>Description</h3>

<p>These functions allow measurement of various features of
a diffusion process at the network level:
</p>

<ul>
<li> <p><code>net_transmissibility()</code> measures the average transmissibility observed
in a diffusion simulation, or the number of new infections over
the number of susceptible nodes.
</p>
</li>
<li> <p><code>net_recovery()</code> measures the average number of time steps
nodes remain infected once they become infected.
</p>
</li>
<li> <p><code>net_reproduction()</code> measures the observed reproductive number
in a diffusion simulation as the network's transmissibility over
the network's average infection length.
</p>
</li>
<li> <p><code>net_immunity()</code> measures the proportion of nodes that would need
to be protected through vaccination, isolation, or recovery for herd immunity to be reached.
</p>
</li>
<li> <p><code>net_hazard()</code> measures the hazard rate or instantaneous probability that
nodes will adopt/become infected at that time
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>net_transmissibility(diff_model)

net_recovery(diff_model, censor = TRUE)

net_reproduction(diff_model)

net_immunity(diff_model, normalized = TRUE)

net_hazard(diff_model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_diffusion_net_+3A_diff_model">diff_model</code></td>
<td>
<p>A valid network diffusion model,
as created by <code>as_diffusion()</code> or <code>play_diffusion()</code>.</p>
</td></tr>
<tr><td><code id="measure_diffusion_net_+3A_censor">censor</code></td>
<td>
<p>Where some nodes have not yet recovered by the end
of the simulation, right censored values can be replaced by the number of steps.
By default TRUE.
Note that this will likely still underestimate recovery.</p>
</td></tr>
<tr><td><code id="measure_diffusion_net_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td></tr>
</table>


<h3>Transmissibility</h3>

<p><code>net_transmissibility()</code> measures how many directly susceptible nodes
each infected node will infect in each time period, on average.
That is:
</p>
<p style="text-align: center;"><code class="reqn">T = \frac{1}{n}\sum_{j=1}^n \frac{i_{j}}{s_{j}}</code>
</p>

<p>where <code class="reqn">i</code> is the number of new infections in each time period, <code class="reqn">j \in n</code>,
and <code class="reqn">s</code> is the number of nodes that could have been infected in that time period
(note that <code class="reqn">s \neq S</code>, or
the number of nodes that are susceptible in the population).
<code class="reqn">T</code> can be interpreted as the proportion of susceptible nodes that are
infected at each time period.
</p>


<h3>Recovery time</h3>

<p><code>net_recovery()</code> measures the average number of time steps that
nodes in a network remain infected.
Note that in a diffusion model without recovery, average infection length
will be infinite.
This will also be the case where there is right censoring.
The longer nodes remain infected, the longer they can infect others.
</p>


<h3>Reproduction number</h3>

<p><code>net_reproduction()</code> measures a given diffusion's reproductive number.
Here it is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">R = \min\left(\frac{T}{1/L}, \bar{k}\right)</code>
</p>

<p>where <code class="reqn">T</code> is the observed transmissibility in a diffusion
and <code class="reqn">L</code> is the observed recovery length in a diffusion.
Since <code class="reqn">L</code> can be infinite where there is no recovery
or there is right censoring,
and since network structure places an upper limit on how many
nodes each node may further infect (their degree),
this function returns the minimum of <code class="reqn">R_0</code>
and the network's average degree.
</p>
<p>Interpretation of the reproduction number is oriented around R = 1.
Where <code class="reqn">R &gt; 1</code>, the 'disease' will 'infect' more and more
nodes in the network.
Where <code class="reqn">R &lt; 1</code>, the 'disease' will not sustain itself and eventually
die out.
Where <code class="reqn">R = 1</code>, the 'disease' will continue as endemic,
if conditions allow.
</p>


<h3>Herd immunity</h3>

<p><code>net_immunity()</code> estimates the proportion of a network
that need to be protected from infection for herd immunity
to be achieved.
This is known as the Herd Immunity Threshold or HIT:
</p>
<p style="text-align: center;"><code class="reqn">1 - \frac{1}{R}</code>
</p>

<p>where <code class="reqn">R</code> is the reproduction number from <code>net_reproduction()</code>.
The HIT indicates the threshold at which
the reduction of susceptible members of the network means
that infections will no longer keep increasing.
Note that there may still be more infections after this threshold has been reached,
but there should be fewer and fewer.
These excess infections are called the <em>overshoot</em>.
This function does <em>not</em> take into account the structure
of the network, instead using the average degree.
</p>
<p>Interpretation is quite straightforward.
A HIT or immunity score of 0.75 would mean that 75% of the nodes in the network
would need to be vaccinated or otherwise protected to achieve herd immunity.
To identify how many nodes this would be, multiply this proportion with the number
of nodes in the network.
</p>


<h3>Hazard rate</h3>

<p>The hazard rate is the instantaneous probability of adoption/infection at each time point (Allison 1984).
In survival analysis, hazard rate is formally defined as:
</p>
<p style="text-align: center;"><code class="reqn">%
\lambda(t)=\lim_{h\to +0}\frac{F(t+h)-F(t)}{h}\frac{1}{1-F(t)} %
</code>
</p>

<p>By approximating <code class="reqn">h=1</code>, we can rewrite the equation as
</p>
<p style="text-align: center;"><code class="reqn">%
\lambda(t)=\frac{F(t+1)-F(t)}{1-F(t)} %
</code>
</p>

<p>If we estimate <code class="reqn">F(t)</code>,
the probability of not having adopted the innovation in time <code class="reqn">t</code>,
from the proportion of adopters in that time,
such that <code class="reqn">F(t) \sim q_t/n</code>, we now have (ultimately for <code class="reqn">t&gt;1</code>):
</p>
<p style="text-align: center;"><code class="reqn">%
\lambda(t)=\frac{q_{t+1}/n-q_t/n}{1-q_t/n} = \frac{q_{t+1} - q_t}{n - q_t} = \frac{q_t - q_{t-1}}{n - q_{t-1}} %
</code>
</p>

<p>where <code class="reqn">q_i</code> is the number of adopters in time <code class="reqn">t</code>,
and <code class="reqn">n</code> is the number of vertices in the graph.
</p>
<p>The shape of the hazard rate indicates the pattern of new adopters over time.
Rapid diffusion with convex cumulative adoption curves will have
hazard functions that peak early and decay over time.
Slow concave cumulative adoption curves will have
hazard functions that are low early and rise over time.
Smooth hazard curves indicate constant adoption whereas
those that oscillate indicate variability in adoption behavior over time.
</p>


<h3>Source</h3>

<p><code>{netdiffuseR}</code>
</p>


<h3>References</h3>



<h4>On epidemiological models</h4>

<p>Kermack, William O., and Anderson Gray McKendrick. 1927.
&quot;A contribution to the mathematical theory of epidemics&quot;.
<em>Proc. R. Soc. London A</em> 115: 700-721.
<a href="https://doi.org/10.1098/rspa.1927.0118">doi:10.1098/rspa.1927.0118</a>
</p>



<h4>On the basic reproduction number</h4>

<p>Diekmann, Odo, Hans J.A.P. Heesterbeek, and Hans J.A.J. Metz. 1990.
&quot;On the definition and the computation of the basic reproduction ratio R0 in models for infectious diseases in heterogeneous populations&quot;.
<em>Journal of Mathematical Biology</em>, 28(4): 365–82.
<a href="https://doi.org/10.1007/BF00178324">doi:10.1007/BF00178324</a>
</p>
<p>Kenah, Eben, and James M. Robins. 2007.
&quot;Second look at the spread of epidemics on networks&quot;.
<em>Physical Review E</em>, 76(3 Pt 2): 036113.
<a href="https://doi.org/10.1103/PhysRevE.76.036113">doi:10.1103/PhysRevE.76.036113</a>
</p>



<h4>On herd immunity</h4>

<p>Garnett, G.P. 2005.
&quot;Role of herd immunity in determining the effect of vaccines against sexually transmitted disease&quot;.
<em>The Journal of Infectious Diseases</em>, 191(1): S97-106.
<a href="https://doi.org/10.1086/425271">doi:10.1086/425271</a>
</p>



<h4>On hazard rates</h4>

<p>Allison, Paul D. 1984.
<em>Event history analysis: Regression for longitudinal event data</em>.
London: Sage Publications.
<a href="https://doi.org/10.4135/9781412984195">doi:10.4135/9781412984195</a>
</p>
<p>Wooldridge, Jeffrey M. 2010.
<em>Econometric Analysis of Cross Section and Panel Data</em> (2nd ed.).
Cambridge: MIT Press.
</p>



<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>
<p>Other diffusion: 
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  smeg &lt;- generate_smallworld(15, 0.025)
  smeg_diff &lt;- play_diffusion(smeg, recovery = 0.2)
  plot(smeg_diff)
  # To calculate the average transmissibility for a given diffusion model
  net_transmissibility(smeg_diff)
  # To calculate the average infection length for a given diffusion model
  net_recovery(smeg_diff)
  # To calculate the reproduction number for a given diffusion model
  net_reproduction(smeg_diff)
  # Calculating the proportion required to achieve herd immunity
  net_immunity(smeg_diff)
  # To find the number of nodes to be vaccinated
  ceiling(net_immunity(smeg_diff) * manynet::net_nodes(smeg))
# To calculate the hazard rates at each time point
net_hazard(play_diffusion(smeg, transmissibility = 0.3))
</code></pre>

<hr>
<h2 id='measure_diffusion_node'>Measures of nodes in a diffusion</h2><span id='topic+measure_diffusion_node'></span><span id='topic+node_adoption_time'></span><span id='topic+node_thresholds'></span><span id='topic+node_recovery'></span><span id='topic+node_exposure'></span>

<h3>Description</h3>

<p>These functions allow measurement of various features of
a diffusion process:
</p>

<ul>
<li> <p><code>node_adoption_time()</code>: Measures the number of time steps until
nodes adopt/become infected
</p>
</li>
<li> <p><code>node_thresholds()</code>: Measures nodes' thresholds from the amount
of exposure they had when they became infected
</p>
</li>
<li> <p><code>node_infection_length()</code>: Measures the average length nodes that become
infected remain infected in a compartmental model with recovery
</p>
</li>
<li> <p><code>node_exposure()</code>: Measures how many exposures nodes have to
a given mark
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_adoption_time(diff_model)

node_thresholds(diff_model, normalized = TRUE, lag = 1)

node_recovery(diff_model)

node_exposure(.data, mark, time = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_diffusion_node_+3A_diff_model">diff_model</code></td>
<td>
<p>A valid network diffusion model,
as created by <code>as_diffusion()</code> or <code>play_diffusion()</code>.</p>
</td></tr>
<tr><td><code id="measure_diffusion_node_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether the centrality scores are normalized.
Different denominators are used depending on whether the object is one-mode or two-mode,
the type of centrality, and other arguments.</p>
</td></tr>
<tr><td><code id="measure_diffusion_node_+3A_lag">lag</code></td>
<td>
<p>The number of time steps back upon which the thresholds are
inferred.</p>
</td></tr>
<tr><td><code id="measure_diffusion_node_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_diffusion_node_+3A_mark">mark</code></td>
<td>
<p>A valid 'node_mark' object or
logical vector (TRUE/FALSE) of length equal to
the number of nodes in the network.</p>
</td></tr>
<tr><td><code id="measure_diffusion_node_+3A_time">time</code></td>
<td>
<p>A time point until which infections/adoptions should be
identified. By default <code>time = 0</code>.</p>
</td></tr>
</table>


<h3>Adoption time</h3>

<p><code>node_adoption_time()</code> measures the time units it took
until each node became infected.
Note that an adoption time of 0 indicates that this was a seed node.
</p>


<h3>Thresholds</h3>

<p><code>node_thresholds()</code> infers nodes' thresholds based on how much
exposure they had when they were infected.
This inference is of course imperfect,
especially where there is a sudden increase in exposure,
but it can be used heuristically.
In a threshold model,
nodes activate when <code class="reqn">\sum_{j:\text{active}} w_{ji} \geq \theta_i</code>,
where <code class="reqn">w</code> is some (potentially weighted) matrix,
<code class="reqn">j</code> are some already activated nodes,
and <code class="reqn">theta</code> is some pre-defined threshold value.
Where a fractional threshold is used, the equation is
<code class="reqn">\frac{\sum_{j:\text{active}} w_{ji}}{\sum_{j} w_{ji}} \geq \theta_i</code>.
That is, <code class="reqn">theta</code> is now a proportion,
and works regardless of whether <code class="reqn">w</code> is weighted or not.
</p>


<h3>Infection length</h3>

<p><code>node_infection_length()</code> measures the average length of time that nodes
that become infected remain infected in a compartmental model with recovery.
Infections that are not concluded by the end of the study period are
calculated as infinite.
</p>


<h3>Exposure</h3>

<p><code>node_exposure()</code> calculates the number of infected/adopting nodes
to which each susceptible node is exposed.
It usually expects network data and
an index or mark (TRUE/FALSE) vector of those nodes which are currently infected,
but if a diff_model is supplied instead it will return
nodes exposure at <code class="reqn">t = 0</code>.
</p>


<h3>References</h3>



<h4>On diffusion measures</h4>

<p>Valente, Tom W. 1995. <em>Network models of the diffusion of innovations</em>
(2nd ed.). Cresskill N.J.: Hampton Press.
</p>



<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>
<p>Other diffusion: 
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  smeg &lt;- generate_smallworld(15, 0.025)
  smeg_diff &lt;- play_diffusion(smeg, recovery = 0.2)
  plot(smeg_diff)
  # To measure when nodes adopted a diffusion/were infected
  (times &lt;- node_adoption_time(smeg_diff))
  # To infer nodes' thresholds
  node_thresholds(smeg_diff)
  # To measure how long each node remains infected for
  node_recovery(smeg_diff)
  # To measure how much exposure nodes have to a given mark
  node_exposure(smeg, mark = c(1,3))
  node_exposure(smeg_diff)
</code></pre>

<hr>
<h2 id='measure_features'>Measures of network topological features</h2><span id='topic+measure_features'></span><span id='topic+net_core'></span><span id='topic+net_richclub'></span><span id='topic+net_factions'></span><span id='topic+net_modularity'></span><span id='topic+net_smallworld'></span><span id='topic+net_scalefree'></span><span id='topic+net_balance'></span>

<h3>Description</h3>

<p>These functions measure certain topological features of networks:
</p>

<ul>
<li> <p><code>net_core()</code> measures the correlation between a network
and a core-periphery model with the same dimensions.
</p>
</li>
<li> <p><code>net_richclub()</code> measures the rich-club coefficient of a network.
</p>
</li>
<li> <p><code>net_factions()</code> measures the correlation between a network
and a component model with the same dimensions.
If no 'membership' vector is given for the data,
<code>node_partition()</code> is used to partition nodes into two groups.
</p>
</li>
<li> <p><code>net_modularity()</code> measures the modularity of a network
based on nodes' membership in defined clusters.
</p>
</li>
<li> <p><code>net_smallworld()</code> measures the small-world coefficient for one- or
two-mode networks. Small-world networks can be highly clustered and yet
have short path lengths.
</p>
</li>
<li> <p><code>net_scalefree()</code> measures the exponent of a fitted
power-law distribution. An exponent between 2 and 3 usually indicates
a power-law distribution.
</p>
</li>
<li> <p><code>net_balance()</code> measures the structural balance index on
the proportion of balanced triangles,
ranging between <code>0</code> if all triangles are imbalanced and
<code>1</code> if all triangles are balanced.
</p>
</li></ul>

<p>These <code style="white-space: pre;">&#8288;net_*()&#8288;</code> functions return a single numeric scalar or value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_core(.data, mark = NULL)

net_richclub(.data)

net_factions(.data, membership = NULL)

net_modularity(.data, membership = NULL, resolution = 1)

net_smallworld(.data, method = c("omega", "sigma", "SWI"), times = 100)

net_scalefree(.data)

net_balance(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_features_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_features_+3A_mark">mark</code></td>
<td>
<p>A logical vector the length of the nodes in the network.
This can be created by, among other things, any <code style="white-space: pre;">&#8288;node_is_*()&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="measure_features_+3A_membership">membership</code></td>
<td>
<p>A vector of partition membership.</p>
</td></tr>
<tr><td><code id="measure_features_+3A_resolution">resolution</code></td>
<td>
<p>A proportion indicating the resolution scale.
By default 1, which returns the original definition of modularity.
The higher this parameter, the more smaller communities will be privileged.
The lower this parameter, the fewer larger communities are likely to be found.</p>
</td></tr>
<tr><td><code id="measure_features_+3A_method">method</code></td>
<td>
<p>There are three small-world measures implemented:
</p>

<ul>
<li><p> &quot;sigma&quot; is the original equation from Watts and Strogatz (1998),
</p>
<p style="text-align: center;"><code class="reqn">\frac{\frac{C}{C_r}}{\frac{L}{L_r}}</code>
</p>
<p>,
where <code class="reqn">C</code> and <code class="reqn">L</code> are the observed
clustering coefficient and path length, respectively,
and <code class="reqn">C_r</code> and <code class="reqn">L_r</code> are the averages obtained from
random networks of the same dimensions and density.
A <code class="reqn">\sigma &gt; 1</code> is considered to be small-world,
but this measure is highly sensitive to network size.
</p>
</li>
<li><p> &quot;omega&quot; (the default) is an update from Telesford et al. (2011),
</p>
<p style="text-align: center;"><code class="reqn">\frac{L_r}{L} - \frac{C}{C_l}</code>
</p>
<p>,
where <code class="reqn">C_l</code> is the clustering coefficient for a lattice graph
with the same dimensions.
<code class="reqn">\omega</code> ranges between 0 and 1,
where 1 is as close to a small-world as possible.
</p>
</li>
<li><p> &quot;SWI&quot; is an alternative proposed by Neal (2017),
</p>
<p style="text-align: center;"><code class="reqn">\frac{L - L_l}{L_r - L_l} \times \frac{C - C_r}{C_l - C_r}</code>
</p>
<p>,
where <code class="reqn">L_l</code> is the average path length for a lattice graph
with the same dimensions.
<code class="reqn">SWI</code> also ranges between 0 and 1 with the same interpretation,
but where there may not be a network for which <code class="reqn">SWI = 1</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_features_+3A_times">times</code></td>
<td>
<p>Integer of number of simulations.</p>
</td></tr>
</table>


<h3>Modularity</h3>

<p>Modularity measures the difference between the number of ties within each community
from the number of ties expected within each community in a random graph
with the same degrees, and ranges between -1 and +1.
Modularity scores of +1 mean that ties only appear within communities,
while -1 would mean that ties only appear between communities.
A score of 0 would mean that ties are half within and half between communities,
as one would expect in a random graph.
</p>
<p>Modularity faces a difficult problem known as the resolution limit
(Fortunato and Barthélemy 2007).
This problem appears when optimising modularity,
particularly with large networks or depending on the degree of interconnectedness,
can miss small clusters that 'hide' inside larger clusters.
In the extreme case, this can be where they are only connected
to the rest of the network through a single tie.
To help manage this problem, a <code>resolution</code> parameter is added.
Please see the argument definition for more details.
</p>


<h3>Source</h3>

<p><code>{signnet}</code> by David Schoch
</p>


<h3>References</h3>



<h4>On core-periphery</h4>

<p>Borgatti, Stephen P., and Martin G. Everett. 2000.
“Models of Core/Periphery Structures.”
<em>Social Networks</em> 21(4):375–95.
<a href="https://doi.org/10.1016/S0378-8733%2899%2900019-2">doi:10.1016/S0378-8733(99)00019-2</a>
</p>



<h4>On the rich-club coefficient</h4>

<p>Zhou, Shi, and Raul J. Mondragon. 2004.
&quot;The Rich-Club Phenomenon in the Internet Topology&quot;.
<em>IEEE Communications Letters</em>, 8(3): 180-182.
<a href="https://doi.org/10.1109/lcomm.2004.823426">doi:10.1109/lcomm.2004.823426</a>
</p>



<h4>On modularity</h4>

<p>Newman, Mark E.J. 2006.
&quot;Modularity and community structure in networks&quot;,
<em>Proceedings of the National Academy of Sciences</em> 103(23): 8577-8696.
<a href="https://doi.org/10.1073/pnas.0601602103">doi:10.1073/pnas.0601602103</a>
</p>
<p>Murata, Tsuyoshi. 2010.
&quot;Modularity for Bipartite Networks&quot;.
In: Memon, N., Xu, J., Hicks, D., Chen, H. (eds)
<em>Data Mining for Social Network Data. Annals of Information Systems</em>, Vol 12.
Springer, Boston, MA.
<a href="https://doi.org/10.1007/978-1-4419-6287-4_7">doi:10.1007/978-1-4419-6287-4_7</a>
</p>



<h4>On small-worldliness</h4>

<p>Watts, Duncan J., and Steven H. Strogatz. 1998.
“Collective Dynamics of ‘Small-World’ Networks”.
<em>Nature</em> 393(6684):440–42.
<a href="https://doi.org/10.1038/30918">doi:10.1038/30918</a>
</p>
<p>Telesford QK, Joyce KE, Hayasaka S, Burdette JH, Laurienti PJ. 2011.
&quot;The ubiquity of small-world networks&quot;.
<em>Brain Connectivity</em> 1(5): 367–75.
<a href="https://doi.org/10.1089/brain.2011.0038">doi:10.1089/brain.2011.0038</a>
</p>
<p>Neal, Zachary P. 2017.
&quot;How small is it? Comparing indices of small worldliness&quot;.
<em>Network Science</em>. 5 (1): 30–44.
<a href="https://doi.org/10.1017/nws.2017.5">doi:10.1017/nws.2017.5</a>
</p>



<h4>On scale-free networks</h4>

<p>Barabasi, Albert-Laszlo, and Reka Albert. 1999.
&quot;Emergence of scaling in random networks&quot;,
<em>Science</em>, 286(5439): 509-512.
<a href="https://doi.org/10.1126/science.286.5439.509">doi:10.1126/science.286.5439.509</a>
</p>
<p>Clauset, Aaron, Cosma Rohilla Shalizi, and Mark E.J. Newman. 2009.
&quot;Power-law distributions in empirical data&quot;,
<em>SIAM Review</em>, 51(4): 661-703.
<a href="https://doi.org/10.1137/070710111">doi:10.1137/070710111</a>
</p>
<p>Stumpf, Michael P.H., and Mason Porter. 2012.
&quot;Critical truths about power laws&quot;,
<em>Science</em>, 335(6069): 665-666.
<a href="https://doi.org/10.1126/science.1216142">doi:10.1126/science.1216142</a>
</p>
<p>Holme, Petter. 2019.
&quot;Rare and everywhere: Perspectives on scale-free networks&quot;,
<em>Nature Communications</em>, 10(1): 1016.
<a href="https://doi.org/10.1038/s41467-019-09038-8">doi:10.1038/s41467-019-09038-8</a>
</p>



<h4>On balance theory</h4>

<p>Heider, Fritz. 1946.
&quot;Attitudes and cognitive organization&quot;.
<em>The Journal of Psychology</em>, 21: 107-112.
<a href="https://doi.org/10.1080/00223980.1946.9917275">doi:10.1080/00223980.1946.9917275</a>
</p>
<p>Cartwright, D., and Frank Harary. 1956.
&quot;Structural balance: A generalization of Heider's theory&quot;.
<em>Psychological Review</em>, 63(5): 277-293.
<a href="https://doi.org/10.1037/h0046049">doi:10.1037/h0046049</a>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+net_transitivity">net_transitivity()</a></code> and <code><a href="#topic+net_equivalency">net_equivalency()</a></code>
for how clustering is calculated
</p>
<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net_core(ison_adolescents)
net_core(ison_southern_women)
net_richclub(ison_adolescents)
  net_factions(ison_southern_women)
net_modularity(ison_adolescents, 
  node_in_partition(ison_adolescents))
net_modularity(ison_southern_women, 
  node_in_partition(ison_southern_women))
net_smallworld(ison_brandes)
net_smallworld(ison_southern_women)
net_scalefree(ison_adolescents)
net_scalefree(generate_scalefree(50, 1.5))
net_scalefree(create_lattice(100))
net_balance(ison_marvel_relationships)
</code></pre>

<hr>
<h2 id='measure_heterogeneity'>Measures of network diversity</h2><span id='topic+measure_heterogeneity'></span><span id='topic+net_richness'></span><span id='topic+node_richness'></span><span id='topic+net_diversity'></span><span id='topic+node_diversity'></span><span id='topic+net_heterophily'></span><span id='topic+node_heterophily'></span><span id='topic+net_assortativity'></span><span id='topic+net_spatial'></span>

<h3>Description</h3>

<p>These functions offer ways to measure the heterogeneity of an attribute
across a network, within groups of a network, or the distribution of ties
across this attribute:
</p>

<ul>
<li> <p><code>net_richness()</code> measures the number of unique categories
in a network attribute.
</p>
</li>
<li> <p><code>node_richness()</code> measures the number of unique categories
of an attribute to which each node is connected.
</p>
</li>
<li> <p><code>net_diversity()</code> measures the heterogeneity of ties across a network
or within clusters by node attributes.
</p>
</li>
<li> <p><code>node_diversity()</code> measures the heterogeneity of each node's
local neighbourhood.
</p>
</li>
<li> <p><code>net_heterophily()</code> measures how embedded nodes in the network
are within groups of nodes with the same attribute.
</p>
</li>
<li> <p><code>node_heterophily()</code> measures each node's embeddedness within groups
of nodes with the same attribute.
</p>
</li>
<li> <p><code>net_assortativity()</code> measures the degree assortativity in a network.
</p>
</li>
<li> <p><code>net_spatial()</code> measures the spatial association/autocorrelation
(global Moran's I) in a network.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>net_richness(.data, attribute)

node_richness(.data, attribute)

net_diversity(.data, attribute, clusters = NULL)

node_diversity(.data, attribute)

net_heterophily(.data, attribute)

node_heterophily(.data, attribute)

net_assortativity(.data)

net_spatial(.data, attribute)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_heterogeneity_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_heterogeneity_+3A_attribute">attribute</code></td>
<td>
<p>Name of a nodal attribute or membership vector
to use as categories for the diversity measure.</p>
</td></tr>
<tr><td><code id="measure_heterogeneity_+3A_clusters">clusters</code></td>
<td>
<p>A nodal cluster membership vector or name of a vertex attribute.</p>
</td></tr>
</table>


<h3>net_diversity</h3>

<p>Blau's index (1977) uses a formula known also in other disciplines
by other names
(Gini-Simpson Index, Gini impurity, Gini's diversity index,
Gibbs-Martin index, and probability of interspecific encounter (PIE)):
</p>
<p style="text-align: center;"><code class="reqn">1 - \sum\limits_{i = 1}^k {p_i^2 }</code>
</p>
<p>,
where <code class="reqn">p_i</code> is the proportion of group members in <code class="reqn">i</code>th category
and <code class="reqn">k</code> is the number of categories for an attribute of interest.
This index can be interpreted as the probability that two members
randomly selected from a group would be from different categories.
This index finds its minimum value (0) when there is no variety,
i.e. when all individuals are classified in the same category.
The maximum value depends on the number of categories and
whether nodes can be evenly distributed across categories.
</p>


<h3>net_homophily</h3>

<p>Given a partition of a network into a number of mutually exclusive groups then
The E-I index is the number of ties between (or <em>external</em>) nodes
grouped in some mutually exclusive categories
minus the number of ties within (or <em>internal</em>) these groups
divided by the total number of ties.
This value can range from 1 to -1,
where 1 indicates ties only between categories/groups and -1 ties only within categories/groups.
</p>


<h3>References</h3>



<h4>On diversity</h4>

<p>Blau, Peter M. 1977.
<em>Inequality and heterogeneity</em>.
New York: Free Press.
</p>



<h4>On heterophily</h4>

<p>Krackhardt, David, and Robert N. Stern. 1988.
Informal networks and organizational crises: an experimental simulation.
<em>Social Psychology Quarterly</em> 51(2): 123-140.
<a href="https://doi.org/10.2307/2786835">doi:10.2307/2786835</a>
</p>
<p>McPherson, Miller, Lynn Smith-Lovin, and James M. Cook. 2001.
&quot;Birds of a Feather: Homophily in Social Networks&quot;.
<em>Annual Review of Sociology</em>, 27(1): 415-444.
<a href="https://doi.org/10.1146/annurev.soc.27.1.415">doi:10.1146/annurev.soc.27.1.415</a>
</p>



<h4>On assortativity</h4>

<p>Newman, Mark E.J. 2002.
&quot;Assortative Mxing in Networks&quot;.
<em>Physical Review Letters</em>, 89(20): 208701.
<a href="https://doi.org/10.1103/physrevlett.89.208701">doi:10.1103/physrevlett.89.208701</a>
</p>



<h4>On spatial autocorrelation</h4>

<p>Moran, Patrick Alfred Pierce. 1950.
&quot;Notes on Continuous Stochastic Phenomena&quot;.
<em>Biometrika</em> 37(1): 17-23.
<a href="https://doi.org/10.2307/2332142">doi:10.2307/2332142</a>
</p>



<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net_richness(ison_networkers)
node_richness(ison_networkers, "Discipline")
marvel_friends &lt;- to_unsigned(ison_marvel_relationships, "positive")
net_diversity(marvel_friends, "Gender")
net_diversity(marvel_friends, "Attractive")
net_diversity(marvel_friends, "Gender", "Rich")
node_diversity(marvel_friends, "Gender")
node_diversity(marvel_friends, "Attractive")
net_heterophily(marvel_friends, "Gender")
net_heterophily(marvel_friends, "Attractive")
node_heterophily(marvel_friends, "Gender")
node_heterophily(marvel_friends, "Attractive")
net_assortativity(ison_networkers)
net_spatial(ison_lawfirm, "age")
</code></pre>

<hr>
<h2 id='measure_hierarchy'>Graph theoretic dimensions of hierarchy</h2><span id='topic+measure_hierarchy'></span><span id='topic+net_connectedness'></span><span id='topic+net_efficiency'></span><span id='topic+net_upperbound'></span>

<h3>Description</h3>

<p>These functions, together with <code>net_reciprocity()</code>, are used jointly to
measure how hierarchical a network is:
</p>

<ul>
<li> <p><code>net_connectedness()</code> measures the proportion of dyads in the network
that are reachable to one another,
or the degree to which network is a single component.
</p>
</li>
<li> <p><code>net_efficiency()</code> measures the Krackhardt efficiency score.
</p>
</li>
<li> <p><code>net_upperbound()</code> measures the Krackhardt (least) upper bound score.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>net_connectedness(.data)

net_efficiency(.data)

net_upperbound(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_hierarchy_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>References</h3>



<h4>On hierarchy</h4>

<p>Krackhardt, David. 1994.
Graph theoretical dimensions of informal organizations.
In Carley and Prietula (eds) <em>Computational Organizational Theory</em>,
Hillsdale, NJ: Lawrence Erlbaum Associates. Pp. 89-111.
</p>
<p>Everett, Martin, and David Krackhardt. 2012.
“A second look at Krackhardt's graph theoretical dimensions of informal organizations.”
<em>Social Networks</em>, 34: 159-163.
<a href="https://doi.org/10.1016/j.socnet.2011.10.006">doi:10.1016/j.socnet.2011.10.006</a>
</p>



<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net_connectedness(ison_networkers)
1 - net_reciprocity(ison_networkers)
net_efficiency(ison_networkers)
net_upperbound(ison_networkers)
</code></pre>

<hr>
<h2 id='measure_holes'>Measures of structural holes</h2><span id='topic+measure_holes'></span><span id='topic+node_bridges'></span><span id='topic+node_redundancy'></span><span id='topic+node_effsize'></span><span id='topic+node_efficiency'></span><span id='topic+node_constraint'></span><span id='topic+node_hierarchy'></span><span id='topic+node_neighbours_degree'></span><span id='topic+tie_cohesion'></span>

<h3>Description</h3>

<p>These function provide different measures of the degree to which nodes
fill structural holes, as outlined in Burt (1992):
</p>

<ul>
<li> <p><code>node_bridges()</code> measures the sum of bridges to which each node
is adjacent.
</p>
</li>
<li> <p><code>node_redundancy()</code> measures the redundancy of each nodes' contacts.
</p>
</li>
<li> <p><code>node_effsize()</code> measures nodes' effective size.
</p>
</li>
<li> <p><code>node_efficiency()</code> measures nodes' efficiency.
</p>
</li>
<li> <p><code>node_constraint()</code> measures nodes' constraint scores for one-mode networks
according to Burt (1992) and for two-mode networks according to Hollway et al (2020).
</p>
</li>
<li> <p><code>node_hierarchy()</code> measures nodes' exposure to hierarchy,
where only one or two contacts are the source of closure.
</p>
</li>
<li> <p><code>node_neighbours_degree()</code> measures nodes' average nearest neighbors degree,
or <code class="reqn">knn</code>, a measure of the type of local environment a node finds itself in
</p>
</li>
<li> <p><code>tie_cohesion()</code> measures the ratio between common neighbors to ties'
adjacent nodes and the total number of adjacent nodes,
where high values indicate ties' embeddedness in dense local environments
</p>
</li></ul>

<p>Burt's theory holds that while those nodes embedded in dense clusters
of close connections are likely exposed to the same or similar ideas and information,
those who fill structural holes between two otherwise disconnected groups
can gain some comparative advantage from that position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_bridges(.data)

node_redundancy(.data)

node_effsize(.data)

node_efficiency(.data)

node_constraint(.data)

node_hierarchy(.data)

node_neighbours_degree(.data)

tie_cohesion(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_holes_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>A number of different ways of measuring these structural holes are available.
Note that we use Borgatti's reformulation for unweighted networks in
<code>node_redundancy()</code> and <code>node_effsize()</code>.
Redundancy is thus <code class="reqn">\frac{2t}{n}</code>,
where <code class="reqn">t</code> is the sum of ties and <code class="reqn">n</code> the sum of nodes in each node's neighbourhood,
and effective size is calculated as <code class="reqn">n - \frac{2t}{n}</code>.
Node efficiency is the node's effective size divided by its degree.
</p>


<h3>References</h3>



<h4>On structural holes</h4>

<p>Burt, Ronald S. 1992.
<em>Structural Holes: The Social Structure of Competition</em>.
Cambridge, MA: Harvard University Press.
</p>

<p>Borgatti, Steven. 1997.
“<a href="http://www.analytictech.com/connections/v20(1)/holes.htm">Structural Holes: Unpacking Burt’s Redundancy Measures</a>”
<em>Connections</em> 20(1):35-38.
</p>
<p>Burchard, Jake, and Benjamin Cornwell. 2018.
“Structural Holes and Bridging in Two-Mode Networks.”
<em>Social Networks</em> 55:11–20.
<a href="https://doi.org/10.1016/j.socnet.2018.04.001">doi:10.1016/j.socnet.2018.04.001</a>
</p>
<p>Hollway, James, Jean-Frédéric Morin, and Joost Pauwelyn. 2020.
&quot;Structural conditions for novelty: The introduction of new environmental clauses to the trade regime complex.&quot;
<em>International Environmental Agreements: Politics, Law and Economics</em> 20 (1): 61–83.
<a href="https://doi.org/10.1007/s10784-019-09464-5">doi:10.1007/s10784-019-09464-5</a>
</p>


<h4>On neighbours average degree</h4>

<p>Barrat, Alain, Marc Barthelemy, Romualdo Pastor-Satorras, and Alessandro Vespignani. 2004.
&quot;The architecture of complex weighted networks&quot;,
<em>Proc. Natl. Acad. Sci.</em> 101: 3747.
</p>



<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_bridges(ison_adolescents)
node_bridges(ison_southern_women)
node_redundancy(ison_adolescents)
node_redundancy(ison_southern_women)
node_effsize(ison_adolescents)
node_effsize(ison_southern_women)
node_efficiency(ison_adolescents)
node_efficiency(ison_southern_women)
node_constraint(ison_southern_women)
node_hierarchy(ison_adolescents)
node_hierarchy(ison_southern_women)
</code></pre>

<hr>
<h2 id='measure_over'>Helper functions for measuring over splits of networks</h2><span id='topic+measure_over'></span><span id='topic+over_membership'></span><span id='topic+over_waves'></span><span id='topic+over_time'></span>

<h3>Description</h3>


<ul>
<li> <p><code>over_membership()</code> runs a function, e.g. a measure,
over different group memberships
</p>
</li>
<li> <p><code>over_waves()</code> runs a function, e.g. a measure,
over waves of a panel network
</p>
</li>
<li> <p><code>over_time()</code> runs a function, e.g. a measure,
over time slices of a dynamic network
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>over_membership(
  .data,
  FUN,
  ...,
  membership,
  strategy = "sequential",
  verbose = FALSE
)

over_waves(
  .data,
  FUN,
  ...,
  attribute = "wave",
  strategy = "sequential",
  verbose = FALSE
)

over_time(
  .data,
  FUN,
  ...,
  attribute = "time",
  slice = NULL,
  strategy = "sequential",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_over_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_over_+3A_fun">FUN</code></td>
<td>
<p>A function to run over all splits.</p>
</td></tr>
<tr><td><code id="measure_over_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to FUN.</p>
</td></tr>
<tr><td><code id="measure_over_+3A_membership">membership</code></td>
<td>
<p>A categorical membership vector.</p>
</td></tr>
<tr><td><code id="measure_over_+3A_strategy">strategy</code></td>
<td>
<p>If <code>{furrr}</code> is installed,
then multiple cores can be used to accelerate the function.
By default <code>"sequential"</code>,
but if multiple cores available,
then <code>"multisession"</code> or <code>"multicore"</code> may be useful.
Generally this is useful only when <code>times</code> &gt; 1000.
See <a href="https://furrr.futureverse.org"><code>{furrr}</code></a> for more.</p>
</td></tr>
<tr><td><code id="measure_over_+3A_verbose">verbose</code></td>
<td>
<p>Whether the function should report on its progress.
By default FALSE.
See <a href="https://progressr.futureverse.org"><code>{progressr}</code></a> for more.</p>
</td></tr>
<tr><td><code id="measure_over_+3A_attribute">attribute</code></td>
<td>
<p>A string naming the attribute to be split upon.</p>
</td></tr>
<tr><td><code id="measure_over_+3A_slice">slice</code></td>
<td>
<p>Optionally, a vector of specific slices.
Otherwise all observed slices will be returned.</p>
</td></tr>
</table>

<hr>
<h2 id='measure_periods'>Measures of network change</h2><span id='topic+measure_periods'></span><span id='topic+net_change'></span><span id='topic+net_stability'></span><span id='topic+net_correlation'></span>

<h3>Description</h3>

<p>These functions measure certain topological features of networks:
</p>

<ul>
<li> <p><code>net_change()</code> measures the Hamming distance between two or more networks.
</p>
</li>
<li> <p><code>net_stability()</code> measures the Jaccard index of stability between two or more networks.
</p>
</li>
<li> <p><code>net_correlation()</code> measures the product-moment correlation between two networks.
</p>
</li></ul>

<p>These <code style="white-space: pre;">&#8288;net_*()&#8288;</code> functions return a numeric vector the length of the number
of networks minus one. E.g., the periods between waves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_change(.data, object2)

net_stability(.data, object2)

net_correlation(.data, object2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_periods_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_periods_+3A_object2">object2</code></td>
<td>
<p>A network object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>

<hr>
<h2 id='measure_properties'>Describing network properties</h2><span id='topic+measure_properties'></span><span id='topic+net_nodes'></span><span id='topic+net_ties'></span><span id='topic+net_dims'></span><span id='topic+net_node_attributes'></span><span id='topic+net_tie_attributes'></span>

<h3>Description</h3>

<p>These functions extract certain attributes from given network data:
</p>

<ul>
<li> <p><code>net_nodes()</code> returns the total number of nodes (of any mode) in a network.
</p>
</li>
<li> <p><code>net_ties()</code> returns the number of ties in a network.
</p>
</li>
<li> <p><code>net_dims()</code> returns the dimensions of a network in a vector
as long as the number of modes in the network.
</p>
</li>
<li> <p><code>net_node_attributes()</code> returns a vector of nodal attributes in a network.
</p>
</li>
<li> <p><code>net_tie_attributes()</code> returns a vector of tie attributes in a network.
</p>
</li></ul>

<p>These functions are also often used as helpers within other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_nodes(.data)

net_ties(.data)

net_dims(.data)

net_node_attributes(.data)

net_tie_attributes(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_properties_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;net_*()&#8288;</code> functions always relate to the overall graph or network,
usually returning a scalar.
<code>net_dims()</code> returns an integer of the number of nodes in a one-mode network,
or two integers representing the number of nodes in each nodeset
in the case of a two-mode network.
<code style="white-space: pre;">&#8288;net_*_attributes()&#8288;</code> returns a string vector with the names
of all node or tie attributes in the network.
</p>


<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+member_diffusion">member_diffusion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net_nodes(ison_southern_women)
net_ties(ison_southern_women)
net_dims(ison_southern_women)
net_dims(to_mode1(ison_southern_women))
  net_node_attributes(fict_lotr)
  net_tie_attributes(ison_algebra)
</code></pre>

<hr>
<h2 id='member_brokerage'>Memberships of brokerage</h2><span id='topic+member_brokerage'></span><span id='topic+node_in_brokering'></span>

<h3>Description</h3>

<p>These functions include ways to take a census of the brokerage positions of nodes
in a network:
</p>

<ul>
<li> <p><code>node_in_brokerage()</code> returns nodes membership as a powerhouse,
connector, linchpin, or sideliner according to Hamilton et al. (2020).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_in_brokering(.data, membership)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="member_brokerage_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="member_brokerage_+3A_membership">membership</code></td>
<td>
<p>A vector of partition membership as integers.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other memberships: 
<code><a href="#topic+mark_core">mark_core</a></code>,
<code><a href="#topic+member_cliques">member_cliques</a></code>,
<code><a href="#topic+member_community_hier">member_community_hier</a></code>,
<code><a href="#topic+member_community_non">member_community_non</a></code>,
<code><a href="#topic+member_components">member_components</a></code>,
<code><a href="#topic+member_equivalence">member_equivalence</a></code>
</p>

<hr>
<h2 id='member_cliques'>Clique partitioning algorithms</h2><span id='topic+member_cliques'></span><span id='topic+node_in_roulette'></span>

<h3>Description</h3>

<p>These functions create a vector of nodes' memberships in
cliques:
</p>

<ul>
<li> <p><code>node_in_roulette()</code> assigns nodes to maximally diverse groups.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_in_roulette(.data, num_groups, group_size, times = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="member_cliques_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="member_cliques_+3A_num_groups">num_groups</code></td>
<td>
<p>An integer indicating the number of groups desired.</p>
</td></tr>
<tr><td><code id="member_cliques_+3A_group_size">group_size</code></td>
<td>
<p>An integer indicating the desired size of most of the groups.
Note that if the number of nodes is not divisible into groups of equal size,
there may be some larger or smaller groups.</p>
</td></tr>
<tr><td><code id="member_cliques_+3A_times">times</code></td>
<td>
<p>An integer of the number of search iterations the algorithm should complete.
By default this is the number of nodes in the network multiplied by the number of groups.
This heuristic may be insufficient for small networks and numbers of groups,
and burdensome for large networks and numbers of groups, but can be overwritten.
At every 10th iteration, a stronger perturbation of a number of successive changes,
approximately the number of nodes divided by the number of groups,
will take place irrespective of whether it improves the objective function.</p>
</td></tr>
</table>


<h3>Maximally diverse grouping problem</h3>

<p>This well known computational problem is a NP-hard problem
with a number of relevant applications,
including the formation of groups of students that have encountered
each other least or least recently.
Essentially, the aim is to return a membership of nodes in cliques
that minimises the sum of their previous (weighted) ties:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{g=1}^{m} \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} x_{ij} y_{ig} y_{jg}</code>
</p>

<p>where <code class="reqn">y_{ig} = 1</code> if node <code class="reqn">i</code> is in group <code class="reqn">g</code>, and 0 otherwise.
</p>
<p><code class="reqn">x_{ij}</code> is the existing network data.
If this is an empty network, the function will just return cliques.
To run this repeatedly, one can join a clique network of the membership result
with the original network, using this as the network data for the next round.
</p>
<p>A form of the Lai and Hao (2016) iterated maxima search (IMS) is used here.
This performs well for small and moderately sized networks.
It includes both weak and strong perturbations to an initial solution
to ensure that a robust solution from the broader state space is identified.
The user is referred to Lai and Hao (2016) and Lai et al (2021) for more details.
</p>


<h3>References</h3>



<h4>On the maximally diverse grouping problem</h4>

<p>Lai, Xiangjing, and Jin-Kao Hao. 2016.
“Iterated Maxima Search for the Maximally Diverse Grouping Problem.”
<em>European Journal of Operational Research</em> 254(3):780–800.
<a href="https://doi.org/10.1016/j.ejor.2016.05.018">doi:10.1016/j.ejor.2016.05.018</a>.
</p>
<p>Lai, Xiangjing, Jin-Kao Hao, Zhang-Hua Fu, and Dong Yue. 2021.
“Neighborhood Decomposition Based Variable Neighborhood Search and Tabu Search for Maximally Diverse Grouping.”
<em>European Journal of Operational Research</em> 289(3):1067–86.
<a href="https://doi.org/10.1016/j.ejor.2020.07.048">doi:10.1016/j.ejor.2020.07.048</a>.
</p>



<h3>See Also</h3>

<p>Other memberships: 
<code><a href="#topic+mark_core">mark_core</a></code>,
<code><a href="#topic+member_brokerage">member_brokerage</a></code>,
<code><a href="#topic+member_community_hier">member_community_hier</a></code>,
<code><a href="#topic+member_community_non">member_community_non</a></code>,
<code><a href="#topic+member_components">member_components</a></code>,
<code><a href="#topic+member_equivalence">member_equivalence</a></code>
</p>

<hr>
<h2 id='member_community_hier'>Hierarchical community partitioning algorithms</h2><span id='topic+member_community_hier'></span><span id='topic+node_in_betweenness'></span><span id='topic+node_in_greedy'></span><span id='topic+node_in_eigen'></span><span id='topic+node_in_walktrap'></span>

<h3>Description</h3>

<p>These functions offer algorithms for hierarchically clustering
networks into communities. Since all of the following are hierarchical,
their dendrograms can be plotted:
</p>

<ul>
<li> <p><code>node_in_betweenness()</code> is a hierarchical, decomposition algorithm
where edges are removed in decreasing order of the number of
shortest paths passing through the edge.
</p>
</li>
<li> <p><code>node_in_greedy()</code> is a hierarchical, agglomerative algorithm,
that tries to optimize modularity in a greedy manner.
</p>
</li>
<li> <p><code>node_in_eigen()</code> is a top-down, hierarchical algorithm.
</p>
</li>
<li> <p><code>node_in_walktrap()</code> is a hierarchical, agglomerative algorithm based on random walks.
</p>
</li></ul>

<p>The different algorithms offer various advantages in terms of computation time,
availability on different types of networks, ability to maximise modularity,
and their logic or domain of inspiration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_in_betweenness(.data)

node_in_greedy(.data)

node_in_eigen(.data)

node_in_walktrap(.data, times = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="member_community_hier_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="member_community_hier_+3A_times">times</code></td>
<td>
<p>Integer indicating number of simulations/walks used.
By default, <code>times=50</code>.</p>
</td></tr>
</table>


<h3>Edge-betweenness</h3>

<p>This is motivated by the idea that edges connecting different groups
are more likely to lie on multiple shortest paths when they are the
only option to go from one group to another.
This method yields good results but is very slow because of
the computational complexity of edge-betweenness calculations and
the betweenness scores have to be re-calculated after every edge removal.
Networks of ~700 nodes and ~3500 ties are around the upper size limit
that are feasible with this approach.
</p>


<h3>Fast-greedy</h3>

<p>Initially, each node is assigned a separate community.
Communities are then merged iteratively such that each merge
yields the largest increase in the current value of modularity,
until no further increases to the modularity are possible.
The method is fast and recommended as a first approximation
because it has no parameters to tune.
However, it is known to suffer from a resolution limit.
</p>


<h3>Leading eigenvector</h3>

<p>In each step, the network is bifurcated such that modularity increases most.
The splits are determined according to the leading eigenvector of the modularity matrix.
A stopping condition prevents tightly connected groups from being split further.
Note that due to the eigenvector calculations involved,
this algorithm will perform poorly on degenerate networks,
but will likely obtain a higher modularity than fast-greedy (at some cost of speed).
</p>


<h3>Walktrap</h3>

<p>The general idea is that random walks on a network are more likely to stay
within the same community because few edges lead outside a community.
By repeating random walks of 4 steps many times,
information about the hierarchical merging of communities is collected.
</p>


<h3>References</h3>



<h4>On edge-betweenness community detection</h4>

<p>Newman, Mark, and Michelle Girvan. 2004.
&quot;Finding and evaluating community structure in networks.&quot;
<em>Physical Review E</em> 69: 026113.
<a href="https://doi.org/10.1103/PhysRevE.69.026113">doi:10.1103/PhysRevE.69.026113</a>
</p>



<h4>On fast-greedy community detection</h4>

<p>Clauset, Aaron, Mark E.J. Newman, and Cristopher Moore. 2004.
&quot;Finding community structure in very large networks.&quot;
<em>Physical Review E</em>, 70: 066111.
<a href="https://doi.org/10.1103/PhysRevE.70.066111">doi:10.1103/PhysRevE.70.066111</a>
</p>



<h4>On leading eigenvector community detection</h4>

<p>Newman, Mark E.J. 2006.
&quot;Finding community structure using the eigenvectors of matrices&quot;
<em>Physical Review E</em> 74:036104.
<a href="https://doi.org/10.1103/PhysRevE.74.036104">doi:10.1103/PhysRevE.74.036104</a>
</p>



<h4>On walktrap community detection</h4>

<p>Pons, Pascal, and Matthieu Latapy. 2005.
&quot;Computing communities in large networks using random walks&quot;.
1-20.
<a href="https://doi.org/10.48550/arXiv.physics/0512106">doi:10.48550/arXiv.physics/0512106</a>
</p>



<h3>See Also</h3>

<p>Other memberships: 
<code><a href="#topic+mark_core">mark_core</a></code>,
<code><a href="#topic+member_brokerage">member_brokerage</a></code>,
<code><a href="#topic+member_cliques">member_cliques</a></code>,
<code><a href="#topic+member_community_non">member_community_non</a></code>,
<code><a href="#topic+member_components">member_components</a></code>,
<code><a href="#topic+member_equivalence">member_equivalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_in_betweenness(ison_adolescents)
if(require("ggdendro", quietly = TRUE)){
plot(node_in_betweenness(ison_adolescents))
}
node_in_greedy(ison_adolescents)
node_in_eigen(ison_adolescents)
node_in_walktrap(ison_adolescents)
</code></pre>

<hr>
<h2 id='member_community_non'>Non-hierarchical community partitioning algorithms</h2><span id='topic+member_community_non'></span><span id='topic+node_in_community'></span><span id='topic+node_in_optimal'></span><span id='topic+node_in_partition'></span><span id='topic+node_in_infomap'></span><span id='topic+node_in_spinglass'></span><span id='topic+node_in_fluid'></span><span id='topic+node_in_louvain'></span><span id='topic+node_in_leiden'></span>

<h3>Description</h3>

<p>These functions offer algorithms for partitioning
networks into sets of communities:
</p>

<ul>
<li> <p><code>node_in_community()</code> runs either optimal or, for larger networks,
finds the algorithm that maximises modularity and returns that membership
vector.
</p>
</li>
<li> <p><code>node_in_optimal()</code> is a problem-solving algorithm that seeks to maximise
modularity over all possible partitions.
</p>
</li>
<li> <p><code>node_in_partition()</code> is a greedy, iterative, deterministic
partitioning algorithm that results in two equally-sized communities.
</p>
</li>
<li> <p><code>node_in_infomap()</code> is an algorithm based on the information in random walks.
</p>
</li>
<li> <p><code>node_in_spinglass()</code> is a greedy, iterative, probabilistic algorithm,
based on analogy to model from statistical physics.
</p>
</li>
<li> <p><code>node_in_fluid()</code> is a propogation-based partitioning algorithm,
based on analogy to model from fluid dynamics.
</p>
</li>
<li> <p><code>node_in_louvain()</code> is an agglomerative multilevel algorithm that seeks to maximise
modularity over all possible partitions.
</p>
</li>
<li> <p><code>node_in_leiden()</code> is an agglomerative multilevel algorithm that seeks to maximise
the Constant Potts Model over all possible partitions.
</p>
</li></ul>

<p>The different algorithms offer various advantages in terms of computation time,
availability on different types of networks, ability to maximise modularity,
and their logic or domain of inspiration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_in_community(.data)

node_in_optimal(.data)

node_in_partition(.data)

node_in_infomap(.data, times = 50)

node_in_spinglass(.data, max_k = 200, resolution = 1)

node_in_fluid(.data)

node_in_louvain(.data, resolution = 1)

node_in_leiden(.data, resolution = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="member_community_non_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="member_community_non_+3A_times">times</code></td>
<td>
<p>Integer indicating number of simulations/walks used.
By default, <code>times=50</code>.</p>
</td></tr>
<tr><td><code id="member_community_non_+3A_max_k">max_k</code></td>
<td>
<p>Integer constant, the number of spins to use as an upper limit
of communities to be found. Some sets can be empty at the end.</p>
</td></tr>
<tr><td><code id="member_community_non_+3A_resolution">resolution</code></td>
<td>
<p>The Reichardt-Bornholdt “gamma” resolution parameter for modularity.
By default 1, making existing and non-existing ties equally important.
Smaller values make existing ties more important,
and larger values make missing ties more important.</p>
</td></tr>
</table>


<h3>Community</h3>

<p>This function runs through all available community detection algorithms
for a given network type, finds the algorithm that returns the
largest modularity score, and returns the corresponding membership
partition.
Where feasible (a small enough network), the optimal problem solving
technique is used to ensure the maximal modularity partition.
</p>


<h3>Optimal</h3>

<p>The general idea is to calculate the modularity of all possible partitions,
and choose the community structure that maximises this modularity measure.
Note that this is an NP-complete problem with exponential time complexity.
The guidance in the igraph package is networks of &lt;50-200 nodes is probably fine.
</p>


<h3>Infomap</h3>

<p>Motivated by information theoretic principles, this algorithm tries to build
a grouping that provides the shortest description length for a random walk,
where the description length is measured by the expected number of bits per node required to encode the path.
</p>


<h3>Spin-glass</h3>

<p>This is motivated by analogy to the Potts model in statistical physics.
Each node can be in one of <em>k</em> &quot;spin states&quot;,
and ties (particle interactions) provide information about which pairs of nodes
want similar or different spin states.
The final community definitions are represented by the nodes' spin states
after a number of updates.
A different implementation than the default is used in the case of signed networks,
such that nodes connected by negative ties will be more likely found in separate communities.
</p>


<h3>Fluid</h3>

<p>The general idea is to observe how a discrete number of fluids interact, expand and contract,
in a non-homogenous environment, i.e. the network structure.
Unlike the <code>{igraph}</code> implementation that this function wraps,
this function iterates over all possible numbers of communities and returns the membership
associated with the highest modularity.
</p>


<h3>Louvain</h3>

<p>The general idea is to take a hierarchical approach to optimising the modularity criterion.
Nodes begin in their own communities and are re-assigned in a local, greedy way:
each node is moved to the community where it achieves the highest contribution to modularity.
When no further modularity-increasing reassignments are possible,
the resulting communities are considered nodes (like a reduced graph),
and the process continues.
</p>


<h3>Leiden</h3>

<p>The general idea is to optimise the Constant Potts Model,
which does not suffer from the resolution limit, instead of modularity.
As outlined in the <code>{igraph}</code> package,
the Constant Potts Model object function is:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2m} \sum_{ij}(A_{ij}-\gamma n_i n_j)\delta(\sigma_i, \sigma_j)</code>
</p>

<p>where <em>m</em> is the total tie weight,
<code class="reqn">A_{ij}</code> is the tie weight between <em>i</em> and <em>j</em>,
<code class="reqn">\gamma</code> is the so-called resolution parameter,
<code class="reqn">n_i</code> is the node weight of node <em>i</em>,
and <code class="reqn">\delta(\sigma_i, \sigma_j) = 1</code> if and only if
<em>i</em> and <em>j</em> are in the same communities and 0 otherwise.
Compared to the Louvain method, the Leiden algorithm additionally
tries to avoid unconnected communities.
</p>


<h3>References</h3>



<h4>On optimal community detection</h4>

<p>Brandes, Ulrik, Daniel Delling, Marco Gaertler, Robert Gorke, Martin Hoefer, Zoran Nikoloski, Dorothea Wagner. 2008.
&quot;On Modularity Clustering&quot;,
<em>IEEE Transactions on Knowledge and Data Engineering</em> 20(2):172-188.
</p>



<h4>On partitioning community detection</h4>

<p>Kernighan, Brian W., and Shen Lin. 1970.
&quot;An efficient heuristic procedure for partitioning graphs.&quot;
<em>The Bell System Technical Journal</em> 49(2): 291-307.
<a href="https://doi.org/10.1002/j.1538-7305.1970.tb01770.x">doi:10.1002/j.1538-7305.1970.tb01770.x</a>
</p>



<h4>On infomap community detection</h4>

<p>Rosvall, M, and C. T. Bergstrom. 2008.
&quot;Maps of information flow reveal community structure in complex networks&quot;,
<em>PNAS</em> 105:1118.
<a href="https://doi.org/10.1073/pnas.0706851105">doi:10.1073/pnas.0706851105</a>
</p>
<p>Rosvall, M., D. Axelsson, and C. T. Bergstrom. 2009.
&quot;The map equation&quot;,
<em>Eur. Phys. J. Special Topics</em> 178: 13.
<a href="https://doi.org/10.1140/epjst/e2010-01179-1">doi:10.1140/epjst/e2010-01179-1</a>
</p>



<h4>On spinglass community detection</h4>

<p>Reichardt, Jorg, and Stefan Bornholdt. 2006.
&quot;Statistical Mechanics of Community Detection&quot;
<em>Physical Review E</em>, 74(1): 016110–14.
<a href="https://doi.org/10.1073/pnas.0605965104">doi:10.1073/pnas.0605965104</a>
</p>
<p>Traag, Vincent A., and Jeroen Bruggeman. 2009.
&quot;Community detection in networks with positive and negative links&quot;.
<em>Physical Review E</em>, 80(3): 036115.
<a href="https://doi.org/10.1103/PhysRevE.80.036115">doi:10.1103/PhysRevE.80.036115</a>
</p>



<h4>On fluid community detection</h4>

<p>Parés Ferran, Dario Garcia Gasulla, Armand Vilalta, Jonatan Moreno, Eduard Ayguade, Jesus Labarta, Ulises Cortes, and Toyotaro Suzumura. 2018.
&quot;Fluid Communities: A Competitive, Scalable and Diverse Community Detection Algorithm&quot;.
In: <em>Complex Networks &amp; Their Applications VI</em>
Springer, 689: 229.
<a href="https://doi.org/10.1007/978-3-319-72150-7_19">doi:10.1007/978-3-319-72150-7_19</a>
</p>



<h4>On Louvain community detection</h4>

<p>Blondel, Vincent, Jean-Loup Guillaume, Renaud Lambiotte, Etienne Lefebvre. 2008.
&quot;Fast unfolding of communities in large networks&quot;,
<em>J. Stat. Mech.</em> P10008.
</p>



<h4>On Leiden community detection</h4>

<p>Traag, Vincent A., Ludo Waltman, and Nees Jan van Eck. 2019.
&quot;From Louvain to Leiden: guaranteeing well-connected communities&quot;,
<em>Scientific Reports</em>, 9(1):5233.
<a href="https://doi.org/10.1038/s41598-019-41695-z">doi:10.1038/s41598-019-41695-z</a>
</p>



<h3>See Also</h3>

<p>Other memberships: 
<code><a href="#topic+mark_core">mark_core</a></code>,
<code><a href="#topic+member_brokerage">member_brokerage</a></code>,
<code><a href="#topic+member_cliques">member_cliques</a></code>,
<code><a href="#topic+member_community_hier">member_community_hier</a></code>,
<code><a href="#topic+member_components">member_components</a></code>,
<code><a href="#topic+member_equivalence">member_equivalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>node_in_optimal(ison_adolescents)
node_in_partition(ison_adolescents)
node_in_partition(ison_southern_women)
node_in_infomap(ison_adolescents)
node_in_spinglass(ison_adolescents)
node_in_fluid(ison_adolescents)
node_in_louvain(ison_adolescents)
node_in_leiden(ison_adolescents)
</code></pre>

<hr>
<h2 id='member_components'>Component partitioning algorithms</h2><span id='topic+member_components'></span><span id='topic+node_in_component'></span><span id='topic+node_in_weak'></span><span id='topic+node_in_strong'></span>

<h3>Description</h3>

<p>These functions create a vector of nodes' memberships in
components or degrees of coreness:
</p>

<ul>
<li> <p><code>node_in_component()</code> assigns nodes' component membership
using edge direction where available.
</p>
</li>
<li> <p><code>node_in_weak()</code> assigns nodes' component membership
ignoring edge direction.
</p>
</li>
<li> <p><code>node_in_strong()</code> assigns nodes' component membership
based on edge direction.
</p>
</li></ul>

<p>In graph theory, components, sometimes called connected components,
are induced subgraphs from partitioning the nodes into disjoint sets.
All nodes that are members of the same partition as <em>i</em> are reachable
from <em>i</em>.
</p>
<p>For directed networks,
strongly connected components consist of subgraphs where there are paths
in each direction between member nodes.
Weakly connected components consist of subgraphs where there is a path
in either direction between member nodes.
</p>
<p>Coreness captures the maximal subgraphs in which each vertex has at least
degree <em>k</em>, where <em>k</em> is also the order of the subgraph.
As described in <code>igraph::coreness</code>,
a node's coreness is <em>k</em> if it belongs to the <em>k</em>-core
but not to the (<em>k</em>+1)-core.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_in_component(.data)

node_in_weak(.data)

node_in_strong(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="member_components_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other memberships: 
<code><a href="#topic+mark_core">mark_core</a></code>,
<code><a href="#topic+member_brokerage">member_brokerage</a></code>,
<code><a href="#topic+member_cliques">member_cliques</a></code>,
<code><a href="#topic+member_community_hier">member_community_hier</a></code>,
<code><a href="#topic+member_community_non">member_community_non</a></code>,
<code><a href="#topic+member_equivalence">member_equivalence</a></code>
</p>

<hr>
<h2 id='member_diffusion'>Membership of nodes in a diffusion</h2><span id='topic+member_diffusion'></span><span id='topic+node_in_adopter'></span>

<h3>Description</h3>

<p><code>node_in_adopter()</code> classifies membership of nodes into diffusion categories
by where on the distribution of adopters they fell.
Valente (1995) defines five memberships:
</p>

<ul>
<li> <p><em>Early adopter</em>: those with an adoption time less than
the average adoption time minus one standard deviation of adoptions times
</p>
</li>
<li> <p><em>Early majority</em>: those with an adoption time between
the average adoption time and
the average adoption time minus one standard deviation of adoptions times
</p>
</li>
<li> <p><em>Late majority</em>: those with an adoption time between
the average adoption time and
the average adoption time plus one standard deviation of adoptions times
</p>
</li>
<li> <p><em>Laggard</em>: those with an adoption time greater than
the average adoption time plus one standard deviation of adoptions times
</p>
</li>
<li> <p><em>Non-adopter</em>: those without an adoption time,
i.e. never adopted
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_in_adopter(diff_model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="member_diffusion_+3A_diff_model">diff_model</code></td>
<td>
<p>A valid network diffusion model,
as created by <code>as_diffusion()</code> or <code>play_diffusion()</code>.</p>
</td></tr>
</table>


<h3>References</h3>



<h4>On adopter classes</h4>

<p>Valente, Tom W. 1995.
<em>Network models of the diffusion of innovations</em>
(2nd ed.). Cresskill N.J.: Hampton Press.
</p>



<h3>See Also</h3>

<p>Other measures: 
<code><a href="#topic+measure_attributes">measure_attributes</a></code>,
<code><a href="#topic+measure_central_between">measure_central_between</a></code>,
<code><a href="#topic+measure_central_close">measure_central_close</a></code>,
<code><a href="#topic+measure_central_degree">measure_central_degree</a></code>,
<code><a href="#topic+measure_central_eigen">measure_central_eigen</a></code>,
<code><a href="#topic+measure_closure">measure_closure</a></code>,
<code><a href="#topic+measure_cohesion">measure_cohesion</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>,
<code><a href="#topic+measure_features">measure_features</a></code>,
<code><a href="#topic+measure_heterogeneity">measure_heterogeneity</a></code>,
<code><a href="#topic+measure_hierarchy">measure_hierarchy</a></code>,
<code><a href="#topic+measure_holes">measure_holes</a></code>,
<code><a href="#topic+measure_periods">measure_periods</a></code>,
<code><a href="#topic+measure_properties">measure_properties</a></code>
</p>
<p>Other diffusion: 
<code><a href="#topic+make_play">make_play</a></code>,
<code><a href="#topic+measure_diffusion_infection">measure_diffusion_infection</a></code>,
<code><a href="#topic+measure_diffusion_net">measure_diffusion_net</a></code>,
<code><a href="#topic+measure_diffusion_node">measure_diffusion_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  smeg &lt;- generate_smallworld(15, 0.025)
  smeg_diff &lt;- play_diffusion(smeg, recovery = 0.2)
  # To classify nodes by their position in the adoption curve
  (adopts &lt;- node_in_adopter(smeg_diff))
  summary(adopts)
</code></pre>

<hr>
<h2 id='member_equivalence'>Equivalence clustering algorithms</h2><span id='topic+member_equivalence'></span><span id='topic+node_in_equivalence'></span><span id='topic+node_in_structural'></span><span id='topic+node_in_regular'></span><span id='topic+node_in_automorphic'></span>

<h3>Description</h3>

<p>These functions combine an appropriate <code style="white-space: pre;">&#8288;node_by_*()&#8288;</code> function
together with methods for calculating the hierarchical clusters
provided by a certain distance calculation.
</p>

<ul>
<li> <p><code>node_in_equivalence()</code> assigns nodes membership based on their equivalence
with respective to some census/class.
The following functions call this function, together with an appropriate census.
</p>

<ul>
<li> <p><code>node_in_structural()</code> assigns nodes membership based on their
having equivalent ties to the same other nodes.
</p>
</li>
<li> <p><code>node_in_regular()</code> assigns nodes membership based on their
having equivalent patterns of ties.
</p>
</li>
<li> <p><code>node_in_automorphic()</code> assigns nodes membership based on their
having equivalent distances to other nodes.
</p>
</li></ul>

</li></ul>

<p>A <code>plot()</code> method exists for investigating the dendrogram
of the hierarchical cluster and showing the returned cluster
assignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_in_equivalence(
  .data,
  census,
  k = c("silhouette", "elbow", "strict"),
  cluster = c("hierarchical", "concor", "cosine"),
  distance = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  range = 8L
)

node_in_structural(
  .data,
  k = c("silhouette", "elbow", "strict"),
  cluster = c("hierarchical", "concor", "cosine"),
  distance = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  range = 8L
)

node_in_regular(
  .data,
  k = c("silhouette", "elbow", "strict"),
  cluster = c("hierarchical", "concor", "cosine"),
  distance = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  range = 8L
)

node_in_automorphic(
  .data,
  k = c("silhouette", "elbow", "strict"),
  cluster = c("hierarchical", "concor", "cosine"),
  distance = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  range = 8L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="member_equivalence_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="member_equivalence_+3A_census">census</code></td>
<td>
<p>A matrix returned by a <code style="white-space: pre;">&#8288;node_by_*()&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="member_equivalence_+3A_k">k</code></td>
<td>
<p>Typically a character string indicating which method
should be used to select the number of clusters to return.
By default <code>"silhouette"</code>, other options include <code>"elbow"</code> and <code>"strict"</code>.
<code>"strict"</code> returns classes with members only when strictly equivalent.
<code>"silhouette"</code> and <code>"elbow"</code> select classes based on the distance between
clusters or between nodes within a cluster.
Fewer, identifiable letters, e.g. <code>"e"</code> for elbow, is sufficient.
Alternatively, if <code>k</code> is passed an integer, e.g. <code>k = 3</code>,
then all selection routines are skipped in favour of this number of clusters.</p>
</td></tr>
<tr><td><code id="member_equivalence_+3A_cluster">cluster</code></td>
<td>
<p>Character string indicating whether clusters should be
clustered hierarchically (<code>"hierarchical"</code>) or
through convergence of correlations (<code>"concor"</code>).
Fewer, identifiable letters, e.g. <code>"c"</code> for CONCOR, is sufficient.</p>
</td></tr>
<tr><td><code id="member_equivalence_+3A_distance">distance</code></td>
<td>
<p>Character string indicating which distance metric
to pass on to <code>stats::dist</code>.
By default <code>"euclidean"</code>, but other options include
<code>"maximum"</code>, <code>"manhattan"</code>, <code>"canberra"</code>, <code>"binary"</code>, and <code>"minkowski"</code>.
Fewer, identifiable letters, e.g. <code>"e"</code> for Euclidean, is sufficient.</p>
</td></tr>
<tr><td><code id="member_equivalence_+3A_range">range</code></td>
<td>
<p>Integer indicating the maximum number of (k) clusters
to evaluate.
Ignored when <code>k = "strict"</code> or a discrete number is given for <code>k</code>.</p>
</td></tr>
</table>


<h3>Source</h3>

<p><a href="https://github.com/aslez/concoR">https://github.com/aslez/concoR</a>
</p>


<h3>See Also</h3>

<p>Other memberships: 
<code><a href="#topic+mark_core">mark_core</a></code>,
<code><a href="#topic+member_brokerage">member_brokerage</a></code>,
<code><a href="#topic+member_cliques">member_cliques</a></code>,
<code><a href="#topic+member_community_hier">member_community_hier</a></code>,
<code><a href="#topic+member_community_non">member_community_non</a></code>,
<code><a href="#topic+member_components">member_components</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(nse &lt;- node_in_structural(ison_algebra))
if(require("ggdendro", quietly = TRUE)){
plot(nse)
}


(nre &lt;- node_in_regular(ison_southern_women,
  cluster = "concor"))
if(require("ggdendro", quietly = TRUE)){
plot(nre)
}


if(require("sna", quietly = TRUE)){
(nae &lt;- node_in_automorphic(ison_southern_women,
  k = "elbow"))
if(require("ggdendro", quietly = TRUE)){
plot(nae)
}
}

</code></pre>

<hr>
<h2 id='model_cluster'>Methods for equivalence clustering</h2><span id='topic+model_cluster'></span><span id='topic+cluster_hierarchical'></span><span id='topic+cluster_cosine'></span><span id='topic+cluster_concor'></span>

<h3>Description</h3>

<p>These functions are used to cluster some census object:
</p>

<ul>
<li> <p><code>cluster_hierarchical()</code> returns a hierarchical clustering object
created by <code>stats::hclust()</code>.
</p>
</li>
<li> <p><code>cluster_concor()</code> returns a hierarchical clustering object
created from a convergence of correlations procedure (CONCOR).
</p>
</li></ul>

<p>These functions are not intended to be called directly,
but are called within <code>node_equivalence()</code> and related functions.
They are exported and listed here to provide more detailed documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_hierarchical(census, distance)

cluster_cosine(census, distance)

cluster_concor(.data, census)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_cluster_+3A_census">census</code></td>
<td>
<p>A matrix returned by a <code style="white-space: pre;">&#8288;node_by_*()&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="model_cluster_+3A_distance">distance</code></td>
<td>
<p>Character string indicating which distance metric
to pass on to <code>stats::dist</code>.
By default <code>"euclidean"</code>, but other options include
<code>"maximum"</code>, <code>"manhattan"</code>, <code>"canberra"</code>, <code>"binary"</code>, and <code>"minkowski"</code>.
Fewer, identifiable letters, e.g. <code>"e"</code> for Euclidean, is sufficient.</p>
</td></tr>
<tr><td><code id="model_cluster_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>CONCOR</h3>

<p>First a matrix of Pearson correlation coefficients between each pair of nodes
profiles in the given census is created.
Then, again, we find the correlations of this square, symmetric matrix,
and continue to do this iteratively until each entry is either <code>1</code> or <code>-1</code>.
These values are used to split the data into two partitions,
with members either holding the values <code>1</code> or <code>-1</code>.
This procedure from census to convergence is then repeated within each block,
allowing further partitions to be found.
Unlike UCINET, partitions are continued until there are single members in
each partition.
Then a distance matrix is constructed from records of in which partition phase
nodes were separated,
and this is given to <code>stats::hclust()</code> so that dendrograms etc can be returned.
</p>


<h3>References</h3>



<h4>On CONCOR clustering</h4>

<p>Breiger, Ronald L., Scott A. Boorman, and Phipps Arabie. 1975.
&quot;An Algorithm for Clustering Relational Data with Applications to
Social Network Analysis and Comparison with Multidimensional Scaling&quot;.
<em>Journal of Mathematical Psychology</em>, 12: 328-83.
<a href="https://doi.org/10.1016/0022-2496%2875%2990028-0">doi:10.1016/0022-2496(75)90028-0</a>.
</p>


<hr>
<h2 id='model_kselect'>Methods for selecting clusters</h2><span id='topic+model_kselect'></span><span id='topic+k_strict'></span><span id='topic+k_elbow'></span><span id='topic+k_silhouette'></span>

<h3>Description</h3>

<p>These functions help select the number of clusters to return from <code>hc</code>,
some hierarchical clustering object:
</p>

<ul>
<li> <p><code>k_strict()</code> selects a number of clusters in which there is no
distance between cluster members.
</p>
</li>
<li> <p><code>k_elbow()</code> selects a number of clusters in which there is
a fair trade-off between parsimony and fit according to the elbow method.
</p>
</li>
<li> <p><code>k_silhouette()</code> selects a number of clusters that
optimises the silhouette score.
</p>
</li></ul>

<p>These functions are generally not user-facing but used internally
in e.g. the <code style="white-space: pre;">&#8288;*_equivalence()&#8288;</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k_strict(hc, .data)

k_elbow(hc, .data, census, range)

k_silhouette(hc, .data, range)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_kselect_+3A_hc">hc</code></td>
<td>
<p>A hierarchical clustering object.</p>
</td></tr>
<tr><td><code id="model_kselect_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="model_kselect_+3A_census">census</code></td>
<td>
<p>A motif census object.</p>
</td></tr>
<tr><td><code id="model_kselect_+3A_range">range</code></td>
<td>
<p>An integer indicating the maximum number of options to consider.
The minimum of this and the number of nodes in the network is used.</p>
</td></tr>
</table>


<h3>References</h3>



<h4>On the elbow method</h4>

<p>Thorndike, Robert L. 1953.
&quot;Who Belongs in the Family?&quot;.
<em>Psychometrika</em>, 18(4): 267–76.
<a href="https://doi.org/10.1007/BF02289263">doi:10.1007/BF02289263</a>.
</p>



<h4>On the silhouette method</h4>

<p>Rousseeuw, Peter J. 1987.
“Silhouettes: A Graphical Aid to the Interpretation and Validation of Cluster Analysis.”
<em>Journal of Computational and Applied Mathematics</em>, 20: 53–65.
<a href="https://doi.org/10.1016/0377-0427%2887%2990125-7">doi:10.1016/0377-0427(87)90125-7</a>.
</p>


<hr>
<h2 id='motif_brokerage'>Motifs of brokerage</h2><span id='topic+motif_brokerage'></span><span id='topic+node_by_brokerage'></span><span id='topic+net_by_brokerage'></span><span id='topic+node_brokering_activity'></span><span id='topic+node_brokering_exclusivity'></span>

<h3>Description</h3>

<p>These functions include ways to take a census of the brokerage positions of nodes
in a network:
</p>

<ul>
<li> <p><code>node_by_brokerage()</code> returns the Gould-Fernandez brokerage
roles played by nodes in a network.
</p>
</li>
<li> <p><code>net_by_brokerage()</code> returns the Gould-Fernandez brokerage
roles in a network.
</p>
</li>
<li> <p><code>node_brokering_activity()</code> measures nodes' brokerage activity.
</p>
</li>
<li> <p><code>node_brokering_exclusivity()</code> measures nodes' brokerage exclusivity.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_by_brokerage(.data, membership, standardized = FALSE)

net_by_brokerage(.data, membership, standardized = FALSE)

node_brokering_activity(.data, membership)

node_brokering_exclusivity(.data, membership)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="motif_brokerage_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="motif_brokerage_+3A_membership">membership</code></td>
<td>
<p>A vector of partition membership as integers.</p>
</td></tr>
<tr><td><code id="motif_brokerage_+3A_standardized">standardized</code></td>
<td>
<p>Whether the score should be standardized
into a <em>z</em>-score indicating how many standard deviations above
or below the average the score lies.</p>
</td></tr>
</table>


<h3>References</h3>



<h4>On brokerage motifs</h4>

<p>Gould, Roger V., and Roberto M. Fernandez. 1989.
“Structures of Mediation: A Formal Approach to Brokerage in Transaction Networks.”
<em>Sociological Methodology</em>, 19: 89-126.
<a href="https://doi.org/10.2307/270949">doi:10.2307/270949</a>
</p>
<p>Jasny, Lorien, and Mark Lubell. 2015.
“Two-Mode Brokerage in Policy Networks.”
<em>Social Networks</em> 41:36–47.
<a href="https://doi.org/10.1016/j.socnet.2014.11.005">doi:10.1016/j.socnet.2014.11.005</a>
</p>



<h4>On brokerage activity and exclusivity</h4>

<p>Hamilton, Matthew, Jacob Hileman, and Orjan Bodin. 2020.
&quot;Evaluating heterogeneous brokerage: New conceptual and methodological approaches
and their application to multi-level environmental governance networks&quot;
<em>Social Networks</em> 61: 1-10.
<a href="https://doi.org/10.1016/j.socnet.2019.08.002">doi:10.1016/j.socnet.2019.08.002</a>
</p>



<h3>See Also</h3>

<p>Other motifs: 
<code><a href="#topic+motif_diffusion">motif_diffusion</a></code>,
<code><a href="#topic+motif_net">motif_net</a></code>,
<code><a href="#topic+motif_node">motif_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># node_by_brokerage(ison_networkers, "Discipline")
# net_by_brokerage(ison_networkers, "Discipline")
node_brokering_exclusivity(ison_networkers, "Discipline")
</code></pre>

<hr>
<h2 id='motif_diffusion'>Motifs of diffusion</h2><span id='topic+motif_diffusion'></span><span id='topic+node_by_exposure'></span>

<h3>Description</h3>


<ul>
<li> <p><code>node_by_exposure()</code> produces a motif matrix of nodes' exposure to
infection/adoption by time step
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_by_exposure(diff_model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="motif_diffusion_+3A_diff_model">diff_model</code></td>
<td>
<p>A valid network diffusion model,
as created by <code>as_diffusion()</code> or <code>play_diffusion()</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other motifs: 
<code><a href="#topic+motif_brokerage">motif_brokerage</a></code>,
<code><a href="#topic+motif_net">motif_net</a></code>,
<code><a href="#topic+motif_node">motif_node</a></code>
</p>

<hr>
<h2 id='motif_net'>Motifs at the network level</h2><span id='topic+motif_net'></span><span id='topic+net_by_dyad'></span><span id='topic+net_by_triad'></span><span id='topic+net_by_tetrad'></span><span id='topic+net_by_mixed'></span>

<h3>Description</h3>

<p>These functions include ways to take a census of the graphlets
in a network:
</p>

<ul>
<li> <p><code>net_by_dyad()</code> returns a census of dyad motifs in a network.
</p>
</li>
<li> <p><code>net_by_triad()</code> returns a census of triad motifs in a network.
</p>
</li>
<li> <p><code>net_by_tetrad()</code> returns a census of tetrad motifs in a network.
</p>
</li>
<li> <p><code>net_by_mixed()</code> returns a census of triad motifs that span
a one-mode and a two-mode network.
</p>
</li></ul>

<p>See also <a href="https://www.graphclasses.org/smallgraphs.html">graph classes</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_by_dyad(.data)

net_by_triad(.data)

net_by_tetrad(.data)

net_by_mixed(.data, object2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="motif_net_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="motif_net_+3A_object2">object2</code></td>
<td>
<p>A second, two-mode migraph-consistent object.</p>
</td></tr>
</table>


<h3>Tetrad census</h3>

<p>The tetrad census counts the number of four-node configurations in the network.
The function returns a matrix with a special naming convention:
</p>

<ul>
<li><p> E4 (aka co-K4): This is an empty set of four nodes; no ties
</p>
</li>
<li><p> I4 (aka co-diamond): This is a set of four nodes with just one tie
</p>
</li>
<li><p> H4 (aka co-C4): This set of four nodes includes two non-adjacent ties
</p>
</li>
<li><p> L4 (aka co-paw): This set of four nodes includes two adjacent ties
</p>
</li>
<li><p> D4 (aka co-claw): This set of four nodes includes three adjacent ties,
in the form of a triangle with one isolate
</p>
</li>
<li><p> U4 (aka P4, four-actor line): This set of four nodes includes three ties
arranged in a line
</p>
</li>
<li><p> Y4 (aka claw): This set of four nodes includes three ties all adjacent
to a single node
</p>
</li>
<li><p> P4 (aka paw, kite): This set of four nodes includes four ties arranged
as a triangle with an extra tie hanging off of one of the nodes
</p>
</li>
<li><p> C4 (aka bifan): This is a symmetric box or 4-cycle or set of shared choices
</p>
</li>
<li><p> Z4 (aka diamond): This resembles C4 but with an extra tie cutting across the box
</p>
</li>
<li><p> X4 (aka K4): This resembles C4 but with two extra ties cutting across the box;
a realisation of all possible ties
</p>
</li></ul>

<p>Graphs of these motifs can be shown using
<code>plot(net_by_tetrad(ison_southern_women))</code>.
</p>


<h3>Source</h3>

<p>Alejandro Espinosa 'netmem'
</p>


<h3>References</h3>



<h4>On the dyad census</h4>

<p>Holland, Paul W., and Samuel Leinhardt. 1970.
&quot;A Method for Detecting Structure in Sociometric Data&quot;.
<em>American Journal of Sociology</em>, 76: 492-513.
<a href="https://doi.org/10.1016/B978-0-12-442450-0.50028-6">doi:10.1016/B978-0-12-442450-0.50028-6</a>
</p>
<p>Wasserman, Stanley, and Katherine Faust. 1994.
&quot;Social Network Analysis: Methods and Applications&quot;.
Cambridge: Cambridge University Press.
</p>



<h4>On the triad census</h4>

<p>Davis, James A., and Samuel Leinhardt. 1967.
“<a href="https://files.eric.ed.gov/fulltext/ED024086.pdf">The Structure of Positive Interpersonal Relations in Small Groups</a>.” 55.
</p>



<h4>On the tetrad census</h4>

<p>Ortmann, Mark, and Ulrik Brandes. 2017.
“Efficient Orbit-Aware Triad and Quad Census in Directed and Undirected Graphs.”
<em>Applied Network Science</em> 2(1):13.
<a href="https://doi.org/10.1007/s41109-017-0027-2">doi:10.1007/s41109-017-0027-2</a>.
</p>
<p>McMillan, Cassie, and Diane Felmlee. 2020.
&quot;Beyond Dyads and Triads: A Comparison of Tetrads in Twenty Social Networks&quot;.
<em>Social Psychology Quarterly</em> 83(4): 383-404.
<a href="https://doi.org/10.1177/0190272520944151">doi:10.1177/0190272520944151</a>
</p>



<h4>On the mixed census</h4>

<p>Hollway, James, Alessandro Lomi, Francesca Pallotti, and Christoph Stadtfeld. 2017.
“Multilevel Social Spaces: The Network Dynamics of Organizational Fields.”
<em>Network Science</em> 5(2): 187–212.
<a href="https://doi.org/10.1017/nws.2017.8">doi:10.1017/nws.2017.8</a>
</p>



<h3>See Also</h3>

<p>Other motifs: 
<code><a href="#topic+motif_brokerage">motif_brokerage</a></code>,
<code><a href="#topic+motif_diffusion">motif_diffusion</a></code>,
<code><a href="#topic+motif_node">motif_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net_by_dyad(manynet::ison_algebra)
net_by_triad(manynet::ison_adolescents)
net_by_tetrad(ison_southern_women)
marvel_friends &lt;- to_unsigned(ison_marvel_relationships, "positive")
(mixed_cen &lt;- net_by_mixed(marvel_friends, ison_marvel_teams))
</code></pre>

<hr>
<h2 id='motif_node'>Motifs at the nodal level</h2><span id='topic+motif_node'></span><span id='topic+node_by_tie'></span><span id='topic+node_by_dyad'></span><span id='topic+node_by_triad'></span><span id='topic+node_by_tetrad'></span><span id='topic+node_by_path'></span>

<h3>Description</h3>

<p>These functions include ways to take a census of the positions of nodes
in a network:
</p>

<ul>
<li> <p><code>node_by_tie()</code> returns a census of the ties in a network.
For directed networks, out-ties and in-ties are bound together.
For multiplex networks, the various types of ties are bound together.
</p>
</li>
<li> <p><code>node_by_triad()</code> returns a census of the triad configurations
nodes are embedded in.
</p>
</li>
<li> <p><code>node_by_tetrad()</code> returns a census of nodes' positions
in motifs of four nodes.
</p>
</li>
<li> <p><code>node_by_path()</code> returns the shortest path lengths
of each node to every other node in the network.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_by_tie(.data)

node_by_dyad(.data)

node_by_triad(.data)

node_by_tetrad(.data)

node_by_path(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="motif_node_+3A_.data">.data</code></td>
<td>
<p>An object of a manynet-consistent class:
</p>

<ul>
<li><p> matrix (adjacency or incidence) from <code>{base}</code> R
</p>
</li>
<li><p> edgelist, a data frame from <code>{base}</code> R or tibble from <code>{tibble}</code>
</p>
</li>
<li><p> igraph, from the <code>{igraph}</code> package
</p>
</li>
<li><p> network, from the <code>{network}</code> package
</p>
</li>
<li><p> tbl_graph, from the <code>{tidygraph}</code> package
</p>
</li></ul>
</td></tr>
</table>


<h3>Tetrad census</h3>

<p>The nodal tetrad census counts the number of four-node configurations
that each node is embedded in.
The function returns a matrix with a special naming convention:
</p>

<ul>
<li><p> E4 (aka co-K4): This is an empty set of four nodes; no ties
</p>
</li>
<li><p> I4 (aka co-diamond): This is a set of four nodes with just one tie
</p>
</li>
<li><p> H4 (aka co-C4): This set of four nodes includes two non-adjacent ties
</p>
</li>
<li><p> L4 (aka co-paw): This set of four nodes includes two adjacent ties
</p>
</li>
<li><p> D4 (aka co-claw): This set of four nodes includes three adjacent ties,
in the form of a triangle with one isolate
</p>
</li>
<li><p> U4 (aka P4, four-actor line): This set of four nodes includes three ties
arranged in a line
</p>
</li>
<li><p> Y4 (aka claw): This set of four nodes includes three ties all adjacent
to a single node
</p>
</li>
<li><p> P4 (aka paw, kite): This set of four nodes includes four ties arranged
as a triangle with an extra tie hanging off of one of the nodes
</p>
</li>
<li><p> C4 (aka bifan): This is a symmetric box or 4-cycle or set of shared choices
</p>
</li>
<li><p> Z4 (aka diamond): This resembles C4 but with an extra tie cutting across the box
</p>
</li>
<li><p> X4 (aka K4): This resembles C4 but with two extra ties cutting across the box;
a realisation of all possible ties
</p>
</li></ul>

<p>Graphs of these motifs can be shown using
<code>plot(node_by_tetrad(ison_southern_women))</code>.
</p>


<h3>References</h3>



<h4>On the dyad census</h4>

<p>Holland, Paul W., and Samuel Leinhardt. 1970.
&quot;A Method for Detecting Structure in Sociometric Data&quot;.
<em>American Journal of Sociology</em>, 76: 492-513.
<a href="https://doi.org/10.1016/B978-0-12-442450-0.50028-6">doi:10.1016/B978-0-12-442450-0.50028-6</a>
</p>



<h4>On the triad census</h4>

<p>Davis, James A., and Samuel Leinhardt. 1967.
“<a href="https://files.eric.ed.gov/fulltext/ED024086.pdf">The Structure of Positive Interpersonal Relations in Small Groups</a>.” 55.
</p>



<h4>On the tetrad census</h4>

<p>Ortmann, Mark, and Ulrik Brandes. 2017.
“Efficient Orbit-Aware Triad and Quad Census in Directed and Undirected Graphs.”
<em>Applied Network Science</em> 2(1):13.
<a href="https://doi.org/10.1007/s41109-017-0027-2">doi:10.1007/s41109-017-0027-2</a>.
</p>
<p>McMillan, Cassie, and Diane Felmlee. 2020.
&quot;Beyond Dyads and Triads: A Comparison of Tetrads in Twenty Social Networks&quot;.
<em>Social Psychology Quarterly</em> 83(4): 383-404.
<a href="https://doi.org/10.1177/0190272520944151">doi:10.1177/0190272520944151</a>
</p>



<h4>On paths</h4>

<p>Dijkstra, Edsger W. 1959.
&quot;A note on two problems in connexion with graphs&quot;.
<em>Numerische Mathematik</em> 1, 269-71.
<a href="https://doi.org/10.1007/BF01386390">doi:10.1007/BF01386390</a>.
</p>
<p>Opsahl, Tore, Filip Agneessens, and John Skvoretz. 2010.
&quot;Node centrality in weighted networks: Generalizing degree and shortest paths&quot;.
<em>Social Networks</em> 32(3): 245-51.
<a href="https://doi.org/10.1016/j.socnet.2010.03.006">doi:10.1016/j.socnet.2010.03.006</a>.
</p>



<h3>See Also</h3>

<p>Other motifs: 
<code><a href="#topic+motif_brokerage">motif_brokerage</a></code>,
<code><a href="#topic+motif_diffusion">motif_diffusion</a></code>,
<code><a href="#topic+motif_net">motif_net</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>task_eg &lt;- to_named(to_uniplex(ison_algebra, "tasks"))
(tie_cen &lt;- node_by_tie(task_eg))
node_by_dyad(ison_networkers)
(triad_cen &lt;- node_by_triad(task_eg))
node_by_tetrad(ison_southern_women)
node_by_path(ison_adolescents)
node_by_path(ison_southern_women)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+is_igraph'></span><span id='topic++25+3E+25'></span><span id='topic+with_graph'></span><span id='topic+is.tbl_graph'></span><span id='topic+.G'></span><span id='topic+.N'></span><span id='topic+.E'></span><span id='topic+ggplot'></span><span id='topic+ggtitle'></span><span id='topic+guides'></span><span id='topic+labs'></span><span id='topic+xlab'></span><span id='topic+ylab'></span><span id='topic+aes'></span><span id='topic+ggsave'></span><span id='topic+scale_size'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+aes">aes</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, <code><a href="ggplot2.html#topic+ggsave">ggsave</a></code>, <code><a href="ggplot2.html#topic+labs">ggtitle</a></code>, <code><a href="ggplot2.html#topic+guides">guides</a></code>, <code><a href="ggplot2.html#topic+labs">labs</a></code>, <code><a href="ggplot2.html#topic+scale_size">scale_size</a></code>, <code><a href="ggplot2.html#topic+labs">xlab</a></code>, <code><a href="ggplot2.html#topic+labs">ylab</a></code></p>
</dd>
<dt>igraph</dt><dd><p><code><a href="igraph.html#topic+is_igraph">is_igraph</a></code></p>
</dd>
<dt>tidygraph</dt><dd><p><code><a href="tidygraph.html#topic+context_accessors">.E</a></code>, <code><a href="tidygraph.html#topic+context_accessors">.G</a></code>, <code><a href="tidygraph.html#topic+context_accessors">.N</a></code>, <code><a href="tidygraph.html#topic+tbl_graph">is.tbl_graph</a></code>, <code><a href="tidygraph.html#topic+with_graph">with_graph</a></code></p>
</dd>
</dl>

<hr>
<h2 id='tutorials'>Open and extract code from tutorials</h2><span id='topic+tutorials'></span><span id='topic+run_tute'></span><span id='topic+extract_tute'></span>

<h3>Description</h3>

<p>These functions make it easy to use the tutorials
in the <code>{manynet}</code> and <code>{migraph}</code> packages:
</p>

<ul>
<li> <p><code>run_tute()</code> runs a <code>{learnr}</code> tutorial from
either the <code>{manynet}</code> or <code>{migraph}</code> packages,
wraps <code>learnr::run_tutorial()</code> with some convenience.
</p>
</li>
<li> <p><code>extract_tute()</code> extracts and opens just the solution code
from a <code>{manynet}</code> or <code>{migraph}</code> tutorial,
saving the .R script to the current working directory.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>run_tute(tute)

extract_tute(tute)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tutorials_+3A_tute">tute</code></td>
<td>
<p>String, name of the tutorial (e.g. &quot;tutorial2&quot;).</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
