<!DOCTYPE html><html lang="en"><head><title>Help for package mmtsne</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mmtsne}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hbeta'><p>Estimate perplexity and probability values</p></a></li>
<li><a href='#mmtsne'><p>Multiple maps t-SNE</p></a></li>
<li><a href='#mmtsneP'><p>Multiple maps t-SNE with symmetric probability matrix</p></a></li>
<li><a href='#p2sp'><p>Probability matrix to symmetric probability matrix</p></a></li>
<li><a href='#x2p'><p>Data to probability matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Maps t-SNE</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin J. Radford</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin J. Radford &lt;benjamin.radford@gmail.com&gt;</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of multiple maps t-distributed stochastic
    neighbor embedding (t-SNE). Multiple maps t-SNE is a method for
    projecting high-dimensional data into several low-dimensional maps such that
    non-metric space properties are better preserved than they would be by a single
    map. Multiple maps t-SNE with only one map is equivalent to standard t-SNE.
    When projecting onto more than one map, multiple maps t-SNE estimates a set
    of latent weights that allow each point to contribute to one or more maps
    depending on similarity relationships in the original data. This
    implementation is a port of the original 'Matlab' library by Laurens van der
    Maaten. 
    See Van der Maaten and Hinton (2012) &lt;<a href="https://doi.org/10.1007%2Fs10994-011-5273-4">doi:10.1007/s10994-011-5273-4</a>&gt;.
    This material is based upon work supported by the United States Air Force 
    and Defense Advanced Research Project Agency (DARPA) under Contract No. 
    FA8750-17-C-0020.
    Any opinions, findings and conclusions or recommendations expressed in this
    material are those of the author(s) and do not necessarily reflect the views 
    of the United States Air Force and Defense Advanced Research Projects Agency.
    Distribution Statement A: Approved for Public Release; Distribution Unlimited.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.freebsd.org/copyright/freebsd-license.html">FreeBSD</a> | file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-07-27 21:41:32 UTC; Ben</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-07-28 09:09:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='hbeta'>Estimate perplexity and probability values</h2><span id='topic+hbeta'></span>

<h3>Description</h3>

<p><code>hbeta</code> returns the perplexity and probability values for a row
of data <code>D</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbeta(D, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbeta_+3A_d">D</code></td>
<td>
<p>A distance vector.</p>
</td></tr>
<tr><td><code id="hbeta_+3A_beta">beta</code></td>
<td>
<p>A constant scalar.</p>
</td></tr>
</table>

<hr>
<h2 id='mmtsne'>Multiple maps t-SNE</h2><span id='topic+mmtsne'></span>

<h3>Description</h3>

<p><code>mmtsne</code> estimates a multiple maps t-distributed stochastic neighbor
embedding (multiple maps t-SNE) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmtsne(X, no_maps = 1, no_dims = 2, perplexity = 30, max_iter = 500,
  momentum = 0.5, final_momentum = 0.8, mom_switch_iter = 250,
  eps = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmtsne_+3A_x">X</code></td>
<td>
<p>A dataframe or matrix of <code class="reqn">N</code> rows and <code class="reqn">D</code> columns.</p>
</td></tr>
<tr><td><code id="mmtsne_+3A_no_maps">no_maps</code></td>
<td>
<p>The number of maps (positive whole number) to be estimated.</p>
</td></tr>
<tr><td><code id="mmtsne_+3A_no_dims">no_dims</code></td>
<td>
<p>The number of dimensions per map. Typical values are 2 or 3.</p>
</td></tr>
<tr><td><code id="mmtsne_+3A_perplexity">perplexity</code></td>
<td>
<p>The target perplexity for probability matrix
construction. Commonly recommended values range from 5 to 30.
Perplexity roughly corresponds to the expected number of neighbors
per data point.</p>
</td></tr>
<tr><td><code id="mmtsne_+3A_max_iter">max_iter</code></td>
<td>
<p>The number of iterations to run.</p>
</td></tr>
<tr><td><code id="mmtsne_+3A_momentum">momentum</code></td>
<td>
<p>Constant scaling factor for update momentum in gradient
descent algorithm.</p>
</td></tr>
<tr><td><code id="mmtsne_+3A_final_momentum">final_momentum</code></td>
<td>
<p>Constant scaling factor for update momentum in gradient
descent algorithm after the momentum switch point.</p>
</td></tr>
<tr><td><code id="mmtsne_+3A_mom_switch_iter">mom_switch_iter</code></td>
<td>
<p>The iteration at which momentum switches from
<code>momentum</code> to <code>final_momentum</code>.</p>
</td></tr>
<tr><td><code id="mmtsne_+3A_eps">eps</code></td>
<td>
<p>A small positive value near zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mmtsne</code> is a wrapper that performs multiple maps t-SNE on an input
dataset, <code>X</code>. The function will pre-process <code>X</code>, an <code class="reqn">N</code>
by <code class="reqn">D</code> matrix or dataframe, then call <code><a href="#topic+mmtsneP">mmtsneP</a></code>.
The pre-processing steps include calls to <code><a href="#topic+x2p">x2p</a></code> and
<code><a href="#topic+p2sp">p2sp</a></code> to convert <code>X</code> into an <code class="reqn">N</code> by <code class="reqn">N</code>
symmetrical joint probability matrix.
</p>
<p>The <code>mmtnseP</code> code is an almost direct port of the original multiple
maps t-SNE Matlab code by van der Maaten and Hinton (2012). <code>mmtsne</code>
estimates a multidimensional array of <code>N x no_dims x no_maps</code>. Each
map is an <code>N x no_dims</code> matrix of estimated t-SNE coordinates. When
<code>no_maps=1</code>, multiple maps t-SNE reduces to standard t-SNE.
</p>


<h3>Value</h3>

<p>A list that includes the following objects:
</p>

<dl>
<dt>Y</dt><dd><p>An <code>N x no_dims x no_maps</code> array of predicted coordinates.</p>
</dd>
<dt>weights</dt><dd><p>An <code>N x no_maps</code> matrix of unscaled weights. A high
weight on entry <code class="reqn">i, j</code> indicates a greater contribution of point
<code class="reqn">i</code> on map <code class="reqn">j</code>.</p>
</dd>
<dt>proportions</dt><dd><p>An <code>N x no_maps</code> matrix of scaled weights. A high
weight on entry <code class="reqn">i, j</code> indicates a greater contribution of point
<code class="reqn">i</code> on map <code class="reqn">j</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>L.J.P. van der Maaten and G.E. Hinton. &ldquo;Visualizing Non-Metric
Similarities in Multiple Maps.&rdquo; <em>Machine Learning</em> 87(1):33-55,
2012.
<a href="https://lvdmaaten.github.io/publications/papers/MachLearn_2012.pdf">PDF.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the iris dataset
data("iris")

# Estimate a mmtsne model with 2 maps, 2 dimensions each
model &lt;- mmtsne(iris[,1:4], no_maps=2, max_iter=100)

# Plot the results side-by-side for inspection
# Points scaled by map proportion weights plus constant factor
par(mfrow=c(1,2))
plot(model$Y[,,1], col=iris$Species, cex=model$proportions[,1] + .2)
plot(model$Y[,,2], col=iris$Species, cex=model$proportions[,2] + .2)
par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='mmtsneP'>Multiple maps t-SNE with symmetric probability matrix</h2><span id='topic+mmtsneP'></span>

<h3>Description</h3>

<p><code>mmtsneP</code> estimates a multiple maps t-distributed stochastic neighbor
embedding (multiple maps t-SNE) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmtsneP(P, no_maps, no_dims = 2, max_iter = 500, momentum = 0.5,
  final_momentum = 0.8, mom_switch_iter = 250, eps = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmtsneP_+3A_p">P</code></td>
<td>
<p>An <code class="reqn">N x N</code> symmetric joint probability distribution matrix.
These can be constructed from an <code class="reqn">N</code> by <code class="reqn">D</code> matrix with
<code><a href="#topic+x2p">x2p</a></code> and <code><a href="#topic+p2sp">p2sp</a></code>. Alternatively, the wrapper
function <code><a href="#topic+mmtsne">mmtsne</a></code> will wrap the matrix construction and
multiple maps t-SNE model estimation into a single step.</p>
</td></tr>
<tr><td><code id="mmtsneP_+3A_no_maps">no_maps</code></td>
<td>
<p>The number of maps (positive whole number) to be estimated.</p>
</td></tr>
<tr><td><code id="mmtsneP_+3A_no_dims">no_dims</code></td>
<td>
<p>The number of dimensions per map. Typical values are 2 or 3.</p>
</td></tr>
<tr><td><code id="mmtsneP_+3A_max_iter">max_iter</code></td>
<td>
<p>The number of iterations to run.</p>
</td></tr>
<tr><td><code id="mmtsneP_+3A_momentum">momentum</code></td>
<td>
<p>Constant scaling factor for update momentum in gradient
descent algorithm.</p>
</td></tr>
<tr><td><code id="mmtsneP_+3A_final_momentum">final_momentum</code></td>
<td>
<p>Constant scaling factor for update momentum in gradient
descent algorithm after the momentum switch point.</p>
</td></tr>
<tr><td><code id="mmtsneP_+3A_mom_switch_iter">mom_switch_iter</code></td>
<td>
<p>The iteration at which momentum switches from
<code>momentum</code> to <code>final_momentum</code>.</p>
</td></tr>
<tr><td><code id="mmtsneP_+3A_eps">eps</code></td>
<td>
<p>A small positive value near zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code is an almost direct port of the original multiple maps t-SNE Matlab
code by van der Maaten and Hinton (2012). <code>mmtsne</code> estimates a
multidimensional array of <code>N x no_dims x no_maps</code>. Each map is an
<code>N x no_dims</code> matrix of estimated t-SNE coordinates. When
<code>no_maps=1</code>, multiple maps t-SNE reduces to standard t-SNE.
</p>


<h3>Value</h3>

<p>A list that includes the following objects:
</p>

<dl>
<dt>Y</dt><dd><p>An <code>N x no_dims x no_maps</code> array of predicted coordinates.</p>
</dd>
<dt>weights</dt><dd><p>An <code>N x no_maps</code> matrix of unscaled weights. A high
weight on entry <code class="reqn">i, j</code> indicates a greater contribution of point
<code class="reqn">i</code> on map <code class="reqn">j</code>.</p>
</dd>
<dt>proportions</dt><dd><p>An <code>N x no_maps</code> matrix of scaled weights. A high
weight on entry <code class="reqn">i, j</code> indicates a greater contribution of point
<code class="reqn">i</code> on map <code class="reqn">j</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>L.J.P. van der Maaten and G.E. Hinton. &ldquo;Visualizing Non-Metric
Similarities in Multiple Maps.&rdquo; <em>Machine Learning</em> 87(1):33-55,
2012.
<a href="https://lvdmaaten.github.io/publications/papers/MachLearn_2012.pdf">PDF.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the iris dataset
data("iris")

# Produce a symmetric joint probability matrix
prob_matrix &lt;- p2sp(x2p(as.matrix(iris[,1:4])))

# Estimate a mmtsne model with 2 maps, 2 dimensions each
model &lt;- mmtsneP(prob_matrix, no_maps=2, max_iter=100)

# Plot the results side-by-side for inspection
# Points scaled by map proportion weights plus constant factor
par(mfrow=c(1,2))
plot(model$Y[,,1], col=iris$Species, cex=model$proportions[,1] + 0.2)
plot(model$Y[,,2], col=iris$Species, cex=model$proportions[,2] + 0.2)
par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='p2sp'>Probability matrix to symmetric probability matrix</h2><span id='topic+p2sp'></span>

<h3>Description</h3>

<p><code>p2sp</code> returns a symmetrical pair-wise joint probability
matrix given an input probability matrix <em>P</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2sp(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p2sp_+3A_p">P</code></td>
<td>
<p>An <code>N x N</code> probability matrix, like those produced by
<code><a href="#topic+x2p">x2p</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>N x N</code> symmetrical matrix of pair-wise probabilities.
</p>

<hr>
<h2 id='x2p'>Data to probability matrix</h2><span id='topic+x2p'></span>

<h3>Description</h3>

<p><code>x2p</code> returns a pair-wise conditional probability matrix given an input
matrix <em>X</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x2p(X, perplexity = 30, tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x2p_+3A_x">X</code></td>
<td>
<p>A data matrix with <code class="reqn">N</code> rows.</p>
</td></tr>
<tr><td><code id="x2p_+3A_perplexity">perplexity</code></td>
<td>
<p>The target perplexity. Values between 5 and 50 are
generally considered appropriate. Loosely translates into the
expected number of neighbors per point.</p>
</td></tr>
<tr><td><code id="x2p_+3A_tol">tol</code></td>
<td>
<p>A small positive value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an almost direct port of the original Python implementation
by van der Maaten and Hinton (2008). It uses a binary search to estimate
probability values for all pairwise-elements of <code>X</code>. The conditional
Gaussian distributions should all be of equal perplexity.
</p>


<h3>Value</h3>

<p>An <code>N x N</code> matrix of pair-wise probabilities.
</p>


<h3>References</h3>

<p>L.J.P. van der Maaten and G.E. Hinton. &ldquo;Visualizing
High-Dimensional Data Using t-SNE.&rdquo; <em>Journal of Machine Learning
Research</em> 9(Nov):2579-2605, 2008. <a href="https://lvdmaaten.github.io/publications/papers/JMLR_2008.pdf">PDF.</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
