<!DOCTYPE html><html lang="en"><head><title>Help for package OptimModel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OptimModel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#beta_model'><p>Beta hook-effect model, gradient, starting values, and back-calculation functions</p></a></li>
<li><a href='#exp_2o_decay'><p>Five-parameter second-order exponential decay, gradient, starting values, and back-calculation functions</p></a></li>
<li><a href='#exp_decay'><p>Three-parameter exponential decay, gradient, starting values, and back-calculation functions</p></a></li>
<li><a href='#exp_decay_pl'><p>Three-parameter exponential decay with initial plateau, gradient, starting values, and back-calculation functions</p></a></li>
<li><a href='#f2djac'><p>Compute derivative with respect to parameters</p></a></li>
<li><a href='#get_se_func'><p>Compute standard error for a function of model parameter estimates</p></a></li>
<li><a href='#getData'><p>Extract data object from an optim fit</p></a></li>
<li><a href='#gompertz_model'><p>Four-parameter Gompertz model, gradient, starting values, and back-calculation functions</p></a></li>
<li><a href='#hill_model'><p>Four-parameter Hill model, gradient, starting values, and back-calculation functions</p></a></li>
<li><a href='#hill_quad_model'><p>Five-parameter Hill model with quadratic component, gradient, starting values, and back-calculation functions</p></a></li>
<li><a href='#hill_switchpoint_model'><p>Five-parameter Hill model with switch point component, gradient, starting values, and back-calculation functions</p></a></li>
<li><a href='#hill5_model'><p>Five-parameter Hill model, gradient, starting values, and back-calculation functions</p></a></li>
<li><a href='#linear_model'><p>Linear model, gradient, and starting values</p></a></li>
<li><a href='#nlogLik_cauchy'><p>Negative log-likelihood function for Cauchy regression</p></a></li>
<li><a href='#optim_fit'><p>Fit Model with optim</p></a></li>
<li><a href='#optim_weights'><p>Weight functions for optim_fit</p></a></li>
<li><a href='#predict.optim_fit'><p>Predicted values for optim.fit objects</p></a></li>
<li><a href='#print.optim_fit'><p>Prints optim_fit objects</p></a></li>
<li><a href='#residuals.optim_fit'><p>Residuals for optim.fit objects</p></a></li>
<li><a href='#rout_fitter'><p>Fit Model with ROUT</p></a></li>
<li><a href='#rout_outlier_test'><p>ROUT Outlier Testing</p></a></li>
<li><a href='#test_fit'><p>Test Fit Parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-17</td>
</tr>
<tr>
<td>Title:</td>
<td>Perform Nonlinear Regression Using 'optim' as the Optimization
Engine</td>
</tr>
<tr>
<td>Author:</td>
<td>Steven Novick [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steven Novick &lt;Steven.Novick@takeda.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0),stats, utils, methods, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, rmarkdown, ggplot2</td>
</tr>
<tr>
<td>Description:</td>
<td>A wrapper for 'optim' for nonlinear regression problems; see Nocedal J and Write S (2006, ISBN: 978-0387-30303-1).  Performs ordinary least squares (OLS), iterative re-weighted least squares (IRWLS), and maximum likelihood (MLE). Also includes the robust outlier detection (ROUT) algorithm; see Motulsky, H and Brown, R (2006)&lt;<a href="https://doi.org/10.1186%2F1471-2105-7-123">doi:10.1186/1471-2105-7-123</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-08 23:02:39 UTC; mvculp</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-12 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='beta_model'>Beta hook-effect model, gradient, starting values, and back-calculation functions </h2><span id='topic+beta_model'></span>

<h3>Description</h3>

<p> Five-parameter hook-effect model for dose-response curve fitting  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
       beta_model(theta, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beta_model_+3A_theta">theta</code></td>
<td>
<p> Vector of five parameters:  <code class="reqn"> (e_{\min}, e_{\max}, \log(\delta_1), \log(\delta_2), \log(\delta_3)) </code>.  See details.</p>
</td></tr>
<tr><td><code id="beta_model_+3A_x">x</code></td>
<td>
<p> Vector of concentrations for the Beta model. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The five-parameter Beta model is given by:
</p>
<p style="text-align: center;"><code class="reqn">y = e_{\min} + e_{\max} \times \exp( log( \beta(\delta_1, \delta_2) ) + \delta_1 \times\log(x) + \delta_2*\log(\text{sc}-x) - 
                      (\delta_1+\delta_2)\times\log(\text{sc})   </code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">\beta(\delta_1, \delta_2) = (\delta_1+\delta_2)^(\delta_1+\delta_2) /(\delta_1^{\delta_1} \times \delta_2^{\delta_2})</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\text{sc} = \max(x) + \delta_3. </code>
</p>

<p>Note that the Beta model depends on the maximum x value. For a particular data set, this may be set by
</p>
<p>attr(theta), &quot;maxX&quot;) = max(x).
</p>


<h3>Value</h3>

<p>Let N = length(x).  Then
</p>

<ul>
<li><p> beta_model(theta, x) returns a numeric vector of length N.
</p>
</li>
<li><p> attr(beta_model, &quot;gradient&quot;)(theta, x) returns an N x 5 matrix.
</p>
</li>
<li><p> attr(beta_model, &quot;start&quot;)(x, y) returns a numeric vector of length 5 with starting values for
</p>
<p style="text-align: center;"><code class="reqn">(e_{\min}, e_{\max}, \log(\delta_1), \log(\delta_2), \log(\delta_3)).</code>
</p>
       
</li>
<li><p> attr(beta_model, &quot;backsolve&quot;)(theta, y) returns a numeric vector of length=length(y) with the first x such that beta_model(theta, x)=y.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = rep( c(0, 2^(-4:4)), each=4 )
theta = c(emin=0, emax=115, ldelta1=-1.5, ldelta2=9, ldelta3=11.5)
y = beta_model(theta, x)  + rnorm( length(x), mean=0, sd=1 )

beta_model(theta, x)
attr(beta_model, "gradient")(theta, x)
attr(beta_model, "start")(x, y)

attr(theta, "maxX") = max(x)
attr(beta_model, "backsolve")(theta, 50)
</code></pre>

<hr>
<h2 id='exp_2o_decay'>Five-parameter second-order exponential decay, gradient, starting values, and back-calculation functions</h2><span id='topic+exp_2o_decay'></span>

<h3>Description</h3>

<p> Five-parameter second-order exponential decay, gradient, starting values, and back-calculation functions.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
        exp_2o_decay(theta, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp_2o_decay_+3A_theta">theta</code></td>
<td>
<p> Vector of five parameters: (A, B, k1, k2, p).  See details.</p>
</td></tr>
<tr><td><code id="exp_2o_decay_+3A_x">x</code></td>
<td>
<p> Vector of concentrations. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The five-parameter exponential decay model is given by:
</p>
<p style="text-align: center;"><code class="reqn">y = A + B\times P\times \exp(-K1 \times x) + B\times (1 - P)\times \exp(-K2\times x)</code>
</p>
  
<p>The parameter vector is (A, B, k1, k2, p) where <code class="reqn">A = \min y</code> (min y value), <code class="reqn">A+B = \max y</code> (max y value), 
<code class="reqn">K1 = \exp(k1)</code> which is the shape parameter for first term, <code class="reqn">K2 = \exp(k2)</code> which is the shape parameter for second term, and <code class="reqn">P = 1/(1+\exp(p))</code> which is the  proportion of signal from the first term. 
</p>


<h3>Value</h3>

<p>Let N = length(x).  Then
</p>

<ul>
<li><p> exp_2o_decay(theta, x) returns a numeric vector of length N.
</p>
</li>
<li><p> attr(exp_2o_decay, &quot;gradient&quot;)(theta, x) returns an N x 5 matrix.
</p>
</li>
<li><p> attr(exp_2o_decay, &quot;start&quot;)(x, y) returns a numeric vector of length 5 with starting values for (A, B, k1, k2, p). 
</p>
</li>
<li><p> attr(exp_2o_decay, &quot;backsolve&quot;)(theta, y) returns a numeric vector of length = length(y).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = 2^(-4:4)
theta = c(25, 75, log(3), log(1.2), 1/(1+exp(.7)))
y = exp_2o_decay(theta, x) + rnorm( length(x), mean=0, sd=1 )
attr(exp_2o_decay, "gradient")(theta, x)
attr(exp_2o_decay, "start")(x, y)
attr(exp_2o_decay, "backsolve")(theta, 38)
</code></pre>

<hr>
<h2 id='exp_decay'>Three-parameter exponential decay, gradient, starting values, and back-calculation functions</h2><span id='topic+exp_decay'></span>

<h3>Description</h3>

<p> Three-parameter exponential decay, gradient, starting values, and back-calculation functions.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
        exp_decay(theta, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp_decay_+3A_theta">theta</code></td>
<td>
<p> Vector of three parameters:  (A, B, k).  See details.</p>
</td></tr>
<tr><td><code id="exp_decay_+3A_x">x</code></td>
<td>
<p> Vector of concentrations. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three-parameter exponential decay model is given by:
</p>
<p style="text-align: center;"><code class="reqn">y = A + B \times \exp(-Kx).</code>
</p>

<p>The parameter vector is (A, B, k) where
<code class="reqn">A =\min y</code> ( minimum y value), <code class="reqn">A + B = \max y</code> (maximum y value), and <code class="reqn">K = \exp(k)</code> whichi is the shape parameter.
</p>


<h3>Value</h3>

<p>Let N = length(x).  Then
</p>

<ul>
<li><p> exp_decay(theta, x) returns a numeric vector of length N.
</p>
</li>
<li><p> attr(exp_decay, &quot;gradient&quot;)(theta, x) returns an N x 3 matrix.
</p>
</li>
<li><p> attr(exp_decay, &quot;start&quot;)(x, y) returns a numeric vector of length 3 with starting values for
(A, B, k).
</p>
</li>
<li><p> attr(exp_decay, &quot;backsolve&quot;)(theta, y) returns a numeric vector of length=length(y).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = 2^(-4:4)
theta = c(25, 75, log(3))
y = exp_decay(theta, x)  + rnorm( length(x), mean=0, sd=1 )
attr(exp_decay, "gradient")(theta, x)
attr(exp_decay, "start")(x, y)
attr(exp_decay, "backsolve")(theta, 38)
</code></pre>

<hr>
<h2 id='exp_decay_pl'>Three-parameter exponential decay with initial plateau, gradient, starting values, and back-calculation functions</h2><span id='topic+exp_decay_pl'></span>

<h3>Description</h3>

<p> Three-parameter exponential decay with initial plateau, gradient, starting values, and back-calculation functions.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
        exp_decay_pl(theta, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp_decay_pl_+3A_theta">theta</code></td>
<td>
<p> Vector of four parameters:  (x0, yMax, yMin, k).  See details.</p>
</td></tr>
<tr><td><code id="exp_decay_pl_+3A_x">x</code></td>
<td>
<p> Vector of concentrations. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three-parameter exponential decay with initial plateau model is given by <code class="reqn">y = \text{yMax}</code> whenever <code class="reqn">x\le 0</code> otherwise 
</p>
<p style="text-align: center;"><code class="reqn">y = \text{yMin} + (\text{yMax}-\text{yMin})\times\exp(-K(x-X0))\text{ if }  x &gt; X0,</code>
</p>

<p>where <code class="reqn">X0 = \exp(x0)</code> is an inflection point between plateau and exponential decay curve,
<code class="reqn">\text{yMin} = \min y</code> (min response), <code class="reqn">\text{yMax} = \max y</code> (maximum response), and <code class="reqn">K = \exp(k)</code> is the shape parameter.
</p>


<h3>Value</h3>

<p>Let N = length(x).  Then
</p>

<ul>
<li><p> exp_decay_pl(theta, x) returns a numeric vector of length N.
</p>
</li>
<li><p> attr(exp_decay_pl, &quot;gradient&quot;)(theta, x) returns an N x 4 matrix.
</p>
</li>
<li><p> attr(exp_decay_pl, &quot;start&quot;)(x, y) returns a numeric vector of length 4 with starting values for
(x0, yMax, yMin, k).
</p>
</li>
<li><p> attr(exp_decay_pl, &quot;backsolve&quot;)(theta, y) returns a numeric vector of length=length(y).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
x = 2^(-4:4)
theta = c(0.4, 75, 10, log(3))
y = exp_decay_pl(theta, x)  + rnorm( length(x), mean=0, sd=1 )
attr(exp_decay_pl, "gradient")(theta, x)
attr(exp_decay_pl, "start")(x, y)
attr(exp_decay_pl, "backsolve")(theta, 38)
</code></pre>

<hr>
<h2 id='f2djac'>Compute derivative with respect to parameters</h2><span id='topic+f2djac'></span>

<h3>Description</h3>

<p> Compute derivative with respect to parameters. </p>


<h3>Usage</h3>

<pre><code class='language-R'>f2djac(Func, theta, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f2djac_+3A_func">Func</code></td>
<td>
<p> A function with theta as first argument that returns an n x 1 vector, 
where n represents the number of observations. </p>
</td></tr>
<tr><td><code id="f2djac_+3A_theta">theta</code></td>
<td>
<p> A p x 1 vector of parameters. </p>
</td></tr>
<tr><td><code id="f2djac_+3A_...">...</code></td>
<td>
<p> Other arguments needed for function.    </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an n x p matrix of derivatives with respect to theta.
Computes <code class="reqn"> \frac{\delta \, Func( \theta, ...)}{ \delta \, \theta}</code>, where <code class="reqn">\theta</code> = theta
</p>


<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    f = function(theta, x){ theta[1] + (theta[2]-theta[1])/(1 + (x/theta[3])^theta[4]) }
    theta0 = c(0, 100, .5, 2)
    x = 0:10
    f2djac(f, theta0, x=x)
</code></pre>

<hr>
<h2 id='get_se_func'>Compute standard error for a function of model parameter estimates</h2><span id='topic+get_se_func'></span>

<h3>Description</h3>

<p> Compute standard error for a function of model parameter estimates via the delta method. </p>


<h3>Usage</h3>

<pre><code class='language-R'>get_se_func(object, Func, ..., level=0.95)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_se_func_+3A_object">object</code></td>
<td>
<p> An optim_fit() object </p>
</td></tr>
<tr><td><code id="get_se_func_+3A_func">Func</code></td>
<td>
<p> Function that returns a numeric value. See details. </p>
</td></tr>
<tr><td><code id="get_se_func_+3A_...">...</code></td>
<td>
<p> Other arguments needed for Func.    </p>
</td></tr>
<tr><td><code id="get_se_func_+3A_level">level</code></td>
<td>
<p> Confidence level for confidence interval </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Func is of the form function(theta, ...).  For example,
</p>
<p>Func = function(theta, x){ exp(theta[1])*log(x)/theta[2] }
</p>


<h3>Value</h3>

<p>Returns a data.frame with a single row for the estimated Func call (Est),
its standard error (SE), and a confidence interval (lower, upper).
</p>


<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = rep( c(0, 2^(-4:4)), each =4 )
theta = c(0, 100, log(.5), 2)
y = hill_model(theta, x) + rnorm( length(x), sd=2 )
fit = optim_fit(theta, hill_model, x=x, y=y)
  
## Get SE for IC20 and IC40
ic.z = function(theta, z){  attr(hill_model, "backsolve")(theta, z)  }
get_se_func(object=fit, Func=ic.z, z=20)
get_se_func(object=fit, Func=ic.z, z=40)
  
</code></pre>

<hr>
<h2 id='getData'>Extract data object from an optim fit</h2><span id='topic+getData'></span><span id='topic+getData.optim.fit'></span>

<h3>Description</h3>

<p> Extract data object from an <code>optim_fit</code> object. </p>


<h3>Usage</h3>

<pre><code class='language-R'>  getData(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getData_+3A_object">object</code></td>
<td>
<p> object of class <code>optim_fit</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with elements x and y.
</p>


<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = rep( c(0, 2^(-4:4)), each =4 )
theta = c(0, 100, log(.5), 2)
y = hill_model(theta, x) + rnorm( length(x), sd=2 )
fit = optim_fit(c(0, 100, .5, 1), f.model=hill_model, x=x, y=y)
d=getData(fit)
</code></pre>

<hr>
<h2 id='gompertz_model'>Four-parameter Gompertz model, gradient, starting values, and back-calculation functions</h2><span id='topic+gompertz_model'></span>

<h3>Description</h3>

<p> Four-parameter Gompertz model, gradient, starting values, and back-calculation functions.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
        gompertz_model(theta, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gompertz_model_+3A_theta">theta</code></td>
<td>
<p> Vector of four parameters:  (A, B, m, offset).  See details.</p>
</td></tr>
<tr><td><code id="gompertz_model_+3A_x">x</code></td>
<td>
<p> Vector of concentrations for the Gompertz model. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The four parameter Gompertz model is given by:
</p>
<p style="text-align: center;"><code class="reqn">y = A + (B-A)\times\exp( -\exp( m(x-\text{offset}) ) )\text{, where}</code>
</p>

<p><code class="reqn">A = \min y</code> (minimum y value), <code class="reqn">A+(B-A)\exp(-\exp( -m*\text{offset} ))</code> is the maximum y value, m is the shape parameter, and offset shifts the curve, relative to the concentration x.
</p>


<h3>Value</h3>

<p>Let N = length(x).  Then
</p>

<ul>
<li><p> gompertz_model(theta, x) returns a numeric vector of length N.
</p>
</li>
<li><p> gompertz_model(hill_model, &quot;gradient&quot;)(theta, x) returns an N x 4 matrix.
</p>
</li>
<li><p> attr(gompertz_model, &quot;start&quot;)(x, y) returns a numeric vector of length 4 with starting values for
(A, B, m, offset).
</p>
</li>
<li><p> attr(gompertz_model, &quot;backsolve&quot;)(theta, y) returns a numeric vector of length=length(y).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
x = rep( c(0, 2^(-4:4)), each=4 )
theta = c(0, 100, log(.5), 2)
y = gompertz_model(theta, x)  + rnorm( length(x), mean=0, sd=1 )
attr(gompertz_model, "gradient")(theta, x)
attr(gompertz_model, "start")(x, y)
attr(gompertz_model, "backsolve")(theta, 50)
</code></pre>

<hr>
<h2 id='hill_model'>Four-parameter Hill model, gradient, starting values, and back-calculation functions</h2><span id='topic+hill_model'></span>

<h3>Description</h3>

<p> Four-parameter Hill model, gradient, starting values, and back-calculation functions.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
        hill_model(theta, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hill_model_+3A_theta">theta</code></td>
<td>
<p> Vector of four parameters:  <code class="reqn">(e_{\min}, e_{\max}, \text{lec50}, m)</code>.  See details.</p>
</td></tr>
<tr><td><code id="hill_model_+3A_x">x</code></td>
<td>
<p> Vector of concentrations for the Hill model. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The four parameter Hill model is given by:
</p>
<p style="text-align: center;"><code class="reqn">y = e_{\min} + \frac{(e_{\max}-e_{\min})}{( 1 + \exp( m\log(x) - m*\text{lec50} ) )}\text{, where }</code>
</p>

<p><code class="reqn">e_{\min} = \min y</code> (minimum y value), <code class="reqn">e_{\max} = \max y</code> (maximum y value), <code class="reqn">\text{lec50} = \log( \text{ec5} )</code>, and m is the shape parameter.
Note:  ec50 is defined such that hill.model(theta, ec50) = .5*( emin+ emax ).  
</p>


<h3>Value</h3>

<p>Let N = length(x).  Then
</p>

<ul>
<li><p> hill_model(theta, x) returns a numeric vector of length N.
</p>
</li>
<li><p> attr(hill_model, &quot;gradient&quot;)(theta, x) returns an N x 4 matrix.
</p>
</li>
<li><p> attr(hill_model, &quot;start&quot;)(x, y) returns a numeric vector of length 4 with starting values for
<code class="reqn">(e_{\min}, e_{\max}, \text{lec50}, m)</code>.
</p>
</li>
<li><p> attr(hill_model, &quot;backsolve&quot;)(theta, y) returns a numeric vector of length=length(y).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = rep( c(0, 2^(-4:4)), each=4 )
theta = c(0, 100, log(.5), 2)
y = hill_model(theta, x)  + rnorm( length(x), mean=0, sd=1 )
attr(hill_model, "gradient")(theta, x)
attr(hill_model, "start")(x, y)
attr(hill_model, "backsolve")(theta, 50)
</code></pre>

<hr>
<h2 id='hill_quad_model'>Five-parameter Hill model with quadratic component, gradient, starting values, and back-calculation functions</h2><span id='topic+hill_quad_model'></span>

<h3>Description</h3>

<p> Five-parameter Hill model with quadratic component, gradient, starting values, and back-calculation functions.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
        hill_quad_model(theta, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hill_quad_model_+3A_theta">theta</code></td>
<td>
<p> Vector of five parameters:  (A, B, a, b, c).  See details. </p>
</td></tr>
<tr><td><code id="hill_quad_model_+3A_x">x</code></td>
<td>
<p> Vector of concentrations for the five-parameter Hill model with quadratic component. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The five parameter Hill model with quadratic component is given by:
</p>
<p style="text-align: center;"><code class="reqn">y = A + \frac{B-A}{( 1 + \exp( -(a + bz + cz^2) )  )}\text{, where }z = \log(x)</code>
</p>

<p><code class="reqn">A =\min y</code> ( minimum y value), <code class="reqn">B = \max y</code> (maximum y value), (a, b, c) are quadratic parameters for <code class="reqn">\log(x)</code>.
</p>
<p>Notes:
</p>
<p>1.  If <code class="reqn">c = 0</code>, this model is equivalent to the four-parameter Hill model (hill.model).
</p>
<p>2.  The ic50 is defined such that <code class="reqn">a + bz + cz^2 = 0</code>.  If the roots of the quadratic equation are real, then the ic50
is given by <code class="reqn">\tfrac{-b \pm\sqrt{b^2 - 4ac }}{2a}</code>.
</p>


<h3>Value</h3>

<p>Let N = length(x).  Then
</p>

<ul>
<li><p> hill_quad_model(theta, x) returns a numeric vector of length N.
</p>
</li>
<li><p> attr(hill_quad_model, &quot;gradient&quot;)(theta, x) returns an N x 5 matrix.
</p>
</li>
<li><p> attr(hill_quad_model, &quot;start&quot;)(x, y) returns a numeric vector of length 5 with starting values for
(A, B, a, b, c).
</p>
<p>If the quadratic roots are real-valued, attr(hill_quad_model, &quot;backsolve&quot;)(theta, y) returns a numeric vector of length=2.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = rep( c(0, 2^(-4:4)), each=3 )      ## Dose
theta = c(0, 100, 2, 1, -0.5)          ## Model parameters
y = hill_quad_model(theta, x) + rnorm( length(x), mean=0, sd=5 )

## Generate data
hill_quad_model(theta, x)
attr(hill_quad_model, "gradient")(theta, x)
attr(hill_quad_model, "start")(x, y)
attr(hill_quad_model, "backsolve")(theta, 50)
</code></pre>

<hr>
<h2 id='hill_switchpoint_model'>Five-parameter Hill model with switch point component, gradient, starting values, and back-calculation functions</h2><span id='topic+hill_switchpoint_model'></span>

<h3>Description</h3>

<p> Five-parameter Hill model with switch point component, gradient, starting values, and back-calculation functions.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
        hill_switchpoint_model(theta, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hill_switchpoint_model_+3A_theta">theta</code></td>
<td>
<p> Vector of five parameters:  <code class="reqn">(e_{\min}, e_{\max}, \text{lec50}, m, \text{lsp})</code>.  See details. </p>
</td></tr>
<tr><td><code id="hill_switchpoint_model_+3A_x">x</code></td>
<td>
<p> Vector of concentrations for the five-parameter Hill model with switch point component. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The five parameter Hill model with switch point component is given by:
</p>
<p style="text-align: center;"><code class="reqn">y = e_{\min} + \frac{e_{\max}-e_{\min}}{1 + \exp( m\times f(\exp(\text{lsp}), x)\times(\log(x) - \text{log.ic50}) )}\text{, where}</code>
</p>

<p><code class="reqn">e_{\min} = \min y</code> (minimum y value), <code class="reqn">e_{\max} = \max y</code> (maximum y value), <code class="reqn">\text{log.ic50} = \log( \text{ic50} )</code>, m is the shape parameter, and <code class="reqn">f(s, x)</code> is the switch point function.
</p>
<p>The function <code class="reqn">f(s, x) = (s-x)/(s+x) = 2/(1+x/s) - 1</code>.  This function is constrained to be between -1 and +1 with <code class="reqn">s &gt; 0.</code>
</p>
<p>Notes:
</p>
<p>1.  At <code class="reqn">x = 0</code>, <code class="reqn">f(s, x) = 1</code>, which reduces to hill_model(theta[1:4], 0).
</p>
<p>2.  The <code>hill_switchpoint_model</code>() is more flexible compared to <code>hill_quad_model</code>().
</p>
<p>3.  When the data does not contain a switchpoint, then lsp should be a large value so that <code class="reqn">f(\exp(\text{lsp}), x)</code> will be near 1 for all x.
</p>


<h3>Value</h3>

<p>Let N = length(x).  Then
</p>

<ul>
<li><p> hill_switchpoint_model(theta, x) returns a numeric vector of length N.
</p>
</li>
<li><p> attr(hill_switchpoint_model, &quot;gradient&quot;)(theta, x) returns an N x 5 matrix.
</p>
</li>
<li><p> attr(hill_switchpoint_model, &quot;start&quot;)(x, y) returns a numeric vector of length 5 with starting values for
<code class="reqn">(e_{\min}, e_{\max}, \text{lec50}, m, \text{lsp})</code>.
</p>
<p>Because <code>hill_switchpoint_model</code>() can be fitted to biphasic data with a hook-effect, attr(hill_switchpoint_model, &quot;backsolve&quot;)(theta, y0) returns the first x that satisfies
y0=hill_switchpoint_model(theta, x)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = rep( c(0, 2^(-4:4)), each=3 )      ## Dose
## Create model with no switchpoint term
theta = c(0, 100, log(.5), 2)
y = hill_model(theta, x) + rnorm( length(x), mean=0, sd=5 )

## fit0 and fit return roughly the same r-squared and sigma values.
## Note that BIC(fit0) &lt; BIC(fit), as it should be.
fit0 = optim_fit(NULL, hill_model, x=x, y=y)
fit = optim_fit(c(coef(fit0), lsp=0), hill_switchpoint_model, x=x, y=y)
fit = optim_fit(NULL, hill_switchpoint_model, x=x, y=y) 

## Generate data from hill.quad.model() with a biphasic (hook-effect) profile
set.seed(123L)
theta = c(0, 100, 2, 1, -0.5)          ## Model parameters
y = hill_quad_model(theta, x) + rnorm( length(x), mean=0, sd=5 )

## fit.qm and fit.sp return nearly identical fits
fit.qm = optim_fit(theta, hill_quad_model, x=x, y=y)  
fit.sp = optim_fit(NULL, hill_switchpoint_model, x=x, y=y, ntry=50)  

plot(log(x+0.01), y)
lines(log(x+0.01), fitted(fit.qm))
lines(log(x+0.01), fitted(fit.sp), col="red")

## Generate data from hill.switchback.model()
set.seed(123)
theta = c(0, 100, log(0.25), -3, -2)
y = hill_switchpoint_model(theta, x) + rnorm( length(x), mean=0, sd=5 )
plot( log(x+0.01), y )

## Note that this model cannot be fitted by hill.quad.model()
fit = optim_fit(NULL, hill_switchpoint_model, x=x, y=y, ntry=50, 
       start.method="fixed", until.converge=FALSE)
pred = predict(fit, x=exp(seq(log(0.01), log(16), length=50)), interval='confidence')

plot(log(x+0.01), y, main="Fitted curve with 95% confidence bands")
lines(log(pred[,'x']+0.01), pred[,'y.hat'], col='black')
lines(log(pred[,'x']+0.01), pred[,'lower'], col='red', lty=2)
lines(log(pred[,'x']+0.01), pred[,'upper'], col='red', lty=2)


## Other functions
hill_switchpoint_model(theta, x)
attr(hill_switchpoint_model, "gradient")(theta, x)
attr(hill_switchpoint_model, "start")(x, y)
attr(hill_switchpoint_model, "backsolve")(theta, 50)

</code></pre>

<hr>
<h2 id='hill5_model'>Five-parameter Hill model, gradient, starting values, and back-calculation functions</h2><span id='topic+hill5_model'></span>

<h3>Description</h3>

<p> Five-parameter Hill model, gradient, starting values, and back-calculation functions.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
        hill5_model(theta, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hill5_model_+3A_theta">theta</code></td>
<td>
<p> Vector of five parameters:  <code class="reqn">(e_{\min}, e_{\max}, \text{log.ic50}, m, \text{log.sym})</code>.  See details. </p>
</td></tr>
<tr><td><code id="hill5_model_+3A_x">x</code></td>
<td>
<p> Vector of concentrations for the five-parameter Hill model. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The five parameter Hill model is given by:
</p>
<p style="text-align: center;"><code class="reqn">y = e_{\min} + \frac{e_{\max}-e+{\min}}{ 1 + \exp( m\log(x) - m\text{ log.ic50}) )^{\exp(\text{log.sym})}}</code>
</p>

<p><code class="reqn">e_{\min} = \min y</code> (minimum y value), <code class="reqn">e_{\max} = \max y</code> (maximum y value), <code class="reqn">\text{log.ic50} = \log( \text{ic50} )</code>, m  is the shape parameter,  and <code class="reqn">\text{log.sym} = \log( \text{symmetry parameter})</code>.
</p>
<p>Note:  ic50 is defined such that hill5_model(theta, ic50) <code class="reqn">= e_{\min}+(e_{\max}-e_{\min})/2^{\exp(\text{log.sym})}</code>
</p>


<h3>Value</h3>

<p>Let N = length(x).  Then
</p>

<ul>
<li><p> hill5_model(theta, x) returns a numeric vector of length N.
</p>
</li>
<li><p> attr(hill5_model, &quot;gradient&quot;)(theta, x) returns an N x 5 matrix.
</p>
</li>
<li><p> attr(hill5_model, &quot;start&quot;)(x, y) returns a numeric vector of length 5 with starting values for
<code class="reqn">(e_{\min}, e_{\max}, \text{log.ic50}, m, \text{log.sym})</code>.
</p>
</li>
<li><p> attr(hill5_model, &quot;backsolve&quot;)(theta, y) returns a numeric vector of length=length(y).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = rep( c(0, 2^(-4:4)), each=4 )
theta = c(0, 100, log(.5), 2, log(10))
y = hill5_model(theta, x)  + rnorm( length(x), mean=0, sd=1 )
attr(hill5_model, "gradient")(theta, x)
attr(hill5_model, "start")(x, y)
attr(hill5_model, "backsolve")(theta, 50)
</code></pre>

<hr>
<h2 id='linear_model'>Linear model, gradient, and starting values</h2><span id='topic+linear_model'></span>

<h3>Description</h3>

<p> Linear model, gradient, and starting values.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
        linear_model(theta, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_model_+3A_theta">theta</code></td>
<td>
<p> Vector of model parameters intercept and slope.  See details.</p>
</td></tr>
<tr><td><code id="linear_model_+3A_x">x</code></td>
<td>
<p> Matrix, possibly from <code>model.matrix</code>(). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear model is given by:
</p>
<p style="text-align: center;"><code class="reqn">y = x * \theta \text{, where}</code>
</p>

<p>x is a <code>matrix</code>, possibly generated from <code>model.matrix</code>()
<code class="reqn">\theta</code> is a vector of linear parameters
</p>


<h3>Value</h3>

<p>Let N = nrow(x).  Then
</p>

<ul>
<li><p> linear_model(theta, x) returns a numeric vector of length N.
</p>
</li>
<li><p> attr(linear_model, &quot;gradient&quot;)(theta, x) returns x.
</p>
</li>
<li><p> attr(linear_model, &quot;start&quot;)(x, y) returns solve(t(x) * x) * t(x) * y
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
d = data.frame( Group=factor(rep(LETTERS[1:3], each=5)), age=rnorm(15, mean=20, sd=3) )
d$y = c(80, 100, 120)[unclass(d$Group)] - 3*d$age + rnorm(nrow(d), mean=0, sd=5)

X = model.matrix(~Group+age, data=d)  ## This is the "x" in linear.model()
theta = c(80, 20, 40, -3)   ## Intercept, effect for B, effect for C, slope for age
linear_model(theta, x=X)
attr(linear_model, "gradient")(theta, x=X)
attr(linear_model, "start")(x=X, y=d$y)

</code></pre>

<hr>
<h2 id='nlogLik_cauchy'>Negative log-likelihood function for Cauchy regression</h2><span id='topic+nlogLik_cauchy'></span>

<h3>Description</h3>

<p> The negative log-likelihood function for Cauchy regression, for use with <code>rout_fitter</code>. Usually not called by the end user.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
       nlogLik_cauchy(theta, x, y, f.model, lbs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlogLik_cauchy_+3A_theta">theta</code></td>
<td>
<p>Parameters for f.model and an extra parameter for the scale parameter; e.g., f.model=hill.model</p>
</td></tr>
<tr><td><code id="nlogLik_cauchy_+3A_x">x</code></td>
<td>
<p> Explanatory variable(s).  Can be vector, matrix, or data.frame </p>
</td></tr>
<tr><td><code id="nlogLik_cauchy_+3A_y">y</code></td>
<td>
<p> Response variable. </p>
</td></tr>
<tr><td><code id="nlogLik_cauchy_+3A_f.model">f.model</code></td>
<td>
<p>Name of mean model function. </p>
</td></tr>
<tr><td><code id="nlogLik_cauchy_+3A_lbs">lbs</code></td>
<td>
<p>Logical. lbs = log both sides. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides the negative log-likelihood for Cauchy regression
</p>
<p>Let mu = f.model(theta[1:(p-1)], x) and sigma = exp(theta[p]), where p = number of parameters in theta.
</p>
<p>The Cauchy likelihood is
</p>
<p style="text-align: center;"><code class="reqn"> L = \prod \frac{1}{\pi \sigma} ( 1 + ( \frac{y_i - \mu_i}{\sigma} )^2 )^{-1} </code>
</p>
<p>.
</p>
<p>The function returns <code class="reqn">\log(L)</code>.  
</p>
<p>If <code>lbs == TRUE</code>, then <code class="reqn">\mu</code> is replaced with <code class="reqn">\log(mu)</code>.
</p>


<h3>Value</h3>

<p>Returns a single numerical value.
</p>


<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = rep( c(0, 2^(-4:4)), each=4 )
theta = c(emin=0, emax=100, lec50=log(.5), m=2)
y = hill_model(theta, x)  + rnorm( length(x), mean=0, sd=2 )

theta1 = c(theta, lsigma=log(2))
nlogLik_cauchy(theta1, x=x, y=y, f.model=hill_model, lbs=FALSE)

  ## Cauchy regression via maximum likelihood
optim( theta1, nlogLik_cauchy, x=x, y=y, f.model=hill_model, lbs=FALSE )

</code></pre>

<hr>
<h2 id='optim_fit'>Fit Model with optim</h2><span id='topic+optim_fit'></span><span id='topic+robust_fit'></span>

<h3>Description</h3>

 
<p>Fit nonlinear model using the <code>optim</code> function in the <span class="pkg">stats</span> library.  This defaults to Ordinary Least Squares (OLS) The other options are Iterative Reweighted Least Squares (IRWLS), and Maximum Likelihood Estimator (MLE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
optim_fit( theta0, f.model, gr.model=NULL, x, y, wts,
            fit.method=c("ols", "irwls", "mle"),
            var.method=c("hessian", "normal", "robust"),
            phi0=NULL, phi.fixed=TRUE, conf.level = 0.95, tol = 1e-3, 
            n.start=1000, ntry=1, start.method=c("fixed", "random"), 
            until.converge=TRUE, check.pd.tol = 1e-8, ...)


robust_fit(theta0, f.model, gr.model=NULL, x, y, wts=c("huber", "tukey"), 
    var.method=c("hessian", "normal", "robust"), conf.level=.95, tol=1e-3, ...)             
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optim_fit_+3A_theta0">theta0</code></td>
<td>
<p> starting values.  Alternatively, if given as NULL, theta0 can be computed within <code>optim.fit</code>()
if a starting values function is supplied as attr(f.model, &quot;start&quot;), as a function of x and y.</p>
</td></tr>
<tr><td><code id="optim_fit_+3A_f.model">f.model</code></td>
<td>
<p> Name of mean model function. </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_gr.model">gr.model</code></td>
<td>
<p> If specified, name of the partial derivative of f.model with respect to its parameter argument.  If
not specified, <code>f2djac</code> will approximate the derivative.  Alternatively, the gradient of f.model can
be specified as attr(f.model, &quot;gradient&quot;) </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_x">x</code></td>
<td>
<p> Explanatory variable(s).  Can be <code>vector</code>, <code>matrix</code>, or <code>data.frame</code> </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_y">y</code></td>
<td>
<p> Response variable. </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_fit.method">fit.method</code></td>
<td>
<p> &quot;ols&quot; for ordinary least squares, &quot;irwls&quot; for iterative re-weighted least squares, &quot;mle&quot; for
maximum likelihood. </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_wts">wts</code></td>
<td>
<p> For <code>optim.fit</code>(), can be a numeric vector or a function.  Functions supplied in the library are <code>weights_varIdent</code>, <code>weights_tukey_bw</code>, <code>weights_huber</code>, <code>weights_varExp</code>, <code>weights_varPower</code>, and <code>weights_varConstPower</code>.  For <code>robust_fit</code>(), choices are a character string of &quot;huber&quot; for <code>weights_huber</code> and &quot;tukey&quot; for <code>weights_tukey_bw</code> </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_var.method">var.method</code></td>
<td>
<p> Method to compute variance-covariance matrix of estimated model parameters.  Choices are &quot;hessian&quot; to
use the hessian inverse, &quot;normal&quot; to use the so-called 'folk-lore' theorem estimator, and &quot;robust&quot; to use a
sandwich-variance estimator.  When <code>fit.method = "mle"</code>, <code>var.method = "hessian"</code> and cannot be overridden. </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_phi0">phi0</code></td>
<td>
<p> Not meaningful for <code>fit.method = "ols"</code>.  Starting value(s) for variance parameters (for weights). </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_phi.fixed">phi.fixed</code></td>
<td>
<p> Not meaningful for <code>fit.method = "ols"</code>.  If set to <code>TRUE</code>, the variance parameter(s) remain fixed at the given starting value, phi0.  Otherwise, the variance parameter(s) are estimated. </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_conf.level">conf.level</code></td>
<td>
<p> Confidence level of estimated parameters. </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_tol">tol</code></td>
<td>
<p> Tolerance for <code>optim</code> algorithm. </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_n.start">n.start</code></td>
<td>
<p> Number of starting values to generate (see details). </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_ntry">ntry</code></td>
<td>
<p> Maximum number of calls to <code>optim.fit</code>(). </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_start.method">start.method</code></td>
<td>
<p> Parameter </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_until.converge">until.converge</code></td>
<td>
<p> Logical (<code>TRUE</code>/<code>FALSE</code>) indicating when algorithm should stop. </p>
</td></tr>
<tr><td><code id="optim_fit_+3A_check.pd.tol">check.pd.tol</code></td>
<td>
<p>absolute tolarence for determing whether a matrix is positive definite. Refer to <code>test_fit</code>.</p>
</td></tr>
<tr><td><code id="optim_fit_+3A_...">...</code></td>
<td>
<p> Other arguments to passed to <code>optim</code>.  See ?<code>optim</code>.  For example, lower=, upper=, method=</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>optim_fit</code>() is a wrapper for <code>stats::optim</code>(), specifically for non-linear regression.
The Default algorithm is ordinary least squares (ols) using method=&quot;BFGS&quot; or &quot;L-BFGS-B&quot;, if lower= and upper=
are specified.  These can easily be overridden.
</p>
<p>The assumed model is: 
</p>
<p style="text-align: center;"><code class="reqn">y = \text{f.model}(\theta, x) + g(\theta, \phi, x)\sigma\epsilon\text{, where }\epsilon\sim N(0, 1).</code>
</p>

<p>Usually the function <code class="reqn">g(\cdot) = 1</code>.
</p>
<p>With the exception of weights.tukey.bw and weights.huber, the weights functions are equivalent 
to <code class="reqn">g(\theta, \phi, x)</code>.
</p>
<p>Note that <code>robust_fit</code>() is a convenience function to simplify the model call with <code>fit.method = "irwls"</code>,
<code>phi0 = NULL</code>, and <code>phi.fixed = TRUE</code>.
</p>
<p><b>Algorithms</b>:
</p>
<p>1.  OLS.   Minimize  sum(  (y - f.model(theta, x))^2 )
</p>
<p>2.  IRWLS. Minimize sum( g(theta, phi, x)*(y - f.model(theta, x))^2 ), where g(theta, phi, x) act as weights.  See section
on Variance functions below for more details on <code class="reqn">g(\cdot)</code>.
</p>
<p>3.  MLE.   Minimize the -log(Likelihood).  See section on Variance functions below for more details on <code class="reqn">g(\cdot)</code>.
</p>
<p><b>Variance functions</b>:
</p>
<p>Weights are given by some variance function.  Some common variance functions are supplied.
</p>
<p>See <code>weights_varIdent</code>, <code>weights_varExp</code>, <code>weights_varPower</code>, <code>weights_varConstPower</code>, <code>weights_tukey_bw</code>, <code>weights_huber</code>.
</p>
<p>User-specified variance functions can be provided for weighted regression.
</p>


<h3>Value</h3>

<p>The returned object is a list with the following components and attributes:
</p>
<p>coefficients = estimated model coefficients
</p>
<p>value, counts, convergence = returns from optim()
</p>
<p>message = character, indicating problem if any.  otherwise=NULL
</p>
<p>hessian = hessian matrix of the objective function (e.g., sum of squares)
</p>
<p>fit.method = chosen fit.method (e.g., &quot;ols&quot;)
</p>
<p>var.method = chosen var.method (e.g., &quot;hessian&quot;)
</p>
<p>call = optim.fit() function call
</p>
<p>fitted, residuals = model mean and model residuals
</p>
<p>r.squared, bic = model statistics
</p>
<p>df = error degrees of freedom = N - p, where N = # of observations and p = # of parameters
</p>
<p>dims = list containing the values of N and p
</p>
<p>sigma = estimated standard deviation parameter
</p>
<p>varBeta = estimated variance-covariance matrix for the coefficients
</p>
<p>beta = data.frame summary of the fit
</p>
<p>attr(object, &quot;weights&quot;) = weights
</p>
<p>attr(object, &quot;w.func&quot;) = weights model for the variance
</p>
<p>attr(object, &quot;var.param&quot;) = variance parameter values
</p>
<p>attr(object, &quot;converge.pls&quot;) = logical indicating if IRWLS algorithm converged.
</p>


<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, 
<code><a href="#topic+rout_outlier_test">rout_outlier_test</a></code>,
<code><a href="#topic+beta_model">beta_model</a></code>,
<code><a href="#topic+exp_2o_decay">exp_2o_decay</a></code>,
<code><a href="#topic+exp_decay_pl">exp_decay_pl</a></code>,
<code><a href="#topic+gompertz_model">gompertz_model</a></code>, 
<code><a href="#topic+hill_model">hill_model</a></code>, 
<code><a href="#topic+hill5_model">hill5_model</a></code>, 
<code><a href="#topic+hill_quad_model">hill_quad_model</a></code>, 
<code><a href="#topic+hill_switchpoint_model">hill_switchpoint_model</a></code>, 
<code><a href="#topic+linear_model">linear_model</a></code>,
<code><a href="#topic+weights_huber">weights_huber</a></code>,
<code><a href="#topic+weights_tukey_bw">weights_tukey_bw</a></code>,
<code><a href="#topic+weights_varConstPower">weights_varConstPower</a></code>,
<code><a href="#topic+weights_varExp">weights_varExp</a></code>,
<code><a href="#topic+weights_varIdent">weights_varIdent</a></code>,
<code><a href="#topic+weights_varPower">weights_varPower</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = rep( c(0, 2^(-4:4)), each=4 )
theta = c(0, 100, log(.5), 2)
y1 = hill_model(theta, x) + rnorm( length(x), sd=2 )
y2 = hill_model(theta, x) + rnorm( length(x), sd=.1*hill_model(theta, x) )
wts = runif( length(y1) )
fit1=optim_fit(theta, hill_model, x=x, y=y1)
fit2=optim_fit(theta, hill_model, x=x, y=y1, wts=weights_varIdent)
fit3=optim_fit(theta, hill_model, x=x, y=y1, wts=wts)
fit4=optim_fit(theta, hill_model, attr(hill_model, "gradient"), x=x, y=y1, wts=wts)

fit5=optim_fit(NULL, hill_model, x=x, y=y2, wts=weights_varPower, fit.method="irwls")
fit6=optim_fit(theta, hill_model, x=x, y=y2, wts=weights_varPower, fit.method="mle")

fit7=optim_fit(theta, hill_model, x=x, y=y2, wts=weights_varPower, fit.method="irwls", 
               phi0=0.5, phi.fixed=FALSE)
fit8=optim_fit(theta, hill_model, x=x, y=y2, wts=weights_varPower, fit.method="mle", 
              phi0=0.5, phi.fixed=FALSE)

fit9a=optim_fit(theta, hill_model, x=x, y=y1, wts=weights_tukey_bw, fit.method="irwls", 
             phi0=4.685, phi.fixed=TRUE)

fit9b=robust_fit(theta, hill_model, x=x, y=y1, wts="tukey")

</code></pre>

<hr>
<h2 id='optim_weights'>Weight functions for optim_fit</h2><span id='topic+weights_huber'></span><span id='topic+weights_tukey_bw'></span><span id='topic+weights_varConstPower'></span><span id='topic+weights_varExp'></span><span id='topic+weights_varIdent'></span><span id='topic+weights_varPower'></span>

<h3>Description</h3>

<p> Weight functions for <code>optim_fit</code>. May be used when <code>fit.method=="irwls"</code> or <code>fit.method=="mle"</code>. Generally, not called by the user.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
       weights_varIdent(phi, mu)
       weights_varExp(phi, mu)
       weights_varPower(phi, mu)
       weights_varConstPower(phi, mu)
       weights_tukey_bw(phi = 4.685, resid)
       weights_huber(phi=1.345, resid)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optim_weights_+3A_phi">phi</code></td>
<td>
<p>Variance parameter(s)</p>
</td></tr>
<tr><td><code id="optim_weights_+3A_mu">mu</code></td>
<td>
<p>Vector of means</p>
</td></tr>
<tr><td><code id="optim_weights_+3A_resid">resid</code></td>
<td>
<p>Vector of model residuals</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>weights_varIdent</code> returns a vector of ones.
</p>
</li>
<li> <p><code>weights_varExp</code> returns <code class="reqn">\exp(\phi*\mu)</code>
</p>
</li>
<li> <p><code>weights_varPower</code> returns <code class="reqn">|\mu|^{\phi}</code>
</p>
</li>
<li> <p><code>weights_varConstPower</code> returns <code class="reqn">\phi_1 + |\mu|^{\phi_2}</code> where <code class="reqn">\phi_i =\phi</code>[i]
</p>
</li>
<li> <p><code> weights_tukey_bw</code> is a Tukey bi-weight function. Let 
</p>
<p style="text-align: center;"><code class="reqn">r=\tfrac{|\text{resid}|}{\text{mad}(\text{resid},\text{center}=\text{TRUE})}.</code>
</p>
 
<p>Then this function returns
</p>
<p style="text-align: center;"><code class="reqn">\left(1-\left(\tfrac{r}{\phi}\right)^2\right)^2\text{ whenever } r &lt;= \phi\text{ and }0{ o.w.}</code>
</p>

<p>For this the user should use <code>phi.fixed=TRUE</code> in the <code>optim_fit</code> function.
</p>
</li>
<li><p><code>weights_huber</code> is a Huber weighting function that returns <code class="reqn">\min(1, \phi/r)</code>, where <code class="reqn">r = |\text{resid}|/\text{sig}</code> and <code class="reqn">\text{sig} = \text{mad}(\text{resid}, \text{center} = \text{TRUE})</code>.  For this the user should use <code>phi.fixed = TRUE</code> in the <code>optim_fit</code> function.
</p>
</li></ul>



<h3>Value</h3>

<p>A vector of numeric weights.
</p>


<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, <code><a href="#topic+rout_fitter">rout_fitter</a></code>
</p>

<hr>
<h2 id='predict.optim_fit'>Predicted values for optim.fit objects</h2><span id='topic+predict.optim_fit'></span>

<h3>Description</h3>

<p> Provides predicted values, standard errors, confidence intervals and prediction intervals for <code>optim_fit</code> objects.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
    ## S3 method for class 'optim_fit'
predict(object, x, se.fit=FALSE, 
    interval=c("none", "confidence", "prediction"), K = 1, level = 0.95,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.optim_fit_+3A_object">object</code></td>
<td>
<p> An object resulting from <code>optim_fit</code>. </p>
</td></tr>
<tr><td><code id="predict.optim_fit_+3A_x">x</code></td>
<td>
<p> If supplied, a vector, data.frame, or matrix of Explanatory variables. </p>
</td></tr>
<tr><td><code id="predict.optim_fit_+3A_se.fit">se.fit</code></td>
<td>
<p> Logical.  Should standard errors be returned?  Requires that 'x' is supplied. </p>
</td></tr>
<tr><td><code id="predict.optim_fit_+3A_interval">interval</code></td>
<td>
<p> If equal to 'confidence', returns a 100*level% confidence interval for the
mean response.  If equal to 'prediction', returns a 100*level% prediction interval for the mean of the next
K observations.  Requires that 'x' is supplied. </p>
</td></tr>    
<tr><td><code id="predict.optim_fit_+3A_k">K</code></td>
<td>
<p> Only used for prediction interval.  Number of observations in the mean for the prediction interval. </p>
</td></tr>
<tr><td><code id="predict.optim_fit_+3A_level">level</code></td>
<td>
<p> Confidence/prediction interval level.</p>
</td></tr>
<tr><td><code id="predict.optim_fit_+3A_...">...</code></td>
<td>
<p>mop up additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (if interval='none').
Otherwise returns a data.frame with possible columns 'x', 'y.hat', 'se.fit', 'lower', and 'upper'.
</p>


<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)

x = rep( c(0, 2^(-4:4)), each=4 )
theta = c(0, 100, log(.5), 2)
y1 = hill_model(theta, x) + rnorm( length(x), sd=2 )


fit1=optim_fit(theta, hill_model, x=x, y=y1)
fitted(fit1)
predict(fit1)
predict(fit1, x=x)
predict(fit1, x=seq(0, 1, by=.1), se.fit=TRUE)
predict(fit1, x=seq(0, 1, by=.1), interval="conf")
predict(fit1, x=seq(0, 1, by=.1), interval="pred")
</code></pre>

<hr>
<h2 id='print.optim_fit'>Prints optim_fit objects</h2><span id='topic+print.optim_fit'></span>

<h3>Description</h3>

<p> Provides a nice printed summary of <code>optim_fit</code> objects.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
  ## S3 method for class 'optim_fit'
print(x, digits=4,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.optim_fit_+3A_x">x</code></td>
<td>
<p> An object resulting from optim_fit(). </p>
</td></tr>
<tr><td><code id="print.optim_fit_+3A_digits">digits</code></td>
<td>
<p> Number of digits to print for output. </p>
</td></tr>
<tr><td><code id="print.optim_fit_+3A_...">...</code></td>
<td>
<p>other arguments not used by this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No Return Value.
</p>


<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = rep( c(0, 2^(-4:4)), each=4 )
theta = c(0, 100, log(.5), 2)
y1 = hill_model(theta, x) + rnorm( length(x), sd=2 )

fit1=optim_fit(theta, hill_model, x=x, y=y1)
print(fit1)
fit1

</code></pre>

<hr>
<h2 id='residuals.optim_fit'>Residuals for optim.fit objects</h2><span id='topic+residuals.optim_fit'></span>

<h3>Description</h3>

<p> Provides raw and studentized residuals for <code>optim_fit</code> objects.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
    ## S3 method for class 'optim_fit'
residuals(object, type=c("raw", "studentized"),...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.optim_fit_+3A_object">object</code></td>
<td>
<p> An object resulting from <code>optim.fit</code>(). </p>
</td></tr>
<tr><td><code id="residuals.optim_fit_+3A_type">type</code></td>
<td>
<p> 'raw' or 'studentized' residuals. </p>
</td></tr>
<tr><td><code id="residuals.optim_fit_+3A_...">...</code></td>
<td>
<p>mop up additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

x = rep( c(0, 2^(-4:4)), each=4 )
theta = c(0, 100, log(.5), 2)
y1 = hill_model(theta, x) + rnorm( length(x), sd=2 )

fit1=optim_fit(theta, hill_model, x=x, y=y1)
residuals(fit1)
residuals(fit1, type="s")
</code></pre>

<hr>
<h2 id='rout_fitter'>Fit Model with ROUT</h2><span id='topic+rout_fitter'></span>

<h3>Description</h3>

 
<p>The <code>rout_fitter</code> method in <span class="rlang"><b>R</b></span> fits nonlinear regression using the ROUT method as described in the reference below. The starting point is to fit a robust nonlinear regression approach assuming the Lorentzian distribution. An adaptive method then proceeds. The False Discovery Rate is used to detect outliers and the method fits in an iterative fashion. 
</p>
<p>The <code>rout_fitter</code> function provides a wrapper algorithm to the <code>optim</code> function in package <span class="pkg">stats</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rout_fitter(theta0 = NULL, f.model, x, y, lbs = FALSE, ntry = 0, tol = 1e-3, 
               Q = 0.01, check.pd.tol = 1e-8, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rout_fitter_+3A_theta0">theta0</code></td>
<td>
<p> a numeric vector of starting values.  Alternatively, if given as NULL, <code>theta0</code> can be computed within [rout.fitter()]
if a starting values function is supplied as attr(f.model, &quot;start&quot;), as a function of <code>x</code> and <code>y</code>. If <code>theta0</code> is user supplied,
the last entry of <code>theta0</code> should be log(sigma), where sigma = residual standard deviation. Otherwise, log(sigma) will be
estimated and appended to the results from attr(f.model, &quot;start&quot;). </p>
</td></tr>
<tr><td><code id="rout_fitter_+3A_f.model">f.model</code></td>
<td>
<p> Name of mean model function. See detials below. </p>
</td></tr>
<tr><td><code id="rout_fitter_+3A_x">x</code></td>
<td>
<p> Explanatory variable(s).  Can be a numeric <code>vector</code>, a <code>matrix</code>, or a <code>data.frame</code>. </p>
</td></tr>
<tr><td><code id="rout_fitter_+3A_y">y</code></td>
<td>
<p> a numeric <code>vector</code> for the response variable. </p>
</td></tr>
<tr><td><code id="rout_fitter_+3A_lbs">lbs</code></td>
<td>
<p>Parmeter</p>
</td></tr>
<tr><td><code id="rout_fitter_+3A_ntry">ntry</code></td>
<td>
<p>Parmeter</p>
</td></tr>
<tr><td><code id="rout_fitter_+3A_tol">tol</code></td>
<td>
<p> Tolerance for <code>optim</code> algorithm. </p>
</td></tr>
<tr><td><code id="rout_fitter_+3A_q">Q</code></td>
<td>
<p> The test size for ROUT testing. </p>
</td></tr>
<tr><td><code id="rout_fitter_+3A_check.pd.tol">check.pd.tol</code></td>
<td>
<p>absolute tolarence for determing whether a matrix is positive definite. Refer to <code>test_fit</code>.</p>
</td></tr>
<tr><td><code id="rout_fitter_+3A_...">...</code></td>
<td>
<p> Other arguments to passed to <code>optim</code>.  See ?optim.  For example, lower=, upper=, method=</p>
</td></tr>
</table>


<h3>Details</h3>

<p>[rout.fitter()] is a wrapper for [optim()], specifically for Cauchy likelihood linear and non-linear regression.
The Default algorithm uses method=&ldquo;BFGS&rdquo; or &ldquo;L-BFGS-B&rdquo;, if lower= and upper= arguments
are specified.  These can easily be overridden using the &ldquo;...&rdquo;.
</p>
<p>The assumed model is:   
</p>
<p style="text-align: center;"><code class="reqn">y = \text{f.model}(theta, x) + \sigma*\epsilon \text{, where } \epsilon \sim Cauchy(0,1).</code>
</p>

<p>After the Cauchy likelihood model is fitted to data, the residuals are interrogated to determine which observations
might be outliers.  An FDR correction is made to p-values (for outlier testing) through the p.adjust(method=&quot;fdr&quot;) function of the <span class="pkg">stats</span> package.
</p>
<p>The package supports several mean model functions for the f.model parameter. This includes <code>beta_model</code>, <code>exp_2o_decay</code>, <code>exp_decay_pl</code>,
<code>gompertz_model</code>, <code>hill_model</code>, <code>hill_quad_model</code>, <code>hill_switchpoint_model</code>, <code>hill5_model</code> and <code>linear_model</code>.
</p>


<h3>Value</h3>

<p>An object with class &ldquo;rout_fit&rdquo; is returned that gives a list with the following components and attributes:
</p>
<p>par = estimated Cauchy model coefficients.  The last term is log(sigma)
</p>
<p>value, counts, convergence = returns from [optim()]
</p>
<p>message = character, indicating problem if any.  otherwise = NULL
</p>
<p>hessian = hessian matrix of the objective function (e.g., sum of squares)
</p>
<p>Converge = logical value to indicate hessian is positive definite
</p>
<p>call = [rout.fitter()] function call
</p>
<p>residuals = model residuals
</p>
<p>rsdr = robust standard deviation from ROUT method
</p>
<p>sresiduals = residuals/rsdr
</p>
<p>outlier = logical vector.  TRUE indicates observation is an outlier via hypothesis testing with unadjust p-values.
</p>
<p>outlier.adj = logical vector.  TRUE indicates observation is an outlier via hypothesis testing with FDR-adjust p-values.
</p>
<p><code>attr</code>(object, &quot;Q&quot;) = test size for outlier detection
</p>


<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>References</h3>

<p>Motulsky, H.J. and Brown, R.E. (2006) Detecting Outliers When Fitting Data with Nonlinear Regression: A New Method Based on Robust Nonlinear Regression and the False Discovery Rate. BMC Bioinformatics, 7, 123.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>, 
<code><a href="#topic+rout_outlier_test">rout_outlier_test</a></code>,
<code><a href="#topic+beta_model">beta_model</a></code>,
<code><a href="#topic+exp_2o_decay">exp_2o_decay</a></code>,
<code><a href="#topic+exp_decay_pl">exp_decay_pl</a></code>,
<code><a href="#topic+gompertz_model">gompertz_model</a></code>, 
<code><a href="#topic+hill_model">hill_model</a></code>, 
<code><a href="#topic+hill5_model">hill5_model</a></code>, 
<code><a href="#topic+hill_quad_model">hill_quad_model</a></code>, 
<code><a href="#topic+hill_switchpoint_model">hill_switchpoint_model</a></code>, 
<code><a href="#topic+linear_model">linear_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = rep( c(0, 2^(-4:4)), each=4 )
theta = c(0, 100, log(.5), 2)
y = hill_model(theta, x) + rnorm( length(x), sd=2 )

rout_fitter(NULL, hill_model, x=x, y=y)
rout_fitter(c( theta, log(2) ), hill_model, x=x, y=y)

ii = sample( 1:length(y), 2 )
y[ii] = hill_model(theta, x[ii]) + 5.5*2 + rnorm( length(ii), sd=2 )

rout_fitter(c( theta, log(2) ), hill_model, x=x, y=y, Q=0.01)
rout_fitter(c( theta, log(2) ), hill_model, x=x, y=y, Q=0.05)
rout_fitter(c( theta, log(2) ), hill_model, x=x, y=y, Q=0.0001)

## Use optim method="L-BFGS-B"
rout_fitter(NULL, hill_model, x=x, y=y, Q=0.01, lower=c(-2, 95, NA, 0.5), upper=c(5, 110, NA, 4) )

</code></pre>

<hr>
<h2 id='rout_outlier_test'>ROUT Outlier Testing</h2><span id='topic+rout_outlier_test'></span>

<h3>Description</h3>

<p> Perform ROUT outlier testing on <code>rout.fitter</code> object.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>rout_outlier_test(fit, Q = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rout_outlier_test_+3A_fit">fit</code></td>
<td>
<p> A &lsquo;rout.fitter&rsquo; object from the <code>rout_fitter</code> function. </p>
</td></tr>
<tr><td><code id="rout_outlier_test_+3A_q">Q</code></td>
<td>
<p> Test size for ROUT outlier detection.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rout_outlier_test</code>() is typically called from <code>rout_fitter</code>(), but may also be called directly by the user.
</p>


<h3>Value</h3>

<p>outlier = logical vector.  TRUE indicates observation is an outlier via hypothesis testing with unadjust p-values.
</p>
<p>outlier.adj = logical vector.  TRUE indicates observation is an outlier via hypothesis testing with FDR-adjust p-values.
</p>
<p>attr(object, &quot;Q&quot;) = test size for outlier detection
</p>


<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+rout_fitter">rout_fitter</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)

x = rep( c(0, 2^(-4:4)), each=4 )
theta = c(0, 100, log(.5), 2)
y = hill_model(theta, x) + rnorm( length(x), sd=2 )

ii = sample( 1:length(y), 2 )
y[ii] = hill_model(theta, x[ii]) + 5.5*2 + rnorm( length(ii), sd=2 )

fit = rout_fitter(c( theta, log(2) ), hill_model, x=x, y=y, Q=0.01)
rout_outlier_test(fit, Q=0.001)

</code></pre>

<hr>
<h2 id='test_fit'>Test Fit Parameters</h2><span id='topic+test_fit'></span>

<h3>Description</h3>

<p> Test if estimated parameters optimize the regression system (i.e., minimize sums of squares, maximize likelihood).  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
       test_fit(obj, check.pd.tol = 1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_fit_+3A_obj">obj</code></td>
<td>
<p>An <code>optim_fit</code> object</p>
</td></tr>
<tr><td><code id="test_fit_+3A_check.pd.tol">check.pd.tol</code></td>
<td>
<p>absolute tolarence for determing whether a matrix is positive definite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks if <code>optim</code> convergence has been reached and also checks if the cholesky decompoisition of the Hessian matrix is positive definite.  The latter is an indication that optimization has been reached.
Sometimes the <code>chol</code> decomposition check doesn't work and to enforce that constriant we use the <code>check.pd.tol</code> to make sure all the eigenvalues are larger than this minimum threshhold.
</p>


<h3>Value</h3>

<p>Returns a TRUE or FALSE as to whether or not hessian component of the object is Positive Definite.
</p>


<h3>Author(s)</h3>

<p>Steven Novick</p>


<h3>See Also</h3>

<p><code><a href="#topic+optim_fit">optim_fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123L)
x = rep( c(0, 2^(-4:4)), each=4 )
theta = c(0, 100, log(.5), 2)
y1 = hill_model(theta, x) + rnorm( length(x), sd=2 )
wts = runif( length(y1) )
fit1=optim_fit(theta, hill_model, x=x, y=y1)
test_fit(fit1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
