<!DOCTYPE html><html><head><title>Help for package bwsTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bwsTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ae_mnl'><p>Analytical Estimation of a Multinomial Logit Model for Best-Worst Scaling</p></a></li>
<li><a href='#agg'><p>Example Data for Non-BIBD Aggregate-Level Best-Worst Scaling</p></a></li>
<li><a href='#bibds'><p>Balanced Incomplete Block Designs for use in Best-Worst Scaling</p></a></li>
<li><a href='#diffscoring'><p>Difference Method to Calculate Individual Best-Worst Scores</p></a></li>
<li><a href='#e_bayescoring'><p>Empirical Bayes Method to Calculate Individual Best-Worst Scores</p></a></li>
<li><a href='#elo'><p>Elo Method to Calculate Aggregate Best-Worst Scores</p></a></li>
<li><a href='#eloscoring'><p>Elo Method to Calculate Individual Best-Worst Scores</p></a></li>
<li><a href='#indiv'><p>Example Data for Individual-Level Best-Worst Scaling</p></a></li>
<li><a href='#make_bibd'><p>Make Balanced Incomplete Block Designs from bibds Designs</p></a></li>
<li><a href='#prscoring'><p>Page Rank Method to Calculate Individual Best-Worst Scores</p></a></li>
<li><a href='#vdata'><p>Example Data Used in Vignettes</p></a></li>
<li><a href='#walkscoring'><p>Walkscoring Method to Calculate Individual Best-Worst Scores</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Case 1 Best-Worst Scaling (MaxDiff) Designs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to design best-worst scaling designs (i.e., balanced incomplete block designs) and
    to analyze data from these designs, using aggregate and individual methods such as: difference 
    scores, Louviere, Lings, Islam, Gudergan, &amp; Flynn (2013) &lt;<a href="https://doi.org/10.1016%2Fj.ijresmar.2012.10.002">doi:10.1016/j.ijresmar.2012.10.002</a>&gt;; 
    analytical estimation, Lipovetsky &amp; Conklin (2014) &lt;<a href="https://doi.org/10.1016%2Fj.jocm.2014.02.001">doi:10.1016/j.jocm.2014.02.001</a>&gt;; empirical 
    Bayes, Lipovetsky &amp; Conklin (2015) &lt;<a href="https://doi.org/10.1142%2FS1793536915500028">doi:10.1142/S1793536915500028</a>&gt;; Elo, Hollis (2018) 
    &lt;<a href="https://doi.org/10.3758%2Fs13428-017-0898-2">doi:10.3758/s13428-017-0898-2</a>&gt;; and network-based measures.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/markhwhiteii/bwsTools">https://github.com/markhwhiteii/bwsTools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/markhwhiteii/bwsTools/issues">https://github.com/markhwhiteii/bwsTools/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>crossdes, dplyr, igraph, magrittr, rlang, tidyr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, ggplot2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-26 15:40:05 UTC; markwhite</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark White [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark White &lt;markhwhiteii@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-26 22:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ae_mnl'>Analytical Estimation of a Multinomial Logit Model for Best-Worst Scaling</h2><span id='topic+ae_mnl'></span>

<h3>Description</h3>

<p>This uses Equations 7, 10, 12, 13, and 18 from Lipovetsky &amp;
Conklin (2014) to take vectors of total times shown to participants, total 
times selected as best, and total times selected as worst. It uses their 
closed-form solution to calculate utility coefficients—as well as their 
standard errors and confidence intervals—and choice probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ae_mnl(data, totals, bests, worsts, z = 1.96)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ae_mnl_+3A_data">data</code></td>
<td>
<p>A data.frame where each row represents an item, and three columns
represent total times shown to participants, total times selected as bests,
and total time selected as worsts.</p>
</td></tr>
<tr><td><code id="ae_mnl_+3A_totals">totals</code></td>
<td>
<p>A string that is the name of the column for totals in the data.</p>
</td></tr>
<tr><td><code id="ae_mnl_+3A_bests">bests</code></td>
<td>
<p>A string that is the name of the column for bests in the data.</p>
</td></tr>
<tr><td><code id="ae_mnl_+3A_worsts">worsts</code></td>
<td>
<p>A string that is the name of the column for worsts in the data.</p>
</td></tr>
<tr><td><code id="ae_mnl_+3A_z">z</code></td>
<td>
<p>A z-value to calculate the confidence intervals. Defaults to 1.96,
a 95% CI.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the utility coefficients (with standard error
and confidence intervals) and choice probabilities for each item (row)
in the data.
</p>


<h3>References</h3>

<p>Lipovetsky, S., &amp; Conklin, M. (2014). Best-worst scaling in analytical 
closed-form solution. The Journal of Choice Modelling, 10, 60-68. 
doi: 10.1016/j.jocm.2014.02.001
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Replicate Table 6 from Lipovetsky &amp; Conklin (2014)
d &lt;- data.frame(
  totals = c(7145, 7144, 7144, 7144, 7145, 7145, 7144, 7146, 8166, 
             7145, 7144, 7144, 7145, 7144, 7145, 7144, 7146),
  bests = c(1733, 968, 5218, 2704, 2307, 692, 1816, 689, 2483, 1422, 
            362, 2589, 4158, 825, 829, 859, 966),
  worsts = c(1324, 2139, 113, 1010, 772, 3986, 1438, 2397, 1041, 1538, 
  4597, 966, 305, 2875, 2256, 2259, 1604)
)
results &lt;- ae_mnl(d, "totals", "bests", "worsts")
(d &lt;- cbind(d, results))

</code></pre>

<hr>
<h2 id='agg'>Example Data for Non-BIBD Aggregate-Level Best-Worst Scaling</h2><span id='topic+agg'></span>

<h3>Description</h3>

<p>A tibble that shows the format a tibble should take when it is
submitted to an aggregate scoring function that is NOT ae_mnl(), which
assumes a balanced incomplete block design (BIBD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 400 rows and 4 columns.
</p>

<hr>
<h2 id='bibds'>Balanced Incomplete Block Designs for use in Best-Worst Scaling</h2><span id='topic+bibds'></span>

<h3>Description</h3>

<p>A data.frame of 32 different balanced incomplete block designs (BIBD) that
can be used to set up best-worst scaling studies. The columns are: design,
which is an identification number that can is fed to get_bibd; t, which
is the number of items (or &quot;treatments&quot;) one will be using in the study;
k, which is how many of the items the respondent sees per trial; r, which
is how many times the participant sees each item across all of the trials;
b, which is how many trials (or &quot;blocks&quot;) there are in the design; and
lambda, which indicates how many times each pair of options co-occur
throughout the design. This is taken from Table 11.3 in Cochran &amp; Cox 
(1957), including only the designs where t and b are both less than or
equal to 20 (as any larger would put cognitive strain on a respondent).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bibds
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 32 rows and 6 columns.
</p>


<h3>References</h3>

<p>Cochran, W. G., &amp; Cox, G. M. (1957). Balanced and partially balanced 
incomplete block designs. In Experimental designs (2nd ed., pp. 439–482).
New York: John Wiley &amp; Sons, Inc.
</p>

<hr>
<h2 id='diffscoring'>Difference Method to Calculate Individual Best-Worst Scores</h2><span id='topic+diffscoring'></span>

<h3>Description</h3>

<p>Calculate best-worst scores for each respondent-item combination. This is
simply taking the total number of times a respondent selected the item
as &quot;best&quot; and subtracting from that the number of times a respondent
selected the item as &quot;worst&quot; (Louviere et al., 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffscoring(data, id, block, item, choice, std = FALSE, wide = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffscoring_+3A_data">data</code></td>
<td>
<p>A data.frame of the type described in details.</p>
</td></tr>
<tr><td><code id="diffscoring_+3A_id">id</code></td>
<td>
<p>A string of the name of the id column.</p>
</td></tr>
<tr><td><code id="diffscoring_+3A_block">block</code></td>
<td>
<p>A string of the name of the block column.</p>
</td></tr>
<tr><td><code id="diffscoring_+3A_item">item</code></td>
<td>
<p>A string of the name of the item column.</p>
</td></tr>
<tr><td><code id="diffscoring_+3A_choice">choice</code></td>
<td>
<p>A string of the name of the choice column.</p>
</td></tr>
<tr><td><code id="diffscoring_+3A_std">std</code></td>
<td>
<p>Logical of whether or not one wants to standardize the data to
a -1 to +1 range.</p>
</td></tr>
<tr><td><code id="diffscoring_+3A_wide">wide</code></td>
<td>
<p>Logical of whether or not one wants the data returned in long
(each row is an item-respondent combination and all best-worst scores are
in the same column) format (FALSE) or in wide format (where each row is a 
respondent, and the best-worst scores for the items are in their own 
columns). See the 'indiv' data as an example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires data to be in a specified format. Each row must
represent a respondent-block-label combination. That is, it indicates
the person, the block (or trial), the item that was judged, and a column
indicating whether it was chosen as best (+1), worst (-1), or wasn't 
selected as either (0).
</p>


<h3>Value</h3>

<p>A data.frame containing the id and item columns as well as a &quot;bws&quot; column
that indicates the best worst score. If 'wide = TRUE', then each item
has its own column and the bws is filled-in those columns.
</p>


<h3>References</h3>

<p>Louviere, J., Lings, I., Islam, T., Gudergan, S., &amp; Flynn (2013). An
introduction to the application of (case 1) best-worst scaling in marketing
research. International Journal of Research in Marketing, 30(3), 292-303.
doi: 10.1016/j.ijresmar.2012.10.002
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(indiv)
head(indiv)
diffscoring(indiv, "id", "block", "label", "value")
diffscoring(indiv, "id", "block", "label", "value", TRUE, TRUE)

</code></pre>

<hr>
<h2 id='e_bayescoring'>Empirical Bayes Method to Calculate Individual Best-Worst Scores</h2><span id='topic+e_bayescoring'></span>

<h3>Description</h3>

<p>Individual utilities from empirical bayes estimations. Instead of doing the
computationally-expensive hierarchical Bayesian multinomial logistic
regression model, Lipovetsky &amp; Conklin (2015) show an empirical Bayes
way to calculate this analytically. This function calculates choice
probabilities shown using Equation 10 in Lipovetsky &amp; Conklin (2015) and
transforms them to be on a linear regression coefficient scale. Default
values for the E and alpha parameters are those performing best in their
empirical example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e_bayescoring(data, id, block, item, choice, E = 0.1, alpha = 1, wide = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_bayescoring_+3A_data">data</code></td>
<td>
<p>A data.frame of the type described in details.</p>
</td></tr>
<tr><td><code id="e_bayescoring_+3A_id">id</code></td>
<td>
<p>A string of the name of the id column.</p>
</td></tr>
<tr><td><code id="e_bayescoring_+3A_block">block</code></td>
<td>
<p>A string of the name of the block column.</p>
</td></tr>
<tr><td><code id="e_bayescoring_+3A_item">item</code></td>
<td>
<p>A string of the name of the item column.</p>
</td></tr>
<tr><td><code id="e_bayescoring_+3A_choice">choice</code></td>
<td>
<p>A string of the name of the choice column.</p>
</td></tr>
<tr><td><code id="e_bayescoring_+3A_e">E</code></td>
<td>
<p>Value of precision shown in Equation 8 of Lipovetsky &amp; Conklin
(2015). If the naive estimate for a choice probability is 0, it is replaced
with E; If the naive estimate for the choice probability is 1, i is
replaced with 1 - E.</p>
</td></tr>
<tr><td><code id="e_bayescoring_+3A_alpha">alpha</code></td>
<td>
<p>The mixing parameter shown in Equation 10 of Lipovetsky &amp;
Conklin (2015). This shapes how much the naive individual estimate and how
much of the aggregate estimate influences the resulting estimate.</p>
</td></tr>
<tr><td><code id="e_bayescoring_+3A_wide">wide</code></td>
<td>
<p>Logical of whether or not one wants the data returned in long
(each row is an item-respondent combination and all best-worst scores are
in the same column) format (FALSE) or in wide format (where each row is a 
respondent, and the best-worst scores for the items are in their own 
columns). See the 'indiv' data as an example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires data to be in a specified format. Each row must
represent a respondent-block-label combination. That is, it indicates
the person, the block (or trial), the item that was judged, and a column
indicating whether it was chosen as best (+1), worst (-1), or wasn't 
selected as either (0).
</p>


<h3>Value</h3>

<p>A data.frame containing the id and item columns as well as a &quot;b_ebayes&quot; 
column that indicates the utility coefficient. If 'wide = TRUE', then 
each item has its own column and the coefficient is filled-in 
those columns.
</p>


<h3>References</h3>

<p>Lipovetsky, S., &amp; Conklin, M. (2015). MaxDiff priority estimations with and
without HB-MNL. Advances in Adaptive Data Analysis, 7(1). doi:
10.1142/S1793536915500028
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(indiv)
head(indiv)
e_bayescoring(indiv, "id", "block", "label", "value")

</code></pre>

<hr>
<h2 id='elo'>Elo Method to Calculate Aggregate Best-Worst Scores</h2><span id='topic+elo'></span>

<h3>Description</h3>

<p>Calculate aggregate best-worst scores using Elo scoring. This specific
application comes from Hollis (2018). It makes each individual/block 
pairwise comparisons and updates Elo scores based on who won and lost those
comparisons. No ties are considered, which occurs between all of the items
that have not been selected as either best or worst. Hollis (2018) also
recommends adding two &quot;dummy items&quot;: one that defeats every other item,
and one that loses to every other item. This is employed here. The default 
K is 30, per Hollis (2018). Since Elo is temporal in nature, Hollis also
recommends running various iterations, each with a different randomization
of the order of matchups. The default is the 100 used by Hollis. These are 
averaged together to calculate individual Elo best-worst scores. Elo scores
are all initialized at 1000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elo(data, id, block, item, choice, K = 30, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elo_+3A_data">data</code></td>
<td>
<p>A data.frame of the type described in details.</p>
</td></tr>
<tr><td><code id="elo_+3A_id">id</code></td>
<td>
<p>A string of the name of the id column.</p>
</td></tr>
<tr><td><code id="elo_+3A_block">block</code></td>
<td>
<p>A string of the name of the block column.</p>
</td></tr>
<tr><td><code id="elo_+3A_item">item</code></td>
<td>
<p>A string of the name of the item column.</p>
</td></tr>
<tr><td><code id="elo_+3A_choice">choice</code></td>
<td>
<p>A string of the name of the choice column.</p>
</td></tr>
<tr><td><code id="elo_+3A_k">K</code></td>
<td>
<p>The Elo K-factor. The default is 30, per Hollis (2018).</p>
</td></tr>
<tr><td><code id="elo_+3A_iter">iter</code></td>
<td>
<p>Number of different randomizations of the &quot;matchup&quot; order to 
iterate through. The default is Hollis's (2018, 2019) recommendation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires data to be in a specified format. Each row must
represent a respondent-block-label combination. That is, it indicates
the person, the block (or trial), the item that was judged, and a column
indicating whether it was chosen as best (+1), worst (-1), or wasn't 
selected as either (0).
</p>


<h3>Value</h3>

<p>A data.frame containing the item column as well as an &quot;elo&quot; column that 
indicates the Elo score.
</p>


<h3>References</h3>

<p>Hollis, G. (2018). Scoring best-worst data in unbalanced many-item designs,
with applications to crowdsourcing semantic judgments. Behavior Research
Methods, 50(2), 711-729. doi: 10.3758/s13428-017-0898-2
</p>
<p>Hollis, G. (2019). The role of number of items per trial in best-worst
scaling experiments. Behavior Research Methods. doi: 
10.3758/s13428-019-01270-w
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(agg)
head(agg)
# run more than 1 iter; just doing 1 here for speed
elo(agg, "pid", "trial", "character", "decision", iter = 1)

</code></pre>

<hr>
<h2 id='eloscoring'>Elo Method to Calculate Individual Best-Worst Scores</h2><span id='topic+eloscoring'></span>

<h3>Description</h3>

<p>Calculate individual best-worst scores using Elo scoring. This specific
application comes from Hollis (2018). It makes each block pairwise
comparisons and updates Elo scores based on who won and lost those
comparisons. No ties are considered, which occurs between all of the items
that have not been selected as either best or worst. Hollis (2018) also
recommends adding two &quot;dummy items&quot;: one that defeats every other item,
and one that loses to every other item. This is employed here. The default 
K is 30, per Hollis (2018). Since Elo is temporal in nature, Hollis also
recommends running various iterations, each with a different randomization
of the order of matchups. The default is the 100 used by Hollis. These are 
averaged together to calculate individual Elo best-worst scores. Elo scores
are all initialized at 1000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eloscoring(data, id, block, item, choice, K = 30, iter = 100, wide = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eloscoring_+3A_data">data</code></td>
<td>
<p>A data.frame of the type described in details.</p>
</td></tr>
<tr><td><code id="eloscoring_+3A_id">id</code></td>
<td>
<p>A string of the name of the id column.</p>
</td></tr>
<tr><td><code id="eloscoring_+3A_block">block</code></td>
<td>
<p>A string of the name of the block column.</p>
</td></tr>
<tr><td><code id="eloscoring_+3A_item">item</code></td>
<td>
<p>A string of the name of the item column.</p>
</td></tr>
<tr><td><code id="eloscoring_+3A_choice">choice</code></td>
<td>
<p>A string of the name of the choice column.</p>
</td></tr>
<tr><td><code id="eloscoring_+3A_k">K</code></td>
<td>
<p>The Elo K-factor. The default is 30, per Hollis (2018).</p>
</td></tr>
<tr><td><code id="eloscoring_+3A_iter">iter</code></td>
<td>
<p>Number of different randomizations of the &quot;matchup&quot; order to 
iterate through. The default is Hollis's (2018, 2019) recommendation.</p>
</td></tr>
<tr><td><code id="eloscoring_+3A_wide">wide</code></td>
<td>
<p>Logical of whether or not one wants the data returned in long
(each row is an item-respondent combination and all best-worst scores are
in the same column) format (FALSE) or in wide format (where each row is a 
respondent, and the best-worst scores for the items are in their own 
columns). See the 'indiv' data as an example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires data to be in a specified format. Each row must
represent a respondent-block-label combination. That is, it indicates
the person, the block (or trial), the item that was judged, and a column
indicating whether it was chosen as best (+1), worst (-1), or wasn't 
selected as either (0).
</p>


<h3>Value</h3>

<p>A data.frame containing the id and item columns as well as a &quot;elo&quot; 
column that indicates the Elo score. If 'wide = TRUE', then 
each item has its own column and the Elo score is filled-in those columns.
</p>


<h3>References</h3>

<p>Hollis, G. (2018). Scoring best-worst data in unbalanced many-item designs,
with applications to crowdsourcing semantic judgments. Behavior Research
Methods, 50(2), 711-729. doi: 10.3758/s13428-017-0898-2
</p>
<p>Hollis, G. (2019). The role of number of items per trial in best-worst
scaling experiments. Behavior Research Methods. doi: 
10.3758/s13428-019-01270-w
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(indiv)
head(indiv)
# run more than 1 iter; just doing 1 here for speed
eloscoring(indiv, "id", "block", "label", "value", iter = 1)

</code></pre>

<hr>
<h2 id='indiv'>Example Data for Individual-Level Best-Worst Scaling</h2><span id='topic+indiv'></span>

<h3>Description</h3>

<p>A tibble that shows the format a tibble should take when it is
submitted to a individual 'scoring' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indiv
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 520 rows and 4 columns.
</p>

<hr>
<h2 id='make_bibd'>Make Balanced Incomplete Block Designs from bibds Designs</h2><span id='topic+make_bibd'></span>

<h3>Description</h3>

<p>This function generates a balanced incomplete block design. It takes one
argument, the design number from the bibds data.frame object. See bibds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_bibd(design, seed = 1839)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_bibd_+3A_design">design</code></td>
<td>
<p>Integer from 1 to 32. Corresponds to the characteristics from
the bibds data.frame object.</p>
</td></tr>
<tr><td><code id="make_bibd_+3A_seed">seed</code></td>
<td>
<p>Integer to set seed for reproducibility, such that the same
design will be returned on different occasions. Defaults to 1839, so that
the function will, by default, yield reproducible designs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble. The first column indicates the block, and the rest of the
columns indicate which item is in each block.
</p>

<hr>
<h2 id='prscoring'>Page Rank Method to Calculate Individual Best-Worst Scores</h2><span id='topic+prscoring'></span>

<h3>Description</h3>

<p>Calculate best-worst scores for each respondent-item combination. This uses
the page rank method. It works virtually the same as the walkscoring
method; the only difference is that there is a parameter for randomly
&quot;teleporting&quot; to a random node. This can help prevent random walks
from getting &quot;stuck&quot; in certain areas. Page rank scores using are
calculated and synthesized in the same way as the method used in
walkscoring(). See White (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prscoring(data, id, block, item, choice, ..., wide = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prscoring_+3A_data">data</code></td>
<td>
<p>A data.frame of the type described in details.</p>
</td></tr>
<tr><td><code id="prscoring_+3A_id">id</code></td>
<td>
<p>A string of the name of the id column.</p>
</td></tr>
<tr><td><code id="prscoring_+3A_block">block</code></td>
<td>
<p>A string of the name of the block column.</p>
</td></tr>
<tr><td><code id="prscoring_+3A_item">item</code></td>
<td>
<p>A string of the name of the item column.</p>
</td></tr>
<tr><td><code id="prscoring_+3A_choice">choice</code></td>
<td>
<p>A string of the name of the choice column.</p>
</td></tr>
<tr><td><code id="prscoring_+3A_...">...</code></td>
<td>
<p>Additional arguments to igraph::page_rank()</p>
</td></tr>
<tr><td><code id="prscoring_+3A_wide">wide</code></td>
<td>
<p>Logical of whether or not one wants the data returned in long
(each row is an item-respondent combination and all best-worst scores are
in the same column) format (FALSE) or in wide format (where each row is a 
respondent, and the best-worst scores for the items are in their own 
columns). See the 'indiv' data as an example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires data to be in a specified format. Each row must
represent a respondent-block-label combination. That is, it indicates
the person, the block (or trial), the item that was judged, and a column
indicating whether it was chosen as best (+1), worst (-1), or wasn't 
selected as either (0).
</p>


<h3>Value</h3>

<p>A data.frame containing the id and item columns as well as a &quot;walk&quot; column
that indicates the best worst score. If 'wide = TRUE', then each item
has its own column and the walkscore is filled-in those columns.
</p>


<h3>References</h3>

<p>Brin, S., &amp; Page, L. (1998). The anatomy of a large-scale hypertextual
Web search engine. Computer Networks and ISDN Systems, 30(1), 107-117.
</p>
<p>Gleich, D. F. (2014). PageRank beyond the Web. arxiv.org/abs/1407.5107
</p>
<p>White, M. H., II. (2019). bwsTools: An R package for case 1 best-worst
scaling. Retrieved from https://osf.io/xftvq/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(indiv)
head(indiv)
prscoring(indiv, "id", "block", "label", "value")

## End(Not run)

</code></pre>

<hr>
<h2 id='vdata'>Example Data Used in Vignettes</h2><span id='topic+vdata'></span>

<h3>Description</h3>

<p>A tibble that shows the format a tibble should take when it is
submitted to a individual 'scoring' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdata
</code></pre>


<h3>Format</h3>

<p>An object of class <code>spec_tbl_df</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 18200 rows and 4 columns.
</p>

<hr>
<h2 id='walkscoring'>Walkscoring Method to Calculate Individual Best-Worst Scores</h2><span id='topic+walkscoring'></span>

<h3>Description</h3>

<p>Calculate best-worst scores for each respondent-item combination. This uses
the walkscoring method described in White (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walkscoring(data, id, block, item, choice, walks = 10000, wide = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walkscoring_+3A_data">data</code></td>
<td>
<p>A data.frame of the type described in details.</p>
</td></tr>
<tr><td><code id="walkscoring_+3A_id">id</code></td>
<td>
<p>A string of the name of the id column.</p>
</td></tr>
<tr><td><code id="walkscoring_+3A_block">block</code></td>
<td>
<p>A string of the name of the block column.</p>
</td></tr>
<tr><td><code id="walkscoring_+3A_item">item</code></td>
<td>
<p>A string of the name of the item column.</p>
</td></tr>
<tr><td><code id="walkscoring_+3A_choice">choice</code></td>
<td>
<p>A string of the name of the choice column.</p>
</td></tr>
<tr><td><code id="walkscoring_+3A_walks">walks</code></td>
<td>
<p>Integer indicating how many random walks to simulate.</p>
</td></tr>
<tr><td><code id="walkscoring_+3A_wide">wide</code></td>
<td>
<p>Logical of whether or not one wants the data returned in long
(each row is an item-respondent combination and all best-worst scores are
in the same column) format (FALSE) or in wide format (where each row is a 
respondent, and the best-worst scores for the items are in their own 
columns). See the 'indiv' data as an example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires data to be in a specified format. Each row must
represent a respondent-block-label combination. That is, it indicates
the person, the block (or trial), the item that was judged, and a column
indicating whether it was chosen as best (+1), worst (-1), or wasn't 
selected as either (0).
</p>


<h3>Value</h3>

<p>A data.frame containing the id and item columns as well as a &quot;walk&quot; column
that indicates the best worst score. If 'wide = TRUE', then each item
has its own column and the walkscore is filled-in those columns.
</p>


<h3>References</h3>

<p>White, M. H., II. (2019). bwsTools: An R package for case 1 best-worst
scaling. Retrieved from https://osf.io/xftvq/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(indiv)
head(indiv)
# use more than 100 walks; only using 100 here for speed
walkscoring(indiv, "id", "block", "label", "value", 100)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
