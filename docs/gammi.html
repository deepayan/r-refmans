<!DOCTYPE html><html lang="en"><head><title>Help for package gammi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gammi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#exam'>
<p>Cross-Classified Examination Data</p></a></li>
<li><a href='#gammi'>
<p>Fit a Generalized Additive Mixed Model</p></a></li>
<li><a href='#plot.gammi'>
<p>Plot Method for gammi Fits</p></a></li>
<li><a href='#predict.gammi'>
<p>Predict Method for gammi Fits</p></a></li>
<li><a href='#spline.basis'>
<p>Spectral Spline Basis</p></a></li>
<li><a href='#spline.model.matrix'>
<p>Construct Design Matrices via Spectral Splines</p></a></li>
<li><a href='#StartupMessage'><p>Startup Message for gammi</p></a></li>
<li><a href='#summary.gammi'>
<p>Summary Method for gammi Fits</p></a></li>
<li><a href='#visualizers'>
<p>Internal Functions for Plot Method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Additive Mixed Model Interface</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-30</td>
</tr>
<tr>
<td>Description:</td>
<td>An interface for fitting generalized additive models (GAMs) and generalized additive mixed models (GAMMs) using the 'lme4' package as the computational engine, as described in Helwig (2024) &lt;<a href="https://doi.org/10.3390%2Fstats7010003">doi:10.3390/stats7010003</a>&gt;. Supports default and formula methods for model specification, additive and tensor product splines for capturing nonlinear effects, and automatic determination of spline type based on the class of each predictor. Includes an S3 plot method for visualizing the (nonlinear) model terms, an S3 predict method for forming predictions from a fit model, and an S3 summary method for conducting significance testing using the Bayesian interpretation of a smoothing spline.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lme4, Matrix, methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-30 14:14:21 UTC; nate</td>
</tr>
<tr>
<td>Author:</td>
<td>Nathaniel E. Helwig [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-30 14:50:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='exam'>
Cross-Classified Examination Data
</h2><span id='topic+exam'></span>

<h3>Description</h3>

<p>Scores on secondary school leaving examinations (response) and verbal reasoning scores in primary school (fixed effect) for 3435 students in Fife, Scotland. The students are cross-classified in 148 primary schools (random effect) and 19 secondary schools (random effect).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("exam")</code></pre>


<h3>Format</h3>

<p>A data frame with 3435 observations on the following 4 variables.
</p>

<dl>
<dt><code>VRQ.score</code></dt><dd><p>Verbal Reasoning Quotient obtained in primary school (integer vector ranging from 70 to 140)</p>
</dd>
<dt><code>Exam.score</code></dt><dd><p>Leaving examination score obtained in secondary school (integer vector ranging from 1 to 10)</p>
</dd>
<dt><code>Primary.school</code></dt><dd><p>Primary school identifier (factor with 148 levels)</p>
</dd>
<dt><code>Secondary.school</code></dt><dd><p>Secondary school identifier (factor with 19 levels)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The VRQ scores were obtained at age 12 (right before entering secondary school), and the Exam scores were obtained at age 16 (right before leaving secondary school). The VRQ scores are constructed to have a population mean of 100 and population standard deviation of 15. The goal is to predict the leaving Exam scores from the VRQ scores while accounting for the primary and secondary school cross-classifications.
</p>


<h3>Source</h3>

<p>Data Obtainable from:
<a href="https://www.bristol.ac.uk/cmm/team/hg/msm-3rd-ed/datasets.html">https://www.bristol.ac.uk/cmm/team/hg/msm-3rd-ed/datasets.html</a>
</p>


<h3>References</h3>

<p>Goldstein, H. (2011). Multilevel Statistical Models, 4th Edition. Chapter 12: Cross-classified data structures (pages 243-254). <a href="https://doi.org/10.1002/9780470973394">doi:10.1002/9780470973394</a> 
</p>
<p>Paterson, L. (1991). Socio-economic status and educational attainment: a multidimensional and multilevel study. Evaluation and Research in Education, 5, 97-121. <a href="https://doi.org/10.1080/09500799109533303">doi:10.1080/09500799109533303</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load 'gammi' package
library(gammi)

# load 'exam' help file
?exam

# load data
data(exam)

# header of data
head(exam)

# fit model
mod &lt;- gammi(Exam.score ~ VRQ.score, data = exam,
             random = ~ (1 | Primary.school) + (1 | Secondary.school))
             
# plot results
plot(mod)

# summarize results
summary(mod)

# variance parameters
mod$VarCorr
</code></pre>

<hr>
<h2 id='gammi'>
Fit a Generalized Additive Mixed Model
</h2><span id='topic+gammi'></span><span id='topic+gammi.default'></span><span id='topic+gammi.formula'></span>

<h3>Description</h3>

<p>Fits generalized additive models (GAMs) and generalized additive mixed model (GAMMs) using <b>lme4</b> as the tuning engine. Predictor groups can be manually input (default S3 method) or inferred from the model (S3 &quot;formula&quot; method). Smoothing parameters are treated as variance components and estimated using REML/ML (gaussian) or Laplace approximation to ML (others).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammi(x, ...)

## Default S3 method:
gammi(x,
      y,
      group,
      family = gaussian,
      fixed = NULL,
      random = NULL,
      data = NULL,
      REML = TRUE,
      control = NULL,
      start = NULL,
      verbose = 0L,
      nAGQ = 10L,
      subset, 
      weights, 
      na.action, 
      offset, 
      mustart, 
      etastart,
      ...)

## S3 method for class 'formula'
gammi(formula, 
      data, 
      family = gaussian,
      fixed = NULL, 
      random = NULL, 
      REML = TRUE,
      control = NULL,
      start = NULL,
      verbose = 0L,
      nAGQ = 10L,
      subset, 
      weights, 
      na.action, 
      offset, 
      mustart, 
      etastart,
      ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammi_+3A_x">x</code></td>
<td>

<p>Model (design) matrix of dimension <code>nobs</code> by <code>nvars</code> (<code class="reqn">n \times p</code>).
</p>
</td></tr>
<tr><td><code id="gammi_+3A_y">y</code></td>
<td>

<p>Response vector of length <code class="reqn">n</code>. 
</p>
</td></tr>
<tr><td><code id="gammi_+3A_group">group</code></td>
<td>

<p>Group label vector (factor, character, or integer) of length <code class="reqn">p</code>. Predictors with the same label are assumed to have the same variance parameter.
</p>
</td></tr>
<tr><td><code id="gammi_+3A_formula">formula</code></td>
<td>

<p>Model formula: a symbolic description of the model to be fitted. Uses the same syntax as <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+glm">glm</a></code>. 
</p>
</td></tr>
<tr><td><code id="gammi_+3A_family">family</code></td>
<td>

<p>Assumed exponential <code><a href="stats.html#topic+family">family</a></code> (and link function) for the response variable.  
</p>
</td></tr>
<tr><td><code id="gammi_+3A_fixed">fixed</code></td>
<td>

<p>For default method: a character vector specifying which <code>group</code> labels should be treated as fixed effects. For formula method: a one-sided formula specifying the fixed effects model structure. 
</p>
</td></tr>
<tr><td><code id="gammi_+3A_random">random</code></td>
<td>

<p>A one-sided formula specifying the random effects structure using <b>lme4</b> syntax. See Note.  
</p>
</td></tr>
<tr><td><code id="gammi_+3A_data">data</code></td>
<td>

<p>Optional data frame containing the variables referenced in <code>formula</code>, <code>fixed</code>, and/or <code>random</code>.
</p>
</td></tr>
<tr><td><code id="gammi_+3A_reml">REML</code></td>
<td>

<p>Logical indicating whether REML versus ML should be used to tune the smoothing parameters and variance components.
</p>
</td></tr>
<tr><td><code id="gammi_+3A_control">control</code></td>
<td>

<p>List containing the control parameters (output from <code><a href="lme4.html#topic+lmerControl">lmerControl</a></code> or <code><a href="lme4.html#topic+glmerControl">glmerControl</a></code>).
</p>
</td></tr>
<tr><td><code id="gammi_+3A_start">start</code></td>
<td>

<p>List (with names) of starting parameter values for model parameters.
</p>
</td></tr>
<tr><td><code id="gammi_+3A_verbose">verbose</code></td>
<td>

<p>Postive integer that controls the level of output displayed during optimization.
</p>
</td></tr>
<tr><td><code id="gammi_+3A_nagq">nAGQ</code></td>
<td>

<p>Numer of adaptive Gaussian quadrature points. Only used for non-Gaussian responses with a single variance component.
</p>
</td></tr>
<tr><td><code id="gammi_+3A_subset">subset</code></td>
<td>

<p>Optional expression indicating the subset of rows to use for the fitting (defaults to all rows).
</p>
</td></tr>
<tr><td><code id="gammi_+3A_weights">weights</code></td>
<td>

<p>Optional vector indicating prior observations weights for the fitting (defaults to all ones).
</p>
</td></tr>
<tr><td><code id="gammi_+3A_na.action">na.action</code></td>
<td>

<p>Function that indicates how <code>NA</code> data should be dealt with. Default (of <code>na.omit</code>) will omit any observations with missing data on any variable.
</p>
</td></tr>
<tr><td><code id="gammi_+3A_offset">offset</code></td>
<td>

<p>Optional vector indicating each observation's offset for the fitting (defaults to all zeros).
</p>
</td></tr>
<tr><td><code id="gammi_+3A_mustart">mustart</code></td>
<td>

<p>Optional starting values for the mean (fitted values).
</p>
</td></tr>
<tr><td><code id="gammi_+3A_etastart">etastart</code></td>
<td>

<p>Optional starting values for the linear predictors.
</p>
</td></tr>
<tr><td><code id="gammi_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to the <code><a href="#topic+spline.model.matrix">spline.model.matrix</a></code> function, e.g., spline <code>knots</code> or <code>df</code> for each term.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits a generalized additive mixed model (GAMM) of the form
</p>
<p style="text-align: center;"><code class="reqn">
g(\mu) = f(\mathbf{X}, \mathbf{Z}) + \mathbf{X}^\top \boldsymbol\beta + \mathbf{Z}^\top \boldsymbol\alpha
</code>
</p>

<p>where 
</p>

<ul>
<li> <p><code class="reqn">\mu = E(Y | \mathbf{X}, \mathbf{Z})</code> is the conditional expectation of the response <code class="reqn">Y</code> given the predictor vectors <code class="reqn">\mathbf{X} = (X_1, \ldots, X_p)^\top</code> and <code class="reqn">\mathbf{Z} = (Z_1, \ldots, Z_q)^\top</code>
</p>
</li>
<li><p> the function <code class="reqn">g(\cdot)</code> is a user-specified (invertible) link function
</p>
</li>
<li><p> the function <code class="reqn">f(\cdot)</code> is an unknown smooth function of the predictors (specified by <code>formula</code>)
</p>
</li>
<li><p> the vector <code class="reqn">\mathbf{X}</code> is the fixed effects component of the design (specified by <code>fixed</code>)
</p>
</li>
<li><p> the vector <code class="reqn">\mathbf{Z}</code> is the random effects component of the design (specified by <code>random</code>)
</p>
</li>
<li><p> the vector <code class="reqn">\boldsymbol\beta</code> contains the unknown fixed effects coefficients
</p>
</li>
<li><p> the vector <code class="reqn">\boldsymbol\alpha</code> contains the unknown Gaussian random effects
</p>
</li></ul>

<p>Note that the mean function <code class="reqn">f(\cdot)</code> can include main and/or interaction effects between any number of predictors. Furthermore, note that the fixed effects in <code class="reqn">\mathbf{X}^\top \boldsymbol\beta</code> and the random effects in <code class="reqn">\mathbf{Z}^\top \boldsymbol\alpha</code> are both optional.
</p>


<h3>Value</h3>

<p>An object of class <code>"gammi"</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>fitted.values</code></td>
<td>
<p>model predictions on the data scale</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>model predictions on the link scale</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>coefficients used to make the predictions</p>
</td></tr>
<tr><td><code>random.coefficients</code></td>
<td>
<p>coefficients corresponding to the <code>random</code> argument, i.e., the BLUPs.</p>
</td></tr>
<tr><td><code>term.labels</code></td>
<td>
<p>labels for the terms included in the <code>coefficients</code></p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>estimated dispersion parameter = <code>deviance/df.residual</code> when <code>is.null(random)</code></p>
</td></tr>
<tr><td><code>vcovchol</code></td>
<td>
<p>Cholesky factor of covariance matrix such that <code>tcrossprod(vcovchol)</code> gives the covariance matrix for the combined coefficient vector  <code>c(coefficients, random.coefficients)</code></p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>exponential family distribution (same as input)</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>log-likelihood for the solution</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC for the solution</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>model deviance, i.e., two times the negative log-likelihood</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>deviance of the null model, i.e., intercept only. Will be <code>NA</code> if the <code>random</code> argument is used.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>proportion of null deviance explained = <code>1 - deviance/null.deviance</code>. Will be <code>NA</code> if the <code>random</code> argument is used; see Note.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations used in fit</p>
</td></tr>
<tr><td><code>leverages</code></td>
<td>
<p>leverage scores for each observation</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>effective degrees of freedom = <code>sum(leverages)</code></p>
</td></tr>
<tr><td><code>df.random</code></td>
<td>
<p>degress of freedom corresponding to <code>random</code> formula, i.e., number of co/variance parameters</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>residual degrees of freedom = <code>nobs - edf</code></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>input <code>x</code> matrix (default method only)</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>character vector indicating which columns of <code>x</code> belong to which model terms</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>numeric vector giving the scale parameter used to z-score each term's data</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>fixed effects terms (default method) or formula (formula method); will be <code>NULL</code> if no fixed terms are included</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>random effects formula</p>
</td></tr>
<tr><td><code>mer</code></td>
<td>
<p>object of class <code>"merMod"</code>, such as output by <a href="lme4.html#topic+lmer">lmer</a>, with model fit information on a standardized scale</p>
</td></tr>
<tr><td><code>VarCorr</code></td>
<td>
<p>data frame with variance and covariance parameter estimates from <code>mer</code> transformed back to the original scale</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>input data</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>list of contrasts applied to <code>fixed</code> terms; will be <code>NULL</code> if no fixed terms are included</p>
</td></tr>
<tr><td><code>spline.info</code></td>
<td>
<p>list of spline parameters for terms in <code>x</code> or <code>formula</code></p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>input model formula</p>
</td></tr>
</table>


<h3>Random Syntax</h3>

<p>The <code>random</code> argument uses standard <a href="lme4.html#topic+lmer">lmer</a> syntax:
</p>

<ul>
<li> <p><code>(1 | g)</code> for a random intercept for each level of <code>g</code>
</p>
</li>
<li> <p><code>(1 | g1) + (1 | g2)</code> for random intercepts for g1 and g2
</p>
</li>
<li> <p><code>(1 | g1/g2) = (1 | g1) + (1 | g1:g2)</code> for random intercepts for g1 and g2 nested within g1
</p>
</li>
<li> <p><code>(x | g) = (1 + x | g)</code> for a correlated random intercept and slope of x for each level of <code>g</code>
</p>
</li>
<li> <p><code>(x || g) = (1 | g) + (0 + x | g)</code> for an uncorrelated random intercept and slope of x for each level of <code>g</code>
</p>
</li></ul>



<h3>Warning</h3>

<p>For stable computation, any terms entered through <code>x</code> (default method) or <code>formula</code> and/or <code>fixed</code> (formula method) are z-scored prior to fitting the model. Note that terms entered through <code>random</code> are not standardized. 
</p>
<p>The <code>"mer"</code> component of the output contains the model fitting results for a z-scored version of the original data (i.e., this fit is on a different scale). Consequently, the <code>"mer"</code> component should <b>not</b> be used for prediction and/or inference purposes. All prediction and inference should be conducted using the plot, predict, and summary methods mentioned in the &lsquo;See Also&rsquo; section.
</p>
<p>The <code>"VarCorr"</code> component contains the estimated variance/covariance parameters transformed back to the original scale.
</p>


<h3>Note</h3>

<p>The model R-squared is the proportion of the null deviance that is explained by the model, i.e.,
</p>
<p><code>r.squared = 1 - deviance / null.deviance</code>
</p>
<p>where <code>deviance</code> is the deviance of the model, and <code>null.deviance</code> is the deviance of the null model. 
</p>
<p>When the <code>random</code> argument is used, <code>null.deviance</code> and <code>r.squared</code> will be <code>NA</code>. This is because there is not an obvious null model when random effects are included, e.g., should the null model include or exclude the random effects? Assuming that is it possible to define a reasonable <code>null.deviance</code> in such cases, the above formula can be applied to calculate the model R-squared for models that contain random effects.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Bates, D., Maechler, M., Bolker, B., &amp; Walker, S. (2015). Fitting linear mixed-effects models using lme4. <em>Journal of Statistical Software, 67</em>(1), 1â€“48. <a href="https://doi.org/10.18637/jss.v067.i01">doi:10.18637/jss.v067.i01</a>
</p>
<p>Helwig, N. E. (2024). Precise tensor product smoothing via spectral splines. <em>Stats, 7</em>(1), 34-53, <a href="https://doi.org/10.3390/stats7010003">doi:10.3390/stats7010003</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.gammi">plot.gammi</a></code> for plotting effects from <code>gammi</code> objects
</p>
<p><code><a href="#topic+predict.gammi">predict.gammi</a></code> for predicting from <code>gammi</code> objects
</p>
<p><code><a href="#topic+summary.gammi">summary.gammi</a></code> for summarizing results from <code>gammi</code> objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############***##############   EXAM EXAMPLE   ##############***##############

# load 'gammi' package
library(gammi)

# load 'exam' help file
?exam

# load data
data(exam)

# header of data
head(exam)

# fit model
mod &lt;- gammi(Exam.score ~ VRQ.score, data = exam,
             random = ~ (1 | Primary.school) + (1 | Secondary.school))
             
# plot results
plot(mod)

# summarize results
summary(mod)





#############***#############   GAUSSIAN EXAMPLE   #############***#############

#~~~Example 1:  Single Predictor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# generate data
n &lt;- 1000
x &lt;- seq(0, 1, length.out = n)
fx &lt;- sin(2 * pi * x)
set.seed(1)
y &lt;- fx + rnorm(n)

# fit model via formula method
mod &lt;- gammi(y ~ x)
mod

# fit model via default method
modmat &lt;- spline.model.matrix(y ~ 0 + x)
tlabels &lt;- attr(modmat, "term.labels")
tassign &lt;- attr(modmat, "assign")
g &lt;- factor(tlabels[tassign], levels = tlabels)
mod0 &lt;- gammi(modmat, y, g)
mod0

# summarize fit model
summary(mod)

# plot function estimate
plot(mod)



#~~~Example 2:  Additive Model ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# mean function
eta &lt;- function(x, z, additive = TRUE){
  mx1 &lt;- cos(2 * pi * (x - pi))
  mx2 &lt;- 30 * (z - 0.6)^5
  mx12 &lt;- 0
  if(!additive) mx12 &lt;- sin(pi * (x - z))
  mx1 + mx2 + mx12
}

# generate data
set.seed(1)
n &lt;- 1000
x &lt;- runif(n)
z &lt;- runif(n)
fx &lt;- eta(x, z)
y &lt;- fx + rnorm(n)

# fit model via formula method
mod &lt;- gammi(y ~ x + z)
mod

# fit model via default method
modmat &lt;- spline.model.matrix(y ~ 0 + x + z)
tlabels &lt;- attr(modmat, "term.labels")
tassign &lt;- attr(modmat, "assign")
g &lt;- factor(tlabels[tassign], levels = tlabels)
mod0 &lt;- gammi(modmat, y, g)
mod0

# summarize fit model
summary(mod)

# plot function estimate
plot(mod)



#~~~Example 3:  Interaction Model ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# mean function
eta &lt;- function(x, z, additive = TRUE){
  mx1 &lt;- cos(2 * pi * (x - pi))
  mx2 &lt;- 30 * (z - 0.6)^5
  mx12 &lt;- 0
  if(!additive) mx12 &lt;- sin(pi * (x - z))
  mx1 + mx2 + mx12
}

# generate data
set.seed(1)
n &lt;- 1000
x &lt;- runif(n)
z &lt;- runif(n)
fx &lt;- eta(x, z, additive = FALSE)
y &lt;- fx + rnorm(n)

# fit model via formula method
mod &lt;- gammi(y ~ x * z)
mod

# fit model via default method
modmat &lt;- spline.model.matrix(y ~ 0 + x * z)
tlabels &lt;- attr(modmat, "term.labels")
tassign &lt;- attr(modmat, "assign")
g &lt;- factor(tlabels[tassign], levels = tlabels)
mod0 &lt;- gammi(modmat, y, g)
mod0

# summarize fit model
summary(mod)

# plot function estimate
plot(mod)



#~~~Example 4:  Random Intercept ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# mean function
eta &lt;- function(x, z, additive = TRUE){
  mx1 &lt;- cos(2 * pi * (x - pi))
  mx2 &lt;- 30 * (z - 0.6)^5
  mx12 &lt;- 0
  if(!additive) mx12 &lt;- sin(pi * (x - z))
  mx1 + mx2 + mx12
}

# generate mean function
set.seed(1)
n &lt;- 1000
nsub &lt;- 50
x &lt;- runif(n)
z &lt;- runif(n)
fx &lt;- eta(x, z)

# generate random intercepts
subid &lt;- factor(rep(paste0("sub", 1:nsub), n / nsub),
                levels = paste0("sub", 1:nsub))
u &lt;- rnorm(nsub, sd = sqrt(1/2))

# generate responses
y &lt;- fx + u[subid] + rnorm(n, sd = sqrt(1/2))

# fit model via formula method
mod &lt;- gammi(y ~ x + z, random = ~ (1 | subid))
mod

# fit model via default method
modmat &lt;- spline.model.matrix(y ~ 0 + x + z)
tlabels &lt;- attr(modmat, "term.labels")
tassign &lt;- attr(modmat, "assign")
g &lt;- factor(tlabels[tassign], levels = tlabels)
mod0 &lt;- gammi(modmat, y, g, random = ~ (1 | subid))
mod0

# summarize fit model
summary(mod)

# plot function estimate
plot(mod)




#############***#############   BINOMIAL EXAMPLE   #############***#############

#~~~Example 1:  Single Predictor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# generate data
n &lt;- 1000
x &lt;- seq(0, 1, length.out = n)
fx &lt;- sin(2 * pi * x)
set.seed(1)
y &lt;- rbinom(n = n, size = 1, prob = 1 / (1 + exp(-fx)))

# fit model
mod &lt;- gammi(y ~ x, family = binomial)
mod

# summarize fit model
summary(mod)

# plot function estimate
plot(mod)



#~~~Example 2:  Additive Model ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# mean function
eta &lt;- function(x, z, additive = TRUE){
  mx1 &lt;- cos(2 * pi * (x - pi))
  mx2 &lt;- 30 * (z - 0.6)^5
  mx12 &lt;- 0
  if(!additive) mx12 &lt;- sin(pi * (x - z))
  mx1 + mx2 + mx12
}

# generate data
set.seed(1)
n &lt;- 1000
x &lt;- runif(n)
z &lt;- runif(n)
fx &lt;- 1 + eta(x, z)
y &lt;- rbinom(n = n, size = 1, prob = 1 / (1 + exp(-fx)))

# fit model
mod &lt;- gammi(y ~ x + z, family = binomial)
mod

# summarize fit model
summary(mod)

# plot function estimate
plot(mod)



#~~~Example 3:  Interaction Model ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# mean function
eta &lt;- function(x, z, additive = TRUE){
  mx1 &lt;- cos(2 * pi * (x - pi))
  mx2 &lt;- 30 * (z - 0.6)^5
  mx12 &lt;- 0
  if(!additive) mx12 &lt;- sin(pi * (x - z))
  mx1 + mx2 + mx12
}

# generate data
set.seed(1)
n &lt;- 1000
x &lt;- runif(n)
z &lt;- runif(n)
fx &lt;- eta(x, z, additive = FALSE)
y &lt;- rbinom(n = n, size = 1, prob = 1 / (1 + exp(-fx)))

# fit model
mod &lt;- gammi(y ~ x * z, family = binomial)
mod

# summarize fit model
summary(mod)

# plot function estimate
plot(mod)



#~~~Example 4:  Random Intercept ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# mean function
eta &lt;- function(x, z, additive = TRUE){
  mx1 &lt;- cos(2 * pi * (x - pi))
  mx2 &lt;- 30 * (z - 0.6)^5
  mx12 &lt;- 0
  if(!additive) mx12 &lt;- sin(pi * (x - z))
  mx1 + mx2 + mx12
}

# generate mean function
set.seed(1)
n &lt;- 1000
nsub &lt;- 50
x &lt;- runif(n)
z &lt;- runif(n)
fx &lt;- 1 + eta(x, z)

# generate random intercepts
subid &lt;- factor(rep(paste0("sub", 1:nsub), n / nsub),
                levels = paste0("sub", 1:nsub))
u &lt;- rnorm(nsub, sd = sqrt(1/2))

# generate responses
y &lt;- rbinom(n = n, size = 1, prob = 1 / (1 + exp(-(fx+u[subid]))))

# fit model
mod &lt;- gammi(y ~ x + z, random = ~ (1 | subid), family = binomial)
mod

# summarize fit model
summary(mod)

# plot function estimate
plot(mod)


</code></pre>

<hr>
<h2 id='plot.gammi'>
Plot Method for gammi Fits
</h2><span id='topic+plot.gammi'></span>

<h3>Description</h3>

<p>Plots main and interaction effects from a fit gammi object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gammi'
plot(x, terms = x$term.labels, conf.int = TRUE, n = 400,
     intercept = FALSE, random = TRUE, ask = dev.interactive(), 
     xlab = NULL, ylab = NULL, zlab = NULL, main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gammi_+3A_x">x</code></td>
<td>

<p>Object of class &quot;gammi&quot;
</p>
</td></tr>
<tr><td><code id="plot.gammi_+3A_terms">terms</code></td>
<td>

<p>Which model term(s) should be plotted? Default plots all terms.
</p>
</td></tr>
<tr><td><code id="plot.gammi_+3A_conf.int">conf.int</code></td>
<td>

<p>Should a 95% confidence interval be added to the plot(s)?
</p>
</td></tr>
<tr><td><code id="plot.gammi_+3A_n">n</code></td>
<td>

<p>Number of points used to plot each of the (continuous) terms.
</p>
</td></tr>
<tr><td><code id="plot.gammi_+3A_intercept">intercept</code></td>
<td>

<p>Should the intercept be added to the y-axis of the plot(s)?
</p>
</td></tr>
<tr><td><code id="plot.gammi_+3A_random">random</code></td>
<td>

<p>Should Q-Q plots of the random coefficients be produced?  
</p>
</td></tr>
<tr><td><code id="plot.gammi_+3A_ask">ask</code></td>
<td>

<p>Should the user be asked before each plot is produced?  
</p>
</td></tr>
<tr><td><code id="plot.gammi_+3A_xlab">xlab</code></td>
<td>

<p>Optional x-axis label for plot(s).
</p>
</td></tr>
<tr><td><code id="plot.gammi_+3A_ylab">ylab</code></td>
<td>

<p>Optional y-axis label for plot(s).
</p>
</td></tr>
<tr><td><code id="plot.gammi_+3A_zlab">zlab</code></td>
<td>

<p>Optional z-axis label for plot(s).
</p>
</td></tr>
<tr><td><code id="plot.gammi_+3A_main">main</code></td>
<td>

<p>Optional title for plot(s).
</p>
</td></tr>
<tr><td><code id="plot.gammi_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to internal plotting functions.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default use plots each effect function along with a 95% confidence interval (if applicable). Line plots are used for continuous predictors, bar plots are used for categorical predictors, Q-Q plots are used for random effects, and image plots are used for two-way interactions. The <code>visualizer1</code> and <code>visualizer2</code> functions are used to plot main and interaction effects, respectively.
</p>


<h3>Value</h3>

<p>A plot is produced and nothing is returned.
</p>


<h3>Note</h3>

<p>Three-way and higher-order interactions are not currently supported. 
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E. (2024). Precise tensor product smoothing via spectral splines. <em>Stats, 7</em>(1), 34-53, <a href="https://doi.org/10.3390/stats7010003">doi:10.3390/stats7010003</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gammi">gammi</a></code> for fitting generalized additive mixed models
</p>
<p><code><a href="#topic+predict.gammi">predict.gammi</a></code> for predicting from <code>gammi</code> objects
</p>
<p><code><a href="#topic+summary.gammi">summary.gammi</a></code> for summarizing results from <code>gammi</code> objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load 'gammi' package
library(gammi)

# load data
data(exam)

# header of data
head(exam)

# fit model
mod &lt;- gammi(Exam.score ~ VRQ.score, data = exam,
             random = ~ (1 | Primary.school) + (1 | Secondary.school))
       
# plot terms
plot(mod)

# refit model with Secondary.school as penalized nominal effect
mod &lt;- gammi(Exam.score ~ Secondary.school + VRQ.score, data = exam,
             random = ~ (1 | Primary.school))
             
# plot terms
plot(mod)
</code></pre>

<hr>
<h2 id='predict.gammi'>
Predict Method for gammi Fits
</h2><span id='topic+predict.gammi'></span>

<h3>Description</h3>

<p>Obtain predictions from a fit generalized additive mixed model (gammi) object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gammi'
predict(object, 
        newx,
        newdata, 
        se.fit = FALSE,
        type = c("link", "response", "terms"),
        conf.int = FALSE, 
        conf.level = 0.95,
        ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.gammi_+3A_object">object</code></td>
<td>

<p>Object of class &quot;gammi&quot;
</p>
</td></tr>
<tr><td><code id="predict.gammi_+3A_newx">newx</code></td>
<td>

<p>Matrix of new <code>x</code> scores for prediction (default S3 method). Must have <code class="reqn">p</code> columns arranged in the same order as the <code>x</code> matrix used to fit the model.
</p>
</td></tr>
<tr><td><code id="predict.gammi_+3A_newdata">newdata</code></td>
<td>

<p>Data frame of new data scores for prediction (S3 &quot;formula&quot; method). Must contain all variables in the <code>formula</code> (and <code>fixed</code> formula if applicable) used to fit the model.
</p>
</td></tr>
<tr><td><code id="predict.gammi_+3A_se.fit">se.fit</code></td>
<td>

<p>Logical indicating whether standard errors of predictions should be returned.
</p>
</td></tr>
<tr><td><code id="predict.gammi_+3A_type">type</code></td>
<td>

<p>Type of prediction to return: link = linear prediction, response = fitted value, and terms = matrix where each columns contains each term's linear predictor contribution.
</p>
</td></tr>
<tr><td><code id="predict.gammi_+3A_conf.int">conf.int</code></td>
<td>

<p>Logical indicating whether confidence intervals for predictions should be returned.
</p>
</td></tr>
<tr><td><code id="predict.gammi_+3A_conf.level">conf.level</code></td>
<td>

<p>Scalar between 0 and 1 controlling the confidence level for the interval. Ignored if <code>conf.int = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="predict.gammi_+3A_...">...</code></td>
<td>

<p>Additional arugments (ignored).  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default of <code>type = "link"</code> returns the model implied linear predictor corresponding to <code>newx</code> or <code>newdata</code>, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">g(\hat{\boldsymbol\mu}_{\theta (\mathrm{new}) }) = \hat{f}_\theta(\mathbf{X}_\mathrm{new}, \mathbf{Z}_\mathrm{new}) + \mathbf{X}_\mathrm{new}^\top \hat{\boldsymbol\beta}_\theta</code>
</p>

<p>where <code class="reqn">\hat{f}_\theta(\cdot)</code> is the estimated smooth function (with the subscript of <code class="reqn">\theta</code> denoting the dependence on the variance parameters), and <code class="reqn">\hat{\boldsymbol\beta}_\theta</code> are the fixed effect estimates (if applicable). Note that <code class="reqn">\mathbf{X}_\mathrm{new}</code> and <code class="reqn">\mathbf{Z}_\mathrm{new}</code> denote the new data at which the predictions will be formed.
</p>
<p>Using <code>type = "response"</code> returns the predictions on the fitted value scale, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">\hat{\boldsymbol\mu}_{\theta (\mathrm{new})} = g^{-1} \left( \hat{f}_\theta(\mathbf{X}_\mathrm{new}, \mathbf{Z}_\mathrm{new}) + \mathbf{X}_\mathrm{new}^\top \hat{\boldsymbol\beta}_\theta \right)</code>
</p>

<p>where <code class="reqn">g^{-1}(\cdot)</code> denotes the inverse of the chosen link function.
</p>
<p>Using <code>type = "terms"</code> returns a matrix where each column contains the linear predictor contribution for a different model term, i.e., the <code class="reqn">k</code>-th column contains
</p>
<p style="text-align: center;"><code class="reqn">\hat{f}_{\theta k}(\mathbf{X}_\mathrm{new}, \mathbf{Z}_\mathrm{new}) + \mathbf{X}_{\mathrm{new} k }^\top \hat{\boldsymbol\beta}_{\theta k}</code>
</p>

<p>where <code class="reqn">\hat{f}_{\theta k}</code> is the <code class="reqn">k</code>-th additive function, i.e., <code class="reqn">\hat{f}_\theta(\mathbf{X}_\mathrm{new}, \mathbf{Z}_\mathrm{new}) = \sum_{k=1}^K \hat{f}_{\theta k}(\mathbf{X}_\mathrm{new}, \mathbf{Z}_\mathrm{new})</code> and the second term denotes the (optional) fixed-effect contribution for the <code class="reqn">k</code>-th term, i.e., <code class="reqn">\mathbf{X}_\mathrm{new}^\top \hat{\boldsymbol\beta}_\theta = \sum_{k=1}^K \mathbf{X}_{\mathrm{new} k }^\top \hat{\boldsymbol\beta}_{\theta k}</code>
</p>


<h3>Value</h3>

<p>If <code>type = "link"</code> or <code>type = "response"</code>, returns either a vector (of predictions corresponding to the new data) or a data frame that contains the predictions, along with their standard errors and/or confidence interval endpoints (as controlled by <code>se.fit</code> and <code>conf.int</code> arguments).
</p>
<p>If <code>type = "terms"</code>, returns either a matrix (with columns containing predictions for each term) or a list that contains the term-wise predictions, along with their standard errors and/or confidence interval endpoints (as controlled by <code>se.fit</code> and <code>conf.int</code> arguments).
</p>


<h3>Note</h3>

<p>Terms entered through the <code>random</code> argument of the <code><a href="#topic+gammi">gammi</a></code> function are <b>not</b> included as a part of predictions.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E. (2024). Precise tensor product smoothing via spectral splines. <em>Stats, 7</em>(1), 34-53, <a href="https://doi.org/10.3390/stats7010003">doi:10.3390/stats7010003</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gammi">gammi</a></code> for fitting generalized additive mixed models
</p>
<p><code><a href="#topic+plot.gammi">plot.gammi</a></code> for plotting effects from <code>gammi</code> objects
</p>
<p><code><a href="#topic+summary.gammi">summary.gammi</a></code> for summarizing results from <code>gammi</code> objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load 'gammi' package
library(gammi)

# mean function
eta &lt;- function(x, z, additive = TRUE){
  mx1 &lt;- cos(2 * pi * (x - pi))
  mx2 &lt;- 30 * (z - 0.6)^5
  mx12 &lt;- 0
  if(!additive) mx12 &lt;- sin(pi * (x - z))
  mx1 + mx2 + mx12
}

# generate mean function
set.seed(1)
n &lt;- 1000
nsub &lt;- 50
x &lt;- runif(n)
z &lt;- runif(n)
fx &lt;- eta(x, z)

# generate random intercepts
subid &lt;- factor(rep(paste0("sub", 1:nsub), n / nsub),
                levels = paste0("sub", 1:nsub))
u &lt;- rnorm(nsub, sd = sqrt(1/2))

# generate responses
y &lt;- fx + u[subid] + rnorm(n, sd = sqrt(1/2))

# fit model via formula method
mod &lt;- gammi(y ~ x + z, random = ~ (1 | subid))
mod

# get fitted values via predict
fit &lt;- predict(mod, newdata = data.frame(x = x, z = z))
max(abs(fit - mod$fitted.values))

# get fitted values with SE and CI
fit &lt;- predict(mod, newdata = data.frame(x = x, z = z), conf.int = TRUE)
head(fit)

# get fitted values with SE and CI for each term
fit &lt;- predict(mod, newdata = data.frame(x = x, z = z), 
               type = "terms", conf.int = TRUE)
str(fit)                                  # list with 4 components
head(sapply(fit, function(x) x[,1]))      # for x effect
head(sapply(fit, function(x) x[,2]))      # for z effect
</code></pre>

<hr>
<h2 id='spline.basis'>
Spectral Spline Basis
</h2><span id='topic+spline.basis'></span>

<h3>Description</h3>

<p>Generate a spectral spline basis matrix for a nominal, ordinal, or polynomial smoothing spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline.basis(x, df = NULL, knots = NULL, m = NULL, intercept = FALSE, 
             Boundary.knots = NULL, warn.outside = TRUE, 
             periodic = FALSE, xlev = levels(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spline.basis_+3A_x">x</code></td>
<td>

<p>the predictor vector of length <code>n</code>. Can be a factor, integer, or numeric, see Note.
</p>
</td></tr>
<tr><td><code id="spline.basis_+3A_df">df</code></td>
<td>

<p>the degrees of freedom, i.e., number of knots to place at quantiles of <code>x</code>. Defaults to 10 but ignored if <code>knots</code> are provided.
</p>
</td></tr>
<tr><td><code id="spline.basis_+3A_knots">knots</code></td>
<td>

<p>the breakpoints (knots) defining the spline. If <code>knots</code> are provided, the <code>df</code> is defined as <code>length(unique(c(knots, Boundary.knots)))</code>.
</p>
</td></tr>
<tr><td><code id="spline.basis_+3A_m">m</code></td>
<td>

<p>the derivative penalty order: 0 = ordinal spline, 1 = linear spline, 2 = cubic spline, 3 = quintic spline
</p>
</td></tr>
<tr><td><code id="spline.basis_+3A_intercept">intercept</code></td>
<td>

<p>should an intercept be included in the basis?  
</p>
</td></tr>
<tr><td><code id="spline.basis_+3A_boundary.knots">Boundary.knots</code></td>
<td>

<p>the boundary points for spline basis. Defaults to <code>range(x)</code>.
</p>
</td></tr>
<tr><td><code id="spline.basis_+3A_warn.outside">warn.outside</code></td>
<td>

<p>if <code>TRUE</code>, a warning is provided when <code>x</code> values are outside of the <code>Boundary.knots</code>
</p>
</td></tr>
<tr><td><code id="spline.basis_+3A_periodic">periodic</code></td>
<td>

<p>should the spline basis functions be constrained to be periodic with respect to the <code>Boundary.knots</code>?
</p>
</td></tr>
<tr><td><code id="spline.basis_+3A_xlev">xlev</code></td>
<td>

<p>levels of <code>x</code> (only applicable if <code>x</code> is a <code><a href="base.html#topic+factor">factor</a></code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a reproduction of the <code><a href="grpnet.html#topic+rk">rk</a></code> function in the <b>grpnet</b> package (Helwig, 2024b). 
</p>
<p>Given a vector of function realizations <code class="reqn">f</code>, suppose that <code class="reqn">f = X \beta</code>, where <code class="reqn">X</code> is the (unregularized) spline basis and <code class="reqn">\beta</code> is the coefficient vector. Let <code class="reqn">Q</code> denote the postive semi-definite penalty matrix, such that <code class="reqn">\beta^\top Q \beta</code> defines the roughness penalty for the spline. See Helwig (2017) for the form of <code class="reqn">X</code> and <code class="reqn">Q</code> for the various types of splines.
</p>
<p>Consider the spectral parameterization of the form <code class="reqn">f = Z \alpha</code> where
</p>
<p style="text-align: center;"><code class="reqn">Z = X Q^{-1/2}</code>
</p>

<p>is the regularized spline basis (that is returned by this function), and <code class="reqn">\alpha = Q^{1/2} \beta</code> are the reparameterized coefficients. Note that <code class="reqn">X \beta = Z \alpha</code> and <code class="reqn">\beta^\top Q \beta = \alpha^\top \alpha</code>, so the spectral parameterization absorbs the penalty into the coefficients (see Helwig, 2021, 2024).
</p>
<p>Syntax of this function is designed to mimic the syntax of the <code><a href="splines.html#topic+bs">bs</a></code> function.
</p>


<h3>Value</h3>

<p>Returns a basis function matrix of dimension <code>n</code> by <code>df</code> (plus 1 if an <code>intercept</code> is included) with the following attributes:
</p>
<table role = "presentation">
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>knots for spline basis</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>derivative penalty order</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>was an intercept included?</p>
</td></tr>
<tr><td><code>Boundary.knots</code></td>
<td>
<p>boundary points of <code>x</code></p>
</td></tr>
<tr><td><code>periodic</code></td>
<td>
<p>is the basis periodic?</p>
</td></tr>
<tr><td><code>xlev</code></td>
<td>
<p>factor levels (if applicable)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The (default) type of spline basis depends on the <code><a href="base.html#topic+class">class</a></code> of the input <code>x</code> object:
</p>
<p>* If <code>x</code> is an unordered factor, then a nominal spline basis is used
</p>
<p>* If <code>x</code> is an ordered factor (and <code>m = NULL</code>), then an ordinal spline basis is used
</p>
<p>* If <code>x</code> is an integer or numeric (and <code>m = NULL</code>), then a cubic spline basis is used
</p>
<p>Note that you can override the default behavior by specifying the <code>m</code> argument.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E. (2021). Spectrally sparse nonparametric regression via elastic net regularized smoothers. <em>Journal of Computational and Graphical Statistics, 30</em>(1), 182-191. <a href="https://doi.org/10.1080/10618600.2020.1806855">doi:10.1080/10618600.2020.1806855</a>
</p>
<p>Helwig, N. E. (2024a). Precise tensor product smoothing via spectral splines. <em>Stats, 7</em>(1), 34-53, <a href="https://doi.org/10.3390/stats7010003">doi:10.3390/stats7010003</a>
</p>
<p>Helwig, N. E. (2024b). grpnet: Group Elastic Net Regularized GLMs and GAMs. R package version 0.4. <a href="https://doi.org/10.32614/CRAN.package.grpnet">doi:10.32614/CRAN.package.grpnet</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spline.model.matrix">spline.model.matrix</a></code> for building model matrices using tensor products of spline bases
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######***######   LOAD GAMMI PACKAGE   ######***######
library(gammi)


######***######   NOMINAL SPLINE BASIS   ######***######

x &lt;- as.factor(LETTERS[1:5])
basis &lt;- spline.basis(x)
plot(1:5, basis[,1], t = "l", ylim = extendrange(basis))
for(j in 2:ncol(basis)){
  lines(1:5, basis[,j], col = j)
}


######***######   ORDINAL SPLINE BASIS   ######***######

x &lt;- as.ordered(LETTERS[1:5])
basis &lt;- spline.basis(x)
plot(1:5, basis[,1], t = "l", ylim = extendrange(basis))
for(j in 2:ncol(basis)){
  lines(1:5, basis[,j], col = j)
}


######***######   LINEAR SPLINE BASIS   ######***######

x &lt;- seq(0, 1, length.out = 101)
basis &lt;- spline.basis(x, df = 5, m = 1)
plot(x, basis[,1], t = "l", ylim = extendrange(basis))
for(j in 2:ncol(basis)){
  lines(x, basis[,j], col = j)
}


######***######   CUBIC SPLINE BASIS   ######***######

x &lt;- seq(0, 1, length.out = 101)
basis &lt;- spline.basis(x, df = 5)
basis &lt;- scale(basis)  # for visualization only!
plot(x, basis[,1], t = "l", ylim = extendrange(basis))
for(j in 2:ncol(basis)){
  lines(x, basis[,j], col = j)
}


######***######   QUINTIC SPLINE BASIS   ######***######

x &lt;- seq(0, 1, length.out = 101)
basis &lt;- spline.basis(x, df = 5, m = 3)
basis &lt;- scale(basis)  # for visualization only!
plot(x, basis[,1], t = "l", ylim = extendrange(basis))
for(j in 2:ncol(basis)){
  lines(x, basis[,j], col = j)
}
</code></pre>

<hr>
<h2 id='spline.model.matrix'>
Construct Design Matrices via Spectral Splines
</h2><span id='topic+spline.model.matrix'></span><span id='topic+rowKronecker'></span>

<h3>Description</h3>

<p>Creates a design (or model) matrix using the <code><a href="#topic+spline.basis">spline.basis</a></code> function to expand variables via a spectral spline basis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline.model.matrix(object, data, ...)

rowKronecker(X, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spline.model.matrix_+3A_object">object</code></td>
<td>

<p>a <code><a href="stats.html#topic+formula">formula</a></code> or <code><a href="stats.html#topic+terms">terms</a></code> object describing the fit model
</p>
</td></tr>
<tr><td><code id="spline.model.matrix_+3A_data">data</code></td>
<td>

<p>a data frame containing the variables referenced in <code>object</code>
</p>
</td></tr>
<tr><td><code id="spline.model.matrix_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the <code><a href="#topic+spline.basis">spline.basis</a></code> function, e.g., <code>df</code>, <code>knots</code>, <code>m</code>, etc. Arguments must be passed as a named list, see Examples.
</p>
</td></tr>
<tr><td><code id="spline.model.matrix_+3A_x">X</code></td>
<td>

<p>matrix of dimension <code class="reqn">n \times p</code>  
</p>
</td></tr>
<tr><td><code id="spline.model.matrix_+3A_y">Y</code></td>
<td>

<p>matrix of dimension <code class="reqn">n \times q</code>  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a reproduction of the <code><a href="grpnet.html#topic+rk.model.matrix">rk.model.matrix</a></code> function in the <b>grpnet</b> package (Helwig, 2024b). 
</p>
<p>Designed to be a more flexible alternative to the <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> function. The <code><a href="#topic+spline.basis">spline.basis</a></code> function is used to construct a marginal basis for each variable that appears in the input <code>object</code>. Tensor product interactions are formed by taking a rowwise Kronecker product of marginal basis matrices. Interactions of any order are supported using standard formulaic conventions, see Note.
</p>


<h3>Value</h3>

<p>The design matrix corresponding to the input formula and data, which has the following attributes:
</p>
<table role = "presentation">
<tr><td><code>assign</code></td>
<td>
<p>an integer vector with an entry for each column in the matrix giving the term in the formula which gave rise to the column</p>
</td></tr>
<tr><td><code>term.labels</code></td>
<td>
<p>a character vector containing the labels for each of the terms in the model</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>a named list giving the knots used for each variable in the formula</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>a named list giving the penalty order used for each variable in the formula</p>
</td></tr>
<tr><td><code>periodic</code></td>
<td>
<p>a named list giving the periodicity used for each variable in the formula</p>
</td></tr>
<tr><td><code>xlev</code></td>
<td>
<p>a named list giving the factor levels used for each variable in the formula</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For formulas of the form <code>y ~ x + z</code>, the constructed model matrix has the form <code>cbind(spline.basis(x), spline.basis(z))</code>, which simply concatenates the two marginal basis matrices. For formulas of the form <code>y ~ x : z</code>, the constructed model matrix has the form <code>rowKronecker(spline.basis(x), spline.basis(z))</code>, where <code><a href="#topic+rowKronecker">rowKronecker</a></code> denotes the row-wise kronecker product. The formula <code>y ~ x * z</code> is a shorthand for <code>y ~ x + z + x : z</code>, which concatenates the two previous results. Unless it is suppressed (using <code>0+</code>), the first column of the basis will be a column of ones named <code>(Intercept)</code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E. (2021). Spectrally sparse nonparametric regression via elastic net regularized smoothers. <em>Journal of Computational and Graphical Statistics, 30</em>(1), 182-191. <a href="https://doi.org/10.1080/10618600.2020.1806855">doi:10.1080/10618600.2020.1806855</a>
</p>
<p>Helwig, N. E. (2024a). Precise tensor product smoothing via spectral splines. <em>Stats, 7</em>(1), 34-53, <a href="https://doi.org/10.3390/stats7010003">doi:10.3390/stats7010003</a>
</p>
<p>Helwig, N. E. (2024b). grpnet: Group Elastic Net Regularized GLMs and GAMs. R package version 0.4. <a href="https://doi.org/10.32614/CRAN.package.grpnet">doi:10.32614/CRAN.package.grpnet</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+spline.basis">spline.basis</a></code> for details on the spectral spline basis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load 'gammi' package
library(gammi)

# load data
data(exam)

# header of data
head(exam)

# make basis matrix 
x &lt;- spline.model.matrix(Exam.score ~ ., data = exam)

# check dimension (= 3435 by 178)
dim(x)

# check term labels
attr(x, "term.labels")

# check which columns of x belong to which terms
attr(x, "assign")             # note: 0 = (Intercept)
</code></pre>

<hr>
<h2 id='StartupMessage'>Startup Message for gammi</h2><span id='topic+StartupMessage'></span><span id='topic+gammiStartupMessage'></span>

<h3>Description</h3>

<p>Prints the startup message when gammi is loaded. Not intended to be called by the user.
</p>


<h3>Details</h3>

<p>The &lsquo;gammi&rsquo; ascii start-up message was created using the taag software.
</p>


<h3>References</h3>

<p>https://patorjk.com/software/taag/
</p>

<hr>
<h2 id='summary.gammi'>
Summary Method for gammi Fits
</h2><span id='topic+summary.gammi'></span>

<h3>Description</h3>

<p>Obtain summary statistics from a fit generalized additive mixed model (gammi) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gammi'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gammi_+3A_object">object</code></td>
<td>

<p>Object of class &quot;gammi&quot;
</p>
</td></tr>
<tr><td><code id="summary.gammi_+3A_...">...</code></td>
<td>

<p>Additional arguments (currently ignored)  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces significance testing and model diagnostic information. The significance tests use the Bayesian interpretation of a smoothing spline. The variable importance indices sum to 100 but can be negative for some terms. The variance inflation factors should ideally be 1 for all terms; values greater than 5 or 10 can indicate noteworthy multicollinearity.
</p>


<h3>Value</h3>

<p>An object of class &quot;summary.gammi&quot;, which is a list with components:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the model call, i.e., <code>object$call</code></p>
</td></tr>
<tr><td><code>term.labels</code></td>
<td>
<p>the model term labels (character vector)</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the exponential <code><a href="stats.html#topic+family">family</a></code> object</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>log-likelihood for the solution</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC for the solution</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the model deviance (numeric)</p>
</td></tr>
<tr><td><code>deviance.resid</code></td>
<td>
<p>the deviance residuals</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>the model R-squared (numeric); see Note</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the total degrees of freedom = <code>object$edf + object$df.random</code></p>
</td></tr>
<tr><td><code>significance</code></td>
<td>
<p>the signififance testing information (matrix)</p>
</td></tr>
<tr><td><code>importance</code></td>
<td>
<p>the variable importance information (numeric)</p>
</td></tr>
<tr><td><code>vif</code></td>
<td>
<p>the variance inflation factors (numeric)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The model R-squared is the proportion of the null deviance that is explained by the model, i.e.,
</p>
<p><code>r.squared = 1 - deviance / null.deviance</code>
</p>
<p>where <code>deviance</code> is the deviance of the model, and <code>null.deviance</code> is the deviance of the null model. 
</p>
<p>When the <code>random</code> argument is used, <code>null.deviance</code> and <code>r.squared</code> will be <code>NA</code>. This is because there is not an obvious null model when random effects are included, e.g., should the null model include or exclude the random effects? Assuming that is it possible to define a reasonable <code>null.deviance</code> in such cases, the above formula can be applied to calculate the model R-squared for models that contain random effects.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E. (2024). Precise tensor product smoothing via spectral splines. <em>Stats, 7</em>(1), 34-53, <a href="https://doi.org/10.3390/stats7010003">doi:10.3390/stats7010003</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gammi">gammi</a></code> for fitting generalized additive mixed models
</p>
<p><code><a href="#topic+plot.gammi">plot.gammi</a></code> for plotting effects from <code>gammi</code> objects
</p>
<p><code><a href="#topic+predict.gammi">predict.gammi</a></code> for predicting from <code>gammi</code> objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load 'gammi' package
library(gammi)

# load data
data(exam)

# header of data
head(exam)

# fit model
mod &lt;- gammi(Exam.score ~ VRQ.score, data = exam,
             random = ~ (1 | Primary.school) + (1 | Secondary.school))
       
# summarize results
summary(mod)

# refit model with Secondary.school as penalized nominal effect
mod &lt;- gammi(Exam.score ~ Secondary.school + VRQ.score, data = exam,
             random = ~ (1 | Primary.school))
             
# summarize results
summary(mod)
</code></pre>

<hr>
<h2 id='visualizers'>
Internal Functions for Plot Method
</h2><span id='topic+visualizer1'></span><span id='topic+visualizer2'></span>

<h3>Description</h3>

<p>Internal functions used by the <code><a href="#topic+plot.gammi">plot.gammi</a></code> function to visualize main effects and two-way interaction effects in fit <code>gammi</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualizer1(x, y, bars = FALSE, bw = 0.02, lty = 1, lwd = 2, col = "black", 
            lwr = NULL, upr = NULL, ci.lty = 2, ci.lwd = 1.25, ci.col = "black",
            zero = TRUE, zero.lty = 3, xlim = NULL, ylim = NULL, 
            xlab = NULL, ylab = NULL, main = NULL, add = FALSE, ...)
            
visualizer2(x, y, z, col = NULL, ncolor = 21,
            xlim = NULL, ylim = NULL, zlim = NULL, zline = 1.5,
            xlab = NULL, ylab = NULL, zlab = NULL, main = NULL, 
            xticks = NULL, xlabels = NULL, yticks = NULL, ylabels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="visualizers_+3A_x">x</code>, <code id="visualizers_+3A_y">y</code>, <code id="visualizers_+3A_z">z</code></td>
<td>

<p>For 1D plots: <code>x</code> and <code>y</code> are the primary inputs to the <code><a href="base.html#topic+plot">plot</a></code> function. For 2D plots: these are the primary inputs to the <code><a href="graphics.html#topic+image">image</a></code> function.
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_bars">bars</code></td>
<td>

<p>For 1D plots: logical indicating whether to create a line plot (default) or a bar plot (<code>bars = TRUE</code>).
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_bw">bw</code></td>
<td>

<p>For 1D plots: width of the bars relative to range of <code>x</code> (ignored if <code>bars = FALSE</code>).
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_lty">lty</code>, <code id="visualizers_+3A_lwd">lwd</code></td>
<td>

<p>For 1D plots: line type and width for 1D plots.
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_col">col</code></td>
<td>

<p>For 1D plots: single color for line/bar plot. For 2D plots: vector of colors for image plot.
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_ncolor">ncolor</code></td>
<td>

<p>For 2D plots: number of colors used for image plot and color legend, see Note.
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_lwr">lwr</code>, <code id="visualizers_+3A_upr">upr</code></td>
<td>

<p>For 1D plots: number vectors defining the lower and upper bounds to plot for a confidence interval. Must be the same length as <code>x</code> and <code>y</code>.
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_ci.lty">ci.lty</code>, <code id="visualizers_+3A_ci.lwd">ci.lwd</code>, <code id="visualizers_+3A_ci.col">ci.col</code></td>
<td>

<p>For 1D plots: the type, width, and color for the confidence interval lines drawn from the <code>lwr</code> and <code>upr</code> arguments.
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_zero">zero</code>, <code id="visualizers_+3A_zero.lty">zero.lty</code></td>
<td>

<p>For 1D plots: <code>zero</code> is a logicical indicating whether a horizontal line at y = 0 should be included, and <code>zero.lty</code> controls the line type
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_xlim">xlim</code>, <code id="visualizers_+3A_ylim">ylim</code>, <code id="visualizers_+3A_zlim">zlim</code></td>
<td>

<p>For 1D plots: <code>xlim</code> and <code>ylim</code> are the axis limits input to the <code><a href="base.html#topic+plot">plot</a></code> function. For 2D plots: these are the axis limits input to the <code><a href="graphics.html#topic+image">image</a></code> function (note: <code>zlim</code> controls range for color legend).
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_xlab">xlab</code>, <code id="visualizers_+3A_ylab">ylab</code>, <code id="visualizers_+3A_zlab">zlab</code></td>
<td>

<p>For 1D plots: <code>xlab</code> and <code>ylab</code> are the axis labels input to the <code><a href="base.html#topic+plot">plot</a></code> function. For 2D plots: these are the axis labels input to the <code><a href="graphics.html#topic+image">image</a></code> function (note: <code>zlab</code> controls label for color legend).
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_main">main</code></td>
<td>

<p>Title of the plot.
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_add">add</code></td>
<td>

<p>Should lines/bars be added to current plot?
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_zline">zline</code></td>
<td>

<p>For 2D plots: margin line for the z-axis label.
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_xticks">xticks</code>, <code id="visualizers_+3A_yticks">yticks</code></td>
<td>

<p>For 2D plots: tick marks for x-axis and y-axis grid lines.
</p>
</td></tr>  
<tr><td><code id="visualizers_+3A_xlabels">xlabels</code>, <code id="visualizers_+3A_ylabels">ylabels</code></td>
<td>

<p>For 2D plots: labels corresponding to the input tick marks that define the grid lines.
</p>
</td></tr>
<tr><td><code id="visualizers_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to the <code><a href="base.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+image">image</a></code> functions.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>visualizer1</code> function is used to plot 1D (line/bar) plots, and the <code>visaulizer2</code> function is used to plot 2D (image) plots. These functions are not intended to be called by the user, but they may be useful for producing customized visualizations that are beyond the scope of the <code><a href="#topic+plot.gammi">plot.gammi</a></code> function.
</p>


<h3>Value</h3>

<p>A plot is produced and nothing is returned.
</p>


<h3>Note</h3>

<p>The vector of colors used to construct the plots is defined as <code>colorRampPalette(col)(ncolor)</code>, which interpolates a color palette of length <code>ncolor</code> from the input colors in the vector <code>col</code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E. (2024). Precise tensor product smoothing via spectral splines. <em>Stats, 7</em>(1), 34-53, <a href="https://doi.org/10.3390/stats7010003">doi:10.3390/stats7010003</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.gammi">plot.gammi</a></code> for plotting effects from <code>gammi</code> objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load 'gammi' package
library(gammi)

# load 'exam' help file
?exam

# load data
data(exam)

# header of data
head(exam)

# fit model
mod &lt;- gammi(Exam.score ~ VRQ.score, data = exam,
             random = ~ (1 | Primary.school) + (1 | Secondary.school))
             
# plot results (using S3 method)
plot(mod, include.random = FALSE)

# plot results (using visualizer)
xnew &lt;- seq(min(exam$VRQ.score), max(exam$VRQ.score), length.out = 400)
pred &lt;- predict(mod, newdata = data.frame(VRQ.score = xnew), 
                type = "terms", conf.int = TRUE)
visualizer1(x = xnew, y = pred$fit, lwr = pred$lwr, upr = pred$upr,
            xlab = "VRQ.score", ylab = "Exam.score", main = "VRQ.score effect")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
