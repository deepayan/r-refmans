<!DOCTYPE html><html lang="en"><head><title>Help for package IOHanalyzer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IOHanalyzer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IOHanalyzer'><p>IOHanalyzer: Data Analysis Part of IOHprofiler</p></a></li>
<li><a href='#+5B.DataSetList'><p>S3 extraction function for DataSetList</p></a></li>
<li><a href='#+3D+3D.DataSet'><p>S3 generic == operator for DataSets</p></a></li>
<li><a href='#arrange'><p>S3 sort function for DataSetList</p></a></li>
<li><a href='#as.character.DataSet'><p>S3 generic as.character operator for DataSet</p></a></li>
<li><a href='#AUC'><p>Area Under Curve (Empirical Cumulative Dsitribution Function)</p></a></li>
<li><a href='#bootstrap_RT'><p>Bootstrapping for running time samples</p></a></li>
<li><a href='#c.DataSet'><p>S3 concatenation function for DataSet</p></a></li>
<li><a href='#c.DataSetList'><p>S3 concatenation function for DataSetList</p></a></li>
<li><a href='#cat.DataSet'><p>S3 generic cat operator for DataSet</p></a></li>
<li><a href='#change_id'><p>Add unique identifiers to each DataSet in the provided DataSetList based on static attributes</p></a></li>
<li><a href='#check_dsc_configured'><p>Verify that the credentials for DSCtool have been set</p></a></li>
<li><a href='#check_format'><p>Check the format of data</p></a></li>
<li><a href='#clean_DataSetList'><p>Clean DataSetList object by concatenating DataSets</p></a></li>
<li><a href='#DataSet'><p>Constructor of S3 class 'DataSet'</p></a></li>
<li><a href='#DataSetList'><p>S3 constructor of the 'DataSetList'</p></a></li>
<li><a href='#dsl'><p>Example DataSetList used in tests / examples</p></a></li>
<li><a href='#dsl_large'><p>Larger example DataSetList used in tests / examples</p></a></li>
<li><a href='#ECDF'><p>Empirical Cumulative Dsitribution Function of Runtime of a single data set</p></a></li>
<li><a href='#fast_RT_samples'><p>Function to get just the RT samples needed, without any formatting to improve speed</p></a></li>
<li><a href='#generate_data.Aggr'><p>Generate dataframe of a single function/dimension pair</p></a></li>
<li><a href='#generate_data.AUC'><p>Generate dataframe containing the AUC for any ECDF-curves</p></a></li>
<li><a href='#generate_data.CDP'><p>Generate data for the cumulative difference plot.</p></a></li>
<li><a href='#generate_data.EAF'><p>Generate dataframe consisting of the levelsets of the EAF</p></a></li>
<li><a href='#generate_data.EAF_diff_Approximate'><p>Generate EAF-differences between each function and the remaining portfolio</p></a></li>
<li><a href='#generate_data.EAF_Difference'><p>Generate differences between two EAFs</p></a></li>
<li><a href='#generate_data.ECDF'><p>Generate dataframe of a single function/dimension pair</p></a></li>
<li><a href='#generate_data.ECDF_From_EAF'><p>Generate dataframe consisting of the ECDF-equivalent based on the EAF</p></a></li>
<li><a href='#generate_data.ECDF_raw'><p>Generate dataframe of a the unaggregated values of individual algorithms. Stripped-down version of</p></a></li>
<li><a href='#generate_data.Heatmaps'><p>Nevergrad-dashboard based algorithm comparison</p></a></li>
<li><a href='#generate_data.hist'><p>Generate dataframe of a single function/dimension pair</p></a></li>
<li><a href='#generate_data.Parameter_correlation'><p>Generate dataframe of exactly 2 parameters, matched by running time</p></a></li>
<li><a href='#generate_data.Parameters'><p>Generate dataframe of a single function/dimension pair</p></a></li>
<li><a href='#generate_data.PMF'><p>Generate dataframe of a single function/dimension pair for creating PDF or PMF plots</p></a></li>
<li><a href='#generate_data.Single_Function'><p>Generate dataframe of a single function/dimension pair</p></a></li>
<li><a href='#get_algId'><p>Get all algorithm ids present in a DataSetList</p></a></li>
<li><a href='#get_color_scheme'><p>Get colors according to the current colorScheme of the IOHanalyzer</p></a></li>
<li><a href='#get_color_scheme_dt'><p>Get datatable of current color (and linestyle) scheme to file</p></a></li>
<li><a href='#get_default_ECDF_targets'><p>Generate ECDF targets for a DataSetList</p></a></li>
<li><a href='#get_dim'><p>Get all dimensions present in a DataSetList</p></a></li>
<li><a href='#get_dsc_omnibus'><p>Perform omnibus statistical tests on the matrix of rankings from the DSCtool api</p></a></li>
<li><a href='#get_dsc_posthoc'><p>Perform post-hoc processing on data from DSCtool</p></a></li>
<li><a href='#get_dsc_rank'><p>Get the matrix of rankings using the DSCtool api for a DataSetList</p></a></li>
<li><a href='#get_ECDF_targets'><p>Generation of default ECDF-targets</p></a></li>
<li><a href='#get_ERT'><p>Get Expected RunTime</p></a></li>
<li><a href='#get_funcId'><p>Get all function ids present in a DataSetList</p></a></li>
<li><a href='#get_funcName'><p>Get all function names present in a DataSetList</p></a></li>
<li><a href='#get_funvals'><p>Get all function values present in a DataSetList</p></a></li>
<li><a href='#get_FV'><p>Get function value matrix of the used dataset.</p></a></li>
<li><a href='#get_FV_overview'><p>Get Function Value condensed overview</p></a></li>
<li><a href='#get_FV_sample'><p>Get Funtion Value Samples</p></a></li>
<li><a href='#get_FV_summary'><p>Get Function Value Summary</p></a></li>
<li><a href='#get_id'><p>Get condensed overview of datasets</p></a></li>
<li><a href='#get_line_style'><p>Get line styles according to the current styleScheme of the IOHanalyzer</p></a></li>
<li><a href='#get_marg_contrib_ecdf'><p>Get the marginal contribution of an algorithm to a portfolio</p></a></li>
<li><a href='#get_maxRT'><p>Get the maximal running time</p></a></li>
<li><a href='#get_ontology_data'><p>Get the list of available options for data from the OPTION ontology</p></a></li>
<li><a href='#get_ontology_var'><p>Get the list of available options for data from the OPTION ontology</p></a></li>
<li><a href='#get_overview'><p>Get condensed overview of datasets</p></a></li>
<li><a href='#get_PAR_name'><p>Get the parameter names of the algorithm</p></a></li>
<li><a href='#get_PAR_sample'><p>Get Parameter Value Samples</p></a></li>
<li><a href='#get_PAR_summary'><p>Get Parameter Value Summary</p></a></li>
<li><a href='#get_parId'><p>Get all parameter ids present in a DataSetList</p></a></li>
<li><a href='#get_position_dsl'><p>Extract the position information from a datasetlist object</p></a></li>
<li><a href='#get_RT'><p>Get runtime matrix of the used dataset.</p></a></li>
<li><a href='#get_RT_overview'><p>Get Runtime Value condensed overview</p></a></li>
<li><a href='#get_RT_sample'><p>Get RunTime Sample</p></a></li>
<li><a href='#get_RT_summary'><p>Get RunTime Summary</p></a></li>
<li><a href='#get_runtimes'><p>Get all runtime values present in a DataSetList</p></a></li>
<li><a href='#get_shapley_values'><p>Get the shapley-values of a portfolio of algorithms</p></a></li>
<li><a href='#get_static_attribute_values'><p>Get all options for a specific attribute which can be used to subset a DataSetList</p></a></li>
<li><a href='#get_static_attributes'><p>Get all attributes which can be used to subset a DataSetList</p></a></li>
<li><a href='#get_target_dt'><p>Generate datatables of runtime or function value targets for a DataSetList</p></a></li>
<li><a href='#glicko2_ranking'><p>Glicko2 raning of algorithms</p></a></li>
<li><a href='#IOH_plot_ly_default'><p>Template for creating plots in the IOHanalyzer-style</p></a></li>
<li><a href='#IOHanlyzer-deprecated'><p>Deprecated function in package <span class="pkg">IOHanalyzer</span></p></a></li>
<li><a href='#limit.data'><p>Reduce the size of the data set by evenly subsampling the records</p></a></li>
<li><a href='#max_ERTs'><p>Get the ERT-values for all DataSets in a DataSetList at certain targets</p></a></li>
<li><a href='#mean_FVs'><p>Get the expected function-values for all DataSets in a DataSetList at certain runtimes</p></a></li>
<li><a href='#pairwise.test'><p>Performs a pairwise Kolmogorov-Smirnov test on the bootstrapped running times</p>
among a data set</a></li>
<li><a href='#plot_eaf_data'><p>Create EAF-based polygon plots</p></a></li>
<li><a href='#plot_eaf_differences'><p>Create EAF-difference contour plots</p></a></li>
<li><a href='#plot_general_data'><p>General function for plotting within IOHanalyzer</p></a></li>
<li><a href='#Plot.Comparison.Heatmap'><p>Plot a heatmap according to the specifications from the Nevergrad dashboard</p></a></li>
<li><a href='#Plot.cumulative_difference_plot'><p>Plot the cumulative difference plot given a DataSetList.</p></a></li>
<li><a href='#Plot.FV.Aggregated'><p>Plot expected function value-based comparison over multiple functions or dimensions</p></a></li>
<li><a href='#Plot.FV.ECDF_AUC'><p>Radarplot of the area under the aggregated ECDF-curve of a DataSetList.</p></a></li>
<li><a href='#Plot.FV.ECDF_Per_Target'><p>Plot the empirical cumulative distriburtion as a function of the target values of</p>
a DataSetList at certain target runtimes</a></li>
<li><a href='#Plot.FV.ECDF_Single_Func'><p>Plot the aggregated empirical cumulative distriburtion as a function of the function values of</p>
a DataSetList.</a></li>
<li><a href='#Plot.FV.Histogram'><p>Plot histograms of the function values of a DataSetList at a certain target runtime</p></a></li>
<li><a href='#Plot.FV.Multi_Func'><p>Plot FV-plots for multiple functions or dimensions</p></a></li>
<li><a href='#Plot.FV.Parameters'><p>Plot the parameter values recorded in a DataSetList (aligned by budget)</p></a></li>
<li><a href='#Plot.FV.PDF'><p>Plot probablity density function of the function values of a DataSetList at</p>
a certain target runtime</a></li>
<li><a href='#Plot.FV.Single_Func'><p>Plot lineplot of the expected function values of a DataSetList</p></a></li>
<li><a href='#Plot.Performviz'><p>Create the PerformViz plot</p></a></li>
<li><a href='#Plot.RT.Aggregated'><p>Plot ERT-based comparison over multiple functions or dimensions</p></a></li>
<li><a href='#Plot.RT.ECDF_AUC'><p>Radarplot of the area under the aggregated ECDF-curve of a DataSetList.</p></a></li>
<li><a href='#Plot.RT.ECDF_Multi_Func'><p>Plot the aggregated empirical cumulative distriburtion as a function of the running times of</p>
a DataSetList. Aggregated over multiple functions or dimensions.</a></li>
<li><a href='#Plot.RT.ECDF_Per_Target'><p>Plot the empirical cumulative distriburtion as a function of the running times of</p>
a DataSetList at certain target function values</a></li>
<li><a href='#Plot.RT.ECDF_Single_Func'><p>Plot the aggregated empirical cumulative distriburtion as a function of the running times of</p>
a DataSetList.</a></li>
<li><a href='#Plot.RT.Histogram'><p>Plot histograms of the runtimes of a DataSetList at a certain target function value</p></a></li>
<li><a href='#Plot.RT.Multi_Func'><p>Plot ERT-plots for multiple functions or dimensions</p></a></li>
<li><a href='#Plot.RT.Parameters'><p>Plot the parameter values recorded in a DataSetList (aligned by funcion value)</p></a></li>
<li><a href='#Plot.RT.PMF'><p>Plot probablity mass function of the runtimes of a DataSetList at a certain target function value</p></a></li>
<li><a href='#Plot.RT.Single_Func'><p>Plot lineplot of the ERTs of a DataSetList</p></a></li>
<li><a href='#Plot.Stats.Glicko2_Candlestick'><p>Create a candlestick plot of Glicko2-rankings</p></a></li>
<li><a href='#Plot.Stats.Significance_Graph'><p>Plot a network graph showing the statistically different algorithms</p></a></li>
<li><a href='#Plot.Stats.Significance_Heatmap'><p>Plot a heatmap showing the statistically different algorithms</p></a></li>
<li><a href='#print.DataSet'><p>S3 generic print operator for DataSet</p></a></li>
<li><a href='#print.DataSetList'><p>S3 print function for DataSetList</p></a></li>
<li><a href='#read_index_file'><p>Read .info files and extract information</p></a></li>
<li><a href='#read_IOH_v1plus'><p>Read Nevergrad data</p></a></li>
<li><a href='#read_pure_csv'><p>Read Nevergrad data</p></a></li>
<li><a href='#register_DSC'><p>Register an account to the DSCtool API</p></a></li>
<li><a href='#runServer'><p>Create a shiny-server GUI to interactively use the IOHanalyzer</p></a></li>
<li><a href='#save_plotly'><p>Save plotly figure in multiple format</p></a></li>
<li><a href='#save_table'><p>Save DataTable in multiple formats</p></a></li>
<li><a href='#scan_index_file'><p>Scan *.info files for IOHProfiler or COCO</p></a></li>
<li><a href='#seq_FV'><p>Function for generating sequences of function values</p></a></li>
<li><a href='#seq_RT'><p>Function for generating sequences of runtime values</p></a></li>
<li><a href='#set_color_scheme'><p>Set the colorScheme of the IOHanalyzer plots</p></a></li>
<li><a href='#set_DSC_credentials'><p>Register an account to the DSCtool API</p></a></li>
<li><a href='#SP'><p>Estimator 'SP' for the Expected Running Time (ERT)</p></a></li>
<li><a href='#subset.DataSet'><p>S3 subset function for DataSet</p></a></li>
<li><a href='#subset.DataSetList'><p>Filter a DataSetList by some criteria</p></a></li>
<li><a href='#summary.DataSet'><p>S3 generic summary operator for DataSet</p></a></li>
<li><a href='#summary.DataSetList'><p>S3 summary function for DataSetList</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Analysis Part of 'IOHprofiler'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8.10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Diederick Vermetten &lt;d.l.vermetten@liacs.leidenuniv.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The data analysis module for the Iterative Optimization Heuristics
    Profiler ('IOHprofiler'). This module provides statistical analysis methods for the 
    benchmark data generated by optimization heuristics, which can be visualized through a 
    web-based interface. The benchmark data is usually generated by the 
    experimentation module, called 'IOHexperimenter'. 'IOHanalyzer' also supports
    the widely used 'COCO' (Comparing Continuous Optimisers) data format for benchmarking.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://iohanalyzer.liacs.nl">https://iohanalyzer.liacs.nl</a>,
<a href="https://github.com/IOHprofiler/IOHAnalyzer">https://github.com/IOHprofiler/IOHAnalyzer</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/IOHprofiler/IOHAnalyzer/issues">https://github.com/IOHprofiler/IOHAnalyzer/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, dplyr, data.table, ggplot2, plotly, colorspace,
RColorBrewer, shiny, reshape2, stringi, httr, knitr, methods,
rjson, eaf, viridis</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rcpp, testthat, withr, ComplexHeatmap, grid, keyring,
PlayerRatings, xtable, shinyjs, colourpicker, bsplus, DT,
kableExtra, markdown, igraph, shinydashboard, RVCompare,
reticulate</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-01 12:06:46 UTC; diedi</td>
</tr>
<tr>
<td>Author:</td>
<td>Hao Wang <a href="https://orcid.org/0000-0002-4933-5181"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Diederick Vermetten
    <a href="https://orcid.org/0000-0003-3040-7162"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Carola Doerr <a href="https://orcid.org/0000-0002-4981-3227"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Thomas Bäck <a href="https://orcid.org/0000-0001-6768-1478"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-01 12:52:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='IOHanalyzer'>IOHanalyzer: Data Analysis Part of IOHprofiler</h2><span id='topic+IOHanalyzer'></span><span id='topic+IOHanalyzer-package'></span>

<h3>Description</h3>

<p>The data analysis module for the Iterative Optimization Heuristics Profiler (IOHprofiler).
This module provides statistical analysis methods for the benchmark data generated by
optimization heuristics, which can be visualized through a
web-based interface. The benchmark data is usually generated by the
experimentation module, called IOHexperimenter. IOHanalyzer also supports
the widely used COCO (Comparing Continuous Optimisers) data format for benchmarking.
</p>


<h3>Functions</h3>

<p>The IOHanalyzer consists of 3 main functionalities:
</p>

<ul>
<li><p> Reading and alligning data from different heuristics, such as IOHExperimenter.
This is done using the <code><a href="#topic+DataSet">DataSet</a></code> and <code><a href="#topic+DataSetList">DataSetList</a></code> functions
</p>
</li>
<li><p> Processing and summarizing this data
</p>
</li>
<li><p> Creating various plots
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Diederick Vermetten <a href="mailto:d.l.vermetten@liacs.leidenuniv.nl">d.l.vermetten@liacs.leidenuniv.nl</a> (<a href="https://orcid.org/0000-0003-3040-7162">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Hao Wang <a href="mailto:h.wang@liacs.leidenuniv.nl">h.wang@liacs.leidenuniv.nl</a> (<a href="https://orcid.org/0000-0002-4933-5181">ORCID</a>)
</p>
</li>
<li><p> Carola Doerr <a href="mailto:Carola.Doerr@mpi-inf.mpg.de">Carola.Doerr@mpi-inf.mpg.de</a> (<a href="https://orcid.org/0000-0002-4981-3227">ORCID</a>)
</p>
</li>
<li><p> Thomas Bäck <a href="mailto:t.h.w.baeck@liacs.leidenuniv.nl">t.h.w.baeck@liacs.leidenuniv.nl</a> (<a href="https://orcid.org/0000-0001-6768-1478">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://iohanalyzer.liacs.nl">https://iohanalyzer.liacs.nl</a>
</p>
</li>
<li> <p><a href="https://github.com/IOHprofiler/IOHAnalyzer">https://github.com/IOHprofiler/IOHAnalyzer</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/IOHprofiler/IOHAnalyzer/issues">https://github.com/IOHprofiler/IOHAnalyzer/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", "ONE_PLUS_LAMDA_EA", package="IOHanalyzer")
dsList &lt;- DataSetList(path)
summary(dsList)
Plot.RT.Single_Func(dsList[1])

## Not run: 
runServer()

## End(Not run)
</code></pre>

<hr>
<h2 id='+5B.DataSetList'>S3 extraction function for DataSetList</h2><span id='topic++5B.DataSetList'></span>

<h3>Description</h3>

<p>S3 extraction function for DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataSetList'
x[i, drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B.DataSetList_+3A_x">x</code></td>
<td>
<p>The DataSetList to use</p>
</td></tr>
<tr><td><code id="+2B5B.DataSetList_+3A_i">i</code></td>
<td>
<p>The indices to extract</p>
</td></tr>
<tr><td><code id="+2B5B.DataSetList_+3A_drop">drop</code></td>
<td>
<p>Currently unused parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The DataSetList of the DataSets at indices i of DataSetList x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dsl[c(1, 3)]
</code></pre>

<hr>
<h2 id='+3D+3D.DataSet'>S3 generic == operator for DataSets</h2><span id='topic++3D+3D.DataSet'></span>

<h3>Description</h3>

<p>S3 generic == operator for DataSets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataSet'
dsL == dsR
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B3D+2B3D.DataSet_+3A_dsl">dsL</code></td>
<td>
<p>A 'DataSet' object</p>
</td></tr>
<tr><td><code id="+2B3D+2B3D.DataSet_+3A_dsr">dsR</code></td>
<td>
<p>A 'DataSet' object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True if the DataSets contain the same function, dimension and algorithm,
and have the exact same attributes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dsl[[1]] == dsl[[2]]
</code></pre>

<hr>
<h2 id='arrange'>S3 sort function for DataSetList</h2><span id='topic+arrange'></span><span id='topic+arrange.DataSetList'></span>

<h3>Description</h3>

<p>Sorts a DataSetList based on the custom specified attributes ('algId', 'DIM' or 'funcId').
Default is as ascending, can be made descending by adding a - in front of the attribute.
Sorting accross multiple attributes is supported, in the order they are specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange(dsl, ...)

## S3 method for class 'DataSetList'
arrange(dsl, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange_+3A_dsl">dsl</code></td>
<td>
<p>The DataSetList to sort</p>
</td></tr>
<tr><td><code id="arrange_+3A_...">...</code></td>
<td>
<p>attribute by which 'dsl' is sorted. Multiple attributes can be specified.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>arrange(dsl, DIM, -funcId, algId)
</code></pre>

<hr>
<h2 id='as.character.DataSet'>S3 generic as.character operator for DataSet</h2><span id='topic+as.character.DataSet'></span>

<h3>Description</h3>

<p>S3 generic as.character operator for DataSet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataSet'
as.character(x, verbose = F, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.character.DataSet_+3A_x">x</code></td>
<td>
<p>A DataSet object</p>
</td></tr>
<tr><td><code id="as.character.DataSet_+3A_verbose">verbose</code></td>
<td>
<p>Verbose mode, currently not implemented</p>
</td></tr>
<tr><td><code id="as.character.DataSet_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A short description of the DataSet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.character(dsl[[1]])
</code></pre>

<hr>
<h2 id='AUC'>Area Under Curve (Empirical Cumulative Dsitribution Function)</h2><span id='topic+AUC'></span><span id='topic+AUC.ECDF'></span>

<h3>Description</h3>

<p>Area Under Curve (Empirical Cumulative Dsitribution Function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AUC(fun, from = NULL, to = NULL)

## S3 method for class 'ECDF'
AUC(fun, from = NULL, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AUC_+3A_fun">fun</code></td>
<td>
<p>A ECDF object.</p>
</td></tr>
<tr><td><code id="AUC_+3A_from">from</code></td>
<td>
<p>double. Starting point of the area on x-axis</p>
</td></tr>
<tr><td><code id="AUC_+3A_to">to</code></td>
<td>
<p>double. Ending point of the area on x-axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a object of type 'ECDF'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ecdf &lt;- ECDF(dsl,c(12,14))
AUC(ecdf, 0, 100)
</code></pre>

<hr>
<h2 id='bootstrap_RT'>Bootstrapping for running time samples</h2><span id='topic+bootstrap_RT'></span>

<h3>Description</h3>

<p>Bootstrapping for running time samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_RT(x, max_eval, bootstrap.size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap_RT_+3A_x">x</code></td>
<td>
<p>A numeric vector. A sample of the running time.</p>
</td></tr>
<tr><td><code id="bootstrap_RT_+3A_max_eval">max_eval</code></td>
<td>
<p>A numeric vector, containing the maximal running time in
each run. It should have the same size as x</p>
</td></tr>
<tr><td><code id="bootstrap_RT_+3A_bootstrap.size">bootstrap.size</code></td>
<td>
<p>integer, the size of the bootstrapped sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the bootstrapped running time sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- dsl[[1]]
x &lt;- get_RT_sample(ds, ftarget = 16, output = 'long')
max_eval &lt;- get_maxRT(dsl, output = 'long')
bootstrap_RT(x$RT, max_eval$maxRT, bootstrap.size = 30)
</code></pre>

<hr>
<h2 id='c.DataSet'>S3 concatenation function for DataSet</h2><span id='topic+c.DataSet'></span>

<h3>Description</h3>

<p>Concatenation for DataSets. Combines multiple runs from separate DataSets
into a single DataSet object if all provided arguments have the same dimension, function ID and
algorithm ID, and each contains only a single run. Currently does not support parameter tracking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataSet'
c(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.DataSet_+3A_...">...</code></td>
<td>
<p>The DataSets to concatenate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new DataSet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c(dsl[[1]], dsl[[1]])
</code></pre>

<hr>
<h2 id='c.DataSetList'>S3 concatenation function for DataSetList</h2><span id='topic+c.DataSetList'></span>

<h3>Description</h3>

<p>S3 concatenation function for DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataSetList'
c(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.DataSetList_+3A_...">...</code></td>
<td>
<p>The DataSetLists to concatenate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c(dsl[1], dsl[3])
</code></pre>

<hr>
<h2 id='cat.DataSet'>S3 generic cat operator for DataSet</h2><span id='topic+cat.DataSet'></span>

<h3>Description</h3>

<p>S3 generic cat operator for DataSet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat.DataSet(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat.DataSet_+3A_x">x</code></td>
<td>
<p>A DataSet object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A short description of the DataSet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat.DataSet(dsl[[1]])
</code></pre>

<hr>
<h2 id='change_id'>Add unique identifiers to each DataSet in the provided DataSetList based on static attributes</h2><span id='topic+change_id'></span>

<h3>Description</h3>

<p>Note that this function returns a new DataSetList object, since a split into new datasetlist has to be done to
ensure each dataset has exactly one unique identifier.
Note that only static attributes (see 'get_static_attributes') can be used to create unique identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_id(dsl, attrs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="change_id_+3A_dsl">dsl</code></td>
<td>
<p>The DataSetList</p>
</td></tr>
<tr><td><code id="change_id_+3A_attrs">attrs</code></td>
<td>
<p>The list of attributes to combine into a unique identifier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new DataSetList object where the split has been done based on the provided attributes, and the unique
identifier has been added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>change_id(dsl, c('instance'))
</code></pre>

<hr>
<h2 id='check_dsc_configured'>Verify that the credentials for DSCtool have been set</h2><span id='topic+check_dsc_configured'></span>

<h3>Description</h3>

<p>This uses the keyring package to store and load credentials.
If the keyring package does not exists, it will default to look for
a config-file in the 'repository'-folder, under your home directory.
This can be changed by setting the option IOHprofiler.config_dir
If you already have an account, please call 'set_DSC_credentials'
with the corresponding username and password.
If you don't have an account, you can register for one using 'register_DSC'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dsc_configured()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>check_dsc_configured()
</code></pre>

<hr>
<h2 id='check_format'>Check the format of data</h2><span id='topic+check_format'></span>

<h3>Description</h3>

<p>Throws a warning when multiple formats are found in the same folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_format(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_format_+3A_path">path</code></td>
<td>
<p>The path to the folder to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The format of the data in the given folder. Either 'COCO', 'IOHprofiler',
'NEVERGRAD' or 'SOS'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", "ONE_PLUS_LAMDA_EA", package = "IOHanalyzer")
check_format(path)
</code></pre>

<hr>
<h2 id='clean_DataSetList'>Clean DataSetList object by concatenating DataSets</h2><span id='topic+clean_DataSetList'></span>

<h3>Description</h3>

<p>Concatenates all DataSets with the same ID, algid, function id and dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_DataSetList(dsList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_DataSetList_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object to clean</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>clean_DataSetList(dsl)
</code></pre>

<hr>
<h2 id='DataSet'>Constructor of S3 class 'DataSet'</h2><span id='topic+DataSet'></span>

<h3>Description</h3>

<p>DataSet contains the following attributes
* funId
* DIM
* algId
* datafile
* instance
* maxEvals
* finalFunEvals
* comment
* Additional attributes based on the original format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataSet(
  info,
  verbose = F,
  maximization = NULL,
  format = IOHprofiler,
  subsampling = FALSE,
  full_sampling = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DataSet_+3A_info">info</code></td>
<td>
<p>A List. Contains a set of in a *.info file.</p>
</td></tr>
<tr><td><code id="DataSet_+3A_verbose">verbose</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="DataSet_+3A_maximization">maximization</code></td>
<td>
<p>Logical. Whether the underlying optimization algorithm performs a maximization?
Set to NULL to determine automatically based on format</p>
</td></tr>
<tr><td><code id="DataSet_+3A_format">format</code></td>
<td>
<p>A character. The format of data source, either 'IOHProfiler', 'COCO' or 'TWO_COL&quot;</p>
</td></tr>
<tr><td><code id="DataSet_+3A_subsampling">subsampling</code></td>
<td>
<p>Logical. Whether *.cdat files are subsampled?</p>
</td></tr>
<tr><td><code id="DataSet_+3A_full_sampling">full_sampling</code></td>
<td>
<p>Logical. Whether the raw (unaligned) FV matrix should be stored.
Currenlt only useful when a correlation plot between function values and parameters should be made</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A S3 object 'DataSet'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file('extdata', 'ONE_PLUS_LAMDA_EA', package = 'IOHanalyzer')
info &lt;- read_index_file(file.path(path, 'IOHprofiler_f1_i1.info'))
DataSet(info[[1]])
</code></pre>

<hr>
<h2 id='DataSetList'>S3 constructor of the 'DataSetList'</h2><span id='topic+DataSetList'></span>

<h3>Description</h3>

<p>Attributes
funId
DIM
algId
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataSetList(
  path = NULL,
  verbose = T,
  print_fun = NULL,
  maximization = NULL,
  format = IOHprofiler,
  subsampling = FALSE,
  full_aggregation = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DataSetList_+3A_path">path</code></td>
<td>
<p>Path to the data files. Will look for all .info-files in this directory and use
the corresponding datafiles to create the DataSetList</p>
</td></tr>
<tr><td><code id="DataSetList_+3A_verbose">verbose</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="DataSetList_+3A_print_fun">print_fun</code></td>
<td>
<p>Function used to print output when in verbose mode</p>
</td></tr>
<tr><td><code id="DataSetList_+3A_maximization">maximization</code></td>
<td>
<p>Logical. Whether the underlying optimization algorithm performs a maximization?</p>
</td></tr>
<tr><td><code id="DataSetList_+3A_format">format</code></td>
<td>
<p>A character. The format of data source, options are:
</p>

<ul>
<li><p>'IOHProfiler'
</p>
</li>
<li><p>'COCO'
</p>
</li>
<li><p>'TWO_COL'
</p>
</li>
<li><p>'COCO_BIOBJ'
</p>
</li>
<li><p>'NEVERGRAD'
</p>
</li>
<li><p>'SOS'
</p>
</li></ul>

<p>These formats are specified in more detail in our github wiki.</p>
</td></tr>
<tr><td><code id="DataSetList_+3A_subsampling">subsampling</code></td>
<td>
<p>Logical. Whether *.cdat files are subsampled?</p>
</td></tr>
<tr><td><code id="DataSetList_+3A_full_aggregation">full_aggregation</code></td>
<td>
<p>If True, individual DataSets are aggregated as much as possible: all DataSets
with the same algorithmname, function id and dimension are combined together. This leads to information loss
related to static variables, so only use if that information is not required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DataSetList object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", "ONE_PLUS_LAMDA_EA", package = "IOHanalyzer")
DataSetList(path)
</code></pre>

<hr>
<h2 id='dsl'>Example DataSetList used in tests / examples</h2><span id='topic+dsl'></span>

<h3>Description</h3>

<p>A DataSetList containing DataSets on 2 IOHProfiler functions from 2 algorithms in 16D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsl
</code></pre>


<h3>Format</h3>

<p>DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(dsl)
</code></pre>

<hr>
<h2 id='dsl_large'>Larger example DataSetList used in tests / examples</h2><span id='topic+dsl_large'></span>

<h3>Description</h3>

<p>A DataSetList containing DataSets on all IOHProfiler functions from 11 algorithms in 100D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsl_large
</code></pre>


<h3>Format</h3>

<p>DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(dsl_large)
</code></pre>

<hr>
<h2 id='ECDF'>Empirical Cumulative Dsitribution Function of Runtime of a single data set</h2><span id='topic+ECDF'></span><span id='topic+ECDF.DataSet'></span><span id='topic+ECDF.DataSetList'></span>

<h3>Description</h3>

<p>Empirical Cumulative Dsitribution Function of Runtime of a single data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ECDF(ds, ftarget, ...)

## S3 method for class 'DataSet'
ECDF(ds, ftarget, ...)

## S3 method for class 'DataSetList'
ECDF(ds, ftarget, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ECDF_+3A_ds">ds</code></td>
<td>
<p>A DataSet or DataSetList object.</p>
</td></tr>
<tr><td><code id="ECDF_+3A_ftarget">ftarget</code></td>
<td>
<p>A Numerical vector. Function values at which runtime values are consumed</p>
</td></tr>
<tr><td><code id="ECDF_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a object of type 'ECDF'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ECDF(dsl,c(12,14))
ECDF(dsl[[1]],c(12,14))
</code></pre>

<hr>
<h2 id='fast_RT_samples'>Function to get just the RT samples needed, without any formatting to improve speed</h2><span id='topic+fast_RT_samples'></span>

<h3>Description</h3>

<p>Function to get just the RT samples needed, without any formatting to improve speed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_RT_samples(RT_mat, target, maximization = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_RT_samples_+3A_rt_mat">RT_mat</code></td>
<td>
<p>A matrix containing the RT-values of a dataset</p>
</td></tr>
<tr><td><code id="fast_RT_samples_+3A_target">target</code></td>
<td>
<p>Which target-value to use</p>
</td></tr>
<tr><td><code id="fast_RT_samples_+3A_maximization">maximization</code></td>
<td>
<p>Whether maximization is needed or not</p>
</td></tr>
</table>

<hr>
<h2 id='generate_data.Aggr'>Generate dataframe of a single function/dimension pair</h2><span id='topic+generate_data.Aggr'></span>

<h3>Description</h3>

<p>This function generates a dataframe which can be easily plotted using the 'plot_general_data'-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.Aggr(dsList, aggr_on = "funcId", targets = NULL, which = "by_RT")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.Aggr_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="generate_data.Aggr_+3A_aggr_on">aggr_on</code></td>
<td>
<p>Which attribute to use for aggregation. Either 'funcId' or 'DIM'</p>
</td></tr>
<tr><td><code id="generate_data.Aggr_+3A_targets">targets</code></td>
<td>
<p>Optional list of target values (Runtime or target value)</p>
</td></tr>
<tr><td><code id="generate_data.Aggr_+3A_which">which</code></td>
<td>
<p>Whether to use a fixed-target 'by_RT' perspective or fixed-budget 'by_FV'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>generate_data.Aggr(dsl)
</code></pre>

<hr>
<h2 id='generate_data.AUC'>Generate dataframe containing the AUC for any ECDF-curves</h2><span id='topic+generate_data.AUC'></span>

<h3>Description</h3>

<p>This function generates a dataframe which can be easily plotted using the 'plot_general_data'-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.AUC(
  dsList,
  targets,
  scale_log = F,
  which = "by_RT",
  dt_ecdf = NULL,
  multiple_x = FALSE,
  normalize = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.AUC_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="generate_data.AUC_+3A_targets">targets</code></td>
<td>
<p>A list or data.table containing the targets per function / dimension. If this is
a data.table, it needs columns 'target', 'DIM' and 'funcId'</p>
</td></tr>
<tr><td><code id="generate_data.AUC_+3A_scale_log">scale_log</code></td>
<td>
<p>Whether to use logarithmic scaling or not</p>
</td></tr>
<tr><td><code id="generate_data.AUC_+3A_which">which</code></td>
<td>
<p>Whether to use a fixed-target 'by_RT' perspective or fixed-budget 'by_FV'</p>
</td></tr>
<tr><td><code id="generate_data.AUC_+3A_dt_ecdf">dt_ecdf</code></td>
<td>
<p>A data table of the ECDF to avoid needless recomputations. Will take preference if it
is provided together with dsList and targets</p>
</td></tr>
<tr><td><code id="generate_data.AUC_+3A_multiple_x">multiple_x</code></td>
<td>
<p>Boolean, whether to get only the total AUC or get stepwise AUC values</p>
</td></tr>
<tr><td><code id="generate_data.AUC_+3A_normalize">normalize</code></td>
<td>
<p>Whether to normalize the resulting AUC values to [0,1] or not</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
generate_data.AUC(dsl, get_ECDF_targets(dsl))
generate_data.AUC(NULL, NULL, dt_ecdf = generate_data.ECDF(dsl, get_ECDF_targets(dsl)))
</code></pre>

<hr>
<h2 id='generate_data.CDP'>Generate data for the cumulative difference plot.</h2><span id='topic+generate_data.CDP'></span>

<h3>Description</h3>

<p>This function generates a dataframe that can be used to generate
the 'cumulative_difference_plot'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.CDP(
  dsList,
  runtime_or_target_value,
  isFixedBudget,
  alpha = 0.05,
  EPSILON = 1e-80,
  nOfBootstrapSamples = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.CDP_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object.
Note that the 'cumulative_difference_plot' can only compare two algorithms
in a single problem of dimension one.</p>
</td></tr>
<tr><td><code id="generate_data.CDP_+3A_runtime_or_target_value">runtime_or_target_value</code></td>
<td>
<p>The target runtime or the target value</p>
</td></tr>
<tr><td><code id="generate_data.CDP_+3A_isfixedbudget">isFixedBudget</code></td>
<td>
<p>Should be TRUE when target runtime is used. False otherwise.</p>
</td></tr>
<tr><td><code id="generate_data.CDP_+3A_alpha">alpha</code></td>
<td>
<p>1 minus the confidence level of the confidence band.</p>
</td></tr>
<tr><td><code id="generate_data.CDP_+3A_epsilon">EPSILON</code></td>
<td>
<p>If abs(x-y) &lt; EPSILON, then we assume that x = y.</p>
</td></tr>
<tr><td><code id="generate_data.CDP_+3A_nofbootstrapsamples">nOfBootstrapSamples</code></td>
<td>
<p>The number of bootstrap samples used in the estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the data to generate the cumulative difference plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dsl_sub &lt;- subset(dsl, funcId == 1)
generate_data.CDP(dsl_sub, 15, TRUE, nOfBootstrapSamples = 10)
</code></pre>

<hr>
<h2 id='generate_data.EAF'>Generate dataframe consisting of the levelsets of the EAF</h2><span id='topic+generate_data.EAF'></span>

<h3>Description</h3>

<p>This function generates a dataframe which can be easily plotted using the 'plot_eaf_data'-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.EAF(
  dsList,
  n_sets = 11,
  subsampling = 100,
  scale_xlog = F,
  xmin = "",
  xmax = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.EAF_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="generate_data.EAF_+3A_n_sets">n_sets</code></td>
<td>
<p>The number of level sets to calculate</p>
</td></tr>
<tr><td><code id="generate_data.EAF_+3A_subsampling">subsampling</code></td>
<td>
<p>Level of subsampling to use for runtime-values (number of runtimes to consider).
Setting to 0 will make the calculations more precise at the cost of potentially much longer exectution times</p>
</td></tr>
<tr><td><code id="generate_data.EAF_+3A_scale_xlog">scale_xlog</code></td>
<td>
<p>Only has effect when 'subsampling' is True. The scaling of the subsampled runtimes
When true, these are equally spaced in log-space, when false they are linearly spaced.</p>
</td></tr>
<tr><td><code id="generate_data.EAF_+3A_xmin">xmin</code></td>
<td>
<p>Minimum runtime value</p>
</td></tr>
<tr><td><code id="generate_data.EAF_+3A_xmax">xmax</code></td>
<td>
<p>Maximum runtime value</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>generate_data.EAF(subset(dsl, funcId == 1))
</code></pre>

<hr>
<h2 id='generate_data.EAF_diff_Approximate'>Generate EAF-differences between each function and the remaining portfolio</h2><span id='topic+generate_data.EAF_diff_Approximate'></span>

<h3>Description</h3>

<p>This is an approximation of &ldquo;, since the number of required polygons
can quickly become problematic for plotly. This function uses discretized
contour matrices instead, which trades off accuracy for scalability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.EAF_diff_Approximate(
  dsList,
  xmin,
  xmax,
  ymin,
  ymax,
  x.log = T,
  y.log = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.EAF_diff_Approximate_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object, containing at least 2 IDs</p>
</td></tr>
<tr><td><code id="generate_data.EAF_diff_Approximate_+3A_xmin">xmin</code></td>
<td>
<p>Minimum runtime to consider</p>
</td></tr>
<tr><td><code id="generate_data.EAF_diff_Approximate_+3A_xmax">xmax</code></td>
<td>
<p>Maximum runtime to consider</p>
</td></tr>
<tr><td><code id="generate_data.EAF_diff_Approximate_+3A_ymin">ymin</code></td>
<td>
<p>Minimum f(x) to consider</p>
</td></tr>
<tr><td><code id="generate_data.EAF_diff_Approximate_+3A_ymax">ymax</code></td>
<td>
<p>Maximum f(x) to consider</p>
</td></tr>
<tr><td><code id="generate_data.EAF_diff_Approximate_+3A_x.log">x.log</code></td>
<td>
<p>Whether to scale the y-space logarithmically</p>
</td></tr>
<tr><td><code id="generate_data.EAF_diff_Approximate_+3A_y.log">y.log</code></td>
<td>
<p>Whether to scale the y-space logarithmically</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>generate_data.EAF_diff_Approximate(subset(dsl, funcId == 1), 1, 16, 1, 16)
</code></pre>

<hr>
<h2 id='generate_data.EAF_Difference'>Generate differences between two EAFs</h2><span id='topic+generate_data.EAF_Difference'></span>

<h3>Description</h3>

<p>This function uses the 'eaf' package to calculate eaf differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.EAF_Difference(dsList1, dsList2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.EAF_Difference_+3A_dslist1">dsList1</code></td>
<td>
<p>The first DataSetList object</p>
</td></tr>
<tr><td><code id="generate_data.EAF_Difference_+3A_dslist2">dsList2</code></td>
<td>
<p>The second DataSetList object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>generate_data.EAF_Difference(dsl[1], dsl[3])
</code></pre>

<hr>
<h2 id='generate_data.ECDF'>Generate dataframe of a single function/dimension pair</h2><span id='topic+generate_data.ECDF'></span>

<h3>Description</h3>

<p>This function generates a dataframe which can be easily plotted using the 'plot_general_data'-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.ECDF(
  dsList,
  targets,
  scale_log = F,
  which = "by_RT",
  use_full_range = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.ECDF_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="generate_data.ECDF_+3A_targets">targets</code></td>
<td>
<p>A list or data.table containing the targets per function / dimension. If this is
a data.table, it needs columns 'target', 'DIM' and 'funcId'</p>
</td></tr>
<tr><td><code id="generate_data.ECDF_+3A_scale_log">scale_log</code></td>
<td>
<p>Wheterh to use logarithmic scaling or not</p>
</td></tr>
<tr><td><code id="generate_data.ECDF_+3A_which">which</code></td>
<td>
<p>Whether to use a fixed-target 'by_RT' perspective or fixed-budget 'by_FV'</p>
</td></tr>
<tr><td><code id="generate_data.ECDF_+3A_use_full_range">use_full_range</code></td>
<td>
<p>Whether or not to use the full range of the x-axis or cut it off as soon as
all algorithms reach 98% success (+10% buffer). Only supported in the case of one function and dimension</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>generate_data.ECDF(subset(dsl, funcId == 1), c(10, 15, 16))
</code></pre>

<hr>
<h2 id='generate_data.ECDF_From_EAF'>Generate dataframe consisting of the ECDF-equivalent based on the EAF</h2><span id='topic+generate_data.ECDF_From_EAF'></span>

<h3>Description</h3>

<p>This function uses EAF-data to calculate a target-independent version of the ECDF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.ECDF_From_EAF(
  eaf_table,
  min_val,
  max_val,
  maximization = F,
  scale_log = F,
  normalize = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.ECDF_From_EAF_+3A_eaf_table">eaf_table</code></td>
<td>
<p>Datatable resulting from the 'generate_data.EAF' function</p>
</td></tr>
<tr><td><code id="generate_data.ECDF_From_EAF_+3A_min_val">min_val</code></td>
<td>
<p>Minimum value to use for y-space</p>
</td></tr>
<tr><td><code id="generate_data.ECDF_From_EAF_+3A_max_val">max_val</code></td>
<td>
<p>Maximum value to use for y-space</p>
</td></tr>
<tr><td><code id="generate_data.ECDF_From_EAF_+3A_maximization">maximization</code></td>
<td>
<p>Whether the data resulted from maximization or not</p>
</td></tr>
<tr><td><code id="generate_data.ECDF_From_EAF_+3A_scale_log">scale_log</code></td>
<td>
<p>Whether to use logarithmic scaling in y-space before calculating the partial integral</p>
</td></tr>
<tr><td><code id="generate_data.ECDF_From_EAF_+3A_normalize">normalize</code></td>
<td>
<p>Whether to normalize the resulting integrals to [0,1] (Based on 'min_val' and 'max_va')</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
generate_data.ECDF_From_EAF(generate_data.EAF(subset(dsl, funcId == 1)), 1, 16, maximization = TRUE)
</code></pre>

<hr>
<h2 id='generate_data.ECDF_raw'>Generate dataframe of a the unaggregated values of individual algorithms. Stripped-down version of</h2><span id='topic+generate_data.ECDF_raw'></span>

<h3>Description</h3>

<p>This provides an unaggregated version of the function 'generate_data.ECDF'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.ECDF_raw(dsList, targets, scale_log = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.ECDF_raw_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="generate_data.ECDF_raw_+3A_targets">targets</code></td>
<td>
<p>A list or data.table containing the targets per function / dimension. If this is
a data.table, it needs columns 'target', 'DIM' and 'funcId'</p>
</td></tr>
<tr><td><code id="generate_data.ECDF_raw_+3A_scale_log">scale_log</code></td>
<td>
<p>Wheterh to use logarithmic scaling or not</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
generate_data.ECDF_raw(subset(dsl, funcId == 1), c(10, 15, 16))
</code></pre>

<hr>
<h2 id='generate_data.Heatmaps'>Nevergrad-dashboard based algorithm comparison</h2><span id='topic+generate_data.Heatmaps'></span>

<h3>Description</h3>

<p>This procedure calculates the fraction of times algorithm A is better than
algorithm B according to their mean on each function,dimension,target tuple
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.Heatmaps(dsList, which = "by_FV", target_dt = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.Heatmaps_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList, can contain multiple functions and dimensions, but should have the
same algorithms for all of them. For functions/dimensions where this is not the case,
all algorithms are considered tied.</p>
</td></tr>
<tr><td><code id="generate_data.Heatmaps_+3A_which">which</code></td>
<td>
<p>Whether to use fixed-target ('by_FV') or fixed-budget ('by_RT') perspective</p>
</td></tr>
<tr><td><code id="generate_data.Heatmaps_+3A_target_dt">target_dt</code></td>
<td>
<p>Custom data.table target value to use. When NULL, this is selected automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the pairwise win-ratios.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate_data.Heatmaps(dsl)
generate_data.Heatmaps(dsl, which = 'by_RT')
</code></pre>

<hr>
<h2 id='generate_data.hist'>Generate dataframe of a single function/dimension pair</h2><span id='topic+generate_data.hist'></span>

<h3>Description</h3>

<p>This function generates a dataframe which can be easily plotted using the 'plot_general_data'-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.hist(dsList, target, use.equal.bins = F, which = "by_RT")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.hist_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="generate_data.hist_+3A_target">target</code></td>
<td>
<p>The target value (Runtime or target value)</p>
</td></tr>
<tr><td><code id="generate_data.hist_+3A_use.equal.bins">use.equal.bins</code></td>
<td>
<p>Whether all bins should be equal size for each algorithm or not</p>
</td></tr>
<tr><td><code id="generate_data.hist_+3A_which">which</code></td>
<td>
<p>Whether to use a fixed-target 'by_RT' perspective or fixed-budget 'by_FV'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>generate_data.hist(subset(dsl, funcId == 1), target = 15, which = 'by_RT')
</code></pre>

<hr>
<h2 id='generate_data.Parameter_correlation'>Generate dataframe of exactly 2 parameters, matched by running time</h2><span id='topic+generate_data.Parameter_correlation'></span>

<h3>Description</h3>

<p>This function generates a dataframe which can be easily plotted using the 'plot_general_data'-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.Parameter_correlation(dsList, par1, par2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.Parameter_correlation_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="generate_data.Parameter_correlation_+3A_par1">par1</code></td>
<td>
<p>The first parameter. Either a parameter name or 'f(x)'</p>
</td></tr>
<tr><td><code id="generate_data.Parameter_correlation_+3A_par2">par2</code></td>
<td>
<p>The second parameter. Either a parameter name or 'f(x)'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>generate_data.Parameter_correlation(subset(dsl, funcId == 1), 'f(x)', 'f(x)')
</code></pre>

<hr>
<h2 id='generate_data.Parameters'>Generate dataframe of a single function/dimension pair</h2><span id='topic+generate_data.Parameters'></span>

<h3>Description</h3>

<p>This function generates a dataframe which can be easily plotted using the 'plot_general_data'-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.Parameters(dsList, which = "by_RT", scale_log = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.Parameters_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="generate_data.Parameters_+3A_which">which</code></td>
<td>
<p>Whether to use a fixed-target 'by_RT' perspective or fixed-budget 'by_FV'</p>
</td></tr>
<tr><td><code id="generate_data.Parameters_+3A_scale_log">scale_log</code></td>
<td>
<p>Wheterh to use logarithmic scaling or not</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>generate_data.Parameters(subset(dsl, funcId == 1))
</code></pre>

<hr>
<h2 id='generate_data.PMF'>Generate dataframe of a single function/dimension pair for creating PDF or PMF plots</h2><span id='topic+generate_data.PMF'></span>

<h3>Description</h3>

<p>This function generates a dataframe which can be easily plotted using the 'plot_general_data'-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.PMF(dsList, target, which = "by_RT")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.PMF_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="generate_data.PMF_+3A_target">target</code></td>
<td>
<p>The target value (Runtime or target value)</p>
</td></tr>
<tr><td><code id="generate_data.PMF_+3A_which">which</code></td>
<td>
<p>Whether to use a fixed-target 'by_RT' perspective or fixed-budget 'by_FV'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>generate_data.PMF(subset(dsl, funcId == 1), target = 15, which = 'by_RT')
</code></pre>

<hr>
<h2 id='generate_data.Single_Function'>Generate dataframe of a single function/dimension pair</h2><span id='topic+generate_data.Single_Function'></span>

<h3>Description</h3>

<p>This function generates a dataframe which can be easily plotted using the 'plot_general_data'-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data.Single_Function(
  dsList,
  start = NULL,
  stop = NULL,
  scale_log = F,
  which = "by_RT",
  include_opts = F,
  budget = NULL,
  include_geom_mean = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_data.Single_Function_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="generate_data.Single_Function_+3A_start">start</code></td>
<td>
<p>Optional start value (Runtime or target value)</p>
</td></tr>
<tr><td><code id="generate_data.Single_Function_+3A_stop">stop</code></td>
<td>
<p>Optional end value (Runtime or target value)</p>
</td></tr>
<tr><td><code id="generate_data.Single_Function_+3A_scale_log">scale_log</code></td>
<td>
<p>Wheterh to use logarithmic scaling or not</p>
</td></tr>
<tr><td><code id="generate_data.Single_Function_+3A_which">which</code></td>
<td>
<p>Whether to use a fixed-target 'by_RT' perspective or fixed-budget 'by_FV'</p>
</td></tr>
<tr><td><code id="generate_data.Single_Function_+3A_include_opts">include_opts</code></td>
<td>
<p>Whether or not to also include the best value hit by each algorithm to
the generated datapoints</p>
</td></tr>
<tr><td><code id="generate_data.Single_Function_+3A_budget">budget</code></td>
<td>
<p>Optional; overwrites the budget of each individual algorithm when doing ERT calculations. Only works
in fixed_target mode.</p>
</td></tr>
<tr><td><code id="generate_data.Single_Function_+3A_include_geom_mean">include_geom_mean</code></td>
<td>
<p>Boolean to indicate whether to include the geometric mean.
Only works in fixed_budget mode. Negative values cause NaN, zeros cause output to be completely 0. Defaults to False.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>generate_data.Single_Function(subset(dsl, funcId == 1), which = 'by_RT')
</code></pre>

<hr>
<h2 id='get_algId'>Get all algorithm ids present in a DataSetList</h2><span id='topic+get_algId'></span>

<h3>Description</h3>

<p>Get all algorithm ids present in a DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_algId(dsList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_algId_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetLsit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sorted list of all unique algorithm ids which occur in the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_algId(dsl)
</code></pre>

<hr>
<h2 id='get_color_scheme'>Get colors according to the current colorScheme of the IOHanalyzer</h2><span id='topic+get_color_scheme'></span>

<h3>Description</h3>

<p>Get colors according to the current colorScheme of the IOHanalyzer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_color_scheme(ids_in)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_color_scheme_+3A_ids_in">ids_in</code></td>
<td>
<p>List of algorithms (or custom ids, see 'change_id') for which to get colors</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>get_color_scheme(get_algId(dsl))
</code></pre>

<hr>
<h2 id='get_color_scheme_dt'>Get datatable of current color (and linestyle) scheme to file</h2><span id='topic+get_color_scheme_dt'></span>

<h3>Description</h3>

<p>Get datatable of current color (and linestyle) scheme to file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_color_scheme_dt()
</code></pre>


<h3>Value</h3>

<p>data.table object with 3 columns: ids, colors, linestyles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_color_scheme_dt()
</code></pre>

<hr>
<h2 id='get_default_ECDF_targets'>Generate ECDF targets for a DataSetList</h2><span id='topic+get_default_ECDF_targets'></span>

<h3>Description</h3>

<p>Generate ECDF targets for a DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_default_ECDF_targets(data, format_func = as.integer)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_default_ECDF_targets_+3A_data">data</code></td>
<td>
<p>A DataSetList</p>
</td></tr>
<tr><td><code id="get_default_ECDF_targets_+3A_format_func">format_func</code></td>
<td>
<p>function to format the targets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of targets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_default_ECDF_targets(dsl)
</code></pre>

<hr>
<h2 id='get_dim'>Get all dimensions present in a DataSetList</h2><span id='topic+get_dim'></span>

<h3>Description</h3>

<p>Get all dimensions present in a DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dim(dsList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dim_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetLsit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sorted list of all unique dimensions which occur in the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_dim(dsl)
</code></pre>

<hr>
<h2 id='get_dsc_omnibus'>Perform omnibus statistical tests on the matrix of rankings from the DSCtool api</h2><span id='topic+get_dsc_omnibus'></span>

<h3>Description</h3>

<p>Perform omnibus statistical tests on the matrix of rankings from the DSCtool api
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dsc_omnibus(res, method = NULL, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dsc_omnibus_+3A_res">res</code></td>
<td>
<p>The result of a call to the 'get_dsc_rank'</p>
</td></tr>
<tr><td><code id="get_dsc_omnibus_+3A_method">method</code></td>
<td>
<p>Which method to use to do the tests.
Has be be one of the allowed ones in 'res$valid_methods'.
When NULL, the first valid option is chosen by default</p>
</td></tr>
<tr><td><code id="get_dsc_omnibus_+3A_alpha">alpha</code></td>
<td>
<p>Threshold value for statistical significance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing the algorithm means
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_dsc_omnibus(get_dsc_rank(dsl, na.correction = 'PAR-10'))
</code></pre>

<hr>
<h2 id='get_dsc_posthoc'>Perform post-hoc processing on data from DSCtool</h2><span id='topic+get_dsc_posthoc'></span>

<h3>Description</h3>

<p>Perform post-hoc processing on data from DSCtool
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dsc_posthoc(
  omni_res,
  nr_algs,
  nr_problems,
  base_algorithm = NULL,
  method = "friedman",
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dsc_posthoc_+3A_omni_res">omni_res</code></td>
<td>
<p>The result from a call to 'get_dsc_omnibus'</p>
</td></tr>
<tr><td><code id="get_dsc_posthoc_+3A_nr_algs">nr_algs</code></td>
<td>
<p>The number of algorithms present in 'omni_res'</p>
</td></tr>
<tr><td><code id="get_dsc_posthoc_+3A_nr_problems">nr_problems</code></td>
<td>
<p>The number of problems present in 'omni_res'</p>
</td></tr>
<tr><td><code id="get_dsc_posthoc_+3A_base_algorithm">base_algorithm</code></td>
<td>
<p>The base algorithm to which the other are compared.
This has to be present in 'omni_res$algorithm_means' as an 'algorithm' property</p>
</td></tr>
<tr><td><code id="get_dsc_posthoc_+3A_method">method</code></td>
<td>
<p>Either 'friedman' or 'friedman-aligned-rank'</p>
</td></tr>
<tr><td><code id="get_dsc_posthoc_+3A_alpha">alpha</code></td>
<td>
<p>Threshold value for statistical significance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing 4 types of analyses:
* Zvalue
* UnadjustedPValue
* Holm
* Hochberg
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_dsc_posthoc(get_dsc_omnibus(get_dsc_rank(dsl, na.correction = 'PAR-10')), 2, 2)
</code></pre>

<hr>
<h2 id='get_dsc_rank'>Get the matrix of rankings using the DSCtool api for a DataSetList</h2><span id='topic+get_dsc_rank'></span>

<h3>Description</h3>

<p>Get the matrix of rankings using the DSCtool api for a DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dsc_rank(
  dsList,
  targets = NULL,
  which = "by_RT",
  test_type = "AD",
  alpha = 0.05,
  epsilon = 0,
  monte_carlo_iterations = 0,
  na.correction = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dsc_rank_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="get_dsc_rank_+3A_targets">targets</code></td>
<td>
<p>Optional list of target values (Runtime or target value)</p>
</td></tr>
<tr><td><code id="get_dsc_rank_+3A_which">which</code></td>
<td>
<p>Whether to use a fixed-target 'by_RT' perspective or fixed-budget 'by_FV'</p>
</td></tr>
<tr><td><code id="get_dsc_rank_+3A_test_type">test_type</code></td>
<td>
<p>Either 'AD' for Anderson-Darling or KS for Kolmogorov-Smirnov tests</p>
</td></tr>
<tr><td><code id="get_dsc_rank_+3A_alpha">alpha</code></td>
<td>
<p>Threshold value for statistical significance</p>
</td></tr>
<tr><td><code id="get_dsc_rank_+3A_epsilon">epsilon</code></td>
<td>
<p>Minimum threshold to have practical difference between algorithms (eDSC)</p>
</td></tr>
<tr><td><code id="get_dsc_rank_+3A_monte_carlo_iterations">monte_carlo_iterations</code></td>
<td>
<p>How many monte-carlo-simulations to perform
(set to 0 to use regular DSC)</p>
</td></tr>
<tr><td><code id="get_dsc_rank_+3A_na.correction">na.correction</code></td>
<td>
<p>How to deal with missing values. Only used in fixed-target perspective.
Options are:
- 'NULL': No correction is done. This will likely result in an error, as the DSCtool
does not allow for na values
- 'PAR-1' Replace missing values with Budget (budget taken from relevant DataSet)
- 'PAR-10' Replace missing values with 10*Budget (budget taken from relevant DataSet)
- 'ERT' Replace NA values with the Expected Running Time. If all values are NA, this
reverts to nr_runs * budget
- 'Remove-na' Removes all NA values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing a ranked-matrix which has the rankin of each algorithm
on each problem, as well as a list of which omnibus tests can be used to further process
this data. This can be further analyzed using 'get_dsc_omnibus'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_dsc_rank(dsl, na.correction = 'PAR-10')
</code></pre>

<hr>
<h2 id='get_ECDF_targets'>Generation of default ECDF-targets</h2><span id='topic+get_ECDF_targets'></span>

<h3>Description</h3>

<p>Generation of default ECDF-targets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ECDF_targets(dsList, type = "log-linear", number_targets = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_ECDF_targets_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object for which to generate the targets</p>
</td></tr>
<tr><td><code id="get_ECDF_targets_+3A_type">type</code></td>
<td>
<p>The way to generate the targets. Either 'log-linear', 'linear' or 'bbob' (51 fixed targets,
equal for all functions / dimensions)</p>
</td></tr>
<tr><td><code id="get_ECDF_targets_+3A_number_targets">number_targets</code></td>
<td>
<p>The amount of targets to generate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with 3 columns: funcId, DIM and target
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_ECDF_targets(dsl, 'linear', 10)
</code></pre>

<hr>
<h2 id='get_ERT'>Get Expected RunTime</h2><span id='topic+get_ERT'></span><span id='topic+get_ERT.DataSet'></span><span id='topic+get_ERT.DataSetList'></span>

<h3>Description</h3>

<p>Get Expected RunTime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ERT(ds, ftarget, budget, ...)

## S3 method for class 'DataSet'
get_ERT(ds, ftarget, budget = NULL, ...)

## S3 method for class 'DataSetList'
get_ERT(ds, ftarget, budget = NULL, algorithm = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_ERT_+3A_ds">ds</code></td>
<td>
<p>A DataSet or DataSetList object</p>
</td></tr>
<tr><td><code id="get_ERT_+3A_ftarget">ftarget</code></td>
<td>
<p>The function target(s) for which to get the ERT</p>
</td></tr>
<tr><td><code id="get_ERT_+3A_budget">budget</code></td>
<td>
<p>Optional; overwrites the budget found in ds for ERT-calculation</p>
</td></tr>
<tr><td><code id="get_ERT_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="get_ERT_+3A_algorithm">algorithm</code></td>
<td>
<p>DEPRECATED, will be removed in next release. Which algorithms in the DataSetList to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing the runtime samples for each provided target
function value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_ERT(dsl, 14)
get_ERT(dsl[[1]], 14)
</code></pre>

<hr>
<h2 id='get_funcId'>Get all function ids present in a DataSetList</h2><span id='topic+get_funcId'></span>

<h3>Description</h3>

<p>Get all function ids present in a DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_funcId(dsList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_funcId_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetLsit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sorted list of all unique function ids which occur in the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_funcId(dsl)
</code></pre>

<hr>
<h2 id='get_funcName'>Get all function names present in a DataSetList</h2><span id='topic+get_funcName'></span>

<h3>Description</h3>

<p>Get all function names present in a DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_funcName(dsList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_funcName_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetLsit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of all unique function names which occur in the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_funcName(dsl)
</code></pre>

<hr>
<h2 id='get_funvals'>Get all function values present in a DataSetList</h2><span id='topic+get_funvals'></span>

<h3>Description</h3>

<p>Get all function values present in a DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_funvals(dsList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_funvals_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetLsit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list matrices of all function values which occur in the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_funvals(dsl)
</code></pre>

<hr>
<h2 id='get_FV'>Get function value matrix of the used dataset.</h2><span id='topic+get_FV'></span><span id='topic+get_FV.DataSet'></span>

<h3>Description</h3>

<p>To be used instead of accessing ds$FV directly, since in the case of constrained
problems, the violation handling should be applied before using the function values
Constraint penalty function should be set in global options, as IOHanalyzer.Violation_Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_FV(ds, ...)

## S3 method for class 'DataSet'
get_FV(ds, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_FV_+3A_ds">ds</code></td>
<td>
<p>The DataSet</p>
</td></tr>
<tr><td><code id="get_FV_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of FV values in the dataset, penalized if applicable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_FV(dsl[[1]])
</code></pre>

<hr>
<h2 id='get_FV_overview'>Get Function Value condensed overview</h2><span id='topic+get_FV_overview'></span><span id='topic+get_FV_overview.DataSet'></span><span id='topic+get_FV_overview.DataSetList'></span>

<h3>Description</h3>

<p>Get Function Value condensed overview
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_FV_overview(ds, ...)

## S3 method for class 'DataSet'
get_FV_overview(ds, ...)

## S3 method for class 'DataSetList'
get_FV_overview(ds, algorithm = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_FV_overview_+3A_ds">ds</code></td>
<td>
<p>A 'DataSet' or 'DataSetList' object</p>
</td></tr>
<tr><td><code id="get_FV_overview_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="get_FV_overview_+3A_algorithm">algorithm</code></td>
<td>
<p>DEPRECATED, will be removed in next release. Which algorithms in the DataSetList to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing the algorithm ID, best, worst and mean reached function
values, the number of runs and available budget for the DataSet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_FV_overview(dsl)
get_FV_overview(dsl[[1]])
get_FV_overview(dsl, algorithm = '(1+1)_greedy_hill_climber_1')
</code></pre>

<hr>
<h2 id='get_FV_sample'>Get Funtion Value Samples</h2><span id='topic+get_FV_sample'></span><span id='topic+get_FV_sample.DataSet'></span><span id='topic+get_FV_sample.DataSetList'></span>

<h3>Description</h3>

<p>Get Funtion Value Samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_FV_sample(ds, ...)

## S3 method for class 'DataSet'
get_FV_sample(ds, runtime, output = "wide", ...)

## S3 method for class 'DataSetList'
get_FV_sample(ds, runtime, algorithm = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_FV_sample_+3A_ds">ds</code></td>
<td>
<p>A DataSet or DataSetList object</p>
</td></tr>
<tr><td><code id="get_FV_sample_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="get_FV_sample_+3A_runtime">runtime</code></td>
<td>
<p>A Numerical vector. Runtimes at which function values are reached</p>
</td></tr>
<tr><td><code id="get_FV_sample_+3A_output">output</code></td>
<td>
<p>A String. The format of the output data: 'wide' or 'long'</p>
</td></tr>
<tr><td><code id="get_FV_sample_+3A_algorithm">algorithm</code></td>
<td>
<p>DEPRECATED, will be removed in next release. Which algorithms in the DataSetList to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing the function value samples for each provided
target runtime
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_FV_sample(dsl, 100)
get_FV_sample(dsl[[1]], 100)
</code></pre>

<hr>
<h2 id='get_FV_summary'>Get Function Value Summary</h2><span id='topic+get_FV_summary'></span><span id='topic+get_FV_summary.DataSet'></span><span id='topic+get_FV_summary.DataSetList'></span>

<h3>Description</h3>

<p>Get Function Value Summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_FV_summary(ds, ...)

## S3 method for class 'DataSet'
get_FV_summary(ds, runtime, include_geom_mean = F, ...)

## S3 method for class 'DataSetList'
get_FV_summary(ds, runtime, algorithm = "all", include_geom_mean = F, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_FV_summary_+3A_ds">ds</code></td>
<td>
<p>A DataSet or DataSetList object</p>
</td></tr>
<tr><td><code id="get_FV_summary_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="get_FV_summary_+3A_runtime">runtime</code></td>
<td>
<p>A Numerical vector. Runtimes at which function values are reached</p>
</td></tr>
<tr><td><code id="get_FV_summary_+3A_include_geom_mean">include_geom_mean</code></td>
<td>
<p>Boolean to indicate whether to include the geometric mean.
Only works in fixed_budget mode. Negative values cause NaN, zeros cause output to be completely 0. Defaults to False.</p>
</td></tr>
<tr><td><code id="get_FV_summary_+3A_algorithm">algorithm</code></td>
<td>
<p>DEPRECATED, will be removed in next release. Which algorithms in the DataSetList to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing the function value statistics for each provided
target runtime value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_FV_summary(dsl, 100)
get_FV_summary(dsl[[1]], 100)
</code></pre>

<hr>
<h2 id='get_id'>Get condensed overview of datasets</h2><span id='topic+get_id'></span><span id='topic+get_id.DataSet'></span><span id='topic+get_id.DataSetList'></span>

<h3>Description</h3>

<p>Get the unique identifiers for each DataSet in the provided DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_id(ds, ...)

## S3 method for class 'DataSet'
get_id(ds, ...)

## S3 method for class 'DataSetList'
get_id(ds, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_id_+3A_ds">ds</code></td>
<td>
<p>The DataSetList</p>
</td></tr>
<tr><td><code id="get_id_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no unique identifier is set (using 'change_id' or done in DataSet construction from 1.6.0 onwards),
this function falls back on returning the algorith id (from 'get_aldId')to ensure backwards compatibility
</p>


<h3>Value</h3>

<p>The list of unique identiefiers present in dsl
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_id(dsl)
get_id(dsl[[1]])
</code></pre>

<hr>
<h2 id='get_line_style'>Get line styles according to the current styleScheme of the IOHanalyzer</h2><span id='topic+get_line_style'></span>

<h3>Description</h3>

<p>Get line styles according to the current styleScheme of the IOHanalyzer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_line_style(ids_in)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_line_style_+3A_ids_in">ids_in</code></td>
<td>
<p>List of algorithms (or custom ids, see 'change_id') for which to get linestyles</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>get_line_style(get_algId(dsl))
</code></pre>

<hr>
<h2 id='get_marg_contrib_ecdf'>Get the marginal contribution of an algorithm to a portfolio</h2><span id='topic+get_marg_contrib_ecdf'></span>

<h3>Description</h3>

<p>Based on the contribution to the ECDF-curve of the VBS of the portfolio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_marg_contrib_ecdf(id, perm, j, dt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_marg_contrib_ecdf_+3A_id">id</code></td>
<td>
<p>The id for which to get the contribution</p>
</td></tr>
<tr><td><code id="get_marg_contrib_ecdf_+3A_perm">perm</code></td>
<td>
<p>The permutation of algorithms to which is being contributed</p>
</td></tr>
<tr><td><code id="get_marg_contrib_ecdf_+3A_j">j</code></td>
<td>
<p>At which point in the permutation the contribution should be measured</p>
</td></tr>
<tr><td><code id="get_marg_contrib_ecdf_+3A_dt">dt</code></td>
<td>
<p>The datatable in which the raw ecdf-values are stored (see 'generate_data.ECDF_raw')</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- generate_data.ECDF_raw(dsl, get_ECDF_targets(dsl))
get_marg_contrib_ecdf(get_id(dsl)[[1]], get_id(dsl), 1, dt)
</code></pre>

<hr>
<h2 id='get_maxRT'>Get the maximal running time</h2><span id='topic+get_maxRT'></span><span id='topic+get_maxRT.DataSet'></span><span id='topic+get_maxRT.DataSetList'></span>

<h3>Description</h3>

<p>Get the maximal running time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_maxRT(ds, ...)

## S3 method for class 'DataSet'
get_maxRT(ds, output = "wide", ...)

## S3 method for class 'DataSetList'
get_maxRT(ds, algorithm = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_maxRT_+3A_ds">ds</code></td>
<td>
<p>A DataSet or DataSetList object</p>
</td></tr>
<tr><td><code id="get_maxRT_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="get_maxRT_+3A_output">output</code></td>
<td>
<p>The format of the outputted table: 'wide' or 'long'</p>
</td></tr>
<tr><td><code id="get_maxRT_+3A_algorithm">algorithm</code></td>
<td>
<p>DEPRECATED, will be removed in next release. Which algorithms in the DataSetList to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table object containing the algorithm ID and the running time
when the algorithm terminates in each run
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_maxRT(dsl)
get_maxRT(dsl[[1]])
</code></pre>

<hr>
<h2 id='get_ontology_data'>Get the list of available options for data from the OPTION ontology</h2><span id='topic+get_ontology_data'></span>

<h3>Description</h3>

<p>Get the list of available options for data from the OPTION ontology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ontology_data(
  datasource,
  fids,
  dims,
  algs,
  iids = NULL,
  funcsuites = NULL,
  min_target = NULL,
  max_target = NULL,
  min_budget = NULL,
  max_budget = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_ontology_data_+3A_datasource">datasource</code></td>
<td>
<p>The datasource: either BBOB or Nevergrad</p>
</td></tr>
<tr><td><code id="get_ontology_data_+3A_fids">fids</code></td>
<td>
<p>The function names as given by 'get_ontology_var'</p>
</td></tr>
<tr><td><code id="get_ontology_data_+3A_dims">dims</code></td>
<td>
<p>The dimensionalities as given by 'get_ontology_var'</p>
</td></tr>
<tr><td><code id="get_ontology_data_+3A_algs">algs</code></td>
<td>
<p>The algorithm names as given by 'get_ontology_var'</p>
</td></tr>
<tr><td><code id="get_ontology_data_+3A_iids">iids</code></td>
<td>
<p>The instances as given by 'get_ontology_var' (only for BBOB data)</p>
</td></tr>
<tr><td><code id="get_ontology_data_+3A_funcsuites">funcsuites</code></td>
<td>
<p>The function suite as given by 'get_ontology_var' (only for Nevergrad data)</p>
</td></tr>
<tr><td><code id="get_ontology_data_+3A_min_target">min_target</code></td>
<td>
<p>The minimum target value for which to return data</p>
</td></tr>
<tr><td><code id="get_ontology_data_+3A_max_target">max_target</code></td>
<td>
<p>The maximum target value for which to return data</p>
</td></tr>
<tr><td><code id="get_ontology_data_+3A_min_budget">min_budget</code></td>
<td>
<p>The minimum budget value for which to return data</p>
</td></tr>
<tr><td><code id="get_ontology_data_+3A_max_budget">max_budget</code></td>
<td>
<p>The maximum budget value for which to return data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a DataSetList object matching the selected attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_ontology_data("BBOB", "f5", 5, "IPOP400D", 1)
</code></pre>

<hr>
<h2 id='get_ontology_var'>Get the list of available options for data from the OPTION ontology</h2><span id='topic+get_ontology_var'></span>

<h3>Description</h3>

<p>Get the list of available options for data from the OPTION ontology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ontology_var(varname, datasource = NULL, study = NULL, algs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_ontology_var_+3A_varname">varname</code></td>
<td>
<p>The variable for which to get the options. Restricted to [Fid, Iid, DIM, AlgId, Suite]</p>
</td></tr>
<tr><td><code id="get_ontology_var_+3A_datasource">datasource</code></td>
<td>
<p>The datasource for which to get the attributes. Either BBOB
or Nevergrad, or NULL if looking at a specific 'study' argument</p>
</td></tr>
<tr><td><code id="get_ontology_var_+3A_study">study</code></td>
<td>
<p>Which study to load the requested variables for (NULL if no study is considered)</p>
</td></tr>
<tr><td><code id="get_ontology_var_+3A_algs">algs</code></td>
<td>
<p>Which algorithms to get the requested variables for. Required for varnames in [Fid, Iid, DIM]</p>
</td></tr>
<tr><td><code id="get_ontology_var_+3A_...">...</code></td>
<td>
<p>Additional arguments to the OPTION call. Currently only supports 'Suite' for nevergrad.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the options of varname given the specified datasource
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_ontology_var("Fid", "BBOB")
</code></pre>

<hr>
<h2 id='get_overview'>Get condensed overview of datasets</h2><span id='topic+get_overview'></span><span id='topic+get_overview.DataSet'></span><span id='topic+get_overview.DataSetList'></span>

<h3>Description</h3>

<p>Get condensed overview of datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_overview(ds, ...)

## S3 method for class 'DataSet'
get_overview(ds, ...)

## S3 method for class 'DataSetList'
get_overview(ds, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_overview_+3A_ds">ds</code></td>
<td>
<p>A DataSet or DataSetList object</p>
</td></tr>
<tr><td><code id="get_overview_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing some basic information about the provided DataSet(List)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_overview(dsl)
get_overview(dsl[[1]])
</code></pre>

<hr>
<h2 id='get_PAR_name'>Get the parameter names of the algorithm</h2><span id='topic+get_PAR_name'></span><span id='topic+get_PAR_name.DataSet'></span>

<h3>Description</h3>

<p>Get the parameter names of the algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_PAR_name(ds, which)

## S3 method for class 'DataSet'
get_PAR_name(ds, which = "by_FV")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_PAR_name_+3A_ds">ds</code></td>
<td>
<p>A DataSet object</p>
</td></tr>
<tr><td><code id="get_PAR_name_+3A_which">which</code></td>
<td>
<p>a string takes it value in &lsquo;c(&rsquo;by_FV', 'by_RT')', indicating the
parameters aligned against the running time (RT) or function value (FV). ''by_FV''
is the default value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character list of paramter names, if recorded in the data set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_PAR_name(dsl[[1]])
</code></pre>

<hr>
<h2 id='get_PAR_sample'>Get Parameter Value Samples</h2><span id='topic+get_PAR_sample'></span><span id='topic+get_PAR_sample.DataSet'></span><span id='topic+get_PAR_sample.DataSetList'></span>

<h3>Description</h3>

<p>Get Parameter Value Samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_PAR_sample(ds, idxValue, ...)

## S3 method for class 'DataSet'
get_PAR_sample(
  ds,
  idxValue,
  parId = "all",
  which = "by_FV",
  output = "wide",
  ...
)

## S3 method for class 'DataSetList'
get_PAR_sample(ds, idxValue, algorithm = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_PAR_sample_+3A_ds">ds</code></td>
<td>
<p>A DataSet or DataSetList object</p>
</td></tr>
<tr><td><code id="get_PAR_sample_+3A_idxvalue">idxValue</code></td>
<td>
<p>A Numerical vector. Index values at which parameter values are observed.
The index value can either take its value in the range of running times, or function values.
Such a value type is signified by 'which' parameter.</p>
</td></tr>
<tr><td><code id="get_PAR_sample_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="get_PAR_sample_+3A_parid">parId</code></td>
<td>
<p>A character vector. Either 'all' or the name of parameters to be retrieved</p>
</td></tr>
<tr><td><code id="get_PAR_sample_+3A_which">which</code></td>
<td>
<p>A string takes values in &lsquo;c(&rsquo;by_FV', 'by_RT')', indicating the parameters to be
retrieved are aligned against the running time (RT) or function value (FV). ''by_FV''
is the default value.</p>
</td></tr>
<tr><td><code id="get_PAR_sample_+3A_output">output</code></td>
<td>
<p>A character. The format of the output data: 'wide' or 'long'</p>
</td></tr>
<tr><td><code id="get_PAR_sample_+3A_algorithm">algorithm</code></td>
<td>
<p>DEPRECATED, will be removed in next release. Which algorithms in the DataSetList to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table object containing parameter values aligned at each given target value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_PAR_sample(dsl, 14)
get_PAR_sample(dsl[[1]], 14)
</code></pre>

<hr>
<h2 id='get_PAR_summary'>Get Parameter Value Summary</h2><span id='topic+get_PAR_summary'></span><span id='topic+get_PAR_summary.DataSet'></span><span id='topic+get_PAR_summary.DataSetList'></span>

<h3>Description</h3>

<p>Get Parameter Value Summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_PAR_summary(ds, idxValue, ...)

## S3 method for class 'DataSet'
get_PAR_summary(ds, idxValue, parId = "all", which = "by_FV", ...)

## S3 method for class 'DataSetList'
get_PAR_summary(ds, idxValue, algorithm = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_PAR_summary_+3A_ds">ds</code></td>
<td>
<p>A DataSet or DataSetList object</p>
</td></tr>
<tr><td><code id="get_PAR_summary_+3A_idxvalue">idxValue</code></td>
<td>
<p>A Numerical vector. Index values at which parameter values are observed.
The index value can either take its value in the range of running times, or function values.
Such a value type is signified by 'which' parameter.</p>
</td></tr>
<tr><td><code id="get_PAR_summary_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="get_PAR_summary_+3A_parid">parId</code></td>
<td>
<p>A character vector. Either 'all' or the name of parameters to be retrieved</p>
</td></tr>
<tr><td><code id="get_PAR_summary_+3A_which">which</code></td>
<td>
<p>A string takes values in &lsquo;c(&rsquo;by_FV', 'by_RT')', indicating the parameters to be
retrieved are aligned against the running time (RT) or function value (FV). ''by_FV''
is the default value.</p>
</td></tr>
<tr><td><code id="get_PAR_summary_+3A_algorithm">algorithm</code></td>
<td>
<p>DEPRECATED, will be removed in next release. Which algorithms in the DataSetList to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table object containing basic statistics of parameter values aligned at each given target value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_PAR_summary(dsl, 14)
get_PAR_summary(dsl[[1]], 14)
</code></pre>

<hr>
<h2 id='get_parId'>Get all parameter ids present in a DataSetList</h2><span id='topic+get_parId'></span>

<h3>Description</h3>

<p>Get all parameter ids present in a DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parId(dsList, which = "by_FV")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_parId_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList</p>
</td></tr>
<tr><td><code id="get_parId_+3A_which">which</code></td>
<td>
<p>A string takes values in &lsquo;c(&rsquo;by_FV', 'by_RT')'. To choose the parameters aligned
by the running time (RT) or the function value (FV). Note that parameters in each case are
not necessary the same.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sorted list of all unique parameter ids which occur in the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_parId(dsl)
</code></pre>

<hr>
<h2 id='get_position_dsl'>Extract the position information from a datasetlist object</h2><span id='topic+get_position_dsl'></span>

<h3>Description</h3>

<p>Extract the position information from a datasetlist object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_position_dsl(dsList, iid)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_position_dsl_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="get_position_dsl_+3A_iid">iid</code></td>
<td>
<p>the Instance Id from which to get the position history (can be a list)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>get_position_dsl(subset(dsl, funcId == 1), 1)
</code></pre>

<hr>
<h2 id='get_RT'>Get runtime matrix of the used dataset.</h2><span id='topic+get_RT'></span><span id='topic+get_RT.DataSet'></span>

<h3>Description</h3>

<p>To be used instead of accessing ds$RT directly, since in the case of constrained
problems, the violation handling should be applied before using the function values
Constraint penalty function should be set in global options, as IOHanalyzer.Violation_Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_RT(ds, ...)

## S3 method for class 'DataSet'
get_RT(ds, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_RT_+3A_ds">ds</code></td>
<td>
<p>The DataSet</p>
</td></tr>
<tr><td><code id="get_RT_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of FV values in the dataset, penalized if applicable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_RT(dsl[[1]])
</code></pre>

<hr>
<h2 id='get_RT_overview'>Get Runtime Value condensed overview</h2><span id='topic+get_RT_overview'></span><span id='topic+get_RT_overview.DataSet'></span><span id='topic+get_RT_overview.DataSetList'></span>

<h3>Description</h3>

<p>Get Runtime Value condensed overview
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_RT_overview(ds, ...)

## S3 method for class 'DataSet'
get_RT_overview(ds, ...)

## S3 method for class 'DataSetList'
get_RT_overview(ds, algorithm = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_RT_overview_+3A_ds">ds</code></td>
<td>
<p>A DataSet or DataSetList object</p>
</td></tr>
<tr><td><code id="get_RT_overview_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="get_RT_overview_+3A_algorithm">algorithm</code></td>
<td>
<p>DEPRECATED, will be removed in next release. Which algorithms in the DataSetList to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing the algorithm ID, minimum and maximum used evaluations,
number of runs and available budget for the DataSet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_RT_overview(dsl)
get_RT_overview(dsl[[1]])
</code></pre>

<hr>
<h2 id='get_RT_sample'>Get RunTime Sample</h2><span id='topic+get_RT_sample'></span><span id='topic+get_RT_sample.DataSet'></span><span id='topic+get_RT_sample.DataSetList'></span>

<h3>Description</h3>

<p>Get RunTime Sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_RT_sample(ds, ftarget, ...)

## S3 method for class 'DataSet'
get_RT_sample(ds, ftarget, output = "wide", ...)

## S3 method for class 'DataSetList'
get_RT_sample(ds, ftarget, algorithm = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_RT_sample_+3A_ds">ds</code></td>
<td>
<p>A DataSet or DataSetList object</p>
</td></tr>
<tr><td><code id="get_RT_sample_+3A_ftarget">ftarget</code></td>
<td>
<p>A Numerical vector. Function values at which runtime values are consumed</p>
</td></tr>
<tr><td><code id="get_RT_sample_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="get_RT_sample_+3A_output">output</code></td>
<td>
<p>A character determining the format of output data.table: 'wide' or 'long'</p>
</td></tr>
<tr><td><code id="get_RT_sample_+3A_algorithm">algorithm</code></td>
<td>
<p>DEPRECATED, will be removed in next release. Which algorithms in the DataSetList to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing the runtime samples for each provided target
function value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_RT_sample(dsl, 14)
get_RT_sample(dsl[[1]], 14)
</code></pre>

<hr>
<h2 id='get_RT_summary'>Get RunTime Summary</h2><span id='topic+get_RT_summary'></span><span id='topic+get_RT_summary.DataSet'></span><span id='topic+get_RT_summary.DataSetList'></span>

<h3>Description</h3>

<p>Get RunTime Summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_RT_summary(ds, ftarget, budget, ...)

## S3 method for class 'DataSet'
get_RT_summary(ds, ftarget, budget = NULL, ...)

## S3 method for class 'DataSetList'
get_RT_summary(ds, ftarget, budget = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_RT_summary_+3A_ds">ds</code></td>
<td>
<p>A DataSet or DataSetList object</p>
</td></tr>
<tr><td><code id="get_RT_summary_+3A_ftarget">ftarget</code></td>
<td>
<p>The function target(s) for which to get the runtime summary</p>
</td></tr>
<tr><td><code id="get_RT_summary_+3A_budget">budget</code></td>
<td>
<p>Optional; overwrites the budget found in ds for ERT-calculation</p>
</td></tr>
<tr><td><code id="get_RT_summary_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing the runtime statistics for each provided target
function value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_RT_summary(dsl, 14)
get_RT_summary(dsl[[1]], 14)
</code></pre>

<hr>
<h2 id='get_runtimes'>Get all runtime values present in a DataSetList</h2><span id='topic+get_runtimes'></span>

<h3>Description</h3>

<p>Get all runtime values present in a DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_runtimes(dsList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_runtimes_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetLsit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list matrices of all runtime values which occur in the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_runtimes(dsl)
</code></pre>

<hr>
<h2 id='get_shapley_values'>Get the shapley-values of a portfolio of algorithms</h2><span id='topic+get_shapley_values'></span>

<h3>Description</h3>

<p>Based on the contribution to the ECDF-curve of the VBS of the portfolio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_shapley_values(
  dsList,
  targets,
  scale.log = T,
  group_size = 5,
  max_perm_size = 10,
  normalize = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_shapley_values_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetList object</p>
</td></tr>
<tr><td><code id="get_shapley_values_+3A_targets">targets</code></td>
<td>
<p>A list or data.table containing the targets per function / dimension. If this is
a data.table, it needs columns 'target', 'DIM' and 'funcId'</p>
</td></tr>
<tr><td><code id="get_shapley_values_+3A_scale.log">scale.log</code></td>
<td>
<p>Whether to use logarithmic scaling for the runtimes at which the ecdf will be sampled or not</p>
</td></tr>
<tr><td><code id="get_shapley_values_+3A_group_size">group_size</code></td>
<td>
<p>How many permutation groups will be considered</p>
</td></tr>
<tr><td><code id="get_shapley_values_+3A_max_perm_size">max_perm_size</code></td>
<td>
<p>The maximum limit for permutations to be considered</p>
</td></tr>
<tr><td><code id="get_shapley_values_+3A_normalize">normalize</code></td>
<td>
<p>Whether or not to ensure the resulting values will be in [0,1]</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dsl_sub &lt;- subset(dsl, funcId == 1)
get_shapley_values(dsl_sub, get_ECDF_targets(dsl_sub), group_size = 2)
</code></pre>

<hr>
<h2 id='get_static_attribute_values'>Get all options for a specific attribute which can be used to subset a DataSetList</h2><span id='topic+get_static_attribute_values'></span>

<h3>Description</h3>

<p>This is a more generic version of the existing 'get_dim', 'get_funcId' and 'get_algId' functions.
Note the only attributes returned by 'get_static_attributes' are supported in this funcion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_static_attribute_values(dsl, attribute)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_static_attribute_values_+3A_dsl">dsl</code></td>
<td>
<p>The DataSetList</p>
</td></tr>
<tr><td><code id="get_static_attribute_values_+3A_attribute">attribute</code></td>
<td>
<p>the name of the attribute for which to get the available options in dsl</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of options for the specified attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_static_attribute_values(dsl, 'funcId')
</code></pre>

<hr>
<h2 id='get_static_attributes'>Get all attributes which can be used to subset a DataSetList</h2><span id='topic+get_static_attributes'></span>

<h3>Description</h3>

<p>Get all attributes which can be used to subset a DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_static_attributes(dsl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_static_attributes_+3A_dsl">dsl</code></td>
<td>
<p>The DataSetList</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of available attributes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_static_attributes(dsl)
</code></pre>

<hr>
<h2 id='get_target_dt'>Generate datatables of runtime or function value targets for a DataSetList</h2><span id='topic+get_target_dt'></span>

<h3>Description</h3>

<p>Only one target is generated per (function, dimension)-pair, as opposed to the
function 'get_default_ECDF_targets', which generates multiple targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_target_dt(dsList, which = "by_RT")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_target_dt_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList</p>
</td></tr>
<tr><td><code id="get_target_dt_+3A_which">which</code></td>
<td>
<p>Whether to generate fixed-target ('by_FV') or fixed-budget ('by_RT') targets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table of targets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_target_dt(dsl)
</code></pre>

<hr>
<h2 id='glicko2_ranking'>Glicko2 raning of algorithms</h2><span id='topic+glicko2_ranking'></span>

<h3>Description</h3>

<p>This procedure ranks algorithms based on a glicko2-procedure.
Every round (total nr_rounds), for every function and dimension of the datasetlist,
each pair of algorithms competes. This competition samples a random runtime for the
provided target (defaults to best achieved target). Whichever algorithm has the lower
runtime wins the game. Then, from these games, the glicko2-rating is determined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glicko2_ranking(dsl, nr_rounds = 100, which = "by_FV", target_dt = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glicko2_ranking_+3A_dsl">dsl</code></td>
<td>
<p>The DataSetList, can contain multiple functions and dimensions, but should have the
same algorithms for all of them</p>
</td></tr>
<tr><td><code id="glicko2_ranking_+3A_nr_rounds">nr_rounds</code></td>
<td>
<p>The number of rounds to run. More rounds leads to a more accurate ranking.</p>
</td></tr>
<tr><td><code id="glicko2_ranking_+3A_which">which</code></td>
<td>
<p>Whether to use fixed-target ('by_FV') or fixed-budget ('by_RT') perspective</p>
</td></tr>
<tr><td><code id="glicko2_ranking_+3A_target_dt">target_dt</code></td>
<td>
<p>Custom data.table target value to use. When NULL, this is selected automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the glicko2-ratings and some additional info
</p>


<h3>Examples</h3>

<pre><code class='language-R'>glicko2_ranking(dsl, nr_round = 25)
glicko2_ranking(dsl, nr_round = 25, which = 'by_RT')
</code></pre>

<hr>
<h2 id='IOH_plot_ly_default'>Template for creating plots in the IOHanalyzer-style</h2><span id='topic+IOH_plot_ly_default'></span>

<h3>Description</h3>

<p>Template for creating plots in the IOHanalyzer-style
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IOH_plot_ly_default(title = NULL, x.title = NULL, y.title = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IOH_plot_ly_default_+3A_title">title</code></td>
<td>
<p>Title for the plot</p>
</td></tr>
<tr><td><code id="IOH_plot_ly_default_+3A_x.title">x.title</code></td>
<td>
<p>X-axis label</p>
</td></tr>
<tr><td><code id="IOH_plot_ly_default_+3A_y.title">y.title</code></td>
<td>
<p>Y-axis label</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>IOH_plot_ly_default("Example plot","x-axis","y-axis")
</code></pre>

<hr>
<h2 id='IOHanlyzer-deprecated'>Deprecated function in package <span class="pkg">IOHanalyzer</span></h2><span id='topic+IOHanlyzer-deprecated'></span>

<h3>Description</h3>

<p>The functions listed below are deprecated and will be defunct in
the near future. When possible, alternative functions with similar
functionality are also mentioned.
</p>

<hr>
<h2 id='limit.data'>Reduce the size of the data set by evenly subsampling the records</h2><span id='topic+limit.data'></span>

<h3>Description</h3>

<p>Reduce the size of the data set by evenly subsampling the records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limit.data(df, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="limit.data_+3A_df">df</code></td>
<td>
<p>The data to subsample</p>
</td></tr>
<tr><td><code id="limit.data_+3A_n">n</code></td>
<td>
<p>The amount of samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A smaller data.frame
</p>

<hr>
<h2 id='max_ERTs'>Get the ERT-values for all DataSets in a DataSetList at certain targets</h2><span id='topic+max_ERTs'></span><span id='topic+max_ERTs.DataSetList'></span>

<h3>Description</h3>

<p>Get the ERT-values for all DataSets in a DataSetList at certain targets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_ERTs(dsList, aggr_on = "funcId", targets = NULL, maximize = T)

## S3 method for class 'DataSetList'
max_ERTs(dsList, aggr_on = "funcId", targets = NULL, maximize = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max_ERTs_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetLsit</p>
</td></tr>
<tr><td><code id="max_ERTs_+3A_aggr_on">aggr_on</code></td>
<td>
<p>Whether to aggregate on 'funcId' or 'DIM'.</p>
</td></tr>
<tr><td><code id="max_ERTs_+3A_targets">targets</code></td>
<td>
<p>Predifined target function-values. Should be one for each function/dimension</p>
</td></tr>
<tr><td><code id="max_ERTs_+3A_maximize">maximize</code></td>
<td>
<p>Whether the DataSetList is from a maximization or minimization problem</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing ERT-values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>max_ERTs(dsl)
</code></pre>

<hr>
<h2 id='mean_FVs'>Get the expected function-values for all DataSets in a DataSetList at certain runtimes</h2><span id='topic+mean_FVs'></span><span id='topic+mean_FVs.DataSetList'></span>

<h3>Description</h3>

<p>Get the expected function-values for all DataSets in a DataSetList at certain runtimes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_FVs(dsList, aggr_on = "funcId", runtimes = NULL)

## S3 method for class 'DataSetList'
mean_FVs(dsList, aggr_on = "funcId", runtimes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_FVs_+3A_dslist">dsList</code></td>
<td>
<p>The DataSetLsit</p>
</td></tr>
<tr><td><code id="mean_FVs_+3A_aggr_on">aggr_on</code></td>
<td>
<p>Whether to aggregate on 'funcId' or 'DIM'.</p>
</td></tr>
<tr><td><code id="mean_FVs_+3A_runtimes">runtimes</code></td>
<td>
<p>Predifined target runtimes-values. Should be one for each function/dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing expected fucntion-values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean_FVs(dsl)
</code></pre>

<hr>
<h2 id='pairwise.test'>Performs a pairwise Kolmogorov-Smirnov test on the bootstrapped running times
among a data set</h2><span id='topic+pairwise.test'></span><span id='topic+pairwise.test.list'></span><span id='topic+pairwise.test.DataSetList'></span>

<h3>Description</h3>

<p>This function performs a Kolmogorov-Smirnov test on each pair of
algorithms in the input x to determine which algorithm gives a significantly
smaller running time. The resulting p-values are arranged in a matrix, where
each cell (i, j) contains a p-value from the test with alternative hypothesis:
the running time of algorithm i is smaller (thus better) than that of j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.test(x, ...)

## S3 method for class 'list'
pairwise.test(x, max_eval, bootstrap.size = 30, ...)

## S3 method for class 'DataSetList'
pairwise.test(x, ftarget, bootstrap.size = 0, which = "by_FV", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise.test_+3A_x">x</code></td>
<td>
<p>either a list that contains running time sample for each algorithm as
sub-lists, or a DataSetList object</p>
</td></tr>
<tr><td><code id="pairwise.test_+3A_...">...</code></td>
<td>
<p>all other options</p>
</td></tr>
<tr><td><code id="pairwise.test_+3A_max_eval">max_eval</code></td>
<td>
<p>list that contains the maximal running time for each algorithm
as sub-lists</p>
</td></tr>
<tr><td><code id="pairwise.test_+3A_bootstrap.size">bootstrap.size</code></td>
<td>
<p>integer, the size of the bootstrapped sample. Set to 0 to disable bootstrapping</p>
</td></tr>
<tr><td><code id="pairwise.test_+3A_ftarget">ftarget</code></td>
<td>
<p>float, the target value used to determine the running / hitting</p>
</td></tr>
<tr><td><code id="pairwise.test_+3A_which">which</code></td>
<td>
<p>wheter to do fixed-target ('by_FV') or fixed-budget ('by_RT') comparison
time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing p-values of the test
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pairwise.test(subset(dsl, funcId == 1), 16)
</code></pre>

<hr>
<h2 id='plot_eaf_data'>Create EAF-based polygon plots</h2><span id='topic+plot_eaf_data'></span>

<h3>Description</h3>

<p>Create EAF-based polygon plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_eaf_data(
  df,
  maximization = F,
  scale.xlog = F,
  scale.ylog = F,
  scale.reverse = F,
  p = NULL,
  x_title = NULL,
  xmin = NULL,
  xmax = NULL,
  ymin = NULL,
  ymax = NULL,
  y_title = NULL,
  plot_title = NULL,
  subplot_attr = NULL,
  show.colorbar = F,
  subplot_shareX = F,
  dt_overlay = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_eaf_data_+3A_df">df</code></td>
<td>
<p>The dataframe containing the data to plot. This should come from 'generate_data.EAF'</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_maximization">maximization</code></td>
<td>
<p>Whether the data comes from maximization or minimization</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Logarithmic scaling of x-axis</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Logarithmic scaling of y-axis</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_scale.reverse">scale.reverse</code></td>
<td>
<p>Decreasing or increasing x-axis</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_p">p</code></td>
<td>
<p>A previously existing plot on which to add traces. If NULL, a new canvas is created</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_x_title">x_title</code></td>
<td>
<p>Title of x-axis. Defaults to x_attr</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_xmin">xmin</code></td>
<td>
<p>Minimum value for the x-axis</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_xmax">xmax</code></td>
<td>
<p>Maximum value for the x-axis</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_ymin">ymin</code></td>
<td>
<p>Minimum value for the y-axis</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_ymax">ymax</code></td>
<td>
<p>Maximum value for the y-axis</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_y_title">y_title</code></td>
<td>
<p>Title of x-axis. Defaults to x_attr</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_plot_title">plot_title</code></td>
<td>
<p>Title of x-axis. Defaults to no title</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_subplot_attr">subplot_attr</code></td>
<td>
<p>Which attribute of the dataframe to use for creating subplots</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_show.colorbar">show.colorbar</code></td>
<td>
<p>Whether or not to include a colorbar</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_subplot_sharex">subplot_shareX</code></td>
<td>
<p>Whether or not to share X-axis when using subplots</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_dt_overlay">dt_overlay</code></td>
<td>
<p>Dataframe containing additional data (e.g. quantiles) to plot
on top of the EAF. This should have a column labeled 'runtime'. The other columsn will
all be plotted as function values.</p>
</td></tr>
<tr><td><code id="plot_eaf_data_+3A_...">...</code></td>
<td>
<p>Additional parameters for the add_trace function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An EAF plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot_eaf_data(generate_data.EAF(subset(dsl, ID==get_id(dsl)[[1]])), maximization=T)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_eaf_differences'>Create EAF-difference contour plots</h2><span id='topic+plot_eaf_differences'></span>

<h3>Description</h3>

<p>Create EAF-difference contour plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_eaf_differences(
  matrices,
  scale.xlog = T,
  scale.ylog = F,
  zero_transparant = F,
  show_negatives = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_eaf_differences_+3A_matrices">matrices</code></td>
<td>
<p>The dataframes containing the data to plot. This should come from 'generate_data.EAF_diff_Approximate'</p>
</td></tr>
<tr><td><code id="plot_eaf_differences_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Logarithmic scaling of x-axis</p>
</td></tr>
<tr><td><code id="plot_eaf_differences_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Logarithmic scaling of y-axis</p>
</td></tr>
<tr><td><code id="plot_eaf_differences_+3A_zero_transparant">zero_transparant</code></td>
<td>
<p>Whether values of 0 should be made transparant or not</p>
</td></tr>
<tr><td><code id="plot_eaf_differences_+3A_show_negatives">show_negatives</code></td>
<td>
<p>Whether to also show negative values or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>EAF difference plots
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot_eaf_differences(generate_data.EAF_diff_Approximate(subset(dsl, funcId == 1), 1, 50, 1, 16))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_general_data'>General function for plotting within IOHanalyzer</h2><span id='topic+plot_general_data'></span>

<h3>Description</h3>

<p>General function for plotting within IOHanalyzer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_general_data(
  df,
  x_attr = "ID",
  y_attr = "vals",
  type = "violin",
  legend_attr = "ID",
  scale.xlog = F,
  scale.ylog = F,
  scale.reverse = F,
  p = NULL,
  x_title = NULL,
  y_title = NULL,
  plot_title = NULL,
  upper_attr = NULL,
  lower_attr = NULL,
  subplot_attr = NULL,
  show.legend = F,
  inf.action = "none",
  violin.showpoints = F,
  frame_attr = "frame",
  symbol_attr = "run_nr",
  subplot_shareX = F,
  line.step = F,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_general_data_+3A_df">df</code></td>
<td>
<p>The dataframe containing the data to plot. It should contain at least two columns:
'x_attr' and 'y_attr'</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_x_attr">x_attr</code></td>
<td>
<p>The column to specify the x_axis. Default is 'algId'</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_y_attr">y_attr</code></td>
<td>
<p>The column to specify the y_axis</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_type">type</code></td>
<td>
<p>The type of plot to use. Currently available: 'violin', 'line', 'radar',
'bar', hist' and 'ribbon'</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_legend_attr">legend_attr</code></td>
<td>
<p>Default is 'algId' This is also used for the selection of colorschemes</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Logarithmic scaling of x-axis</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Logarithmic scaling of y-axis</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_scale.reverse">scale.reverse</code></td>
<td>
<p>Decreasing or increasing x-axis</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_p">p</code></td>
<td>
<p>A previously existing plot on which to add traces. If NULL, a new canvas is created</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_x_title">x_title</code></td>
<td>
<p>Title of x-axis. Defaults to x_attr</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_y_title">y_title</code></td>
<td>
<p>Title of x-axis. Defaults to x_attr</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_plot_title">plot_title</code></td>
<td>
<p>Title of x-axis. Defaults to no title</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_upper_attr">upper_attr</code></td>
<td>
<p>When using ribbon-plot, this can be used to create a shaded area.
Only works in combination with&lsquo;lower_attr' and 'type' == &rsquo;ribbon'</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_lower_attr">lower_attr</code></td>
<td>
<p>When using ribbon-plot, this can be used to create a shaded area.
Only works in combination with&lsquo;upper_attr' and 'type' == &rsquo;ribbon'</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_subplot_attr">subplot_attr</code></td>
<td>
<p>Which attribute of the dataframe to use for creating subplots</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_show.legend">show.legend</code></td>
<td>
<p>Whether or not to include a legend</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_inf.action">inf.action</code></td>
<td>
<p>How to deal with infinite values. Can be 'none', 'overlap' or 'jitter'</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_violin.showpoints">violin.showpoints</code></td>
<td>
<p>Wheteher or not to show individual points when making a violinplot</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_frame_attr">frame_attr</code></td>
<td>
<p>Which attribute of the dataframe to use for the time element of the animation</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_symbol_attr">symbol_attr</code></td>
<td>
<p>Which attribute of the dataframe to use for the scatter symbol</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_subplot_sharex">subplot_shareX</code></td>
<td>
<p>Whether or not to share X-axis when using subplots</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_line.step">line.step</code></td>
<td>
<p>Whether to plot lines as a step-function (T) or as linear interpolation (F, default)</p>
</td></tr>
<tr><td><code id="plot_general_data_+3A_...">...</code></td>
<td>
<p>Additional parameters for the add_trace function</p>
</td></tr>
</table>

<hr>
<h2 id='Plot.Comparison.Heatmap'>Plot a heatmap according to the specifications from the Nevergrad dashboard</h2><span id='topic+Plot.Comparison.Heatmap'></span><span id='topic+Plot.Comparison.Heatmap.DataSetList'></span>

<h3>Description</h3>

<p>Plot a heatmap according to the specifications from the Nevergrad dashboard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.Comparison.Heatmap(dsList, target_dt, which = "by_FV")

## S3 method for class 'DataSetList'
Plot.Comparison.Heatmap(dsList, target_dt = NULL, which = "by_FV")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.Comparison.Heatmap_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.Comparison.Heatmap_+3A_target_dt">target_dt</code></td>
<td>
<p>A data-table containing the targets to condider on each function/dimension pair</p>
</td></tr>
<tr><td><code id="Plot.Comparison.Heatmap_+3A_which">which</code></td>
<td>
<p>Whether to use fixed-target ('by_FV') or fixed-budget ('by_RT') perspective</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap showing the fraction of times algorithm A beats algorithm B
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.Comparison.Heatmap(dsl)
</code></pre>

<hr>
<h2 id='Plot.cumulative_difference_plot'>Plot the cumulative difference plot given a DataSetList.</h2><span id='topic+Plot.cumulative_difference_plot'></span>

<h3>Description</h3>

<p>Plot the cumulative difference plot given a DataSetList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.cumulative_difference_plot(
  dsList,
  runtime_or_target_value,
  isFixedBudget,
  alpha = 0.05,
  EPSILON = 1e-80,
  nOfBootstrapSamples = 1000,
  dataAlreadyComputed = FALSE,
  precomputedData = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.cumulative_difference_plot_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension and two algorithms).</p>
</td></tr>
<tr><td><code id="Plot.cumulative_difference_plot_+3A_runtime_or_target_value">runtime_or_target_value</code></td>
<td>
<p>The target runtime or the target value</p>
</td></tr>
<tr><td><code id="Plot.cumulative_difference_plot_+3A_isfixedbudget">isFixedBudget</code></td>
<td>
<p>Should be TRUE when target runtime is used. False otherwise.</p>
</td></tr>
<tr><td><code id="Plot.cumulative_difference_plot_+3A_alpha">alpha</code></td>
<td>
<p>1 minus the confidence level of the confidence band.</p>
</td></tr>
<tr><td><code id="Plot.cumulative_difference_plot_+3A_epsilon">EPSILON</code></td>
<td>
<p>If abs(x-y) &lt; EPSILON, then we assume that x = y.</p>
</td></tr>
<tr><td><code id="Plot.cumulative_difference_plot_+3A_nofbootstrapsamples">nOfBootstrapSamples</code></td>
<td>
<p>The number of bootstrap samples used in the estimation.</p>
</td></tr>
<tr><td><code id="Plot.cumulative_difference_plot_+3A_dataalreadycomputed">dataAlreadyComputed</code></td>
<td>
<p>If false, 'generate_data.CDP' will be called to process the data.</p>
</td></tr>
<tr><td><code id="Plot.cumulative_difference_plot_+3A_precomputeddata">precomputedData</code></td>
<td>
<p>only needed when dataAlreadyComputed=TRUE. The result of 'generate_data.CDP'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cumulative difference plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dsl
dsl_sub &lt;- subset(dsl, funcId == 1)
target &lt;- 15

Plot.cumulative_difference_plot(dsl_sub, target, FALSE)
</code></pre>

<hr>
<h2 id='Plot.FV.Aggregated'>Plot expected function value-based comparison over multiple functions or dimensions</h2><span id='topic+Plot.FV.Aggregated'></span><span id='topic+Plot.FV.Aggregated.DataSetList'></span>

<h3>Description</h3>

<p>Plot expected function value-based comparison over multiple functions or dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.FV.Aggregated(
  dsList,
  aggr_on = "funcId",
  runtimes = NULL,
  plot_mode = "radar",
  use_rank = F,
  scale.ylog = T,
  fvs = NULL
)

## S3 method for class 'DataSetList'
Plot.FV.Aggregated(
  dsList,
  aggr_on = "funcId",
  runtimes = NULL,
  plot_mode = "radar",
  use_rank = F,
  scale.ylog = T,
  fvs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.FV.Aggregated_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function OR dimension).</p>
</td></tr>
<tr><td><code id="Plot.FV.Aggregated_+3A_aggr_on">aggr_on</code></td>
<td>
<p>Whether to compare on functions ('funcId') or dimensions ('DIM')</p>
</td></tr>
<tr><td><code id="Plot.FV.Aggregated_+3A_runtimes">runtimes</code></td>
<td>
<p>Custom list of function-value targets, one for each function or dimension.</p>
</td></tr>
<tr><td><code id="Plot.FV.Aggregated_+3A_plot_mode">plot_mode</code></td>
<td>
<p>How the plots should be created. Can be 'line' or 'radar'</p>
</td></tr>
<tr><td><code id="Plot.FV.Aggregated_+3A_use_rank">use_rank</code></td>
<td>
<p>Wheter to use a ranking system. If False, the actual expected function-
values will be used.</p>
</td></tr>
<tr><td><code id="Plot.FV.Aggregated_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Whether or not to scale the y-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.FV.Aggregated_+3A_fvs">fvs</code></td>
<td>
<p>Pre-calculated expected function-values for the provided runtimes Created by the
max_ERTs function of DataSetList. Can be provided to prevent needless computation
in recalculating ERTs when recreating this plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of expected function value-based comparison on the provided functions
or dimensions of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.FV.Aggregated(dsl)
</code></pre>

<hr>
<h2 id='Plot.FV.ECDF_AUC'>Radarplot of the area under the aggregated ECDF-curve of a DataSetList.</h2><span id='topic+Plot.FV.ECDF_AUC'></span><span id='topic+Plot.FV.ECDF_AUC.DataSetList'></span>

<h3>Description</h3>

<p>Radarplot of the area under the aggregated ECDF-curve of a DataSetList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.FV.ECDF_AUC(dsList, rt_min = NULL, rt_max = NULL, rt_step = NULL)

## S3 method for class 'DataSetList'
Plot.FV.ECDF_AUC(dsList, rt_min = NULL, rt_max = NULL, rt_step = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.FV.ECDF_AUC_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.FV.ECDF_AUC_+3A_rt_min">rt_min</code></td>
<td>
<p>The starting runtime</p>
</td></tr>
<tr><td><code id="Plot.FV.ECDF_AUC_+3A_rt_max">rt_max</code></td>
<td>
<p>The final runtime</p>
</td></tr>
<tr><td><code id="Plot.FV.ECDF_AUC_+3A_rt_step">rt_step</code></td>
<td>
<p>The spacing between starting and final runtimes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A radarplot of the area under the aggregated ECDF-curve of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Plot.FV.ECDF_AUC(subset(dsl, funcId == 1))
</code></pre>

<hr>
<h2 id='Plot.FV.ECDF_Per_Target'>Plot the empirical cumulative distriburtion as a function of the target values of
a DataSetList at certain target runtimes</h2><span id='topic+Plot.FV.ECDF_Per_Target'></span><span id='topic+Plot.FV.ECDF_Per_Target.DataSetList'></span>

<h3>Description</h3>

<p>Plot the empirical cumulative distriburtion as a function of the target values of
a DataSetList at certain target runtimes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.FV.ECDF_Per_Target(dsList, runtimes, scale.xlog = F, scale.reverse = F)

## S3 method for class 'DataSetList'
Plot.FV.ECDF_Per_Target(dsList, runtimes, scale.xlog = F, scale.reverse = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.FV.ECDF_Per_Target_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.FV.ECDF_Per_Target_+3A_runtimes">runtimes</code></td>
<td>
<p>The target runtimes</p>
</td></tr>
<tr><td><code id="Plot.FV.ECDF_Per_Target_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Whether or not to scale the x-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.FV.ECDF_Per_Target_+3A_scale.reverse">scale.reverse</code></td>
<td>
<p>Whether or not to reverse the x-axis (when using minimization)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the empirical cumulative distriburtion as a function of
the fucntion values of the DataSetList at the target runtimes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Plot.FV.ECDF_Per_Target(subset(dsl, funcId == 1), 10)
</code></pre>

<hr>
<h2 id='Plot.FV.ECDF_Single_Func'>Plot the aggregated empirical cumulative distriburtion as a function of the function values of
a DataSetList.</h2><span id='topic+Plot.FV.ECDF_Single_Func'></span><span id='topic+Plot.FV.ECDF_Single_Func.DataSetList'></span>

<h3>Description</h3>

<p>Plot the aggregated empirical cumulative distriburtion as a function of the function values of
a DataSetList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.FV.ECDF_Single_Func(
  dsList,
  rt_min = NULL,
  rt_max = NULL,
  rt_step = NULL,
  scale.xlog = F,
  show.per_target = F,
  scale.reverse = F
)

## S3 method for class 'DataSetList'
Plot.FV.ECDF_Single_Func(
  dsList,
  rt_min = NULL,
  rt_max = NULL,
  rt_step = NULL,
  scale.xlog = F,
  show.per_target = F,
  scale.reverse = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.FV.ECDF_Single_Func_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.FV.ECDF_Single_Func_+3A_rt_min">rt_min</code></td>
<td>
<p>The starting runtime</p>
</td></tr>
<tr><td><code id="Plot.FV.ECDF_Single_Func_+3A_rt_max">rt_max</code></td>
<td>
<p>The final runtime</p>
</td></tr>
<tr><td><code id="Plot.FV.ECDF_Single_Func_+3A_rt_step">rt_step</code></td>
<td>
<p>The spacing between starting and final runtimes</p>
</td></tr>
<tr><td><code id="Plot.FV.ECDF_Single_Func_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Whether or not to scale the x-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.FV.ECDF_Single_Func_+3A_show.per_target">show.per_target</code></td>
<td>
<p>Whether or not to show the individual ECDF-curves for each runtime</p>
</td></tr>
<tr><td><code id="Plot.FV.ECDF_Single_Func_+3A_scale.reverse">scale.reverse</code></td>
<td>
<p>Whether or not to reverse the x-axis (when using minimization)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the empirical cumulative distriburtion as a function of
the function values of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Plot.FV.ECDF_Single_Func(subset(dsl, funcId == 1))
</code></pre>

<hr>
<h2 id='Plot.FV.Histogram'>Plot histograms of the function values of a DataSetList at a certain target runtime</h2><span id='topic+Plot.FV.Histogram'></span><span id='topic+Plot.FV.Histogram.DataSetList'></span>

<h3>Description</h3>

<p>Plot histograms of the function values of a DataSetList at a certain target runtime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.FV.Histogram(dsList, runtime, plot_mode = "overlay", use.equal.bins = F)

## S3 method for class 'DataSetList'
Plot.FV.Histogram(dsList, runtime, plot_mode = "overlay", use.equal.bins = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.FV.Histogram_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.FV.Histogram_+3A_runtime">runtime</code></td>
<td>
<p>The target runtime</p>
</td></tr>
<tr><td><code id="Plot.FV.Histogram_+3A_plot_mode">plot_mode</code></td>
<td>
<p>How to plot the different hisograms for each algorithm. Can be either
'overlay' to show all algorithms on one plot, or 'subplot' to have one plot per algorithm.</p>
</td></tr>
<tr><td><code id="Plot.FV.Histogram_+3A_use.equal.bins">use.equal.bins</code></td>
<td>
<p>Whether to determine one bin size for all plots or have individual
bin sizes for each algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the histograms of the function values at a the
target runtime of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.FV.Histogram(subset(dsl, funcId == 1), 100)
</code></pre>

<hr>
<h2 id='Plot.FV.Multi_Func'>Plot FV-plots for multiple functions or dimensions</h2><span id='topic+Plot.FV.Multi_Func'></span><span id='topic+Plot.FV.Multi_Func.DataSetList'></span>

<h3>Description</h3>

<p>Plot FV-plots for multiple functions or dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.FV.Multi_Func(dsList, scale.xlog = F, scale.ylog = F, backend = NULL)

## S3 method for class 'DataSetList'
Plot.FV.Multi_Func(dsList, scale.xlog = F, scale.ylog = F, backend = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.FV.Multi_Func_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function OR dimension).</p>
</td></tr>
<tr><td><code id="Plot.FV.Multi_Func_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Whether or not to scale the x-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.FV.Multi_Func_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Whether or not to scale the y-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.FV.Multi_Func_+3A_backend">backend</code></td>
<td>
<p>Which plotting library to use. Either 'plotly' or 'ggplot2'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of Function-values of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.FV.Multi_Func(dsl)
</code></pre>

<hr>
<h2 id='Plot.FV.Parameters'>Plot the parameter values recorded in a DataSetList (aligned by budget)</h2><span id='topic+Plot.FV.Parameters'></span><span id='topic+Plot.FV.Parameters.DataSetList'></span>

<h3>Description</h3>

<p>Plot the parameter values recorded in a DataSetList (aligned by budget)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.FV.Parameters(
  dsList,
  rt_min = NULL,
  rt_max = NULL,
  algids = "all",
  par_name = NULL,
  scale.xlog = F,
  scale.ylog = F,
  show.mean = T,
  show.median = F,
  show.CI = F
)

## S3 method for class 'DataSetList'
Plot.FV.Parameters(
  dsList,
  rt_min = NULL,
  rt_max = NULL,
  algids = "all",
  par_name = NULL,
  scale.xlog = F,
  scale.ylog = F,
  show.mean = T,
  show.median = F,
  show.CI = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.FV.Parameters_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.FV.Parameters_+3A_rt_min">rt_min</code></td>
<td>
<p>The starting budget value.</p>
</td></tr>
<tr><td><code id="Plot.FV.Parameters_+3A_rt_max">rt_max</code></td>
<td>
<p>The final budget value.</p>
</td></tr>
<tr><td><code id="Plot.FV.Parameters_+3A_algids">algids</code></td>
<td>
<p>Which algorithms from dsList to use</p>
</td></tr>
<tr><td><code id="Plot.FV.Parameters_+3A_par_name">par_name</code></td>
<td>
<p>Which parameters to create plots for; set to NULL to use all
parameters found in dsList.</p>
</td></tr>
<tr><td><code id="Plot.FV.Parameters_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Whether or not to scale the x-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.FV.Parameters_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Whether or not to scale the y-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.FV.Parameters_+3A_show.mean">show.mean</code></td>
<td>
<p>Whether or not to show the mean parameter values</p>
</td></tr>
<tr><td><code id="Plot.FV.Parameters_+3A_show.median">show.median</code></td>
<td>
<p>Whether or not to show the median parameter values</p>
</td></tr>
<tr><td><code id="Plot.FV.Parameters_+3A_show.ci">show.CI</code></td>
<td>
<p>Whether or not to show the standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of for every recorded parameter in the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.FV.Parameters(subset(dsl, funcId == 1))
</code></pre>

<hr>
<h2 id='Plot.FV.PDF'>Plot probablity density function of the function values of a DataSetList at
a certain target runtime</h2><span id='topic+Plot.FV.PDF'></span><span id='topic+Plot.FV.PDF.DataSetList'></span>

<h3>Description</h3>

<p>Plot probablity density function of the function values of a DataSetList at
a certain target runtime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.FV.PDF(dsList, runtime, show.sample = F, scale.ylog = F)

## S3 method for class 'DataSetList'
Plot.FV.PDF(dsList, runtime, show.sample = F, scale.ylog = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.FV.PDF_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.FV.PDF_+3A_runtime">runtime</code></td>
<td>
<p>The target runtime</p>
</td></tr>
<tr><td><code id="Plot.FV.PDF_+3A_show.sample">show.sample</code></td>
<td>
<p>Whether or not to show the individual function value samples</p>
</td></tr>
<tr><td><code id="Plot.FV.PDF_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Whether or not to scale the y-axis logaritmically</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the probablity density function of the runtimes at a the
target function value of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.FV.PDF(subset(dsl, funcId == 1), 100)
</code></pre>

<hr>
<h2 id='Plot.FV.Single_Func'>Plot lineplot of the expected function values of a DataSetList</h2><span id='topic+Plot.FV.Single_Func'></span><span id='topic+Plot.FV.Single_Func.DataSetList'></span>

<h3>Description</h3>

<p>Plot lineplot of the expected function values of a DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.FV.Single_Func(
  dsList,
  RTstart = NULL,
  RTstop = NULL,
  show.CI = F,
  show.mean = T,
  show.median = F,
  backend = NULL,
  scale.xlog = F,
  scale.ylog = F,
  scale.reverse = F
)

## S3 method for class 'DataSetList'
Plot.FV.Single_Func(
  dsList,
  RTstart = NULL,
  RTstop = NULL,
  show.CI = F,
  show.mean = T,
  show.median = F,
  backend = NULL,
  scale.xlog = F,
  scale.ylog = F,
  scale.reverse = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.FV.Single_Func_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.FV.Single_Func_+3A_rtstart">RTstart</code></td>
<td>
<p>The starting runtime value.</p>
</td></tr>
<tr><td><code id="Plot.FV.Single_Func_+3A_rtstop">RTstop</code></td>
<td>
<p>The final runtime value.</p>
</td></tr>
<tr><td><code id="Plot.FV.Single_Func_+3A_show.ci">show.CI</code></td>
<td>
<p>Whether or not to show the standard deviations</p>
</td></tr>
<tr><td><code id="Plot.FV.Single_Func_+3A_show.mean">show.mean</code></td>
<td>
<p>Whether or not to show the mean runtimes</p>
</td></tr>
<tr><td><code id="Plot.FV.Single_Func_+3A_show.median">show.median</code></td>
<td>
<p>Whether or not to show the median runtimes</p>
</td></tr>
<tr><td><code id="Plot.FV.Single_Func_+3A_backend">backend</code></td>
<td>
<p>Which plotting library to use. Can be 'plotly' or 'ggplot2'</p>
</td></tr>
<tr><td><code id="Plot.FV.Single_Func_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Whether or not to scale the x-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.FV.Single_Func_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Whether or not to scale the y-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.FV.Single_Func_+3A_scale.reverse">scale.reverse</code></td>
<td>
<p>Wheter or not to reverse the x-axis (when using minimization)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of ERT-values of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.FV.Single_Func(subset(dsl, funcId == 1))
</code></pre>

<hr>
<h2 id='Plot.Performviz'>Create the PerformViz plot</h2><span id='topic+Plot.Performviz'></span>

<h3>Description</h3>

<p>From the paper:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.Performviz(DSC_rank_result)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.Performviz_+3A_dsc_rank_result">DSC_rank_result</code></td>
<td>
<p>The result from a call to DSCtool rank service ('get_dsc_rank')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A performviz plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Plot.Performviz(get_dsc_rank(dsl))

## End(Not run)
</code></pre>

<hr>
<h2 id='Plot.RT.Aggregated'>Plot ERT-based comparison over multiple functions or dimensions</h2><span id='topic+Plot.RT.Aggregated'></span><span id='topic+Plot.RT.Aggregated.DataSetList'></span>

<h3>Description</h3>

<p>Plot ERT-based comparison over multiple functions or dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.RT.Aggregated(
  dsList,
  aggr_on = "funcId",
  targets = NULL,
  plot_mode = "radar",
  use_rank = F,
  scale.ylog = T,
  maximize = T,
  erts = NULL,
  inf.action = "overlap"
)

## S3 method for class 'DataSetList'
Plot.RT.Aggregated(
  dsList,
  aggr_on = "funcId",
  targets = NULL,
  plot_mode = "radar",
  use_rank = F,
  scale.ylog = T,
  maximize = T,
  erts = NULL,
  inf.action = "overlap"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.RT.Aggregated_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function OR dimension).</p>
</td></tr>
<tr><td><code id="Plot.RT.Aggregated_+3A_aggr_on">aggr_on</code></td>
<td>
<p>Whether to compare on functions ('funcId') or dimensions ('DIM')</p>
</td></tr>
<tr><td><code id="Plot.RT.Aggregated_+3A_targets">targets</code></td>
<td>
<p>Custom list of function-value targets, one for each function or dimension.</p>
</td></tr>
<tr><td><code id="Plot.RT.Aggregated_+3A_plot_mode">plot_mode</code></td>
<td>
<p>How the plots should be created. Can be 'line' or 'radar'</p>
</td></tr>
<tr><td><code id="Plot.RT.Aggregated_+3A_use_rank">use_rank</code></td>
<td>
<p>Wheter to use a ranking system. If False, the actual ERT-values will be used.</p>
</td></tr>
<tr><td><code id="Plot.RT.Aggregated_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Whether or not to scale the y-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.RT.Aggregated_+3A_maximize">maximize</code></td>
<td>
<p>Wheter or not to the data is of a maximization problem</p>
</td></tr>
<tr><td><code id="Plot.RT.Aggregated_+3A_erts">erts</code></td>
<td>
<p>Pre-calculated ERT-values for the provided targets. Created by the max_ERTs function
of DataSetList. Can be provided to prevent needless computation in recalculating ERTs when recreating
this plot.</p>
</td></tr>
<tr><td><code id="Plot.RT.Aggregated_+3A_inf.action">inf.action</code></td>
<td>
<p>How to handle infinite ERTs ('overlap' or 'jitter')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of ERT-based comparison on the provided functions or dimensions of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.RT.Aggregated(dsl)
</code></pre>

<hr>
<h2 id='Plot.RT.ECDF_AUC'>Radarplot of the area under the aggregated ECDF-curve of a DataSetList.</h2><span id='topic+Plot.RT.ECDF_AUC'></span><span id='topic+Plot.RT.ECDF_AUC.DataSetList'></span>

<h3>Description</h3>

<p>Radarplot of the area under the aggregated ECDF-curve of a DataSetList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.RT.ECDF_AUC(
  dsList,
  fstart = NULL,
  fstop = NULL,
  fstep = NULL,
  fval_formatter = as.integer
)

## S3 method for class 'DataSetList'
Plot.RT.ECDF_AUC(
  dsList,
  fstart = NULL,
  fstop = NULL,
  fstep = NULL,
  fval_formatter = as.integer
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.RT.ECDF_AUC_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_AUC_+3A_fstart">fstart</code></td>
<td>
<p>The starting function value</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_AUC_+3A_fstop">fstop</code></td>
<td>
<p>The final function value</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_AUC_+3A_fstep">fstep</code></td>
<td>
<p>The spacing between starting and final function values</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_AUC_+3A_fval_formatter">fval_formatter</code></td>
<td>
<p>Function to format the function-value labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A radarplot of the area under the aggregated ECDF-curve of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Plot.RT.ECDF_AUC(subset(dsl, funcId == 1))
</code></pre>

<hr>
<h2 id='Plot.RT.ECDF_Multi_Func'>Plot the aggregated empirical cumulative distriburtion as a function of the running times of
a DataSetList. Aggregated over multiple functions or dimensions.</h2><span id='topic+Plot.RT.ECDF_Multi_Func'></span><span id='topic+Plot.RT.ECDF_Multi_Func.DataSetList'></span>

<h3>Description</h3>

<p>Plot the aggregated empirical cumulative distriburtion as a function of the running times of
a DataSetList. Aggregated over multiple functions or dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.RT.ECDF_Multi_Func(dsList, targets = NULL, scale.xlog = F)

## S3 method for class 'DataSetList'
Plot.RT.ECDF_Multi_Func(dsList, targets = NULL, scale.xlog = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.RT.ECDF_Multi_Func_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList.</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_Multi_Func_+3A_targets">targets</code></td>
<td>
<p>The target function values. Specified in a data.frame, as can be generated</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_Multi_Func_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Whether or not to scale the x-axis logaritmically
by the function 'get_ECDF_targets'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the empirical cumulative distriburtion as a function of
the running times of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Plot.RT.ECDF_Multi_Func(dsl)
</code></pre>

<hr>
<h2 id='Plot.RT.ECDF_Per_Target'>Plot the empirical cumulative distriburtion as a function of the running times of
a DataSetList at certain target function values</h2><span id='topic+Plot.RT.ECDF_Per_Target'></span><span id='topic+Plot.RT.ECDF_Per_Target.DataSetList'></span>

<h3>Description</h3>

<p>Plot the empirical cumulative distriburtion as a function of the running times of
a DataSetList at certain target function values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.RT.ECDF_Per_Target(dsList, ftargets, scale.xlog = F)

## S3 method for class 'DataSetList'
Plot.RT.ECDF_Per_Target(dsList, ftargets, scale.xlog = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.RT.ECDF_Per_Target_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_Per_Target_+3A_ftargets">ftargets</code></td>
<td>
<p>The target function values</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_Per_Target_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Whether or not to scale the x-axis logaritmically</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the empirical cumulative distriburtion as a function of
the running times of the DataSetList at the target function values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Plot.RT.ECDF_Per_Target(subset(dsl, funcId == 1), 14)
</code></pre>

<hr>
<h2 id='Plot.RT.ECDF_Single_Func'>Plot the aggregated empirical cumulative distriburtion as a function of the running times of
a DataSetList.</h2><span id='topic+Plot.RT.ECDF_Single_Func'></span><span id='topic+Plot.RT.ECDF_Single_Func.DataSetList'></span>

<h3>Description</h3>

<p>Plot the aggregated empirical cumulative distriburtion as a function of the running times of
a DataSetList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.RT.ECDF_Single_Func(
  dsList,
  fstart = NULL,
  fstop = NULL,
  fstep = NULL,
  show.per_target = F,
  scale.xlog = F
)

## S3 method for class 'DataSetList'
Plot.RT.ECDF_Single_Func(
  dsList,
  fstart = NULL,
  fstop = NULL,
  fstep = NULL,
  show.per_target = F,
  scale.xlog = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.RT.ECDF_Single_Func_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_Single_Func_+3A_fstart">fstart</code></td>
<td>
<p>The starting function value</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_Single_Func_+3A_fstop">fstop</code></td>
<td>
<p>The final function value</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_Single_Func_+3A_fstep">fstep</code></td>
<td>
<p>The spacing between starting and final function values</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_Single_Func_+3A_show.per_target">show.per_target</code></td>
<td>
<p>Whether or not to show the individual ECDF-curves for each target</p>
</td></tr>
<tr><td><code id="Plot.RT.ECDF_Single_Func_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Whether or not to scale the x-axis logaritmically</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the empirical cumulative distriburtion as a function of
the running times of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Plot.RT.ECDF_Single_Func(subset(dsl, funcId == 1))
</code></pre>

<hr>
<h2 id='Plot.RT.Histogram'>Plot histograms of the runtimes of a DataSetList at a certain target function value</h2><span id='topic+Plot.RT.Histogram'></span><span id='topic+Plot.RT.Histogram.DataSetList'></span>

<h3>Description</h3>

<p>Plot histograms of the runtimes of a DataSetList at a certain target function value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.RT.Histogram(dsList, ftarget, plot_mode = "overlay", use.equal.bins = F)

## S3 method for class 'DataSetList'
Plot.RT.Histogram(dsList, ftarget, plot_mode = "overlay", use.equal.bins = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.RT.Histogram_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.RT.Histogram_+3A_ftarget">ftarget</code></td>
<td>
<p>The target function value.</p>
</td></tr>
<tr><td><code id="Plot.RT.Histogram_+3A_plot_mode">plot_mode</code></td>
<td>
<p>How to plot the different hisograms for each algorithm. Can be either
'overlay' to show all algorithms on one plot, or 'subplot' to have one plot per algorithm.</p>
</td></tr>
<tr><td><code id="Plot.RT.Histogram_+3A_use.equal.bins">use.equal.bins</code></td>
<td>
<p>Whether to determine one bin size for all plots or have individual
bin sizes for each algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the histograms of the runtimes at a the
target function value of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.RT.Histogram(subset(dsl, funcId == 1), 14)
</code></pre>

<hr>
<h2 id='Plot.RT.Multi_Func'>Plot ERT-plots for multiple functions or dimensions</h2><span id='topic+Plot.RT.Multi_Func'></span><span id='topic+Plot.RT.Multi_Func.DataSetList'></span>

<h3>Description</h3>

<p>Plot ERT-plots for multiple functions or dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.RT.Multi_Func(
  dsList,
  scale.xlog = F,
  scale.ylog = F,
  scale.reverse = F,
  backend = NULL
)

## S3 method for class 'DataSetList'
Plot.RT.Multi_Func(
  dsList,
  scale.xlog = F,
  scale.ylog = F,
  scale.reverse = F,
  backend = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.RT.Multi_Func_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function OR dimension).</p>
</td></tr>
<tr><td><code id="Plot.RT.Multi_Func_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Whether or not to scale the x-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.RT.Multi_Func_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Whether or not to scale the y-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.RT.Multi_Func_+3A_scale.reverse">scale.reverse</code></td>
<td>
<p>Wheter or not to reverse the x-axis (when using minimization)</p>
</td></tr>
<tr><td><code id="Plot.RT.Multi_Func_+3A_backend">backend</code></td>
<td>
<p>Which plotting library to use. Either 'plotly' or 'ggplot2'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of ERT-values of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.RT.Multi_Func(dsl)
</code></pre>

<hr>
<h2 id='Plot.RT.Parameters'>Plot the parameter values recorded in a DataSetList (aligned by funcion value)</h2><span id='topic+Plot.RT.Parameters'></span><span id='topic+Plot.RT.Parameters.DataSetList'></span>

<h3>Description</h3>

<p>Plot the parameter values recorded in a DataSetList (aligned by funcion value)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.RT.Parameters(
  dsList,
  f_min = NULL,
  f_max = NULL,
  algids = "all",
  par_name = NULL,
  scale.xlog = F,
  scale.ylog = F,
  show.mean = T,
  show.median = F,
  show.CI = F
)

## S3 method for class 'DataSetList'
Plot.RT.Parameters(
  dsList,
  f_min = NULL,
  f_max = NULL,
  algids = "all",
  par_name = NULL,
  scale.xlog = F,
  scale.ylog = F,
  show.mean = T,
  show.median = F,
  show.CI = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.RT.Parameters_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.RT.Parameters_+3A_f_min">f_min</code></td>
<td>
<p>The starting function value.</p>
</td></tr>
<tr><td><code id="Plot.RT.Parameters_+3A_f_max">f_max</code></td>
<td>
<p>The final function value.</p>
</td></tr>
<tr><td><code id="Plot.RT.Parameters_+3A_algids">algids</code></td>
<td>
<p>Which algorithms from dsList to use</p>
</td></tr>
<tr><td><code id="Plot.RT.Parameters_+3A_par_name">par_name</code></td>
<td>
<p>Which parameters to create plots for; set to NULL to use all
parameters found in dsList.</p>
</td></tr>
<tr><td><code id="Plot.RT.Parameters_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Whether or not to scale the x-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.RT.Parameters_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Whether or not to scale the y-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.RT.Parameters_+3A_show.mean">show.mean</code></td>
<td>
<p>Whether or not to show the mean parameter values</p>
</td></tr>
<tr><td><code id="Plot.RT.Parameters_+3A_show.median">show.median</code></td>
<td>
<p>Whether or not to show the median parameter values</p>
</td></tr>
<tr><td><code id="Plot.RT.Parameters_+3A_show.ci">show.CI</code></td>
<td>
<p>Whether or not to show the standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of for every recorded parameter in the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.RT.Parameters(subset(dsl, funcId == 1))
</code></pre>

<hr>
<h2 id='Plot.RT.PMF'>Plot probablity mass function of the runtimes of a DataSetList at a certain target function value</h2><span id='topic+Plot.RT.PMF'></span><span id='topic+Plot.RT.PMF.DataSetList'></span>

<h3>Description</h3>

<p>Plot probablity mass function of the runtimes of a DataSetList at a certain target function value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.RT.PMF(dsList, ftarget, show.sample = F, scale.ylog = F, backend = NULL)

## S3 method for class 'DataSetList'
Plot.RT.PMF(dsList, ftarget, show.sample = F, scale.ylog = F, backend = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.RT.PMF_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.RT.PMF_+3A_ftarget">ftarget</code></td>
<td>
<p>The target function value.</p>
</td></tr>
<tr><td><code id="Plot.RT.PMF_+3A_show.sample">show.sample</code></td>
<td>
<p>Whether or not to show the individual runtime samples</p>
</td></tr>
<tr><td><code id="Plot.RT.PMF_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Whether or not to scale the y-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.RT.PMF_+3A_backend">backend</code></td>
<td>
<p>Which plotting library to use. Can be 'plotly' or 'ggplot2'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the probablity mass function of the runtimes at a the
target function value of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.RT.PMF(subset(dsl, funcId == 1), 14)
</code></pre>

<hr>
<h2 id='Plot.RT.Single_Func'>Plot lineplot of the ERTs of a DataSetList</h2><span id='topic+Plot.RT.Single_Func'></span><span id='topic+Plot.RT.Single_Func.DataSetList'></span>

<h3>Description</h3>

<p>Plot lineplot of the ERTs of a DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.RT.Single_Func(
  dsList,
  Fstart = NULL,
  Fstop = NULL,
  show.ERT = T,
  show.CI = F,
  show.mean = F,
  show.median = F,
  backend = NULL,
  scale.xlog = F,
  scale.ylog = F,
  scale.reverse = F,
  includeOpts = F,
  p = NULL
)

## S3 method for class 'DataSetList'
Plot.RT.Single_Func(
  dsList,
  Fstart = NULL,
  Fstop = NULL,
  show.ERT = T,
  show.CI = T,
  show.mean = F,
  show.median = F,
  backend = NULL,
  scale.xlog = F,
  scale.ylog = F,
  scale.reverse = F,
  includeOpts = F,
  p = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.RT.Single_Func_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.RT.Single_Func_+3A_fstart">Fstart</code></td>
<td>
<p>The starting function value.</p>
</td></tr>
<tr><td><code id="Plot.RT.Single_Func_+3A_fstop">Fstop</code></td>
<td>
<p>The final function value.</p>
</td></tr>
<tr><td><code id="Plot.RT.Single_Func_+3A_show.ert">show.ERT</code></td>
<td>
<p>Whether or not to show the ERT-values</p>
</td></tr>
<tr><td><code id="Plot.RT.Single_Func_+3A_show.ci">show.CI</code></td>
<td>
<p>Whether or not to show the standard deviations</p>
</td></tr>
<tr><td><code id="Plot.RT.Single_Func_+3A_show.mean">show.mean</code></td>
<td>
<p>Whether or not to show the mean hitting times</p>
</td></tr>
<tr><td><code id="Plot.RT.Single_Func_+3A_show.median">show.median</code></td>
<td>
<p>Whether or not to show the median hitting times</p>
</td></tr>
<tr><td><code id="Plot.RT.Single_Func_+3A_backend">backend</code></td>
<td>
<p>Which plotting library to use. Can be 'plotly' or 'ggplot2'</p>
</td></tr>
<tr><td><code id="Plot.RT.Single_Func_+3A_scale.xlog">scale.xlog</code></td>
<td>
<p>Whether or not to scale the x-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.RT.Single_Func_+3A_scale.ylog">scale.ylog</code></td>
<td>
<p>Whether or not to scale the y-axis logaritmically</p>
</td></tr>
<tr><td><code id="Plot.RT.Single_Func_+3A_scale.reverse">scale.reverse</code></td>
<td>
<p>Wheter or not to reverse the x-axis (when using minimization)</p>
</td></tr>
<tr><td><code id="Plot.RT.Single_Func_+3A_includeopts">includeOpts</code></td>
<td>
<p>Whether or not to include all best points reached by each algorithm</p>
</td></tr>
<tr><td><code id="Plot.RT.Single_Func_+3A_p">p</code></td>
<td>
<p>Existing plot to which to add the current data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of ERT-values of the DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.RT.Single_Func(subset(dsl, funcId == 1))
</code></pre>

<hr>
<h2 id='Plot.Stats.Glicko2_Candlestick'>Create a candlestick plot of Glicko2-rankings</h2><span id='topic+Plot.Stats.Glicko2_Candlestick'></span><span id='topic+Plot.Stats.Glicko2_Candlestick.DataSetList'></span>

<h3>Description</h3>

<p>Create a candlestick plot of Glicko2-rankings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.Stats.Glicko2_Candlestick(
  dsList,
  nr_rounds = 100,
  glicko2_rank_df = NULL,
  which = "by_FV",
  target_dt = NULL
)

## S3 method for class 'DataSetList'
Plot.Stats.Glicko2_Candlestick(
  dsList,
  nr_rounds = 100,
  glicko2_rank_df = NULL,
  which = "by_FV",
  target_dt = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.Stats.Glicko2_Candlestick_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList</p>
</td></tr>
<tr><td><code id="Plot.Stats.Glicko2_Candlestick_+3A_nr_rounds">nr_rounds</code></td>
<td>
<p>The number of rounds in the tournament</p>
</td></tr>
<tr><td><code id="Plot.Stats.Glicko2_Candlestick_+3A_glicko2_rank_df">glicko2_rank_df</code></td>
<td>
<p>Optional. Dataframe containing the glicko2 rating to avoid needless recalculation.</p>
</td></tr>
<tr><td><code id="Plot.Stats.Glicko2_Candlestick_+3A_which">which</code></td>
<td>
<p>Whether to use fixed-target ('by_FV') or fixed-budget ('by_RT') perspective</p>
</td></tr>
<tr><td><code id="Plot.Stats.Glicko2_Candlestick_+3A_target_dt">target_dt</code></td>
<td>
<p>Optional: data table containing the targets for each function and dimension</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.Stats.Glicko2_Candlestick(dsl, nr_rounds=2)
</code></pre>

<hr>
<h2 id='Plot.Stats.Significance_Graph'>Plot a network graph showing the statistically different algorithms</h2><span id='topic+Plot.Stats.Significance_Graph'></span><span id='topic+Plot.Stats.Significance_Graph.DataSetList'></span>

<h3>Description</h3>

<p>Plot a network graph showing the statistically different algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.Stats.Significance_Graph(
  dsList,
  ftarget,
  alpha = 0.01,
  bootstrap.size = 30,
  which = "by_FV"
)

## S3 method for class 'DataSetList'
Plot.Stats.Significance_Graph(
  dsList,
  ftarget,
  alpha = 0.01,
  bootstrap.size = 30,
  which = "by_FV"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.Stats.Significance_Graph_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.Stats.Significance_Graph_+3A_ftarget">ftarget</code></td>
<td>
<p>The target function value to use</p>
</td></tr>
<tr><td><code id="Plot.Stats.Significance_Graph_+3A_alpha">alpha</code></td>
<td>
<p>The cutoff for statistical significance</p>
</td></tr>
<tr><td><code id="Plot.Stats.Significance_Graph_+3A_bootstrap.size">bootstrap.size</code></td>
<td>
<p>The amound of bootstrapped samples used</p>
</td></tr>
<tr><td><code id="Plot.Stats.Significance_Graph_+3A_which">which</code></td>
<td>
<p>Whether to use fixed-target ('by_FV') or fixed-budget ('by_RT') perspective</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph showing the statistical significance between algorithms
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.Stats.Significance_Graph(subset(dsl, funcId == 2), 16)
</code></pre>

<hr>
<h2 id='Plot.Stats.Significance_Heatmap'>Plot a heatmap showing the statistically different algorithms</h2><span id='topic+Plot.Stats.Significance_Heatmap'></span><span id='topic+Plot.Stats.Significance_Heatmap.DataSetList'></span>

<h3>Description</h3>

<p>Plot a heatmap showing the statistically different algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot.Stats.Significance_Heatmap(
  dsList,
  ftarget,
  alpha = 0.01,
  bootstrap.size = 30,
  which = "by_FV"
)

## S3 method for class 'DataSetList'
Plot.Stats.Significance_Heatmap(
  dsList,
  ftarget,
  alpha = 0.01,
  bootstrap.size = 30,
  which = "by_FV"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot.Stats.Significance_Heatmap_+3A_dslist">dsList</code></td>
<td>
<p>A DataSetList (should consist of only one function and dimension).</p>
</td></tr>
<tr><td><code id="Plot.Stats.Significance_Heatmap_+3A_ftarget">ftarget</code></td>
<td>
<p>The target function value to use</p>
</td></tr>
<tr><td><code id="Plot.Stats.Significance_Heatmap_+3A_alpha">alpha</code></td>
<td>
<p>The cutoff for statistical significance</p>
</td></tr>
<tr><td><code id="Plot.Stats.Significance_Heatmap_+3A_bootstrap.size">bootstrap.size</code></td>
<td>
<p>The amound of bootstrapped samples used</p>
</td></tr>
<tr><td><code id="Plot.Stats.Significance_Heatmap_+3A_which">which</code></td>
<td>
<p>Whether to use fixed-target ('by_FV') or fixed-budget ('by_RT') perspective</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap showing the statistical significance between algorithms
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Plot.Stats.Significance_Heatmap(subset(dsl, funcId == 2), 16)
</code></pre>

<hr>
<h2 id='print.DataSet'>S3 generic print operator for DataSet</h2><span id='topic+print.DataSet'></span>

<h3>Description</h3>

<p>S3 generic print operator for DataSet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataSet'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.DataSet_+3A_x">x</code></td>
<td>
<p>A DataSet object</p>
</td></tr>
<tr><td><code id="print.DataSet_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A short description of the DataSet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(dsl[[1]])
</code></pre>

<hr>
<h2 id='print.DataSetList'>S3 print function for DataSetList</h2><span id='topic+print.DataSetList'></span>

<h3>Description</h3>

<p>S3 print function for DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataSetList'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.DataSetList_+3A_x">x</code></td>
<td>
<p>The DataSetList to print</p>
</td></tr>
<tr><td><code id="print.DataSetList_+3A_...">...</code></td>
<td>
<p>Arguments for underlying print function?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>print(dsl)
</code></pre>

<hr>
<h2 id='read_index_file'>Read .info files and extract information</h2><span id='topic+read_index_file'></span>

<h3>Description</h3>

<p>Read .info files and extract information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_index_file(fname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_index_file_+3A_fname">fname</code></td>
<td>
<p>The path to the .info file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data contained in the .info file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", "ONE_PLUS_LAMDA_EA", package="IOHanalyzer")
info &lt;- read_index_file(file.path(path,"IOHprofiler_f1_i1.info"))
</code></pre>

<hr>
<h2 id='read_IOH_v1plus'>Read Nevergrad data</h2><span id='topic+read_IOH_v1plus'></span>

<h3>Description</h3>

<p>Read .csv files in arbitrary format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_IOH_v1plus(info, full_sampling = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_IOH_v1plus_+3A_info">info</code></td>
<td>
<p>A List containing all meta-data about the dataset to create</p>
</td></tr>
<tr><td><code id="read_IOH_v1plus_+3A_full_sampling">full_sampling</code></td>
<td>
<p>Logical. Whether the raw (unaligned) FV matrix should be stored.
Currently only useful when a correlation plot between function values and parameters should be made</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The DataSetList extracted from the .csv file provided
</p>

<hr>
<h2 id='read_pure_csv'>Read Nevergrad data</h2><span id='topic+read_pure_csv'></span>

<h3>Description</h3>

<p>Read .csv files in arbitrary format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_pure_csv(
  path,
  neval_name,
  fval_name,
  fname_name,
  algname_name,
  dim_name,
  run_name,
  maximization = F,
  static_attrs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_pure_csv_+3A_path">path</code></td>
<td>
<p>The path to the .csv file</p>
</td></tr>
<tr><td><code id="read_pure_csv_+3A_neval_name">neval_name</code></td>
<td>
<p>The name of the column to use for the evaluation count.
If NULL, will be assumed to be sequential</p>
</td></tr>
<tr><td><code id="read_pure_csv_+3A_fval_name">fval_name</code></td>
<td>
<p>The name of the column to use for the function values</p>
</td></tr>
<tr><td><code id="read_pure_csv_+3A_fname_name">fname_name</code></td>
<td>
<p>The name of the column to use for the function name</p>
</td></tr>
<tr><td><code id="read_pure_csv_+3A_algname_name">algname_name</code></td>
<td>
<p>The name of the column to use for the algorithm name</p>
</td></tr>
<tr><td><code id="read_pure_csv_+3A_dim_name">dim_name</code></td>
<td>
<p>The name of the column to use for the dimension</p>
</td></tr>
<tr><td><code id="read_pure_csv_+3A_run_name">run_name</code></td>
<td>
<p>The name of the column to use for the run number</p>
</td></tr>
<tr><td><code id="read_pure_csv_+3A_maximization">maximization</code></td>
<td>
<p>Boolean indicating whether the data is resulting from maximization or minimization</p>
</td></tr>
<tr><td><code id="read_pure_csv_+3A_static_attrs">static_attrs</code></td>
<td>
<p>Named list containing the static values for missing columns.
When a parameter is not present in the csv file, its name-parameter should
be set to NULL, and the static value should be added to this static_attrs list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The DataSetList extracted from the .csv file provided
</p>

<hr>
<h2 id='register_DSC'>Register an account to the DSCtool API</h2><span id='topic+register_DSC'></span>

<h3>Description</h3>

<p>This uses the keyring package to store and load credentials.
If you already have an account, please call 'set_DSC_credentials' instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_DSC(name, username, affiliation, email, password = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="register_DSC_+3A_name">name</code></td>
<td>
<p>Your name</p>
</td></tr>
<tr><td><code id="register_DSC_+3A_username">username</code></td>
<td>
<p>A usename to be identified with. Will be stored on keyring under 'DSCtool_name'</p>
</td></tr>
<tr><td><code id="register_DSC_+3A_affiliation">affiliation</code></td>
<td>
<p>Your affiliation (university / company)</p>
</td></tr>
<tr><td><code id="register_DSC_+3A_email">email</code></td>
<td>
<p>Your email adress</p>
</td></tr>
<tr><td><code id="register_DSC_+3A_password">password</code></td>
<td>
<p>The password to use. If NULL, this will be generated at random.
Will be stored on keyring under 'DSCtool'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
register_DSC('John Doe', 'jdoe', 'Sample University', "j.doe.sample.com")

## End(Not run)
</code></pre>

<hr>
<h2 id='runServer'>Create a shiny-server GUI to interactively use the IOHanalyzer</h2><span id='topic+runServer'></span>

<h3>Description</h3>

<p>Create a shiny-server GUI to interactively use the IOHanalyzer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runServer(port = getOption("shiny.port"), open_browser = TRUE, orca_gpu = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runServer_+3A_port">port</code></td>
<td>
<p>Optional; which port the server should be opened at. Defaults
to the option set for 'shiny.port'</p>
</td></tr>
<tr><td><code id="runServer_+3A_open_browser">open_browser</code></td>
<td>
<p>Whether or not to open a browser tab with the
IOHanalyzer GUI. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="runServer_+3A_orca_gpu">orca_gpu</code></td>
<td>
<p>Whether or not orca will be allowed to use gpu-accelleration for saving figures to file.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
runServer(6563, TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='save_plotly'>Save plotly figure in multiple format</h2><span id='topic+save_plotly'></span>

<h3>Description</h3>

<p>NOTE: This function requires orca to be installed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_plotly(p, file, width = NULL, height = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_plotly_+3A_p">p</code></td>
<td>
<p>plotly object. The plot to be saved</p>
</td></tr>
<tr><td><code id="save_plotly_+3A_file">file</code></td>
<td>
<p>String. The name of the figure file, with the extension of the required file-format</p>
</td></tr>
<tr><td><code id="save_plotly_+3A_width">width</code></td>
<td>
<p>Optional. Width of the figure</p>
</td></tr>
<tr><td><code id="save_plotly_+3A_height">height</code></td>
<td>
<p>Optional. Height of the figure</p>
</td></tr>
<tr><td><code id="save_plotly_+3A_...">...</code></td>
<td>
<p>Additional arguments for orca</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
p &lt;- Plot.RT.Single_Func(dsl[1])
save_plotly(p, 'example_file.png')

## End(Not run)
</code></pre>

<hr>
<h2 id='save_table'>Save DataTable in multiple formats</h2><span id='topic+save_table'></span>

<h3>Description</h3>

<p>Save DataTable in multiple formats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_table(df, file, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_table_+3A_df">df</code></td>
<td>
<p>The DataTable to store</p>
</td></tr>
<tr><td><code id="save_table_+3A_file">file</code></td>
<td>
<p>String. The name of the figure file, with the extension of the required file-format</p>
</td></tr>
<tr><td><code id="save_table_+3A_format">format</code></td>
<td>
<p>Optional, string. Overwrites the extension of the 'file' parameter. If not specified while
file does not have an extension, it defaults to csv</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- generate_data.Single_Function(subset(dsl, funcId == 1), which = 'by_RT')
save_table(df, tempfile(fileext = ".md"))
</code></pre>

<hr>
<h2 id='scan_index_file'>Scan *.info files for IOHProfiler or COCO</h2><span id='topic+scan_index_file'></span>

<h3>Description</h3>

<p>Scan *.info files for IOHProfiler or COCO
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_index_file(folder)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scan_index_file_+3A_folder">folder</code></td>
<td>
<p>The folder containing the .info or .json files</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The paths to all found .info and .json-files
</p>


<h3>Note</h3>

<p>This automatically filetrs our files of size 0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", "ONE_PLUS_LAMDA_EA", package="IOHanalyzer")
scan_index_file(path)
</code></pre>

<hr>
<h2 id='seq_FV'>Function for generating sequences of function values</h2><span id='topic+seq_FV'></span>

<h3>Description</h3>

<p>Function for generating sequences of function values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_FV(
  FV,
  from = NULL,
  to = NULL,
  by = NULL,
  length.out = NULL,
  scale = NULL,
  force_limits = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq_FV_+3A_fv">FV</code></td>
<td>
<p>A list of function values</p>
</td></tr>
<tr><td><code id="seq_FV_+3A_from">from</code></td>
<td>
<p>Starting function value. Will be replaced by min(FV) if it is NULL or too small</p>
</td></tr>
<tr><td><code id="seq_FV_+3A_to">to</code></td>
<td>
<p>Stopping function value. Will be replaced by max(FV) if it is NULL or too large</p>
</td></tr>
<tr><td><code id="seq_FV_+3A_by">by</code></td>
<td>
<p>Stepsize of the sequence. Will be replaced if it is too small</p>
</td></tr>
<tr><td><code id="seq_FV_+3A_length.out">length.out</code></td>
<td>
<p>Number of values in the sequence.
'by' takes preference if both it and length.out are provided.</p>
</td></tr>
<tr><td><code id="seq_FV_+3A_scale">scale</code></td>
<td>
<p>Scaling of the sequence. Can be either 'linear' or 'log', indicating a
linear or log-linear spacing respectively. If NULL, the scale will be predicted
based on FV</p>
</td></tr>
<tr><td><code id="seq_FV_+3A_force_limits">force_limits</code></td>
<td>
<p>Whether the from and to values are hard, or should be modified
based on detected FV values (default False)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sequence of function values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FVall &lt;- get_runtimes(dsl)
seq_FV(FVall, 10, 16, 1, scale='linear')
</code></pre>

<hr>
<h2 id='seq_RT'>Function for generating sequences of runtime values</h2><span id='topic+seq_RT'></span>

<h3>Description</h3>

<p>Function for generating sequences of runtime values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_RT(
  RT,
  from = NULL,
  to = NULL,
  by = NULL,
  length.out = NULL,
  scale = "linear"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq_RT_+3A_rt">RT</code></td>
<td>
<p>A list of runtime values</p>
</td></tr>
<tr><td><code id="seq_RT_+3A_from">from</code></td>
<td>
<p>Starting runtime value. Will be replaced by min(RT) if it is NULL or too small</p>
</td></tr>
<tr><td><code id="seq_RT_+3A_to">to</code></td>
<td>
<p>Stopping runtime value. Will be replaced by max(RT) if it is NULL or too large</p>
</td></tr>
<tr><td><code id="seq_RT_+3A_by">by</code></td>
<td>
<p>Stepsize of the sequence. Will be replaced if it is too small</p>
</td></tr>
<tr><td><code id="seq_RT_+3A_length.out">length.out</code></td>
<td>
<p>Number of values in the sequence.
'by' takes preference if both it and length.out are provided.</p>
</td></tr>
<tr><td><code id="seq_RT_+3A_scale">scale</code></td>
<td>
<p>Scaling of the sequence. Can be either 'linear' or 'log', indicating a
linear or log-linear spacing respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sequence of runtime values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RTall &lt;- get_runtimes(dsl)
seq_RT(RTall, 0, 500, length.out=10, scale='log')
</code></pre>

<hr>
<h2 id='set_color_scheme'>Set the colorScheme of the IOHanalyzer plots</h2><span id='topic+set_color_scheme'></span>

<h3>Description</h3>

<p>Set the colorScheme of the IOHanalyzer plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_color_scheme(schemename, ids, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_color_scheme_+3A_schemename">schemename</code></td>
<td>
<p>Three default colorschemes are implemented:
</p>

<ul>
<li><p> Default
</p>
</li>
<li><p> Variant 1
</p>
</li>
<li><p> Variant 2
</p>
</li>
<li><p> Variant 3
</p>
</li></ul>

<p>And it is also possible to select &quot;Custom&quot;, which allows uploading of a custom set of colors</p>
</td></tr>
<tr><td><code id="set_color_scheme_+3A_ids">ids</code></td>
<td>
<p>The names of the algorithms (or custom ids, see 'change_id') for which to set the colors</p>
</td></tr>
<tr><td><code id="set_color_scheme_+3A_path">path</code></td>
<td>
<p>The path to the file containing the colors to use. Only used if
schemename is &quot;Custom&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set_color_scheme("Default", get_algId(dsl))
</code></pre>

<hr>
<h2 id='set_DSC_credentials'>Register an account to the DSCtool API</h2><span id='topic+set_DSC_credentials'></span>

<h3>Description</h3>

<p>This uses the keyring package to store and load credentials.
If you already have an account, please call 'add_DSC_credentials' instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_DSC_credentials(username, password)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_DSC_credentials_+3A_username">username</code></td>
<td>
<p>The usename you use on DSCtool. Will be stored on keyring under 'DSCtool_name'</p>
</td></tr>
<tr><td><code id="set_DSC_credentials_+3A_password">password</code></td>
<td>
<p>The password you use on DSCtool. Will be stored on keyring under 'DSCtool'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: set_DSC_credentials('jdoe', 'monkey123')
</code></pre>

<hr>
<h2 id='SP'>Estimator 'SP' for the Expected Running Time (ERT)</h2><span id='topic+SP'></span>

<h3>Description</h3>

<p>Estimator 'SP' for the Expected Running Time (ERT)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SP(data, max_runtime)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SP_+3A_data">data</code></td>
<td>
<p>A dataframe or matrix. Each row stores the runtime sample points from
several runs</p>
</td></tr>
<tr><td><code id="SP_+3A_max_runtime">max_runtime</code></td>
<td>
<p>The budget to use for calculating ERT. If this is a vector, the largest value is taken.
Using this as a vector is being deprecated, and will be removed in a future update</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing ERTs, number of succesfull runs and the succes rate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SP(dsl[[1]]$RT, max(dsl[[1]]$RT))
</code></pre>

<hr>
<h2 id='subset.DataSet'>S3 subset function for DataSet</h2><span id='topic+subset.DataSet'></span>

<h3>Description</h3>

<p>Subset for DataSets. Based on the provided mask, the relevant data is taken from the given DataSet
and turned into a new DataSet object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataSet'
subset(x, mask, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.DataSet_+3A_x">x</code></td>
<td>
<p>The DataSet from which to get a subset</p>
</td></tr>
<tr><td><code id="subset.DataSet_+3A_mask">mask</code></td>
<td>
<p>The mask (as boolean list) to use when subsetting. The length should be equal to the number of runs
present in the provided dataset object x.</p>
</td></tr>
<tr><td><code id="subset.DataSet_+3A_...">...</code></td>
<td>
<p>Arguments passed to underlying subset method (not yet supported)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new DataSet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subset(dsl[[1]], c(0,1,1,1,0,0,0,0,0,0,0))
</code></pre>

<hr>
<h2 id='subset.DataSetList'>Filter a DataSetList by some criteria</h2><span id='topic+subset.DataSetList'></span>

<h3>Description</h3>

<p>Filter a DataSetList by some criteria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataSetList'
subset(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.DataSetList_+3A_x">x</code></td>
<td>
<p>The DataSetList</p>
</td></tr>
<tr><td><code id="subset.DataSetList_+3A_...">...</code></td>
<td>
<p>The conditions to filter on. Can be any expression which assigns True or False
to a DataSet object, such as DIM == 625 or funcId == 2. Usage of &amp;&amp; and || is only supported on default attributes
(funcId, algId, DIM), not on combinations of with other attributes (e.g. instance). In those cases, &amp; and | should
be used respectively. Alternatively, this can be used as a keyword argument named 'text', with the condition as a
string to be parsed. This allows exectution of subset commands on arbitrary variables in code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filtered DataSetList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subset(dsl, funcId == 1)
subset(dsl, funcId == 1 &amp;&amp; DIM == 16) # Can use &amp;&amp; and || for default attributes
subset(dsl, instance == 1)
subset(dsl, instance == 1 &amp; funcId == 1) # Can use &amp; and | for all attributes
subset(dsl, instance == 1, funcId == 1) # Comma-seperated conditions are treated as AND
</code></pre>

<hr>
<h2 id='summary.DataSet'>S3 generic summary operator for DataSet</h2><span id='topic+summary.DataSet'></span>

<h3>Description</h3>

<p>S3 generic summary operator for DataSet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataSet'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.DataSet_+3A_object">object</code></td>
<td>
<p>A DataSet object</p>
</td></tr>
<tr><td><code id="summary.DataSet_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary of the DataSet containing both function-value and runtime based statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(dsl[[1]])
</code></pre>

<hr>
<h2 id='summary.DataSetList'>S3 summary function for DataSetList</h2><span id='topic+summary.DataSetList'></span>

<h3>Description</h3>

<p>Prints the Function ID, Dimension, Algorithm Id, datafile location and comment for every
DataSet in the DataSetList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataSetList'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.DataSetList_+3A_object">object</code></td>
<td>
<p>The DataSetList to print</p>
</td></tr>
<tr><td><code id="summary.DataSetList_+3A_...">...</code></td>
<td>
<p>Arguments for underlying summary function?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>summary(dsl)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
