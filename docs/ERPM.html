<!DOCTYPE html><html><head><title>Help for package ERPM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ERPM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ERPM-package'><p>ERPM: Exponential Random Partition Models</p></a></li>
<li><a href='#Bell_constraints'><p>Function to calculate the number of partitions with groups</p>
of sizes between smin and smax</a></li>
<li><a href='#calculate_denominator_Dirichlet_restricted'><p>Calculate Dirichlet denominator</p></a></li>
<li><a href='#calculate_proba_Dirichlet_restricted'><p>Calculate Dirichlet probability</p></a></li>
<li><a href='#check_sizes'><p>Function to determine whether a partition contains the allowed group sizes</p></a></li>
<li><a href='#compute_averagesize'><p>Compute the average size of a random partition</p></a></li>
<li><a href='#compute_numgroups_denominator'><p>Compute denominator for model with number of groups</p></a></li>
<li><a href='#computeStatistics'><p>Compute Statistics</p></a></li>
<li><a href='#computeStatistics_multiple'><p>Compute Statistics multiple</p></a></li>
<li><a href='#correlation_between'><p>Between groups correlation</p></a></li>
<li><a href='#correlation_with_size'><p>Correlation with size</p></a></li>
<li><a href='#correlation_within'><p>Within groups correlation</p></a></li>
<li><a href='#count_classes'><p>Function to count the number of partitions with a certain</p>
group size structure, for all possible group size structure.
Function to use after calling the &quot;find_all_partitions&quot; function.</a></li>
<li><a href='#CUP'><p>CUP</p></a></li>
<li><a href='#draw_Metropolis_multiple'><p>Draw Metropolis multiple</p></a></li>
<li><a href='#draw_Metropolis_single'><p>Draw Metropolis single</p></a></li>
<li><a href='#estimate_ERPM'><p>Estimate ERPM</p></a></li>
<li><a href='#estimate_logL'><p>Estimate log likelihood</p></a></li>
<li><a href='#estimate_multipleERPM'><p>Estimate ERPM for multiple observations</p></a></li>
<li><a href='#exactestimates_numgroups'><p>Exact estimates number of groups</p></a></li>
<li><a href='#find_all_partitions'><p>Function to enumerate all possible partitions for a given n</p></a></li>
<li><a href='#gridsearch_burnin_single'><p>Grid - search burnin single</p></a></li>
<li><a href='#gridsearch_burninthining_multiple'><p>Grid - search burnin thining multiple</p></a></li>
<li><a href='#gridsearch_burninthining_single'><p>Grid - search burnin thining single</p></a></li>
<li><a href='#gridsearch_thining_single'><p>Grid - search thining single</p></a></li>
<li><a href='#group_size'><p>Statistics on the size of groups in a partition</p></a></li>
<li><a href='#icc'><p>Intra class correlation</p></a></li>
<li><a href='#number_categories'><p>Number of individuals having an attribute</p></a></li>
<li><a href='#number_ties'><p>Same pairs of individuals in a partition</p></a></li>
<li><a href='#order_groupids'><p>Function to replace the ids of the group without forgetting an id</p>
and put in the first appearance order
for example: <code style="white-space: pre;">&#8288;[2 1 1 4 2]&#8288;</code> becomes <code style="white-space: pre;">&#8288;[1 2 2 3 1]&#8288;</code></a></li>
<li><a href='#outcomeObjects'><p>Exemplary outcome objects for the ERPM Package</p></a></li>
<li><a href='#phase1'><p>Core function for Phase 1</p></a></li>
<li><a href='#plot_averagesizes'><p>Plot average sizes</p></a></li>
<li><a href='#plot_numgroups_likelihood'><p>Plot likelihood of number groups</p></a></li>
<li><a href='#plot_partition'><p>Visualization of partition</p></a></li>
<li><a href='#print.results.bayesian.erpm'><p>Print results of bayesian estimation (beta version)</p></a></li>
<li><a href='#print.results.list.erpm'><p>Print estimation results</p></a></li>
<li><a href='#print.results.p3.erpm'><p>Print results of estimation of phase 3</p></a></li>
<li><a href='#proportion_isolate'><p>Proportion of isolates</p></a></li>
<li><a href='#range_attribute'><p>Range of attribute in groups</p></a></li>
<li><a href='#run_phase1_multiple'><p>Phase 1 wrapper for multiple observations</p></a></li>
<li><a href='#run_phase1_single'><p>Phase 1 wrapper for single observation</p></a></li>
<li><a href='#run_phase2_multiple'><p>Phase 2 wrapper for multiple observation</p></a></li>
<li><a href='#run_phase2_single'><p>Phase 2 wrapper for single observation</p></a></li>
<li><a href='#run_phase3_multiple'><p>Phase 3 wrapper for multiple observation</p></a></li>
<li><a href='#run_phase3_single'><p>Phase 3 wrapper for single observation</p></a></li>
<li><a href='#same_pairs'><p>Same pairs of individuals in a partition</p></a></li>
<li><a href='#similar_pairs'><p>Similar pairs of individuals in a partition</p></a></li>
<li><a href='#simulate_burnin_single'><p>Simulate burn in single</p></a></li>
<li><a href='#simulate_burninthining_multiple'><p>Simulate burnin thining multiple</p></a></li>
<li><a href='#simulate_burninthining_single'><p>Simulate burnin thining single</p></a></li>
<li><a href='#simulate_thining_single'><p>Simulate thining single</p></a></li>
<li><a href='#Stirling2_constraints'><p>Function to calculate the number of partitions with k groups</p>
of sizes between smin and smax</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Exponential Random Partition Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-03</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulates and estimates the Exponential Random Partition Model presented 
    in the paper Hoffman, Block, and Snijders (2023) &lt;<a href="https://doi.org/10.1177%2F00811750221145166">doi:10.1177/00811750221145166</a>&gt;. 
    It can also be used to estimate longitudinal partitions, following the model 
    proposed in Hoffman and Chabot (2023) &lt;<a href="https://doi.org/10.1016%2Fj.socnet.2023.04.002">doi:10.1016/j.socnet.2023.04.002</a>&gt;. 
    The model is an exponential family distribution on the space of partitions 
    (sets of non-overlapping groups) and is called in reference to the Exponential 
    Random Graph Models (ERGM) for networks.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>numbers, utils, stats, igraph, RColorBrewer, snowfall</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'erpm-package.R' 'functions_utility.R'
'functions_Metropolis.R' 'functions_burninthining.R'
'functions_change_statistics.R' 'functions_estimate.R'
'functions_exactcalculations.R'
'functions_exchange_algorithm.R' 'functions_loglikelihood.R'
'functions_output.R' 'functions_phase1.R' 'functions_phase2.R'
'functions_phase3.R' 'functions_statistics.R'
'functions_visualisation.R' 'outcomeObjects.R'</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stocnet/ERPM">https://github.com/stocnet/ERPM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stocnet/ERPM/issues">https://github.com/stocnet/ERPM/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-09 13:58:06 UTC; hoffman</td>
</tr>
<tr>
<td>Author:</td>
<td>Marion Hoffman <a href="https://orcid.org/0000-0002-0741-7760"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, cph],
  Alexandra Amani [aut],
  Nico Keiser [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marion Hoffman &lt;marion.hoffman.31@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-10 17:53:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='ERPM-package'>ERPM: Exponential Random Partition Models</h2><span id='topic+ERPM'></span><span id='topic+ERPM-package'></span>

<h3>Description</h3>

<p>Simulates and estimates the Exponential Random Partition Model presented in the paper Hoffman, Block, and Snijders (2023) <a href="https://doi.org/10.1177/00811750221145166">doi:10.1177/00811750221145166</a>. It can also be used to estimate longitudinal partitions, following the model proposed in Hoffman and Chabot (2023) <a href="https://doi.org/10.1016/j.socnet.2023.04.002">doi:10.1016/j.socnet.2023.04.002</a>. The model is an exponential family distribution on the space of partitions (sets of non-overlapping groups) and is called in reference to the Exponential Random Graph Models (ERGM) for networks.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Marion Hoffman <a href="mailto:marion.hoffman.31@gmail.com">marion.hoffman.31@gmail.com</a> (<a href="https://orcid.org/0000-0002-0741-7760">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Alexandra Amani
</p>
</li>
<li><p> Nico Keiser
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/stocnet/ERPM">https://github.com/stocnet/ERPM</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/stocnet/ERPM/issues">https://github.com/stocnet/ERPM/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Bell_constraints'>Function to calculate the number of partitions with groups
of sizes between smin and smax</h2><span id='topic+Bell_constraints'></span>

<h3>Description</h3>

<p>Function to calculate the number of partitions with groups
of sizes between smin and smax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bell_constraints(n, smin, smax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bell_constraints_+3A_n">n</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="Bell_constraints_+3A_smin">smin</code></td>
<td>
<p>minimum group size possible in the partition</p>
</td></tr>
<tr><td><code id="Bell_constraints_+3A_smax">smax</code></td>
<td>
<p>minimum group size possible in the partition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 6
size_min &lt;- 2
size_max &lt;- 4
Bell_constraints(n,size_min,size_max)

</code></pre>

<hr>
<h2 id='calculate_denominator_Dirichlet_restricted'>Calculate Dirichlet denominator</h2><span id='topic+calculate_denominator_Dirichlet_restricted'></span>

<h3>Description</h3>

<p>Recursive function to calculate the denominator for the model with a single statistic
for the number of groups and a given parameter value.
The set of possible partitions can be restricted to partitions with groups of a certain size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_denominator_Dirichlet_restricted(n, smin, smax, alpha, results)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_denominator_Dirichlet_restricted_+3A_n">n</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="calculate_denominator_Dirichlet_restricted_+3A_smin">smin</code></td>
<td>
<p>minimum size for a group</p>
</td></tr>
<tr><td><code id="calculate_denominator_Dirichlet_restricted_+3A_smax">smax</code></td>
<td>
<p>maximum size for a group</p>
</td></tr>
<tr><td><code id="calculate_denominator_Dirichlet_restricted_+3A_alpha">alpha</code></td>
<td>
<p>parameter value</p>
</td></tr>
<tr><td><code id="calculate_denominator_Dirichlet_restricted_+3A_results">results</code></td>
<td>
<p>a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric
</p>

<hr>
<h2 id='calculate_proba_Dirichlet_restricted'>Calculate Dirichlet probability</h2><span id='topic+calculate_proba_Dirichlet_restricted'></span>

<h3>Description</h3>

<p>Calculate the probability of observing a partition with a given number of groups
for a model with a single statistic for the number of groups and a given parameter value.
The set of possible partitions can be restricted to partitions with groups of a certain size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_proba_Dirichlet_restricted(alpha, stat, n, smin, smax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_proba_Dirichlet_restricted_+3A_alpha">alpha</code></td>
<td>
<p>parameter value</p>
</td></tr>
<tr><td><code id="calculate_proba_Dirichlet_restricted_+3A_stat">stat</code></td>
<td>
<p>observed stat (number of groups)</p>
</td></tr>
<tr><td><code id="calculate_proba_Dirichlet_restricted_+3A_n">n</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="calculate_proba_Dirichlet_restricted_+3A_smin">smin</code></td>
<td>
<p>minimum size for a group</p>
</td></tr>
<tr><td><code id="calculate_proba_Dirichlet_restricted_+3A_smax">smax</code></td>
<td>
<p>maximum size for a group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric
</p>

<hr>
<h2 id='check_sizes'>Function to determine whether a partition contains the allowed group sizes</h2><span id='topic+check_sizes'></span>

<h3>Description</h3>

<p>Function to determine whether a partition contains the allowed group sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_sizes(partition, sizes.allowed, numgroups.allowed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_sizes_+3A_partition">partition</code></td>
<td>
<p>observed partition</p>
</td></tr>
<tr><td><code id="check_sizes_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>vector containing possible group sizes in the partition</p>
</td></tr>
<tr><td><code id="check_sizes_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing possible number of groups in the partition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean
</p>

<hr>
<h2 id='compute_averagesize'>Compute the average size of a random partition</h2><span id='topic+compute_averagesize'></span>

<h3>Description</h3>

<p>Recursive function to compute the average size of a random partition for a given number of nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_averagesize(num.nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_averagesize_+3A_num.nodes">num.nodes</code></td>
<td>
<p>number of nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 6
compute_averagesize(n)

</code></pre>

<hr>
<h2 id='compute_numgroups_denominator'>Compute denominator for model with number of groups</h2><span id='topic+compute_numgroups_denominator'></span>

<h3>Description</h3>

<p>Recursive function to compute the value of the denominator for the model
with a single statistic which is the number of groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_numgroups_denominator(num.nodes, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_numgroups_denominator_+3A_num.nodes">num.nodes</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="compute_numgroups_denominator_+3A_alpha">alpha</code></td>
<td>
<p>parameter value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric
</p>

<hr>
<h2 id='computeStatistics'>Compute Statistics</h2><span id='topic+computeStatistics'></span>

<h3>Description</h3>

<p>Function that computes the statistic vector for a given partition and a given model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeStatistics(partition, nodes, effects, objects)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeStatistics_+3A_partition">partition</code></td>
<td>
<p>vector, A partition</p>
</td></tr>
<tr><td><code id="computeStatistics_+3A_nodes">nodes</code></td>
<td>
<p>data frame, Node set</p>
</td></tr>
<tr><td><code id="computeStatistics_+3A_effects">effects</code></td>
<td>
<p>list with a vector &quot;names&quot;, and a vector &quot;objects&quot;, Effects/sufficient statistics</p>
</td></tr>
<tr><td><code id="computeStatistics_+3A_objects">objects</code></td>
<td>
<p>list with a vector &quot;name&quot;, and a vector &quot;object&quot;, Objects used for statistics calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the statistics
</p>

<hr>
<h2 id='computeStatistics_multiple'>Compute Statistics multiple</h2><span id='topic+computeStatistics_multiple'></span>

<h3>Description</h3>

<p>Function that computes the statistic vector for given (multiple) partitions and a given model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeStatistics_multiple(
  partitions,
  presence.tables,
  nodes,
  effects,
  objects,
  single.obs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeStatistics_multiple_+3A_partitions">partitions</code></td>
<td>
<p>Observed partitions</p>
</td></tr>
<tr><td><code id="computeStatistics_multiple_+3A_presence.tables">presence.tables</code></td>
<td>
<p>to indicate which nodes were present when</p>
</td></tr>
<tr><td><code id="computeStatistics_multiple_+3A_nodes">nodes</code></td>
<td>
<p>Node set (data frame)</p>
</td></tr>
<tr><td><code id="computeStatistics_multiple_+3A_effects">effects</code></td>
<td>
<p>Effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="computeStatistics_multiple_+3A_objects">objects</code></td>
<td>
<p>Objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="computeStatistics_multiple_+3A_single.obs">single.obs</code></td>
<td>
<p>equal NULL by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>

<hr>
<h2 id='correlation_between'>Between groups correlation</h2><span id='topic+correlation_between'></span>

<h3>Description</h3>

<p>This function computes the correlation between the group averages of the two attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation_between(partition, attribute1, attribute2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlation_between_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="correlation_between_+3A_attribute1">attribute1</code></td>
<td>
<p>A vector containing the values of the first attribute</p>
</td></tr>
<tr><td><code id="correlation_between_+3A_attribute2">attribute2</code></td>
<td>
<p>A vector containing the values of the second attribute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number corresponding to the correlation coefficient
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,2,2,3,3,4,4,4,5)
at &lt;- c(3,5,23,2,1,0,3,9,2)
at2 &lt;- c(3,5,20,2,1,0,0,9,0)
correlation_between(p,at,at2)
</code></pre>

<hr>
<h2 id='correlation_with_size'>Correlation with size</h2><span id='topic+correlation_with_size'></span>

<h3>Description</h3>

<p>This function computes the correlation between an attribute and the size of the groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation_with_size(partition, attribute, categorical)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlation_with_size_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="correlation_with_size_+3A_attribute">attribute</code></td>
<td>
<p>A vector containing the values of the attribute</p>
</td></tr>
<tr><td><code id="correlation_with_size_+3A_categorical">categorical</code></td>
<td>
<p>A Boolean (True or False) indicating if the attribute is categorical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number corresponding to the correlation coefficient if the attribute is numerical or
the correlation ratio if the attribute is categorical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,2,2,3,3,4,4,4,5)
at &lt;- c(3,5,23,2,1,0,3,9,2)
correlation_with_size(p,at,categorical=FALSE)
</code></pre>

<hr>
<h2 id='correlation_within'>Within groups correlation</h2><span id='topic+correlation_within'></span>

<h3>Description</h3>

<p>This function computes the correlation between the two attributes for individuals in the same group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation_within(partition, attribute1, attribute2, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlation_within_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="correlation_within_+3A_attribute1">attribute1</code></td>
<td>
<p>A vector containing the values of the first attribute</p>
</td></tr>
<tr><td><code id="correlation_within_+3A_attribute2">attribute2</code></td>
<td>
<p>A vector containing the values of the second attribute</p>
</td></tr>
<tr><td><code id="correlation_within_+3A_group">group</code></td>
<td>
<p>A number indicating the selected group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number corresponding to the correlation coefficient
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,2,2,3,3,4,4,4,5)
at &lt;- c(3,5,23,2,1,0,3,9,2)
at2 &lt;- c(3,5,20,2,1,0,0,9,0)
correlation_within(p,at,at2,4)
</code></pre>

<hr>
<h2 id='count_classes'>Function to count the number of partitions with a certain
group size structure, for all possible group size structure.
Function to use after calling the &quot;find_all_partitions&quot; function.</h2><span id='topic+count_classes'></span>

<h3>Description</h3>

<p>Function to count the number of partitions with a certain
group size structure, for all possible group size structure.
Function to use after calling the &quot;find_all_partitions&quot; function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_classes(allpartitions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_classes_+3A_allpartitions">allpartitions</code></td>
<td>
<p>matrix containing all possible partitions for a nodeset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer(number of partitions with different group structures)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#find partitions first
n &lt;- 6
all_partitions &lt;- find_all_partitions(n)
# count classes
counts_partition_classes &lt;- count_classes(all_partitions)

</code></pre>

<hr>
<h2 id='CUP'>CUP</h2><span id='topic+CUP'></span>

<h3>Description</h3>

<p>This function tests a partition statistic against a &quot;conditional uniform partition null hypothesi:
It compares a statistic computed on an observed partition and the same statistic computed on a set of permuted partition
(partitions with the same group structure as the observed partition, with nodes being permuted).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CUP(observation, fun, permutations = NULL, num.permutations = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CUP_+3A_observation">observation</code></td>
<td>
<p>A vector giving the observed partition</p>
</td></tr>
<tr><td><code id="CUP_+3A_fun">fun</code></td>
<td>
<p>A function used to compute a given partition statistic to be computed</p>
</td></tr>
<tr><td><code id="CUP_+3A_permutations">permutations</code></td>
<td>
<p>A matrix, whose lines contain partitions which are permutations of the observed partition.
This argument is NULL by default (in that case, the permutations are created automatically).</p>
</td></tr>
<tr><td><code id="CUP_+3A_num.permutations">num.permutations</code></td>
<td>
<p>An integer indicating the number of permutations to generate, if they are not already given.
1000 permutations are generated by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test is similar to Conditional Uniform Graph tests in networks (we translate this into Condtional Uniform Partition tests).
</p>


<h3>Value</h3>

<p>The value of the statistic calculated for the observed partition,
the mean value of the statistic among permuted partitions,
the standard deviation of the statistic among permuted partitions,
the proportion of permutation below the observed statistic,
the proportion of permutation above the observed statistic,
the lower boundary of the 95% CI,
the upper boundary of the 95% CI
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,2,2,3,3,4,4,4,5)
at &lt;- c(0,1,1,1,1,0,0,0,0)
CUP(p,fun=function(x){same_pairs(x,at,'avg_pergroup')})
</code></pre>

<hr>
<h2 id='draw_Metropolis_multiple'>Draw Metropolis multiple</h2><span id='topic+draw_Metropolis_multiple'></span>

<h3>Description</h3>

<p>Function to sample the model with a Markov chain (single partition procedure).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_Metropolis_multiple(
  theta,
  first.partitions,
  presence.tables,
  nodes,
  effects,
  objects,
  burnin,
  thining,
  num.steps,
  neighborhood = c(0.7, 0.3, 0),
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  return.all.partitions = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_Metropolis_multiple_+3A_theta">theta</code></td>
<td>
<p>model parameters</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_first.partitions">first.partitions</code></td>
<td>
<p>starting partition for the Markov chain</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_presence.tables">presence.tables</code></td>
<td>
<p>matrix indicating which actors were present for each observations (mandatory)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_nodes">nodes</code></td>
<td>
<p>node set (data frame)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_effects">effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_objects">objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_burnin">burnin</code></td>
<td>
<p>integer for the number of burn-in steps before sampling</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_thining">thining</code></td>
<td>
<p>integer for the number of thining steps between sampling</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_num.steps">num.steps</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_neighborhood">neighborhood</code></td>
<td>
<p>= c(0.7,0.3,0), way of choosing partitions: probability vector (2 actors swap, merge/division, single actor move, single pair move, 2 pairs swap, 2 groups reshuffle)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>= NULL, # vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>= NULL, # vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>= NULL,  vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>= NULL, vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_return.all.partitions">return.all.partitions</code></td>
<td>
<p>= FALSE, option to return the sampled partitions on top of their statistics (for GOF)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_multiple_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define an arbitrary set of n = 6 nodes with attributes, and an arbitrary covariate matrix
n &lt;- 6 
nodes &lt;- data.frame(label = c("A","B","C","D","E","F"),
                    gender = c(1,1,2,1,2,2),
                    age = c(20,22,25,30,30,31)) 
friendship &lt;- matrix(c(0, 1, 1, 1, 0, 0,
                       1, 0, 0, 0, 1, 0,
                       1, 0, 0, 0, 1, 0,
                       1, 0, 0, 0, 0, 0,
                       0, 1, 1, 0, 0, 1,
                       0, 0, 0, 0, 1, 0), 6, 6, TRUE) 

# specify whether nodes are present at different points of time
presence.tables &lt;- matrix(c(1, 1, 1, 1, 1, 1,
                            0, 1, 1, 1, 1, 1,
                            1, 0, 1, 1, 1, 1), 6, 3)

# choose effects to be included in the estimated model
effects_multiple &lt;- list(names = c("num_groups","same","diff","tie","inertia_1"),
                objects = c("partitions","gender","age","friendship","partitions"),
                objects2 = c("","","","",""))
objects_multiple &lt;- list()
objects_multiple[[1]] &lt;- list(name = "friendship", object = friendship)

# set parameter values for each of these effects
parameters &lt;- c(-0.2,0.2,-0.1,0.5,1)

# set a starting point for the simulation
first.partitions &lt;- matrix(c(1, 1, 2, 2, 2, 3,
                             NA, 1, 1, 2, 2, 2,
                             1, NA, 2, 3, 3, 1), 6, 3) 


# generate the simulated sample
nsteps &lt;- 50
sample &lt;- draw_Metropolis_multiple(theta = parameters, 
                                   first.partitions = first.partitions,
                                   nodes = nodes, 
                                   presence.tables = presence.tables,
                                   effects = effects_multiple, 
                                   objects = objects_multiple, 
                                   burnin = 100, 
                                   thining = 100, 
                                   num.steps = nsteps, 
                                   neighborhood = c(0,1,0), 
                                   numgroups.allowed = 1:n,
                                   numgroups.simulated = 1:n,
                                   sizes.allowed = 1:n,
                                   sizes.simulated = 1:n,
                                   return.all.partitions = TRUE)


</code></pre>

<hr>
<h2 id='draw_Metropolis_single'>Draw Metropolis single</h2><span id='topic+draw_Metropolis_single'></span>

<h3>Description</h3>

<p>Function to sample the model with a Markov chain (single partition procedure).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_Metropolis_single(
  theta,
  first.partition,
  nodes,
  effects,
  objects,
  burnin,
  thining,
  num.steps,
  neighborhood = c(0.7, 0.3, 0),
  numgroups.allowed = NULL,
  numgroups.simulated = NULL,
  sizes.allowed = NULL,
  sizes.simulated = NULL,
  return.all.partitions = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_Metropolis_single_+3A_theta">theta</code></td>
<td>
<p>model parameters</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_first.partition">first.partition</code></td>
<td>
<p>starting partition for the Markov chain</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_nodes">nodes</code></td>
<td>
<p>nodeset (data frame)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_effects">effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_objects">objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_burnin">burnin</code></td>
<td>
<p>integer for the number of burn-in steps before sampling</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_thining">thining</code></td>
<td>
<p>integer for the number of thining steps between sampling</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_num.steps">num.steps</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_neighborhood">neighborhood</code></td>
<td>
<p>= c(0.7,0.3,0), way of choosing partitions: probability vector (2 actors swap, merge/division, single actor move, single pair move, 2 pairs swap, 2 groups reshuffle)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>= NULL, # vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>= NULL, # vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>= NULL,  vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>= NULL, vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="draw_Metropolis_single_+3A_return.all.partitions">return.all.partitions</code></td>
<td>
<p>= FALSE option to return the sampled partitions on top of their statistics (for GOF)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define an arbitrary set of n = 6 nodes with attributes, and an arbitrary covariate matrix
n &lt;- 6 
nodes &lt;- data.frame(label = c("A","B","C","D","E","F"),
                    gender = c(1,1,2,1,2,2),
                    age = c(20,22,25,30,30,31)) 
friendship &lt;- matrix(c(0, 1, 1, 1, 0, 0,
                       1, 0, 0, 0, 1, 0,
                       1, 0, 0, 0, 1, 0,
                       1, 0, 0, 0, 0, 0,
                       0, 1, 1, 0, 0, 1,
                       0, 0, 0, 0, 1, 0), 6, 6, TRUE)

# choose the effects to be included (see manual for all effect names)
effects &lt;- list(names = c("num_groups","same","diff","tie"),
objects = c("partition","gender","age","friendship"))
objects &lt;- list()
objects[[1]] &lt;- list(name = "friendship", object = friendship)

# set parameter values for each of these effects
parameters &lt;- c(-0.2, 0.2, -0.1, 0.5)


# generate simulated sample, by setting the desired additional parameters for the 
# Metropolis sampler and choosing a starting point for the chain (first.partition)
nsteps &lt;- 100
sample &lt;- draw_Metropolis_single(theta = parameters, 
                                 first.partition = c(1,1,2,2,3,3), 
                                 nodes = nodes, 
                                 effects = effects, 
                                 objects = objects, 
                                 burnin = 100, 
                                 thining = 10, 
                                 num.steps = nsteps, 
                                 neighborhood = c(0,1,0), 
                                 numgroups.allowed = 1:n,
                                 numgroups.simulated = 1:n,
                                 sizes.allowed = 1:n,
                                 sizes.simulated = 1:n,
                                 return.all.partitions = TRUE)


# or: simulate an estimated model
partition &lt;- c(1,1,2,2,2,3) # the partition already defined for the (previous) estimation
nsimulations &lt;- 1000
simulations &lt;- draw_Metropolis_single(theta = estimation$results$est, 
                                      first.partition = partition, 
                                      nodes = nodes, 
                                      effects = effects, 
                                      objects = objects, 
                                      burnin = 100, 
                                      thining = 20, 
                                      num.steps = nsimulations, 
                                      neighborhood = c(0,1,0), 
                                      sizes.allowed = 1:n,
                                      sizes.simulated = 1:n,
                                      return.all.partitions = TRUE)


</code></pre>

<hr>
<h2 id='estimate_ERPM'>Estimate ERPM</h2><span id='topic+estimate_ERPM'></span>

<h3>Description</h3>

<p>Function to estimate a given model for a given observed partition.
All options of the algorithm can be specified here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_ERPM(
  partition,
  nodes,
  objects,
  effects,
  startingestimates,
  gainfactor = 0.1,
  a.scaling = 0.8,
  r.truncation.p1 = -1,
  r.truncation.p2 = -1,
  burnin = 30,
  thining = 10,
  length.p1 = 100,
  min.iter.p2 = NULL,
  max.iter.p2 = NULL,
  multiplication.iter.p2 = 100,
  num.steps.p2 = 6,
  length.p3 = 1000,
  neighborhood = c(0.7, 0.3, 0),
  fixed.estimates = NULL,
  numgroups.allowed = NULL,
  numgroups.simulated = NULL,
  sizes.allowed = NULL,
  sizes.simulated = NULL,
  double.averaging = FALSE,
  inv.zcov = NULL,
  inv.scaling = NULL,
  parallel = FALSE,
  parallel2 = FALSE,
  cpus = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_ERPM_+3A_partition">partition</code></td>
<td>
<p>observed partition</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_nodes">nodes</code></td>
<td>
<p>nodeset (data frame)</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_objects">objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_effects">effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_startingestimates">startingestimates</code></td>
<td>
<p>first guess for the model parameters</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_gainfactor">gainfactor</code></td>
<td>
<p>numeric used to decrease the size of steps made in the Newton optimization</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_a.scaling">a.scaling</code></td>
<td>
<p>numeric used to reduce the influence of non-diagonal elements in the scaling matrix (for stability)</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_r.truncation.p1">r.truncation.p1</code></td>
<td>
<p>numeric used to limit extreme values in the covariance matrix (for stability)</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_r.truncation.p2">r.truncation.p2</code></td>
<td>
<p>numeric used to limit extreme values in the covariance matrix (for stability)</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_burnin">burnin</code></td>
<td>
<p>integer for the number of burn-in steps before sampling</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_thining">thining</code></td>
<td>
<p>integer for the number of thining steps between sampling</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_length.p1">length.p1</code></td>
<td>
<p>number of samples in phase 1</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_min.iter.p2">min.iter.p2</code></td>
<td>
<p>minimum number of sub-steps in phase 2</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_max.iter.p2">max.iter.p2</code></td>
<td>
<p>maximum number of sub-steps in phase 2</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_multiplication.iter.p2">multiplication.iter.p2</code></td>
<td>
<p>value for the lengths of sub-steps in phase 2 (multiplied by  2.52^k)</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_num.steps.p2">num.steps.p2</code></td>
<td>
<p>number of optimisation steps in phase 2</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_length.p3">length.p3</code></td>
<td>
<p>number of samples in phase 3</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_neighborhood">neighborhood</code></td>
<td>
<p>way of choosing partitions: probability vector (actors swap, merge/division, single actor move)</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_fixed.estimates">fixed.estimates</code></td>
<td>
<p>if some parameters are fixed, list with as many elements as effects, these elements equal a fixed value if needed, or NULL if they should be estimated</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_double.averaging">double.averaging</code></td>
<td>
<p>option to average the statistics sampled in each sub-step of phase 2</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_inv.zcov">inv.zcov</code></td>
<td>
<p>initial value of the inverted covariance matrix (if a phase 3 was run before) to bypass the phase 1</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_inv.scaling">inv.scaling</code></td>
<td>
<p>initial value of the inverted scaling matrix (if a phase 3 was run before) to bypass the phase 1</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_parallel">parallel</code></td>
<td>
<p>whether the phase 1 and 3 should be parallelized</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_parallel2">parallel2</code></td>
<td>
<p>whether there should be several phases 2 run in parallel</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_cpus">cpus</code></td>
<td>
<p>how many cores can be used</p>
</td></tr>
<tr><td><code id="estimate_ERPM_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the outputs of the three different phases of the algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define an arbitrary set of n = 6 nodes with attributes, and an arbitrary covariate matrix
n &lt;- 6 
nodes &lt;- data.frame(label = c("A","B","C","D","E","F"),
                    gender = c(1,1,2,1,2,2),
                    age = c(20,22,25,30,30,31)) 
friendship &lt;- matrix(c(0, 1, 1, 1, 0, 0,
                       1, 0, 0, 0, 1, 0,
                       1, 0, 0, 0, 1, 0,
                       1, 0, 0, 0, 0, 0,
                       0, 1, 1, 0, 0, 1,
                       0, 0, 0, 0, 1, 0), 6, 6, TRUE)

# choose the effects to be included (see manual for all effect names)
effects &lt;- list(names = c("num_groups","same","diff","tie"),
                objects = c("partition","gender","age","friendship"))
objects &lt;- list()
objects[[1]] &lt;- list(name = "friendship", object = friendship)

# define observed partition
partition &lt;- c(1,1,2,2,2,3)


# estimate
startingestimates &lt;- c(-2,0,0,0)
estimation &lt;- estimate_ERPM(partition, 
                            nodes, 
                            objects, 
                            effects, 
                            startingestimates = startingestimates, 
                            burnin = 100, 
                            thining = 20,
                            length.p1 = 500, # number of samples in phase 1
                            multiplication.iter.p2 = 20, # iterations in phase 2
                            num.steps.p2 = 4, # number of phase 2 subphases
                            length.p3 = 1000) # number of samples in phase 3

# get results table
estimation


</code></pre>

<hr>
<h2 id='estimate_logL'>Estimate log likelihood</h2><span id='topic+estimate_logL'></span>

<h3>Description</h3>

<p>Function to estimate the log likelihood of a model for an observed partition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_logL(
  partition,
  nodes,
  effects,
  objects,
  theta,
  theta_0,
  M,
  num.steps,
  burnin,
  thining,
  neighborhoods = c(0.7, 0.3, 0),
  numgroups.allowed = NULL,
  numgroups.simulated = NULL,
  sizes.allowed = NULL,
  sizes.simulated = NULL,
  logL_0 = NULL,
  parallel = FALSE,
  cpus = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_logL_+3A_partition">partition</code></td>
<td>
<p>observed partition</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_nodes">nodes</code></td>
<td>
<p>node set (data frame)</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_effects">effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_objects">objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_theta">theta</code></td>
<td>
<p>estimated model parameters</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_theta_0">theta_0</code></td>
<td>
<p>model parameters if all other effects than &quot;num-groups&quot; are fixed to 0 (basic Dirichlet partition model)</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_m">M</code></td>
<td>
<p>number of steps in the path-sampling algorithm</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_num.steps">num.steps</code></td>
<td>
<p>number of samples in each step</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_burnin">burnin</code></td>
<td>
<p>integer for the number of burn-in steps before sampling</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_thining">thining</code></td>
<td>
<p>integer for the number of thining steps between sampling</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_neighborhoods">neighborhoods</code></td>
<td>
<p>= c(0.7,0.3,0) way of choosing partitions</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>= NULL, # vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>= NULL, # vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>= NULL,   vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>= NULL,  vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_logl_0">logL_0</code></td>
<td>
<p>= NULL, if known, the value of the log likelihood of the basic dirichlet model</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_parallel">parallel</code></td>
<td>
<p>= FALSE, indicating whether the code should be run in parallel</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_cpus">cpus</code></td>
<td>
<p>= 1, number of cpus required for the parallelization</p>
</td></tr>
<tr><td><code id="estimate_logL_+3A_verbose">verbose</code></td>
<td>
<p>= FALSE, to print the current step the algorithm is in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the log likelihood , AIC, lambda and the draws
</p>


<h3>Examples</h3>

<pre><code class='language-R'># estimate the log-likelihood and AIC of an estimated model (e.g. useful to compare two models)

# define an arbitrary set of n = 6 nodes with attributes, and an arbitrary covariate matrix
n &lt;- 6
nodes &lt;- data.frame(label = c("A","B","C","D","E","F"),
                    gender = c(1,1,2,1,2,2),
                    age = c(20,22,25,30,30,31)) 
friendship &lt;- matrix(c(0, 1, 1, 1, 0, 0,
                       1, 0, 0, 0, 1, 0,
                       1, 0, 0, 0, 1, 0,
                       1, 0, 0, 0, 0, 0,
                       0, 1, 1, 0, 0, 1,
                       0, 0, 0, 0, 1, 0), 6, 6, TRUE)

# choose the effects to be included (see manual for all effect names)
effects &lt;- list(names = c("num_groups","same","diff","tie"),
objects = c("partition","gender","age","friendship"))
objects &lt;- list()
objects[[1]] &lt;- list(name = "friendship", object = friendship)

# define observed partition 
partition &lt;- c(1,1,2,2,2,3)
# (an exemplary estimation is internally stored in order to save time)

# first: estimate the ML estimates of a simple model with only one parameter 
# for number of groups (this parameter should be in the model!)
likelihood_function &lt;- function(x){ exp(x*max(partition)) / compute_numgroups_denominator(n,x)}
curve(likelihood_function, from=-2, to=0)
parameter_base &lt;- optimize(likelihood_function, interval=c(-2, 0), maximum=TRUE)
parameters_basemodel &lt;- c(parameter_base$maximum,0,0,0)


# estimate logL and AIC
logL_AIC &lt;- estimate_logL(partition,
                          nodes,
                          effects, 
                          objects,
                          theta = estimation$results$est,
                          theta_0 = parameters_basemodel,
                          M = 3,
                          num.steps = 200,
                          burnin = 100,
                          thining = 20)
logL_AIC$logL
logL_AIC$AIC


</code></pre>

<hr>
<h2 id='estimate_multipleERPM'>Estimate ERPM for multiple observations</h2><span id='topic+estimate_multipleERPM'></span>

<h3>Description</h3>

<p>Function to estimate a given model for given observed (multiple) partitions.
All options of the algorithm can be specified here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_multipleERPM(
  partitions,
  presence.tables,
  nodes,
  objects,
  effects,
  startingestimates,
  gainfactor = 0.1,
  a.scaling = 0.8,
  r.truncation.p1 = -1,
  r.truncation.p2 = -1,
  burnin = 30,
  thining = 10,
  length.p1 = 100,
  min.iter.p2 = NULL,
  max.iter.p2 = NULL,
  multiplication.iter.p2 = 200,
  num.steps.p2 = 6,
  length.p3 = 1000,
  neighborhood = c(0.7, 0.3, 0),
  fixed.estimates = NULL,
  numgroups.allowed = NULL,
  numgroups.simulated = NULL,
  sizes.allowed = NULL,
  sizes.simulated = NULL,
  double.averaging = FALSE,
  inv.zcov = NULL,
  inv.scaling = NULL,
  parallel = FALSE,
  parallel2 = FALSE,
  cpus = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_multipleERPM_+3A_partitions">partitions</code></td>
<td>
<p>observed partitions</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_presence.tables">presence.tables</code></td>
<td>
<p>XXX</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_nodes">nodes</code></td>
<td>
<p>nodeset (data frame)</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_objects">objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_effects">effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_startingestimates">startingestimates</code></td>
<td>
<p>first guess for the model parameters</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_gainfactor">gainfactor</code></td>
<td>
<p>numeric used to decrease the size of steps made in the Newton optimization</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_a.scaling">a.scaling</code></td>
<td>
<p>numeric used to reduce the influence of non-diagonal elements in the scaling matrix (for stability)</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_r.truncation.p1">r.truncation.p1</code></td>
<td>
<p>numeric used to limit extreme values in the covariance matrix (for stability)</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_r.truncation.p2">r.truncation.p2</code></td>
<td>
<p>numeric used to limit extreme values in the covariance matrix (for stability)</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_burnin">burnin</code></td>
<td>
<p>integer for the number of burn-in steps before sampling</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_thining">thining</code></td>
<td>
<p>integer for the number of thining steps between sampling</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_length.p1">length.p1</code></td>
<td>
<p>number of samples in phase 1</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_min.iter.p2">min.iter.p2</code></td>
<td>
<p>minimum number of sub-steps in phase 2</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_max.iter.p2">max.iter.p2</code></td>
<td>
<p>maximum number of sub-steps in phase 2</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_multiplication.iter.p2">multiplication.iter.p2</code></td>
<td>
<p>value for the lengths of sub-steps in phase 2 (multiplied by  2.52^k)</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_num.steps.p2">num.steps.p2</code></td>
<td>
<p>number of optimisation steps in phase 2</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_length.p3">length.p3</code></td>
<td>
<p>number of samples in phase 3</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_neighborhood">neighborhood</code></td>
<td>
<p>way of choosing partitions: probability vector (actors swap, merge/division, single actor move)</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_fixed.estimates">fixed.estimates</code></td>
<td>
<p>if some parameters are fixed, list with as many elements as effects, these elements equal a fixed value if needed, or NULL if they should be estimated</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_double.averaging">double.averaging</code></td>
<td>
<p>option to average the statistics sampled in each sub-step of phase 2</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_inv.zcov">inv.zcov</code></td>
<td>
<p>initial value of the inverted covariance matrix (if a phase 3 was run before) to bypass the phase 1</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_inv.scaling">inv.scaling</code></td>
<td>
<p>initial value of the inverted scaling matrix (if a phase 3 was run before) to bypass the phase 1</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_parallel">parallel</code></td>
<td>
<p>whether the phase 1 and 3 should be parallelized</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_parallel2">parallel2</code></td>
<td>
<p>whether there should be several phases 2 run in parallel</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_cpus">cpus</code></td>
<td>
<p>how many cores can be used</p>
</td></tr>
<tr><td><code id="estimate_multipleERPM_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the outputs of the three different phases of the algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define an arbitrary set of n = 6 nodes with attributes, and an arbitrary covariate matrix
n &lt;- 6 
nodes &lt;- data.frame(label = c("A","B","C","D","E","F"),
                    gender = c(1,1,2,1,2,2),
                    age = c(20,22,25,30,30,31)) 
friendship &lt;- matrix(c(0, 1, 1, 1, 0, 0,
                       1, 0, 0, 0, 1, 0,
                       1, 0, 0, 0, 1, 0,
                       1, 0, 0, 0, 0, 0,
                       0, 1, 1, 0, 0, 1,
                       0, 0, 0, 0, 1, 0), 6, 6, TRUE) 

# specify whether nodes are present at different points of time
presence.tables &lt;- matrix(c(1, 1, 1, 1, 1, 1,
                            0, 1, 1, 1, 1, 1,
                            1, 0, 1, 1, 1, 1), 6, 3)

# choose effects to be included in the estimated model
effects_multiple &lt;- list(names = c("num_groups","same","diff","tie","inertia_1"),
                objects = c("partitions","gender","age","friendship","partitions"),
                objects2 = c("","","","",""))
objects_multiple &lt;- list()
objects_multiple[[1]] &lt;- list(name = "friendship", object = friendship)

# define the observation
partitions &lt;- matrix(c(1, 1, 2, 2, 2, 3,
                       NA, 1, 1, 2, 2, 2,
                       1, NA, 2, 3, 3, 1), 6, 3) 


# estimate
startingestimates &lt;- c(-2,0,0,0,0)
estimation &lt;- estimate_multipleERPM(partitions,
                                    presence.tables,          
                                    nodes, 
                                    objects_multiple, 
                                    effects_multiple, 
                                    startingestimates = startingestimates, 
                                    burnin = 100, 
                                    thining = 50,
                                    gainfactor = 0.6,
                                    length.p1 = 200, 
                                    multiplication.iter.p2 = 20, 
                                    num.steps.p2 = 4, 
                                    length.p3 = 1000) 

# get results table
estimation


</code></pre>

<hr>
<h2 id='exactestimates_numgroups'>Exact estimates number of groups</h2><span id='topic+exactestimates_numgroups'></span>

<h3>Description</h3>

<p>This function finds the best estimate for a model only including the statistics of number of groups.
It does a grid search for a vector of potential parameters, for all numbers of groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exactestimates_numgroups(num.nodes, pmin, pmax, pinc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exactestimates_numgroups_+3A_num.nodes">num.nodes</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="exactestimates_numgroups_+3A_pmin">pmin</code></td>
<td>
<p>lowest parameter value</p>
</td></tr>
<tr><td><code id="exactestimates_numgroups_+3A_pmax">pmax</code></td>
<td>
<p>highest parameter value</p>
</td></tr>
<tr><td><code id="exactestimates_numgroups_+3A_pinc">pinc</code></td>
<td>
<p>increment between different parameter values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='find_all_partitions'>Function to enumerate all possible partitions for a given n</h2><span id='topic+find_all_partitions'></span>

<h3>Description</h3>

<p>Function to enumerate all possible partitions for a given n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_all_partitions(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_all_partitions_+3A_n">n</code></td>
<td>
<p>number of nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix where each line corresponds to a possible partition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 6
all_partitions &lt;- find_all_partitions(n)

</code></pre>

<hr>
<h2 id='gridsearch_burnin_single'>Grid - search burnin single</h2><span id='topic+gridsearch_burnin_single'></span>

<h3>Description</h3>

<p>Function that can be used to find a good length for the burn-in of the Markov chain for a given model and differents sets of transitions in the chain (the neighborhoods).
For each neighborhood, it draws a chain and calculates the mean statistics for different burn-ins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridsearch_burnin_single(
  partition,
  theta,
  nodes,
  effects,
  objects,
  num.steps,
  neighborhoods,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  parallel = FALSE,
  cpus = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridsearch_burnin_single_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="gridsearch_burnin_single_+3A_theta">theta</code></td>
<td>
<p>Initial model parameters</p>
</td></tr>
<tr><td><code id="gridsearch_burnin_single_+3A_nodes">nodes</code></td>
<td>
<p>Node set (data frame)</p>
</td></tr>
<tr><td><code id="gridsearch_burnin_single_+3A_effects">effects</code></td>
<td>
<p>Effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="gridsearch_burnin_single_+3A_objects">objects</code></td>
<td>
<p>Objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="gridsearch_burnin_single_+3A_num.steps">num.steps</code></td>
<td>
<p>Number of samples wanted</p>
</td></tr>
<tr><td><code id="gridsearch_burnin_single_+3A_neighborhoods">neighborhoods</code></td>
<td>
<p>List of probability vectors (proba actors swap, proba merge/division, proba single actor move)</p>
</td></tr>
<tr><td><code id="gridsearch_burnin_single_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>= NULL, # vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="gridsearch_burnin_single_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="gridsearch_burnin_single_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>Vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="gridsearch_burnin_single_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>Vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="gridsearch_burnin_single_+3A_parallel">parallel</code></td>
<td>
<p>False, to run different neighborhoods in parallel</p>
</td></tr>
<tr><td><code id="gridsearch_burnin_single_+3A_cpus">cpus</code></td>
<td>
<p>Equal to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>all simulations
</p>

<hr>
<h2 id='gridsearch_burninthining_multiple'>Grid - search burnin thining multiple</h2><span id='topic+gridsearch_burninthining_multiple'></span>

<h3>Description</h3>

<p>Function that simulates the Markov chain for a given model and several sets of transitions (the neighborhoods), for multiple partitions.
For each neighborhood, it calculates the autocorrelation of statistics for different thinings and the average statistics for different burn-ins.
Then the best neighborhood can be selected along with good values for burn-in and thining
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridsearch_burninthining_multiple(
  partitions,
  presence.tables,
  theta,
  nodes,
  effects,
  objects,
  num.steps,
  neighborhoods,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  max.thining,
  parallel = FALSE,
  cpus = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_partitions">partitions</code></td>
<td>
<p>Observed partitions</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_presence.tables">presence.tables</code></td>
<td>
<p>Presence of nodes</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_theta">theta</code></td>
<td>
<p>Initial model parameters</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_nodes">nodes</code></td>
<td>
<p>Node set (data frame)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_effects">effects</code></td>
<td>
<p>Effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_objects">objects</code></td>
<td>
<p>Objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_num.steps">num.steps</code></td>
<td>
<p>Number of samples wanted</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_neighborhoods">neighborhoods</code></td>
<td>
<p>List of probability vectors (proba actors swap, proba merge/division, proba single actor move)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>Vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>Vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_max.thining">max.thining</code></td>
<td>
<p>Where to stop adding thining</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_parallel">parallel</code></td>
<td>
<p>False, to run different neighborhoods in parallel</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_multiple_+3A_cpus">cpus</code></td>
<td>
<p>Equal to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='gridsearch_burninthining_single'>Grid - search burnin thining single</h2><span id='topic+gridsearch_burninthining_single'></span>

<h3>Description</h3>

<p>Function that simulates the Markov chain for a given model and several sets of transitions (the neighborhoods), for a single partition.
For each neighborhood, it calculates the autocorrelation of statistics for different thinings and the average statistics for different burn-ins.
Then the best neighborhood can be selected along with good values for burn-in and thining
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridsearch_burninthining_single(
  partition,
  theta,
  nodes,
  effects,
  objects,
  num.steps,
  neighborhoods,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  max.thining,
  parallel = FALSE,
  cpus = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridsearch_burninthining_single_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_theta">theta</code></td>
<td>
<p>Initial model parameters</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_nodes">nodes</code></td>
<td>
<p>Node set (data frame)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_effects">effects</code></td>
<td>
<p>Effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_objects">objects</code></td>
<td>
<p>Objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_num.steps">num.steps</code></td>
<td>
<p>Number of samples wanted</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_neighborhoods">neighborhoods</code></td>
<td>
<p>List of probability vectors (proba actors swap, proba merge/division, proba single actor move)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>Vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>Vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_max.thining">max.thining</code></td>
<td>
<p>Where to stop adding thining</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_parallel">parallel</code></td>
<td>
<p>False, to run different neighborhoods in parallel</p>
</td></tr>
<tr><td><code id="gridsearch_burninthining_single_+3A_cpus">cpus</code></td>
<td>
<p>Equal to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='gridsearch_thining_single'>Grid - search thining single</h2><span id='topic+gridsearch_thining_single'></span>

<h3>Description</h3>

<p>Function that can be used to find a good length for the thining of the Markov chain for a given model and differents sets of transitions in the chain (the neighborhoods).
For each neighborhood, it draws a chain and calculates the autocorrelation of statistics for different thinings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridsearch_thining_single(
  partition,
  theta,
  nodes,
  effects,
  objects,
  num.steps,
  neighborhoods,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  burnin,
  max.thining,
  parallel = FALSE,
  cpus = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridsearch_thining_single_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_theta">theta</code></td>
<td>
<p>Initial model parameters</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_nodes">nodes</code></td>
<td>
<p>Node set (data frame)</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_effects">effects</code></td>
<td>
<p>Effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_objects">objects</code></td>
<td>
<p>Objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_num.steps">num.steps</code></td>
<td>
<p>Number of samples wanted</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_neighborhoods">neighborhoods</code></td>
<td>
<p>List of probability vectors (proba actors swap, proba merge/division, proba single actor move)</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>Vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>Vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_burnin">burnin</code></td>
<td>
<p>length of the burn-in period</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_max.thining">max.thining</code></td>
<td>
<p>maximal value for the thining to be tested</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_parallel">parallel</code></td>
<td>
<p>False, to run different neighborhoods in parallel</p>
</td></tr>
<tr><td><code id="gridsearch_thining_single_+3A_cpus">cpus</code></td>
<td>
<p>Equal to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>all simulations
</p>

<hr>
<h2 id='group_size'>Statistics on the size of groups in a partition</h2><span id='topic+group_size'></span>

<h3>Description</h3>

<p>This function computes the average or the standard
deviation of the size of groups in a partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_size(partition, stat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_size_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="group_size_+3A_stat">stat</code></td>
<td>
<p>The statistic to compute : 'avg' for average and 'sd' for standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number corresponding to the correlation coefficient if the attribute is numerical or
the correlation ratio if the attribute is categorical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,2,2,3,3,4,4,4,5)
group_size(p,'avg')
group_size(p,'sd')
</code></pre>

<hr>
<h2 id='icc'>Intra class correlation</h2><span id='topic+icc'></span>

<h3>Description</h3>

<p>This function computes the intra class correlation correlation
of attributes for 2 randomly drawn individuals in the same group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icc(partition, attribute)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icc_+3A_partition">partition</code></td>
<td>
<p>A partition</p>
</td></tr>
<tr><td><code id="icc_+3A_attribute">attribute</code></td>
<td>
<p>A vector containing the values of the attribute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number corresponding to the ICC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,2,2,3,3,4,4,4,5)
at &lt;- c(3,5,23,2,1,0,3,9,2)
icc(p, at)
</code></pre>

<hr>
<h2 id='number_categories'>Number of individuals having an attribute</h2><span id='topic+number_categories'></span>

<h3>Description</h3>

<p>This function computes the total number of individuals being in a category of an attribute in a partition.
It also computes the sum of the proportion in each group of individuals being in
a category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_categories(partition, attribute, stat, category)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_categories_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="number_categories_+3A_attribute">attribute</code></td>
<td>
<p>A vector containing the values of the attribute</p>
</td></tr>
<tr><td><code id="number_categories_+3A_stat">stat</code></td>
<td>
<p>The statistic to compute : 'avg' for the sum of proportion per group and 'sum' for the total number</p>
</td></tr>
<tr><td><code id="number_categories_+3A_category">category</code></td>
<td>
<p>The category to consider or category = 'all' if all categories have to be considered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The statisic chosen in stat depending on the value of category. If category = 'all', returns a vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,2,2,3,3,4,4,4,5)
at &lt;- c(1,0,0,0,1,1,0,0,1)
number_categories(p,at,'avg','all')
</code></pre>

<hr>
<h2 id='number_ties'>Same pairs of individuals in a partition</h2><span id='topic+number_ties'></span>

<h3>Description</h3>

<p>This function computes the number of ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_ties(partition, dyadic_attribute, stat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_ties_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="number_ties_+3A_dyadic_attribute">dyadic_attribute</code></td>
<td>
<p>A matrix containing the values of the attribute</p>
</td></tr>
<tr><td><code id="number_ties_+3A_stat">stat</code></td>
<td>
<p>The statistic to compute : 'avg_pergroup' for the average per group , 'sum_pergroup' for the sum, 'sum_perind' and 'avg_perind' for the number of ties per individuals
each individual has in its group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The statisic chosen in stat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,2,2,3,3,4)
v &lt;- c(0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0)
at &lt;- matrix(v,6,6, byrow = TRUE)
number_ties(p,at,'avg_pergroup')
</code></pre>

<hr>
<h2 id='order_groupids'>Function to replace the ids of the group without forgetting an id
and put in the first appearance order
for example: <code style="white-space: pre;">&#8288;[2 1 1 4 2]&#8288;</code> becomes <code style="white-space: pre;">&#8288;[1 2 2 3 1]&#8288;</code></h2><span id='topic+order_groupids'></span>

<h3>Description</h3>

<p>Function to replace the ids of the group without forgetting an id
and put in the first appearance order
for example: <code style="white-space: pre;">&#8288;[2 1 1 4 2]&#8288;</code> becomes <code style="white-space: pre;">&#8288;[1 2 2 3 1]&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_groupids(partition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_groupids_+3A_partition">partition</code></td>
<td>
<p>observed partition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector (partition)
</p>

<hr>
<h2 id='outcomeObjects'>Exemplary outcome objects for the ERPM Package</h2><span id='topic+outcomeObjects'></span><span id='topic+estimation'></span>

<h3>Description</h3>

<p>These are exemplary outcome objects for the ERPM package and can be used in
order not to run all precedent functions and thus save time. The following
products are provided:
</p>


<h3>Format</h3>

<p><code>estimation</code>
An results object created by the function <code><a href="#topic+estimate_ERPM">estimate_ERPM()</a></code>.
</p>

<hr>
<h2 id='phase1'>Core function for Phase 1</h2><span id='topic+phase1'></span>

<h3>Description</h3>

<p>Core function for Phase 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase1(
  startingestimates,
  inv.zcov,
  inv.scaling,
  z.phase1,
  z.obs,
  nodes,
  effects,
  objects,
  r.truncation.p1,
  length.p1,
  fixed.estimates,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase1_+3A_startingestimates">startingestimates</code></td>
<td>
<p>vector containing initial parameter values</p>
</td></tr>
<tr><td><code id="phase1_+3A_inv.zcov">inv.zcov</code></td>
<td>
<p>inverted covariance matrix</p>
</td></tr>
<tr><td><code id="phase1_+3A_inv.scaling">inv.scaling</code></td>
<td>
<p>scaling matrix</p>
</td></tr>
<tr><td><code id="phase1_+3A_z.phase1">z.phase1</code></td>
<td>
<p>statistics retrieved from phase 1</p>
</td></tr>
<tr><td><code id="phase1_+3A_z.obs">z.obs</code></td>
<td>
<p>observed statistics</p>
</td></tr>
<tr><td><code id="phase1_+3A_nodes">nodes</code></td>
<td>
<p>node set (data frame)</p>
</td></tr>
<tr><td><code id="phase1_+3A_effects">effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="phase1_+3A_objects">objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="phase1_+3A_r.truncation.p1">r.truncation.p1</code></td>
<td>
<p>numeric used to limit extreme values in the covariance matrix (for stability)</p>
</td></tr>
<tr><td><code id="phase1_+3A_length.p1">length.p1</code></td>
<td>
<p>number of samples in phase 1</p>
</td></tr>
<tr><td><code id="phase1_+3A_fixed.estimates">fixed.estimates</code></td>
<td>
<p>if some parameters are fixed, list with as many elements as effects, these elements equal a fixed value if needed, or NULL if they should be estimated</p>
</td></tr>
<tr><td><code id="phase1_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated parameters after phase 1
</p>

<hr>
<h2 id='plot_averagesizes'>Plot average sizes</h2><span id='topic+plot_averagesizes'></span>

<h3>Description</h3>

<p>Function to plot the average size of a random partition depending on the number of nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_averagesizes(nmin, nmax, ninc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_averagesizes_+3A_nmin">nmin</code></td>
<td>
<p>minimum number of nodes</p>
</td></tr>
<tr><td><code id="plot_averagesizes_+3A_nmax">nmax</code></td>
<td>
<p>maximum number of nodes</p>
</td></tr>
<tr><td><code id="plot_averagesizes_+3A_ninc">ninc</code></td>
<td>
<p>increment between the different number of nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector
</p>

<hr>
<h2 id='plot_numgroups_likelihood'>Plot likelihood of number groups</h2><span id='topic+plot_numgroups_likelihood'></span>

<h3>Description</h3>

<p>Function to plot the log-likelihood of the model with a single statistic (number of groups)
depending on the parameter value for this statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_numgroups_likelihood(m.obs, num.nodes, pmin, pmax, pinc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_numgroups_likelihood_+3A_m.obs">m.obs</code></td>
<td>
<p>observed number of groups</p>
</td></tr>
<tr><td><code id="plot_numgroups_likelihood_+3A_num.nodes">num.nodes</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="plot_numgroups_likelihood_+3A_pmin">pmin</code></td>
<td>
<p>lowest parameter value</p>
</td></tr>
<tr><td><code id="plot_numgroups_likelihood_+3A_pmax">pmax</code></td>
<td>
<p>highest parameter value</p>
</td></tr>
<tr><td><code id="plot_numgroups_likelihood_+3A_pinc">pinc</code></td>
<td>
<p>increment between different parameter values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector
</p>

<hr>
<h2 id='plot_partition'>Visualization of partition</h2><span id='topic+plot_partition'></span>

<h3>Description</h3>

<p>This function plot the groups of a partition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_partition(
  partition,
  title = NULL,
  group.color = NULL,
  attribute.color = NULL,
  attribute.shape = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_partition_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="plot_partition_+3A_title">title</code></td>
<td>
<p>Character, the title of the plot (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_partition_+3A_group.color">group.color</code></td>
<td>
<p>A vector with the colors of the groups (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_partition_+3A_attribute.color">attribute.color</code></td>
<td>
<p>A vector, attribute to represent with colors (default=NULL)</p>
</td></tr>
<tr><td><code id="plot_partition_+3A_attribute.shape">attribute.shape</code></td>
<td>
<p>A vector, attribute to represent with shapes (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the partition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,1,1,2,2,2,2,3,3,3,4,4,4,4,4,4)
attr1 &lt;- c(1,0,0,1,0,0,1,0,1,0,1,1,1,1,1,2)
attr2 &lt;- c(1,1,1,1,0,0,3,0,1,0,1,1,1,1,1,2)
plot_partition(p,attribute.color = attr1, attribute.shape = attr2)
</code></pre>

<hr>
<h2 id='print.results.bayesian.erpm'>Print results of bayesian estimation (beta version)</h2><span id='topic+print.results.bayesian.erpm'></span>

<h3>Description</h3>

<p>Print results of bayesian estimation (beta version)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'results.bayesian.erpm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.results.bayesian.erpm_+3A_x">x</code></td>
<td>
<p>output of the bayesian estimate function</p>
</td></tr>
<tr><td><code id="print.results.bayesian.erpm_+3A_...">...</code></td>
<td>
<p>For internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>

<hr>
<h2 id='print.results.list.erpm'>Print estimation results</h2><span id='topic+print.results.list.erpm'></span>

<h3>Description</h3>

<p>Print estimation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'results.list.erpm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.results.list.erpm_+3A_x">x</code></td>
<td>
<p>output of the estimate function</p>
</td></tr>
<tr><td><code id="print.results.list.erpm_+3A_...">...</code></td>
<td>
<p>For internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>

<hr>
<h2 id='print.results.p3.erpm'>Print results of estimation of phase 3</h2><span id='topic+print.results.p3.erpm'></span>

<h3>Description</h3>

<p>Print results of estimation of phase 3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'results.p3.erpm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.results.p3.erpm_+3A_x">x</code></td>
<td>
<p>output of the estimate function</p>
</td></tr>
<tr><td><code id="print.results.p3.erpm_+3A_...">...</code></td>
<td>
<p>For internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>

<hr>
<h2 id='proportion_isolate'>Proportion of isolates</h2><span id='topic+proportion_isolate'></span>

<h3>Description</h3>

<p>This function computes the proportion of individuals not joining others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proportion_isolate(partition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proportion_isolate_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number corresponding to proportion of individuals alone.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,2,2,3,3,4,4,4,5)
proportion_isolate(p)
</code></pre>

<hr>
<h2 id='range_attribute'>Range of attribute in groups</h2><span id='topic+range_attribute'></span>

<h3>Description</h3>

<p>This function computes the sum or the average range of an attribute for groups in a partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_attribute(partition, attribute, stat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_attribute_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="range_attribute_+3A_attribute">attribute</code></td>
<td>
<p>A vector containing the values of the attribute</p>
</td></tr>
<tr><td><code id="range_attribute_+3A_stat">stat</code></td>
<td>
<p>The statistic to compute : 'avg_pergroup' for the average per group  and 'sum_pergroup' for the sum of the ranges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The statisic chosen in stat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,2,2,3,3,4,4,4,5)
at &lt;- c(3,5,23,2,1,0,3,9,2)
range_attribute(p,at,'avg_pergroup')
</code></pre>

<hr>
<h2 id='run_phase1_multiple'>Phase 1 wrapper for multiple observations</h2><span id='topic+run_phase1_multiple'></span>

<h3>Description</h3>

<p>Phase 1 wrapper for multiple observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_phase1_multiple(
  partitions,
  startingestimates,
  z.obs,
  presence.tables,
  nodes,
  effects,
  objects,
  burnin,
  thining,
  gainfactor,
  a.scaling,
  r.truncation.p1,
  length.p1,
  neighborhood,
  fixed.estimates,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  parallel = FALSE,
  cpus = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_phase1_multiple_+3A_partitions">partitions</code></td>
<td>
<p>observed partitions</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_startingestimates">startingestimates</code></td>
<td>
<p>vector containing initial parameter values</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_z.obs">z.obs</code></td>
<td>
<p>observed statistics</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_presence.tables">presence.tables</code></td>
<td>
<p>data frame to indicate which times nodes are present in the partition</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_nodes">nodes</code></td>
<td>
<p>node set (data frame)</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_effects">effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_objects">objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_burnin">burnin</code></td>
<td>
<p>integer for the number of burn-in steps before sampling</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_thining">thining</code></td>
<td>
<p>integer for the number of thining steps between sampling</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_gainfactor">gainfactor</code></td>
<td>
<p>gain factor (useless now)</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_a.scaling">a.scaling</code></td>
<td>
<p>scaling factor</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_r.truncation.p1">r.truncation.p1</code></td>
<td>
<p>truncation factor (for stability)</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_length.p1">length.p1</code></td>
<td>
<p>number of samples for phase 1</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_neighborhood">neighborhood</code></td>
<td>
<p>vector for the probability of choosing a particular transition in the chain</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_fixed.estimates">fixed.estimates</code></td>
<td>
<p>if some parameters are fixed, list with as many elements as effects, these elements equal a fixed value if needed, or NULL if they should be estimated</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>vector of group sizes allowed in the Markov chain but not necessarily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_parallel">parallel</code></td>
<td>
<p>boolean to indicate whether the code should be run in parallel</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_cpus">cpus</code></td>
<td>
<p>number of cpus if parallel = TRUE</p>
</td></tr>
<tr><td><code id="run_phase1_multiple_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='run_phase1_single'>Phase 1 wrapper for single observation</h2><span id='topic+run_phase1_single'></span>

<h3>Description</h3>

<p>Phase 1 wrapper for single observation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_phase1_single(
  partition,
  startingestimates,
  z.obs,
  nodes,
  effects,
  objects,
  burnin,
  thining,
  gainfactor,
  a.scaling,
  r.truncation.p1,
  length.p1,
  neighborhood,
  fixed.estimates,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  parallel = TRUE,
  cpus = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_phase1_single_+3A_partition">partition</code></td>
<td>
<p>observed partition</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_startingestimates">startingestimates</code></td>
<td>
<p>vector containing initial parameter values</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_z.obs">z.obs</code></td>
<td>
<p>observed statistics</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_nodes">nodes</code></td>
<td>
<p>node set (data frame)</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_effects">effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_objects">objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_burnin">burnin</code></td>
<td>
<p>integer for the number of burn-in steps before sampling</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_thining">thining</code></td>
<td>
<p>integer for the number of thining steps between sampling</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_gainfactor">gainfactor</code></td>
<td>
<p>gain factor (useless now)</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_a.scaling">a.scaling</code></td>
<td>
<p>scaling factor</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_r.truncation.p1">r.truncation.p1</code></td>
<td>
<p>truncation factor (for stability)</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_length.p1">length.p1</code></td>
<td>
<p>number of samples for phase 1</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_neighborhood">neighborhood</code></td>
<td>
<p>vector for the probability of choosing a particular transition in the chain</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_fixed.estimates">fixed.estimates</code></td>
<td>
<p>if some parameters are fixed, list with as many elements as effects, these elements equal a fixed value if needed, or NULL if they should be estimated</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>vector of group sizes allowed in the Markov chain but not necessarily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_parallel">parallel</code></td>
<td>
<p>boolean to indicate whether the code should be run in parallel</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_cpus">cpus</code></td>
<td>
<p>number of cpus if parallel = TRUE</p>
</td></tr>
<tr><td><code id="run_phase1_single_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='run_phase2_multiple'>Phase 2 wrapper for multiple observation</h2><span id='topic+run_phase2_multiple'></span>

<h3>Description</h3>

<p>Phase 2 wrapper for multiple observation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_phase2_multiple(
  partitions,
  estimates.phase1,
  inv.zcov,
  inv.scaling,
  z.obs,
  presence.tables,
  nodes,
  effects,
  objects,
  burnin,
  thining,
  num.steps,
  gainfactors,
  r.truncation.p2,
  min.iter,
  max.iter,
  multiplication.iter,
  neighborhood,
  fixed.estimates,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  double.averaging,
  parallel = FALSE,
  cpus = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_phase2_multiple_+3A_partitions">partitions</code></td>
<td>
<p>observed partitions</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_estimates.phase1">estimates.phase1</code></td>
<td>
<p>vector containing parameter values after phase 1</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_inv.zcov">inv.zcov</code></td>
<td>
<p>inverted covariance matrix</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_inv.scaling">inv.scaling</code></td>
<td>
<p>scaling matrix</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_z.obs">z.obs</code></td>
<td>
<p>observed statistics</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_presence.tables">presence.tables</code></td>
<td>
<p>data frame to indicate which times nodes are present in the partition</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_nodes">nodes</code></td>
<td>
<p>node set (data frame)</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_effects">effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_objects">objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_burnin">burnin</code></td>
<td>
<p>integer for the number of burn-in steps before sampling</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_thining">thining</code></td>
<td>
<p>integer for the number of thining steps between sampling</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_num.steps">num.steps</code></td>
<td>
<p>number of sub-phases in phase 2</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_gainfactors">gainfactors</code></td>
<td>
<p>vector of gain factors</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_r.truncation.p2">r.truncation.p2</code></td>
<td>
<p>truncation factor</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_min.iter">min.iter</code></td>
<td>
<p>minimum numbers of steps in each subphase</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum numbers of steps in each subphase</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_multiplication.iter">multiplication.iter</code></td>
<td>
<p>used to calculate min.iter and max.iter if not specified</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_neighborhood">neighborhood</code></td>
<td>
<p>vector for the probability of choosing a particular transition in the chain</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_fixed.estimates">fixed.estimates</code></td>
<td>
<p>if some parameters are fixed, list with as many elements as effects, these elements equal a fixed value if needed, or NULL if they should be estimated</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_double.averaging">double.averaging</code></td>
<td>
<p>boolean to indicate whether we follow the double-averaging procedure (often leads to better convergence)</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_parallel">parallel</code></td>
<td>
<p>boolean to indicate whether the code should be run in parallel</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_cpus">cpus</code></td>
<td>
<p>number of cpus if parallel = TRUE</p>
</td></tr>
<tr><td><code id="run_phase2_multiple_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='run_phase2_single'>Phase 2 wrapper for single observation</h2><span id='topic+run_phase2_single'></span>

<h3>Description</h3>

<p>Phase 2 wrapper for single observation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_phase2_single(
  partition,
  estimates.phase1,
  inv.zcov,
  inv.scaling,
  z.obs,
  nodes,
  effects,
  objects,
  burnin,
  thining,
  num.steps,
  gainfactors,
  r.truncation.p2,
  min.iter,
  max.iter,
  multiplication.iter,
  neighborhood,
  fixed.estimates,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  double.averaging,
  parallel = FALSE,
  cpus = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_phase2_single_+3A_partition">partition</code></td>
<td>
<p>observed partition</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_estimates.phase1">estimates.phase1</code></td>
<td>
<p>vector containing parameter values after phase 1</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_inv.zcov">inv.zcov</code></td>
<td>
<p>inverted covariance matrix</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_inv.scaling">inv.scaling</code></td>
<td>
<p>scaling matrix</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_z.obs">z.obs</code></td>
<td>
<p>observed statistics</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_nodes">nodes</code></td>
<td>
<p>node set (data frame)</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_effects">effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_objects">objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_burnin">burnin</code></td>
<td>
<p>integer for the number of burn-in steps before sampling</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_thining">thining</code></td>
<td>
<p>integer for the number of thining steps between sampling</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_num.steps">num.steps</code></td>
<td>
<p>number of sub-phases in phase 2</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_gainfactors">gainfactors</code></td>
<td>
<p>vector of gain factors</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_r.truncation.p2">r.truncation.p2</code></td>
<td>
<p>truncation factor</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_min.iter">min.iter</code></td>
<td>
<p>minimum numbers of steps in each subphase</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum numbers of steps in each subphase</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_multiplication.iter">multiplication.iter</code></td>
<td>
<p>used to calculate min.iter and max.iter if not specified</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_neighborhood">neighborhood</code></td>
<td>
<p>vector for the probability of choosing a particular transition in the chain</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_fixed.estimates">fixed.estimates</code></td>
<td>
<p>if some parameters are fixed, list with as many elements as effects, these elements equal a fixed value if needed, or NULL if they should be estimated</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_double.averaging">double.averaging</code></td>
<td>
<p>boolean to indicate whether we follow the double-averaging procedure (often leads to better convergence)</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_parallel">parallel</code></td>
<td>
<p>boolean to indicate whether the code should be run in parallel</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_cpus">cpus</code></td>
<td>
<p>number of cpus if parallel = TRUE</p>
</td></tr>
<tr><td><code id="run_phase2_single_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='run_phase3_multiple'>Phase 3 wrapper for multiple observation</h2><span id='topic+run_phase3_multiple'></span>

<h3>Description</h3>

<p>Phase 3 wrapper for multiple observation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_phase3_multiple(
  partitions,
  estimates.phase2,
  z.obs,
  presence.tables,
  nodes,
  effects,
  objects,
  burnin,
  thining,
  a.scaling,
  length.p3,
  neighborhood,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  fixed.estimates,
  parallel = FALSE,
  cpus = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_phase3_multiple_+3A_partitions">partitions</code></td>
<td>
<p>observed partitions</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_estimates.phase2">estimates.phase2</code></td>
<td>
<p>vector containing parameter values after phase 2</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_z.obs">z.obs</code></td>
<td>
<p>observed statistics</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_presence.tables">presence.tables</code></td>
<td>
<p>data frame to indicate which times nodes are present in the partition</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_nodes">nodes</code></td>
<td>
<p>node set (data frame)</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_effects">effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_objects">objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_burnin">burnin</code></td>
<td>
<p>integer for the number of burn-in steps before sampling</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_thining">thining</code></td>
<td>
<p>integer for the number of thining steps between sampling</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_a.scaling">a.scaling</code></td>
<td>
<p>multiplicative factor for out-of-diagonal elements of the covariance matrix</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_length.p3">length.p3</code></td>
<td>
<p>number of samples in phase 3</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_neighborhood">neighborhood</code></td>
<td>
<p>vector for the probability of choosing a particular transition in the chain</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_fixed.estimates">fixed.estimates</code></td>
<td>
<p>if some parameters are fixed, list with as many elements as effects, these elements equal a fixed value if needed, or NULL if they should be estimated</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_parallel">parallel</code></td>
<td>
<p>boolean to indicate whether the code should be run in parallel</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_cpus">cpus</code></td>
<td>
<p>number of cpus if parallel = TRUE</p>
</td></tr>
<tr><td><code id="run_phase3_multiple_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='run_phase3_single'>Phase 3 wrapper for single observation</h2><span id='topic+run_phase3_single'></span>

<h3>Description</h3>

<p>Phase 3 wrapper for single observation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_phase3_single(
  partition,
  estimates.phase2,
  z.obs,
  nodes,
  effects,
  objects,
  burnin,
  thining,
  a.scaling,
  length.p3,
  neighborhood,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  fixed.estimates,
  parallel = FALSE,
  cpus = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_phase3_single_+3A_partition">partition</code></td>
<td>
<p>observed partition</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_estimates.phase2">estimates.phase2</code></td>
<td>
<p>vector containing parameter values after phase 2</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_z.obs">z.obs</code></td>
<td>
<p>observed statistics</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_nodes">nodes</code></td>
<td>
<p>node set (data frame)</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_effects">effects</code></td>
<td>
<p>effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_objects">objects</code></td>
<td>
<p>objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_burnin">burnin</code></td>
<td>
<p>integer for the number of burn-in steps before sampling</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_thining">thining</code></td>
<td>
<p>integer for the number of thining steps between sampling</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_a.scaling">a.scaling</code></td>
<td>
<p>multiplicative factor for out-of-diagonal elements of the covariance matrix</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_length.p3">length.p3</code></td>
<td>
<p>number of sampled partitions in phase 3</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_neighborhood">neighborhood</code></td>
<td>
<p>vector for the probability of choosing a particular transition in the chain</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_fixed.estimates">fixed.estimates</code></td>
<td>
<p>if some parameters are fixed, list with as many elements as effects, these elements equal a fixed value if needed, or NULL if they should be estimated</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_parallel">parallel</code></td>
<td>
<p>boolean to indicate whether the code should be run in parallel</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_cpus">cpus</code></td>
<td>
<p>number of cpus if parallel = TRUE</p>
</td></tr>
<tr><td><code id="run_phase3_single_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='same_pairs'>Same pairs of individuals in a partition</h2><span id='topic+same_pairs'></span>

<h3>Description</h3>

<p>This function computes the total number, the average number having the same value of a categorical variable
and the number of individuals a partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>same_pairs(partition, attribute, stat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="same_pairs_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="same_pairs_+3A_attribute">attribute</code></td>
<td>
<p>A vector containing the values of the attribute</p>
</td></tr>
<tr><td><code id="same_pairs_+3A_stat">stat</code></td>
<td>
<p>The statistic to compute : 'avg_pergroup' for the average, 'sum_pergroup' for the sum,  'sum_perind' and 'avg_perind'  for the number of ties per individual
each individual has in its group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The statistic chosen in stat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,2,2,3,3,4,4,4,5)
at &lt;- c(0,1,1,1,1,0,0,0,0)
same_pairs(p,at,'avg_pergroup')
</code></pre>

<hr>
<h2 id='similar_pairs'>Similar pairs of individuals in a partition</h2><span id='topic+similar_pairs'></span>

<h3>Description</h3>

<p>This function computes the total number, the average number having the close values of a numerical variable
and the number of individuals a partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similar_pairs(partition, attribute, stat, threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similar_pairs_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="similar_pairs_+3A_attribute">attribute</code></td>
<td>
<p>A vector containing the values of the attribute</p>
</td></tr>
<tr><td><code id="similar_pairs_+3A_stat">stat</code></td>
<td>
<p>The statistic to compute : 'avg_pergroup' for the average, 'sum_pergroup' for the sum, 'sum_perind' and 'avg_perind' for individuals</p>
</td></tr>
<tr><td><code id="similar_pairs_+3A_threshold">threshold</code></td>
<td>
<p>Threshold to determine if 2 individuals attributes values are close</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The statisic chosen in stat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1,2,2,3,3,4,4,4,5)
at &lt;- c(3,5,23,2,1,0,3,9,2)
similar_pairs(p,at,1,'avg_pergroup')
</code></pre>

<hr>
<h2 id='simulate_burnin_single'>Simulate burn in single</h2><span id='topic+simulate_burnin_single'></span>

<h3>Description</h3>

<p>Function that can be used to find a good length for the burn-in of the Markov chain for a given model and a given set of transitions in the chain (the neighborhood).
It draws a chain and calculates the mean statistics for different burn-ins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_burnin_single(
  partition,
  theta,
  nodes,
  effects,
  objects,
  num.steps,
  neighborhood,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_burnin_single_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="simulate_burnin_single_+3A_theta">theta</code></td>
<td>
<p>Initial model parameters</p>
</td></tr>
<tr><td><code id="simulate_burnin_single_+3A_nodes">nodes</code></td>
<td>
<p>Node set (data frame)</p>
</td></tr>
<tr><td><code id="simulate_burnin_single_+3A_effects">effects</code></td>
<td>
<p>Effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="simulate_burnin_single_+3A_objects">objects</code></td>
<td>
<p>Objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="simulate_burnin_single_+3A_num.steps">num.steps</code></td>
<td>
<p>Number of samples wanted</p>
</td></tr>
<tr><td><code id="simulate_burnin_single_+3A_neighborhood">neighborhood</code></td>
<td>
<p>Way of choosing partitions: probability vector (proba actors swap, proba merge/division, proba single actor move)</p>
</td></tr>
<tr><td><code id="simulate_burnin_single_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="simulate_burnin_single_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="simulate_burnin_single_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>Vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="simulate_burnin_single_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>Vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with list the draws, the moving.means and the moving means smoothed
</p>

<hr>
<h2 id='simulate_burninthining_multiple'>Simulate burnin thining multiple</h2><span id='topic+simulate_burninthining_multiple'></span>

<h3>Description</h3>

<p>Function that simulates the Markov chain for a given model and a set of transitions (the neighborhood), for multiple partitions.
It calculates the autocorrelation of statistics for different thinings and the average statistics for different burn-ins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_burninthining_multiple(
  partitions,
  presence.tables,
  theta,
  nodes,
  effects,
  objects,
  num.steps,
  neighborhood,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  max.thining,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_burninthining_multiple_+3A_partitions">partitions</code></td>
<td>
<p>Observed partitions</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_presence.tables">presence.tables</code></td>
<td>
<p>to indicate which nodes were present when</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_theta">theta</code></td>
<td>
<p>Initial model parameters</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_nodes">nodes</code></td>
<td>
<p>Node set (data frame)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_effects">effects</code></td>
<td>
<p>Effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_objects">objects</code></td>
<td>
<p>Objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_num.steps">num.steps</code></td>
<td>
<p>Number of samples wanted</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_neighborhood">neighborhood</code></td>
<td>
<p>Way of choosing partitions: probability vector (proba actors swap, proba merge/division, proba single actor move)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>Vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>Vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_max.thining">max.thining</code></td>
<td>
<p>maximal number of simulated steps in the thining</p>
</td></tr>
<tr><td><code id="simulate_burninthining_multiple_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>

<hr>
<h2 id='simulate_burninthining_single'>Simulate burnin thining single</h2><span id='topic+simulate_burninthining_single'></span>

<h3>Description</h3>

<p>Function that simulates the Markov chain for a given model and a set of transitions (the neighborhood), for a single partition.
It calculates the autocorrelation of statistics for different thinings and the average statistics for different burn-ins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_burninthining_single(
  partition,
  theta,
  nodes,
  effects,
  objects,
  num.steps,
  neighborhood,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  max.thining,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_burninthining_single_+3A_partition">partition</code></td>
<td>
<p>Observed partition (vector)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_single_+3A_theta">theta</code></td>
<td>
<p>Initial model parameters</p>
</td></tr>
<tr><td><code id="simulate_burninthining_single_+3A_nodes">nodes</code></td>
<td>
<p>Node set (data frame)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_single_+3A_effects">effects</code></td>
<td>
<p>Effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_single_+3A_objects">objects</code></td>
<td>
<p>Objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_single_+3A_num.steps">num.steps</code></td>
<td>
<p>Number of samples wanted</p>
</td></tr>
<tr><td><code id="simulate_burninthining_single_+3A_neighborhood">neighborhood</code></td>
<td>
<p>Way of choosing partitions: probability vector (proba actors swap, proba merge/division, proba single actor move)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_single_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_single_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="simulate_burninthining_single_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>Vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_single_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>Vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="simulate_burninthining_single_+3A_max.thining">max.thining</code></td>
<td>
<p>maximal number of simulated steps in the thining</p>
</td></tr>
<tr><td><code id="simulate_burninthining_single_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>

<hr>
<h2 id='simulate_thining_single'>Simulate thining single</h2><span id='topic+simulate_thining_single'></span>

<h3>Description</h3>

<p>Function that can be used to find a good length for the thining of the Markov chain for a given model and a set of transitions in the chain (the neighborhood).
It draws a chain and calculates the autocorrelation of statistics for different thinings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_thining_single(
  partition,
  theta,
  nodes,
  effects,
  objects,
  num.steps,
  neighborhood,
  numgroups.allowed,
  numgroups.simulated,
  sizes.allowed,
  sizes.simulated,
  burnin,
  max.thining,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_thining_single_+3A_partition">partition</code></td>
<td>
<p>A partition (vector)</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_theta">theta</code></td>
<td>
<p>Initial model parameters</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_nodes">nodes</code></td>
<td>
<p>Node set (data frame)</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_effects">effects</code></td>
<td>
<p>Effects/sufficient statistics (list with a vector &quot;names&quot;, and a vector &quot;objects&quot;)</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_objects">objects</code></td>
<td>
<p>Objects used for statistics calculation (list with a vector &quot;name&quot;, and a vector &quot;object&quot;)</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_num.steps">num.steps</code></td>
<td>
<p>Number of samples wanted</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_neighborhood">neighborhood</code></td>
<td>
<p>Way of choosing partitions: probability vector (proba actors swap, proba merge/division, proba single actor move)</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_numgroups.allowed">numgroups.allowed</code></td>
<td>
<p>vector containing the number of groups allowed in the partition (now, it only works with vectors like num_min:num_max)</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_numgroups.simulated">numgroups.simulated</code></td>
<td>
<p>vector containing the number of groups simulated</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_sizes.allowed">sizes.allowed</code></td>
<td>
<p>Vector of group sizes allowed in sampling (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_sizes.simulated">sizes.simulated</code></td>
<td>
<p>Vector of group sizes allowed in the Markov chain but not necessraily sampled (now, it only works for vectors like size_min:size_max)</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_burnin">burnin</code></td>
<td>
<p>number of simulated steps for the burn-in</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_max.thining">max.thining</code></td>
<td>
<p>maximal number of simulated steps in the thining</p>
</td></tr>
<tr><td><code id="simulate_thining_single_+3A_verbose">verbose</code></td>
<td>
<p>logical: should intermediate results during the estimation be printed or not? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>

<hr>
<h2 id='Stirling2_constraints'>Function to calculate the number of partitions with k groups
of sizes between smin and smax</h2><span id='topic+Stirling2_constraints'></span>

<h3>Description</h3>

<p>Function to calculate the number of partitions with k groups
of sizes between smin and smax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Stirling2_constraints(n, k, smin, smax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Stirling2_constraints_+3A_n">n</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="Stirling2_constraints_+3A_k">k</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code id="Stirling2_constraints_+3A_smin">smin</code></td>
<td>
<p>minimum group size possible in the partition</p>
</td></tr>
<tr><td><code id="Stirling2_constraints_+3A_smax">smax</code></td>
<td>
<p>maximum group size possible in the partition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 6
k &lt;- 2
size_min &lt;- 2
size_max &lt;- 4
Stirling2_constraints(n,k,size_min,size_max)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
