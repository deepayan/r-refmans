<!DOCTYPE html><html lang="en"><head><title>Help for package transformr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {transformr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#transformr-package'><p>transformr: Polygon and Path Transformations</p></a></li>
<li><a href='#simple_shapes'><p>Some different geometries to play with</p></a></li>
<li><a href='#st_normalize'><p>Normalise a geometry to fit inside a unit square</p></a></li>
<li><a href='#tween_path'><p>Transition between path data frames</p></a></li>
<li><a href='#tween_polygon'><p>Transition between polygon data.frames</p></a></li>
<li><a href='#tween_sf'><p>Transition between data.frames containing sfc columns</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Polygon and Path Transformations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>In order to smoothly animate the transformation of polygons and 
    paths, many aspects needs to be taken into account, such as differing number 
    of control points, changing center of rotation, etc. The 'transformr' 
    package provides an extensive framework for manipulating the shapes of 
    polygons and paths and can be seen as the spatial brother to the 'tweenr' 
    package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>tweenr, rlang, sf, lpSolve, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, magrittr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thomasp85/transformr">https://github.com/thomasp85/transformr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/transformr/issues">https://github.com/thomasp85/transformr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-26 13:46:42 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-26 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='transformr-package'>transformr: Polygon and Path Transformations</h2><span id='topic+transformr'></span><span id='topic+transformr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>In order to smoothly animate the transformation of polygons and paths, many aspects needs to be taken into account, such as differing number of control points, changing center of rotation, etc. The 'transformr' package provides an extensive framework for manipulating the shapes of polygons and paths and can be seen as the spatial brother to the 'tweenr' package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/thomasp85/transformr">https://github.com/thomasp85/transformr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/transformr/issues">https://github.com/thomasp85/transformr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='simple_shapes'>Some different geometries to play with</h2><span id='topic+simple_shapes'></span><span id='topic+poly_circle'></span><span id='topic+poly_circles'></span><span id='topic+poly_star'></span><span id='topic+poly_star_hole'></span><span id='topic+path_spiral'></span><span id='topic+path_waves'></span><span id='topic+point_random'></span><span id='topic+point_grid'></span>

<h3>Description</h3>

<p>These functions are provided to allow you to play with somee simple shapes as
you explore <code>transformr</code> and are also used in the examples for the different
tween functions. All geometries can be returned as either a standard
<code>data.frame</code> with <code>x</code>, <code>y</code>, and <code>id</code> column, or as an sf geometry of the
appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_circle(st = FALSE, detail = 360)

poly_circles(st = FALSE, n = 3, r = 0.25, detail = 360)

poly_star(st = FALSE, n = 5, r1 = 0.5)

poly_star_hole(st = FALSE, n = 5, r1 = 0.5)

path_spiral(st = FALSE, windings = 5)

path_waves(st = FALSE, w1 = 7, w2 = 11)

point_random(st = FALSE, n = 10)

point_grid(st = FALSE, dim = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simple_shapes_+3A_st">st</code></td>
<td>
<p>Logical. Should the geometry be returned as an <code>sf</code> feature?</p>
</td></tr>
<tr><td><code id="simple_shapes_+3A_detail">detail</code></td>
<td>
<p>The number of points defining the shape</p>
</td></tr>
<tr><td><code id="simple_shapes_+3A_n">n</code></td>
<td>
<p>For <code>poly_circles</code> the number of circles, for <code>poly_star</code> and
<code>poly_star_hole</code> the number of 'arms', and for <code>point_random</code> the number of
points</p>
</td></tr>
<tr><td><code id="simple_shapes_+3A_r">r</code>, <code id="simple_shapes_+3A_r1">r1</code></td>
<td>
<p>The radius of the geometry. <code>r</code> gives the radius of the circles
in <code>poly_circles</code> and <code>r1</code> gives the inner radius for
<code>poly_star</code>/<code>poly_star_hole</code>, thus determining how pointy it is</p>
</td></tr>
<tr><td><code id="simple_shapes_+3A_windings">windings</code></td>
<td>
<p>The number of revolutions in the spiral</p>
</td></tr>
<tr><td><code id="simple_shapes_+3A_w1">w1</code>, <code id="simple_shapes_+3A_w2">w2</code></td>
<td>
<p>The frequency for the two sine waves</p>
</td></tr>
<tr><td><code id="simple_shapes_+3A_dim">dim</code></td>
<td>
<p>the number of rows and columns in the grid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a data.frame or an sf feature depending on the value of <code>st</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a 7-pointed star
poly_star(n = 7)

</code></pre>

<hr>
<h2 id='st_normalize'>Normalise a geometry to fit inside a unit square</h2><span id='topic+st_normalize'></span>

<h3>Description</h3>

<p>This is a small helper function that will take an sf geometry and fit it
inside the unit square (a square centered on 0 and ranging from -1 to 1 in
both dimensions). The function will retain the aspect ratio of the geometry
and simply scale it down until it fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_normalize(st)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="st_normalize_+3A_st">st</code></td>
<td>
<p>An sf geometry such as <code>sf</code>, <code>sfc</code>, or <code>sfg</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>st</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
nc &lt;- st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)
st_bbox(nc)

nc_norm &lt;- st_normalize(nc)
st_bbox(nc_norm)

</code></pre>

<hr>
<h2 id='tween_path'>Transition between path data frames</h2><span id='topic+tween_path'></span>

<h3>Description</h3>

<p>This function is equivalent to <code><a href="tweenr.html#topic+tween_state">tweenr::tween_state()</a></code> but expects the data
to have an <code>x</code> and <code>y</code> column and encode paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_path(
  .data,
  to,
  ease,
  nframes,
  id = NULL,
  enter = NULL,
  exit = NULL,
  match = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tween_path_+3A_.data">.data</code></td>
<td>
<p>A data.frame to start from. If <code>.data</code> is the result of a prior
tween, only the last frame will be used for the tween. The new tween will
then be added to the prior tween</p>
</td></tr>
<tr><td><code id="tween_path_+3A_to">to</code></td>
<td>
<p>A data.frame to end at. It must contain the same columns as .data
(exluding <code>.frame</code>)</p>
</td></tr>
<tr><td><code id="tween_path_+3A_ease">ease</code></td>
<td>
<p>The easing function to use. Either a single string or one for
each column in the data set.</p>
</td></tr>
<tr><td><code id="tween_path_+3A_nframes">nframes</code></td>
<td>
<p>The number of frames to calculate for the tween</p>
</td></tr>
<tr><td><code id="tween_path_+3A_id">id</code></td>
<td>
<p>The column to match observations on. If <code>NULL</code> observations will be
matched by position. See the <em>Match, Enter, and Exit</em> section for more
information.</p>
</td></tr>
<tr><td><code id="tween_path_+3A_enter">enter</code>, <code id="tween_path_+3A_exit">exit</code></td>
<td>
<p>functions that calculate a start state for new observations
that appear in <code>to</code> or an end state for observations that are not present in
<code>to</code>. If <code>NULL</code> the new/old observations will not be part of the tween. The
function gets a data.frame with either the start state of the exiting
observations, or the end state of the entering observations and must return
a modified version of that data.frame. See the <em>Match, Enter, and Exit</em>
section for more information.</p>
</td></tr>
<tr><td><code id="tween_path_+3A_match">match</code></td>
<td>
<p>Should polygons be matched by id? If <code>FALSE</code> then polygons will
be matched by shortest distance and if any state has more polygons than the
other, the other states polygons will be chopped up so the numbers match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing intermediary states
</p>


<h3>Aligning paths</h3>

<p>There is less work required to align paths than there is to align polygons,
simply because no rotation is possible/required, and the notion of clockwise
winding order is not meaningful in the scope of paths. Still, paths need to
be matched and the number of points in each pair of matched paths must be
equal. Paths are matched based on relative length rather than on position and
seek to minimize the change in length during transition. This is chosen from
the point of view that huge elongation or contraction are much more
distracting than longer travel distances.
</p>


<h3>Cutting paths</h3>

<p>If the number of paths to transition between is not even, some of the paths
need to be cut in order to succesfully match the paths. The cuts are
distributed based on the same algorithm that distributes cuts in polygons and
seek to cut the lines into as even-length pieces as possible.
</p>


<h3>Multipaths</h3>

<p>It is possible to encode multiple paths with the same id be separating them
with a <code>NA</code> row, much in the same way as holes are encoded in polygons. If
paths are not matched based on id (<code>match = FALSE</code>) then multipaths will
simply be split into separate paths. On the other hand, if paths are matched
by id all paths within a multipath will transition into the (multi)path that
has the same id in the other state.
</p>

<hr>
<h2 id='tween_polygon'>Transition between polygon data.frames</h2><span id='topic+tween_polygon'></span>

<h3>Description</h3>

<p>This function is equivalent to <code><a href="tweenr.html#topic+tween_state">tweenr::tween_state()</a></code> except that data is
interpeted as encoding polygons. Data is expected to have an <code>x</code> and <code>y</code>
column encoding the location of corners in the polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_polygon(
  .data,
  to,
  ease,
  nframes,
  id = NULL,
  enter = NULL,
  exit = NULL,
  match = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tween_polygon_+3A_.data">.data</code></td>
<td>
<p>A data.frame to start from. If <code>.data</code> is the result of a prior
tween, only the last frame will be used for the tween. The new tween will
then be added to the prior tween</p>
</td></tr>
<tr><td><code id="tween_polygon_+3A_to">to</code></td>
<td>
<p>A data.frame to end at. It must contain the same columns as .data
(exluding <code>.frame</code>)</p>
</td></tr>
<tr><td><code id="tween_polygon_+3A_ease">ease</code></td>
<td>
<p>The easing function to use. Either a single string or one for
each column in the data set.</p>
</td></tr>
<tr><td><code id="tween_polygon_+3A_nframes">nframes</code></td>
<td>
<p>The number of frames to calculate for the tween</p>
</td></tr>
<tr><td><code id="tween_polygon_+3A_id">id</code></td>
<td>
<p>The column to match observations on. If <code>NULL</code> observations will be
matched by position. See the <em>Match, Enter, and Exit</em> section for more
information.</p>
</td></tr>
<tr><td><code id="tween_polygon_+3A_enter">enter</code>, <code id="tween_polygon_+3A_exit">exit</code></td>
<td>
<p>functions that calculate a start state for new observations
that appear in <code>to</code> or an end state for observations that are not present in
<code>to</code>. If <code>NULL</code> the new/old observations will not be part of the tween. The
function gets a data.frame with either the start state of the exiting
observations, or the end state of the entering observations and must return
a modified version of that data.frame. See the <em>Match, Enter, and Exit</em>
section for more information.</p>
</td></tr>
<tr><td><code id="tween_polygon_+3A_match">match</code></td>
<td>
<p>Should polygons be matched by id? If <code>FALSE</code> then polygons will
be matched by shortest distance and if any state has more polygons than the
other, the other states polygons will be chopped up so the numbers match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing intermediary states
</p>


<h3>Aligning polygons</h3>

<p><code>transformr</code> performs a lot of work to try to ensure the transition between
different shapes are as smooth and direct as possible. The first operation is
to ensure that the two end states of the polygon are both drawn clockwise, so
that the transition will not contain an inversion. Second, we need to make
sure that each end state is drawn with the same number of points. If not, the
less detailed polygon will get points inserted at the longest edges so that
the number is even between the two states. Third, we rotate the last state so
as to minimize the cumulative distance between all point pairs, thus ensuring
that the transition will involve a minimum of rotation.
</p>


<h3>Cutting polygons</h3>

<p>If the transition involves changing the number of polygons, there are two
strategies: Making polygons appear/disappear to even out the number, or
cutting up the polygons in the state with the fewest in order to create the
same number of polygons for the transition. In the latter case, a choice have
to be made with regards to which polygons to cut, into how many, and where to
cut it. <code>transformr</code> will distribute the number of cuts among candidate
polygons based on their relative area, ensuring that it is not necessarily
the largest polygon that gets all the cuts, but that divisions are
distributed as fairly as possible. For deciding on where to cut the polygons
they are triangulated and the triangles are then reassembled into the number
of pieces needed by always adding to the smallest piece.
</p>


<h3>Polygon with holes</h3>

<p><code>transformr</code> support polygons with any number of holes. Holes are encoded by
adding an <code>NA</code> row to the main enclosing polygon and appending the hole after
that. Multiple holes are likewise added by simply separating them with <code>NA</code>
rows. A hole might get cut up and disappear during transition if the polygon
needs to be divided. When transitioning between polygons with holes the holes
are matched by position to minimize the travel distance. If there is a
mismatch between the number of holes in each end state then new zero-area
holes are inserted in the centroid of the polygon with the fewest to even out
the number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
star &lt;- poly_star_hole()
circle &lt;- poly_circle()
circles &lt;- poly_circles()

tween_polygon(circle, star, 'cubic-in-out', 20) %&gt;%
  tween_polygon(circles, 'cubic-in-out', 20)

</code></pre>

<hr>
<h2 id='tween_sf'>Transition between data.frames containing sfc columns</h2><span id='topic+tween_sf'></span>

<h3>Description</h3>

<p>This function is equivalent to <code><a href="tweenr.html#topic+tween_state">tweenr::tween_state()</a></code> except that it
understands <code><a href="sf.html#topic+sfc">sf::sfc</a></code> columns, as defined by the <code>sf</code> package. An <code>sfc</code>
column is a column containing simple features and can this hold both points,
lines polygons and more. <code>tween_sf</code> currently has support for (multi)point,
(multi)linestring, and (multi)polygon types and requires that the transition
is between compatible types (points-to-points, linestring-to-linestring,
polygon-to-polygon). For (multi)linestring and (multi)polygon, the behavior
is similar to <code><a href="#topic+tween_path">tween_path()</a></code> and <code><a href="#topic+tween_polygon">tween_polygon()</a></code> respectively, with each
feature beeing run through the respective function with <code>match = FALSE</code>. For
(multi)points it behaves more or less like <code><a href="tweenr.html#topic+tween_state">tweenr::tween_state()</a></code> except
additional points are added as needed to make the to stages contain the same
number of points. Points are added on top of existing points so it appears as
if the points are divided into more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_sf(.data, to, ease, nframes, id = NULL, enter = NULL, exit = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tween_sf_+3A_.data">.data</code></td>
<td>
<p>A data.frame to start from. If <code>.data</code> is the result of a prior
tween, only the last frame will be used for the tween. The new tween will
then be added to the prior tween</p>
</td></tr>
<tr><td><code id="tween_sf_+3A_to">to</code></td>
<td>
<p>A data.frame to end at. It must contain the same columns as .data
(exluding <code>.frame</code>)</p>
</td></tr>
<tr><td><code id="tween_sf_+3A_ease">ease</code></td>
<td>
<p>The easing function to use. Either a single string or one for
each column in the data set.</p>
</td></tr>
<tr><td><code id="tween_sf_+3A_nframes">nframes</code></td>
<td>
<p>The number of frames to calculate for the tween</p>
</td></tr>
<tr><td><code id="tween_sf_+3A_id">id</code></td>
<td>
<p>The column to match observations on. If <code>NULL</code> observations will be
matched by position. See the <em>Match, Enter, and Exit</em> section for more
information.</p>
</td></tr>
<tr><td><code id="tween_sf_+3A_enter">enter</code>, <code id="tween_sf_+3A_exit">exit</code></td>
<td>
<p>functions that calculate a start state for new observations
that appear in <code>to</code> or an end state for observations that are not present in
<code>to</code>. If <code>NULL</code> the new/old observations will not be part of the tween. The
function gets a data.frame with either the start state of the exiting
observations, or the end state of the entering observations and must return
a modified version of that data.frame. See the <em>Match, Enter, and Exit</em>
section for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing intermediary states
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
star_hole &lt;- poly_star_hole(st = TRUE)
circles &lt;- poly_circles(st = TRUE)
spiral &lt;- path_spiral(st = TRUE)
waves &lt;- path_waves(st = TRUE)
random &lt;- point_random(st = TRUE)
grid &lt;- point_grid(st = TRUE)
df1 &lt;- data.frame(geo = sf::st_sfc(star_hole, spiral, random))
df2 &lt;- data.frame(geo = sf::st_sfc(circles, waves, grid))

tween_sf(df1, df2, 'linear', 30)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
