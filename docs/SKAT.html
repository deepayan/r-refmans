<!DOCTYPE html><html><head><title>Help for package SKAT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SKAT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Close_SSD'><p>Close SNP set data file (SSD)</p></a></li>
<li><a href='#Generate_SSD_SetID'><p>Generate SNP set data file (SSD)</p></a></li>
<li><a href='#Get_EffectiveNumberTest'><p>Estimate the effective number of tests for Bonferroni correction</p></a></li>
<li><a href='#Get_Genotypes_SSD'><p>Get Genotype data from SSD file</p></a></li>
<li><a href='#Get_Logistic_Weights'><p>Get the logistic weight</p></a></li>
<li><a href='#Get_RequiredSampleSize'><p>Get the required sample size to achieve the given power</p></a></li>
<li><a href='#Get_Resampling_Pvalue'><p>Compute a resampling p-value</p></a></li>
<li><a href='#Open_SSD'><p>Open SNP set data file (SSD)</p></a></li>
<li><a href='#Power_Continuous'><p>Power calculation, continuous traits</p></a></li>
<li><a href='#Power_Logistic'><p>Power calculation, Dichotomous traits</p></a></li>
<li><a href='#QQPlot_Adj'><p>Adjusted QQ plot</p></a></li>
<li><a href='#Read_Plink_FAM'><p>Read Plink FAM and covariates files</p></a></li>
<li><a href='#Read_SNP_WeightFile'><p>Read a file with custom weights</p></a></li>
<li><a href='#Resampling_FWER'><p>Obtain significant SNP sets after controlling family wise error rate (FWER)</p></a></li>
<li><a href='#SKAT'><p>SNP-set (Sequence) Kernel Association Test</p></a></li>
<li><a href='#SKAT_ChrX'><p>SNP-set (Sequence) Kernel Association Test for  X and Y chromosome variables</p></a></li>
<li><a href='#SKAT_CommonRare'><p>SKAT for the combined effect of common and rare variants</p></a></li>
<li><a href='#SKAT_CommonRare_Robust'><p>SNP set test (both common and rare variants) for binary traits with robust region-based methods</p></a></li>
<li><a href='#SKAT_NULL_emmaX'><p>Get parameters and residuals from the null model with incorporating the kinship structure</p></a></li>
<li><a href='#SKAT_Null_Model'><p>Get parameters and residuals from the NULL model</p></a></li>
<li><a href='#SKAT_Null_Model_MomentAdjust'><p>Get parameters and residuals from the NULL model for small sample adjustment</p></a></li>
<li><a href='#SKAT.example'><p>Example data for SKAT</p></a></li>
<li><a href='#SKAT.example.ChrX'><p>Example data for SKAT</p></a></li>
<li><a href='#SKAT.fam.example'><p>Example data for SKAT_NULL_emmaX</p></a></li>
<li><a href='#SKAT.haplotypes'><p>Haplotype dataset for power calculation</p></a></li>
<li><a href='#SKAT.SSD.All'><p>SNP-set Kernel Association Test</p></a></li>
<li><a href='#SKATBinary'><p>SNP set test for binary traits with asymptotic and efficient resampling methods</p></a></li>
<li><a href='#SKATBinary_Robust'><p>SNP set test for binary traits with robust region-based methods</p></a></li>
<li><a href='#SKATBinary_Single'><p>Single variant tests for binary traits with Firth and efficient resampling methods</p></a></li>
<li><a href='#SKATBinary.example'><p>Example data for SKAT</p></a></li>
<li><a href='#SSD_FILE_OPEN'><p>Internal variables for SSD and functions for other packages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>SNP-Set (Sequence) Kernel Association Test</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Seunggeun (Shawn) Lee and Zhangchen Zhao, with contributions from Larisa Miropolsky and Michael Wu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Seunggeun (Shawn) Lee &lt;lee7801@snu.ac.kr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for kernel-regression-based association tests including Burden test, SKAT and SKAT-O. These methods aggregate individual SNP score statistics in a SNP set and efficiently compute SNP-set level p-values.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.13.0), Matrix, SPAtest, RSpectra</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-15 06:18:28 UTC; seunggeunlee</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-15 15:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='Close_SSD'>Close SNP set data file (SSD) </h2><span id='topic+Close_SSD'></span>

<h3>Description</h3>

<p>Close the opened SNP Set data file (SSD). After using the SSD file, it must be closed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Close_SSD()
 </code></pre>


<h3>Author(s)</h3>

<p>Seunggeun Lee, Larisa Miropolsky</p>

<hr>
<h2 id='Generate_SSD_SetID'>Generate SNP set data file (SSD) </h2><span id='topic+Generate_SSD_SetID'></span>

<h3>Description</h3>

<p>Generate a SNP set data file (SSD) from binary plink data files using user specified SNP sets. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Generate_SSD_SetID(File.Bed, File.Bim, File.Fam, File.SetID,
	 File.SSD, File.Info, Is.FlipGenotype=TRUE)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Generate_SSD_SetID_+3A_file.bed">File.Bed</code></td>
<td>
<p>name of the binary ped file (BED).</p>
</td></tr>
<tr><td><code id="Generate_SSD_SetID_+3A_file.bim">File.Bim</code></td>
<td>
<p>name of the binary map file (BIM).</p>
</td></tr>
<tr><td><code id="Generate_SSD_SetID_+3A_file.fam">File.Fam</code></td>
<td>
<p>name of the FAM file (FAM).</p>
</td></tr>
<tr><td><code id="Generate_SSD_SetID_+3A_file.setid">File.SetID</code></td>
<td>
<p>name of the SNP set ID file that defines SNP sets. 
The first column must be Set ID, and the second column must be SNP ID. There should be no header!! </p>
</td></tr>
<tr><td><code id="Generate_SSD_SetID_+3A_file.ssd">File.SSD</code></td>
<td>
<p>name of the SSD file generated. </p>
</td></tr>
<tr><td><code id="Generate_SSD_SetID_+3A_file.info">File.Info</code></td>
<td>
<p>name of the SSD info file generated. </p>
</td></tr>
<tr><td><code id="Generate_SSD_SetID_+3A_is.flipgenotype">Is.FlipGenotype</code></td>
<td>
<p>internal use only, please do not change</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SetID file is a white-space (space or tab) delimitered file with 2 columns:
SetID and SNP_ID.
</p>
<p>Please keep in mind that there should be no header!
The SNP_IDs and SetIDs should be less than 50 characters, otherwise, it will return an error message.
</p>
<p>The SSD file is a binary formated file with genotypes. 
The SSD info file is a text file with general information on data and SNP sets (first 6 rows), 
and information on each set (after 8th row).
</p>


<h3>Author(s)</h3>

<p>Seunggeun Lee, Larisa Miropolsky</p>

<hr>
<h2 id='Get_EffectiveNumberTest'>Estimate the effective number of tests for Bonferroni correction</h2><span id='topic+Get_EffectiveNumberTest'></span>

<h3>Description</h3>

<p>Estimate the effective number of tests for Bonferroni correction using the minimum achievable p-values (MAP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 
	Get_EffectiveNumberTest(MAP, alpha=0.05, Is.MidP=TRUE) 


 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Get_EffectiveNumberTest_+3A_map">MAP</code></td>
<td>
<p>a vector of the minimum achievable p-values (MAP).</p>
</td></tr>
<tr><td><code id="Get_EffectiveNumberTest_+3A_alpha">alpha</code></td>
<td>
<p>a significant level.</p>
</td></tr>
<tr><td><code id="Get_EffectiveNumberTest_+3A_is.midp">Is.MidP</code></td>
<td>
<p>a logical value indicating whether p-values are mid-p-values.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>Effective number of test for Bonferroni correction at the level alpha. MAP can be obtained from 
SKATBinary functions.
</p>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>


<h3>References</h3>

<p>Lee, S., Fuchsberger, C., Kim, S., Scott, L. (2015) 
An efficient resampling method for calibrating single and gene-based rare variant association analysis in case-control studies.
<em>Biostatistics</em>, in press.
</p>

<hr>
<h2 id='Get_Genotypes_SSD'>Get Genotype data from SSD file</h2><span id='topic+Get_Genotypes_SSD'></span><span id='topic+Get_Genotypes_SSD_Sparse'></span>

<h3>Description</h3>

<p>Read a SSD file and return a genotype matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Get_Genotypes_SSD(SSD_INFO, Set_Index, is_ID = TRUE)
	
	Get_Genotypes_SSD_Sparse(SSD_INFO, Set_Index)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Get_Genotypes_SSD_+3A_ssd_info">SSD_INFO</code></td>
<td>
<p>SSD_INFO object returned from Open_SSD.</p>
</td></tr>
<tr><td><code id="Get_Genotypes_SSD_+3A_set_index">Set_Index</code></td>
<td>
<p>a numeric value of Set index. The set index of each set can be found from SetInfo object of SSD.INFO. </p>
</td></tr>
<tr><td><code id="Get_Genotypes_SSD_+3A_is_id">is_ID</code></td>
<td>
<p>a logical value indicating whether to read SNP ID (default=TRUE). If TRUE, it reads SNP IDs and use them as column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A genotype matrix with n rows and m columns, where n is the number of samples and m is the number of SNPs. Get_Genotypes_SSD_Sparse returns a sparse matrix. Get_Genotypes_SSD_Sparse always returns SNP IDs as the column names, so does not have is_ID parameter. 
</p>


<h3>Author(s)</h3>

<p>Seunggeun Lee, Larisa Miropolsky</p>

<hr>
<h2 id='Get_Logistic_Weights'>Get the logistic weight</h2><span id='topic+Get_Logistic_Weights'></span><span id='topic+Get_Logistic_Weights_MAF'></span>

<h3>Description</h3>

<p>Get logistic weights from either a genotype matrix (Z) or a vector of minor allele frequncies (MAF). 
Users can apply this weights to SKAT by giving it as the &ldquo;weights&rdquo; parameter. 
The logistic weight gives equal weights to rare variants and nearly zero weight to common variants. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
	Get_Logistic_Weights(Z, par1=0.07, par2=150)


	Get_Logistic_Weights_MAF(MAF, par1=0.07, par2=150)
		
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Get_Logistic_Weights_+3A_z">Z</code></td>
<td>
<p>a numeric genotype matrix with each row as a different individual and each column as a separate gene/snp. 
Each genotype should be coded as 0, 1, 2, and 9 for AA, Aa, aa, and missing, where A is a major allele and a is a minor allele. </p>
</td></tr>
<tr><td><code id="Get_Logistic_Weights_+3A_maf">MAF</code></td>
<td>
<p>a numeric vector of minor allele frequncies. </p>
</td></tr>
<tr><td><code id="Get_Logistic_Weights_+3A_par1">par1</code></td>
<td>
<p>a numeric value of the first parameter of the logistic weight (default= 0.07).</p>
</td></tr>
<tr><td><code id="Get_Logistic_Weights_+3A_par2">par2</code></td>
<td>
<p>a numeric value of the second parameter of the logistic weight(default= 150).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula for the weight is 
</p>
<p style="text-align: center;"><code class="reqn"> weights = \frac{e^{(par1 - MAF) par2}}{1 + e^{(par1 - MAF) par2}}. </code>
</p>
                                              


<h3>Value</h3>

<p>A vector of the logistic weight. 
</p>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(SKAT.example)


#############################################################
#	Compute the P-value of SKAT with the logistic Weight (par1=0.07, par2=150)

# Use logistic weight
Z&lt;-SKAT.example$Z
obj&lt;-SKAT_Null_Model(y.c ~ X, out_type="C", data=SKAT.example)
weights&lt;-Get_Logistic_Weights(Z, par1=0.07, par2=150)
SKAT(Z, obj, kernel = "linear.weighted", weights=weights)$p.value

# Weights function
MAF&lt;-colMeans(Z)/2
plot(MAF,weights)


</code></pre>

<hr>
<h2 id='Get_RequiredSampleSize'>Get the required sample size to achieve the given power</h2><span id='topic+Get_RequiredSampleSize'></span>

<h3>Description</h3>

<p>Get the sample sizes required to achieve the given power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Get_RequiredSampleSize(obj, Power=0.8)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Get_RequiredSampleSize_+3A_obj">obj</code></td>
<td>
<p>an object returned from Power_Continuous or Power_Logistic.</p>
</td></tr>
<tr><td><code id="Get_RequiredSampleSize_+3A_power">Power</code></td>
<td>
<p>a value of the power to be achieved (default= 0.8).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes required sample sizes using simple interpolation. 
</p>


<h3>Value</h3>

<p>A list object for the required sample sizes.
</p>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>

<hr>
<h2 id='Get_Resampling_Pvalue'>Compute a resampling p-value</h2><span id='topic+Get_Resampling_Pvalue'></span><span id='topic+Get_Resampling_Pvalue_1'></span>

<h3>Description</h3>

<p>Compute a resampling p-value using resampled residuals. 
To use it, SKAT_Null_Model or SKAT_Null_Model_MomentAdjust should have n.Resampling &gt; 0. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Get_Resampling_Pvalue(obj)

	Get_Resampling_Pvalue_1(p.value, p.value.resampling)


 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Get_Resampling_Pvalue_+3A_obj">obj</code></td>
<td>
<p>SKAT outcome object.</p>
</td></tr>
<tr><td><code id="Get_Resampling_Pvalue_+3A_p.value">p.value</code></td>
<td>
<p>a numeric value of the SKAT p-value.</p>
</td></tr>
<tr><td><code id="Get_Resampling_Pvalue_+3A_p.value.resampling">p.value.resampling</code></td>
<td>
<p>a vector of p-values from the resampled residuals.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>See SKAT_Null_Model
</p>


<h3>Value</h3>

<table>
<tr><td><code>p.value</code></td>
<td>
<p>the resampling p-value. It is computed as (n1 +1)/(n+1), where n is the number of resampling (n.Resampling in SKAT_Null_Model or SKAT_Null_Model_MomentAdjust), 
and n1 is the number of resampled residual p-values smaller than the original sample p-value. </p>
</td></tr>
<tr><td><code>is_smaller</code></td>
<td>
<p>a logical value indicates whether the resampling p-value should be smaller. 
If n1=0, then it is TRUE, otherwise it is FALSE. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>

<hr>
<h2 id='Open_SSD'>Open SNP set data file (SSD) </h2><span id='topic+Open_SSD'></span>

<h3>Description</h3>

<p>Open a SNP Set data file (SSD). After finishing using the SSD file, you must close the file by callinsg Close_SSD function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Open_SSD(File.SSD, File.Info)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Open_SSD_+3A_file.ssd">File.SSD</code></td>
<td>
<p> name of the SSD file . </p>
</td></tr>
<tr><td><code id="Open_SSD_+3A_file.info">File.Info</code></td>
<td>
<p> name of the SSD info file. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object of SSD.INFO.
</p>


<h3>Author(s)</h3>

<p>Seunggeun Lee, Larisa Miropolsky</p>

<hr>
<h2 id='Power_Continuous'>Power calculation, continuous traits</h2><span id='topic+Power_Continuous'></span><span id='topic+Power_Continuous_R'></span>

<h3>Description</h3>

<p>Compute an average power of SKAT and SKAT-O for testing association between a genomic region
and continuous phenotypes with a given disease model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Power_Continuous(Haplotypes=NULL, SNP.Location=NULL, SubRegion.Length=-1
, Causal.Percent=5, Causal.MAF.Cutoff=0.03, alpha =c(0.01,10^(-3),10^(-6))
, N.Sample.ALL = 500 * (1:10), Weight.Param=c(1,25), N.Sim=100
, BetaType = "Log", MaxBeta=1.6, Negative.Percent=0)

 
Power_Continuous_R(Haplotypes=NULL, SNP.Location, SubRegion.Length=-1
, Causal.Percent=5, Causal.MAF.Cutoff=0.03, alpha =c(0.01,10^(-3),10^(-6))
, N.Sample.ALL = 500 * (1:10), Weight.Param=c(1,25), N.Sim=100
, BetaType = "Log", MaxBeta=1.6, Negative.Percent=0, r.corr=0)

 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Power_Continuous_+3A_haplotypes">Haplotypes</code></td>
<td>
<p>a haplotype matrix with each row as a different individual and each column as a separate SNP (default= NULL). 
Each element of the matrix should be either 0 (major allel) or 1 (minor allele). 
If NULL, SKAT.haplotype dataset will be used to compute power.</p>
</td></tr>
<tr><td><code id="Power_Continuous_+3A_snp.location">SNP.Location</code></td>
<td>
<p>a numeric vector of SNP locations that should be matched with the SNPs in the Haplotype matrix (default= NULL). 
It is used to obtain subregions. When Haplotype=NULL, it should be NULL. </p>
</td></tr>
<tr><td><code id="Power_Continuous_+3A_subregion.length">SubRegion.Length</code></td>
<td>
<p>a value of the length of subregions (default= -1). 
Each subregion will be randomly selected, and then the average power will be calculated by taking the average 
over the estimated powers of all subregions. 
If SubRegion.Length=-1 (default), the length of the subregion will be the same as the length of the whole region, 
so there will no random selection of subregions.</p>
</td></tr>
<tr><td><code id="Power_Continuous_+3A_causal.percent">Causal.Percent</code></td>
<td>
<p>a value of the percentage of causal SNPs among rare SNPs (MAF &lt; Causal.MAF.Cutoff)(default= 5).</p>
</td></tr>
<tr><td><code id="Power_Continuous_+3A_causal.maf.cutoff">Causal.MAF.Cutoff</code></td>
<td>
<p>a value of MAF cutoff for the causal SNPs. Only SNPs that have MAFs smaller than the cutoff will be considered as causal SNPs (default= 0.03).</p>
</td></tr>
<tr><td><code id="Power_Continuous_+3A_alpha">alpha</code></td>
<td>
<p>a vector of the significance levels (default= c(0.01,10^(-3),10^(-6))). </p>
</td></tr>
<tr><td><code id="Power_Continuous_+3A_n.sample.all">N.Sample.ALL</code></td>
<td>
<p>a vector of the sample sizes (default= 500 * (1:10)). </p>
</td></tr>
<tr><td><code id="Power_Continuous_+3A_weight.param">Weight.Param</code></td>
<td>
<p>a vector of parameters of beta weights (default= c(1,25)).</p>
</td></tr>
<tr><td><code id="Power_Continuous_+3A_n.sim">N.Sim</code></td>
<td>
<p> a value of number of causal SNP/SubRegion sets to be generated to compute the average power (default= 100). 
Power will be computed for each causal SNP/SubRegion set, and then the average power will be obtained by taking average over the computed powers. </p>
</td></tr>
<tr><td><code id="Power_Continuous_+3A_betatype">BetaType</code></td>
<td>
<p>a type of effect sizes (default= &ldquo;Log&rdquo;). &ldquo;Log&rdquo; indicates that effect sizes of causal variants equal to <code class="reqn">c|log10(MAF)|</code>, 
and &ldquo;Fixed&rdquo; indicates that effect sizes of all causal variants are the same.</p>
</td></tr>
<tr><td><code id="Power_Continuous_+3A_maxbeta">MaxBeta</code></td>
<td>
<p>a numeric value of the maximum effect size (default= 1.6). When BetaType=&quot;Log&quot;, the maximum effect size is MaxBeta (when MAF=0.0001).
When BetaType=&quot;Fixed&quot;, all causal variants have the same effect size (= MaxBeta). See details</p>
</td></tr>
<tr><td><code id="Power_Continuous_+3A_negative.percent">Negative.Percent</code></td>
<td>
<p>a numeric value of the percentage of coefficients of causal variants that are negative (default= 0).</p>
</td></tr>
<tr><td><code id="Power_Continuous_+3A_r.corr">r.corr</code></td>
<td>
<p>(Power_Continuous_R only) the <code class="reqn">\rho</code> parameter for the compound symmetric correlation kernel  (default= 0). See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default it uses the haplotype information in the SKAT.haplotypes dataset. 
So if you want to use the SKAT.haplotypes dataset, you can left Haplotypes and SNP.Location as NULL. 
</p>
<p>When BetaType=&ldquo;Log&rdquo;, MaxBeta is a coeffecient value (<code class="reqn">\beta</code>) of the causal SNP at MAF <code class="reqn">= 10^{-4}</code> 
and used to obtain c value of the function <code class="reqn">c|log10(MAF)|</code>. For example, if MaxBeta=1.6, <code class="reqn"> c = 1.6/4 = 0.4</code>. 
Then a variant with MAF=0.001 has <code class="reqn">\beta = 1.2</code> and a variant with MAF=0.01 has <code class="reqn">\beta = 0.8</code>.
</p>
<p>When SubRegion.Length is small such as 3kb or 5kb, 
it is possible that you can have different estimated power for each run with N.Sim = <code class="reqn">50 \sim 100</code>. 
Then, please increase the N.Sim to <code class="reqn">500 \sim 1000</code> to obtain stable results. 
</p>
<p>R.sq is computed under the no linkage disequilibrium assumption.  
</p>
<p>Power_Continuous_R computes power with new class of kernels with the compound symmetric correlation structure. 
It uses a slightly different approach, and thus 
Power_Continuous and Power_Continuous_R can produce slightly different results although r.corr=0.
</p>
<p>If you want to computer power of SKAT-O by estimating the optimal r.corr, use r.corr=2. 
The estimated optimal r.corr is 
<code class="reqn">r.corr = p_1^2 ( 2p_2-1)^2</code>,
where <code class="reqn">p_1</code> is a proportion of causal variants, and <code class="reqn">p_2</code> is a proportion of negatively associated causal variants
among the causal variants.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Power</code></td>
<td>
<p>A matrix with each row as a different 
sample size and each column as a different significance level. Each element of the matrix is the estimated power.</p>
</td></tr>
<tr><td><code>R.sq</code></td>
<td>
<p>Proportion of phenotype variance explained by genetic variants.</p>
</td></tr>
<tr><td><code>r.corr</code></td>
<td>
<p>r.corr value. When r.corr=2 is used, it provides the estimated r.corr value. See details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
#	Calculate the average power of randomly selected 3kb regions 
#	with the following conditions.
#
#	Causal percent = 20%
#	Negative percent = 20%
#	Max effect size  = 2 at MAF = 10^-4
#
#	When you use this function, please increase N.Sim (more than 100)	
#

out.c&lt;-Power_Continuous(SubRegion.Length=3000, 
Causal.Percent= 20, N.Sim=5, MaxBeta=2,Negative.Percent=20)
out.c

#
#	Calculate the required sample sizes to achieve 80% power

Get_RequiredSampleSize(out.c, Power=0.8)

</code></pre>

<hr>
<h2 id='Power_Logistic'>Power calculation, Dichotomous traits</h2><span id='topic+Power_Logistic'></span><span id='topic+Power_Logistic_R'></span>

<h3>Description</h3>

<p>Compute an average power of SKAT and SKAT-O for testing association between a genomic region
and dichotomous phenotypes from case-control studies with a given disease model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Power_Logistic(Haplotypes = NULL, SNP.Location = NULL, SubRegion.Length=-1
, Prevalence=0.01, Case.Prop=0.5, Causal.Percent=5, Causal.MAF.Cutoff=0.03
, alpha =c(0.01,10^(-3),10^(-6)), N.Sample.ALL = 500 * (1:10)
, Weight.Param=c(1,25), N.Sim=100, OR.Type = "Log"
, MaxOR=5, Negative.Percent=0)

Power_Logistic_R(Haplotypes = NULL, SNP.Location = NULL, SubRegion.Length=-1
, Prevalence=0.01, Case.Prop=0.5, Causal.Percent=5, Causal.MAF.Cutoff=0.03
, alpha =c(0.01,10^(-3),10^(-6)), N.Sample.ALL = 500 * (1:10)
, Weight.Param=c(1,25), N.Sim=100, OR.Type = "Log"
, MaxOR=5, Negative.Percent=0, r.corr=0)

 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Power_Logistic_+3A_haplotypes">Haplotypes</code></td>
<td>
<p>a haplotype matrix with each row as a different individual and each column as a separate SNP (default= NULL). 
Each element of the matrix should be either 0 (major allel) or 1 (minor allele). 
If NULL, SKAT.haplotype dataset will be used to compute power.</p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_snp.location">SNP.Location</code></td>
<td>
<p>a numeric vector of SNP locations which should be matched with the SNPs in the Haplotype matrix (default= NULL). 
It is used to obtain subregions. When Haplotype=NULL, it should be NULL. </p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_subregion.length">SubRegion.Length</code></td>
<td>
<p>a value of the length of subregions (default= -1). 
Each subregion will be randomly selected, and then the average power will be calculated by taking the average over the estimated powers of all subregions. 
If SubRegion.Length=-1 (default), the length of the subregion is the same as the length of the whole region, so there will no random selection of subregions.</p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_prevalence">Prevalence</code></td>
<td>
<p>a value of disease prevalence.</p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_case.prop">Case.Prop</code></td>
<td>
<p>a value of the proportion of cases. For example, Case.Prop=0.5 means 50 % of samples are cases and 50 % of samples are controls. </p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_causal.percent">Causal.Percent</code></td>
<td>
<p>a value of the percentage of causal SNPs among rare SNPs (MAF &lt; Causal.MAF.Cutoff)(default= 5).</p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_causal.maf.cutoff">Causal.MAF.Cutoff</code></td>
<td>
<p>a value of MAF cutoff for the causal SNPs. Only SNPs that have MAFs smaller than this are considered as causal SNPs (default= 0.03).</p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_alpha">alpha</code></td>
<td>
<p>a vector of the significance levels (default= c(0.01,10^(-3),10^(-6))). </p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_n.sample.all">N.Sample.ALL</code></td>
<td>
<p>a vector of the sample sizes (default= 500 * (1:10)). </p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_weight.param">Weight.Param</code></td>
<td>
<p>a vector of parameters of beta weights (default= c(1,25)).</p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_n.sim">N.Sim</code></td>
<td>
<p> a value of number of causal SNP/SubRegion sets to be generated to compute the average power (default= 100). Power will be computed for each causal SNP/SubRegion set, and then the average power will be obtained by taking mean of the computed powers. </p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_or.type">OR.Type</code></td>
<td>
<p>a function type of effect sizes (default= &ldquo;Log&rdquo;). &ldquo;Log&rdquo; indicates that log odds ratio of causal variants equal to <code class="reqn">c|log10(MAF)|</code>, 
and &ldquo;Fixed&rdquo; indicates that log odds ratio of all causal variants are the same.</p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_maxor">MaxOR</code></td>
<td>
<p>a numeric value of the maximum odds ratio (default= 5). When OR.Type=&ldquo;Log&rdquo;, the maximum odds ratio is MaxOR (when MAF=0.0001). 
When OR.Type=&ldquo;Fixed&rdquo;, all causal variants have the same odds ratio (= MaxOR). See details</p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_negative.percent">Negative.Percent</code></td>
<td>
<p>a numeric value of the percentage of coefficients of causal variants that are negative (default= 0).</p>
</td></tr>
<tr><td><code id="Power_Logistic_+3A_r.corr">r.corr</code></td>
<td>
<p>(Power_Logistic_R only) the <code class="reqn">\rho</code> parameter of new class of kernels with compound symmetric correlation structure for genotype effects  (default= 0). See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default it uses the haplotype information in the SKAT.haplotypes dataset. 
So you can left Haplotypes and SNP.Location as NULL if you want to use the SKAT.haplotypes dataset. 
</p>
<p>When OR.Type=&quot;Log&quot;, MaxOR is a odds ratio of the causal SNP at MAF <code class="reqn">= 10^{-4}</code> 
and used to obtain c value in the function <code class="reqn">\log OR = c|log10(MAF)|</code>. 
For example, if MaxOR=5, <code class="reqn">c = log(5)/4 = 0.402</code>. Then a variant with MAF=0.001 has log odds ratio = 1.206 and a variant with MAF=0.01 has log odds ratio = 0.804.
</p>
<p>When SubRegion.Length is small such as 3kb or 5kb, it is possible that you can have different estimated power for each run with N.Sim = <code class="reqn">50 \sim 100</code>. 
Then, please increase N.Sim to <code class="reqn">500 \sim 1000</code> to obtain stable results. 
</p>
<p>Power_Logistic_R computes the power with new class of kernels with the compound symmetric correlation structure. 
It uses a slightly different approach, and thus 
Power_Logistic and Power_Logistic_R can produce slightly different results although r.corr=0.
</p>
<p>If you want to computer power of SKAT-O by estimating the optimal r.corr, use r.corr=2. 
The estimated optimal r.corr is 
<code class="reqn">r.corr = p_1^2 ( 2p_2-1)^2</code>,
where <code class="reqn">p_1</code> is a proportion of causal variants, and <code class="reqn">p_2</code> is a proportion of negatively associated causal variants
among the causal variants.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Power</code></td>
<td>
<p>A matrix with each row as a different 
sample size and each column as a different significance level. Each element of the matrix is the estimated power.</p>
</td></tr>
<tr><td><code>r.corr</code></td>
<td>
<p>r.corr value. When r.corr=2 is used, it provides the estimated r.corr value. See details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
#	Calculate the average power of randomly selected 3kb regions 
#	with the following conditions.
#
#	Causal percent = 20%
#	Negative percent = 20%
#	Max OR = 7 at MAF = 10^-4
#
#	When you use this function, please increase N.Sim (more than 100)	
#
out.b&lt;-Power_Logistic(SubRegion.Length=3000, 
Causal.Percent= 20, N.Sim=5 ,MaxOR=7,Negative.Percent=20)

out.b

#
#	Calculate the required sample sizes to achieve 80% power

Get_RequiredSampleSize(out.b, Power=0.8)

</code></pre>

<hr>
<h2 id='QQPlot_Adj'>Adjusted QQ plot</h2><span id='topic+QQPlot_Adj'></span>

<h3>Description</h3>

<p>Draws a MAP-adjusted QQ plot 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 

	QQPlot_Adj(Pval, MAP, main="QQ plot", ntry=500, confidence=0.95, Is.unadjsted=TRUE
	, Is.legend=TRUE, xlab="Expected Quantiles (-log10 P-values)"
	, ylab="Observed Quantiles (-log10 P-values)")



 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QQPlot_Adj_+3A_pval">Pval</code></td>
<td>
<p>a vector of p-values.</p>
</td></tr>
<tr><td><code id="QQPlot_Adj_+3A_map">MAP</code></td>
<td>
<p>a vector of MAP.</p>
</td></tr>
<tr><td><code id="QQPlot_Adj_+3A_main">main</code></td>
<td>
<p>a main title.</p>
</td></tr>
<tr><td><code id="QQPlot_Adj_+3A_ntry">ntry</code></td>
<td>
<p>a numeric value of the number for resampling (default= 500).</p>
</td></tr>
<tr><td><code id="QQPlot_Adj_+3A_confidence">confidence</code></td>
<td>
<p>a value for the confidence band (default= 0.95).</p>
</td></tr>
<tr><td><code id="QQPlot_Adj_+3A_is.unadjsted">Is.unadjsted</code></td>
<td>
<p>a logical value to indicate whether to plot the unadjusted QQ plot (default= TRUE).</p>
</td></tr>
<tr><td><code id="QQPlot_Adj_+3A_is.legend">Is.legend</code></td>
<td>
<p>a logical value to indicate whether to plot a legend (default= TRUE).</p>
</td></tr>
<tr><td><code id="QQPlot_Adj_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="QQPlot_Adj_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>


<h3>References</h3>

<p>Lee, S., Fuchsberger, C., Kim, S., Scott, L. (2015) 
An efficient resampling method for calibrating single and gene-based rare variant association analysis in case-control studies.
<em>Biostatistics</em>, in press.
</p>

<hr>
<h2 id='Read_Plink_FAM'>Read Plink FAM and covariates files</h2><span id='topic+Read_Plink_FAM'></span><span id='topic+Read_Plink_FAM_Cov'></span>

<h3>Description</h3>

<p>Read Plink FAM and covariates files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Read_Plink_FAM(Filename, Is.binary=TRUE, flag1=0)
	Read_Plink_FAM_Cov(Filename, File_Cov, Is.binary=TRUE, flag1=0, cov_header=TRUE)

 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Read_Plink_FAM_+3A_filename">Filename</code></td>
<td>
<p>input file name of plink FAM file</p>
</td></tr>
<tr><td><code id="Read_Plink_FAM_+3A_is.binary">Is.binary</code></td>
<td>
<p>if TRUE, the phenotype is binary. If phenotype is continuous, it should be FALSE</p>
</td></tr>
<tr><td><code id="Read_Plink_FAM_+3A_flag1">flag1</code></td>
<td>
<p>0 represents the default coding of unaffected/affected (1/2) (default=0), and 1 represents 0/1 coding. 
flag1=1 is the same as &ndash;1 flag in plink. Please see the plink manual. </p>
</td></tr>      
<tr><td><code id="Read_Plink_FAM_+3A_file_cov">File_Cov</code></td>
<td>
<p>an input file name of plink covariates file. The first two columns of this file should be FID and IID.</p>
</td></tr>      
<tr><td><code id="Read_Plink_FAM_+3A_cov_header">cov_header</code></td>
<td>
<p>a logical value indicating whether the covariate file contains a header row (default=TRUE)</p>
</td></tr>      
</table>


<h3>Value</h3>

<p>A dataframe of Family ID (FID), Individual ID (IID), Paternal ID (PID), Maternal ID(MID), Sex, and Phenotype. 
If Read_Plink_FAM_Cov is used with a covariate file, the dataframe has covariates from the 7th column.
</p>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>

<hr>
<h2 id='Read_SNP_WeightFile'>Read a file with custom weights</h2><span id='topic+Read_SNP_WeightFile'></span>

<h3>Description</h3>

<p>Read a file with custom weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	Read_SNP_WeightFile(FileName)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Read_SNP_WeightFile_+3A_filename">FileName</code></td>
<td>
<p>input file name of a custom weight.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file should be a white-space (space or tab) delimitered file with 2 columns:
SNP_ID and weight value.
</p>
<p>Please keep in mind that there should be no header!!
</p>


<h3>Value</h3>

<p>Output object has a hash table of SNP IDs and weights.
</p>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>

<hr>
<h2 id='Resampling_FWER'>Obtain significant SNP sets after controlling family wise error rate (FWER)</h2><span id='topic+Resampling_FWER'></span><span id='topic+Resampling_FWER_1'></span>

<h3>Description</h3>

<p>Obtain significant SNP sets after controlling for family wise error rate (FWER) 
using resampled residuals. To use it, SKAT_Null_Model or 
SKAT_Null_Model_MomentAdjust should have n.Resampling &gt; 0. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
	Resampling_FWER(obj,FWER=0.05)

	Resampling_FWER_1(P.value, P.value.Resampling, FWER=0.05)

 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Resampling_FWER_+3A_obj">obj</code></td>
<td>
<p>object returned from SKAT.SSD.All or SKATBinary.SSD.All.</p>
</td></tr>
<tr><td><code id="Resampling_FWER_+3A_p.value">P.value</code></td>
<td>
<p>a vector of SKAT p-values. If 100 genes were tested, this vector should have 100 p-values.</p>
</td></tr>
<tr><td><code id="Resampling_FWER_+3A_p.value.resampling">P.value.Resampling</code></td>
<td>
<p>a matrix of p-values of the resampled residuals. 
Each row represents each gene/snp set, and each column represents resampling set. 
For example, if you have 100 genes, and conducted resampling 1000 times ( ex.n.Resampling=1000 in SKAT_Null_Model), then it should be a 100 x 1000 matrix.</p>
</td></tr>  
<tr><td><code id="Resampling_FWER_+3A_fwer">FWER</code></td>
<td>
<p>a numeric value of FWER rate to control (default=0.05)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>results</code></td>
<td>
<p>If the returned object from SKAT.SSD.all (or SKATBinary.SSD.All) are used, it is a sub-table of significant snp sets of the result table in the obj. 
If you use P.value and P.value.Resampling, it is a vector of significant p-values. 
If there is no significant snp set, it is NULL. </p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a numeric value of the number of significant snp sets.</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p>a vector of indexes of significant snp sets.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>

<hr>
<h2 id='SKAT'>SNP-set (Sequence) Kernel Association Test</h2><span id='topic+SKAT'></span><span id='topic+SKAT.SSD.OneSet'></span><span id='topic+SKAT.SSD.OneSet_SetIndex'></span>

<h3>Description</h3>

<p>Test for association between a set of SNPS/genes and continuous or dichotomous phenotypes using kernel regression framework.      
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
SKAT(Z, obj, kernel = "linear.weighted", 
  method="davies", weights.beta=c(1,25), weights=NULL, 
  impute.method="fixed", r.corr=0, is_check_genotype=TRUE,
  is_dosage = FALSE, missing_cutoff=0.15 , max_maf=1, estimate_MAF=1)

SKAT.SSD.OneSet(SSD.INFO, SetID, obj, ... ,obj.SNPWeight=NULL)

SKAT.SSD.OneSet_SetIndex(SSD.INFO, SetIndex, obj, ... ,obj.SNPWeight=NULL)

 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKAT_+3A_z">Z</code></td>
<td>
<p>a numeric genotype matrix with each row as a different individual and each column as a separate gene/snp. 
Each genotype should be coded as 0, 1, 2, and 9 (or NA) for AA, Aa, aa, and missing, where A is a major allele and a is a minor allele. 
Missing genotypes will be imputed by the simple Hardy-Weinberg equilibrium (HWE) based imputation. </p>
</td></tr>
<tr><td><code id="SKAT_+3A_obj">obj</code></td>
<td>
<p>an output object of the SKAT_Null_Model function. </p>
</td></tr>
<tr><td><code id="SKAT_+3A_kernel">kernel</code></td>
<td>
<p>a type of kernel (default= &quot;linear.weighted&quot;). See detail section. </p>
</td></tr>
<tr><td><code id="SKAT_+3A_method">method</code></td>
<td>
<p>a method to compute the p-value (default= &quot;davies&quot;). 
&quot;davies&quot; represents an exact method that  computes the p-value by inverting the characteristic function of the mixture chisq, 
&quot;liu&quot; represents an approximation method that matches the first 3 moments, 
&quot;liu.mod&quot; represents modified &quot;liu&quot; method that matches kurtosis instead of skewness 
to improve tail probability approximation,&quot;SKATO&quot; and &quot;optimal.adj&quot; represent a SKAT-O based on an unified approach, 
and &quot;optimal&quot; is an old version of the implementation of SKAT-O. See details.</p>
</td></tr>
<tr><td><code id="SKAT_+3A_weights.beta">weights.beta</code></td>
<td>
<p>a numeric vector of parameters for the beta weights for the weighted kernels. 
If you want to use your own  weights, please use the &ldquo;weights&rdquo; parameter. It will be ignored if &ldquo;weights&rdquo; parameter is not null.</p>
</td></tr>
<tr><td><code id="SKAT_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights for the weighted kernels. 
It is <code class="reqn">\sqrt{w}</code> in the SKAT paper. 
So if you want to use the Madsen and Browning (2009) weight, you should set each element of weights as <code class="reqn">1/ \sqrt{p(1-p)}</code>, 
not <code class="reqn">1/ p(1-p)</code>. When it is NULL, the beta weight with the &ldquo;weights.beta&rdquo; parameter is used. </p>
</td></tr>
<tr><td><code id="SKAT_+3A_impute.method">impute.method</code></td>
<td>
<p>a method to impute missing genotypes (default= &quot;fixed&quot;). 
&quot;bestguess&quot; imputes missing genotypes as most likely values (0,1,2), &quot;random&quot; imputes missing genotypes by generating binomial(2,p) random variables (p is the MAF), 
and &quot;fixed&quot; imputes missing genotypes by assigning the mean genotype values (2p).</p>
</td></tr>
<tr><td><code id="SKAT_+3A_r.corr">r.corr</code></td>
<td>
<p>the <code class="reqn">\rho</code> parameter for the compound symmetric correlation structure kernels (default= 0). 
If you give a vector value, SKAT will conduct the optimal test. It will be ignored if method=&ldquo;optimal&rdquo; or method=&ldquo;optimal.adj&rdquo;. See details.</p>
</td></tr>
<tr><td><code id="SKAT_+3A_is_check_genotype">is_check_genotype</code></td>
<td>
<p>a logical value indicating whether to check the validity of the genotype matrix Z (default= TRUE). 
If Z has non-SNP data, please set it FALSE, otherwise you will get an error message. 
If it is FALSE and you use weighted kernels, the weights should be given through the &ldquo;weights&rdquo; parameter.</p>
</td></tr>
<tr><td><code id="SKAT_+3A_is_dosage">is_dosage</code></td>
<td>
<p>a logical value indicating whether the matrix Z is a dosage matrix. If it is TRUE, SKAT will ignore &ldquo;is_check_genotype&rdquo;. </p>
</td></tr>
<tr><td><code id="SKAT_+3A_missing_cutoff">missing_cutoff</code></td>
<td>
<p>a cutoff of the missing rates of SNPs (default=0.15). Any SNPs with missing rates higher than the cutoff will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="SKAT_+3A_max_maf">max_maf</code></td>
<td>
<p>a cutoff of the maximum minor allele frequencies (MAF) (default=1, no cutoff). Any SNPs with MAF &gt; cutoff will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="SKAT_+3A_estimate_maf">estimate_MAF</code></td>
<td>
<p>a numeric value indicating how to estimate MAFs for the weight calculation and 
the missing genotype imputation. If estimate_MAF=1 (default), SKAT uses all samples to estimate MAFs. 
If estimate_MAF=2, only samples with non-missing phenotypes and covariates are used to estimate MAFs. </p>
</td></tr>
<tr><td><code id="SKAT_+3A_ssd.info">SSD.INFO</code></td>
<td>
<p>an SSD_INFO object returned from Open_SSD. </p>
</td></tr>
<tr><td><code id="SKAT_+3A_setid">SetID</code></td>
<td>
<p>a character value of Set ID. A set ID of each set can be found from SetInfo object in SSD.INFO.</p>
</td></tr>
<tr><td><code id="SKAT_+3A_setindex">SetIndex</code></td>
<td>
<p>a numeric value of Set index. A set index of each set can be found from SetInfo object in SSD.INFO.</p>
</td></tr>
<tr><td><code id="SKAT_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to &ldquo;SKAT&rdquo; </p>
</td></tr>
<tr><td><code id="SKAT_+3A_obj.snpweight">obj.SNPWeight</code></td>
<td>
<p> an output object of Read_SNP_WeightFile (default=NULL). 
If NULL, the beta weight with the &ldquo;weights.beta&rdquo; parameter will be used.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 6 types of pre-specified kernels:
&quot;linear&quot;, &quot;linear.weighted&quot;, &quot;IBS&quot;, &quot;IBS.weighted&quot;, &quot;quadratic&quot; and &quot;2wayIX&quot;.
Among them, &quot;2wayIX&quot; is a product kernel consisting of main effects and SNP-SNP interaction terms. 
</p>
<p>If users want to use dosage values instead of genotypes, set is_dosage=TRUE. 
Please keep in mind that plink formatted files (so SSD files) cannot used for dosages. Instead, 
you should make a genotype matrix Z to run SKAT.
</p>
<p>The kernel matrix for the weighted linear kernel is
<code class="reqn">K = G W W G </code>, where G is a genotype matrix and W is a diagonal weight matrix. 
Please note that it is different from the notation we used in the original SKAT paper, 
which was <code class="reqn">K = G W G </code>. 
The Madsen and Browning (2009) weight is <code class="reqn">w = 1/ \sqrt{p(1-p)}</code> in the current notation. 
By the previous notation, it is <code class="reqn">w = 1/ p(1-p)</code>.
</p>
<p>If you want to use the SSD file, you need to open it first using Open_SSD,
and then use either SKAT.SSD.OneSet  or SKAT.SSD.OneSet_SetIndex. 
Set index is a numeric value and automatically assigned to each set (from 1).
</p>
<p>The r.corr represents a <code class="reqn">\rho</code> parameter of the unified test, 
<code class="reqn">Q_{\rho} = (1-\rho) Q_S + \rho Q_B</code>, where <code class="reqn">Q_S</code> is a SKAT test statistic, 
and <code class="reqn">Q_B</code> is a weighted burden test statistic. 
Therefore, <code class="reqn">\rho=0</code> results in the original weighted linear kernel SKAT, 
and <code class="reqn">\rho=1</code> results in the weighted burden test (default: <code class="reqn">\rho=0</code>). 
If r.corr is a vector, SKAT-O will be conducted with adaptively seleting <code class="reqn">\rho</code> from given r.corr values. 
<code class="reqn">\rho</code> should be a value between 0 and 1. When method=&quot;optimal&quot; or method=&quot;optimal.adj&quot;, the r.corr parameter will be ignored.
</p>
<p>We slightly changed the implementation for SKAT-O to improve the estimation of p-values. You can run it by 
using method=&quot;optimal.adj&quot; or &quot;SKATO&quot;. It uses a grid of eight points <code class="reqn">\rho=(0, 0.1^2, 0.2^2, 0.3^2, 0.4^2, 0.5^2, 0.5, 1)</code> 
for the search of the optimal <code class="reqn">\rho</code>.   
If you want to use the original implementation of SKAT-O, use method=&quot;optimal&quot; that 
carries out SKAT-O with an equal sized grid of 11 points (from 0 to 1).
</p>
<p>If the true p.value is very small, you can have p.value=0 due to numerical reasons. In this case, 
please see pval.zero.msg that shows how small it is. 
For example, if the p.value is smaller than <code class="reqn">10^{-60}</code>, it has &quot;Pvalue &lt; 1.000000e-60&quot;.                                           
</p>
<p>By default, SKAT uses impute.method=&quot;fixed&quot; that imputes missing genotypes as the mean genotype values (2p). 
When variates are very rare and missing rates between cases and controls are highly unbalanced, 
impute.method=&quot;fixed&quot; can yield inflated type I error rate. In this case, we recommend to use
impute.method=&quot;bestguess&quot;, which does not suffer the same problem.
</p>


<h3>Value</h3>

<table>
<tr><td><code>p.value</code></td>
<td>
<p>p-value of SKAT. </p>
</td></tr>
<tr><td><code>p.value.resampling</code></td>
<td>
<p>p-values from resampled outcomes. You can get it when you use obj from SKAT_Null_Model function with resampling. See the SKAT_Null_Model. </p>
</td></tr>
<tr><td><code>p.value.noadj</code></td>
<td>
<p>p-value of SKAT without the small sample adjustment. It only appears when small sample adjustment is applied.</p>
</td></tr>
<tr><td><code>p.value.noadj.resampling</code></td>
<td>
<p>p-values from resampled outcomes without the small sample adjustment.</p>
</td></tr>
<tr><td><code>pval.zero.msg</code></td>
<td>
<p>(only when p.value=0) text message that shows how small the p.value is. ex. &quot;Pvalue &lt; 1.000000e-60&quot; when the p.value is smaller than <code class="reqn">10^{-60}</code> </p>
</td></tr> 
<tr><td><code>Q</code></td>
<td>
<p>test statistic of SKAT. It has NA when method=&quot;optimal.adj&quot; or &quot;optimal&quot;.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>estimated parameters of each method.</p>
</td></tr>   
<tr><td><code>param$Is_Converged</code></td>
<td>
<p> (only with method=&quot;davies&quot;) an indicator of the convergence (1=convergence, 0=non-convergence). 
When 0 (not converged), &quot;liu&quot; method will be used to compute p-values. </p>
</td></tr>  
<tr><td><code>param$n.marker</code></td>
<td>
<p>a number of SNPs in the genotype matrix.</p>
</td></tr>  
<tr><td><code>param$n.marker.test</code></td>
<td>
<p>a number of SNPs used for the test. It can be different from param$n.marker when 
some markers are monomorphic or have higher missing rates than the missing_cutoff. </p>
</td></tr> 
<tr><td><code>test.snp.mac</code></td>
<td>
<p>a vector of minor allele count (MAC) of the snps tested. The name is SNP-ID. </p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Seunggeun Lee, Micheal Wu</p>


<h3>References</h3>

<p>Lee, S., Emond, M.J., Bamshad, M.J., Barnes, K.C., Rieder, M.J., Nickerson, D.A., 
NHLBI GO Exome Sequencing Project-ESP Lung Project Team, Christiani, D.C., Wurfel, M.M. and Lin, X. (2012) 
Optimal unified approach for rare variant association testing with application to small sample 
case-control whole-exome sequencing studies. <em>American Journal of Human Genetics</em>, 91, 224-237.
</p>
<p>Lee, S., Wu, M. C., and Lin, X. (2012)  Optimal tests for rare variant effects in sequencing association studies. <em>Biostatistics</em>, 13, 762-775.
</p>
<p>Wu, M. C.*, Lee, S.*, Cai, T., Li, Y., Boehnke, M., and Lin, X. (2011)  Rare Variant Association Testing for Sequencing Data Using the Sequence Kernel Association Test (SKAT). <em>American Journal of Human Genetics</em>, 89, 82-93. \
* contributed equally. 
</p>
<p>Wu, M. C., Kraft, P., Epstein, M. P.,Taylor, D., M., Chanock, S. J., Hunter, D., J., and Lin, X. (2010)  Powerful SNP Set Analysis for Case-Control Genome-wide Association Studies. <em>American Journal of Human Genetics</em>, 86, 929-942.
</p>
<p>Davies R.B. (1980) Algorithm AS 155: The Distribution of a Linear
Combination of chi-2 Random Variables, <em> Journal of the Royal
Statistical Society. Series C </em>, 29, 323-333.
</p>
<p>H. Liu, Y. Tang, H.H. Zhang (2009) A new chi-square approximation
to the distribution of non-negative definite quadratic forms in
non-central normal variables, <em>Computational Statistics and Data Analysis</em>, 53, 853-856.
</p>
<p>Duchesne, P. and Lafaye De Micheaux, P. (2010) Computing the distribution of quadratic forms: Further comparisons between the Liu-Tang-Zhang approximation and exact methods, <em>Computational Statistics and Data Analysis</em>, 54, 858-862. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(SKAT.example)


#############################################################
#	SKAT with default Beta(1,25) Weights 
#		- without covariates
Z&lt;-SKAT.example$Z
# continuous trait
obj&lt;-SKAT_Null_Model(y.c ~ 1, out_type="C", data=SKAT.example)
SKAT(Z, obj)$p.value

# dichotomous trait 
obj&lt;-SKAT_Null_Model(y.b ~ 1, out_type="D", data=SKAT.example)
SKAT(Z, obj)$p.value


##################################################
#	SKAT with default Beta(1,25) Weights
#		- with covariates

# continuous trait
obj&lt;-SKAT_Null_Model(y.c ~ X, out_type="C", data=SKAT.example)
SKAT(Z, obj)$p.value

obj.b&lt;-SKAT_Null_Model(y.b ~ X, out_type="D", data=SKAT.example)
SKAT(Z, obj.b)$p.value

##################################################
#	SKAT with default Beta(1,25) Weights
#		- Optimal Test

SKAT(Z, obj, method="optimal.adj")$p.value

# you can get the same p-value by using method="SKATO"
SKAT(Z, obj, method="SKATO")$p.value

#############################################################
#	SKAT with Beta(1,30) Weights

SKAT(Z, obj, weights.beta=c(1,30))$p.value


</code></pre>

<hr>
<h2 id='SKAT_ChrX'>SNP-set (Sequence) Kernel Association Test for  X and Y chromosome variables</h2><span id='topic+SKAT_ChrX'></span><span id='topic+SKAT_ChrY'></span>

<h3>Description</h3>

<p>Test for association between a set of SNPS/genes in the X chromosome and continuous or dichotomous outcomes using the kernel machine.      
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
SKAT_ChrX(Z, obj, is_X.inact =TRUE
, kernel = "linear.weighted", method="davies", weights.beta=c(1,25)
, weights = NULL, impute.method = "fixed", r.corr=0, is_check_genotype=TRUE
, is_dosage = FALSE, missing_cutoff=0.15, max_maf=1, estimate_MAF=1, SetID=NULL)

SKAT_ChrY(Z, obj, kernel = "linear.weighted", method="davies", weights.beta=c(1,25)
, weights = NULL, impute.method = "fixed", r.corr=0, is_check_genotype=TRUE
, is_dosage = FALSE, missing_cutoff=0.15, max_maf=1, estimate_MAF=1, SetID=NULL)


 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKAT_ChrX_+3A_z">Z</code></td>
<td>
<p>a numeric genotype matrix with each row as a different individual and each column as a separate gene/snp. 
Each genotype should be coded as 0, 1, 2, and 9 (or NA) for AA, Aa, aa, and missing, where A is a major allele and a is a minor allele. 
Missing genotypes will be imputed by the simple Hardy-Weinberg equilibrium (HWE) based imputation. </p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_obj">obj</code></td>
<td>
<p>output object of the SKAT_Null_Model_ChrX function. For SKAT_ChrY, SKAT_Null_Model_ChrX function should be  used with Model.Y=TRUE</p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_is_x.inact">is_X.inact</code></td>
<td>
<p>an indicator variable for the X-inactivation coding (default=TRUE). 
Male genotypes are coded as g=(0,2) when it is TRUE, and  g=(0,1) when it is false.</p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_kernel">kernel</code></td>
<td>
<p>a type of kernel (default= &quot;linear.weighted&quot;). </p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_method">method</code></td>
<td>
<p>a method to compute the p-value (default= &quot;davies&quot;). See SKAT page for details.</p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_weights.beta">weights.beta</code></td>
<td>
<p>a numeric vector of parameters of beta weights. See SKAT page for details. </p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights for the weighted kernels. See SKAT page for details. </p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_impute.method">impute.method</code></td>
<td>
<p>a method to impute missing genotypes (default= &quot;fixed&quot;). 
&quot;fixed&quot; imputes missing genotypes by assigning the mean genotype value (2p), and &quot;bestguess&quot; uses best guess genotype values. </p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_r.corr">r.corr</code></td>
<td>
<p>the <code class="reqn">\rho</code> parameter for the compound symmetric kernel. See  SKAT page for details. </p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_is_check_genotype">is_check_genotype</code></td>
<td>
<p>a logical value indicating whether to check the validity of the genotype matrix Z (default= TRUE). See SKAT page for details.</p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_is_dosage">is_dosage</code></td>
<td>
<p>a logical value indicating whether the matrix Z is a dosage matrix. If it is TRUE, SKAT will ignore &ldquo;is_check_genotype&rdquo;. </p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_missing_cutoff">missing_cutoff</code></td>
<td>
<p>a cutoff of the missing rates of SNPs (default=0.15). Any SNPs with missing rates higher than the cutoff will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_max_maf">max_maf</code></td>
<td>
<p>a cutoff of the maximum minor allele frequencies (MAF) (default=1, no cutoff). Any SNPs with MAF &gt; cutoff will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_estimate_maf">estimate_MAF</code></td>
<td>
<p>a numeric value indicating how to estimate MAFs for the weight calculation and 
the missing genotype imputation. See SKAT page for details. </p>
</td></tr>
<tr><td><code id="SKAT_ChrX_+3A_setid">SetID</code></td>
<td>
<p>Internal use only. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of parameters, please see SKAT page.  
</p>


<h3>Value</h3>

<table>
<tr><td><code>p.value</code></td>
<td>
<p>p-value of SKAT. </p>
</td></tr>
<tr><td><code>p.value.resampling</code></td>
<td>
<p>p-values from resampled outcome. You can get it when you use obj from SKAT_Null_Model function with resampling. See the SKAT_Null_Model. </p>
</td></tr>
<tr><td><code>p.value.noadj</code></td>
<td>
<p>p-value of SKAT without the small sample adjustment. It only appears when small sample adjustment is applied.</p>
</td></tr>
<tr><td><code>p.value.noadj.resampling</code></td>
<td>
<p>p-values from resampled outcome without the small sample adjustment. It only appears when small sample adjustment is applied. </p>
</td></tr>
<tr><td><code>pval.zero.msg</code></td>
<td>
<p>(only when p.value=0) text message that shows how small the p.value is. ex. &quot;Pvalue &lt; 1.000000e-60&quot; when p.value is smaller than <code class="reqn">10^{-60}</code> </p>
</td></tr> 
<tr><td><code>Q</code></td>
<td>
<p>the test statistic of SKAT. It has NA when method=&quot;optimal.adj&quot; or &quot;optimal&quot;.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>estimated parameters of each method.</p>
</td></tr>   
<tr><td><code>param$Is_Converged</code></td>
<td>
<p> (only with method=&quot;davies&quot;) an indicator of the convergence. 
When 0 (not converged), &quot;liu&quot; method is used to compute p-value. </p>
</td></tr>  
<tr><td><code>param$n.marker</code></td>
<td>
<p>a number of SNPs in the genotype matrix</p>
</td></tr>  
<tr><td><code>param$n.marker.test</code></td>
<td>
<p>a number of SNPs used for the test. It can be different from param$n.marker when 
some markers are monomorphic or have higher missing rates than the missing_cutoff. </p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Clement Ma and Seunggeun Lee</p>


<h3>Examples</h3>

<pre><code class='language-R'>


data(SKAT.example.ChrX)
Z&lt;-SKAT.example.ChrX$Z

#############################################################
#	Compute the P-value of SKAT 

# binary trait
obj.x&lt;-SKAT_Null_Model_ChrX(y ~ x1 +x2 + Gender, 
  SexVar="Gender", out_type="D", data=SKAT.example.ChrX)

# SKAT
SKAT_ChrX(Z, obj.x, kernel = "linear.weighted")

# Burden
SKAT_ChrX(Z, obj.x, kernel = "linear.weighted", r.corr=1)

# SKAT-O
SKAT_ChrX(Z, obj.x, kernel = "linear.weighted", method="SKATO")

#############################################################
# Fit the Y chromosome function
# In this example, since male has only one copy of X (and Y), we reuse X chromosome genotype matrix.

# binary trait
obj.x&lt;-SKAT_Null_Model_ChrX(y ~ x1 +x2 + Gender, 
  SexVar="Gender", out_type="D", Model.Y=TRUE, data=SKAT.example.ChrX)

SKAT_ChrY(Z, obj.x, kernel = "linear.weighted", method="SKATO")



</code></pre>

<hr>
<h2 id='SKAT_CommonRare'>SKAT for the combined effect of common and rare variants</h2><span id='topic+SKAT_CommonRare'></span><span id='topic+SKAT_CommonRare.SSD.OneSet'></span><span id='topic+SKAT_CommonRare.SSD.OneSet_SetIndex'></span>

<h3>Description</h3>

<p>Sequence Kernel association test for the combined effect of common and rare variants.      
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
	SKAT_CommonRare(Z, obj, weights.beta.rare=c(1,25)
	, weights.beta.common=c(0.5,0.5), weights=NULL
	, method="C", r.corr.rare=0, r.corr.common=0, CommonRare_Cutoff=NULL
	, test.type="Joint", is_dosage=FALSE, missing_cutoff=0.15
	, estimate_MAF=1, SetID1=NULL)


	SKAT_CommonRare.SSD.OneSet(SSD.INFO
	, SetID, obj, ..., obj.SNPWeight=NULL)

	SKAT_CommonRare.SSD.OneSet_SetIndex(SSD.INFO
	, SetIndex, obj, ..., obj.SNPWeight=NULL )


	
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKAT_CommonRare_+3A_z">Z</code></td>
<td>
<p>a numeric genotype matrix with each row as a different individual and each column as a separate gene/snp. 
Each genotype should be coded as 0, 1, 2, and 9 (or NA) for AA, Aa, aa, and missing, where A is a major allele and a is a minor allele. 
Missing genotypes will be imputed by the simple Hardy-Weinberg equilibrium (HWE) based imputation. </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_obj">obj</code></td>
<td>
<p>an output object of the SKAT_Null_Model function. </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_weights.beta.rare">weights.beta.rare</code></td>
<td>
<p>a numeric vector of parameters of beta weights for rare variants (default=c(1,25)).</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_weights.beta.common">weights.beta.common</code></td>
<td>
<p>a numeric vector of parameters of beta weights for common variants (default=c(0.5,0.5)).</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights for both common and rare variants. When it is NULL, the beta weight with the &ldquo;weights.beta.rare&rdquo; and &ldquo;weights.beta.common&rdquo;  parameter are used. When method =&quot;C&quot;, the coefficient to combine common and rare variants test statistics will be calculated after applying the weights to variants. </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_method">method</code></td>
<td>
<p>a method to combine common and rare variant effects (default=&quot;C&quot;). &quot;C&quot; represents the combined sum test,
and &quot;A&quot; represents the adaptive sum test. &quot;AR&quot; represents a different type of adaptive test in which 
common variants are projected over rare variants. </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_r.corr.rare">r.corr.rare</code></td>
<td>
<p>the <code class="reqn">\rho</code> parameter for rare variants (default= 0). <code class="reqn">\rho</code> =0 and 1 indicate SKAT and Burden test, respectively</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_r.corr.common">r.corr.common</code></td>
<td>
<p>the <code class="reqn">\rho</code> parameter for common variants (default= 0). <code class="reqn">\rho</code> =0 and 1 indicate SKAT and Burden test, respectively</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_commonrare_cutoff">CommonRare_Cutoff</code></td>
<td>
<p>MAF cutoff for common vs rare variants (default=NULL). It should be a numeric value between 
0 and 0.5, or NULL. When it is NULL, <code class="reqn">1/ \sqrt{2 SampleSize }</code> will be used. </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_test.type">test.type</code></td>
<td>
<p>a string to indicate test type (default=&quot;Joint&quot;). &quot;Joint&quot; indicates the joint test of the 
combined effects of common and rare variants. &quot;Rare.Only&quot; and &quot;Common.Only&quot; will conduct test only with rare and common variants, 
respectively.  </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_is_dosage">is_dosage</code></td>
<td>
<p>see SKAT</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_missing_cutoff">missing_cutoff</code></td>
<td>
<p>see SKAT</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_estimate_maf">estimate_MAF</code></td>
<td>
<p>see SKAT</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_setid1">SetID1</code></td>
<td>
<p>internal use only</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_ssd.info">SSD.INFO</code></td>
<td>
<p>an SSD_INFO object returned from Open_SSD. </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_setid">SetID</code></td>
<td>
<p>a character value of Set ID. You can find a set ID of each set from SetInfo object of SSD.INFO</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_setindex">SetIndex</code></td>
<td>
<p>a numeric value of Set index. You can find a set index of each set from SetInfo object of SSD.INFO  </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_obj.snpweight">obj.SNPWeight</code></td>
<td>
<p>output object from Read_SNP_WeightFile (default=NULL). 
If NULL, the beta weight with the &ldquo;weights.beta&rdquo; parameter will be used.  </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_+3A_...">...</code></td>
<td>
<p> furthuer arguments to be passed to &ldquo;SKAT_CommonRare&rdquo; </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The small sample adjustment for binary traits is not implemented for &quot;A&quot; and &quot;AR&quot;. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>p.value</code></td>
<td>
<p>p-value. </p>
</td></tr>
<tr><td><code>p.value.resampling</code></td>
<td>
<p>p-values from resampled phenotypes. You can get it when you use obj from SKAT_Null_Model function with resampling. See the SKAT_Null_Model. </p>
</td></tr>
<tr><td><code>n.rare</code></td>
<td>
<p>the number of rare variants used for the test</p>
</td></tr>
<tr><td><code>n.common</code></td>
<td>
<p>the number of common variants used for the test</p>
</td></tr>	
<tr><td><code>Cutoff</code></td>
<td>
<p>the MAF cut-off to divide common and rare variants</p>
</td></tr>	
<tr><td><code>Q</code></td>
<td>
<p>the test statistic of SKAT. It has NA when method=&quot;A&quot; or &quot;AR&quot;.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>estimated parameters of each method.</p>
</td></tr>   
<tr><td><code>param$Is_Converged</code></td>
<td>
<p>an indicator of the convergence. 1 indicates the method is converged, and 0 indicates the method is not converged. 
When 0 (not converged), &quot;liu.mod&quot; method is used to compute p-value. </p>
</td></tr>  
<tr><td><code>param$n.marker</code></td>
<td>
<p>a number of SNPs in the genotype matrix</p>
</td></tr>  
<tr><td><code>param$n.marker.test</code></td>
<td>
<p>a number of SNPs used for the test. It can be different from param$n.marker when 
some markers are monomorphic or have higher missing rates than the missing_cutoff. </p>
</td></tr> 
<tr><td><code>test.snp.mac</code></td>
<td>
<p>a vector of minor allele count (MAC) of the snps tested. The name is SNP-ID. </p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>


<h3>References</h3>

<p>Ionita-Laza, I.*, Lee, S.*, Makarov, V., Buxbaum, J. Lin, X. (2013). 
Sequence kernel association tests for the combined effect of rare and common variants.  
<em>American Journal of Human Genetics</em>, 92, 841-853. 
* contributed equally. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(SKAT.example)
Z&lt;-SKAT.example$Z


# continuous trait
obj&lt;-SKAT_Null_Model(y.c ~ X, out_type="C", data=SKAT.example)
SKAT_CommonRare(Z, obj)$p.value
SKAT_CommonRare(Z, obj, method="A")$p.value
SKAT_CommonRare(Z, obj, method="AR")$p.value


# dichotomous trait 
obj&lt;-SKAT_Null_Model(y.b ~ X, out_type="D", data=SKAT.example)

# Combined sum test in the manuscript (SKAT-C and Burden-C)
SKAT_CommonRare(Z, obj)$p.value
SKAT_CommonRare(Z, obj, r.corr.rare=1, r.corr.common=1 )$p.value


# Test only with common variant
SKAT_CommonRare(Z, obj, test.type="Common.Only")$p.value

# Test only with rare variant
SKAT_CommonRare(Z, obj, test.type="Rare.Only")$p.value


# Use CommonRare_Cutoff=0.01 instead of CommonRare_Cutoff = NULL
SKAT_CommonRare(Z, obj, CommonRare_Cutoff=0.01)$p.value

# Use custom weights; the first 10 variants have higher weights 
weights&lt;-rep(1,67); weights[1:10]&lt;-2
SKAT_CommonRare(Z, obj, weights=weights)$p.value

</code></pre>

<hr>
<h2 id='SKAT_CommonRare_Robust'>SNP set test (both common and rare variants) for binary traits with robust region-based methods</h2><span id='topic+SKAT_CommonRare_Robust'></span><span id='topic+SKAT_CommonRare_Robust.SSD.OneSet'></span><span id='topic+SKAT_CommonRare_Robust.SSD.OneSet_SetIndex'></span>

<h3>Description</h3>

<p>This function computes p-values of robust burden test, SKAT, and SKAT-O for binary traits using SPA and ER.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
	SKAT_CommonRare_Robust(Z, obj, kernel = "linear.weighted"
	, method="SKAT", r.corr=NULL,weights.beta.rare=c(1,25)
	, weights.beta.common=c(0.5,0.5), weights = NULL
	, CommonRare_Cutoff=NULL, impute.method = "bestguess"
	, is_check_genotype=TRUE,is_dosage = FALSE, missing_cutoff=0.15
	, max_maf=1, estimate_MAF=1)

	SKAT_CommonRare_Robust.SSD.OneSet(SSD.INFO
	, SetID, obj, ..., obj.SNPWeight=NULL)

	SKAT_CommonRare_Robust.SSD.OneSet_SetIndex(SSD.INFO
	, SetIndex, obj, ..., obj.SNPWeight=NULL )
	

 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_z">Z</code></td>
<td>
<p>a numeric genotype matrix with each row as a different individual and each column as a separate gene/snp. 
Each genotype should be coded as 0, 1, 2, and 9 (or NA) for AA, Aa, aa, and missing, 
where A is a major allele and a is a minor allele. Now we support both matrix and sparse matrix. </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_obj">obj</code></td>
<td>
<p>output object from SKAT_Null_Model. </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_kernel">kernel</code></td>
<td>
<p>type of kernel (default= &quot;linear.weighted&quot;). The possible choices are &quot;linear&quot; and &quot;linear.weighted&quot;.</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_method">method</code></td>
<td>
<p>type of gene based test (default= &quot;SKAT&quot;). The possible choices are
&quot;SKAT&quot;, &quot;Burden&quot; and &quot;SKATO&quot;, which represents robust SKAT, Burden and SKAT-O tests, respectively. </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_r.corr">r.corr</code></td>
<td>
<p>the <code class="reqn">\rho</code> parameter for all variants. <code class="reqn">\rho</code> =0 and 1 indicate SKAT and Burden test, respectively.</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_weights.beta.rare">weights.beta.rare</code></td>
<td>
<p>a numeric vector of parameters of beta weights for rare variants. It is only used for weighted kernels. 
If you want to use your own  weights, please specify the &quot;weights&quot; parameter.</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_weights.beta.common">weights.beta.common</code></td>
<td>
<p>a numeric vector of parameters of beta weights for common variants. It is only used for weighted kernels. 
If you want to use your own  weights, please specify the &quot;weights&quot; parameter.</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights for the weighted kernels. See SKAT page for details.</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_commonrare_cutoff">CommonRare_Cutoff</code></td>
<td>
<p>MAF cutoff for common vs rare variants (default=NULL). It should be a numeric value between 
0 and 0.5, or NULL. When it is NULL, <code class="reqn">1/ \sqrt{2 SampleSize }</code> will be used. </p>
</td></tr>	     	     
<tr><td><code id="SKAT_CommonRare_Robust_+3A_impute.method">impute.method</code></td>
<td>
<p>a method to impute missing genotypes (default= &quot;bestguess&quot;). &quot;bestguess&quot; imputes missing genotypes as most likely 
values (0,1,2), &quot;random&quot; imputes missing genotypes by generating binomial(2,p) random variables (p is the MAF), 
and &quot;fixed&quot; imputes missing genotypes by assigning the mean genotype value (2p).</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_is_check_genotype">is_check_genotype</code></td>
<td>
<p>a logical value indicating whether to check the validity of the genotype matrix Z (default= TRUE). See SKAT page for details.</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_is_dosage">is_dosage</code></td>
<td>
<p>a logical value indicating whether the matrix Z is a dosage matrix. If it is TRUE, SKAT will ignore &ldquo;is_check_genotype&rdquo;. </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_missing_cutoff">missing_cutoff</code></td>
<td>
<p>a cutoff of the missing rates of SNPs (default=0.15). Any SNPs with missing rates higher than the cutoff will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_max_maf">max_maf</code></td>
<td>
<p>a cutoff of the maximum minor allele frequencies (MAF) (default=1, no cutoff). Any SNPs with MAF &gt; cutoff will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_estimate_maf">estimate_MAF</code></td>
<td>
<p>a numeric value indicating how to estimate MAFs for the weight calculation and 
the missing genotype imputation. See SKAT page for details. </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_ssd.info">SSD.INFO</code></td>
<td>
<p>an SSD_INFO object returned from Open_SSD. </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_setid">SetID</code></td>
<td>
<p>a character value of Set ID. You can find a set ID of each set from SetInfo object of SSD.INFO. In SKATBinary_Robust function, this parameter is for the internal use only.</p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_setindex">SetIndex</code></td>
<td>
<p>a numeric value of Set index. You can find a set index of each set from SetInfo object of SSD.INFO  </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_obj.snpweight">obj.SNPWeight</code></td>
<td>
<p>output object from Read_SNP_WeightFile (default=NULL). 
If NULL, the beta weight with the &ldquo;weights.beta&rdquo; parameter will be used.  </p>
</td></tr>
<tr><td><code id="SKAT_CommonRare_Robust_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to &ldquo;SKATBinary_Robust&rdquo; </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>p.value</code></td>
<td>
<p>p-value. It will be the p-value based on robust methods. </p>
</td></tr>
<tr><td><code>p.value_singlevariant</code></td>
<td>
<p>p-value for each single variant in this region-based test.</p>
</td></tr>
<tr><td><code>param$n.marker</code></td>
<td>
<p>a number of SNPs in the genotype matrix.</p>
</td></tr>  
<tr><td><code>param$n.marker.test</code></td>
<td>
<p>a number of SNPs used for the test. It can be different from param$n.marker when some markers are monomorphic or have higher missing rates than the missing_cutoff. </p>
</td></tr> 
<tr><td><code>param$rho</code></td>
<td>
<p>the <code class="reqn">\rho</code> parameter for all variants. </p>
</td></tr>
<tr><td><code>n.common</code></td>
<td>
<p>A number of common markers used for the test. </p>
</td></tr>
<tr><td><code>mac.common</code></td>
<td>
<p>The total minor allele count (MAC) of common markers used for the test.</p>
</td></tr>
<tr><td><code>n.rare</code></td>
<td>
<p>A number of rare markers used for the test. </p>
</td></tr>
<tr><td><code>mac.rare</code></td>
<td>
<p>The total minor allele count (MAC) of rare markers used for the test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhangchen Zhao</p>


<h3>References</h3>

<p>Zhao, Z., Bi, W., Zhou, W., VandeHaar, P., Fritsche, L. G., &amp; Lee, S. (2019). UK-Biobank Whole Exome Sequence Binary Phenome Analysis with Robust Region-based Rare Variant Test. <em>The American Journal of Human Genetics</em>, in press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(SKATBinary.example)
Z&lt;-SKATBinary.example$Z

obj&lt;-SKAT_Null_Model(y ~ x1 + x2, out_type="D", data=SKATBinary.example)

# run SKAT (default method) with Hybrid
out = SKAT_CommonRare_Robust(Z, obj)

# p-value
out$p.value

#
#	Run burden and SKAT

SKAT_CommonRare_Robust(Z, obj, method="Burden")$p.value
SKAT_CommonRare_Robust(Z, obj, method="SKAT")$p.value



</code></pre>

<hr>
<h2 id='SKAT_NULL_emmaX'>Get parameters and residuals from the null model with incorporating the kinship structure</h2><span id='topic+SKAT_NULL_emmaX'></span>

<h3>Description</h3>

<p>Compute model parameters and residuals for SKAT with incorporating the kinship structure. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
SKAT_NULL_emmaX (formula, data=NULL, K=NULL, 
Kin.File=NULL, ngrids=100, llim=-10, ulim=10, esp=1e-10, Is.GetEigenResult=FALSE) 
  
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKAT_NULL_emmaX_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;formula&rdquo;: a symbolic description of the NULL model to be fitted.</p>
</td></tr>
<tr><td><code id="SKAT_NULL_emmaX_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model (default=NULL).  If it is NULL, the variables are taken from 'environment(formula)'</p>
</td></tr>
<tr><td><code id="SKAT_NULL_emmaX_+3A_k">K</code></td>
<td>
<p>a kinship matrix. If K=NULL, the function reads Kin.File to get a kinship matrix.</p>
</td></tr>
<tr><td><code id="SKAT_NULL_emmaX_+3A_kin.file">Kin.File</code></td>
<td>
<p>an emmax-kin output file name. If K=NULL, the function reads this file. </p>
</td></tr>
<tr><td><code id="SKAT_NULL_emmaX_+3A_ngrids">ngrids</code></td>
<td>
<p>Number of grids to search for the optimal variance component</p>
</td></tr>
<tr><td><code id="SKAT_NULL_emmaX_+3A_llim">llim</code></td>
<td>
<p>Lower bound of log ratio of two variance components</p>
</td></tr>
<tr><td><code id="SKAT_NULL_emmaX_+3A_ulim">ulim</code></td>
<td>
<p>Upper bound of log ratio of two variance components</p>
</td></tr>
<tr><td><code id="SKAT_NULL_emmaX_+3A_esp">esp</code></td>
<td>
<p>Tolerance of numerical precision error</p>
</td></tr>
<tr><td><code id="SKAT_NULL_emmaX_+3A_is.geteigenresult">Is.GetEigenResult</code></td>
<td>
<p>Return intermediate eigen-decomposition results</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Emma package code was used to implement this function.
</p>
<p>Resampling is not implemented. 
</p>


<h3>Value</h3>

<p>This function returns an object that has model parameters and residuals of the NULL model of no associations. 
After obtaining it, use SKAT function to carry out the association test.
</p>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(SKAT.fam.example)

K = SKAT.fam.example$K
Z = SKAT.fam.example$Z
obj&lt;-SKAT_NULL_emmaX(y ~ X, K=K, data=SKAT.fam.example)
SKAT(Z, obj)$p.value

# SKAT-O
SKAT(Z, obj, method="optimal.adj")$p.value	

</code></pre>

<hr>
<h2 id='SKAT_Null_Model'>Get parameters and residuals from the NULL model</h2><span id='topic+SKAT_Null_Model'></span><span id='topic+SKAT_Null_Model_ChrX'></span>

<h3>Description</h3>

<p>Compute model parameters and residuals for SKAT. You also can obtain resampled residuals that can be used to compute resampling p-value or to control family-wise error rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
SKAT_Null_Model(formula, data=NULL, out_type="C", n.Resampling=0
, type.Resampling="bootstrap", Adjustment=TRUE)

SKAT_Null_Model_ChrX(formula, SexVar, data=NULL, out_type="C", n.Resampling=0
, type.Resampling="bootstrap", Adjustment=TRUE, Model.Y=FALSE)
	

 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKAT_Null_Model_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;formula&rdquo;: a symbolic description of the NULL model to be fitted.</p>
</td></tr>
<tr><td><code id="SKAT_Null_Model_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model (default=NULL).  If it is NULL, the variables are taken from 'environment(formula)'</p>
</td></tr>
<tr><td><code id="SKAT_Null_Model_+3A_out_type">out_type</code></td>
<td>
<p>an indicator of the outcome type. &quot;C&quot; for the continuous outcome and &quot;D&quot; for the dichotomous outcome.</p>
</td></tr>
<tr><td><code id="SKAT_Null_Model_+3A_n.resampling">n.Resampling</code></td>
<td>
<p>a numeric value of the number of resampling (default=0). If you don't want resampling, please set n.Resampling=0. </p>
</td></tr>
<tr><td><code id="SKAT_Null_Model_+3A_type.resampling">type.Resampling</code></td>
<td>
<p> resampling methods (default=&quot;bootstrap&quot;). see details.</p>
</td></tr>
<tr><td><code id="SKAT_Null_Model_+3A_adjustment">Adjustment</code></td>
<td>
<p>If TRUE, a small sample adjustment will be applied when the sample size &lt; 2000 and the trait is binary (default=TRUE). See details</p>
</td></tr>      
<tr><td><code id="SKAT_Null_Model_+3A_sexvar">SexVar</code></td>
<td>
<p>a sex variable name in &ldquo;formula&rdquo;.</p>
</td></tr>
<tr><td><code id="SKAT_Null_Model_+3A_model.y">Model.Y</code></td>
<td>
<p>indicator variable whether the model will be also used for ChrY. It should be TRUE if you want to use SKAT_ChrY function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 2 different methods to get resampled residuals.
&quot;bootstrap&quot; conducts the parametric bootstrap to resample residuals under the NULL model with considering covariates. 
&quot;bootstrap.fast&quot; (only for binary traits) is a fast implementation of &quot;bootstrap&quot;.
If there is no covariate, &quot;bootstrap&quot; is equivalent to the permutation method.
</p>
<p>When the trait is binary, the SKAT can produce conservative results when the sample size is small. 
To address this, we developed a small sample adjustment method, which adjusts asymptotic null distribution by estimating small sample moments. 
See also SKAT_Null_Model_MomentAdjust.
</p>
<p>Since small sample adjustment uses random sampling to estimate the kurtosis of the test statistics, SKAT with the (kurtosis-based) small sample adjustment 
can yield slightly different p-values for each run. If you want to reproduce p-values, please set a seed number 
using set.seed function in R.  
</p>
<p>We recently developed more advanced methods to get p-values for binary traits, and the methods are implemented in
SKATBinary. We recommend to use SKATBinary function instead of SKAT when your trait is binary. 
</p>


<h3>Value</h3>

<p>This function returns an object that has model parameters and residuals of the NULL model of no association between genetic variables and outcome phenotypes. 
After obtaining it, please use SKAT function to conduct the association test.
</p>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(SKAT.example)
Z&lt;-SKAT.example$Z
#############################################################
#	Compute the P-value of SKAT 

# binary trait
obj&lt;-SKAT_Null_Model(y.b ~ X, out_type="D", data=SKAT.example)
SKAT(Z, obj, kernel = "linear.weighted")$p.value


#############################################################
# 	When you have no covariate to adjust.

# binary trait
obj&lt;-SKAT_Null_Model(y.b ~ 1, out_type="D", data=SKAT.example)
SKAT(Z, obj, kernel = "linear.weighted")$p.value



#########################################################
# Small sample adjustment
IDX&lt;-c(1:100,1001:1100)

# With-adjustment
obj&lt;-SKAT_Null_Model(y.b[IDX] ~ X[IDX,],out_type="D", data=SKAT.example)
SKAT(Z[IDX,], obj, kernel = "linear.weighted")$p.value

# Without-adjustment
obj&lt;-SKAT_Null_Model(y.b[IDX] ~ X[IDX,],out_type="D", Adjustment=FALSE, data=SKAT.example)
SKAT(Z[IDX,], obj, kernel = "linear.weighted")$p.value

#########################################################
# 	Use SKATBinary 

SKATBinary(Z[IDX,], obj, kernel = "linear.weighted")$p.value


</code></pre>

<hr>
<h2 id='SKAT_Null_Model_MomentAdjust'>Get parameters and residuals from the NULL model for small sample adjustment</h2><span id='topic+SKAT_Null_Model_MomentAdjust'></span>

<h3>Description</h3>

<p>Compute model parameters and residuals for SKAT with adjusting small sample moments when the trait is binary. 
You can also obtain resampled residuals that can be used to compute resampling p-value or to control family-wise error rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
SKAT_Null_Model_MomentAdjust(formula, data=NULL, n.Resampling=0,
type.Resampling="bootstrap", is_kurtosis_adj=TRUE, n.Resampling.kurtosis=10000)

 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKAT_Null_Model_MomentAdjust_+3A_formula">formula</code></td>
<td>
<p>object of class &ldquo;formula&rdquo;: a symbolic description of the NULL model to be fitted.</p>
</td></tr>
<tr><td><code id="SKAT_Null_Model_MomentAdjust_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables in the model (default=NULL).  If it is NULL, the variables are taken from 'environment(formula)'</p>
</td></tr>
<tr><td><code id="SKAT_Null_Model_MomentAdjust_+3A_n.resampling">n.Resampling</code></td>
<td>
<p>a numeric value of the number of resampling (default=0). If you don't want resampling, please set n.Resampling=0. </p>
</td></tr>
<tr><td><code id="SKAT_Null_Model_MomentAdjust_+3A_type.resampling">type.Resampling</code></td>
<td>
<p> resampling methods (default=&quot;bootstrap&quot;). see details.</p>
</td></tr>
<tr><td><code id="SKAT_Null_Model_MomentAdjust_+3A_is_kurtosis_adj">is_kurtosis_adj</code></td>
<td>
<p> If TRUE, the kurtosis adjustment will be applied. The small sample kurtosis will be estimated using the resampled phenotypes.</p>
</td></tr>   
<tr><td><code id="SKAT_Null_Model_MomentAdjust_+3A_n.resampling.kurtosis">n.Resampling.kurtosis</code></td>
<td>
<p> a numeric value of the number of resampling for kurtosis estimation (default=10000). If is_kurtosis_ad=FALSE, it will be ignored. </p>
</td></tr>     
</table>


<h3>Details</h3>

<p>When the trait is binary, the SKAT can produce conservative results when the sample size is small. 
To address this, we developed a small sample adjustment method, which adjust asymptotic null distribution by estimating small sample variance and kurtosis. 
The small smaple variance is estimated analytically, and the small sample kurtosis is estimated using the resampling approach.
</p>
<p>There are 2 different methods to get resampled residuals.
&quot;bootstrap&quot; conducts the parametric bootstrap to resample residuals under the NULL model with considering covariates. 
&quot;bootstrap.fast&quot; (only for binary traits) is a fast implementation of &quot;bootstrap&quot;.
If there is no covariate, &quot;bootstrap&quot; is equivalent to the permutation method.
</p>
<p>Since the kurtosis is estimated using random samples, SKAT with the kurtosis-based small sample adjustment 
can yield slightly different p-values for each run. If you want to reproduce p-values, please set a seed number 
using set.seed function in R.  
</p>


<h3>Value</h3>

<p>This function returns an object that has model parameters and residuals of the NULL model of no association between genetic variants and outcome phenotypes. 
After obtaining it, please use SKAT function to conduct association tests.
</p>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(SKAT.example)
Z&lt;-SKAT.example$Z
#############################################################
#	Compute the P-value of SKAT 

IDX&lt;-c(1:100,1001:1100)

# binary trait
obj&lt;-SKAT_Null_Model_MomentAdjust(y.b[IDX] ~ X[IDX,], data=SKAT.example)
SKAT(Z[IDX,], obj, kernel = "linear.weighted")$p.value


</code></pre>

<hr>
<h2 id='SKAT.example'>Example data for SKAT</h2><span id='topic+SKAT.example'></span>

<h3>Description</h3>

<p>Example data for SKAT.
</p>


<h3>Format</h3>

<p>SKAT.example contains the following objects:
</p>

<dl>
<dt>Z</dt><dd><p>a numeric genotype matrix of 2000 individuals and 67 SNPs. 
Each row represents a different individual, and each column represents a different SNP marker. </p>
</dd>
<dt>X</dt><dd><p>a numeric matrix of 2 covariates. </p>
</dd>
<dt>y.c</dt><dd><p>a numeric vector of continuous phenotypes.</p>
</dd>
<dt>y.b</dt><dd><p>a numeric vector of binary phenotypes.</p>
</dd>
</dl>


<hr>
<h2 id='SKAT.example.ChrX'>Example data for SKAT</h2><span id='topic+SKAT.example.ChrX'></span>

<h3>Description</h3>

<p>Example data for SKAT.
</p>


<h3>Format</h3>

<p>SKAT.example contains the following objects:
</p>

<dl>
<dt>Z</dt><dd><p>a numeric genotype matrix of 2000 individuals and 52 SNPs. 
Each row represents a different individual, and each column represents a different SNP marker. </p>
</dd>
<dt>x1</dt><dd><p>a numeric vector of continuous covariates. </p>
</dd>
<dt>x2</dt><dd><p>a numeric vector of binary covariates. </p>
</dd>
<dt>Gender</dt><dd><p>a numeric vector of gender (male=1, female=2). </p>
</dd>
<dt>y</dt><dd><p>a numeric vector of binary phenotypes.</p>
</dd>
<dt>Z.A</dt><dd><p>a list object of 10 genotype matrices.</p>
</dd>
</dl>


<hr>
<h2 id='SKAT.fam.example'>Example data for SKAT_NULL_emmaX</h2><span id='topic+SKAT.fam.example'></span>

<h3>Description</h3>

<p>Example data for SKAT_emmaX.
</p>


<h3>Format</h3>

<p>Example contains the following objects:
</p>

<dl>
<dt>Z</dt><dd><p>a numeric genotype matrix 
Each row represents a different individual, and each column represents a different SNP marker. </p>
</dd>
<dt>X</dt><dd><p>a numeric matrix of covariates. </p>
</dd>
<dt>y</dt><dd><p>a numeric vector of continuous phenotypes.</p>
</dd>
<dt>K</dt><dd><p>a kinship matrix.</p>
</dd>
</dl>


<hr>
<h2 id='SKAT.haplotypes'>Haplotype dataset for power calculation</h2><span id='topic+SKAT.haplotypes'></span>

<h3>Description</h3>

<p>Haplotype dataset generated by COSI with mimicking linkage disequilibrium (LD) structure of European ancestry.
</p>


<h3>Format</h3>

<p>This list object contains the following objects:
</p>

<dl>
<dt>Haplotype</dt><dd><p>a numeric matrix of 10,000 haplotypes over 200k BP region. 
Each row represents a different haplotype, and each column represents a different SNP marker. 
It is generated by the calibration coalescent model (COSI) with mimicking LD structure of European ancestry.</p>
</dd>
<dt>SNPInfo</dt><dd><p>a dataframe of SNP information.</p>
</dd>
</dl>



<h3>References</h3>

<p>Schaffner, S.F. and Foo, C. and Gabriel, S. and Reich, D. and Daly, M.J. and Altshuler, D. (2005) Calibrating a coalescent simulation of human genome sequence variation.
<em>Genome Research</em>, 15, 1576-1583.
</p>

<hr>
<h2 id='SKAT.SSD.All'>SNP-set Kernel Association Test</h2><span id='topic+SKAT.SSD.All'></span><span id='topic+SKATBinary.SSD.All'></span><span id='topic+SKAT_CommonRare.SSD.All'></span><span id='topic+SKAT_CommonRare_Robust.SSD.All'></span><span id='topic+SKATBinary_Robust.SSD.All'></span>

<h3>Description</h3>

<p>Iteratively carry out association tests with phenotypes and SNP sets in SSD file. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
	SKAT.SSD.All(SSD.INFO, obj, ..., obj.SNPWeight=NULL)
	
	SKATBinary.SSD.All(SSD.INFO, obj, ..., obj.SNPWeight=NULL)
	
	SKATBinary_Robust.SSD.All(SSD.INFO, obj, ...,obj.SNPWeight=NULL)
	
	SKAT_CommonRare.SSD.All(SSD.INFO, obj, ..., obj.SNPWeight=NULL)

	SKAT_CommonRare_Robust.SSD.All(SSD.INFO, obj, ..., obj.SNPWeight=NULL)

 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKAT.SSD.All_+3A_ssd.info">SSD.INFO</code></td>
<td>
<p>SSD_INFO object returned from Open_SSD.   </p>
</td></tr>
<tr><td><code id="SKAT.SSD.All_+3A_obj">obj</code></td>
<td>
<p>output object from SKAT_Null_Model. </p>
</td></tr>
<tr><td><code id="SKAT.SSD.All_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to &ldquo;SKAT&rdquo; or &ldquo;SKATBinary&rdquo;. </p>
</td></tr>
<tr><td><code id="SKAT.SSD.All_+3A_obj.snpweight">obj.SNPWeight</code></td>
<td>
<p>output object from Read_SNP_WeightFile (default=NULL). 
If NULL, the beta weight with the &ldquo;weights.beta&rdquo; parameter will be used.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see SKAT or SKATBinary for details.                     
</p>


<h3>Value</h3>

<table>
<tr><td><code>results</code></td>
<td>
<p>dataframe that contains SetID, p-values (P.value), the number of markers in the SNP sets (N.Marker.All), 
and the number of markers to test for an association after excluding non-polymorphic or high missing rates markers (N.Marker.Test). 
The output dataframe from SKATBinary.SSD.All (and others)  have more columns. For example, the outcome from SKATBinary.SSD.All have columns for the method to compute p-values and the minimum achievable p-values (MAP).   </p>
</td></tr>
<tr><td><code>P.value.Resampling</code></td>
<td>
<p>the matrix that contains p-values of resampled phenotypes. </p>
</td></tr>
<tr><td><code>OUT.snp.mac</code></td>
<td>
<p>each element in the list is a vector of MAC of SNPs used in the test. The names are SNP-IDs. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>

<hr>
<h2 id='SKATBinary'>SNP set test for binary traits with asymptotic and efficient resampling methods</h2><span id='topic+SKATBinary'></span><span id='topic+SKATBinary.SSD.OneSet'></span><span id='topic+SKATBinary.SSD.OneSet_SetIndex'></span>

<h3>Description</h3>

<p>This function computes p-values of Burden test, SKAT, and SKAT-O for binary traits using asymptotic and efficient resampling methods.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
	SKATBinary(Z, obj, kernel = "linear.weighted", method="SKAT"
	, method.bin="Hybrid", weights.beta=c(1,25), weights = NULL
	, r.corr=0, impute.method = "bestguess", is_check_genotype=TRUE
	, is_dosage = FALSE, missing_cutoff=0.15, max_maf=1
	, estimate_MAF=1, N.Resampling=2 *10^6, seednum=100, epsilon=10^-6
	, SetID=NULL)
	
	SKATBinary.SSD.OneSet(SSD.INFO, SetID, obj, ... ,obj.SNPWeight=NULL)

	SKATBinary.SSD.OneSet_SetIndex(SSD.INFO, SetIndex, obj, ... ,obj.SNPWeight=NULL)


 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKATBinary_+3A_z">Z</code></td>
<td>
<p>a numeric genotype matrix with each row as a different individual and each column as a separate gene/snp. 
Each genotype should be coded as 0, 1, 2, and 9 (or NA) for AA, Aa, aa, and missing, 
where A is a major allele and a is a minor allele. </p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_obj">obj</code></td>
<td>
<p>output object from SKAT_Null_Model. </p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_kernel">kernel</code></td>
<td>
<p>type of kernel (default= &quot;linear.weighted&quot;). See SKAT page for details. </p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_method">method</code></td>
<td>
<p>type of gene based test (default= &quot;SKAT&quot;). The possible choices are
&quot;SKAT&quot;, &quot;Burden&quot; and &quot;SKATO&quot;, which represents SKAT, Burden and SKAT-O tests, respectively. 
This parameter differs from the &quot;method&quot; parameter in SKAT function. 
&quot;Burden&quot; is equivalent to method=&quot;davies&quot; and r.corr=1 and &quot;SKATO&quot; is equivalent to method=&quot;optimal.adj&quot; in the SKAT function.
When method=&quot;Burden&quot; or method=&quot;SKATO&quot;, r.corr will be ignored.</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_method.bin">method.bin</code></td>
<td>
<p>type of method to compute a p-value (default=&quot;Hybrid&quot;). Possible choices are
&quot;Hybrid&quot;, &quot;ER&quot;, &quot;ER.A&quot;, &quot;QA&quot;, &quot;MA&quot; and &quot;UA&quot;. See details</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_weights.beta">weights.beta</code></td>
<td>
<p>a numeric vector of parameters of beta weights. 
It is only used for weighted kernels. 
If you want to use your own  weights, please specify the &ldquo;weights&rdquo; parameter.</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights for the weighted kernels. See SKAT page for details.</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_impute.method">impute.method</code></td>
<td>
<p>a method to impute missing genotypes (default= &quot;bestguess&quot;). &quot;bestguess&quot; imputes missing genotypes as most likely 
values (0,1,2), &quot;random&quot; imputes missing genotypes by generating binomial(2,p) random variables (p is the MAF), 
and &quot;fixed&quot; imputes missing genotypes by assigning the mean genotype value (2p).</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_r.corr">r.corr</code></td>
<td>
<p>the <code class="reqn">\rho</code> parameter for the compound symmetric correlation structure kernel (default= 0). 
If it is a vector, SKAT will conduct the optimal test. It is ignored when method=&quot;Burden&quot; or method=&quot;SKATO&quot;.</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_is_check_genotype">is_check_genotype</code></td>
<td>
<p>a logical value indicating whether to check the validity of the genotype matrix Z (default= TRUE). See SKAT page for details.</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_is_dosage">is_dosage</code></td>
<td>
<p>a logical value indicating whether the matrix Z is a dosage matrix. If it is TRUE, SKAT will ignore &ldquo;is_check_genotype&rdquo;. </p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_missing_cutoff">missing_cutoff</code></td>
<td>
<p>a cutoff of the missing rates of SNPs (default=0.15). Any SNPs with missing rates higher than the cutoff will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_max_maf">max_maf</code></td>
<td>
<p>a cutoff of the maximum minor allele frequencies (MAF) (default=1, no cutoff). Any SNPs with MAF &gt; cutoff will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_estimate_maf">estimate_MAF</code></td>
<td>
<p>a numeric value indicating how to estimate MAFs for the weight calculation and 
the missing genotype imputation. See SKAT page for details. </p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_n.resampling">N.Resampling</code></td>
<td>
<p>a number of resampling to be conducted to get p-values (default=2 *10^6).</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_seednum">seednum</code></td>
<td>
<p>a seed number for random number generation (default=100). If NULL, no seed number will be assigned.</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_epsilon">epsilon</code></td>
<td>
<p>a precision level  (default=10^-6).</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_ssd.info">SSD.INFO</code></td>
<td>
<p>an SSD_INFO object returned from Open_SSD. </p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_setid">SetID</code></td>
<td>
<p>a character value of Set ID. You can find a set ID of each set from SetInfo object of SSD.INFO. In SKATBinary function, this parameter is for the internal use only.</p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_setindex">SetIndex</code></td>
<td>
<p>a numeric value of Set index. You can find a set index of each set from SetInfo object of SSD.INFO  </p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to &ldquo;SKATBinary&rdquo; </p>
</td></tr>
<tr><td><code id="SKATBinary_+3A_obj.snpweight">obj.SNPWeight</code></td>
<td>
<p>an output object of Read_SNP_WeightFile (default=NULL). 
If NULL, the beta weight with the &ldquo;weights.beta&rdquo; parameter will be used.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements six methods (method.bin) to compute p-values: 1) Efficient resampling (ER);
2) Quantile adjusted moment matching (QA); 3) Moment matching adjustment (MA);
4) No adjustment (UA);  5) Adaptive ER (ER.A); and 6) Hybrid. 
&quot;Hybrid&quot; selects a method based on the total minor allele count (MAC), the number of individuals with minor 
alleles (m), and the degree of case-control imbalance. When method.bin=&quot;ER&quot; or &quot;ER.A&quot;, SKATBinary compute mid-p-values and minimum achievable 
mid p-values. 
</p>
<p>If seednum is not NULL, set.seed(seednum) function is used to specify seeds to get the same p-values 
of ER based methods for different runs. Therefore, please set seednum=NULL, if you do not want to set seeds. 
</p>
<p>SKATBinary uses impute.method=&quot;bestguess&quot; as a default method for the imputation, which is different from SKAT that uses 
impute.method=&quot;fixed&quot; as a default method. We changed it because SKATBinary with impute.method=&quot;fixed&quot; can yield false positives
when variates are very rare and missing rates between cases and controls are unbalanced. 
When missing rates between cases and controls are highly unbalanced, SKAT impute.method=&quot;fixed&quot; can also yield false positives, 
but it happens less likely. So we did not change the default imputation method in SKAT.
</p>


<h3>Value</h3>

<table>
<tr><td><code>p.value</code></td>
<td>
<p>p-value. It will be the mid p-value if ER or ER.A are used to compute the p-value.</p>
</td></tr>
<tr><td><code>p.value.standard</code></td>
<td>
<p>(ER and ER.A only) standard p-value.</p>
</td></tr>
<tr><td><code>p.value.resampling</code></td>
<td>
<p>p-values from resampled outcome. You can obtain it when n.Resampling (in SKAT_Null_Model) &gt; 0. See SKAT_Null_Model page. </p>
</td></tr>
<tr><td><code>p.value.standard.resampling</code></td>
<td>
<p>(ER and ER.A only)standard p-values from resampled outcomes.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>the number of individuals with minor alleles.</p>
</td></tr>
<tr><td><code>MAP</code></td>
<td>
<p>minimum possible p-values. It is available when the method.bin=&quot;ER&quot; and m is sufficiently small.</p>
</td></tr>
<tr><td><code>MAC</code></td>
<td>
<p>total minor allele count (MAC).</p>
</td></tr>
<tr><td><code>n.total</code></td>
<td>
<p>(ER only) the number of resampling to be generated to get the p-value. 
It can be smaller than N.Resampling when the total number of configurations of case-controls among individuals with minor alleles are smaller than
N.Resampling.</p>
</td></tr>
<tr><td><code>is.accurate</code></td>
<td>
<p>logical value for the accuracy of the p-value. If it is false, more resampling is needed to accurately estimate the p-value. </p>
</td></tr>
<tr><td><code>param$n.marker</code></td>
<td>
<p>a number of SNPs in the genotype matrix</p>
</td></tr>  
<tr><td><code>param$n.marker.test</code></td>
<td>
<p>a number of SNPs used for the test. It can be different from param$n.marker when 
some markers are monomorphic or have higher missing rates than the missing_cutoff. </p>
</td></tr> 
<tr><td><code>method.bin</code></td>
<td>
<p>a type of method to be used to compute the p-value.</p>
</td></tr>
<tr><td><code>test.snp.mac</code></td>
<td>
<p>a vector of minor allele count (MAC) of the snps tested. The name is SNP-ID. </p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>


<h3>References</h3>

<p>Lee, S., Fuchsberger, C., Kim, S., Scott, L. (2015) 
An efficient resampling method for calibrating single and gene-based rare variant association analysis in case-control studies.
<em>Biostatistics</em>, in press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(SKATBinary.example)
Z&lt;-SKATBinary.example$Z

obj&lt;-SKAT_Null_Model(y ~ x1 + x2, out_type="D", data=SKATBinary.example)

# run SKAT (default method) with Hybrid
out = SKATBinary(Z, obj)

# p-value
out$p.value

# MAP
out$MAP

# method used to compute p-value (method.bin)
out$method.bin


#
#	Run burden and SKAT-O with Hybrid

SKATBinary(Z, obj, method="Burden")$p.value
SKATBinary(Z, obj, method="SKATO")$p.value

#
#	Run with SKAT-QA, -MA and -UA

SKATBinary(Z, obj, method.bin="QA")$p.value

SKATBinary(Z, obj, method.bin="MA")$p.value

SKATBinary(Z, obj, method.bin="UA")$p.value

# UA from SKAT function
SKAT(Z, obj)$p.value


#
#	Run with Adaptive ER

out =SKATBinary(Z, obj, method.bin="ER.A")

out$p.value

# the number of total resampling is smaller than 2*10^6 (default value)
out$n.total 

</code></pre>

<hr>
<h2 id='SKATBinary_Robust'>SNP set test for binary traits with robust region-based methods</h2><span id='topic+SKATBinary_Robust'></span><span id='topic+SKATBinary_Robust.SSD.OneSet'></span><span id='topic+SKATBinary_Robust.SSD.OneSet_SetIndex'></span>

<h3>Description</h3>

<p>This function computes p-values of robust burden test, SKAT, and SKAT-O for binary traits using SPA and ER.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
	SKATBinary_Robust(Z, obj, kernel = "linear.weighted", method="SKAT"
	, r.corr=NULL, weights.beta=c(1,25), weights = NULL
	, impute.method = "bestguess",  is_check_genotype=TRUE
  , is_dosage = FALSE, missing_cutoff=0.15, max_maf=1
	, estimate_MAF=1)

	SKATBinary_Robust.SSD.OneSet(SSD.INFO
	, SetID, obj, ...,obj.SNPWeight=NULL)

	SKATBinary_Robust.SSD.OneSet_SetIndex(SSD.INFO
	, SetIndex, obj, ... ,obj.SNPWeight=NULL)
	

 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKATBinary_Robust_+3A_z">Z</code></td>
<td>
<p>a numeric genotype matrix with each row as a different individual and each column as a separate gene/snp. 
Each genotype should be coded as 0, 1, 2, and 9 (or NA) for AA, Aa, aa, and missing, 
where A is a major allele and a is a minor allele. Now we support both matrix and sparse matrix. </p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_obj">obj</code></td>
<td>
<p>output object from SKAT_Null_Model. </p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_kernel">kernel</code></td>
<td>
<p>type of kernel (default= &quot;linear.weighted&quot;). The possible choices are &quot;linear&quot; and &quot;linear.weighted&quot;.</p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_method">method</code></td>
<td>
<p>type of gene based test (default= &quot;SKAT&quot;). The possible choices are
&quot;SKAT&quot;, &quot;Burden&quot; and &quot;SKATO&quot;, which represents robust SKAT, Burden and SKAT-O tests, respectively. </p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_r.corr">r.corr</code></td>
<td>
<p>the <code class="reqn">\rho</code> parameter for all variants. <code class="reqn">\rho</code> =0 and 1 indicate SKAT and Burden test, respectively.</p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_weights.beta">weights.beta</code></td>
<td>
<p>a numeric vector of parameters of beta weights. 
It is only used for weighted kernels. 
If you want to use your own  weights, please specify the &ldquo;weights&rdquo; parameter.</p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights for the weighted kernels. See SKAT page for details.</p>
</td></tr>	     	     
<tr><td><code id="SKATBinary_Robust_+3A_impute.method">impute.method</code></td>
<td>
<p>a method to impute missing genotypes (default= &quot;bestguess&quot;). &quot;bestguess&quot; imputes missing genotypes as most likely 
values (0,1,2), &quot;random&quot; imputes missing genotypes by generating binomial(2,p) random variables (p is the MAF), 
and &quot;fixed&quot; imputes missing genotypes by assigning the mean genotype value (2p).</p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_is_check_genotype">is_check_genotype</code></td>
<td>
<p>a logical value indicating whether to check the validity of the genotype matrix Z (default= TRUE). See SKAT page for details.</p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_is_dosage">is_dosage</code></td>
<td>
<p>a logical value indicating whether the matrix Z is a dosage matrix. If it is TRUE, SKAT will ignore &ldquo;is_check_genotype&rdquo;. </p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_missing_cutoff">missing_cutoff</code></td>
<td>
<p>a cutoff of the missing rates of SNPs (default=0.15). Any SNPs with missing rates higher than the cutoff will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_max_maf">max_maf</code></td>
<td>
<p>a cutoff of the maximum minor allele frequencies (MAF) (default=1, no cutoff). Any SNPs with MAF &gt; cutoff will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_estimate_maf">estimate_MAF</code></td>
<td>
<p>a numeric value indicating how to estimate MAFs for the weight calculation and 
the missing genotype imputation. See SKAT page for details. </p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_ssd.info">SSD.INFO</code></td>
<td>
<p>an SSD_INFO object returned from Open_SSD. </p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_setid">SetID</code></td>
<td>
<p>a character value of Set ID. You can find a set ID of each set from SetInfo object of SSD.INFO. In SKATBinary_Robust function, this parameter is for the internal use only.</p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_setindex">SetIndex</code></td>
<td>
<p>a numeric value of Set index. You can find a set index of each set from SetInfo object of SSD.INFO  </p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_obj.snpweight">obj.SNPWeight</code></td>
<td>
<p>output object from Read_SNP_WeightFile (default=NULL). 
If NULL, the beta weight with the &ldquo;weights.beta&rdquo; parameter will be used.  </p>
</td></tr>
<tr><td><code id="SKATBinary_Robust_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to &ldquo;SKATBinary_Robust&rdquo; </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>p.value</code></td>
<td>
<p>p-value. It will be the p-value based on robust methods. </p>
</td></tr>
<tr><td><code>p.value_singlevariant</code></td>
<td>
<p>p-value for each single variant in this region-based test.</p>
</td></tr>
<tr><td><code>mac</code></td>
<td>
<p>total minor allele count (MAC).</p>
</td></tr>
<tr><td><code>param$n.marker</code></td>
<td>
<p>a number of SNPs in the genotype matrix.</p>
</td></tr>  
<tr><td><code>param$n.marker.test</code></td>
<td>
<p>a number of SNPs used for the test. It can be different from param$n.marker when some markers are monomorphic or have higher missing rates than the missing_cutoff. </p>
</td></tr> 
<tr><td><code>param$rho</code></td>
<td>
<p>the <code class="reqn">\rho</code> parameter for all variants. </p>
</td></tr>
<tr><td><code>test.snp.mac</code></td>
<td>
<p>a vector of minor allele count (MAC) of the snps tested. The name is SNP-ID. </p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Zhangchen Zhao</p>


<h3>References</h3>

<p>Zhao, Z., Bi, W., Zhou, W., VandeHaar, P., Fritsche, L. G., &amp; Lee, S. (2019). UK-Biobank Whole Exome Sequence Binary Phenome Analysis with Robust Region-based Rare Variant Test. <em>The American Journal of Human Genetics</em>, in press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(SKATBinary.example)
Z&lt;-SKATBinary.example$Z

obj&lt;-SKAT_Null_Model(y ~ x1 + x2, out_type="D", data=SKATBinary.example)

# run SKAT (default method) with Hybrid
out = SKATBinary_Robust(Z, obj)

# p-value
out$p.value

#
#	Run burden and SKAT

SKATBinary_Robust(Z, obj, method="Burden")$p.value
SKATBinary_Robust(Z, obj, method="SKAT")$p.value



</code></pre>

<hr>
<h2 id='SKATBinary_Single'>Single variant tests for binary traits with Firth and efficient resampling methods</h2><span id='topic+SKATBinary_Single'></span>

<h3>Description</h3>

<p>This function computes p-values of single variant test using the firth and efficient resampling methods.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 
	SKATBinary_Single(Z, obj, method.bin="Hybrid"
	, impute.method = "bestguess", is_check_genotype=TRUE, is_dosage = FALSE
	, missing_cutoff=0.15, max_maf=1, estimate_MAF=1
	, N.Resampling=2*10^6, seednum=100, epsilon=10^-6)


 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKATBinary_Single_+3A_z">Z</code></td>
<td>
<p>a numeric genotype vector. Each genotype should be coded as 0, 1, 2, and 9 (or NA) for AA, Aa, aa, and missing, 
where A is a major allele and a is a minor allele. </p>
</td></tr>
<tr><td><code id="SKATBinary_Single_+3A_obj">obj</code></td>
<td>
<p>output object from SKAT_Null_Model. </p>
</td></tr>
<tr><td><code id="SKATBinary_Single_+3A_method.bin">method.bin</code></td>
<td>
<p>a type of method to compute a p-value (default=&quot;Hybrid&quot;). See details.</p>
</td></tr>
<tr><td><code id="SKATBinary_Single_+3A_impute.method">impute.method</code></td>
<td>
<p>a method to impute missing genotypes (default= &quot;bestguess&quot;). </p>
</td></tr>
<tr><td><code id="SKATBinary_Single_+3A_is_check_genotype">is_check_genotype</code></td>
<td>
<p>a logical value indicating whether to check the validity of the genotype matrix Z (default= TRUE). See SKAT page for details. </p>
</td></tr>
<tr><td><code id="SKATBinary_Single_+3A_is_dosage">is_dosage</code></td>
<td>
<p>a logical value indicating whether the matrix Z is a dosage matrix. If it is TRUE, SKAT will ignore &ldquo;is_check_genotype&rdquo;. </p>
</td></tr>
<tr><td><code id="SKATBinary_Single_+3A_missing_cutoff">missing_cutoff</code></td>
<td>
<p>a cutoff of the missing rates of SNPs (default=0.15). Any SNPs with missing rates higher than the cutoff will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="SKATBinary_Single_+3A_max_maf">max_maf</code></td>
<td>
<p>a cutoff of the maximum minor allele frequencies (MAF) (default=1, no cutoff). Any SNPs with MAF &gt; cutoff will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="SKATBinary_Single_+3A_estimate_maf">estimate_MAF</code></td>
<td>
<p>a numeric value indicating how to estimate MAFs for the weight calculation and 
the missing genotype imputation. See SKAT page for details </p>
</td></tr>
<tr><td><code id="SKATBinary_Single_+3A_n.resampling">N.Resampling</code></td>
<td>
<p>a number of resampling to be conducted to get p-values (default=2 *10^6).</p>
</td></tr>
<tr><td><code id="SKATBinary_Single_+3A_seednum">seednum</code></td>
<td>
<p>a seed number for random number generation (default=100). If NULL, no seed number will be assigned.</p>
</td></tr>
<tr><td><code id="SKATBinary_Single_+3A_epsilon">epsilon</code></td>
<td>
<p>a precision level  (default=10^-6).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements three methods (method.bin) to compute p-values: 1) Efficient resampling (ER);
2) Firth biased adjusted likelihood ratio test (Firth);  and 3) Hybrid. 
&quot;Hybrid&quot; selects a method based on the total minor allele count (MAC), the number of individuals with minor 
alleles (m), and the degree of case-control imbalance. 
</p>
<p>Adaptive ER (ER.A) is not implemented yet. 
</p>
<p>If seednum is not NULL, set.seed(seednum) function is used to specify seeds to get the same p-values 
of ER based methods for different runs. Therefore, please set seednum=NULL, if you do not want to set seeds. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>p.value</code></td>
<td>
<p>p-value. It will be the mid p-value if ER is used to compute the p-value.</p>
</td></tr>
<tr><td><code>p.value.standard</code></td>
<td>
<p>(ER only) standard p-value.</p>
</td></tr>
<tr><td><code>p.value.resampling</code></td>
<td>
<p>p-values from resampled outcome. You can obtain it when n.Resampling in SKAT_Null_Model was &gt; 0. See the SKAT_Null_Model. </p>
</td></tr>
<tr><td><code>p.value.standard.resampling</code></td>
<td>
<p>(ER only) standard p-values from resampled outcome.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>the number of individuals with minor alleles.</p>
</td></tr>
<tr><td><code>MAP</code></td>
<td>
<p>the minimum possible p-values. It is available when the method.bin=&quot;ER&quot; and m is sufficiently small.</p>
</td></tr>
<tr><td><code>MAC</code></td>
<td>
<p>the total minor allele count (MAC).</p>
</td></tr>
<tr><td><code>n.total</code></td>
<td>
<p>(ER only) the number of resampling to be generated to get the p-value. 
It can be smaller than N.Resampling when the total number of configurations of case-controls among individuals with minor alleles are smaller than
N.Resampling.</p>
</td></tr>
<tr><td><code>is.accurate</code></td>
<td>
<p>logical value for the accuracy of the p-value. If it is false, more resampling is needed to accurately estimate the p-value. </p>
</td></tr>
<tr><td><code>method.bin</code></td>
<td>
<p>a type of method to be used to compute the p-value.</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Seunggeun Lee</p>


<h3>References</h3>

<p>Lee, S., Fuchsberger, C., Kim, S., Scott, L. (2015) 
An efficient resampling method for calibrating single and gene-based rare variant association analysis in case-control studies.
<em>Biostatistics</em>, in press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(SKATBinary.example)
Z&lt;-SKATBinary.example$Z


obj&lt;-SKAT_Null_Model(y ~ x1 + x2, out_type="D", data=SKATBinary.example)
out = SKATBinary_Single(Z[,1], obj)

# p-value
out$p.value

# MAP
out$MAP

# method used to compute p-value (method.bin)
out$method.bin


#
#	Use firth method to compute p-value
SKATBinary_Single(Z[,1], obj, method.bin="Firth")$p.value

</code></pre>

<hr>
<h2 id='SKATBinary.example'>Example data for SKAT</h2><span id='topic+SKATBinary.example'></span>

<h3>Description</h3>

<p>Example data for SKAT.
</p>


<h3>Format</h3>

<p>SKAT.example contains the following objects:
</p>

<dl>
<dt>Z</dt><dd><p>a numeric genotype matrix of 2000 individuals and 11 SNPs. 
Each row represents a different individual, and each column represents a different SNP marker. </p>
</dd>
<dt>x1</dt><dd><p>a numeric vector of continuous covariates. </p>
</dd>
<dt>x2</dt><dd><p>a numeric vector of binary covariates. </p>
</dd>
<dt>y</dt><dd><p>a numeric vector of binary phenotypes.</p>
</dd>
<dt>Z.A</dt><dd><p>a list object of 30 genotype matrices.</p>
</dd>
</dl>


<hr>
<h2 id='SSD_FILE_OPEN'>Internal variables for SSD and functions for other packages</h2><span id='topic+SSD_FILE_OPEN.isOpen'></span><span id='topic+SSD_FILE_OPEN.FileName'></span><span id='topic+Get_Lambda'></span><span id='topic+Get_Liu_PVal'></span><span id='topic+SKAT_Check_Method'></span><span id='topic+SKAT_Optimal_Each_Q'></span><span id='topic+SKAT_Optimal_PValue_Davies'></span><span id='topic+SKAT_Optimal_PValue_Liu'></span><span id='topic+Get_Davies_PVal'></span>

<h3>Description</h3>

<p>Internal variable for SSD and functions for other packages
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
