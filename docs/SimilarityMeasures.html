<!DOCTYPE html><html lang="en"><head><title>Help for package SimilarityMeasures</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SimilarityMeasures}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SimilarityMeasures-package'>
<p>Implements Several Similarity Measures and Useful Functions</p></a></li>
<li><a href='#AveTranslate'>
<p>Create an Average Point Translation Vector</p></a></li>
<li><a href='#DistanceCheck'>
<p>Check if Two Points Lie Within some Distance in All Dimensions</p></a></li>
<li><a href='#DistanceSq'>
<p>Calculate the Square Distance Between Two Points</p></a></li>
<li><a href='#Dot'>
<p>Calculate the Dot Product Between Two Vectors</p></a></li>
<li><a href='#DTW'>
<p>Run the Dynamic Time Warping Algorithm on Two Trajectories</p></a></li>
<li><a href='#EditDist'>
<p>Run the Edit Distance Algorithm on Two Trajectories</p></a></li>
<li><a href='#Frechet'>
<p>Run the Frechet Calculation Algorithm on Two Trajectories</p></a></li>
<li><a href='#FrechetCheck'>
<p>Checks a Frechet Leash Distance</p></a></li>
<li><a href='#LCSS'>
<p>Run the LCSS Algorithm on Two Trajectories Allowing Translations</p></a></li>
<li><a href='#LCSSCalc'>
<p>Run the LCSS Algorithm on Two Trajectories Without Translations</p></a></li>
<li><a href='#LCSSRatio'>
<p>Find the LCSS Ratio using Two Trajectories Allowing Translations</p></a></li>
<li><a href='#LCSSRatioCalc'>
<p>Find the LCSS Ratio using Two Trajectories Without Translations</p></a></li>
<li><a href='#LCSSTranslation'>
<p>Create a Translation Vector Using LCSS</p></a></li>
<li><a href='#SimLoop'>
<p>Loop Over and Test Trajectories With Different Translations</p></a></li>
<li><a href='#SinglePointCalc'>
<p>Calculate Frechet Distance With a Single Point Trajectory</p></a></li>
<li><a href='#StartEndTranslate'>
<p>Translate a Trajectory Based on Start and End Points</p></a></li>
<li><a href='#TrajCheck'>
<p>Checking Two Trajectories are Matrices of N Dimensional Points</p></a></li>
<li><a href='#TranslationSubset'>
<p>Calculate the Subset of Translations for LCSS</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Trajectory Similarity Measures</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-02-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Toohey</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Toohey &lt;kevintoohey@live.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to run and assist four
  different similarity measures. The similarity
  measures included are: longest common
  subsequence (LCSS), Frechet distance, edit distance
  and dynamic time warping (DTW). Each of these
  similarity measures can be calculated from two
  n-dimensional trajectories, both in matrix form.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-02-06 02:29:48 UTC; Awesome</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-02-06 06:19:21</td>
</tr>
</table>
<hr>
<h2 id='SimilarityMeasures-package'>
Implements Several Similarity Measures and Useful Functions
</h2><span id='topic+SimilarityMeasures-package'></span><span id='topic+SimilarityMeasures'></span>

<h3>Description</h3>

<p>This package contains functions to run and assist four different similarity measures. The similarity measures included are: longest common subsequence (LCSS), Frechet distance, edit distance and dynamic time warping (DTW). Each of these similarity measures can be calculated from two n-dimensional trajectories, both in matrix form.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SimilarityMeasures</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-02-06</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Kevin Toohey
</p>
<p>Maintainer: Kevin Toohey &lt;kevintoohey@live.com&gt;
</p>


<h3>References</h3>

<p>Alt, H. and Godau, M. (1995) Computing the Frechet distance between two polygonal curves. <em>International Journal of Computational Geometry &amp; Applications</em>, <b>5(01n02)</b>, 75&ndash;91.
</p>
<p>Berndt, D. and Clifford, J. (1994) Using Dynamic Time Warping to Find Patterns in Time Series. Paper presented at the KDD workshop.
</p>
<p>Chen, L., Ozsu, M. T. and Oria, V. (2005) Robust and fast similarity search for moving object trajectories. Paper presented at the Proceedings of the 2005 ACM SIGMOD international conference on Management of data, Baltimore, Maryland.
</p>
<p>Vlachos, M., Kollios, G. and Gunopulos, D. (2002) Discovering similar multidimensional trajectories. Paper presented at the Data Engineering, 2002. Proceedings. 18th International Conference on.
</p>

<hr>
<h2 id='AveTranslate'>
Create an Average Point Translation Vector
</h2><span id='topic+AveTranslate'></span>

<h3>Description</h3>

<p>A function to calculate a translation vector for trajectory2 using the average of the two trajectories.  The vector created can be used to translate the average of trajectory2's points to that of trajectory1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AveTranslate(traj1, traj2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AveTranslate_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="AveTranslate_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average of each dimension of both trajectories is calculated.  The required translation is then calculated from the difference between them.
</p>


<h3>Value</h3>

<p>A vector of length n is returned containing the translation in each dimension.  If there is a problem this returns a string of information instead.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LCSSTranslation">LCSSTranslation</a></code>, <code><a href="#topic+StartEndTranslate">StartEndTranslate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the translation.
AveTranslate(path1, path2)
</code></pre>

<hr>
<h2 id='DistanceCheck'>
Check if Two Points Lie Within some Distance in All Dimensions
</h2><span id='topic+DistanceCheck'></span>

<h3>Description</h3>

<p>A function to check whether two points lie within some distance in every dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistanceCheck(point1, point2, dist, dimensions=length(point1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DistanceCheck_+3A_point1">point1</code></td>
<td>

<p>An n dimensional vector representing point1.
</p>
</td></tr>
<tr><td><code id="DistanceCheck_+3A_point2">point2</code></td>
<td>

<p>An n dimensional vector representing point2.
</p>
</td></tr>
<tr><td><code id="DistanceCheck_+3A_dist">dist</code></td>
<td>

<p>A floating point number representing the maximum distance in each dimension allowed for points to be considered equivalent.
</p>
</td></tr>
<tr><td><code id="DistanceCheck_+3A_dimensions">dimensions</code></td>
<td>

<p>An integer representing the number of dimensions being checked.  This defaults to the length of the first vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean value is returned.  The value is true if the points are within the distance in every dimension and false if not.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two points.
point1 &lt;- c(0, 2, 4, 6)
point2 &lt;- c(0, 1, 2, 3)

# Running the check with distances 1 and 3 in 4 dimensions.
DistanceCheck(point1, point2, 1, 4)
DistanceCheck(point1, point2, 3, 4)
</code></pre>

<hr>
<h2 id='DistanceSq'>
Calculate the Square Distance Between Two Points
</h2><span id='topic+DistanceSq'></span>

<h3>Description</h3>

<p>A function to calculate the square of the distance between two points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistanceSq(point1, point2, dimensions=length(point1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DistanceSq_+3A_point1">point1</code></td>
<td>

<p>An n dimensional vector representing point1.
</p>
</td></tr>
<tr><td><code id="DistanceSq_+3A_point2">point2</code></td>
<td>

<p>An n dimensional vector representing point2.
</p>
</td></tr>
<tr><td><code id="DistanceSq_+3A_dimensions">dimensions</code></td>
<td>

<p>An integer representing the number of dimensions being used for the distance square calculation.  This defaults to the length of the first vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A floating point value is returned, representing the square of the distance between the two points.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two points.
point1 &lt;- c(0, 2, 4, 6)
point2 &lt;- c(0, 1, 2, 3)

# Calculating the square distance between the two points 
# in 4 dimensions.
DistanceSq(point1, point2, 4)
</code></pre>

<hr>
<h2 id='Dot'>
Calculate the Dot Product Between Two Vectors
</h2><span id='topic+Dot'></span>

<h3>Description</h3>

<p>A function to calculate the dot product between two vectors.  This is used in the Frechet algorithm and does not need to be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dot(vect1, vect2, dimensions=length(vect1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dot_+3A_vect1">vect1</code></td>
<td>

<p>An n dimensional vector representing the first vector.
</p>
</td></tr>
<tr><td><code id="Dot_+3A_vect2">vect2</code></td>
<td>

<p>An n dimensional vector representing the second vector.
</p>
</td></tr>
<tr><td><code id="Dot_+3A_dimensions">dimensions</code></td>
<td>

<p>An integer representing the number of dimensions being used for the dot product calculation.  This defaults to the length of the first vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by the <code><a href="#topic+Frechet">Frechet</a></code> function.
</p>


<h3>Value</h3>

<p>A floating point value is returned, representing the dot product between the two vectors.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>

<hr>
<h2 id='DTW'>
Run the Dynamic Time Warping Algorithm on Two Trajectories
</h2><span id='topic+DTW'></span>

<h3>Description</h3>

<p>A function to calculate the dynamic time warping value between two trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DTW(traj1, traj2, pointSpacing=-1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DTW_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="DTW_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
<tr><td><code id="DTW_+3A_pointspacing">pointSpacing</code></td>
<td>

<p>An integer value of the maximum index difference between trajectory1 and trajectory2 allowed in the calculation.  A negative value sets the point spacing to unlimited.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dynamic time warping algorithm (DTW) calculates the smallest warp path for the two trajectories.  This is the DTW version discussed by Berndt &amp; Clifford (1994).  Several variations of calculating the warping cost exist.  In this version, the warping path is equal to the sum of the distances at each point along the path.  Please see the references for more information.
</p>


<h3>Value</h3>

<p>A floating point value representing the smallest warp path is returned.  If a problem occurs, then a string containing information about the problem is returned.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>References</h3>

<p>Berndt, D. and Clifford, J. (1994) Using Dynamic Time Warping to Find Patterns in Time Series. Paper presented at the KDD workshop.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the dynamic time warping algorithm with point spacing 
# set to 4.
DTW(path1, path2, 4)
</code></pre>

<hr>
<h2 id='EditDist'>
Run the Edit Distance Algorithm on Two Trajectories
</h2><span id='topic+EditDist'></span>

<h3>Description</h3>

<p>A function to calculate the edit distance between two trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EditDist(traj1, traj2, pointDistance=20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EditDist_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="EditDist_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
<tr><td><code id="EditDist_+3A_pointdistance">pointDistance</code></td>
<td>

<p>A floating point number representing the maximum distance in each dimension allowed for points to be considered equivalent.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The edit distance algorithm calculates the minimum number of edits required to allow the two trajectories to be considered equivalent.  This function uses Edit Distance on Real sequence (EDR) as described by Chen et al. (2005).  Please see the references for more information.
</p>


<h3>Value</h3>

<p>An integer representing the minimum number of edits required is returned.  If a problem occurs, then a string containing information about the problem is returned.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>References</h3>

<p>Chen, L., Ozsu, M. T. and Oria, V. (2005) Robust and fast similarity search for moving object trajectories. Paper presented at the Proceedings of the 2005 ACM SIGMOD international conference on Management of data, Baltimore, Maryland. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the edit distance algorithm with point distance 
# set to 2.
EditDist(path1, path2, 2)
</code></pre>

<hr>
<h2 id='Frechet'>
Run the Frechet Calculation Algorithm on Two Trajectories
</h2><span id='topic+Frechet'></span>

<h3>Description</h3>

<p>A function to calculate the Frechet distance between two trajectories.  The function can also be used to test leash values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Frechet(traj1, traj2, testLeash=-1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Frechet_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="Frechet_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
<tr><td><code id="Frechet_+3A_testleash">testLeash</code></td>
<td>

<p>A numeric leash value, which if positive, checks whether the leash can be used between the two trajectories.  If this value is negative, then it is not used and the standard calculation is performed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm calculates the Frechet distance.  The Frechet metric (or distance) is generally described in the following way: A man is walking a dog on a leash, the man walks on one curve while the dog walks on the other (Alt &amp; Godau, 1995).  The dog and the man are able to vary their speeds, or even stop, but not go backwards.  The Frechet metric is the minimum leash length required to complete the traversal of both curves.  Please see the references for more information.
</p>


<h3>Value</h3>

<p>A floating point value representing the Frechet distance is returned.  If a test leash is given, then a boolean value is returned as true if the leash was successful and false if not.  If a problem occurs, then a string containing information about the problem is returned.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>References</h3>

<p>Alt, H. and Godau, M. (1995) Computing the Frechet distance between two polygonal curves. <em>International Journal of Computational Geometry &amp; Applications</em>, <b>5(01n02)</b>, 75&ndash;91.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the Frechet distance algorithm.
Frechet(path1, path2)
</code></pre>

<hr>
<h2 id='FrechetCheck'>
Checks a Frechet Leash Distance
</h2><span id='topic+FrechetCheck'></span>

<h3>Description</h3>

<p>A function to check whether a Frechet leash distance is successful or not.  This is used by the Frechet calculation and does not need to be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FrechetCheck(traj1, traj2, leash, dist1, dist2, distSq12)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FrechetCheck_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="FrechetCheck_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
<tr><td><code id="FrechetCheck_+3A_leash">leash</code></td>
<td>

<p>A numeric leash value to be checked by the function.
</p>
</td></tr>
<tr><td><code id="FrechetCheck_+3A_dist1">dist1</code></td>
<td>

<p>A vector containing the distance between each successive two points in trajectory1.
</p>
</td></tr>
<tr><td><code id="FrechetCheck_+3A_dist2">dist2</code></td>
<td>

<p>A vector containing the distance between each successive two points in trajectory2.
</p>
</td></tr>
<tr><td><code id="FrechetCheck_+3A_distsq12">distSq12</code></td>
<td>

<p>A matrix containing the distance between each pair of two points where 1 point lies in trajectory1 and the other in trajectory2.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is required by <code><a href="#topic+Frechet">Frechet</a></code> and in general does not need to be called directly.
</p>


<h3>Value</h3>

<p>A boolean value is returned.  A value of true is returned if the leash is successful and false if not.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>References</h3>

<p>Alt, H. and Godau, M. (1995) Computing the Frechet distance between two polygonal curves. <em>International Journal of Computational Geometry &amp; Applications</em>, <b>5(01n02)</b>, 75&ndash;91.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Frechet">Frechet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the Frechet distance algorithm with a test leash of 2.
Frechet(path1, path2, 2)
</code></pre>

<hr>
<h2 id='LCSS'>
Run the LCSS Algorithm on Two Trajectories Allowing Translations
</h2><span id='topic+LCSS'></span>

<h3>Description</h3>

<p>A function to calculate the longest common subsequence between two trajectories.  This calculation automatically uses translations to find the largest value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCSS(traj1, traj2, pointSpacing=-1, pointDistance=20, 
     errorMarg=2, returnTrans=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCSS_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="LCSS_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
<tr><td><code id="LCSS_+3A_pointspacing">pointSpacing</code></td>
<td>

<p>An integer value of the maximum index difference between trajectory1 and trajectory2 allowed in the calculation.  A negative value sets the point spacing to unlimited.
</p>
</td></tr>
<tr><td><code id="LCSS_+3A_pointdistance">pointDistance</code></td>
<td>

<p>A floating point number representing the maximum distance in each dimension allowed for points to be considered equivalent.
</p>
</td></tr>
<tr><td><code id="LCSS_+3A_errormarg">errorMarg</code></td>
<td>

<p>A floating point error margin used to scale the accuracy and speed of the calculation.
</p>
</td></tr>
<tr><td><code id="LCSS_+3A_returntrans">returnTrans</code></td>
<td>

<p>A boolean value to allow the best translation found to be returned as well as the LCSS value if set to true.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LCSS algorithm calculates the largest number of equivalent points between the two trajectories when traversed in a monotone way.  Possible translations are calculated in each dimension and used to provide the maximum LCSS.  The accuracy of the algorithm can be varied to provide faster or slower calculations.  Please see the references for more information.
</p>


<h3>Value</h3>

<p>An integer value is returned.  This represents the maximum LCSS value obtained using the variables provided.  If returnTrans is set to TRUE, then the LCSS value and the translations are returned as a vector.  The first value of this vector is the LCSS value and the translations follow directly afterwards.  If a problem occurs, then a string containing information about the problem is returned.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>References</h3>

<p>Vlachos, M., Kollios, G. and Gunopulos, D. (2002) Discovering similar multidimensional trajectories. Paper presented at the Data Engineering, 2002. Proceedings. 18th International Conference on.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LCSSCalc">LCSSCalc</a></code>, <code><a href="#topic+LCSSRatio">LCSSRatio</a></code>, <code><a href="#topic+LCSSRatioCalc">LCSSRatioCalc</a></code>, <code><a href="#topic+LCSSTranslation">LCSSTranslation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the LCSS algorithm on the trajectories.
LCSS(path1, path2, 2, 2, 0.5)

# Running the LCSS algorithm on the trajectories
# and returning the translation as well.
LCSS(path1, path2, 2, 2, 0.5, TRUE)
</code></pre>

<hr>
<h2 id='LCSSCalc'>
Run the LCSS Algorithm on Two Trajectories Without Translations
</h2><span id='topic+LCSSCalc'></span>

<h3>Description</h3>

<p>A function to calculate the longest common subsequence between two trajectories.  This function does not calculate translations and only uses the given trajectories and optional translation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCSSCalc(traj1, traj2, pointSpacing=-1, pointDistance=20, 
         trans=rep(0, (dim(traj1)[2])))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCSSCalc_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="LCSSCalc_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
<tr><td><code id="LCSSCalc_+3A_pointspacing">pointSpacing</code></td>
<td>

<p>An integer value of the maximum index difference between trajectory1 and trajectory2 allowed in the calculation.  A negative value sets the point spacing to unlimited.
</p>
</td></tr>
<tr><td><code id="LCSSCalc_+3A_pointdistance">pointDistance</code></td>
<td>

<p>A floating point number representing the maximum distance in each dimension allowed for points to be considered equivalent.
</p>
</td></tr>
<tr><td><code id="LCSSCalc_+3A_trans">trans</code></td>
<td>

<p>A vector containing translations in each dimension to be applied to trajectory2 in this calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LCSS algorithm calculates the largest number of equivalent points between the two trajectories when traversed in a monotone way.  If a translation is given then this is applied before the calculation is done.  This function is used by all of the the LCSS functions.  Please see the references for more information.
</p>


<h3>Value</h3>

<p>An integer value is returned.  This represents the maximum LCSS value obtained using the variables provided.  If a problem occurs, then a string containing information about the problem is returned.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>References</h3>

<p>Vlachos, M., Kollios, G. and Gunopulos, D. (2002) Discovering similar multidimensional trajectories. Paper presented at the Data Engineering, 2002. Proceedings. 18th International Conference on.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LCSS">LCSS</a></code>, <code><a href="#topic+LCSSRatio">LCSSRatio</a></code>, <code><a href="#topic+LCSSRatioCalc">LCSSRatioCalc</a></code>, <code><a href="#topic+LCSSTranslation">LCSSTranslation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the LCSS algorithm on the trajectories.
LCSSCalc(path1, path2, 2, 2, c(0, 3))
</code></pre>

<hr>
<h2 id='LCSSRatio'>
Find the LCSS Ratio using Two Trajectories Allowing Translations
</h2><span id='topic+LCSSRatio'></span>

<h3>Description</h3>

<p>A function to calculate the longest common subsequence ratio using two trajectories.  This calculation automatically uses translations to find the largest value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCSSRatio(traj1, traj2, pointSpacing=-1, pointDistance=20, 
          errorMarg=2, returnTrans=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCSSRatio_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="LCSSRatio_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
<tr><td><code id="LCSSRatio_+3A_pointspacing">pointSpacing</code></td>
<td>

<p>An integer value of the maximum index difference between trajectory1 and trajectory2 allowed in the calculation.  A negative value sets the point spacing to unlimited.
</p>
</td></tr>
<tr><td><code id="LCSSRatio_+3A_pointdistance">pointDistance</code></td>
<td>

<p>A floating point number representing the maximum distance in each dimension allowed for points to be considered equivalent.
</p>
</td></tr>
<tr><td><code id="LCSSRatio_+3A_errormarg">errorMarg</code></td>
<td>

<p>A floating point error margin used to scale the accuracy and speed of the calculation.
</p>
</td></tr>
<tr><td><code id="LCSSRatio_+3A_returntrans">returnTrans</code></td>
<td>

<p>A boolean value to allow the best translation found to be returned as well as the LCSS value if set to true.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LCSS algorithm calculates the largest number of equivalent points between the two trajectories when traversed in a monotone way.  The ratio of this value to the smallest number of points out of the two trajectories is then calculated.  Possible translations are calculated in each dimension and used to provide the maximum LCSS.  The accuracy of the algorithm can be varied to provide faster or slower calculations.  Please see the references for more information.
</p>


<h3>Value</h3>

<p>A floating point value is returned.  This represents the maximum LCSS ratio obtained using the variables provided.  If returnTrans is set to TRUE, then the LCSS ratio and the translations are returned as a vector.  The first value of this vector is the LCSS ratio and the translations follow directly afterwards.  If a problem occurs, then a string containing information about the problem is returned.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>References</h3>

<p>Vlachos, M., Kollios, G. and Gunopulos, D. (2002) Discovering similar multidimensional trajectories. Paper presented at the Data Engineering, 2002. Proceedings. 18th International Conference on.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LCSSCalc">LCSSCalc</a></code>, <code><a href="#topic+LCSS">LCSS</a></code>, <code><a href="#topic+LCSSRatioCalc">LCSSRatioCalc</a></code>, <code><a href="#topic+LCSSTranslation">LCSSTranslation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the LCSS ratio algorithm on the trajectories.
LCSSRatio(path1, path2, 2, 2, 0.5)

# Running the LCSS ratio algorithm on the trajectories
# and returning the translation as well.
LCSSRatio(path1, path2, 2, 2, 0.5, TRUE)
</code></pre>

<hr>
<h2 id='LCSSRatioCalc'>
Find the LCSS Ratio using Two Trajectories Without Translations
</h2><span id='topic+LCSSRatioCalc'></span>

<h3>Description</h3>

<p>A function to calculate the longest common subsequence ratio using two trajectories.  This function does not calculate translations and only uses the given trajectories and optional translation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCSSRatioCalc(traj1, traj2, pointSpacing=-1, pointDistance=20, 
              trans=rep(0.0, (dim(traj1)[2])))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCSSRatioCalc_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="LCSSRatioCalc_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
<tr><td><code id="LCSSRatioCalc_+3A_pointspacing">pointSpacing</code></td>
<td>

<p>An integer value of the maximum index difference between trajectory1 and trajectory2 allowed in the calculation.  A negative value sets the point spacing to unlimited.
</p>
</td></tr>
<tr><td><code id="LCSSRatioCalc_+3A_pointdistance">pointDistance</code></td>
<td>

<p>A floating point number representing the maximum distance in each dimension allowed for points to be considered equivalent.
</p>
</td></tr>
<tr><td><code id="LCSSRatioCalc_+3A_trans">trans</code></td>
<td>

<p>A vector containing translations in each dimension to be applied to trajectory2 in this calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LCSS algorithm calculates the largest number of equivalent points between the two trajectories when traversed in a monotone way.  The ratio of this value to the smallest number of points out of the two trajectories is then calculated.  If a translation is given then this is applied before the calculation is done.  Please see the references for more information.
</p>


<h3>Value</h3>

<p>A floating point value is returned.  This represents the maximum LCSS ratio obtained using the variables provided.  If a problem occurs, then a string containing information about the problem is returned.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>References</h3>

<p>Vlachos, M., Kollios, G. and Gunopulos, D. (2002) Discovering similar multidimensional trajectories. Paper presented at the Data Engineering, 2002. Proceedings. 18th International Conference on.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LCSS">LCSS</a></code>, <code><a href="#topic+LCSSRatio">LCSSRatio</a></code>, <code><a href="#topic+LCSSCalc">LCSSCalc</a></code>, <code><a href="#topic+LCSSTranslation">LCSSTranslation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the LCSS ratio algorithm on the trajectories.
LCSSRatioCalc(path1, path2, 2, 2, c(0, 3))
</code></pre>

<hr>
<h2 id='LCSSTranslation'>
Create a Translation Vector Using LCSS
</h2><span id='topic+LCSSTranslation'></span>

<h3>Description</h3>

<p>A function to return the best translation calculated using the LCSS method.  The vector created can be used to translate trajectory2's points to the position of the maximum LCSS found with trajectory1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCSSTranslation(traj1, traj2, pointSpacing=-1, pointDistance=20, 
                errorMarg=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCSSTranslation_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="LCSSTranslation_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
<tr><td><code id="LCSSTranslation_+3A_pointspacing">pointSpacing</code></td>
<td>

<p>An integer value of the maximum index difference between trajectory1 and trajectory2 allowed in the calculation.  A negative value sets the point spacing to unlimited.
</p>
</td></tr>
<tr><td><code id="LCSSTranslation_+3A_pointdistance">pointDistance</code></td>
<td>

<p>A floating point number representing the maximum distance in each dimension allowed for points to be considered equivalent.
</p>
</td></tr>
<tr><td><code id="LCSSTranslation_+3A_errormarg">errorMarg</code></td>
<td>

<p>A floating point error margin used to scale the accuracy and speed of the calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LCSS function is called using the two trajectories along with the given variables.  The optimal translation vector is then returned from this result.  Please see the references for more information.
</p>


<h3>Value</h3>

<p>A vector of length n is returned containing the translation in each dimension.  If a problem occurs, then a string containing information about the problem is returned.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>References</h3>

<p>Vlachos, M., Kollios, G. and Gunopulos, D. (2002) Discovering similar multidimensional trajectories. Paper presented at the Data Engineering, 2002. Proceedings. 18th International Conference on.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AveTranslate">AveTranslate</a></code>, <code><a href="#topic+StartEndTranslate">StartEndTranslate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the translation.
LCSSTranslation(path1, path2, 1, 1, 0.5)
</code></pre>

<hr>
<h2 id='SimLoop'>
Loop Over and Test Trajectories With Different Translations
</h2><span id='topic+SimLoop'></span>

<h3>Description</h3>

<p>Function to loop over and test the trajectories using the different translations in each dimension.  This is used by the LCSS function to test all of the n dimensional translations.  Do not call this function directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimLoop(traj1, traj2, pointSpacing, pointDistance, spacing, 
        similarity, translations, dimensions, 
        dimLeft=dimensions, currentTrans=rep(0, dimensions))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimLoop_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="SimLoop_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
<tr><td><code id="SimLoop_+3A_pointspacing">pointSpacing</code></td>
<td>

<p>An integer value of the maximum index difference between trajectory1 and trajectory2 allowed in the calculation.
</p>
</td></tr>
<tr><td><code id="SimLoop_+3A_pointdistance">pointDistance</code></td>
<td>

<p>A floating point number representing the maximum distance in each dimension allowed for points to be considered equivalent.
</p>
</td></tr>
<tr><td><code id="SimLoop_+3A_spacing">spacing</code></td>
<td>

<p>The integer spacing between each translation that will be tested.
</p>
</td></tr>
<tr><td><code id="SimLoop_+3A_similarity">similarity</code></td>
<td>

<p>A vector containing the current best similarity and translations calculated.
</p>
</td></tr>
<tr><td><code id="SimLoop_+3A_translations">translations</code></td>
<td>

<p>A list of vectors containing the translations in each dimension.
</p>
</td></tr>
<tr><td><code id="SimLoop_+3A_dimensions">dimensions</code></td>
<td>

<p>An integer representing the number of dimensions being used for the calculation.
</p>
</td></tr>
<tr><td><code id="SimLoop_+3A_dimleft">dimLeft</code></td>
<td>

<p>An integer number of dimensions which have not been looped over yet.
</p>
</td></tr>
<tr><td><code id="SimLoop_+3A_currenttrans">currentTrans</code></td>
<td>

<p>A vector containing the current translation being tested.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to loop over the n dimensions for the <code><a href="#topic+LCSS">LCSS</a></code> function.  This function should not be called directly.
</p>


<h3>Value</h3>

<p>Returns the current best LCSS value and the translations that created this as a vector.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LCSS">LCSS</a></code>, <code><a href="#topic+LCSSRatio">LCSSRatio</a></code>, <code><a href="#topic+LCSSRatioCalc">LCSSRatioCalc</a></code>, <code><a href="#topic+LCSSTranslation">LCSSTranslation</a></code>, <code><a href="#topic+LCSSCalc">LCSSCalc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the LCSS algorithm on the trajectories.
LCSS(path1, path2, 2, 2, 0.5)
</code></pre>

<hr>
<h2 id='SinglePointCalc'>
Calculate Frechet Distance With a Single Point Trajectory
</h2><span id='topic+SinglePointCalc'></span>

<h3>Description</h3>

<p>A function to calculate the Frechet distance between two trajectories.  This function is called by the frechet function when one trajectory consists of a single point.  This function does not need to be directly called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SinglePointCalc(traj1, traj2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SinglePointCalc_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="SinglePointCalc_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calculates the longest distance to the single point trajectory.  This is the Frechet distance for such a pair of trajectories.  This function is automatically called if required by the <code><a href="#topic+Frechet">Frechet</a></code> function, therefore it does not need to be called directly.
</p>


<h3>Value</h3>

<p>A floating point value representing the Frechet distance is returned.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Frechet">Frechet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1), 1)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the Frechet distance algorithm which will
# automatically call this function.
Frechet(path1, path2)
</code></pre>

<hr>
<h2 id='StartEndTranslate'>
Translate a Trajectory Based on Start and End Points
</h2><span id='topic+StartEndTranslate'></span>

<h3>Description</h3>

<p>A function to translate, rotate and scale the points of trajectory2 using trajectory1.  The new trajectory will have the same start and end points as trajectory1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StartEndTranslate(traj1, traj2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StartEndTranslate_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="StartEndTranslate_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every point of trajectory2 is rotated, scaled and translated so that the start and end points of the two trajectories match.  The new variation of trajectory2 is returned as a matrix. 
</p>


<h3>Value</h3>

<p>An m x n matrix containing the new variation of trajectory2 is returned.  Here m is the number of points and n is the dimension of the points.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LCSSTranslation">LCSSTranslation</a></code>, <code><a href="#topic+AveTranslate">AveTranslate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)

# Running the translation.
StartEndTranslate(path1, path2)
</code></pre>

<hr>
<h2 id='TrajCheck'>
Checking Two Trajectories are Matrices of N Dimensional Points
</h2><span id='topic+TrajCheck'></span>

<h3>Description</h3>

<p>This function checks whether two trajectories are compatible with the functions provided.  They are first checked if they are represented as matrices.  They are then checked to ensure that points in both trajectories have the same dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrajCheck(traj1, traj2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TrajCheck_+3A_traj1">traj1</code></td>
<td>

<p>An m x n matrix containing trajectory1.  Here m is the number of points and n is the dimension of the points.
</p>
</td></tr>
<tr><td><code id="TrajCheck_+3A_traj2">traj2</code></td>
<td>

<p>A k x n matrix containing trajectory2.  Here k is the number of points and n is the dimension of the points.  The two trajectories are not required to have the same number of points.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for determining if the trajectories are compatible with the many functions provided.  This function is performed at the start of most other functions to ensure that no major errors can occur and that the results make sense.
</p>


<h3>Value</h3>

<p>If there is a problem with one of the checks then a string containing information is returned.  If all of the checks pass then -1 is returned.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two trajectories.
path1 &lt;- matrix(c(0, 1, 2, 3, 0, 1, 2, 3), 4)
path2 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 4)
path3 &lt;- matrix(c(0, 1, 2, 3, 4, 5, 6, 7), 2)

# Running the trajectory check on the trajectories.
TrajCheck(path1, path2)
TrajCheck(path1, path3)
</code></pre>

<hr>
<h2 id='TranslationSubset'>
Calculate the Subset of Translations for LCSS
</h2><span id='topic+TranslationSubset'></span>

<h3>Description</h3>

<p>A function for calculating the subsets of translations to be tested using the LCSS methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TranslationSubset(traj1, traj2, pointSpacing, pointDistance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TranslationSubset_+3A_traj1">traj1</code></td>
<td>

<p>A vector containing one dimension of trajectory1.
</p>
</td></tr>
<tr><td><code id="TranslationSubset_+3A_traj2">traj2</code></td>
<td>

<p>A vector containing one dimension of trajectory2.
</p>
</td></tr>
<tr><td><code id="TranslationSubset_+3A_pointspacing">pointSpacing</code></td>
<td>

<p>An integer value of the maximum index difference between trajectory1 and trajectory2 allowed in the calculation.
</p>
</td></tr>
<tr><td><code id="TranslationSubset_+3A_pointdistance">pointDistance</code></td>
<td>

<p>A floating point number representing the maximum distance in each dimension allowed for points to be considered equivalent.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by the <code><a href="#topic+LCSS">LCSS</a></code> method to calculate the translations required.
</p>


<h3>Value</h3>

<p>A vector of floating point numbers is returned containing the translations calculated.  This vector is sorted in ascending order.
</p>


<h3>Author(s)</h3>

<p>Kevin Toohey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LCSS">LCSS</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
