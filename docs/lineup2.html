<!DOCTYPE html><html><head><title>Help for package lineup2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lineup2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lineup2-package'><p>lineup2: Lining Up Two Sets of Measurements</p></a></li>
<li><a href='#align_matrix_cols'><p>Align the columns of two matrices</p></a></li>
<li><a href='#align_matrix_rows'><p>Align the rows of two matrices</p></a></li>
<li><a href='#corr_betw_matrices'><p>Calculate correlations between columns of two matrices</p></a></li>
<li><a href='#dist_betw_arrays'><p>Distance between rows of two arrays</p></a></li>
<li><a href='#dist_betw_matrices'><p>Distance between rows of two matrices</p></a></li>
<li><a href='#get_2ndbest'><p>Get 2nd-smallest distance for each individual</p></a></li>
<li><a href='#get_best'><p>Get smallest distance for each individual</p></a></li>
<li><a href='#get_nonself'><p>Get self-nonself distances</p></a></li>
<li><a href='#get_problems'><p>Summarize potential problems in a distance matrix</p></a></li>
<li><a href='#get_self'><p>Get self-self distance</p></a></li>
<li><a href='#hist_self_nonself'><p>Plot histograms of self-self and self-nonself distances</p></a></li>
<li><a href='#lineup2ex'><p>Example dataset for lineup2 package</p></a></li>
<li><a href='#plot_sample'><p>Plot the distances for a given sample</p></a></li>
<li><a href='#which_2ndbest'><p>Determine which individual has 2nd-smallest distance to each individual</p></a></li>
<li><a href='#which_best'><p>Determine which individual has smallest distance to each individual</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-06-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Lining Up Two Sets of Measurements</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for detecting and correcting sample mix-ups between two sets
    of measurements, such as between gene expression data on two
    tissues. This is a revised version of the 'lineup' package, to be
    more general and not tied to the 'qtl' package.</td>
</tr>
<tr>
<td>Author:</td>
<td>Karl W Broman <a href="https://orcid.org/0000-0002-4914-6671"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karl W Broman &lt;broman@wisc.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, Rcpp (&ge; 0.12.12)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, devtools, roxygen2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kbroman/lineup2">https://github.com/kbroman/lineup2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kbroman/lineup2/issues">https://github.com/kbroman/lineup2/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-15 03:03:12 UTC; kbroman</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-15 05:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='lineup2-package'>lineup2: Lining Up Two Sets of Measurements</h2><span id='topic+lineup2'></span><span id='topic+lineup2-package'></span>

<h3>Description</h3>

<p>Tools for detecting and correcting sample mix-ups between two sets
of measurements, such as between gene expression data on two
tissues. This is a revised version of the 'lineup' package, to be
more general and not tied to the 'qtl' package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> (<a href="https://orcid.org/0000-0002-4914-6671">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/kbroman/lineup2">https://github.com/kbroman/lineup2</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/kbroman/lineup2/issues">https://github.com/kbroman/lineup2/issues</a>
</p>
</li></ul>


<hr>
<h2 id='align_matrix_cols'>Align the columns of two matrices</h2><span id='topic+align_matrix_cols'></span>

<h3>Description</h3>

<p>Align the columns of two matrices using their column names,
omitting columns that are not present in both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_matrix_cols(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_matrix_cols_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="align_matrix_cols_+3A_y">y</code></td>
<td>
<p>Another matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the input <code>x</code> and <code>y</code> matrices, with the
columns aligned using their names. Columns not in both matrices
are omitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+align_matrix_rows">align_matrix_rows()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using the provided lineup2ex data (a list of two matrices)
# reduces to the common columns and puts the columns in the same order
# (using the column names)
aligned &lt;- align_matrix_cols(lineup2ex$gastroc, lineup2ex$islet)

</code></pre>

<hr>
<h2 id='align_matrix_rows'>Align the rows of two matrices</h2><span id='topic+align_matrix_rows'></span>

<h3>Description</h3>

<p>Align the rows of two matrices using their row names, omitting rows
that are not present in both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_matrix_rows(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_matrix_rows_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="align_matrix_rows_+3A_y">y</code></td>
<td>
<p>Another matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the input <code>x</code> and <code>y</code> matrices, with the rows
aligned using their names. Rows not in both matrices are
omitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+align_matrix_cols">align_matrix_cols()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using the provided lineup2ex data (a list of two matrices)
# reduces to the common rows and puts the rows in the same order
# (using the row names)
aligned &lt;- align_matrix_rows(lineup2ex$gastroc, lineup2ex$islet)

</code></pre>

<hr>
<h2 id='corr_betw_matrices'>Calculate correlations between columns of two matrices</h2><span id='topic+corr_betw_matrices'></span>

<h3>Description</h3>

<p>For matrices x and y, calculate the correlation between columns of x and
columns of y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_betw_matrices(
  x,
  y,
  what = c("paired", "bestright", "bestpairs", "all"),
  corr_threshold = 0.9,
  align_rows = TRUE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_betw_matrices_+3A_x">x</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="corr_betw_matrices_+3A_y">y</code></td>
<td>
<p>A numeric matrix with the same number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="corr_betw_matrices_+3A_what">what</code></td>
<td>
<p>Indicates which correlations to calculate and return.  See
value, below.</p>
</td></tr>
<tr><td><code id="corr_betw_matrices_+3A_corr_threshold">corr_threshold</code></td>
<td>
<p>Threshold on correlations if <code>what="bestpairs"</code>.</p>
</td></tr>
<tr><td><code id="corr_betw_matrices_+3A_align_rows">align_rows</code></td>
<td>
<p>If TRUE, align the rows in the two matrices by
the row names.</p>
</td></tr>
<tr><td><code id="corr_betw_matrices_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values (<code>NA</code>) are ignored, and we calculate the correlation
using all complete pairs, as in <code><a href="stats.html#topic+cor">stats::cor()</a></code> with
<code>use="pairwise.complete.obs"</code>.
</p>


<h3>Value</h3>

<p>If <code>what="paired"</code>, the return value is a vector of
correlations, between columns of <code>x</code> and the corresponding column of
<code>y</code>.  <code>x</code> and <code>y</code> must have the same number of columns.
</p>
<p>If <code>what="bestright"</code>, we return a data frame of size <code>ncol(x)</code> by
<code>3</code>, with the <code class="reqn">i</code>th row being the maximum correlation between
column <code class="reqn">i</code> of <code>x</code> and a column of <code>y</code>, and then the
<code>y</code>-column index and <code>y</code>-column name with that correlation.  (In
case of ties, we give the first one.)
</p>
<p>If <code>what="bestpairs"</code>, we return a data frame with five columns,
containing all pairs of columns (with one in <code>x</code> and one in <code>y</code>)
with correlation <code class="reqn">\ge</code> <code>corr_threshold</code>.  Each row corresponds to a
column pair, and contains the correlation and then the <code>x</code>- and
<code>y</code>-column indices followed by the <code>x</code>- and <code>y</code>-column names.
</p>
<p>If <code>what="all"</code>, the output is a matrix of size <code>ncol(x)</code> by
<code>ncol(y)</code>, with all correlations between columns of <code>x</code> and
columns of <code>y</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist_betw_matrices">dist_betw_matrices()</a></code>, <code><a href="#topic+dist_betw_arrays">dist_betw_arrays()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use the provided data, and first align the rows
aligned &lt;- align_matrix_rows(lineup2ex$gastroc, lineup2ex$islet)

# correlations for each column in x with each in y
result_pairs &lt;- corr_betw_matrices(aligned[[1]], aligned[[2]], "paired")

# subset columns to those with correlation &gt; 0.75
gastroc &lt;- lineup2ex$gastroc[,result_pairs &gt; 0.75]
islet &lt;- lineup2ex$islet[,result_pairs &gt; 0.75]

# similarity matrix for the two sets of rows
# (by transposing and using what="all")
corr_betw_samples &lt;- corr_betw_matrices(t(gastroc), t(islet), "all")

# for each column in x, find most correlated column in y
# (max in each row of result_all)
bestright &lt;- corr_betw_matrices(t(gastroc), t(islet), "bestright")

# correlations that exceed a threshold
bestpairs &lt;- corr_betw_matrices(t(gastroc), t(islet), "bestpairs", corr_threshold=0.8)

</code></pre>

<hr>
<h2 id='dist_betw_arrays'>Distance between rows of two arrays</h2><span id='topic+dist_betw_arrays'></span>

<h3>Description</h3>

<p>Calculate the distances between the rows of two multi-dimensional
arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_betw_arrays(x, y, distance = c("rmsd", "mad", "propdiff"), cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_betw_arrays_+3A_x">x</code></td>
<td>
<p>A numeric array.</p>
</td></tr>
<tr><td><code id="dist_betw_arrays_+3A_y">y</code></td>
<td>
<p>A second numeric array, with the same dimensions as <code>x</code>.</p>
</td></tr>
<tr><td><code id="dist_betw_arrays_+3A_distance">distance</code></td>
<td>
<p>Indicates whether to use Euclidean distance
(<code>"rmsd"</code> for root mean square difference), the mean absolute
difference (<code>"mad"</code>), or the proportion of differences (<code>"propdiff"</code>).</p>
</td></tr>
<tr><td><code id="dist_betw_arrays_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two arrays need to have the same dimensions, except for the
leading dimension (rows). They are turned into matrices by merging
all but the leading dimension, and then they're sent to
<code><a href="#topic+dist_betw_matrices">dist_betw_matrices()</a></code>.
</p>


<h3>Value</h3>

<p>If <code>x</code> and <code>y</code> have <code>m</code> and <code>n</code> rows, respectively, the
result is an <code>m</code> by <code>n</code> matrix whose (i,j)th element is the
distance between the ith row of <code>x</code> and the jth row of
<code>y</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist_betw_matrices">dist_betw_matrices()</a></code>, <code><a href="#topic+corr_betw_matrices">corr_betw_matrices()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 10
k &lt;- 6
n &lt;- 5
m &lt;- 3
x &lt;- array(stats::rnorm(n*k*p), dim=c(n,k,p))
rownames(x) &lt;- LETTERS[1:n]
y &lt;- array(stats::rnorm(m*k*p), dim=c(m,k,p))
rownames(y) &lt;- letters[1:m]

d &lt;- dist_betw_arrays(x, y)

</code></pre>

<hr>
<h2 id='dist_betw_matrices'>Distance between rows of two matrices</h2><span id='topic+dist_betw_matrices'></span>

<h3>Description</h3>

<p>Calculate the distances between the rows of one matrix and the rows
of a second matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_betw_matrices(
  x,
  y,
  distance = c("rmsd", "mad", "propdiff"),
  align_cols = TRUE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_betw_matrices_+3A_x">x</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="dist_betw_matrices_+3A_y">y</code></td>
<td>
<p>A second numeric matrix, with the same number of columns as <code>x</code>.</p>
</td></tr>
<tr><td><code id="dist_betw_matrices_+3A_distance">distance</code></td>
<td>
<p>Indicates whether to use Euclidean distance
(<code>"rmsd"</code> for root mean square difference), the mean absolute
difference (<code>"mad"</code>), or the proportion of differences (<code>"propdiff"</code>).</p>
</td></tr>
<tr><td><code id="dist_betw_matrices_+3A_align_cols">align_cols</code></td>
<td>
<p>If TRUE, align the columns in the two matrices by
the column names.</p>
</td></tr>
<tr><td><code id="dist_betw_matrices_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is <code>m</code> by <code>p</code> and <code>y</code> is <code>n</code> by <code>p</code>, then the result
is an <code>m</code> by <code>n</code> matrix whose (i,j)th element is the distance
between the ith row of <code>x</code> and the jth row of <code>y</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corr_betw_matrices">corr_betw_matrices()</a></code>, <code><a href="#topic+dist_betw_arrays">dist_betw_arrays()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 10
n &lt;- 5
m &lt;- 3
x &lt;- matrix(stats::rnorm(n*p), ncol=p)
rownames(x) &lt;- LETTERS[1:n]
y &lt;- matrix(stats::rnorm(m*p), ncol=p)
rownames(y) &lt;- letters[1:m]

d &lt;- dist_betw_matrices(x, y)

</code></pre>

<hr>
<h2 id='get_2ndbest'>Get 2nd-smallest distance for each individual</h2><span id='topic+get_2ndbest'></span>

<h3>Description</h3>

<p>For each individual represented in a distance matrix, find the
2nd-smallest entry (with NAs for individuals present in only the
rows or only the columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_2ndbest(d, dimension = c("row", "column"), get_min = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_2ndbest_+3A_d">d</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
<tr><td><code id="get_2ndbest_+3A_dimension">dimension</code></td>
<td>
<p>Whether to get the 2nd-best by row or by column</p>
</td></tr>
<tr><td><code id="get_2ndbest_+3A_get_min">get_min</code></td>
<td>
<p>If TRUE, get the 2nd-minimum; if FALSE, get the 2nd-maximum</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with <strong>all</strong> distinct individuals, with the
2nd-smallest (or largest) value by row or column. We include
all individuals so that the results are aligned with the
results of <code><a href="#topic+get_self">get_self()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_self">get_self()</a></code>, <code><a href="#topic+get_best">get_best()</a></code>, <code><a href="#topic+which_2ndbest">which_2ndbest()</a></code>, <code><a href="#topic+get_nonself">get_nonself()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># align rows in the provided dataset, lineup2ex
aligned &lt;- align_matrix_rows(lineup2ex$gastroc, lineup2ex$islet)
# find correlated columns
selected_genes &lt;- (corr_betw_matrices(aligned[[1]], aligned[[2]], "paired") &gt; 0.75)
# calculate correlation between rows
similarity &lt;- corr_betw_matrices(t(lineup2ex$gastroc[,selected_genes]),
                                 t(lineup2ex$islet[,selected_genes]), "all")
# second-biggest value by row
secbest_byrow &lt;- get_2ndbest(similarity, get_min=FALSE)

# second-biggest value by column
secbest_bycol &lt;- get_2ndbest(similarity, get_min=FALSE, dimension="column")

</code></pre>

<hr>
<h2 id='get_best'>Get smallest distance for each individual</h2><span id='topic+get_best'></span>

<h3>Description</h3>

<p>For each individual represented in a distance matrix, find the
smallest entry (with NAs for individuals present in only the rows
or only the columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_best(d, dimension = c("row", "column"), get_min = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_best_+3A_d">d</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
<tr><td><code id="get_best_+3A_dimension">dimension</code></td>
<td>
<p>Whether to get the minimum by row or by column</p>
</td></tr>
<tr><td><code id="get_best_+3A_get_min">get_min</code></td>
<td>
<p>If TRUE, get the minimum; if FALSE, get the maximum</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with <strong>all</strong> distinct individuals, with the
minimum (or maximum) value by row or column. We include all
individuals so that the results are aligned with the results of
<code><a href="#topic+get_self">get_self()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_self">get_self()</a></code>, <code><a href="#topic+get_2ndbest">get_2ndbest()</a></code>, <code><a href="#topic+which_best">which_best()</a></code>, <code><a href="#topic+get_nonself">get_nonself()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># align rows in the provided dataset, lineup2ex
aligned &lt;- align_matrix_rows(lineup2ex$gastroc, lineup2ex$islet)
# find correlated columns
selected_genes &lt;- (corr_betw_matrices(aligned[[1]], aligned[[2]], "paired") &gt; 0.75)
# calculate correlation between rows
similarity &lt;- corr_betw_matrices(t(lineup2ex$gastroc[,selected_genes]),
                                 t(lineup2ex$islet[,selected_genes]), "all")
# maximum value by row
best_byrow &lt;- get_best(similarity, get_min=FALSE)

# maximum value by column
best_bycol &lt;- get_best(similarity, get_min=FALSE, dimension="column")

</code></pre>

<hr>
<h2 id='get_nonself'>Get self-nonself distances</h2><span id='topic+get_nonself'></span>

<h3>Description</h3>

<p>Return the distance matrix with all self-self distances replaced
with NAs (and so just containing the self-self distances).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nonself(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nonself_+3A_d">d</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input distance matrix with all self-self distances
replaced with NAs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_self">get_self()</a></code>, <code><a href="#topic+get_best">get_best()</a></code>, <code><a href="#topic+get_2ndbest">get_2ndbest()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># align rows in the provided dataset, lineup2ex
aligned &lt;- align_matrix_rows(lineup2ex$gastroc, lineup2ex$islet)
# find correlated columns
selected_genes &lt;- (corr_betw_matrices(aligned[[1]], aligned[[2]], "paired") &gt; 0.75)
# calculate correlation between rows
similarity &lt;- corr_betw_matrices(t(lineup2ex$gastroc[,selected_genes]),
                                 t(lineup2ex$islet[,selected_genes]), "all")
# pull out the non-self similarities
nonself &lt;- get_nonself(similarity)

</code></pre>

<hr>
<h2 id='get_problems'>Summarize potential problems in a distance matrix</h2><span id='topic+get_problems'></span>

<h3>Description</h3>

<p>For the inviduals represented in a distance matrix, collect the
self-self, best, and 2nd best distances, and summarize the results
in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_problems(
  d,
  dimension = c("row", "column"),
  get_min = TRUE,
  subset = c("problems", "all"),
  threshold = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_problems_+3A_d">d</code></td>
<td>
<p>A distance or similarity matrix</p>
</td></tr>
<tr><td><code id="get_problems_+3A_dimension">dimension</code></td>
<td>
<p>Whether to determine the best distances within rows or columns</p>
</td></tr>
<tr><td><code id="get_problems_+3A_get_min">get_min</code></td>
<td>
<p>If TRUE, get the minimum (for a distance matrix);
if FALSE, get the maximum (for a similarity matrix)</p>
</td></tr>
<tr><td><code id="get_problems_+3A_subset">subset</code></td>
<td>
<p>Whether to return just the rows with potential problems, or all of the rows.</p>
</td></tr>
<tr><td><code id="get_problems_+3A_threshold">threshold</code></td>
<td>
<p>If <code>subset="problems"</code>, the threshold on the difference between the self and best distances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing individual ID, distance to self,
best distance and corresponding individual, 2nd best distance
and the corresponding individual.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_self">get_self()</a></code>, <code><a href="#topic+get_best">get_best()</a></code>, <code><a href="#topic+get_2ndbest">get_2ndbest()</a></code>, <code><a href="#topic+which_best">which_best()</a></code>, <code><a href="#topic+get_nonself">get_nonself()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># align rows in the provided dataset, lineup2ex
aligned &lt;- align_matrix_rows(lineup2ex$gastroc, lineup2ex$islet)
# find correlated columns
selected_genes &lt;- (corr_betw_matrices(aligned[[1]], aligned[[2]], "paired") &gt; 0.75)
# calculate correlation between rows
similarity &lt;- corr_betw_matrices(t(lineup2ex$gastroc[,selected_genes]),
                                 t(lineup2ex$islet[,selected_genes]), "all")
# pull out the problems, looking by row (where best &gt; self + 0.3)
problems_byrow &lt;- get_problems(similarity, get_min=FALSE, threshold=0.3)

# pull out the problems, looking by column (where best &gt; self + 0.3)
problems_bycol &lt;- get_problems(similarity, get_min=FALSE, threshold=0.3,
                               dimension="column")

</code></pre>

<hr>
<h2 id='get_self'>Get self-self distance</h2><span id='topic+get_self'></span>

<h3>Description</h3>

<p>For each individual represented in a distance matrix, pull the
self-self entry (with NAs for individuals present in only the rows
or only the columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_self(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_self_+3A_d">d</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with all distinct individuals, with the self-self
values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_best">get_best()</a></code>, <code><a href="#topic+get_2ndbest">get_2ndbest()</a></code>, <code><a href="#topic+get_nonself">get_nonself()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># align rows in the provided dataset, lineup2ex
aligned &lt;- align_matrix_rows(lineup2ex$gastroc, lineup2ex$islet)
# find correlated columns
selected_genes &lt;- (corr_betw_matrices(aligned[[1]], aligned[[2]], "paired") &gt; 0.75)
# calculate correlation between rows
similarity &lt;- corr_betw_matrices(t(lineup2ex$gastroc[,selected_genes]),
                                 t(lineup2ex$islet[,selected_genes]), "all")
# pull out the self-self similarities
self &lt;- get_self(similarity)

</code></pre>

<hr>
<h2 id='hist_self_nonself'>Plot histograms of self-self and self-nonself distances</h2><span id='topic+hist_self_nonself'></span>

<h3>Description</h3>

<p>Plot histograms of self-self and self-nonself distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_self_nonself(d, breaks = NULL, rug = TRUE, xlabel = "distance")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_self_nonself_+3A_d">d</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
<tr><td><code id="hist_self_nonself_+3A_breaks">breaks</code></td>
<td>
<p>Histogram breaks (default is to use 100 intervals)</p>
</td></tr>
<tr><td><code id="hist_self_nonself_+3A_rug">rug</code></td>
<td>
<p>If TRUE, use <code><a href="graphics.html#topic+rug">graphics::rug()</a></code> to plot tick marks at the
observed values, below the histograms.</p>
</td></tr>
<tr><td><code id="hist_self_nonself_+3A_xlabel">xlabel</code></td>
<td>
<p>Label on x-axes (e.g., &quot;similarity&quot; vs &quot;distance&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use the <code>mfrow</code> arg for <code><a href="graphics.html#topic+par">graphics::par()</a></code> to make a
two-panel figure.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_self">get_self()</a></code>, <code><a href="#topic+get_nonself">get_nonself()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># align rows in the provided dataset, lineup2ex
aligned &lt;- align_matrix_rows(lineup2ex$gastroc, lineup2ex$islet)
# find correlated columns
selected_genes &lt;- (corr_betw_matrices(aligned[[1]], aligned[[2]], "paired") &gt; 0.75)
# calculate correlation between rows
similarity &lt;- corr_betw_matrices(t(lineup2ex$gastroc[,selected_genes]),
                                 t(lineup2ex$islet[,selected_genes]), "all")
# histograms of the self and non-self distances
hist_self_nonself(similarity)

</code></pre>

<hr>
<h2 id='lineup2ex'>Example dataset for lineup2 package</h2><span id='topic+lineup2ex'></span>

<h3>Description</h3>

<p>Example dataset for lineup2 package, with gene expression data
for a selected set of 200 genes on two tissues on a set of about 500 mice,
with 100 genes chosen to be highly correlated between the two tissues
and 100 chosen at random.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lineup2ex)
</code></pre>


<h3>Format</h3>

<p>List of two matrices, with gene expression data for gastrocnemius
muscle (<code>gastroc</code>) and pancreatic islets (<code>islet</code>), at a selected
set of 200 genes (100 are highly correlated between the two
tissues, and 100 others chosen at random). The matrices have
samples as rows and genes as columns. The row names are sample
identifiers. There are 498 samples for gastroc and 499 samples for
islet, with 497 samples in common.
</p>


<h3>Source</h3>

<p><a href="https://phenome.jax.org/projects/Attie1">https://phenome.jax.org/projects/Attie1</a>
</p>


<h3>References</h3>

<p>Broman KW, Keller MP, Broman AT, Kendziorski C, Yandell BS, Sen Ś,
Attie AD (2015) Identification and correction of sample mix-ups in
expression genetic data: A case study. G3 5:2177&ndash;2186
</p>
<p>Tian J, Keller MP, Oler AT, Rabaglia ME, Schueler KL, Stapleton DS,
Broman AT, Zhao W, Kendziorski C, Yandell BS, Hagenbuch B, Broman
KW, Attie AD (2015) Identification of the bile acid transporter
Slco1a6 as a candidate gene that broadly affects gene expression in
mouse pancreatic islets. Genetics 201:1253&ndash;1262
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lineup2ex)
common_ind &lt;- align_matrix_rows(lineup2ex$gastroc, lineup2ex$islet)
</code></pre>

<hr>
<h2 id='plot_sample'>Plot the distances for a given sample</h2><span id='topic+plot_sample'></span>

<h3>Description</h3>

<p>Plot the distances for a given sample, highlighting itself and the closest sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sample(
  d,
  sample,
  dimension = c("row", "column"),
  get_min = TRUE,
  add_labels = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_sample_+3A_d">d</code></td>
<td>
<p>A distance or similarity matrix</p>
</td></tr>
<tr><td><code id="plot_sample_+3A_sample">sample</code></td>
<td>
<p>Sample ID (in row or column names)</p>
</td></tr>
<tr><td><code id="plot_sample_+3A_dimension">dimension</code></td>
<td>
<p>Whether to look at the row or column</p>
</td></tr>
<tr><td><code id="plot_sample_+3A_get_min">get_min</code></td>
<td>
<p>If TRUE, get the minimum (for a distance matrix);
if FALSE, get the maximum (for a similarity matrix)</p>
</td></tr>
<tr><td><code id="plot_sample_+3A_add_labels">add_labels</code></td>
<td>
<p>If TRUE, label the individual sample and the optimal sample</p>
</td></tr>
<tr><td><code id="plot_sample_+3A_...">...</code></td>
<td>
<p>Passed to <code>points()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># align rows in the provided dataset, lineup2ex
aligned &lt;- align_matrix_rows(lineup2ex$gastroc, lineup2ex$islet)
# find correlated columns
selected_genes &lt;- (corr_betw_matrices(aligned[[1]], aligned[[2]], "paired") &gt; 0.75)
# calculate correlation between rows
similarity &lt;- corr_betw_matrices(t(lineup2ex$gastroc[,selected_genes]),
                                 t(lineup2ex$islet[,selected_genes]), "all")

plot_sample(similarity, "Mouse3659", get_min=FALSE)
plot_sample(similarity, "Mouse3655", "column", get_min=FALSE)

</code></pre>

<hr>
<h2 id='which_2ndbest'>Determine which individual has 2nd-smallest distance to each individual</h2><span id='topic+which_2ndbest'></span>

<h3>Description</h3>

<p>For each individual represented in a distance matrix, find the
individual giving the 2nd-smallest entry (with NAs for individuals
present in only the rows or only the columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_2ndbest(d, dimension = c("row", "column"), get_min = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_2ndbest_+3A_d">d</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
<tr><td><code id="which_2ndbest_+3A_dimension">dimension</code></td>
<td>
<p>Whether to get the 2nd-best by row or by column</p>
</td></tr>
<tr><td><code id="which_2ndbest_+3A_get_min">get_min</code></td>
<td>
<p>If TRUE, get the 2nd-minimum; if FALSE, get the 2nd-maximum</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with <strong>all</strong> distinct individuals, with the
character string labels for the individuals giving the
2nd-smallest (or largest) value by row or column. We include
all individuals so that the results are aligned with the
results of <code><a href="#topic+get_self">get_self()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_2ndbest">get_2ndbest()</a></code>, <code><a href="#topic+get_self">get_self()</a></code>, <code><a href="#topic+get_best">get_best()</a></code>, <code><a href="#topic+which_best">which_best()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># align rows in the provided dataset, lineup2ex
aligned &lt;- align_matrix_rows(lineup2ex$gastroc, lineup2ex$islet)
# find correlated columns
selected_genes &lt;- (corr_betw_matrices(aligned[[1]], aligned[[2]], "paired") &gt; 0.75)
# calculate correlation between rows
similarity &lt;- corr_betw_matrices(t(lineup2ex$gastroc[,selected_genes]),
                                 t(lineup2ex$islet[,selected_genes]), "all")
# which sample gives second-biggest value by row
secbest_byrow &lt;- which_2ndbest(similarity, get_min=FALSE)

# which sample gives second-biggest value by column
secbest_bycol &lt;- which_2ndbest(similarity, get_min=FALSE, dimension="column")

</code></pre>

<hr>
<h2 id='which_best'>Determine which individual has smallest distance to each individual</h2><span id='topic+which_best'></span>

<h3>Description</h3>

<p>For each individual represented in a distance matrix, find the
individual giving the smallest entry (with NAs for individuals
present in only the rows or only the columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_best(d, dimension = c("row", "column"), get_min = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_best_+3A_d">d</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
<tr><td><code id="which_best_+3A_dimension">dimension</code></td>
<td>
<p>Whether to get the minimum by row or by column</p>
</td></tr>
<tr><td><code id="which_best_+3A_get_min">get_min</code></td>
<td>
<p>If TRUE, get the minimum; if FALSE, get the maximum</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with <strong>all</strong> distinct individuals, with the
character string labels for the individuals giving the minimum
(or maximum) value by row or column. We include all individuals
so that the results are aligned with the results of
<code><a href="#topic+get_self">get_self()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_best">get_best()</a></code>, <code><a href="#topic+get_self">get_self()</a></code>, <code><a href="#topic+get_2ndbest">get_2ndbest()</a></code>, <code><a href="#topic+which_2ndbest">which_2ndbest()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># align rows in the provided dataset, lineup2ex
aligned &lt;- align_matrix_rows(lineup2ex$gastroc, lineup2ex$islet)
# find correlated columns
selected_genes &lt;- (corr_betw_matrices(aligned[[1]], aligned[[2]], "paired") &gt; 0.75)
# calculate correlation between rows
similarity &lt;- corr_betw_matrices(t(lineup2ex$gastroc[,selected_genes]),
                                 t(lineup2ex$islet[,selected_genes]), "all")
# which sample gives maximum value by row
best_byrow &lt;- which_best(similarity, get_min=FALSE)

# which sample gives maximum value by column
best_bycol &lt;- which_best(similarity, get_min=FALSE, dimension="column")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
