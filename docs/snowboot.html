<!DOCTYPE html><html><head><title>Help for package snowboot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {snowboot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#artificial_networks'><p>10 Simulated Networks of Order 2000 with Polylogarithmic (0.1, 2)</p>
Degree Distributions</a></li>
<li><a href='#boot_ci'><p>Confidence Intervals from Bootstrapped Network Degree Distribution</p></a></li>
<li><a href='#boot_dd'><p>Bootstrapping Empirical Degree Distribution</p></a></li>
<li><a href='#igraph_to_network'><p>Create a &quot;Network&quot; Object from an igraph Object</p></a></li>
<li><a href='#lsmi'><p>Labeled Snowball with Multiple Inclusions (LSMI)</p></a></li>
<li><a href='#lsmi_cv'><p>Cross-validation to Select an Optimal Combination of n.seed and n.wave</p></a></li>
<li><a href='#lsmi_dd'><p>Network Degree Distribution Estimated from Labeled Snowball</p>
Sample with Multiple Inclusion (LSMI)</a></li>
<li><a href='#lsmi_union'><p>Snowball Sampling with Multiple Inclusions around Several Subsets of Seeds</p></a></li>
<li><a href='#plot.snowboot'><p>Plot Degree Distribution Estimates</p></a></li>
<li><a href='#random_network'><p>Construct Artificial Networks</p></a></li>
<li><a href='#sample_about_one_seed'><p>Snowball Sampling with Multiple Inclusions around One Network Node</p></a></li>
<li><a href='#vertboot'><p>Bootstrapping a Network with Vertex Bootstrap</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bootstrap Methods for Network Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-04-23</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for analysis of network objects, which are imported or simulated by the package. The non-parametric methods of analysis center on snowball and bootstrap sampling for estimating functions of network degree distribution. For other parameters of interest, see, e.g., 'bootnet' package.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, igraph, parallel, Rcpp, Rdpack, stats</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-23 19:33:49 UTC; Slava</td>
</tr>
<tr>
<td>Author:</td>
<td>Leticia Ramirez-Ramirez [aut],
  Kusha Nezafati [aut],
  Yuzhou Chen [aut],
  Vyacheslav Lyubchich
    <a href="https://orcid.org/0000-0001-7936-4285"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Yulia R. Gel [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vyacheslav Lyubchich &lt;lyubchich@umces.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-25 18:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='artificial_networks'>10 Simulated Networks of Order 2000 with Polylogarithmic (0.1, 2)
Degree Distributions</h2><span id='topic+artificial_networks'></span>

<h3>Description</h3>

<p>A list called &quot;artificial_networks&quot;. The length of the list is 10, and each element is a
network object of order 2000. These networks were simulated using the
polylogarithmic (aka Gutenberg&ndash;Richter law) degree distribution with parameters
<code class="reqn">\delta = 0.1</code> and <code class="reqn">\lambda = 2</code> as shown in the following equations:
</p>
<p style="text-align: center;"><code class="reqn">f(k) = k^{-{\delta}}e^{-{k/{\lambda}}}/Li_{\delta}(e^{-{1/\lambda}})</code>
</p>

<p style="text-align: center;"><code class="reqn">Li_{\delta}(z)=\sum_{j=1}^{\infty} z^{-j}/{j^{\delta}},</code>
</p>

<p>where <code class="reqn">\lambda &gt; 0</code>
(see Newman et al. 2001, Gel et al. 2017, and Chen et al. 2018 for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artificial_networks
</code></pre>


<h3>Format</h3>

<p>A list containing 10 network objects. Each network object is a list
with three elements:
</p>

<dl>
<dt><code>degree</code></dt><dd><p>the degree sequence of the network, which is
an integer vector of length <code class="reqn">n</code>;</p>
</dd>
<dt><code>edges</code></dt><dd><p>the edgelist, which is a two-column
matrix, where each row is an edge of the network;</p>
</dd>
<dt><code>n</code></dt><dd><p>the network order (number of nodes in the network).
The order is 2000.</p>
</dd>
</dl>



<h3>References</h3>

<p>Chen Y, Gel YR, Lyubchich V, Nezafati K (2018).
&ldquo;Snowboot: bootstrap methods for network inference.&rdquo;
<em>The R Journal</em>, <b>10</b>(2), 95&ndash;113.
doi: <a href="https://doi.org/10.32614/RJ-2018-056">10.32614/RJ-2018-056</a>.<br /><br /> Gel YR, Lyubchich V, Ramirez Ramirez LL (2017).
&ldquo;Bootstrap quantification of estimation uncertainties in network degree distributions.&rdquo;
<em>Scientific Reports</em>, <b>7</b>, 5807.
doi: <a href="https://doi.org/10.1038/s41598-017-05885-x">10.1038/s41598-017-05885-x</a>.<br /><br /> Newman MEJ, Strogatz SH, Watts DJ (2001).
&ldquo;Random graphs with arbitrary degree distributions and their applications.&rdquo;
<em>Physical Review E</em>, <b>64</b>(2), 026118.
doi: <a href="https://doi.org/10.1103/PhysRevE.64.026118">10.1103/PhysRevE.64.026118</a>.
</p>

<hr>
<h2 id='boot_ci'>Confidence Intervals from Bootstrapped Network Degree Distribution</h2><span id='topic+boot_ci'></span>

<h3>Description</h3>

<p>The function calculates bootstrap confidence intervals for the parameters
of network degree distribution: probabilities of node degrees <code class="reqn">f(k)</code>
and mean degree <code class="reqn">\mu</code>, where <code class="reqn">k = 0, 1, \ldots</code> are the degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_ci(x, prob = 0.95, method = c("percentile", "basic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_ci_+3A_x">x</code></td>
<td>
<p>a list with bootstrapped results &ndash; output of <code><a href="#topic+boot_dd">boot_dd</a></code>.</p>
</td></tr>
<tr><td><code id="boot_ci_+3A_prob">prob</code></td>
<td>
<p>confidence level for the intervals. Default is 0.95
(i.e., 95% confidence).</p>
</td></tr>
<tr><td><code id="boot_ci_+3A_method">method</code></td>
<td>
<p>method for calculating the bootstrap intervals. Default is
<code>"percentile"</code> (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the bootstrap intervals can be calculated with two alternative
methods: <code>"percentile"</code> or <code>"basic"</code>. The <code>"percentile"</code>
intervals correspond to Efron's <code class="reqn">100\cdot</code><code>prob</code>% intervals
(see Efron 1979, also Equation 5.18 by Davison and Hinkley 1997 and Equation 3 by Gel et al. 2017, Chen et al. 2018):
</p>
<p style="text-align: center;"><code class="reqn">(\theta^*_{[B\alpha/2]}, \theta^*_{[B(1-\alpha/2)]}),</code>
</p>

<p>where <code class="reqn">\theta^*_{[B\alpha/2]}</code> and <code class="reqn">\theta^*_{[B(1-\alpha/2)]}</code>
are empirical quantiles of the bootstrap distribution with <code>B</code> bootstrap
replications for parameter <code class="reqn">\theta</code>
(<code class="reqn">\theta</code> can be the <code class="reqn">f(k)</code> or <code class="reqn">\mu</code>),
and <code class="reqn">\alpha = 1 -</code> <code>prob</code>.
</p>
<p>The <code>"basic"</code> method produces intervals
(see Equation 5.6 by Davison and Hinkley 1997):
</p>
<p style="text-align: center;"><code class="reqn">(2\hat{\theta} - \theta^*_{[B(1-\alpha/2)]}, 2\hat{\theta} - \theta^*_{[B\alpha/2]}),</code>
</p>

<p>where <code class="reqn">\hat{\theta}</code> is the sample estimate of the parameter.
Note that this method can lead to negative confidence bounds, especially
when <code class="reqn">\hat{\theta}</code> is close to 0.
</p>


<h3>Value</h3>

<p>A list object of class &quot;<code>snowboot</code>&quot; with the following elements:
</p>
<table>
<tr><td><code>fk_ci</code></td>
<td>
<p>A matrix of dimensions <code class="reqn">2 \times</code><code>length(x$fk)</code>, where
the number of columns corresponds to the number of probabilities <code class="reqn">f(k)</code>
estimated from an LSMI sample. Each column of the matrix is a confidence
interval for a corresponding <code class="reqn">f(k)</code>. I.e., the first row of the matrix
gives the lower bounds, while the second row contains all upper bounds.</p>
</td></tr>
<tr><td><code>mu_ci</code></td>
<td>
<p>A numeric vector of length 2 with lower and upper confidence
bounds for the network mean degree <code class="reqn">\mu</code>.</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>Confidence level for the intervals.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method that was used for calculating the bootstrap intervals.</p>
</td></tr>
<tr><td><code>fk</code></td>
<td>
<p>A vector with an estimate of the degree distribution, copied
from the input <code>x$fk</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>An estimate of the mean degree, copied from the input <code>x$mu</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chen Y, Gel YR, Lyubchich V, Nezafati K (2018).
&ldquo;Snowboot: bootstrap methods for network inference.&rdquo;
<em>The R Journal</em>, <b>10</b>(2), 95&ndash;113.
doi: <a href="https://doi.org/10.32614/RJ-2018-056">10.32614/RJ-2018-056</a>.<br /><br /> Davison AC, Hinkley DV (1997).
<em>Bootstrap Methods and Their Application</em>.
Cambridge University Press, Cambridge.<br /><br /> Efron B (1979).
&ldquo;Bootstrap methods: Another look at the jackknife.&rdquo;
<em>The Annals of Statistics</em>, <b>7</b>(1), 1&ndash;26.
doi: <a href="https://doi.org/10.1214/aos/1176344552">10.1214/aos/1176344552</a>.<br /><br /> Gel YR, Lyubchich V, Ramirez Ramirez LL (2017).
&ldquo;Bootstrap quantification of estimation uncertainties in network degree distributions.&rdquo;
<em>Scientific Reports</em>, <b>7</b>, 5807.
doi: <a href="https://doi.org/10.1038/s41598-017-05885-x">10.1038/s41598-017-05885-x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot_dd">boot_dd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- artificial_networks[[1]]
lsmiEstimate &lt;- lsmi_dd(net = net, n.seed = 5, n.wave = 3)
bootEstimates &lt;- boot_dd(lsmiEstimate, B = 10)
bootIntervals1 &lt;- boot_ci(bootEstimates)

#Another version of the intervals:
bootIntervals2 &lt;- boot_ci(bootEstimates, method = "basic")

</code></pre>

<hr>
<h2 id='boot_dd'>Bootstrapping Empirical Degree Distribution</h2><span id='topic+boot_dd'></span>

<h3>Description</h3>

<p>This function delivers bootstrap estimates of network degree distribution
based on an LSMI sample. The bootstrap scheme is non-weighted for seeds
(resampling with replacement) and weighted for non-seeds (resampling with
replacement, with weights proportional to inverse of the degrees),
as described in Section 3.3 by Thompson et al. (2016)
and in Algorithm 1 by Gel et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_dd(x, B = 100, cl = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_dd_+3A_x">x</code></td>
<td>
<p>a list that is the output of <code><a href="#topic+lsmi_dd">lsmi_dd</a></code>, i.e., an estimate
of the degree distribution together with all degrees of seeds and non-seeds
from an LSMI.</p>
</td></tr>
<tr><td><code id="boot_dd_+3A_b">B</code></td>
<td>
<p>a positive integer, the number of bootstrap replications to perform.
Default is 100.</p>
</td></tr>
<tr><td><code id="boot_dd_+3A_cl">cl</code></td>
<td>
<p>parameter to specify computer cluster for bootstrapping, passed to
the package <code>parallel</code> (default is <code>1</code>, meaning no cluster is used).
Possible values are:
</p>

<ul>
<li><p> cluster object (list) produced by <a href="parallel.html#topic+makeCluster">makeCluster</a>.
In this case, new cluster is not started nor stopped;
</p>
</li>
<li> <p><code>NULL</code>. In this case, the function will attempt to detect
available cores (see <a href="parallel.html#topic+detectCores">detectCores</a>) and, if there are
multiple cores (<code class="reqn">&gt;1</code>), a cluster will be started with
<a href="parallel.html#topic+makeCluster">makeCluster</a>. If started, the cluster will be stopped
after computations are finished;
</p>
</li>
<li><p> positive integer defining the number of cores to start a cluster.
If <code>cl = 1</code>, no attempt to create a cluster will be made.
If <code>cl &gt; 1</code>, cluster will be started (using <a href="parallel.html#topic+makeCluster">makeCluster</a>)
and stopped afterwards (using <a href="parallel.html#topic+stopCluster">stopCluster</a>).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of class &quot;<code>snowboot</code>&quot; consisting of:
</p>
<table>
<tr><td><code>fkb</code></td>
<td>
<p>A matrix of dimensions <code>length(x$fk)</code><code class="reqn">\times</code><code>B</code>
with <code>B</code> bootstrap estimates of the degree distribution.
The bootstrap estimates are computed according to
Equation 1 by Gel et al. (2017), also
see Chen et al. (2018).</p>
</td></tr>
<tr><td><code>mub</code></td>
<td>
<p>A vector of length <code>B</code> with bootstrapped estimates
of the network mean degree.
The bootstrap estimates are computed according to
Equation 2 by Gel et al. (2017).</p>
</td></tr>
<tr><td><code>fk</code></td>
<td>
<p>A vector with an estimate of the degree distribution, copied
from the input <code>x$fk</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>An estimate of the mean degree, copied from the input <code>x$mu</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The number of bootstrap replications performed.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chen Y, Gel YR, Lyubchich V, Nezafati K (2018).
&ldquo;Snowboot: bootstrap methods for network inference.&rdquo;
<em>The R Journal</em>, <b>10</b>(2), 95&ndash;113.
doi: <a href="https://doi.org/10.32614/RJ-2018-056">10.32614/RJ-2018-056</a>.<br /><br /> Gel YR, Lyubchich V, Ramirez Ramirez LL (2017).
&ldquo;Bootstrap quantification of estimation uncertainties in network degree distributions.&rdquo;
<em>Scientific Reports</em>, <b>7</b>, 5807.
doi: <a href="https://doi.org/10.1038/s41598-017-05885-x">10.1038/s41598-017-05885-x</a>.<br /><br /> Thompson ME, Ramirez Ramirez LL, Lyubchich V, Gel YR (2016).
&ldquo;Using the bootstrap for statistical inference on random graphs.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>44</b>(1), 3&ndash;24.
doi: <a href="https://doi.org/10.1002/cjs.11271">10.1002/cjs.11271</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsmi">lsmi</a></code>, <code><a href="#topic+lsmi_dd">lsmi_dd</a></code>, <code><a href="#topic+boot_ci">boot_ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- artificial_networks[[1]]
lsmiEstimate &lt;- lsmi_dd(net = net, n.seed = 5, n.wave = 3)
bootEstimates &lt;- boot_dd(lsmiEstimate, B = 10)

</code></pre>

<hr>
<h2 id='igraph_to_network'>Create a &quot;Network&quot; Object from an igraph Object</h2><span id='topic+igraph_to_network'></span>

<h3>Description</h3>

<p>This function converts an igraph object to an object compatible with
snowboot functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph_to_network(in_graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph_to_network_+3A_in_graph">in_graph</code></td>
<td>
<p>An igraph object. To create igraph objects from field data,
see <code><a href="igraph.html#topic+graph_from_edgelist">graph_from_edgelist</a></code>,
<code><a href="igraph.html#topic+graph_from_data_frame">graph_from_data_frame</a></code>,
<code><a href="igraph.html#topic+graph_from_adjacency_matrix">graph_from_adjacency_matrix</a></code>, or
<code><a href="igraph.html#topic+read_graph">read_graph</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contain elements:
</p>
<table>
<tr><td><code>edges</code></td>
<td>
<p>The edgelist of the network. A two column
<code>matrix</code> where each row is an edge.</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>The degree sequence of the network, which is
an <code>integer</code> vector of length n.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The network order.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="http://igraph.org/">http://igraph.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hex_ring &lt;- igraph::make_ring(6, directed = FALSE, mutual = FALSE, circular = TRUE)
net &lt;- igraph_to_network(hex_ring)
</code></pre>

<hr>
<h2 id='lsmi'>Labeled Snowball with Multiple Inclusions (LSMI)</h2><span id='topic+lsmi'></span>

<h3>Description</h3>

<p>Obtain LSMI samples around several seeds, which can be selected randomly or
pre-specified. See Figure 1 by
Gel et al. (2017) or
Figure 2 by Chen et al. (2018)
illustrating the algorithm of sampling around multiple seeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsmi(net, n.seed = 10, n.wave = 1, seeds = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsmi_+3A_net">net</code></td>
<td>
<p>a network object that is a list containing:
</p>

<dl>
<dt><code>degree</code></dt><dd><p>the degree sequence of the network, which is
an <code>integer</code> vector of length <code class="reqn">n</code>;</p>
</dd>
<dt><code>edges</code></dt><dd><p>the edgelist, which is a two-column
matrix, where each row is an edge of the network;</p>
</dd>
<dt><code>n</code></dt><dd><p>the network order (i.e., number of nodes in the network).</p>
</dd>
</dl>

<p>The network object can be simulated by <code><a href="#topic+random_network">random_network</a></code>,
selected from the networks available in <code><a href="#topic+artificial_networks">artificial_networks</a></code>,
converged from an <code>igraph</code> object with <code><a href="#topic+igraph_to_network">igraph_to_network</a></code>,
etc.</p>
</td></tr>
<tr><td><code id="lsmi_+3A_n.seed">n.seed</code></td>
<td>
<p>an integer defining the number of nodes to randomly sample
from the network to start an LSMI sample around each of them.</p>
</td></tr>
<tr><td><code id="lsmi_+3A_n.wave">n.wave</code></td>
<td>
<p>an integer defining the number of waves (order of the neighborhood)
to be recorded around the seed in the LSMI. For example, <code>n.wave = 1</code> corresponds to
an LSMI with the seed and its first neighbors. Note that the algorithm allows for
multiple inclusions.</p>
</td></tr>
<tr><td><code id="lsmi_+3A_seeds">seeds</code></td>
<td>
<p>a vector of numeric IDs of pre-specified seeds. If specified,
LSMIs are constructed around each such seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>seeds</code> specified, <code>n.seed</code> is not used.
</p>


<h3>Value</h3>

<p>A list of length <code>n.seed</code> (or, if <code>seeds</code> are specified,
of length <code>length(unique(seeds))</code>), where each element is a list
of length <code>n.wave + 1</code> representing an LSMI produced by
<code><a href="#topic+sample_about_one_seed">sample_about_one_seed</a></code>.
</p>


<h3>References</h3>

<p>Chen Y, Gel YR, Lyubchich V, Nezafati K (2018).
&ldquo;Snowboot: bootstrap methods for network inference.&rdquo;
<em>The R Journal</em>, <b>10</b>(2), 95&ndash;113.
doi: <a href="https://doi.org/10.32614/RJ-2018-056">10.32614/RJ-2018-056</a>.<br /><br /> Gel YR, Lyubchich V, Ramirez Ramirez LL (2017).
&ldquo;Bootstrap quantification of estimation uncertainties in network degree distributions.&rdquo;
<em>Scientific Reports</em>, <b>7</b>, 5807.
doi: <a href="https://doi.org/10.1038/s41598-017-05885-x">10.1038/s41598-017-05885-x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_about_one_seed">sample_about_one_seed</a></code>, <code><a href="#topic+lsmi_union">lsmi_union</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- artificial_networks[[1]]
a &lt;- lsmi(net, n.seed = 20, n.wave = 2)

</code></pre>

<hr>
<h2 id='lsmi_cv'>Cross-validation to Select an Optimal Combination of n.seed and n.wave</h2><span id='topic+lsmi_cv'></span>

<h3>Description</h3>

<p>From the vector of specified <code>n.seeds</code> and possible waves <code>1:n.wave</code> around each
seed, the function selects a single number <code>n.seed</code> and an <code>n.wave</code>
(optimal seed-wave combination) that produce
a labeled snowball with multiple inclusions (LSMI) sample with desired
bootstrap confidence intervals for a parameter of interest. Here by &lsquo;desired&rsquo;
we mean that the interval (and corresponding seed-wave combination) are selected
as having the best coverage (closest to the specified level <code>prob</code>), based on
a cross-validation procedure with proxy estimates of the parameter.
See Algorithm 2 by Gel et al. (2017) and Details
below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsmi_cv(
  net,
  n.seeds,
  n.wave,
  seeds = NULL,
  B = 100,
  prob = 0.95,
  cl = 1,
  param = c("mu"),
  method = c("percentile", "basic"),
  proxyRep = 19,
  proxySize = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsmi_cv_+3A_net">net</code></td>
<td>
<p>a network object that is a list containing:
</p>

<dl>
<dt><code>degree</code></dt><dd><p>the degree sequence of the network, which is
an <code>integer</code> vector of length <code class="reqn">n</code>;</p>
</dd>
<dt><code>edges</code></dt><dd><p>the edgelist, which is a two-column
matrix, where each row is an edge of the network;</p>
</dd>
<dt><code>n</code></dt><dd><p>the network order (i.e., number of nodes in the network).</p>
</dd>
</dl>

<p>The network object can be simulated by <code><a href="#topic+random_network">random_network</a></code>,
selected from the networks available in <code><a href="#topic+artificial_networks">artificial_networks</a></code>,
converged from an <code>igraph</code> object with <code><a href="#topic+igraph_to_network">igraph_to_network</a></code>,
etc.</p>
</td></tr>
<tr><td><code id="lsmi_cv_+3A_n.seeds">n.seeds</code></td>
<td>
<p>an integer vector of numbers of seeds for snowball sampling
(cf. a single integer <code>n.seed</code> in <code><a href="#topic+lsmi">lsmi</a></code>). Only
<code>n.seeds &lt;= n</code> are retained. If <code>seeds</code> is
specified, only values <code>n.seeds &lt; length(unique(seeds))</code> are retained
and automatically supplemented by <code>length(unique(seeds))</code>.</p>
</td></tr>
<tr><td><code id="lsmi_cv_+3A_n.wave">n.wave</code></td>
<td>
<p>an integer defining the number of waves (order of the neighborhood)
to be recorded around the seed in the LSMI. For example, <code>n.wave = 1</code> corresponds to
an LSMI with the seed and its first neighbors. Note that the algorithm allows for
multiple inclusions.</p>
</td></tr>
<tr><td><code id="lsmi_cv_+3A_seeds">seeds</code></td>
<td>
<p>a vector of numeric IDs of pre-specified seeds. If specified,
LSMIs are constructed around each such seed.</p>
</td></tr>
<tr><td><code id="lsmi_cv_+3A_b">B</code></td>
<td>
<p>a positive integer, the number of bootstrap replications to perform.
Default is 100.</p>
</td></tr>
<tr><td><code id="lsmi_cv_+3A_prob">prob</code></td>
<td>
<p>confidence level for the intervals. Default is 0.95
(i.e., 95% confidence).</p>
</td></tr>
<tr><td><code id="lsmi_cv_+3A_cl">cl</code></td>
<td>
<p>parameter to specify computer cluster for bootstrapping, passed to
the package <code>parallel</code> (default is <code>1</code>, meaning no cluster is used).
Possible values are:
</p>

<ul>
<li><p> cluster object (list) produced by <a href="parallel.html#topic+makeCluster">makeCluster</a>.
In this case, new cluster is not started nor stopped;
</p>
</li>
<li> <p><code>NULL</code>. In this case, the function will attempt to detect
available cores (see <a href="parallel.html#topic+detectCores">detectCores</a>) and, if there are
multiple cores (<code class="reqn">&gt;1</code>), a cluster will be started with
<a href="parallel.html#topic+makeCluster">makeCluster</a>. If started, the cluster will be stopped
after computations are finished;
</p>
</li>
<li><p> positive integer defining the number of cores to start a cluster.
If <code>cl = 1</code>, no attempt to create a cluster will be made.
If <code>cl &gt; 1</code>, cluster will be started (using <a href="parallel.html#topic+makeCluster">makeCluster</a>)
and stopped afterwards (using <a href="parallel.html#topic+stopCluster">stopCluster</a>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="lsmi_cv_+3A_param">param</code></td>
<td>
<p>The parameter of interest for which to run a cross-validation
and select optimal <code>n.seed</code> and <code>n.wave</code>. Currently, only one
selection is possible: <code>"mu"</code> (the network mean degree).</p>
</td></tr>
<tr><td><code id="lsmi_cv_+3A_method">method</code></td>
<td>
<p>method for calculating the bootstrap intervals. Default is
<code>"percentile"</code> (see Details).</p>
</td></tr>
<tr><td><code id="lsmi_cv_+3A_proxyrep">proxyRep</code></td>
<td>
<p>The number of times to repeat proxy sampling. Default is 19.</p>
</td></tr>
<tr><td><code id="lsmi_cv_+3A_proxysize">proxySize</code></td>
<td>
<p>The size of the proxy sample. Default is 30.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the bootstrap intervals can be calculated with two alternative
methods: <code>"percentile"</code> or <code>"basic"</code>. The <code>"percentile"</code>
intervals correspond to Efron's <code class="reqn">100\cdot</code><code>prob</code>% intervals
(see Efron 1979, also Equation 5.18 by Davison and Hinkley 1997 and Equation 3 by Gel et al. 2017, Chen et al. 2018):
</p>
<p style="text-align: center;"><code class="reqn">(\theta^*_{[B\alpha/2]}, \theta^*_{[B(1-\alpha/2)]}),</code>
</p>

<p>where <code class="reqn">\theta^*_{[B\alpha/2]}</code> and <code class="reqn">\theta^*_{[B(1-\alpha/2)]}</code>
are empirical quantiles of the bootstrap distribution with <code>B</code> bootstrap
replications for parameter <code class="reqn">\theta</code>
(<code class="reqn">\theta</code> can be the <code class="reqn">f(k)</code> or <code class="reqn">\mu</code>),
and <code class="reqn">\alpha = 1 -</code> <code>prob</code>.
</p>
<p>The <code>"basic"</code> method produces intervals
(see Equation 5.6 by Davison and Hinkley 1997):
</p>
<p style="text-align: center;"><code class="reqn">(2\hat{\theta} - \theta^*_{[B(1-\alpha/2)]}, 2\hat{\theta} - \theta^*_{[B\alpha/2]}),</code>
</p>

<p>where <code class="reqn">\hat{\theta}</code> is the sample estimate of the parameter.
Note that this method can lead to negative confidence bounds, especially
when <code class="reqn">\hat{\theta}</code> is close to 0.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>bci</code></td>
<td>
<p>A numeric vector of length 2 with the bootstrap confidence interval
(lower bound, upper bound) for the parameter of interest. This interval is
obtained by bootstrapping node degrees in an LSMI with the optimal combination
of <code>n.seed</code> and <code>n.wave</code>
(the combination is reported in <code>best_combination</code>).</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Point estimate of the parameter of interest
(based on the LSMI with <code>n.seed</code> seeds and <code>n.wave</code> waves
reported in the <code>best_combination</code>).</p>
</td></tr>
<tr><td><code>best_combination</code></td>
<td>
<p>An integer vector of lenght 2 containing the optimal
<code>n.seed</code> and <code>n.wave</code> selected via cross-validation.</p>
</td></tr>
<tr><td><code>seeds</code></td>
<td>
<p>A vector of numeric IDs of the seeds that were used
in the LSMI with the optimal combination of <code>n.seed</code> and <code>n.wave</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chen Y, Gel YR, Lyubchich V, Nezafati K (2018).
&ldquo;Snowboot: bootstrap methods for network inference.&rdquo;
<em>The R Journal</em>, <b>10</b>(2), 95&ndash;113.
doi: <a href="https://doi.org/10.32614/RJ-2018-056">10.32614/RJ-2018-056</a>.<br /><br /> Davison AC, Hinkley DV (1997).
<em>Bootstrap Methods and Their Application</em>.
Cambridge University Press, Cambridge.<br /><br /> Efron B (1979).
&ldquo;Bootstrap methods: Another look at the jackknife.&rdquo;
<em>The Annals of Statistics</em>, <b>7</b>(1), 1&ndash;26.
doi: <a href="https://doi.org/10.1214/aos/1176344552">10.1214/aos/1176344552</a>.<br /><br /> Gel YR, Lyubchich V, Ramirez Ramirez LL (2017).
&ldquo;Bootstrap quantification of estimation uncertainties in network degree distributions.&rdquo;
<em>Scientific Reports</em>, <b>7</b>, 5807.
doi: <a href="https://doi.org/10.1038/s41598-017-05885-x">10.1038/s41598-017-05885-x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsmi">lsmi</a></code>, <code><a href="#topic+lsmi_union">lsmi_union</a></code>, <code><a href="#topic+boot_dd">boot_dd</a></code>, <code><a href="#topic+boot_ci">boot_ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- artificial_networks[[1]]
a &lt;- lsmi_cv(net, n.seeds = c(10, 20, 30), n.wave = 5, B = 100)

</code></pre>

<hr>
<h2 id='lsmi_dd'>Network Degree Distribution Estimated from Labeled Snowball
Sample with Multiple Inclusion (LSMI)</h2><span id='topic+lsmi_dd'></span>

<h3>Description</h3>

<p>lsmi_dd computes an empirical network degree distribution and estimates
mean degree based on data from an LSMI sample from a network;
see Equations 6 and 7 by Thompson et al. (2016)
and Equation 1 by Chen et al. (2018)
on the details of the calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsmi_dd(x = NULL, net, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsmi_dd_+3A_x">x</code></td>
<td>
<p>the LSMI sample obtained from the network <code>net</code>, for example,
with <code><a href="#topic+lsmi">lsmi</a></code> function or as a subset of the output
by <code><a href="#topic+lsmi_union">lsmi_union</a></code>.</p>
</td></tr>
<tr><td><code id="lsmi_dd_+3A_net">net</code></td>
<td>
<p>a network object that is a list containing:
</p>

<dl>
<dt><code>degree</code></dt><dd><p>the degree sequence of the network, which is
an <code>integer</code> vector of length <code class="reqn">n</code>;</p>
</dd>
<dt><code>edges</code></dt><dd><p>the edgelist, which is a two-column
matrix, where each row is an edge of the network;</p>
</dd>
<dt><code>n</code></dt><dd><p>the network order (i.e., number of nodes in the network).</p>
</dd>
</dl>

<p>The network object can be simulated by <code><a href="#topic+random_network">random_network</a></code>,
selected from the networks available in <code><a href="#topic+artificial_networks">artificial_networks</a></code>,
converged from an <code>igraph</code> object with <code><a href="#topic+igraph_to_network">igraph_to_network</a></code>,
etc.</p>
</td></tr>
<tr><td><code id="lsmi_dd_+3A_...">...</code></td>
<td>
<p>arguments passed to the <code><a href="#topic+lsmi">lsmi</a></code> function
(ignored if <code>x</code> is specified, see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The samples produced with <code><a href="#topic+lsmi">lsmi</a></code> or <code><a href="#topic+lsmi_union">lsmi_union</a></code> contain
just node IDs arranged into lists of seeds and waves (no details on the
node degrees or other node features). This information is
sufficient to study some properties of a network (e.g., network motifs &ndash;
not yet implemented in the package). To estimate a degree distribution or
mean degree, both the LSMI sample and the original network object are required.
If the LSMI object <code>x</code> is not supplied, the function will attempt
sampling an LSMI automatically, using the arguments supplied in &quot;<code>...</code>&quot;
that will be passed to the <code><a href="#topic+lsmi">lsmi</a></code> function.
</p>


<h3>Value</h3>

<p>A list object of class &quot;<code>snowboot</code>&quot; consisting of:
</p>
<table>
<tr><td><code>fk</code></td>
<td>
<p>A named numeric vector with estimated probabilities <code class="reqn">\hat{f}(k)</code>
of degrees <code class="reqn">k</code>, where <code class="reqn">k = 0, 1, \ldots,</code> <code>max(c(ds, dns))</code>
(i.e., <code class="reqn">k</code> ranges from 0 to the maximum node degree observed in the LSMI sample).
The names of the vector elements are <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>An estimate of the mean degree.</p>
</td></tr>
<tr><td><code>ds</code></td>
<td>
<p>An integer vector of degrees of seed nodes.</p>
</td></tr>
<tr><td><code>dns</code></td>
<td>
<p>An integer vector of degrees of non-seed nodes (i.e., nodes
recorded in the waves of neighbors).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chen Y, Gel YR, Lyubchich V, Nezafati K (2018).
&ldquo;Snowboot: bootstrap methods for network inference.&rdquo;
<em>The R Journal</em>, <b>10</b>(2), 95&ndash;113.
doi: <a href="https://doi.org/10.32614/RJ-2018-056">10.32614/RJ-2018-056</a>.<br /><br /> Thompson ME, Ramirez Ramirez LL, Lyubchich V, Gel YR (2016).
&ldquo;Using the bootstrap for statistical inference on random graphs.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>44</b>(1), 3&ndash;24.
doi: <a href="https://doi.org/10.1002/cjs.11271">10.1002/cjs.11271</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsmi">lsmi</a></code>, <code><a href="#topic+lsmi_union">lsmi_union</a></code>, <code><a href="#topic+boot_dd">boot_dd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- artificial_networks[[1]]

#Obtain an LSMI sample and, at the next step,
#use it to estimate the degree distribution:
lsmiSample &lt;- lsmi(net, n.seed = 5, n.wave = 3)
fkEstimate1 &lt;- lsmi_dd(lsmiSample, net)$fk

#Obtain an LSMI sample and estimate the degree
#distribution in a single step:
fkEstimate2 &lt;- lsmi_dd(net = net, n.seed = 5, n.wave = 3)$fk

#Use the output of lsmi_union to get the estimate:
lsmiUnionSample &lt;- lsmi_union(net, n.seeds = c(5, 10), n.wave = 3)
fkEstimate3 &lt;- lsmi_dd(lsmiUnionSample$lsmi_big, net)$fk

</code></pre>

<hr>
<h2 id='lsmi_union'>Snowball Sampling with Multiple Inclusions around Several Subsets of Seeds</h2><span id='topic+lsmi_union'></span>

<h3>Description</h3>

<p>Obtain one big LSMI &ndash; with <code>max(n.seeds)</code> seeds and <code>n.wave</code>
waves around each &ndash; and subsample seeds to create smaller LSMIs (with less
seeds and/or waves). The function is primarily used in cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsmi_union(net, n.seeds, n.wave, seeds = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsmi_union_+3A_net">net</code></td>
<td>
<p>a network object that is a list containing:
</p>

<dl>
<dt><code>degree</code></dt><dd><p>the degree sequence of the network, which is
an <code>integer</code> vector of length <code class="reqn">n</code>;</p>
</dd>
<dt><code>edges</code></dt><dd><p>the edgelist, which is a two-column
matrix, where each row is an edge of the network;</p>
</dd>
<dt><code>n</code></dt><dd><p>the network order (i.e., number of nodes in the network).</p>
</dd>
</dl>

<p>The network object can be simulated by <code><a href="#topic+random_network">random_network</a></code>,
selected from the networks available in <code><a href="#topic+artificial_networks">artificial_networks</a></code>,
converged from an <code>igraph</code> object with <code><a href="#topic+igraph_to_network">igraph_to_network</a></code>,
etc.</p>
</td></tr>
<tr><td><code id="lsmi_union_+3A_n.seeds">n.seeds</code></td>
<td>
<p>an integer vector of numbers of seeds for snowball sampling
(cf. a single integer <code>n.seed</code> in <code><a href="#topic+lsmi">lsmi</a></code>). Only
<code>n.seeds &lt;= n</code> are retained. If <code>seeds</code> is
specified, only values <code>n.seeds &lt; length(unique(seeds))</code> are retained
and automatically supplemented by <code>length(unique(seeds))</code>.</p>
</td></tr>
<tr><td><code id="lsmi_union_+3A_n.wave">n.wave</code></td>
<td>
<p>an integer defining the number of waves (order of the neighborhood)
to be recorded around the seed in the LSMI. For example, <code>n.wave = 1</code> corresponds to
an LSMI with the seed and its first neighbors. Note that the algorithm allows for
multiple inclusions.</p>
</td></tr>
<tr><td><code id="lsmi_union_+3A_seeds">seeds</code></td>
<td>
<p>a vector of numeric IDs of pre-specified seeds. If specified,
LSMIs are constructed around each such seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the produced LSMIs are slightly different from those described by
Gel et al. (2017). The current R implementation
produces smaller LSMIs by subsetting the seeds, not by new sampling of
seeds from the network and growing completely new LSMIs, as it was done by
Gel et al. (2017). See the details in Figure 3 by
Chen et al. (2018)
</p>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr><td><code>lsmi_big</code></td>
<td>
<p>LSMI with <code>max(n.seeds)</code> seeds (see the argument definition
above) and <code>n.wave</code> waves produced by the <code><a href="#topic+lsmi">lsmi</a></code> function.</p>
</td></tr>
<tr><td><code>sequence_seeds</code></td>
<td>
<p>A list of length equal to <code>length(n.seeds)</code>;
each element of the list is a random subset of the seeds' IDs, starting from
the largest (a set of size <code>max(n.seeds)</code>) to the smallest
(a set of size <code>min(n.seeds)</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chen Y, Gel YR, Lyubchich V, Nezafati K (2018).
&ldquo;Snowboot: bootstrap methods for network inference.&rdquo;
<em>The R Journal</em>, <b>10</b>(2), 95&ndash;113.
doi: <a href="https://doi.org/10.32614/RJ-2018-056">10.32614/RJ-2018-056</a>.<br /><br /> Gel YR, Lyubchich V, Ramirez Ramirez LL (2017).
&ldquo;Bootstrap quantification of estimation uncertainties in network degree distributions.&rdquo;
<em>Scientific Reports</em>, <b>7</b>, 5807.
doi: <a href="https://doi.org/10.1038/s41598-017-05885-x">10.1038/s41598-017-05885-x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_about_one_seed">sample_about_one_seed</a></code>, <code><a href="#topic+lsmi">lsmi</a></code>, <code><a href="#topic+lsmi_cv">lsmi_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- artificial_networks[[1]]
a &lt;- lsmi_union(net, n.seeds = c(5, 10, 15), n.wave = 2)

</code></pre>

<hr>
<h2 id='plot.snowboot'>Plot Degree Distribution Estimates</h2><span id='topic+plot.snowboot'></span>

<h3>Description</h3>

<p>Plot LSMI-based point estimates of probabilities of node degrees, <code class="reqn">\hat{f}(k)</code>, and
of mean degree, <code class="reqn">\hat{\mu}</code>, where <code class="reqn">k = 0, 1, \ldots</code> are the degrees.
The point estimates are supplemented with box-and-whisker plots
of bootstrapped values (if the input is a <code><a href="#topic+boot_dd">boot_dd</a></code> output) or element-wise
bootstrap confidence intervals (if the input is a <code><a href="#topic+boot_ci">boot_ci</a></code> output).
See Chen et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snowboot'
plot(
  x,
  k = NULL,
  plotmu = TRUE,
  plotlegend = TRUE,
  col0 = "gray50",
  lwd0 = 1,
  colpt = "royalblue3",
  lwdpt = 2,
  pchpt = 4,
  coli = "palegreen3",
  colibg = "palegreen",
  length = 0.1,
  boxwex = 0.4,
  legendargs = list(x = "topright", cex = 0.9, bty = "n"),
  las = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.snowboot_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+lsmi_dd">lsmi_dd</a></code>, <code><a href="#topic+boot_dd">boot_dd</a></code>, or <code><a href="#topic+boot_ci">boot_ci</a></code>.</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_k">k</code></td>
<td>
<p>an integer vector with degrees to plot.
By default, all degrees represented in <code>x</code> are plotted.</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_plotmu">plotmu</code></td>
<td>
<p>logical value indicating whether to plot the results for mean degree
(default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_plotlegend">plotlegend</code></td>
<td>
<p>logical value indicating whether to plot a legend
(default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_col0">col0</code></td>
<td>
<p>color to plot horizontal zero-line at <code class="reqn">f(k) = 0</code>.
Use <code>NA</code> for no plotting.</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_lwd0">lwd0</code></td>
<td>
<p>width of the horizontal zero-line at <code class="reqn">f(k) = 0</code>.</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_colpt">colpt</code></td>
<td>
<p>color for plotting point estimates.</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_lwdpt">lwdpt</code></td>
<td>
<p>line width for plotting point estimates.</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_pchpt">pchpt</code></td>
<td>
<p>point type for plotting point estimates
(see argument <code>pch</code> in <code><a href="graphics.html#topic+points">points</a></code>).</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_coli">coli</code></td>
<td>
<p>color for plotting lines or borders of box-plots for bootstrap estimates.</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_colibg">colibg</code></td>
<td>
<p>background color, if plotting boxplots of bootstrapped estimates
(see argument <code>border</code> in <code><a href="graphics.html#topic+boxplot">boxplot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_length">length</code></td>
<td>
<p>length of arrows, if plotting bootstrap confidence intervals
(see argument <code>length</code> in <code><a href="graphics.html#topic+arrows">arrows</a></code>).</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_boxwex">boxwex</code></td>
<td>
<p>argument of <code><a href="graphics.html#topic+boxplot">boxplot</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_legendargs">legendargs</code></td>
<td>
<p>additional arguments for plotting the legend
(see arguments in <code><a href="graphics.html#topic+legend">legend</a></code>).</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_las">las</code></td>
<td>
<p>argument of <code><a href="graphics.html#topic+plot">plot</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.snowboot_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to the <code><a href="graphics.html#topic+plot">plot</a></code> function.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chen Y, Gel YR, Lyubchich V, Nezafati K (2018).
&ldquo;Snowboot: bootstrap methods for network inference.&rdquo;
<em>The R Journal</em>, <b>10</b>(2), 95&ndash;113.
doi: <a href="https://doi.org/10.32614/RJ-2018-056">10.32614/RJ-2018-056</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- artificial_networks[[1]]
x &lt;- lsmi_dd(net = net, n.wave = 2, n.seed = 40)
plot(x)

x2 &lt;- boot_dd(x)
plot(x2, k = c(1:10))

x3 &lt;- boot_ci(x2, prob = 0.99)
plot(x3, k = c(1:10))

</code></pre>

<hr>
<h2 id='random_network'>Construct Artificial Networks</h2><span id='topic+random_network'></span>

<h3>Description</h3>

<p>This function constructs an artificial network from a given distribution.
Only 11 distributions are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_network(n, distrib, param = NULL, degree = NULL, take.p = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_network_+3A_n">n</code></td>
<td>
<p>the number of nodes in the desired network.</p>
</td></tr>
<tr><td><code id="random_network_+3A_distrib">distrib</code></td>
<td>
<p>an atomic character representing the desired degree
distribution. User may choose from 11 available distributions: &quot;fixed&quot;,
&quot;pois&quot;, &quot;ztpois&quot;, &quot;geom&quot;, &quot;nbinom&quot;, &quot;ztgeom&quot;, &quot;poly.log&quot;, &quot;logarithmic&quot;,
&quot;power.law&quot;, &quot;full&quot; (fully connected), or &quot;none&quot; (no element connected).</p>
</td></tr>
<tr><td><code id="random_network_+3A_param">param</code></td>
<td>
<p>the distribution parameters. If the function is &quot;fixed&quot;,
<code>param</code> is a vector of degrees.</p>
</td></tr>
<tr><td><code id="random_network_+3A_degree">degree</code></td>
<td>
<p>an optional vector of degrees that must be of length <code>n</code>.
The default is <code>degree = NULL</code>.</p>
</td></tr>
<tr><td><code id="random_network_+3A_take.p">take.p</code></td>
<td>
<p>a number between 0 and 1 representing the proportion to take
for elimination with each iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>edges</code></td>
<td>
<p>The edgelist of the network. A two column
<code>matrix</code> where each row is an edge.</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>The degree sequence of the network, which is
an <code>integer</code> vector of length n.</p>
</td></tr>
<tr><td><code>degree.left</code></td>
<td>
<p>A vector of length <code>n</code> that should be all zeroes.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The network order. The order for every network is 2000.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- random_network(1000, "poly.log", c(2, 13))
</code></pre>

<hr>
<h2 id='sample_about_one_seed'>Snowball Sampling with Multiple Inclusions around One Network Node</h2><span id='topic+sample_about_one_seed'></span>

<h3>Description</h3>

<p>This function obtains a labeled snowball with multiple inclusions (LSMI) sample,
starting from a single network node called seed. See Figure 1 by
Thompson et al. (2016) illustrating the algorithm
of sampling around one seed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_about_one_seed(net, seed, n.wave = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_about_one_seed_+3A_net">net</code></td>
<td>
<p>a network object that is a list containing:
</p>

<dl>
<dt><code>degree</code></dt><dd><p>the degree sequence of the network, which is
an <code>integer</code> vector of length <code class="reqn">n</code>;</p>
</dd>
<dt><code>edges</code></dt><dd><p>the edgelist, which is a two-column
matrix, where each row is an edge of the network;</p>
</dd>
<dt><code>n</code></dt><dd><p>the network order (i.e., number of nodes in the network).</p>
</dd>
</dl>

<p>The network object can be simulated by <code><a href="#topic+random_network">random_network</a></code>,
selected from the networks available in <code><a href="#topic+artificial_networks">artificial_networks</a></code>,
converged from an <code>igraph</code> object with <code><a href="#topic+igraph_to_network">igraph_to_network</a></code>,
etc.</p>
</td></tr>
<tr><td><code id="sample_about_one_seed_+3A_seed">seed</code></td>
<td>
<p>numeric ID of a seed to start the LSMI.</p>
</td></tr>
<tr><td><code id="sample_about_one_seed_+3A_n.wave">n.wave</code></td>
<td>
<p>an integer defining the number of waves (order of the neighborhood)
to be recorded around the seed in the LSMI. For example, <code>n.wave = 1</code> corresponds to
an LSMI with the seed and its first neighbors. Note that the algorithm allows for
multiple inclusions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sample_about_one_seed</code> returns a list of length <code>n.wave + 1</code>
containing ID of the seed (1st element of the output list), IDs of nodes in the
1st wave (2nd element of the list), ..., IDs of nodes in the wave <code>n.wave</code>
((<code>n.wave + 1</code>)th element of the list). If a wave has no nodes in it, the
corresponding element of the output contains <code>NA</code>.
</p>


<h3>References</h3>

<p>Thompson ME, Ramirez Ramirez LL, Lyubchich V, Gel YR (2016).
&ldquo;Using the bootstrap for statistical inference on random graphs.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>44</b>(1), 3&ndash;24.
doi: <a href="https://doi.org/10.1002/cjs.11271">10.1002/cjs.11271</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsmi">lsmi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- artificial_networks[[1]]
a &lt;- sample_about_one_seed(net, seed = 1, n.wave = 2)

</code></pre>

<hr>
<h2 id='vertboot'>Bootstrapping a Network with Vertex Bootstrap</h2><span id='topic+vertboot'></span>

<h3>Description</h3>

<p>This function bootstraps the original network using a vertex bootstrap technique.
See Snijders and Borgatti (1999)
and Chen et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertboot(m1, boot_rep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertboot_+3A_m1">m1</code></td>
<td>
<p>An adjacency matrix of the original network.</p>
</td></tr>
<tr><td><code id="vertboot_+3A_boot_rep">boot_rep</code></td>
<td>
<p>A positive integer number, the number of bootstrap replications.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of bootstrapped networks as adjacency matrices.
</p>


<h3>References</h3>

<p>Chen Y, Gel YR, Lyubchich V, Nezafati K (2018).
&ldquo;Snowboot: bootstrap methods for network inference.&rdquo;
<em>The R Journal</em>, <b>10</b>(2), 95&ndash;113.
doi: <a href="https://doi.org/10.32614/RJ-2018-056">10.32614/RJ-2018-056</a>.<br /><br /> Snijders TAB, Borgatti SP (1999).
&ldquo;Non-parametric standard errors and tests for network statistics.&rdquo;
<em>Connections</em>, <b>22</b>(2), 61&ndash;70.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph_ex &lt;- igraph::graph_from_edgelist(artificial_networks[[1]]$edges)
m1 &lt;- igraph::as_adjacency_matrix(graph_ex)
m1 &lt;- as.matrix(m1)
vertboot_out &lt;- vertboot(m1, 20)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
