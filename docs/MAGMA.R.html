<!DOCTYPE html><html lang="en"><head><title>Help for package MAGMA.R</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MAGMA.R}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adj_d_ratio'><p>adj_d_ratio</p></a></li>
<li><a href='#Balance_extract'><p>Balance_extract</p></a></li>
<li><a href='#Balance_MAGMA'><p>Balance_MAGMA</p></a></li>
<li><a href='#build_value_matrix'><p>build_value_matrix</p></a></li>
<li><a href='#cohen_d'><p>cohen_d</p></a></li>
<li><a href='#Density_overlap'><p>Density_overlap</p></a></li>
<li><a href='#distance_estimator'><p>distance_estimator</p></a></li>
<li><a href='#effect_nominal'><p>effect_nominal</p></a></li>
<li><a href='#effect_ordinal'><p>effect_ordinal</p></a></li>
<li><a href='#initial_unbalance'><p>initial_unbalance</p></a></li>
<li><a href='#inner_d'><p>inner_d</p></a></li>
<li><a href='#J_group_size'><p>J_group_size</p></a></li>
<li><a href='#MAGMA'><p>MAGMA</p></a></li>
<li><a href='#MAGMA_desc'><p>MAGMA_desc</p></a></li>
<li><a href='#MAGMA_exact'><p>MAGMA_exact</p></a></li>
<li><a href='#MAGMA_sim_data'><p>MAGMA simulated data set</p></a></li>
<li><a href='#match_iterative'><p>match_iterative</p></a></li>
<li><a href='#mean_g_meta'><p>mean_g_meta</p></a></li>
<li><a href='#Pillai_iterativ'><p>Pillai_iterativ</p></a></li>
<li><a href='#Plot_MAGMA'><p>Plot_MAGMA</p></a></li>
<li><a href='#row_nominal'><p>row_nominal</p></a></li>
<li><a href='#row_ordinal'><p>row_ordinal</p></a></li>
<li><a href='#Table_MAGMA'><p>Table_MAGMA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>MAny-Group MAtching</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Balancing quasi-experimental field research for effects of covariates is fundamental for drawing causal inference. Propensity Score Matching deals with this issue but current
    techniques are restricted to binary treatment variables. Moreover, they provide several solutions without providing a comprehensive framework on choosing the best model. The
    MAGMA R-package addresses these restrictions by offering nearest neighbor matching for two to four groups. It also includes the option to match data of a 2x2 design. In addition, 
    MAGMA includes a framework for evaluating the post-matching balance. The package includes functions for the matching process and matching reporting. We provide a tutorial on 
    MAGMA as vignette. More information on MAGMA can be found in Feuchter, M. D., Urban, J., Scherrer V., Breit, M. L., and Preckel F. (2022) <a href="https://osf.io/p47nc/">https://osf.io/p47nc/</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), tidyverse (&ge; 2.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel (&ge; 4.2), doParallel (&ge; 1.0.17), foreach (&ge; 1.5.2),
metafor (&ge; 4.4-0), robumeta (&ge; 2.1), psych (&ge; 2.3.9),
ggplot2 (&ge; 3.4.4), janitor (&ge; 2.2.0), flextable (&ge; 0.9.4) ,
overlapping (&ge; 2.1), purrr (&ge; 1.0.1), tibble (&ge; 3.2.1),
dplyr (&ge; 1.1.4), tidyselect (&ge; 1.2.0), stats (&ge; 4.2), rlang
(&ge; 1.1.1), stddiff (&ge; 3.1)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Author:</td>
<td>Julian Urban [aut, cre],
  Markus D. Feuchter [aut],
  Vsevolod Scherrer [aut],
  Moritz L. Breit [aut],
  Franzis Preckel [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julian Urban &lt;urbanj@uni-trier.de&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JulianUrban/MAGMA/issues">https://github.com/JulianUrban/MAGMA/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-27 06:44:52 UTC; urbanjn</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-27 07:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adj_d_ratio'>adj_d_ratio</h2><span id='topic+adj_d_ratio'></span>

<h3>Description</h3>

<p>adjusted d-ratio with respect to sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_d_ratio(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adj_d_ratio_+3A_input">input</code></td>
<td>
<p>An inner d object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computed the adjusted d_ratio with respect to sample size.
</p>


<h3>Value</h3>

<p>A vector containing the adjusted d-ratio in dependency of
sample size.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>

<hr>
<h2 id='Balance_extract'>Balance_extract</h2><span id='topic+Balance_extract'></span>

<h3>Description</h3>

<p>This function extracts the balance criteria or pairwise effects of a
<code><a href="#topic+Balance_MAGMA">Balance_MAGMA</a></code> result for a specified sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Balance_extract(Balance, samplesize, effects = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Balance_extract_+3A_balance">Balance</code></td>
<td>
<p>A result of <code><a href="#topic+Balance_MAGMA">Balance_MAGMA</a></code> See the function
<code><a href="#topic+Balance_MAGMA">Balance_MAGMA</a></code> for details.</p>
</td></tr>
<tr><td><code id="Balance_extract_+3A_samplesize">samplesize</code></td>
<td>
<p>An integer indicating the sample size for which the balance
criteria or pairwise effects should be extracted.</p>
</td></tr>
<tr><td><code id="Balance_extract_+3A_effects">effects</code></td>
<td>
<p>Indicates whether balance criteria or pairwise effects should
be extracted. The default value <em>FALSE</em> returns the balance criteria, while
<em>TRUE</em> leads to the extraction of pairwise effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a previous computed <code><a href="#topic+Balance_MAGMA">Balance_MAGMA</a></code> object, this function
enables the extraction of balance criteria or pairwise effects for any
desired sample size. This makes it possible to independently check the
balance for each possible sample size.
</p>


<h3>Value</h3>

<p>Depends on the effects argument. If <em>FALSE</em>, it returns in a vector
containing the balance criteria. If <em>TRUE</em>, it returns a vector containing
all possible pairwise effects.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Defining the names of the metric and binary covariates
covariates_vector &lt;- c("GPA_school", "IQ_score", "Motivation", "parents_academic", "gender")


# Estimating balance of a two-group matching using the data set
# 'MAGMA_sim_data'.
# Matching variable 'gifted_support' (received giftedness support yes or no)
Balance_gifted &lt;- Balance_MAGMA(Data = MAGMA_sim_data[MAGMA_sim_data$step_gifted &lt; 200, ],
                                group = "gifted_support",
                                covariates = covariates_vector,
                                step = "step_gifted")

# Balance criteria for 100 cases per group
# Balance criteria
Balance_100_gifted &lt;- Balance_extract(Balance = Balance_gifted,
                                      samplesize = 100,
                                      effects = FALSE)
Balance_100_gifted

# Pairwise effects
Balance_100_gifted_effects &lt;- Balance_extract(Balance = Balance_gifted,
                                              samplesize = 100,
                                              effects = TRUE)
Balance_100_gifted_effects


# 2x2 matching using the data set 'MAGMA_sim_data'
# Matching variables are 'gifted_support' (received giftedness support yes
# or no) and 'enrichment' (participated in enrichment or not)
# 'MAGMA_sim_data_gift_enrich' contains the result of the matching
# 2x2 matching is equivalent to four-group matching
MAGMA_sim_data_gift_enrich &lt;- MAGMA(Data = MAGMA_sim_data,
                                   group = c("gifted_support", "enrichment"),
                                   dist = "ps_2x2",
                                   cores = 2)


# Estimating balance. Covariates same as above
Balance_2x2 &lt;- Balance_MAGMA(Data = MAGMA_sim_data_gift_enrich,
                             group = c("gifted_support", "enrichment"),
                             covariates = covariates_vector,
                             step = "step") # Step created during matching
str(Balance_2x2)

# Balance criteria for 125 cases per group
# Balance criteria
Balance_125_2x2 &lt;- Balance_extract(Balance = Balance_2x2,
                                      samplesize = 125,
                                      effects = FALSE)
Balance_125_2x2

# Pairwise effects
Balance_125_2x2_effects &lt;- Balance_extract(Balance = Balance_2x2,
                                              samplesize = 125,
                                              effects = TRUE)
Balance_125_2x2_effects


</code></pre>

<hr>
<h2 id='Balance_MAGMA'>Balance_MAGMA</h2><span id='topic+Balance_MAGMA'></span>

<h3>Description</h3>

<p>This function computes all four balance criteria of 'MAGMA.R', namely
<em>Pillai's Trace</em>, <em>d-ratio</em>, <em>mean g</em>, and <em>adjusted d-ratio</em>. The
estimation considers the scale level of the variables. Balance
estimation is performed across various sample sizes. See Details for more
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Balance_MAGMA(
  Data,
  group,
  covariates,
  step = "step",
  verbose = TRUE,
  covariates_ordinal = NULL,
  covariates_nominal = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Balance_MAGMA_+3A_data">Data</code></td>
<td>
<p>A data frame containing at least the <em>grouping</em> variable, the
<em>step</em> variable from the main MAGMA-function (or other matching algorithms),
and all <em>covariates</em> of interest.</p>
</td></tr>
<tr><td><code id="Balance_MAGMA_+3A_group">group</code></td>
<td>
<p>A character specifying the name of
your grouping variable in data. Note that MAGMA can only match your data for
a maximum of four groups. For matching over two grouping variables (e.g., 2x2
design) is possible by specifying group as a character vector with a length
of two. In this case, each of the two grouping variables can only have two
levels.</p>
</td></tr>
<tr><td><code id="Balance_MAGMA_+3A_covariates">covariates</code></td>
<td>
<p>A character vector listing the names of all binary and
metric covariates of interest.</p>
</td></tr>
<tr><td><code id="Balance_MAGMA_+3A_step">step</code></td>
<td>
<p>A character specifying the step variable of the matching. Per
default, it is set to <em>step</em>, which corresponds the resulting
name of the main MAGMA function.</p>
</td></tr>
<tr><td><code id="Balance_MAGMA_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE indicating whether matching information should
be printed to the console.</p>
</td></tr>
<tr><td><code id="Balance_MAGMA_+3A_covariates_ordinal">covariates_ordinal</code></td>
<td>
<p>A character vector listing the names of all ordinal
covariates of interest.</p>
</td></tr>
<tr><td><code id="Balance_MAGMA_+3A_covariates_nominal">covariates_nominal</code></td>
<td>
<p>A character vector listing the names of all nominal
covariates of interest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes all four balance criteria of 'MAGMA.R', namely
Pillai's Trace, d-ratio, mean g, and adjusted d-ratio. This is an iterative
process including more cases with each iteration according to the step
variable. Thus, starting with cases having a small within-match distance,
larger distances are included with increasing iterations. As a minimum the
function specifies n &gt;= 20 per group. This does not imply that balance
criteria with such a small sample size can be estimated consistently. For
Pillai's Trace a higher minimum sample size can be possible. It depends on
the number of covariates to ensure a positive model identification.
Missing data for Pillai's Trace are excluded listwise, while for the other
balance criteria pairwise exclusion is applied.
</p>


<h3>Value</h3>

<p>A list of length four containing all balance criteria and all
pairwise effects with respect to group sample size.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>


<h3>References</h3>

<p>Pastore, M., Loro, P.A.D., Mingione, M., Calcagni, A. (2022). <em>overlapping: Estimation of Overlapping in Empirical Distributions</em>. R package version
2.1, (<a href="https://CRAN.R-project.org/package=overlapping">https://CRAN.R-project.org/package=overlapping</a>).
</p>
<p>Revelle, W. (2023). <em>psych: Procedures for Psychological, Psychometric, and Personality Research</em>. Northwestern University, Evanston, Illinois. R package version 2.3.6, (<a href="https://CRAN.R-project.org/package=psych">https://CRAN.R-project.org/package=psych</a>).
</p>
<p>Viechtbauer, W. (2010). Conducting meta-analyses in R with the metafor package. Journal of Statistical Software, 36(3), 1-48. (<a href="https://doi.org/10.18637/jss.v036.i03">doi:10.18637/jss.v036.i03</a>)
</p>
<p>Fisher, Z., Tipton, E., Zhipeng, H. (2023). <em>robumeta: Robust Variance Meta-Regression</em>. R package version 2.1,
(<a href="https://CRAN.R-project.org/package=robumeta">https://CRAN.R-project.org/package=robumeta</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Defining the names of the metric and binary covariates
covariates_vector &lt;- c("GPA_school", "IQ_score", "Motivation", "parents_academic", "gender")


# Estimating balance of a two-group matching using the data set
# 'MAGMA_sim_data'.
# Matching variable 'gifted_support' (received giftedness support yes or no)
# Using subsample only for faster execution.
Balance_gifted &lt;- Balance_MAGMA(Data = MAGMA_sim_data[MAGMA_sim_data$step_gifted &lt; 200, ],
                                group = "gifted_support",
                                covariates = covariates_vector,
                                step = "step_gifted")
str(Balance_gifted)


# 2x2 matching using the data set 'MAGMA_sim_data'
# Matching variables are 'gifted_support' (received giftedness support yes
# or no) and 'enrichment' (participated in enrichment or not)
# 'MAGMA_sim_data_gift_enrich' contains the result of the matching
# 2x2 matching is equivalent to four-group matching
MAGMA_sim_data_gift_enrich &lt;- MAGMA(Data = MAGMA_sim_data,
                                   group = c("gifted_support", "enrichment"),
                                   dist = "ps_2x2",
                                   cores = 2)


# Estimating balance. Covariates same as above
Balance_2x2 &lt;- Balance_MAGMA(Data = MAGMA_sim_data_gift_enrich,
                             group = c("gifted_support", "enrichment"),
                             covariates = covariates_vector,
                             step = "step") # step created during matching
str(Balance_2x2)



</code></pre>

<hr>
<h2 id='build_value_matrix'>build_value_matrix</h2><span id='topic+build_value_matrix'></span>

<h3>Description</h3>

<p>prepares distance estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_value_matrix(input_list, rep_element, name_ps = "distance_ps")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_value_matrix_+3A_input_list">input_list</code></td>
<td>
<p>Data with PS</p>
</td></tr>
<tr><td><code id="build_value_matrix_+3A_rep_element">rep_element</code></td>
<td>
<p>sample sizes per group</p>
</td></tr>
<tr><td><code id="build_value_matrix_+3A_name_ps">name_ps</code></td>
<td>
<p>names of PS in data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the PS inputs to prepare them for distance estimation.
</p>


<h3>Value</h3>

<p>the input for distance estimation
</p>

<hr>
<h2 id='cohen_d'>cohen_d</h2><span id='topic+cohen_d'></span>

<h3>Description</h3>

<p>This function estimates Cohen's d in <code><a href="#topic+MAGMA_desc">MAGMA_desc</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohen_d(Data, index_1, index_2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cohen_d_+3A_data">Data</code></td>
<td>
<p>A data frame that contains sample sizes, means, and standard
deviations.</p>
</td></tr>
<tr><td><code id="cohen_d_+3A_index_1">index_1</code></td>
<td>
<p>Number of group 1.</p>
</td></tr>
<tr><td><code id="cohen_d_+3A_index_2">index_2</code></td>
<td>
<p>Number of group_2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inner function of <code><a href="#topic+MAGMA_desc">MAGMA_desc</a></code> that computes Cohen's d using the
pooled SD.
</p>


<h3>Value</h3>

<p>A vector of pairwise Cohen'ds.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>

<hr>
<h2 id='Density_overlap'>Density_overlap</h2><span id='topic+Density_overlap'></span>

<h3>Description</h3>

<p>This function shows and quantifies the kernel density overlap of a variable
for two or more groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Density_overlap(
  Data,
  variable,
  group,
  variable_name = NULL,
  group_labels = NULL,
  group_name = NULL,
  step_num = NULL,
  step_var = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Density_overlap_+3A_data">Data</code></td>
<td>
<p>A data frame that contains the desired variable for density
plotting as well as the specified grouping variable.</p>
</td></tr>
<tr><td><code id="Density_overlap_+3A_variable">variable</code></td>
<td>
<p>A character specifying the variable for which the density
should be plotted (e.g., &quot;ps_gifted&quot;).</p>
</td></tr>
<tr><td><code id="Density_overlap_+3A_group">group</code></td>
<td>
<p>A character specifying the groups for which the density should
be plotted. Can be an independent group comparison (e.g., comparing matched
groups) or the comparison of pre and post matched samples.</p>
</td></tr>
<tr><td><code id="Density_overlap_+3A_variable_name">variable_name</code></td>
<td>
<p>A character specifying the name to appear
in the plot for the variable.</p>
</td></tr>
<tr><td><code id="Density_overlap_+3A_group_labels">group_labels</code></td>
<td>
<p>A character vector specifying the labels for the groups
to ppear in the legend of the plot.</p>
</td></tr>
<tr><td><code id="Density_overlap_+3A_group_name">group_name</code></td>
<td>
<p>A character specifying the name of the grouping variable
to appear in the title of the legend.</p>
</td></tr>
<tr><td><code id="Density_overlap_+3A_step_num">step_num</code></td>
<td>
<p>An integer specifying the number of cases to be included
per group in this post matching comparison. Is based on the step variable of
MAGMA.</p>
</td></tr>
<tr><td><code id="Density_overlap_+3A_step_var">step_var</code></td>
<td>
<p>A character specifying the name of the step variable.</p>
</td></tr>
<tr><td><code id="Density_overlap_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE indicating whether matching information should
be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enables the comparison of the density of variables for two
or more groups. It plots the kernel density separately for each group and
quantifies the amount of overlap.
</p>


<h3>Value</h3>

<p>A plot showing the kernel density for a specified variable separately
for specified groups and the quantification of this overlap.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>


<h3>References</h3>

<p>Pastore, M., Loro, P.A.D., Mingione, M., Calcagni, A. (2022). <em>overlapping: Estimation of Overlapping in Empirical Distributions</em>. R package version
2.1, <a href="https://CRAN.R-project.org/package=overlapping">https://CRAN.R-project.org/package=overlapping</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimating density overlap using the data set 'MAGMA_sim_data
# Estimating density overlap for 'ps_gifted' (propensity scores for
# giftedness support)
# Defining plot aesthetics with 'group', 'variable_name', "group_lables',
# and 'group_name'
# Estimating pre-matching density overlap by not specifying 'step_num' and
# 'step_var'
Density_overlap(Data = MAGMA_sim_data,
variable = "ps_gifted",
group = "gifted_support",
step_num = NULL,
step_var = NULL,
variable_name = "Propensity Score",
group_labels = c("No Support", "Support"),
group_name = "Gifted Support")


# Estimating density overlap using the matched data set
#'MAGMA_sim_data_gifted'
# Estimating density overlap for 'ps_gifted' (propensity scores for
# giftedness support)
# Defining plot aesthetics with 'group', 'variable_name', 'group_lables',
# and 'group_name'
# Estimating post-matching overlap for 250 cases per group ('step_num')
# Name of the step variable is 'step'
Density_overlap(Data = MAGMA_sim_data,
variable = "ps_gifted",
group = "gifted_support",
step_num = 250,
step_var = "step_gifted",
variable_name = "Propensity Score",
group_labels = c("No Support", "Support"),
group_name = "Gifted Support")

# Estimating density overlap using the data set 'MAGMA_sim_data
# Estimating density overlap for 'teacher_ability_rating' (ability rated
# from teacher as below average, average, or above average)
# Defining plot aesthetics with 'group', 'variable_name', 'group_lables',
# and 'group_name'
# Estimating pre-matching density overlap by not specifying 'step_num' and
# 'step_var'
Density_overlap(Data = MAGMA_sim_data,
variable = "GPA_school",
group = "teacher_ability_rating",
variable_name = "School Achievement",
group_labels = c("Low", "Medium", "High"),
group_name = "Rating")

</code></pre>

<hr>
<h2 id='distance_estimator'>distance_estimator</h2><span id='topic+distance_estimator'></span>

<h3>Description</h3>

<p>estimates distance in <code><a href="#topic+MAGMA">MAGMA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_estimator(data, means, variance, cores, inp = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_estimator_+3A_data">data</code></td>
<td>
<p>A matrix containing all possible combinations.</p>
</td></tr>
<tr><td><code id="distance_estimator_+3A_means">means</code></td>
<td>
<p>A matrix containing all row means of all possible matches.</p>
</td></tr>
<tr><td><code id="distance_estimator_+3A_variance">variance</code></td>
<td>
<p>A numeric indicating the variance of the propensity scores.</p>
</td></tr>
<tr><td><code id="distance_estimator_+3A_cores">cores</code></td>
<td>
<p>An integer defining the number of cores used for
parallel computation.</p>
</td></tr>
<tr><td><code id="distance_estimator_+3A_inp">inp</code></td>
<td>
<p>input parameter for parallel distance computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an inner function of <code><a href="#topic+MAGMA">MAGMA</a></code>. It estimates the
distance of all possible matches.
</p>


<h3>Value</h3>

<p>A matrix of distance for each case of each possible match.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>

<hr>
<h2 id='effect_nominal'>effect_nominal</h2><span id='topic+effect_nominal'></span>

<h3>Description</h3>

<p>Computes descriptive statistics and effect size for nominal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effect_nominal(Data, group, variable)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="effect_nominal_+3A_data">Data</code></td>
<td>
<p>A data set</p>
</td></tr>
<tr><td><code id="effect_nominal_+3A_group">group</code></td>
<td>
<p>A character specifying the grouping variable</p>
</td></tr>
<tr><td><code id="effect_nominal_+3A_variable">variable</code></td>
<td>
<p>Variables for which the effect should be estimated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes descriptive statistics and effect size for nominal
data.
</p>


<h3>Value</h3>

<p>A vector or matrix containing nominal effect sizes
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>

<hr>
<h2 id='effect_ordinal'>effect_ordinal</h2><span id='topic+effect_ordinal'></span>

<h3>Description</h3>

<p>Computes descriptive statistics and effect size for ordinal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effect_ordinal(Data, group, variable)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="effect_ordinal_+3A_data">Data</code></td>
<td>
<p>A data set</p>
</td></tr>
<tr><td><code id="effect_ordinal_+3A_group">group</code></td>
<td>
<p>A character specifying the grouping variable</p>
</td></tr>
<tr><td><code id="effect_ordinal_+3A_variable">variable</code></td>
<td>
<p>Variables for which the effect should be estimated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes descriptive statistics and effect size for ordinal
data.
</p>


<h3>Value</h3>

<p>A vector or matrix containing ordinal effect sizes
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>

<hr>
<h2 id='initial_unbalance'>initial_unbalance</h2><span id='topic+initial_unbalance'></span>

<h3>Description</h3>

<p>This function computes all four balance criteria of 'MAGMA.R,' namely
<em>Pillai's Trace</em>, <em>d-ratiO</em>, <em>mean g</em>, and <em>adjusted d-ratio</em> for the
unmatched data set. This enables comparison of initial unbalance with
the balance after matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial_unbalance(
  Data,
  group,
  covariates,
  verbose = TRUE,
  covariates_ordinal = NULL,
  covariates_nominal = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initial_unbalance_+3A_data">Data</code></td>
<td>
<p>A data frame containing at least the <em>grouping</em> variable and all
<em>covariates</em> of interest.</p>
</td></tr>
<tr><td><code id="initial_unbalance_+3A_group">group</code></td>
<td>
<p>A character specifying the name of
your grouping variable in data. Note that MAGMA can only match your data for
a maximum of 4 groups. For matching over two grouping variables (e.g., 2x2
design) is possible by specifying group as a character vector with a length
of two. In this case each or the two grouping variables can only have two
levels.</p>
</td></tr>
<tr><td><code id="initial_unbalance_+3A_covariates">covariates</code></td>
<td>
<p>A character vector listing the names of all binary and
metric covariates of interest.</p>
</td></tr>
<tr><td><code id="initial_unbalance_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE indicating whether matching information should
be printed to the console.</p>
</td></tr>
<tr><td><code id="initial_unbalance_+3A_covariates_ordinal">covariates_ordinal</code></td>
<td>
<p>A character vector listing the names of all ordinal
covariates of interest.</p>
</td></tr>
<tr><td><code id="initial_unbalance_+3A_covariates_nominal">covariates_nominal</code></td>
<td>
<p>A character vector listing the names of all nominal
covariates of interest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes all four Balance criteria of 'MAGMA.R', namely
Pillai's Trace, d-ratio, mean g, and adjusted d-ratio for the overall
samples. Missing data for Pillai's Trace are excluded listwise, while for
the other balance criteria pairwise exclusion is applied.
</p>


<h3>Value</h3>

<p>A numeric vector of length 4 containing the balance
criteria for the unmatched sample.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>


<h3>References</h3>

<p>Pastore, M., Loro, P.A.D., Mingione, M., Calcagni, A. (2022). <em>overlapping: Estimation of Overlapping in Empirical Distributions</em>. R package version
2.1, (<a href="https://CRAN.R-project.org/package=overlapping">https://CRAN.R-project.org/package=overlapping</a>).
</p>
<p>Revelle, W. (2023). <em>psych: Procedures for Psychological, Psychometric, and Personality Research</em>. Northwestern University, Evanston, Illinois. R package version 2.3.6, (<a href="https://CRAN.R-project.org/package=psych">https://CRAN.R-project.org/package=psych</a>)
</p>
<p>Viechtbauer, W. (2010). Conducting meta-analyses in R with the metafor package. Journal of Statistical Software, 36(3), 1-48. (<a href="https://doi.org/10.18637/jss.v036.i03">doi:10.18637/jss.v036.i03</a>)
</p>
<p>Fisher, Z., Tipton, E., Zhipeng, H. (2023). <em>robumeta: Robust Variance Meta-Regression</em>. R package version 2.1,
(<a href="https://CRAN.R-project.org/package=robumeta">https://CRAN.R-project.org/package=robumeta</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defining covariates for balance estimation
covariates_vector &lt;- c("GPA_school", "IQ_score", "Motivation", "parents_academic", "gender")

# Computing initial unbalance using the data set 'MAGMA_sim_data'
# Computing initial unbalance for the variable 'gifted_support' (received
# giftedness support yes or no)
unbalance_gifted &lt;- initial_unbalance(Data = MAGMA_sim_data,
                                      group = "gifted_support",
                                      covariates = covariates_vector)
unbalance_gifted

# Computing initial unbalance using the data set 'MAGMA_sim_data'
# Computing initial unbalance for the variable 'teacher_ability_rating'
# (ability rated from teacher as below average, average, or above average)
unbalance_tar &lt;- initial_unbalance(Data = MAGMA_sim_data,
                                  group = "teacher_ability_rating",
                                  covariates = covariates_vector)
unbalance_tar

# Computing initial unbalance using the data set 'MAGMA_sim_data'
# Computing initial unbalance for the variables 'gifted_support' (received
# giftedness support yes or no) and 'enrichment' (participated in enrichment
# or not)
unbalance_2x2 &lt;- initial_unbalance(Data = MAGMA_sim_data,
                                  group = c("gifted_support", "enrichment"),
                                  covariates = covariates_vector)
unbalance_2x2


</code></pre>

<hr>
<h2 id='inner_d'>inner_d</h2><span id='topic+inner_d'></span>

<h3>Description</h3>

<p>d-ratio and pairwise Cohen's d with respect to sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_d(da, gr, co, st, co_ord = NULL, co_nom = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inner_d_+3A_da">da</code></td>
<td>
<p>Specifying the data frame or tibble with the data.</p>
</td></tr>
<tr><td><code id="inner_d_+3A_gr">gr</code></td>
<td>
<p>A character vector specifying the IVs.</p>
</td></tr>
<tr><td><code id="inner_d_+3A_co">co</code></td>
<td>
<p>A character vector naming the DVs.</p>
</td></tr>
<tr><td><code id="inner_d_+3A_st">st</code></td>
<td>
<p>A character naming the variable for iteratively inclusion</p>
</td></tr>
<tr><td><code id="inner_d_+3A_co_ord">co_ord</code></td>
<td>
<p>A character vector naming the ordinal DVs.</p>
</td></tr>
<tr><td><code id="inner_d_+3A_co_nom">co_nom</code></td>
<td>
<p>A character vector naming the nominal DVs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computed the d-ratio and all pairwise effects
with respect to sample size.
</p>


<h3>Value</h3>

<p>A list of length two. The first element is a matrix including all
pairwise effects. The second is a vector expressing d-ratio
in dependency of sample size.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>

<hr>
<h2 id='J_group_size'>J_group_size</h2><span id='topic+J_group_size'></span>

<h3>Description</h3>

<p>inner function of <code><a href="#topic+mean_g_meta">mean_g_meta</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>J_group_size(group_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="J_group_size_+3A_group_size">group_size</code></td>
<td>
<p>A numeric defining the max sample size for which J
should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes J over samples sizes necessary for Hedges' g.
</p>


<h3>Value</h3>

<p>A vector of J's in dependency of sample size.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>

<hr>
<h2 id='MAGMA'>MAGMA</h2><span id='topic+MAGMA'></span>

<h3>Description</h3>

<p>This function conducts many group matching for 2 to 4 groups. It augments
the original data set by the relevant 'MAGMA.R' variables. For details, see
below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAGMA(Data, group, dist, cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAGMA_+3A_data">Data</code></td>
<td>
<p>A data frame or tibble containing at least your grouping and
distance variable. Data needs to be specified in your environment.</p>
</td></tr>
<tr><td><code id="MAGMA_+3A_group">group</code></td>
<td>
<p>A character specifying the name of
your grouping variable in the data. Note that MAGMA can only match your data
for a maximum of 4 groups. Matching over two grouping variables (e.g., 2x2
Design) is possible by specifying group as a character vector with a length
of two. In this case, each or the 2 grouping variables can only have two
levels.</p>
</td></tr>
<tr><td><code id="MAGMA_+3A_dist">dist</code></td>
<td>
<p>A character specifying the name of your distance
variable in data.</p>
</td></tr>
<tr><td><code id="MAGMA_+3A_cores">cores</code></td>
<td>
<p>An integer defining the number of cores used for
parallel computation.</p>
</td></tr>
<tr><td><code id="MAGMA_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE indicating whether matching information should
be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function conducts nearest neighbor many group matching. It is
applicable for two to four groups or a 2x2 design. As output, this function
augments your original data by the variables <em>weight</em>, <em>step</em>, <em>distance</em>,
and <em>ID</em>. Weight indicates whether a case was matched. Step specifies the
iteration in which a case was matched. It also shows which cases were matched
together. Distance indicates the mean difference within a match. Since
matches with a lower distance are matched in an earlier iteration, step and
distance are strongly correlated.
This function has some CPU and RAM load. In most four-group applications and
three-group applications with large sample size, RAM may be not sufficient.
Therefore MAGMA switches to random quasi-systematic matching. If this is the
case, MAGMA informs you. The output of the function does not change, but
balance might be slightly affected.
</p>


<h3>Value</h3>

<p>Your input data frame augmented with matching
relevant variables, namely <em>weight</em>, <em>step</em>, <em>distance</em>, and <em>ID</em>. In case
of missing values on the distance or group variable, MAGMA excludes them for
the matching process. The returned data set does not contain those excluded
cases. For more information, see Details.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Running this code will take a while
# Two-group exact matching using the data set 'MAGMA_sim_data'
# Matching variable 'gifted_support' (received giftedness support yes or no)
# 'MAGMA_sim_data_gifted' contains the result of the matching
MAGMA_sim_data_gifted &lt;- MAGMA(Data = MAGMA_sim_data,
                                group = "gifted_support",
                                dist = "ps_gifted",
                                cores = 1)
head(MAGMA_sim_data_gifted)


# Two-group exact matching using the data set 'MAGMA_sim_data'
# Matching variable 'teacher_ability_rating' (ability rated from teacher as
# below average, average, or above average)
# MAGMA_sim_data_tar' contains the result of the matching
# Cores per default = 1
MAGMA_sim_data_tar &lt;- MAGMA(Data = MAGMA_sim_data,
                            group = "teacher_ability_rating",
                            dist = "ps_tar")
head(MAGMA_sim_data_tar)

# 2x2 matching using the data set 'MAGMA_sim_data'
# Matching variables are 'gifted_support' (received giftedness support yes
# or no) and 'enrichment' (participated in enrichment or not)
# 'MAGMA_sim_data_gift_enrich' contains the result of the matching
# 2x2 matching is equal to four-group matching
MAGMA_sim_data_gift_enrich &lt;- MAGMA(Data = MAGMA_sim_data,
                                   group = c("gifted_support", "enrichment"),
                                   dist = "ps_2x2",
                                   cores = 2)
head(MAGMA_sim_data_gift_enrich)


</code></pre>

<hr>
<h2 id='MAGMA_desc'>MAGMA_desc</h2><span id='topic+MAGMA_desc'></span>

<h3>Description</h3>

<p>This function provides pre- and post-matching descriptive statistics and
effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAGMA_desc(
  Data,
  covariates,
  group,
  step_num = NULL,
  step_var = NULL,
  filename = NULL,
  verbose = TRUE,
  covariates_ordinal = NULL,
  covariates_nominal = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAGMA_desc_+3A_data">Data</code></td>
<td>
<p>A data frame that contains the desired variable for density
plotting as well as the specified grouping variable.</p>
</td></tr>
<tr><td><code id="MAGMA_desc_+3A_covariates">covariates</code></td>
<td>
<p>A character vector specifying the variable names of the
binary and metric variables for which the descriptive statistics should be
computed.</p>
</td></tr>
<tr><td><code id="MAGMA_desc_+3A_group">group</code></td>
<td>
<p>A character (vector) specifying the groups for which
differentiated statistics should be computed.</p>
</td></tr>
<tr><td><code id="MAGMA_desc_+3A_step_num">step_num</code></td>
<td>
<p>An integer specifying the number of cases to be
included per group in this post matching comparison (e.g., 100). If no value
is specified, pre-matching statistics are computed. Is based on the step
variable of MAGMA. Optional argument.</p>
</td></tr>
<tr><td><code id="MAGMA_desc_+3A_step_var">step_var</code></td>
<td>
<p>A character specifying the name of the step
variable in the data set. If no value is specified, pre matching
statistics are computed. Optional argument.</p>
</td></tr>
<tr><td><code id="MAGMA_desc_+3A_filename">filename</code></td>
<td>
<p>A character specifying the filename that
the resulting Word document with the Table should have. Optional argument.</p>
</td></tr>
<tr><td><code id="MAGMA_desc_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE indicating whether matching information should
be printed to the console.</p>
</td></tr>
<tr><td><code id="MAGMA_desc_+3A_covariates_ordinal">covariates_ordinal</code></td>
<td>
<p>A character vector specifying the variable names of
the ordinal variables for which the descriptive statistics should be computed.</p>
</td></tr>
<tr><td><code id="MAGMA_desc_+3A_covariates_nominal">covariates_nominal</code></td>
<td>
<p>A character vector specifying the variable names of
the nominal variables for which the descriptive statistics should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enables the computation of descriptive statistics for the
overall sample and specified groups. Additional, pairwise effects according
to the respective scale level are computed.
</p>


<h3>Value</h3>

<p>A table of descriptive statistics and pairwise effects for pre- or
post-matching samples.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defining covariates
covariates_gifted &lt;- c("GPA_school", "IQ_score", "Motivation", "parents_academic", "gender")

# Estimating pre-matching descriptive statistics and pairwise effects using
# the data set 'MAGMA_sim_data'
# Estimating statistics for grouping variable 'gifted support' (received
# giftedness support yes or no)
MAGMA_desc(Data = MAGMA_sim_data,
           covariates = covariates_gifted,
           group =  "gifted_support")


# Estimating post-matching descriptive statistics and pairwise effects using
# the data set 'MAGMA_sim_data'
# Estimating statistics for grouping variable 'gifted support' (received
# giftedness support yes or no)
# Estimating statistics for 100 cases per group
MAGMA_desc(Data = MAGMA_sim_data,
           covariates = covariates_gifted,
           group =  "gifted_support",
           step_num = 100,
           step_var = "step_gifted")

</code></pre>

<hr>
<h2 id='MAGMA_exact'>MAGMA_exact</h2><span id='topic+MAGMA_exact'></span>

<h3>Description</h3>

<p>This function conducts exact many group matching for 2 to 4 groups. Exact
means that only cases with the same value on the exact variable can be
matched. It augments the original data set by relevant 'MAGMA.R' variables.
For details, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAGMA_exact(Data, group, dist, exact, cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAGMA_exact_+3A_data">Data</code></td>
<td>
<p>A data frame or tibble containing at least your grouping and
distance variable. Data needs to be specified in your environment.</p>
</td></tr>
<tr><td><code id="MAGMA_exact_+3A_group">group</code></td>
<td>
<p>A character specifying the name of
your grouping variable in the data. Note that MAGMA can only match your data
for a maximum of 4 groups. Matching over two grouping variables (e.g., 2x2
Design) is possible by specifying group as a character vector with a length
of two. In this case, each or the 2 grouping variables can only have two
levels.</p>
</td></tr>
<tr><td><code id="MAGMA_exact_+3A_dist">dist</code></td>
<td>
<p>A character specifying the name of your distance
variable in data.</p>
</td></tr>
<tr><td><code id="MAGMA_exact_+3A_exact">exact</code></td>
<td>
<p>A character specifying the name of the exact variable.
Only cases with the same value on this variable can be matched.</p>
</td></tr>
<tr><td><code id="MAGMA_exact_+3A_cores">cores</code></td>
<td>
<p>An integer defining the number of cores used for
parallel computation.</p>
</td></tr>
<tr><td><code id="MAGMA_exact_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE indicating whether matching information should
be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function conducts nearest neighbor exact many group matching. It is
applicable for two to four groups or a 2x2 design. As output, this function
augments your original data by the variables <em>weight</em>, <em>step</em>, <em>distance</em>,
and <em>ID</em>. Weight indicates whether a case was matched. Step specifies the
iteration in which a case was matched. It also shows which cases were
matched together. Distance indicates the mean difference within a match.
Since matches with a lower distance are matched in an earlier iteration,
step and distance are strongly correlated.
Exact matching means that only cases with the same value on the exact
variable can be matched. As example, only person of the same gender, the
same school, or the same organization are possible matches. For standard
matching, see <code><a href="#topic+MAGMA">MAGMA</a></code>
</p>


<h3>Value</h3>

<p>Your input data frame of valid cases augmented with matching
relevant variables, namely <em>weight</em>, <em>step</em>, <em>distance</em>, and <em>ID</em>. In case
of missing values on the distance or group variable, MAGMA_exact excludes
them for the matching process. The returned data set does not contain those
excluded cases. For more information, see Details.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Running this code will take a while
# Two-group exact matching using the data set 'MAGMA_sim_data'
# Matching variable 'gifted_support' (received giftedness support yes or no)
# 'MAGMA_sim_data_gifted_exact' contains the result of the matching
# Exact matching for 'enrichment' (participated in enrichment or not)
# Students that participated can only be matched with other
# students that participated and vice versa
MAGMA_sim_data_gifted_exact &lt;- MAGMA_exact(Data = MAGMA_sim_data[c(1:20), ],
                                           group = "gifted_support",
                                           dist = "ps_gifted",
                                           exact = "enrichment",
                                           cores = 1)
head(MAGMA_sim_data_gifted_exact)


# Conducting three-group matching using the data set 'MAGMA_sim_data'
# Matching variable 'teacher_ability_rating' (ability rated from teacher as
# below average, average, or above average)
# 'MAGMA_sim_data_tar_exact' contains the result of the matching
# Exact matching for gender (male or female)
# Male students can only be matched to male students, female students can only
# be matched to female students
# Cores per default = 1
MAGMA_sim_data_tar_exact&lt;- MAGMA_exact(Data = MAGMA_sim_data,
                                       group = "teacher_ability_rating",
                                       dist = "ps_tar",
                                       exact = "gender")
head(MAGMA_sim_data_tar_exact)

# 2x2 matching using the data set 'MAGMA_sim_data'
# Matching variables are 'gifted_support' (received giftedness support yes
# or no) and 'enrichment' (participated in enrichment or not)
# 'MAGMA_sim_data_gift_enrich_exact' contains the result of the matching
# 2x2 matching is equal to four-group matching
# Exact matching for for teacher rated ability (ability rated from teacher as
# below average, average, or above average)
# Below average students can only be matched to other below average rated
# students, average rated students can be matched with other average rated
# students, and above average rated students can only be matched to other
# above average rated students
MAGMA_sim_data_gift_enrich_exact &lt;- MAGMA_exact(Data = MAGMA_sim_data,
                                                group = c("gifted_support", "enrichment"),
                                                dist = "ps_2x2",
                                                exact = "teacher_ability_rating",
                                                cores = 2)
head(MAGMA_sim_data_gift_enrich_exact)


</code></pre>

<hr>
<h2 id='MAGMA_sim_data'>MAGMA simulated data set</h2><span id='topic+MAGMA_sim_data'></span>

<h3>Description</h3>

<p>The 'MAGMA.R' simulated data set contains 14 variables of 800 cases. It is
used as example in the vignette and the help pages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAGMA_sim_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 17 variables of 800 cases.
</p>

<dl>
<dt>ID</dt><dd><p>: Individual ID for each case</p>
</dd>
<dt>gender</dt><dd><p>: Binary variable indicating gender of a participant</p>
</dd>
<dt>gifted_support</dt><dd><p>: Binary variable that specifies whether a case received
giftedness support (1) or not (0)</p>
</dd>
<dt>teacher_ability_rating</dt><dd><p>: Three-step ordinal variable ranging from 1 to
3 indicating increasing eacher rated ability of a case</p>
</dd>
<dt>enrichment</dt><dd><p>: Binary variable that indicates whether a case participated
in an afternoon enrichment program</p>
</dd>
<dt>parents_academic</dt><dd><p>: Binary variable that indicates whether at least one
parent of a case has an academic background</p>
</dd>
<dt>GPA_school</dt><dd><p>: Variable ranging from 1 to 6 that indicates a case's high
school GPA. Lower values indicate higher achievement</p>
</dd>
<dt>IQ_score</dt><dd><p>: Variable indicating the normed IQ score of a case</p>
</dd>
<dt>Motivation</dt><dd><p>: The scale score of a case in a motivational questionnaire</p>
</dd>
<dt>college_GPA</dt><dd><p>: variable ranging from 1 to 6 that indicates a case's
college GPA. Lower values indicate higher achievement</p>
</dd>
<dt>support_enrichment</dt><dd><p>: Multinomial variable representing the combination
of gifted support and enrichment</p>
</dd>
<dt>ps_tar</dt><dd><p>: Propensity score of twangs mnps function for
teacher_ability_rating</p>
</dd>
<dt>ps_2x2</dt><dd><p>: Propensity score of twangs mnps function for
support_enrichment</p>
</dd>
<dt>ps_gifted</dt><dd><p>: Propensity score of twangs ps function for gifted support</p>
</dd>
<dt>step_gifted</dt><dd><p>: Indicates step of MAGMA-matching for gifted support</p>
</dd>
<dt>weight_gifted</dt><dd><p>: Indicates weight of MAGMA-matching for gifted support</p>
</dd>
<dt>distance_gifted</dt><dd><p>: Indicates distance of MAGMA-matching for gifted
support</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated data
</p>

<hr>
<h2 id='match_iterative'>match_iterative</h2><span id='topic+match_iterative'></span>

<h3>Description</h3>

<p>matches Cases iteratively during the matching process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_iterative(distance_input, output_list, rep_elements)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_iterative_+3A_distance_input">distance_input</code></td>
<td>
<p>distance matrix to extract lowest distance</p>
</td></tr>
<tr><td><code id="match_iterative_+3A_output_list">output_list</code></td>
<td>
<p>output where MAGMA results get stored</p>
</td></tr>
<tr><td><code id="match_iterative_+3A_rep_elements">rep_elements</code></td>
<td>
<p>sample sizes per group</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function conducts the matching process, by extracting the match with
the lowest distance.
</p>


<h3>Value</h3>

<p>A matched sample including the variables step, weight &amp; distance
</p>

<hr>
<h2 id='mean_g_meta'>mean_g_meta</h2><span id='topic+mean_g_meta'></span>

<h3>Description</h3>

<p>Mean standardized effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_g_meta(input, number_groups)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_g_meta_+3A_input">input</code></td>
<td>
<p>An inner d object.</p>
</td></tr>
<tr><td><code id="mean_g_meta_+3A_number_groups">number_groups</code></td>
<td>
<p>A numeric specifying the number of groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the mean effect. Method varies between two and
many group matchings.
</p>


<h3>Value</h3>

<p>A vector containing the mean g in dependency of sample size.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>

<hr>
<h2 id='Pillai_iterativ'>Pillai_iterativ</h2><span id='topic+Pillai_iterativ'></span>

<h3>Description</h3>

<p>Pillai's Trace with respect to sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pillai_iterativ(da, gr, co, st)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pillai_iterativ_+3A_da">da</code></td>
<td>
<p>Specifying the data frame or tibble with the data.</p>
</td></tr>
<tr><td><code id="Pillai_iterativ_+3A_gr">gr</code></td>
<td>
<p>A character vector specifying the IVs.</p>
</td></tr>
<tr><td><code id="Pillai_iterativ_+3A_co">co</code></td>
<td>
<p>A character vector naming the DVs.</p>
</td></tr>
<tr><td><code id="Pillai_iterativ_+3A_st">st</code></td>
<td>
<p>A character naming the variable for iteratively inclusion</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes Pillai's Trace for increasing sample size.
</p>


<h3>Value</h3>

<p>A vector containing Pillai's Trace in dependency of sample size. If two
grouping variables were specified, the output is a matrix containing
Pillai's Trace for both IVs and their ineraction.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>

<hr>
<h2 id='Plot_MAGMA'>Plot_MAGMA</h2><span id='topic+Plot_MAGMA'></span>

<h3>Description</h3>

<p>Plots for balance with respect to sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot_MAGMA(
  Balance,
  criterion = c("Pillai", "d_ratio", "mean_g", "Adj_d_ratio")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot_MAGMA_+3A_balance">Balance</code></td>
<td>
<p>A result of Balance_MAGMA. Compare the function
<code><a href="#topic+Balance_MAGMA">Balance_MAGMA</a></code>.</p>
</td></tr>
<tr><td><code id="Plot_MAGMA_+3A_criterion">criterion</code></td>
<td>
<p>A character vector specifying for which balance criteria
a plot should be created. Default is all criteria.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates R-Plots using ggplot2 to show the balance trend over
sample size.
</p>


<h3>Value</h3>

<p>R Plots showing the balance trend over sample size.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This function bases on a MAGMA function as well as Balance_MAGMA
# To run examples, copy them into your console or script
# Defining the names of the metric and binary covariates
covariates_vector &lt;- c("GPA_school", "IQ_score", "Motivation", "parents_academic", "gender")

#  Estimating balance of a two-group matching using the data set
# 'MAGMA_sim_data'.
# Matching variable 'gifted_support' (received giftedness support yes or no)
Balance_gifted &lt;- Balance_MAGMA(Data = MAGMA_sim_data[MAGMA_sim_data$step_gifted &lt; 150, ],
                                group = "gifted_support",
                                covariates = covariates_vector,
                                step = "step_gifted") 

Plot_MAGMA(Balance = Balance_gifted,
           criterion = "Adj_d_ratio") #Using default to plot all criteria


# 2x2 matching using the data set 'MAGMA_sim_data'
# Matching variables are 'gifted_support' (received giftedness support yes
# or no) and 'enrichment' (participated in enrichment or not)
# 'MAGMA_sim_data_gift_enrich' contains the result of the matching
# 2x2 matching is equivalent to four-group matching
MAGMA_sim_data_gift_enrich &lt;- MAGMA(Data = MAGMA_sim_data,
                                   group = c("gifted_support", "enrichment"),
                                   dist = "ps_2x2",
                                   cores = 2)


# Estimating balance. Covariates same as above
Balance_2x2 &lt;- Balance_MAGMA(Data = MAGMA_sim_data_gift_enrich,
                             group = c("gifted_support", "enrichment"),
                             covariates = covariates_vector,
                             step = "step") #step created during matching

Plot_MAGMA(Balance = Balance_2x2,
           criterion = c("d_ration", "Adj_d_ratio"))


</code></pre>

<hr>
<h2 id='row_nominal'>row_nominal</h2><span id='topic+row_nominal'></span>

<h3>Description</h3>

<p>Computes descriptive statistics and effect size for nominal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_nominal(Data, group, variable)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="row_nominal_+3A_data">Data</code></td>
<td>
<p>A data set</p>
</td></tr>
<tr><td><code id="row_nominal_+3A_group">group</code></td>
<td>
<p>A character specifying the grouping variable</p>
</td></tr>
<tr><td><code id="row_nominal_+3A_variable">variable</code></td>
<td>
<p>Variables for which the effect should be estimated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes descriptive statistics and effect size for nominal data.
</p>


<h3>Value</h3>

<p>A vector containing the adjusted d-ratio in dependency of
sample size.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>

<hr>
<h2 id='row_ordinal'>row_ordinal</h2><span id='topic+row_ordinal'></span>

<h3>Description</h3>

<p>Computes descriptive statistics and effect size for ordinal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_ordinal(Data, group, variable)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="row_ordinal_+3A_data">Data</code></td>
<td>
<p>A data set</p>
</td></tr>
<tr><td><code id="row_ordinal_+3A_group">group</code></td>
<td>
<p>A character specifying the grouping variable</p>
</td></tr>
<tr><td><code id="row_ordinal_+3A_variable">variable</code></td>
<td>
<p>Variables for which the effect should be estimated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes descriptive statistics and effect size for ordinal data.
</p>


<h3>Value</h3>

<p>A vector containing the adjusted d-ratio in dependency of
sample size.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>

<hr>
<h2 id='Table_MAGMA'>Table_MAGMA</h2><span id='topic+Table_MAGMA'></span>

<h3>Description</h3>

<p>This function prints an APA Table of the Balance criteria. It displays the
balance criteria for four different sample sizes per group. In each scenario,
one balance criteria has its optimal value. Thus, the table is a 4x5 table
showing the four balance criteria and the respective sample size per group
for the four scenarios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Table_MAGMA(Balance, filename = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Table_MAGMA_+3A_balance">Balance</code></td>
<td>
<p>A result of <code><a href="#topic+Balance_MAGMA">Balance_MAGMA</a></code> Compare the function
<code><a href="#topic+Balance_MAGMA">Balance_MAGMA</a></code>.</p>
</td></tr>
<tr><td><code id="Table_MAGMA_+3A_filename">filename</code></td>
<td>
<p>Optional argument.  A character specifying the filename that
the resulting Word document with the table should have.</p>
</td></tr>
<tr><td><code id="Table_MAGMA_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE indicating whether matching information should
be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an APA Table including the optimal models for each
balance criterion, the other criteria for the respective sample size per
group as well as the sample size itself. With an optional argument you can
save a the APA table in Word.
</p>


<h3>Value</h3>

<p>A 4x5 APA table showing the four balance
criteria and the respective sample sizes per group for four scenarios. In
each of these scenarios, one balance criteria has its optimal value. It can
print a Word Document with this table.
</p>


<h3>Author(s)</h3>

<p>Julian Urban
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function bases on a MAGMA function as well as Balance_MAGMA
# Defining the names of the metric and binary covariates
covariates_vector &lt;- c("GPA_school", "IQ_score", "Motivation", "parents_academic", "gender")


# Estimating balance of a two-group matching using the data set
# 'MAGMA_sim_data'.
# Matching variable 'gifted_support' (received giftedness support yes or no)
Balance_gifted &lt;- Balance_MAGMA(Data = MAGMA_sim_data[MAGMA_sim_data$step_gifted &lt; 200, ],
                                group = "gifted_support",
                                covariates = covariates_vector,
                                step = "step_gifted")

Table_MAGMA(Balance_gifted)


# 2x2 matching using the data set 'MAGMA_sim_data'
# Matching variables are 'gifted_support' (received giftedness support yes
# or no) and 'enrichment' (participated in enrichment or not)
# 'MAGMA_sim_data_gift_enrich' contains the result of the matching
# 2x2 matching is equivalent to four-group matching
MAGMA_sim_data_gift_enrich &lt;- MAGMA(Data = MAGMA_sim_data,
                                   group = c("gifted_support", "enrichment"),
                                   dist = "ps_2x2",
                                   cores = 2)


# Estimating Balance. Covariates same as above
Balance_2x2 &lt;- Balance_MAGMA(Data = MAGMA_sim_data_gift_enrich,
                             group = c("gifted_support", "enrichment"),
                             covariates = covariates_vector,
                             step = "step") #step created during matching

Table_MAGMA(Balance_2x2)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
