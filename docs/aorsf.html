<!DOCTYPE html><html lang="en"><head><title>Help for package aorsf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aorsf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aorsf-package'><p>aorsf: Accelerated Oblique Random Forests</p></a></li>
<li><a href='#as.data.table.orsf_summary_uni'><p>Coerce to data.table</p></a></li>
<li><a href='#orsf'><p>Oblique Random Forests</p></a></li>
<li><a href='#orsf_control'><p>Oblique random forest control</p></a></li>
<li><a href='#orsf_control_cph'><p>Cox regression ORSF control</p></a></li>
<li><a href='#orsf_control_custom'><p>Custom ORSF control</p></a></li>
<li><a href='#orsf_control_fast'><p>Accelerated ORSF control</p></a></li>
<li><a href='#orsf_control_net'><p>Penalized Cox regression ORSF control</p></a></li>
<li><a href='#orsf_ice_oob'><p>Individual Conditional Expectations</p></a></li>
<li><a href='#orsf_pd_oob'><p>Partial dependence</p></a></li>
<li><a href='#orsf_scale_cph'><p>Scale input data</p></a></li>
<li><a href='#orsf_summarize_uni'><p>Univariate summary</p></a></li>
<li><a href='#orsf_time_to_train'><p>Estimate training time</p></a></li>
<li><a href='#orsf_update'><p>Update Forest Parameters</p></a></li>
<li><a href='#orsf_vi'><p>Variable Importance</p></a></li>
<li><a href='#orsf_vint'><p>Variable Interactions</p></a></li>
<li><a href='#orsf_vs'><p>Variable selection</p></a></li>
<li><a href='#pbc_orsf'><p>Mayo Clinic Primary Biliary Cholangitis Data</p></a></li>
<li><a href='#penguins_orsf'><p>Size measurements for adult foraging penguins near Palmer Station, Antarctica</p></a></li>
<li><a href='#pred_spec_auto'><p>Automatic variable values for dependence</p></a></li>
<li><a href='#predict.ObliqueForest'><p>Prediction for ObliqueForest Objects</p></a></li>
<li><a href='#print.ObliqueForest'><p>Inspect Forest Parameters</p></a></li>
<li><a href='#print.orsf_summary_uni'><p>Print ORSF summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Accelerated Oblique Random Forests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit, interpret, and compute predictions with oblique random
    forests. Includes support for partial dependence, variable importance,
    passing customized functions for variable importance and identification
    of linear combinations of features. Methods for the oblique random 
    survival forest are described in Jaeger et al., (2023)
    &lt;<a href="https://doi.org/10.1080%2F10618600.2023.2231048">doi:10.1080/10618600.2023.2231048</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/aorsf">https://github.com/ropensci/aorsf</a>,
<a href="https://docs.ropensci.org/aorsf/">https://docs.ropensci.org/aorsf/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/aorsf/issues/">https://github.com/ropensci/aorsf/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>collapse, data.table, lifecycle, R6, Rcpp, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, glmnet, knitr, rmarkdown, survival,
SurvMetrics, testthat (&ge; 3.0.0), tibble, units</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-29 21:11:33 UTC; bjaeger</td>
</tr>
<tr>
<td>Author:</td>
<td>Byron Jaeger <a href="https://orcid.org/0000-0001-7399-2299"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Nicholas Pajewski [ctb],
  Sawyer Welden [ctb],
  Christopher Jackson [rev],
  Marvin Wright [rev],
  Lukas Burk [rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Byron Jaeger &lt;bjaeger@wakehealth.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-30 03:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aorsf-package'>aorsf: Accelerated Oblique Random Forests</h2><span id='topic+aorsf'></span><span id='topic+aorsf-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Fit, interpret, and compute predictions with oblique random forests. Includes support for partial dependence, variable importance, passing customized functions for variable importance and identification of linear combinations of features. Methods for the oblique random survival forest are described in Jaeger et al., (2023) <a href="https://doi.org/10.1080/10618600.2023.2231048">doi:10.1080/10618600.2023.2231048</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Byron Jaeger <a href="mailto:bjaeger@wakehealth.edu">bjaeger@wakehealth.edu</a> (<a href="https://orcid.org/0000-0001-7399-2299">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Nicholas Pajewski [contributor]
</p>
</li>
<li><p> Sawyer Welden <a href="mailto:swelden@wakehealth.edu">swelden@wakehealth.edu</a> [contributor]
</p>
</li>
<li><p> Christopher Jackson <a href="mailto:chris.jackson@mrc-bsu.cam.ac.uk">chris.jackson@mrc-bsu.cam.ac.uk</a> [reviewer]
</p>
</li>
<li><p> Marvin Wright [reviewer]
</p>
</li>
<li><p> Lukas Burk [reviewer]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ropensci/aorsf">https://github.com/ropensci/aorsf</a>
</p>
</li>
<li> <p><a href="https://docs.ropensci.org/aorsf/">https://docs.ropensci.org/aorsf/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/aorsf/issues/">https://github.com/ropensci/aorsf/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='as.data.table.orsf_summary_uni'>Coerce to data.table</h2><span id='topic+as.data.table.orsf_summary_uni'></span>

<h3>Description</h3>

<p>Convert an 'orsf_summary' object into a <code>data.table</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orsf_summary_uni'
as.data.table(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.table.orsf_summary_uni_+3A_x">x</code></td>
<td>
<p>an object of class 'orsf_summary_uni'</p>
</td></tr>
<tr><td><code id="as.data.table.orsf_summary_uni_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="data.table.html#topic+data.table">data.table</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(data.table)

object &lt;- orsf(pbc_orsf, Surv(time, status) ~ . - id, n_tree = 25)

smry &lt;- orsf_summarize_uni(object, n_variables = 2)

as.data.table(smry)


## End(Not run)


</code></pre>

<hr>
<h2 id='orsf'>Oblique Random Forests</h2><span id='topic+orsf'></span><span id='topic+orsf_train'></span>

<h3>Description</h3>

<p>Grow or specify an oblique random forest. While the name <code>orsf()</code>
implies that this function only works for survival forests,
it can be used for classification, regression, or survival
forests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf(
  data,
  formula,
  control = NULL,
  weights = NULL,
  n_tree = 500,
  n_split = 5,
  n_retry = 3,
  n_thread = 0,
  mtry = NULL,
  sample_with_replacement = TRUE,
  sample_fraction = 0.632,
  leaf_min_events = 1,
  leaf_min_obs = 5,
  split_rule = NULL,
  split_min_events = 5,
  split_min_obs = 10,
  split_min_stat = NULL,
  oobag_pred_type = NULL,
  oobag_pred_horizon = NULL,
  oobag_eval_every = NULL,
  oobag_fun = NULL,
  importance = "anova",
  importance_max_pvalue = 0.01,
  group_factors = TRUE,
  tree_seeds = NULL,
  attach_data = TRUE,
  no_fit = FALSE,
  na_action = "fail",
  verbose_progress = FALSE,
  ...
)

orsf_train(object, attach_data = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_+3A_data">data</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a>, <a href="tibble.html#topic+tibble-package">tibble</a>, or <a href="data.table.html#topic+data.table">data.table</a> that contains the
relevant variables.</p>
</td></tr>
<tr><td><code id="orsf_+3A_formula">formula</code></td>
<td>
<p>(<em>formula</em>) Two sided formula with a single outcome.
The terms on the right are names of predictor variables, and the
symbol '.' may be used to indicate all variables in the data
except the response. The symbol '-' may also be used to indicate
removal of a predictor. Details on the response vary depending
on forest type:
</p>

<ul>
<li> <p><em>Classification</em>: The response should be a single variable,
and that variable should have type <code>factor</code> in <code>data</code>.
</p>
</li>
<li> <p><em>Regression</em>: The response should be a single variable, and
that variable should have typee <code>double</code> or <code>integer</code> with at
least 10 unique numeric values in <code>data</code>.
</p>
</li>
<li> <p><em>Survival</em>: The response should include a time variable,
followed by a status variable, and may be written inside a
call to <a href="survival.html#topic+Surv">Surv</a> (see examples).
</p>
</li></ul>
</td></tr>
<tr><td><code id="orsf_+3A_control">control</code></td>
<td>
<p>(<em>orsf_control</em>) An object returned from one of the
<code>orsf_control</code> functions: <a href="#topic+orsf_control_survival">orsf_control_survival</a>,
<a href="#topic+orsf_control_classification">orsf_control_classification</a>, and <a href="#topic+orsf_control_regression">orsf_control_regression</a>. If
<code>NULL</code> (the default) will use an accelerated control, which is the
fastest available option. For survival and classification, this is
Cox and Logistic regression with 1 iteration, and for regression
it is ordinary least squares.</p>
</td></tr>
<tr><td><code id="orsf_+3A_weights">weights</code></td>
<td>
<p>(<em>numeric vector</em>) Optional. If given, this input should
have length equal to <code>nrow(data)</code> for complete or imputed data and should
have length equal to <code>nrow(na.omit(data))</code> if <code>na_action</code> is <code>"omit"</code>.
As the weights vector is used to count observations and events prior to
growing a node for a tree, <code>orsf()</code> scales <code>weights</code> so that
<code>sum(weights) == nrow(data)</code>. This helps to make tree depth consistent
between weighted and un-weighted fits.</p>
</td></tr>
<tr><td><code id="orsf_+3A_n_tree">n_tree</code></td>
<td>
<p>(<em>integer</em>) the number of trees to grow.
Default is <code>n_tree = 500.</code></p>
</td></tr>
<tr><td><code id="orsf_+3A_n_split">n_split</code></td>
<td>
<p>(<em>integer</em>) the number of cut-points assessed when splitting
a node in decision trees. Default is <code>n_split = 5</code>.</p>
</td></tr>
<tr><td><code id="orsf_+3A_n_retry">n_retry</code></td>
<td>
<p>(<em>integer</em>) when a node is splittable, but the current
linear combination of inputs is unable to provide a valid split, <code>orsf</code>
will try again with a new linear combination based on a different set
of randomly selected predictors, up to <code>n_retry</code> times. Default is
<code>n_retry = 3</code>. Set <code>n_retry = 0</code> to prevent any retries.</p>
</td></tr>
<tr><td><code id="orsf_+3A_n_thread">n_thread</code></td>
<td>
<p>(<em>integer</em>) number of threads to use while growing trees, computing predictions, and computing importance. Default is 0, which allows a suitable number of threads to be used based on availability.</p>
</td></tr>
<tr><td><code id="orsf_+3A_mtry">mtry</code></td>
<td>
<p>(<em>integer</em>) Number of predictors randomly included as candidates
for splitting a node. The default is the smallest integer greater than
the square root of the number of total predictors, i.e.,
<code style="white-space: pre;">&#8288;mtry = ceiling(sqrt(number of predictors))&#8288;</code></p>
</td></tr>
<tr><td><code id="orsf_+3A_sample_with_replacement">sample_with_replacement</code></td>
<td>
<p>(<em>logical</em>) If <code>TRUE</code> (the default),
observations are sampled with replacement when an in-bag sample
is created for a decision tree. If <code>FALSE</code>, observations are
sampled without replacement and each tree will have an in-bag sample
containing <code>sample_fraction</code>% of the original sample.</p>
</td></tr>
<tr><td><code id="orsf_+3A_sample_fraction">sample_fraction</code></td>
<td>
<p>(<em>double</em>) the proportion of observations that
each trees' in-bag sample will contain, relative to the number of
rows in <code>data</code>. Only used if <code>sample_with_replacement</code> is <code>FALSE</code>.
Default value is 0.632.</p>
</td></tr>
<tr><td><code id="orsf_+3A_leaf_min_events">leaf_min_events</code></td>
<td>
<p>(<em>integer</em>) This input is only relevant for
survival analysis, and specifies the minimum number of events in a
leaf node. Default is <code>leaf_min_events = 1</code></p>
</td></tr>
<tr><td><code id="orsf_+3A_leaf_min_obs">leaf_min_obs</code></td>
<td>
<p>(<em>integer</em>) minimum number of observations in a
leaf node. Default is <code>leaf_min_obs = 5</code>.</p>
</td></tr>
<tr><td><code id="orsf_+3A_split_rule">split_rule</code></td>
<td>
<p>(<em>character</em>) how to assess the quality of a potential
splitting rule for a node. Valid options for survival are:
</p>

<ul>
<li><p> 'logrank' : a log-rank test statistic (default).
</p>
</li>
<li><p> 'cstat'   : Harrell's concordance statistic.
</p>
</li></ul>

<p>For classification, valid options are:
</p>

<ul>
<li><p> 'gini'  : gini impurity (default)
</p>
</li>
<li><p> 'cstat' : area underneath the ROC curve (AUC-ROC)
</p>
</li></ul>

<p>For regression, valid options are:
</p>

<ul>
<li><p> 'variance' : variance reduction (default)
</p>
</li></ul>
</td></tr>
<tr><td><code id="orsf_+3A_split_min_events">split_min_events</code></td>
<td>
<p>(<em>integer</em>) minimum number of events required
in a node to consider splitting it. Default is <code>split_min_events = 5</code>.
This input is only relevant for survival trees.</p>
</td></tr>
<tr><td><code id="orsf_+3A_split_min_obs">split_min_obs</code></td>
<td>
<p>(<em>integer</em>) minimum number of observations required
in a node to consider splitting it. Default is <code>split_min_obs = 10</code>.</p>
</td></tr>
<tr><td><code id="orsf_+3A_split_min_stat">split_min_stat</code></td>
<td>
<p>(double) minimum test statistic required to split
a node. If no splits are found with a statistic exceeding <code>split_min_stat</code>,
the given node either becomes a leaf or a retry occurs (up to <code>n_retry</code>
retries). Defaults are
</p>

<ul>
<li><p> 3.84 if <code>split_rule = 'logrank'</code>
</p>
</li>
<li><p> 0.55 if <code>split_rule = 'cstat'</code> (see first note below)
</p>
</li>
<li><p> 0.00 if <code>split_rule = 'gini'</code> (see second note below)
</p>
</li>
<li><p> 0.00 if <code>split_rule = 'variance'</code>
</p>
</li></ul>

<p><strong>Note 1</strong> For C-statistic splitting, if C is &lt; 0.50, we consider the statistic
value to be 1 - C to allow for good 'anti-predictive' splits. So,
if a C-statistic is initially computed as 0.1, it will be considered
as 1 - 0.10 = 0.90.
</p>
<p><strong>Note 2</strong> For Gini impurity, a value of 0 and 1 usually indicate the best and
worst possible scores, respectively. To make things simple and to avoid
introducing a <code>split_max_stat</code> input, we flip the values of Gini
impurity so that 1 and 0 indicate the best and worst possible scores,
respectively.</p>
</td></tr>
<tr><td><code id="orsf_+3A_oobag_pred_type">oobag_pred_type</code></td>
<td>
<p>(<em>character</em>) The type of out-of-bag predictions
to compute while fitting the ensemble. Valid options for any tree type:
</p>

<ul>
<li><p> 'none' : don't compute out-of-bag predictions
</p>
</li>
<li><p> 'leaf' : the ID of the predicted leaf is returned for each tree
</p>
</li></ul>

<p>Valid options for survival:
</p>

<ul>
<li><p> 'risk' : probability of event occurring at or before
<code>oobag_pred_horizon</code> (default).
</p>
</li>
<li><p> 'surv' : 1 - risk.
</p>
</li>
<li><p> 'chf'  : cumulative hazard function at <code>oobag_pred_horizon</code>.
</p>
</li>
<li><p> 'mort' : mortality, i.e., the number of events expected if all
observations in the training data were identical to a
given observation.
</p>
</li></ul>

<p>Valid options for classification:
</p>

<ul>
<li><p> 'prob'  : probability of each class (default)
</p>
</li>
<li><p> 'class' : class (i.e., which.max(prob))
</p>
</li></ul>

<p>Valid options for regression:
</p>

<ul>
<li><p> 'mean' : mean value (default)
</p>
</li></ul>
</td></tr>
<tr><td><code id="orsf_+3A_oobag_pred_horizon">oobag_pred_horizon</code></td>
<td>
<p>(<em>numeric</em>) A numeric value indicating what time
should be used for out-of-bag predictions. Default is the median
of the observed times, i.e., <code>oobag_pred_horizon = median(time)</code>.
This input is only relevant for survival trees that have prediction
type of 'risk', 'surv', or 'chf'.</p>
</td></tr>
<tr><td><code id="orsf_+3A_oobag_eval_every">oobag_eval_every</code></td>
<td>
<p>(<em>integer</em>) The out-of-bag performance of the
ensemble will be checked every <code>oobag_eval_every</code> trees. So, if
<code>oobag_eval_every = 10</code>, then out-of-bag performance is checked
after growing the 10th tree, the 20th tree, and so on. Default
is <code>oobag_eval_every = n_tree</code>.</p>
</td></tr>
<tr><td><code id="orsf_+3A_oobag_fun">oobag_fun</code></td>
<td>
<p>(<em>function</em>) to be used for evaluating out-of-bag prediction accuracy every <code>oobag_eval_every</code>
trees. When <code>oobag_fun = NULL</code> (the default), the evaluation statistic is selected based on tree type
</p>

<ul>
<li><p> survival: Harrell's C-statistic (1982)
</p>
</li>
<li><p> classification: Area underneath the ROC curve (AUC-ROC)
</p>
</li>
<li><p> regression: Traditional prediction R-squared
</p>
</li></ul>

<p>if you use your own <code>oobag_fun</code> note the following:
</p>

<ul>
<li> <p><code>oobag_fun</code> should have three inputs: <code>y_mat</code>, <code>w_vec</code>, and <code>s_vec</code>
</p>
</li>
<li><p> For survival trees, <code>y_mat</code> should be a two column matrix with first column named 'time' and second named 'status'. For classification trees, <code>y_mat</code> should be a matrix with number of columns = number of distinct classes in the outcome. For regression, <code>y_mat</code> should be a matrix with one column.
</p>
</li>
<li> <p><code>s_vec</code> is a numeric vector containing predictions
</p>
</li>
<li> <p><code>oobag_fun</code> should return a numeric output of length 1
</p>
</li></ul>

<p>For more details, see the out-of-bag <a href="https://docs.ropensci.org/aorsf/articles/oobag.html#user-supplied-out-of-bag-evaluation-functions">vignette</a>.</p>
</td></tr>
<tr><td><code id="orsf_+3A_importance">importance</code></td>
<td>
<p>(<em>character</em>) Indicate method for variable importance:
</p>

<ul>
<li><p> 'none': no variable importance is computed.
</p>
</li>
<li><p> 'anova': compute analysis of variance (ANOVA) importance
</p>
</li>
<li><p> 'negate': compute negation importance
</p>
</li>
<li><p> 'permute': compute permutation importance
</p>
</li></ul>

<p>For details on these methods, see <a href="#topic+orsf_vi">orsf_vi</a>.</p>
</td></tr>
<tr><td><code id="orsf_+3A_importance_max_pvalue">importance_max_pvalue</code></td>
<td>
<p>(<em>double</em>) Only relevant if <code>importance</code>
is <code>"anova"</code>. The maximum p-value that will register as a positive
case when counting the number of times a variable was found to be
'significant' during tree growth. Default is 0.01, as recommended
by Menze et al.</p>
</td></tr>
<tr><td><code id="orsf_+3A_group_factors">group_factors</code></td>
<td>
<p>(<em>logical</em>) Only relevant if variable importance is
being estimated. if <code>TRUE</code>, the importance of factor variables will be reported overall by aggregating the importance of individual levels of the factor. If <code>FALSE</code>, the importance of individual factor levels will be returned.</p>
</td></tr>
<tr><td><code id="orsf_+3A_tree_seeds">tree_seeds</code></td>
<td>
<p>(<em>integer vector</em>) Optional. if specified, random seeds
will be set using the values in <code>tree_seeds[i]</code>  before growing tree <code>i</code>.
Two forests grown with the same number of trees and the same seeds will
have the exact same out-of-bag samples, making out-of-bag error
estimates of the forests more comparable. If <code>NULL</code> (the default),
seeds are picked at random.</p>
</td></tr>
<tr><td><code id="orsf_+3A_attach_data">attach_data</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, a copy of the training
data will be attached to the output. This is required if you
plan on using functions like <a href="#topic+orsf_pd_oob">orsf_pd_oob</a> or <a href="#topic+orsf_summarize_uni">orsf_summarize_uni</a>
to interpret the forest using its training data. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orsf_+3A_no_fit">no_fit</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, model fitting steps are defined and
saved, but training is not initiated. The object returned can be
directly submitted to <code>orsf_train()</code> so long as <code>attach_data</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="orsf_+3A_na_action">na_action</code></td>
<td>
<p>(<em>character</em>) what should happen when <code>data</code> contains missing values (i.e., <code>NA</code> values). Valid options are:
</p>

<ul>
<li><p> 'fail' : an error is thrown if <code>data</code> contains <code>NA</code> values
</p>
</li>
<li><p> 'omit' : rows in <code>data</code> with incomplete data will be dropped
</p>
</li>
<li><p> 'impute_meanmode' : missing values for continuous and categorical variables in <code>data</code> will be imputed using the mean and mode, respectively.
</p>
</li></ul>
</td></tr>
<tr><td><code id="orsf_+3A_verbose_progress">verbose_progress</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, progress messages are
printed in the console. If <code>FALSE</code> (the default), nothing is printed.</p>
</td></tr>
<tr><td><code id="orsf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
<tr><td><code id="orsf_+3A_object">object</code></td>
<td>
<p>an untrained 'aorsf' object, created by setting
<code>no_fit = TRUE</code> in <code>orsf()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Why isn't this function called <code>orf()</code>? In its earlier versions, the
<code>aorsf</code> package was exclusively for <em>o</em>blique <em>r</em>andom <em>s</em>urvival <em>f</em>orests.
</p>
<p><strong>formula for survival oblique RFs</strong>:
</p>

<ul>
<li><p> The response in <code>formula</code> can be a survival
object as returned by the <a href="survival.html#topic+Surv">Surv</a> function,
but can also just be the time and status variables. I.e.,
<code>Surv(time, status) ~ .</code> works and <code>time + status ~ .</code> works
</p>
</li>
<li><p> The response can also be a survival object stored in <code>data</code>.
For example, <code>y ~ .</code> is a valid formula if <code>data$y</code> inherits
from the <code>Surv</code> class.
</p>
</li></ul>

<p><strong>mtry</strong>:
</p>
<p>The <code>mtry</code> parameter may be temporarily reduced to ensure that linear
models used to find combinations of predictors remain stable. This occurs
because coefficients in linear model fitting algorithms may become infinite
if the number of predictors exceeds the number of observations.
</p>
<p><strong>oobag_fun</strong>:
</p>
<p>If <code>oobag_fun</code> is specified, it will be used in to compute negation
importance or permutation importance, but it will not have any role
for ANOVA importance.
</p>
<p><strong>n_thread</strong>:
</p>
<p>If an R function is to be called from C++ (i.e., user-supplied function to
compute out-of-bag error or identify linear combinations of variables),
<code>n_thread</code> will automatically be set to 1 because attempting to run R
functions in multiple threads will cause the R session to crash.
</p>


<h3>Value</h3>

<p>an <em>obliqueForest</em> object
</p>


<h3>What is an oblique decision tree?</h3>

<p>Decision trees are developed by splitting a set of training data into two
new subsets, with the goal of having more similarity within the new subsets
than between them. This splitting process is repeated on the resulting
subsets of data until a stopping criterion is met. When the new subsets of
data are formed based on a single predictor, the decision tree is said to
be axis-based because the splits of the data appear perpendicular to the
axis of the predictor. When linear combinations of variables are used
instead of a single variable, the tree is oblique because the splits of
the data are neither parallel nor at a right angle to the axis
</p>
<p><em>Figure</em> : Decision trees for classification with axis-based splitting
(left) and oblique splitting (right). Cases are orange squares; controls
are purple circles. Both trees partition the predictor space defined by
variables X1 and X2, but the oblique splits do a better job of separating
the two classes.
</p>
<p><img src="../help/figures/tree_axis_v_oblique.png" width=95% alt="tree_axis_v_oblique.png" />
</p>


<h3>What is a random forest?</h3>

<p>Random forests are collections of de-correlated decision trees.
Predictions from each tree are aggregated to make an ensemble
prediction for the forest. For more details, see Breiman at el, 2001.
</p>


<h3>Training, out-of-bag error, and testing</h3>

<p>In random forests, each tree is grown with a bootstrapped version of
the training set. Because bootstrap samples are selected with replacement,
each bootstrapped training set contains about two-thirds of instances in
the original training set. The 'out-of-bag' data are instances that are
<em>not</em> in the bootstrapped training set. Each tree in the random forest
can make predictions for its out-of-bag data, and the out-of-bag
predictions can be aggregated to make an ensemble out-of-bag prediction.
Since the out-of-bag data are not used to grow the tree, the accuracy of
the ensemble out-of-bag predictions approximate the generalization error
of the random forest. Generalization error refers to the error of a
random forest's predictions when it is applied to predict outcomes for
data that were not used to train it, i.e., testing data.
</p>


<h3>Examples</h3>

<div class="sourceCode r"><pre>library(aorsf)
library(magrittr) # for %&gt;%
</pre></div>
<div class="sourceCode"><pre>## 
## Attaching package: 'magrittr'

## The following object is masked from 'package:tidyr':
## 
##     extract

## The following objects are masked from 'package:testthat':
## 
##     equals, is_less_than, not
</pre></div>
<p><code>orsf()</code> is the entry-point of the <code>aorsf</code> package. It can be used to
fit classification, regression, and survival forests.
</p>
<p>For classification, we fit an oblique RF to predict penguin species
using <code>penguin</code> data from the magnificent <code>palmerpenguins</code> <a href="https://allisonhorst.github.io/palmerpenguins/">R package</a>
</p>
<div class="sourceCode r"><pre># An oblique classification RF
penguin_fit &lt;- orsf(data = penguins_orsf,
                    n_tree = 5, 
                    formula = species ~ .)

penguin_fit
</pre></div>
<div class="sourceCode"><pre>## ---------- Oblique random classification forest
## 
##      Linear combinations: Accelerated Logistic regression
##           N observations: 333
##                N classes: 3
##                  N trees: 5
##       N predictors total: 7
##    N predictors per node: 3
##  Average leaves per tree: 4.6
## Min observations in leaf: 5
##           OOB stat value: 0.99
##            OOB stat type: AUC-ROC
##      Variable importance: anova
## 
## -----------------------------------------
</pre></div>
<p>For regression, we use the same data but predict bill length of
penguins:
</p>
<div class="sourceCode r"><pre># An oblique regression RF
bill_fit &lt;- orsf(data = penguins_orsf, 
                 n_tree = 5, 
                 formula = bill_length_mm ~ .)

bill_fit
</pre></div>
<div class="sourceCode"><pre>## ---------- Oblique random regression forest
## 
##      Linear combinations: Accelerated Linear regression
##           N observations: 333
##                  N trees: 5
##       N predictors total: 7
##    N predictors per node: 3
##  Average leaves per tree: 51
## Min observations in leaf: 5
##           OOB stat value: 0.70
##            OOB stat type: RSQ
##      Variable importance: anova
## 
## -----------------------------------------
</pre></div>
<p>My personal favorite is the oblique survival RF with accelerated Cox
regression because it was the first type of oblique RF that <code>aorsf</code>
provided (see <a href="https://arxiv.org/abs/2208.01129">ArXiv paper</a>; the paper
is also published in <em>Journal of Computational and Graphical Statistics</em>
but is not publicly available there). Here, we use it to predict
mortality risk following diagnosis of primary biliary cirrhosis:
</p>
<div class="sourceCode r"><pre># An oblique survival RF
pbc_fit &lt;- orsf(data = pbc_orsf, 
                n_tree = 5,
                formula = Surv(time, status) ~ . - id)

pbc_fit
</pre></div>
<div class="sourceCode"><pre>## ---------- Oblique random survival forest
## 
##      Linear combinations: Accelerated Cox regression
##           N observations: 276
##                 N events: 111
##                  N trees: 5
##       N predictors total: 17
##    N predictors per node: 5
##  Average leaves per tree: 22.2
## Min observations in leaf: 5
##       Min events in leaf: 1
##           OOB stat value: 0.78
##            OOB stat type: Harrell's C-index
##      Variable importance: anova
## 
## -----------------------------------------
</pre></div>


<h4>More than one way to grow a forest</h4>

<p>You can use <code>orsf(no_fit = TRUE)</code> to make a <em>specification</em> to grow a
forest instead of a fitted forest.
</p>
<div class="sourceCode r"><pre>orsf_spec &lt;- orsf(pbc_orsf, 
                  formula = time + status ~ . - id,
                  no_fit = TRUE)

orsf_spec
</pre></div>
<div class="sourceCode"><pre>## Untrained oblique random survival forest
## 
##      Linear combinations: Accelerated Cox regression
##           N observations: 276
##                 N events: 111
##                  N trees: 500
##       N predictors total: 17
##    N predictors per node: 5
##  Average leaves per tree: 0
## Min observations in leaf: 5
##       Min events in leaf: 1
##           OOB stat value: none
##            OOB stat type: Harrell's C-index
##      Variable importance: anova
## 
## -----------------------------------------
</pre></div>
<p>Why would you do this? Two reasons:
</p>

<ol>
<li><p> For very computational tasks, you may want to check how long it will
take to fit the forest before you commit to it:
</p>
</li></ol>

<div class="sourceCode r"><pre>orsf_spec %&gt;% 
 orsf_update(n_tree = 10000) %&gt;%
 orsf_time_to_train()
</pre></div>
<div class="sourceCode"><pre>## Time difference of 2.429678 secs
</pre></div>

<ol>
<li><p> If fitting multiple forests, use the blueprint along with
<code>orsf_train()</code> and <code>orsf_update()</code> to simplify your code:
</p>
</li></ol>

<div class="sourceCode r"><pre>orsf_fit &lt;- orsf_train(orsf_spec)
orsf_fit_10 &lt;- orsf_update(orsf_fit, leaf_min_obs = 10)
orsf_fit_20 &lt;- orsf_update(orsf_fit, leaf_min_obs = 20)

orsf_fit$leaf_min_obs
</pre></div>
<div class="sourceCode"><pre>## [1] 5
</pre></div>
<div class="sourceCode r"><pre>orsf_fit_10$leaf_min_obs
</pre></div>
<div class="sourceCode"><pre>## [1] 10
</pre></div>
<div class="sourceCode r"><pre>orsf_fit_20$leaf_min_obs
</pre></div>
<div class="sourceCode"><pre>## [1] 20
</pre></div>



<h4>tidymodels</h4>

<p><code>tidymodels</code> includes support for <code>aorsf</code> as a computational engine:
</p>
<div class="sourceCode r"><pre>library(tidymodels)
library(censored)
library(yardstick)

pbc_tidy &lt;- pbc_orsf %&gt;% 
 mutate(event_time = Surv(time, status), .before = 1) %&gt;% 
 select(-c(id, time, status)) %&gt;% 
 as_tibble()

split  &lt;- initial_split(pbc_tidy)

orsf_spec &lt;- rand_forest() %&gt;% 
 set_engine("aorsf") %&gt;% 
 set_mode("censored regression")

orsf_fit &lt;- fit(orsf_spec, 
                formula = event_time ~ ., 
                data = training(split))
</pre></div>
<p>Prediction with <code>aorsf</code> models at different times is also supported:
</p>
<div class="sourceCode r"><pre>time_points &lt;- seq(500, 3000, by = 500)

test_pred &lt;- augment(orsf_fit, 
                     new_data = testing(split), 
                     eval_time = time_points)

brier_scores &lt;- test_pred %&gt;% 
  brier_survival(truth = event_time, .pred)

brier_scores
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 6 x 4
##   .metric        .estimator .eval_time .estimate
##   &lt;chr&gt;          &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;
## 1 brier_survival standard          500    0.0597
## 2 brier_survival standard         1000    0.0943
## 3 brier_survival standard         1500    0.0883
## 4 brier_survival standard         2000    0.102 
## 5 brier_survival standard         2500    0.137 
## 6 brier_survival standard         3000    0.153
</pre></div>
<div class="sourceCode r"><pre>roc_scores &lt;- test_pred %&gt;% 
  roc_auc_survival(truth = event_time, .pred)

roc_scores
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 6 x 4
##   .metric          .estimator .eval_time .estimate
##   &lt;chr&gt;            &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;
## 1 roc_auc_survival standard          500     0.957
## 2 roc_auc_survival standard         1000     0.912
## 3 roc_auc_survival standard         1500     0.935
## 4 roc_auc_survival standard         2000     0.931
## 5 roc_auc_survival standard         2500     0.907
## 6 roc_auc_survival standard         3000     0.889
</pre></div>



<h3>References</h3>


<ol>
<li><p> Harrell, E F, Califf, M R, Pryor, B D, Lee, L K, Rosati, A R (1982).
&quot;Evaluating the yield of medical tests.&quot; <em>Jama</em>, <em>247</em>(18), 2543-2546.
</p>
</li>
<li><p> Breiman, Leo (2001). &quot;Random Forests.&quot; <em>Machine Learning</em>, <em>45</em>(1),
5-32. ISSN 1573-0565.
</p>
</li>
<li><p> Ishwaran H, Kogalur UB, Blackstone EH, Lauer MS (2008). &quot;Random
survival forests.&quot; <em>The Annals of Applied Statistics</em>, <em>2</em>(3).
</p>
</li>
<li><p> Menze, H B, Kelm, Michael B, Splitthoff, N D, Koethe, Ullrich,
Hamprecht, A F (2011). &quot;On oblique random forests.&quot; In <em>Machine
Learning and Knowledge Discovery in Databases: European Conference,
ECML PKDD 2011, Athens, Greece, September 5-9, 2011, Proceedings, Part
II 22</em>, 453-469. Springer.
</p>
</li>
<li><p> Jaeger BC, Long DL, Long DM, Sims M, Szychowski JM, Min Y, Mcclure LA,
Howard G, Simon N (2019). &quot;Oblique random survival forests.&quot; <em>The
Annals of Applied Statistics</em>, <em>13</em>(3).
</p>
</li>
<li><p> Jaeger BC, Welden S, Lenoir K, Speiser JL, Segar MW, Pandey A, Pajewski
NM (2023). &quot;Accelerated and interpretable oblique random survival
forests.&quot; <em>Journal of Computational and Graphical Statistics</em>, 1-16.
</p>
</li></ol>


<hr>
<h2 id='orsf_control'>Oblique random forest control</h2><span id='topic+orsf_control'></span><span id='topic+orsf_control_classification'></span><span id='topic+orsf_control_regression'></span><span id='topic+orsf_control_survival'></span>

<h3>Description</h3>

<p>Oblique random forest control
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_control(
  tree_type,
  method,
  scale_x,
  ties,
  net_mix,
  target_df,
  max_iter,
  epsilon,
  ...
)

orsf_control_classification(
  method = "glm",
  scale_x = TRUE,
  net_mix = 0.5,
  target_df = NULL,
  max_iter = 20,
  epsilon = 1e-09,
  ...
)

orsf_control_regression(
  method = "glm",
  scale_x = TRUE,
  net_mix = 0.5,
  target_df = NULL,
  max_iter = 20,
  epsilon = 1e-09,
  ...
)

orsf_control_survival(
  method = "glm",
  scale_x = TRUE,
  ties = "efron",
  net_mix = 0.5,
  target_df = NULL,
  max_iter = 20,
  epsilon = 1e-09,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_control_+3A_tree_type">tree_type</code></td>
<td>
<p>(<em>character</em>) the type of tree. Valid options are
</p>

<ul>
<li><p> &quot;classification&quot;, i.e., categorical outcomes
</p>
</li>
<li><p> &quot;regression&quot;, i.e., continuous outcomes
</p>
</li>
<li><p> &quot;survival&quot;, i.e., time-to event outcomes
</p>
</li></ul>
</td></tr>
<tr><td><code id="orsf_control_+3A_method">method</code></td>
<td>
<p>(<em>character</em> or <em>function</em>) how to identify linear
linear combinations of predictors. If <code>method</code> is a character value,
it must be one of:
</p>

<ul>
<li><p> 'glm': linear, logistic, and cox regression
</p>
</li>
<li><p> 'net': same as 'glm' but with penalty terms
</p>
</li>
<li><p> 'pca': principal component analysis
</p>
</li>
<li><p> 'random': random draw from uniform distribution
</p>
</li></ul>

<p>If <code>method</code> is a <em>function</em>, it will be used to identify  linear
combinations of predictor variables. <code>method</code> must in this case accept
three inputs named <code>x_node</code>, <code>y_node</code> and <code>w_node</code>, and should expect
the following types and dimensions:
</p>

<ul>
<li> <p><code>x_node</code> (<em>matrix</em>; <code>n</code> rows, <code>p</code> columns)
</p>
</li>
<li> <p><code>y_node</code> (<em>matrix</em>; <code>n</code> rows, <code>2</code> columns)
</p>
</li>
<li> <p><code>w_node</code> (<em>matrix</em>; <code>n</code> rows, <code>1</code> column)
</p>
</li></ul>

<p>In addition, <code>method</code> must return a matrix with p rows and 1 column.</p>
</td></tr>
<tr><td><code id="orsf_control_+3A_scale_x">scale_x</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, values of predictors will be
scaled prior to each instance of finding a linear combination of
predictors, using summary values from the data in the current node
of the decision tree.</p>
</td></tr>
<tr><td><code id="orsf_control_+3A_ties">ties</code></td>
<td>
<p>(<em>character</em>) a character string specifying the method
for tie handling. Only relevant when modeling survival outcomes
and using a method that engages with tied outcome times.
If there are no ties, all the methods are equivalent. Valid options
are 'breslow' and 'efron'. The Efron approximation is the default
because it is more accurate when dealing with tied event times and
has similar computational efficiency compared to the Breslow method.</p>
</td></tr>
<tr><td><code id="orsf_control_+3A_net_mix">net_mix</code></td>
<td>
<p>(<em>double</em>) The elastic net mixing parameter. A value of 1
gives the lasso penalty, and a value of 0 gives the ridge penalty. If
multiple values of alpha are given, then a penalized model is fit using
each alpha value prior to splitting a node.</p>
</td></tr>
<tr><td><code id="orsf_control_+3A_target_df">target_df</code></td>
<td>
<p>(<em>integer</em>) Preferred number of variables used in each
linear combination. For example, with <code>mtry</code> of 5 and <code>target_df</code> of 3,
we sample 5 predictors and look for the best linear combination using
3 of them.</p>
</td></tr>
<tr><td><code id="orsf_control_+3A_max_iter">max_iter</code></td>
<td>
<p>(<em>integer</em>) iteration continues until convergence
(see <code>eps</code> above) or the number of attempted iterations is equal to
<code>iter_max</code>.</p>
</td></tr>
<tr><td><code id="orsf_control_+3A_epsilon">epsilon</code></td>
<td>
<p>(<em>double</em>) When using most modeling based method,
iteration continues in the algorithm until the relative change in
some kind of objective is less than <code>epsilon</code>, or the absolute
change is less than <code>sqrt(epsilon)</code>.</p>
</td></tr>
<tr><td><code id="orsf_control_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adjust <code>scale_x</code> <em>at your own risk</em>. Setting <code>scale_x = FALSE</code> will
reduce computation time but will also make the <code>orsf</code> model dependent
on the scale of your data, which is why the default value is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>'orsf_control'</code>, which should be used as
an input for the <code>control</code> argument of <a href="#topic+orsf">orsf</a>. Components are:
</p>

<ul>
<li> <p><code>tree_type</code>: type of trees to fit
</p>
</li>
<li> <p><code>lincomb_type</code>: method for linear combinations
</p>
</li>
<li> <p><code>lincomb_eps</code>: epsilon for convergence
</p>
</li>
<li> <p><code>lincomb_iter_max</code>: max iterations
</p>
</li>
<li> <p><code>lincomb_scale</code>: to scale or not.
</p>
</li>
<li> <p><code>lincomb_alpha</code>: mixing parameter
</p>
</li>
<li> <p><code>lincomb_df_target</code>: target degrees of freedom
</p>
</li>
<li> <p><code>lincomb_ties_method</code>: method for ties in survival time
</p>
</li>
<li> <p><code>lincomb_R_function</code>: R function for custom splits
</p>
</li></ul>



<h3>Examples</h3>

<p>First we load some relevant packages
</p>
<div class="sourceCode r"><pre>set.seed(329730)
suppressPackageStartupMessages({
 library(aorsf)
 library(survival)
 library(ranger)
 library(riskRegression)
})
</pre></div>


<h4>Accelerated linear combinations</h4>

<p>The accelerated ORSF ensemble is the default because it has a nice
balance of computational speed and prediction accuracy. It runs a single
iteration of Newton Raphson scoring on the Cox partial likelihood
function to find linear combinations of predictors.
</p>
<div class="sourceCode r"><pre>fit_accel &lt;- orsf(pbc_orsf, 
                  control = orsf_control_survival(),
                  formula = Surv(time, status) ~ . - id,
                  tree_seeds = 329)
</pre></div>



<h4>Linear combinations with Cox regression</h4>

<p>Setting inputs in <code>orsf_control_survival</code> to scale the X matrix and
repeat iterations until convergence allows you to run Cox regression in
each non-terminal node of each survival tree, using the regression
coefficients to create linear combinations of predictors:
</p>
<div class="sourceCode r"><pre>control_cph &lt;- orsf_control_survival(method = 'glm', 
                                     scale_x = TRUE, 
                                     max_iter = 20)

fit_cph &lt;- orsf(pbc_orsf, 
                control = control_cph,
                formula = Surv(time, status) ~ . - id,
                tree_seeds = 329)
</pre></div>



<h4>Linear combinations with penalized cox regression</h4>

<p>Setting <code>method == 'net'</code> runs penalized Cox regression in each
non-terminal node of each survival tree. This can be really helpful if
you want to do feature selection within the node, but it is a lot slower
than the <code>'glm'</code> option.
</p>
<div class="sourceCode r"><pre># select 3 predictors out of 5 to be used in
# each linear combination of predictors.

control_net &lt;- orsf_control_survival(method = 'net', target_df = 3)

fit_net &lt;- orsf(pbc_orsf, 
                control = control_net,
                formula = Surv(time, status) ~ . - id,
                tree_seeds = 329)
</pre></div>



<h4>Linear combinations with your own function</h4>

<p>In addition to the built-in methods, customized functions can be used to
identify linear combinations of predictors. We’ll demonstrate a few
here.
</p>

<ul>
<li><p> The first uses random coefficients
</p>
</li></ul>

<div class="sourceCode r"><pre>f_rando &lt;- function(x_node, y_node, w_node){
 matrix(runif(ncol(x_node)), ncol=1) 
}
</pre></div>

<ul>
<li><p> The second derives coefficients from principal component analysis
</p>
</li></ul>

<div class="sourceCode r"><pre>f_pca &lt;- function(x_node, y_node, w_node) { 
 
 # estimate two principal components.
 pca &lt;- stats::prcomp(x_node, rank. = 2)
 # use the second principal component to split the node
 pca$rotation[, 1L, drop = FALSE]
 
}
</pre></div>

<ul>
<li><p> The third uses <code>ranger()</code> inside of <code>orsf()</code>. This approach is very
similar to a method known as reinforcement learning trees (see the
<code>RLT</code> package), although our method of “muting” is very crude compared
to the method proposed by Zhu et al. 
</p>
</li></ul>

<div class="sourceCode r"><pre>f_rlt &lt;- function(x_node, y_node, w_node){
 
 colnames(y_node) &lt;- c('time', 'status')
 colnames(x_node) &lt;- paste("x", seq(ncol(x_node)), sep = '')
 
 data &lt;- as.data.frame(cbind(y_node, x_node))
 
 if(nrow(data) &lt;= 10) 
  return(matrix(runif(ncol(x_node)), ncol = 1))
 
 fit &lt;- ranger::ranger(data = data, 
                       formula = Surv(time, status) ~ ., 
                       num.trees = 25, 
                       num.threads = 1,
                       min.node.size = 5,
                       importance = 'permutation')
 
 out &lt;- sort(fit$variable.importance, decreasing = TRUE)
 
 # "mute" the least two important variables
 n_vars &lt;- length(out)
 if(n_vars &gt; 4){
   out[c(n_vars, n_vars-1)] &lt;- 0
 }
 
 # ensure out has same variable order as input
 out &lt;- out[colnames(x_node)]
 
 # protect yourself
 out[is.na(out)] &lt;- 0
 
 matrix(out, ncol = 1)
 
}
</pre></div>
<p>We can plug these functions into <code>orsf_control_custom()</code>, and then pass
the result into <code>orsf()</code>:
</p>
<div class="sourceCode r"><pre>fit_rando &lt;- orsf(pbc_orsf,
                  Surv(time, status) ~ . - id,
                  control = orsf_control_survival(method = f_rando),
                  tree_seeds = 329)

fit_pca &lt;- orsf(pbc_orsf,
                Surv(time, status) ~ . - id,
                control = orsf_control_survival(method = f_pca),
                tree_seeds = 329)

fit_rlt &lt;- orsf(pbc_orsf, time + status ~ . - id, 
                control = orsf_control_survival(method = f_rlt),
                tree_seeds = 329)
</pre></div>
<p>So which fit seems to work best in this example? Let’s find out by
evaluating the out-of-bag survival predictions.
</p>
<div class="sourceCode r"><pre>risk_preds &lt;- list(
 accel = fit_accel$pred_oobag,
 cph   = fit_cph$pred_oobag,
 net   = fit_net$pred_oobag,
 rando = fit_rando$pred_oobag,
 pca   = fit_pca$pred_oobag,
 rlt   = fit_rlt$pred_oobag
)

sc &lt;- Score(object = risk_preds, 
            formula = Surv(time, status) ~ 1, 
            data = pbc_orsf, 
            summary = 'IPA',
            times = fit_accel$pred_horizon)
</pre></div>
<p>The AUC values, from highest to lowest:
</p>
<div class="sourceCode r"><pre>sc$AUC$score[order(-AUC)]
</pre></div>
<div class="sourceCode"><pre>##     model times       AUC         se     lower     upper
##    &lt;fctr&gt; &lt;num&gt;     &lt;num&gt;      &lt;num&gt;     &lt;num&gt;     &lt;num&gt;
## 1:    net  1788 0.9151649 0.02025057 0.8754745 0.9548553
## 2:    rlt  1788 0.9119200 0.02090107 0.8709547 0.9528854
## 3:  accel  1788 0.9095628 0.02143250 0.8675558 0.9515697
## 4:    cph  1788 0.9095628 0.02143250 0.8675558 0.9515697
## 5:  rando  1788 0.9062197 0.02148854 0.8641029 0.9483365
## 6:    pca  1788 0.8999479 0.02226683 0.8563057 0.9435901
</pre></div>
<p>And the indices of prediction accuracy:
</p>
<div class="sourceCode r"><pre>sc$Brier$score[order(-IPA), .(model, times, IPA)]
</pre></div>
<div class="sourceCode"><pre>##         model times       IPA
##        &lt;fctr&gt; &lt;num&gt;     &lt;num&gt;
## 1:        net  1788 0.4905777
## 2:      accel  1788 0.4806649
## 3:        cph  1788 0.4806649
## 4:        rlt  1788 0.4675228
## 5:        pca  1788 0.4383995
## 6:      rando  1788 0.4302814
## 7: Null model  1788 0.0000000
</pre></div>
<p>From inspection,
</p>

<ul>
<li> <p><code>net</code>, <code>accel</code>, and <code>rlt</code> have high discrimination and index of
prediction accuracy.
</p>
</li>
<li> <p><code>rando</code> and <code>pca</code> do less well, but they aren’t bad.
</p>
</li></ul>




<h3>See Also</h3>

<p>linear combination control functions
<code><a href="#topic+orsf_control_cph">orsf_control_cph</a>()</code>,
<code><a href="#topic+orsf_control_custom">orsf_control_custom</a>()</code>,
<code><a href="#topic+orsf_control_fast">orsf_control_fast</a>()</code>,
<code><a href="#topic+orsf_control_net">orsf_control_net</a>()</code>
</p>

<hr>
<h2 id='orsf_control_cph'>Cox regression ORSF control</h2><span id='topic+orsf_control_cph'></span>

<h3>Description</h3>

<p>Use the coefficients from a proportional hazards model
to create linear combinations of predictor variables
while fitting an <a href="#topic+orsf">orsf</a> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_control_cph(method = "efron", eps = 1e-09, iter_max = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_control_cph_+3A_method">method</code></td>
<td>
<p>(<em>character</em>) a character string specifying the method
for tie handling. If there are no ties, all the methods are
equivalent. Valid options are 'breslow' and 'efron'. The Efron
approximation is the default because it is more accurate when dealing
with tied event times and has similar computational efficiency compared
to the Breslow method.</p>
</td></tr>
<tr><td><code id="orsf_control_cph_+3A_eps">eps</code></td>
<td>
<p>(<em>double</em>) When using Newton Raphson scoring to identify
linear combinations of inputs, iteration continues in the algorithm
until the relative change in  the log partial likelihood is less than
<code>eps</code>, or the absolute change is less than <code>sqrt(eps)</code>. Must be positive.
A default value of 1e-09 is used for consistency with
<a href="survival.html#topic+coxph.control">survival::coxph.control</a>.</p>
</td></tr>
<tr><td><code id="orsf_control_cph_+3A_iter_max">iter_max</code></td>
<td>
<p>(<em>integer</em>) iteration continues until convergence
(see <code>eps</code> above) or the number of attempted iterations is equal to
<code>iter_max</code>.</p>
</td></tr>
<tr><td><code id="orsf_control_cph_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>code from the  <a href="https://github.com/therneau/survival/blob/master/src/coxfit6.c">survival package</a>
was modified to make this routine.
</p>
<p>For more details on the Cox proportional hazards model, see
<a href="survival.html#topic+coxph">coxph</a> and/or Therneau and Grambsch (2000).
</p>


<h3>Value</h3>

<p>an object of class <code>'orsf_control'</code>, which should be used as
an input for the <code>control</code> argument of <a href="#topic+orsf">orsf</a>.
</p>


<h3>References</h3>

<p>Therneau T.M., Grambsch P.M. (2000) The Cox Model. In: Modeling Survival
Data: Extending the Cox Model. Statistics for Biology and Health.
Springer, New York, NY. DOI: 10.1007/978-1-4757-3294-8_3
</p>


<h3>See Also</h3>

<p>linear combination control functions
<code><a href="#topic+orsf_control_custom">orsf_control_custom</a>()</code>,
<code><a href="#topic+orsf_control_fast">orsf_control_fast</a>()</code>,
<code><a href="#topic+orsf_control_net">orsf_control_net</a>()</code>,
<code><a href="#topic+orsf_control">orsf_control</a>()</code>
</p>

<hr>
<h2 id='orsf_control_custom'>Custom ORSF control</h2><span id='topic+orsf_control_custom'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_control_custom(beta_fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_control_custom_+3A_beta_fun">beta_fun</code></td>
<td>
<p>(<em>function</em>) a function to define coefficients used
in linear combinations of predictor variables. <code>beta_fun</code> must accept
three inputs named <code>x_node</code>, <code>y_node</code> and <code>w_node</code>, and should expect
the following types and dimensions:
</p>

<ul>
<li> <p><code>x_node</code> (<em>matrix</em>; <code>n</code> rows, <code>p</code> columns)
</p>
</li>
<li> <p><code>y_node</code> (<em>matrix</em>; <code>n</code> rows, <code>2</code> columns)
</p>
</li>
<li> <p><code>w_node</code> (<em>matrix</em>; <code>n</code> rows, <code>1</code> column)
</p>
</li></ul>

<p>In addition, <code>beta_fun</code> must return a matrix with p rows and 1 column. If
any of these conditions are not met, <code>orsf_control_custom()</code> will let
you know.</p>
</td></tr>
<tr><td><code id="orsf_control_custom_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>'orsf_control'</code>, which should be used as
an input for the <code>control</code> argument of <a href="#topic+orsf">orsf</a>.
</p>


<h3>See Also</h3>

<p>linear combination control functions
<code><a href="#topic+orsf_control_cph">orsf_control_cph</a>()</code>,
<code><a href="#topic+orsf_control_fast">orsf_control_fast</a>()</code>,
<code><a href="#topic+orsf_control_net">orsf_control_net</a>()</code>,
<code><a href="#topic+orsf_control">orsf_control</a>()</code>
</p>

<hr>
<h2 id='orsf_control_fast'>Accelerated ORSF control</h2><span id='topic+orsf_control_fast'></span>

<h3>Description</h3>

<p>Fast methods to identify linear combinations of predictors while
fitting an <a href="#topic+orsf">orsf</a> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_control_fast(method = "efron", do_scale = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_control_fast_+3A_method">method</code></td>
<td>
<p>(<em>character</em>) a character string specifying the method
for tie handling. If there are no ties, all the methods are
equivalent. Valid options are 'breslow' and 'efron'. The Efron
approximation is the default because it is more accurate when dealing
with tied event times and has similar computational efficiency compared
to the Breslow method.</p>
</td></tr>
<tr><td><code id="orsf_control_fast_+3A_do_scale">do_scale</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, values of predictors will be
scaled prior to each instance of Newton Raphson scoring, using summary
values from the data in the current node of the decision tree.</p>
</td></tr>
<tr><td><code id="orsf_control_fast_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>code from the  <a href="https://github.com/therneau/survival/blob/master/src/coxfit6.c">survival package</a>
was modified to make this routine.
</p>
<p>Adjust <code>do_scale</code> <em>at your own risk</em>. Setting <code>do_scale = FALSE</code> will
reduce computation time but will also make the <code>orsf</code> model dependent
on the scale of your data, which is why the default value is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>'orsf_control'</code>, which should be used as
an input for the <code>control</code> argument of <a href="#topic+orsf">orsf</a>.
</p>


<h3>See Also</h3>

<p>linear combination control functions
<code><a href="#topic+orsf_control_cph">orsf_control_cph</a>()</code>,
<code><a href="#topic+orsf_control_custom">orsf_control_custom</a>()</code>,
<code><a href="#topic+orsf_control_net">orsf_control_net</a>()</code>,
<code><a href="#topic+orsf_control">orsf_control</a>()</code>
</p>

<hr>
<h2 id='orsf_control_net'>Penalized Cox regression ORSF control</h2><span id='topic+orsf_control_net'></span>

<h3>Description</h3>

<p>Use regularized Cox proportional hazard models to identify linear
combinations of input variables while fitting an <a href="#topic+orsf">orsf</a> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_control_net(alpha = 1/2, df_target = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_control_net_+3A_alpha">alpha</code></td>
<td>
<p>(<em>double</em>) The elastic net mixing parameter. A value of 1 gives the
lasso penalty, and a value of 0 gives the ridge penalty. If multiple
values of alpha are given, then a penalized model is fit using each
alpha value prior to splitting a node.</p>
</td></tr>
<tr><td><code id="orsf_control_net_+3A_df_target">df_target</code></td>
<td>
<p>(<em>integer</em>) Preferred number of variables used in a linear combination.</p>
</td></tr>
<tr><td><code id="orsf_control_net_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>df_target</code> has to be less than <code>mtry</code>, which is a separate argument in
<a href="#topic+orsf">orsf</a> that indicates the number of variables chosen at random prior to
finding a linear combination of those variables.
</p>


<h3>Value</h3>

<p>an object of class <code>'orsf_control'</code>, which should be used as
an input for the <code>control</code> argument of <a href="#topic+orsf">orsf</a>.
</p>


<h3>References</h3>


<ol>
<li><p> Simon, Noah, Friedman, Jerome, Hastie, Trevor, Tibshirani, Rob (2011).
&quot;Regularization paths for Cox's proportional hazards model via
coordinate descent.&quot; <em>Journal of statistical software</em>, <em>39</em>(5), 1.
</p>
</li></ol>



<h3>See Also</h3>

<p>linear combination control functions
<code><a href="#topic+orsf_control_cph">orsf_control_cph</a>()</code>,
<code><a href="#topic+orsf_control_custom">orsf_control_custom</a>()</code>,
<code><a href="#topic+orsf_control_fast">orsf_control_fast</a>()</code>,
<code><a href="#topic+orsf_control">orsf_control</a>()</code>
</p>

<hr>
<h2 id='orsf_ice_oob'>Individual Conditional Expectations</h2><span id='topic+orsf_ice_oob'></span><span id='topic+orsf_ice_inb'></span><span id='topic+orsf_ice_new'></span>

<h3>Description</h3>

<p>Compute individual conditional expectations for an
oblique random forest. Unlike partial dependence, which shows the expected prediction as a function of one or multiple predictors, individual conditional expectations (ICE) show the prediction for an individual observation as a function of a predictor.
You can compute individual conditional expectations three ways using a random forest:
</p>

<ul>
<li><p> using in-bag predictions for the training data
</p>
</li>
<li><p> using out-of-bag predictions for the training data
</p>
</li>
<li><p> using predictions for a new set of data
</p>
</li></ul>

<p>See examples for more details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_ice_oob(
  object,
  pred_spec,
  pred_horizon = NULL,
  pred_type = NULL,
  expand_grid = TRUE,
  boundary_checks = TRUE,
  n_thread = NULL,
  verbose_progress = NULL,
  ...
)

orsf_ice_inb(
  object,
  pred_spec,
  pred_horizon = NULL,
  pred_type = NULL,
  expand_grid = TRUE,
  boundary_checks = TRUE,
  n_thread = NULL,
  verbose_progress = NULL,
  ...
)

orsf_ice_new(
  object,
  pred_spec,
  new_data,
  pred_horizon = NULL,
  pred_type = NULL,
  na_action = "fail",
  expand_grid = TRUE,
  boundary_checks = TRUE,
  n_thread = NULL,
  verbose_progress = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_ice_oob_+3A_object">object</code></td>
<td>
<p>(<em>ObliqueForest</em>) a trained oblique random forest object (see <a href="#topic+orsf">orsf</a>).</p>
</td></tr>
<tr><td><code id="orsf_ice_oob_+3A_pred_spec">pred_spec</code></td>
<td>
<p>(<em>named list</em>, <em>pspec_auto</em>, or <em>data.frame</em>).
</p>

<ul>
<li><p> If <code>pred_spec</code> is a named list,
Each item in the list should be a vector of values that will be used as
points in the partial dependence function. The name of each item in the
list should indicate which variable will be modified to take the
corresponding values.
</p>
</li>
<li><p> If <code>pred_spec</code> is created using <code>pred_spec_auto()</code>, all that is needed
is the names of variables to use (see <a href="#topic+pred_spec_auto">pred_spec_auto</a>).
</p>
</li>
<li><p> If <code>pred_spec</code> is a <code>data.frame</code>, columns will
indicate variable names, values will indicate variable values, and
partial dependence will be computed using the inputs on each row.
</p>
</li></ul>
</td></tr>
<tr><td><code id="orsf_ice_oob_+3A_pred_horizon">pred_horizon</code></td>
<td>
<p>(<em>double</em>) Only relevent for survival forests.
A value or vector indicating the time(s) that predictions will be
calibrated to. E.g., if you were predicting risk of incident heart
failure within the next 10 years, then <code>pred_horizon = 10</code>.
<code>pred_horizon</code> can be <code>NULL</code> if <code>pred_type</code> is <code>'mort'</code>, since
mortality predictions are aggregated over all event times</p>
</td></tr>
<tr><td><code id="orsf_ice_oob_+3A_pred_type">pred_type</code></td>
<td>
<p>(<em>character</em>) the type of predictions to compute. Valid
Valid options for survival are:
</p>

<ul>
<li><p> 'risk' : probability of having an event at or before <code>pred_horizon</code>.
</p>
</li>
<li><p> 'surv' : 1 - risk.
</p>
</li>
<li><p> 'chf': cumulative hazard function
</p>
</li>
<li><p> 'mort': mortality prediction
</p>
</li>
<li><p> 'time': survival time prediction
</p>
</li></ul>

<p>For classification:
</p>

<ul>
<li><p> 'prob': probability for each class
</p>
</li></ul>

<p>For regression:
</p>

<ul>
<li><p> 'mean': predicted mean, i.e., the expected value
</p>
</li></ul>
</td></tr>
<tr><td><code id="orsf_ice_oob_+3A_expand_grid">expand_grid</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, partial dependence will be
computed at all possible combinations of inputs in <code>pred_spec</code>. If
<code>FALSE</code>, partial dependence will be computed for each variable
in <code>pred_spec</code>, separately.</p>
</td></tr>
<tr><td><code id="orsf_ice_oob_+3A_boundary_checks">boundary_checks</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, <code>pred_spec</code> will be checked
to make sure the requested values are between the 10th and 90th
percentile in the object's training data. If <code>FALSE</code>, these checks are
skipped.</p>
</td></tr>
<tr><td><code id="orsf_ice_oob_+3A_n_thread">n_thread</code></td>
<td>
<p>(<em>integer</em>) number of threads to use while computing predictions. Default is 0, which allows a suitable number of threads to be used based on availability.</p>
</td></tr>
<tr><td><code id="orsf_ice_oob_+3A_verbose_progress">verbose_progress</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, progress will be
printed to console. If <code>FALSE</code> (the default), nothing will be
printed.</p>
</td></tr>
<tr><td><code id="orsf_ice_oob_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
<tr><td><code id="orsf_ice_oob_+3A_new_data">new_data</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a>, <a href="tibble.html#topic+tibble-package">tibble</a>, or <a href="data.table.html#topic+data.table">data.table</a> to compute predictions in.</p>
</td></tr>
<tr><td><code id="orsf_ice_oob_+3A_na_action">na_action</code></td>
<td>
<p>(<em>character</em>) what should happen when <code>new_data</code> contains missing values (i.e., <code>NA</code> values). Valid options are:
</p>

<ul>
<li><p> 'fail' : an error is thrown if <code>new_data</code> contains <code>NA</code> values
</p>
</li>
<li><p> 'omit' : rows in <code>new_data</code> with incomplete data will be dropped
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="data.table.html#topic+data.table">data.table</a> containing
individual conditional expectations for the specified variable(s)
and, if relevant, at the specified prediction horizon(s).
</p>


<h3>Examples</h3>

<p>You can compute individual conditional expectation and individual
conditional expectations in three ways:
</p>

<ul>
<li><p> using in-bag predictions for the training data. In-bag individual
conditional expectation indicates relationships that the model has
learned during training. This is helpful if your goal is to interpret
the model.
</p>
</li>
<li><p> using out-of-bag predictions for the training data. Out-of-bag
individual conditional expectation indicates relationships that the
model has learned during training but using the out-of-bag data
simulates application of the model to new data. This is helpful if you
want to test your model’s reliability or fairness in new data but you
don’t have access to a large testing set.
</p>
</li>
<li><p> using predictions for a new set of data. New data individual
conditional expectation shows how the model predicts outcomes for
observations it has not seen. This is helpful if you want to test your
model’s reliability or fairness.
</p>
</li></ul>



<h4>Classification</h4>

<p>Begin by fitting an oblique classification random forest:
</p>
<div class="sourceCode r"><pre>set.seed(329)

index_train &lt;- sample(nrow(penguins_orsf), 150) 

penguins_orsf_train &lt;- penguins_orsf[index_train, ]
penguins_orsf_test &lt;- penguins_orsf[-index_train, ]

fit_clsf &lt;- orsf(data = penguins_orsf_train, 
                 formula = species ~ .)
</pre></div>
<p>Compute individual conditional expectation using out-of-bag data for
<code>flipper_length_mm = c(190, 210)</code>.
</p>
<div class="sourceCode r"><pre>pred_spec &lt;- list(flipper_length_mm = c(190, 210))

ice_oob &lt;- orsf_ice_oob(fit_clsf, pred_spec = pred_spec)

ice_oob
</pre></div>
<div class="sourceCode"><pre>## Key: &lt;class&gt;
##      id_variable id_row  class flipper_length_mm       pred
##            &lt;int&gt; &lt;char&gt; &lt;fctr&gt;             &lt;num&gt;      &lt;num&gt;
##   1:           1      1 Adelie               190 0.92169247
##   2:           1      2 Adelie               190 0.80944657
##   3:           1      3 Adelie               190 0.85172955
##   4:           1      4 Adelie               190 0.93559327
##   5:           1      5 Adelie               190 0.97708693
##  ---                                                       
## 896:           2    146 Gentoo               210 0.26092984
## 897:           2    147 Gentoo               210 0.04798334
## 898:           2    148 Gentoo               210 0.07927359
## 899:           2    149 Gentoo               210 0.84779971
## 900:           2    150 Gentoo               210 0.11105143
</pre></div>
<p>There are two identifiers in the output:
</p>

<ul>
<li> <p><code>id_variable</code> is an identifier for the current value of the
variable(s) that are in the data. It is redundant if you only have one
variable, but helpful if there are multiple variables.
</p>
</li>
<li> <p><code>id_row</code> is an identifier for the observation in the original data.
</p>
</li></ul>

<p>Note that predicted probabilities are returned for each class and each
observation in the data. Predicted probabilities for a given observation
and given variable value sum to 1. For example,
</p>
<div class="sourceCode r"><pre>ice_oob %&gt;%
 .[flipper_length_mm == 190] %&gt;% 
 .[id_row == 1] %&gt;% 
 .[['pred']] %&gt;% 
 sum()
</pre></div>
<div class="sourceCode"><pre>## [1] 1
</pre></div>



<h4>Regression</h4>

<p>Begin by fitting an oblique regression random forest:
</p>
<div class="sourceCode r"><pre>set.seed(329)

index_train &lt;- sample(nrow(penguins_orsf), 150) 

penguins_orsf_train &lt;- penguins_orsf[index_train, ]
penguins_orsf_test &lt;- penguins_orsf[-index_train, ]

fit_regr &lt;- orsf(data = penguins_orsf_train, 
                 formula = bill_length_mm ~ .)
</pre></div>
<p>Compute individual conditional expectation using new data for
<code>flipper_length_mm = c(190, 210)</code>.
</p>
<div class="sourceCode r"><pre>pred_spec &lt;- list(flipper_length_mm = c(190, 210))

ice_new &lt;- orsf_ice_new(fit_regr, 
                        pred_spec = pred_spec,
                        new_data = penguins_orsf_test)

ice_new
</pre></div>
<div class="sourceCode"><pre>##      id_variable id_row flipper_length_mm     pred
##            &lt;int&gt; &lt;char&gt;             &lt;num&gt;    &lt;num&gt;
##   1:           1      1               190 37.94483
##   2:           1      2               190 37.61595
##   3:           1      3               190 37.53681
##   4:           1      4               190 39.49476
##   5:           1      5               190 38.95635
##  ---                                              
## 362:           2    179               210 51.80471
## 363:           2    180               210 47.27183
## 364:           2    181               210 47.05031
## 365:           2    182               210 50.39028
## 366:           2    183               210 48.44774
</pre></div>
<p>You can also let <code>pred_spec_auto</code> pick reasonable values like so:
</p>
<div class="sourceCode r"><pre>pred_spec = pred_spec_auto(species, island, body_mass_g)

ice_new &lt;- orsf_ice_new(fit_regr, 
                        pred_spec = pred_spec,
                        new_data = penguins_orsf_test)

ice_new
</pre></div>
<div class="sourceCode"><pre>##       id_variable id_row species    island body_mass_g     pred
##             &lt;int&gt; &lt;char&gt;  &lt;fctr&gt;    &lt;fctr&gt;       &lt;num&gt;    &lt;num&gt;
##    1:           1      1  Adelie    Biscoe        3200 37.78339
##    2:           1      2  Adelie    Biscoe        3200 37.73273
##    3:           1      3  Adelie    Biscoe        3200 37.71248
##    4:           1      4  Adelie    Biscoe        3200 40.25782
##    5:           1      5  Adelie    Biscoe        3200 40.04074
##   ---                                                          
## 8231:          45    179  Gentoo Torgersen        5300 46.14559
## 8232:          45    180  Gentoo Torgersen        5300 43.98050
## 8233:          45    181  Gentoo Torgersen        5300 44.59837
## 8234:          45    182  Gentoo Torgersen        5300 44.85146
## 8235:          45    183  Gentoo Torgersen        5300 44.23710
</pre></div>
<p>By default, all combinations of all variables are used. However, you can
also look at the variables one by one, separately, like so:
</p>
<div class="sourceCode r"><pre>ice_new &lt;- orsf_ice_new(fit_regr, 
                        expand_grid = FALSE,
                        pred_spec = pred_spec,
                        new_data = penguins_orsf_test)

ice_new
</pre></div>
<div class="sourceCode"><pre>##       id_variable id_row    variable value  level     pred
##             &lt;int&gt; &lt;char&gt;      &lt;char&gt; &lt;num&gt; &lt;char&gt;    &lt;num&gt;
##    1:           1      1     species    NA Adelie 37.74136
##    2:           1      2     species    NA Adelie 37.42367
##    3:           1      3     species    NA Adelie 37.04598
##    4:           1      4     species    NA Adelie 39.89602
##    5:           1      5     species    NA Adelie 39.14848
##   ---                                                     
## 2009:           5    179 body_mass_g  5300   &lt;NA&gt; 51.50196
## 2010:           5    180 body_mass_g  5300   &lt;NA&gt; 47.27055
## 2011:           5    181 body_mass_g  5300   &lt;NA&gt; 48.34064
## 2012:           5    182 body_mass_g  5300   &lt;NA&gt; 48.75828
## 2013:           5    183 body_mass_g  5300   &lt;NA&gt; 48.11020
</pre></div>
<p>And you can also bypass all the bells and whistles by using your own
<code>data.frame</code> for a <code>pred_spec</code>. (Just make sure you request values that
exist in the training data.)
</p>
<div class="sourceCode r"><pre>custom_pred_spec &lt;- data.frame(species = 'Adelie', 
                               island = 'Biscoe')

ice_new &lt;- orsf_ice_new(fit_regr, 
                        pred_spec = custom_pred_spec,
                        new_data = penguins_orsf_test)

ice_new
</pre></div>
<div class="sourceCode"><pre>##      id_variable id_row species island     pred
##            &lt;int&gt; &lt;char&gt;  &lt;fctr&gt; &lt;fctr&gt;    &lt;num&gt;
##   1:           1      1  Adelie Biscoe 38.52327
##   2:           1      2  Adelie Biscoe 38.32073
##   3:           1      3  Adelie Biscoe 37.71248
##   4:           1      4  Adelie Biscoe 41.68380
##   5:           1      5  Adelie Biscoe 40.91140
##  ---                                           
## 179:           1    179  Adelie Biscoe 43.09493
## 180:           1    180  Adelie Biscoe 38.79455
## 181:           1    181  Adelie Biscoe 39.37734
## 182:           1    182  Adelie Biscoe 40.71952
## 183:           1    183  Adelie Biscoe 39.34501
</pre></div>



<h4>Survival</h4>

<p>Begin by fitting an oblique survival random forest:
</p>
<div class="sourceCode r"><pre>set.seed(329)

index_train &lt;- sample(nrow(pbc_orsf), 150) 

pbc_orsf_train &lt;- pbc_orsf[index_train, ]
pbc_orsf_test &lt;- pbc_orsf[-index_train, ]

fit_surv &lt;- orsf(data = pbc_orsf_train, 
                 formula = Surv(time, status) ~ . - id,
                 oobag_pred_horizon = 365.25 * 5)
</pre></div>
<p>Compute individual conditional expectation using in-bag data for
<code>bili = c(1,2,3,4,5)</code>:
</p>
<div class="sourceCode r"><pre>ice_train &lt;- orsf_ice_inb(fit_surv, pred_spec = list(bili = 1:5))
ice_train
</pre></div>
<div class="sourceCode"><pre>##      id_variable id_row pred_horizon  bili      pred
##            &lt;int&gt; &lt;char&gt;        &lt;num&gt; &lt;num&gt;     &lt;num&gt;
##   1:           1      1      1826.25     1 0.1290317
##   2:           1      2      1826.25     1 0.1242352
##   3:           1      3      1826.25     1 0.0963452
##   4:           1      4      1826.25     1 0.1172367
##   5:           1      5      1826.25     1 0.2030256
##  ---                                                
## 746:           5    146      1826.25     5 0.7868537
## 747:           5    147      1826.25     5 0.2012954
## 748:           5    148      1826.25     5 0.4893605
## 749:           5    149      1826.25     5 0.4698220
## 750:           5    150      1826.25     5 0.9557285
</pre></div>
<p>If you don’t have specific values of a variable in mind, let
<code>pred_spec_auto</code> pick for you:
</p>
<div class="sourceCode r"><pre>ice_train &lt;- orsf_ice_inb(fit_surv, pred_spec_auto(bili))
ice_train
</pre></div>
<div class="sourceCode"><pre>##      id_variable id_row pred_horizon  bili       pred
##            &lt;int&gt; &lt;char&gt;        &lt;num&gt; &lt;num&gt;      &lt;num&gt;
##   1:           1      1      1826.25  0.55 0.11728559
##   2:           1      2      1826.25  0.55 0.11728839
##   3:           1      3      1826.25  0.55 0.08950739
##   4:           1      4      1826.25  0.55 0.10064959
##   5:           1      5      1826.25  0.55 0.18736417
##  ---                                                 
## 746:           5    146      1826.25  7.25 0.82600898
## 747:           5    147      1826.25  7.25 0.29156437
## 748:           5    148      1826.25  7.25 0.58395919
## 749:           5    149      1826.25  7.25 0.54202021
## 750:           5    150      1826.25  7.25 0.96391985
</pre></div>
<p>Specify <code>pred_horizon</code> to get individual conditional expectation at each
value:
</p>
<div class="sourceCode r"><pre>ice_train &lt;- orsf_ice_inb(fit_surv, pred_spec_auto(bili),
                          pred_horizon = seq(500, 3000, by = 500))
ice_train
</pre></div>
<div class="sourceCode"><pre>##       id_variable id_row pred_horizon  bili        pred
##             &lt;int&gt; &lt;char&gt;        &lt;num&gt; &lt;num&gt;       &lt;num&gt;
##    1:           1      1          500  0.55 0.008276627
##    2:           1      1         1000  0.55 0.055724516
##    3:           1      1         1500  0.55 0.085091120
##    4:           1      1         2000  0.55 0.123423352
##    5:           1      1         2500  0.55 0.166380739
##   ---                                                  
## 4496:           5    150         1000  7.25 0.837774757
## 4497:           5    150         1500  7.25 0.934536379
## 4498:           5    150         2000  7.25 0.967823286
## 4499:           5    150         2500  7.25 0.972059574
## 4500:           5    150         3000  7.25 0.980785643
</pre></div>
<p>Multi-prediction horizon ice comes with minimal extra computational
cost. Use a fine grid of time values and assess whether predictors have
time-varying effects.
</p>


<hr>
<h2 id='orsf_pd_oob'>Partial dependence</h2><span id='topic+orsf_pd_oob'></span><span id='topic+orsf_pd_inb'></span><span id='topic+orsf_pd_new'></span>

<h3>Description</h3>

<p>Compute partial dependence for an oblique random forest.
Partial dependence (PD) shows the expected prediction from a model as a function of a single predictor or multiple predictors. The expectation is marginalized over the values of all other predictors, giving something like a multivariable adjusted estimate of the model's prediction.
You can compute partial dependence three ways using a random forest:
</p>

<ul>
<li><p> using in-bag predictions for the training data
</p>
</li>
<li><p> using out-of-bag predictions for the training data
</p>
</li>
<li><p> using predictions for a new set of data
</p>
</li></ul>

<p>See examples for more details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_pd_oob(
  object,
  pred_spec,
  pred_horizon = NULL,
  pred_type = NULL,
  expand_grid = TRUE,
  prob_values = c(0.025, 0.5, 0.975),
  prob_labels = c("lwr", "medn", "upr"),
  boundary_checks = TRUE,
  n_thread = NULL,
  verbose_progress = NULL,
  ...
)

orsf_pd_inb(
  object,
  pred_spec,
  pred_horizon = NULL,
  pred_type = NULL,
  expand_grid = TRUE,
  prob_values = c(0.025, 0.5, 0.975),
  prob_labels = c("lwr", "medn", "upr"),
  boundary_checks = TRUE,
  n_thread = NULL,
  verbose_progress = NULL,
  ...
)

orsf_pd_new(
  object,
  pred_spec,
  new_data,
  pred_horizon = NULL,
  pred_type = NULL,
  na_action = "fail",
  expand_grid = TRUE,
  prob_values = c(0.025, 0.5, 0.975),
  prob_labels = c("lwr", "medn", "upr"),
  boundary_checks = TRUE,
  n_thread = NULL,
  verbose_progress = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_pd_oob_+3A_object">object</code></td>
<td>
<p>(<em>ObliqueForest</em>) a trained oblique random forest object (see <a href="#topic+orsf">orsf</a>).</p>
</td></tr>
<tr><td><code id="orsf_pd_oob_+3A_pred_spec">pred_spec</code></td>
<td>
<p>(<em>named list</em>, <em>pspec_auto</em>, or <em>data.frame</em>).
</p>

<ul>
<li><p> If <code>pred_spec</code> is a named list,
Each item in the list should be a vector of values that will be used as
points in the partial dependence function. The name of each item in the
list should indicate which variable will be modified to take the
corresponding values.
</p>
</li>
<li><p> If <code>pred_spec</code> is created using <code>pred_spec_auto()</code>, all that is needed
is the names of variables to use (see <a href="#topic+pred_spec_auto">pred_spec_auto</a>).
</p>
</li>
<li><p> If <code>pred_spec</code> is a <code>data.frame</code>, columns will
indicate variable names, values will indicate variable values, and
partial dependence will be computed using the inputs on each row.
</p>
</li></ul>
</td></tr>
<tr><td><code id="orsf_pd_oob_+3A_pred_horizon">pred_horizon</code></td>
<td>
<p>(<em>double</em>) Only relevent for survival forests.
A value or vector indicating the time(s) that predictions will be
calibrated to. E.g., if you were predicting risk of incident heart
failure within the next 10 years, then <code>pred_horizon = 10</code>.
<code>pred_horizon</code> can be <code>NULL</code> if <code>pred_type</code> is <code>'mort'</code>, since
mortality predictions are aggregated over all event times</p>
</td></tr>
<tr><td><code id="orsf_pd_oob_+3A_pred_type">pred_type</code></td>
<td>
<p>(<em>character</em>) the type of predictions to compute. Valid
Valid options for survival are:
</p>

<ul>
<li><p> 'risk' : probability of having an event at or before <code>pred_horizon</code>.
</p>
</li>
<li><p> 'surv' : 1 - risk.
</p>
</li>
<li><p> 'chf': cumulative hazard function
</p>
</li>
<li><p> 'mort': mortality prediction
</p>
</li>
<li><p> 'time': survival time prediction
</p>
</li></ul>

<p>For classification:
</p>

<ul>
<li><p> 'prob': probability for each class
</p>
</li></ul>

<p>For regression:
</p>

<ul>
<li><p> 'mean': predicted mean, i.e., the expected value
</p>
</li></ul>
</td></tr>
<tr><td><code id="orsf_pd_oob_+3A_expand_grid">expand_grid</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, partial dependence will be
computed at all possible combinations of inputs in <code>pred_spec</code>. If
<code>FALSE</code>, partial dependence will be computed for each variable
in <code>pred_spec</code>, separately.</p>
</td></tr>
<tr><td><code id="orsf_pd_oob_+3A_prob_values">prob_values</code></td>
<td>
<p>(<em>numeric</em>) a vector of values between 0 and 1,
indicating what quantiles will be used to summarize the partial
dependence values at each set of inputs. <code>prob_values</code> should
have the same length as <code>prob_labels</code>. The quantiles are calculated
based on predictions from <code>object</code> at each set of values indicated
by <code>pred_spec</code>.</p>
</td></tr>
<tr><td><code id="orsf_pd_oob_+3A_prob_labels">prob_labels</code></td>
<td>
<p>(<em>character</em>) a vector of labels with the same length
as <code>prob_values</code>, with each label indicating what the corresponding
value in <code>prob_values</code> should be labelled as in summarized outputs.
<code>prob_labels</code> should have the same length as <code>prob_values</code>.</p>
</td></tr>
<tr><td><code id="orsf_pd_oob_+3A_boundary_checks">boundary_checks</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, <code>pred_spec</code> will be checked
to make sure the requested values are between the 10th and 90th
percentile in the object's training data. If <code>FALSE</code>, these checks are
skipped.</p>
</td></tr>
<tr><td><code id="orsf_pd_oob_+3A_n_thread">n_thread</code></td>
<td>
<p>(<em>integer</em>) number of threads to use while computing predictions. Default is 0, which allows a suitable number of threads to be used based on availability.</p>
</td></tr>
<tr><td><code id="orsf_pd_oob_+3A_verbose_progress">verbose_progress</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, progress will be
printed to console. If <code>FALSE</code> (the default), nothing will be
printed.</p>
</td></tr>
<tr><td><code id="orsf_pd_oob_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
<tr><td><code id="orsf_pd_oob_+3A_new_data">new_data</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a>, <a href="tibble.html#topic+tibble-package">tibble</a>, or <a href="data.table.html#topic+data.table">data.table</a> to compute predictions in.</p>
</td></tr>
<tr><td><code id="orsf_pd_oob_+3A_na_action">na_action</code></td>
<td>
<p>(<em>character</em>) what should happen when <code>new_data</code> contains missing values (i.e., <code>NA</code> values). Valid options are:
</p>

<ul>
<li><p> 'fail' : an error is thrown if <code>new_data</code> contains <code>NA</code> values
</p>
</li>
<li><p> 'omit' : rows in <code>new_data</code> with incomplete data will be dropped
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Partial dependence has a number of <a href="https://christophm.github.io/interpretable-ml-book/pdp.html#disadvantages-5">known limitations and assumptions</a> that users should be aware of (see Hooker, 2021). In particular, partial dependence is less intuitive when &gt;2 predictors are examined jointly, and it is assumed that the feature(s) for which the partial dependence is computed are not correlated with other features (this is likely not true in many cases). Accumulated local effect plots can be used (see <a href="https://christophm.github.io/interpretable-ml-book/ale.html">here</a>) in the case where feature independence is not a valid assumption.
</p>


<h3>Value</h3>

<p>a <a href="data.table.html#topic+data.table">data.table</a> containing
partial dependence values for the specified variable(s)
and, if relevant, at the specified prediction horizon(s).
</p>


<h3>Examples</h3>

<p>You can compute partial dependence and individual conditional
expectations in three ways:
</p>

<ul>
<li><p> using in-bag predictions for the training data. In-bag partial
dependence indicates relationships that the model has learned during
training. This is helpful if your goal is to interpret the model.
</p>
</li>
<li><p> using out-of-bag predictions for the training data. Out-of-bag partial
dependence indicates relationships that the model has learned during
training but using the out-of-bag data simulates application of the
model to new data. This is helpful if you want to test your model’s
reliability or fairness in new data but you don’t have access to a
large testing set.
</p>
</li>
<li><p> using predictions for a new set of data. New data partial dependence
shows how the model predicts outcomes for observations it has not
seen. This is helpful if you want to test your model’s reliability or
fairness.
</p>
</li></ul>



<h4>Classification</h4>

<p>Begin by fitting an oblique classification random forest:
</p>
<div class="sourceCode r"><pre>set.seed(329)

index_train &lt;- sample(nrow(penguins_orsf), 150) 

penguins_orsf_train &lt;- penguins_orsf[index_train, ]
penguins_orsf_test &lt;- penguins_orsf[-index_train, ]

fit_clsf &lt;- orsf(data = penguins_orsf_train, 
                 formula = species ~ .)
</pre></div>
<p>Compute partial dependence using out-of-bag data for
<code>flipper_length_mm = c(190, 210)</code>.
</p>
<div class="sourceCode r"><pre>pred_spec &lt;- list(flipper_length_mm = c(190, 210))

pd_oob &lt;- orsf_pd_oob(fit_clsf, pred_spec = pred_spec)

pd_oob
</pre></div>
<div class="sourceCode"><pre>## Key: &lt;class&gt;
##        class flipper_length_mm      mean         lwr       medn       upr
##       &lt;fctr&gt;             &lt;num&gt;     &lt;num&gt;       &lt;num&gt;      &lt;num&gt;     &lt;num&gt;
## 1:    Adelie               190 0.6176908 0.202278109 0.75856417 0.9810614
## 2:    Adelie               210 0.4338528 0.019173811 0.56489202 0.8648110
## 3: Chinstrap               190 0.2114979 0.017643385 0.15211271 0.7215181
## 4: Chinstrap               210 0.1803019 0.020108201 0.09679464 0.7035053
## 5:    Gentoo               190 0.1708113 0.001334861 0.02769695 0.5750201
## 6:    Gentoo               210 0.3858453 0.068685035 0.20717073 0.9532853
</pre></div>
<p>Note that predicted probabilities are returned for each class and
probabilities in the <code>mean</code> column sum to 1 if you take the sum over
each class at a specific value of the <code>pred_spec</code> variables. For
example,
</p>
<div class="sourceCode r"><pre>sum(pd_oob[flipper_length_mm == 190, mean])
</pre></div>
<div class="sourceCode"><pre>## [1] 1
</pre></div>
<p>But this isn’t the case for the median predicted probability!
</p>
<div class="sourceCode r"><pre>sum(pd_oob[flipper_length_mm == 190, medn])
</pre></div>
<div class="sourceCode"><pre>## [1] 0.9383738
</pre></div>



<h4>Regression</h4>

<p>Begin by fitting an oblique regression random forest:
</p>
<div class="sourceCode r"><pre>set.seed(329)

index_train &lt;- sample(nrow(penguins_orsf), 150) 

penguins_orsf_train &lt;- penguins_orsf[index_train, ]
penguins_orsf_test &lt;- penguins_orsf[-index_train, ]

fit_regr &lt;- orsf(data = penguins_orsf_train, 
                 formula = bill_length_mm ~ .)
</pre></div>
<p>Compute partial dependence using new data for
<code>flipper_length_mm = c(190, 210)</code>.
</p>
<div class="sourceCode r"><pre>pred_spec &lt;- list(flipper_length_mm = c(190, 210))

pd_new &lt;- orsf_pd_new(fit_regr, 
                      pred_spec = pred_spec,
                      new_data = penguins_orsf_test)

pd_new
</pre></div>
<div class="sourceCode"><pre>##    flipper_length_mm     mean      lwr     medn      upr
##                &lt;num&gt;    &lt;num&gt;    &lt;num&gt;    &lt;num&gt;    &lt;num&gt;
## 1:               190 42.96571 37.09805 43.69769 48.72301
## 2:               210 45.66012 40.50693 46.31577 51.65163
</pre></div>
<p>You can also let <code>pred_spec_auto</code> pick reasonable values like so:
</p>
<div class="sourceCode r"><pre>pred_spec = pred_spec_auto(species, island, body_mass_g)

pd_new &lt;- orsf_pd_new(fit_regr, 
                      pred_spec = pred_spec,
                      new_data = penguins_orsf_test)

pd_new
</pre></div>
<div class="sourceCode"><pre>##       species    island body_mass_g     mean      lwr     medn      upr
##        &lt;fctr&gt;    &lt;fctr&gt;       &lt;num&gt;    &lt;num&gt;    &lt;num&gt;    &lt;num&gt;    &lt;num&gt;
##  1:    Adelie    Biscoe        3200 40.31374 37.24373 40.31967 44.22824
##  2: Chinstrap    Biscoe        3200 45.10582 42.63342 45.10859 47.60119
##  3:    Gentoo    Biscoe        3200 42.81649 40.19221 42.55664 46.84035
##  4:    Adelie     Dream        3200 40.16219 36.95895 40.34633 43.90681
##  5: Chinstrap     Dream        3200 46.21778 43.53954 45.90929 49.19173
## ---                                                                    
## 41: Chinstrap     Dream        5300 48.48139 46.36282 48.25679 51.02996
## 42:    Gentoo     Dream        5300 45.91819 43.62832 45.54110 49.91622
## 43:    Adelie Torgersen        5300 42.92879 40.66576 42.31072 46.76406
## 44: Chinstrap Torgersen        5300 46.59576 44.80400 46.49196 49.03906
## 45:    Gentoo Torgersen        5300 45.11384 42.95190 44.51289 49.27629
</pre></div>
<p>By default, all combinations of all variables are used. However, you can
also look at the variables one by one, separately, like so:
</p>
<div class="sourceCode r"><pre>pd_new &lt;- orsf_pd_new(fit_regr, 
                      expand_grid = FALSE,
                      pred_spec = pred_spec,
                      new_data = penguins_orsf_test)

pd_new
</pre></div>
<div class="sourceCode"><pre>##        variable value     level     mean      lwr     medn      upr
##          &lt;char&gt; &lt;num&gt;    &lt;char&gt;    &lt;num&gt;    &lt;num&gt;    &lt;num&gt;    &lt;num&gt;
##  1:     species    NA    Adelie 41.90271 37.10417 41.51723 48.51478
##  2:     species    NA Chinstrap 47.11314 42.40419 46.96478 51.51392
##  3:     species    NA    Gentoo 44.37038 39.87306 43.89889 51.21635
##  4:      island    NA    Biscoe 44.21332 37.22711 45.27862 51.21635
##  5:      island    NA     Dream 44.43354 37.01471 45.57261 51.51392
##  6:      island    NA Torgersen 43.29539 37.01513 44.26924 49.84391
##  7: body_mass_g  3200      &lt;NA&gt; 42.84625 37.03978 43.95991 49.19173
##  8: body_mass_g  3550      &lt;NA&gt; 43.53326 37.56730 44.43756 50.47092
##  9: body_mass_g  3975      &lt;NA&gt; 44.30431 38.31567 45.22089 51.50683
## 10: body_mass_g  4700      &lt;NA&gt; 45.22559 39.88199 46.34680 51.18955
## 11: body_mass_g  5300      &lt;NA&gt; 45.91412 40.84742 46.95327 51.48851
</pre></div>
<p>And you can also bypass all the bells and whistles by using your own
<code>data.frame</code> for a <code>pred_spec</code>. (Just make sure you request values that
exist in the training data.)
</p>
<div class="sourceCode r"><pre>custom_pred_spec &lt;- data.frame(species = 'Adelie', 
                               island = 'Biscoe')

pd_new &lt;- orsf_pd_new(fit_regr, 
                      pred_spec = custom_pred_spec,
                      new_data = penguins_orsf_test)

pd_new
</pre></div>
<div class="sourceCode"><pre>##    species island     mean      lwr     medn      upr
##     &lt;fctr&gt; &lt;fctr&gt;    &lt;num&gt;    &lt;num&gt;    &lt;num&gt;    &lt;num&gt;
## 1:  Adelie Biscoe 41.98024 37.22711 41.65252 48.51478
</pre></div>



<h4>Survival</h4>

<p>Begin by fitting an oblique survival random forest:
</p>
<div class="sourceCode r"><pre>set.seed(329)

index_train &lt;- sample(nrow(pbc_orsf), 150) 

pbc_orsf_train &lt;- pbc_orsf[index_train, ]
pbc_orsf_test &lt;- pbc_orsf[-index_train, ]

fit_surv &lt;- orsf(data = pbc_orsf_train, 
                 formula = Surv(time, status) ~ . - id,
                 oobag_pred_horizon = 365.25 * 5)
</pre></div>
<p>Compute partial dependence using in-bag data for <code>bili = c(1,2,3,4,5)</code>:
</p>
<div class="sourceCode r"><pre>pd_train &lt;- orsf_pd_inb(fit_surv, pred_spec = list(bili = 1:5))
pd_train
</pre></div>
<div class="sourceCode"><pre>##    pred_horizon  bili      mean        lwr      medn       upr
##           &lt;num&gt; &lt;num&gt;     &lt;num&gt;      &lt;num&gt;     &lt;num&gt;     &lt;num&gt;
## 1:      1826.25     1 0.2566200 0.02234786 0.1334170 0.8918909
## 2:      1826.25     2 0.3121392 0.06853733 0.1896849 0.9204338
## 3:      1826.25     3 0.3703242 0.11409793 0.2578505 0.9416791
## 4:      1826.25     4 0.4240692 0.15645214 0.3331057 0.9591581
## 5:      1826.25     5 0.4663670 0.20123406 0.3841700 0.9655296
</pre></div>
<p>If you don’t have specific values of a variable in mind, let
<code>pred_spec_auto</code> pick for you:
</p>
<div class="sourceCode r"><pre>pd_train &lt;- orsf_pd_inb(fit_surv, pred_spec_auto(bili))
pd_train
</pre></div>
<div class="sourceCode"><pre>##    pred_horizon  bili      mean        lwr      medn       upr
##           &lt;num&gt; &lt;num&gt;     &lt;num&gt;      &lt;num&gt;     &lt;num&gt;     &lt;num&gt;
## 1:      1826.25  0.55 0.2481444 0.02035041 0.1242215 0.8801444
## 2:      1826.25  0.70 0.2502831 0.02045039 0.1271039 0.8836536
## 3:      1826.25  1.50 0.2797763 0.03964900 0.1601715 0.9041584
## 4:      1826.25  3.50 0.3959349 0.13431288 0.2920400 0.9501230
## 5:      1826.25  7.25 0.5351935 0.28064629 0.4652185 0.9783000
</pre></div>
<p>Specify <code>pred_horizon</code> to get partial dependence at each value:
</p>
<div class="sourceCode r"><pre>pd_train &lt;- orsf_pd_inb(fit_surv, pred_spec_auto(bili),
                        pred_horizon = seq(500, 3000, by = 500))
pd_train
</pre></div>
<div class="sourceCode"><pre>##     pred_horizon  bili      mean         lwr       medn       upr
##            &lt;num&gt; &lt;num&gt;     &lt;num&gt;       &lt;num&gt;      &lt;num&gt;     &lt;num&gt;
##  1:          500  0.55 0.0617199 0.000443399 0.00865419 0.5907104
##  2:         1000  0.55 0.1418501 0.005793742 0.05572853 0.7360749
##  3:         1500  0.55 0.2082505 0.013609478 0.09174558 0.8556319
##  4:         2000  0.55 0.2679017 0.023047689 0.14574169 0.8910549
##  5:         2500  0.55 0.3179617 0.063797305 0.20254500 0.9017710
## ---                                                              
## 26:         1000  7.25 0.3264627 0.135343689 0.25956791 0.8884333
## 27:         1500  7.25 0.4641265 0.218208755 0.38787435 0.9702903
## 28:         2000  7.25 0.5511761 0.293367409 0.48427730 0.9812413
## 29:         2500  7.25 0.6200238 0.371965247 0.56954399 0.9845058
## 30:         3000  7.25 0.6803482 0.425128031 0.64642318 0.9888637
</pre></div>
<p>vector-valued <code>pred_horizon</code> input comes with minimal extra
computational cost. Use a fine grid of time values and assess whether
predictors have time-varying effects. (see partial dependence vignette
for example)
</p>



<h3>References</h3>


<ol>
<li><p> Hooker, Giles, Mentch, Lucas, Zhou, Siyu (2021). &quot;Unrestricted
permutation forces extrapolation: variable importance requires at least
one more model, or there is no free variable importance.&quot; <em>Statistics
and Computing</em>, <em>31</em>, 1-16.
</p>
</li></ol>


<hr>
<h2 id='orsf_scale_cph'>Scale input data</h2><span id='topic+orsf_scale_cph'></span><span id='topic+orsf_unscale_cph'></span>

<h3>Description</h3>

<p>These functions are exported so that users may access internal routines
that are used to scale inputs when <a href="#topic+orsf_control_cph">orsf_control_cph</a> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_scale_cph(x_mat, w_vec = NULL)

orsf_unscale_cph(x_mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_scale_cph_+3A_x_mat">x_mat</code></td>
<td>
<p>(<em>numeric matrix</em>) a matrix with values to be scaled or
unscaled. Note that <code>orsf_unscale_cph</code> will only accept <code>x_mat</code> inputs
that have an attribute containing transform values, which are added
automatically by <code>orsf_scale_cph</code>.</p>
</td></tr>
<tr><td><code id="orsf_scale_cph_+3A_w_vec">w_vec</code></td>
<td>
<p>(<em>numeric vector</em>) an optional vector of weights. If no weights
are supplied (the default), all observations will be equally weighted. If
supplied, <code>w_vec</code> must have length equal to <code>nrow(x_mat)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data are transformed by first subtracting the mean and then
multiplying by the scale. An inverse transform can be completed using
<code>orsf_unscale_cph</code> or by dividing each column by the corresponding scale
and then adding the mean.
</p>
<p>The values of means and scales are stored in an attribute of the output
returned by <code>orsf_scale_cph</code> (see examples)
</p>


<h3>Value</h3>

<p>the scaled or unscaled <code>x_mat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x_mat &lt;- as.matrix(pbc_orsf[, c('bili', 'age', 'protime')])

head(x_mat)

x_scaled &lt;- orsf_scale_cph(x_mat)

head(x_scaled)

attributes(x_scaled) # note the transforms attribute

x_unscaled &lt;- orsf_unscale_cph(x_scaled)

head(x_unscaled)

# numeric difference in x_mat and x_unscaled should be practically 0
max(abs(x_mat - x_unscaled))
</code></pre>

<hr>
<h2 id='orsf_summarize_uni'>Univariate summary</h2><span id='topic+orsf_summarize_uni'></span>

<h3>Description</h3>

<p>Summarize the univariate information from an ORSF object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_summarize_uni(
  object,
  n_variables = NULL,
  pred_horizon = NULL,
  pred_type = NULL,
  importance = NULL,
  class = NULL,
  verbose_progress = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_summarize_uni_+3A_object">object</code></td>
<td>
<p>(<em>ObliqueForest</em>) a trained oblique random forest object (see <a href="#topic+orsf">orsf</a>).</p>
</td></tr>
<tr><td><code id="orsf_summarize_uni_+3A_n_variables">n_variables</code></td>
<td>
<p>(<em>integer</em>) how many variables should be summarized?
Setting this input to a lower number will reduce computation time.</p>
</td></tr>
<tr><td><code id="orsf_summarize_uni_+3A_pred_horizon">pred_horizon</code></td>
<td>
<p>(<em>double</em>) Only relevent for survival forests.
A value or vector indicating the time(s) that predictions will be
calibrated to. E.g., if you were predicting risk of incident heart
failure within the next 10 years, then <code>pred_horizon = 10</code>.
<code>pred_horizon</code> can be <code>NULL</code> if <code>pred_type</code> is <code>'mort'</code>, since
mortality predictions are aggregated over all event times</p>
</td></tr>
<tr><td><code id="orsf_summarize_uni_+3A_pred_type">pred_type</code></td>
<td>
<p>(<em>character</em>) the type of predictions to compute. Valid
Valid options for survival are:
</p>

<ul>
<li><p> 'risk' : probability of having an event at or before <code>pred_horizon</code>.
</p>
</li>
<li><p> 'surv' : 1 - risk.
</p>
</li>
<li><p> 'chf': cumulative hazard function
</p>
</li>
<li><p> 'mort': mortality prediction
</p>
</li>
<li><p> 'time': survival time prediction
</p>
</li></ul>

<p>For classification:
</p>

<ul>
<li><p> 'prob': probability for each class
</p>
</li></ul>

<p>For regression:
</p>

<ul>
<li><p> 'mean': predicted mean, i.e., the expected value
</p>
</li></ul>
</td></tr>
<tr><td><code id="orsf_summarize_uni_+3A_importance">importance</code></td>
<td>
<p>(<em>character</em>) Indicate method for variable importance:
</p>

<ul>
<li><p> 'none': no variable importance is computed.
</p>
</li>
<li><p> 'anova': compute analysis of variance (ANOVA) importance
</p>
</li>
<li><p> 'negate': compute negation importance
</p>
</li>
<li><p> 'permute': compute permutation importance
</p>
</li></ul>
</td></tr>
<tr><td><code id="orsf_summarize_uni_+3A_class">class</code></td>
<td>
<p>(<em>character</em>) only relevant for classification forests.
If <code>NULL</code> (the default), summary statistics are returned for all
classes in the outcome, and printed summaries will show the last
class in the class levels. To specify a single class to summarize,
indicate the name of the class with <code>class</code>. E.g., if the categorical
outcome has class levels A, B,  and C, then using <code>class = "A"</code> will
restrict output to class A.
</p>
<p>For details on these methods, see <a href="#topic+orsf_vi">orsf_vi</a>.</p>
</td></tr>
<tr><td><code id="orsf_summarize_uni_+3A_verbose_progress">verbose_progress</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, progress will be
printed to console. If <code>FALSE</code> (the default), nothing will be
printed.</p>
</td></tr>
<tr><td><code id="orsf_summarize_uni_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>pred_horizon</code> is left unspecified, the median value of
the time-to-event variable in <code>object</code>'s training data will be used.
It is recommended to always specify your own prediction horizon,
as the median time may not be an especially meaningful horizon to
compute predicted risk values at.
</p>
<p>If <code>object</code> already has variable importance values, you can
safely bypass the computation of variable importance in this function
by setting importance = 'none'.
</p>


<h3>Value</h3>

<p>an object of class 'orsf_summary', which includes data on
</p>

<ul>
<li><p> importance of individual predictors.
</p>
</li>
<li><p> expected values of predictions at specific values of predictors.
</p>
</li></ul>



<h3>See Also</h3>

<p>as.data.table.orsf_summary_uni
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
object &lt;- orsf(pbc_orsf, Surv(time, status) ~ . - id, n_tree = 25)

# since anova importance was used to make object, it is also
# used for ranking variables in the summary, unless we specify
# a different type of importance

orsf_summarize_uni(object, n_variables = 2)

# if we want to summarize object according to variables
# ranked by negation importance, we can compute negation
# importance within orsf_summarize_uni() as follows:

orsf_summarize_uni(object, n_variables = 2, importance = 'negate')

# for multi-category fits, you can specify which class
# you want to summarize:

object =  orsf(species ~ ., data = penguins_orsf, n_tree = 25)

orsf_summarize_uni(object, class = "Adelie", n_variables = 1)


</code></pre>

<hr>
<h2 id='orsf_time_to_train'>Estimate training time</h2><span id='topic+orsf_time_to_train'></span>

<h3>Description</h3>

<p>Estimate training time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_time_to_train(object, n_tree_subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_time_to_train_+3A_object">object</code></td>
<td>
<p>an untrained <code>aorsf</code> object</p>
</td></tr>
<tr><td><code id="orsf_time_to_train_+3A_n_tree_subset">n_tree_subset</code></td>
<td>
<p>(<em>integer</em>)  how many trees should be fit in order
to estimate the time needed to train <code>object</code>. The default value is 10%
of the trees specified in <code>object</code>. I.e., if <code>object</code> has <code>n_tree</code> of
500, then the default value <code>n_tree_subset</code> is 50.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="base.html#topic+difftime">difftime</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# specify but do not train the model by setting no_fit = TRUE.
object &lt;- orsf(pbc_orsf, Surv(time, status) ~ . - id,
               n_tree = 10, no_fit = TRUE)

# approximate the time it will take to grow 10 trees
time_estimated &lt;- orsf_time_to_train(object, n_tree_subset=1)

print(time_estimated)

# let's see how close the approximation was
time_true_start &lt;- Sys.time()
orsf_train(object)
time_true_stop &lt;- Sys.time()

time_true &lt;- time_true_stop - time_true_start

print(time_true)

# error
abs(time_true - time_estimated)

</code></pre>

<hr>
<h2 id='orsf_update'>Update Forest Parameters</h2><span id='topic+orsf_update'></span>

<h3>Description</h3>

<p>Update Forest Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_update(object, ..., modify_in_place = FALSE, no_fit = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_update_+3A_object">object</code></td>
<td>
<p>(<em>ObliqueForest</em>) an oblique random forest object (see <a href="#topic+orsf">orsf</a>).</p>
</td></tr>
<tr><td><code id="orsf_update_+3A_...">...</code></td>
<td>
<p>arguments to plug into <a href="#topic+orsf">orsf</a> that will be used to define the
update. These arguments include:
</p>

<ul>
<li> <p><code>data</code>
</p>
</li>
<li> <p><code>formula</code>
</p>
</li>
<li> <p><code>control</code>
</p>
</li>
<li> <p><code>weights</code>
</p>
</li>
<li> <p><code>n_tree</code>
</p>
</li>
<li> <p><code>n_split</code>
</p>
</li>
<li> <p><code>n_retry</code>
</p>
</li>
<li> <p><code>n_thread</code>
</p>
</li>
<li> <p><code>mtry</code>
</p>
</li>
<li> <p><code>sample_with_replacement</code>
</p>
</li>
<li> <p><code>sample_fraction</code>
</p>
</li>
<li> <p><code>leaf_min_events</code>
</p>
</li>
<li> <p><code>leaf_min_obs</code>
</p>
</li>
<li> <p><code>split_rule</code>
</p>
</li>
<li> <p><code>split_min_events</code>
</p>
</li>
<li> <p><code>split_min_obs</code>
</p>
</li>
<li> <p><code>split_min_stat</code>
</p>
</li>
<li> <p><code>pred_type</code>
</p>
</li>
<li> <p><code>oobag_pred_horizon</code>
</p>
</li>
<li> <p><code>oobag_eval_every</code>
</p>
</li>
<li> <p><code>oobag_fun</code>
</p>
</li>
<li> <p><code>importance</code>
</p>
</li>
<li> <p><code>importance_max_pvalue</code>
</p>
</li>
<li> <p><code>group_factors</code>
</p>
</li>
<li> <p><code>tree_seeds</code>
</p>
</li>
<li> <p><code>na_action</code>
</p>
</li>
<li> <p><code>verbose_progress</code>
</p>
</li></ul>

<p>Note that you can update <code>control</code>, but you cannot change the type
of forest. For example, you can't go from classification to regression
with <code>orsf_update</code>.</p>
</td></tr>
<tr><td><code id="orsf_update_+3A_modify_in_place">modify_in_place</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, <code>object</code> will be modified
by the inputs specified in <code>...</code>. Be cautious, as modification in place
will overwrite existing data. If <code>FALSE</code> (the default), <code>object</code> will
be copied and then the modifications will be applied to the copy,
leaving the original <code>object</code> unmodified.</p>
</td></tr>
<tr><td><code id="orsf_update_+3A_no_fit">no_fit</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, model fitting steps are defined and
saved, but training is not initiated. The object returned can be
directly submitted to <code>orsf_train()</code> so long as <code>attach_data</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are several dynamic inputs in <code>orsf</code> with default values of <code>NULL</code>.
Specifically, these inputs are <code>control</code>, <code>weights</code>, <code>mtry</code>, <code>split_rule</code>,
<code>split_min_stat</code>, <code>pred_type</code>, <code>pred_horizon</code>, <code>oobag_eval_function</code>,
<code>tree_seeds</code>, and <code>oobag_eval_every</code>. If no explicit value is given for
these inputs in the call, they <em>will be re-formed</em>. For example, if
an initial forest includes 17 predictors, the default <code>mtry</code> is the
smallest integer that is greater than or equal to the square root of 17,
i.e., 5. Then, if you make an updated forest with 1 less predictor and
you do not explicitly say <code>mtry = 5</code>, then <code>mtry</code> will be re-initialized
in the update based on the available 16 predictors, and the resulting
value of <code>mtry</code> will be 4. This is done to avoid many potential errors
that would occur if the dynamic outputs were not re-initialized.
</p>


<h3>Value</h3>

<p>an <code>ObliqueForest</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# initial fit has mtry of 5
fit &lt;- orsf(pbc_orsf, time + status ~ . -id)

# note that mtry is now 4 (see details)
fit_new &lt;- orsf_update(fit, formula = . ~ . - edema, n_tree = 100)

# prevent dynamic updates by specifying inputs you want to freeze.
fit_newer &lt;- orsf_update(fit_new, mtry = 2)

## End(Not run)


</code></pre>

<hr>
<h2 id='orsf_vi'>Variable Importance</h2><span id='topic+orsf_vi'></span><span id='topic+orsf_vi_negate'></span><span id='topic+orsf_vi_permute'></span><span id='topic+orsf_vi_anova'></span>

<h3>Description</h3>

<p>Estimate the importance of individual predictor variables using
oblique random forests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_vi(
  object,
  group_factors = TRUE,
  importance = NULL,
  oobag_fun = NULL,
  n_thread = NULL,
  verbose_progress = NULL,
  ...
)

orsf_vi_negate(
  object,
  group_factors = TRUE,
  oobag_fun = NULL,
  n_thread = NULL,
  verbose_progress = NULL,
  ...
)

orsf_vi_permute(
  object,
  group_factors = TRUE,
  oobag_fun = NULL,
  n_thread = NULL,
  verbose_progress = NULL,
  ...
)

orsf_vi_anova(object, group_factors = TRUE, verbose_progress = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_vi_+3A_object">object</code></td>
<td>
<p>(<em>ObliqueForest</em>) a trained oblique random forest object (see <a href="#topic+orsf">orsf</a>).</p>
</td></tr>
<tr><td><code id="orsf_vi_+3A_group_factors">group_factors</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, the importance of factor variables will be reported overall by aggregating the importance of individual levels of the factor. If <code>FALSE</code>, the importance of individual factor levels will be returned.</p>
</td></tr>
<tr><td><code id="orsf_vi_+3A_importance">importance</code></td>
<td>
<p>(<em>character</em>) Indicate method for variable importance:
</p>

<ul>
<li><p> 'anova': compute analysis of variance (ANOVA) importance
</p>
</li>
<li><p> 'negate': compute negation importance
</p>
</li>
<li><p> 'permute': compute permutation importance
</p>
</li></ul>
</td></tr>
<tr><td><code id="orsf_vi_+3A_oobag_fun">oobag_fun</code></td>
<td>
<p>(<em>function</em>) to be used for evaluating out-of-bag prediction accuracy after negating coefficients
(if importance = 'negate') or permuting the values of a predictor
(if importance = 'permute')
</p>

<ul>
<li><p> When <code>oobag_fun = NULL</code> (the default), the evaluation statistic is selected based on tree type
</p>
</li>
<li><p> survival: Harrell's C-statistic (1982)
</p>
</li>
<li><p> classification: Area underneath the ROC curve (AUC-ROC)
</p>
</li>
<li><p> regression: Traditional prediction R-squared
</p>
</li>
<li><p> if you use your own <code>oobag_fun</code> note the following:
</p>

<ul>
<li> <p><code>oobag_fun</code> should have three inputs: <code>y_mat</code>, <code>w_vec</code>, and <code>s_vec</code>
</p>
</li>
<li><p> For survival trees, <code>y_mat</code> should be a two column matrix with first column named 'time' and second named 'status'. For classification trees, <code>y_mat</code> should be a matrix with number of columns = number of distinct classes in the outcome. For regression, <code>y_mat</code> should be a matrix with one column.
</p>
</li>
<li> <p><code>s_vec</code> is a numeric vector containing predictions
</p>
</li>
<li> <p><code>oobag_fun</code> should return a numeric output of length 1
</p>
</li>
<li><p> the same <code>oobag_fun</code> should have been used when you created <code>object</code>
so that the initial value of out-of-bag prediction accuracy is
consistent with the values that will be computed while variable
importance is estimated.
</p>
</li></ul>

</li></ul>

<p>For more details, see the out-of-bag
<a href="https://docs.ropensci.org/aorsf/articles/oobag.html">vignette</a>.</p>
</td></tr>
<tr><td><code id="orsf_vi_+3A_n_thread">n_thread</code></td>
<td>
<p>(<em>integer</em>) number of threads to use while computing predictions. Default is 0, which allows a suitable number of threads to be used based on availability.</p>
</td></tr>
<tr><td><code id="orsf_vi_+3A_verbose_progress">verbose_progress</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, progress messages are
printed in the console. If <code>FALSE</code> (the default), nothing is printed.</p>
</td></tr>
<tr><td><code id="orsf_vi_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When an <code>ObliqueForest</code> object is grown with importance = 'anova',
'negate', or 'permute', the output will have a vector of importance
values based on the requested type of importance. However, <code>orsf_vi()</code>
can be used to compute variable importance after growing a forest
or to compute a different type of importance.
</p>
<p><code>orsf_vi()</code> is a general purpose function to extract or compute variable
importance estimates from an <code>ObliqueForest</code> object (see <a href="#topic+orsf">orsf</a>).
<code>orsf_vi_negate()</code>, <code>orsf_vi_permute()</code>, and <code>orsf_vi_anova()</code> are wrappers
for <code>orsf_vi()</code>. The way these functions work depends on whether the
<code>object</code> they are given already has variable importance estimates in it
or not (see examples).
</p>


<h3>Value</h3>

<p><code>orsf_vi</code> functions return a named numeric vector.
</p>

<ul>
<li><p> Names of the vector are the predictor variables used by <code>object</code>
</p>
</li>
<li><p> Values of the vector are the estimated importance of the given predictor.
</p>
</li></ul>

<p>The returned vector is sorted from highest to lowest value, with higher
values indicating higher importance.
</p>


<h3>Variable importance methods</h3>

<p><strong>negation importance</strong>: Each variable is assessed separately by multiplying the variable's coefficients by -1 and then determining how much the model's performance changes. The worse the model's performance after negating coefficients for a given variable, the more important the variable. This technique is promising b/c it does not require permutation and it emphasizes variables with larger coefficients in linear combinations, but it is also relatively new and hasn't been studied as much as permutation importance. See Jaeger, (2023) for more details on this technique.
</p>
<p><strong>permutation importance</strong>: Each variable is assessed separately by randomly permuting the variable's values and then determining how much the model's performance changes. The worse the model's performance after permuting the values of a given variable, the more important the variable. This technique is flexible, intuitive, and frequently used. It also has several <a href="https://christophm.github.io/interpretable-ml-book/feature-importance.html#disadvantages-9">known limitations</a>
</p>
<p><strong>analysis of variance (ANOVA) importance</strong>: A p-value is computed for each coefficient in each linear combination of variables in each decision tree. Importance for an individual predictor variable is the proportion of times a p-value for its coefficient is &lt; 0.01. This technique is very efficient computationally, but may not be as effective as permutation or negation in terms of selecting signal over noise variables. See <a href="https://link.springer.com/chapter/10.1007/978-3-642-23783-6_29">Menze, 2011</a> for more details on this technique.
</p>


<h3>Examples</h3>



<h4>ANOVA importance</h4>

<p>The default variable importance technique, ANOVA, is calculated while
you fit an oblique random forest ensemble.
</p>
<div class="sourceCode r"><pre>fit &lt;- orsf(pbc_orsf, Surv(time, status) ~ . - id)

fit
</pre></div>
<div class="sourceCode"><pre>## ---------- Oblique random survival forest
## 
##      Linear combinations: Accelerated Cox regression
##           N observations: 276
##                 N events: 111
##                  N trees: 500
##       N predictors total: 17
##    N predictors per node: 5
##  Average leaves per tree: 21.022
## Min observations in leaf: 5
##       Min events in leaf: 1
##           OOB stat value: 0.84
##            OOB stat type: Harrell's C-index
##      Variable importance: anova
## 
## -----------------------------------------
</pre></div>
<p>ANOVA is the default because it is fast, but it may not be as decisive
as the permutation and negation techniques for variable selection.
</p>



<h4>Raw VI values</h4>

<p>the ‘raw’ variable importance values can be accessed from the fit object
</p>
<div class="sourceCode r"><pre>fit$get_importance_raw()
</pre></div>
<div class="sourceCode"><pre>##                   [,1]
## trt_placebo 0.06355042
## age         0.23259259
## sex_f       0.14700432
## ascites_1   0.46791708
## hepato_1    0.14349776
## spiders_1   0.17371938
## edema_0.5   0.17459191
## edema_1     0.51197605
## bili        0.40590758
## chol        0.17666667
## albumin     0.25972156
## copper      0.28840580
## alk.phos    0.10614251
## ast         0.18327491
## trig        0.12815626
## platelet    0.09265648
## protime     0.22656250
## stage       0.20264766
</pre></div>
<p>these are ‘raw’ because values for factors have not been aggregated into
a single value. Currently there is one value for k-1 levels of a k level
factor. For example, you can see edema_1 and edema_0.5 in the importance
values above because edema is a factor variable with levels of 0, 0.5,
and 1.
</p>



<h4>Collapse VI across factor levels</h4>

<p>To get aggregated values across all levels of each factor,
</p>

<ul>
<li><p> access the <code>importance</code> element from the <code>orsf</code> fit:
</p>
<div class="sourceCode r"><pre># this assumes you used group_factors = TRUE in orsf()
fit$importance
</pre></div>
<div class="sourceCode"><pre>##    ascites       bili      edema     copper    albumin        age    protime 
## 0.46791708 0.40590758 0.31115216 0.28840580 0.25972156 0.23259259 0.22656250 
##      stage        ast       chol    spiders        sex     hepato       trig 
## 0.20264766 0.18327491 0.17666667 0.17371938 0.14700432 0.14349776 0.12815626 
##   alk.phos   platelet        trt 
## 0.10614251 0.09265648 0.06355042
</pre></div>
</li>
<li><p> use <code>orsf_vi()</code> with group_factors set to <code>TRUE</code> (the default)
</p>
<div class="sourceCode r"><pre>orsf_vi(fit)
</pre></div>
<div class="sourceCode"><pre>##    ascites       bili      edema     copper    albumin        age    protime 
## 0.46791708 0.40590758 0.31115216 0.28840580 0.25972156 0.23259259 0.22656250 
##      stage        ast       chol    spiders        sex     hepato       trig 
## 0.20264766 0.18327491 0.17666667 0.17371938 0.14700432 0.14349776 0.12815626 
##   alk.phos   platelet        trt 
## 0.10614251 0.09265648 0.06355042
</pre></div>
</li></ul>

<p>Note that you can make the default returned importance values ungrouped
by setting <code>group_factors</code> to <code>FALSE</code> in the <code>orsf_vi</code> functions or the
<code>orsf</code> function.
</p>



<h4>Add VI to an oblique random forest</h4>

<p>You can fit an oblique random forest without VI, then add VI later
</p>
<div class="sourceCode r"><pre>fit_no_vi &lt;- orsf(pbc_orsf,
                  Surv(time, status) ~ . - id,
                  importance = 'none')

# Note: you can't call orsf_vi_anova() on fit_no_vi because anova
# VI can only be computed while the forest is being grown.

orsf_vi_negate(fit_no_vi)
</pre></div>
<div class="sourceCode"><pre>##        bili      copper         sex     protime         age       stage 
## 0.130439814 0.051880867 0.038308025 0.025115249 0.023826061 0.020354822 
##     albumin     ascites        chol         ast     spiders      hepato 
## 0.019997729 0.015918292 0.013320469 0.010086726 0.007409116 0.007326714 
##       edema         trt    alk.phos        trig    platelet 
## 0.006844435 0.003214544 0.002517057 0.002469545 0.001056829
</pre></div>
<div class="sourceCode r"><pre>orsf_vi_permute(fit_no_vi)
</pre></div>
<div class="sourceCode"><pre>##          bili        copper           age       ascites       protime 
##  0.0592069141  0.0237362075  0.0136479213  0.0130805894  0.0123091354 
##         stage       albumin          chol        hepato           ast 
##  0.0117177661  0.0106414724  0.0064501213  0.0058813969  0.0057753740 
##         edema       spiders           sex          trig      platelet 
##  0.0052171180  0.0048427005  0.0023386947  0.0017883700  0.0013533691 
##      alk.phos           trt 
##  0.0006492029 -0.0009921507
</pre></div>



<h4>Oblique random forest and VI all at once</h4>

<p>fit an oblique random forest and compute vi at the same time
</p>
<div class="sourceCode r"><pre>fit_permute_vi &lt;- orsf(pbc_orsf,
                       Surv(time, status) ~ . - id,
                       importance = 'permute')

# get the vi instantly (i.e., it doesn't need to be computed again)
orsf_vi_permute(fit_permute_vi)
</pre></div>
<div class="sourceCode"><pre>##          bili        copper       ascites       protime       albumin 
##  0.0571305446  0.0243657146  0.0138318057  0.0133401675  0.0130746154 
##           age         stage          chol           ast       spiders 
##  0.0123610374  0.0102963203  0.0077895394  0.0075250059  0.0048628813 
##         edema        hepato           sex      platelet          trig 
##  0.0046003168  0.0039818730  0.0016891584  0.0012767063  0.0007324402 
##      alk.phos           trt 
##  0.0005128897 -0.0014443967
</pre></div>
<p>You can still get negation VI from this fit, but it needs to be computed
</p>
<div class="sourceCode r"><pre>orsf_vi_negate(fit_permute_vi)
</pre></div>
<div class="sourceCode"><pre>##        bili      copper         sex     protime       stage         age 
## 0.123331760 0.052544318 0.037291358 0.024977898 0.023239189 0.021934511 
##     albumin     ascites        chol         ast     spiders       edema 
## 0.020586632 0.014229536 0.014053040 0.012227048 0.007643156 0.006832766 
##      hepato         trt    alk.phos        trig    platelet 
## 0.006301693 0.004348705 0.002371797 0.002309396 0.001347035
</pre></div>



<h4>Custom functions for VI</h4>

<p>The default prediction accuracy functions work well most of the time:
</p>
<div class="sourceCode r"><pre>fit_standard &lt;- orsf(penguins_orsf, bill_length_mm ~ ., tree_seeds = 1)

# Default method for prediction accuracy with VI is R-squared
orsf_vi_permute(fit_standard)
</pre></div>
<div class="sourceCode"><pre>##           species flipper_length_mm       body_mass_g     bill_depth_mm 
##      0.3725898166      0.3261834607      0.2225730676      0.1026569498 
##            island               sex              year 
##      0.0876071687      0.0844807334      0.0006978493
</pre></div>
<p>But sometimes you want to do something specific and the defaults just
won’t work. For these cases, you can compute VI with any function you’d
like to measure prediction accuracy by supplying a valid function to the
<code>oobag_fun</code> input. For example, we use mean absolute error below. Higher
values are considered good when <code>aorsf</code> computes prediction accuracy, so
we make our function return a pseudo R-squared based on mean absolute
error:
</p>
<div class="sourceCode r"><pre>rsq_mae &lt;- function(y_mat, w_vec, s_vec){
 
 mae_standard &lt;- mean(abs((y_mat - mean(y_mat)) * w_vec))
 mae_fit &lt;- mean(abs((y_mat - s_vec) * w_vec))
 
 1 - mae_fit / mae_standard
 
}

fit_custom &lt;- orsf_update(fit_standard, oobag_fun = rsq_mae)

# not much changes, but the difference between variables shrinks
# and the ordering of sex and island has swapped
orsf_vi_permute(fit_custom)
</pre></div>
<div class="sourceCode"><pre>##           species flipper_length_mm       body_mass_g     bill_depth_mm 
##       0.206951751       0.193248912       0.140899603       0.076759148 
##               sex            island              year 
##       0.073042331       0.050851073       0.003633365
</pre></div>



<h3>References</h3>


<ol>
<li><p> Harrell, E F, Califf, M R, Pryor, B D, Lee, L K, Rosati, A R (1982).
&quot;Evaluating the yield of medical tests.&quot; <em>Jama</em>, <em>247</em>(18), 2543-2546.
</p>
</li>
<li><p> Breiman, Leo (2001). &quot;Random Forests.&quot; <em>Machine Learning</em>, <em>45</em>(1),
5-32. ISSN 1573-0565.
</p>
</li>
<li><p> Menze, H B, Kelm, Michael B, Splitthoff, N D, Koethe, Ullrich,
Hamprecht, A F (2011). &quot;On oblique random forests.&quot; In <em>Machine
Learning and Knowledge Discovery in Databases: European Conference,
ECML PKDD 2011, Athens, Greece, September 5-9, 2011, Proceedings, Part
II 22</em>, 453-469. Springer.
</p>
</li>
<li><p> Jaeger BC, Welden S, Lenoir K, Speiser JL, Segar MW, Pandey A, Pajewski
NM (2023). &quot;Accelerated and interpretable oblique random survival
forests.&quot; <em>Journal of Computational and Graphical Statistics</em>, 1-16.
</p>
</li></ol>


<hr>
<h2 id='orsf_vint'>Variable Interactions</h2><span id='topic+orsf_vint'></span>

<h3>Description</h3>

<p>Use the variable interaction score described in Greenwell et al (2018).
As this method can be computationally demanding, using <code>n_thread=0</code>
can substantially reduce time needed to compute scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_vint(
  object,
  predictors = NULL,
  n_thread = NULL,
  verbose_progress = NULL,
  sep = ".."
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_vint_+3A_object">object</code></td>
<td>
<p>(<em>ObliqueForest</em>) a trained oblique random forest object (see <a href="#topic+orsf">orsf</a>)</p>
</td></tr>
<tr><td><code id="orsf_vint_+3A_predictors">predictors</code></td>
<td>
<p>(<em>character</em>) a vector of length 2 or more with names
of predictors used by <code>object</code>. All pairwise interactions between
the predictors will be scored. If <code>NULL</code> (the default), all predictors
are used.</p>
</td></tr>
<tr><td><code id="orsf_vint_+3A_n_thread">n_thread</code></td>
<td>
<p>(<em>integer</em>) number of threads to use while growing trees, computing predictions, and computing importance. Default is 0, which allows a suitable number of threads to be used based on availability.</p>
</td></tr>
<tr><td><code id="orsf_vint_+3A_verbose_progress">verbose_progress</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, progress messages are
printed in the console. If <code>FALSE</code> (the default), nothing is printed.</p>
</td></tr>
<tr><td><code id="orsf_vint_+3A_sep">sep</code></td>
<td>
<p>(<em>character</em>) how to separate the names of two predictors.
The default value of <code>".."</code> returns names as <code>name1..name2</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of possible interactions grows exponentially based on the
number of predictors. Some caution is warranted when using large predictor
sets and it is recommended that you supply a specific vector of predictor
names to assess rather than a global search. A good strategy is to use
<code>n_tree = 5</code> to search all predictors, then pick the top 10 interactions,
get the unique predictors from them, and re-run on just those predictors
with more trees.
</p>


<h3>Value</h3>

<p>a data.table with variable interaction scores and
partial dependence values.
</p>


<h3>References</h3>


<ol>
<li><p> Greenwell, M B, Boehmke, C B, McCarthy, J A (2018). &quot;A simple and
effective model-based variable importance measure.&quot; <em>arXiv preprint
arXiv:1805.04755</em>.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(329)

data &lt;- data.frame(
 x1 = rnorm(500),
 x2 = rnorm(500),
 x3 = rnorm(500)
)

data$y = with(data, expr = x1 + x2 + x3 + 1/2*x1 * x2 + x2 * x3 + rnorm(500))

forest &lt;- orsf(data, y ~ ., n_tree = 5)

orsf_vint(forest)
</code></pre>

<hr>
<h2 id='orsf_vs'>Variable selection</h2><span id='topic+orsf_vs'></span>

<h3>Description</h3>

<p>Variable selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orsf_vs(object, n_predictor_min = 3, verbose_progress = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orsf_vs_+3A_object">object</code></td>
<td>
<p>(<em>ObliqueForest</em>) a trained oblique random forest object (see <a href="#topic+orsf">orsf</a>).</p>
</td></tr>
<tr><td><code id="orsf_vs_+3A_n_predictor_min">n_predictor_min</code></td>
<td>
<p>(<em>integer</em>) the minimum number of predictors allowed</p>
</td></tr>
<tr><td><code id="orsf_vs_+3A_verbose_progress">verbose_progress</code></td>
<td>
<p>(<em>logical</em>) not implemented yet. Should progress be printed to the console?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The difference between <code>variables_included</code> and <code>predictors_included</code> is
referent coding. The <code>variable</code> would be the name of a factor variable
in the training data, while the <code>predictor</code> would be the name of that
same factor with the levels of the factor appended. For example, if
the variable is <code>diabetes</code> with <code>levels = c("no", "yes")</code>, then the
variable name is <code>diabetes</code> and the predictor name is <code>diabetes_yes</code>.
</p>
<p><code>tree_seeds</code> should be specified in <code>object</code> so that each successive run
of <code>orsf</code> will be evaluated in the same out-of-bag samples as the initial
run.
</p>


<h3>Value</h3>

<p>a <a href="data.table.html#topic+data.table">data.table</a> with four columns:
</p>

<ul>
<li> <p><em>n_predictors</em>: the number of predictors used
</p>
</li>
<li> <p><em>stat_value</em>: the out-of-bag statistic
</p>
</li>
<li> <p><em>variables_included</em>: the names of the variables included
</p>
</li>
<li> <p><em>predictors_included</em>: the names of the predictors included
</p>
</li>
<li> <p><em>predictor_dropped</em>: the predictor selected to be dropped
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
object &lt;- orsf(formula = time + status ~ .,
               data = pbc_orsf,
               n_tree = 25,
               importance = 'anova')

orsf_vs(object, n_predictor_min = 15)
</code></pre>

<hr>
<h2 id='pbc_orsf'>Mayo Clinic Primary Biliary Cholangitis Data</h2><span id='topic+pbc_orsf'></span>

<h3>Description</h3>

<p>These data are a light modification of the <a href="survival.html#topic+pbc">survival::pbc</a> data. The
modifications are:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbc_orsf
</code></pre>


<h3>Format</h3>

<p>A data frame with 276 rows and 20 variables:
</p>

<dl>
<dt>id</dt><dd><p>case number</p>
</dd>
<dt>time</dt><dd><p>number of days between registration and the earlier of death, transplantion, or study analysis in July, 1986</p>
</dd>
<dt>status</dt><dd><p> status at endpoint, 0 for censored or transplant, 1 for dead</p>
</dd>
<dt>trt</dt><dd><p>randomized treatment group: D-penicillmain or placebo</p>
</dd>
<dt>age</dt><dd><p>in years</p>
</dd>
<dt>sex</dt><dd><p>m/f</p>
</dd>
<dt>ascites</dt><dd><p>presence of ascites</p>
</dd>
<dt>hepato</dt><dd><p>presence of hepatomegaly or enlarged liver</p>
</dd>
<dt>spiders</dt><dd><p>blood vessel malformations in the skin</p>
</dd>
<dt>edema</dt><dd><p>0 no edema, 0.5 untreated or successfully treated, 1 edema despite diuretic therapy</p>
</dd>
<dt>bili</dt><dd><p>serum bilirubin (mg/dl)</p>
</dd>
<dt>chol</dt><dd><p>serum cholesterol (mg/dl)</p>
</dd>
<dt>albumin</dt><dd><p>serum albumin (g/dl)</p>
</dd>
<dt>copper</dt><dd><p>urine copper (ug/day)</p>
</dd>
<dt>alk.phos</dt><dd><p>alkaline phosphotase (U/liter)</p>
</dd>
<dt>ast</dt><dd><p>aspartate aminotransferase, once called SGOT (U/ml)</p>
</dd>
<dt>trig</dt><dd><p>triglycerides (mg/dl)</p>
</dd>
<dt>platelet</dt><dd><p>platelet count</p>
</dd>
<dt>protime</dt><dd><p>standardized blood clotting time</p>
</dd>
<dt>stage</dt><dd><p>histologic stage of disease (needs biopsy)</p>
</dd>
</dl>



<h3>Details</h3>


<ol>
<li><p> removed rows with missing data
</p>
</li>
<li><p> converted <code>status</code> into 0 for censor or transplant, 1 for dead
</p>
</li>
<li><p> converted <code>stage</code> into an ordered factor.
</p>
</li>
<li><p> converted <code>trt</code>, <code>ascites</code>, <code>hepato</code>, <code>spiders</code>, and <code>edema</code> into factors.
</p>
</li></ol>



<h3>Source</h3>

<p>T Therneau and P Grambsch (2000), Modeling Survival Data: Extending the Cox Model, Springer-Verlag, New York. ISBN: 0-387-98784-3.
</p>

<hr>
<h2 id='penguins_orsf'>Size measurements for adult foraging penguins near Palmer Station, Antarctica</h2><span id='topic+penguins_orsf'></span>

<h3>Description</h3>

<p>These data are copied and lightly modified from the <code>penguins</code> data in
the <a href="https://allisonhorst.github.io/palmerpenguins/">palmerpenguins</a> R
package. The only modification is removal of rows
with missing data. The data include measurements for penguin species,
island in Palmer Archipelago, size (flipper length, body mass, bill
dimensions), and sex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penguins_orsf
</code></pre>


<h3>Format</h3>

<p>A tibble with 333 rows and 8 variables:
</p>

<dl>
<dt>species</dt><dd><p>a factor denoting penguin species (Adélie, Chinstrap and Gentoo)</p>
</dd>
<dt>island</dt><dd><p>a factor denoting island in Palmer Archipelago, Antarctica (Biscoe, Dream or Torgersen)</p>
</dd>
<dt>bill_length_mm</dt><dd><p>a number denoting bill length (millimeters)</p>
</dd>
<dt>bill_depth_mm</dt><dd><p>a number denoting bill depth (millimeters)</p>
</dd>
<dt>flipper_length_mm</dt><dd><p>an integer denoting flipper length (millimeters)</p>
</dd>
<dt>body_mass_g</dt><dd><p>an integer denoting body mass (grams)</p>
</dd>
<dt>sex</dt><dd><p>a factor denoting penguin sex (female, male)</p>
</dd>
<dt>year</dt><dd><p>an integer denoting the study year (2007, 2008, or 2009)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Adélie penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural size measurements and isotopic signatures of foraging among adult male and female Adélie penguins (Pygoscelis adeliae) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental Data Initiative. <a href="https://doi.org/10.6073/pasta/98b16d7d563f265cb52372c8ca99e60f">doi:10.6073/pasta/98b16d7d563f265cb52372c8ca99e60f</a>
</p>
<p>Gentoo penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural size measurements and isotopic signatures of foraging among adult male and female Gentoo penguin (Pygoscelis papua) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental Data Initiative. <a href="https://doi.org/10.6073/pasta/7fca67fb28d56ee2ffa3d9370ebda689">doi:10.6073/pasta/7fca67fb28d56ee2ffa3d9370ebda689</a>
</p>
<p>Chinstrap penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural size measurements and isotopic signatures of foraging among adult male and female Chinstrap penguin (Pygoscelis antarcticus) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 6. Environmental Data Initiative. <a href="https://doi.org/10.6073/pasta/c14dfcfada8ea13a17536e73eb6fbe9e">doi:10.6073/pasta/c14dfcfada8ea13a17536e73eb6fbe9e</a>
</p>
<p>Originally published in: Gorman KB, Williams TD, Fraser WR (2014) Ecological Sexual Dimorphism and Environmental Variability within a Community of Antarctic Penguins (Genus Pygoscelis). PLoS ONE 9(3): e90081. doi:10.1371/journal.pone.0090081
</p>

<hr>
<h2 id='pred_spec_auto'>Automatic variable values for dependence</h2><span id='topic+pred_spec_auto'></span>

<h3>Description</h3>

<p>For partial dependence and individual conditional expectations,
this function allows a variable to be considered without having
to specify what values to set the variable at. The values used
are based on quantiles for continuous variables (10th, 25th, 50th,
75th, and 90th) and unique categories for categorical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred_spec_auto(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pred_spec_auto_+3A_...">...</code></td>
<td>
<p>names of the variables to use. These can be in quotes
or not in quotes (see examples).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should only be used in the context of
<code>orsf_pd</code> or <code>orsf_ice</code> functions.
</p>


<h3>Value</h3>

<p>a character vector with the names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- orsf(penguins_orsf, species ~., n_tree = 5)

orsf_pd_oob(fit, pred_spec_auto(flipper_length_mm))

</code></pre>

<hr>
<h2 id='predict.ObliqueForest'>Prediction for ObliqueForest Objects</h2><span id='topic+predict.ObliqueForest'></span>

<h3>Description</h3>

<p>Compute predicted values from an oblique random forest. Predictions
may be returned in aggregate (i.e., averaging over all the trees)
or tree-specific.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ObliqueForest'
predict(
  object,
  new_data = NULL,
  pred_type = NULL,
  pred_horizon = NULL,
  pred_aggregate = TRUE,
  pred_simplify = FALSE,
  oobag = FALSE,
  na_action = NULL,
  boundary_checks = TRUE,
  n_thread = NULL,
  verbose_progress = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ObliqueForest_+3A_object">object</code></td>
<td>
<p>(<em>ObliqueForest</em>) a trained oblique random forest object (see <a href="#topic+orsf">orsf</a>).</p>
</td></tr>
<tr><td><code id="predict.ObliqueForest_+3A_new_data">new_data</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a>, <a href="tibble.html#topic+tibble-package">tibble</a>, or <a href="data.table.html#topic+data.table">data.table</a> to compute predictions in.</p>
</td></tr>
<tr><td><code id="predict.ObliqueForest_+3A_pred_type">pred_type</code></td>
<td>
<p>(<em>character</em>) the type of predictions to compute. Valid
options for survival are:
</p>

<ul>
<li><p> 'risk' : probability of having an event at or before <code>pred_horizon</code>.
</p>
</li>
<li><p> 'surv' : 1 - risk.
</p>
</li>
<li><p> 'chf': cumulative hazard function
</p>
</li>
<li><p> 'mort': mortality prediction
</p>
</li>
<li><p> 'time': survival time prediction
</p>
</li></ul>

<p>For classification:
</p>

<ul>
<li><p> 'prob': probability for each class
</p>
</li>
<li><p> 'class': predicted class
</p>
</li></ul>

<p>For regression:
</p>

<ul>
<li><p> 'mean': predicted mean, i.e., the expected value
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.ObliqueForest_+3A_pred_horizon">pred_horizon</code></td>
<td>
<p>(<em>double</em>) Only relevent for survival forests.
A value or vector indicating the time(s) that predictions will be
calibrated to. E.g., if you were predicting risk of incident heart
failure within the next 10 years, then <code>pred_horizon = 10</code>.
<code>pred_horizon</code> can be <code>NULL</code> if <code>pred_type</code> is <code>'mort'</code>, since
mortality predictions are aggregated over all event times</p>
</td></tr>
<tr><td><code id="predict.ObliqueForest_+3A_pred_aggregate">pred_aggregate</code></td>
<td>
<p>(<em>logical</em>) If <code>TRUE</code> (the default), predictions
will be aggregated over all trees by taking the mean. If <code>FALSE</code>, the
returned output will contain one row per observation and one column
for each tree. If the length of <code>pred_horizon</code> is two or more and
<code>pred_aggregate</code> is <code>FALSE</code>, then the result will be a list of such
matrices, with the i'th item in the list corresponding to the i'th
value of <code>pred_horizon</code>.</p>
</td></tr>
<tr><td><code id="predict.ObliqueForest_+3A_pred_simplify">pred_simplify</code></td>
<td>
<p>(<em>logical</em>) If <code>FALSE</code> (the default), predictions
will always be returned in a numeric matrix or a list of numeric matrices.
If <code>TRUE</code>, predictions may be simplified to a vector, e.g., if <code>pred_type</code>
is <code>'mort'</code> for survival or <code>'class'</code> for classification, or an array of
matrices if <code>length(pred_horizon) &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="predict.ObliqueForest_+3A_oobag">oobag</code></td>
<td>
<p>(<em>logical</em>) If <code>FALSE</code> (the default), predictions will
be computed using all trees for each observation. If <code>TRUE</code>, then
out-of-bag predictions will be computed. This input parameter should
only be set to <code>TRUE</code> if <code>new_data</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.ObliqueForest_+3A_na_action">na_action</code></td>
<td>
<p>(<em>character</em>) what should happen when <code>new_data</code> contains missing values (i.e., <code>NA</code> values). Valid options are:
</p>

<ul>
<li><p> 'fail' : an error is thrown if <code>new_data</code> contains <code>NA</code> values
</p>
</li>
<li><p> 'pass' : the output will have <code>NA</code> in all rows where <code>new_data</code> has 1 or more <code>NA</code> value for the predictors used by <code>object</code>
</p>
</li>
<li><p> 'omit' : rows in <code>new_data</code> with incomplete data will be dropped
</p>
</li>
<li><p> 'impute_meanmode' : missing values for continuous and categorical variables in <code>new_data</code> will be imputed using the mean and mode, respectively. To clarify,
the mean and mode used to impute missing values are from the
training data of <code>object</code>, not from <code>new_data</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.ObliqueForest_+3A_boundary_checks">boundary_checks</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, <code>pred_horizon</code> will be
checked to make sure the requested values are less than the maximum
observed time in <code>object</code>'s training data. If <code>FALSE</code>, these checks
are skipped.</p>
</td></tr>
<tr><td><code id="predict.ObliqueForest_+3A_n_thread">n_thread</code></td>
<td>
<p>(<em>integer</em>) number of threads to use while computing predictions. Default is 0, which allows a suitable number of threads to be used based on availability.</p>
</td></tr>
<tr><td><code id="predict.ObliqueForest_+3A_verbose_progress">verbose_progress</code></td>
<td>
<p>(<em>logical</em>) if <code>TRUE</code>, progress messages are
printed in the console. If <code>FALSE</code> (the default), nothing is printed.</p>
</td></tr>
<tr><td><code id="predict.ObliqueForest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>new_data</code> must have the same columns with equivalent types as the data
used to train <code>object</code>. Also, factors in <code>new_data</code> must not have levels
that were not in the data used to train <code>object</code>.
</p>
<p><code>pred_horizon</code> values should not exceed the maximum follow-up time in
<code>object</code>'s training data, but if you truly want to do this, set
<code>boundary_checks = FALSE</code> and you can use a <code>pred_horizon</code> as large
as you want. Note that predictions beyond the maximum follow-up time
in the <code>object</code>'s training data are equal to predictions at the
maximum follow-up time, because <code>aorsf</code> does not estimate survival
beyond its maximum observed time.
</p>
<p>If unspecified, <code>pred_horizon</code> may be automatically specified as the value
used for <code>oobag_pred_horizon</code> when <code>object</code> was created (see <a href="#topic+orsf">orsf</a>).
</p>


<h3>Value</h3>

<p>a <code>matrix</code> of predictions. Column <code>j</code> of the matrix corresponds
to value <code>j</code> in <code>pred_horizon</code>. Row <code>i</code> of the matrix corresponds to
row <code>i</code> in <code>new_data</code>.
</p>


<h3>Examples</h3>

<div class="sourceCode r"><pre>library(aorsf)
</pre></div>


<h4>Classification</h4>

<div class="sourceCode r"><pre>set.seed(329)

index_train &lt;- sample(nrow(penguins_orsf), 150) 

penguins_orsf_train &lt;- penguins_orsf[index_train, ]
penguins_orsf_test &lt;- penguins_orsf[-index_train, ]

fit_clsf &lt;- orsf(data = penguins_orsf_train, 
                 formula = species ~ .)
</pre></div>
<p>Predict probability for each class or the predicted class:
</p>
<div class="sourceCode r"><pre># predicted probabilities, the default
predict(fit_clsf, 
        new_data = penguins_orsf_test[1:5, ],
        pred_type = 'prob')
</pre></div>
<div class="sourceCode"><pre>##         Adelie  Chinstrap      Gentoo
## [1,] 0.9405310 0.04121955 0.018249405
## [2,] 0.9628988 0.03455909 0.002542096
## [3,] 0.9032074 0.08510528 0.011687309
## [4,] 0.9300133 0.05209040 0.017896329
## [5,] 0.7965703 0.16243492 0.040994821
</pre></div>
<div class="sourceCode r"><pre># predicted class (as a matrix by default)
predict(fit_clsf, 
        new_data = penguins_orsf_test[1:5, ],
        pred_type = 'class')
</pre></div>
<div class="sourceCode"><pre>##      [,1]
## [1,]    1
## [2,]    1
## [3,]    1
## [4,]    1
## [5,]    1
</pre></div>
<div class="sourceCode r"><pre># predicted class (as a factor if you use simplify)
predict(fit_clsf, 
        new_data = penguins_orsf_test[1:5, ],
        pred_type = 'class',
        pred_simplify = TRUE)
</pre></div>
<div class="sourceCode"><pre>## [1] Adelie Adelie Adelie Adelie Adelie
## Levels: Adelie Chinstrap Gentoo
</pre></div>



<h4>Regression</h4>

<div class="sourceCode r"><pre>set.seed(329)

index_train &lt;- sample(nrow(penguins_orsf), 150) 

penguins_orsf_train &lt;- penguins_orsf[index_train, ]
penguins_orsf_test &lt;- penguins_orsf[-index_train, ]

fit_regr &lt;- orsf(data = penguins_orsf_train, 
                 formula = bill_length_mm ~ .)
</pre></div>
<p>Predict the mean value of the outcome:
</p>
<div class="sourceCode r"><pre>predict(fit_regr, 
        new_data = penguins_orsf_test[1:5, ], 
        pred_type = 'mean')
</pre></div>
<div class="sourceCode"><pre>##          [,1]
## [1,] 37.74136
## [2,] 37.42367
## [3,] 37.04598
## [4,] 39.89602
## [5,] 39.14848
</pre></div>



<h4>Survival</h4>

<p>Begin by fitting an oblique survival random forest:
</p>
<div class="sourceCode r"><pre>set.seed(329)

index_train &lt;- sample(nrow(pbc_orsf), 150) 

pbc_orsf_train &lt;- pbc_orsf[index_train, ]
pbc_orsf_test &lt;- pbc_orsf[-index_train, ]

fit_surv &lt;- orsf(data = pbc_orsf_train, 
                 formula = Surv(time, status) ~ . - id,
                 oobag_pred_horizon = 365.25 * 5)
</pre></div>
<p>Predict risk, survival, or cumulative hazard at one or several times:
</p>
<div class="sourceCode r"><pre># predicted risk, the default
predict(fit_surv, 
        new_data = pbc_orsf_test[1:5, ], 
        pred_type = 'risk', 
        pred_horizon = c(500, 1000, 1500))
</pre></div>
<div class="sourceCode"><pre>##             [,1]        [,2]       [,3]
## [1,] 0.013648562 0.058393393 0.11184029
## [2,] 0.003811413 0.026857586 0.04774151
## [3,] 0.030548361 0.100600301 0.14847107
## [4,] 0.040381075 0.169596943 0.27018952
## [5,] 0.001484698 0.006663576 0.01337655
</pre></div>
<div class="sourceCode r"><pre># predicted survival, i.e., 1 - risk
predict(fit_surv, 
        new_data = pbc_orsf_test[1:5, ], 
        pred_type = 'surv',
        pred_horizon = c(500, 1000, 1500))
</pre></div>
<div class="sourceCode"><pre>##           [,1]      [,2]      [,3]
## [1,] 0.9863514 0.9416066 0.8881597
## [2,] 0.9961886 0.9731424 0.9522585
## [3,] 0.9694516 0.8993997 0.8515289
## [4,] 0.9596189 0.8304031 0.7298105
## [5,] 0.9985153 0.9933364 0.9866235
</pre></div>
<div class="sourceCode r"><pre># predicted cumulative hazard function
# (expected number of events for person i at time j)
predict(fit_surv, 
        new_data = pbc_orsf_test[1:5, ], 
        pred_type = 'chf',
        pred_horizon = c(500, 1000, 1500))
</pre></div>
<div class="sourceCode"><pre>##             [,1]        [,2]       [,3]
## [1,] 0.015395388 0.067815817 0.14942956
## [2,] 0.004022524 0.028740305 0.05424314
## [3,] 0.034832754 0.127687156 0.20899732
## [4,] 0.059978334 0.233048809 0.42562310
## [5,] 0.001651365 0.007173177 0.01393016
</pre></div>
<p>Predict mortality, defined as the number of events in the forest’s
population if all observations had characteristics like the current
observation. This type of prediction does not require you to specify a
prediction horizon
</p>
<div class="sourceCode r"><pre>predict(fit_surv, 
        new_data = pbc_orsf_test[1:5, ], 
        pred_type = 'mort')
</pre></div>
<div class="sourceCode"><pre>##           [,1]
## [1,] 23.405016
## [2,] 15.362916
## [3,] 26.180648
## [4,] 36.515629
## [5,]  5.856674
</pre></div>


<hr>
<h2 id='print.ObliqueForest'>Inspect Forest Parameters</h2><span id='topic+print.ObliqueForest'></span>

<h3>Description</h3>

<p>Printing an ORSF model tells you:
</p>

<ul>
<li><p> Linear combinations: How were these identified?
</p>
</li>
<li><p> N observations: Number of rows in training data
</p>
</li>
<li><p> N events: Number of events in training data
</p>
</li>
<li><p> N trees: Number of trees in the forest
</p>
</li>
<li><p> N predictors total: Total number of columns in the predictor matrix
</p>
</li>
<li><p> N predictors per node: Number of variables used in linear combinations
</p>
</li>
<li><p> Average leaves per tree: A proxy for the depth of your trees
</p>
</li>
<li><p> Min observations in leaf: See <code>leaf_min_obs</code> in <a href="#topic+orsf">orsf</a>
</p>
</li>
<li><p> Min events in leaf: See <code>leaf_min_events</code> in <a href="#topic+orsf">orsf</a>
</p>
</li>
<li><p> OOB stat value: Out-of-bag error after fitting all trees
</p>
</li>
<li><p> OOB stat type: How was out-of-bag error computed?
</p>
</li>
<li><p> Variable importance: How was variable importance computed?
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ObliqueForest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ObliqueForest_+3A_x">x</code></td>
<td>
<p>(<em>ObliqueForest</em>) an oblique random survival forest (ORSF; see <a href="#topic+orsf">orsf</a>).</p>
</td></tr>
<tr><td><code id="print.ObliqueForest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
object &lt;- orsf(pbc_orsf, Surv(time, status) ~ . - id, n_tree = 5)

print(object)

</code></pre>

<hr>
<h2 id='print.orsf_summary_uni'>Print ORSF summary</h2><span id='topic+print.orsf_summary_uni'></span>

<h3>Description</h3>

<p>Print ORSF summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orsf_summary_uni'
print(x, n_variables = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.orsf_summary_uni_+3A_x">x</code></td>
<td>
<p>an object of class 'orsf_summary'</p>
</td></tr>
<tr><td><code id="print.orsf_summary_uni_+3A_n_variables">n_variables</code></td>
<td>
<p>The number of variables to print</p>
</td></tr>
<tr><td><code id="print.orsf_summary_uni_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly, <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
object &lt;- orsf(pbc_orsf, Surv(time, status) ~ . - id, n_tree = 25)

smry &lt;- orsf_summarize_uni(object, n_variables = 2)

print(smry)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
