<!DOCTYPE html><html><head><title>Help for package ggetho</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggetho}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geom_peak'><p>Visualise peaks in a power spectrum or periodogram</p></a></li>
<li><a href='#ggetho'><p>Prepare a ggplot object to represent behavioural data</p></a></li>
<li><a href='#ggperio'><p>Prepare a ggplot object to represent periodogram data</p></a></li>
<li><a href='#ggspectro'><p>Prepare a ggplot object to represent spectrogram data</p></a></li>
<li><a href='#id_labeller'><p>A facet labeller for <code>id</code></p></a></li>
<li><a href='#stat_bar_tile_etho'><p>Display a variable of interest either as a colour intensity value or as a bar height</p></a></li>
<li><a href='#stat_ld_annotations'><p>Compute and display light/dark annotations onto a plot object</p></a></li>
<li><a href='#stat_pop_etho'><p>Compute and display a population aggregate for a variable of interest</p></a></li>
<li><a href='#time_scales'><p>Scales for durations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Visualisation of High-Throughput Behavioural (i.e. Ethomics)
Data</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-17</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Extension of 'ggplot2' providing layers, scales and preprocessing functions
    useful to represent behavioural variables that are recorded over multiple animals and days.
    This package is part of the 'rethomics' framework <a href="https://rethomics.github.io/">https://rethomics.github.io/</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.00), ggplot2, behavr</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, stringr, scales, labeling, rlang, cli</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, zeitgebr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rethomics/ggetho">https://github.com/rethomics/ggetho</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rethomics/ggetho/issues">https://github.com/rethomics/ggetho/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-24 09:31:16 UTC; quentin</td>
</tr>
<tr>
<td>Author:</td>
<td>Quentin Geissmann [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Quentin Geissmann &lt;qgeissmann@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-24 09:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='geom_peak'>Visualise peaks in a power spectrum or periodogram</h2><span id='topic+geom_peak'></span>

<h3>Description</h3>

<p>This function draws points on the x-y coordinates of selected peaks and write their (y) value on the bottom of the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_peak(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE,
  peak_rank = 1,
  conversion = hours
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_peak_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_peak_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_peak_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_peak_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_peak_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_peak_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_peak_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_peak_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_peak_+3A_peak_rank">peak_rank</code></td>
<td>
<p>numerical vector specifying the rank(s) of peak(s) to draw</p>
</td></tr>
<tr><td><code id="geom_peak_+3A_conversion">conversion</code></td>
<td>
<p>function to convert values of <code>x</code> to a specific unit.
The default, <code>hours</code>, will write x (time) in decimal hours.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the input data, peaks are encoded as an additional column/aesthetic with values
corresponding to peak ranks (and <code>0</code> when the point is not a peak).
In other word, the mapping must provide <code>x</code>, <code>y</code> and <code>peak</code>.
Only peaks matching <code>peak_rank</code> will be drawn (see example).
</p>


<h3>Value</h3>

<p>A ggplot layer.
</p>


<h3>References</h3>


<ul>
<li><p> The relevant <a href="https://rethomics.github.io/ggetho.html#periodograms">rethomic tutorial section</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+ggperio">ggperio</a> to create a periodogram
</p>
</li>
<li> <p><a href="zeitgebr.html#topic+find_peaks">zeitgebr::find_peaks</a> to automatically add a <code>peak</code> column on periodogram data
</p>
</li></ul>

<p>Other layers: 
<code><a href="#topic+stat_bar_tile_etho">stat_bar_tile_etho</a>()</code>,
<code><a href="#topic+stat_ld_annotations">stat_ld_annotations</a>()</code>,
<code><a href="#topic+stat_pop_etho">stat_pop_etho</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We make a data frame by hand with five rows
# There are two peaks: in position 4 and 2

df &lt;- data.frame(x = hours(1:5),
                 y = c(1, 2, 0, 4, 1),
                 peak = c(0, 2, 0, 1, 0))
#  We draw the plot as a line
pl &lt;-  ggplot(df, aes(x, y, peak = peak)) +
                  geom_line() +
                  scale_x_hours()
pl
# Now we could add the peak values as an extra layer:
# The first peak
pl + geom_peak()
# The first ans second peak
pl + geom_peak(peak_rank = 1:2)
# The second only
pl + geom_peak(peak_rank = 2)

# Just like with other geoms,
# we can change colour, size, alpha, shape, ... :
pl + geom_peak(colour = "red", size = 10, alpha = .5, shape = 20)

## In the context of circadian analysis,
# Using the zeitgebr package:

require(zeitgebr)
# We make toy data
metadata &lt;- data.table(id = sprintf("toy_experiment|%02d", 1:40),
                       region_id = 1:40,
                       condition = c("A", "B"),
                       sex = c("M", "M", "F", "F"))
dt &lt;- toy_activity_data(metadata, seed = 107)
# We shift period of the group "A" by 0.01
dt[, t := ifelse(xmv(condition) == "A", t, t * 1.01)]
# We  compute a periodogram for each individual
per_dt &lt;- periodogram(moving, dt, FUN = chi_sq_periodogram)
per_dt &lt;- find_peaks(per_dt)
out &lt;- ggperio(per_dt, aes(y = power - signif_threshold, colour = condition, peak = peak)) +
                    stat_pop_etho() +
                    facet_wrap( ~ id, labeller = id_labeller)
out
out + geom_peak(colour="black")

</code></pre>

<hr>
<h2 id='ggetho'>Prepare a ggplot object to represent behavioural data</h2><span id='topic+ggetho'></span>

<h3>Description</h3>

<p>This function summarises a variable of interest (y or z axis)
in order to subsequently represent it over time (x axis)
(using layers provided either by <code>ggplot2</code> or <code>ggetho</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggetho(
  data,
  mapping,
  summary_FUN = mean,
  summary_time_window = mins(30),
  time_wrap = NULL,
  time_offset = 0,
  multiplot = NULL,
  multiplot_period = hours(24),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggetho_+3A_data">data</code></td>
<td>
<p><a href="behavr.html#topic+behavr">behavr::behavr</a> table containing the data and metadata</p>
</td></tr>
<tr><td><code id="ggetho_+3A_mapping">mapping</code></td>
<td>
<p>default list of aesthetic mappings to use for plot</p>
</td></tr>
<tr><td><code id="ggetho_+3A_summary_fun">summary_FUN</code></td>
<td>
<p>method (function) used to summarise <code>variable</code> over time (typically, the mean)</p>
</td></tr>
<tr><td><code id="ggetho_+3A_summary_time_window">summary_time_window</code></td>
<td>
<p>width (in seconds) of the time window to compute a summary on</p>
</td></tr>
<tr><td><code id="ggetho_+3A_time_wrap">time_wrap</code></td>
<td>
<p>time (in seconds) used to wrap the data (see details)</p>
</td></tr>
<tr><td><code id="ggetho_+3A_time_offset">time_offset</code></td>
<td>
<p>time offset (i.e. phase, in seconds) when using <code>time_wrap</code></p>
</td></tr>
<tr><td><code id="ggetho_+3A_multiplot">multiplot</code></td>
<td>
<p>integer, greater than two, or NULL, the default (see details)</p>
</td></tr>
<tr><td><code id="ggetho_+3A_multiplot_period">multiplot_period</code></td>
<td>
<p>the duration of the period when mutiplotting (see details)</p>
</td></tr>
<tr><td><code id="ggetho_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time_wrap</code> is typically used to express time relatively to the start of the the day.
In other words, it can help be used to pull all days together in one representative day.
In this case, <code>time_wrap = hours(24)</code>.
Instead of representing data from the start of the day, it can be done from any offset, using <code>time_offset</code>.
For instance,  <code>time_offset = hours(12)</code> puts the circadian reference (ZT0) in the middle of the plot.
</p>
<p>Multiplotting is a generalisation of double-plotting, triple-plotting...
This type or representation is useful to understand periodic behaviours.
When <code>multiplot</code> is <em>not</em> NULL, data is repeated as
many time as its value, along the x axis.
The y axis is then the period (typically the day) onset.
It is possible to set duration of the period, which is typically 24 h to arbitrary values using the
<code>multiplot_period</code> argument.
</p>


<h3>Value</h3>

<p>An initial ggplot object that can be further edited.
</p>


<h3>References</h3>


<ul>
<li><p> The relevant <a href="https://rethomics.github.io/ggetho.html#the-ggetho-function">rethomic tutorial section</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+stat_pop_etho">stat_pop_etho</a> to show population trend by aggregating individuals over time
</p>
</li>
<li> <p><a href="#topic+stat_tile_etho">stat_tile_etho</a> to show variable of interest as colour intensity
</p>
</li>
<li> <p><a href="#topic+stat_ld_annotations">stat_ld_annotations</a> to show light and dark phases on the plot
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We start by making a dataset with 4 animals
metadata &lt;- data.table(id = sprintf("toy_experiment|%02d", 1:4),
                   condition = c("A", "B"))
dt &lt;- toy_activity_data(metadata, 3)
# We build a plot object with **nothing inside** (just the axis)
# we want to show proportion of time sleeping  on the y axis:
pl &lt;- ggetho(dt, aes(y = asleep))
pl
# Sometimes, the variable of interest in not on the y axis, but on z axis (colour scale).
# When we do not provide a y axis,
# ggetho will make an ID fo each animal and display them on separate rows
## Not run: 
pl &lt;- ggetho(dt, aes(z = asleep))
pl
# this one is the same type, but it groups the animals by condition
pl &lt;- ggetho(dt, aes(z = asleep, y = condition))
pl
# sorting with paste
pl &lt;- ggetho(dt, aes(z = asleep,y = paste(condition, id)))
pl
# we want to summarise (wrap) data along a circadian day:
pl &lt;- ggetho(dt, aes(y = asleep), time_wrap = hours(24))
pl

# double-plotted actogram:
pl &lt;- ggetho(dt,
              aes(z = moving),
              multiplot = 2,
              multiplot_period = hours(24))
pl
# then use `+ stat_tile_etho()` , or `+ stat_bar_tile_etho()`

## End(Not run)
</code></pre>

<hr>
<h2 id='ggperio'>Prepare a ggplot object to represent periodogram data</h2><span id='topic+ggperio'></span>

<h3>Description</h3>

<p>This function summarises periodogram data (containing periodograms of multiple individual),
to show period on the <code>x</code> axis, and power (or equivalent) on the <code>y</code> axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggperio(data, mapping = aes(x = period, y = power), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggperio_+3A_data">data</code></td>
<td>
<p><a href="behavr.html#topic+behavr">behavr::behavr</a> table containing the data and metadata</p>
</td></tr>
<tr><td><code id="ggperio_+3A_mapping">mapping</code></td>
<td>
<p>default list of aesthetic mappings to use for plot</p>
</td></tr>
<tr><td><code id="ggperio_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An initial ggplot object that can be further edited.
</p>


<h3>References</h3>


<ul>
<li><p> The relevant <a href="https://rethomics.github.io/ggetho.html#periodograms">rethomic tutorial section</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+ggetho">ggetho</a> to plot time series
</p>
</li>
<li> <p><a href="#topic+geom_peak">geom_peak</a> to draw peaks on a periodogram
</p>
</li>
<li> <p><a href="zeitgebr.html#topic+periodogram">zeitgebr::periodogram</a> to compute periodograms in a first place
</p>
</li>
<li> <p><a href="#topic+ggspectro">ggspectro</a> to visualise spectrograms
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
require(zeitgebr)
# We make toy data
metadata &lt;- data.table(id = sprintf("toy_experiment|%02d", 1:40),
                       region_id = 1:40,
                       condition = c("A", "B"),
                       sex = c("M", "M", "F", "F"))
dt &lt;- toy_activity_data(metadata, seed = 107)
# We shift period of the group "A" by 0.01
dt[, t := ifelse(xmv(condition) == "A", t, t * 1.01)]
# We  compute a periodogram for each individual
per_dt &lt;- periodogram(moving, dt, FUN = chi_sq_periodogram)

# Then we display them as an average
out &lt;- ggperio(per_dt, aes(y = power, colour = condition))
out +  stat_pop_etho()

out &lt;- ggperio(per_dt, aes(y = power - signif_threshold, colour = condition))
out +  stat_pop_etho()
out &lt;- ggperio(per_dt, aes(y = power - signif_threshold, colour = condition))
out +  stat_pop_etho() + facet_wrap( ~ id, labeller = id_labeller)

</code></pre>

<hr>
<h2 id='ggspectro'>Prepare a ggplot object to represent spectrogram data</h2><span id='topic+ggspectro'></span>

<h3>Description</h3>

<p>This function summarises spectrogram data (containing spectrograms of multiple individual),
to show period on the <code>y</code> axis, time on the <code>x</code> axis and power on the <code>z</code> axis (<em>e.g.</em> as a colour).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggspectro(
  data,
  mapping = aes(),
  summary_FUN = mean,
  summary_time_window = mins(30),
  time_wrap = NULL,
  time_offset = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggspectro_+3A_data">data</code></td>
<td>
<p><a href="behavr.html#topic+behavr">behavr::behavr</a> table containing the data and metadata</p>
</td></tr>
<tr><td><code id="ggspectro_+3A_mapping">mapping</code></td>
<td>
<p>default list of aesthetic mappings to use for plot</p>
</td></tr>
<tr><td><code id="ggspectro_+3A_summary_fun">summary_FUN</code></td>
<td>
<p>method (function) used to summarise <code>variable</code> over time (typically, the mean)</p>
</td></tr>
<tr><td><code id="ggspectro_+3A_summary_time_window">summary_time_window</code></td>
<td>
<p>width (in seconds) of the time window to compute a summary on</p>
</td></tr>
<tr><td><code id="ggspectro_+3A_time_wrap">time_wrap</code></td>
<td>
<p>time (in seconds) used to wrap the data (see details)</p>
</td></tr>
<tr><td><code id="ggspectro_+3A_time_offset">time_offset</code></td>
<td>
<p>time offset (i.e. phase, in seconds) when using <code>time_wrap</code></p>
</td></tr>
<tr><td><code id="ggspectro_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An initial ggplot object that can be further edited.
</p>


<h3>References</h3>


<ul>
<li><p> The relevant <a href="https://rethomics.github.io/ggetho.html#spectrogram">rethomic tutorial section</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+ggperio">ggperio</a> to visualise periodograms
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(zeitgebr)
data(dams_sample)
dt &lt;- dams_sample
spect_dt &lt;- spectrogram(activity, dt)
pl &lt;- ggspectro(spect_dt,time_wrap = hours(24)) +
  stat_tile_etho() +
  scale_y_hours(log=TRUE) +
  stat_ld_annotations(ld_colours = c("grey","black"))
pl + facet_grid(period_group ~ .)
pl + facet_wrap(~ id)

</code></pre>

<hr>
<h2 id='id_labeller'>A facet labeller for <code>id</code></h2><span id='topic+id_labeller'></span>

<h3>Description</h3>

<p>This function returns a <a href="ggplot2.html#topic+labeller">ggplot2::labeller</a> that displays the <code>id</code> on several lines to improve readability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_labeller(labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_labeller_+3A_labels">labels</code></td>
<td>
<p>Data frame of labels. Usually contains only one
element, but faceting over multiple factors entails multiple
label variables.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="ggplot2.html#topic+labeller">ggplot2::labeller</a>, to make your own labellers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(behavr)
metadata &lt;- data.frame(
     id = sprintf("2017-09-01 20:00:12|toy_experiment_a_very_long_name|%02d", 1:20),
     condition = c("A", "B"))
dt &lt;- toy_activity_data(metadata, duration = hours(2))
pl &lt;- ggetho(dt, aes(y = asleep)) + stat_pop_etho()
## Without labelling
pl + facet_wrap( ~ id)

## With labeller
pl + facet_wrap( ~ id, labeller = id_labeller)

</code></pre>

<hr>
<h2 id='stat_bar_tile_etho'>Display a variable of interest either as a colour intensity value or as a bar height</h2><span id='topic+stat_bar_tile_etho'></span><span id='topic+stat_tile_etho'></span>

<h3>Description</h3>

<p>These functions show the temporal trend (time on the x axis) of a variable of interest (z axis)
as either colour intensity (<code>stat_tile_etho</code>) or using the hight of the tiles (<code>stat_bar_tile_etho</code>).
In both cases, the y axis is a discrete variable such as a treatment or the id of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_bar_tile_etho(
  mapping = NULL,
  data = NULL,
  geom = "bar_tile",
  position = "identity",
  ...,
  method = mean,
  method.args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_tile_etho(
  mapping = NULL,
  data = NULL,
  geom = "raster",
  position = "identity",
  ...,
  method = mean,
  method.args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_bar_tile_etho_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_bar_tile_etho_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_bar_tile_etho_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_bar_tile_etho_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_bar_tile_etho_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_bar_tile_etho_+3A_method">method</code></td>
<td>
<p>function used to compute the aggregate, when/if grouping several individuals on the same row.
The default is fucntion is <a href="base.html#topic+mean">mean</a>. <a href="stats.html#topic+median">median</a>, <a href="base.html#topic+min">min</a>, <a href="base.html#topic+max">max</a> are examples of alternatives.</p>
</td></tr>
<tr><td><code id="stat_bar_tile_etho_+3A_method.args">method.args</code></td>
<td>
<p>List of additional arguments passed on to the modelling
function defined by <code>method</code>.</p>
</td></tr>
<tr><td><code id="stat_bar_tile_etho_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_bar_tile_etho_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_bar_tile_etho_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot layer.
</p>

<ul>
<li><p> The relevant <a href="https://rethomics.github.io/ggetho.html#tile-plots">rethomic tutorial section</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+ggetho">ggetho</a> to generate a plot object
</p>
</li>
<li> <p><a href="#topic+stat_pop_etho">stat_pop_etho</a> to show population trend by aggregating individuals over time
</p>
</li>
<li> <p><a href="#topic+stat_ld_annotations">stat_ld_annotations</a> to show light and dark phases on the plot
</p>
</li></ul>

<p>Other layers: 
<code><a href="#topic+geom_peak">geom_peak</a>()</code>,
<code><a href="#topic+stat_ld_annotations">stat_ld_annotations</a>()</code>,
<code><a href="#topic+stat_pop_etho">stat_pop_etho</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We start by making a to dataset with 20 animals
metadata &lt;- data.frame(id = sprintf("toy_experiment | %02d", 1:20),
                   age = c(1, 5, 10, 20),
                   condition = c("A", "B"))
print(metadata)
dt &lt;- toy_activity_data(metadata, 3)
# We build a plot object
pl &lt;-  ggetho(dt, aes(z = asleep))
# A standard plot one row per animal:
pl + stat_tile_etho()
# We can also group animals per condition and calculate the average sleep
pl &lt;-  ggetho(dt, aes(z = asleep, y = condition))
pl + stat_tile_etho()

# We can sort by adding condition AND id on the y axis:
pl &lt;-  ggetho(dt, aes(z = asleep, y = interaction(id, condition)))
pl + stat_tile_etho()
# Same if we want to sort by age
pl &lt;-  ggetho(dt, aes(z = asleep, y = interaction(id, age)))
pl + stat_tile_etho()

# Instead, of the average, maybe we want to show the highest (max)
# posible value of sleep for any time point
pl + stat_tile_etho(method = max)
# We can also use stat_bar_tile as an alternative
pl + stat_bar_tile_etho()
</code></pre>

<hr>
<h2 id='stat_ld_annotations'>Compute and display light/dark annotations onto a plot object</h2><span id='topic+stat_ld_annotations'></span>

<h3>Description</h3>

<p>This function is used to show light and dark (L and D) phases as boxes on top a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_ld_annotations(
  mapping = NULL,
  data = NULL,
  position = "identity",
  ld_colours = c("white", "black"),
  ypos = "bottom",
  height = 0.03,
  period = hours(24),
  phase = 0,
  l_duration = hours(12),
  outline = "black",
  x_limits = c(NA, NA),
  ...,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_ld_annotations_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_ld_annotations_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_ld_annotations_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_ld_annotations_+3A_ld_colours">ld_colours</code></td>
<td>
<p>character vector of length two setting the
colours for light and dark phases, respectively.
The default is <code>c("white", "black")</code>.</p>
</td></tr>
<tr><td><code id="stat_ld_annotations_+3A_ypos">ypos</code></td>
<td>
<p>position and height of the annotation on the y axis.
It can be either <code>"top"</code> or <code>"bottom"</code>.
The default, <code>"bottom"</code> will put the labels below any data.</p>
</td></tr>
<tr><td><code id="stat_ld_annotations_+3A_height">height</code></td>
<td>
<p>relative height of the rectangles. The default is 3 percent (0.03).</p>
</td></tr>
<tr><td><code id="stat_ld_annotations_+3A_period">period</code>, <code id="stat_ld_annotations_+3A_phase">phase</code>, <code id="stat_ld_annotations_+3A_l_duration">l_duration</code></td>
<td>
<p>period, phase and duration of the L phase (in seconds) of the LD cycle.</p>
</td></tr>
<tr><td><code id="stat_ld_annotations_+3A_outline">outline</code></td>
<td>
<p>colour of the border of the rectangles. A value of <code>NA</code> draws no border.</p>
</td></tr>
<tr><td><code id="stat_ld_annotations_+3A_x_limits">x_limits</code></td>
<td>
<p>numerical vector of length 2 for the start and end of the annotations (in seconds).
The default, <code>c(NA, NA)</code>, uses the full range of the plotted data.</p>
</td></tr>
<tr><td><code id="stat_ld_annotations_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_ld_annotations_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_ld_annotations_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_ld_annotations_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot layer.
</p>


<h3>References</h3>


<ul>
<li><p> The relevant <a href="https://rethomics.github.io/ggetho.html#ld-annotations">rethomic tutorial section</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+ggetho">ggetho</a> to generate a plot object
</p>
</li></ul>

<p>Other layers: 
<code><a href="#topic+geom_peak">geom_peak</a>()</code>,
<code><a href="#topic+stat_bar_tile_etho">stat_bar_tile_etho</a>()</code>,
<code><a href="#topic+stat_pop_etho">stat_pop_etho</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(behavr)
# We start by making a to dataset with 4 animals
metadata &lt;- data.frame(id = sprintf("toy_experiment | %02d", 1:4),
                   condition = c("A", "B"))
dt &lt;- toy_activity_data(metadata, 3)
# We build a plot object
pl &lt;-  ggetho(dt, aes(y = asleep)) + stat_pop_etho()
pl + stat_ld_annotations()
# We can also put the annotations in the background:
pl &lt;-  ggetho(dt, aes(y = asleep)) +
                 stat_ld_annotations(outline = NA) +
                 stat_pop_etho()
pl
# Different colours (e.g. DD)
pl + stat_ld_annotations(ld_colour = c("grey", "black"))
# Shorter period
pl + stat_ld_annotations(period = hours(22), phase = hours(3))
# On a tile plot:
pl &lt;-  ggetho(dt, aes(z = asleep)) + stat_tile_etho()
pl + stat_ld_annotations()
</code></pre>

<hr>
<h2 id='stat_pop_etho'>Compute and display a population aggregate for a variable of interest</h2><span id='topic+stat_pop_etho'></span>

<h3>Description</h3>

<p>This function displays the temporal (time on the x axis) trend of variable of interest,
on the y axis as a line with confidence interval as a shaded area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_pop_etho(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  method = mean_se,
  method.args = list(),
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_pop_etho_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_pop_etho_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_pop_etho_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_pop_etho_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_pop_etho_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_pop_etho_+3A_method">method</code></td>
<td>
<p>function used to compute the aggregate and  confidence intervals.
It should return (<code>y</code>, <code>ymin</code> and <code>ymax</code>).
The default is <a href="ggplot2.html#topic+mean_se">ggplot2::mean_se</a>, which computes the mean + or - standard error.
<a href="ggplot2.html#topic+hmisc">ggplot2::mean_cl_boot</a> can be used instead to generate bootstrap confidence interval instead.</p>
</td></tr>
<tr><td><code id="stat_pop_etho_+3A_method.args">method.args</code></td>
<td>
<p>List of additional arguments passed on to the modelling
function defined by <code>method</code>.</p>
</td></tr>
<tr><td><code id="stat_pop_etho_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_pop_etho_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot layer.
</p>


<h3>References</h3>


<ul>
<li><p> The relevant <a href="https://rethomics.github.io/ggetho.html#population-plots">rethomic tutorial section</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+ggetho">ggetho</a> to generate a plot object
</p>
</li>
<li> <p><a href="#topic+stat_tile_etho">stat_tile_etho</a> to show variable of interest as colour intensity
</p>
</li>
<li> <p><a href="#topic+stat_ld_annotations">stat_ld_annotations</a> to show light and dark phases on the plot
</p>
</li>
<li> <p><a href="ggplot2.html#topic+geom_smooth">ggplot2::stat_smooth</a> to understand how to change the type of confidence interval, line colour and so forth
</p>
</li></ul>

<p>Other layers: 
<code><a href="#topic+geom_peak">geom_peak</a>()</code>,
<code><a href="#topic+stat_bar_tile_etho">stat_bar_tile_etho</a>()</code>,
<code><a href="#topic+stat_ld_annotations">stat_ld_annotations</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(behavr)
metadata &lt;- data.frame(id = sprintf("toy_experiment | %02d", 1:4),
                   age=c(1, 5, 10, 20),
                   condition=c("A", "B"))
dt &lt;- toy_activity_data(metadata, 3)
# We build a plot object
pl &lt;-  ggetho(dt, aes(y = asleep))
# A standard plot of the whole population:
pl + stat_pop_etho()
# We can also split by condition, and display the two population on different facets:
pl + stat_pop_etho() + facet_grid(condition ~ .)
## Not run: 
# Instead, we can use different colour for separate conditions:
pl &lt;-  ggetho(dt, aes(y = asleep, colour = condition))
pl + stat_pop_etho()

# Sometimes, we also have numeric condition (e.g. age)
pl &lt;-  ggetho(dt, aes(y = asleep, colour = age))
pl + stat_pop_etho()
# We could want to aggregate several days of data to one circadian day (i.e. time wrapping)
# here, we also plot the invert of moving (!moving)
pl &lt;-  ggetho(dt, aes(y = !moving), time_wrap = hours(24))
pl + stat_pop_etho()

## End(Not run)
</code></pre>

<hr>
<h2 id='time_scales'>Scales for durations</h2><span id='topic+time_scales'></span><span id='topic+scale_x_days'></span><span id='topic+scale_y_days'></span><span id='topic+scale_x_hours'></span><span id='topic+scale_y_hours'></span><span id='topic+scale_x_seconds'></span><span id='topic+scale_y_seconds'></span>

<h3>Description</h3>

<p>A set of scales used to represent experimental durations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_days(
  name = "Time",
  breaks = waiver(),
  minor_breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = scales::censor,
  na.value = NA_real_,
  position = "bottom",
  time_wrap = NULL,
  unit = "day",
  log = FALSE
)

scale_y_days(
  name = "Time",
  breaks = waiver(),
  minor_breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = scales::censor,
  na.value = NA_real_,
  position = "left",
  time_wrap = NULL,
  unit = "day",
  log = FALSE
)

scale_x_hours(
  name = "Time",
  breaks = waiver(),
  minor_breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = scales::censor,
  na.value = NA_real_,
  position = "bottom",
  time_wrap = NULL,
  unit = "h",
  log = FALSE
)

scale_y_hours(
  name = "Time",
  breaks = waiver(),
  minor_breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = scales::censor,
  na.value = NA_real_,
  position = "left",
  time_wrap = NULL,
  unit = "h",
  log = FALSE
)

scale_x_seconds(
  name = "Time",
  breaks = waiver(),
  minor_breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = scales::censor,
  na.value = NA_real_,
  position = "bottom",
  time_wrap = NULL,
  unit = "s",
  log = FALSE
)

scale_y_seconds(
  name = "Time",
  breaks = waiver(),
  minor_breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = scales::censor,
  na.value = NA_real_,
  position = "left",
  time_wrap = NULL,
  unit = "s",
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_scales_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="time_scales_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the breaks specified by <code>date_breaks</code>
</p>
</li>
<li><p> A <code>Date</code>/<code>POSIXct</code> vector giving positions of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_scales_+3A_minor_breaks">minor_breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the breaks specified by <code>date_minor_breaks</code>
</p>
</li>
<li><p> A <code>Date</code>/<code>POSIXct</code> vector giving positions of minor breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns minor breaks as
output
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_scales_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_scales_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_scales_+3A_expand">expand</code></td>
<td>
<p>Vector of range expansion constants used to add some
padding around the data, to ensure that they are placed some distance
away from the axes. Use the convenience function <code>ggplot2::expand_scale()</code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5\
0.6 units on each side for discrete variables.</p>
</td></tr>
<tr><td><code id="time_scales_+3A_oob">oob</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="time_scales_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value.</p>
</td></tr>
<tr><td><code id="time_scales_+3A_position">position</code></td>
<td>
<p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</td></tr>
<tr><td><code id="time_scales_+3A_time_wrap">time_wrap</code></td>
<td>
<p>duration (in seconds) used to wrap the labels of the time axis</p>
</td></tr>
<tr><td><code id="time_scales_+3A_unit">unit</code></td>
<td>
<p>the name of unit (string) to be used in the label (e.g. one could use <code>"second"</code> instead of <code>"s"</code>)</p>
</td></tr>
<tr><td><code id="time_scales_+3A_log">log</code></td>
<td>
<p>logical, whether axis should be on a log-transformed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time_wrap</code> is useful, for instance, to express time within a day (ZT), instead of absolute time.
</p>


<h3>Value</h3>

<p>A ggplot scale.
</p>


<h3>References</h3>


<ul>
<li><p> The relevant <a href="https://rethomics.github.io/ggetho.html#coordinate-and-scales">rethomic tutorial section</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+ggetho">ggetho</a> to generate a plot object
</p>
</li>
<li> <p><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_x_continuous</a>, the defaut ggplot scale, to understand limits, breaks, labels and name
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We generate some data
metadata &lt;- data.frame(id = sprintf("toy_experiment | %02d", 1:20),
                   condition = c("A","B"))
dt &lt;- toy_activity_data(metadata, 3)
# Then, a simple plot
pl &lt;-  ggetho(dt, aes(y = asleep)) + stat_pop_etho()
pl + scale_x_hours(breaks = days(c(1, 2)))
pl + scale_x_hours()
pl + scale_x_days(breaks = days(c(1, 2)))
pl + scale_x_days()

# To express time modulus `time_wrap`
# e.g. time n the day
pl + scale_x_hours(time_wrap = hours(24)) +
     coord_cartesian(xlim=c(0, days(2)))

# On a shorter time scale
pl &lt;-  ggetho(dt[t &lt; hours(5)], aes(z = asleep)) + stat_tile_etho()
pl + scale_x_hours()
pl + scale_x_hours(breaks = hours(1:4))
pl + scale_x_seconds(breaks = hours(1:4))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
