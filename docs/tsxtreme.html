<!DOCTYPE html><html lang="en"><head><title>Help for package tsxtreme</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tsxtreme}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tsxtreme-package'>
<p>Bayesian Modelling of Extremal Dependence in Time Series</p></a></li>
<li><a href='#bayesfit'><p>Traces from MCMC output</p></a></li>
<li><a href='#bayesparams'>
<p>Parameters for the semi-parametric approach</p></a></li>
<li><a href='#dep2fit'>
<p>Dependence model fit (stepwise)</p></a></li>
<li><a href='#depfit'>
<p>Dependence model fit</p></a></li>
<li><a href='#depmeasure'><p>Dependence measures estimates</p></a></li>
<li><a href='#depmeasures'>
<p>Estimate dependence measures</p></a></li>
<li><a href='#Laplace'>
<p>The Laplace Distribution</p></a></li>
<li><a href='#stepfit'>
<p>Estimates from stepwise fit</p></a></li>
<li><a href='#theta2fit'>
<p>Fit time series extremes</p></a></li>
<li><a href='#thetaruns'>
<p>Runs estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Modelling of Extremal Dependence in Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-30</td>
</tr>
<tr>
<td>Imports:</td>
<td>evd, mvtnorm, stats, MASS, graphics, tictoc</td>
</tr>
<tr>
<td>Description:</td>
<td>Characterisation of the extremal dependence structure of time series, avoiding pre-processing and filtering as done typically with peaks-over-threshold methods. It uses the conditional approach of Heffernan and Tawn (2004) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2004.02050.x">doi:10.1111/j.1467-9868.2004.02050.x</a>&gt; which is very flexible in terms of extremal and asymptotic dependence structures, and Bayesian methods improve efficiency and allow for deriving measures of uncertainty. For example, the extremal index, related to the size of clusters in time, can be estimated and samples from its posterior distribution obtained.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-30 18:20:46 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lugrin [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lugrin &lt;thomas.lugrin@alumni.epfl.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-30 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tsxtreme-package'>
Bayesian Modelling of Extremal Dependence in Time Series
</h2><span id='topic+tsxtreme-package'></span><span id='topic+tsxtreme'></span>

<h3>Description</h3>

<p>Characterisation of the extremal dependence structure of time series, avoiding pre-processing and filtering as done typically with peaks-over-threshold methods. It uses the conditional approach of Heffernan and Tawn (2004) &lt;DOI:10.1111/j.1467-9868.2004.02050.x&gt; which is very flexible in terms of extremal and asymptotic dependence structures, and Bayesian methods improve efficiency and allow for deriving measures of uncertainty. For example, the extremal index, related to the size of clusters in time, can be estimated and samples from its posterior distribution obtained.
</p>


<h3>Details</h3>


<p>Index of help topics:
</p>
<pre>
bayesfit                Traces from MCMC output
bayesparams             Parameters for the semi-parametric approach
dep2fit                 Dependence model fit (stepwise)
depfit                  Dependence model fit
depmeasure              Dependence measures estimates
depmeasures             Estimate dependence measures
dlapl                   The Laplace Distribution
stepfit                 Estimates from stepwise fit
theta2fit               Fit time series extremes
thetaruns               Runs estimator
tsxtreme-package        Bayesian Modelling of Extremal Dependence in
                        Time Series
</pre>
<p>The Heffernan&ndash;Tawn conditional formulation for a stationary time series <code class="reqn">(X_t)</code> with Laplace marginal distribution states that for a large enough threshold <code class="reqn">u</code> there exist scale parameters <code class="reqn">-1 \le\alpha_j\le 1</code> and <code class="reqn">0 \le \beta_j \le 1</code> such that
</p>
<p style="text-align: center;"><code class="reqn">Pr\left(\frac{X_j-\alpha_j X_0}{(X_j)^{\beta_j}} &lt; z_j, j=1,\ldots,m \mid X_0 &gt; u\right) = H(z_1,\ldots,z_m),</code>
</p>

<p>with <code class="reqn">H</code> non-degenerate; the equality holds exactly only when <code class="reqn">u</code> tends to infinity.
</p>
<p>There are mainly 3 functions provided by this package, which allow estimation of extremal dependence measures and fitting the Heffernan&ndash;Tawn model using Dirichlet processes.
</p>
<p><code><a href="#topic+depfit">depfit</a></code> fits the Heffernan&ndash;Tawn model using a Bayesian semi-parametric approach.
</p>
<p><code><a href="#topic+thetafit">thetafit</a></code> computes posterior samples of the threshold-based index of Ledford and Tawn (2003) based on inference in <code><a href="#topic+depfit">depfit</a></code>.
</p>
<p><code><a href="#topic+chifit">chifit</a></code> computes posterior samples of the extremal measure of dependence of Coles, Heffernan and Tawn (1999) at any extremal level.
</p>
<p>Some corresponding functions using the stepwise approach of Heffernan and Tawn (2004) are also part of the package, namely <code><a href="#topic+dep2fit">dep2fit</a></code> and <code><a href="#topic+theta2fit">theta2fit</a></code>.
</p>
<p>The empirical estimation of the extremal index can be done using <code><a href="#topic+thetaruns">thetaruns</a></code> and some basic functions handling the Laplace distribution are also available in <code><a href="#topic+dlapl">dlapl</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Lugrin [aut, cre, cph]
</p>
<p>Maintainer: Thomas Lugrin &lt;thomas.lugrin@alumni.epfl.ch&gt;
</p>


<h3>References</h3>

<p>Coles, S., Heffernan, J. E. and Tawn, J. A. (1999) Dependence measures for extreme value analyses. <em>Extremes</em>, <b>2</b>, 339&ndash;365.
</p>
<p>Davison, A. C. and Smith, R. L. (1990) Models for exceedances over high thresholds. <em>Journal of the Royal Statistical Society Series B</em>, <b>52</b>, 393&ndash;442.
</p>
<p>Heffernan, J. E. and Tawn, J. A. (2004) A conditional approach for multivariate extreme values. <em>Journal of the Royal Statistical Society Series B</em>, <b>66</b>, 497&ndash;546.
</p>
<p>Ledford, W. A. and Tawn, J. A. (2003) Diagnostics for dependence within time series extremes. <em>Journal of the Royal Statistical Society Series B</em>, <b>65</b>, 521&ndash;543.
</p>
<p>Lugrin, T., Davison, A. C. and Tawn, J. A. (2016) Bayesian uncertainty management in temporal dependence of extremes. <em>Extremes</em>, <b>19</b>, 491&ndash;515.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thetafit">thetafit</a></code>, <code><a href="#topic+chifit">chifit</a></code>, <code><a href="#topic+depfit">depfit</a></code>
</p>

<hr>
<h2 id='bayesfit'>Traces from MCMC output</h2><span id='topic+bayesfit'></span><span id='topic+is.bayesfit'></span><span id='topic+summary.bayesfit'></span><span id='topic+plot.bayesfit'></span><span id='topic+print.bayesfit'></span>

<h3>Description</h3>

<p>Test or show objects of class &quot;bayesfit&quot;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.bayesfit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesfit_+3A_x">x</code></td>
<td>
<p>an arbitrary <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default plot shows samples of residual densities (<code>which==1</code>), residual distribution with credible interval (<code class="reqn">5\%</code> and <code class="reqn">95\%</code> posterior quantiles; <code>which==2</code>), and joint posterior distribution of <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> (<code>which==3</code>) for each lag successively. <code>which</code> can be any composition of 1,2 and 3.
</p>


<h3>Value</h3>

<p>An object of class &quot;bayesfit&quot; is a list containing MCMC traces for:
</p>
<table role = "presentation">
<tr><td><code>a</code>, <code>b</code></td>
<td>
<p>Heffernan-Tawn parameters.</p>
</td></tr>
<tr><td><code>sd</code>, <code>mean</code>, <code>w</code></td>
<td>
<p>standard deviations, means and weights of the mixture components.</p>
</td></tr>
<tr><td><code>prec</code></td>
<td>
<p>precision parameter of the Dirichlet process.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>auxiliary variable; components' indices for each observation.</p>
</td></tr>
<tr><td><code>noo</code></td>
<td>
<p>number of observations in each mixture component.</p>
</td></tr>
<tr><td><code>noc</code></td>
<td>
<p>number of non-empty components in the mixture.</p>
</td></tr>
<tr><td><code>prop.sd</code></td>
<td>
<p>standard deviations of the proposal distributions for <code>a</code> and <code>b</code>.</p>
</td></tr>
</table>
<p>And <code>len</code>, the length of the traces, i.e., the number of iterations saved.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesparams">bayesparams</a></code>, <code><a href="#topic+stepfit">stepfit</a></code>
</p>

<hr>
<h2 id='bayesparams'>
Parameters for the semi-parametric approach
</h2><span id='topic+bayesparams'></span><span id='topic+is.bayesparams'></span><span id='topic+summary.bayesparams'></span><span id='topic+print.bayesparams'></span>

<h3>Description</h3>

<p>Create, test or show objects of class &quot;bayesparams&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesparams(prop.a = 0.02, prop.b = 0.02,
  prior.mu = c(0, 10), prior.nu = c(2, 1/2), prior.eta = c(2, 2),
  trunc = 100, comp.saved = 15, maxit = 30000,
  burn = 5000, thin = 1,
  adapt = 5000, batch.size = 125,
  mode = 1)

is.bayesparams(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesparams_+3A_prop.a">prop.a</code>, <code id="bayesparams_+3A_prop.b">prop.b</code></td>
<td>
<p>standard deviation for the Gaussian proposal of the Heffernan&ndash;Tawn parameters.</p>
</td></tr>
<tr><td><code id="bayesparams_+3A_prior.mu">prior.mu</code></td>
<td>
<p>mean and standard deviation of the Gaussian prior for the components' means.</p>
</td></tr>
<tr><td><code id="bayesparams_+3A_prior.nu">prior.nu</code></td>
<td>
<p>shape and rate of the inverse gamma prior for the components' variances.</p>
</td></tr>
<tr><td><code id="bayesparams_+3A_prior.eta">prior.eta</code></td>
<td>
<p>shape and scale of the gamma prior for the precision parameter of the Dirichlet process.</p>
</td></tr>
<tr><td><code id="bayesparams_+3A_trunc">trunc</code></td>
<td>
<p>integer; value of the truncation for the approximation of the infinite sum in the stick-breaking representation.</p>
</td></tr>
<tr><td><code id="bayesparams_+3A_comp.saved">comp.saved</code></td>
<td>
<p>number of first components to be saved and returned.</p>
</td></tr>
<tr><td><code id="bayesparams_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="bayesparams_+3A_burn">burn</code></td>
<td>
<p>number of first iterations to discard.</p>
</td></tr>
<tr><td><code id="bayesparams_+3A_thin">thin</code></td>
<td>
<p>positive integer; spacing between iterations to be saved. Default is 1, i.e., all iterations are saved.</p>
</td></tr>
<tr><td><code id="bayesparams_+3A_adapt">adapt</code></td>
<td>
<p>integer; number of iterations during which an adaption algorithm is applied to the proposal variances of <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="bayesparams_+3A_batch.size">batch.size</code></td>
<td>
<p>size of batches used in the adaption algorithm. It has no effect if <code>adapt==0</code>.</p>
</td></tr>
<tr><td><code id="bayesparams_+3A_mode">mode</code></td>
<td>
<p>verbosity; 0 for debug mode, 1 (default) for standard output, and 2 for silent.</p>
</td></tr>
<tr><td><code id="bayesparams_+3A_x">x</code></td>
<td>
<p>an arbitrary <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>prop.a</code> is a vector of length 5 with the standard deviations for each region of the RAMA for the (Gaussian) proposal for <code class="reqn">\alpha</code>. If a scalar is given, 5 identical values are assumed.
</p>
<p><code>prop.b</code> is a vector of length 3 with the standard deviations for each region of the RAMA for the (Gaussian) proposal for <code class="reqn">\beta</code>. If a scalar is provided, 3 identical values are assumed.
</p>
<p><code>comp.saved</code> has no impact on the calculations: its only purpose is to prevent from storing huge amounts of empty components.
</p>
<p>The regional adaption scheme targets a <code class="reqn">0.44</code> acceptance probability. It splits <code class="reqn">[-1;1]</code> in <code class="reqn">5</code> regions for <code class="reqn">\alpha</code> and <code class="reqn">[0;1]</code> in <code class="reqn">3</code> regions for <code class="reqn">\beta</code>. The decision to increase/decrease the proposal standard deviation is based on the past <code>batch.size</code> MCMC iterations, so too low values yield inefficient adaption, while too large values yield slow adaption.
</p>
<p>Default values for the hyperparameters are chosen to get reasonably uninformative priors.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesfit">bayesfit</a></code>, <code><a href="#topic+depmeasure">depmeasure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.bayesparams(bayesparams()) # TRUE
## use defaults, change max number of iteration of MCMC
par &lt;- bayesparams(maxit=1e5)
</code></pre>

<hr>
<h2 id='dep2fit'>
Dependence model fit (stepwise)
</h2><span id='topic+dep2fit'></span>

<h3>Description</h3>

<p>The conditional Heffernan&ndash;Tawn model is used to fit the dependence in time of a stationary series. A standard 2-stage procedure is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dep2fit(ts, u.mar = 0, u.dep,
        lapl = FALSE, method.mar = c("mle","mom","pwm"),
        nlag = 1, conditions = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dep2fit_+3A_ts">ts</code></td>
<td>

<p>numeric vector; time series to be fitted.
</p>
</td></tr>
<tr><td><code id="dep2fit_+3A_u.mar">u.mar</code></td>
<td>

<p>marginal threshold; used when transforming the time series to Laplace scale.
</p>
</td></tr>
<tr><td><code id="dep2fit_+3A_u.dep">u.dep</code></td>
<td>

<p>dependence threshold; level above which the dependence is modelled. <code>u.dep</code> can be lower than <code>u.mar</code>.
</p>
</td></tr>
<tr><td><code id="dep2fit_+3A_lapl">lapl</code></td>
<td>

<p>logical; is <code>ts</code> on the Laplace scale already? The default (FALSE) assumes unknown marginal distribution.
</p>
</td></tr>
<tr><td><code id="dep2fit_+3A_method.mar">method.mar</code></td>
<td>

<p>a character string defining the method used to estimate the marginal GPD; either <code>"mle"</code> for maximum likelihood of <code>"mom"</code> for method of moments. Defaults to <code>"mle"</code>.
</p>
</td></tr>
<tr><td><code id="dep2fit_+3A_nlag">nlag</code></td>
<td>

<p>integer; number of lags to be considered when modelling the dependence in time.
</p>
</td></tr>
<tr><td><code id="dep2fit_+3A_conditions">conditions</code></td>
<td>

<p>logical; should conditions on <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> be set? (see Details) Defaults to <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a stationary time series <code class="reqn">(X_t)</code> with Laplace marginal distribution; the fitting procedure consists of fitting
</p>
<p style="text-align: center;"><code class="reqn">X_t = \alpha_t\times x_0 + x_0^{\beta_t}\times Z_t,\quad t=1,\ldots,m,</code>
</p>

<p>with <code class="reqn">m</code> the number of lags considered. A likelihood is maximised assuming <code class="reqn">Z_t\sim N(\mu_t, \sigma^2_t)</code>, then an empirical distribution for the <code class="reqn">Z_t</code> is derived using the estimates of <code class="reqn">\alpha_t</code> and <code class="reqn">\beta_t</code> and the relation
</p>
<p style="text-align: center;"><code class="reqn">\hat Z_t = \frac{X_t - \hat\alpha_t\times x_0}{x_0^{\hat\beta_t}}.</code>
</p>

<p><code>conditions</code> implements additional conditions suggested by Keef, Papastathopoulos and Tawn (2013) on the ordering of conditional quantiles. These conditions help with getting a consistent fit by shrinking the domain in which <code class="reqn">(\alpha,\beta)</code> live.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>parameter controlling the conditional extremal expectation.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>parameter controlling the conditional extremal expectation and variance.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>empirical residual of the model.</p>
</td></tr>
<tr><td><code>pars.se</code></td>
<td>
<p>vector of length 2 giving the estimated standard errors for <code>alpha</code> and <code>beta</code> given by the hessian matrix of the likelihood function used in the first step of the inference procedure.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+depfit">depfit</a></code>, <code><a href="#topic+theta2fit">theta2fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data from an AR(1)
## with Gaussian marginal distribution
n   &lt;- 10000
dep &lt;- 0.5
ar    &lt;- numeric(n)
ar[1] &lt;- rnorm(1)
for(i in 2:n)
  ar[i] &lt;- rnorm(1, mean=dep*ar[i-1], sd=1-dep^2)
plot(ar, type="l")
plot(density(ar))
grid &lt;- seq(-3,3,0.01)
lines(grid, dnorm(grid), col="blue")

## rescale margin
ar &lt;- qlapl(pnorm(ar))

## fit model without constraints...
fit1 &lt;- dep2fit(ts=ar, u.mar = 0.95, u.dep=0.98, conditions=FALSE)
fit1$a; fit1$b

## ...and compare with a fit with constraints
fit2 &lt;- dep2fit(ts=ar, u.mar = 0.95, u.dep=0.98, conditions=TRUE)
fit2$a; fit2$b# should be similar, as true parameters lie well within the constraints
</code></pre>

<hr>
<h2 id='depfit'>
Dependence model fit
</h2><span id='topic+depfit'></span>

<h3>Description</h3>

<p>Bayesian semiparametrics are used to fit the Heffernan&ndash;Tawn model to time series. Options are available to impose a structure in time on the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depfit(ts, u.mar = 0, u.dep=u.mar,
    lapl = FALSE, method.mar=c("mle","mom","pwm"),  nlag = 1,
    par = bayesparams(),
    submodel = c("fom", "none", "ugm"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="depfit_+3A_ts">ts</code></td>
<td>

<p>numeric vector; time series to be fitted.
</p>
</td></tr>
<tr><td><code id="depfit_+3A_u.mar">u.mar</code></td>
<td>

<p>marginal threshold; used when transforming the time series to Laplace scale.
</p>
</td></tr>
<tr><td><code id="depfit_+3A_u.dep">u.dep</code></td>
<td>

<p>dependence threshold; level above which the dependence is modelled. <code>u.dep</code> can be lower than <code>u.mar</code>.
</p>
</td></tr>
<tr><td><code id="depfit_+3A_lapl">lapl</code></td>
<td>

<p>logical; is <code>ts</code> on the Laplace scale already? The default (FALSE) assumes unknown marginal distribution.
</p>
</td></tr>
<tr><td><code id="depfit_+3A_method.mar">method.mar</code></td>
<td>

<p>a character string defining the method used to estimate the marginal GPD; either <code>"mle"</code> for maximum likelihood or <code>"mom"</code> for method of moments or <code>"pwm"</code> for probability weighted moments. Defaults to <code>"mle"</code>.
</p>
</td></tr>
<tr><td><code id="depfit_+3A_nlag">nlag</code></td>
<td>

<p>integer; number of lags to be considered when modelling the dependence in time.
</p>
</td></tr>
<tr><td><code id="depfit_+3A_par">par</code></td>
<td>

<p>an object of class 'bayesparams'.
</p>
</td></tr>
<tr><td><code id="depfit_+3A_submodel">submodel</code></td>
<td>

<p>a character string; &quot;fom&quot; for <em>first order Markov</em>, &quot;none&quot; for <em>no particular time structure</em>, or &quot;ugm&quot; for <em>univariate Gaussian mixture</em> (see details).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>submodel</code> can be <code>"fom"</code> to impose a first order Markov structure on the model parameters <code class="reqn">\alpha_j</code> and <code class="reqn">\beta_j</code> (see <code><a href="#topic+thetafit">thetafit</a></code> for more details); it can take the value <code>"none"</code> to impose no particular structure in time; it can also be <code>"ugm"</code> which can be applied to density estimation, as it corresponds to setting <code class="reqn">\alpha=\beta=0</code> (see examples).
</p>


<h3>Value</h3>

<p>An object of class 'bayesfit' with elements:
</p>
<table role = "presentation">
<tr><td><code>a</code></td>
<td>
<p>posterior trace of <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>posterior trace of <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>posterior trace of the components' standard deviations.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>posterior trace of the components' means.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>posterior trace of the components' assigned weights.</p>
</td></tr>
<tr><td><code>prec</code></td>
<td>
<p>posterior trace of the precision parameter.</p>
</td></tr>
<tr><td><code>noo</code></td>
<td>
<p>posterior trace of the number of observations per component.</p>
</td></tr>
<tr><td><code>noc</code></td>
<td>
<p>posterior trace of the number of components containing at least one observation.</p>
</td></tr>
<tr><td><code>prop.sd</code></td>
<td>
<p>trace of proposal standard deviations in the 5+3 regions of the adaption scheme for <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>len</code></td>
<td>
<p>length of the returned traces.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+thetafit">thetafit</a></code>, <code><a href="#topic+chifit">chifit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data from an AR(1)
## with Gaussian marginal distribution
n   &lt;- 10000
dep &lt;- 0.5
ar    &lt;- numeric(n)
ar[1] &lt;- rnorm(1)
for(i in 2:n)
  ar[i] &lt;- rnorm(1, mean=dep*ar[i-1], sd=1-dep^2)
  
## rescale the margin
ar &lt;- qlapl(pnorm(ar))

## fit the data
params &lt;- bayesparams()
params$maxit &lt;- 100# bigger numbers would be
params$burn  &lt;- 10 # more sensible...
params$thin  &lt;- 4
fit &lt;- depfit(ts=ar, u.mar=0.95, u.dep=0.98, par=params)

########
## density estimation with submodel=="ugm"
data &lt;- MASS::galaxies/1e3
dens &lt;- depfit(ts=data, par=params, submodel="ugm")
</code></pre>

<hr>
<h2 id='depmeasure'>Dependence measures estimates</h2><span id='topic+depmeasure'></span><span id='topic+is.depmeasure'></span><span id='topic+summary.depmeasure'></span><span id='topic+plot.depmeasure'></span><span id='topic+print.depmeasure'></span>

<h3>Description</h3>

<p>Test or show objects of class &quot;depmeasure&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.depmeasure(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="depmeasure_+3A_x">x</code></td>
<td>
<p>an arbitrary <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'depmeasure' is a list which contains:
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>an object of class '<a href="#topic+bayesfit">bayesfit</a>'</p>
</td></tr>
<tr><td><code>distr</code></td>
<td>
<p>an array with the samples used for the estimation.</p>
</td></tr>
<tr><td><code>probs</code>, <code>levels</code></td>
<td>
<p>points  &mdash;probability and original scale respectively&mdash; at which the dependence measure is estimated</p>
</td></tr>
</table>
<p>Depending on the dependence measure, <code>theta</code> or <code>chi</code>, a matrix with levels on row-entries and mean, median and specified quantiles of the posterior distribution of theta or chi respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+depmeasures">depmeasures</a></code>
</p>

<hr>
<h2 id='depmeasures'>
Estimate dependence measures
</h2><span id='topic+depmeasures'></span><span id='topic+thetafit'></span><span id='topic+chifit'></span>

<h3>Description</h3>

<p>Appropriate marginal transforms are done before the fit using standard procedures, before the dependence model is fitted to the data. Then the posterior distribution of a measure of dependence is derived. <code>thetafit</code> gives posterior samples for the extremal index <code class="reqn">\theta(x,m)</code> and <code>chifit</code> does the same for the coefficient of extremal dependence <code class="reqn">\chi_m(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thetafit(ts, lapl = FALSE, nlag = 1,
      R = 1000, S = 500,
      u.mar = 0, u.dep,
      probs = seq(u.dep, 0.9999, length.out = 30),
      method.mar = c("mle", "mom","pwm"), method = c("prop", "MCi"),
      silent = FALSE,
      fit = TRUE, prev.fit=bayesfit(), par = bayesparams(),
      submodel = c("fom", "none"), levels=c(.025,.975))

chifit(ts, lapl = FALSE, nlag = 1,
      R = 1000, S = 500,
      u.mar = 0, u.dep,
      probs = seq(u.dep, 0.9999, length.out = 30),
      method.mar = c("mle", "mom","pwm"), method = c("prop", "MCi"),
      silent = FALSE,
      fit = TRUE, prev.fit=bayesfit(), par = bayesparams(),
      submodel = c("fom", "none"), levels=c(.025,.975))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="depmeasures_+3A_ts">ts</code></td>
<td>

<p>a vector, the time series for which to estimate the extremal index <code class="reqn">\theta(x,m)</code> or the coefficient of extremal dependence <code class="reqn">\chi_m(x)</code>, with <code class="reqn">x</code> a probability level and <code class="reqn">m</code> a run-length (see details).
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_lapl">lapl</code></td>
<td>

<p>logical; <code>TRUE</code> indicates that <code>ts</code> has a marginal Laplace distribution. If <code>FALSE</code> (default), <code>method.mar</code> is used to transform the marginal distribution of <code>ts</code> to Laplace.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_nlag">nlag</code></td>
<td>

<p>the run-length; an integer larger or equal to 1.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_r">R</code></td>
<td>

<p>the number of samples per MCMC iteration drawn from the sampled posterior distributions; used for the estimation of the dependence measure.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_s">S</code></td>
<td>

<p>the number of posterior distributions sampled to be used for the estimation of the dependence measure.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_u.mar">u.mar</code></td>
<td>

<p>probability; threshold used for marginal transformation if <code>lapl</code> is <code>FALSE</code>. Not used otherwise.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_u.dep">u.dep</code></td>
<td>

<p>probability; threshold used for the extremal dependence model.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_probs">probs</code></td>
<td>

<p>vector of probabilities; the values of <code class="reqn">x</code> for which to evaluate <code class="reqn">\theta(x,m)</code> or <code class="reqn">\chi_m(x)</code>.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_method.mar">method.mar</code></td>
<td>

<p>a character string defining the method used to estimate the marginal GPD; either <code>"mle"</code> for maximum likelihood of <code>"mom"</code> for method of moments or <code>"pwm"</code> for probability weighted moments methods. Defaults to <code>"mle"</code>.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_method">method</code></td>
<td>

<p>a character string defining the method used to estimate the dependence measure; either <code>"prop"</code> for proportions or <code>"MCi"</code> for Monte Carlo integration (see details).
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_silent">silent</code></td>
<td>

<p>logical (<code>FALSE</code>); verbosity.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_fit">fit</code></td>
<td>

<p>logical; <code>TRUE</code> means that the dependence model must be fitted and the values in <code>par</code> are used. Otherwise the result from a previous call to <code><a href="#topic+depfit">depfit</a></code>.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_prev.fit">prev.fit</code></td>
<td>

<p>an object of class 'bayesfit'. Needed if <code>fit</code> is FALSE. Typically returned by a previous call to <code><a href="#topic+depfit">depfit</a></code>.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_par">par</code></td>
<td>

<p>an object of class '<code><a href="#topic+bayesparams">bayesparams</a></code>' to be used for the fit of dependence model.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_submodel">submodel</code></td>
<td>

<p>a character string, either <code>"fom"</code> for <em>first order Markov</em> or <code>"none"</code> for no specification.
</p>
</td></tr>
<tr><td><code id="depmeasures_+3A_levels">levels</code></td>
<td>

<p>vector of probabilites; the quantiles of the posterior distribution of the extremal measure to be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sub-asymptotic extremal index is defined as
</p>
<p style="text-align: center;"><code class="reqn">\theta(x,m) = Pr(X_1 &lt; x,\ldots,X_m &lt; x | X_0 &gt; x),</code>
</p>

<p>whose limit as <code class="reqn">x</code> and <code class="reqn">m</code> go to <code class="reqn">\infty</code>appropriately is the extremal index <code class="reqn">\theta</code>. The extremal index can be interpreted as the inverse of the asymptotic mean cluster size (see <code><a href="#topic+thetaruns">thetaruns</a>)</code>.
</p>
<p>The sub-asymptotic coefficient of extremal dependence is
</p>
<p style="text-align: center;"><code class="reqn">\chi_m(x) = Pr(X_m &gt; x | X_0 &gt; x),</code>
</p>

<p>whose limit <code class="reqn">\chi</code> defines asymptotic dependence (<code class="reqn">\chi &gt; 0</code>) or asymptotic independence (<code class="reqn">\chi = 0</code>).
</p>
<p>Both types of extremal dependence measures can be estimated either using a
</p>
<p>* proportion method (<code>method == "prop"</code>), sampling from the conditional probability given <code class="reqn">X_0 &gt; x</code> and counting the proportion of sampled points falling in the region of interest, or
</p>
<p>* Monte Carlo integration (<code>method == "MCi"</code>), sampling replicates from the marginal exponential tail distribution and evaluating the conditional tail distribution in these replicates, then taking their mean as an approximation of the integral.
</p>
<p><code>submodel == "fom"</code> imposes a first order Markov structure to the model, namely a geometrical decrease in <code class="reqn">\alpha</code> and a constant <code class="reqn">\beta</code> across lags, i.e. <code class="reqn">\alpha_j = \alpha^j</code> and <code class="reqn">\beta_j = \beta</code>, <code class="reqn">j=1,\ldots,m</code>.
</p>


<h3>Value</h3>

<p>An object of class 'depmeasure', containing a subset of:
</p>
<table role = "presentation">
<tr><td><code>bayesfit</code></td>
<td>
<p>An object of class 'bayesfit'</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>An array with dimensions <code>m</code> <code class="reqn">\times</code> <code>length(probs)</code> <code class="reqn">\times</code> (2+<code>length(levels)</code>), with the last dimension listing the posterior mean and median, and the <code>level</code> posterior quantiles</p>
</td></tr>
<tr><td><code>distr</code></td>
<td>
<p>An array with dimensions <code>m</code> <code class="reqn">\times</code> <code>length(probs)</code> <code class="reqn">\times</code> <code>S</code>; posterior samples of <code>theta</code></p>
</td></tr>
<tr><td><code>chi</code></td>
<td>
<p>An array with dimensions <code>m</code> <code class="reqn">\times</code> <code>length(probs)</code> <code class="reqn">\times</code> (2+<code>length(levels)</code>), with the last dimension listing the posterior mean and median, and the <code>level</code> posterior quantiles</p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p><code>probs</code></p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p><code>probs</code> transformed to original scale of <code>ts</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+depfit">depfit</a></code>, <code><a href="#topic+theta2fit">theta2fit</a></code>, <code><a href="#topic+thetaruns">thetaruns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data from an AR(1)
## with Gaussian marginal distribution
n   &lt;- 10000
dep &lt;- 0.5
ar    &lt;- numeric(n)
ar[1] &lt;- rnorm(1)
for(i in 2:n)
  ar[i] &lt;- rnorm(1, mean=dep*ar[i-1], sd=1-dep^2)
plot(ar, type="l")
plot(density(ar))
grid &lt;- seq(-3,3,0.01)
lines(grid, dnorm(grid), col="blue")

## rescale the margin (focus on dependence)
ar &lt;- qlapl(pnorm(ar))

## fit the data
params &lt;- bayesparams()
params$maxit &lt;- 100 # bigger numbers would be
params$burn  &lt;- 10  # more sensible...
params$thin  &lt;- 4
theta &lt;- thetafit(ts=ar, R=500, S=100, u.mar=0.95, u.dep=0.98,
                  probs = c(0.98, 0.999), par=params)
## or, same thing in two steps to control fit output before computing theta:
fit &lt;- depfit(ts=ar, u.mar=0.95, u.dep=0.98, par=params)
plot(fit)
theta &lt;- thetafit(ts=ar, R=500, S=100, u.mar=0.95, u.dep=0.98,
                  probs = c(0.98, 0.999), fit=FALSE, prev.fit=fit)
</code></pre>

<hr>
<h2 id='Laplace'>
The Laplace Distribution
</h2><span id='topic+dlapl'></span><span id='topic+plapl'></span><span id='topic+qlapl'></span><span id='topic+rlapl'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the Laplace distribution with location parameter <code>loc</code> and scale parameter <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlapl(x, loc = 0, scale = 1, log = FALSE)
plapl(q, loc = 0, scale = 1, lower.tail = TRUE, log.p = FALSE)
qlapl(p, loc = 0, scale = 1, lower.tail = TRUE, log.p = FALSE)
rlapl(n, loc = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Laplace_+3A_x">x</code>, <code id="Laplace_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_n">n</code></td>
<td>
<p>number of samples to generate.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_loc">loc</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_scale">scale</code></td>
<td>
<p>vector of scale parameters. These must be positive.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">Pr(X\le x)</code>, otherwise <code class="reqn">Pr(X&gt;x)</code>.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_log">log</code>, <code id="Laplace_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">\log(p)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>loc</code> or <code>scale</code> are not specified, they assume the default values of 0 and 1 respectively.
</p>
<p>The Laplace distribution has density
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \exp(- |x-\mu|/\sigma)/(2\sigma)</code>
</p>

<p>where <code class="reqn">\mu</code> is the location parameter and <code class="reqn">\sigma</code> is the scale parameter.
</p>


<h3>Value</h3>

<p><code>dlapl</code> gives the density, <code>plapl</code> gives the distribution function, <code>qlapl</code> gives the quantile function, and <code>rlapl</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> in <code>rlapl</code>, and is the maximum of the lengths of the numerical arguments for the other functions. Standard <code>R</code> vector operations are to be assumed.
</p>
<p>If <code>sd</code>=0, the limit as <code>sd</code> decreases to 0 is returned, i.e., a point mass at <code>loc</code>. The case <code>sd</code>&lt;0 is an error and nothing is returned.
</p>


<h3>Warning</h3>

<p>Some checks are done previous to standard evaluation, but vector computations have not yet been tested thoroughly! Typically vectors not having lengths multiple of each other return an error.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+dexp">dexp</a> for the exponential distribution which is the positive part of the Laplace distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## evaluate the density function on a grid of values
x  &lt;- seq(from=-5, to=5, by=0.1)
fx &lt;- dlapl(x, loc=1, scale=.5)

## generate random samples of a mixture of Laplace distributions
rnd &lt;- rlapl(1000, loc=c(-5,-3,2), scale=0.5)

## an alternative:
rnd &lt;- runif(1000)
rnd &lt;- qlapl(rnd, loc=c(-5,-3,2), scale=0.5)

## integrate the Laplace density on [a,b]
a &lt;- -1
b &lt;- 7
integral &lt;- plapl(b)-plapl(a)
</code></pre>

<hr>
<h2 id='stepfit'>
Estimates from stepwise fit
</h2><span id='topic+stepfit'></span><span id='topic+is.stepfit'></span><span id='topic+summary.stepfit'></span><span id='topic+plot.stepfit'></span><span id='topic+print.stepfit'></span>

<h3>Description</h3>

<p>Create, test or show objects of class &quot;stepfit&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepfit()

is.stepfit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepfit_+3A_x">x</code></td>
<td>
<p>an arbitrary <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;stepfit&quot; is a list containing:
</p>
<table role = "presentation">
<tr><td><code>a</code>, <code>b</code></td>
<td>
<p>Heffernan&ndash;Tawn parameters.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>fitted residuals.</p>
</td></tr>
<tr><td><code>pars.se</code></td>
<td>
<p>estimated standard error of <code>a</code> and <code>b</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bayesfit">bayesfit</a></code>, <code><a href="#topic+depmeasure">depmeasure</a></code>
</p>

<hr>
<h2 id='theta2fit'>
Fit time series extremes
</h2><span id='topic+theta2fit'></span>

<h3>Description</h3>

<p>Appropriate marginal transforms are done before the fit using standard procedures, before the dependence model is fitted to the data. Then the measure of dependence <code class="reqn">\theta(x,m)</code> is derived using a method described in Eastoe and Tawn (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta2fit(ts, lapl = FALSE, nlag = 1, R = 1000,
          u.mar = 0, u.dep, probs = seq(u.dep, 0.9999, length.out = 30),
          method.mar = c("mle","mom","pwm"), method = c("prop", "MCi"),
          silent = FALSE,
          R.boot = 0, block.length = m * 5, levels = c(.025,.975))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theta2fit_+3A_ts">ts</code></td>
<td>

<p>numeric vector; time series to be fitted.
</p>
</td></tr>
<tr><td><code id="theta2fit_+3A_lapl">lapl</code></td>
<td>

<p>logical; is <code>ts</code> on the Laplace scale already? The default (FALSE) assumes unknown marginal distribution.
</p>
</td></tr>
<tr><td><code id="theta2fit_+3A_nlag">nlag</code></td>
<td>

<p>integer; number of lags to be considered when modelling the dependence in time.
</p>
</td></tr>
<tr><td><code id="theta2fit_+3A_r">R</code></td>
<td>

<p>integer; the number of samples used for estimating <code class="reqn">\theta(x,m)</code>.
</p>
</td></tr>
<tr><td><code id="theta2fit_+3A_u.mar">u.mar</code></td>
<td>

<p>marginal threshold; used when transforming the time series to Laplace scale if <code>lapl</code> is FALSE; not used otherwise.
</p>
</td></tr>
<tr><td><code id="theta2fit_+3A_u.dep">u.dep</code></td>
<td>

<p>dependence threshold; level above which the dependence is modelled. <code>u.dep</code> can be lower than <code>u.mar</code>.
</p>
</td></tr>
<tr><td><code id="theta2fit_+3A_probs">probs</code></td>
<td>

<p>vector of probabilities; the values of <code class="reqn">x</code> for which to evaluate <code class="reqn">\theta(x,m)</code>.
</p>
</td></tr>
<tr><td><code id="theta2fit_+3A_method.mar">method.mar</code></td>
<td>

<p>a character string defining the method used to estimate the marginal GPD; either <code>"mle"</code> for maximum likelihood of <code>"mom"</code> for method of moments or <code>"pwm"</code> for probability weighted moments methods. Defaults to <code>"mle"</code>.
</p>
</td></tr>
<tr><td><code id="theta2fit_+3A_method">method</code></td>
<td>

<p>a character string defining the method used to estimate the dependence measure; either <code>"prop"</code> for proportions or <code>"MCi"</code> for Monte Carlo integration (see Details).
</p>
</td></tr>
<tr><td><code id="theta2fit_+3A_silent">silent</code></td>
<td>

<p>logical (<code>FALSE</code>); verbosity.
</p>
</td></tr>
<tr><td><code id="theta2fit_+3A_r.boot">R.boot</code></td>
<td>

<p>integer; the number of samples used for the block bootstrap for the confidence intervals.
</p>
</td></tr>
<tr><td><code id="theta2fit_+3A_block.length">block.length</code></td>
<td>

<p>integer; the block length used for the block-bootstrapped confidence intervals.
</p>
</td></tr>
<tr><td><code id="theta2fit_+3A_levels">levels</code></td>
<td>

<p>vector of probabilities; the quantiles of the bootstrap distribution of the extremal measure to be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard procedure (<code>method="prop"</code>) to estimating probabilities from a Heffernan-Tawn fit best illustrated in the bivariate context (<code class="reqn">Y\mid X&gt;u</code>):
</p>
<p>1. sample <code class="reqn">X</code> from an exponential distribution above <code class="reqn">v \ge u</code>,
</p>
<p>2. sample <code class="reqn">Z</code> (residuals) from their empirical distribution,
</p>
<p>3. compute <code class="reqn">Y</code> using the relation <code class="reqn">Y = \alpha\times X + X^\beta\times Z</code>,
</p>
<p>4. estimate <code class="reqn">Pr(X &gt; v_x, Y &gt; v_y)</code> by calculating the proportion <code class="reqn">p</code> of <code class="reqn">Y</code> samples above <code class="reqn">v_y</code> and multiply <code class="reqn">p</code> with the marginal survival distribution evaluated at <code class="reqn">v_x</code>.
</p>
<p>With <code>method="MCi"</code> a Monte Carlo integration approach is used, where the survivor distribution of <code class="reqn">Z</code> is evaluated at pseudo-residuals of the form
</p>
<p style="text-align: center;"><code class="reqn">\frac{v_y - \alpha\times X}{X^\beta},</code>
</p>

<p>where <code class="reqn">X</code> is sampled from an exponential distribution above <code class="reqn">v_x</code>. Taking the mean of these survival probabilities, we get the Monte Carlo equivalent of <code class="reqn">p</code> in the proportion approach.
</p>


<h3>Value</h3>

<p>List containing:
</p>
<table role = "presentation">
<tr><td><code>depfit</code></td>
<td>
<p>an object of class '<a href="#topic+stepfit">stepfit</a>'</p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p><code>probs</code></p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p><code>probs</code> transformed to original scale of <code>ts</code></p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>a matrix with <em>proportion</em> or <em>Monte Carlo</em> estimates of <code class="reqn">\theta(x,m)</code>. Rows correspond to values in <code>probs</code>, columns are point estimates and bootstrap quantiles</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+dep2fit">dep2fit</a></code>, <code><a href="#topic+thetafit">thetafit</a></code>, <code><a href="#topic+thetaruns">thetaruns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data from an AR(1)
## with Gaussian marginal distribution
n   &lt;- 10000
dep &lt;- 0.5
ar    &lt;- numeric(n)
ar[1] &lt;- rnorm(1)
for(i in 2:n)
  ar[i] &lt;- rnorm(1, mean=dep*ar[i-1], sd=1-dep^2)
plot(ar, type="l")
plot(density(ar))
grid &lt;- seq(-3,3,0.01)
lines(grid, dnorm(grid), col="blue")

## rescale the margin (focus on dependence)
ar &lt;- qlapl(pnorm(ar))

## fit the data
fit &lt;- theta2fit(ts=ar, u.mar=0.95, u.dep=0.98)

## plot theta(x,1)
plot(fit)
abline(h=1, lty="dotted")
</code></pre>

<hr>
<h2 id='thetaruns'>
Runs estimator
</h2><span id='topic+thetaruns'></span>

<h3>Description</h3>

<p>Compute the empirical estimator of the extremal index using the runs method (Smith &amp; Weissman, 1994, JRSSB).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thetaruns(ts, lapl = FALSE, nlag = 1,
          u.mar = 0, probs = seq(u.mar, 0.995, length.out = 30),
          method.mar = c("mle", "mom", "pwm"),
          R.boot = 0, block.length = (nlag+1) * 5, levels = c(0.025, 0.975))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thetaruns_+3A_ts">ts</code></td>
<td>

<p>a vector, the time series for which to estimate the threshold-based extremal index <code class="reqn">\theta(x,m)</code>, with <code class="reqn">x</code> a probability level and <code class="reqn">m</code> a run-length (see details).
</p>
</td></tr>
<tr><td><code id="thetaruns_+3A_lapl">lapl</code></td>
<td>

<p>logical; is <code>ts</code> on the Laplace scale already? The default (FALSE) assumes unknown marginal distribution. 
</p>
</td></tr>
<tr><td><code id="thetaruns_+3A_nlag">nlag</code></td>
<td>

<p>the run-length; an integer larger or equal to 1.
</p>
</td></tr>
<tr><td><code id="thetaruns_+3A_u.mar">u.mar</code></td>
<td>

<p>marginal threshold (probability); used when transforming the time series to Laplace scale if <code>lapl</code> is FALSE; if <code>lapl</code> is TRUE, it is nevertheless used when bootstrapping, since the bootstrapped series generally do not have Laplace marginal distributions.
</p>
</td></tr>
<tr><td><code id="thetaruns_+3A_probs">probs</code></td>
<td>

<p>vector of probabilities; the values of <code class="reqn">x</code> for which to evaluate <code class="reqn">\theta(x,m)</code>.
</p>
</td></tr>
<tr><td><code id="thetaruns_+3A_method.mar">method.mar</code></td>
<td>

<p>a character string defining the method used to estimate the marginal GPD; either <code>"mle"</code> for maximum likelihood or <code>"mom"</code> for method of moments or <code>"pwm"</code> for probability weighted moments methods. Defaults to <code>"mle"</code>.
</p>
</td></tr>
<tr><td><code id="thetaruns_+3A_block.length">block.length</code></td>
<td>

<p>integer; the block length used for the block-bootstrapped confidence intervals.
</p>
</td></tr>
<tr><td><code id="thetaruns_+3A_r.boot">R.boot</code></td>
<td>

<p>integer; the number of samples used for the block bootstrap.
</p>
</td></tr>
<tr><td><code id="thetaruns_+3A_levels">levels</code></td>
<td>

<p>vector of probabilites; the quantiles of the posterior distribution of the extremal index <code class="reqn">\theta(x,m)</code> to output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a stationary time series <code class="reqn">(X_t)</code>. A characterisation of the extremal index is
</p>
<p style="text-align: center;"><code class="reqn">\theta(x,m) = Pr(X_1\le x,\ldots,X_m\le x \mid X_0\ge x).</code>
</p>

<p>In the limit when <code class="reqn">x</code> and <code class="reqn">m</code> tend to <code class="reqn">\infty</code> appropriately, <code class="reqn">\theta</code> corresponds to the asymptotic inverse mean cluster size. It also links the generalised extreme value distribution of the independent series <code class="reqn">(Y_t)</code>, with the same marginal distribution as <code class="reqn">(X_t)</code>,
</p>
<p style="text-align: center;"><code class="reqn">G_Y(z)=G_X^\theta(z),</code>
</p>

<p>with <code class="reqn">G_X</code> and <code class="reqn">G_Y</code> the extreme value distributions of <code class="reqn">(X_t)</code> and <code class="reqn">(Y_t)</code> respectively.
</p>
<p><code>nlag</code> corresponds to the <em>run-length</em> <code class="reqn">m</code> and <code>probs</code> is a set of values for <code class="reqn">x</code>.
The <em>runs</em> estimator is computed, which consists of counting the proportion of clusters to the number of exceedances of a threshold <code class="reqn">x</code>; two exceedances of the threshold belong to different clusters if there are at least <code class="reqn">m+1</code> non-exceedances inbetween.
</p>


<h3>Value</h3>

<p>An object of class '<code><a href="#topic+depmeasure">depmeasure</a></code>' containing:
</p>
<table role = "presentation">
<tr><td><code>theta</code></td>
<td>
<p>matrix; estimates of the extremal index <code class="reqn">\theta(x,m)</code> with rows corresponding to the <code>probs</code> values of <code class="reqn">x</code> and the columns to the runs estimate and the chosen <code>levels</code>-quantiles of the bootstrap distribution.</p>
</td></tr>
<tr><td><code>nbr.exc</code></td>
<td>
<p>numeric vector; number of exceedances for each threshold corresponding to the elements in <code>probs</code>.</p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p><code>probs</code>.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>numeric vector; <code>probs</code> converted to the original scale of <code>ts</code>.</p>
</td></tr>
<tr><td><code>nlag</code></td>
<td>
<p><code>nlag</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+theta2fit">theta2fit</a></code>, <code><a href="#topic+thetafit">thetafit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data from an AR(1)
## with Gaussian marginal distribution
n   &lt;- 10000
dep &lt;- 0.5
ar    &lt;- numeric(n)
ar[1] &lt;- rnorm(1)
for(i in 2:n)
  ar[i] &lt;- rnorm(1, mean=dep*ar[i-1], sd=1-dep^2)
## transform to Laplace scale
ar &lt;- qlapl(pnorm(ar))
## compute empirical estimate
theta &lt;- thetaruns(ts=ar, u.mar=.95, probs=c(.95,.98,.99))
## output
plot(theta, ylim=c(.2,1))
abline(h=1, lty="dotted")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
