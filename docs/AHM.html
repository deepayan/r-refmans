<!DOCTYPE html><html lang="en"><head><title>Help for package AHM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AHM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ahm'><p>This is one of the main functions. The function ahm computes the proposed additive heredity model.</p></a></li>
<li><a href='#check_col_correlation'><p>Check column correlations</p></a></li>
<li><a href='#coating'><p>Photoresist-coating experiment data</p></a></li>
<li><a href='#coef.ahm'><p>Coefficient method for the fitted ahm object</p></a></li>
<li><a href='#coef.cv.ahm'><p>Coefficient method for the fitted cv.ahm object</p></a></li>
<li><a href='#compute_aicc'><p>compute AICc</p></a></li>
<li><a href='#cv.ahm'><p>This is one of the main functions. It perform the cross validation on ahm models to select the optimal setting of hyper parameter h</p></a></li>
<li><a href='#design_simplex_centroid_design_3_major_component'><p>Design points for the simplex centroid design with 3 components</p></a></li>
<li><a href='#enlist'><p>Create a list</p></a></li>
<li><a href='#expand_interactions'><p>Expand the interaction terms for each subset group, say x11, x12, or c1, c2, c3</p></a></li>
<li><a href='#find_condition_num'><p>Compute the conditional number of design matrix</p></a></li>
<li><a href='#mapping_function'><p>Mapping_function is a function to add the functional coefficients of major components in front of minor components terms</p></a></li>
<li><a href='#mymaximin'><p>The mymaximin function generates the matrix of maximin design points.</p>
It uses the simplex centroid design as the base design, then in a stochastics way sample the candidate design points generated by the function partition.</a></li>
<li><a href='#predict.ahm'><p>Predict method for the fitted ahm object</p></a></li>
<li><a href='#predict.cv.ahm'><p>Predict method for the fitted cv.ahm object</p></a></li>
<li><a href='#pringles_candidates2search'><p>The candidate search points in the nonlinear optimization for the optimal value</p>
in the Pringles experiment</a></li>
<li><a href='#pringles_fat'><p>Pringles experiment data set with the percent of Fat as the response</p></a></li>
<li><a href='#pringles_hardness'><p>Pringles experiment data set with the Hardness as the response</p></a></li>
<li><a href='#summary.ahm'><p>Summary method for the fitted ahm object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Additive Heredity Model: Method for the Mixture-of-Mixtures
Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sumin Shen &lt;sumin@vt.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the additive heredity model for the mixture-of-mixtures experiments of Shen et al. (2019) in Technometrics &lt;<a href="https://doi.org/10.1080%2F00401706.2019.1630010">doi:10.1080/00401706.2019.1630010</a>&gt;. The additive heredity model considers an additive structure to inherently connect the major components with the minor components. The additive heredity model has a meaningful interpretation for the estimated model because of the hierarchical and heredity principles applied and the nonnegative garrote technique used for variable selection. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>mixexp, plgp, devtools, dplyr, tibble, tidyr, Matrix</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), quadprog, glmnet</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, partitions</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-07-25 12:10:43 UTC; shen</td>
</tr>
<tr>
<td>Author:</td>
<td>Sumin Shen [aut, cre],
  Lulu Kang [aut],
  Xinwei Deng [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-07-28 09:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ahm'>This is one of the main functions. The function ahm computes the proposed additive heredity model.</h2><span id='topic+ahm'></span>

<h3>Description</h3>

<p>This is one of the main functions. The function ahm computes the proposed additive heredity model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahm(y, x, num_major = 3, dist_minor = c(2, 2, 1), type = "weak",
  alpha = 0, lambda_seq = seq(0, 5, 0.01), nfolds = NULL,
  mapping_type = c("power"), powerh = 0, rep_gcv = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ahm_+3A_y">y</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="ahm_+3A_x">x</code></td>
<td>
<p>data.frame Note the column names of the x should be in the order of major components, minor components, and no interactions are needed.</p>
</td></tr>
<tr><td><code id="ahm_+3A_num_major">num_major</code></td>
<td>
<p>number of major components</p>
</td></tr>
<tr><td><code id="ahm_+3A_dist_minor">dist_minor</code></td>
<td>
<p>the allocation of number of minor components nested under major components</p>
</td></tr>
<tr><td><code id="ahm_+3A_type">type</code></td>
<td>
<p>heredity type, weak heredity is the current support type</p>
</td></tr>
<tr><td><code id="ahm_+3A_alpha">alpha</code></td>
<td>
<p>0 is for the ridge in glmnet https://web.stanford.edu/~hastie/glmnet/glmnet_alpha.html</p>
</td></tr>
<tr><td><code id="ahm_+3A_lambda_seq">lambda_seq</code></td>
<td>
<p>a numeric vector for the options of lambda used in ridge regression for estimating the initials</p>
</td></tr>
<tr><td><code id="ahm_+3A_nfolds">nfolds</code></td>
<td>
<p>used in cv.glmnet for initial value of parameters in the non-negative garrote method</p>
</td></tr>
<tr><td><code id="ahm_+3A_mapping_type">mapping_type</code></td>
<td>
<p>the form of the coefficient function of major components in front of corresponding minor terms. Currently only support &quot;power&quot;</p>
</td></tr>
<tr><td><code id="ahm_+3A_powerh">powerh</code></td>
<td>
<p>the power parameter used for the power function</p>
</td></tr>
<tr><td><code id="ahm_+3A_rep_gcv">rep_gcv</code></td>
<td>
<p>the number of choices of tuning parameter used in the GCV selection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pringles_fat")
data_fat = pringles_fat
h_tmp = 1.3
x = data_fat[,c("c1","c2","c3","x11","x12","x21","x22")]
y = data_fat[,1]
out = ahm (y, x, num_major = 3, dist_minor = c(2,2,1),
           type = "weak", alpha=0, lambda_seq=seq(0,5,0.01), nfold = NULL,
           mapping_type = c("power"), powerh = h_tmp,
           rep_gcv=100)
summary(out)
</code></pre>

<hr>
<h2 id='check_col_correlation'>Check column correlations</h2><span id='topic+check_col_correlation'></span>

<h3>Description</h3>

<p>Check column correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_col_correlation(dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_col_correlation_+3A_dat">dat</code></td>
<td>
<p>data.frame</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("pringles_fat")
data_fat = pringles_fat
h_tmp = 1.3
x = data_fat[,c("c1","c2","c3","x11","x12","x21","x22")]
check_col_correlation (dat=x)
</code></pre>

<hr>
<h2 id='coating'>Photoresist-coating experiment data</h2><span id='topic+coating'></span>

<h3>Description</h3>

<p>Photoresist-coating experiment data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coating)
</code></pre>


<h3>Format</h3>

<p>data.frame</p>


<h3>References</h3>

<p>Cornell, J.A. and Ramsey, P.J. (1998). A Generalized mixture model for
categorized-components problems with an application to a
photoresist-coating experiment. <em>Technometrics</em>, 40(1), 48-61.
(<a href="https://www.tandfonline.com/doi/abs/10.1080/00401706.1998.10485481">tandfonline</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coating)
print(coating)
</code></pre>

<hr>
<h2 id='coef.ahm'>Coefficient method for the fitted ahm object</h2><span id='topic+coef.ahm'></span>

<h3>Description</h3>

<p>Coefficient method for the fitted ahm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ahm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.ahm_+3A_object">object</code></td>
<td>
<p>ahm object</p>
</td></tr>
<tr><td><code id="coef.ahm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pringles_fat")
data_fat = pringles_fat
h_tmp = 1.3
x = data_fat[,c("c1","c2","c3","x11","x12","x21","x22")]
y = data_fat[,1]
out = ahm (y, x, num_major = 3, dist_minor = c(2,2,1),
           type = "weak", alpha=0, lambda_seq=seq(0,5,0.01), nfold = NULL,
           mapping_type = c("power"), powerh = h_tmp,
           rep_gcv=100)
coef(out)

</code></pre>

<hr>
<h2 id='coef.cv.ahm'>Coefficient method for the fitted cv.ahm object</h2><span id='topic+coef.cv.ahm'></span>

<h3>Description</h3>

<p>Coefficient method for the fitted cv.ahm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.ahm'
coef(object, metric = "mse", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.cv.ahm_+3A_object">object</code></td>
<td>
<p>cv.ahm object</p>
</td></tr>
<tr><td><code id="coef.cv.ahm_+3A_metric">metric</code></td>
<td>
<p>&quot;mse&quot; or &quot;aicc&quot;</p>
</td></tr>
<tr><td><code id="coef.cv.ahm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("pringles_fat")
data_fat = pringles_fat
h_tmp = 1.3
x = data_fat[,c("c1","c2","c3","x11","x12","x21","x22")]
y = data_fat[,1]
powerh_path = round(seq(0.001,2,length.out =15),3)
num_major = 3; dist_minor = c(2,2,1)
res = cv.ahm (y, x, powerh_path=powerh_path, metric = "mse", num_major, dist_minor, type = "weak"
, alpha=0, lambda_seq=seq(0,5,0.01), nfolds=NULL, mapping_type = c("power"), rep_gcv=100)
coefficients = coef(res)


</code></pre>

<hr>
<h2 id='compute_aicc'>compute AICc</h2><span id='topic+compute_aicc'></span>

<h3>Description</h3>

<p>compute AICc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_aicc(rss, n, p, type = "AICc")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_aicc_+3A_rss">rss</code></td>
<td>
<p>residual sum of squares</p>
</td></tr>
<tr><td><code id="compute_aicc_+3A_n">n</code></td>
<td>
<p>number of observation</p>
</td></tr>
<tr><td><code id="compute_aicc_+3A_p">p</code></td>
<td>
<p>number of nonzero parameters</p>
</td></tr>
<tr><td><code id="compute_aicc_+3A_type">type</code></td>
<td>
<p>character &quot;AICc&quot;</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://stats.stackexchange.com/questions/87345/calculating-aic-by-hand-in-r/">Calculating AIC “by hand” in R in Stack Overflow</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_aicc (rss=10, n=30, p=6, type = "AICc")
</code></pre>

<hr>
<h2 id='cv.ahm'>This is one of the main functions. It perform the cross validation on ahm models to select the optimal setting of hyper parameter h</h2><span id='topic+cv.ahm'></span>

<h3>Description</h3>

<p>This is one of the main functions. It perform the cross validation on ahm models to select the optimal setting of hyper parameter h
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.ahm(y, x, powerh_path = NULL, metric = c("mse", "AICc"), num_major = 3,
  dist_minor = c(2, 2, 1), type = "weak", alpha = 0, lambda_seq = seq(0,
  5, 0.01), nfolds = NULL, mapping_type = c("power"), rep_gcv = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.ahm_+3A_y">y</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="cv.ahm_+3A_x">x</code></td>
<td>
<p>data.frame Note the column names of the x should be in the order of major components, minor components, and no interactions between major or minor components are needed.</p>
</td></tr>
<tr><td><code id="cv.ahm_+3A_powerh_path">powerh_path</code></td>
<td>
<p>if NULL, then the default is the vector: round(seq(0.001,2,length.out =15),3)</p>
</td></tr>
<tr><td><code id="cv.ahm_+3A_metric">metric</code></td>
<td>
<p>&quot;mse&quot; or &quot;AICc&quot; the metric used in cross validtion where the minimum is selected as the optimal</p>
</td></tr>
<tr><td><code id="cv.ahm_+3A_num_major">num_major</code></td>
<td>
<p>number of major components</p>
</td></tr>
<tr><td><code id="cv.ahm_+3A_dist_minor">dist_minor</code></td>
<td>
<p>the allocation of number of minor components nested under major components</p>
</td></tr>
<tr><td><code id="cv.ahm_+3A_type">type</code></td>
<td>
<p>heredity type, weak heredity is the current support type</p>
</td></tr>
<tr><td><code id="cv.ahm_+3A_alpha">alpha</code></td>
<td>
<p>0 is for the ridge in glmnet https://web.stanford.edu/~hastie/glmnet/glmnet_alpha.html</p>
</td></tr>
<tr><td><code id="cv.ahm_+3A_lambda_seq">lambda_seq</code></td>
<td>
<p>a numeric vector for the options of lambda used in ridge regression for estimating the initials</p>
</td></tr>
<tr><td><code id="cv.ahm_+3A_nfolds">nfolds</code></td>
<td>
<p>used in cv.glmnet for initial value of parameters in the non-negative garrote method</p>
</td></tr>
<tr><td><code id="cv.ahm_+3A_mapping_type">mapping_type</code></td>
<td>
<p>the form of the coefficient function of major components in front of corresponding minor terms. Currently only support &quot;power&quot;</p>
</td></tr>
<tr><td><code id="cv.ahm_+3A_rep_gcv">rep_gcv</code></td>
<td>
<p>the number of choices of tuning parameter used in the GCV selection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("pringles_fat")
data_fat = pringles_fat
h_tmp = 1.3
x = data_fat[,c("c1","c2","c3","x11","x12","x21","x22")]
y = data_fat[,1]
powerh_path = round(seq(0.001,2,length.out =15),3)
num_major = 3; dist_minor = c(2,2,1)
res = cv.ahm (y, x, powerh_path=powerh_path, metric = "mse", num_major, dist_minor, type = "weak"
, alpha=0, lambda_seq=seq(0,5,0.01), nfolds=NULL, mapping_type = c("power"), rep_gcv=100)
object = res$metric_mse

</code></pre>

<hr>
<h2 id='design_simplex_centroid_design_3_major_component'>Design points for the simplex centroid design with 3 components</h2><span id='topic+design_simplex_centroid_design_3_major_component'></span>

<h3>Description</h3>

<p>Design points for the simplex centroid design with 3 components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(design_simplex_centroid_design_3_major_component)
</code></pre>


<h3>Format</h3>

<p>data.frame</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(design_simplex_centroid_design_3_major_component)
print(design_simplex_centroid_design_3_major_component)
</code></pre>

<hr>
<h2 id='enlist'>Create a list</h2><span id='topic+enlist'></span>

<h3>Description</h3>

<p>Create a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enlist(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enlist_+3A_...">...</code></td>
<td>
<p>object to be included as elements in the list</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>item = c(1:10)
enlist(item)
</code></pre>

<hr>
<h2 id='expand_interactions'>Expand the interaction terms for each subset group, say x11, x12, or c1, c2, c3</h2><span id='topic+expand_interactions'></span>

<h3>Description</h3>

<p>Expand the interaction terms for each subset group, say x11, x12, or c1, c2, c3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_interactions(dat, sel_names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_interactions_+3A_dat">dat</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="expand_interactions_+3A_sel_names">sel_names</code></td>
<td>
<p>characters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("pringles_fat")
data_fat = pringles_fat
h_tmp = 1.3
x = data_fat[,c("c1","c2","c3","x11","x12","x21","x22")]
expand_interactions (dat=x, sel_names=c("c1", "c2", "c3"))
</code></pre>

<hr>
<h2 id='find_condition_num'>Compute the conditional number of design matrix</h2><span id='topic+find_condition_num'></span>

<h3>Description</h3>

<p>Compute the conditional number of design matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_condition_num(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_condition_num_+3A_x">x</code></td>
<td>
<p>matrix to be used in svd</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("pringles_fat")
data_fat = pringles_fat
h_tmp = 1.3
x = data_fat[,c("c1","c2","c3","x11","x12","x21","x22")]
find_condition_num (x)
</code></pre>

<hr>
<h2 id='mapping_function'>Mapping_function is a function to add the functional coefficients of major components in front of minor components terms</h2><span id='topic+mapping_function'></span>

<h3>Description</h3>

<p>Mapping_function is a function to add the functional coefficients of major components in front of minor components terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapping_function(x, num_major = 3, dist_minor = C(2, 2, 1),
  mapping_type = c("power"), powerh = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapping_function_+3A_x">x</code></td>
<td>
<p>data.frame Note the column names of the x should be in the order of major components, minor components, and no interactions are needed.</p>
</td></tr>
<tr><td><code id="mapping_function_+3A_num_major">num_major</code></td>
<td>
<p>number of major components</p>
</td></tr>
<tr><td><code id="mapping_function_+3A_dist_minor">dist_minor</code></td>
<td>
<p>the allocation of number of minor components nested under major components</p>
</td></tr>
<tr><td><code id="mapping_function_+3A_mapping_type">mapping_type</code></td>
<td>
<p>the form of the coefficient function of major components in front of corresponding minor terms. Currently only support &quot;power&quot;</p>
</td></tr>
<tr><td><code id="mapping_function_+3A_powerh">powerh</code></td>
<td>
<p>the power parameter used for the power function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pringles_fat")
data_fat = pringles_fat
h_tmp = 1.3
x = data_fat[,c("c1","c2","c3","x11","x12","x21","x22")]
mapping_function(x=x, num_major=3, dist_minor=c(2,2,1), mapping_type = c("power"), powerh=0)
</code></pre>

<hr>
<h2 id='mymaximin'>The mymaximin function generates the matrix of maximin design points.
It uses the simplex centroid design as the base design, then in a stochastics way sample the candidate design points generated by the function partition.</h2><span id='topic+mymaximin'></span>

<h3>Description</h3>

<p>This method is modified based on Prof. Bobby Gramacy's Computer Experiment lecture at Virginia Tech. <a href="http://bobby.gramacy.com/teaching/">Prof. Gramacy's lecture website</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mymaximin(pool, n = 50, m = 3, iter = 1e+05, Xorig = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mymaximin_+3A_pool">pool</code></td>
<td>
<p>partition the base design points provided to the function</p>
</td></tr>
<tr><td><code id="mymaximin_+3A_n">n</code></td>
<td>
<p>numeric, sample size</p>
</td></tr>
<tr><td><code id="mymaximin_+3A_m">m</code></td>
<td>
<p>numeric, 3 stands for 3 components, i.e. c1, c2, and c3</p>
</td></tr>
<tr><td><code id="mymaximin_+3A_iter">iter</code></td>
<td>
<p>numeric, iterations used in the stochastic sampling</p>
</td></tr>
<tr><td><code id="mymaximin_+3A_xorig">Xorig</code></td>
<td>
<p>matrix, initial design points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a matrixt of the design points for the major components
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The case of unconstrainted experiments
library(mixexp)
num_size = 8 # num points in the design for the major component
Xorig = as.matrix(SCD(3))
# all possible combinations sum to 1
pool_3d =partitions::compositions(1000, 3,include.zero = TRUE)/1000
res_C = mymaximin(pool=pool_3d, n=num_size, m=3, iter=1e5, Xorig=Xorig)
DesignPoints(res_C,cornerlabs = c("c3","c2","c1"),axislabs=c("c1","c2","c3"))

# The case of constrainted experiments
library(mixexp)
num_size = 8 # num points in the design for the major component
# all possible combinations sum to 1
pool_3d =partitions::compositions(1000, 3,include.zero = TRUE)/1000
c1_min=0.2
c1_max=0.45
c2_min=0.4
c2_max=0.6
c3_min=0.1
c3_max=0.25
tmp = Xvert(nfac=3,lc=c(c1_min,c2_min,c3_min),uc =c(c1_max,c2_max,c3_max),ndm=1,pseudo=FALSE)
Xorig=tmp[c(1:6,13),c(1:3)]
colnames(Xorig)=c("V1","V2","V3")
pool_3d = t(dplyr::filter(as.data.frame(t(as.matrix(pool_3d))),t(pool_3d)[,1] &gt; c1_min &amp;
                     t(pool_3d)[,1] &lt;= c1_max &amp;
                     t(pool_3d)[,2] &gt; c2_min &amp;
                     t(pool_3d)[,2] &lt;= c2_max &amp;
                     t(pool_3d)[,3] &gt; c3_min &amp;
                     t(pool_3d)[,3] &lt;= c3_max
)
)
res_C = mymaximin(pool=pool_3d, n=num_size, m=3, iter=1e5, Xorig=Xorig)
DesignPoints(res_C,cornerlabs = c("c3","c2","c1"),axislabs=c("c1","c2","c3")
                     ,x1lower=c1_min,x2lower=c2_min,x3lower=c3_min
                     ,x1upper=c1_max,x2upper=c2_max,x3upper=c3_max, pseudo=FALSE)

</code></pre>

<hr>
<h2 id='predict.ahm'>Predict method for the fitted ahm object</h2><span id='topic+predict.ahm'></span>

<h3>Description</h3>

<p>Predict method for the fitted ahm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ahm'
predict(object, newx, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ahm_+3A_object">object</code></td>
<td>
<p>ahm object</p>
</td></tr>
<tr><td><code id="predict.ahm_+3A_newx">newx</code></td>
<td>
<p>Matrix of new values for x at which predictions are to be made.</p>
</td></tr>
<tr><td><code id="predict.ahm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predicted value(s) at newx
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pringles_fat")
data_fat = pringles_fat
h_tmp = 1.3
x = data_fat[,c("c1","c2","c3","x11","x12","x21","x22")]
y = data_fat[,1]
out = ahm (y, x, num_major = 3, dist_minor = c(2,2,1),
           type = "weak", alpha=0, lambda_seq=seq(0,5,0.01), nfold = NULL,
           mapping_type = c("power"), powerh = h_tmp,
           rep_gcv=100)
predict(out)

</code></pre>

<hr>
<h2 id='predict.cv.ahm'>Predict method for the fitted cv.ahm object</h2><span id='topic+predict.cv.ahm'></span>

<h3>Description</h3>

<p>Predict method for the fitted cv.ahm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.ahm'
predict(object, newx, metric = "mse", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cv.ahm_+3A_object">object</code></td>
<td>
<p>cv.ahm object</p>
</td></tr>
<tr><td><code id="predict.cv.ahm_+3A_newx">newx</code></td>
<td>
<p>Matrix of new values for x at which predictions are to be made.</p>
</td></tr>
<tr><td><code id="predict.cv.ahm_+3A_metric">metric</code></td>
<td>
<p>&quot;mse&quot; or &quot;aicc&quot;</p>
</td></tr>
<tr><td><code id="predict.cv.ahm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("pringles_fat")
data_fat = pringles_fat
h_tmp = 1.3
x = data_fat[,c("c1","c2","c3","x11","x12","x21","x22")]
y = data_fat[,1]
powerh_path = round(seq(0.001,2,length.out =15),3)
num_major = 3; dist_minor = c(2,2,1)
res = cv.ahm (y, x, powerh_path=powerh_path, metric = "mse", num_major, dist_minor, type = "weak"
, alpha=0, lambda_seq=seq(0,5,0.01), nfolds=NULL, mapping_type = c("power"), rep_gcv=100)
pred = predict(res)


</code></pre>

<hr>
<h2 id='pringles_candidates2search'>The candidate search points in the nonlinear optimization for the optimal value
in the Pringles experiment</h2><span id='topic+pringles_candidates2search'></span>

<h3>Description</h3>

<p>The candidate search points in the nonlinear optimization for the optimal value
in the Pringles experiment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pringles_candidates2search)
</code></pre>


<h3>Format</h3>

<p>matrix</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pringles_candidates2search)
print(pringles_candidates2search)
</code></pre>

<hr>
<h2 id='pringles_fat'>Pringles experiment data set with the percent of Fat as the response</h2><span id='topic+pringles_fat'></span>

<h3>Description</h3>

<p>Pringles experiment data set with the percent of Fat as the response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pringles_fat)
</code></pre>


<h3>Format</h3>

<p>data.frame</p>


<h3>References</h3>

<p>Kang, L., Joseph, V.R. and Brenneman, W.A. (2011). Design and modeling
strategies for mixture-of-mixtures experiments. <em>Technometrics</em>,
53(2), 125&ndash;36.
(<a href="https://www.tandfonline.com/doi/abs/10.1198/TECH.2011.08132">tandfonline</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pringles_fat)
print(pringles_fat)
</code></pre>

<hr>
<h2 id='pringles_hardness'>Pringles experiment data set with the Hardness as the response</h2><span id='topic+pringles_hardness'></span>

<h3>Description</h3>

<p>Pringles experiment data set with the Hardness as the response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pringles_hardness)
</code></pre>


<h3>Format</h3>

<p>data.frame</p>


<h3>References</h3>

<p>Kang, L., Joseph, V.R. and Brenneman, W.A. (2011). Design and modeling
strategies for mixture-of-mixtures experiments. <em>Technometrics</em>,
53(2), 125&ndash;36.
(<a href="https://www.tandfonline.com/doi/abs/10.1198/TECH.2011.08132">tandfonline</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pringles_hardness)
print(pringles_hardness)
</code></pre>

<hr>
<h2 id='summary.ahm'>Summary method for the fitted ahm object</h2><span id='topic+summary.ahm'></span>

<h3>Description</h3>

<p>Summary method for the fitted ahm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ahm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ahm_+3A_object">object</code></td>
<td>
<p>fitted ahm object</p>
</td></tr>
<tr><td><code id="summary.ahm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("pringles_fat")
data_fat = pringles_fat
h_tmp = 1.3
x = data_fat[,c("c1","c2","c3","x11","x12","x21","x22")]
y = data_fat[,1]
out = ahm (y, x, num_major = 3, dist_minor = c(2,2,1),
           type = "weak", alpha=0, lambda_seq=seq(0,5,0.01), nfold = NULL,
           mapping_type = c("power"), powerh = h_tmp,
           rep_gcv=100)
summary(out)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
